--- makefile-old	2012-02-16 10:47:18.000000000 +0100
+++ makefile	2012-02-23 15:19:37.000000000 +0100
@@ -591,8 +591,6 @@
 EMUINFOOBJ = $(OBJ)/$(TARGET)/$(TARGET).o
 DRIVLISTSRC = $(OBJ)/$(TARGET)/$(SUBTARGET)/drivlist.c
 DRIVLISTOBJ = $(OBJ)/$(TARGET)/$(SUBTARGET)/drivlist.o
-DEVLISTSRC = $(OBJ)/$(TARGET)/$(SUBTARGET)/devlist.c
-DEVLISTOBJ = $(OBJ)/$(TARGET)/$(SUBTARGET)/devlist.o
 
 
 
@@ -733,7 +731,7 @@
 
 ifndef EXECUTABLE_DEFINED
 
-$(EMULATOR): $(VERSIONOBJ) $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DEVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(7Z_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
+$(EMULATOR): $(VERSIONOBJ) $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(7Z_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
 	$(CC) $(CDEFS) $(CFLAGS) -c $(SRC)/version.c -o $(VERSIONOBJ)
 	@echo Linking $@...
 	$(LD) $(LDFLAGS) $(LDFLAGSEMULATOR) $^ $(LIBS) -o $@
@@ -776,18 +774,10 @@
 	@echo Compiling $<...
 	$(CC) $(CDEFS) $(CFLAGS) -c $< -o $@
 
-$(DEVLISTOBJ): $(DEVLISTSRC)
-	@echo Compiling $<...
-	$(CC) $(CDEFS) $(CFLAGS) -c $< -o $@
-
 $(DRIVLISTSRC): $(SRC)/$(TARGET)/$(SUBTARGET).lst $(MAKELIST_TARGET)
 	@echo Building driver list $<...
 	@$(MAKELIST) $< >$@
 
-$(DEVLISTSRC): $(SRC)/$(TARGET)/$(SUBTARGET)_dev.lst $(MAKEDEV_TARGET)
-	@echo Building device list $<...
-	@$(MAKEDEV) $< >$@
-
 $(OBJ)/%.a:
 	@echo Archiving $@...
 	$(RM) $@
diff -Nru src-old/build/build.mak src/build/build.mak
--- src-old/build/build.mak	2011-08-02 16:09:21.000000000 +0200
+++ src/build/build.mak	2012-02-23 15:19:37.000000000 +0100
@@ -21,7 +21,6 @@
 FILE2STR_TARGET = $(BUILDOUT)/file2str$(BUILD_EXE)
 MAKEDEP_TARGET = $(BUILDOUT)/makedep$(BUILD_EXE)
 MAKELIST_TARGET = $(BUILDOUT)/makelist$(BUILD_EXE)
-MAKEDEV_TARGET = $(BUILDOUT)/makedev$(BUILD_EXE)
 PNG2BDC_TARGET = $(BUILDOUT)/png2bdc$(BUILD_EXE)
 VERINFO_TARGET = $(BUILDOUT)/verinfo$(BUILD_EXE)
 
@@ -29,14 +28,12 @@
 FILE2STR = $(subst /,\,$(FILE2STR_TARGET))
 MAKEDEP = $(subst /,\,$(MAKEDEP_TARGET))
 MAKELIST = $(subst /,\,$(MAKELIST_TARGET))
-MAKEDEV = $(subst /,\,$(MAKEDEV_TARGET))
 PNG2BDC = $(subst /,\,$(PNG2BDC_TARGET))
 VERINFO = $(subst /,\,$(VERINFO_TARGET))
 else
 FILE2STR = $(FILE2STR_TARGET)
 MAKEDEP = $(MAKEDEP_TARGET)
 MAKELIST = $(MAKELIST_TARGET)
-MAKEDEV = $(MAKEDEV_TARGET)
 PNG2BDC = $(PNG2BDC_TARGET)
 VERINFO = $(VERINFO_TARGET)
 endif
@@ -46,7 +43,6 @@
 	$(FILE2STR_TARGET) \
 	$(MAKEDEP_TARGET) \
 	$(MAKELIST_TARGET) \
-	$(MAKEDEV_TARGET) \
 	$(PNG2BDC_TARGET) \
 	$(VERINFO_TARGET) \
 
@@ -92,19 +88,6 @@
 
 
 #-------------------------------------------------
-# makedev
-#-------------------------------------------------
-
-MAKEDEVOBJS = \
-	$(BUILDOBJ)/makedev.o \
-
-$(MAKEDEV_TARGET): $(MAKEDEVOBJS) $(LIBUTIL) $(LIBOCORE) $(ZLIB)
-	@echo Linking $@...
-	$(LD) $(LDFLAGS) $^ $(LIBS) -o $@
-
-
-
-#-------------------------------------------------
 # png2bdc
 #-------------------------------------------------
 
diff -Nru src-old/build/makedev.c src/build/makedev.c
--- src-old/build/makedev.c	2011-11-30 12:51:46.000000000 +0100
+++ src/build/makedev.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,268 +0,0 @@
-/***************************************************************************
-
-    makedev.c
-
-    Create and sort the driver list.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include "corefile.h"
-
-
-#define MAX_DEVICES 65536
-#define MAX_IGNORE  512
-
-static const char *devlist[MAX_DEVICES];
-static int devcount;
-static const char *ignorelst[MAX_IGNORE];
-static int ignorecount;
-
-
-//-------------------------------------------------
-//  driver_sort_callback - compare two items in
-//  a string array
-//-------------------------------------------------
-
-int sort_callback(const void *elem1, const void *elem2)
-{
-	const char **item1 = (const char **)elem1;
-	const char **item2 = (const char **)elem2;
-	return strcmp(*item1, *item2);
-}
-
-//-------------------------------------------------
-//  isignored - return info if item is in ignore
-//  list or not
-//-------------------------------------------------
-
-bool isignored(const char *drivname)
-{
-	if (ignorecount>0) {
-		for(int i=0;i<ignorecount;i++) {
-			if (strcmp(ignorelst[i],drivname)==0) return true;
-		}
-	}
-	return false;
-}
-
-//-------------------------------------------------
-//  parse_file - parse a single file, may be
-//  called recursively
-//-------------------------------------------------
-
-int parse_file(const char *srcfile)
-{
-	// read source file
-	void *buffer;
-	UINT32 length;
-	file_error filerr = core_fload(srcfile, &buffer, &length);
-	if (filerr != FILERR_NONE)
-	{
-		fprintf(stderr, "Unable to read source file '%s'\n", srcfile);
-		return 1;
-	}
-
-	// rip through it to find all drivers
-	char *srcptr = (char *)buffer;
-	char *endptr = srcptr + length;
-	int linenum = 1;
-	bool in_comment = false;
-	while (srcptr < endptr)
-	{
-		char c = *srcptr++;
-
-		// count newlines
-		if (c == 13 || c == 10)
-		{
-			if (c == 13 && *srcptr == 10)
-				srcptr++;
-			linenum++;
-			continue;
-		}
-
-		// skip any spaces
-		if (isspace(c))
-			continue;
-
-		// look for end of C comment
-		if (in_comment && c == '*' && *srcptr == '/')
-		{
-			srcptr++;
-			in_comment = false;
-			continue;
-		}
-
-		// skip anything else inside a C comment
-		if (in_comment)
-			continue;
-
-		// look for start of C comment
-		if (c == '/' && *srcptr == '*')
-		{
-			srcptr++;
-			in_comment = true;
-			continue;
-		}
-
-		// if we hit a C++ comment, scan to the end of line
-		if (c == '/' && *srcptr == '/')
-		{
-			while (srcptr < endptr && *srcptr != 13 && *srcptr != 10)
-				srcptr++;
-			continue;
-		}
-
-		// look for an import directive
-		if (c == '#')
-		{
-			char filename[256];
-			filename[0] = 0;
-			for (int pos = 0; srcptr < endptr && pos < ARRAY_LENGTH(filename) - 1 && !isspace(*srcptr); pos++)
-			{
-				filename[pos] = *srcptr++;
-				filename[pos+1] = 0;
-			}
-			fprintf(stderr, "Importing devices from '%s'\n", filename);
-			parse_file(filename);
-			continue;
-		}
-		if (c == '!')
-		{
-			char drivname[256];
-			drivname[0] = 0;
-			for (int pos = 0; srcptr < endptr && pos < ARRAY_LENGTH(drivname) - 1 && !isspace(*srcptr); pos++)
-			{
-				drivname[pos] = *srcptr++;
-				drivname[pos+1] = 0;
-			}
-			fprintf(stderr, "Place device '%s' to ignore list\n", drivname);
-			char *name = (char *)malloc(strlen(drivname) + 1);
-			strcpy(name, drivname);
-			ignorelst[ignorecount++] = name;
-			continue;
-		}
-
-		// otherwise treat as a device name
-		char drivname[32];
-		drivname[0] = 0;
-		srcptr--;
-		for (int pos = 0; srcptr < endptr && pos < ARRAY_LENGTH(drivname) - 1 && !isspace(*srcptr); pos++)
-		{
-			drivname[pos] = *srcptr++;
-			drivname[pos+1] = 0;
-		}
-
-		// verify the name as valid
-		for (char *drivch = drivname; *drivch != 0; drivch++)
-		{
-			if ((*drivch >= 'A' && *drivch <= 'Z') || (*drivch >= '0' && *drivch <= '9') || *drivch == '_')
-				continue;
-			fprintf(stderr, "%s:%d - Invalid character '%c' in device type \"%s\"\n", srcfile, linenum, *drivch, drivname);
-			return 1;
-		}
-
-		// add it to the list
-		if(!isignored(drivname))
-		{
-			char *name = (char *)malloc(strlen(drivname) + 1);
-			strcpy(name, drivname);
-			devlist[devcount++] = name;
-		}
-	}
-
-	osd_free(buffer);
-
-	return 0;
-}
-
-
-//-------------------------------------------------
-//  main - primary entry point
-//-------------------------------------------------
-
-int main(int argc, char *argv[])
-{
-	// needs at least 1 argument
-	if (argc < 2)
-	{
-		fprintf(stderr,
-			"Usage:\n"
-			"  makedev <source.lst>\n"
-		);
-		return 0;
-	}
-
-	// extract arguments
-	const char *srcfile = argv[1];
-
-	// parse the root file, exit early upon failure
-	devcount = 0;
-	if (parse_file(srcfile))
-		return 1;
-
-	// output a count
-	if (devcount == 0)
-	{
-		fprintf(stderr, "No devices found\n");
-	} else {
-		fprintf(stderr, "%d devices found\n", devcount);
-	}
-
-	// sort the list
-	qsort(devlist, devcount, sizeof(*devlist), sort_callback);
-
-	// start with a header
-	printf("#include \"emu.h\"\n\n");
-
-	// output the list of externs first
-	for (int index = 0; index < devcount; index++)
-		printf("extern const device_type %s;\n", devlist[index]);
-	printf("\n");
-
-	// then output the array
-	printf("const device_type * s_devices_sorted[] =\n");
-	printf("{\n");
-	for (int index = 0; index < devcount; index++)
-		printf("\t&%s%s\n", devlist[index], (index == devcount - 1) ? "" : ",");
-	printf("};\n");
-	printf("\n");
-
-	// also output a global count
-	printf("int m_device_count = %d;\n", devcount);
-
-	return 0;
-}
diff -Nru src-old/emu/audit.c src/emu/audit.c
--- src-old/emu/audit.c	2012-02-19 02:53:16.000000000 +0100
+++ src/emu/audit.c	2012-02-24 15:22:36.000000000 +0100
@@ -77,42 +77,38 @@
 // all searches
 const char *driverpath = m_enumerator.config().root_device().searchpath();
 
-	// iterate over ROM sources and regions
 	int found = 0;
 	int required = 0;
-	int sharedFound = 0;
-	int sharedRequired = 0;
+	int shared_found = 0;
+	int shared_required = 0;
 
-	for (const rom_source *source = rom_first_source(m_enumerator.config()); source != NULL; source = rom_next_source(*source))
+	// iterate over devices and regions
+	device_iterator deviter(m_enumerator.config().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
 	{
 		// determine the search path for this source and iterate through the regions
-		m_searchpath = source->searchpath();
+		m_searchpath = device->searchpath();
 
 		// now iterate over regions and ROMs within
-		for (const rom_entry *region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+		for (const rom_entry *region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 		{
 // temporary hack: add the driver path & region name
-astring combinedpath(source->searchpath(), ";", driverpath);
-if(source->shortname())
-{
-	combinedpath=combinedpath.cat(";");
-	combinedpath=combinedpath.cat(source->shortname());
-}
+astring combinedpath(device->searchpath(), ";", driverpath);
+if (device->shortname())
+	combinedpath.cat(";").cat(device->shortname());
 m_searchpath = combinedpath;
 
 			for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
 			{
 				hash_collection hashes(ROM_GETHASHDATA(rom));
-				const rom_source *shared_source = find_shared_source(source, hashes, ROM_GETLENGTH(rom));
+				device_t *shared_device = find_shared_device(*device, hashes, ROM_GETLENGTH(rom));
 
 				// count the number of files with hashes
 				if (!hashes.flag(hash_collection::FLAG_NO_DUMP) && !ROM_ISOPTIONAL(rom))
 				{
 					required++;
-					if (shared_source != NULL)
-					{
-						sharedRequired++;
-					}
+					if (shared_device != NULL)
+						shared_required++;
 				}
 
 				// audit a file
@@ -127,31 +123,25 @@
 				if (record != NULL)
 				{
 					// count the number of files that are found.
-					if (record->status() == audit_record::STATUS_GOOD || (record->status() == audit_record::STATUS_FOUND_INVALID && find_shared_source(source, record->actual_hashes(), record->actual_length()) == NULL))
+					if (record->status() == audit_record::STATUS_GOOD || (record->status() == audit_record::STATUS_FOUND_INVALID && find_shared_device(*device, record->actual_hashes(), record->actual_length()) == NULL))
 					{
 						found++;
-						if (shared_source != NULL)
-						{
-							sharedFound++;
-						}
+						if (shared_device != NULL)
+							shared_found++;
 					}
 
-					record->set_shared_source(shared_source);
+					record->set_shared_device(shared_device);
 				}
 			}
 		}
 	}
 
 	// if we only find files that are in the parent & either the set has no unique files or the parent is not found, then assume we don't have the set at all
-	if (found == sharedFound && required > 0 && (required != sharedRequired || sharedFound == 0))
+	if (found == shared_found && required > 0 && (required != shared_required || shared_found == 0))
 	{
 		m_record_list.reset();
 		return NOTFOUND;
 	}
-	else if (found == 0 && m_record_list.count() == 0)
-	{
-		return NONE_NEEDED;
-	}
 
 	// return a summary
 	return summarize(m_enumerator.driver().name);
@@ -209,10 +199,6 @@
 		m_record_list.reset();
 		return NOTFOUND;
 	}
-	else if (found == 0 && m_record_list.count() == 0)
-	{
-		return NONE_NEEDED;
-	}
 
 	// return a summary
 	return summarize(device->shortname());
@@ -279,10 +265,6 @@
 		m_record_list.reset();
 		return NOTFOUND;
 	}
-	else if (found == 0 && m_record_list.count() == 0)
-	{
-		return NONE_NEEDED;
-	}
 
 	// return a summary
 	return summarize(m_enumerator.driver().name);
@@ -296,6 +278,11 @@
 
 media_auditor::summary media_auditor::summarize(const char *name, astring *string)
 {
+	if (m_record_list.count() == 0)
+	{
+		return NONE_NEEDED;
+	}
+
 	// loop over records
 	summary overall_status = CORRECT;
 	for (audit_record *record = m_record_list.first(); record != NULL; record = record->next())
@@ -345,9 +332,11 @@
 			case audit_record::SUBSTATUS_NOT_FOUND:
 				if (string != NULL)
 				{
-					const rom_source *shared_source = record->shared_source();
-					if (shared_source == NULL) string->catprintf("NOT FOUND\n");
-					else string->catprintf("NOT FOUND (%s)\n", shared_source->shortname());
+					device_t *shared_device = record->shared_device();
+					if (shared_device == NULL)
+						string->catprintf("NOT FOUND\n");
+					else
+						string->catprintf("NOT FOUND (%s)\n", shared_device->shortname());
 				}
 				break;
 
@@ -494,43 +483,48 @@
 
 
 //-------------------------------------------------
-//  find_shared_source - return the source that
+//  find_shared_device - return the source that
 //  shares a media entry with the same hashes
 //-------------------------------------------------
-const rom_source *media_auditor::find_shared_source(const rom_source *source, const hash_collection &romhashes, UINT64 romlength)
-{
-	const rom_source *highest_source = NULL;
 
-	if (!romhashes.flag(hash_collection::FLAG_NO_DUMP))
+device_t *media_auditor::find_shared_device(device_t &device, const hash_collection &romhashes, UINT64 romlength)
+{
+	// doesn't apply to NO_DUMP items
+	if (romhashes.flag(hash_collection::FLAG_NO_DUMP))
+		return NULL;
+
+	// special case for non-root devices
+	device_t *highest_device = NULL;
+	if (device.owner() != NULL)
+	{
+		for (const rom_entry *region = rom_first_region(device); region != NULL; region = rom_next_region(region))
+			for (const rom_entry *rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
+				if (ROM_GETLENGTH(rom) == romlength)
+				{
+					hash_collection hashes(ROM_GETHASHDATA(rom));
+					if (hashes == romhashes)
+						highest_device = &device;
+				}
+	}
+	else
 	{
-		if (dynamic_cast<const driver_device *>(source) == NULL)
-		{
-			for (const rom_entry *region = rom_first_region(*source); region; region = rom_next_region(region))
-				for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
-					if (ROM_GETLENGTH(rom) == romlength)
-					{
-						hash_collection hashes(ROM_GETHASHDATA(rom));
-						if (hashes == romhashes)
-							highest_source = source;
-					}
-		}
-		else
+		// iterate up the parent chain
+		for (int drvindex = m_enumerator.find(m_enumerator.driver().parent); drvindex != -1; drvindex = m_enumerator.find(m_enumerator.driver(drvindex).parent))
 		{
-			// iterate up the parent chain
-			for (int drvindex = m_enumerator.find(m_enumerator.driver().parent); drvindex != -1; drvindex = m_enumerator.find(m_enumerator.driver(drvindex).parent))
-				for (const rom_source *source = rom_first_source(m_enumerator.config(drvindex)); source != NULL; source = rom_next_source(*source))
-					for (const rom_entry *region = rom_first_region(*source); region; region = rom_next_region(region))
-						for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
-							if (ROM_GETLENGTH(rom) == romlength)
-							{
-								hash_collection hashes(ROM_GETHASHDATA(rom));
-								if (hashes == romhashes)
-									highest_source = source;
-							}
+			device_iterator deviter(m_enumerator.config(drvindex).root_device());
+			for (device_t *scandevice = deviter.first(); scandevice != NULL; scandevice = deviter.next())
+				for (const rom_entry *region = rom_first_region(*scandevice); region; region = rom_next_region(region))
+					for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+						if (ROM_GETLENGTH(rom) == romlength)
+						{
+							hash_collection hashes(ROM_GETHASHDATA(rom));
+							if (hashes == romhashes)
+								highest_device = scandevice;
+						}
 		}
 	}
 
-	return highest_source;
+	return highest_device;
 }
 
 
@@ -546,7 +540,7 @@
 	  m_name(ROM_GETNAME(&media)),
 	  m_explength(rom_file_size(&media)),
 	  m_length(0),
-	  m_shared_source(NULL)
+	  m_shared_device(NULL)
 {
 	m_exphashes.from_internal_string(ROM_GETHASHDATA(&media));
 }
@@ -559,6 +553,6 @@
 	  m_name(name),
 	  m_explength(0),
 	  m_length(0),
-	  m_shared_source(NULL)
+	  m_shared_device(NULL)
 {
 }
diff -Nru src-old/emu/audit.h src/emu/audit.h
--- src-old/emu/audit.h	2011-08-20 21:33:18.000000000 +0200
+++ src/emu/audit.h	2012-02-20 07:06:58.000000000 +0100
@@ -114,7 +114,7 @@
 	UINT64 actual_length() const { return m_length; }
 	const hash_collection &expected_hashes() const { return m_exphashes; }
 	const hash_collection &actual_hashes() const { return m_hashes; }
-	const rom_source *shared_source() const { return m_shared_source; }
+	device_t *shared_device() const { return m_shared_device; }
 
 	// setters
 	void set_status(audit_status status, audit_substatus substatus)
@@ -129,9 +129,9 @@
 		m_length = length;
 	}
 
-	void set_shared_source(const rom_source *shared_source)
+	void set_shared_device(device_t *shared_device)
 	{
-		m_shared_source = shared_source;
+		m_shared_device = shared_device;
 	}
 
 private:
@@ -145,7 +145,7 @@
 	UINT64				m_length;				/* actual length of item */
 	hash_collection		m_exphashes;    		/* expected hash data */
 	hash_collection		m_hashes;				/* actual hash information */
-	const rom_source *	m_shared_source;		/* rom_source that shares the rom */
+	device_t *			m_shared_device;		/* device that shares the rom */
 };
 
 
@@ -183,7 +183,7 @@
 	audit_record *audit_one_rom(const rom_entry *rom);
 	audit_record *audit_one_disk(const rom_entry *rom);
 	void compute_status(audit_record &record, const rom_entry *rom, bool found);
-	const rom_source *find_shared_source(const rom_source *source, const hash_collection &romhashes, UINT64 romlength);
+	device_t *find_shared_device(device_t &device, const hash_collection &romhashes, UINT64 romlength);
 
 	// internal state
 	simple_list<audit_record>	m_record_list;
diff -Nru src-old/emu/clifront.c src/emu/clifront.c
--- src-old/emu/clifront.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/clifront.c	2012-02-26 15:31:24.000000000 +0100
@@ -88,7 +88,7 @@
 	{ CLICOMMAND_LISTSLOTS ";lslot",    "0",       OPTION_COMMAND,    "list available slots and slot devices" },
 	{ CLICOMMAND_LISTMEDIA ";lm",       "0",       OPTION_COMMAND,    "list available media for the system" },
 	{ CLICOMMAND_LISTSOFTWARE ";lsoft", "0",       OPTION_COMMAND,    "list known software for the system" },
-
+	{ CLICOMMAND_GETSOFTLIST ";glist",  "0",       OPTION_COMMAND,    "retrieve software list by name" },
 	{ NULL }
 };
 
@@ -463,18 +463,18 @@
 
 	// iterate through matches, and then through ROMs
 	while (drivlist.next())
-		for (const rom_source *source = rom_first_source(drivlist.config()); source != NULL; source = rom_next_source(*source))
-		{
-			bool isdriver = (source == rom_first_source(drivlist.config()));
-			for (const rom_entry *region = rom_first_region(*source); region; region = rom_next_region(region))
+	{
+		device_iterator deviter(drivlist.config().root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+			for (const rom_entry *region = rom_first_region(*device); region; region = rom_next_region(region))
 				for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
 				{
 					// if we have a CRC, display it
 					UINT32 crc;
 					if (hash_collection(ROM_GETHASHDATA(rom)).crc(crc))
-						mame_printf_info("%08x %-16s \t %-8s \t %s\n", crc, ROM_GETNAME(rom), source->shortname(), isdriver ? drivlist.driver().description : source->name());
+						mame_printf_info("%08x %-16s \t %-8s \t %s\n", crc, ROM_GETNAME(rom), device->shortname(), device->name());
 				}
-		}
+	}
 }
 
 
@@ -503,8 +503,9 @@
 				"Name                    Size Checksum\n", drivlist.driver().name);
 
 		// iterate through roms
-		for (const rom_source *source = rom_first_source(drivlist.config()); source != NULL; source = rom_next_source(*source))
-			for (const rom_entry *region = rom_first_region(*source); region; region = rom_next_region(region))
+		device_iterator deviter(drivlist.config().root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+			for (const rom_entry *region = rom_first_region(*device); region; region = rom_next_region(region))
 				for (const rom_entry *rom = rom_first_file(region); rom; rom = rom_next_file(rom))
 				{
 					// accumulate the total length of all chunks
@@ -731,9 +732,6 @@
 //  verifyroms - verify the ROM sets of one or
 //  more games
 //-------------------------------------------------
-extern int m_device_count;
-extern const device_type *s_devices_sorted[];
-
 void cli_frontend::verifyroms(const char *gamename)
 {
 	// determine which drivers to output;
@@ -758,7 +756,7 @@
 			notfound++;
 
 		// else display information about what we discovered
-		else if (summary != media_auditor::NONE_NEEDED)
+		else
 		{
 			// output the summary of the audit
 			astring summary_string;
@@ -785,6 +783,7 @@
 					break;
 
 				case media_auditor::BEST_AVAILABLE:
+				case media_auditor::NONE_NEEDED:
 					mame_printf_info("is best available\n");
 					correct++;
 					break;
@@ -796,63 +795,131 @@
 	}
 
 	driver_enumerator dummy_drivlist(m_options);
-	dummy_drivlist.next();
-	machine_config &config = dummy_drivlist.config();
-	device_t *owner = &config.root_device();
-	// check if all are listed, note that empty one is included
-	for (int i = 0; i < m_device_count; i++)
+	int_map device_map;
+	while (dummy_drivlist.next())
 	{
-		device_type type = *s_devices_sorted[i];
-		device_t *dev = (*type)(config, "dummy", owner, 0);
-		dev->config_complete();
-
-		if (mame_strwildcmp(gamename, dev->shortname()) == 0)
+		machine_config &config = dummy_drivlist.config();
+		device_iterator iter(config.root_device());
+		for (device_t *dev = iter.first(); dev != NULL; dev = iter.next())
 		{
-			matched++;
+			if (dev->owner() != NULL && (strlen(dev->shortname())>0) && dev->rom_region() != NULL && (device_map.add(dev->shortname(), 0, false) != TMERR_DUPLICATE)) {
+				if (mame_strwildcmp(gamename, dev->shortname()) == 0)
+				{
+					matched++;
 
-			// audit the ROMs in this set
-			media_auditor::summary summary = auditor.audit_device(dev, AUDIT_VALIDATE_FAST);
+					// audit the ROMs in this set
+					media_auditor::summary summary = auditor.audit_device(dev, AUDIT_VALIDATE_FAST);
 
-			// if not found, count that and leave it at that
-			if (summary == media_auditor::NOTFOUND)
-				notfound++;
+					// if not found, count that and leave it at that
+					if (summary == media_auditor::NOTFOUND)
+						notfound++;
+					// else display information about what we discovered
+					else if (summary != media_auditor::NONE_NEEDED)
+					{
+						// output the summary of the audit
+						astring summary_string;
+						auditor.summarize(dev->shortname(),&summary_string);
+						mame_printf_info("%s", summary_string.cstr());
 
-			// else display information about what we discovered
-			else
+						// display information about what we discovered
+						mame_printf_info("romset %s ", dev->shortname());
+
+						// switch off of the result
+						switch (summary)
+						{
+							case media_auditor::INCORRECT:
+								mame_printf_info("is bad\n");
+								incorrect++;
+								break;
+
+							case media_auditor::CORRECT:
+								mame_printf_info("is good\n");
+								correct++;
+								break;
+
+							case media_auditor::BEST_AVAILABLE:
+								mame_printf_info("is best available\n");
+								correct++;
+								break;
+
+							default:
+								break;
+						}
+					}
+				}
+			}
+		}
+
+		slot_interface_iterator slotiter(config.root_device());
+		for (const device_slot_interface *slot = slotiter.first(); slot != NULL; slot = slotiter.next())
+		{
+			const slot_interface* intf = slot->get_slot_interfaces();
+			for (int i = 0; intf && intf[i].name != NULL; i++)
 			{
-				// output the summary of the audit
-				astring summary_string;
-				auditor.summarize(dev->shortname(),&summary_string);
-				mame_printf_info("%s", summary_string.cstr());
+				astring temptag("_");
+				temptag.cat(intf[i].name);
+				device_t *dev = const_cast<machine_config &>(config).device_add(&config.root_device(), temptag.cstr(), intf[i].devtype, 0);
+
+				// notify this device and all its subdevices that they are now configured
+				device_iterator subiter(*dev);
+				for (device_t *device = subiter.first(); device != NULL; device = subiter.next())
+					if (!device->configured())
+						device->config_complete();
 
-				// display information about what we discovered
-				mame_printf_info("romset %s ", dev->shortname());
+				if (device_map.add(dev->shortname(), 0, false) != TMERR_DUPLICATE) {
+					if (mame_strwildcmp(gamename, dev->shortname()) == 0)
+					{
+						matched++;
+						if (dev->rom_region() != NULL)
+						{
+							// audit the ROMs in this set
+							media_auditor::summary summary = auditor.audit_device(dev, AUDIT_VALIDATE_FAST);
 
-				// switch off of the result
-				switch (summary)
-				{
-					case media_auditor::INCORRECT:
-						mame_printf_info("is bad\n");
-						incorrect++;
-						break;
-
-					case media_auditor::CORRECT:
-						mame_printf_info("is good\n");
-						correct++;
-						break;
-
-					case media_auditor::BEST_AVAILABLE:
-						mame_printf_info("is best available\n");
-						correct++;
-						break;
+							// if not found, count that and leave it at that
+							if (summary == media_auditor::NOTFOUND)
+								notfound++;
+
+							// else display information about what we discovered
+							else if(summary != media_auditor::NONE_NEEDED)
+							{
+								// output the summary of the audit
+								astring summary_string;
+								auditor.summarize(dev->shortname(),&summary_string);
+								mame_printf_info("%s", summary_string.cstr());
+
+								// display information about what we discovered
+								mame_printf_info("romset %s ", dev->shortname());
+
+								// switch off of the result
+								switch (summary)
+								{
+									case media_auditor::INCORRECT:
+										mame_printf_info("is bad\n");
+										incorrect++;
+										break;
+
+									case media_auditor::CORRECT:
+										mame_printf_info("is good\n");
+										correct++;
+										break;
+
+									case media_auditor::BEST_AVAILABLE:
+										mame_printf_info("is best available\n");
+										correct++;
+										break;
 
-					default:
-						break;
+									default:
+										break;
+								}
+							}
+						}
+					}
 				}
+
+				const_cast<machine_config &>(config).device_remove(&config.root_device(), temptag.cstr());
+				global_free(dev);
 			}
 		}
-
-		global_free(dev);
 	}
 
 	// clear out any cached files
@@ -863,7 +930,7 @@
 		throw emu_fatalerror(MAMERR_NO_SUCH_GAME, "No matching games found for '%s'", gamename);
 
 	// if we didn't get anything at all, display a generic end message
-	if (matched == 1 && correct == 0 && incorrect == 0)
+	if (matched > 0 && correct == 0 && incorrect == 0)
 	{
 		if (notfound > 0)
 			throw emu_fatalerror(MAMERR_MISSING_FILES, "romset \"%s\" not found!\n", gamename);
@@ -955,7 +1022,7 @@
 		throw emu_fatalerror(MAMERR_NO_SUCH_GAME, "No matching games found for '%s'", gamename);
 
 	// if we didn't get anything at all, display a generic end message
-	if (matched == 1 && correct == 0 && incorrect == 0)
+	if (matched > 0 && correct == 0 && incorrect == 0)
 	{
 		if (notfound > 0)
 			throw emu_fatalerror(MAMERR_MISSING_FILES, "sampleset \"%s\" not found!\n", gamename);
@@ -971,8 +1038,192 @@
 		mame_printf_info("%d samplesets found, %d were OK.\n", correct, correct);
 	}
 }
+#define SOFTLIST_XML_BEGIN "<?xml version=\"1.0\"?>\n" \
+				"<!DOCTYPE softwarelist [\n" \
+				"<!ELEMENT softwarelists (softwarelist*)>\n" \
+				"\t<!ELEMENT softwarelist (software+)>\n" \
+				"\t\t<!ATTLIST softwarelist name CDATA #REQUIRED>\n" \
+				"\t\t<!ATTLIST softwarelist description CDATA #IMPLIED>\n" \
+				"\t\t<!ELEMENT software (description, year?, publisher, info*, sharedfeat*, part*)>\n" \
+				"\t\t\t<!ATTLIST software name CDATA #REQUIRED>\n" \
+				"\t\t\t<!ATTLIST software cloneof CDATA #IMPLIED>\n" \
+				"\t\t\t<!ATTLIST software supported (yes|partial|no) \"yes\">\n" \
+				"\t\t\t<!ELEMENT description (#PCDATA)>\n" \
+				"\t\t\t<!ELEMENT year (#PCDATA)>\n" \
+				"\t\t\t<!ELEMENT publisher (#PCDATA)>\n" \
+				"\t\t\t<!ELEMENT info EMPTY>\n" \
+				"\t\t\t\t<!ATTLIST info name CDATA #REQUIRED>\n" \
+				"\t\t\t\t<!ATTLIST info value CDATA #IMPLIED>\n" \
+				"\t\t\t<!ELEMENT sharedfeat EMPTY>\n" \
+				"\t\t\t\t<!ATTLIST sharedfeat name CDATA #REQUIRED>\n" \
+				"\t\t\t\t<!ATTLIST sharedfeat value CDATA #IMPLIED>\n" \
+				"\t\t\t<!ELEMENT part (feature*, dataarea*, diskarea*, dipswitch*)>\n" \
+				"\t\t\t\t<!ATTLIST part name CDATA #REQUIRED>\n" \
+				"\t\t\t\t<!ATTLIST part interface CDATA #REQUIRED>\n" \
+				"\t\t\t\t<!ELEMENT feature EMPTY>\n" \
+				"\t\t\t\t\t<!ATTLIST feature name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ATTLIST feature value CDATA #IMPLIED>\n" \
+				"\t\t\t\t<!ELEMENT dataarea (rom*)>\n" \
+				"\t\t\t\t\t<!ATTLIST dataarea name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ATTLIST dataarea size CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ATTLIST dataarea databits (8|16|32|64) \"8\">\n" \
+				"\t\t\t\t\t<!ATTLIST dataarea endian (big|little) \"little\">\n" \
+				"\t\t\t\t\t<!ELEMENT rom EMPTY>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom name CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom size CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom length CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom crc CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom sha1 CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom offset CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom value CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom status (baddump|nodump|good) \"good\">\n" \
+				"\t\t\t\t\t\t<!ATTLIST rom loadflag (load16_byte|load16_word|load16_word_swap|load32_byte|load32_word|load32_word_swap|load32_dword|load64_word|load64_word_swap|reload|fill|continue) #IMPLIED>\n" \
+				"\t\t\t\t<!ELEMENT diskarea (disk*)>\n" \
+				"\t\t\t\t\t<!ATTLIST diskarea name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ELEMENT disk EMPTY>\n" \
+				"\t\t\t\t\t\t<!ATTLIST disk name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST disk sha1 CDATA #IMPLIED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST disk status (baddump|nodump|good) \"good\">\n" \
+				"\t\t\t\t\t\t<!ATTLIST disk writeable (yes|no) \"no\">\n" \
+				"\t\t\t\t<!ELEMENT dipswitch (dipvalue*)>\n" \
+				"\t\t\t\t\t<!ATTLIST dipswitch name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ATTLIST dipswitch tag CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ATTLIST dipswitch mask CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t<!ELEMENT dipvalue EMPTY>\n" \
+				"\t\t\t\t\t\t<!ATTLIST dipvalue name CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST dipvalue value CDATA #REQUIRED>\n" \
+				"\t\t\t\t\t\t<!ATTLIST dipvalue default (yes|no) \"no\">\n" \
+				"]>\n\n" \
+				"<softwarelists>\n"
+
+void cli_frontend::output_single_softlist(FILE *out,software_list *list, const char *listname)
+{
+	astring tempstr;
+	software_list_parse( list, NULL, NULL );
+
+	fprintf(out, "\t<softwarelist name=\"%s\" description=\"%s\">\n", listname, xml_normalize_string(software_list_get_description(list)) );
+
+	for ( software_info *swinfo = software_list_find( list, "*", NULL ); swinfo != NULL; swinfo = software_list_find( list, "*", swinfo ) )
+	{
+		fprintf( out, "\t\t<software name=\"%s\"", swinfo->shortname );
+		if ( swinfo->parentname != NULL )
+			fprintf( out, " cloneof=\"%s\"", swinfo->parentname );
+		if ( swinfo->supported == SOFTWARE_SUPPORTED_PARTIAL )
+			fprintf( out, " supported=\"partial\"" );
+		if ( swinfo->supported == SOFTWARE_SUPPORTED_NO )
+			fprintf( out, " supported=\"no\"" );
+		fprintf( out, ">\n" );
+		fprintf( out, "\t\t\t<description>%s</description>\n", xml_normalize_string(swinfo->longname) );
+		fprintf( out, "\t\t\t<year>%s</year>\n", xml_normalize_string( swinfo->year ) );
+		fprintf( out, "\t\t\t<publisher>%s</publisher>\n", xml_normalize_string( swinfo->publisher ) );
+
+		for ( software_part *part = software_find_part( swinfo, NULL, NULL ); part != NULL; part = software_part_next( part ) )
+		{
+			fprintf( out, "\t\t\t<part name=\"%s\"", part->name );
+			if ( part->interface_ )
+				fprintf( out, " interface=\"%s\"", part->interface_ );
+
+			fprintf( out, ">\n");
+
+			if ( part->featurelist )
+			{
+				feature_list *flist = part->featurelist;
+
+				while( flist )
+				{
+					fprintf( out, "\t\t\t\t<feature name=\"%s\" value=\"%s\" />\n", flist->name, flist->value );
+					flist = flist->next;
+				}
+			}
+
+			/* TODO: display rom region information */
+			for ( const rom_entry *region = part->romdata; region; region = rom_next_region( region ) )
+			{
+				int is_disk = ROMREGION_ISDISKDATA(region);
+
+				if (!is_disk)
+					fprintf( out, "\t\t\t\t<dataarea name=\"%s\" size=\"%d\">\n", ROMREGION_GETTAG(region), ROMREGION_GETLENGTH(region) );
+				else
+					fprintf( out, "\t\t\t\t<diskarea name=\"%s\">\n", ROMREGION_GETTAG(region) );
+
+				for ( const rom_entry *rom = rom_first_file( region ); rom && !ROMENTRY_ISREGIONEND(rom); rom++ )
+				{
+					if ( ROMENTRY_ISFILE(rom) )
+					{
+						if (!is_disk)
+							fprintf( out, "\t\t\t\t\t<rom name=\"%s\" size=\"%d\"", xml_normalize_string(ROM_GETNAME(rom)), rom_file_size(rom) );
+						else
+							fprintf( out, "\t\t\t\t\t<disk name=\"%s\"", xml_normalize_string(ROM_GETNAME(rom)) );
+
+						/* dump checksum information only if there is a known dump */
+						hash_collection hashes(ROM_GETHASHDATA(rom));
+						if ( !hashes.flag(hash_collection::FLAG_NO_DUMP) )
+							fprintf( out, " %s", hashes.attribute_string(tempstr) );
+						else
+							fprintf( out, " status=\"nodump\"" );
+
+						if (is_disk)
+							fprintf( out, " writeable=\"%s\"", (ROM_GETFLAGS(rom) & DISK_READONLYMASK) ? "no" : "yes");
+
+						if ((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(1))
+							fprintf( out, " loadflag=\"load16_byte\"" );
+
+						if ((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(3))
+							fprintf( out, " loadflag=\"load32_byte\"" );
 
+						if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(2)) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
+						{
+							if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
+								fprintf( out, " loadflag=\"load32_word\"" );
+							else
+								fprintf( out, " loadflag=\"load32_word_swap\"" );
+						}
+
+						if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(6)) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
+						{
+							if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
+								fprintf( out, " loadflag=\"load64_word\"" );
+							else
+								fprintf( out, " loadflag=\"load64_word_swap\"" );
+						}
+
+						if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_NOSKIP) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
+						{
+							if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
+								fprintf( out, " loadflag=\"load32_dword\"" );
+							else
+								fprintf( out, " loadflag=\"load16_word_swap\"" );
+						}
+
+						fprintf( out, "/>\n" );
+					}
+					else if ( ROMENTRY_ISRELOAD(rom) )
+					{
+						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"reload\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
+					}
+					else if ( ROMENTRY_ISCONTINUE(rom) )
+					{
+						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"continue\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
+					}
+					else if ( ROMENTRY_ISFILL(rom) )
+					{
+						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"fill\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
+					}
+				}
+
+				if (!is_disk)
+					fprintf( out, "\t\t\t\t</dataarea>\n" );
+				else
+					fprintf( out, "\t\t\t\t</diskarea>\n" );
+			}
+
+			fprintf( out, "\t\t\t</part>\n" );
+		}
 
+		fprintf( out, "\t\t</software>\n" );
+	}
+	fprintf(out, "\t</softwarelist>\n" );
+}
 /*-------------------------------------------------
     info_listsoftware - output the list of
     software supported by a given game or set of
@@ -985,100 +1236,14 @@
 void cli_frontend::listsoftware(const char *gamename)
 {
 	FILE *out = stdout;
+	int_map list_map;
+	bool isfirst = TRUE;
 
 	// determine which drivers to output; return an error if none found
 	driver_enumerator drivlist(m_options, gamename);
 	if (drivlist.count() == 0)
 		throw emu_fatalerror(MAMERR_NO_SUCH_GAME, "No matching games found for '%s'", gamename);
 
-	// first determine the maximum number of lists we might encounter
-	int list_count = 0;
-	while (drivlist.next())
-	{
-		software_list_device_iterator iter(drivlist.config().root_device());
-		for (const software_list_device *swlist = iter.first(); swlist != NULL; swlist = iter.next())
-			if (swlist->list_type() == SOFTWARE_LIST_ORIGINAL_SYSTEM)
-				list_count++;
-	}
-
-	// allocate a list
-	astring *lists = global_alloc_array(astring, list_count);
-
-	if (list_count)
-	{
-		fprintf( out,
-				"<?xml version=\"1.0\"?>\n"
-				"<!DOCTYPE softwarelist [\n"
-				"<!ELEMENT softwarelists (softwarelist*)>\n"
-				"\t<!ELEMENT softwarelist (software+)>\n"
-				"\t\t<!ATTLIST softwarelist name CDATA #REQUIRED>\n"
-				"\t\t<!ATTLIST softwarelist description CDATA #IMPLIED>\n"
-				"\t\t<!ELEMENT software (description, year?, publisher, info*, sharedfeat*, part*)>\n"
-				"\t\t\t<!ATTLIST software name CDATA #REQUIRED>\n"
-				"\t\t\t<!ATTLIST software cloneof CDATA #IMPLIED>\n"
-				"\t\t\t<!ATTLIST software supported (yes|partial|no) \"yes\">\n"
-				"\t\t\t<!ELEMENT description (#PCDATA)>\n"
-				"\t\t\t<!ELEMENT year (#PCDATA)>\n"
-				"\t\t\t<!ELEMENT publisher (#PCDATA)>\n"
-				// we still do not store the info strings internally, so there is no output here
-				// TODO: add parsing info in softlist.c and then add output here!
-				"\t\t\t<!ELEMENT info EMPTY>\n"
-				"\t\t\t\t<!ATTLIST info name CDATA #REQUIRED>\n"
-				"\t\t\t\t<!ATTLIST info value CDATA #IMPLIED>\n"
-				// shared features get stored in the part->feature below and are output there
-				// this means that we don't output any <sharedfeat> and that -lsoft output will
-				// be different from the list in hash/ when the list uses sharedfeat. But this
-				// is by design: sharedfeat is only available to simplify the life to list creators,
-				// to e.g. avoid manually adding the same feature to each disk of a 9 floppies game!
-				"\t\t\t<!ELEMENT sharedfeat EMPTY>\n"
-				"\t\t\t\t<!ATTLIST sharedfeat name CDATA #REQUIRED>\n"
-				"\t\t\t\t<!ATTLIST sharedfeat value CDATA #IMPLIED>\n"
-				"\t\t\t<!ELEMENT part (feature*, dataarea*, diskarea*, dipswitch*)>\n"
-				"\t\t\t\t<!ATTLIST part name CDATA #REQUIRED>\n"
-				"\t\t\t\t<!ATTLIST part interface CDATA #REQUIRED>\n"
-				"\t\t\t\t<!ELEMENT feature EMPTY>\n"
-				"\t\t\t\t\t<!ATTLIST feature name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ATTLIST feature value CDATA #IMPLIED>\n"
-				"\t\t\t\t<!ELEMENT dataarea (rom*)>\n"
-				"\t\t\t\t\t<!ATTLIST dataarea name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ATTLIST dataarea size CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ATTLIST dataarea databits (8|16|32|64) \"8\">\n"
-				"\t\t\t\t\t<!ATTLIST dataarea endian (big|little) \"little\">\n"
-				"\t\t\t\t\t<!ELEMENT rom EMPTY>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom name CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom size CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom length CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom crc CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom sha1 CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom offset CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom value CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST rom status (baddump|nodump|good) \"good\">\n"
-				"\t\t\t\t\t\t<!ATTLIST rom loadflag (load16_byte|load16_word|load16_word_swap|load32_byte|load32_word|load32_word_swap|load32_dword|load64_word|load64_word_swap|reload|fill|continue) #IMPLIED>\n"
-				"\t\t\t\t<!ELEMENT diskarea (disk*)>\n"
-				"\t\t\t\t\t<!ATTLIST diskarea name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ELEMENT disk EMPTY>\n"
-				"\t\t\t\t\t\t<!ATTLIST disk name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t\t<!ATTLIST disk sha1 CDATA #IMPLIED>\n"
-				"\t\t\t\t\t\t<!ATTLIST disk status (baddump|nodump|good) \"good\">\n"
-				"\t\t\t\t\t\t<!ATTLIST disk writeable (yes|no) \"no\">\n"
-				// we still do not store the dipswitch values internally, so there is no output here
-				// TODO: add parsing dipsw in softlist.c and then add output here!
-				"\t\t\t\t<!ELEMENT dipswitch (dipvalue*)>\n"
-				"\t\t\t\t\t<!ATTLIST dipswitch name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ATTLIST dipswitch tag CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ATTLIST dipswitch mask CDATA #REQUIRED>\n"
-				"\t\t\t\t\t<!ELEMENT dipvalue EMPTY>\n"
-				"\t\t\t\t\t\t<!ATTLIST dipvalue name CDATA #REQUIRED>\n"
-				"\t\t\t\t\t\t<!ATTLIST dipvalue value CDATA #REQUIRED>\n"
-				"\t\t\t\t\t\t<!ATTLIST dipvalue default (yes|no) \"no\">\n"
-				"]>\n\n"
-				"<softwarelists>\n"
-				);
-	}
-
-	drivlist.reset();
-	list_count = 0;
-	astring tempstr;
 	while (drivlist.next())
 	{
 		software_list_device_iterator iter(drivlist.config().root_device());
@@ -1091,153 +1256,58 @@
 				if ( list )
 				{
 					/* Verify if we have encountered this list before */
-					bool seen_before = false;
-					for (int seen_index = 0; seen_index < list_count && !seen_before; seen_index++)
-						if (lists[seen_index] == swlist->list_name())
-							seen_before = true;
-
-					if (!seen_before)
+					if (list_map.add(swlist->list_name(), 0, false) != TMERR_DUPLICATE)
 					{
-						lists[list_count++] = swlist->list_name();
-						software_list_parse( list, NULL, NULL );
-
-						fprintf(out, "\t<softwarelist name=\"%s\" description=\"%s\">\n", swlist->list_name(), xml_normalize_string(software_list_get_description(list)) );
-
-						for ( software_info *swinfo = software_list_find( list, "*", NULL ); swinfo != NULL; swinfo = software_list_find( list, "*", swinfo ) )
-						{
-							fprintf( out, "\t\t<software name=\"%s\"", swinfo->shortname );
-							if ( swinfo->parentname != NULL )
-								fprintf( out, " cloneof=\"%s\"", swinfo->parentname );
-							if ( swinfo->supported == SOFTWARE_SUPPORTED_PARTIAL )
-								fprintf( out, " supported=\"partial\"" );
-							if ( swinfo->supported == SOFTWARE_SUPPORTED_NO )
-								fprintf( out, " supported=\"no\"" );
-							fprintf( out, ">\n" );
-							fprintf( out, "\t\t\t<description>%s</description>\n", xml_normalize_string(swinfo->longname) );
-							fprintf( out, "\t\t\t<year>%s</year>\n", xml_normalize_string( swinfo->year ) );
-							fprintf( out, "\t\t\t<publisher>%s</publisher>\n", xml_normalize_string( swinfo->publisher ) );
-
-							for ( software_part *part = software_find_part( swinfo, NULL, NULL ); part != NULL; part = software_part_next( part ) )
-							{
-								fprintf( out, "\t\t\t<part name=\"%s\"", part->name );
-								if ( part->interface_ )
-									fprintf( out, " interface=\"%s\"", part->interface_ );
-
-								fprintf( out, ">\n");
-
-								if ( part->featurelist )
-								{
-									feature_list *flist = part->featurelist;
-
-									while( flist )
-									{
-										fprintf( out, "\t\t\t\t<feature name=\"%s\" value=\"%s\" />\n", flist->name, flist->value );
-										flist = flist->next;
-									}
-								}
-
-								/* TODO: display rom region information */
-								for ( const rom_entry *region = part->romdata; region; region = rom_next_region( region ) )
-								{
-									int is_disk = ROMREGION_ISDISKDATA(region);
-
-									if (!is_disk)
-										fprintf( out, "\t\t\t\t<dataarea name=\"%s\" size=\"%d\">\n", ROMREGION_GETTAG(region), ROMREGION_GETLENGTH(region) );
-									else
-										fprintf( out, "\t\t\t\t<diskarea name=\"%s\">\n", ROMREGION_GETTAG(region) );
-
-									for ( const rom_entry *rom = rom_first_file( region ); rom && !ROMENTRY_ISREGIONEND(rom); rom++ )
-									{
-										if ( ROMENTRY_ISFILE(rom) )
-										{
-											if (!is_disk)
-												fprintf( out, "\t\t\t\t\t<rom name=\"%s\" size=\"%d\"", xml_normalize_string(ROM_GETNAME(rom)), rom_file_size(rom) );
-											else
-												fprintf( out, "\t\t\t\t\t<disk name=\"%s\"", xml_normalize_string(ROM_GETNAME(rom)) );
-
-											/* dump checksum information only if there is a known dump */
-											hash_collection hashes(ROM_GETHASHDATA(rom));
-											if ( !hashes.flag(hash_collection::FLAG_NO_DUMP) )
-												fprintf( out, " %s", hashes.attribute_string(tempstr) );
-											else
-												fprintf( out, " status=\"nodump\"" );
-
-											if (is_disk)
-												fprintf( out, " writeable=\"%s\"", (ROM_GETFLAGS(rom) & DISK_READONLYMASK) ? "no" : "yes");
-
-											if ((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(1))
-												fprintf( out, " loadflag=\"load16_byte\"" );
-
-											if ((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(3))
-												fprintf( out, " loadflag=\"load32_byte\"" );
-
-											if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(2)) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
-											{
-												if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
-													fprintf( out, " loadflag=\"load32_word\"" );
-												else
-													fprintf( out, " loadflag=\"load32_word_swap\"" );
-											}
-
-											if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_SKIP(6)) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
-											{
-												if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
-													fprintf( out, " loadflag=\"load64_word\"" );
-												else
-													fprintf( out, " loadflag=\"load64_word_swap\"" );
-											}
-
-											if (((ROM_GETFLAGS(rom) & ROM_SKIPMASK) == ROM_NOSKIP) && ((ROM_GETFLAGS(rom) & ROM_GROUPMASK) == ROM_GROUPWORD))
-											{
-												if (!(ROM_GETFLAGS(rom) & ROM_REVERSEMASK))
-													fprintf( out, " loadflag=\"load32_dword\"" );
-												else
-													fprintf( out, " loadflag=\"load16_word_swap\"" );
-											}
+						if (isfirst) { fprintf( out, SOFTLIST_XML_BEGIN); isfirst = FALSE; }
+						output_single_softlist(out, list, swlist->list_name());
+					}
 
-											fprintf( out, "/>\n" );
-										}
-										else if ( ROMENTRY_ISRELOAD(rom) )
-										{
-											fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"reload\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
-										}
-										else if ( ROMENTRY_ISCONTINUE(rom) )
-										{
-											fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"continue\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
-										}
-										else if ( ROMENTRY_ISFILL(rom) )
-										{
-											fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"fill\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
-										}
-									}
+					software_list_close( list );
+				}
+			}
+		}
+	}
 
-									if (!is_disk)
-										fprintf( out, "\t\t\t\t</dataarea>\n" );
-									else
-										fprintf( out, "\t\t\t\t</diskarea>\n" );
-								}
+	if (!isfirst)
+		fprintf( out, "</softwarelists>\n" );
+	else
+		fprintf( out, "No software lists found for this system\n" );
+}
 
-								fprintf( out, "\t\t\t</part>\n" );
-							}
 
-							fprintf( out, "\t\t</software>\n" );
-						}
+/*-------------------------------------------------
+    getsoftlist - retrieve software list by name
+-------------------------------------------------*/
 
-						fprintf(out, "\t</softwarelist>\n" );
-					}
+void cli_frontend::getsoftlist(const char *gamename)
+{
+	FILE *out = stdout;
+	int_map list_map;
+	bool isfirst = TRUE;
 
-					software_list_close( list );
+	driver_enumerator drivlist(m_options);
+	while (drivlist.next())
+	{
+		software_list_device_iterator iter(drivlist.config().root_device());
+		for (const software_list_device *swlist = iter.first(); swlist != NULL; swlist = iter.next())
+		{
+			software_list *list = software_list_open(m_options, swlist->list_name(), FALSE, NULL);
+			if ( list )
+			{
+				if ((mame_strwildcmp(swlist->list_name(),gamename)==0) && list_map.add(swlist->list_name(), 0, false) != TMERR_DUPLICATE)
+				{
+					if (isfirst) { fprintf( out, SOFTLIST_XML_BEGIN); isfirst = FALSE; }
+					output_single_softlist(out, list, swlist->list_name());
 				}
+				software_list_close( list );
 			}
 		}
 	}
 
-	if (list_count > 0)
+	if (!isfirst)
 		fprintf( out, "</softwarelists>\n" );
 	else
-		fprintf( out, "No software lists found for this system\n" );
-
-	global_free( lists );
+		fprintf( out, "No such software lists found\n" );
 }
 
 
@@ -1347,7 +1417,8 @@
 		{ CLICOMMAND_VERIFYSAMPLES,	&cli_frontend::verifysamples },
 		{ CLICOMMAND_LISTMEDIA,		&cli_frontend::listmedia },
 		{ CLICOMMAND_LISTSOFTWARE,  &cli_frontend::listsoftware },
-		{ CLICOMMAND_ROMIDENT,		&cli_frontend::romident }
+		{ CLICOMMAND_ROMIDENT,		&cli_frontend::romident },
+		{ CLICOMMAND_GETSOFTLIST,   &cli_frontend::getsoftlist },
 	};
 
 	// find the command
@@ -1649,9 +1720,10 @@
 	m_drivlist.reset();
 	while (m_drivlist.next())
 	{
-		// iterate over sources, regions and files within the region */
-		for (const rom_source *source = rom_first_source(m_drivlist.config()); source != NULL; source = rom_next_source(*source))
-			for (const rom_entry *region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+		// iterate over devices, regions and files within the region */
+		device_iterator deviter(m_drivlist.config().root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+			for (const rom_entry *region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 				for (const rom_entry *rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
 				{
 					hash_collection romhashes(ROM_GETHASHDATA(rom));
diff -Nru src-old/emu/clifront.h src/emu/clifront.h
--- src-old/emu/clifront.h	2011-11-28 13:46:11.000000000 +0100
+++ src/emu/clifront.h	2012-02-24 15:59:26.000000000 +0100
@@ -74,6 +74,7 @@
 #define CLICOMMAND_LISTSLOTS			"listslots"
 #define CLICOMMAND_LISTMEDIA			"listmedia"		// needed by MESS
 #define CLICOMMAND_LISTSOFTWARE			"listsoftware"
+#define CLICOMMAND_GETSOFTLIST			"getsoftlist"
 
 
 
@@ -96,6 +97,7 @@
 // cli_frontend handles command-line processing and emulator execution
 class cli_frontend
 {
+	typedef tagmap_t<FPTR> int_map;
 public:
 	// construction/destruction
 	cli_frontend(cli_options &options, osd_interface &osd);
@@ -120,12 +122,14 @@
 	void verifyroms(const char *gamename = "*");
 	void verifysamples(const char *gamename = "*");
 	void romident(const char *filename);
+	void getsoftlist(const char *gamename = "*");
 
 private:
 	// internal helpers
 	void execute_commands(const char *exename);
 	void display_help();
 	void display_suggestions(const char *gamename);
+	void output_single_softlist(FILE *out,software_list *list, const char *listname);
 
 	// internal state
 	cli_options &		m_options;
diff -Nru src-old/emu/cpu/cpu.mak src/emu/cpu/cpu.mak
--- src-old/emu/cpu/cpu.mak	2012-01-11 18:47:39.000000000 +0100
+++ src/emu/cpu/cpu.mak	2012-02-20 09:25:57.000000000 +0100
@@ -1140,6 +1140,8 @@
 $(CPUOBJ)/m68000/m68kcpu.o: 	$(CPUOBJ)/m68000/m68kops.c \
 								$(CPUSRC)/m68000/m68kcpu.h $(CPUSRC)/m68000/m68kfpu.c $(CPUSRC)/m68000/m68kmmu.h
 
+# m68kcpu.h now includes m68kops.h; m68kops.h won't exist until m68kops.c has been made
+$(CPUSRC)/m68000/m68kcpu.h: $(CPUOBJ)/m68000/m68kops.c
 
 
 #-------------------------------------------------
diff -Nru src-old/emu/cpu/i386/i386.c src/emu/cpu/i386/i386.c
--- src-old/emu/cpu/i386/i386.c	2012-02-08 22:26:25.000000000 +0100
+++ src/emu/cpu/i386/i386.c	2012-02-26 15:31:24.000000000 +0100
@@ -1915,7 +1915,6 @@
 static void i386_protected_mode_retf(i386_state* cpustate, UINT8 count, UINT8 operand32)
 {
 	UINT32 newCS, newEIP;
-	UINT32 newSS, newESP;  // when changing privilege
 	I386_SREG desc;
 	UINT8 CPL, RPL, DPL;
 
@@ -1925,17 +1924,11 @@
 	{
 		newEIP = READ16(cpustate, ea) & 0xffff;
 		newCS = READ16(cpustate, ea+2) & 0xffff;
-		ea += count+4;
-		newESP = READ16(cpustate, ea) & 0xffff;
-		newSS = READ16(cpustate, ea+2) & 0xffff;
 	}
 	else
 	{
 		newEIP = READ32(cpustate, ea);
 		newCS = READ32(cpustate, ea+4) & 0xffff;
-		ea += count+8;
-		newESP = READ32(cpustate, ea);
-		newSS = READ32(cpustate, ea+4) & 0xffff;
 	}
 
 	memset(&desc, 0, sizeof(desc));
@@ -2031,6 +2024,7 @@
 	}
 	else if(RPL > CPL)
 	{
+		UINT32 newSS, newESP;  // when changing privilege
 		/* outer privilege level */
 		if(operand32 == 0)
 		{
@@ -2050,7 +2044,6 @@
 				FAULT(FAULT_SS,0)
 			}
 		}
-
 		/* Check CS selector and descriptor */
 		if((newCS & ~0x03) == 0)
 		{
@@ -2104,6 +2097,20 @@
 			logerror("RETF: EIP is past return CS segment limit.\n");
 			FAULT(FAULT_GP,0)
 		}
+
+		if(operand32 == 0)
+		{
+			ea += count+4;
+			newESP = READ16(cpustate, ea) & 0xffff;
+			newSS = READ16(cpustate, ea+2) & 0xffff;
+		}
+		else
+		{
+			ea += count+8;
+			newESP = READ32(cpustate, ea);
+			newSS = READ32(cpustate, ea+4) & 0xffff;
+		}
+
 		/* Check SS selector and descriptor */
 		desc.selector = newSS;
 		i386_load_protected_mode_segment(cpustate,&desc);
@@ -2191,16 +2198,12 @@
 		newEIP = READ16(cpustate, ea) & 0xffff;
 		newCS = READ16(cpustate, ea+2) & 0xffff;
 		newflags = READ16(cpustate, ea+4) & 0xffff;
-		newESP = READ16(cpustate, ea+6) & 0xffff;
-		newSS = READ16(cpustate, ea+8) & 0xffff;
 	}
 	else
 	{
 		newEIP = READ32(cpustate, ea);
 		newCS = READ32(cpustate, ea+4) & 0xffff;
 		newflags = READ32(cpustate, ea+8);
-		newESP = READ32(cpustate, ea+12);
-		newSS = READ32(cpustate, ea+16) & 0xffff;
 	}
 
 	if(V8086_MODE)
@@ -2271,6 +2274,16 @@
 		if(newflags & 0x00020000) // if returning to virtual 8086 mode
 		{
 //          UINT8 SSRPL,SSDPL;
+			if(operand32 == 0)
+			{
+				newESP = READ16(cpustate, ea+6) & 0xffff;
+				newSS = READ16(cpustate, ea+8) & 0xffff;
+			}
+			else
+			{
+				newESP = READ32(cpustate, ea+12);
+				newSS = READ32(cpustate, ea+16) & 0xffff;
+			}
 			memset(&desc, 0, sizeof(desc));
 			desc.selector = newCS;
 			i386_load_protected_mode_segment(cpustate,&desc);
@@ -2547,16 +2560,12 @@
 			}
 			else if(RPL > CPL)
 			{
-				I386_SREG stack;
 				/* return to outer privilege level */
 				memset(&desc, 0, sizeof(desc));
 				desc.selector = newCS;
 				i386_load_protected_mode_segment(cpustate,&desc);
 				DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 				RPL = newCS & 0x03;
-				memset(&stack, 0, sizeof(stack));
-				stack.selector = newSS;
-				i386_load_protected_mode_segment(cpustate,&stack);
 				if(operand32 == 0)
 				{
 					UINT32 offset = (STACK_32BIT ? REG32(ESP) : REG16(SP));
@@ -2625,6 +2634,19 @@
 				}
 
 				/* Check SS selector and descriptor */
+				if(operand32 == 0)
+				{
+					newESP = READ16(cpustate, ea+6) & 0xffff;
+					newSS = READ16(cpustate, ea+8) & 0xffff;
+				}
+				else
+				{
+					newESP = READ32(cpustate, ea+12);
+					newSS = READ32(cpustate, ea+16) & 0xffff;
+				}
+				memset(&stack, 0, sizeof(stack));
+				stack.selector = newSS;
+				i386_load_protected_mode_segment(cpustate,&stack);
 				DPL = (stack.flags >> 5) & 0x03;
 				if((newSS & ~0x03) == 0)
 				{
diff -Nru src-old/emu/cpu/i386/i386op16.c src/emu/cpu/i386/i386op16.c
--- src-old/emu/cpu/i386/i386op16.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/cpu/i386/i386op16.c	2012-02-23 00:42:26.000000000 +0100
@@ -3331,8 +3331,8 @@
 				}
 				if(PROTECTED_MODE)
 					b |= 0x0001;  // cannot return to real mode using this instruction.
-				cpustate->cr[0] &= ~0x0000ffff;
-				cpustate->cr[0] |= b & 0x0000ffff;
+				cpustate->cr[0] &= ~0x0000000f;
+				cpustate->cr[0] |= b & 0x0000000f;
 				break;
 			}
 		default:
diff -Nru src-old/emu/cpu/i386/i386op32.c src/emu/cpu/i386/i386op32.c
--- src-old/emu/cpu/i386/i386op32.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/cpu/i386/i386op32.c	2012-02-23 00:42:26.000000000 +0100
@@ -3163,6 +3163,25 @@
 				}
 				break;
 			}
+		case 6:			/* LMSW */
+			{
+				if(PROTECTED_MODE && cpustate->CPL)
+					FAULT(FAULT_GP,0)
+				UINT16 b;
+				if( modrm >= 0xc0 ) {
+					b = LOAD_RM16(modrm);
+					CYCLES(cpustate,CYCLES_LMSW_REG);
+				} else {
+					ea = GetEA(cpustate,modrm,0);
+					CYCLES(cpustate,CYCLES_LMSW_MEM);
+				b = READ16(cpustate,ea);
+				}
+				if(PROTECTED_MODE)
+					b |= 0x0001;  // cannot return to real mode using this instruction.
+				cpustate->cr[0] &= ~0x0000000f;
+				cpustate->cr[0] |= b & 0x0000000f;
+				break;
+			}
 		default:
 			fatalerror("i386: unimplemented opcode 0x0f 01 /%d at %08X", (modrm >> 3) & 0x7, cpustate->eip - 2);
 			break;
diff -Nru src-old/emu/cpu/i386/i386ops.c src/emu/cpu/i386/i386ops.c
--- src-old/emu/cpu/i386/i386ops.c	2012-01-29 10:40:48.000000000 +0100
+++ src/emu/cpu/i386/i386ops.c	2012-02-24 22:04:08.000000000 +0100
@@ -351,7 +351,7 @@
 	ead = i386_translate(cpustate, ES, cpustate->address_size ? REG32(EDI) : REG16(DI), 0 );
 	src = READ8(cpustate,eas);
 	dst = READ8(cpustate,ead);
-	SUB8(cpustate,dst, src);
+	SUB8(cpustate,src, dst);
 	BUMP_SI(cpustate,1);
 	BUMP_DI(cpustate,1);
 	CYCLES(cpustate,CYCLES_CMPS);
@@ -736,7 +736,10 @@
 	int s = (modrm >> 3) & 0x7;
 
 	if( modrm >= 0xc0 ) {
-		STORE_RM16(modrm, cpustate->sreg[s].selector);
+		if(cpustate->operand_size)
+			STORE_RM32(modrm, cpustate->sreg[s].selector);
+		else
+			STORE_RM16(modrm, cpustate->sreg[s].selector);
 		CYCLES(cpustate,CYCLES_MOV_SREG_REG);
 	} else {
 		UINT32 ea = GetEA(cpustate,modrm,1);
@@ -2408,12 +2411,8 @@
 
 static void I386OP(lock)(i386_state *cpustate)				// Opcode 0xf0
 {
-	if(PROTECTED_MODE)
-	{
-		UINT8 IOPL = cpustate->IOP1 | (cpustate->IOP2 << 1);
-		if(cpustate->CPL > IOPL)
-			FAULT(FAULT_GP,0);
-	}
+	// lock doesn't depend on iopl on 386
+	// TODO: lock causes UD on unlockable opcodes
 	CYCLES(cpustate,CYCLES_LOCK);		// TODO: Determine correct cycle count
 	I386OP(decode_opcode)(cpustate);
 }
diff -Nru src-old/emu/cpu/i386/i486ops.c src/emu/cpu/i386/i486ops.c
--- src-old/emu/cpu/i386/i486ops.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/cpu/i386/i486ops.c	2012-02-23 00:42:26.000000000 +0100
@@ -282,19 +282,21 @@
 			}
 		case 6:			/* LMSW */
 			{
-				UINT8 b;
+				UINT16 b;
 				if(PROTECTED_MODE && cpustate->CPL)
 					FAULT(FAULT_GP,0)
 				if( modrm >= 0xc0 ) {
-					b = LOAD_RM8(modrm);
+					b = LOAD_RM16(modrm);
 					CYCLES(cpustate,CYCLES_LMSW_REG);
 				} else {
 					ea = GetEA(cpustate,modrm,0);
 					CYCLES(cpustate,CYCLES_LMSW_MEM);
-					b = READ8(cpustate,ea);
+					b = READ16(cpustate,ea);
 				}
-				cpustate->cr[0] &= ~0x03;
-				cpustate->cr[0] |= b & 0x03;
+				if(PROTECTED_MODE)
+					b |= 0x0001;  // cannot return to real mode using this instruction.
+				cpustate->cr[0] &= ~0x0000000f;
+				cpustate->cr[0] |= b & 0x0000000f;
 				break;
 			}
 		case 7:			/* INVLPG */
@@ -387,6 +389,25 @@
 				}
 				break;
 			}
+		case 6:			/* LMSW */
+			{
+				if(PROTECTED_MODE && cpustate->CPL)
+					FAULT(FAULT_GP,0)
+				UINT16 b;
+				if( modrm >= 0xc0 ) {
+					b = LOAD_RM16(modrm);
+					CYCLES(cpustate,CYCLES_LMSW_REG);
+				} else {
+					ea = GetEA(cpustate,modrm,0);
+					CYCLES(cpustate,CYCLES_LMSW_MEM);
+				b = READ16(cpustate,ea);
+				}
+				if(PROTECTED_MODE)
+					b |= 0x0001;  // cannot return to real mode using this instruction.
+				cpustate->cr[0] &= ~0x0000000f;
+				cpustate->cr[0] |= b & 0x0000000f;
+				break;
+			}
 		case 7:			/* INVLPG */
 			{
 				// Nothing to do ?
diff -Nru src-old/emu/cpu/lr35902/lr35902.c src/emu/cpu/lr35902/lr35902.c
--- src-old/emu/cpu/lr35902/lr35902.c	2011-04-27 06:11:18.000000000 +0200
+++ src/emu/cpu/lr35902/lr35902.c	2012-02-25 22:22:21.000000000 +0100
@@ -46,16 +46,20 @@
 #define FLAG_H  0x20
 #define FLAG_C  0x10
 
-#define CYCLES_PASSED(X)		cpustate->w.icount -= ((X) / (cpustate->w.gb_speed));	\
-					if ( cpustate->w.timer_expired_func ) {			\
-						cpustate->w.timer_expired_func( cpustate->w.device, X );		\
+#define CYCLES_PASSED(X)		cpustate->icount -= ((X) / (cpustate->gb_speed));	\
+					if ( cpustate->timer_expired_func ) {			\
+						cpustate->timer_expired_func( cpustate->device, X );		\
 					}
 
-typedef struct {
-	UINT16 AF;
-	UINT16 BC;
-	UINT16 DE;
-	UINT16 HL;
+typedef struct _lr35902_state {
+	UINT8 A;
+	UINT8 F;
+	UINT8 B;
+	UINT8 C;
+	UINT8 D;
+	UINT8 E;
+	UINT8 H;
+	UINT8 L;
 
 	UINT16 SP;
 	UINT16 PC;
@@ -80,38 +84,7 @@
 	int doHALTbug;
 	UINT8	features;
 	const lr35902_cpu_core *config;
-} lr35902_16BitRegs;
-
-#ifdef LSB_FIRST
-typedef struct {
-	UINT8 F;
-	UINT8 A;
-	UINT8 C;
-	UINT8 B;
-	UINT8 E;
-	UINT8 D;
-	UINT8 L;
-	UINT8 H;
-} lr35902_8BitRegs;
-#else
-typedef struct {
-	UINT8 A;
-	UINT8 F;
-	UINT8 B;
-	UINT8 C;
-	UINT8 D;
-	UINT8 E;
-	UINT8 H;
-	UINT8 L;
-} lr35902_8BitRegs;
-#endif
-
-
-typedef union _lr35902_state lr35902_state;
-union _lr35902_state {
-	lr35902_16BitRegs w;
-	lr35902_8BitRegs b;
-};
+} lr35902_state;
 
 INLINE lr35902_state *get_safe_token(device_t *device)
 {
@@ -129,12 +102,19 @@
 /* Memory functions                                                         */
 /****************************************************************************/
 
-#define mem_ReadByte(cs,A)		((UINT8)(cs)->w.program->read_byte(A))
-#define mem_WriteByte(cs,A,V)	((cs)->w.program->write_byte(A,V))
+#define mem_ReadByte(cs,A)		((UINT8)(cs)->program->read_byte(A)); CYCLES_PASSED(4);
+#define mem_WriteByte(cs,A,V)	((cs)->program->write_byte(A,V)); CYCLES_PASSED(4);
+
+INLINE UINT8 mem_ReadOp(lr35902_state *cpustate)
+{
+	UINT8 r = mem_ReadByte (cpustate, cpustate->PC++);
+	return r;
+}
 
 INLINE UINT16 mem_ReadWord (lr35902_state *cpustate, UINT32 address)
 {
-	UINT16 value = (UINT16) mem_ReadByte (cpustate, (address + 1) & 0xffff) << 8;
+	UINT16 value = mem_ReadByte (cpustate, (address + 1) & 0xffff);
+	value <<= 8;
 	value |= mem_ReadByte (cpustate, address);
 	return value;
 }
@@ -145,54 +125,14 @@
 	mem_WriteByte (cpustate, (address + 1) & 0xffff, value >> 8);
 }
 
-static const int Cycles[256] =
-{
-	 4,12, 8, 8, 4, 4, 8, 4,20, 8, 8, 8, 4, 4, 8, 4,
-	 4,12, 8, 8, 4, 4, 8, 4,12, 8, 8, 8, 4, 4, 8, 4,
-	 8,12, 8, 8, 4, 4, 8, 4, 8, 8, 8, 8, 4, 4, 8, 4,
-	 8,12, 8, 8,12,12,12, 4, 8, 8, 8, 8, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 8, 8, 8, 8, 8, 8, 4, 8, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,
-	 8,12,12,16,12,16, 8,16, 8,16,12, 0,12,24, 8,16,
-	 8,12,12, 4,12,16, 8,16, 8,16,12, 4,12, 4, 8,16,
-	12,12, 8, 4, 4,16, 8,16,16, 4,16, 4, 4, 4, 8,16,
-	12,12, 8, 4, 4,16, 8,16,12, 8,16, 4, 4, 4, 8,16
-};
-
-static const int CyclesCB[256] =
-{
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
-	 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
-	 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
-	 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,
-	 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8
-};
-
 static CPU_INIT( lr35902 )
 {
 	lr35902_state *cpustate = get_safe_token(device);
 
-	cpustate->w.config = (const lr35902_cpu_core *) device->static_config();
-	cpustate->w.irq_callback = irqcallback;
-	cpustate->w.device = device;
-	cpustate->w.program = device->space(AS_PROGRAM);
+	cpustate->config = (const lr35902_cpu_core *) device->static_config();
+	cpustate->irq_callback = irqcallback;
+	cpustate->device = device;
+	cpustate->program = device->space(AS_PROGRAM);
 }
 
 /*** Reset lr353902 registers: ******************************/
@@ -204,52 +144,60 @@
 {
 	lr35902_state *cpustate = get_safe_token(device);
 
-	cpustate->w.AF = 0x0000;
-	cpustate->w.BC = 0x0000;
-	cpustate->w.DE = 0x0000;
-	cpustate->w.HL = 0x0000;
-	cpustate->w.SP = 0x0000;
-	cpustate->w.PC = 0x0000;
-	cpustate->w.timer_expired_func = NULL;
-	cpustate->w.features = LR35902_FEATURE_HALT_BUG;
-	if (cpustate->w.config)
+	cpustate->A = 0x00;
+	cpustate->F = 0x00;
+	cpustate->B = 0x00;
+	cpustate->C = 0x00;
+	cpustate->D = 0x00;
+	cpustate->E = 0x00;
+	cpustate->H = 0x00;
+	cpustate->L = 0x00;
+	cpustate->SP = 0x0000;
+	cpustate->PC = 0x0000;
+	cpustate->timer_expired_func = NULL;
+	cpustate->features = LR35902_FEATURE_HALT_BUG;
+	if (cpustate->config)
 	{
-		if ( cpustate->w.config->regs ) {
-			cpustate->w.AF = cpustate->w.config->regs[0];
-			cpustate->w.BC = cpustate->w.config->regs[1];
-			cpustate->w.DE = cpustate->w.config->regs[2];
-			cpustate->w.HL = cpustate->w.config->regs[3];
-			cpustate->w.SP = cpustate->w.config->regs[4];
-			cpustate->w.PC = cpustate->w.config->regs[5];
+		if ( cpustate->config->regs ) {
+			cpustate->A = cpustate->config->regs[0] >> 8;
+			cpustate->F = cpustate->config->regs[0] & 0xFF;
+			cpustate->B = cpustate->config->regs[1] >> 8;
+			cpustate->C = cpustate->config->regs[1] & 0xFF;
+			cpustate->D = cpustate->config->regs[2] >> 8;
+			cpustate->E = cpustate->config->regs[2] & 0xFF;
+			cpustate->H = cpustate->config->regs[3] >> 8;
+			cpustate->L = cpustate->config->regs[3] & 0xFF;
+			cpustate->SP = cpustate->config->regs[4];
+			cpustate->PC = cpustate->config->regs[5];
 		}
-		cpustate->w.timer_expired_func = cpustate->w.config->timer_expired_func;
-		cpustate->w.features = cpustate->w.config->features;
+		cpustate->timer_expired_func = cpustate->config->timer_expired_func;
+		cpustate->features = cpustate->config->features;
 	}
-	cpustate->w.enable = 0;
-	cpustate->w.IE = 0;
-	cpustate->w.IF = 0;
-
-	cpustate->w.execution_state = 0;
-	cpustate->w.doHALTbug = 0;
-	cpustate->w.ei_delay = 0;
-	cpustate->w.gb_speed_change_pending = 0;
-	cpustate->w.gb_speed = 1;
+	cpustate->enable = 0;
+	cpustate->IE = 0;
+	cpustate->IF = 0;
+
+	cpustate->execution_state = 0;
+	cpustate->doHALTbug = 0;
+	cpustate->ei_delay = 0;
+	cpustate->gb_speed_change_pending = 0;
+	cpustate->gb_speed = 1;
 }
 
 INLINE void lr35902_ProcessInterrupts (lr35902_state *cpustate)
 {
-	UINT8 irq = cpustate->w.IE & cpustate->w.IF;
+	UINT8 irq = cpustate->IE & cpustate->IF;
 
 	/* Interrupts should be taken after the first instruction after an EI instruction */
-	if (cpustate->w.ei_delay) {
-		cpustate->w.ei_delay = 0;
+	if (cpustate->ei_delay) {
+		cpustate->ei_delay = 0;
 		return;
 	}
 
 	/*
        logerror("Attempting to process LR35902 Interrupt IRQ $%02X\n", irq);
-       logerror("Attempting to process LR35902 Interrupt IE $%02X\n", cpustate->w.IE);
-       logerror("Attempting to process LR35902 Interrupt IF $%02X\n", cpustate->w.IF);
+       logerror("Attempting to process LR35902 Interrupt IE $%02X\n", cpustate->IE);
+       logerror("Attempting to process LR35902 Interrupt IF $%02X\n", cpustate->IF);
     */
 	if (irq)
 	{
@@ -262,14 +210,14 @@
 		{
 			if( irq & (1<<irqline) )
 			{
-				if (cpustate->w.enable & HALTED)
+				if (cpustate->enable & HALTED)
 				{
-					cpustate->w.enable &= ~HALTED;
-					cpustate->w.PC++;
-					if ( cpustate->w.features & LR35902_FEATURE_HALT_BUG ) {
-						if ( ! ( cpustate->w.enable & IME ) ) {
+					cpustate->enable &= ~HALTED;
+					cpustate->PC++;
+					if ( cpustate->features & LR35902_FEATURE_HALT_BUG ) {
+						if ( ! ( cpustate->enable & IME ) ) {
 							/* Old cpu core (dmg/mgb/sgb) */
-							cpustate->w.doHALTbug = 1;
+							cpustate->doHALTbug = 1;
 						}
 					} else {
 						/* New cpu core (cgb/agb/ags) */
@@ -280,16 +228,16 @@
 						}
 					}
 				}
-				if ( cpustate->w.enable & IME ) {
-					if ( cpustate->w.irq_callback )
-						(*cpustate->w.irq_callback)(cpustate->w.device, irqline);
-					cpustate->w.enable &= ~IME;
-					cpustate->w.IF &= ~(1 << irqline);
-					CYCLES_PASSED( 20 );
-					cpustate->w.SP -= 2;
-					mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-					cpustate->w.PC = 0x40 + irqline * 8;
-					/*logerror("LR35902 Interrupt PC $%04X\n", cpustate->w.PC );*/
+				if ( cpustate->enable & IME ) {
+					if ( cpustate->irq_callback )
+						(*cpustate->irq_callback)(cpustate->device, irqline);
+					cpustate->enable &= ~IME;
+					cpustate->IF &= ~(1 << irqline);
+					CYCLES_PASSED( 12 );
+					cpustate->SP -= 2;
+					mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+					cpustate->PC = 0x40 + irqline * 8;
+					/*logerror("LR35902 Interrupt PC $%04X\n", cpustate->PC );*/
 					return;
 				}
 			}
@@ -307,30 +255,29 @@
 
 	do
 	{
-		if ( cpustate->w.execution_state ) {
+		if ( cpustate->execution_state ) {
 			UINT8	x;
 			/* Execute instruction */
-			switch( cpustate->w.op ) {
+			switch( cpustate->op ) {
 #include "opc_main.h"
 			}
 		} else {
 			/* Fetch and count cycles */
 			lr35902_ProcessInterrupts (cpustate);
-			debugger_instruction_hook(device, cpustate->w.PC);
-			if ( cpustate->w.enable & HALTED ) {
-				CYCLES_PASSED( Cycles[0x76] );
-				cpustate->w.execution_state = 1;
+			debugger_instruction_hook(device, cpustate->PC);
+			if ( cpustate->enable & HALTED ) {
+				CYCLES_PASSED( 4 );
+				cpustate->execution_state = 1;
 			} else {
-				cpustate->w.op = mem_ReadByte (cpustate, cpustate->w.PC++);
-				if ( cpustate->w.doHALTbug ) {
-					cpustate->w.PC--;
-					cpustate->w.doHALTbug = 0;
+				cpustate->op = mem_ReadOp (cpustate);
+				if ( cpustate->doHALTbug ) {
+					cpustate->PC--;
+					cpustate->doHALTbug = 0;
 				}
-				CYCLES_PASSED( Cycles[cpustate->w.op] );
 			}
 		}
-		cpustate->w.execution_state ^= 1;
-	} while (cpustate->w.icount > 0);
+		cpustate->execution_state ^= 1;
+	} while (cpustate->icount > 0);
 }
 
 static CPU_BURN( lr35902 )
@@ -341,29 +288,29 @@
     {
         /* NOP takes 4 cycles per instruction */
         int n = (cycles + 3) / 4;
-        cpustate->w.icount -= 4 * n;
+        cpustate->icount -= 4 * n;
     }
 }
 
 static void lr35902_set_irq_line (lr35902_state *cpustate, int irqline, int state)
 {
 	/*logerror("setting irq line 0x%02x state 0x%08x\n", irqline, state);*/
-	//if( cpustate->w.irq_state == state )
+	//if( cpustate->irq_state == state )
 	//  return;
 
-	cpustate->w.irq_state = state;
+	cpustate->irq_state = state;
 	if( state == ASSERT_LINE )
 	{
 
-		cpustate->w.IF |= (0x01 << irqline);
-		/*logerror("LR35902 assert irq line %d ($%02X)\n", irqline, cpustate->w.IF);*/
+		cpustate->IF |= (0x01 << irqline);
+		/*logerror("LR35902 assert irq line %d ($%02X)\n", irqline, cpustate->IF);*/
 
 	}
 	else
 	{
 
-		cpustate->w.IF &= ~(0x01 << irqline);
-		/*logerror("LR35902 clear irq line %d ($%02X)\n", irqline, cpustate->w.IF);*/
+		cpustate->IF &= ~(0x01 << irqline);
+		/*logerror("LR35902 clear irq line %d ($%02X)\n", irqline, cpustate->IF);*/
 
 	}
 }
@@ -371,7 +318,7 @@
 #ifdef UNUSED_FUNCTION
 static void lr35902_clear_pending_interrupts (lr35902_state *cpustate)
 {
-    cpustate->w.IF = 0;
+    cpustate->IF = 0;
 }
 #endif
 
@@ -388,18 +335,18 @@
 	case CPUINFO_INT_INPUT_STATE + 3:
 	case CPUINFO_INT_INPUT_STATE + 4:			lr35902_set_irq_line(cpustate, state-CPUINFO_INT_INPUT_STATE, info->i); break;
 
-	case CPUINFO_INT_SP:						cpustate->w.SP = info->i;						break;
-	case CPUINFO_INT_PC:						cpustate->w.PC = info->i;						break;
+	case CPUINFO_INT_SP:						cpustate->SP = info->i;						break;
+	case CPUINFO_INT_PC:						cpustate->PC = info->i;						break;
 
-	case CPUINFO_INT_REGISTER + LR35902_PC:		cpustate->w.PC = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_SP:		cpustate->w.SP = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_AF:		cpustate->w.AF = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_BC:		cpustate->w.BC = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_DE:		cpustate->w.DE = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_HL:		cpustate->w.HL = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_IE:		cpustate->w.IE = info->i; break;
-	case CPUINFO_INT_REGISTER + LR35902_IF:		cpustate->w.IF = info->i; break;
-	case CPUINFO_INT_REGISTER + LR35902_SPEED:	cpustate->w.gb_speed_change_pending = info->i & 0x01; break;
+	case CPUINFO_INT_REGISTER + LR35902_PC:		cpustate->PC = info->i;						break;
+	case CPUINFO_INT_REGISTER + LR35902_SP:		cpustate->SP = info->i;						break;
+	case CPUINFO_INT_REGISTER + LR35902_AF:		cpustate->A = info->i >> 8; cpustate->F = info->i & 0xFF;		break;
+	case CPUINFO_INT_REGISTER + LR35902_BC:		cpustate->B = info->i >> 8; cpustate->C = info->i & 0xFF;		break;
+	case CPUINFO_INT_REGISTER + LR35902_DE:		cpustate->D = info->i >> 8; cpustate->E = info->i & 0xFF;		break;
+	case CPUINFO_INT_REGISTER + LR35902_HL:		cpustate->H = info->i >> 8; cpustate->L = info->i & 0xFF;		break;
+	case CPUINFO_INT_REGISTER + LR35902_IE:		cpustate->IE = info->i; break;
+	case CPUINFO_INT_REGISTER + LR35902_IF:		cpustate->IF = info->i; break;
+	case CPUINFO_INT_REGISTER + LR35902_SPEED:	cpustate->gb_speed_change_pending = info->i & 0x01; break;
 	}
 }
 
@@ -431,25 +378,25 @@
 	case DEVINFO_INT_ADDRBUS_WIDTH + AS_IO:		info->i = 16;					break;
 	case DEVINFO_INT_ADDRBUS_SHIFT + AS_IO:		info->i = 0;					break;
 
-	case CPUINFO_INT_SP:							info->i = cpustate->w.SP;					break;
-	case CPUINFO_INT_PC:							info->i = cpustate->w.PC;					break;
+	case CPUINFO_INT_SP:							info->i = cpustate->SP;					break;
+	case CPUINFO_INT_PC:							info->i = cpustate->PC;					break;
 	case CPUINFO_INT_PREVIOUSPC:					info->i = 0;	/* TODO??? */			break;
 
 	case CPUINFO_INT_INPUT_STATE + 0:
 	case CPUINFO_INT_INPUT_STATE + 1:
 	case CPUINFO_INT_INPUT_STATE + 2:
 	case CPUINFO_INT_INPUT_STATE + 3:
-	case CPUINFO_INT_INPUT_STATE + 4:					info->i = cpustate->w.IF & (1 << (state-CPUINFO_INT_INPUT_STATE)); break;
+	case CPUINFO_INT_INPUT_STATE + 4:					info->i = cpustate->IF & (1 << (state-CPUINFO_INT_INPUT_STATE)); break;
 
-	case CPUINFO_INT_REGISTER + LR35902_PC:			info->i = cpustate->w.PC;					break;
-	case CPUINFO_INT_REGISTER + LR35902_SP:			info->i = cpustate->w.SP;					break;
-	case CPUINFO_INT_REGISTER + LR35902_AF:			info->i = cpustate->w.AF;					break;
-	case CPUINFO_INT_REGISTER + LR35902_BC:			info->i = cpustate->w.BC;					break;
-	case CPUINFO_INT_REGISTER + LR35902_DE:			info->i = cpustate->w.DE;					break;
-	case CPUINFO_INT_REGISTER + LR35902_HL:			info->i = cpustate->w.HL;					break;
-	case CPUINFO_INT_REGISTER + LR35902_IE:			info->i = cpustate->w.IE;					break;
-	case CPUINFO_INT_REGISTER + LR35902_IF:			info->i = cpustate->w.IF;					break;
-	case CPUINFO_INT_REGISTER + LR35902_SPEED:		info->i = 0x7E | ( ( cpustate->w.gb_speed - 1 ) << 7 ) | cpustate->w.gb_speed_change_pending; break;
+	case CPUINFO_INT_REGISTER + LR35902_PC:			info->i = cpustate->PC;					break;
+	case CPUINFO_INT_REGISTER + LR35902_SP:			info->i = cpustate->SP;					break;
+	case CPUINFO_INT_REGISTER + LR35902_AF:			info->i = ( cpustate->A << 8 ) | cpustate->F;					break;
+	case CPUINFO_INT_REGISTER + LR35902_BC:			info->i = ( cpustate->B << 8 ) | cpustate->C;					break;
+	case CPUINFO_INT_REGISTER + LR35902_DE:			info->i = ( cpustate->D << 8 ) | cpustate->E;					break;
+	case CPUINFO_INT_REGISTER + LR35902_HL:			info->i = ( cpustate->H << 8 ) | cpustate->L;					break;
+	case CPUINFO_INT_REGISTER + LR35902_IE:			info->i = cpustate->IE;					break;
+	case CPUINFO_INT_REGISTER + LR35902_IF:			info->i = cpustate->IF;					break;
+	case CPUINFO_INT_REGISTER + LR35902_SPEED:		info->i = 0x7E | ( ( cpustate->gb_speed - 1 ) << 7 ) | cpustate->gb_speed_change_pending; break;
 
 	/* --- the following bits of info are returned as pointers to data or functions --- */
 	case CPUINFO_FCT_SET_INFO:						info->setinfo = CPU_SET_INFO_NAME(lr35902);		break;
@@ -458,7 +405,7 @@
 	case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(lr35902);		break;
 	case CPUINFO_FCT_BURN:							info->burn = CPU_BURN_NAME(lr35902);				break;
 	case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(lr35902);		break;
-	case CPUINFO_PTR_INSTRUCTION_COUNTER:			info->icount = &cpustate->w.icount;			break;
+	case CPUINFO_PTR_INSTRUCTION_COUNTER:			info->icount = &cpustate->icount;			break;
 
 	/* --- the following bits of info are returned as NULL-terminated strings --- */
 	case DEVINFO_STR_NAME:							strcpy(info->s, "LR35902"); break;
@@ -469,26 +416,26 @@
 
 	case CPUINFO_STR_FLAGS:
 		sprintf(info->s, "%c%c%c%c%c%c%c%c",
-			cpustate->b.F & 0x80 ? 'Z':'.',
-			cpustate->b.F & 0x40 ? 'N':'.',
-			cpustate->b.F & 0x20 ? 'H':'.',
-			cpustate->b.F & 0x10 ? 'C':'.',
-			cpustate->b.F & 0x08 ? '3':'.',
-			cpustate->b.F & 0x04 ? '2':'.',
-			cpustate->b.F & 0x02 ? '1':'.',
-			cpustate->b.F & 0x01 ? '0':'.');
+			cpustate->F & 0x80 ? 'Z':'.',
+			cpustate->F & 0x40 ? 'N':'.',
+			cpustate->F & 0x20 ? 'H':'.',
+			cpustate->F & 0x10 ? 'C':'.',
+			cpustate->F & 0x08 ? '3':'.',
+			cpustate->F & 0x04 ? '2':'.',
+			cpustate->F & 0x02 ? '1':'.',
+			cpustate->F & 0x01 ? '0':'.');
 		break;
 
-	case CPUINFO_STR_REGISTER + LR35902_PC: sprintf(info->s, "PC:%04X", cpustate->w.PC); break;
-	case CPUINFO_STR_REGISTER + LR35902_SP: sprintf(info->s, "SP:%04X", cpustate->w.SP); break;
-	case CPUINFO_STR_REGISTER + LR35902_AF: sprintf(info->s, "AF:%04X", cpustate->w.AF); break;
-	case CPUINFO_STR_REGISTER + LR35902_BC: sprintf(info->s, "BC:%04X", cpustate->w.BC); break;
-	case CPUINFO_STR_REGISTER + LR35902_DE: sprintf(info->s, "DE:%04X", cpustate->w.DE); break;
-	case CPUINFO_STR_REGISTER + LR35902_HL: sprintf(info->s, "HL:%04X", cpustate->w.HL); break;
-	case CPUINFO_STR_REGISTER + LR35902_IRQ_STATE: sprintf(info->s, "IRQ:%X", cpustate->w.enable & IME ); break;
-	case CPUINFO_STR_REGISTER + LR35902_IE: sprintf(info->s, "IE:%02X", cpustate->w.IE); break;
-	case CPUINFO_STR_REGISTER + LR35902_IF: sprintf(info->s, "IF:%02X", cpustate->w.IF); break;
-	case CPUINFO_STR_REGISTER + LR35902_SPEED: sprintf(info->s, "SPD:%02x", 0x7E | ( ( cpustate->w.gb_speed - 1 ) << 7 ) | cpustate->w.gb_speed_change_pending ); break;
+	case CPUINFO_STR_REGISTER + LR35902_PC: sprintf(info->s, "PC:%04X", cpustate->PC); break;
+	case CPUINFO_STR_REGISTER + LR35902_SP: sprintf(info->s, "SP:%04X", cpustate->SP); break;
+	case CPUINFO_STR_REGISTER + LR35902_AF: sprintf(info->s, "AF:%02X%02X", cpustate->A, cpustate->F); break;
+	case CPUINFO_STR_REGISTER + LR35902_BC: sprintf(info->s, "BC:%02X%02X", cpustate->B, cpustate->C); break;
+	case CPUINFO_STR_REGISTER + LR35902_DE: sprintf(info->s, "DE:%02X%02X", cpustate->D, cpustate->E); break;
+	case CPUINFO_STR_REGISTER + LR35902_HL: sprintf(info->s, "HL:%02X%02X", cpustate->H, cpustate->L); break;
+	case CPUINFO_STR_REGISTER + LR35902_IRQ_STATE: sprintf(info->s, "IRQ:%X", cpustate->enable & IME ); break;
+	case CPUINFO_STR_REGISTER + LR35902_IE: sprintf(info->s, "IE:%02X", cpustate->IE); break;
+	case CPUINFO_STR_REGISTER + LR35902_IF: sprintf(info->s, "IF:%02X", cpustate->IF); break;
+	case CPUINFO_STR_REGISTER + LR35902_SPEED: sprintf(info->s, "SPD:%02x", 0x7E | ( ( cpustate->gb_speed - 1 ) << 7 ) | cpustate->gb_speed_change_pending ); break;
 	}
 }
 
diff -Nru src-old/emu/cpu/lr35902/opc_cb.h src/emu/cpu/lr35902/opc_cb.h
--- src-old/emu/cpu/lr35902/opc_cb.h	2008-12-10 18:50:50.000000000 +0100
+++ src/emu/cpu/lr35902/opc_cb.h	2012-02-25 22:22:21.000000000 +0100
@@ -8,17 +8,17 @@
 		f=0;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->b.F=f;			\
+	cpustate->F=f;			\
 }
 
 #define	RL_8BIT(x)				\
 {								\
 	register UINT8 r;			\
 	r=((x)&0x80)?FLAG_C:0;		\
-	(x)=(UINT8)(((x)<<1)|((cpustate->b.F&FLAG_C)?1:0));	 \
+	(x)=(UINT8)(((x)<<1)|((cpustate->F&FLAG_C)?1:0));	 \
 	if( (x)==0 )				\
 		r|=FLAG_Z;				\
-	cpustate->b.F=r;			\
+	cpustate->F=r;			\
 }
 
 #define	RRC_8BIT(x)				\
@@ -31,17 +31,17 @@
 		f=0;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->b.F=f;			\
+	cpustate->F=f;			\
 }
 
 #define	RR_8BIT(x)				\
 {								\
 	register UINT8 r;			\
 	r=((x)&1)?FLAG_C:0;			\
-	(x)=(UINT8)(((x)>>1)|((cpustate->b.F&FLAG_C)?0x80:0));	 \
+	(x)=(UINT8)(((x)>>1)|((cpustate->F&FLAG_C)?0x80:0));	 \
 	if( (x)==0 )				\
 		r|=FLAG_Z;				\
-	cpustate->b.F=r;			\
+	cpustate->F=r;			\
 }
 
 #define	SLA_8BIT(x)				\
@@ -54,7 +54,7 @@
 	(x)<<=1;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->b.F=f;			\
+	cpustate->F=f;			\
 }
 
 #define	SRA_8BIT(x)				\
@@ -67,15 +67,15 @@
 	(x)=(UINT8)(((char)(x))>>1);	 \
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->b.F=f;			\
+	cpustate->F=f;			\
 }
 
 #define	SWAP_8BIT(x)			\
 	(x)=(UINT8)(((x)>>4)|((x)<<4)); 	 \
 	if( (x)==0 )				\
-		cpustate->b.F=FLAG_Z;	\
+		cpustate->F=FLAG_Z;	\
 	else						\
-		cpustate->b.F=0;
+		cpustate->F=0;
 
 
 #define	SRL_8BIT(x)				\
@@ -88,14 +88,14 @@
 	(x)>>=1;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->b.F=f;			\
+	cpustate->F=f;			\
 }
 
 #define	BIT_8BIT(n,x)			\
 	if( (x)&(1<<(n)) )			\
-		cpustate->b.F=(UINT8)(FLAG_H|(cpustate->b.F&FLAG_C));  \
+		cpustate->F=(UINT8)(FLAG_H|(cpustate->F&FLAG_C));  \
 	else						\
-		cpustate->b.F=(UINT8)(FLAG_Z|FLAG_H|(cpustate->b.F&FLAG_C));
+		cpustate->F=(UINT8)(FLAG_Z|FLAG_H|(cpustate->F&FLAG_C));
 
 #define	RES_8BIT(n,x)	(x)&=~(1<<(n));
 
@@ -105,1336 +105,1432 @@
 case 0x00:
   /*      RLC B */
 
-  RLC_8BIT (cpustate->b.B)
+  RLC_8BIT (cpustate->B)
   break;
 case 0x01:
   /*      RLC C */
 
-  RLC_8BIT (cpustate->b.C)
+  RLC_8BIT (cpustate->C)
   break;
 case 0x02:
   /*      RLC D */
 
-  RLC_8BIT (cpustate->b.D)
+  RLC_8BIT (cpustate->D)
   break;
 case 0x03:
   /*      RLC E */
 
-  RLC_8BIT (cpustate->b.E)
+  RLC_8BIT (cpustate->E)
   break;
 case 0x04:
   /*      RLC H */
 
-  RLC_8BIT (cpustate->b.H)
+  RLC_8BIT (cpustate->H)
   break;
 case 0x05:
   /*      RLC L */
 
-  RLC_8BIT (cpustate->b.L)
+  RLC_8BIT (cpustate->L)
   break;
 case 0x06:
-  /*      RLC (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RLC_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RLC (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RLC_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x07:
   /*      RLC A */
 
-  RLC_8BIT (cpustate->b.A)
+  RLC_8BIT (cpustate->A)
   break;
 case 0x08:
   /*      RRC B */
 
-  RRC_8BIT (cpustate->b.B)
+  RRC_8BIT (cpustate->B)
   break;
 case 0x09:
   /*      RRC C */
 
-  RRC_8BIT (cpustate->b.C)
+  RRC_8BIT (cpustate->C)
   break;
 case 0x0A:
   /*      RRC D */
 
-  RRC_8BIT (cpustate->b.D)
+  RRC_8BIT (cpustate->D)
   break;
 case 0x0B:
   /*      RRC E */
 
-  RRC_8BIT (cpustate->b.E)
+  RRC_8BIT (cpustate->E)
   break;
 case 0x0C:
   /*      RRC H */
 
-  RRC_8BIT (cpustate->b.H)
+  RRC_8BIT (cpustate->H)
   break;
 case 0x0D:
   /*      RRC L */
 
-  RRC_8BIT (cpustate->b.L)
+  RRC_8BIT (cpustate->L)
   break;
 case 0x0E:
-  /*      RRC (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RRC_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RRC (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RRC_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x0F:
   /*      RRC A */
 
-  RRC_8BIT (cpustate->b.A)
+  RRC_8BIT (cpustate->A)
   break;
 case 0x10:
   /*      RL B */
 
-  RL_8BIT (cpustate->b.B)
+  RL_8BIT (cpustate->B)
   break;
 case 0x11:
   /*      RL C */
 
-  RL_8BIT (cpustate->b.C)
+  RL_8BIT (cpustate->C)
   break;
 case 0x12:
   /*      RL D */
 
-  RL_8BIT (cpustate->b.D)
+  RL_8BIT (cpustate->D)
   break;
 case 0x13:
   /*      RL E */
 
-  RL_8BIT (cpustate->b.E)
+  RL_8BIT (cpustate->E)
   break;
 case 0x14:
   /*      RL H */
 
-  RL_8BIT (cpustate->b.H)
+  RL_8BIT (cpustate->H)
   break;
 case 0x15:
   /*      RL L */
 
-  RL_8BIT (cpustate->b.L)
+  RL_8BIT (cpustate->L)
   break;
 case 0x16:
-  /*      RL (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RL_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RL (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RL_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x17:
   /*      RL A */
 
-  RL_8BIT (cpustate->b.A)
+  RL_8BIT (cpustate->A)
   break;
 case 0x18:
   /*      RR B */
 
-  RR_8BIT (cpustate->b.B)
+  RR_8BIT (cpustate->B)
   break;
 case 0x19:
   /*      RR C */
 
-  RR_8BIT (cpustate->b.C)
+  RR_8BIT (cpustate->C)
   break;
 case 0x1A:
   /*      RR D */
 
-  RR_8BIT (cpustate->b.D)
+  RR_8BIT (cpustate->D)
   break;
 case 0x1B:
   /*      RR E */
 
-  RR_8BIT (cpustate->b.E)
+  RR_8BIT (cpustate->E)
   break;
 case 0x1C:
   /*      RR H */
 
-  RR_8BIT (cpustate->b.H)
+  RR_8BIT (cpustate->H)
   break;
 case 0x1D:
   /*      RR L */
 
-  RR_8BIT (cpustate->b.L)
+  RR_8BIT (cpustate->L)
   break;
 case 0x1E:
-  /*      RR (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RR_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RR (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RR_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x1F:
   /*      RR A */
 
-  RR_8BIT (cpustate->b.A)
+  RR_8BIT (cpustate->A)
   break;
 case 0x20:
   /*      SLA B */
 
-  SLA_8BIT (cpustate->b.B)
+  SLA_8BIT (cpustate->B)
   break;
 case 0x21:
   /*      SLA C */
 
-  SLA_8BIT (cpustate->b.C)
+  SLA_8BIT (cpustate->C)
   break;
 case 0x22:
   /*      SLA D */
 
-  SLA_8BIT (cpustate->b.D)
+  SLA_8BIT (cpustate->D)
   break;
 case 0x23:
   /*      SLA E */
 
-  SLA_8BIT (cpustate->b.E)
+  SLA_8BIT (cpustate->E)
   break;
 case 0x24:
   /*      SLA H */
 
-  SLA_8BIT (cpustate->b.H)
+  SLA_8BIT (cpustate->H)
   break;
 case 0x25:
   /*      SLA L */
 
-  SLA_8BIT (cpustate->b.L)
+  SLA_8BIT (cpustate->L)
   break;
 case 0x26:
-  /*      SLA (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SLA_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SLA (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SLA_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x27:
   /*      SLA A */
 
-  SLA_8BIT (cpustate->b.A)
+  SLA_8BIT (cpustate->A)
   break;
 case 0x28:
   /*      SRA B */
 
-  SRA_8BIT (cpustate->b.B)
+  SRA_8BIT (cpustate->B)
   break;
 case 0x29:
   /*      SRA C */
 
-  SRA_8BIT (cpustate->b.C)
+  SRA_8BIT (cpustate->C)
   break;
 case 0x2A:
   /*      SRA D */
 
-  SRA_8BIT (cpustate->b.D)
+  SRA_8BIT (cpustate->D)
   break;
 case 0x2B:
   /*      SRA E */
 
-  SRA_8BIT (cpustate->b.E)
+  SRA_8BIT (cpustate->E)
   break;
 case 0x2C:
   /*      SRA H */
 
-  SRA_8BIT (cpustate->b.H)
+  SRA_8BIT (cpustate->H)
   break;
 case 0x2D:
   /*      SRA L */
 
-  SRA_8BIT (cpustate->b.L)
+  SRA_8BIT (cpustate->L)
   break;
 case 0x2E:
-  /*      SRA (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SRA_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SRA (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SRA_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x2F:
   /*      SRA A */
 
-  SRA_8BIT (cpustate->b.A)
+  SRA_8BIT (cpustate->A)
   break;
 case 0x30:
   /*      SWAP B */
 
-  SWAP_8BIT (cpustate->b.B)
+  SWAP_8BIT (cpustate->B)
   break;
 case 0x31:
   /*      SWAP C */
 
-  SWAP_8BIT (cpustate->b.C)
+  SWAP_8BIT (cpustate->C)
   break;
 case 0x32:
   /*      SWAP D */
 
-  SWAP_8BIT (cpustate->b.D)
+  SWAP_8BIT (cpustate->D)
   break;
 case 0x33:
   /*      SWAP E */
 
-  SWAP_8BIT (cpustate->b.E)
+  SWAP_8BIT (cpustate->E)
   break;
 case 0x34:
   /*      SWAP H */
 
-  SWAP_8BIT (cpustate->b.H)
+  SWAP_8BIT (cpustate->H)
   break;
 case 0x35:
   /*      SWAP L */
 
-  SWAP_8BIT (cpustate->b.L)
+  SWAP_8BIT (cpustate->L)
   break;
 case 0x36:
-  /*      SWAP (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SWAP_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SWAP (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SWAP_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x37:
   /*      SWAP A */
 
-  SWAP_8BIT (cpustate->b.A)
+  SWAP_8BIT (cpustate->A)
   break;
 case 0x38:
   /*      SRL B */
 
-  SRL_8BIT (cpustate->b.B)
+  SRL_8BIT (cpustate->B)
   break;
 case 0x39:
   /*      SRL C */
 
-  SRL_8BIT (cpustate->b.C)
+  SRL_8BIT (cpustate->C)
   break;
 case 0x3A:
   /*      SRL D */
 
-  SRL_8BIT (cpustate->b.D)
+  SRL_8BIT (cpustate->D)
   break;
 case 0x3B:
   /*      SRL E */
 
-  SRL_8BIT (cpustate->b.E)
+  SRL_8BIT (cpustate->E)
   break;
 case 0x3C:
   /*      SRL H */
 
-  SRL_8BIT (cpustate->b.H)
+  SRL_8BIT (cpustate->H)
   break;
 case 0x3D:
   /*      SRL L */
 
-  SRL_8BIT (cpustate->b.L)
+  SRL_8BIT (cpustate->L)
   break;
 case 0x3E:
-  /*      SRL (HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SRL_8BIT (x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SRL (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SRL_8BIT (x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x3F:
   /*      SRL A */
 
-  SRL_8BIT (cpustate->b.A)
+  SRL_8BIT (cpustate->A)
   break;
 case 0x40:
   /*      BIT 0,B */
 
-  BIT_8BIT (0, cpustate->b.B)
+  BIT_8BIT (0, cpustate->B)
   break;
 case 0x41:
   /*      BIT 0,C */
 
-  BIT_8BIT (0, cpustate->b.C)
+  BIT_8BIT (0, cpustate->C)
   break;
 case 0x42:
   /*      BIT 0,D */
 
-  BIT_8BIT (0, cpustate->b.D)
+  BIT_8BIT (0, cpustate->D)
   break;
 case 0x43:
   /*      BIT 0,E */
 
-  BIT_8BIT (0, cpustate->b.E)
+  BIT_8BIT (0, cpustate->E)
   break;
 case 0x44:
   /*      BIT 0,H */
 
-  BIT_8BIT (0, cpustate->b.H)
+  BIT_8BIT (0, cpustate->H)
   break;
 case 0x45:
   /*      BIT 0,L */
 
-  BIT_8BIT (0, cpustate->b.L)
+  BIT_8BIT (0, cpustate->L)
   break;
 case 0x46:
-  /*      BIT 0,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (0, x)
-  break;
+	/*      BIT 0,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (0, x)
+	}
+	break;
 case 0x47:
   /*      BIT 0,A */
 
-  BIT_8BIT (0, cpustate->b.A)
+  BIT_8BIT (0, cpustate->A)
   break;
 case 0x48:
   /*      BIT 1,B */
 
-  BIT_8BIT (1, cpustate->b.B)
+  BIT_8BIT (1, cpustate->B)
   break;
 case 0x49:
   /*      BIT 1,C */
 
-  BIT_8BIT (1, cpustate->b.C)
+  BIT_8BIT (1, cpustate->C)
   break;
 case 0x4A:
   /*      BIT 1,D */
 
-  BIT_8BIT (1, cpustate->b.D)
+  BIT_8BIT (1, cpustate->D)
   break;
 case 0x4B:
   /*      BIT 1,E */
 
-  BIT_8BIT (1, cpustate->b.E)
+  BIT_8BIT (1, cpustate->E)
   break;
 case 0x4C:
   /*      BIT 1,H */
 
-  BIT_8BIT (1, cpustate->b.H)
+  BIT_8BIT (1, cpustate->H)
   break;
 case 0x4D:
   /*      BIT 1,L */
 
-  BIT_8BIT (1, cpustate->b.L)
+  BIT_8BIT (1, cpustate->L)
   break;
 case 0x4E:
-  /*      BIT 1,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (1, x)
-  break;
+	/*      BIT 1,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (1, x)
+	}
+	break;
 case 0x4F:
   /*      BIT 1,A */
 
-  BIT_8BIT (1, cpustate->b.A)
+  BIT_8BIT (1, cpustate->A)
   break;
 case 0x50:
   /*      BIT 2,B */
 
-  BIT_8BIT (2, cpustate->b.B)
+  BIT_8BIT (2, cpustate->B)
   break;
 case 0x51:
   /*      BIT 2,C */
 
-  BIT_8BIT (2, cpustate->b.C)
+  BIT_8BIT (2, cpustate->C)
   break;
 case 0x52:
   /*      BIT 2,D */
 
-  BIT_8BIT (2, cpustate->b.D)
+  BIT_8BIT (2, cpustate->D)
   break;
 case 0x53:
   /*      BIT 2,E */
 
-  BIT_8BIT (2, cpustate->b.E)
+  BIT_8BIT (2, cpustate->E)
   break;
 case 0x54:
   /*      BIT 2,H */
 
-  BIT_8BIT (2, cpustate->b.H)
+  BIT_8BIT (2, cpustate->H)
   break;
 case 0x55:
   /*      BIT 2,L */
 
-  BIT_8BIT (2, cpustate->b.L)
+  BIT_8BIT (2, cpustate->L)
   break;
 case 0x56:
-  /*      BIT 2,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (2, x)
-  break;
+	/*      BIT 2,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (2, x)
+	}
+	break;
 case 0x57:
   /*      BIT 2,A */
 
-  BIT_8BIT (2, cpustate->b.A)
+  BIT_8BIT (2, cpustate->A)
   break;
 case 0x58:
   /*      BIT 3,B */
 
-  BIT_8BIT (3, cpustate->b.B)
+  BIT_8BIT (3, cpustate->B)
   break;
 case 0x59:
   /*      BIT 3,C */
 
-  BIT_8BIT (3, cpustate->b.C)
+  BIT_8BIT (3, cpustate->C)
   break;
 case 0x5A:
   /*      BIT 3,D */
 
-  BIT_8BIT (3, cpustate->b.D)
+  BIT_8BIT (3, cpustate->D)
   break;
 case 0x5B:
   /*      BIT 3,E */
 
-  BIT_8BIT (3, cpustate->b.E)
+  BIT_8BIT (3, cpustate->E)
   break;
 case 0x5C:
   /*      BIT 3,H */
 
-  BIT_8BIT (3, cpustate->b.H)
+  BIT_8BIT (3, cpustate->H)
   break;
 case 0x5D:
   /*      BIT 3,L */
 
-  BIT_8BIT (3, cpustate->b.L)
+  BIT_8BIT (3, cpustate->L)
   break;
 case 0x5E:
-  /*      BIT 3,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (3, x)
-  break;
+	/*      BIT 3,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (3, x)
+	}
+	break;
 case 0x5F:
   /*      BIT 3,A */
 
-  BIT_8BIT (3, cpustate->b.A)
+  BIT_8BIT (3, cpustate->A)
   break;
 case 0x60:
   /*      BIT 4,B */
 
-  BIT_8BIT (4, cpustate->b.B)
+  BIT_8BIT (4, cpustate->B)
   break;
 case 0x61:
   /*      BIT 4,C */
 
-  BIT_8BIT (4, cpustate->b.C)
+  BIT_8BIT (4, cpustate->C)
   break;
 case 0x62:
   /*      BIT 4,D */
 
-  BIT_8BIT (4, cpustate->b.D)
+  BIT_8BIT (4, cpustate->D)
   break;
 case 0x63:
   /*      BIT 4,E */
 
-  BIT_8BIT (4, cpustate->b.E)
+  BIT_8BIT (4, cpustate->E)
   break;
 case 0x64:
   /*      BIT 4,H */
 
-  BIT_8BIT (4, cpustate->b.H)
+  BIT_8BIT (4, cpustate->H)
   break;
 case 0x65:
   /*      BIT 4,L */
 
-  BIT_8BIT (4, cpustate->b.L)
+  BIT_8BIT (4, cpustate->L)
   break;
 case 0x66:
-  /*      BIT 4,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (4, x)
-  break;
+	/*      BIT 4,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (4, x)
+	}
+	break;
 case 0x67:
   /*      BIT 4,A */
 
-  BIT_8BIT (4, cpustate->b.A)
+  BIT_8BIT (4, cpustate->A)
   break;
 case 0x68:
   /*      BIT 5,B */
 
-  BIT_8BIT (5, cpustate->b.B)
+  BIT_8BIT (5, cpustate->B)
   break;
 case 0x69:
   /*      BIT 5,C */
 
-  BIT_8BIT (5, cpustate->b.C)
+  BIT_8BIT (5, cpustate->C)
   break;
 case 0x6A:
   /*      BIT 5,D */
 
-  BIT_8BIT (5, cpustate->b.D)
+  BIT_8BIT (5, cpustate->D)
   break;
 case 0x6B:
   /*      BIT 5,E */
 
-  BIT_8BIT (5, cpustate->b.E)
+  BIT_8BIT (5, cpustate->E)
   break;
 case 0x6C:
   /*      BIT 5,H */
 
-  BIT_8BIT (5, cpustate->b.H)
+  BIT_8BIT (5, cpustate->H)
   break;
 case 0x6D:
   /*      BIT 5,L */
 
-  BIT_8BIT (5, cpustate->b.L)
+  BIT_8BIT (5, cpustate->L)
   break;
 case 0x6E:
-  /*      BIT 5,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (5, x)
-  break;
+	/*      BIT 5,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (5, x)
+	}
+	break;
 case 0x6F:
   /*      BIT 5,A */
 
-  BIT_8BIT (5, cpustate->b.A)
+  BIT_8BIT (5, cpustate->A)
   break;
 case 0x70:
   /*      BIT 6,B */
 
-  BIT_8BIT (6, cpustate->b.B)
+  BIT_8BIT (6, cpustate->B)
   break;
 case 0x71:
   /*      BIT 6,C */
 
-  BIT_8BIT (6, cpustate->b.C)
+  BIT_8BIT (6, cpustate->C)
   break;
 case 0x72:
   /*      BIT 6,D */
 
-  BIT_8BIT (6, cpustate->b.D)
+  BIT_8BIT (6, cpustate->D)
   break;
 case 0x73:
   /*      BIT 6,E */
 
-  BIT_8BIT (6, cpustate->b.E)
+  BIT_8BIT (6, cpustate->E)
   break;
 case 0x74:
   /*      BIT 6,H */
 
-  BIT_8BIT (6, cpustate->b.H)
+  BIT_8BIT (6, cpustate->H)
   break;
 case 0x75:
   /*      BIT 6,L */
 
-  BIT_8BIT (6, cpustate->b.L)
+  BIT_8BIT (6, cpustate->L)
   break;
 case 0x76:
-  /*      BIT 6,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (6, x)
-  break;
+	/*      BIT 6,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (6, x)
+	}
+	break;
 case 0x77:
   /*      BIT 6,A */
 
-  BIT_8BIT (6, cpustate->b.A)
+  BIT_8BIT (6, cpustate->A)
   break;
 case 0x78:
   /*      BIT 7,B */
 
-  BIT_8BIT (7, cpustate->b.B)
+  BIT_8BIT (7, cpustate->B)
   break;
 case 0x79:
   /*      BIT 7,C */
 
-  BIT_8BIT (7, cpustate->b.C)
+  BIT_8BIT (7, cpustate->C)
   break;
 case 0x7A:
   /*      BIT 7,D */
 
-  BIT_8BIT (7, cpustate->b.D)
+  BIT_8BIT (7, cpustate->D)
   break;
 case 0x7B:
   /*      BIT 7,E */
 
-  BIT_8BIT (7, cpustate->b.E)
+  BIT_8BIT (7, cpustate->E)
   break;
 case 0x7C:
   /*      BIT 7,H */
 
-  BIT_8BIT (7, cpustate->b.H)
+  BIT_8BIT (7, cpustate->H)
   break;
 case 0x7D:
   /*      BIT 7,L */
 
-  BIT_8BIT (7, cpustate->b.L)
+  BIT_8BIT (7, cpustate->L)
   break;
 case 0x7E:
-  /*      BIT 7,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  BIT_8BIT (7, x)
-  break;
+	/*      BIT 7,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		BIT_8BIT (7, x)
+	}
+	break;
 case 0x7F:
   /*      BIT 7,A */
 
-  BIT_8BIT (7, cpustate->b.A)
+  BIT_8BIT (7, cpustate->A)
   break;
 case 0x80:
   /*      RES 0,B */
 
-  RES_8BIT (0, cpustate->b.B)
+  RES_8BIT (0, cpustate->B)
   break;
 case 0x81:
   /*      RES 0,C */
 
-  RES_8BIT (0, cpustate->b.C)
+  RES_8BIT (0, cpustate->C)
   break;
 case 0x82:
   /*      RES 0,D */
 
-  RES_8BIT (0, cpustate->b.D)
+  RES_8BIT (0, cpustate->D)
   break;
 case 0x83:
   /*      RES 0,E */
 
-  RES_8BIT (0, cpustate->b.E)
+  RES_8BIT (0, cpustate->E)
   break;
 case 0x84:
   /*      RES 0,H */
 
-  RES_8BIT (0, cpustate->b.H)
+  RES_8BIT (0, cpustate->H)
   break;
 case 0x85:
   /*      RES 0,L */
 
-  RES_8BIT (0, cpustate->b.L)
+  RES_8BIT (0, cpustate->L)
   break;
 case 0x86:
-  /*      RES 0,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (0, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 0,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (0, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x87:
   /*      RES 0,A */
 
-  RES_8BIT (0, cpustate->b.A)
+  RES_8BIT (0, cpustate->A)
   break;
 case 0x88:
   /*      RES 1,B */
 
-  RES_8BIT (1, cpustate->b.B)
+  RES_8BIT (1, cpustate->B)
   break;
 case 0x89:
   /*      RES 1,C */
 
-  RES_8BIT (1, cpustate->b.C)
+  RES_8BIT (1, cpustate->C)
   break;
 case 0x8A:
   /*      RES 1,D */
 
-  RES_8BIT (1, cpustate->b.D)
+  RES_8BIT (1, cpustate->D)
   break;
 case 0x8B:
   /*      RES 1,E */
 
-  RES_8BIT (1, cpustate->b.E)
+  RES_8BIT (1, cpustate->E)
   break;
 case 0x8C:
   /*      RES 1,H */
 
-  RES_8BIT (1, cpustate->b.H)
+  RES_8BIT (1, cpustate->H)
   break;
 case 0x8D:
   /*      RES 1,L */
 
-  RES_8BIT (1, cpustate->b.L)
+  RES_8BIT (1, cpustate->L)
   break;
 case 0x8E:
-  /*      RES 1,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (1, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 1,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (1, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x8F:
   /*      RES 1,A */
 
-  RES_8BIT (1, cpustate->b.A)
+  RES_8BIT (1, cpustate->A)
   break;
 case 0x90:
   /*      RES 2,B */
 
-  RES_8BIT (2, cpustate->b.B)
+  RES_8BIT (2, cpustate->B)
   break;
 case 0x91:
   /*      RES 2,C */
 
-  RES_8BIT (2, cpustate->b.C)
+  RES_8BIT (2, cpustate->C)
   break;
 case 0x92:
   /*      RES 2,D */
 
-  RES_8BIT (2, cpustate->b.D)
+  RES_8BIT (2, cpustate->D)
   break;
 case 0x93:
   /*      RES 2,E */
 
-  RES_8BIT (2, cpustate->b.E)
+  RES_8BIT (2, cpustate->E)
   break;
 case 0x94:
   /*      RES 2,H */
 
-  RES_8BIT (2, cpustate->b.H)
+  RES_8BIT (2, cpustate->H)
   break;
 case 0x95:
   /*      RES 2,L */
 
-  RES_8BIT (2, cpustate->b.L)
+  RES_8BIT (2, cpustate->L)
   break;
 case 0x96:
-  /*      RES 2,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (2, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 2,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (2, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x97:
   /*      RES 2,A */
 
-  RES_8BIT (2, cpustate->b.A)
+  RES_8BIT (2, cpustate->A)
   break;
 case 0x98:
   /*      RES 3,B */
 
-  RES_8BIT (3, cpustate->b.B)
+  RES_8BIT (3, cpustate->B)
   break;
 case 0x99:
   /*      RES 3,C */
 
-  RES_8BIT (3, cpustate->b.C)
+  RES_8BIT (3, cpustate->C)
   break;
 case 0x9A:
   /*      RES 3,D */
 
-  RES_8BIT (3, cpustate->b.D)
+  RES_8BIT (3, cpustate->D)
   break;
 case 0x9B:
   /*      RES 3,E */
 
-  RES_8BIT (3, cpustate->b.E)
+  RES_8BIT (3, cpustate->E)
   break;
 case 0x9C:
   /*      RES 3,H */
 
-  RES_8BIT (3, cpustate->b.H)
+  RES_8BIT (3, cpustate->H)
   break;
 case 0x9D:
   /*      RES 3,L */
 
-  RES_8BIT (3, cpustate->b.L)
+  RES_8BIT (3, cpustate->L)
   break;
 case 0x9E:
-  /*      RES 3,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (3, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 3,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (3, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0x9F:
   /*      RES 3,A */
 
-  RES_8BIT (3, cpustate->b.A)
+  RES_8BIT (3, cpustate->A)
   break;
 case 0xA0:
   /*      RES 4,B */
 
-  RES_8BIT (4, cpustate->b.B)
+  RES_8BIT (4, cpustate->B)
   break;
 case 0xA1:
   /*      RES 4,C */
 
-  RES_8BIT (4, cpustate->b.C)
+  RES_8BIT (4, cpustate->C)
   break;
 case 0xA2:
   /*      RES 4,D */
 
-  RES_8BIT (4, cpustate->b.D)
+  RES_8BIT (4, cpustate->D)
   break;
 case 0xA3:
   /*      RES 4,E */
 
-  RES_8BIT (4, cpustate->b.E)
+  RES_8BIT (4, cpustate->E)
   break;
 case 0xA4:
   /*      RES 4,H */
 
-  RES_8BIT (4, cpustate->b.H)
+  RES_8BIT (4, cpustate->H)
   break;
 case 0xA5:
   /*      RES 4,L */
 
-  RES_8BIT (4, cpustate->b.L)
+  RES_8BIT (4, cpustate->L)
   break;
 case 0xA6:
-  /*      RES 4,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (4, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 4,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (4, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xA7:
   /*      RES 4,A */
 
-  RES_8BIT (4, cpustate->b.A)
+  RES_8BIT (4, cpustate->A)
   break;
 case 0xA8:
   /*      RES 5,B */
 
-  RES_8BIT (5, cpustate->b.B)
+  RES_8BIT (5, cpustate->B)
   break;
 case 0xA9:
   /*      RES 5,C */
 
-  RES_8BIT (5, cpustate->b.C)
+  RES_8BIT (5, cpustate->C)
   break;
 case 0xAA:
   /*      RES 5,D */
 
-  RES_8BIT (5, cpustate->b.D)
+  RES_8BIT (5, cpustate->D)
   break;
 case 0xAB:
   /*      RES 5,E */
 
-  RES_8BIT (5, cpustate->b.E)
+  RES_8BIT (5, cpustate->E)
   break;
 case 0xAC:
   /*      RES 5,H */
 
-  RES_8BIT (5, cpustate->b.H)
+  RES_8BIT (5, cpustate->H)
   break;
 case 0xAD:
   /*      RES 5,L */
 
-  RES_8BIT (5, cpustate->b.L)
+  RES_8BIT (5, cpustate->L)
   break;
 case 0xAE:
-  /*      RES 5,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (5, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 5,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (5, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xAF:
   /*      RES 5,A */
 
-  RES_8BIT (5, cpustate->b.A)
+  RES_8BIT (5, cpustate->A)
   break;
 case 0xB0:
   /*      RES 6,B */
 
-  RES_8BIT (6, cpustate->b.B)
+  RES_8BIT (6, cpustate->B)
   break;
 case 0xB1:
   /*      RES 6,C */
 
-  RES_8BIT (6, cpustate->b.C)
+  RES_8BIT (6, cpustate->C)
   break;
 case 0xB2:
   /*      RES 6,D */
 
-  RES_8BIT (6, cpustate->b.D)
+  RES_8BIT (6, cpustate->D)
   break;
 case 0xB3:
   /*      RES 6,E */
 
-  RES_8BIT (6, cpustate->b.E)
+  RES_8BIT (6, cpustate->E)
   break;
 case 0xB4:
   /*      RES 6,H */
 
-  RES_8BIT (6, cpustate->b.H)
+  RES_8BIT (6, cpustate->H)
   break;
 case 0xB5:
   /*      RES 6,L */
 
-  RES_8BIT (6, cpustate->b.L)
+  RES_8BIT (6, cpustate->L)
   break;
 case 0xB6:
-  /*      RES 6,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (6, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 6,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (6, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xB7:
   /*      RES 6,A */
 
-  RES_8BIT (6, cpustate->b.A)
+  RES_8BIT (6, cpustate->A)
   break;
 case 0xB8:
   /*      RES 7,B */
 
-  RES_8BIT (7, cpustate->b.B)
+  RES_8BIT (7, cpustate->B)
   break;
 case 0xB9:
   /*      RES 7,C */
 
-  RES_8BIT (7, cpustate->b.C)
+  RES_8BIT (7, cpustate->C)
   break;
 case 0xBA:
   /*      RES 7,D */
 
-  RES_8BIT (7, cpustate->b.D)
+  RES_8BIT (7, cpustate->D)
   break;
 case 0xBB:
   /*      RES 7,E */
 
-  RES_8BIT (7, cpustate->b.E)
+  RES_8BIT (7, cpustate->E)
   break;
 case 0xBC:
   /*      RES 7,H */
 
-  RES_8BIT (7, cpustate->b.H)
+  RES_8BIT (7, cpustate->H)
   break;
 case 0xBD:
   /*      RES 7,L */
 
-  RES_8BIT (7, cpustate->b.L)
+  RES_8BIT (7, cpustate->L)
   break;
 case 0xBE:
-  /*      RES 7,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  RES_8BIT (7, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      RES 7,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		RES_8BIT (7, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xBF:
   /*      RES 7,A */
 
-  RES_8BIT (7, cpustate->b.A)
+  RES_8BIT (7, cpustate->A)
   break;
 case 0xC0:
   /*      SET 0,B */
 
-  SET_8BIT (0, cpustate->b.B)
+  SET_8BIT (0, cpustate->B)
   break;
 case 0xC1:
   /*      SET 0,C */
 
-  SET_8BIT (0, cpustate->b.C)
+  SET_8BIT (0, cpustate->C)
   break;
 case 0xC2:
   /*      SET 0,D */
 
-  SET_8BIT (0, cpustate->b.D)
+  SET_8BIT (0, cpustate->D)
   break;
 case 0xC3:
   /*      SET 0,E */
 
-  SET_8BIT (0, cpustate->b.E)
+  SET_8BIT (0, cpustate->E)
   break;
 case 0xC4:
   /*      SET 0,H */
 
-  SET_8BIT (0, cpustate->b.H)
+  SET_8BIT (0, cpustate->H)
   break;
 case 0xC5:
   /*      SET 0,L */
 
-  SET_8BIT (0, cpustate->b.L)
+  SET_8BIT (0, cpustate->L)
   break;
 case 0xC6:
-  /*      SET 0,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (0, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 0,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (0, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xC7:
   /*      SET 0,A */
 
-  SET_8BIT (0, cpustate->b.A)
+  SET_8BIT (0, cpustate->A)
   break;
 case 0xC8:
   /*      SET 1,B */
 
-  SET_8BIT (1, cpustate->b.B)
+  SET_8BIT (1, cpustate->B)
   break;
 case 0xC9:
   /*      SET 1,C */
 
-  SET_8BIT (1, cpustate->b.C)
+  SET_8BIT (1, cpustate->C)
   break;
 case 0xCA:
   /*      SET 1,D */
 
-  SET_8BIT (1, cpustate->b.D)
+  SET_8BIT (1, cpustate->D)
   break;
 case 0xCB:
   /*      SET 1,E */
 
-  SET_8BIT (1, cpustate->b.E)
+  SET_8BIT (1, cpustate->E)
   break;
 case 0xCC:
   /*      SET 1,H */
 
-  SET_8BIT (1, cpustate->b.H)
+  SET_8BIT (1, cpustate->H)
   break;
 case 0xCD:
   /*      SET 1,L */
 
-  SET_8BIT (1, cpustate->b.L)
+  SET_8BIT (1, cpustate->L)
   break;
 case 0xCE:
-  /*      SET 1,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (1, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 1,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (1, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xCF:
   /*      SET 1,A */
 
-  SET_8BIT (1, cpustate->b.A)
+  SET_8BIT (1, cpustate->A)
   break;
 case 0xD0:
   /*      SET 2,B */
 
-  SET_8BIT (2, cpustate->b.B)
+  SET_8BIT (2, cpustate->B)
   break;
 case 0xD1:
   /*      SET 2,C */
 
-  SET_8BIT (2, cpustate->b.C)
+  SET_8BIT (2, cpustate->C)
   break;
 case 0xD2:
   /*      SET 2,D */
 
-  SET_8BIT (2, cpustate->b.D)
+  SET_8BIT (2, cpustate->D)
   break;
 case 0xD3:
   /*      SET 2,E */
 
-  SET_8BIT (2, cpustate->b.E)
+  SET_8BIT (2, cpustate->E)
   break;
 case 0xD4:
   /*      SET 2,H */
 
-  SET_8BIT (2, cpustate->b.H)
+  SET_8BIT (2, cpustate->H)
   break;
 case 0xD5:
   /*      SET 2,L */
 
-  SET_8BIT (2, cpustate->b.L)
+  SET_8BIT (2, cpustate->L)
   break;
 case 0xD6:
-  /*      SET 2,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (2, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 2,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (2, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xD7:
   /*      SET 2,A */
 
-  SET_8BIT (2, cpustate->b.A)
+  SET_8BIT (2, cpustate->A)
   break;
 case 0xD8:
   /*      SET 3,B */
 
-  SET_8BIT (3, cpustate->b.B)
+  SET_8BIT (3, cpustate->B)
   break;
 case 0xD9:
   /*      SET 3,C */
 
-  SET_8BIT (3, cpustate->b.C)
+  SET_8BIT (3, cpustate->C)
   break;
 case 0xDA:
   /*      SET 3,D */
 
-  SET_8BIT (3, cpustate->b.D)
+  SET_8BIT (3, cpustate->D)
   break;
 case 0xDB:
   /*      SET 3,E */
 
-  SET_8BIT (3, cpustate->b.E)
+  SET_8BIT (3, cpustate->E)
   break;
 case 0xDC:
   /*      SET 3,H */
 
-  SET_8BIT (3, cpustate->b.H)
+  SET_8BIT (3, cpustate->H)
   break;
 case 0xDD:
   /*      SET 3,L */
 
-  SET_8BIT (3, cpustate->b.L)
+  SET_8BIT (3, cpustate->L)
   break;
 case 0xDE:
-  /*      SET 3,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (3, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 3,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (3, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xDF:
   /*      SET 3,A */
 
-  SET_8BIT (3, cpustate->b.A)
+  SET_8BIT (3, cpustate->A)
   break;
 case 0xE0:
   /*      SET 4,B */
 
-  SET_8BIT (4, cpustate->b.B)
+  SET_8BIT (4, cpustate->B)
   break;
 case 0xE1:
   /*      SET 4,C */
 
-  SET_8BIT (4, cpustate->b.C)
+  SET_8BIT (4, cpustate->C)
   break;
 case 0xE2:
   /*      SET 4,D */
 
-  SET_8BIT (4, cpustate->b.D)
+  SET_8BIT (4, cpustate->D)
   break;
 case 0xE3:
   /*      SET 4,E */
 
-  SET_8BIT (4, cpustate->b.E)
+  SET_8BIT (4, cpustate->E)
   break;
 case 0xE4:
   /*      SET 4,H */
 
-  SET_8BIT (4, cpustate->b.H)
+  SET_8BIT (4, cpustate->H)
   break;
 case 0xE5:
   /*      SET 4,L */
 
-  SET_8BIT (4, cpustate->b.L)
+  SET_8BIT (4, cpustate->L)
   break;
 case 0xE6:
-  /*      SET 4,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (4, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 4,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (4, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xE7:
   /*      SET 4,A */
 
-  SET_8BIT (4, cpustate->b.A)
+  SET_8BIT (4, cpustate->A)
   break;
 case 0xE8:
   /*      SET 5,B */
 
-  SET_8BIT (5, cpustate->b.B)
+  SET_8BIT (5, cpustate->B)
   break;
 case 0xE9:
   /*      SET 5,C */
 
-  SET_8BIT (5, cpustate->b.C)
+  SET_8BIT (5, cpustate->C)
   break;
 case 0xEA:
   /*      SET 5,D */
 
-  SET_8BIT (5, cpustate->b.D)
+  SET_8BIT (5, cpustate->D)
   break;
 case 0xEB:
   /*      SET 5,E */
 
-  SET_8BIT (5, cpustate->b.E)
+  SET_8BIT (5, cpustate->E)
   break;
 case 0xEC:
   /*      SET 5,H */
 
-  SET_8BIT (5, cpustate->b.H)
+  SET_8BIT (5, cpustate->H)
   break;
 case 0xED:
   /*      SET 5,L */
 
-  SET_8BIT (5, cpustate->b.L)
+  SET_8BIT (5, cpustate->L)
   break;
 case 0xEE:
-  /*      SET 5,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (5, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 5,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (5, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xEF:
   /*      SET 5,A */
 
-  SET_8BIT (5, cpustate->b.A)
+  SET_8BIT (5, cpustate->A)
   break;
 case 0xF0:
   /*      SET 6,B */
 
-  SET_8BIT (6, cpustate->b.B)
+  SET_8BIT (6, cpustate->B)
   break;
 case 0xF1:
   /*      SET 6,C */
 
-  SET_8BIT (6, cpustate->b.C)
+  SET_8BIT (6, cpustate->C)
   break;
 case 0xF2:
   /*      SET 6,D */
 
-  SET_8BIT (6, cpustate->b.D)
+  SET_8BIT (6, cpustate->D)
   break;
 case 0xF3:
   /*      SET 6,E */
 
-  SET_8BIT (6, cpustate->b.E)
+  SET_8BIT (6, cpustate->E)
   break;
 case 0xF4:
   /*      SET 6,H */
 
-  SET_8BIT (6, cpustate->b.H)
+  SET_8BIT (6, cpustate->H)
   break;
 case 0xF5:
   /*      SET 6,L */
 
-  SET_8BIT (6, cpustate->b.L)
+  SET_8BIT (6, cpustate->L)
   break;
 case 0xF6:
-  /*      SET 6,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (6, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 6,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (6, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xF7:
   /*      SET 6,A */
 
-  SET_8BIT (6, cpustate->b.A)
+  SET_8BIT (6, cpustate->A)
   break;
 case 0xF8:
   /*      SET 7,B */
 
-  SET_8BIT (7, cpustate->b.B)
+  SET_8BIT (7, cpustate->B)
   break;
 case 0xF9:
   /*      SET 7,C */
 
-  SET_8BIT (7, cpustate->b.C)
+  SET_8BIT (7, cpustate->C)
   break;
 case 0xFA:
   /*      SET 7,D */
 
-  SET_8BIT (7, cpustate->b.D)
+  SET_8BIT (7, cpustate->D)
   break;
 case 0xFB:
   /*      SET 7,E */
 
-  SET_8BIT (7, cpustate->b.E)
+  SET_8BIT (7, cpustate->E)
   break;
 case 0xFC:
   /*      SET 7,H */
 
-  SET_8BIT (7, cpustate->b.H)
+  SET_8BIT (7, cpustate->H)
   break;
 case 0xFD:
   /*      SET 7,L */
 
-  SET_8BIT (7, cpustate->b.L)
+  SET_8BIT (7, cpustate->L)
   break;
 case 0xFE:
-  /*      SET 7,(HL) */
-
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
-  SET_8BIT (7, x)
-  mem_WriteByte (cpustate, cpustate->w.HL, x);
-  break;
+	/*      SET 7,(HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+
+		x = mem_ReadByte (cpustate, addr);
+		SET_8BIT (7, x)
+		mem_WriteByte (cpustate, addr, x);
+	}
+	break;
 case 0xFF:
   /*      SET 7,A */
 
-  SET_8BIT (7, cpustate->b.A)
+  SET_8BIT (7, cpustate->A)
   break;
diff -Nru src-old/emu/cpu/lr35902/opc_main.h src/emu/cpu/lr35902/opc_main.h
--- src-old/emu/cpu/lr35902/opc_main.h	2009-09-14 20:17:19.000000000 +0200
+++ src/emu/cpu/lr35902/opc_main.h	2012-02-25 22:22:21.000000000 +0100
@@ -3,10 +3,10 @@
   register UINT8 r,f; \
   x++; \
   r=(x);  \
-  f=(UINT8)(cpustate->b.F&FLAG_C); \
+  f=(UINT8)(cpustate->F&FLAG_C); \
   if( r==0 )       f|=FLAG_Z; \
   if( (r&0xF)==0 ) f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	DEC_8BIT(x) \
@@ -14,51 +14,52 @@
   register UINT8 r,f; \
   x--; \
   r=(x);  \
-  f=(UINT8)((cpustate->b.F&FLAG_C)|FLAG_N); \
+  f=(UINT8)((cpustate->F&FLAG_C)|FLAG_N); \
   if( r==0 )       f|=FLAG_Z; \
   if( (r&0xF)==0xF ) f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	ADD_HL_RR(x) \
 { \
   register UINT32 r1,r2; \
   register UINT8 f; \
-  r1=cpustate->w.HL+(x); \
-  r2=(cpustate->w.HL&0xFFF)+((x)&0xFFF); \
-  f=(UINT8)(cpustate->b.F&FLAG_Z); \
+  r1=((cpustate->H<<8)|cpustate->L)+(x); \
+  r2=(((cpustate->H<<8)|cpustate->L)&0xFFF)+((x)&0xFFF); \
+  f=(UINT8)(cpustate->F&FLAG_Z); \
   if( r1>0xFFFF ) f|=FLAG_C; \
   if( r2>0x0FFF ) f|=FLAG_H; \
-  cpustate->w.HL=(UINT16)r1; \
-  cpustate->b.F=f; \
+  cpustate->L = r1; \
+  cpustate->H = r1 >> 8; \
+  cpustate->F=f; \
 }
 
 #define	ADD_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->b.A&0xF)+((x)&0xF)); \
-  r2=(UINT16)(cpustate->b.A+(x)); \
-  cpustate->b.A=(UINT8)r2; \
+  r1=(UINT16)((cpustate->A&0xF)+((x)&0xF)); \
+  r2=(UINT16)(cpustate->A+(x)); \
+  cpustate->A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_Z; \
     else f=0; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	SUB_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->b.A&0xF)-((x)&0xF)); \
-  r2=(UINT16)(cpustate->b.A-(x)); \
-  cpustate->b.A=(UINT8)r2; \
+  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)); \
+  r2=(UINT16)(cpustate->A-(x)); \
+  cpustate->A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 /*
@@ -66,15 +67,15 @@
    { \
    register UINT16 r; \
    register UINT8 f; \
-   r=(UINT16)(cpustate->b.A-(x)); \
+   r=(UINT16)(cpustate->A-(x)); \
    if( ((UINT8)r)==0 ) \
    f=FLAG_N|FLAG_Z; \
    else \
    f=FLAG_N; \
    f|=(UINT8)((r>>8)&FLAG_C); \
-   if( (r^cpustate->b.A^(x))&0x10 ) \
+   if( (r^cpustate->A^(x))&0x10 ) \
    f|=FLAG_H; \
-   cpustate->b.F=f; \
+   cpustate->F=f; \
    }
  */
 
@@ -82,1320 +83,1321 @@
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->b.A&0xF)-((x)&0xF)); \
-  r2=(UINT16)(cpustate->b.A-(x)); \
+  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)); \
+  r2=(UINT16)(cpustate->A-(x)); \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	SBC_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->b.A&0xF)-((x)&0xF)-((cpustate->b.F&FLAG_C)?1:0)); \
-  r2=(UINT16)(cpustate->b.A-(x)-((cpustate->b.F&FLAG_C)?1:0)); \
-  cpustate->b.A=(UINT8)r2; \
+  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)-((cpustate->F&FLAG_C)?1:0)); \
+  r2=(UINT16)(cpustate->A-(x)-((cpustate->F&FLAG_C)?1:0)); \
+  cpustate->A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	ADC_A_X(x) \
 { \
   register UINT16 r1,r2;  \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->b.A&0xF)+((x)&0xF)+((cpustate->b.F&FLAG_C)?1:0));  \
-  r2=(UINT16)(cpustate->b.A+(x)+((cpustate->b.F&FLAG_C)?1:0)); \
-  if( (cpustate->b.A=(UINT8)r2)==0 ) f=FLAG_Z; \
+  r1=(UINT16)((cpustate->A&0xF)+((x)&0xF)+((cpustate->F&FLAG_C)?1:0));  \
+  r2=(UINT16)(cpustate->A+(x)+((cpustate->F&FLAG_C)?1:0)); \
+  if( (cpustate->A=(UINT8)r2)==0 ) f=FLAG_Z; \
     else f=0; \
   if( r2>0xFF )	f|=FLAG_C; \
   if( r1>0xF )	f|=FLAG_H; \
-  cpustate->b.F=f; \
+  cpustate->F=f; \
 }
 
 #define	AND_A_X(x) \
-  if( (cpustate->b.A&=(x))==0 ) \
-    cpustate->b.F=FLAG_H|FLAG_Z; \
+  if( (cpustate->A&=(x))==0 ) \
+    cpustate->F=FLAG_H|FLAG_Z; \
   else \
-    cpustate->b.F=FLAG_H;
+    cpustate->F=FLAG_H;
 
 #define XOR_A_X(x) \
-  if( (cpustate->b.A^=(x))==0 ) \
-    cpustate->b.F=FLAG_Z; \
+  if( (cpustate->A^=(x))==0 ) \
+    cpustate->F=FLAG_Z; \
   else \
-    cpustate->b.F=0;
+    cpustate->F=0;
 
 #define	OR_A_X(x) \
-  if( (cpustate->b.A|=(x))==0 ) \
-    cpustate->b.F=FLAG_Z; \
+  if( (cpustate->A|=(x))==0 ) \
+    cpustate->F=FLAG_Z; \
   else \
-    cpustate->b.F=0;
+    cpustate->F=0;
 
+#define POP(x,y) \
+	y = mem_ReadByte( cpustate, cpustate->SP++ ); \
+	x = mem_ReadByte( cpustate, cpustate->SP++ );
+
+#define PUSH(x,y) \
+	cpustate->SP--; \
+	mem_WriteByte( cpustate, cpustate->SP, x ); \
+	cpustate->SP--; \
+	mem_WriteByte( cpustate, cpustate->SP, y );
 
 case 0x00: /*      NOP */
   break;
 case 0x01: /*      LD BC,n16 */
-  cpustate->w.BC = mem_ReadWord (cpustate, cpustate->w.PC);
-  cpustate->w.PC += 2;
-  break;
+	cpustate->C = mem_ReadOp (cpustate);
+	cpustate->B = mem_ReadOp (cpustate);
+	break;
 case 0x02: /*      LD (BC),A */
-  mem_WriteByte (cpustate, cpustate->w.BC, cpustate->b.A);
+  mem_WriteByte (cpustate, ( cpustate->B << 8 ) | cpustate->C, cpustate->A);
   break;
 case 0x03: /*      INC BC */
-
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.B == 0xFE)
+  if (cpustate->B == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-  cpustate->w.BC += 1;
-  break;
+	cpustate->C++;
+	if ( cpustate->C == 0 )
+	{
+		cpustate->B++;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x04: /*      INC B */
-
-  INC_8BIT (cpustate->b.B)
-  break;
+	INC_8BIT (cpustate->B)
+	break;
 case 0x05: /*      DEC B */
 
-  DEC_8BIT (cpustate->b.B)
+  DEC_8BIT (cpustate->B)
   break;
 case 0x06: /*      LD B,n8 */
 
-  cpustate->b.B = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->B = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x07: /*      RLCA */
 
-  cpustate->b.A = (UINT8) ((cpustate->b.A << 1) | (cpustate->b.A >> 7));
-  if (cpustate->b.A & 1)
+  cpustate->A = (UINT8) ((cpustate->A << 1) | (cpustate->A >> 7));
+  if (cpustate->A & 1)
   {
-    cpustate->b.F = FLAG_C;
+    cpustate->F = FLAG_C;
   }
   else
   {
-    cpustate->b.F = 0;
+    cpustate->F = 0;
   }
   break;
 case 0x08: /*      LD (n16),SP */
 
-  mem_WriteWord (cpustate, mem_ReadWord (cpustate, cpustate->w.PC), cpustate->w.SP);
-  cpustate->w.PC += 2;
+  mem_WriteWord (cpustate, mem_ReadWord (cpustate, cpustate->PC), cpustate->SP);
+  cpustate->PC += 2;
   break;
 case 0x09: /*      ADD HL,BC */
-
-  ADD_HL_RR (cpustate->w.BC)
-  break;
+	ADD_HL_RR ((cpustate->B<<8)|cpustate->C)
+	CYCLES_PASSED( 4 );
+	break;
 case 0x0A: /*      LD A,(BC) */
 
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.BC);
+  cpustate->A = mem_ReadByte (cpustate, (cpustate->B<<8)|cpustate->C);
   break;
 case 0x0B: /*      DEC BC */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.B == 0xFE)
+  if (cpustate->B == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->w.BC -= 1;
-  break;
+	cpustate->C--;
+	if ( cpustate->C == 0xFF )
+	{
+		cpustate->B--;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x0C: /*      INC C */
 
-  INC_8BIT (cpustate->b.C)
+  INC_8BIT (cpustate->C)
   break;
 case 0x0D: /*      DEC C */
 
-  DEC_8BIT (cpustate->b.C)
+  DEC_8BIT (cpustate->C)
   break;
 case 0x0E: /*      LD C,n8 */
 
-  cpustate->b.C = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->C = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x0F: /*      RRCA */
 
-  cpustate->b.A = (UINT8) ((cpustate->b.A >> 1) | (cpustate->b.A << 7));
-  cpustate->b.F = 0;
-  if (cpustate->b.A & 0x80)
+  cpustate->A = (UINT8) ((cpustate->A >> 1) | (cpustate->A << 7));
+  cpustate->F = 0;
+  if (cpustate->A & 0x80)
   {
-    cpustate->b.F |= FLAG_C;
+    cpustate->F |= FLAG_C;
   }
   break;
 case 0x10: /*      STOP */
-  if ( cpustate->w.gb_speed_change_pending ) {
-    cpustate->w.gb_speed = ( cpustate->w.gb_speed == 1 ) ? 2 : 1;
+  if ( cpustate->gb_speed_change_pending ) {
+    cpustate->gb_speed = ( cpustate->gb_speed == 1 ) ? 2 : 1;
   }
-  cpustate->w.gb_speed_change_pending = 0;
+  cpustate->gb_speed_change_pending = 0;
   break;
 case 0x11: /*      LD DE,n16 */
-
-  cpustate->w.DE = mem_ReadWord (cpustate, cpustate->w.PC);
-  cpustate->w.PC += 2;
-  break;
+	cpustate->E = mem_ReadOp (cpustate);
+	cpustate->D = mem_ReadOp (cpustate);
+	break;
 case 0x12: /*      LD (DE),A */
-  mem_WriteByte (cpustate, cpustate->w.DE, cpustate->b.A);
+  mem_WriteByte (cpustate, ( cpustate->D << 8 ) | cpustate->E, cpustate->A);
   break;
 case 0x13: /*      INC DE */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.D == 0xFE)
+  if (cpustate->D == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->w.DE += 1;
-  break;
+	cpustate->E++;
+	if ( cpustate->E == 0 )
+	{
+		cpustate->D++;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x14: /*      INC D */
 
-  INC_8BIT (cpustate->b.D)
+  INC_8BIT (cpustate->D)
   break;
 case 0x15: /*      DEC D */
 
-  DEC_8BIT (cpustate->b.D)
+  DEC_8BIT (cpustate->D)
   break;
 case 0x16: /*      LD D,n8 */
 
-  cpustate->b.D = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->D = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x17: /*      RLA */
 
-  x = (cpustate->b.A & 0x80) ? FLAG_C : 0;
+  x = (cpustate->A & 0x80) ? FLAG_C : 0;
 
-  cpustate->b.A = (UINT8) ((cpustate->b.A << 1) | ((cpustate->b.F & FLAG_C) ? 1 : 0));
-  cpustate->b.F = x;
+  cpustate->A = (UINT8) ((cpustate->A << 1) | ((cpustate->F & FLAG_C) ? 1 : 0));
+  cpustate->F = x;
   break;
 case 0x18: /*      JR      n8 */
   {
 	INT8 offset;
 
-    offset = mem_ReadByte (cpustate, cpustate->w.PC++);
-    cpustate->w.PC += offset;
+    offset = mem_ReadByte (cpustate, cpustate->PC++);
+    cpustate->PC += offset;
+	CYCLES_PASSED( 4 );
   }
   break;
 case 0x19: /*      ADD HL,DE */
-
-  ADD_HL_RR (cpustate->w.DE)
-  break;
+	ADD_HL_RR (( cpustate->D << 8 ) | cpustate->E)
+	CYCLES_PASSED( 4 );
+	break;
 case 0x1A: /*      LD A,(DE) */
 
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.DE);
+  cpustate->A = mem_ReadByte (cpustate, ( cpustate->D << 8 ) | cpustate->E);
   break;
 case 0x1B: /*      DEC DE */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.D == 0xFE)
+  if (cpustate->D == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->w.DE -= 1;
-  break;
+	cpustate->E--;
+	if ( cpustate->E == 0xFF )
+	{
+		cpustate->D--;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x1C: /*      INC E */
 
-  INC_8BIT (cpustate->b.E)
+  INC_8BIT (cpustate->E)
   break;
 case 0x1D: /*      DEC E */
 
-  DEC_8BIT (cpustate->b.E)
+  DEC_8BIT (cpustate->E)
   break;
 case 0x1E: /*      LD E,n8 */
 
-  cpustate->b.E = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->E = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x1F: /*      RRA */
 
-  x = (cpustate->b.A & 1) ? FLAG_C : 0;
+  x = (cpustate->A & 1) ? FLAG_C : 0;
 
-  cpustate->b.A = (UINT8) ((cpustate->b.A >> 1) | ((cpustate->b.F & FLAG_C) ? 0x80 : 0));
-  cpustate->b.F = x;
+  cpustate->A = (UINT8) ((cpustate->A >> 1) | ((cpustate->F & FLAG_C) ? 0x80 : 0));
+  cpustate->F = x;
   break;
 case 0x20: /*      JR NZ,n8 */
-
-  if (cpustate->b.F & FLAG_Z)
-  {
-    cpustate->w.PC++;
-  }
-  else
-  {
-	INT8 offset;
-
-    offset = mem_ReadByte (cpustate, cpustate->w.PC++);
-    cpustate->w.PC += offset;
-    CYCLES_PASSED( 4 );
-  }
-  break;
+	{
+		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
+		if (! (cpustate->F & FLAG_Z) )
+		{
+			cpustate->PC += offset;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0x21: /*      LD HL,n16 */
-
-  cpustate->w.HL = mem_ReadWord (cpustate, cpustate->w.PC);
-  cpustate->w.PC += 2;
-  break;
+	cpustate->L = mem_ReadOp (cpustate);
+	cpustate->H = mem_ReadOp (cpustate);
+	break;
 case 0x22: /*      LD (HL+),A */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.A);
-  cpustate->w.HL += 1;
-  break;
+	mem_WriteByte (cpustate, (cpustate->H << 8 ) | cpustate->L, cpustate->A);
+	cpustate->L++;
+	if ( cpustate->L == 0 )
+	{
+		cpustate->H++;
+	}
+	break;
 case 0x23: /*      INC HL */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->w.HL += 1;
-  break;
+	cpustate->L++;
+	if ( cpustate->L == 0 )
+	{
+		cpustate->H++;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x24: /*      INC H */
 
-  INC_8BIT (cpustate->b.H);
+  INC_8BIT (cpustate->H);
   break;
 case 0x25: /*      DEC H */
 
-  DEC_8BIT (cpustate->b.H);
+  DEC_8BIT (cpustate->H);
   break;
 case 0x26: /*      LD H,n8 */
 
-  cpustate->b.H = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->H = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x27: /*      DAA */
 	{
-		int tmp = cpustate->b.A;
+		int tmp = cpustate->A;
 
-		if ( ! ( cpustate->b.F & FLAG_N ) ) {
-			if ( ( cpustate->b.F & FLAG_H ) || ( tmp & 0x0F ) > 9 )
+		if ( ! ( cpustate->F & FLAG_N ) ) {
+			if ( ( cpustate->F & FLAG_H ) || ( tmp & 0x0F ) > 9 )
 				tmp += 6;
-			if ( ( cpustate->b.F & FLAG_C ) || tmp > 0x9F )
+			if ( ( cpustate->F & FLAG_C ) || tmp > 0x9F )
 				tmp += 0x60;
 		} else {
-			if ( cpustate->b.F & FLAG_H ) {
+			if ( cpustate->F & FLAG_H ) {
 				tmp -= 6;
-				if ( ! ( cpustate->b.F & FLAG_C ) )
+				if ( ! ( cpustate->F & FLAG_C ) )
 					tmp &= 0xFF;
 			}
-			if ( cpustate->b.F & FLAG_C )
+			if ( cpustate->F & FLAG_C )
 					tmp -= 0x60;
 		}
-		cpustate->b.F &= ~ ( FLAG_H | FLAG_Z );
+		cpustate->F &= ~ ( FLAG_H | FLAG_Z );
 		if ( tmp & 0x100 )
-			cpustate->b.F |= FLAG_C;
-		cpustate->b.A = tmp & 0xFF;
-		if ( ! cpustate->b.A )
-			cpustate->b.F |= FLAG_Z;
+			cpustate->F |= FLAG_C;
+		cpustate->A = tmp & 0xFF;
+		if ( ! cpustate->A )
+			cpustate->F |= FLAG_Z;
 	}
   break;
 case 0x28: /*      JR Z,n8 */
+	{
+		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);;
 
-  if (cpustate->b.F & FLAG_Z)
-  {
-	INT8 offset;
-
-    offset = mem_ReadByte (cpustate, cpustate->w.PC++);
-    cpustate->w.PC += offset;
-
-    CYCLES_PASSED( 4 );
-  }
-  else
-  {
-    cpustate->w.PC += 1;
-  }
-  break;
+		if (cpustate->F & FLAG_Z)
+		{
+			cpustate->PC += offset;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0x29: /*      ADD HL,HL */
-
-  ADD_HL_RR (cpustate->w.HL)
-  break;
+	ADD_HL_RR ((cpustate->H << 8 ) | cpustate->L)
+	CYCLES_PASSED( 4 );
+	break;
 case 0x2A: /*      LD A,(HL+) */
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.HL);
-  cpustate->w.HL += 1;
-  break;
+	cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+	cpustate->L++;
+	if ( cpustate->L == 0 )
+	{
+		cpustate->H++;
+	}
+	break;
 case 0x2B: /*      DEC HL */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->w.HL -= 1;
-  break;
+	cpustate->L--;
+	if ( cpustate->L == 0xFF )
+	{
+		cpustate->H--;
+	}
+	CYCLES_PASSED( 4 );
+	break;
 case 0x2C: /*      INC L */
 
-  INC_8BIT (cpustate->b.L);
+  INC_8BIT (cpustate->L);
   break;
 case 0x2D: /*      DEC L */
 
-  DEC_8BIT (cpustate->b.L);
+  DEC_8BIT (cpustate->L);
   break;
 case 0x2E: /*      LD L,n8 */
 
-  cpustate->b.L = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->L = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x2F: /*      CPL */
 
-  cpustate->b.A = ~cpustate->b.A;
-  cpustate->b.F |= FLAG_N | FLAG_H;
+  cpustate->A = ~cpustate->A;
+  cpustate->F |= FLAG_N | FLAG_H;
   break;
 case 0x30: /*      JR NC,n8 */
+	{
+		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
 
-  if (cpustate->b.F & FLAG_C)
-  {
-    cpustate->w.PC += 1;
-  }
-  else
-  {
-	INT8 offset;
-
-    offset = mem_ReadByte (cpustate, cpustate->w.PC++);
-    cpustate->w.PC += offset;
-    CYCLES_PASSED( 4 );
-  }
-  break;
+		if ( ! (cpustate->F & FLAG_C) )
+		{
+			cpustate->PC += offset;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0x31: /*      LD SP,n16 */
 
-  cpustate->w.SP = mem_ReadWord (cpustate, cpustate->w.PC);
-  cpustate->w.PC += 2;
+  cpustate->SP = mem_ReadWord (cpustate, cpustate->PC);
+  cpustate->PC += 2;
   break;
 case 0x32: /*      LD (HL-),A */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.A);
-  cpustate->w.HL -= 1;
-  break;
+	mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->A);
+	cpustate->L--;
+	if ( cpustate->L == 0xFF )
+	{
+		cpustate->H--;
+	}
+	break;
 case 0x33: /*      INC SP */
-
-  cpustate->w.SP += 1;
-  break;
+	cpustate->SP += 1;
+	CYCLES_PASSED( 4 );
+	break;
 case 0x34: /*      INC (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		register UINT8 r, f;
 
-  {
-	register UINT8 r, f;
-
-	f = (UINT8) (cpustate->b.F & FLAG_C);
-	r = (UINT8) (mem_ReadByte (cpustate, cpustate->w.HL) + 1);
-    mem_WriteByte (cpustate, cpustate->w.HL, r);
+		f = (UINT8) (cpustate->F & FLAG_C);
+		r = mem_ReadByte (cpustate, addr);
+		r += 1;
+		mem_WriteByte (cpustate, addr, r);
 
-    if (r == 0)
-      f |= FLAG_Z;
+		if (r == 0)
+			f |= FLAG_Z;
 
-    if ((r & 0xF) == 0)
-      f |= FLAG_H;
+		if ((r & 0xF) == 0)
+			f |= FLAG_H;
 
-    cpustate->b.F = f;
-  }
-  break;
+		cpustate->F = f;
+	}
+	break;
 case 0x35: /*      DEC (HL) */
+	{
+		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		register UINT8 r, f;
 
-  {
-	register UINT8 r, f;
-
-	f = (UINT8) ((cpustate->b.F & FLAG_C) | FLAG_N);
-	r = (UINT8) (mem_ReadByte (cpustate, cpustate->w.HL) - 1);
-    mem_WriteByte (cpustate, cpustate->w.HL, r);
+		f = (UINT8) ((cpustate->F & FLAG_C) | FLAG_N);
+		r = mem_ReadByte (cpustate, addr);
+		r -= 1;
+		mem_WriteByte (cpustate, addr, r);
 
-    if (r == 0)
-      f |= FLAG_Z;
+		if (r == 0)
+			f |= FLAG_Z;
 
-    if ((r & 0xF) == 0xF)
-      f |= FLAG_H;
+		if ((r & 0xF) == 0xF)
+			f |= FLAG_H;
 
-    cpustate->b.F = f;
-  }
-  break;
+		cpustate->F = f;
+	}
+	break;
 case 0x36: /*      LD (HL),n8 */
-  /* FIXED / broken ? */
-  mem_WriteByte (cpustate, cpustate->w.HL, mem_ReadByte (cpustate, cpustate->w.PC++));
-  break;
+	{
+		UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
+		mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, v);
+	}
+	break;
 case 0x37: /*      SCF */
 
-  cpustate->b.F = (UINT8) ((cpustate->b.F & FLAG_Z) | FLAG_C);
+  cpustate->F = (UINT8) ((cpustate->F & FLAG_Z) | FLAG_C);
   break;
 case 0x38: /*      JR C,n8 */
+	{
+		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
 
-  if (cpustate->b.F & FLAG_C)
-  {
-	INT8 offset;
-
-    offset = mem_ReadByte (cpustate, cpustate->w.PC++);
-    cpustate->w.PC += offset;
-
-    CYCLES_PASSED( 4 );
-  }
-  else
-  {
-    cpustate->w.PC += 1;
-  }
-  break;
+		if (cpustate->F & FLAG_C)
+		{
+			cpustate->PC += offset;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0x39: /*      ADD HL,SP */
-  ADD_HL_RR (cpustate->w.SP)
-  break;
+	ADD_HL_RR (cpustate->SP)
+	CYCLES_PASSED( 4 );
+	break;
 case 0x3A: /*      LD A,(HL-) */
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->b.H == 0xFE)
+  if (cpustate->H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.HL);
-  cpustate->w.HL -= 1;
-  break;
+	cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+	cpustate->L--;
+	if ( cpustate->L == 0xFF )
+	{
+		cpustate->H--;
+	}
+	break;
 case 0x3B: /*      DEC SP */
-
-  cpustate->w.SP -= 1;
-  break;
+	cpustate->SP -= 1;
+	CYCLES_PASSED( 4 );
+	break;
 case 0x3C: /*      INC     A */
 
-  INC_8BIT (cpustate->b.A);
+  INC_8BIT (cpustate->A);
   break;
 case 0x3D: /*      DEC     A */
 
-  DEC_8BIT (cpustate->b.A);
+  DEC_8BIT (cpustate->A);
   break;
 case 0x3E: /*      LD A,n8 */
 
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.PC++);
+  cpustate->A = mem_ReadByte (cpustate, cpustate->PC++);
   break;
 case 0x3F: /*      CCF */
 
-  cpustate->b.F = (UINT8) ((cpustate->b.F & FLAG_Z) | ((cpustate->b.F & FLAG_C) ? 0 : FLAG_C));
+  cpustate->F = (UINT8) ((cpustate->F & FLAG_Z) | ((cpustate->F & FLAG_C) ? 0 : FLAG_C));
   break;
 case 0x40: /*      LD B,B */
   break;
 case 0x41: /*      LD B,C */
 
-  cpustate->b.B = cpustate->b.C;
+  cpustate->B = cpustate->C;
   break;
 case 0x42: /*      LD B,D */
 
-  cpustate->b.B = cpustate->b.D;
+  cpustate->B = cpustate->D;
   break;
 case 0x43: /*      LD B,E */
 
-  cpustate->b.B = cpustate->b.E;
+  cpustate->B = cpustate->E;
   break;
 case 0x44: /*      LD B,H */
 
-  cpustate->b.B = cpustate->b.H;
+  cpustate->B = cpustate->H;
   break;
 case 0x45: /*      LD B,L */
 
-  cpustate->b.B = cpustate->b.L;
+  cpustate->B = cpustate->L;
   break;
 case 0x46: /*      LD B,(HL) */
 
-  cpustate->b.B = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->B = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x47: /*      LD B,A */
 
-  cpustate->b.B = cpustate->b.A;
+  cpustate->B = cpustate->A;
   break;
 case 0x48: /*      LD C,B */
 
-  cpustate->b.C = cpustate->b.B;
+  cpustate->C = cpustate->B;
   break;
 case 0x49: /*      LD C,C */
   break;
 case 0x4A: /*      LD C,D */
 
-  cpustate->b.C = cpustate->b.D;
+  cpustate->C = cpustate->D;
   break;
 case 0x4B: /*      LD C,E */
 
-  cpustate->b.C = cpustate->b.E;
+  cpustate->C = cpustate->E;
   break;
 case 0x4C: /*      LD C,H */
 
-  cpustate->b.C = cpustate->b.H;
+  cpustate->C = cpustate->H;
   break;
 case 0x4D: /*      LD C,L */
 
-  cpustate->b.C = cpustate->b.L;
+  cpustate->C = cpustate->L;
   break;
 case 0x4E: /*      LD C,(HL) */
 
-  cpustate->b.C = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->C = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x4F: /*      LD C,A */
 
-  cpustate->b.C = cpustate->b.A;
+  cpustate->C = cpustate->A;
   break;
 case 0x50: /*      LD D,B */
 
-  cpustate->b.D = cpustate->b.B;
+  cpustate->D = cpustate->B;
   break;
 case 0x51: /*      LD D,C */
 
-  cpustate->b.D = cpustate->b.C;
+  cpustate->D = cpustate->C;
   break;
 case 0x52: /*      LD D,D */
   break;
 case 0x53: /*      LD D,E */
 
-  cpustate->b.D = cpustate->b.E;
+  cpustate->D = cpustate->E;
   break;
 case 0x54: /*      LD D,H */
 
-  cpustate->b.D = cpustate->b.H;
+  cpustate->D = cpustate->H;
   break;
 case 0x55: /*      LD D,L */
 
-  cpustate->b.D = cpustate->b.L;
+  cpustate->D = cpustate->L;
   break;
 case 0x56: /*      LD D,(HL) */
 
-  cpustate->b.D = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->D = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x57: /*      LD D,A */
 
-  cpustate->b.D = cpustate->b.A;
+  cpustate->D = cpustate->A;
   break;
 case 0x58: /*      LD E,B */
 
-  cpustate->b.E = cpustate->b.B;
+  cpustate->E = cpustate->B;
   break;
 case 0x59: /*      LD E,C */
 
-  cpustate->b.E = cpustate->b.C;
+  cpustate->E = cpustate->C;
   break;
 case 0x5A: /*      LD E,D */
 
-  cpustate->b.E = cpustate->b.D;
+  cpustate->E = cpustate->D;
   break;
 case 0x5B: /*      LD E,E */
   break;
 case 0x5C: /*      LD E,H */
 
-  cpustate->b.E = cpustate->b.H;
+  cpustate->E = cpustate->H;
   break;
 case 0x5D: /*      LD E,L */
 
-  cpustate->b.E = cpustate->b.L;
+  cpustate->E = cpustate->L;
   break;
 case 0x5E: /*      LD E,(HL) */
 
-  cpustate->b.E = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->E = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x5F: /*      LD E,A */
 
-  cpustate->b.E = cpustate->b.A;
+  cpustate->E = cpustate->A;
   break;
 case 0x60: /*      LD H,B */
 
-  cpustate->b.H = cpustate->b.B;
+  cpustate->H = cpustate->B;
   break;
 case 0x61: /*      LD H,C */
 
-  cpustate->b.H = cpustate->b.C;
+  cpustate->H = cpustate->C;
   break;
 case 0x62: /*      LD H,D */
 
-  cpustate->b.H = cpustate->b.D;
+  cpustate->H = cpustate->D;
   break;
 case 0x63: /*      LD H,E */
 
-  cpustate->b.H = cpustate->b.E;
+  cpustate->H = cpustate->E;
   break;
 case 0x64: /*      LD H,H */
   break;
 case 0x65: /*      LD H,L */
 
-  cpustate->b.H = cpustate->b.L;
+  cpustate->H = cpustate->L;
   break;
 case 0x66: /*      LD H,(HL) */
 
-  cpustate->b.H = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->H = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x67: /*      LD H,A */
 
-  cpustate->b.H = cpustate->b.A;
+  cpustate->H = cpustate->A;
   break;
 case 0x68: /*      LD L,B */
 
-  cpustate->b.L = cpustate->b.B;
+  cpustate->L = cpustate->B;
   break;
 case 0x69: /*      LD L,C */
 
-  cpustate->b.L = cpustate->b.C;
+  cpustate->L = cpustate->C;
   break;
 case 0x6A: /*      LD L,D */
-  cpustate->b.L = cpustate->b.D;
+  cpustate->L = cpustate->D;
   break;
 case 0x6B: /*      LD L,E */
 
-  cpustate->b.L = cpustate->b.E;
+  cpustate->L = cpustate->E;
   break;
 case 0x6C: /*      LD L,H */
 
-  cpustate->b.L = cpustate->b.H;
+  cpustate->L = cpustate->H;
   break;
 case 0x6D: /*      LD L,L */
   break;
 case 0x6E: /*      LD L,(HL) */
 
-  cpustate->b.L = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->L = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x6F: /*      LD L,A */
 
-  cpustate->b.L = cpustate->b.A;
+  cpustate->L = cpustate->A;
   break;
 case 0x70: /*      LD (HL),B */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.B);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->B);
   break;
 case 0x71: /*      LD (HL),C */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.C);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->C);
   break;
 case 0x72: /*      LD (HL),D */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.D);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->D);
   break;
 case 0x73: /*      LD (HL),E */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.E);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->E);
   break;
 case 0x74: /*      LD (HL),H */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.H);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->H);
   break;
 case 0x75: /*      LD (HL),L */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.L);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->L);
   break;
 case 0x76: /*      HALT */
-	cpustate->w.enable |= HALTED;
-	cpustate->w.PC--;
+	cpustate->enable |= HALTED;
+	cpustate->PC--;
   break;
 case 0x77: /*      LD (HL),A */
 
-  mem_WriteByte (cpustate, cpustate->w.HL, cpustate->b.A);
+  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->A);
   break;
 case 0x78: /*      LD A,B */
 
-  cpustate->b.A = cpustate->b.B;
+  cpustate->A = cpustate->B;
   break;
 case 0x79: /*      LD A,C */
 
-  cpustate->b.A = cpustate->b.C;
+  cpustate->A = cpustate->C;
   break;
 case 0x7A: /*      LD A,D */
 
-  cpustate->b.A = cpustate->b.D;
+  cpustate->A = cpustate->D;
   break;
 case 0x7B: /*      LD A,E */
 
-  cpustate->b.A = cpustate->b.E;
+  cpustate->A = cpustate->E;
   break;
 case 0x7C: /*      LD A,H */
 
-  cpustate->b.A = cpustate->b.H;
+  cpustate->A = cpustate->H;
   break;
 case 0x7D: /*      LD A,L */
 
-  cpustate->b.A = cpustate->b.L;
+  cpustate->A = cpustate->L;
   break;
 case 0x7E: /*      LD A,(HL) */
 
-  cpustate->b.A = mem_ReadByte (cpustate, cpustate->w.HL);
+  cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
   break;
 case 0x7F: /*      LD A,A */
   break;
 case 0x80: /*      ADD A,B */
 
-  ADD_A_X (cpustate->b.B)
+  ADD_A_X (cpustate->B)
   break;
 case 0x81: /*      ADD A,C */
 
-  ADD_A_X (cpustate->b.C)
+  ADD_A_X (cpustate->C)
   break;
 case 0x82: /*      ADD A,D */
 
-  ADD_A_X (cpustate->b.D)
+  ADD_A_X (cpustate->D)
   break;
 case 0x83: /*      ADD A,E */
 
-  ADD_A_X (cpustate->b.E)
+  ADD_A_X (cpustate->E)
   break;
 case 0x84: /*      ADD A,H */
 
-  ADD_A_X (cpustate->b.H)
+  ADD_A_X (cpustate->H)
   break;
 case 0x85: /*      ADD A,L */
 
-  ADD_A_X (cpustate->b.L)
+  ADD_A_X (cpustate->L)
   break;
 case 0x86: /*      ADD A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   ADD_A_X (x)
   break;
 case 0x87: /*      ADD A,A */
 
-  ADD_A_X (cpustate->b.A)
+  ADD_A_X (cpustate->A)
   break;
 case 0x88: /*      ADC A,B */
 
-  ADC_A_X (cpustate->b.B)
+  ADC_A_X (cpustate->B)
   break;
 case 0x89: /*      ADC A,C */
 
-  ADC_A_X (cpustate->b.C)
+  ADC_A_X (cpustate->C)
   break;
 case 0x8A: /*      ADC A,D */
 
-  ADC_A_X (cpustate->b.D)
+  ADC_A_X (cpustate->D)
   break;
 case 0x8B: /*      ADC A,E */
 
-  ADC_A_X (cpustate->b.E)
+  ADC_A_X (cpustate->E)
   break;
 case 0x8C: /*      ADC A,H */
 
-  ADC_A_X (cpustate->b.H)
+  ADC_A_X (cpustate->H)
   break;
 case 0x8D: /*      ADC A,L */
 
-  ADC_A_X (cpustate->b.L)
+  ADC_A_X (cpustate->L)
   break;
 case 0x8E: /*      ADC A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   ADC_A_X (x)
   break;
 case 0x8F: /*      ADC A,A */
 
-  ADC_A_X (cpustate->b.A)
+  ADC_A_X (cpustate->A)
   break;
 case 0x90: /*      SUB A,B */
 
-  SUB_A_X (cpustate->b.B)
+  SUB_A_X (cpustate->B)
   break;
 case 0x91: /*      SUB A,C */
 
-  SUB_A_X (cpustate->b.C)
+  SUB_A_X (cpustate->C)
   break;
 case 0x92: /*      SUB A,D */
 
-  SUB_A_X (cpustate->b.D)
+  SUB_A_X (cpustate->D)
   break;
 case 0x93: /*      SUB A,E */
 
-  SUB_A_X (cpustate->b.E)
+  SUB_A_X (cpustate->E)
   break;
 case 0x94: /*      SUB A,H */
 
-  SUB_A_X (cpustate->b.H)
+  SUB_A_X (cpustate->H)
   break;
 case 0x95: /*      SUB A,L */
 
-  SUB_A_X (cpustate->b.L)
+  SUB_A_X (cpustate->L)
   break;
 case 0x96: /*      SUB A,(HL) */
 
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   SUB_A_X (x)
   break;
 case 0x97: /*      SUB A,A */
 
-  SUB_A_X (cpustate->b.A)
+  SUB_A_X (cpustate->A)
   break;
 case 0x98: /*      SBC A,B */
 
-  SBC_A_X (cpustate->b.B)
+  SBC_A_X (cpustate->B)
   break;
 case 0x99: /*      SBC A,C */
 
-  SBC_A_X (cpustate->b.C)
+  SBC_A_X (cpustate->C)
   break;
 case 0x9A: /*      SBC A,D */
 
-  SBC_A_X (cpustate->b.D)
+  SBC_A_X (cpustate->D)
   break;
 case 0x9B: /*      SBC A,E */
 
-  SBC_A_X (cpustate->b.E)
+  SBC_A_X (cpustate->E)
   break;
 case 0x9C: /*      SBC A,H */
 
-  SBC_A_X (cpustate->b.H)
+  SBC_A_X (cpustate->H)
   break;
 case 0x9D: /*      SBC A,L */
 
-  SBC_A_X (cpustate->b.L)
+  SBC_A_X (cpustate->L)
   break;
 case 0x9E: /*      SBC A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   SBC_A_X (x)
   break;
 case 0x9F: /*      SBC A,A */
 
-  SBC_A_X (cpustate->b.A)
+  SBC_A_X (cpustate->A)
   break;
 case 0xA0: /*      AND A,B */
 
-  AND_A_X (cpustate->b.B)
+  AND_A_X (cpustate->B)
   break;
 case 0xA1: /*      AND A,C */
 
-  AND_A_X (cpustate->b.C)
+  AND_A_X (cpustate->C)
   break;
 case 0xA2: /*      AND A,D */
 
-  AND_A_X (cpustate->b.D)
+  AND_A_X (cpustate->D)
   break;
 case 0xA3: /*      AND A,E */
 
-  AND_A_X (cpustate->b.E)
+  AND_A_X (cpustate->E)
   break;
 case 0xA4: /*      AND A,H */
 
-  AND_A_X (cpustate->b.H)
+  AND_A_X (cpustate->H)
   break;
 case 0xA5: /*      AND A,L */
 
-  AND_A_X (cpustate->b.L)
+  AND_A_X (cpustate->L)
   break;
 case 0xA6: /*      AND A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   AND_A_X (x)
   break;
 case 0xA7: /*      AND A,A */
 
-  cpustate->b.F = (cpustate->b.A == 0) ? (FLAG_H | FLAG_Z) : FLAG_H;
+  cpustate->F = (cpustate->A == 0) ? (FLAG_H | FLAG_Z) : FLAG_H;
   break;
 case 0xA8: /*      XOR A,B */
 
-  XOR_A_X (cpustate->b.B)
+  XOR_A_X (cpustate->B)
   break;
 case 0xA9: /*      XOR A,C */
 
-  XOR_A_X (cpustate->b.C)
+  XOR_A_X (cpustate->C)
   break;
 case 0xAA: /*      XOR A,D */
 
-  XOR_A_X (cpustate->b.D)
+  XOR_A_X (cpustate->D)
   break;
 case 0xAB: /*      XOR A,E */
 
-  XOR_A_X (cpustate->b.E)
+  XOR_A_X (cpustate->E)
   break;
 case 0xAC: /*      XOR A,H */
 
-  XOR_A_X (cpustate->b.H)
+  XOR_A_X (cpustate->H)
   break;
 case 0xAD: /*      XOR A,L */
 
-  XOR_A_X (cpustate->b.L)
+  XOR_A_X (cpustate->L)
   break;
 case 0xAE: /*      XOR A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   XOR_A_X (x)
   break;
 case 0xAF: /*      XOR A,A */
 
-  XOR_A_X (cpustate->b.A)
+  XOR_A_X (cpustate->A)
   break;
 case 0xB0: /*      OR A,B */
 
-  OR_A_X (cpustate->b.B)
+  OR_A_X (cpustate->B)
   break;
 case 0xB1: /*      OR A,C */
 
-  OR_A_X (cpustate->b.C)
+  OR_A_X (cpustate->C)
   break;
 case 0xB2: /*      OR A,D */
 
-  OR_A_X (cpustate->b.D)
+  OR_A_X (cpustate->D)
   break;
 case 0xB3: /*      OR A,E */
 
-  OR_A_X (cpustate->b.E)
+  OR_A_X (cpustate->E)
   break;
 case 0xB4: /*      OR A,H */
 
-  OR_A_X (cpustate->b.H)
+  OR_A_X (cpustate->H)
   break;
 case 0xB5: /*      OR A,L */
 
-  OR_A_X (cpustate->b.L)
+  OR_A_X (cpustate->L)
   break;
 case 0xB6: /*      OR A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   OR_A_X (x)
   break;
 case 0xB7: /*      OR A,A */
 
-  OR_A_X (cpustate->b.A)
+  OR_A_X (cpustate->A)
   break;
 case 0xB8: /*      CP A,B */
 
-  CP_A_X (cpustate->b.B)
+  CP_A_X (cpustate->B)
   break;
 case 0xB9: /*      CP A,C */
 
-  CP_A_X (cpustate->b.C)
+  CP_A_X (cpustate->C)
   break;
 case 0xBA: /*      CP A,D */
 
-  CP_A_X (cpustate->b.D)
+  CP_A_X (cpustate->D)
   break;
 case 0xBB: /*      CP A,E */
 
-  CP_A_X (cpustate->b.E)
+  CP_A_X (cpustate->E)
   break;
 case 0xBC: /*      CP A,H */
 
-  CP_A_X (cpustate->b.H)
+  CP_A_X (cpustate->H)
   break;
 case 0xBD: /*      CP A,L */
 
-  CP_A_X (cpustate->b.L)
+  CP_A_X (cpustate->L)
   break;
 case 0xBE: /*      CP A,(HL) */
 
-  x = mem_ReadByte (cpustate, cpustate->w.HL);
+  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
 
   CP_A_X (x)
   break;
 case 0xBF: /*      CP A,A */
 
-  CP_A_X (cpustate->b.A)
+  CP_A_X (cpustate->A)
   break;
 case 0xC0: /*      RET NZ */
-
-  if (!(cpustate->b.F & FLAG_Z))
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-    cpustate->w.SP += 2;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+	CYCLES_PASSED( 4 );
+	if (!(cpustate->F & FLAG_Z))
+	{
+		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+		cpustate->SP += 2;
+		CYCLES_PASSED( 4 );
+	}
+	break;
 case 0xC1: /*      POP BC */
-
-  cpustate->w.BC = mem_ReadWord (cpustate, cpustate->w.SP);
-  cpustate->w.SP += 2;
-  break;
+	POP( cpustate->B, cpustate->C );
+	break;
 case 0xC2: /*      JP NZ,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_Z)
-  {
-    cpustate->w.PC += 2;
-  }
-  else
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    CYCLES_PASSED( 4 );
-  }
-  break;
+		if ( ! (cpustate->F & FLAG_Z) )
+		{
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xC3: /*      JP n16 */
-
-  cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.PC);
-  break;
+	cpustate->PC = mem_ReadWord (cpustate, cpustate->PC);
+	CYCLES_PASSED( 4 );
+	break;
 case 0xC4: /*      CALL NZ,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_Z)
-  {
-    cpustate->w.PC += 2;
-  }
-  else
-  {
-	register UINT16 PC;
-    PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    cpustate->w.PC += 2;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-    cpustate->w.PC = PC;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+		if ( ! (cpustate->F & FLAG_Z) )
+		{
+			cpustate->SP -= 2;
+			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xC5: /*      PUSH BC */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.BC);
-  break;
+	PUSH( cpustate->B, cpustate->C );
+	CYCLES_PASSED( 4 );
+	break;
 case 0xC6: /*      ADD A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   ADD_A_X (x)
   break;
 case 0xC7: /*      RST 0 */
-
-  {
-	register UINT16 PC;
-    PC = cpustate->w.PC;
-    cpustate->w.PC = 0;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, PC);
-  }
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xC8: /*      RET Z */
-
-  if (cpustate->b.F & FLAG_Z)
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-    cpustate->w.SP += 2;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+	CYCLES_PASSED( 4 );
+	if (cpustate->F & FLAG_Z)
+	{
+		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+		cpustate->SP += 2;
+		CYCLES_PASSED( 4 );
+	}
+	break;
 case 0xC9: /*      RET */
-
-  cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-  cpustate->w.SP += 2;
-  break;
+	cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+	cpustate->SP += 2;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xCA: /*      JP Z,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_Z)
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    CYCLES_PASSED( 4 );
-  }
-  else
-  {
-    cpustate->w.PC += 2;
-  }
-  break;
+		if (cpustate->F & FLAG_Z)
+		{
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xCB: /*      PREFIX! */
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
-  CYCLES_PASSED( CyclesCB[x] );
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   switch (x)
   {
     #include "opc_cb.h"
   }
   break;
 case 0xCC: /*      CALL Z,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_Z)
-  {
-	register UINT16 PC;
-    PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    cpustate->w.PC += 2;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-    cpustate->w.PC = PC;
-    CYCLES_PASSED( 12 );
-  }
-  else
-  {
-    cpustate->w.PC += 2;
-  }
-  break;
+		if (cpustate->F & FLAG_Z)
+		{
+			cpustate->SP -= 2;
+			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xCD: /*      CALL n16 */
-  {
-	register UINT16 PC;
-    PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    cpustate->w.PC += 2;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-    cpustate->w.PC = PC;
-  }
-  break;
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
+
+		cpustate->SP -= 2;
+		mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+		cpustate->PC = addr;
+		CYCLES_PASSED( 4 );
+	}
+	break;
 case 0xCE: /*      ADC A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   ADC_A_X (x)
   break;
 case 0xCF: /*      RST 8 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 8;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 8;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xD0: /*      RET NC */
-
-  if (!(cpustate->b.F & FLAG_C))
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-    cpustate->w.SP += 2;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+	CYCLES_PASSED( 4 );
+	if (!(cpustate->F & FLAG_C))
+	{
+		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+		cpustate->SP += 2;
+		CYCLES_PASSED( 4 );
+	}
+	break;
 case 0xD1: /*      POP DE */
-
-  cpustate->w.DE = mem_ReadWord (cpustate, cpustate->w.SP);
-  cpustate->w.SP += 2;
-  break;
+	POP( cpustate->D, cpustate->E );
+	break;
 case 0xD2: /*      JP NC,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_C)
-  {
-    cpustate->w.PC += 2;
-  }
-  else
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    CYCLES_PASSED( 4 );
-  }
-  break;
+		if ( ! (cpustate->F & FLAG_C) )
+		{
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xD3: /*      EH? */
   break;
 case 0xD4: /*      CALL NC,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_C)
-  {
-    cpustate->w.PC += 2;
-  }
-  else
-  {
-	register UINT16 PC;
-    PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    cpustate->w.PC += 2;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-    cpustate->w.PC = PC;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+		if ( ! (cpustate->F & FLAG_C) )
+		{
+			cpustate->SP -= 2;
+			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xD5: /*      PUSH DE */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.DE);
-  break;
+	PUSH( cpustate->D, cpustate->E );
+	CYCLES_PASSED( 4 );
+	break;
 case 0xD6: /*      SUB A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   SUB_A_X (x)
   break;
 case 0xD7: /*      RST     $10 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x10;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x10;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xD8: /*      RET C */
-
-  if (cpustate->b.F & FLAG_C)
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-    cpustate->w.SP += 2;
-    CYCLES_PASSED( 12 );
-  }
-  break;
+	CYCLES_PASSED( 4 );
+	if (cpustate->F & FLAG_C)
+	{
+		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+		cpustate->SP += 2;
+		CYCLES_PASSED( 4 );
+	}
+	break;
 case 0xD9: /*      RETI */
-
-  cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.SP);
-  cpustate->w.SP += 2;
-  cpustate->w.enable |= IME;
-  break;
+	cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
+	cpustate->SP += 2;
+	cpustate->enable |= IME;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xDA: /*      JP C,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_C)
-  {
-    cpustate->w.PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    CYCLES_PASSED( 4 );
-  }
-  else
-  {
-    cpustate->w.PC += 2;
-  }
-  break;
+		if (cpustate->F & FLAG_C)
+		{
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xDB: /*      EH? */
   break;
 case 0xDC: /*      CALL C,n16 */
+	{
+		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
+		cpustate->PC += 2;
 
-  if (cpustate->b.F & FLAG_C)
-  {
-	register UINT16 PC;
-    PC = mem_ReadWord (cpustate, cpustate->w.PC);
-    cpustate->w.PC += 2;
-
-    cpustate->w.SP -= 2;
-    mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-    cpustate->w.PC = PC;
-    CYCLES_PASSED( 12 );
-  }
-  else
-  {
-    cpustate->w.PC += 2;
-  }
-  break;
+		if (cpustate->F & FLAG_C)
+		{
+			cpustate->SP -= 2;
+			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+			cpustate->PC = addr;
+			CYCLES_PASSED( 4 );
+		}
+	}
+	break;
 case 0xDD: /*      EH? */
   break;
 case 0xDE: /*      SBC A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   SBC_A_X (x)
   break;
 case 0xDF: /*      RST     $18 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x18;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x18;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xE0: /*      LD      ($FF00+n8),A */
-  mem_WriteByte (cpustate, mem_ReadByte (cpustate, cpustate->w.PC++) + 0xFF00, cpustate->b.A);
+  {
+	UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
+	mem_WriteByte (cpustate, 0xFF00 + v, cpustate->A);
+  }
   break;
 case 0xE1: /*      POP HL */
-
-  cpustate->w.HL = mem_ReadWord (cpustate, cpustate->w.SP);
-  cpustate->w.SP += 2;
-  break;
+	POP( cpustate->H, cpustate->L );
+	break;
 case 0xE2: /*      LD ($FF00+C),A */
 
-  mem_WriteByte (cpustate, (UINT16) (0xFF00 + cpustate->b.C), cpustate->b.A);
+  mem_WriteByte (cpustate, (UINT16) (0xFF00 + cpustate->C), cpustate->A);
   break;
 case 0xE3: /*      EH? */
   break;
 case 0xE4: /*      EH? */
   break;
 case 0xE5: /*      PUSH HL */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.HL);
-  break;
+	PUSH( cpustate->H, cpustate->L );
+	CYCLES_PASSED( 4 );
+	break;
 case 0xE6: /*      AND A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   AND_A_X (x)
   break;
 case 0xE7: /*      RST $20 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x20;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x20;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xE8: /*      ADD SP,n8 */
 /*
  *   Z - Reset.
@@ -1407,33 +1409,33 @@
   {
 	register INT32 n;
 
-	n = (INT32) ((INT8) mem_ReadByte (cpustate, cpustate->w.PC++));
+	n = (INT8) mem_ReadByte (cpustate, cpustate->PC++);
 
-	if ( ( cpustate->w.SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
+	if ( ( cpustate->SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
     {
-      cpustate->b.F = FLAG_C;
+      cpustate->F = FLAG_C;
     }
     else
     {
-      cpustate->b.F = 0;
+      cpustate->F = 0;
     }
 
-    if ( ( cpustate->w.SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
+    if ( ( cpustate->SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
     {
-      cpustate->b.F |= FLAG_H;
+      cpustate->F |= FLAG_H;
     }
 
-	cpustate->w.SP = (UINT16) ( cpustate->w.SP + n );
+	cpustate->SP = (UINT16) ( cpustate->SP + n );
   }
+  CYCLES_PASSED( 8 );
   break;
 case 0xE9: /*      JP (HL) */
-
-  cpustate->w.PC = cpustate->w.HL;
-  break;
+	cpustate->PC = ( cpustate->H << 8 ) | cpustate->L;
+	break;
 case 0xEA: /*      LD (n16),A */
 
-  mem_WriteByte (cpustate, mem_ReadWord (cpustate, cpustate->w.PC), cpustate->b.A);
-  cpustate->w.PC += 2;
+  mem_WriteByte (cpustate, mem_ReadWord (cpustate, cpustate->PC), cpustate->A);
+  cpustate->PC += 2;
   break;
 case 0xEB: /*      EH? */
   break;
@@ -1443,50 +1445,51 @@
   break;
 case 0xEE: /*      XOR A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   XOR_A_X (x)
   break;
 case 0xEF: /*      RST $28 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x28;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x28;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xF0: /*      LD A,($FF00+n8) */
-
-  cpustate->b.A = mem_ReadByte (cpustate, 0xFF00 + mem_ReadByte (cpustate, cpustate->w.PC++));
+  {
+	UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
+	cpustate->A = mem_ReadByte (cpustate, 0xFF00 + v);
+  }
   break;
 case 0xF1: /*      POP AF */
-
-  cpustate->w.AF = (UINT16) (mem_ReadWord (cpustate, cpustate->w.SP) & 0xFFF0);
-  cpustate->w.SP += 2;
-  break;
+	POP( cpustate->A, cpustate->F );
+	cpustate->F &= 0xF0;
+	break;
 case 0xF2: /*      LD A,($FF00+C) */
 
-  cpustate->b.A = mem_ReadByte (cpustate, (UINT16) (0xFF00 + cpustate->b.C));
+  cpustate->A = mem_ReadByte (cpustate, (UINT16) (0xFF00 + cpustate->C));
   break;
 case 0xF3: /*      DI */
-  cpustate->w.ei_delay = 0;
-  cpustate->w.enable &= ~IME;
+  cpustate->ei_delay = 0;
+  cpustate->enable &= ~IME;
   break;
 case 0xF4: /*      EH? */
   break;
 case 0xF5: /*      PUSH AF */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, (UINT16) (cpustate->w.AF & 0xFFF0));
-  break;
+	cpustate->F &= 0xF0;
+	PUSH( cpustate->A, cpustate->F );
+	CYCLES_PASSED( 4 );
+	break;
 case 0xF6: /*      OR A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
+  x = mem_ReadByte (cpustate, cpustate->PC++);
   OR_A_X (x)
   break;
 case 0xF7: /*      RST $30 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x30;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x30;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xF8: /*      LD HL,SP+n8 */
 /*
  *   n = one UINT8 signed immediate value.
@@ -1501,51 +1504,52 @@
   {
 	register INT32 n;
 
-	n = (INT32) ((INT8) mem_ReadByte (cpustate, cpustate->w.PC++));
+	n = (INT8) mem_ReadByte (cpustate, cpustate->PC++);
 
-	if ( ( cpustate->w.SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
+	if ( ( cpustate->SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
     {
-      cpustate->b.F = FLAG_C;
+      cpustate->F = FLAG_C;
     }
     else
     {
-      cpustate->b.F = 0;
+      cpustate->F = 0;
     }
 
-	if ( ( cpustate->w.SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
+	if ( ( cpustate->SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
     {
-      cpustate->b.F |= FLAG_H;
+      cpustate->F |= FLAG_H;
     }
 
-	cpustate->w.HL = (UINT16) ( cpustate->w.SP + n );
+	UINT16 res = cpustate->SP + n;
+
+	cpustate->L = res & 0xFF;
+	cpustate->H = res >> 8;
   }
+  CYCLES_PASSED( 4 );
   break;
 case 0xF9: /*      LD SP,HL */
-
-  cpustate->w.SP = cpustate->w.HL;
-  break;
+	cpustate->SP = ( cpustate->H << 8 ) | cpustate->L;
+	CYCLES_PASSED( 4 );
+	break;
 case 0xFA: /*      LD A,(n16) */
-
-  cpustate->b.A = mem_ReadByte (cpustate, mem_ReadWord (cpustate, cpustate->w.PC));
-  cpustate->w.PC += 2;
-  break;
+	cpustate->A = mem_ReadByte (cpustate, mem_ReadWord (cpustate, cpustate->PC));
+	cpustate->PC += 2;
+	break;
 case 0xFB: /*      EI */
-
-  cpustate->w.enable |= IME;
-  cpustate->w.ei_delay = 1;
-  break;
+	cpustate->enable |= IME;
+	cpustate->ei_delay = 1;
+	break;
 case 0xFC: /*      EH? */
-  break;
+	break;
 case 0xFD: /*      EH? */
-  break;
+	break;
 case 0xFE: /*      CP A,n8 */
-
-  x = mem_ReadByte (cpustate, cpustate->w.PC++);
-  CP_A_X (x)
-  break;
+	x = mem_ReadByte (cpustate, cpustate->PC++);
+	CP_A_X (x)
+	break;
 case 0xFF: /*      RST $38 */
-
-  cpustate->w.SP -= 2;
-  mem_WriteWord (cpustate, cpustate->w.SP, cpustate->w.PC);
-  cpustate->w.PC = 0x38;
-  break;
+	cpustate->SP -= 2;
+	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
+	cpustate->PC = 0x38;
+	CYCLES_PASSED( 4 );
+	break;
diff -Nru src-old/emu/cpu/m68000/m68000.h src/emu/cpu/m68000/m68000.h
--- src-old/emu/cpu/m68000/m68000.h	2011-12-12 15:20:12.000000000 +0100
+++ src/emu/cpu/m68000/m68000.h	2012-02-20 09:25:57.000000000 +0100
@@ -122,4 +122,9 @@
 void m68k_set_tas_callback(device_t *device, m68k_tas_func callback);
 UINT16 m68k_get_fc(device_t *device);
 
+
+typedef int (*instruction_hook_t)(device_t *device, offs_t curpc);
+void m68k_set_instruction_hook(device_t *device, instruction_hook_t ihook);
+
+
 #endif /* __M68000_H__ */
diff -Nru src-old/emu/cpu/m68000/m68kcpu.c src/emu/cpu/m68000/m68kcpu.c
--- src-old/emu/cpu/m68000/m68kcpu.c	2012-02-16 15:02:34.000000000 +0100
+++ src/emu/cpu/m68000/m68kcpu.c	2012-02-20 09:25:57.000000000 +0100
@@ -5,7 +5,7 @@
 #if 0
 static const char copyright_notice[] =
 "MUSASHI\n"
-"Version 4.90 (2011-09-22)\n"
+"Version 4.95 (2012-02-19)\n"
 "A portable Motorola M68xxx/CPU32/ColdFire processor emulation engine.\n"
 "Copyright Karl Stenerud.  All rights reserved.\n"
 "\n"
@@ -17,7 +17,7 @@
 "(Karl Stenerud).\n"
 "\n"
 "The latest version of this code can be obtained at:\n"
-"http://kstenerud.cjb.net or http://mamedev.org\n"
+"http://kstenerud.cjb.net or http://mamedev.org/\n"
 ;
 #endif
 
@@ -1242,9 +1242,9 @@
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
 		case DEVINFO_STR_NAME:							/* set per-core */						break;
 		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Motorola 68K");		break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "4.90");				break;
+		case DEVINFO_STR_VERSION:					strcpy(info->s, "4.95");				break;
 		case DEVINFO_STR_SOURCE_FILE:						strcpy(info->s, __FILE__);				break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright Karl Stenerud. All rights reserved. (2.1 fixes HJB, FPU+MMU by RB+HO)"); break;
+		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright Karl Stenerud. All rights reserved. (2.1 fixes HJB, FPU+MMU by RB+HO+OG)"); break;
 	}
 }
 
@@ -1265,6 +1265,13 @@
 	m68k->hmmu_enabled = enable;
 }
 
+void m68k_set_instruction_hook(device_t *device, instruction_hook_t ihook)
+{
+	m68ki_cpu_core *m68k = get_safe_token(device);
+
+    m68k->instruction_hook = ihook;
+}
+
 /****************************************************************************
  * 8-bit data memory interface
  ****************************************************************************/
diff -Nru src-old/emu/cpu/m68000/m68kcpu.h src/emu/cpu/m68000/m68kcpu.h
--- src-old/emu/cpu/m68000/m68kcpu.h	2012-02-14 10:27:58.000000000 +0100
+++ src/emu/cpu/m68000/m68kcpu.h	2012-02-23 15:07:01.000000000 +0100
@@ -707,6 +707,8 @@
 	UINT16 mmu_tmp_rw;      /* temporary hack: read/write (1/0) for the mmu */
 	UINT32 mmu_tmp_buserror_address;   /* temporary hack: (first) bus error address */
 	UINT16 mmu_tmp_buserror_occurred;  /* temporary hack: flag that bus error has occurred from mmu */
+	UINT16 mmu_tmp_buserror_fc;   /* temporary hack: (first) bus error fc */
+	UINT16 mmu_tmp_buserror_rw;   /* temporary hack: (first) bus error rw */
 
 	UINT32 ic_address[M68K_IC_SIZE];   /* instruction cache address data */
 	UINT16 ic_data[M68K_IC_SIZE];      /* instruction cache content data */
@@ -1571,8 +1573,8 @@
  */
 void m68ki_stack_frame_1010(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
-	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
-	int orig_fc = m68k->mmu_tmp_fc;
+	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_buserror_fc;
 
 	/* INTERNAL REGISTER */
 	m68ki_push_16(m68k, 0);
@@ -1623,8 +1625,8 @@
  */
 void m68ki_stack_frame_1011(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
-	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
-	int orig_fc = m68k->mmu_tmp_fc;
+	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_buserror_fc;
 
 	/* INTERNAL REGISTERS (18 words) */
 	m68ki_push_32(m68k, 0);
@@ -1697,8 +1699,8 @@
  */
 void m68ki_stack_frame_0111(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address, bool in_mmu)
 {
-	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
-	int orig_fc = m68k->mmu_tmp_fc;
+	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_buserror_fc;
 
 	/* INTERNAL REGISTERS (18 words) */
 	m68ki_push_32(m68k, 0);
diff -Nru src-old/emu/cpu/m68000/m68kmmu.h src/emu/cpu/m68000/m68kmmu.h
--- src-old/emu/cpu/m68000/m68kmmu.h	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/cpu/m68000/m68kmmu.h	2012-02-26 15:31:24.000000000 +0100
@@ -253,7 +253,7 @@
 		// transparent translation register 0 enabled
 		UINT32 address_base = m68k->mmu_tt0 & 0xff000000;
 		UINT32 address_mask = ((m68k->mmu_tt0 << 8) & 0xff000000) ^ 0xff000000;
-		if ((addr_in & address_mask) == address_base)
+		if ((addr_in & address_mask) == address_base && (fc & ~m68k->mmu_tt0) == ((m68k->mmu_tt0 >> 4) & 7))
 		{
 //          printf("PMMU: pc=%x TT0 fc=%x addr_in=%08x address_mask=%08x address_base=%08x\n", m68k->ppc, fc, addr_in, address_mask, address_base);
 			return addr_in;
@@ -265,7 +265,7 @@
 		// transparent translation register 1 enabled
 		UINT32 address_base = m68k->mmu_tt1 & 0xff000000;
 		UINT32 address_mask = ((m68k->mmu_tt1 << 8) & 0xff000000) ^ 0xff000000;
-		if ((addr_in & address_mask) == address_base)
+		if ((addr_in & address_mask) == address_base && (fc & ~m68k->mmu_tt1) == ((m68k->mmu_tt1 >> 4) & 7))
 		{
 //          printf("PMMU: pc=%x TT1 fc=%x addr_in=%08x address_mask=%08x address_base=%08x\n", m68k->ppc, fc, addr_in, address_mask, address_base);
 			return addr_in;
@@ -335,7 +335,7 @@
 	bbits = (m68k->mmu_tc >> 8) & 0xf;
 	cbits = (m68k->mmu_tc >> 4) & 0xf;
 
-//  printf("PMMU: tcr %08x limit %08x aptr %08x is %x abits %d bbits %d cbits %d\n", m68k->mmu_tc, root_limit, root_aptr, is, abits, bbits, cbits);
+	//  printf("PMMU: tcr %08x limit %08x aptr %08x is %x abits %d bbits %d cbits %d\n", m68k->mmu_tc, root_limit, root_aptr, is, abits, bbits, cbits);
 
 	// get table A offset
 	tofs = (addr_in<<is)>>(32-abits);
@@ -488,6 +488,8 @@
 			if (++m68k->mmu_tmp_buserror_occurred == 1)
 			{
 				m68k->mmu_tmp_buserror_address = addr_in;
+				m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+				m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 			}
 		}
 		else if (m68k->mmu_tmp_sr & M68K_MMU_SR_SUPERVISOR_ONLY)
@@ -495,6 +497,8 @@
 			if (++m68k->mmu_tmp_buserror_occurred == 1)
 			{
 				m68k->mmu_tmp_buserror_address = addr_in;
+				m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+				m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 			}
 		}
 		else if ((m68k->mmu_tmp_sr & M68K_MMU_SR_WRITE_PROTECT) && !m68k->mmu_tmp_rw)
@@ -502,6 +506,8 @@
 			if (++m68k->mmu_tmp_buserror_occurred == 1)
 			{
 				m68k->mmu_tmp_buserror_address = addr_in;
+				m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+				m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 			}
 		}
 
@@ -547,11 +553,13 @@
 
 	if (tt0 & 0x8000)
 	{
+		static int fcmask[4] = { 4, 4, 0, 0 };
+		static int fcmatch[4] = { 0, 4, 0, 0 };
 		UINT32 mask = (tt0>>16) & 0xff;
 		mask ^= 0xff;
 		mask <<= 24;
 
-		if ((addr_in & mask) == (tt0 & mask))
+		if ((addr_in & mask) == (tt0 & mask) && (fc & fcmask[(tt0 >> 13) & 3]) == fcmatch[(tt0 >> 13) & 3])
 		{
 			//          fprintf(stderr, "TT0 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt0, mask);
 			if ((tt0 & 4) && !m68k->mmu_tmp_rw && !ptest)	// write protect?
@@ -559,6 +567,8 @@
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
+					m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+					m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 				}
 			}
 
@@ -568,11 +578,13 @@
 
 	if (tt1 & 0x8000)
 	{
+		static int fcmask[4] = { 4, 4, 0, 0 };
+		static int fcmatch[4] = { 0, 4, 0, 0 };
 		UINT32 mask = (tt1>>16) & 0xff;
 		mask ^= 0xff;
 		mask <<= 24;
 
-		if ((addr_in & mask) == (tt1 & mask))
+		if ((addr_in & mask) == (tt1 & mask) && (fc & fcmask[(tt1 >> 13) & 3]) == fcmatch[(tt1 >> 13) & 3])
 		{
 			//          fprintf(stderr, "TT1 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt1, mask);
 			if ((tt1 & 4) && !m68k->mmu_tmp_rw && !ptest)	// write protect?
@@ -580,6 +592,8 @@
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
+					m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+					m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 				}
 			}
 
@@ -607,15 +621,6 @@
 
 		// get the root entry
 		root_entry = m68k->program->read_dword(root_ptr);
-		static UINT32 psrp = 0, purp=0;
-		if(psrp != m68k->mmu_srp_aptr) {
-			psrp = m68k->mmu_srp_aptr;
-//          fprintf(stderr, "srp = %08x\n", psrp);
-		}
-		if(purp != m68k->mmu_urp_aptr) {
-			purp = m68k->mmu_urp_aptr;
-//          fprintf(stderr, "urp = %08x\n", purp);
-		}
 
 		// is UDT marked valid?
 		if (root_entry & 2)
@@ -623,7 +628,7 @@
 			pointer_ptr = (root_entry & ~0x1ff) + (ptr_idx<<2);
 			pointer_entry = m68k->program->read_dword(pointer_ptr);
 
-			//          fprintf(stderr, "pointer entry = %08x\n", pointer_entry);
+			//          logerror("pointer entry = %08x\n", pointer_entry);
 
 			// write protected by the root or pointer entries?
 			if ((((root_entry & 4) && !m68k->mmu_tmp_rw) || ((pointer_entry & 4) && !m68k->mmu_tmp_rw)) && !ptest)
@@ -631,6 +636,8 @@
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
+					m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+					m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 				}
 
 				return addr_in;
@@ -639,10 +646,12 @@
 			// is UDT valid on the pointer entry?
 			if (!(pointer_entry & 2) && !ptest)
 			{
-              fprintf(stderr, "Invalid pointer entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+//              fprintf(stderr, "Invalid pointer entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
+					m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+					m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 				}
 
 				return addr_in;
@@ -652,12 +661,15 @@
 		}
 		else // throw an error
 		{
-          fprintf(stderr, "Invalid root entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+//          fprintf(stderr, "Invalid root entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+
 			if (!ptest)
 			{
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
+					m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+					m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 				}
 			}
 
@@ -671,7 +683,7 @@
 			page = addr_in & 0x1fff;
 			pointer_entry &= ~0x7f;
 
-			//          fprintf(stderr, "8k pages: index %x page %x\n", page_idx, page);
+			//          logerror("8k pages: index %x page %x\n", page_idx, page);
 		}
 		else	// 4k pages
 		{
@@ -679,13 +691,13 @@
 			page = addr_in & 0xfff;
 			pointer_entry &= ~0xff;
 
-			//          fprintf(stderr, "4k pages: index %x page %x\n", page_idx, page);
+			//          logerror("4k pages: index %x page %x\n", page_idx, page);
 		}
 
 		page_ptr = pointer_entry + (page_idx<<2);
 		page_entry = m68k->program->read_dword(page_ptr);
 
-		//      fprintf(stderr, "page_entry = %08x\n", page_entry);
+		//      logerror("page_entry = %08x\n", page_entry);
 
 		// resolve indirect page pointers
 		while ((page_entry & 3) == 2)
@@ -699,6 +711,8 @@
 			if (++m68k->mmu_tmp_buserror_occurred == 1)
 			{
 				m68k->mmu_tmp_buserror_address = addr_in;
+				m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+				m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 			}
 
 			return addr_in;
@@ -707,12 +721,14 @@
 		switch (page_entry & 3)
 		{
 			case 0:	// invalid
-              fprintf(stderr, "Invalid page entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+//              fprintf(stderr, "Invalid page entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
 				if (!ptest)
 				{
 					if (++m68k->mmu_tmp_buserror_occurred == 1)
 					{
 						m68k->mmu_tmp_buserror_address = addr_in;
+						m68k->mmu_tmp_buserror_rw = m68k->mmu_tmp_rw;
+						m68k->mmu_tmp_buserror_fc = m68k->mmu_tmp_fc;
 					}
 				}
 
diff -Nru src-old/emu/cpu/mips/mips3drc.c src/emu/cpu/mips/mips3drc.c
--- src-old/emu/cpu/mips/mips3drc.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/cpu/mips/mips3drc.c	2012-02-20 08:47:44.000000000 +0100
@@ -1524,9 +1524,20 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
+			UINT32 sum = seqhead->opptr.l[0];
 			void *base = mips3->direct->read_decrypted_ptr(seqhead->physpc);
 			UML_LOAD(block, I0, base, 0, SIZE_DWORD, SCALE_x4);			// load    i0,base,0,dword
-			UML_CMP(block, I0, seqhead->opptr.l[0]);						// cmp     i0,opptr[0]
+
+			if (seqhead->delay.first() != NULL && seqhead->physpc != seqhead->delay.first()->physpc)
+			{
+				base = mips3->direct->read_decrypted_ptr(seqhead->delay.first()->physpc);
+				UML_LOAD(block, I1, base, 0, SIZE_DWORD, SCALE_x4);					// load    i1,base,dword
+				UML_ADD(block, I0, I0, I1);						// add     i0,i0,i1
+
+				sum += seqhead->delay.first()->opptr.l[0];
+			}
+
+			UML_CMP(block, I0, sum);									// cmp     i0,opptr[0]
 			UML_EXHc(block, COND_NE, *mips3->impstate->nocode, epc(seqhead));		// exne    nocode,seqhead->pc
 		}
 	}
@@ -1702,11 +1713,16 @@
 
 	/* fetch the target register if dynamic, in case it is modified by the delay slot */
 	if (desc->targetpc == BRANCH_TARGET_DYNAMIC)
+	{
 		UML_MOV(block, mem(&mips3->impstate->jmpdest), R32(RSREG));					// mov     [jmpdest],<rsreg>
 
+	}
+
 	/* set the link if needed -- before the delay slot */
 	if (linkreg != 0)
+	{
 		UML_DMOV(block, R64(linkreg), (INT32)(desc->pc + 8));					// dmov    <linkreg>,desc->pc + 8
+	}
 
 	/* compile the delay slot using temporary compiler state */
 	assert(desc->delay.first() != NULL);
diff -Nru src-old/emu/cpu/powerpc/ppcdrc.c src/emu/cpu/powerpc/ppcdrc.c
--- src-old/emu/cpu/powerpc/ppcdrc.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/cpu/powerpc/ppcdrc.c	2012-02-25 16:02:06.000000000 +0100
@@ -4547,7 +4547,7 @@
 
 static CPU_INIT( mpc8240 )
 {
-	ppcdrc_init(PPC_MODEL_MPC8240, PPCCAP_OEA | PPCCAP_VEA | PPCCAP_FPU | PPCCAP_MISALIGNED, 4/* unknown */, device, irqcallback);
+	ppcdrc_init(PPC_MODEL_MPC8240, PPCCAP_OEA | PPCCAP_VEA | PPCCAP_FPU | PPCCAP_MISALIGNED | PPCCAP_603_MMU, 4/* unknown */, device, irqcallback);
 }
 
 
diff -Nru src-old/emu/cpu/rsp/rspdrc.c src/emu/cpu/rsp/rspdrc.c
--- src-old/emu/cpu/rsp/rspdrc.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/cpu/rsp/rspdrc.c	2012-02-23 15:30:03.000000000 +0100
@@ -124,7 +124,7 @@
 	UINT32				vres[8];					/* used for temporary vector results */
 
 	/* register mappings */
-	parameter	regmap[32];					/* parameter to register mappings for all 32 integer registers */
+	parameter	regmap[34];					/* parameter to register mappings for all 32 integer registers */
 
 	/* subroutines */
 	code_handle *	entry;						/* entry point */
@@ -210,8 +210,9 @@
 #define VS2REG						((op >> 16) & 0x1f)
 #define EL							((op >> 21) & 0xf)
 
-#define VREG_B(reg, offset)		rsp->v[(reg)].b[BYTE4_XOR_BE(offset)]
-#define VREG_S(reg, offset)		rsp->v[(reg)].s[(offset)^1]
+#define VREG_B(reg, offset)		rsp->v[(reg)].b[(offset)^1]
+#define W_VREG_S(reg, offset)		rsp->v[(reg)].s[(offset)]
+#define VREG_S(reg, offset)		(INT16)rsp->v[(reg)].s[(offset)]
 
 #define VEC_EL_2(x,z)				(vector_elements_2[(x)][(z)])
 
@@ -320,7 +321,9 @@
 
 INLINE UINT8 READ8(rsp_state *rsp, UINT32 address)
 {
-	return rsp->dmem8[BYTE4_XOR_BE(address & 0xfff)];
+	UINT8 ret = rsp->dmem8[BYTE4_XOR_BE(address & 0xfff)];
+	//printf("%04xr%02x\n",address, ret);
+	return ret;
 }
 
 static void cfunc_read8(void *param)
@@ -367,7 +370,7 @@
 {
 	address &= 0xfff;
 	rsp->dmem8[BYTE4_XOR_BE(address)] = data;
-	//printf("%04xw%02x\n",address, data);
+	//printf("%04x:%02x\n",address, data);
 }
 
 static void cfunc_write8(void *param)
@@ -381,7 +384,7 @@
 	address &= 0xfff;
 	rsp->dmem8[BYTE4_XOR_BE(address)] = data >> 8;
 	rsp->dmem8[BYTE4_XOR_BE(address + 1)] = data & 0xff;
-	//printf("%04xw%04x\n",address, data);
+	//printf("%04x:%04x\n",address, data);
 }
 
 static void cfunc_write16(void *param)
@@ -397,7 +400,7 @@
 	rsp->dmem8[BYTE4_XOR_BE(address + 1)] = (data >> 16) & 0xff;
 	rsp->dmem8[BYTE4_XOR_BE(address + 2)] = (data >> 8) & 0xff;
 	rsp->dmem8[BYTE4_XOR_BE(address + 3)] = data & 0xff;
-	//printf("%04xw%08x\n",address, data);
+	//printf("%04x:%08x\n",address, data);
 }
 
 static void cfunc_write32(void *param)
@@ -431,25 +434,31 @@
 	switch(rsp->impstate->arg2)
 	{
 		case 0: // WRITE8
-			printf("%04x:%02x\n", rsp->impstate->arg0 & 0x0fff, (UINT8)rsp->impstate->arg1);
+			printf("%04x:%02x\n", rsp->impstate->arg0 & 0xffff, (UINT8)rsp->impstate->arg1);
 			break;
 		case 1: // WRITE16
-			printf("%04x:%04x\n", rsp->impstate->arg0 & 0x0fff, (UINT16)rsp->impstate->arg1);
+			printf("%04x:%04x\n", rsp->impstate->arg0 & 0xffff, (UINT16)rsp->impstate->arg1);
 			break;
 		case 2: // WRITE32
-			printf("%04x:%08x\n", rsp->impstate->arg0 & 0x0fff, rsp->impstate->arg1);
+			printf("%04x:%08x\n", rsp->impstate->arg0 & 0xffff, rsp->impstate->arg1);
 			break;
 		case 3: // READ8
-			printf("%04xr%02x\n", rsp->impstate->arg0 & 0x0fff, (UINT8)rsp->impstate->arg1);
+			printf("%04xr%02x\n", rsp->impstate->arg0 & 0xffff, (UINT8)rsp->impstate->arg1);
 			break;
 		case 4: // READ16
-			printf("%04xr%04x\n", rsp->impstate->arg0 & 0x0fff, (UINT16)rsp->impstate->arg1);
+			printf("%04xr%04x\n", rsp->impstate->arg0 & 0xffff, (UINT16)rsp->impstate->arg1);
 			break;
 		case 5: // READ32
-			printf("%04xr%08x\n", rsp->impstate->arg0 & 0x0fff, rsp->impstate->arg1);
+			printf("%04xr%08x\n", rsp->impstate->arg0 & 0xffff, rsp->impstate->arg1);
+			break;
+		case 6: // Checksum
+			printf("Sum: %08x\n", rsp->impstate->arg0);
+			break;
+		case 7: // Checksum
+			printf("Correct Sum: %08x\n", rsp->impstate->arg0);
 			break;
 		default: // ???
-			printf("%08x %08x\n", rsp->impstate->arg0 & 0x0fff, rsp->impstate->arg1);
+			printf("%08x %08x\n", rsp->impstate->arg0 & 0xffff, rsp->impstate->arg1);
 			break;
 	}
 }
@@ -860,6 +869,7 @@
 
 	end = index + (16 - (ea & 0xf));
 	if (end > 16) end = 16;
+
 	for (i=index; i < end; i++)
 	{
 		VREG_B(dest, i) = READ8(rsp, ea);
@@ -927,7 +937,7 @@
 
 	for (i=0; i < 8; i++)
 	{
-		VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + i) & 0xf)) << 8;
+		W_VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + i) & 0xf)) << 8;
 	}
 }
 
@@ -956,7 +966,7 @@
 
 	for (i=0; i < 8; i++)
 	{
-		VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + i) & 0xf)) << 7;
+		W_VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + i) & 0xf)) << 7;
 	}
 }
 
@@ -985,7 +995,7 @@
 
 	for (i=0; i < 8; i++)
 	{
-		VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + (i<<1)) & 0xf)) << 7;
+		W_VREG_S(dest, i) = READ8(rsp, ea + (((16-index) + (i<<1)) & 0xf)) << 7;
 	}
 }
 
@@ -1020,7 +1030,7 @@
 
 	for (i=index >> 1; i < end; i++)
 	{
-		VREG_S(dest, i) = READ8(rsp, ea) << 7;
+		W_VREG_S(dest, i) = READ8(rsp, ea) << 7;
 		ea += 4;
 	}
 }
@@ -1761,14 +1771,14 @@
 }
 
 #define WRITEBACK_RESULT() { \
-		VREG_S(VDREG, 0) = vres[0];	\
-		VREG_S(VDREG, 1) = vres[1];	\
-		VREG_S(VDREG, 2) = vres[2];	\
-		VREG_S(VDREG, 3) = vres[3];	\
-		VREG_S(VDREG, 4) = vres[4];	\
-		VREG_S(VDREG, 5) = vres[5];	\
-		VREG_S(VDREG, 6) = vres[6];	\
-		VREG_S(VDREG, 7) = vres[7];	\
+		W_VREG_S(VDREG, 0) = vres[0];	\
+		W_VREG_S(VDREG, 1) = vres[1];	\
+		W_VREG_S(VDREG, 2) = vres[2];	\
+		W_VREG_S(VDREG, 3) = vres[3];	\
+		W_VREG_S(VDREG, 4) = vres[4];	\
+		W_VREG_S(VDREG, 5) = vres[5];	\
+		W_VREG_S(VDREG, 6) = vres[6];	\
+		W_VREG_S(VDREG, 7) = vres[7];	\
 }
 
 INLINE void cfunc_rsp_vmulf(void *param)
@@ -2415,7 +2425,7 @@
 		{
 			for (int i = 0; i < 8; i++)
 			{
-				VREG_S(VDREG, i) = ACCUM_H(i);
+				W_VREG_S(VDREG, i) = ACCUM_H(i);
 			}
 			break;
 		}
@@ -2423,7 +2433,7 @@
 		{
 			for (int i = 0; i < 8; i++)
 			{
-				VREG_S(VDREG, i) = ACCUM_M(i);
+				W_VREG_S(VDREG, i) = ACCUM_M(i);
 			}
 			break;
 		}
@@ -2431,7 +2441,7 @@
 		{
 			for (int i = 0; i < 8; i++)
 			{
-				VREG_S(VDREG, i) = ACCUM_L(i);
+				W_VREG_S(VDREG, i) = ACCUM_L(i);
 			}
 			break;
 		}
@@ -3091,7 +3101,7 @@
 	rsp->reciprocal_res = rec;
 	rsp->dp_allowed = 0;
 
-	VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
+	W_VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
 
 	for (i = 0; i < 8; i++)
 	{
@@ -3183,7 +3193,7 @@
 	rsp->reciprocal_res = rec;
 	rsp->dp_allowed = 0;
 
-	VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
+	W_VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
 
 	for (i = 0; i < 8; i++)
 	{
@@ -3215,7 +3225,7 @@
 		ACCUM_L(i) = VREG_S(VS2REG, sel);
 	}
 
-	VREG_S(VDREG, del) = (INT16)(rsp->reciprocal_res >> 16);
+	W_VREG_S(VDREG, del) = (INT16)(rsp->reciprocal_res >> 16);
 }
 
 INLINE void cfunc_rsp_vmov(void *param)
@@ -3232,7 +3242,7 @@
 	int del = VS1REG & 7;
 	int sel = EL & 7;
 
-	VREG_S(VDREG, del) = VREG_S(VS2REG, sel);
+	W_VREG_S(VDREG, del) = VREG_S(VS2REG, sel);
 	for (int i = 0; i < 8; i++)
 	{
 		sel = VEC_EL_2(EL, i);
@@ -3324,7 +3334,7 @@
 	rsp->reciprocal_res = rec;
 	rsp->dp_allowed = 0;
 
-	VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
+	W_VREG_S(VDREG, del) = (UINT16)(rec & 0xffff);
 
 	for (i = 0; i < 8; i++)
 	{
@@ -3357,7 +3367,7 @@
 		ACCUM_L(i) = VREG_S(VS2REG, sel);
 	}
 
-	VREG_S(VDREG, del) = (INT16)(rsp->reciprocal_res >> 16);	// store high part
+	W_VREG_S(VDREG, del) = (INT16)(rsp->reciprocal_res >> 16);	// store high part
 }
 
 static void cfunc_sp_set_status_cb(void *param)
@@ -3477,7 +3487,7 @@
 		try
 		{
 			/* start the block */
-			block = drcuml->begin_block(8192);
+			block = drcuml->begin_block(4096);
 
 			/* loop until we get through all instruction sequences */
 			for (seqhead = desclist; seqhead != NULL; seqhead = seqlast->next())
@@ -3612,8 +3622,7 @@
 	load_fast_iregs(rsp, block);
 
 	/* generate a hash jump via the current mode and PC */
-	UML_HASHJMP(block, 0, mem(&rsp->pc), *rsp->impstate->nocode);
-																					// hashjmp <mode>,<pc>,nocode
+	UML_HASHJMP(block, 0, mem(&rsp->pc), *rsp->impstate->nocode);					// hashjmp <mode>,<pc>,nocode
 	block->end();
 }
 
@@ -3774,9 +3783,20 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
+			UINT32 sum = seqhead->opptr.l[0];
 			void *base = rsp->direct->read_decrypted_ptr(seqhead->physpc | 0x1000);
 			UML_LOAD(block, I0, base, 0, SIZE_DWORD, SCALE_x4);							// load    i0,base,0,dword
-			UML_CMP(block, I0, seqhead->opptr.l[0]);						// cmp     i0,opptr[0]
+
+			if (seqhead->delay.first() != NULL && seqhead->physpc != seqhead->delay.first()->physpc)
+			{
+				base = rsp->direct->read_decrypted_ptr(seqhead->delay.first()->physpc | 0x1000);
+				UML_LOAD(block, I1, base, 0, SIZE_DWORD, SCALE_x4);					// load    i1,base,dword
+				UML_ADD(block, I0, I0, I1);						// add     i0,i0,i1
+
+				sum += seqhead->delay.first()->opptr.l[0];
+			}
+
+			UML_CMP(block, I0, sum);									// cmp     i0,opptr[0]
 			UML_EXHc(block, COND_NE, *rsp->impstate->nocode, epc(seqhead));		// exne    nocode,seqhead->pc
 		}
 	}
@@ -3795,6 +3815,15 @@
 				UML_LOAD(block, I1, base, 0, SIZE_DWORD, SCALE_x4);						// load    i1,base,dword
 				UML_ADD(block, I0, I0, I1);							// add     i0,i0,i1
 				sum += curdesc->opptr.l[0];
+
+				if (curdesc->delay.first() != NULL && (curdesc == seqlast || (curdesc->next() != NULL && curdesc->next()->physpc != curdesc->delay.first()->physpc)))
+				{
+					base = rsp->direct->read_decrypted_ptr(curdesc->delay.first()->physpc | 0x1000);
+					UML_LOAD(block, I1, base, 0, SIZE_DWORD, SCALE_x4);					// load    i1,base,dword
+					UML_ADD(block, I0, I0, I1);						// add     i0,i0,i1
+
+					sum += curdesc->delay.first()->opptr.l[0];
+				}
 			}
 		UML_CMP(block, I0, sum);											// cmp     i0,sum
 		UML_EXHc(block, COND_NE, *rsp->impstate->nocode, epc(seqhead));			// exne    nocode,seqhead->pc
@@ -3887,14 +3916,10 @@
 	{
 		generate_update_cycles(rsp, block, &compiler_temp, desc->targetpc, TRUE);	// <subtract cycles>
 		if (desc->flags & OPFLAG_INTRABLOCK_BRANCH)
-		{
 			UML_JMP(block, desc->targetpc | 0x80000000);							// jmp     desc->targetpc
-		}
 		else
-		{
 			UML_HASHJMP(block, 0, desc->targetpc, *rsp->impstate->nocode);
 																					// hashjmp <mode>,desc->targetpc,nocode
-		}
 	}
 	else
 	{
@@ -4596,6 +4621,11 @@
 				UML_MOV(block, mem(&rsp->impstate->arg0), RDREG);				// mov     [arg0],<rdreg>
 				UML_MOV(block, mem(&rsp->impstate->arg1), RTREG);				// mov     [arg1],<rtreg>
 				UML_CALLC(block, cfunc_get_cop0_reg, rsp);							// callc   cfunc_get_cop0_reg
+				if(RDREG == 2)
+				{
+					generate_update_cycles(rsp, block, compiler, mem(&rsp->pc), TRUE);
+					UML_HASHJMP(block, 0, mem(&rsp->pc), *rsp->impstate->nocode);
+				}
 			}
 			return TRUE;
 
@@ -4751,10 +4781,10 @@
 
 		case CPUINFO_INT_INPUT_STATE:					info->i = CLEAR_LINE;					break;
 
-		case CPUINFO_INT_PREVIOUSPC:					info->i = rsp->ppc;						break;
+		case CPUINFO_INT_PREVIOUSPC:					info->i = rsp->ppc | 0x04000000;						break;
 
 		case CPUINFO_INT_PC:	/* intentional fallthrough */
-		case CPUINFO_INT_REGISTER + RSP_PC:				info->i = rsp->pc;						break;
+		case CPUINFO_INT_REGISTER + RSP_PC:				info->i = rsp->pc | 0x04000000;						break;
 
 		case CPUINFO_INT_REGISTER + RSP_R0:				info->i = rsp->r[0];						break;
 		case CPUINFO_INT_REGISTER + RSP_R1:				info->i = rsp->r[1];						break;
@@ -4788,9 +4818,9 @@
 		case CPUINFO_INT_REGISTER + RSP_R29:			info->i = rsp->r[29];					break;
 		case CPUINFO_INT_REGISTER + RSP_R30:			info->i = rsp->r[30];					break;
 		case CPUINFO_INT_SP:
-		case CPUINFO_INT_REGISTER + RSP_R31:			info->i = rsp->r[31];					break;
+		case CPUINFO_INT_REGISTER + RSP_R31:			info->i = rsp->r[31];					 break;
 		case CPUINFO_INT_REGISTER + RSP_SR:             info->i = rsp->sr;                       break;
-		case CPUINFO_INT_REGISTER + RSP_NEXTPC:         info->i = rsp->nextpc;                   break;
+		case CPUINFO_INT_REGISTER + RSP_NEXTPC:         info->i = rsp->nextpc | 0x04000000;      break;
 		case CPUINFO_INT_REGISTER + RSP_STEPCNT:        info->i = rsp->step_count;               break;
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
@@ -4812,7 +4842,7 @@
 
 		case CPUINFO_STR_FLAGS:							strcpy(info->s, " ");					break;
 
-		case CPUINFO_STR_REGISTER + RSP_PC:				sprintf(info->s, "PC: %08X", rsp->pc);	break;
+		case CPUINFO_STR_REGISTER + RSP_PC:				sprintf(info->s, "PC: %08X", rsp->pc | 0x04000000);	break;
 
 		case CPUINFO_STR_REGISTER + RSP_R0:				sprintf(info->s, "R0: %08X", rsp->r[0]); break;
 		case CPUINFO_STR_REGISTER + RSP_R1:				sprintf(info->s, "R1: %08X", rsp->r[1]); break;
diff -Nru src-old/emu/cpu/rsp/rspfe.c src/emu/cpu/rsp/rspfe.c
--- src-old/emu/cpu/rsp/rspfe.c	2011-01-24 06:09:05.000000000 +0100
+++ src/emu/cpu/rsp/rspfe.c	2012-02-23 15:30:03.000000000 +0100
@@ -274,6 +274,10 @@
 
 		case 0x04:	// MTCz
 			desc.regin[0] |= REGFLAG_R(RTREG);
+			if(RDREG == 2) // SP_RD_LEN, initiating DMA
+			{
+				desc.flags |= OPFLAG_END_SEQUENCE;
+			}
 			return true;
 	}
 
diff -Nru src-old/emu/devcb.c src/emu/devcb.c
--- src-old/emu/devcb.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/devcb.c	2012-02-25 20:15:32.000000000 +0100
@@ -82,9 +82,10 @@
 
 const input_port_config *devcb_resolver::resolve_port(const char *tag, device_t &current)
 {
-	const input_port_config *result = current.machine().port(tag);
+	astring fullname;
+	const input_port_config *result = current.machine().port(current.siblingtag(fullname, tag));
 	if (result == NULL)
-		throw emu_fatalerror("Unable to find input port '%s' (requested by %s '%s')", tag, current.name(), current.tag());
+		throw emu_fatalerror("Unable to find input port '%s' (requested by %s '%s')", fullname.cstr(), current.name(), current.tag());
 	return result;
 }
 
diff -Nru src-old/emu/device.c src/emu/device.c
--- src-old/emu/device.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/device.c	2012-02-25 20:21:35.000000000 +0100
@@ -394,7 +394,7 @@
 	state_registrations = machine().save().registration_count() - state_registrations;
 	device_execute_interface *exec;
 	device_sound_interface *sound;
-	if (state_registrations == 0 && (interface(exec) || interface(sound)))
+	if (state_registrations == 0 && (interface(exec) || interface(sound)) && type() != SPEAKER)
 	{
 		logerror("Device '%s' did not register any state to save!\n", tag());
 		if ((machine().system().flags & GAME_SUPPORTS_SAVE) != 0)
diff -Nru src-old/emu/diimage.c src/emu/diimage.c
--- src-old/emu/diimage.c	2012-02-16 22:53:30.000000000 +0100
+++ src/emu/diimage.c	2012-02-26 15:31:24.000000000 +0100
@@ -38,6 +38,7 @@
 ***************************************************************************/
 
 #include "emu.h"
+#include "emuopts.h"
 #include "ui.h"
 #include "zippath.h"
 #include "uiimage.h"
@@ -845,7 +846,7 @@
     load_internal - core image loading
 -------------------------------------------------*/
 
-bool device_image_interface::load_internal(const char *path, bool is_create, int create_format, option_resolution *create_args)
+bool device_image_interface::load_internal(const char *path, bool is_create, int create_format, option_resolution *create_args, bool just_load)
 {
     UINT32 open_plan[4];
     int i;
@@ -872,7 +873,7 @@
         goto done;
 
 	/* Check if there's a software list defined for this device and use that if we're not creating an image */
-	if (!filename_has_period)
+	if (!filename_has_period && !just_load)
 	{
 		softload = load_software_part( device().machine().options(), this, path, &m_software_info_ptr, &m_software_part_ptr, &m_full_software_name, &m_software_list_name );
 		// if we had launched from softlist with a specified part, e.g. "shortname:part"
@@ -926,6 +927,10 @@
     /* success! */
 
 done:
+	if (just_load) {
+		if(m_err) clear();
+		return m_err ? IMAGE_INIT_FAIL : IMAGE_INIT_PASS;
+	}
     if (m_err!=0) {
 		if (!m_init_phase)
 		{
@@ -962,9 +967,26 @@
 
 bool device_image_interface::load(const char *path)
 {
-    return load_internal(path, FALSE, 0, NULL);
+    return load_internal(path, FALSE, 0, NULL, FALSE);
 }
 
+/*-------------------------------------------------
+    open_image_file - opening plain image file
+-------------------------------------------------*/
+
+bool device_image_interface::open_image_file(emu_options &options)
+{
+	const char* path = options.value(instance_name());
+	if (strlen(path)>0)
+	{
+		set_init_phase();
+		if (load_internal(path, FALSE, 0, NULL, TRUE)==IMAGE_INIT_PASS)
+		{
+			if (software_entry()==NULL) return true;
+		}
+	}
+	return false;
+}
 
 /*-------------------------------------------------
     image_finish_load - special call - only use
@@ -1016,7 +1038,7 @@
 bool device_image_interface::create(const char *path, const image_device_format *create_format, option_resolution *create_args)
 {
     int format_index = (create_format != NULL) ? create_format->m_index : 0;
-    return load_internal(path, TRUE, format_index, create_args);
+    return load_internal(path, TRUE, format_index, create_args, FALSE);
 }
 
 
diff -Nru src-old/emu/diimage.h src/emu/diimage.h
--- src-old/emu/diimage.h	2012-01-30 15:32:31.000000000 +0100
+++ src/emu/diimage.h	2012-02-21 13:43:14.000000000 +0100
@@ -246,6 +246,7 @@
 	image_device_format *formatlist() const { return m_formatlist; }
 
 	bool load(const char *path);
+	bool open_image_file(emu_options &options);
 	bool finish_load();
 	void unload();
 	bool create(const char *path, const image_device_format *create_format, option_resolution *create_args);
@@ -253,7 +254,7 @@
 	int reopen_for_write(const char *path);
 
 protected:
-	bool load_internal(const char *path, bool is_create, int create_format, option_resolution *create_args);
+	bool load_internal(const char *path, bool is_create, int create_format, option_resolution *create_args, bool just_load);
 	void determine_open_plan(int is_create, UINT32 *open_plan);
 	image_error_t load_image_by_path(UINT32 open_flags, const char *path);
 	void clear();
diff -Nru src-old/emu/dimemory.c src/emu/dimemory.c
--- src-old/emu/dimemory.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/dimemory.c	2012-02-20 07:06:58.000000000 +0100
@@ -301,11 +301,12 @@
 					device().siblingtag(entry_region, entry->m_region);
 
 					// look for the region
-					for (const rom_source *source = rom_first_source(device().mconfig()); source != NULL && !found; source = rom_next_source(*source))
-						for (const rom_entry *romp = rom_first_region(*source); romp != NULL && !found; romp = rom_next_region(romp))
+					device_iterator deviter(device().mconfig().root_device());
+					for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+						for (const rom_entry *romp = rom_first_region(*device); romp != NULL && !found; romp = rom_next_region(romp))
 						{
 							astring fulltag;
-							rom_region_name(fulltag, &device().mconfig().gamedrv(), source, romp);
+							rom_region_name(fulltag, *device, romp);
 							if (fulltag == entry_region)
 							{
 								// verify the address range is within the region's bounds
diff -Nru src-old/emu/diserial.c src/emu/diserial.c
--- src-old/emu/diserial.c	2011-09-06 14:39:18.000000000 +0200
+++ src/emu/diserial.c	2012-02-26 14:42:03.000000000 +0100
@@ -37,12 +37,58 @@
 
 		m_serial_parity_table[i] = sum & 0x01;
 	}
+	m_rcv_clock = NULL;
+	m_tra_clock = NULL;
 }
 
 device_serial_interface::~device_serial_interface()
 {
 }
 
+//-------------------------------------------------
+//  interface_pre_start - work to be done prior to
+//  actually starting a device
+//-------------------------------------------------
+
+void device_serial_interface::interface_pre_start()
+{
+	m_rcv_clock = device().machine().scheduler().timer_alloc(timer_expired_delegate(FUNC(device_serial_interface::rcv_timer), this));
+	m_tra_clock = device().machine().scheduler().timer_alloc(timer_expired_delegate(FUNC(device_serial_interface::tra_timer), this));
+}
+
+void device_serial_interface::set_rcv_rate(int baud)
+{
+	m_rcv_baud = baud;
+	receive_register_reset();
+	m_rcv_clock->adjust(attotime::never);
+}
+
+void device_serial_interface::set_tra_rate(int baud)
+{
+	m_tra_baud = baud;
+	transmit_register_reset();
+	m_tra_clock->adjust(attotime::never);
+}
+
+void device_serial_interface::tra_timer(void *ptr, int param)
+{
+	tra_callback();
+	if(is_transmit_register_empty())
+	{
+		m_tra_clock->adjust(attotime::never);
+		tra_complete();
+	}
+}
+
+void device_serial_interface::rcv_timer(void *ptr, int param)
+{
+	rcv_callback();
+	if(is_receive_register_full())
+	{
+		m_rcv_clock->adjust(attotime::never);
+		rcv_complete();
+	}
+}
 
 void device_serial_interface::set_data_frame(int num_data_bits, int stop_bit_count, int parity_code)
 {
@@ -66,6 +112,22 @@
 	m_rcv_flags |= RECEIVE_REGISTER_WAITING_FOR_START_BIT;
 }
 
+UINT8 device_serial_interface::check_for_start(UINT8 bit)
+{
+	m_rcv_line = bit;
+	if(m_rcv_flags & RECEIVE_REGISTER_SYNCHRONISED)
+		return 0;
+	receive_register_update_bit(bit);
+	if(m_rcv_flags & RECEIVE_REGISTER_SYNCHRONISED)
+	{
+		if(m_rcv_clock && m_rcv_baud)
+			// make start delay just a bit longer to make sure we are called after the sender
+			m_rcv_clock->adjust(attotime::from_hz((m_rcv_baud*2)/3), 0, attotime::from_hz(m_rcv_baud));
+		return 1;
+	}
+	return 0;
+}
+
 /* this is generic code to be used in serial chip implementations */
 /* the majority of serial chips work in the same way and this code will work */
 /* for them */
@@ -76,12 +138,12 @@
 	int previous_bit;
 
 	//LOG(("receive register receive bit: %1x\n",bit));
-	previous_bit = m_rcv_register_data & 1;
+	previous_bit = (m_rcv_register_data & 0x8000) && 1;
 
 	/* shift previous bit 7 out */
-	m_rcv_register_data = m_rcv_register_data<<1;
+	m_rcv_register_data = m_rcv_register_data>>1;
 	/* shift new bit in */
-	m_rcv_register_data = (m_rcv_register_data & 0xfffe) | bit;
+	m_rcv_register_data = (m_rcv_register_data & 0x7fff) | (bit<<15);
 	/* update bit count received */
 	m_rcv_bit_count_received++;
 
@@ -123,47 +185,34 @@
 
 void device_serial_interface::receive_register_extract()
 {
-	unsigned long data_shift;
 	UINT8 data;
 
 	receive_register_reset();
 
-	data_shift = 0;
-
-	/* if parity is even or odd, there should be a parity bit in the stream! */
-	if (m_df_parity!=SERIAL_PARITY_NONE)
-	{
-		data_shift++;
-	}
-
-	data_shift+=m_df_stop_bit_count;
-
 	/* strip off stop bits and parity */
-	data = m_rcv_register_data>>data_shift;
+	data = m_rcv_register_data>>(16-m_rcv_bit_count);
 
 	/* mask off other bits so data byte has 0's in unused bits */
-	data = data & (0x0ff
-		>>
-		(8-(m_df_word_length)));
+	data &= ~(0xff<<m_df_word_length);
 
 	m_rcv_byte_received  = data;
 
+	if(m_df_parity == SERIAL_PARITY_NONE)
+		return;
+
+	//unsigned char computed_parity;
+	//unsigned char parity_received;
+
+	/* get state of parity bit received */
+	//parity_received = (m_rcv_register_data>>m_df_word length) & 0x01;
+
 	/* parity enable? */
 	switch (m_df_parity)
 	{
-		case SERIAL_PARITY_NONE:
-			break;
-
 		/* check parity */
 		case SERIAL_PARITY_ODD:
 		case SERIAL_PARITY_EVEN:
 		{
-			//unsigned char computed_parity;
-			//unsigned char parity_received;
-
-			/* get state of parity bit received */
-			//parity_received = (m_rcv_register_data>>m_df_stop_bit_count) & 0x01;
-
 			/* compute parity for received bits */
 			//computed_parity = serial_helper_get_parity(data);
 
@@ -182,6 +231,10 @@
 
 		}
 		break;
+		case SERIAL_PARITY_MARK:
+		case SERIAL_PARITY_SPACE:
+			//computed_parity = parity_received;
+			break;
 	}
 }
 
@@ -210,6 +263,8 @@
 	int i;
 	unsigned char transmit_data;
 
+	if(m_tra_clock && m_tra_baud)
+		m_tra_clock->adjust(attotime::from_hz(m_tra_baud), 0, attotime::from_hz(m_tra_baud));
 
 	m_tra_bit_count_transmitted = 0;
 	m_tra_bit_count = 0;
@@ -225,23 +280,34 @@
 		int databit;
 
 		/* get bit from data */
-		databit = (transmit_data>>(m_df_word_length-1)) & 0x01;
+		databit = transmit_data & 0x01;
 		/* add bit to formatted byte */
 		transmit_register_add_bit(databit);
-		transmit_data = transmit_data<<1;
+		transmit_data = transmit_data>>1;
 	}
 
 	/* parity */
 	if (m_df_parity!=SERIAL_PARITY_NONE)
 	{
 		/* odd or even parity */
-		unsigned char parity;
-
-		/* get parity */
-		/* if parity = 0, data has even parity - i.e. there is an even number of one bits in the data */
-		/* if parity = 1, data has odd parity - i.e. there is an odd number of one bits in the data */
-		parity = serial_helper_get_parity(data_byte);
+		unsigned char parity = 0;
+		switch(m_df_parity)
+		{
+		case SERIAL_PARITY_EVEN:
+		case SERIAL_PARITY_ODD:
 
+			/* get parity */
+			/* if parity = 0, data has even parity - i.e. there is an even number of one bits in the data */
+			/* if parity = 1, data has odd parity - i.e. there is an odd number of one bits in the data */
+			parity = serial_helper_get_parity(data_byte);
+			break;
+		case SERIAL_PARITY_MARK:
+			parity = 1;
+			break;
+		case SERIAL_PARITY_SPACE:
+			parity = 0;
+			break;
+		}
 		transmit_register_add_bit(parity);
 	}
 
@@ -258,9 +324,7 @@
 {
 	int bit;
 
-	bit = (m_tra_register_data>>
-		(m_tra_bit_count - 1 -
-		m_tra_bit_count_transmitted)) & 0x01;
+	bit = (m_tra_register_data>>(m_tra_bit_count-1-m_tra_bit_count_transmitted))&1;
 
 	m_tra_bit_count_transmitted++;
 
diff -Nru src-old/emu/diserial.h src/emu/diserial.h
--- src-old/emu/diserial.h	2011-09-06 14:39:18.000000000 +0200
+++ src/emu/diserial.h	2012-02-26 15:31:24.000000000 +0100
@@ -19,7 +19,9 @@
 {
 	SERIAL_PARITY_NONE,		/* no parity. a parity bit will not be in the transmitted/received data */
 	SERIAL_PARITY_ODD,		/* odd parity */
-	SERIAL_PARITY_EVEN		/* even parity */
+	SERIAL_PARITY_EVEN,		/* even parity */
+	SERIAL_PARITY_MARK,		/* one parity */
+	SERIAL_PARITY_SPACE		/* zero parity */
 };
 
 /*
@@ -73,7 +75,6 @@
 /* TX = Transmit data. (OUTPUT) */
 #define SERIAL_STATE_TX_DATA	0x00020
 
-
 // ======================> device_serial_interface
 class device_serial_interface : public device_interface
 {
@@ -90,6 +91,8 @@
 	void receive_register_update_bit(int bit);
 	void receive_register_extract();
 
+	void set_rcv_rate(int baud);
+	void set_tra_rate(int baud);
 
 	void transmit_register_reset();
 	void transmit_register_add_bit(int bit);
@@ -112,10 +115,21 @@
 	void set_other_connection(device_serial_interface *other_connection);
 
 	void connect(device_serial_interface *other_connection);
+	UINT8 check_for_start(UINT8 bit);
 protected:
 	UINT8 m_input_state;
 	UINT8 m_connection_state;
+	virtual void tra_callback() { }
+	virtual void rcv_callback() { receive_register_update_bit(m_rcv_line); }
+	virtual void tra_complete() { }
+	virtual void rcv_complete() { }
+
+	// interface-level overrides
+	virtual void interface_pre_start();
 private:
+	void tra_timer(void *ptr, int param);
+	void rcv_timer(void *ptr, int param);
+
 	UINT8 m_serial_parity_table[256];
 
 	// Data frame
@@ -148,6 +162,12 @@
 	/* length of data to send */
 	UINT8 m_tra_bit_count;
 
+	emu_timer *m_rcv_clock;
+	emu_timer *m_tra_clock;
+	int m_rcv_baud;
+	int m_tra_baud;
+	UINT8 m_rcv_line;
+
 	device_serial_interface *m_other_connection;
 };
 
diff -Nru src-old/emu/disound.c src/emu/disound.c
--- src-old/emu/disound.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/disound.c	2012-02-26 15:31:24.000000000 +0100
@@ -79,9 +79,7 @@
 		throw emu_fatalerror("MCFG_SOUND_ROUTE called on device '%s' with no sound interface", device.tag());
 
 	// append a new route to the list
-	astring devtag;
-	device.siblingtag(devtag, target);
-	sound->m_route_list.append(*global_alloc(sound_route(output, input, gain, devtag.cstr())));
+	sound->m_route_list.append(*global_alloc(sound_route(output, input, gain, target)));
 }
 
 
@@ -265,7 +263,7 @@
 		for (const sound_route *route = sound->first_route(); route != NULL; route = route->next())
 		{
 			// see if we are the target of this route; if we are, make sure the source device is started
-			device_t *target_device = m_device.machine().device(route->m_target);
+			device_t *target_device = sound->device().siblingdevice(route->m_target);
 			if (target_device == &m_device && !sound->device().started())
 				throw device_missing_dependencies();
 		}
@@ -279,7 +277,7 @@
 		for (const sound_route *route = sound->first_route(); route != NULL; route = route->next())
 		{
 			// see if we are the target of this route
-			device_t *target_device = m_device.machine().device(route->m_target);
+			device_t *target_device = sound->device().siblingdevice(route->m_target);
 			if (target_device == &m_device && route->m_input == AUTO_ALLOC_INPUT)
 			{
 				const_cast<sound_route *>(route)->m_input = m_auto_allocated_inputs;
@@ -305,7 +303,7 @@
 		for (const sound_route *route = sound->first_route(); route != NULL; route = route->next())
 		{
 			// if we are the target of this route, hook it up
-			device_t *target_device = m_device.machine().device(route->m_target);
+			device_t *target_device = sound->device().siblingdevice(route->m_target);
 			if (target_device == &m_device)
 			{
 				// iterate over all outputs, matching any that apply
@@ -366,3 +364,84 @@
 	  m_target(target)
 {
 }
+
+
+
+//**************************************************************************
+//  SIMPLE DERIVED MIXER INTERFACE
+//**************************************************************************
+
+//-------------------------------------------------
+//  device_mixer_interface - constructor
+//-------------------------------------------------
+
+device_mixer_interface::device_mixer_interface(const machine_config &mconfig, device_t &device, int outputs)
+	: device_sound_interface(mconfig, device),
+	  m_outputs(outputs),
+	  m_mixer_stream(NULL)
+{
+}
+
+
+//-------------------------------------------------
+//  ~device_mixer_interface - destructor
+//-------------------------------------------------
+
+device_mixer_interface::~device_mixer_interface()
+{
+}
+
+
+//-------------------------------------------------
+//  interface_pre_start - perform startup prior
+//  to the device startup
+//-------------------------------------------------
+
+void device_mixer_interface::interface_pre_start()
+{
+	// call our parent
+	device_sound_interface::interface_pre_start();
+
+	// no inputs? that's weird
+	if (m_auto_allocated_inputs == 0)
+	{
+		logerror("Warning: mixer \"%s\" has no inputs\n", device().tag());
+		return;
+	}
+
+	// allocate the mixer stream
+	m_mixer_stream = stream_alloc(m_auto_allocated_inputs, m_outputs, device().machine().sample_rate());
+}
+
+
+//-------------------------------------------------
+//  interface_post_load - after we load a save
+//  state be sure to update the mixer stream's
+//  output sample rate
+//-------------------------------------------------
+
+void device_mixer_interface::interface_post_load()
+{
+	m_mixer_stream->set_sample_rate(device().machine().sample_rate());
+
+	// call our parent
+	device_sound_interface::interface_post_load();
+}
+
+
+//-------------------------------------------------
+//  mixer_update - mix all inputs to one output
+//-------------------------------------------------
+
+void device_mixer_interface::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
+{
+	// loop over samples
+	for (int pos = 0; pos < samples; pos++)
+	{
+		// add up all the inputs
+		INT32 sample = inputs[0][pos];
+		for (int inp = 1; inp < m_auto_allocated_inputs; inp++)
+			sample += inputs[inp][pos];
+		outputs[0][pos] = sample;
+	}
+}
diff -Nru src-old/emu/disound.h src/emu/disound.h
--- src-old/emu/disound.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/disound.h	2012-02-25 20:21:35.000000000 +0100
@@ -152,4 +152,29 @@
 // iterator
 typedef device_interface_iterator<device_sound_interface> sound_interface_iterator;
 
+
+
+// ======================> device_mixer_interface
+
+class device_mixer_interface : public device_sound_interface
+{
+public:
+	// construction/destruction
+	device_mixer_interface(const machine_config &mconfig, device_t &device, int outputs = 1);
+	virtual ~device_mixer_interface();
+
+protected:
+	// optional operation overrides
+	virtual void interface_pre_start();
+	virtual void interface_post_load();
+
+	// sound interface overrides
+	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+
+	// internal state
+	UINT8				m_outputs;				// number of outputs
+	sound_stream *		m_mixer_stream;			// mixing stream
+};
+
+
 #endif	/* __DISOUND_H__ */
diff -Nru src-old/emu/hash.c src/emu/hash.c
--- src-old/emu/hash.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/hash.c	2012-02-21 07:29:54.000000000 +0100
@@ -307,7 +307,7 @@
 
 	// loop until we hit it
 	bool errors = false;
-	bool skip_digits = false;
+	int skip_digits = 0;
 	while (ptr < stringend)
 	{
 		char c = *ptr++;
@@ -316,10 +316,21 @@
 		// non-hex alpha values specify a hash type
 		if (uc >= 'G' && uc <= 'Z')
 		{
+			if (skip_digits != 0)
+				errors = true;
+			skip_digits = 0;
 			if (uc == HASH_CRC)
-				skip_digits = m_has_crc32 = m_crc32.from_string(ptr, stringend - ptr);
+			{
+				m_has_crc32 = true;
+				errors = !m_crc32.from_string(ptr, stringend - ptr);
+				skip_digits = 2 * sizeof(crc32_t);
+			}
 			else if (uc == HASH_SHA1)
-				skip_digits = m_has_sha1 = m_sha1.from_string(ptr, stringend - ptr);
+			{
+				m_has_sha1 = true;
+				errors = !m_sha1.from_string(ptr, stringend - ptr);
+				skip_digits = 2 * sizeof(sha1_t);
+			}
 			else
 				errors = true;
 		}
@@ -327,11 +338,15 @@
 		// hex values are ignored, though unexpected
 		else if ((uc >= '0' && uc <= '9') || (uc >= 'A' && uc <= 'F'))
 		{
-			if (!skip_digits)
+			if (skip_digits != 0)
+				skip_digits--;
+			else
 				errors = true;
 		}
 
 		// anything else is a flag
+		else if (skip_digits != 0)
+			errors = true;
 		else
 			m_flags.cat(c);
 	}
@@ -386,9 +401,6 @@
 {
 	assert(m_creator != NULL);
 
-	// default to getting nothing
-	m_has_crc32 = m_has_sha1 = false;
-
 	// finish up the CRC32
 	if (m_creator->m_doing_crc32)
 	{
diff -Nru src-old/emu/image.c src/emu/image.c
--- src-old/emu/image.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/image.c	2012-02-20 12:42:40.000000000 +0100
@@ -470,23 +470,3 @@
     if (filerr == FILERR_NONE)
         file.write(buffer, length);
 }
-
-/*-------------------------------------------------
-    image_from_absolute_index - retreives index number
-    of image in device list
--------------------------------------------------*/
-device_image_interface *image_from_absolute_index(running_machine &machine, int absolute_index)
-{
-	image_interface_iterator iter(machine.root_device());
-	return iter.byindex(absolute_index);
-}
-
-/*-------------------------------------------------
-    image_add_device_with_subdevices - adds
-    device with parameters sent, and all subdevices
-    from it's machine config devices list
--------------------------------------------------*/
-void image_add_device_with_subdevices(device_t *owner, device_type type, const char *tag, UINT32 clock)
-{
-	owner->machine().add_dynamic_device(*owner, type, tag, clock);
-}
diff -Nru src-old/emu/image.h src/emu/image.h
--- src-old/emu/image.h	2012-01-03 01:21:13.000000000 +0100
+++ src/emu/image.h	2012-02-20 12:42:40.000000000 +0100
@@ -27,9 +27,4 @@
 void image_battery_save_by_name(emu_options &options, const char *filename, const void *buffer, int length);
 
 astring &image_info_astring(running_machine &machine, astring &string);
-
-device_image_interface *image_from_absolute_index(running_machine &machine, int absolute_index);
-
-void image_add_device_with_subdevices(device_t *owner, device_type type, const char *tag, UINT32 clock);
-
 #endif /* __IMAGE_H__ */
diff -Nru src-old/emu/imagedev/bitbngr.c src/emu/imagedev/bitbngr.c
--- src-old/emu/imagedev/bitbngr.c	2011-11-16 01:38:05.000000000 +0100
+++ src/emu/imagedev/bitbngr.c	2012-02-20 09:05:19.000000000 +0100
@@ -154,7 +154,7 @@
 UINT32 bitbanger_device::baud_value(void)
 {
 	static const float bauds[] = { 150.0f, 300.0f, 600.0f, 1200.0f, 2400.0f, 4800.0f, 9600.0f,
-            14400.0f, 28800.0f, 38400.0f, 57600.0f, 115200.0f};
+            14400.0f, 19200.0f, 28800.0f, 38400.0f, 57600.0f, 115200.0f};
 	float result = tune_value() * bauds[m_baud];
 	return (UINT32)result;
 }
@@ -167,7 +167,7 @@
 const char *bitbanger_device::baud_string(void)
 {
 	static const char *const bauds[] = { "150", "300", "600", "1200", "2400", "4800",
-                     "9600", "14400", "28800", "38400", "57600", "115200"};
+                     "9600", "14400", "19200", "28800", "38400", "57600", "115200"};
 
 	return(bauds[m_baud]);
 }
@@ -303,8 +303,6 @@
 
 void bitbanger_device::device_start(void)
 {
-	const bitbanger_config *config = (const bitbanger_config *) static_config();
-
 	/* output config */
 	m_build_count = 0;
 	m_output_timer = timer_alloc(TIMER_OUTPUT);
@@ -316,13 +314,13 @@
 	m_input_buffer_cursor = 0;
 
 	/* defaults */
-	m_mode = config->m_default_mode;
-	m_baud = config->m_default_baud;
-	m_tune = config->m_default_tune;
+	m_mode = m_default_mode;
+	m_baud = m_default_baud;
+	m_tune = m_default_tune;
 	m_current_baud = attotime::from_hz(baud_value());
 
 	/* callback */
-	m_input_callback.resolve(config->m_input_callback, *this);
+	m_input_func.resolve(m_input_callback, *this);
 }
 
 
@@ -333,6 +331,18 @@
 
 void bitbanger_device::device_config_complete(void)
 {
+	const _bitbanger_config *intf = reinterpret_cast<const _bitbanger_config *>(static_config());
+	if(intf != NULL)
+	{
+		*static_cast<_bitbanger_config *>(this) = *intf;
+	}
+	else
+	{
+		memset(&m_input_callback, 0, sizeof(m_input_callback));
+		m_default_mode = 0;
+		m_default_baud = 0;
+		m_default_tune = 0;
+	}
 	update_names();
 }
 
@@ -433,10 +443,7 @@
 	if (m_current_input != line)
 	{
 		m_current_input = line;
-		if (!m_input_callback.isnull())
-		{
-			m_input_callback(line ? ASSERT_LINE : CLEAR_LINE);
-		}
+		m_input_func(line ? ASSERT_LINE : CLEAR_LINE);
 	}
 }
 
diff -Nru src-old/emu/imagedev/bitbngr.h src/emu/imagedev/bitbngr.h
--- src-old/emu/imagedev/bitbngr.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/imagedev/bitbngr.h	2012-02-19 17:46:00.000000000 +0100
@@ -84,7 +84,8 @@
 
 
 class bitbanger_device :	public device_t,
-							public device_image_interface
+							public device_image_interface,
+							public _bitbanger_config
 {
 public:
 	// construction/destruction
@@ -145,7 +146,7 @@
 	// variables
 	emu_timer *					m_output_timer;
 	emu_timer *					m_input_timer;
-	devcb_resolved_write_line	m_input_callback;
+	devcb_resolved_write_line	m_input_func;
 	int							m_output_value;
 	int							m_build_count;
 	int							m_build_byte;
diff -Nru src-old/emu/imagedev/cartslot.c src/emu/imagedev/cartslot.c
--- src-old/emu/imagedev/cartslot.c	2012-01-11 12:13:36.000000000 +0100
+++ src/emu/imagedev/cartslot.c	2012-02-20 07:06:58.000000000 +0100
@@ -171,13 +171,12 @@
 
 int cartslot_image_device::process_cartridge(bool load)
 {
-	const rom_source *source;
 	const rom_entry *romrgn, *roment;
 	int result = 0;
 
-	for (source = rom_first_source(device().machine().config()); source != NULL; source = rom_next_source(*source))
-	{
-		for (romrgn = rom_first_region(*source); romrgn != NULL; romrgn = rom_next_region(romrgn))
+	device_iterator deviter(device().mconfig().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		for (romrgn = rom_first_region(*device); romrgn != NULL; romrgn = rom_next_region(romrgn))
 		{
 			roment = romrgn + 1;
 			while(!ROMENTRY_ISREGIONEND(roment))
@@ -185,9 +184,9 @@
 				if (ROMENTRY_GETTYPE(roment) == ROMENTRYTYPE_CARTRIDGE)
 				{
 					astring regiontag;
-					device().siblingtag(regiontag, roment->_hashdata);
+					this->device().siblingtag(regiontag, roment->_hashdata);
 
-					if (strcmp(regiontag.cstr(),device().tag())==0)
+					if (strcmp(regiontag.cstr(),this->device().tag())==0)
 					{
 						result |= load_cartridge(romrgn, roment, load);
 
@@ -199,7 +198,6 @@
 				roment++;
 			}
 		}
-	}
 
 	return IMAGE_INIT_PASS;
 }
diff -Nru src-old/emu/imagedev/floppy.h src/emu/imagedev/floppy.h
--- src-old/emu/imagedev/floppy.h	2012-01-23 22:49:30.000000000 +0100
+++ src/emu/imagedev/floppy.h	2012-02-23 15:19:37.000000000 +0100
@@ -165,7 +165,7 @@
 	floppy_35_dd(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 	virtual ~floppy_35_dd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
-
+	virtual void device_config_complete() { m_shortname = "floppy_35_dd"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -175,7 +175,7 @@
 	floppy_35_dd_nosd(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 	virtual ~floppy_35_dd_nosd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
-
+	virtual void device_config_complete() { m_shortname = "floppy_35_dd_nosd"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -185,7 +185,7 @@
 	floppy_35_hd(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 	virtual ~floppy_35_hd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
-
+	virtual void device_config_complete() { m_shortname = "floppy_35_hd"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -195,7 +195,7 @@
 	floppy_35_ed(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 	virtual ~floppy_35_ed();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
-
+	virtual void device_config_complete() { m_shortname = "floppy_35_ed"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -205,7 +205,7 @@
 	floppy_525_dd(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 	virtual ~floppy_525_dd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
-
+	virtual void device_config_complete() { m_shortname = "floppy_525_dd"; }
 protected:
 	virtual void setup_characteristics();
 };
diff -Nru src-old/emu/imagedev/harddriv.c src/emu/imagedev/harddriv.c
--- src-old/emu/imagedev/harddriv.c	2012-02-19 02:59:23.000000000 +0100
+++ src/emu/imagedev/harddriv.c	2012-02-20 11:59:22.000000000 +0100
@@ -195,7 +195,6 @@
 		{
 			is_writeable = !is_readonly();
 			err = m_self_chd.open(*image_core_file(), is_writeable);
-			printf("%d\n",err);
 			if (err == CHDERR_NONE)
 				m_chd = &m_self_chd;
 
@@ -224,9 +223,7 @@
 				m_self_chd.close();
 			m_chd = NULL;
 		}
-		printf("%d\n",err);
 		seterror(IMAGE_ERROR_UNSPECIFIED, chd_file::error_string(err));
-		printf("%s\n",chd_file::error_string(err));
 	}
 	return err ? IMAGE_INIT_FAIL : IMAGE_INIT_PASS;
 }
diff -Nru src-old/emu/info.c src/emu/info.c
--- src-old/emu/info.c	2012-02-19 02:53:16.000000000 +0100
+++ src/emu/info.c	2012-02-26 15:31:24.000000000 +0100
@@ -179,6 +179,7 @@
 "\t\t\t<!ATTLIST slot name CDATA #REQUIRED>\n"
 "\t\t\t<!ELEMENT slotoption EMPTY>\n"
 "\t\t\t\t<!ATTLIST slotoption name CDATA #REQUIRED>\n"
+"\t\t\t\t<!ATTLIST slotoption devname CDATA #REQUIRED>\n"
 "\t\t\t\t<!ATTLIST slotoption default (yes|no) \"no\">\n"
 "\t\t<!ELEMENT softwarelist EMPTY>\n"
 "\t\t\t<!ATTLIST softwarelist name CDATA #REQUIRED>\n"
@@ -189,9 +190,6 @@
 "]>";
 
 
-extern const device_type *s_devices_sorted[];
-extern int m_device_count;
-
 //**************************************************************************
 //  INFO XML CREATOR
 //**************************************************************************
@@ -239,62 +237,19 @@
 		CONFIG_VERSION
 	);
 
-	m_device_used = global_alloc_array_clear(UINT8, m_device_count);
-
 	// iterate through the drivers, outputting one at a time
 	while (m_drivlist.next())
 		output_one();
 
-	// iterate through the devices, and output their roms
+	// output devices (both devices with roms and slot devices)
 	output_devices();
 
-	global_free(m_device_used);
-
 	// close the top level tag
 	fprintf(m_output, "</%s>\n",emulator_info::get_xml_root());
 }
 
 
 //-------------------------------------------------
-//  output_devices - print the XML information
-//  for one particular game driver
-//-------------------------------------------------
-
-void info_xml_creator::output_devices()
-{
-	m_drivlist.reset();
-	m_drivlist.next();
-	machine_config &config = m_drivlist.config();
-	device_t &owner = config.root_device();
-	// check if all are listed, note that empty one is included
-	bool display_all = driver_list::total() == (m_drivlist.count()+1);
-	for(int i=0;i<m_device_count;i++) {
-		if (display_all || (m_device_used[i]!=0)) {
-			device_type type = *s_devices_sorted[i];
-			device_t *dev = (*type)(config, "dummy", &owner, 0);
-			dev->config_complete();
-
-			// print the header and the game name
-			fprintf(m_output, "\t<%s",emulator_info::get_xml_top());
-			fprintf(m_output, " name=\"%s\"", xml_normalize_string(dev->shortname()));
-			fprintf(m_output, " isdevice=\"yes\"");
-			fprintf(m_output, " runnable=\"no\"");
-			fprintf(m_output, ">\n");
-
-			// output device description
-			if (dev->name() != NULL)
-				fprintf(m_output, "\t\t<description>%s</description>\n", xml_normalize_string(dev->name()));
-
-			output_rom(dev);
-
-			// close the topmost tag
-			fprintf(m_output, "\t</%s>\n",emulator_info::get_xml_top());
-			global_free(dev);
-		}
-	}
-}
-
-//-------------------------------------------------
 //  output_one - print the XML information
 //  for one particular game driver
 //-------------------------------------------------
@@ -359,19 +314,19 @@
 
 	// now print various additional information
 	output_bios();
-	output_rom(rom_first_source(m_drivlist.config()));
+	output_rom(m_drivlist.config().root_device());
 	output_device_roms();
 	output_sample();
-	output_chips();
-	output_display();
-	output_sound();
+	output_chips(m_drivlist.config().root_device(), "");
+	output_display(m_drivlist.config().root_device());
+	output_sound(m_drivlist.config().root_device());
 	output_input(portlist);
-	output_switches(portlist, IPT_DIPSWITCH, "dipswitch", "dipvalue");
-	output_switches(portlist, IPT_CONFIG, "configuration", "confsetting");
+	output_switches(portlist, "", IPT_DIPSWITCH, "dipswitch", "dipvalue");
+	output_switches(portlist, "", IPT_CONFIG, "configuration", "confsetting");
 	output_adjusters(portlist);
 	output_driver();
-	output_images();
-	output_slots();
+	output_images(m_drivlist.config().root_device(), "");
+	output_slots(m_drivlist.config().root_device(), "");
 	output_software_list();
 	output_ramoptions();
 
@@ -379,26 +334,126 @@
 	fprintf(m_output, "\t</%s>\n",emulator_info::get_xml_top());
 }
 
-//------------------------------------------------
-//  output_device_roms - print the device
-//  with roms, if appropriate
+
+//-------------------------------------------------
+//  output_one_device - print the XML info for
+//  a single device
 //-------------------------------------------------
 
-void info_xml_creator::output_device_roms()
+void info_xml_creator::output_one_device(device_t &device, const char *devtag)
 {
-	int cnt=0;
-	for (const rom_source *source = rom_first_source(m_drivlist.config()); source != NULL; source = rom_next_source(*source))
+	bool has_speaker = FALSE, has_input = FALSE;
+	// check if the device adds speakers to the system
+	sound_interface_iterator snditer(device);
+	if (snditer.first() != NULL)
+		has_speaker = TRUE;
+	// generate input list
+	ioport_list portlist;
+	astring errors;
+	device_iterator iptiter(device);
+	for (device_t *dev = iptiter.first(); dev != NULL; dev = iptiter.next())
+		input_port_list_init(*dev, portlist, errors);
+	// check if the device adds player inputs (other than dsw and configs) to the system
+	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
+		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
+			if (field->type >= IPT_START1 && field->type < __ipt_ui_start)
+			{
+				has_input = TRUE;
+				break;
+			}
+
+	// start to output info
+	fprintf(m_output, "\t<%s", emulator_info::get_xml_top());
+	fprintf(m_output, " name=\"%s\"", xml_normalize_string(device.shortname()));
+	fprintf(m_output, " isdevice=\"yes\"");
+	fprintf(m_output, " runnable=\"no\"");
+	fprintf(m_output, ">\n");
+	fprintf(m_output, "\t\t<description>%s</description>\n", xml_normalize_string(device.name()));
+
+	output_rom(device);
+	output_chips(device, devtag);
+	output_display(device);
+	if (has_speaker)
+		output_sound(device);
+	if (has_input)
+		output_input(portlist);
+	output_switches(portlist, devtag, IPT_DIPSWITCH, "dipswitch", "dipvalue");
+	output_switches(portlist, devtag, IPT_CONFIG, "configuration", "confsetting");
+	output_adjusters(portlist);
+	output_images(device, devtag);
+	output_slots(device, devtag);
+	fprintf(m_output, "\t</%s>\n", emulator_info::get_xml_top());
+}
+
+
+//-------------------------------------------------
+//  output_devices - print the XML info for devices
+//  with roms and for devices that can be mounted
+//  in slots
+//-------------------------------------------------
+
+typedef tagmap_t<FPTR> slot_map;
+
+void info_xml_creator::output_devices()
+{
+	m_drivlist.reset();
+	slot_map shortnames;
+
+	while (m_drivlist.next())
 	{
-		if (cnt!=0) {
-			fprintf(m_output, "\t\t<device_ref name=\"%s\"/>\n", xml_normalize_string(source->shortname()));
-			for(int i=0;i<m_device_count;i++) {
-				if (source->type() == *s_devices_sorted[i]) m_device_used[i] = 1;
+		// first, run through devices with roms which belongs to the default configuration
+		device_iterator deviter(m_drivlist.config().root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		{
+			if (device->owner() != NULL && device->rom_region() != NULL && device->shortname()!= NULL)
+			{
+				if (shortnames.add(device->shortname(), 0, FALSE) != TMERR_DUPLICATE)
+					output_one_device(*device, device->tag());
+			}
+		}
+
+		// then, run through slot devices
+		slot_interface_iterator iter(m_drivlist.config().root_device());
+		for (const device_slot_interface *slot = iter.first(); slot != NULL; slot = iter.next())
+		{
+			const slot_interface* intf = slot->get_slot_interfaces();
+			for (int i = 0; intf && intf[i].name != NULL; i++)
+			{
+				astring temptag("_");
+				temptag.cat(intf[i].name);
+				device_t *dev = const_cast<machine_config &>(m_drivlist.config()).device_add(&m_drivlist.config().root_device(), temptag.cstr(), intf[i].devtype, 0);
+
+				// notify this device and all its subdevices that they are now configured
+				device_iterator subiter(*dev);
+				for (device_t *device = subiter.first(); device != NULL; device = subiter.next())
+					if (!device->configured())
+						device->config_complete();
+
+				if (shortnames.add(dev->shortname(), 0, FALSE) != TMERR_DUPLICATE)
+					output_one_device(*dev, temptag.cstr());
+
+				const_cast<machine_config &>(m_drivlist.config()).device_remove(&m_drivlist.config().root_device(), temptag.cstr());
+				global_free(dev);
 			}
 		}
-		cnt++;
 	}
 }
 
+
+//------------------------------------------------
+//  output_device_roms - when a driver uses roms
+//  included in a device set, print a reference
+//-------------------------------------------------
+
+void info_xml_creator::output_device_roms()
+{
+	device_iterator deviter(m_drivlist.config().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		if (device->owner() != NULL && device->rom_region() != NULL && device->shortname()!= NULL)
+			fprintf(m_output, "\t\t<device_ref name=\"%s\"/>\n", xml_normalize_string(device->shortname()));
+}
+
+
 //------------------------------------------------
 //  output_sampleof - print the 'sampleof'
 //  attribute, if appropriate
@@ -453,98 +508,96 @@
 //  the XML output
 //-------------------------------------------------
 
-void info_xml_creator::output_rom(const rom_source *source)
+void info_xml_creator::output_rom(device_t &device)
 {
 	// iterate over 3 different ROM "types": BIOS, ROMs, DISKs
 	for (int rom_type = 0; rom_type < 3; rom_type++)
-	{
-			for (const rom_entry *region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+		for (const rom_entry *region = rom_first_region(device); region != NULL; region = rom_next_region(region))
+		{
+			bool is_disk = ROMREGION_ISDISKDATA(region);
+
+			// disk regions only work for disks
+			if ((is_disk && rom_type != 2) || (!is_disk && rom_type == 2))
+				continue;
+
+			// iterate through ROM entries
+			for (const rom_entry *rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
 			{
-				bool is_disk = ROMREGION_ISDISKDATA(region);
+				bool is_bios = ROM_GETBIOSFLAGS(rom);
+				const char *name = ROM_GETNAME(rom);
+				int offset = ROM_GETOFFSET(rom);
+				const char *merge_name = NULL;
+				char bios_name[100];
 
-				// disk regions only work for disks
-				if ((is_disk && rom_type != 2) || (!is_disk && rom_type == 2))
+				// BIOS ROMs only apply to bioses
+				if ((is_bios && rom_type != 0) || (!is_bios && rom_type == 0))
 					continue;
 
-				// iterate through ROM entries
-				for (const rom_entry *rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
+				// if we have a valid ROM and we are a clone, see if we can find the parent ROM
+				hash_collection hashes(ROM_GETHASHDATA(rom));
+				if (!hashes.flag(hash_collection::FLAG_NO_DUMP))
+					merge_name = get_merge_name(hashes);
+
+				// scan for a BIOS name
+				bios_name[0] = 0;
+				if (!is_disk && is_bios)
 				{
-					bool is_bios = ROM_GETBIOSFLAGS(rom);
-					const char *name = ROM_GETNAME(rom);
-					int offset = ROM_GETOFFSET(rom);
-					const char *merge_name = NULL;
-					char bios_name[100];
-
-					// BIOS ROMs only apply to bioses
-					if ((is_bios && rom_type != 0) || (!is_bios && rom_type == 0))
-						continue;
-
-					// if we have a valid ROM and we are a clone, see if we can find the parent ROM
-					hash_collection hashes(ROM_GETHASHDATA(rom));
-					if (!hashes.flag(hash_collection::FLAG_NO_DUMP))
-						merge_name = get_merge_name(hashes);
-
-					// scan for a BIOS name
-					bios_name[0] = 0;
-					if (!is_disk && is_bios)
-					{
-						// scan backwards through the ROM entries
-						for (const rom_entry *brom = rom - 1; brom != m_drivlist.driver().rom; brom--)
-							if (ROMENTRY_ISSYSTEM_BIOS(brom))
-							{
-								strcpy(bios_name, ROM_GETNAME(brom));
-								break;
-							}
-					}
+					// scan backwards through the ROM entries
+					for (const rom_entry *brom = rom - 1; brom != m_drivlist.driver().rom; brom--)
+						if (ROMENTRY_ISSYSTEM_BIOS(brom))
+						{
+							strcpy(bios_name, ROM_GETNAME(brom));
+							break;
+						}
+				}
 
-					// opening tag
-					if (!is_disk)
-						fprintf(m_output, "\t\t<rom");
-					else
-						fprintf(m_output, "\t\t<disk");
-
-					// add name, merge, bios, and size tags */
-					if (name != NULL && name[0] != 0)
-						fprintf(m_output, " name=\"%s\"", xml_normalize_string(name));
-					if (merge_name != NULL)
-						fprintf(m_output, " merge=\"%s\"", xml_normalize_string(merge_name));
-					if (bios_name[0] != 0)
-						fprintf(m_output, " bios=\"%s\"", xml_normalize_string(bios_name));
-					if (!is_disk)
-						fprintf(m_output, " size=\"%d\"", rom_file_size(rom));
+				// opening tag
+				if (!is_disk)
+					fprintf(m_output, "\t\t<rom");
+				else
+					fprintf(m_output, "\t\t<disk");
+
+				// add name, merge, bios, and size tags */
+				if (name != NULL && name[0] != 0)
+					fprintf(m_output, " name=\"%s\"", xml_normalize_string(name));
+				if (merge_name != NULL)
+					fprintf(m_output, " merge=\"%s\"", xml_normalize_string(merge_name));
+				if (bios_name[0] != 0)
+					fprintf(m_output, " bios=\"%s\"", xml_normalize_string(bios_name));
+				if (!is_disk)
+					fprintf(m_output, " size=\"%d\"", rom_file_size(rom));
 
-					// dump checksum information only if there is a known dump
-					if (!hashes.flag(hash_collection::FLAG_NO_DUMP))
-					{
-						// iterate over hash function types and print m_output their values
-						astring tempstr;
-						fprintf(m_output, " %s", hashes.attribute_string(tempstr));
-					}
-					else
-						fprintf(m_output, " status=\"nodump\"");
+				// dump checksum information only if there is a known dump
+				if (!hashes.flag(hash_collection::FLAG_NO_DUMP))
+				{
+					// iterate over hash function types and print m_output their values
+					astring tempstr;
+					fprintf(m_output, " %s", hashes.attribute_string(tempstr));
+				}
+				else
+					fprintf(m_output, " status=\"nodump\"");
 
-					// append a region name
-					fprintf(m_output, " region=\"%s\"", ROMREGION_GETTAG(region));
+				// append a region name
+				fprintf(m_output, " region=\"%s\"", ROMREGION_GETTAG(region));
 
-					// for non-disk entries, print offset
-					if (!is_disk)
-						fprintf(m_output, " offset=\"%x\"", offset);
+				// for non-disk entries, print offset
+				if (!is_disk)
+					fprintf(m_output, " offset=\"%x\"", offset);
 
-					// for disk entries, add the disk index
-					else
-					{
-						fprintf(m_output, " index=\"%x\"", DISK_GETINDEX(rom));
-						fprintf(m_output, " writable=\"%s\"", DISK_ISREADONLY(rom) ? "no" : "yes");
-					}
+				// for disk entries, add the disk index
+				else
+				{
+					fprintf(m_output, " index=\"%x\"", DISK_GETINDEX(rom));
+					fprintf(m_output, " writable=\"%s\"", DISK_ISREADONLY(rom) ? "no" : "yes");
+				}
 
-					// add optional flag
-					if ((!is_disk && ROM_ISOPTIONAL(rom)) || (is_disk && DISK_ISOPTIONAL(rom)))
-						fprintf(m_output, " optional=\"yes\"");
+				// add optional flag
+				if ((!is_disk && ROM_ISOPTIONAL(rom)) || (is_disk && DISK_ISOPTIONAL(rom)))
+					fprintf(m_output, " optional=\"yes\"");
 
-					fprintf(m_output, "/>\n");
-				}
+				fprintf(m_output, "/>\n");
 			}
-	}
+		}
 }
 
 
@@ -579,31 +632,43 @@
     sound chips used by a game
 -------------------------------------------------*/
 
-void info_xml_creator::output_chips()
+void info_xml_creator::output_chips(device_t &device, const char *root_tag)
 {
 	// iterate over executable devices
-	execute_interface_iterator execiter(m_drivlist.config().root_device());
+	execute_interface_iterator execiter(device);
 	for (device_execute_interface *exec = execiter.first(); exec != NULL; exec = execiter.next())
 	{
-		fprintf(m_output, "\t\t<chip");
-		fprintf(m_output, " type=\"cpu\"");
-		fprintf(m_output, " tag=\"%s\"", xml_normalize_string(exec->device().tag()));
-		fprintf(m_output, " name=\"%s\"", xml_normalize_string(exec->device().name()));
-		fprintf(m_output, " clock=\"%d\"", exec->device().clock());
-		fprintf(m_output, "/>\n");
+		if (strcmp(exec->device().tag(), device.tag()))
+		{
+			astring newtag(exec->device().tag()), oldtag(":");
+			newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
+
+			fprintf(m_output, "\t\t<chip");
+			fprintf(m_output, " type=\"cpu\"");
+			fprintf(m_output, " tag=\"%s\"", xml_normalize_string(newtag));
+			fprintf(m_output, " name=\"%s\"", xml_normalize_string(exec->device().name()));
+			fprintf(m_output, " clock=\"%d\"", exec->device().clock());
+			fprintf(m_output, "/>\n");
+		}
 	}
 
 	// iterate over sound devices
-	sound_interface_iterator sounditer(m_drivlist.config().root_device());
+	sound_interface_iterator sounditer(device);
 	for (device_sound_interface *sound = sounditer.first(); sound != NULL; sound = sounditer.next())
 	{
-		fprintf(m_output, "\t\t<chip");
-		fprintf(m_output, " type=\"audio\"");
-		fprintf(m_output, " tag=\"%s\"", xml_normalize_string(sound->device().tag()));
-		fprintf(m_output, " name=\"%s\"", xml_normalize_string(sound->device().name()));
-		if (sound->device().clock() != 0)
-			fprintf(m_output, " clock=\"%d\"", sound->device().clock());
-		fprintf(m_output, "/>\n");
+		if (strcmp(sound->device().tag(), device.tag()))
+		{
+			astring newtag(sound->device().tag()), oldtag(":");
+			newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
+
+			fprintf(m_output, "\t\t<chip");
+			fprintf(m_output, " type=\"audio\"");
+			fprintf(m_output, " tag=\"%s\"", xml_normalize_string(newtag));
+			fprintf(m_output, " name=\"%s\"", xml_normalize_string(sound->device().name()));
+			if (sound->device().clock() != 0)
+				fprintf(m_output, " clock=\"%d\"", sound->device().clock());
+			fprintf(m_output, "/>\n");
+		}
 	}
 }
 
@@ -613,15 +678,15 @@
 //  displays
 //-------------------------------------------------
 
-void info_xml_creator::output_display()
+void info_xml_creator::output_display(device_t &device)
 {
 	// iterate over screens
-	screen_device_iterator iter(m_drivlist.config().root_device());
-	for (const screen_device *device = iter.first(); device != NULL; device = iter.next())
+	screen_device_iterator iter(device);
+	for (const screen_device *screendev = iter.first(); screendev != NULL; screendev = iter.next())
 	{
 		fprintf(m_output, "\t\t<display");
 
-		switch (device->screen_type())
+		switch (screendev->screen_type())
 		{
 			case SCREEN_TYPE_RASTER:	fprintf(m_output, " type=\"raster\"");	break;
 			case SCREEN_TYPE_VECTOR:	fprintf(m_output, " type=\"vector\"");	break;
@@ -659,29 +724,29 @@
 		}
 
 		// output width and height only for games that are not vector
-		if (device->screen_type() != SCREEN_TYPE_VECTOR)
+		if (screendev->screen_type() != SCREEN_TYPE_VECTOR)
 		{
-			const rectangle &visarea = device->visible_area();
+			const rectangle &visarea = screendev->visible_area();
 			fprintf(m_output, " width=\"%d\"", visarea.width());
 			fprintf(m_output, " height=\"%d\"", visarea.height());
 		}
 
 		// output refresh rate
-		fprintf(m_output, " refresh=\"%f\"", ATTOSECONDS_TO_HZ(device->refresh_attoseconds()));
+		fprintf(m_output, " refresh=\"%f\"", ATTOSECONDS_TO_HZ(screendev->refresh_attoseconds()));
 
 		// output raw video parameters only for games that are not vector
 		// and had raw parameters specified
-		if (device->screen_type() != SCREEN_TYPE_VECTOR && !device->oldstyle_vblank_supplied())
+		if (screendev->screen_type() != SCREEN_TYPE_VECTOR && !screendev->oldstyle_vblank_supplied())
 		{
-			int pixclock = device->width() * device->height() * ATTOSECONDS_TO_HZ(device->refresh_attoseconds());
+			int pixclock = screendev->width() * screendev->height() * ATTOSECONDS_TO_HZ(screendev->refresh_attoseconds());
 
 			fprintf(m_output, " pixclock=\"%d\"", pixclock);
-			fprintf(m_output, " htotal=\"%d\"", device->width());
-			fprintf(m_output, " hbend=\"%d\"", device->visible_area().min_x);
-			fprintf(m_output, " hbstart=\"%d\"", device->visible_area().max_x+1);
-			fprintf(m_output, " vtotal=\"%d\"", device->height());
-			fprintf(m_output, " vbend=\"%d\"", device->visible_area().min_y);
-			fprintf(m_output, " vbstart=\"%d\"", device->visible_area().max_y+1);
+			fprintf(m_output, " htotal=\"%d\"", screendev->width());
+			fprintf(m_output, " hbend=\"%d\"", screendev->visible_area().min_x);
+			fprintf(m_output, " hbstart=\"%d\"", screendev->visible_area().max_x+1);
+			fprintf(m_output, " vtotal=\"%d\"", screendev->height());
+			fprintf(m_output, " vbend=\"%d\"", screendev->visible_area().min_y);
+			fprintf(m_output, " vbstart=\"%d\"", screendev->visible_area().max_y+1);
 		}
 		fprintf(m_output, " />\n");
 	}
@@ -690,16 +755,16 @@
 
 //-------------------------------------------------
 //  output_sound - print a list of all the
-//  displays
+//  speakers
 //------------------------------------------------
 
-void info_xml_creator::output_sound()
+void info_xml_creator::output_sound(device_t &device)
 {
-	speaker_device_iterator spkiter(m_drivlist.config().root_device());
+	speaker_device_iterator spkiter(device);
 	int speakers = spkiter.count();
 
 	// if we have no sound, zero m_output the speaker count
-	sound_interface_iterator snditer(m_drivlist.config().root_device());
+	sound_interface_iterator snditer(device);
 	if (snditer.first() == NULL)
 		speakers = 0;
 
@@ -1011,16 +1076,19 @@
 //  DIP switch settings
 //-------------------------------------------------
 
-void info_xml_creator::output_switches(const ioport_list &portlist, int type, const char *outertag, const char *innertag)
+void info_xml_creator::output_switches(const ioport_list &portlist, const char *root_tag, int type, const char *outertag, const char *innertag)
 {
 	// iterate looking for DIP switches
 	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
 		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
 			if (field->type == type)
 			{
+				astring newtag(field->port().tag()), oldtag(":");
+				newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
+
 				// output the switch name information
 				fprintf(m_output, "\t\t<%s name=\"%s\"", outertag, xml_normalize_string(input_field_name(field)));
-				fprintf(m_output, " tag=\"%s\"", xml_normalize_string(field->port().tag()));
+				fprintf(m_output, " tag=\"%s\"", xml_normalize_string(newtag));
 				fprintf(m_output, " mask=\"%u\"", field->mask);
 				fprintf(m_output, ">\n");
 
@@ -1124,48 +1192,54 @@
 //  image devices
 //-------------------------------------------------
 
-void info_xml_creator::output_images()
+void info_xml_creator::output_images(device_t &device, const char *root_tag)
 {
-	image_interface_iterator iter(m_drivlist.config().root_device());
-	for (const device_image_interface *dev = iter.first(); dev != NULL; dev = iter.next())
+	image_interface_iterator iter(device);
+	for (const device_image_interface *imagedev = iter.first(); imagedev != NULL; imagedev = iter.next())
 	{
-		// print m_output device type
-		fprintf(m_output, "\t\t<device type=\"%s\"", xml_normalize_string(dev->image_type_name()));
-
-		// does this device have a tag?
-		if (dev->device().tag())
-			fprintf(m_output, " tag=\"%s\"", xml_normalize_string(dev->device().tag()));
+		if (strcmp(imagedev->device().tag(), device.tag()))
+		{
+			astring newtag(imagedev->device().tag()), oldtag(":");
+			newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
 
-		// is this device mandatory?
-		if (dev->must_be_loaded())
-			fprintf(m_output, " mandatory=\"1\"");
+			// print m_output device type
+			fprintf(m_output, "\t\t<device type=\"%s\"", xml_normalize_string(imagedev->image_type_name()));
 
-		if (dev->image_interface() && dev->image_interface()[0])
-			fprintf(m_output, " interface=\"%s\"", xml_normalize_string(dev->image_interface()));
+			// does this device have a tag?
+			if (imagedev->device().tag())
+				fprintf(m_output, " tag=\"%s\"", xml_normalize_string(newtag));
 
-		// close the XML tag
-		fprintf(m_output, ">\n");
+			// is this device mandatory?
+			if (imagedev->must_be_loaded())
+				fprintf(m_output, " mandatory=\"1\"");
 
-		const char *name = dev->instance_name();
-		const char *shortname = dev->brief_instance_name();
+			if (imagedev->image_interface() && imagedev->image_interface()[0])
+				fprintf(m_output, " interface=\"%s\"", xml_normalize_string(imagedev->image_interface()));
 
-		fprintf(m_output, "\t\t\t<instance");
-		fprintf(m_output, " name=\"%s\"", xml_normalize_string(name));
-		fprintf(m_output, " briefname=\"%s\"", xml_normalize_string(shortname));
-		fprintf(m_output, "/>\n");
+			// close the XML tag
+			fprintf(m_output, ">\n");
 
-		astring extensions(dev->file_extensions());
+			const char *name = imagedev->instance_name();
+			const char *shortname = imagedev->brief_instance_name();
 
-		char *ext = strtok((char *)extensions.cstr(), ",");
-		while (ext != NULL)
-		{
-			fprintf(m_output, "\t\t\t<extension");
-			fprintf(m_output, " name=\"%s\"", xml_normalize_string(ext));
+			fprintf(m_output, "\t\t\t<instance");
+			fprintf(m_output, " name=\"%s\"", xml_normalize_string(name));
+			fprintf(m_output, " briefname=\"%s\"", xml_normalize_string(shortname));
 			fprintf(m_output, "/>\n");
-			ext = strtok(NULL, ",");
-		}
 
-		fprintf(m_output, "\t\t</device>\n");
+			astring extensions(imagedev->file_extensions());
+
+			char *ext = strtok((char *)extensions.cstr(), ",");
+			while (ext != NULL)
+			{
+				fprintf(m_output, "\t\t\t<extension");
+				fprintf(m_output, " name=\"%s\"", xml_normalize_string(ext));
+				fprintf(m_output, "/>\n");
+				ext = strtok(NULL, ",");
+			}
+
+			fprintf(m_output, "\t\t</device>\n");
+		}
 	}
 }
 
@@ -1174,34 +1248,45 @@
 //  output_images - prints all info about slots
 //-------------------------------------------------
 
-void info_xml_creator::output_slots()
+void info_xml_creator::output_slots(device_t &device, const char *root_tag)
 {
-	slot_interface_iterator iter(m_drivlist.config().root_device());
+	slot_interface_iterator iter(device);
 	for (const device_slot_interface *slot = iter.first(); slot != NULL; slot = iter.next())
 	{
-		// print m_output device type
-		fprintf(m_output, "\t\t<slot name=\"%s\">\n", xml_normalize_string(slot->device().tag()+1));
+		if (strcmp(slot->device().tag(), device.tag()))
+		{
+			astring newtag(slot->device().tag()), oldtag(":");
+			newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
+
+			// print m_output device type
+			fprintf(m_output, "\t\t<slot name=\"%s\">\n", xml_normalize_string(newtag));
+
+			/*
+             if (slot->slot_interface()[0])
+             fprintf(m_output, " interface=\"%s\"", xml_normalize_string(slot->slot_interface()));
+             */
 
-		/*
-        if (slot->slot_interface()[0])
-            fprintf(m_output, " interface=\"%s\"", xml_normalize_string(slot->slot_interface()));
-         */
-
-		const slot_interface* intf = slot->get_slot_interfaces();
-		if (intf)
-			for (int i = 0; intf[i].name != NULL; i++)
+			const slot_interface* intf = slot->get_slot_interfaces();
+			for (int i = 0; intf && intf[i].name != NULL; i++)
 			{
+				device_t *dev = const_cast<machine_config &>(m_drivlist.config()).device_add(&m_drivlist.config().root_device(), "dummy", intf[i].devtype, 0);
+				if (!dev->configured())
+					dev->config_complete();
+
 				fprintf(m_output, "\t\t\t<slotoption");
 				fprintf(m_output, " name=\"%s\"", xml_normalize_string(intf[i].name));
+				fprintf(m_output, " devname=\"%s\"", xml_normalize_string(dev->shortname()));
 				if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()))
 				{
 					if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()) == intf[i].name)
 						fprintf(m_output, " default=\"yes\"");
 				}
 				fprintf(m_output, "/>\n");
+				const_cast<machine_config &>(m_drivlist.config()).device_remove(&m_drivlist.config().root_device(), "dummy");
 			}
 
-		fprintf(m_output, "\t\t</slot>\n");
+			fprintf(m_output, "\t\t</slot>\n");
+		}
 	}
 }
 
@@ -1262,13 +1347,14 @@
 
 const char *info_xml_creator::get_merge_name(const hash_collection &romhashes)
 {
-	const char *merge_name = NULL;
 	// walk the parent chain
+	const char *merge_name = NULL;
 	for (int clone_of = m_drivlist.find(m_drivlist.driver().parent); clone_of != -1; clone_of = m_drivlist.find(m_drivlist.driver(clone_of).parent))
-
+	{
 		// look in the parent's ROMs
-		for (const rom_source *psource = rom_first_source(m_drivlist.config(clone_of,m_lookup_options)); psource != NULL; psource = rom_next_source(*psource))
-			for (const rom_entry *pregion = rom_first_region(*psource); pregion != NULL; pregion = rom_next_region(pregion))
+		device_iterator deviter(m_drivlist.config(clone_of, m_lookup_options).root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+			for (const rom_entry *pregion = rom_first_region(*device); pregion != NULL; pregion = rom_next_region(pregion))
 				for (const rom_entry *prom = rom_first_file(pregion); prom != NULL; prom = rom_next_file(prom))
 				{
 					hash_collection phashes(ROM_GETHASHDATA(prom));
@@ -1279,6 +1365,7 @@
 						break;
 					}
 				}
+	}
 
 	return merge_name;
 }
diff -Nru src-old/emu/info.h src/emu/info.h
--- src-old/emu/info.h	2011-12-05 14:52:38.000000000 +0100
+++ src/emu/info.h	2012-02-23 17:18:48.000000000 +0100
@@ -62,22 +62,22 @@
 	void output_one();
 	void output_sampleof();
 	void output_bios();
-	void output_rom(const rom_source *source);
+	void output_rom(device_t &device);
 	void output_device_roms();
 	void output_sample();
-	void output_chips();
-	void output_display();
-	void output_sound();
+	void output_chips(device_t &device, const char *root_tag);
+	void output_display(device_t &device);
+	void output_sound(device_t &device);
 	void output_input(const ioport_list &portlist);
-	void output_switches(const ioport_list &portlist, int type, const char *outertag, const char *innertag);
+	void output_switches(const ioport_list &portlist, const char *root_tag, int type, const char *outertag, const char *innertag);
 	void output_adjusters(const ioport_list &portlist);
-	void output_categories(const ioport_list &portlist);
 	void output_driver();
-	void output_images();
-	void output_slots();
+	void output_images(device_t &device, const char *root_tag);
+	void output_slots(device_t &device, const char *root_tag);
 	void output_software_list();
 	void output_ramoptions();
 
+	void output_one_device(device_t &device, const char *devtag);
 	void output_devices();
 
 	const char *get_merge_name(const hash_collection &romhashes);
@@ -85,7 +85,6 @@
 	// internal state
 	FILE *					m_output;
 	driver_enumerator &		m_drivlist;
-	UINT8 * 				m_device_used;
 	emu_options 			m_lookup_options;
 
 	static const char s_dtd_string[];
diff -Nru src-old/emu/input.h src/emu/input.h
--- src-old/emu/input.h	2011-06-20 20:58:22.000000000 +0200
+++ src/emu/input.h	2012-02-23 16:36:18.000000000 +0100
@@ -535,7 +535,7 @@
 	input_class &			m_class;				// reference to our class
 	astring					m_name;					// string name of device
 	int						m_devindex;				// device index of this device
-	input_device_item *		m_item[ITEM_ID_ABSOLUTE_MAXIMUM];	// array of pointers to items
+	input_device_item *		m_item[ITEM_ID_ABSOLUTE_MAXIMUM+1];	// array of pointers to items
 	input_item_id			m_maxitem;				// maximum item index
 	void *					m_internal;				// internal callback pointer
 
diff -Nru src-old/emu/ioport.c src/emu/ioport.c
--- src-old/emu/ioport.c	2012-02-06 21:18:33.000000000 +0100
+++ src/emu/ioport.c	2012-02-25 20:17:03.000000000 +0100
@@ -2004,6 +2004,8 @@
 			{
 				*readdevicetail = init_field_device_info(field, port->owner().subtag(devicetag, field->read_device));
 				field->read.late_bind(*(*readdevicetail)->device);
+				if (!field->read.has_object())
+					fatalerror("Input port %s, unable to find valid device with tag '%s'", port->tag(), devicetag.cstr());
 				readdevicetail = &(*readdevicetail)->next;
 			}
 
@@ -2012,6 +2014,8 @@
 			{
 				*writedevicetail = init_field_device_info(field, port->owner().subtag(devicetag, field->write_device));
 				field->write.late_bind(*(*writedevicetail)->device);
+				if (!field->write.has_object())
+					fatalerror("Input port %s, unable to find valid device with tag '%s'", port->tag(), devicetag.cstr());
 				writedevicetail = &(*writedevicetail)->next;
 			}
 
diff -Nru src-old/emu/machine/6532riot.c src/emu/machine/6532riot.c
--- src-old/emu/machine/6532riot.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/machine/6532riot.c	2012-02-25 20:18:06.000000000 +0100
@@ -162,6 +162,11 @@
 	via->reg_w(offset, data);
 }
 
+WRITE8_MEMBER( riot6532_device::write )
+{
+	reg_w(offset, data);
+}
+
 void riot6532_device::reg_w(UINT8 offset, UINT8 data)
 {
 	/* if A4 == 1 and A2 == 1, we are writing to the timer */
@@ -248,6 +253,11 @@
 	return via->reg_r(offset);
 }
 
+READ8_MEMBER( riot6532_device::read )
+{
+	return reg_r(offset);
+}
+
 UINT8 riot6532_device::reg_r(UINT8 offset)
 {
 	UINT8 val = 0;
diff -Nru src-old/emu/machine/6532riot.h src/emu/machine/6532riot.h
--- src-old/emu/machine/6532riot.h	2011-11-13 15:56:06.000000000 +0100
+++ src/emu/machine/6532riot.h	2012-02-25 20:18:06.000000000 +0100
@@ -50,6 +50,9 @@
     // construction/destruction
     riot6532_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 
+	DECLARE_READ8_MEMBER( read );
+	DECLARE_WRITE8_MEMBER( write );
+
     UINT8 reg_r(UINT8 offset);
     void reg_w(UINT8 offset, UINT8 data);
 
diff -Nru src-old/emu/machine/ctronics.h src/emu/machine/ctronics.h
--- src-old/emu/machine/ctronics.h	2012-02-05 16:14:28.000000000 +0100
+++ src/emu/machine/ctronics.h	2012-02-23 15:19:37.000000000 +0100
@@ -132,6 +132,7 @@
     // device-level overrides
     virtual void device_start();
     virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "centronics_printer"; }
 private:
 	printer_image_device *m_printer;
 	centronics_device *m_owner;
diff -Nru src-old/emu/machine/idectrl.h src/emu/machine/idectrl.h
--- src-old/emu/machine/idectrl.h	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/machine/idectrl.h	2012-02-23 15:19:37.000000000 +0100
@@ -96,6 +96,7 @@
     // device-level overrides
     virtual void device_start();
 	virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "hdd"; }
 
 	void ide_build_features();
 	virtual bool is_ready() { return (m_disk != NULL); }
@@ -117,6 +118,7 @@
     // device-level overrides
     virtual void device_start();
 	virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "hdd_image"; }
 	// optional information overrides
 	virtual machine_config_constructor device_mconfig_additions() const;
 };
diff -Nru src-old/emu/machine/ins8250.c src/emu/machine/ins8250.c
--- src-old/emu/machine/ins8250.c	2011-08-23 05:59:11.000000000 +0200
+++ src/emu/machine/ins8250.c	2012-02-26 15:31:24.000000000 +0100
@@ -73,136 +73,66 @@
 
 **********************************************************************/
 
-#include "emu.h"
 #include "machine/ins8250.h"
 
+const device_type INS8250 = &device_creator<ins8250_device>;
+const device_type NS16450 = &device_creator<ns16450_device>;
+const device_type NS16550 = &device_creator<ns16550_device>;
 
-#define LOG(LEVEL,N,M,A)  \
-	do { \
-		if(LEVEL>=N) \
-		{ \
-			if( M ) \
-				logerror("%-24s",(char*)M ); \
-			logerror A; \
-		} \
-	} while (0)
-
-
-/* device types */
-enum {
-	TYPE_INS8250 = 0,
-	TYPE_INS8250A,
-	TYPE_NS16450,
-	TYPE_NS16550,
-	TYPE_NS16550A,
-	TYPE_PC16550D,
-
-	NUM_TYPES
-};
-
-
-/* device tags */
-static const char * const device_tags[NUM_TYPES] = { "ins8250", "ins8250a", "ns16450", "ns16550", "ns16550a", "pc16550d" };
-
-
-#define VERBOSE_COM 0
-#define COM_LOG(n,m,a) LOG(VERBOSE_COM,n,m,a)
-
-typedef struct {
-	devcb_resolved_write_line	out_intr_func;
-	const ins8250_interface *interface;
-	int	device_type;
-
-	UINT8 thr;  /* 0 -W transmitter holding register */
-	UINT8 rbr; /* 0 R- receiver buffer register */
-	UINT8 ier;  /* 1 RW interrupt enable register */
-	UINT8 dll;  /* 0 RW divisor latch lsb (if DLAB = 1) */
-	UINT8 dlm;  /* 1 RW divisor latch msb (if DLAB = 1) */
-	UINT8 iir;  /* 2 R- interrupt identification register */
-	UINT8 lcr;  /* 3 RW line control register (bit 7: DLAB) */
-	UINT8 mcr;  /* 4 RW modem control register */
-	UINT8 lsr;  /* 5 R- line status register */
-	UINT8 msr;  /* 6 R- modem status register */
-	UINT8 scr;  /* 7 RW scratch register */
-
-/* holds int pending state for com */
-	UINT8 int_pending;
-
-	// sending circuit
-	struct {
-		int active;
-		UINT8 data;
-		double time;
-	} send;
-} ins8250_t;
-
-/* int's pending */
-#define COM_INT_PENDING_RECEIVED_DATA_AVAILABLE	0x0001
-#define COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY 0x0002
-#define COM_INT_PENDING_RECEIVER_LINE_STATUS 0x0004
-#define COM_INT_PENDING_MODEM_STATUS_REGISTER 0x0008
-
-
-INLINE ins8250_t *get_safe_token(device_t *device)
+ins8250_uart_device::ins8250_uart_device(const machine_config &mconfig, device_type type, const char* name, const char *tag, device_t *owner, UINT32 clock)
+		: device_t(mconfig, type, name, tag, owner, clock),
+		  device_serial_interface(mconfig, *this)
 {
-	assert( device != NULL );
-	assert( ( device->type() == INS8250 ) ||
-			( device->type() == INS8250A ) ||
-			( device->type() == NS16450 ) ||
-			( device->type() == NS16550 ) ||
-			( device->type() == NS16550A ) ||
-			( device->type() == PC16550D ) );
-	return (ins8250_t *)downcast<legacy_device_base *>(device)->token();
 }
 
-
-/* setup iir with the priority id */
-static void ins8250_setup_iir(device_t *device)
+ins8250_device::ins8250_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: ins8250_uart_device(mconfig, INS8250, "ins8250", tag, owner, clock)
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	ins8250->iir &= ~(0x04|0x02);
-
-	/* highest to lowest */
-	if (ins8250->ier & ins8250->int_pending & COM_INT_PENDING_RECEIVER_LINE_STATUS)
-	{
-		ins8250->iir |=0x04|0x02;
-		return;
-	}
-
-	if (ins8250->ier & ins8250->int_pending & COM_INT_PENDING_RECEIVED_DATA_AVAILABLE)
-	{
-		ins8250->iir |=0x04;
-		return;
-	}
+	m_device_type = TYPE_INS8250;
+}
 
-	if (ins8250->ier & ins8250->int_pending & COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY)
-	{
-		ins8250->iir |=0x02;
-		return;
-	}
+ns16450_device::ns16450_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: ins8250_uart_device(mconfig, NS16450, "ns16450", tag, owner, clock)
+{
+	m_device_type = TYPE_NS16450;
+}
 
-	/* modem status has both bits clear */
+ns16550_device::ns16550_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: ins8250_uart_device(mconfig, NS16550, "ns16550", tag, owner, clock)
+{
+	m_device_type = TYPE_NS16550;
 }
 
+/* int's pending */
+#define COM_INT_PENDING_RECEIVED_DATA_AVAILABLE	0x0001
+#define COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY 0x0002
+#define COM_INT_PENDING_RECEIVER_LINE_STATUS 0x0004
+#define COM_INT_PENDING_MODEM_STATUS_REGISTER 0x0008
 
 /* ints will continue to be set for as long as there are ints pending */
-static void ins8250_update_interrupt(device_t *device)
+void ins8250_uart_device::update_interrupt()
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
 	int state;
 
 	/* if any bits are set and are enabled */
-	if (((ins8250->int_pending&ins8250->ier) & 0x0f) != 0)
+	if (((m_int_pending & m_regs.ier) & 0x0f) != 0)
 	{
 		/* trigger next highest priority int */
 
 		/* set int */
 		state = 1;
-		ins8250_setup_iir(device);
+		m_regs.iir &= ~(0x04|0x02);
+
+		/* highest to lowest */
+		if (m_regs.ier & m_int_pending & COM_INT_PENDING_RECEIVER_LINE_STATUS)
+			m_regs.iir |=0x04|0x02;
+		else if (m_regs.ier & m_int_pending & COM_INT_PENDING_RECEIVED_DATA_AVAILABLE)
+			m_regs.iir |=0x04;
+		else if (m_regs.ier & m_int_pending & COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY)
+			m_regs.iir |=0x02;
 
 		/* int pending */
-		ins8250->iir &= ~0x01;
+		m_regs.iir &= ~0x01;
 	}
 	else
 	{
@@ -210,128 +140,133 @@
 		state = 0;
 
 		/* no ints pending */
-		ins8250->iir |= 0x01;
+		m_regs.iir |= 0x01;
 		/* priority level */
-		ins8250->iir &= ~(0x04|0x02);
+		m_regs.iir &= ~(0x04|0x02);
 	}
 
 	/* set or clear the int */
-	ins8250->out_intr_func(state);
+	m_out_int_func(state);
 }
 
-
-
 /* set pending bit and trigger int */
-static void ins8250_trigger_int(device_t *device, int flag)
+void ins8250_uart_device::trigger_int(int flag)
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	ins8250->int_pending |= flag;
-	ins8250_update_interrupt(device);
+	m_int_pending |= flag;
+	update_interrupt();
 }
 
-
-
 /* clear pending bit, if any ints are pending, then int will be triggered, otherwise it
 will be cleared */
-static void ins8250_clear_int(device_t *device, int flag)
+void ins8250_uart_device::clear_int(int flag)
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	ins8250->int_pending &= ~flag;
-	ins8250_update_interrupt(device);
+	m_int_pending &= ~flag;
+	update_interrupt();
 }
 
+void ins8250_uart_device::update_clock()
+{
+	int baud;
+	if(m_regs.dl == 0)
+	{
+		set_tra_rate(0);
+		set_rcv_rate(0);
+		return;
+	}
+	baud = clock()/(m_regs.dl*16);
+	set_tra_rate(baud);
+	set_rcv_rate(baud);
+}
 
-WRITE8_DEVICE_HANDLER( ins8250_w )
+WRITE8_MEMBER( ins8250_uart_device::ins8250_w )
 {
-    static const char P[] = "NONENHNL";  /* names for parity select */
-	ins8250_t	*ins8250 = get_safe_token(device);
-    int tmp;
+	int tmp;
 
 	switch (offset)
 	{
 		case 0:
-			if (ins8250->lcr & 0x80)
+			if (m_regs.lcr & 0x80)
 			{
-				ins8250->dll = data;
-				tmp = ins8250->dlm * 256 + ins8250->dll;
-				COM_LOG(1,"COM_dll_w",("COM \"%s\" $%02x: [$%04x = %d baud]\n", device->tag(),
-					 data, tmp, (tmp)?(int)(ins8250->interface->clockin/16/tmp):0));
+				m_regs.dl = (m_regs.dl & 0xff00) | data;
+				update_clock();
 			}
 			else
 			{
-				ins8250->thr = data;
-				COM_LOG(2,"COM_thr_w",("COM $%02x\n", data));
-
-				if ( ins8250->mcr & 0x10 )
+				m_regs.thr = data;
+				m_regs.lsr &= ~0x20;
+				if ( m_regs.mcr & 0x10 )
 				{
-					ins8250->lsr |= 1;
-					ins8250->rbr = data;
-					ins8250_trigger_int( device, COM_INT_PENDING_RECEIVED_DATA_AVAILABLE );
+					m_regs.lsr &= ~0x40;
+					m_regs.lsr |= 1;
+					m_regs.rbr = data;
+					trigger_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
 				}
-
-				if ( ins8250->interface->transmit )
-					ins8250->interface->transmit(device, ins8250->thr);
-
-				/* writing to thr will clear the int */
-				ins8250_clear_int(device, COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
+				else
+					if(m_regs.lsr & 0x40)
+						tra_complete();
 			}
 			break;
 		case 1:
-			if (ins8250->lcr & 0x80)
+			if (m_regs.lcr & 0x80)
 			{
-				ins8250->dlm = data;
-				tmp = ins8250->dlm * 256 + ins8250->dll;
-                COM_LOG(1,"COM_dlm_w",("COM \"%s\" $%02x: [$%04x = %d baud]\n", device->tag(),
-					data, tmp, (tmp)?(int)(ins8250->interface->clockin/16/tmp):0));
+				m_regs.dl = (m_regs.dl & 0xff) | (data << 8);
+				update_clock();
 			}
 			else
 			{
-				ins8250->ier = data;
-				COM_LOG(2,"COM_ier_w",("COM \"%s\" $%02x: enable int on RX %d, THRE %d, RLS %d, MS %d\n", device->tag(),
-					data, data&1, (data>>1)&1, (data>>2)&1, (data>>3)&1));
-				COM_LOG(2,"COM_ier_w",("COM \"%s\" lsr = $%02x, int_pending = $%02x\n", device->tag(), ins8250->lsr, ins8250->int_pending ));
-				ins8250_update_interrupt(device);
+				m_regs.ier = data;
+				update_interrupt();
 			}
             break;
 		case 2:
-			COM_LOG(1,"COM_fcr_w",("COM \"%s\" $%02x (16550 only)\n", device->tag(), data));
             break;
 		case 3:
-			ins8250->lcr = data;
-			COM_LOG(1,"COM_lcr_w",("COM \"%s\" $%02x word length %d, stop bits %d, parity %c, break %d, DLAB %d\n", device->tag(),
-				data, 5+(data&3), 1+((data>>2)&1), P[(data>>3)&7], (data>>6)&1, (data>>7)&1));
-            break;
+			m_regs.lcr = data;
+			switch ((m_regs.lcr>>3) & 7)
+			{
+			case 1:
+				tmp = SERIAL_PARITY_ODD;
+				break;
+			case 3:
+				tmp = SERIAL_PARITY_EVEN;
+				break;
+			case 5:
+				tmp = SERIAL_PARITY_MARK;
+				break;
+			case 7:
+				tmp = SERIAL_PARITY_SPACE;
+				break;
+			default:
+				tmp = SERIAL_PARITY_NONE;
+				break;
+			}
+			// if 5 data bits and stb = 1, stop bits is supposed to be 1.5
+			set_data_frame((m_regs.lcr & 3) + 5, (m_regs.lcr & 4)?2:1, tmp);
+			break;
 		case 4:
-			if ( ( ins8250->mcr & 0x1f ) != ( data & 0x1f ) )
+			if ( ( m_regs.mcr & 0x1f ) != ( data & 0x1f ) )
 			{
-				ins8250->mcr = data & 0x1f;
-				COM_LOG(1,"COM_mcr_w",("COM \"%s\" $%02x DTR %d, RTS %d, OUT1 %d, OUT2 %d, loopback %d\n", device->tag(),
-					data, data&1, (data>>1)&1, (data>>2)&1, (data>>3)&1, (data>>4)&1));
-				if (ins8250->interface->handshake_out)
-					ins8250->interface->handshake_out(device,data);
+				m_regs.mcr = data & 0x1f;
 
-				if ( ins8250->mcr & 0x10 )		/* loopback test */
+				if ( m_regs.mcr & 0x10 )		/* loopback test */
 				{
-					data = ( ( ins8250->mcr & 0x0c ) << 4 ) | ( ( ins8250->mcr & 0x01 ) << 5 ) | ( ( ins8250->mcr & 0x02 ) << 3 );
-					if ( ( ins8250->msr & 0x20 ) != ( data & 0x20 ) )
-					{
+					data = ( ( m_regs.mcr & 0x0c ) << 4 ) | ( ( m_regs.mcr & 0x01 ) << 5 ) | ( ( m_regs.mcr & 0x02 ) << 3 );
+					if ( ( m_regs.msr & 0x20 ) != ( data & 0x20 ) )
 						data |= 0x02;
-					}
-					if ( ( ins8250->msr & 0x10 ) != ( data & 0x10 ) )
-					{
+					if ( ( m_regs.msr & 0x10 ) != ( data & 0x10 ) )
 						data |= 0x01;
-					}
-					if ( ( ins8250->msr & 0x40 ) && ! ( data & 0x40 ) )
-					{
+					if ( ( m_regs.msr & 0x40 ) && ! ( data & 0x40 ) )
 						data |= 0x04;
-					}
-					if ( ( ins8250->msr & 0x80 ) != ( data & 0x80 ) )
-					{
+					if ( ( m_regs.msr & 0x80 ) != ( data & 0x80 ) )
 						data |= 0x08;
-					}
-					ins8250->msr = data;
+					m_regs.msr = data;
+				}
+				else
+				{
+					m_out_dtr_func(m_regs.mcr & 1);
+					m_out_rts_func((m_regs.mcr & 2) && 1);
+					m_out_out1_func((m_regs.mcr & 4) && 1);
+					m_out_out2_func((m_regs.mcr & 8) && 1);
 				}
 			}
             break;
@@ -341,15 +276,13 @@
               bits 5 - 0, you could cause an interrupt if the appropriate IER bit
               is set.
             */
-			COM_LOG(1,"COM_lsr_w",("COM \"%s\" $%02x\n", device->tag(), data ));
-
-			ins8250->lsr = data;
+			m_regs.lsr = data;
 
 			tmp = 0;
-			tmp |= ( ins8250->lsr & 0x01 ) ? COM_INT_PENDING_RECEIVED_DATA_AVAILABLE : 0;
-			tmp |= ( ins8250->lsr & 0x1e ) ? COM_INT_PENDING_RECEIVER_LINE_STATUS : 0;
-			tmp |= ( ins8250->lsr & 0x20 ) ? COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY : 0;
-			ins8250_trigger_int( device, tmp );
+			tmp |= ( m_regs.lsr & 0x01 ) ? COM_INT_PENDING_RECEIVED_DATA_AVAILABLE : 0;
+			tmp |= ( m_regs.lsr & 0x1e ) ? COM_INT_PENDING_RECEIVER_LINE_STATUS : 0;
+			tmp |= ( m_regs.lsr & 0x20 ) ? COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY : 0;
+			trigger_int(tmp);
 
 			break;
 		case 6:
@@ -358,358 +291,186 @@
               bits 3 - 0, you could cause an interrupt if the appropriate IER bit
               is set.
              */
-			COM_LOG(1,"COM_msr_w",("COM \"%s\" $%02x\n", device->tag(), data ));
+			m_regs.msr = data;
 
-			ins8250->msr = data;
-
-			if ( ins8250->msr & 0x0f )
-			{
-				ins8250_trigger_int( device, COM_INT_PENDING_MODEM_STATUS_REGISTER );
-			}
+			if ( m_regs.msr & 0x0f )
+				trigger_int(COM_INT_PENDING_MODEM_STATUS_REGISTER);
 			break;
 		case 7:
-			ins8250->scr = data;
-			COM_LOG(2,"COM_scr_w",("COM \"%s\" $%02x\n", device->tag(), data));
+			m_regs.scr = data;
             break;
 	}
-
-	if (ins8250->interface->refresh_connected)
-		ins8250->interface->refresh_connected(device);
 }
 
-
-
-READ8_DEVICE_HANDLER( ins8250_r )
+READ8_MEMBER( ins8250_uart_device::ins8250_r )
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
 	int data = 0x0ff;
 
 	switch (offset)
 	{
 		case 0:
-			if (ins8250->lcr & 0x80)
-			{
-				data = ins8250->dll;
-				COM_LOG(1,"COM_dll_r",("COM \"%s\" $%02x\n", device->tag(), data));
-			}
+			if (m_regs.lcr & 0x80)
+				data = (m_regs.dl & 0xff);
 			else
 			{
-				data = ins8250->rbr;
-				if( ins8250->lsr & 0x01 )
-				{
-					ins8250->lsr &= ~0x01;		/* clear data ready status */
-					COM_LOG(2,"COM_rbr_r",("COM \"%s\" $%02x\n", device->tag(), data));
-				}
+				data = m_regs.rbr;
+				if( m_regs.lsr & 0x01 )
+					m_regs.lsr &= ~0x01;		/* clear data ready status */
 
-				ins8250_clear_int(device, COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
+				clear_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
 			}
 			break;
 		case 1:
-			if (ins8250->lcr & 0x80)
-			{
-				data = ins8250->dlm;
-				COM_LOG(1,"COM_dlm_r",("COM \"%s\" $%02x\n", device->tag(), data));
-			}
+			if (m_regs.lcr & 0x80)
+				data = (m_regs.dl >> 8);
 			else
-			{
-				data = ins8250->ier & 0x0f;
-				COM_LOG(2,"COM_ier_r",("COM \"%s\" $%02x\n", device->tag(), data));
-            }
+				data = m_regs.ier & 0x0f;
             break;
 		case 2:
-			data = ins8250->iir;
-			COM_LOG(2,"COM_iir_r",("COM \"%s\" $%02x\n", device->tag(), data));
+			data = m_regs.iir;
 			/* The documentation says that reading this register will
             clear the int if this is the source of the int */
-			if ( ins8250->ier & COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY )
-			{
-				ins8250_clear_int(device, COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
-			}
+			if ( m_regs.ier & COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY )
+				clear_int(COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
             break;
 		case 3:
-			data = ins8250->lcr;
-			COM_LOG(2,"COM_lcr_r",("COM \"%s\" $%02x\n", device->tag(), data));
+			data = m_regs.lcr;
             break;
 		case 4:
-			data = ins8250->mcr;
-			COM_LOG(2,"COM_mcr_r",("COM \"%s\" $%02x\n", device->tag(), data));
+			data = m_regs.mcr;
             break;
 		case 5:
-
-#if 0
-			if (ins8250->send.active && (machine.time()-ins8250->send.time>uart_byte_time(n)))
-			{
-				// currently polling is enough for pc1512
-				ins8250->lsr |= 0x40; /* set TSRE */
-				ins8250->send.active = 0;
-				if ( ins8250->mcr & 0x10 )
-				{
-					ins8250->lsr |= 1;
-					ins8250->rbr = ins8250->send.data;
-				}
-			}
-#endif
-			ins8250->lsr |= 0x60; /* set THRE */
-			data = ins8250->lsr;
-			if( ins8250->lsr & 0x1f )
-			{
-				ins8250->lsr &= 0xe1; /* clear FE, PE and OE and BREAK bits */
-				COM_LOG(2,"COM_lsr_r",("COM \"%s\" $%02x, DR %d, OE %d, PE %d, FE %d, BREAK %d, THRE %d, TSRE %d\n", device->tag(),
-					data, data&1, (data>>1)&1, (data>>2)&1, (data>>3)&1, (data>>4)&1, (data>>5)&1, (data>>6)&1));
-			}
+			data = m_regs.lsr;
+			if( m_regs.lsr & 0x1f )
+				m_regs.lsr &= 0xe1; /* clear FE, PE and OE and BREAK bits */
 
 			/* reading line status register clears int */
-			ins8250_clear_int(device, COM_INT_PENDING_RECEIVER_LINE_STATUS);
+			clear_int(COM_INT_PENDING_RECEIVER_LINE_STATUS);
             break;
 		case 6:
-			data = ins8250->msr;
-			ins8250->msr &= 0xf0; /* reset delta values */
-			COM_LOG(2,"COM_msr_r",("COM \"%s\" $%02x\n", device->tag(), data));
+			data = m_regs.msr;
+			m_regs.msr &= 0xf0; /* reset delta values */
 
 			/* reading msr clears int */
-			ins8250_clear_int(device, COM_INT_PENDING_MODEM_STATUS_REGISTER);
+			clear_int(COM_INT_PENDING_MODEM_STATUS_REGISTER);
 
 			break;
 		case 7:
-			data = ins8250->scr;
-			COM_LOG(2,"COM_scr_r",("COM \"%s\" $%02x\n", device->tag(), data));
+			data = m_regs.scr;
             break;
 	}
-
-	if (ins8250->interface->refresh_connected)
-		ins8250->interface->refresh_connected(device);
-
     return data;
 }
 
-
-
-void ins8250_receive(device_t *device, int data)
-{
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-    /* check if data rate 1200 baud is set */
-	if( ins8250->dlm != 0x00 || ins8250->dll != 0x60 )
-        ins8250->lsr |= 0x08; /* set framing error */
-
-    /* if data not yet serviced */
-	if( ins8250->lsr & 0x01 )
-		ins8250->lsr |= 0x02; /* set overrun error */
-
-    /* put data into receiver buffer register */
-    ins8250->rbr = data;
-
-    /* set data ready status */
-    ins8250->lsr |= 0x01;
-
-	/* set pending state for this interrupt. */
-	ins8250_trigger_int(device, COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
-
-
-//  /* OUT2 + received line data avail interrupt enabled? */
-//  if( (COM_mcr[n] & 0x08) && (COM_ier[n] & 0x01) )
-//  {
-//      if (com_interface.interrupt)
-//          com_interface.interrupt(4-(n&1), 1);
-//
-//  }
-}
-
-/**************************************************************************
- *  change the modem status register
- **************************************************************************/
-void ins8250_handshake_in(device_t *device, int new_msr)
-{
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	/* no change in modem status bits? */
-	if( ((ins8250->msr ^ new_msr) & 0xf0) == 0 )
-		return;
-
-	/* set delta status bits 0..3 and new modem status bits 4..7 */
-    ins8250->msr = (((ins8250->msr ^ new_msr) >> 4) & 0x0f) | (new_msr & 0xf0);
-
-	ins8250_trigger_int(device, COM_INT_PENDING_MODEM_STATUS_REGISTER);
-
-//  /* set up interrupt information register */
-  //  COM_iir[n] &= ~(0x06 | 0x01);
-
-//    /* OUT2 + modem status interrupt enabled? */
-//  if( (COM_mcr[n] & 0x08) && (COM_ier[n] & 0x08) )
-//  {
-//      if (com_interface.interrupt)
-//          com_interface.interrupt(4-(n&1), 1);
-//  }
-}
-
-
-static void common_start( device_t *device, int device_type )
+void ins8250_uart_device::rcv_complete()
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	ins8250->interface = (const ins8250_interface*)device->static_config();
-	ins8250->device_type = device_type;
-
-	ins8250->out_intr_func.resolve(ins8250->interface->out_intr_cb, *device);
-}
-
-
-static DEVICE_START( ins8250 )
-{
-	common_start( device, TYPE_INS8250 );
-}
-
-
-static DEVICE_START( ins8250a )
-{
-	common_start( device, TYPE_INS8250A );
+	if(m_regs.lsr & 0x01)
+	{
+		m_regs.lsr |= 0x02; //overrun
+		trigger_int(COM_INT_PENDING_RECEIVER_LINE_STATUS);
+		receive_register_reset();
+	}
+	else
+	{
+		m_regs.lsr |= 0x01;
+		receive_register_extract();
+		m_regs.rbr = get_received_char();
+		trigger_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
+	}
 }
 
-
-static DEVICE_START( ns16450 )
+void ins8250_uart_device::tra_complete()
 {
-	common_start( device, TYPE_NS16450 );
+	if(!(m_regs.lsr & 0x20))
+	{
+		transmit_register_setup(m_regs.thr);
+		m_regs.lsr &= ~0x40;
+		m_regs.lsr |= 0x20;
+		trigger_int(COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
+	}
+	else
+		m_regs.lsr |= 0x40;
 }
 
-
-static DEVICE_START( ns16550 )
+void ins8250_uart_device::tra_callback()
 {
-	common_start( device, TYPE_NS16550 );
+	m_out_tx_func(transmit_register_get_data_bit());
 }
 
-
-static DEVICE_START( ns16550a )
+void ins8250_uart_device::update_msr(int bit, UINT8 state)
 {
-	common_start( device, TYPE_NS16550A );
+	UINT8 mask = (1<<bit);
+	if((m_regs.msr & mask) == (state<<bit))
+		return;
+	m_regs.msr |= mask;
+	m_regs.msr = (m_regs.msr & ~(mask << 4)) | (state<<(bit+4));
+	trigger_int(COM_INT_PENDING_MODEM_STATUS_REGISTER);
 }
 
-
-static DEVICE_START( pc16550d )
+WRITE_LINE_MEMBER(ins8250_uart_device::dcd_w)
 {
-	common_start( device, TYPE_PC16550D );
+	update_msr(3, (state&&1));
 }
 
-
-static DEVICE_RESET( ins8250 )
+WRITE_LINE_MEMBER(ins8250_uart_device::dsr_w)
 {
-	ins8250_t	*ins8250 = get_safe_token(device);
-
-	ins8250->ier = 0;
-	ins8250->iir = 1;
-	ins8250->lcr = 0;
-	ins8250->mcr = 0;
-	ins8250->lsr = (1<<5) | (1<<6);
-
-	ins8250->send.active=0;
-
-	/* refresh with reset state of register */
-	if (ins8250->interface->refresh_connected)
-		ins8250->interface->refresh_connected(device);
+	update_msr(1, (state&&1));
 }
 
-
-DEVICE_GET_INFO( ins8250 )
+WRITE_LINE_MEMBER(ins8250_uart_device::ri_w)
 {
-	switch ( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:				info->i = sizeof(ins8250_t);				break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:		info->i = 0;								break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ins8250);	break;
-		case DEVINFO_FCT_STOP:						/* nothing */								break;
-		case DEVINFO_FCT_RESET:						info->reset = DEVICE_RESET_NAME(ins8250);	break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor INS8250/INS8250B");	break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "INS8250");					break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.00");					break;
-		case DEVINFO_STR_SOURCE_FILE:				strcpy(info->s, __FILE__);					break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright the MESS Team");	break;
-	}
+	update_msr(2, (state&&1));
 }
 
-
-DEVICE_GET_INFO( ins8250a )
+WRITE_LINE_MEMBER(ins8250_uart_device::cts_w)
 {
-	switch ( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor INS8250A/INS82C50A");	break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ins8250a);	break;
-
-		default:									DEVICE_GET_INFO_CALL(ins8250);				break;
-	}
+	update_msr(0, (state&&1));
 }
 
-
-DEVICE_GET_INFO( ns16450 )
+void ins8250_uart_device::device_start()
 {
-	switch ( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor NS16450/PC16450");	break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ns16450);	break;
-
-		default:									DEVICE_GET_INFO_CALL(ins8250);				break;
-	}
+	m_out_tx_func.resolve(m_out_tx_cb, *this);
+	m_out_dtr_func.resolve(m_out_dtr_cb, *this);
+	m_out_rts_func.resolve(m_out_rts_cb, *this);
+	m_out_int_func.resolve(m_out_int_cb, *this);
+	m_out_out1_func.resolve(m_out_out1_cb, *this);
+	m_out_out2_func.resolve(m_out_out2_cb, *this);
+	set_tra_rate(0);
+	set_rcv_rate(0);
 }
 
-
-DEVICE_GET_INFO( ns16550 )
+void ins8250_uart_device::device_reset()
 {
-	switch ( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor NS16550/PC16550");	break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ns16550);	break;
-
-		default:									DEVICE_GET_INFO_CALL(ins8250);				break;
-	}
+	memset(&m_regs, '\0', sizeof(m_regs));
+	m_regs.ier = 0;
+	m_regs.iir = 1;
+	m_regs.lcr = 0;
+	m_regs.mcr = 0;
+	m_regs.lsr = (1<<5) | (1<<6);
+	m_int_pending = 0;
+	receive_register_reset();
+	transmit_register_reset();
+	m_out_rts_func(0);
+	m_out_dtr_func(0);
+	m_out_out1_func(0);
+	m_out_out2_func(0);
+	m_out_tx_func(1);
 }
 
-
-DEVICE_GET_INFO( ns16550a )
+void ins8250_uart_device::device_config_complete()
 {
-	switch ( state )
+	const ins8250_interface *intf = reinterpret_cast<const ins8250_interface *>(static_config());
+	if(intf != NULL)
 	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor NS16550A/PC16550A");	break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ns16550a);	break;
-
-		default:									DEVICE_GET_INFO_CALL(ins8250);				break;
+		*static_cast<ins8250_interface *>(this) = *intf;
 	}
-}
-
-
-DEVICE_GET_INFO( pc16550d )
-{
-	switch ( state )
+	else
 	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "National Semiconductor PC16550D");	break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(pc16550d);	break;
-
-		default:									DEVICE_GET_INFO_CALL(ins8250);				break;
+		memset(&m_out_tx_cb, 0, sizeof(m_out_tx_cb));
+		memset(&m_out_dtr_cb, 0, sizeof(m_out_dtr_cb));
+		memset(&m_out_rts_cb, 0, sizeof(m_out_rts_cb));
+		memset(&m_out_int_cb, 0, sizeof(m_out_int_cb));
+		memset(&m_out_out1_cb, 0, sizeof(m_out_out1_cb));
+		memset(&m_out_out2_cb, 0, sizeof(m_out_out2_cb));
 	}
 }
-
-
-
-DEFINE_LEGACY_DEVICE(INS8250, ins8250);
-DEFINE_LEGACY_DEVICE(INS8250A, ins8250a);
-DEFINE_LEGACY_DEVICE(NS16450, ns16450);
-DEFINE_LEGACY_DEVICE(NS16550, ns16550);
-DEFINE_LEGACY_DEVICE(NS16550A, ns16550a);
-DEFINE_LEGACY_DEVICE(PC16550D, pc16550d);
diff -Nru src-old/emu/machine/ins8250.h src/emu/machine/ins8250.h
--- src-old/emu/machine/ins8250.h	2011-06-14 12:42:03.000000000 +0200
+++ src/emu/machine/ins8250.h	2012-02-20 09:05:19.000000000 +0100
@@ -7,77 +7,120 @@
 #ifndef __INS8250_H_
 #define __INS8250_H_
 
-#include "devlegcy.h"
-
-DECLARE_LEGACY_DEVICE(INS8250, ins8250);
-DECLARE_LEGACY_DEVICE(INS8250A, ins8250a);
-DECLARE_LEGACY_DEVICE(NS16450, ns16450);
-DECLARE_LEGACY_DEVICE(NS16550, ns16550);
-DECLARE_LEGACY_DEVICE(NS16550A, ns16550a);
-DECLARE_LEGACY_DEVICE(PC16550D, pc16550d);
-
-#define UART8250_HANDSHAKE_OUT_DTR				0x01
-#define UART8250_HANDSHAKE_OUT_RTS				0x02
-
-#define UART8250_HANDSHAKE_IN_DSR				0x020
-#define UART8250_HANDSHAKE_IN_CTS				0x010
-#define UART8250_INPUTS_RING_INDICATOR			0x0040
-#define UART8250_INPUTS_DATA_CARRIER_DETECT		0x0080
-
+#include "emu.h"
 
 /***************************************************************************
-    TYPE DEFINITIONS
+    CLASS DEFINITIONS
 ***************************************************************************/
-
-typedef void (*ins8250_transmit_func)(device_t *device, int data);
-typedef void (*ins8250_handshake_out_func)(device_t *device, int data);
-typedef void (*ins8250_refresh_connect_func)(device_t *device);
-
-#define INS8250_TRANSMIT(name)			void name(device_t *device, int data)
-#define INS8250_HANDSHAKE_OUT(name)		void name(device_t *device, int data)
-#define INS8250_REFRESH_CONNECT(name)	void name(device_t *device)
-
-typedef struct
+struct ins8250_interface
 {
-	long clockin;
-	devcb_write_line				out_intr_cb;
+	devcb_write_line	m_out_tx_cb;
+	devcb_write_line	m_out_dtr_cb;
+	devcb_write_line	m_out_rts_cb;
+	devcb_write_line	m_out_int_cb;
+	devcb_write_line	m_out_out1_cb;
+	devcb_write_line	m_out_out2_cb;
+};
+
+class ins8250_uart_device : public device_t,
+							public device_serial_interface,
+							public ins8250_interface
+{
+public:
+	ins8250_uart_device(const machine_config &mconfig, device_type type, const char* name, const char *tag, device_t *owner, UINT32 clock);
+	DECLARE_WRITE8_MEMBER( ins8250_w );
+	DECLARE_READ8_MEMBER( ins8250_r );
+	DECLARE_WRITE_LINE_MEMBER( dcd_w );
+	DECLARE_WRITE_LINE_MEMBER( dsr_w );
+	DECLARE_WRITE_LINE_MEMBER( ri_w );
+	DECLARE_WRITE_LINE_MEMBER( cts_w );
+	DECLARE_WRITE_LINE_MEMBER( rx_w ) { check_for_start(state); }
+	void input_callback(UINT8 state) { m_input_state = state; }
+
+protected:
+	virtual void device_start();
+	virtual void device_config_complete();
+	virtual void device_reset();
+	virtual void rcv_complete();
+	virtual void tra_complete();
+	virtual void tra_callback();
+
+	enum {
+			TYPE_INS8250 = 0,
+			TYPE_INS8250A,
+			TYPE_NS16450,
+			TYPE_NS16550,
+			TYPE_NS16550A,
+			TYPE_PC16550D,
+	};
+	int	m_device_type;
+private:
+	struct {
+		UINT8 thr;  /* 0 -W transmitter holding register */
+		UINT8 rbr;  /* 0 R- receiver buffer register */
+		UINT8 ier;  /* 1 RW interrupt enable register */
+		UINT16 dl;  /* 0/1 RW divisor latch (if DLAB = 1) */
+		UINT8 iir;  /* 2 R- interrupt identification register */
+		UINT8 lcr;  /* 3 RW line control register (bit 7: DLAB) */
+		UINT8 mcr;  /* 4 RW modem control register */
+		UINT8 lsr;  /* 5 R- line status register */
+		UINT8 msr;  /* 6 R- modem status register */
+		UINT8 scr;  /* 7 RW scratch register */
+	} m_regs;
+	UINT8 m_int_pending;
+
+	devcb_resolved_write_line	m_out_tx_func;
+	devcb_resolved_write_line	m_out_dtr_func;
+	devcb_resolved_write_line	m_out_rts_func;
+	devcb_resolved_write_line	m_out_int_func;
+	devcb_resolved_write_line	m_out_out1_func;
+	devcb_resolved_write_line	m_out_out2_func;
+
+	void update_interrupt();
+	void update_clock();
+	void trigger_int(int flag);
+	void clear_int(int flag);
+	void update_msr(int bit, UINT8 state);
+};
 
-	ins8250_transmit_func			transmit;
-	ins8250_handshake_out_func		handshake_out;
+class ins8250_device : public ins8250_uart_device
+{
+public:
+	ins8250_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
 
-	// refresh object connected to this port
-	ins8250_refresh_connect_func	refresh_connected;
-} ins8250_interface;
+class ns16450_device : public ins8250_uart_device
+{
+public:
+	ns16450_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
 
+class ns16550_device : public ins8250_uart_device
+{
+public:
+	ns16550_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
+extern const device_type INS8250;
+extern const device_type NS16450;
+extern const device_type NS16550;
 
 /***************************************************************************
     DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-#define MCFG_INS8250_ADD(_tag, _intrf) \
-	MCFG_DEVICE_ADD(_tag, INS8250, 0) \
+#define MCFG_INS8250_ADD(_tag, _intrf, _clock) \
+	MCFG_DEVICE_ADD(_tag, INS8250, _clock) \
 	MCFG_DEVICE_CONFIG(_intrf)
 
 
-#define MCFG_NS16450_ADD(_tag, _intrf) \
-	MCFG_DEVICE_ADD(_tag, NS16450, 0) \
+#define MCFG_NS16450_ADD(_tag, _intrf, _clock) \
+	MCFG_DEVICE_ADD(_tag, NS16450, _clock) \
 	MCFG_DEVICE_CONFIG(_intrf)
 
 
-#define MCFG_NS16550_ADD(_tag, _intrf) \
-	MCFG_DEVICE_ADD(_tag, NS16550, 0) \
+#define MCFG_NS16550_ADD(_tag, _intrf, _clock) \
+	MCFG_DEVICE_ADD(_tag, NS16550, _clock) \
 	MCFG_DEVICE_CONFIG(_intrf)
 
-
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-void ins8250_receive(device_t *device, int data);
-void ins8250_handshake_in(device_t *device, int new_msr);
-
-READ8_DEVICE_HANDLER( ins8250_r );
-WRITE8_DEVICE_HANDLER( ins8250_w );
-
-
-#endif /* __INS8250_H_ */
+#endif
diff -Nru src-old/emu/machine/mc146818.c src/emu/machine/mc146818.c
--- src-old/emu/machine/mc146818.c	2012-02-18 11:58:12.000000000 +0100
+++ src/emu/machine/mc146818.c	2012-02-20 09:05:19.000000000 +0100
@@ -476,14 +476,16 @@
 		case 0x0a:
 			// fixme: allow different time base
 			data &= 0x0f;
-			if (m_data[0x0b] & 0x40) {
-				if (data > 2)
-					m_period = attotime::from_hz(32768 >> (data - 1));
-				else if (data > 0)
-					m_period = attotime::from_hz(32768 >> (data + 6));
-				else m_period = attotime::never;
-				rate = attotime::zero;
-			} else rate = attotime::never;
+			if (data > 2)
+				m_period = attotime::from_hz(32768 >> (data - 1));
+			else if (data > 0)
+				m_period = attotime::from_hz(32768 >> (data + 6));
+			else m_period = attotime::never;
+
+			if(m_data[0x0b] & 0x40)
+				 rate = attotime::zero;
+			else rate = attotime::never;
+
 			m_periodic_timer->adjust(rate, 0, m_period);
 			data |= m_data[m_index % MC146818_DATA_SIZE] & 0xf0;
 			m_data[m_index % MC146818_DATA_SIZE] = data;
diff -Nru src-old/emu/machine/microtch.c src/emu/machine/microtch.c
--- src-old/emu/machine/microtch.c	2011-10-04 21:15:30.000000000 +0200
+++ src/emu/machine/microtch.c	2012-02-20 18:34:10.000000000 +0100
@@ -9,49 +9,23 @@
 
 */
 
-#include "emu.h"
 #include "microtch.h"
 
 #define LOG 0
 
-enum MICROTOUCH_FORMAT
-{
-	FORMAT_UNKNOWN,
-	FORMAT_TABLET,
-	FORMAT_DECIMAL
-};
+const device_type MICROTOUCH = &device_creator<microtouch_device>;
 
-ALLOW_SAVE_TYPE(MICROTOUCH_FORMAT);
-
-enum MICROTOUCH_MODE
+microtouch_device::microtouch_device(const machine_config &mconfig, device_type type, const char* name, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, type, name, tag, owner, clock)
 {
-	MODE_INACTIVE,
-	MODE_STREAM,
-	MODE_POINT
-};
-
-ALLOW_SAVE_TYPE(MICROTOUCH_MODE);
+}
 
-static struct
+microtouch_device::microtouch_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, MICROTOUCH, "Microtouch Touchscreen", tag, owner, clock)
 {
-	UINT8		rx_buffer[16];
-	int			rx_buffer_ptr;
-	emu_timer*	timer;
-	UINT8		tx_buffer[16];
-	UINT8		tx_buffer_num;
-	UINT8		tx_buffer_ptr;
-	int			reset_done;
-	MICROTOUCH_FORMAT	format;
-	MICROTOUCH_MODE		mode;
-	int			last_touch_state;
-	int			last_x;
-	int			last_y;
-	microtouch_tx_func	tx_callback;
-	microtouch_touch_func	touch_callback;
-} microtouch;
-
+}
 
-static int microtouch_check_command( const char* commandtocheck, int command_len, UINT8* command_data )
+int microtouch_device::check_command( const char* commandtocheck, int command_len, UINT8* command_data )
 {
 	if ( (command_len == (strlen(commandtocheck) + 2)) &&
 		 (command_data[0] == 0x01) &&
@@ -66,20 +40,20 @@
 	}
 }
 
-static void microtouch_send_format_table_packet(UINT8 flag, int x, int y)
+void microtouch_device::send_format_table_packet(UINT8 flag, int x, int y)
 {
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = flag;
+	m_tx_buffer[m_tx_buffer_num++] = flag;
 	// lower byte (7bits) of x coordinate
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = x & 0x7f;
+	m_tx_buffer[m_tx_buffer_num++] = x & 0x7f;
 	// higher byte (7bits) of x coordinate
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (x >> 7) & 0x7f;
+	m_tx_buffer[m_tx_buffer_num++] = (x >> 7) & 0x7f;
 	// lower byte (7bits) of y coordinate
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = y & 0x7f;
+	m_tx_buffer[m_tx_buffer_num++] = y & 0x7f;
 	// higher byte (7bits) of y coordinate
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (y >> 7) & 0x7f;
-};
+	m_tx_buffer[m_tx_buffer_num++] = (y >> 7) & 0x7f;
+}
 
-static void microtouch_send_format_decimal_packet(int x, int y)
+void microtouch_device::send_format_decimal_packet(int x, int y)
 {
 	int decx, decy;
 
@@ -91,201 +65,283 @@
 		decy = 999;
 
 	// header byte
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x01;
+	m_tx_buffer[m_tx_buffer_num++] = 0x01;
 	// x coordinate in decimal mode
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (decx / 100) + '0';
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = ((decx / 10) % 10) + '0';
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (decx % 10) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = (decx / 100) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = ((decx / 10) % 10) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = (decx % 10) + '0';
 	// comma (separator)
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = ',';
+	m_tx_buffer[m_tx_buffer_num++] = ',';
 	// y coordinate in decimal mode
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (decy / 100) + '0';
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = ((decy / 10) % 10) + '0';
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = (decy % 10) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = (decy / 100) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = ((decy / 10) % 10) + '0';
+	m_tx_buffer[m_tx_buffer_num++] = (decy % 10) + '0';
 	// terminator
-	microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x0d;
+	m_tx_buffer[m_tx_buffer_num++] = 0x0d;
 }
 
-static void microtouch_send_touch_packet(running_machine &machine)
+void microtouch_device::send_touch_packet()
 {
-	int tx = input_port_read(machine, "TOUCH_X");
-	int ty = input_port_read(machine, "TOUCH_Y");
+	int tx = input_port_read(*this, "TOUCH_X");
+	int ty = input_port_read(*this, "TOUCH_Y");
 
-	if ( microtouch.touch_callback == NULL ||
-		 microtouch.touch_callback( machine, &tx, &ty ) != 0 )
+	if ( m_out_touch_cb == NULL ||
+		 m_out_touch_cb( &tx, &ty ) != 0 )
 	{
 		ty = 0x4000 - ty;
 
-		switch( microtouch.format )
+		switch( m_format )
 		{
 			case FORMAT_TABLET:
-				microtouch_send_format_table_packet(0xc8, tx, ty);
+				send_format_table_packet(0xc8, tx, ty);
 				break;
 			case FORMAT_DECIMAL:
-				microtouch_send_format_decimal_packet(tx, ty);
+				send_format_decimal_packet(tx, ty);
 				break;
 			case FORMAT_UNKNOWN:
 				break;
 		}
-		microtouch.last_touch_state = 1;
-		microtouch.last_x = tx;
-		microtouch.last_y = ty;
+		m_last_touch_state = 1;
+		m_last_x = tx;
+		m_last_y = ty;
 	}
 }
 
-static TIMER_CALLBACK(microtouch_timer_callback)
+void microtouch_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
 {
-	if ( microtouch.tx_buffer_ptr < microtouch.tx_buffer_num )
+	if ( m_tx_buffer_ptr < m_tx_buffer_num )
 	{
-		microtouch.tx_callback( machine, microtouch.tx_buffer[microtouch.tx_buffer_ptr++] );
-		if ( microtouch.tx_buffer_ptr == microtouch.tx_buffer_num )
+		tx( m_tx_buffer[m_tx_buffer_ptr++] );
+		if ( m_tx_buffer_ptr == m_tx_buffer_num )
 		{
-			microtouch.tx_buffer_ptr = microtouch.tx_buffer_num = 0;
+			m_tx_buffer_ptr = m_tx_buffer_num = 0;
 		}
 		return;
 	}
 
-	if ( (microtouch.reset_done == 0) ||
-		 (microtouch.format == FORMAT_UNKNOWN) ||
-		 (microtouch.mode != MODE_STREAM))
+	if ( (m_reset_done == 0) ||
+		 (m_format == FORMAT_UNKNOWN) ||
+		 (m_mode != MODE_STREAM))
 	{
 		return;
 	}
 
 	// send format tablet packet
-	if ( input_port_read(machine, "TOUCH") & 0x01 )
+	if ( input_port_read(*this, "TOUCH") & 0x01 )
 	{
-		microtouch_send_touch_packet(machine);
+		send_touch_packet();
 	}
 	else
 	{
-		if ( microtouch.last_touch_state == 1 )
+		if ( m_last_touch_state == 1 )
 		{
-			microtouch.last_touch_state = 0;
-			switch( microtouch.format )
+			m_last_touch_state = 0;
+			switch( m_format )
 			{
 				case FORMAT_TABLET:
-					microtouch_send_format_table_packet(0x88, microtouch.last_x, microtouch.last_y);
+					send_format_table_packet(0x88, m_last_x, m_last_y);
 					break;
 				case FORMAT_DECIMAL:
-					microtouch_send_format_decimal_packet(microtouch.last_x, microtouch.last_y);
+					send_format_decimal_packet(m_last_x, m_last_y);
 					break;
 				case FORMAT_UNKNOWN:
 					break;
 			}
 		}
 	}
-};
+}
 
-void microtouch_init(running_machine &machine, microtouch_tx_func tx_cb, microtouch_touch_func touch_cb)
+void microtouch_device::device_config_complete()
 {
-	memset(&microtouch, 0, sizeof(microtouch));
+	const microtouch_interface *intf = reinterpret_cast<const microtouch_interface *>(static_config());
+	if(intf != NULL)
+		*static_cast<microtouch_interface *>(this) = *intf;
+	else
+	{
+		memset(&m_out_tx_cb, 0, sizeof(m_out_tx_cb));
+		memset(&m_out_touch_cb, 0, sizeof(m_out_touch_cb));
+	}
+}
 
-	microtouch.last_touch_state = -1;
-	microtouch.tx_callback = tx_cb;
-	microtouch.touch_callback = touch_cb;
-
-	microtouch.timer = machine.scheduler().timer_alloc(FUNC(microtouch_timer_callback));
-	microtouch.timer->adjust(attotime::from_hz(167*5), 0, attotime::from_hz(167*5));
-
-	microtouch.format = FORMAT_UNKNOWN;
-	microtouch.mode = MODE_INACTIVE;
-
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.reset_done);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.last_touch_state);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.last_x);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.last_y);
-	state_save_register_item_array(machine, "microtouch", NULL, 0, microtouch.rx_buffer);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.rx_buffer_ptr);
-	state_save_register_item_array(machine, "microtouch", NULL, 0, microtouch.tx_buffer);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.tx_buffer_num);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.tx_buffer_ptr);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.format);
-	state_save_register_item(machine, "microtouch", NULL, 0, microtouch.mode);
-};
+void microtouch_device::device_start()
+{
+	memset(m_rx_buffer, 0, sizeof(m_rx_buffer));
+	memset(m_tx_buffer, 0, sizeof(m_tx_buffer));
+	m_rx_buffer_ptr = 0;
+	m_tx_buffer_ptr = 0;
+	m_tx_buffer_num = 0;
+	m_reset_done = 0;
+	m_format = 0;
+	m_mode = 0;
+	m_last_x = 0;
+	m_last_y = 0;
+	m_last_touch_state = -1;
+
+	m_timer = timer_alloc();
+	m_timer->adjust(attotime::from_hz(167*5), 0, attotime::from_hz(167*5));
+
+	m_format = FORMAT_UNKNOWN;
+	m_mode = MODE_INACTIVE;
+
+	save_item(NAME(m_reset_done));
+	save_item(NAME(m_last_touch_state));
+	save_item(NAME(m_last_x));
+	save_item(NAME(m_last_y));
+	save_item(NAME(m_rx_buffer));
+	save_item(NAME(m_rx_buffer_ptr));
+	save_item(NAME(m_tx_buffer));
+	save_item(NAME(m_tx_buffer_num));
+	save_item(NAME(m_tx_buffer_ptr));
+	save_item(NAME(m_format));
+	save_item(NAME(m_mode));
+	m_out_tx_func.resolve(m_out_tx_cb, *this);
+}
 
 
-void microtouch_rx(int count, UINT8* data)
+WRITE8_MEMBER(microtouch_device::rx)
 {
-	int i;
-
-	for ( i = 0; (i < count) && ((microtouch.rx_buffer_ptr + i) < 16); i++ )
-	{
-		microtouch.rx_buffer[i+microtouch.rx_buffer_ptr] = data[i];
-		microtouch.rx_buffer_ptr++;
-	}
+	m_rx_buffer[m_rx_buffer_ptr] = data;
+	m_rx_buffer_ptr++;
+	if(m_rx_buffer_ptr == 16)
+		return;
 
-	if (microtouch.rx_buffer_ptr > 0 && (microtouch.rx_buffer[microtouch.rx_buffer_ptr-1] == 0x0d))
+	if (m_rx_buffer_ptr > 0 && (m_rx_buffer[m_rx_buffer_ptr-1] == 0x0d))
 	{
 		if (LOG)
 		{
 			char command[16];
 			memset(command, 0, sizeof(command));
-			strncpy( command, (const char*)microtouch.rx_buffer + 1, microtouch.rx_buffer_ptr - 2 );
+			strncpy( command, (const char*)m_rx_buffer + 1, m_rx_buffer_ptr - 2 );
 			logerror("Microtouch: received command %s\n", command);
 		}
 		// check command
-		if ( microtouch_check_command( "MS", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		if ( check_command( "MS", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.mode = MODE_STREAM;
+			m_mode = MODE_STREAM;
 		}
-		else if ( microtouch_check_command( "MI", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command( "MI", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.mode = MODE_INACTIVE;
+			m_mode = MODE_INACTIVE;
 		}
-		else if ( microtouch_check_command( "MP", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command( "MP", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.mode = MODE_POINT;
+			m_mode = MODE_POINT;
 		}
-		else if ( microtouch_check_command( "R", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command( "R", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.tx_buffer_num = 0;
-			microtouch.reset_done = 1;
+			m_tx_buffer_num = 0;
+			m_reset_done = 1;
 		}
-		else if ( microtouch_check_command( "FT", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command( "FT", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.format = FORMAT_TABLET;
+			m_format = FORMAT_TABLET;
 		}
-		else if ( microtouch_check_command( "FD", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command( "FD", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
-			microtouch.format = FORMAT_DECIMAL;
+			m_format = FORMAT_DECIMAL;
 		}
-		else if ( microtouch_check_command("OI", microtouch.rx_buffer_ptr, microtouch.rx_buffer ) )
+		else if ( check_command("OI", m_rx_buffer_ptr, m_rx_buffer ) )
 		{
 			// output identity - SMT3, ver 01.00
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x01;
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = 'Q';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = '1';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = '0';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = '1';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = '0';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = '0';
-			microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x0d;
-			microtouch.rx_buffer_ptr = 0;
+			m_tx_buffer[m_tx_buffer_num++] = 0x01;
+			m_tx_buffer[m_tx_buffer_num++] = 'Q';
+			m_tx_buffer[m_tx_buffer_num++] = '1';
+			m_tx_buffer[m_tx_buffer_num++] = '0';
+			m_tx_buffer[m_tx_buffer_num++] = '1';
+			m_tx_buffer[m_tx_buffer_num++] = '0';
+			m_tx_buffer[m_tx_buffer_num++] = '0';
+			m_tx_buffer[m_tx_buffer_num++] = 0x0d;
+			m_rx_buffer_ptr = 0;
 			return;
 		}
 		// send response
-		microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x01;
-		microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x30;
-		microtouch.tx_buffer[microtouch.tx_buffer_num++] = 0x0d;
-		microtouch.rx_buffer_ptr = 0;
+		m_tx_buffer[m_tx_buffer_num++] = 0x01;
+		m_tx_buffer[m_tx_buffer_num++] = 0x30;
+		m_tx_buffer[m_tx_buffer_num++] = 0x0d;
+		m_rx_buffer_ptr = 0;
 	}
 };
 
-static INPUT_CHANGED( microtouch_touch )
+INPUT_CHANGED_MEMBER( microtouch_device::touch )
 {
-	if ( newval && ( microtouch.mode == MODE_POINT ) )
+	if ( newval && ( m_mode == MODE_POINT ) )
 	{
-		microtouch_send_touch_packet( field.machine() );
+		send_touch_packet();
 	}
 }
 
-INPUT_PORTS_START(microtouch)
+static INPUT_PORTS_START(microtouch)
 	PORT_START("TOUCH")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME( "Touch screen" ) PORT_CHANGED( microtouch_touch, 0 )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME( "Touch screen" ) PORT_CHANGED_MEMBER( DEVICE_SELF,microtouch_device, touch, 0 )
 	PORT_START("TOUCH_X")
 	PORT_BIT( 0x3fff, 0x2000, IPT_LIGHTGUN_X ) PORT_CROSSHAIR(X, 1.0, 0.0, 0) PORT_SENSITIVITY(45) PORT_KEYDELTA(15)
 	PORT_START("TOUCH_Y")
 	PORT_BIT( 0x3fff, 0x2000, IPT_LIGHTGUN_Y ) PORT_CROSSHAIR(Y, 1.0, 0.0, 0) PORT_SENSITIVITY(45) PORT_KEYDELTA(15)
 INPUT_PORTS_END
 
+ioport_constructor microtouch_device::device_input_ports() const
+{
+	return INPUT_PORTS_NAME(microtouch);
+}
+
+const device_type MICROTOUCH_SERIAL = &device_creator<microtouch_serial_device>;
+
+microtouch_serial_device::microtouch_serial_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: microtouch_device(mconfig, MICROTOUCH_SERIAL, "Microtouch Serial Touchscreen", tag, owner, clock),
+	  device_serial_interface(mconfig, *this)
+{
+}
+
+void microtouch_serial_device::device_config_complete()
+{
+	const microtouch_serial_interface *intf = reinterpret_cast<const microtouch_serial_interface *>(static_config());
+	if(intf != NULL)
+		*static_cast<microtouch_serial_interface *>(this) = *intf;
+	else
+	{
+		memset(&m_out_stx_cb, 0, sizeof(m_out_stx_cb));
+	}
+	memset(&(microtouch_interface::m_out_tx_cb), 0, sizeof(microtouch_interface::m_out_tx_cb));
+	memset(&m_out_touch_cb, 0, sizeof(m_out_touch_cb));
+}
+
+void microtouch_serial_device::device_start()
+{
+	microtouch_device::device_start();
+	set_data_frame(8, 1, SERIAL_PARITY_NONE); //8N1?
+	set_tra_rate(clock());
+	set_rcv_rate(clock());
+	m_out_stx_func.resolve(m_out_stx_cb, *this);
+	m_output_valid = false;
+
+	save_item(NAME(m_output_valid));
+	save_item(NAME(m_output));
+}
+
+void microtouch_serial_device::tx(UINT8 data)
+{
+	m_output = data;
+	m_output_valid = true;
+	if(is_transmit_register_empty())
+		tra_complete();
+}
+
+void microtouch_serial_device::tra_callback()
+{
+	m_out_stx_func(transmit_register_get_data_bit());
+}
+
+void microtouch_serial_device::tra_complete()
+{
+	if(m_output_valid)
+	{
+		transmit_register_setup(m_output);
+		m_output_valid = false;
+	}
+}
+
+void microtouch_serial_device::rcv_complete()
+{
+	receive_register_extract();
+	microtouch_device::rx(*memory_nonspecific_space(machine()), 0, get_received_char());
+}
diff -Nru src-old/emu/machine/microtch.h src/emu/machine/microtch.h
--- src-old/emu/machine/microtch.h	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/machine/microtch.h	2012-02-20 18:34:10.000000000 +0100
@@ -1,12 +1,104 @@
 #ifndef _MICROTOUCH_H
 #define _MICROTOUCH_H
 
-INPUT_PORTS_EXTERN(microtouch);
+#include "emu.h"
 
-typedef void (*microtouch_tx_func)(running_machine &machine, UINT8 data);
-typedef int (*microtouch_touch_func)(running_machine &machine, int *touch_x, int *touch_y);
+typedef int (*microtouch_touch_func)(int *touch_x, int *touch_y);
+#define MICROTOUCH_TOUCH(name) int name(int *touch_x, int *touch_y)
 
-void microtouch_init(running_machine &machine, microtouch_tx_func tx_cb, microtouch_touch_func touch_cb);
-void microtouch_rx(int count, UINT8* data);
+struct microtouch_interface
+{
+	devcb_write8			m_out_tx_cb;
+	microtouch_touch_func	m_out_touch_cb;
+};
+
+class microtouch_device :
+		public device_t,
+		public microtouch_interface
+{
+public:
+	microtouch_device(const machine_config &mconfig, device_type type, const char* name, const char *tag, device_t *owner, UINT32 clock);
+	microtouch_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	virtual ioport_constructor device_input_ports() const;
+	DECLARE_WRITE8_MEMBER(rx);
+	DECLARE_INPUT_CHANGED_MEMBER(touch);
+protected:
+	virtual void device_start();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+	virtual void device_config_complete();
+	virtual void tx(UINT8 data) { m_out_tx_func(0, data); }
+	emu_timer*	m_timer;
+private:
+	int check_command( const char* commandtocheck, int command_len, UINT8* command_data );
+	void send_format_table_packet(UINT8 flag, int x, int y);
+	void send_format_decimal_packet(int x, int y);
+	void send_touch_packet();
+
+	enum
+	{
+		FORMAT_UNKNOWN,
+		FORMAT_TABLET,
+		FORMAT_DECIMAL
+	};
+	enum
+	{
+		MODE_INACTIVE,
+		MODE_STREAM,
+		MODE_POINT
+	};
+	UINT8		m_rx_buffer[16];
+	int			m_rx_buffer_ptr;
+	UINT8		m_tx_buffer[16];
+	UINT8		m_tx_buffer_num;
+	UINT8		m_tx_buffer_ptr;
+	int			m_reset_done;
+	int			m_format;
+	int			m_mode;
+	int			m_last_touch_state;
+	int			m_last_x;
+	int			m_last_y;
+	devcb_resolved_write8 m_out_tx_func;
+};
+
+extern const device_type MICROTOUCH;
+
+#define MCFG_MICROTOUCH_ADD(_tag, _intrf) \
+	MCFG_DEVICE_ADD(_tag, MICROTOUCH, 0) \
+	MCFG_DEVICE_CONFIG(_intrf)
+
+struct microtouch_serial_interface
+{
+	devcb_write_line m_out_stx_cb;
+};
+
+class microtouch_serial_device
+	: public microtouch_device,
+	  public device_serial_interface,
+	  public microtouch_serial_interface
+{
+public:
+	microtouch_serial_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	DECLARE_WRITE_LINE_MEMBER(rx) { check_for_start(state); }
+protected:
+	virtual void device_start();
+	virtual void device_config_complete();
+	virtual void tx(UINT8 data);
+	virtual void input_callback(UINT8 state) { m_input_state = state; }
+	virtual void tra_callback();
+	virtual void tra_complete();
+	virtual void rcv_complete();
+private:
+	bool m_output_valid;
+	UINT8 m_output;
+	devcb_resolved_write_line m_out_stx_func;
+};
+
+extern const device_type MICROTOUCH_SERIAL;
+
+#define MCFG_MICROTOUCH_SERIAL_ADD(_tag, _intrf, _clock) \
+	MCFG_DEVICE_ADD(_tag, MICROTOUCH_SERIAL, _clock) \
+	MCFG_DEVICE_CONFIG(_intrf)
 
 #endif //_MICROTOUCH_H
diff -Nru src-old/emu/machine/nscsi_cd.h src/emu/machine/nscsi_cd.h
--- src-old/emu/machine/nscsi_cd.h	2012-02-09 04:41:36.000000000 +0100
+++ src/emu/machine/nscsi_cd.h	2012-02-23 15:19:37.000000000 +0100
@@ -18,6 +18,7 @@
 protected:
 	virtual void device_start();
 	virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "scsi_cdrom"; }
 
 	virtual void scsi_command();
 	virtual UINT8 scsi_get_data(int id, int pos);
diff -Nru src-old/emu/machine/nscsi_hd.h src/emu/machine/nscsi_hd.h
--- src-old/emu/machine/nscsi_hd.h	2012-02-09 04:41:36.000000000 +0100
+++ src/emu/machine/nscsi_hd.h	2012-02-23 15:19:37.000000000 +0100
@@ -18,6 +18,7 @@
 protected:
 	virtual void device_start();
 	virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "scsi_harddisk"; }
 
 	virtual void scsi_command();
 	virtual UINT8 scsi_get_data(int id, int pos);
diff -Nru src-old/emu/machine/pc16552d.c src/emu/machine/pc16552d.c
--- src-old/emu/machine/pc16552d.c	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/machine/pc16552d.c	2012-02-19 17:46:00.000000000 +0100
@@ -55,7 +55,7 @@
 	PC16552D_CHANNEL ch[2];
 	int frequency;
 	void (* irq_handler)(running_machine &machine, int channel, int value);
-	void (* tx_callback)(int channel, int count, UINT8* data);
+	void (* tx_callback)(running_machine &machine, int channel, int count, UINT8* data);
 } PC16552D_REGS;
 
 #define MAX_PC16552D_CHIPS		4
@@ -151,7 +151,7 @@
 	ch = &duart[chip].ch[channel];
 
 	if (duart[chip].tx_callback)
-		duart[chip].tx_callback(channel, ch->tx_fifo_num, ch->tx_fifo);
+		duart[chip].tx_callback(machine, channel, ch->tx_fifo_num, ch->tx_fifo);
 
 	ch->tx_fifo_num = 0;
 
@@ -387,7 +387,7 @@
 
 /*****************************************************************************/
 
-void pc16552d_init(running_machine &machine, int chip, int frequency, void (* irq_handler)(running_machine &machine, int channel, int value), void (* tx_callback)(int channel, int count, UINT8* data))
+void pc16552d_init(running_machine &machine, int chip, int frequency, void (* irq_handler)(running_machine &machine, int channel, int value), void (* tx_callback)(running_machine &machine, int channel, int count, UINT8* data))
 {
 	memset(&duart[chip], 0, sizeof(PC16552D_REGS));
 
diff -Nru src-old/emu/machine/pc16552d.h src/emu/machine/pc16552d.h
--- src-old/emu/machine/pc16552d.h	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/machine/pc16552d.h	2012-02-19 17:46:00.000000000 +0100
@@ -1,7 +1,7 @@
 #ifndef PC16552D_H
 #define PC16552D_H
 
-void pc16552d_init(running_machine &machine, int chip, int frequency, void (* irq_handler)(running_machine &machine, int channel, int value), void (* tx_callback)(int channel, int count, UINT8* data));
+void pc16552d_init(running_machine &machine, int chip, int frequency, void (* irq_handler)(running_machine &machine, int channel, int value), void (* tx_callback)(running_machine &machine, int channel, int count, UINT8* data));
 void pc16552d_rx_data(running_machine &machine, int chip, int channel, UINT8 data);
 
 READ8_HANDLER(pc16552d_0_r);
diff -Nru src-old/emu/machine.c src/emu/machine.c
--- src-old/emu/machine.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/machine.c	2012-02-26 15:31:24.000000000 +0100
@@ -1084,6 +1084,9 @@
 	// set the short name to the game's name
 	driver.m_shortname = game.name;
 
+	// set the full name to the game's description
+	driver.m_name = game.description;
+
 	// and set the search path to include all parents
 	driver.m_searchpath = game.name;
 	for (int parent = driver_list::clone(game); parent != -1; parent = driver_list::clone(parent))
diff -Nru src-old/emu/romload.c src/emu/romload.c
--- src-old/emu/romload.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/romload.c	2012-02-21 07:29:54.000000000 +0100
@@ -165,53 +165,13 @@
 ***************************************************************************/
 
 /*-------------------------------------------------
-    rom_first_source - return pointer to first ROM
-    source
--------------------------------------------------*/
-
-const rom_source *rom_first_source(const machine_config &config)
-{
-	/* look through devices */
-	device_iterator iter(config.root_device());
-	for (const device_t *device = iter.first(); device != NULL; device = iter.next())
-		if (device->rom_region() != NULL)
-			return device;
-
-	return NULL;
-}
-
-
-/*-------------------------------------------------
-    rom_next_source - return pointer to next ROM
-    source
--------------------------------------------------*/
-
-const rom_source *rom_next_source(const rom_source &previous)
-{
-	/* look for further devices with ROM definitions */
-// fixme: this is awful
-	device_iterator iter(previous.mconfig().root_device());
-	const device_t *device;
-	for (device = iter.first(); device != NULL; device = iter.next())
-		if (device == &previous)
-			break;
-
-	for (device = iter.next(); device != NULL; device = iter.next())
-		if (device->rom_region() != NULL)
-			return device;
-
-	return NULL;
-}
-
-
-/*-------------------------------------------------
     rom_first_region - return pointer to first ROM
     region
 -------------------------------------------------*/
 
-const rom_entry *rom_first_region(const rom_source &source)
+const rom_entry *rom_first_region(const device_t &device)
 {
-	const rom_entry *romp = source.rom_region();
+	const rom_entry *romp = device.rom_region();
 	return (romp != NULL && !ROMENTRY_ISEND(romp)) ? romp : NULL;
 }
 
@@ -263,9 +223,9 @@
     for a rom region
 -------------------------------------------------*/
 
-astring &rom_region_name(astring &result, const game_driver *drv, const rom_source *source, const rom_entry *romp)
+astring &rom_region_name(astring &result, const device_t &device, const rom_entry *romp)
 {
-	return source->subtag(result, ROM_GETNAME(romp));
+	return device.subtag(result, ROM_GETNAME(romp));
 }
 
 
@@ -333,46 +293,45 @@
 
 	romdata->system_bios = 0;
 
-	for (const rom_source *source = rom_first_source(romdata->machine().config()); source != NULL; source = rom_next_source(*source))
-	{
-		/* first determine the default BIOS name */
-		for (rom = source->rom_region(); !ROMENTRY_ISEND(rom); rom++)
-			if (ROMENTRY_ISDEFAULT_BIOS(rom))
-				defaultname = ROM_GETNAME(rom);
-
-		/* look for a BIOS with a matching name */
-		for (rom = source->rom_region(); !ROMENTRY_ISEND(rom); rom++)
-			if (ROMENTRY_ISSYSTEM_BIOS(rom))
-			{
-				const char *biosname = ROM_GETNAME(rom);
-				int bios_flags = ROM_GETBIOSFLAGS(rom);
-				char bios_number[20];
-
-				/* Allow '-bios n' to still be used */
-				sprintf(bios_number, "%d", bios_flags - 1);
-				if (mame_stricmp(bios_number, specbios) == 0 || mame_stricmp(biosname, specbios) == 0)
-					romdata->system_bios = bios_flags;
-				if (defaultname != NULL && mame_stricmp(biosname, defaultname) == 0)
-					default_no = bios_flags;
-				bios_count++;
-			}
+	device_t &rootdevice = romdata->machine().config().root_device();
 
-		/* if none found, use the default */
-		if (romdata->system_bios == 0 && bios_count > 0)
+	/* first determine the default BIOS name */
+	for (rom = rootdevice.rom_region(); !ROMENTRY_ISEND(rom); rom++)
+		if (ROMENTRY_ISDEFAULT_BIOS(rom))
+			defaultname = ROM_GETNAME(rom);
+
+	/* look for a BIOS with a matching name */
+	for (rom = rootdevice.rom_region(); !ROMENTRY_ISEND(rom); rom++)
+		if (ROMENTRY_ISSYSTEM_BIOS(rom))
 		{
-			/* if we got neither an empty string nor 'default' then warn the user */
-			if (specbios[0] != 0 && strcmp(specbios, "default") != 0 && romdata != NULL)
-			{
-				romdata->errorstring.catprintf("%s: invalid bios\n", specbios);
-				romdata->warnings++;
-			}
+			const char *biosname = ROM_GETNAME(rom);
+			int bios_flags = ROM_GETBIOSFLAGS(rom);
+			char bios_number[20];
+
+			/* Allow '-bios n' to still be used */
+			sprintf(bios_number, "%d", bios_flags - 1);
+			if (mame_stricmp(bios_number, specbios) == 0 || mame_stricmp(biosname, specbios) == 0)
+				romdata->system_bios = bios_flags;
+			if (defaultname != NULL && mame_stricmp(biosname, defaultname) == 0)
+				default_no = bios_flags;
+			bios_count++;
+		}
 
-			/* set to default */
-			romdata->system_bios = default_no;
+	/* if none found, use the default */
+	if (romdata->system_bios == 0 && bios_count > 0)
+	{
+		/* if we got neither an empty string nor 'default' then warn the user */
+		if (specbios[0] != 0 && strcmp(specbios, "default") != 0 && romdata != NULL)
+		{
+			romdata->errorstring.catprintf("%s: invalid bios\n", specbios);
+			romdata->warnings++;
 		}
-		romdata->default_bios = default_no;
-		LOG(("Using System BIOS: %d\n", romdata->system_bios));
+
+		/* set to default */
+		romdata->system_bios = default_no;
 	}
+	romdata->default_bios = default_no;
+	LOG(("Using System BIOS: %d\n", romdata->system_bios));
 }
 
 
@@ -384,15 +343,15 @@
 static void count_roms(rom_load_data *romdata)
 {
 	const rom_entry *region, *rom;
-	const rom_source *source;
 
 	/* start with 0 */
 	romdata->romstotal = 0;
 	romdata->romstotalsize = 0;
 
 	/* loop over regions, then over files */
-	for (source = rom_first_source(romdata->machine().config()); source != NULL; source = rom_next_source(*source))
-		for (region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+	device_iterator deviter(romdata->machine().config().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		for (region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 			for (rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
 				if (ROM_GETBIOSFLAGS(rom) == 0 || ROM_GETBIOSFLAGS(rom) == romdata->system_bios)
 				{
@@ -455,15 +414,6 @@
 	astring tempstr;
 	romdata->errorstring.catprintf("    EXPECTED: %s\n", hashes.macro_string(tempstr));
 	romdata->errorstring.catprintf("       FOUND: %s\n", acthashes.macro_string(tempstr));
-/*
-    // warn about any ill-formed hashes
-    for (hash_base *hash = hashes.first(); hash != NULL; hash = hash->next())
-        if (hash->parse_error())
-        {
-            romdata->errorstring.catprintf("\tInvalid %s checksum treated as 0 (check leading zeros)\n", hash->name());
-            romdata->warnings++;
-        }
-*/
 }
 
 
@@ -1003,7 +953,6 @@
 {
 	emu_file image_file(options.media_path(), OPEN_FLAG_READ);
 	const rom_entry *region, *rom;
-	const rom_source *source;
 	file_error filerr;
 	chd_error err;
 
@@ -1107,8 +1056,9 @@
 	for (int drv = driver_list::find(*gamedrv); drv != -1; drv = driver_list::clone(drv))
 	{
 		machine_config config(driver_list::driver(drv), options);
-		for (source = rom_first_source(config); source != NULL; source = rom_next_source(*source))
-			for (region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+		device_iterator deviter(config.root_device());
+		for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+			for (region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 				if (ROMREGION_ISDISKDATA(region))
 					for (rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
 
@@ -1430,16 +1380,15 @@
 static void process_region_list(rom_load_data *romdata)
 {
 	astring regiontag;
-	const rom_source *source;
-	const rom_entry *region;
 
 	/* loop until we hit the end */
-	for (source = rom_first_source(romdata->machine().config()); source != NULL; source = rom_next_source(*source))
-		for (region = rom_first_region(*source); region != NULL; region = rom_next_region(region))
+	device_iterator deviter(romdata->machine().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		for (const rom_entry *region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 		{
 			UINT32 regionlength = ROMREGION_GETLENGTH(region);
 
-			rom_region_name(regiontag, &romdata->machine().system(), source, region);
+			rom_region_name(regiontag, *device, region);
 			LOG(("Processing region \"%s\" (length=%X)\n", regiontag.cstr(), regionlength));
 
 			/* the first entry must be a region */
@@ -1472,16 +1421,17 @@
 #endif
 
 				/* now process the entries in the region */
-				process_rom_entries(romdata, (source->shortname()!=NULL) ? source->shortname() : NULL, region, region + 1);
+				process_rom_entries(romdata, device->shortname(), region, region + 1);
 			}
 			else if (ROMREGION_ISDISKDATA(region))
 				process_disk_entries(romdata, regiontag, region, region + 1, NULL);
 		}
 
 	/* now go back and post-process all the regions */
-	for (source = rom_first_source(romdata->machine().config()); source != NULL; source = rom_next_source(*source))
-		for (region = rom_first_region(*source); region != NULL; region = rom_next_region(region)) {
-			rom_region_name(regiontag, &romdata->machine().system(), source, region);
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		for (const rom_entry *region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
+		{
+			rom_region_name(regiontag, *device, region);
 			region_post_process(romdata, regiontag, ROMREGION_ISINVERTED(region));
 		}
 }
diff -Nru src-old/emu/romload.h src/emu/romload.h
--- src-old/emu/romload.h	2012-02-16 10:47:18.000000000 +0100
+++ src/emu/romload.h	2012-02-20 07:06:58.000000000 +0100
@@ -123,8 +123,6 @@
 class emu_options;
 class chd_file;
 
-typedef device_t rom_source;
-
 
 struct rom_entry
 {
@@ -284,14 +282,8 @@
 
 /* ----- ROM iteration ----- */
 
-/* return pointer to first ROM source */
-const rom_source *rom_first_source(const machine_config &config);
-
-/* return pointer to next ROM source */
-const rom_source *rom_next_source(const rom_source &previous);
-
 /* return pointer to the first ROM region within a source */
-const rom_entry *rom_first_region(const rom_source &romp);
+const rom_entry *rom_first_region(const device_t &romp);
 
 /* return pointer to the next ROM region within a source */
 const rom_entry *rom_next_region(const rom_entry *romp);
@@ -302,14 +294,11 @@
 /* return pointer to the next ROM file within a region */
 const rom_entry *rom_next_file(const rom_entry *romp);
 
-/* return TRUE if the given rom_source refers to the game driver itself */
-int rom_source_is_gamedrv(const game_driver *drv, const rom_source *source);
-
 /* return the expected size of a file given the ROM description */
 UINT32 rom_file_size(const rom_entry *romp);
 
 /* return the appropriate name for a rom region */
-astring &rom_region_name(astring &result, const game_driver *drv, const rom_source *source, const rom_entry *romp);
+astring &rom_region_name(astring &result, const device_t &device, const rom_entry *romp);
 
 
 
diff -Nru src-old/emu/sound/bsmt2000.c src/emu/sound/bsmt2000.c
--- src-old/emu/sound/bsmt2000.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/sound/bsmt2000.c	2012-02-25 20:21:35.000000000 +0100
@@ -106,10 +106,6 @@
 //  bsmt2000_device - constructor
 //-------------------------------------------------
 
-//-------------------------------------------------
-//  bsmt2000_device - constructor
-//-------------------------------------------------
-
 bsmt2000_device::bsmt2000_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
 	: device_t(mconfig, BSMT2000, "BSMT2000", "bsmt2000", tag, owner, clock),
 	  device_sound_interface(mconfig, *this),
diff -Nru src-old/emu/sound/samples.c src/emu/sound/samples.c
--- src-old/emu/sound/samples.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/sound/samples.c	2012-02-25 20:19:01.000000000 +0100
@@ -122,10 +122,10 @@
 	chan.stream->update();
 
 	// update the parameters
-	loaded_sample &sample = m_sample[samplenum];
+	sample_t &sample = m_sample[samplenum];
 	chan.source = sample.data;
-	chan.source_length = sample.length;
-	chan.source_num = (sample.data.count() > 0) ? samplenum : -1;
+	chan.source_length = sample.data.count();
+	chan.source_num = (chan.source_length > 0) ? samplenum : -1;
 	chan.pos = 0;
 	chan.frac = 0;
 	chan.basefreq = sample.frequency;
@@ -330,9 +330,9 @@
 		channel_t &chan = m_channel[channel];
 		if (chan.source_num >= 0 && chan.source_num < m_sample.count())
 		{
-			loaded_sample &sample = m_sample[chan.source_num];
+			sample_t &sample = m_sample[chan.source_num];
 			chan.source = sample.data;
-			chan.source_length = sample.length;
+			chan.source_length = sample.data.count();
 			if (sample.data == NULL)
 				chan.source_num = -1;
 		}
@@ -426,7 +426,7 @@
 //  sample
 //-------------------------------------------------
 
-bool samples_device::read_sample(emu_file &file, loaded_sample &sample)
+bool samples_device::read_sample(emu_file &file, sample_t &sample)
 {
 	// read the core header and make sure it's a proper file
 	UINT8 buf[4];
@@ -453,9 +453,8 @@
 //  read_wav_sample - read a WAV file as a sample
 //-------------------------------------------------
 
-bool samples_device::read_wav_sample(emu_file &file, loaded_sample &sample)
+bool samples_device::read_wav_sample(emu_file &file, sample_t &sample)
 {
-printf("Reading %s as WAV\n", file.filename());
 	// we already read the opening 'WAVE' header
 	UINT32 offset = 4;
 
@@ -544,7 +543,6 @@
 		return false;
 
 	// fill in the sample data
-	sample.length = length / 2;
 	sample.frequency = rate;
 
 	// read the data in
@@ -555,7 +553,7 @@
 
 		// convert 8-bit data to signed samples
 		UINT8 *tempptr = reinterpret_cast<UINT8 *>(&sample.data[0]);
-		for (UINT32 sindex = length - 1; sindex >= 0; sindex--)
+		for (INT32 sindex = length - 1; sindex >= 0; sindex--)
 			sample.data[sindex] = INT8(tempptr[sindex] ^ 0x80) * 256;
 	}
 	else
@@ -566,7 +564,7 @@
 
 		// swap high/low on big-endian systems
 		if (ENDIANNESS_NATIVE != ENDIANNESS_LITTLE)
-			for (UINT32 sindex = 0; sindex < sample.length; sindex++)
+			for (UINT32 sindex = 0; sindex < length / 2; sindex++)
 				sample.data[sindex] = LITTLE_ENDIANIZE_INT16(sample.data[sindex]);
 	}
 	return true;
@@ -577,15 +575,13 @@
 //  read_flac_sample - read a FLAC file as a sample
 //-------------------------------------------------
 
-bool samples_device::read_flac_sample(emu_file &file, loaded_sample &sample)
+bool samples_device::read_flac_sample(emu_file &file, sample_t &sample)
 {
-printf("Reading %s as FLAC\n", file.filename());
 	// seek back to the start of the file
 	file.seek(0, SEEK_SET);
 
 	// create the FLAC decoder and fill in the sample data
 	flac_decoder decoder(file);
-	sample.length = decoder.total_samples();
 	sample.frequency = decoder.sample_rate();
 
 	// error if more than 1 channel or not 16bpp
@@ -595,8 +591,8 @@
 		return false;
 
 	// resize the array and read
-	sample.data.resize(sample.length);
-	if (!decoder.decode_interleaved(sample.data, sample.length))
+	sample.data.resize(decoder.total_samples());
+	if (!decoder.decode_interleaved(sample.data, sample.data.count()))
 		return false;
 
 	// finish up and clean up
@@ -628,7 +624,6 @@
 	int index = 0;
 	for (const char *samplename = iter.first(); samplename != NULL; index++, samplename = iter.next())
 	{
-printf("Sample %d = %s\n", index, samplename);
 		// attempt to open as FLAC first
 		emu_file file(machine().options().sample_path(), OPEN_FLAG_READ);
 		file_error filerr = file.open(basename, PATH_SEPARATOR, samplename, ".flac");
diff -Nru src-old/emu/sound/samples.h src/emu/sound/samples.h
--- src-old/emu/sound/samples.h	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/sound/samples.h	2012-02-25 20:19:01.000000000 +0100
@@ -105,6 +105,17 @@
 	void set_frequency(UINT8 channel, UINT32 frequency);
 	void set_volume(UINT8 channel, float volume);
 
+	// helpers
+	struct sample_t
+	{
+		// shouldn't need a copy, but in case it happens, catch it here
+		sample_t &operator=(const sample_t &rhs) { assert(false); return *this; }
+
+	    UINT32			frequency;		// frequency of the sample
+	    dynamic_array<INT16> data;		// 16-bit signed data
+	};
+	static bool read_sample(emu_file &file, sample_t &sample);
+
 protected:
 	// subclasses can do it this way
 	samples_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
@@ -119,16 +130,6 @@
 
 private:
 	// internal classes
-	struct loaded_sample
-	{
-		// shouldn't need a copy, but in case it happens, catch it here
-		loaded_sample &operator=(const loaded_sample &rhs) { assert(false); return *this; }
-
-	    UINT32			length;			// length in samples
-	    UINT32			frequency;		// frequency of the sample
-	    dynamic_array<INT16> data;		// 16-bit signed data
-	};
-
 	struct channel_t
 	{
 		sound_stream *	stream;
@@ -144,14 +145,13 @@
 	};
 
 	// internal helpers
-	bool read_sample(emu_file &file, loaded_sample &sample);
-	bool read_wav_sample(emu_file &file, loaded_sample &sample);
-	bool read_flac_sample(emu_file &file, loaded_sample &sample);
+	static bool read_wav_sample(emu_file &file, sample_t &sample);
+	static bool read_flac_sample(emu_file &file, sample_t &sample);
 	void load_samples();
 
 	// internal state
-	dynamic_array<channel_t>		m_channel;
-	dynamic_array<loaded_sample>	m_sample;
+	dynamic_array<channel_t>	m_channel;
+	dynamic_array<sample_t>		m_sample;
 
 	// internal constants
 	static const UINT8 FRAC_BITS = 24;
diff -Nru src-old/emu/speaker.c src/emu/speaker.c
--- src-old/emu/speaker.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/speaker.c	2012-02-25 20:21:35.000000000 +0100
@@ -45,9 +45,9 @@
 
 
 
-/***************************************************************************
-    DEBUGGING
-***************************************************************************/
+//**************************************************************************
+//  DEBUGGING
+//**************************************************************************
 
 #define VERBOSE			(0)
 
@@ -56,23 +56,28 @@
 
 
 //**************************************************************************
-//  LIVE SPEAKER DEVICE
+//  GLOBAL VARIABLES
 //**************************************************************************
 
 // device type definition
 const device_type SPEAKER = &device_creator<speaker_device>;
 
+
+
+//**************************************************************************
+//  LIVE SPEAKER DEVICE
+//**************************************************************************
+
 //-------------------------------------------------
 //  speaker_device - constructor
 //-------------------------------------------------
 
 speaker_device::speaker_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
 	: device_t(mconfig, SPEAKER, "Speaker", tag, owner, clock),
-	  device_sound_interface(mconfig, *this),
+	  device_mixer_interface(mconfig, *this),
 	  m_x(0.0),
 	  m_y(0.0),
-	  m_z(0.0),
-	  m_mixer_stream(NULL)
+	  m_z(0.0)
 #ifdef MAME_DEBUG
 	,
 	  m_max_sample(0),
@@ -112,57 +117,6 @@
 
 
 //-------------------------------------------------
-//  device_start - perform device-specific
-//  startup
-//-------------------------------------------------
-
-void speaker_device::device_start()
-{
-	// no inputs? that's weird
-	if (m_auto_allocated_inputs == 0)
-	{
-		logerror("Warning: speaker \"%s\" has no inputs\n", tag());
-		return;
-	}
-
-	// allocate the mixer stream
-	m_mixer_stream = machine().sound().stream_alloc(*this, m_auto_allocated_inputs, 1, machine().sample_rate());
-}
-
-
-//-------------------------------------------------
-//  device_post_load - after we load a save state
-//  be sure to update the mixer stream's output
-//  sample rate
-//-------------------------------------------------
-
-void speaker_device::device_post_load()
-{
-	m_mixer_stream->set_sample_rate(machine().sample_rate());
-}
-
-
-//-------------------------------------------------
-//  mixer_update - mix all inputs to one output
-//-------------------------------------------------
-
-void speaker_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
-{
-	VPRINTF(("Mixer_update(%d)\n", samples));
-
-	// loop over samples
-	for (int pos = 0; pos < samples; pos++)
-	{
-		// add up all the inputs
-		INT32 sample = inputs[0][pos];
-		for (int inp = 1; inp < m_auto_allocated_inputs; inp++)
-			sample += inputs[inp][pos];
-		outputs[0][pos] = sample;
-	}
-}
-
-
-//-------------------------------------------------
 //  mix - mix in samples from the speaker's stream
 //-------------------------------------------------
 
@@ -223,3 +177,13 @@
 				rightmix[sample] += stream_buf[sample];
 	}
 }
+
+
+//-------------------------------------------------
+//  device_start - handle device startup
+//-------------------------------------------------
+
+void speaker_device::device_start()
+{
+	// dummy save to make device.c happy
+}
diff -Nru src-old/emu/speaker.h src/emu/speaker.h
--- src-old/emu/speaker.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/speaker.h	2012-02-25 20:21:35.000000000 +0100
@@ -48,6 +48,15 @@
 
 
 //**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+// device type definition
+extern const device_type SPEAKER;
+
+
+
+//**************************************************************************
 //  DEVICE CONFIGURATION MACROS
 //**************************************************************************
 
@@ -72,7 +81,7 @@
 // ======================> speaker_device
 
 class speaker_device : public device_t,
-					   public device_sound_interface
+					   public device_mixer_interface
 {
 	friend resource_pool_object<speaker_device>::~resource_pool_object();
 
@@ -89,11 +98,7 @@
 
 protected:
 	// device-level overrides
-	virtual void device_start();
-	virtual void device_post_load();
-
-	// sound interface overrides
-	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+	virtual void device_start() ATTR_COLD;
 
 	// inline configuration state
 	double				m_x;
@@ -101,7 +106,6 @@
 	double				m_z;
 
 	// internal state
-	sound_stream *		m_mixer_stream;			// mixing stream
 #ifdef MAME_DEBUG
 	INT32				m_max_sample;			// largest sample value we've seen
 	INT32				m_clipped_samples;		// total number of clipped samples
@@ -110,10 +114,6 @@
 };
 
 
-// device type definition
-extern const device_type SPEAKER;
-
-
 // speaker device iterator
 typedef device_type_iterator<&device_creator<speaker_device>, speaker_device> speaker_device_iterator;
 
diff -Nru src-old/emu/validity.c src/emu/validity.c
--- src-old/emu/validity.c	2012-02-11 17:15:39.000000000 +0100
+++ src/emu/validity.c	2012-02-26 15:31:24.000000000 +0100
@@ -60,11 +60,6 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-extern const device_type *s_devices_sorted[];
-extern int m_device_count;
-
-
-
 //**************************************************************************
 //  INLINE FUNCTIONS
 //**************************************************************************
@@ -302,7 +297,6 @@
 		validate_display();
 		validate_gfx();
 		validate_devices();
-		validate_slots();
 	}
 	catch (emu_fatalerror &err)
 	{
@@ -616,10 +610,11 @@
 void validity_checker::validate_roms()
 {
 	// iterate, starting with the driver's ROMs and continuing with device ROMs
-	for (const rom_source *source = rom_first_source(*m_current_config); source != NULL; source = rom_next_source(*source))
+	device_iterator deviter(m_current_config->root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
 	{
 		// for non-root devices, track the current device
-		m_current_device = (source == &m_current_config->root_device()) ? NULL : source;
+		m_current_device = (device->owner() == NULL) ? NULL : device;
 
 		// scan the ROM entries for this device
 		const char *last_region_name = "???";
@@ -628,7 +623,7 @@
 		int items_since_region = 1;
 		int last_bios = 0;
 		int total_files = 0;
-		for (const rom_entry *romp = rom_first_region(*source); !ROMENTRY_ISEND(romp); romp++)
+		for (const rom_entry *romp = rom_first_region(*device); romp != NULL && !ROMENTRY_ISEND(romp); romp++)
 		{
 			// if this is a region, make sure it's valid, and record the length
 			if (ROMENTRY_ISREGION(romp))
@@ -654,7 +649,7 @@
 
 				// generate the full tag
 				astring fulltag;
-				rom_region_name(fulltag, m_current_driver, source, romp);
+				rom_region_name(fulltag, *device, romp);
 
 				// attempt to add it to the map, reporting duplicates as errors
 				current_length = ROMREGION_GETLENGTH(romp);
@@ -705,22 +700,6 @@
 		if (items_since_region == 0)
 			mame_printf_warning("Empty ROM region '%s' (warning)\n", last_region_name);
 
-		// make sure each device is listed in the device list if it loads ROMs
-		if (m_current_device != NULL && total_files > 0)
-		{
-			// scan the list of devices for this device type
-			bool found = false;
-			for (int i = 0; i < m_device_count; i++)
-				if (m_current_device->type() == *s_devices_sorted[i])
-				{
-					found = true;
-					break;
-				}
-
-			// if not found, report an error
-			if (!found)
-				mame_printf_error("Device %s is not listed in device list (mame_dev.lst / mess_dev.lst)\n", m_current_device->shortname());
-		}
 
 		// reset the current device
 		m_current_device = NULL;
@@ -1115,7 +1094,7 @@
 
 		// if we have a ROM region, we must have a shortname
 		if (device->rom_region() != NULL && strcmp(device->shortname(), "") == 0)
-			mame_printf_error("Device %s has ROM definition but does not have short name defined\n", device->name());
+			mame_printf_error("Device has ROM definition but does not have short name defined\n");
 
 		// check for device-specific validity check
 		device->validity_check(*this);
@@ -1123,58 +1102,35 @@
 		// done with this device
 		m_current_device = NULL;
 	}
-}
-
 
-//-------------------------------------------------
-//  validate_slots - run per-slot validity
-//  checks
-//-------------------------------------------------
-
-void validity_checker::validate_slots()
-{
-	// iterate over slots
-	slot_interface_iterator iter(m_current_config->root_device());
-	for (const device_slot_interface *slot = iter.first(); slot != NULL; slot = iter.next())
+	// if device is slot cart device, we must have a shortname
+	int_map slot_device_map;
+	slot_interface_iterator slotiter(m_current_config->root_device());
+	for (const device_slot_interface *slot = slotiter.first(); slot != NULL; slot = slotiter.next())
 	{
-		// iterate over interfaces
-		const slot_interface *intf = slot->get_slot_interfaces();
-		for (int j = 0; intf && intf[j].name != NULL; j++)
+		const slot_interface* intf = slot->get_slot_interfaces();
+		for (int i = 0; intf && intf[i].name != NULL; i++)
 		{
-			// instantiate the device
-			device_t *dev = (*intf[j].devtype)(*m_current_config, "dummy", &m_current_config->root_device(), 0);
-			dev->config_complete();
-
-			// if a ROM region is present
-			if (dev->rom_region() != NULL)
-			{
-				bool has_romfiles = false;
-				for (const rom_entry *romp = rom_first_region(*dev); !ROMENTRY_ISEND(romp); romp++)
-					if (ROMENTRY_ISFILE(romp))
-					{
-						has_romfiles = true;
-						break;
-					}
-
-				if (has_romfiles)
-				{
-					// scan the list of devices for this device type
-					bool found = false;
-					for (int i = 0; i < m_device_count; i++)
-						if (dev->type() == *s_devices_sorted[i])
-						{
-							found = true;
-							break;
-						}
-
-					// if not found, report an error
-					if (!found)
-						mame_printf_error("Device %s in slot %s is not listed in device list (mame_dev.lst / mess_dev.lst)\n", dev->shortname(), intf[j].name);
-				}
+			astring temptag("_");
+			temptag.cat(intf[i].name);
+			device_t *dev = const_cast<machine_config &>(*m_current_config).device_add(&m_current_config->root_device(), temptag.cstr(), intf[i].devtype, 0);
+
+			// notify this device and all its subdevices that they are now configured
+			device_iterator subiter(*dev);
+			for (device_t *device = subiter.first(); device != NULL; device = subiter.next())
+				if (!device->configured())
+					device->config_complete();
+
+			if (strcmp(dev->shortname(), "") == 0) {
+				if (slot_device_map.add(dev->name(), 0, false) != TMERR_DUPLICATE)
+					mame_printf_error("Device '%s' is slot cart device but does not have short name defined\n",dev->name());
 			}
+
+			const_cast<machine_config &>(*m_current_config).device_remove(&m_current_config->root_device(), temptag.cstr());
 			global_free(dev);
 		}
 	}
+
 }
 
 
diff -Nru src-old/emu/validity.h src/emu/validity.h
--- src-old/emu/validity.h	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/validity.h	2012-02-23 15:19:37.000000000 +0100
@@ -97,7 +97,6 @@
 	void validate_condition(input_condition &condition, device_t &device, int_map &port_map);
 	void validate_inputs();
 	void validate_devices();
-	void validate_slots();
 
 	// output helpers
 	void build_output_prefix(astring &string);
diff -Nru src-old/ldplayer/ldplayer_dev.lst src/ldplayer/ldplayer_dev.lst
--- src-old/ldplayer/ldplayer_dev.lst	2012-02-02 16:14:43.000000000 +0100
+++ src/ldplayer/ldplayer_dev.lst	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/******************************************************************************
-
-    ldplayer_dev.lst
-
-    List of all enabled devices in the system. This file is parsed by
-    makedev.exe, sorted, and output as C code describing the devices.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-PIONEER_LDV1000
-PIONEER_PR8210
\ No newline at end of file
diff -Nru src-old/lib/util/avhuff.c src/lib/util/avhuff.c
--- src-old/lib/util/avhuff.c	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/avhuff.c	2012-02-20 08:26:05.000000000 +0100
@@ -318,7 +318,7 @@
 //  bits
 //-------------------------------------------------
 
-avhuff_error avhuff_encoder::assemble_data(UINT8 *dest, UINT32 dlength, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata, UINT32 metadatasize)
+avhuff_error avhuff_encoder::assemble_data(dynamic_buffer &buffer, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata, UINT32 metadatasize)
 {
 	// sanity check the inputs
 	if (metadatasize > 255)
@@ -327,10 +327,10 @@
 		return AVHERR_AUDIO_TOO_LARGE;
 	if (bitmap.width() > 65535 || bitmap.height() > 65535)
 		return AVHERR_VIDEO_TOO_LARGE;
-	if (dlength < 12 + metadatasize + numsamples * channels * 2 + bitmap.width() * bitmap.height() * 2)
-		return AVHERR_BUFFER_TOO_SMALL;
 
 	// fill in the header
+	buffer.resize(12 + metadatasize + numsamples * channels * 2 + bitmap.width() * bitmap.height() * 2);
+	UINT8 *dest = buffer;
 	*dest++ = 'c';
 	*dest++ = 'h';
 	*dest++ = 'a';
diff -Nru src-old/lib/util/avhuff.h src/lib/util/avhuff.h
--- src-old/lib/util/avhuff.h	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/avhuff.h	2012-02-20 08:26:05.000000000 +0100
@@ -119,7 +119,7 @@
 	// static helpers
 	static UINT32 raw_data_size(const UINT8 *data);
 	static UINT32 raw_data_size(UINT32 width, UINT32 height, UINT8 channels, UINT32 numsamples, UINT32 metadatasize = 0) { return 12 + channels * numsamples * 2 + width * height * 2; }
-	static avhuff_error assemble_data(UINT8 *dest, UINT32 dlength, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata = NULL, UINT32 metadatasize = 0);
+	static avhuff_error assemble_data(dynamic_buffer &buffer, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata = NULL, UINT32 metadatasize = 0);
 
 private:
 	// delta-RLE Huffman encoder
diff -Nru src-old/lib/util/cdrom.h src/lib/util/cdrom.h
--- src-old/lib/util/cdrom.h	2012-02-16 10:47:18.000000000 +0100
+++ src/lib/util/cdrom.h	2012-02-26 08:18:28.000000000 +0100
@@ -59,7 +59,7 @@
 #define CD_MAX_SUBCODE_DATA		(96)
 
 #define CD_FRAME_SIZE			(CD_MAX_SECTOR_DATA + CD_MAX_SUBCODE_DATA)
-#define CD_FRAMES_PER_HUNK		(4) // should be 8 for v5 CDs, with a 4-frame pad at the end to maintain SHA1 compatibility
+#define CD_FRAMES_PER_HUNK		(8)
 
 #define CD_METADATA_WORDS		(1+(CD_MAX_TRACKS * 6))
 
diff -Nru src-old/lib/util/chd.c src/lib/util/chd.c
--- src-old/lib/util/chd.c	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/chd.c	2012-02-20 15:51:09.000000000 +0100
@@ -295,7 +295,8 @@
 //-------------------------------------------------
 
 chd_file::chd_file()
-	: m_file(NULL)
+	: m_file(NULL),
+      m_owns_file(false)
 {
 	// reset state
 	memset(m_decompressor, 0, sizeof(m_decompressor));
diff -Nru src-old/lib/util/chdcd.c src/lib/util/chdcd.c
--- src-old/lib/util/chdcd.c	2012-02-16 10:47:18.000000000 +0100
+++ src/lib/util/chdcd.c	2012-02-19 18:22:07.000000000 +0100
@@ -140,7 +140,7 @@
     length in bytes of the data and the offset in
     bytes to where the data starts in the file.
 -------------------------------------------------*/
-static UINT32 parse_wav_sample(char *filename, UINT32 *dataoffs)
+static UINT32 parse_wav_sample(const char *filename, UINT32 *dataoffs)
 {
 	unsigned long offset = 0;
 	UINT32 length, rate, filesize;
@@ -388,7 +388,7 @@
 				index2 = read_uint64(infile);
 
 //              printf("Track %d: sector size %d mode %x index0 %llx index1 %llx index2 %llx (pregap %d sectors, length %d sectors)\n", track, size, mode, index0, index1, index2, (UINT32)(index1-index0)/size, (UINT32)(index2-index1)/size);
-				outinfo.track[track-1].fname.cpy(path.cstr()).cat(tocfname);
+				outinfo.track[track-1].fname.cpy(path).cat(tocfname);
 				outinfo.track[track-1].offset = offset + (UINT32)(index1-index0);
 				outinfo.track[track-1].idx0offs = 0;
 				outinfo.track[track-1].idx1offs = 0;
@@ -538,7 +538,7 @@
 			} while(tok!=NULL && (strrchr(tok,'"')-tok !=(strlen(tok)-1)));
 			name = name.delchr('"');
 		}
-		outinfo.track[trknum].fname.cpy(path.cstr()).cat(name);
+		outinfo.track[trknum].fname.cpy(path).cat(name);
 
 		sz=get_file_size(outinfo.track[trknum].fname);
 
@@ -587,7 +587,7 @@
 	FILE *infile;
 	int i, trknum;
 	static char token[512];
-	static char lastfname[256];
+	astring lastfname;
 	UINT32 wavlen, wavoffs;
 	astring path = astring(tocfname);
 
@@ -623,8 +623,7 @@
 				TOKENIZE
 
 				/* keep the filename */
-				strncpy(lastfname, path.cstr(), 256);
-				strncat(lastfname, token, 256);
+				lastfname.cpy(path).cat(token);
 
 				/* get the file type */
 				TOKENIZE
@@ -649,7 +648,7 @@
 						if (err != FILERR_NONE) printf("holy moley!\n");
 						else core_fclose(fhand);
 
-						printf("ERROR: couldn't read [%s] or not a valid .WAV\n", lastfname);
+						printf("ERROR: couldn't read [%s] or not a valid .WAV\n", lastfname.cstr());
 						return CHDERR_FILE_NOT_FOUND;
 					}
 				}
@@ -688,6 +687,7 @@
 				outinfo.track[trknum].idx1offs = 0;
 
 				outinfo.track[trknum].fname.cpy(lastfname); // default filename to the last one
+
 //              printf("trk %d: fname %s offset %d\n", trknum, outinfo.track[trknum].fname.cstr(), outinfo.track[trknum].offset);
 
 				cdrom_convert_type_string_to_track_info(token, &outtoc.tracks[trknum]);
@@ -774,9 +774,9 @@
 			if (trknum == (outtoc.numtrks-1))
 			{
 				/* if we have the same filename as the last track, do it that way */
-				if (outinfo.track[trknum].fname == outinfo.track[trknum-1].fname)
+				if (trknum != 0 && outinfo.track[trknum].fname == outinfo.track[trknum-1].fname)
 				{
-					tlen = get_file_size(outinfo.track[trknum].fname);
+					tlen = get_file_size(outinfo.track[trknum].fname.cstr());
 					if (tlen == 0)
 					{
 						printf("ERROR: couldn't find bin file [%s]\n", outinfo.track[trknum-1].fname.cstr());
@@ -908,7 +908,7 @@
 				TOKENIZE
 
 				/* keep the filename */
-				outinfo.track[trknum].fname.cpy(path.cstr()).cat(token);
+				outinfo.track[trknum].fname.cpy(path).cat(token);
 
 				/* get either the offset or the length */
 				TOKENIZE
diff -Nru src-old/lib/util/chdcodec.c src/lib/util/chdcodec.c
--- src-old/lib/util/chdcodec.c	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/chdcodec.c	2012-02-26 15:31:24.000000000 +0100
@@ -225,35 +225,20 @@
 {
 public:
 	// construction/destruction
-	chd_flac_compressor(chd_file &chd, bool lossy, bool bigendian);
+	chd_flac_compressor(chd_file &chd, bool lossy);
 
 	// core functionality
 	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
 
+	// static helpers
+	static UINT32 blocksize(UINT32 bytes);
+
 private:
 	// internal state
-	bool			m_swap_endian;
+	bool			m_big_endian;
 	flac_encoder	m_encoder;
 };
 
-// big-endian variant
-class chd_flac_compressor_be : public chd_flac_compressor
-{
-public:
-	// construction/destruction
-	chd_flac_compressor_be(chd_file &chd, bool lossy)
-		: chd_flac_compressor(chd, lossy, true) { }
-};
-
-// little-endian variant
-class chd_flac_compressor_le : public chd_flac_compressor
-{
-public:
-	// construction/destruction
-	chd_flac_compressor_le(chd_file &chd, bool lossy)
-		: chd_flac_compressor(chd, lossy, false) { }
-};
-
 
 // ======================> chd_flac_decompressor
 
@@ -262,35 +247,17 @@
 {
 public:
 	// construction/destruction
-	chd_flac_decompressor(chd_file &chd, bool lossy, bool bigendian);
+	chd_flac_decompressor(chd_file &chd, bool lossy);
 
 	// core functionality
 	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
 
 private:
 	// internal state
-	bool			m_swap_endian;
+	bool			m_big_endian;
 	flac_decoder	m_decoder;
 };
 
-// big-endian variant
-class chd_flac_decompressor_be : public chd_flac_decompressor
-{
-public:
-	// construction/destruction
-	chd_flac_decompressor_be(chd_file &chd, bool lossy)
-		: chd_flac_decompressor(chd, lossy, true) { }
-};
-
-// little-endian variant
-class chd_flac_decompressor_le : public chd_flac_decompressor
-{
-public:
-	// construction/destruction
-	chd_flac_decompressor_le(chd_file &chd, bool lossy)
-		: chd_flac_decompressor(chd, lossy, false) { }
-};
-
 
 // ======================> chd_cd_flac_compressor
 
@@ -305,6 +272,9 @@
 	// core functionality
 	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
 
+	// static helpers
+	static UINT32 blocksize(UINT32 bytes);
+
 private:
 	// internal state
 	bool				m_swap_endian;
@@ -390,8 +360,7 @@
 	{ CHD_CODEC_ZLIB,		false,	"Deflate",				&chd_codec_list::construct_compressor<chd_zlib_compressor>,		&chd_codec_list::construct_decompressor<chd_zlib_decompressor> },
 	{ CHD_CODEC_LZMA,		false,	"LZMA",					&chd_codec_list::construct_compressor<chd_lzma_compressor>,		&chd_codec_list::construct_decompressor<chd_lzma_decompressor> },
 	{ CHD_CODEC_HUFFMAN,	false,	"Huffman",				&chd_codec_list::construct_compressor<chd_huffman_compressor>,	&chd_codec_list::construct_decompressor<chd_huffman_decompressor> },
-	{ CHD_CODEC_FLAC_BE,	false,	"FLAC, big-endian",		&chd_codec_list::construct_compressor<chd_flac_compressor_be>,	&chd_codec_list::construct_decompressor<chd_flac_decompressor_be> },
-	{ CHD_CODEC_FLAC_LE,	false,	"FLAC, little-endian",	&chd_codec_list::construct_compressor<chd_flac_compressor_le>,	&chd_codec_list::construct_decompressor<chd_flac_decompressor_le> },
+	{ CHD_CODEC_FLAC,		false,	"FLAC",					&chd_codec_list::construct_compressor<chd_flac_compressor>,		&chd_codec_list::construct_decompressor<chd_flac_decompressor> },
 	{ CHD_CODEC_CD_FLAC,	false,	"CD FLAC",				&chd_codec_list::construct_compressor<chd_cd_flac_compressor>,	&chd_codec_list::construct_decompressor<chd_cd_flac_decompressor> },
 	{ CHD_CODEC_AVHUFF,		false,	"A/V Huffman",			&chd_codec_list::construct_compressor<chd_avhuff_compressor>,	&chd_codec_list::construct_decompressor<chd_avhuff_decompressor> },
 };
@@ -1157,21 +1126,18 @@
 //  chd_flac_compressor - constructor
 //-------------------------------------------------
 
-chd_flac_compressor::chd_flac_compressor(chd_file &chd, bool lossy, bool bigendian)
+chd_flac_compressor::chd_flac_compressor(chd_file &chd, bool lossy)
 	: chd_compressor(chd, lossy)
 {
 	// determine whether we want native or swapped samples
 	UINT16 native_endian = 0;
 	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
-	if (native_endian == 1)
-		m_swap_endian = bigendian;
-	else
-		m_swap_endian = !bigendian;
+	m_big_endian = (native_endian == 0x100);
 
 	// configure the encoder
 	m_encoder.set_sample_rate(44100);
 	m_encoder.set_num_channels(2);
-	m_encoder.set_block_size(chd.hunk_bytes() / 4);
+	m_encoder.set_block_size(blocksize(chd.hunk_bytes()));
 	m_encoder.set_strip_metadata(true);
 }
 
@@ -1182,16 +1148,49 @@
 
 UINT32 chd_flac_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
 {
-	// reset and encode
-	m_encoder.reset(dest, chd().hunk_bytes());
-	if (!m_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(src), srclen / 4, m_swap_endian))
+	// reset and encode big-endian
+	m_encoder.reset(dest + 1, chd().hunk_bytes() - 1);
+	if (!m_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(src), srclen / 4, !m_big_endian))
 		throw CHDERR_COMPRESSION_ERROR;
+	UINT32 complen_be = m_encoder.finish();
 
-	// finish up
-	UINT32 complen = m_encoder.finish();
-	if (complen >= chd().hunk_bytes())
+	// reset and encode little-endian
+	m_encoder.reset(dest + 1, chd().hunk_bytes() - 1);
+	if (!m_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(src), srclen / 4, m_big_endian))
 		throw CHDERR_COMPRESSION_ERROR;
-	return complen;
+	UINT32 complen_le = m_encoder.finish();
+
+	// pick the best one and add a byte
+	UINT32 complen = MIN(complen_le, complen_be);
+	if (complen + 1 >= chd().hunk_bytes())
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// if big-endian was better, re-do it
+	dest[0] = 'L';
+	if (complen != complen_le)
+	{
+		dest[0] = 'B';
+		m_encoder.reset(dest + 1, chd().hunk_bytes() - 1);
+		if (!m_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(src), srclen / 4, !m_big_endian))
+			throw CHDERR_COMPRESSION_ERROR;
+		m_encoder.finish();
+	}
+	return complen + 1;
+}
+
+
+//-------------------------------------------------
+//  blocksize - return the optimal block size
+//-------------------------------------------------
+
+UINT32 chd_flac_compressor::blocksize(UINT32 bytes)
+{
+	// determine FLAC block size, which must be 16-65535
+	// clamp to 2k since that's supposed to be the sweet spot
+	UINT32 blocksize = bytes / 4;
+	while (blocksize > 2048)
+		blocksize /= 2;
+	return blocksize;
 }
 
 
@@ -1204,16 +1203,13 @@
 //  chd_flac_decompressor - constructor
 //-------------------------------------------------
 
-chd_flac_decompressor::chd_flac_decompressor(chd_file &chd, bool lossy, bool bigendian)
+chd_flac_decompressor::chd_flac_decompressor(chd_file &chd, bool lossy)
 	: chd_decompressor(chd, lossy)
 {
 	// determine whether we want native or swapped samples
 	UINT16 native_endian = 0;
 	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
-	if (native_endian == 1)
-		m_swap_endian = bigendian;
-	else
-		m_swap_endian = !bigendian;
+	m_big_endian = (native_endian == 0x100);
 }
 
 
@@ -1224,10 +1220,19 @@
 
 void chd_flac_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
 {
+	// determine the endianness
+	bool swap_endian;
+	if (src[0] == 'L')
+		swap_endian = m_big_endian;
+	else if (src[0] == 'B')
+		swap_endian = !m_big_endian;
+	else
+		throw CHDERR_DECOMPRESSION_ERROR;
+
 	// reset and decode
-	if (!m_decoder.reset(44100, 2, chd().hunk_bytes() / 4, src, complen))
+	if (!m_decoder.reset(44100, 2, chd_flac_compressor::blocksize(destlen), src + 1, complen - 1))
 		throw CHDERR_DECOMPRESSION_ERROR;
-	if (!m_decoder.decode_interleaved(reinterpret_cast<INT16 *>(dest), destlen / 4, m_swap_endian))
+	if (!m_decoder.decode_interleaved(reinterpret_cast<INT16 *>(dest), destlen / 4, swap_endian))
 		throw CHDERR_DECOMPRESSION_ERROR;
 
 	// finish up
@@ -1260,7 +1265,7 @@
 	// configure the encoder
 	m_encoder.set_sample_rate(44100);
 	m_encoder.set_num_channels(2);
-	m_encoder.set_block_size((chd.hunk_bytes() / CD_FRAME_SIZE) * (CD_MAX_SECTOR_DATA/4));
+	m_encoder.set_block_size(blocksize((chd.hunk_bytes() / CD_FRAME_SIZE) * CD_MAX_SECTOR_DATA));
 	m_encoder.set_strip_metadata(true);
 
 	// initialize the deflater
@@ -1333,6 +1338,20 @@
 }
 
 
+//-------------------------------------------------
+//  blocksize - return the optimal block size
+//-------------------------------------------------
+
+UINT32 chd_cd_flac_compressor::blocksize(UINT32 bytes)
+{
+	// for CDs it seems that CD_MAX_SECTOR_DATA is the right target
+	UINT32 blocksize = bytes / 4;
+	while (blocksize > CD_MAX_SECTOR_DATA)
+		blocksize /= 2;
+	return blocksize;
+}
+
+
 
 //**************************************************************************
 //  CD FLAC DECOMPRESSOR
@@ -1387,8 +1406,8 @@
 void chd_cd_flac_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
 {
 	// reset and decode
-	UINT32 frames = chd().hunk_bytes() / CD_FRAME_SIZE;
-	if (!m_decoder.reset(44100, 2, frames * CD_MAX_SECTOR_DATA/4, src, complen))
+	UINT32 frames = destlen / CD_FRAME_SIZE;
+	if (!m_decoder.reset(44100, 2, chd_cd_flac_compressor::blocksize(frames * CD_MAX_SECTOR_DATA), src, complen))
 		throw CHDERR_DECOMPRESSION_ERROR;
 	UINT8 *buffer = m_buffer;
 	if (!m_decoder.decode_interleaved(reinterpret_cast<INT16 *>(buffer), frames * CD_MAX_SECTOR_DATA/4, m_swap_endian))
diff -Nru src-old/lib/util/chdcodec.h src/lib/util/chdcodec.h
--- src-old/lib/util/chdcodec.h	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/chdcodec.h	2012-02-26 08:18:28.000000000 +0100
@@ -198,8 +198,7 @@
 const chd_codec_type CHD_CODEC_ZLIB 	= CHD_MAKE_TAG('z','l','i','b');
 const chd_codec_type CHD_CODEC_LZMA 	= CHD_MAKE_TAG('l','z','m','a');
 const chd_codec_type CHD_CODEC_HUFFMAN	= CHD_MAKE_TAG('h','u','f','f');
-const chd_codec_type CHD_CODEC_FLAC_BE	= CHD_MAKE_TAG('f','l','c','b');
-const chd_codec_type CHD_CODEC_FLAC_LE	= CHD_MAKE_TAG('f','l','c','l');
+const chd_codec_type CHD_CODEC_FLAC		= CHD_MAKE_TAG('f','l','a','c');
 const chd_codec_type CHD_CODEC_CD_FLAC	= CHD_MAKE_TAG('c','d','f','l');
 const chd_codec_type CHD_CODEC_AVHUFF	= CHD_MAKE_TAG('a','v','h','u');
 
diff -Nru src-old/lib/util/hashing.c src/lib/util/hashing.c
--- src-old/lib/util/hashing.c	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/hashing.c	2012-02-21 07:29:54.000000000 +0100
@@ -85,6 +85,7 @@
 bool sha1_t::from_string(const char *string, int length)
 {
 	// must be at least long enough to hold everything
+	memset(m_raw, 0, sizeof(m_raw));
 	if (length == -1)
 		length = strlen(string);
 	if (length < 2 * sizeof(m_raw))
@@ -127,6 +128,7 @@
 bool md5_t::from_string(const char *string, int length)
 {
 	// must be at least long enough to hold everything
+	memset(m_raw, 0, sizeof(m_raw));
 	if (length == -1)
 		length = strlen(string);
 	if (length < 2 * sizeof(m_raw))
@@ -170,6 +172,7 @@
 bool crc32_t::from_string(const char *string, int length)
 {
 	// must be at least long enough to hold everything
+	m_raw = 0;
 	if (length == -1)
 		length = strlen(string);
 	if (length < 2 * sizeof(m_raw))
@@ -221,6 +224,7 @@
 bool crc16_t::from_string(const char *string, int length)
 {
 	// must be at least long enough to hold everything
+	m_raw = 0;
 	if (length == -1)
 		length = strlen(string);
 	if (length < 2 * sizeof(m_raw))
diff -Nru src-old/mame/drivers/20pacgal.c src/mame/drivers/20pacgal.c
--- src-old/mame/drivers/20pacgal.c	2011-12-06 03:34:43.000000000 +0100
+++ src/mame/drivers/20pacgal.c	2012-02-26 00:51:59.000000000 +0100
@@ -294,29 +294,21 @@
 INPUT_PORTS_END
 
 
+/* Note: 25pacman Control Panel functions the same as 20pacgal, even if Right P1/P2 start are not shown during Switch Test */
 static INPUT_PORTS_START( 25pacman )
 	PORT_INCLUDE(20pacgal)
 
-	PORT_MODIFY("P2")
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
-
 	PORT_MODIFY("SERVICE")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-	PORT_SERVICE_NO_TOGGLE( 0x80, IP_ACTIVE_LOW )
 INPUT_PORTS_END
 
 
 
-
 /*************************************
  *
  *  Machine driver
diff -Nru src-old/mame/drivers/8080bw.c src/mame/drivers/8080bw.c
--- src-old/mame/drivers/8080bw.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/8080bw.c	2012-02-22 00:51:07.000000000 +0100
@@ -2548,8 +2548,8 @@
 	ROM_LOAD( "sv06.41",     0x1c00, 0x0400, CRC(2c68e0b4) SHA1(a5e5357120102ad32792bf3ef6362f45b7ba7070) )
 
 	ROM_REGION( 0x0800, "proms", 0 )		/* color maps player 1/player 2 */
-	ROM_LOAD( "sv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
-	ROM_LOAD( "sv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
+	ROM_LOAD( "cv01(__sisv).1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
+	ROM_LOAD( "cv02(__sisv).2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
 ROM_END
 
 ROM_START( sisv2 )
@@ -2562,8 +2562,8 @@
 	ROM_LOAD( "sv14.41",     0x1c00, 0x0400, CRC(58730370) SHA1(13dc806bcecd2d6089a85dd710ac2869413f7475) )
 
 	ROM_REGION( 0x0800, "proms", 0 )		/* color maps player 1/player 2 */
-	ROM_LOAD( "sv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
-	ROM_LOAD( "sv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
+	ROM_LOAD( "cv01(__sisv).1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
+	ROM_LOAD( "cv02(__sisv).2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
 ROM_END
 
 ROM_START( spceking )
@@ -3377,7 +3377,7 @@
 
 ROM_START( galactic )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1_gal",   0x0000, 0x0800, CRC(b5098f1e) SHA1(9d1d045d8abeafd4716d3052fe93e52c6b347049) )
+	ROM_LOAD( "1(__galactic)",   0x0000, 0x0800, CRC(b5098f1e) SHA1(9d1d045d8abeafd4716d3052fe93e52c6b347049) )
 	ROM_LOAD( "2",       0x0800, 0x0800, CRC(f97410ee) SHA1(47f1f296c905fa13f6c521edc12c10f1f0e42400) )
 	ROM_LOAD( "3",       0x1000, 0x0800, CRC(c1175feb) SHA1(83bf955ed3a52e1ce8c688d89725d8dee1bcc866) )
 	ROM_LOAD( "4",       0x1800, 0x0800, CRC(b4451d7c) SHA1(62a18e8e927ef00a7f6cb933cdc5aeae9f074dc0) )
@@ -3388,7 +3388,7 @@
 
 ROM_START( spacmiss )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1_sm",    0x0000, 0x0800, CRC(e212dc88) SHA1(bc56052bf43d18081f777b936b2be792e91ba842) )
+	ROM_LOAD( "1_(__spacmiss)",    0x0000, 0x0800, CRC(e212dc88) SHA1(bc56052bf43d18081f777b936b2be792e91ba842) )
 	ROM_LOAD( "2",       0x0800, 0x0800, CRC(f97410ee) SHA1(47f1f296c905fa13f6c521edc12c10f1f0e42400) )
 	ROM_LOAD( "3",       0x1000, 0x0800, CRC(c1175feb) SHA1(83bf955ed3a52e1ce8c688d89725d8dee1bcc866) )
 	ROM_LOAD( "4",       0x1800, 0x0800, CRC(b4451d7c) SHA1(62a18e8e927ef00a7f6cb933cdc5aeae9f074dc0) )
diff -Nru src-old/mame/drivers/adp.c src/mame/drivers/adp.c
--- src-old/mame/drivers/adp.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/adp.c	2012-02-26 15:31:24.000000000 +0100
@@ -157,11 +157,14 @@
 public:
 	adp_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		  m_h63484(*this, "h63484")
+		  m_h63484(*this, "h63484"),
+		  m_microtouch(*this, "microtouch")
 		{ }
 
 	required_device<h63484_device> m_h63484;
+	required_device<microtouch_device> m_microtouch;
 
+	DECLARE_WRITE8_MEMBER(microtouch_tx);
 	UINT32 screen_update(screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect);
 
 	/* misc */
@@ -262,20 +265,20 @@
 {
 	adp_state *state = device->machine().driver_data<adp_state>();
 	device_set_input_line_and_vector(state->m_maincpu, 4, HOLD_LINE, vector);
-};
+}
 
 static void duart_tx( device_t *device, int channel, UINT8 data )
 {
+	adp_state *state = device->machine().driver_data<adp_state>();
 	if (channel == 0)
 	{
-		microtouch_rx(1, &data);
+		state->m_microtouch->rx(*memory_nonspecific_space(device->machine()), 0, data);
 	}
-};
+}
 
-static void microtouch_tx( running_machine &machine, UINT8 data )
+WRITE8_MEMBER( adp_state::microtouch_tx )
 {
-	adp_state *state = machine.driver_data<adp_state>();
-	duart68681_rx_data(state->m_duart, 0, data);
+	duart68681_rx_data(m_duart, 0, data);
 }
 
 static UINT8 duart_input( device_t *device )
@@ -283,10 +286,15 @@
 	return input_port_read(device->machine(), "DSW1");
 }
 
+static const microtouch_interface adb_microtouch_config =
+{
+	DEVCB_DRIVER_MEMBER(adp_state, microtouch_tx),
+	NULL
+};
+
 static MACHINE_START( skattv )
 {
 	adp_state *state = machine.driver_data<adp_state>();
-	microtouch_init(machine, microtouch_tx, 0);
 
 	state->m_maincpu = machine.device("maincpu");
 	state->m_duart = machine.device("duart68681");
@@ -530,8 +538,6 @@
 #endif
 
 static INPUT_PORTS_START( skattv )
-	PORT_INCLUDE(microtouch)
-
 	PORT_START("DSW1")
 	PORT_BIT( 0x0001, IP_ACTIVE_HIGH,  IPT_COIN5    )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW,  IPT_COIN6    )
@@ -661,6 +667,7 @@
 	MCFG_MACHINE_RESET(skattv)
 
 	MCFG_DUART68681_ADD( "duart68681", XTAL_8_664MHz / 2, skattv_duart68681_config )
+	MCFG_MICROTOUCH_ADD( "microtouch", adb_microtouch_config )
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -692,6 +699,7 @@
 	MCFG_MACHINE_RESET(skattv)
 
 	MCFG_DUART68681_ADD( "duart68681", XTAL_8_664MHz / 2, skattv_duart68681_config )
+	MCFG_MICROTOUCH_ADD( "microtouch", adb_microtouch_config )
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -719,6 +727,7 @@
 	MCFG_CPU_PROGRAM_MAP(backgamn_mem)
 
 	MCFG_DUART68681_ADD( "duart68681", XTAL_8_664MHz / 2, skattv_duart68681_config )
+	MCFG_MICROTOUCH_ADD( "microtouch", adb_microtouch_config )
 
 	MCFG_MACHINE_START(skattv)
 	MCFG_MACHINE_RESET(skattv)
diff -Nru src-old/mame/drivers/astrocorp.c src/mame/drivers/astrocorp.c
--- src-old/mame/drivers/astrocorp.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/astrocorp.c	2012-02-22 00:51:07.000000000 +0100
@@ -907,15 +907,15 @@
 
 ROM_START( winbingoa )
 	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "f29c51001t_alt.u31", 0x00000, 0x20000, CRC(c33676c3) SHA1(9f5b7d05d187cf59948a572f80c55cb8fa1f656f) )
-	ROM_LOAD16_BYTE( "f29c51001t_alt.u25", 0x00001, 0x20000, CRC(43c7b2d8) SHA1(16ee79c34b7c485dfccecdf3e0ae9f18f8a20150) )
+	ROM_LOAD16_BYTE( "f29c51001t(__alt).u31", 0x00000, 0x20000, CRC(c33676c3) SHA1(9f5b7d05d187cf59948a572f80c55cb8fa1f656f) )
+	ROM_LOAD16_BYTE( "f29c51001t(__alt).u25", 0x00001, 0x20000, CRC(43c7b2d8) SHA1(16ee79c34b7c485dfccecdf3e0ae9f18f8a20150) )
 
 	ROM_REGION( 0x400000, "sprites", 0 )
 	ROM_LOAD( "mx29f1610mc.u26", 0x000000, 0x200000, CRC(ad1f61e7) SHA1(845aa01d49c50bcadaed16d76c0dd9131a425b46) )
 	ROM_LOAD( "mx29f1610mc.u30", 0x200000, 0x200000, CRC(31613d99) SHA1(1c720f8d981c3e9cb9d9b3b27eb95e7f72ccfc93) )
 
 	ROM_REGION( 0x80000, "oki", 0 )
-	ROM_LOAD( "mx27c4000pc_alt.u35", 0x00000, 0x80000, CRC(e48ed57d) SHA1(11995b90e70e010b292ba9db2da0af4ebf795c1a) )
+	ROM_LOAD( "mx27c4000pc(__alt).u35", 0x00000, 0x80000, CRC(e48ed57d) SHA1(11995b90e70e010b292ba9db2da0af4ebf795c1a) )
 ROM_END
 
 /***************************************************************************
diff -Nru src-old/mame/drivers/balsente.c src/mame/drivers/balsente.c
--- src-old/mame/drivers/balsente.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/balsente.c	2012-02-22 00:51:07.000000000 +0100
@@ -1830,7 +1830,7 @@
 	ROM_LOAD( "cd01.u4a",  0x20000, 0x4000, CRC(75e9b51a) SHA1(dbe575d37836245746ea85ffe85e8e6665ec37ea) )
 	ROM_LOAD( "cd23.u3a",  0x24000, 0x4000, CRC(0a32e0a5) SHA1(dedbe08aed483bae27e1a607334e24cdfcb2f851) )
 	ROM_LOAD( "cd45.u2a",  0x28000, 0x4000, CRC(9bb292fe) SHA1(6fc7abcc110c2cf7399d11a478cfdadb3439b6ab) )
-	ROM_LOAD( "ns2_cd6ef.u1a", 0x2c000, 0x4000, CRC(c77d2302) SHA1(2b0956a7d6bdff5e4f77084149a9528fb07154dc) )
+	ROM_LOAD( "cd6ef(__nstocker2).u1a", 0x2c000, 0x4000, CRC(c77d2302) SHA1(2b0956a7d6bdff5e4f77084149a9528fb07154dc) )
 
 	SOUNDBOARD_ROMS
 
@@ -1897,16 +1897,16 @@
 
 ROM_START( spiker2 ) /* Spiker U.R. 5/5/86 */
 	ROM_REGION( 0x40000, "maincpu", 0 )     /* 64k for code for the first CPU, plus 128k of banked ROMs */
-	ROM_LOAD( "ab01_050586.u8a",  0x10000, 0x4000, CRC(59025e39) SHA1(f0e3e45bb32cc6664831c4ef6b0cfabf3fc71f58) )
-	ROM_LOAD( "ab23_050586.u7a",  0x14000, 0x4000, CRC(ffb23288) SHA1(3458e486794f6c936d15e837be0f419027b01311) )
-	ROM_LOAD( "cd6ef_050586.u1a", 0x2c000, 0x4000, CRC(7f04774d) SHA1(c49ac3aa86425cdbab9877fc253999329bb99a49) )
+	ROM_LOAD( "ab01(__050586).u8a",  0x10000, 0x4000, CRC(59025e39) SHA1(f0e3e45bb32cc6664831c4ef6b0cfabf3fc71f58) )
+	ROM_LOAD( "ab23(__050586).u7a",  0x14000, 0x4000, CRC(ffb23288) SHA1(3458e486794f6c936d15e837be0f419027b01311) )
+	ROM_LOAD( "cd6ef(__050586).u1a", 0x2c000, 0x4000, CRC(7f04774d) SHA1(c49ac3aa86425cdbab9877fc253999329bb99a49) )
 
 	SOUNDBOARD_ROMS
 
 	ROM_REGION( 0x10000, "gfx1", 0 )		/* up to 64k of sprites */
-	ROM_LOAD( "gr01_050586.u4c", 0x00000, 0x4000, CRC(1228b7a3) SHA1(70a207714ba7bc4f4dbc492768480afa424b31c0) )
-	ROM_LOAD( "gr23.u3c",        0x04000, 0x4000, CRC(970c81f6) SHA1(f22189e172a795d115597feb48ccbc04be3859b9) )
-	ROM_LOAD( "gr45_050586.u2c", 0x08000, 0x4000, CRC(bf2b413d) SHA1(f0f797853ac1b6e45ff606d7aa5c9350765efd48) )
+	ROM_LOAD( "gr01(__050586).u4c", 0x00000, 0x4000, CRC(1228b7a3) SHA1(70a207714ba7bc4f4dbc492768480afa424b31c0) )
+	ROM_LOAD( "gr23.u3c",           0x04000, 0x4000, CRC(970c81f6) SHA1(f22189e172a795d115597feb48ccbc04be3859b9) )
+	ROM_LOAD( "gr45(__050586).u2c", 0x08000, 0x4000, CRC(bf2b413d) SHA1(f0f797853ac1b6e45ff606d7aa5c9350765efd48) )
 
 	ROM_REGION( 0x00001, "cart_pals", 0) /* PAL's located on the cartridge */
 	ROM_LOAD( "pal16r8.u7c", 0x0000, 0x0001, NO_DUMP ) /* PAL16R8ANC */
@@ -1919,7 +1919,7 @@
 	ROM_REGION( 0x40000, "maincpu", 0 )     /* 64k for code for the first CPU, plus 128k of banked ROMs */
 	ROM_LOAD( "ab01.u8a",  0x10000, 0x4000, CRC(2d53d023) SHA1(01c1d2cd7d8be60c40527e9c1571b84388a39bd8) )
 	ROM_LOAD( "ab23.u7a",  0x14000, 0x4000, CRC(3be87edf) SHA1(0d4f1ff501d5d865abc3906f6b232ec04586d3dc) )
-	ROM_LOAD( "cd6ef_060686.u1a", 0x2c000, 0x4000, CRC(5b5a6d86) SHA1(a173637991601adc87f0fc8fd1ee9102f5fb2b81) )
+	ROM_LOAD( "cd6ef(__060686).u1a", 0x2c000, 0x4000, CRC(5b5a6d86) SHA1(a173637991601adc87f0fc8fd1ee9102f5fb2b81) )
 
 	SOUNDBOARD_ROMS
 
diff -Nru src-old/mame/drivers/bfm_sc2.c src/mame/drivers/bfm_sc2.c
--- src-old/mame/drivers/bfm_sc2.c	2012-02-19 02:23:50.000000000 +0100
+++ src/mame/drivers/bfm_sc2.c	2012-02-22 00:51:07.000000000 +0100
@@ -5121,7 +5121,7 @@
 
 ROM_START( sc2scshxstar )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "scxsp10_star.bin", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
+	ROM_LOAD( "scxsp10(__star).bin", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
 	ROM_REGION( 0x200000, "altrevs", ROMREGION_ERASE00 )
 	ROM_LOAD( "cxspv1gr", 0x0000, 0x010000, CRC(67f69bd4) SHA1(ee2dd0cd98c98a4727df8c7c721de9ac49b583ff) )
 	ROM_LOAD( "cxspv2gr", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
diff -Nru src-old/mame/drivers/by17.c src/mame/drivers/by17.c
--- src-old/mame/drivers/by17.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/by17.c	2012-02-22 00:51:07.000000000 +0100
@@ -128,7 +128,7 @@
 ROM_START(nightr20)
 	ROM_REGION(0x10000, "maincpu", 0)
 	ROM_LOAD( "721-21_1.716", 0x1000, 0x0800, CRC(237c4060) SHA1(4ce3dba9189fe7666fc76a2c8ee7fff9b12d4c00))
-	ROM_LOAD( "rev20_720-20_6.716", 0x1800, 0x0800, CRC(0c17aa4d) SHA1(729e61a29691857112579efcdb96a35e8e5b1279))
+	ROM_LOAD( "720-20_6(__rev20).716", 0x1800, 0x0800, CRC(0c17aa4d) SHA1(729e61a29691857112579efcdb96a35e8e5b1279))
 	ROM_RELOAD( 0xf800, 0x0800)
 ROM_END
 
diff -Nru src-old/mame/drivers/cd32.c src/mame/drivers/cd32.c
--- src-old/mame/drivers/cd32.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/cd32.c	2012-02-19 17:46:00.000000000 +0100
@@ -35,7 +35,6 @@
 #include "includes/cd32.h"
 #include "sound/cdda.h"
 #include "imagedev/chd_cd.h"
-#include "machine/microtch.h"
 #include "machine/amigafdc.h"
 
 #define CD32PAL_XTAL_X1   XTAL_28_37516MHz
@@ -760,6 +759,12 @@
 	I2CMEM_SLAVE_ADDRESS, NVRAM_PAGE_SIZE, NVRAM_SIZE
 };
 
+static const microtouch_interface cd32_microtouch_config =
+{
+	DEVCB_DRIVER_MEMBER(cd32_state, microtouch_tx),
+	NULL
+};
+
 static MACHINE_CONFIG_START( cd32base, cd32_state )
 
 	/* basic machine hardware */
@@ -800,6 +805,8 @@
 	MCFG_MOS8520_ADD("cia_0", AMIGA_68EC020_PAL_CLOCK / 10, cia_0_intf)
 	MCFG_MOS8520_ADD("cia_1", AMIGA_68EC020_PAL_CLOCK / 10, cia_1_intf)
 
+	MCFG_MICROTOUCH_ADD( "microtouch", cd32_microtouch_config )
+
 	/* fdc */
 	MCFG_AMIGA_FDC_ADD("fdc", AMIGA_68000_NTSC_CLOCK)
 MACHINE_CONFIG_END
@@ -1375,8 +1382,6 @@
 
 static INPUT_PORTS_START( odeontw2 )
 //  PORT_INCLUDE( cd32 )
-	PORT_INCLUDE( microtouch )
-
 	PORT_START("CIA0PORTA")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
@@ -1440,14 +1445,15 @@
 
 static void serial_w(running_machine &machine, UINT16 data)
 {
+	cd32_state *state = machine.driver_data<cd32_state>();
 	UINT8 data8 = data & 0xff;
 	if ( data8 != 0x00 )
-		microtouch_rx(1, &data8);
+		state->m_microtouch->rx(*memory_nonspecific_space(machine), 0, data8);
 }
 
-static void microtouch_tx(running_machine &machine, UINT8 data)
+WRITE8_MEMBER (cd32_state::microtouch_tx)
 {
-	amiga_serial_in_w(machine, data);
+	amiga_serial_in_w(machine(), data);
 }
 
 static DRIVER_INIT( odeontw2 )
@@ -1472,9 +1478,6 @@
 
 	/* input hack */
 	state->m_input_hack = NULL;
-
-	/* touch screen */
-	microtouch_init(machine, microtouch_tx, NULL);
 }
 
 /***************************************************************************************************/
diff -Nru src-old/mame/drivers/chihiro.c src/mame/drivers/chihiro.c
--- src-old/mame/drivers/chihiro.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/drivers/chihiro.c	2012-02-23 15:42:22.000000000 +0100
@@ -838,6 +838,7 @@
     // device-level overrides
     virtual void device_start();
 	virtual void device_reset();
+	virtual void device_config_complete() { m_shortname = "ide_baseboard"; }
 };
 
 //**************************************************************************
diff -Nru src-old/mame/drivers/cps1.c src/mame/drivers/cps1.c
--- src-old/mame/drivers/cps1.c	2012-02-19 04:59:57.000000000 +0100
+++ src/mame/drivers/cps1.c	2012-02-21 19:11:26.000000000 +0100
@@ -7729,6 +7729,52 @@
 	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
+/* B-Board 91634B-2 */
+ROM_START( sf2ceja )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "s92j_23a.8f", 0x000000, 0x80000, CRC(4f42bb5a) SHA1(59d0587c554e06ea45d4092ea4299ff086509d4b) )
+	ROM_LOAD16_WORD_SWAP( "s92j_22a.7f", 0x080000, 0x80000, CRC(c4f64bcd) SHA1(262c0419bf727da80c2ac52b877a19276d9aac3c) )
+	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )	// could be s92j_21a.6f
+
+	ROM_REGION( 0x600000, "gfx", 0 )
+	ROMX_LOAD( "s92_01.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-1m.3a
+	ROMX_LOAD( "s92_02.4a",  0x000002, 0x80000, CRC(840289ec) SHA1(2fb42a242f60ba7e74009b5a90eb26e035ba1e82) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-3m.5a
+	ROMX_LOAD( "s92_03.5a",  0x000004, 0x80000, CRC(cdb5f027) SHA1(4c7d944fef200fdfcaf57758b901b5511188ed2e) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-2m.4a
+	ROMX_LOAD( "s92_04.6a",  0x000006, 0x80000, CRC(e2799472) SHA1(27d3796429338d82a8de246a0ea06dd487a87768) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-4m.6a
+	ROMX_LOAD( "s92_05.7a",  0x200000, 0x80000, CRC(ba8a2761) SHA1(4b696d66c51611e43522bed752654314e76d33b6) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-5m.7a
+	ROMX_LOAD( "s92_06.8a",  0x200002, 0x80000, CRC(e584bfb5) SHA1(ebdf1f5e2638eed3a65dda82b1ed9151a355f4c9) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-7m.9a
+	ROMX_LOAD( "s92_07.9a",  0x200004, 0x80000, CRC(21e3f87d) SHA1(4a4961bb68c3a1ce15f9d393d9c03ecb2466cc29) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-6m.8a
+	ROMX_LOAD( "s92_08.10a", 0x200006, 0x80000, CRC(befc47df) SHA1(520390420da3a0271ba90b0a933e65143265e5cf) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-8m.10a
+	ROMX_LOAD( "s92_10.3c",  0x400000, 0x80000, CRC(960687d5) SHA1(2868c31121b1c7564e9767b9a19cdbf655c7ed1d) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-10m.3c
+	ROMX_LOAD( "s92_11.4c",  0x400002, 0x80000, CRC(978ecd18) SHA1(648a59706b93c84b4206a968ecbdc3e834c476f6) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-12m.5c
+	ROMX_LOAD( "s92_12.5c",  0x400004, 0x80000, CRC(d6ec9a0a) SHA1(ed6143f8737013b6ef1684e37c05e037e7a80dae) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-11m.4c
+	ROMX_LOAD( "s92_13.6c",  0x400006, 0x80000, CRC(ed2c67f6) SHA1(0083c0ffaf6fe7659ff0cf822be4346cd6e61329) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-13m.6c
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "s92_09.12a",  0x00000, 0x08000, CRC(08f6b60e) SHA1(8258fcaca4ac419312531eec67079b97f471179c) )	// == s92_09.11a
+	ROM_CONTINUE(            0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "s92_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
+	ROM_LOAD( "s92_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "s9263b.1a",    0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "iob1.12d",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "bprg1.11d",    0x0000, 0x0117, CRC(31793da7) SHA1(400fa7ac517421c978c1ee7773c30b9ed0c5d3f3) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
 ROM_START( sf2rb )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD( "sf2d__23.rom",      0x000000, 0x80000, CRC(450532b0) SHA1(14d5ff44ce97247ef4c42147157856d16c5fb4b8) )
@@ -10159,8 +10205,8 @@
 	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_11.4c
 	ROMX_LOAD( "rcm_13.6c",  0x400006, 0x80000, CRC(5069d4a9) SHA1(b832b98be94371af52bd4bb911e18ec57430a7db) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_14.7c",  0x600000, 0x80000, CRC(303be3bd) SHA1(1e5c3fd71966ea9f457840c40582795b501c323e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_16_9c
-	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_15_8c
+	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_16.9c
+	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_15.8c
 	ROMX_LOAD( "rcm_17.10c", 0x600006, 0x80000, CRC(92371042) SHA1(c55833cbaddcc986edd23c009a3e3c7ff09c2708) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
@@ -10688,6 +10734,7 @@
 GAME( 1992, sf2ceub,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920513)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceuc,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920803)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2cej,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920513)", GAME_SUPPORTS_SAVE )
+GAME( 1992, sf2ceja,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920322)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2rb,       sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 1, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
 GAME( 1992, sf2rb2,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 2, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
 GAME( 1992, sf2rb3,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 3, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
diff -Nru src-old/mame/drivers/cps2.c src/mame/drivers/cps2.c
--- src-old/mame/drivers/cps2.c	2012-01-17 07:16:20.000000000 +0100
+++ src/mame/drivers/cps2.c	2012-02-21 19:11:26.000000000 +0100
@@ -726,7 +726,8 @@
 
 		coin_counter_w(space->machine(), 0, data & 0x0001);
 		if ((strncmp(space->machine().system().name, "pzloop2", 8) == 0) ||
-		    (strncmp(space->machine().system().name, "pzloop2j", 8) == 0))
+		    (strncmp(space->machine().system().name, "pzloop2j", 8) == 0) ||
+		    (strncmp(space->machine().system().name, "pzloop2jr1", 8) == 0))
 		{
 			// Puzz Loop 2 uses coin counter 2 input to switch between stick and paddle controls
 			state->m_readpaddle = data & 0x0002;
@@ -5013,6 +5014,33 @@
 
 ROM_START( pzloop2j )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "pl2j.03c", 0x000000, 0x80000, CRC(3b76b806) SHA1(743808ccd470da075ca2f4a8872b22feb7e993ef) ) // 'c' handwritten over 'a' label
+	ROM_LOAD16_WORD_SWAP( "pl2j.04c", 0x080000, 0x80000, CRC(8878a42a) SHA1(178efe9be9ab7f209489f35d653cb5fef4e9565b) ) // ^^
+	ROM_LOAD16_WORD_SWAP( "pl2j.05c", 0x100000, 0x80000, CRC(51081ea4) SHA1(175dc70ba0b6a158d23e7271dd65f28e7beea746) ) // ^^
+	ROM_LOAD16_WORD_SWAP( "pl2j.06c", 0x180000, 0x80000, CRC(51c68494) SHA1(c3b2055af11138f5280fe89e248536069a22ddca) ) // ^^
+
+	ROM_REGION( 0x1000000, "gfx", 0 )
+	ROMX_LOAD( "pl2-simm.01c",   0x0000000, 0x200000, CRC(137b13a7) SHA1(a1ca1bc8699ddfc54d5de1b39a9db9a5ac8b12e5) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.01d",   0x0000001, 0x200000, CRC(a2db1507) SHA1(61c84c8d698a846d54a571b5f7b4824e22136db7) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.01a",   0x0000002, 0x200000, CRC(7e80ff8e) SHA1(afcebfa995ace8b8973e75f1589980c5c4535bca) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.01b",   0x0000003, 0x200000, CRC(cd93e6ed) SHA1(e4afce48fe481d8291ed2475d5de446afad65351) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.03c",   0x0000004, 0x200000, CRC(0f52bbca) SHA1(e76c29d445062f5e16d06bdc4ab44640ba35aaac) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.03d",   0x0000005, 0x200000, CRC(a62712c3) SHA1(2abfe0209e188010a0ae969f0d9eb7d28820b3f2) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.03a",   0x0000006, 0x200000, CRC(b60c9f8e) SHA1(40c7985e04463fb2bd59b3bb6aa5897328d37ff3) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pl2-simm.03b",   0x0000007, 0x200000, CRC(83fef284) SHA1(ef4429f54c456d6485a7d642d49dffafef4435fe) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "pl2.01",   0x00000, 0x08000, CRC(35697569) SHA1(13718923cffb9ec53cef9e22d8875370b5f3dd74) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "pl2-simm.05a",   0x000000, 0x200000, CRC(85d8fbe8) SHA1(c19d5e9084d07e610379b6e1b6be7bdf0b9b7f7f) ) // ROM on a simm
+	ROM_LOAD16_WORD_SWAP( "pl2-simm.05b",   0x200000, 0x200000, CRC(1ed62584) SHA1(28411f610f48cca6424a2d53e2a4ac691e826317) ) // ROM on a simm
+ROM_END
+
+
+ROM_START( pzloop2jr1 )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "pl2j.03a", 0x000000, 0x80000, CRC(0a751bd0) SHA1(a5a0b60387aacdafdf46ecd1acd764c9cb086b90) )
 	ROM_LOAD16_WORD_SWAP( "pl2j.04a", 0x080000, 0x80000, CRC(c3f72afe) SHA1(597a302e4bba50193c53f239e715962fcc4e3e5e) )
 	ROM_LOAD16_WORD_SWAP( "pl2j.05a", 0x100000, 0x80000, CRC(6ea9dbfc) SHA1(c3065e02516755e8b94a741dd2ab960c96d0ff8c) )
@@ -5037,6 +5065,7 @@
 	ROM_LOAD16_WORD_SWAP( "pl2-simm.05b",   0x200000, 0x200000, CRC(1ed62584) SHA1(28411f610f48cca6424a2d53e2a4ac691e826317) ) // ROM on a simm
 ROM_END
 
+
 ROM_START( qndream )
 	ROM_REGION(CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "tqzj.03a", 0x000000, 0x80000, CRC(7acf3e30) SHA1(5e2a697f98185731afc4130286a2699033dd02af) )
@@ -8314,7 +8343,8 @@
 GAME( 2000, mpangu,     mpang,    cps2, cps2_2p1b, cps2,     ROT0,   "Mitchell (Capcom license)", "Mighty! Pang (USA 001010)", GAME_SUPPORTS_SAVE )
 GAME( 2000, mpangj,     mpang,    cps2, cps2_2p1b, cps2,     ROT0,   "Mitchell (Capcom license)", "Mighty! Pang (Japan 001011)", GAME_SUPPORTS_SAVE )
 GAME( 2001, pzloop2,    0,        cps2, pzloop2,   pzloop2,  ROT0,   "Mitchell (Capcom license)", "Puzz Loop 2 (Euro 010302)", GAME_SUPPORTS_SAVE )
-GAME( 2001, pzloop2j,   pzloop2,  cps2, pzloop2,   pzloop2,  ROT0,   "Mitchell (Capcom license)", "Puzz Loop 2 (Japan 010205)", GAME_SUPPORTS_SAVE )
+GAME( 2001, pzloop2j,   pzloop2,  cps2, pzloop2,   pzloop2,  ROT0,   "Mitchell (Capcom license)", "Puzz Loop 2 (Japan 010226)", GAME_SUPPORTS_SAVE )
+GAME( 2001, pzloop2jr1, pzloop2,  cps2, pzloop2,   pzloop2,  ROT0,   "Mitchell (Capcom license)", "Puzz Loop 2 (Japan 010205)", GAME_SUPPORTS_SAVE )
 GAME( 2001, choko,      0,        cps2, choko,     cps2,     ROT0,   "Mitchell (Capcom license)", "Janpai Puzzle Choukou (Japan 010820)", GAME_SUPPORTS_SAVE )
 
 /* Games released on CPS-2 hardware by Eighting/Raizing */
diff -Nru src-old/mame/drivers/deco32.c src/mame/drivers/deco32.c
--- src-old/mame/drivers/deco32.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/deco32.c	2012-02-26 15:31:24.000000000 +0100
@@ -2613,7 +2613,7 @@
 
 	// this is standard DVI data, see http://www.fileformat.info/format/dvi/egff.htm
 	// there are DVI headers at 0x000000, 0x580000, 0x800000, 0xB10000, 0xB80000
-	ROM_REGION( 0xc00000, "dvi", 0 ) /* Video data - unused for now */
+	ROM_REGION( 0x1000000, "dvi", 0 ) /* Video data - unused for now */
 	ROM_LOAD32_BYTE( "mar-17.bin",  0x000000,  0x100000,  CRC(7799ed23) SHA1(ae28ad4fa6033a3695fa83356701b3774b26e6b0) ) // 56 V / 41 A
 	ROM_LOAD32_BYTE( "mar-20.bin",  0x000001,  0x100000,  CRC(fa0462f0) SHA1(1a52617ad4d7abebc0f273dd979f4cf2d6a0306b) ) // 44 D / 56 V
 	ROM_LOAD32_BYTE( "mar-28.bin",  0x000002,  0x100000,  CRC(5a2ec71d) SHA1(447c404e6bb696f7eb7c61992a99b9be56f5d6b0) ) // 56 V / 53 S
@@ -2835,7 +2835,7 @@
 	ROM_LOAD32_BYTE( "mbm-14.a23",  0x000003, 0x100000,  CRC(5aaaf929) SHA1(5ee30db9b83db664d77e6b5e0988ce3366460df6) )
 	ROM_LOAD32_BYTE( "mbm-15.a25",  0x400003, 0x100000,  CRC(789ce7b1) SHA1(3fb390ce0620ce7a63f7f46eac1ff0eb8ed76d26) )
 
-	ROM_REGION( 0xc00000, "dvi", ROMREGION_ERASE00 ) /* Video data - unique PCB and this region is not used? */
+	ROM_REGION( 0x1000000, "dvi", ROMREGION_ERASE00 ) /* Video data - unique PCB and this region is not used? */
 
 	ROM_REGION(0x100000, "oki1", 0 )
 	ROM_LOAD( "mbm-06.n17",  0x00000, 0x100000,  CRC(f34d5999) SHA1(265b5f4e8598bcf9183bf9bd95db69b01536acb2) )
@@ -2908,7 +2908,7 @@
 	ROM_LOAD32_BYTE( "mbm-14.a23",  0x000003, 0x100000,  CRC(5aaaf929) SHA1(5ee30db9b83db664d77e6b5e0988ce3366460df6) )
 	ROM_LOAD32_BYTE( "mbm-15.a25",  0x400003, 0x100000,  CRC(789ce7b1) SHA1(3fb390ce0620ce7a63f7f46eac1ff0eb8ed76d26) )
 
-	ROM_REGION( 0xc00000, "dvi", ROMREGION_ERASE00 ) /* Video data - unique PCB and this region is not used? */
+	ROM_REGION( 0x1000000, "dvi", ROMREGION_ERASE00 ) /* Video data - unique PCB and this region is not used? */
 
 	ROM_REGION(0x100000, "oki1", 0 )
 	ROM_LOAD( "mbm-06.n17",  0x00000, 0x100000,  CRC(f34d5999) SHA1(265b5f4e8598bcf9183bf9bd95db69b01536acb2) )
@@ -2981,7 +2981,7 @@
 	ROM_LOAD32_BYTE( "mbm-14.a23",  0x000003, 0x100000,  CRC(5aaaf929) SHA1(5ee30db9b83db664d77e6b5e0988ce3366460df6) )
 	ROM_LOAD32_BYTE( "mbm-15.a25",  0x400003, 0x100000,  CRC(789ce7b1) SHA1(3fb390ce0620ce7a63f7f46eac1ff0eb8ed76d26) )
 
-	ROM_REGION( 0xc00000, "dvi", ROMREGION_ERASE00 ) /* Video data - same as Dragongun, probably leftover from a conversion */
+	ROM_REGION( 0x1000000, "dvi", ROMREGION_ERASE00 ) /* Video data - same as Dragongun, probably leftover from a conversion */
 //  ROM_LOAD( "mar-17.bin",  0x00000,  0x100000,  CRC(7799ed23) SHA1(ae28ad4fa6033a3695fa83356701b3774b26e6b0) )
 //  ROM_LOAD( "mar-18.bin",  0x00000,  0x100000,  CRC(ded66da9) SHA1(5134cb47043cc190a35ebdbf1912166669f9c055) )
 //  ROM_LOAD( "mar-19.bin",  0x00000,  0x100000,  CRC(bdd1ed20) SHA1(2435b23210b8fee4d39c30d4d3c6ea40afaa3b93) )
@@ -3259,6 +3259,7 @@
 	deco56_decrypt_gfx(machine, "gfx2");
 }
 
+extern void process_dvi_data(UINT8* dvi_data, int offset, int regionsize);
 static DRIVER_INIT( dragngun )
 {
 	UINT32 *ROM = (UINT32 *)machine.region("maincpu")->base();
@@ -3274,21 +3275,29 @@
 
 	ROM[0x1b32c/4]=0xe1a00000;//  NOP test switch lock
 
-	/*
-    {
-        UINT8 *ROM = machine.region("dvi")->base();
-
-        FILE *fp;
-        char filename[256];
-        sprintf(filename,"video.dvi");
-        fp=fopen(filename, "w+b");
-        if (fp)
-        {
-            fwrite(ROM, 0xc00000, 1, fp);
-            fclose(fp);
-        }
-    }
-    */
+#if 0
+	{
+		UINT8 *ROM = machine.region("dvi")->base();
+
+		FILE *fp;
+		char filename[256];
+		sprintf(filename,"video.dvi");
+		fp=fopen(filename, "w+b");
+		if (fp)
+		{
+			fwrite(ROM, 0xc00000, 1, fp);
+			fclose(fp);
+		}
+	}
+#endif
+
+	// there are DVI headers at 0x000000, 0x580000, 0x800000, 0xB10000, 0xB80000
+	process_dvi_data(machine.region("dvi")->base(),0x000000, 0x1000000);
+	process_dvi_data(machine.region("dvi")->base(),0x580000, 0x1000000);
+	process_dvi_data(machine.region("dvi")->base(),0x800000, 0x1000000);
+	process_dvi_data(machine.region("dvi")->base(),0xB10000, 0x1000000);
+	process_dvi_data(machine.region("dvi")->base(),0xB80000, 0x1000000);
+
 }
 
 static DRIVER_INIT( fghthist )
diff -Nru src-old/mame/drivers/dynax.c src/mame/drivers/dynax.c
--- src-old/mame/drivers/dynax.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/dynax.c	2012-02-22 00:51:07.000000000 +0100
@@ -6929,7 +6929,7 @@
 	ROM_REGION( 0x50000, "maincpu", 0 )
 	ROM_LOAD( "epr-a01.rom",      0x00000, 0x40000, CRC(a35e54db) SHA1(247c856e19989fb834e8ed135393927bbd9c0277) )
 	ROM_RELOAD(                   0x10000, 0x40000 )
-	ROM_LOAD( "tmp91p640n-10_bad.5b", 0x00000, 0x04000, BAD_DUMP CRC(509f1c97) SHA1(08557bea2e924053fd5bc9de5e306f3ecf8e98e6) ) // not dumped, rom taken from tenkai
+	ROM_LOAD( "tmp91p640n-10(__baddump).5b", 0x00000, 0x04000, BAD_DUMP CRC(509f1c97) SHA1(08557bea2e924053fd5bc9de5e306f3ecf8e98e6) ) // not dumped, rom taken from tenkai
 
 	ROM_REGION( 0x100000, "gfx1", 0 )	// blitter data
 	ROM_LOAD( "lzc-01.rom", 0x000000, 0x100000, CRC(786698e3) SHA1(9ddf4e31f454fb3c7969b1433771e95a976de741) )
diff -Nru src-old/mame/drivers/esh.c src/mame/drivers/esh.c
--- src-old/mame/drivers/esh.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/esh.c	2012-02-22 00:51:07.000000000 +0100
@@ -346,7 +346,7 @@
 	/* Main program CPU */
 	ROM_REGION( 0x4000, "maincpu", 0 )
 	ROM_LOAD( "is1.h8", 0x0000, 0x2000, CRC(114c912b) SHA1(7c033a102d046199f3e2c6787579dac5b5295d50) )
-	ROM_LOAD( "esha_is2.f8", 0x2000, 0x2000, CRC(7a562f49) SHA1(acfa49b3b3d96b001a5dbdee39cbb0ca80be1763) )
+	ROM_LOAD( "is2(__esha).f8", 0x2000, 0x2000, CRC(7a562f49) SHA1(acfa49b3b3d96b001a5dbdee39cbb0ca80be1763) )
 
 	/* Tiles */
 	ROM_REGION( 0x3000, "gfx1", 0 )
diff -Nru src-old/mame/drivers/exidy.c src/mame/drivers/exidy.c
--- src-old/mame/drivers/exidy.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/exidy.c	2012-02-23 05:39:44.000000000 +0100
@@ -1343,6 +1343,13 @@
 
 	ROM_REGION( 0x0800, "gfx1", 0 )
 	ROM_LOAD( "fxl1-11d.32",  0x0000, 0x0800, CRC(62083db2) SHA1(0c6e90b73419bff53f991e66d4faa9495c7d8e09) )
+
+// loaded, but not hooked up
+	ROM_REGION( 0x0240, "proms", 0 )
+	ROM_LOAD( "fxl-6b",   0x0000, 0x0100, CRC(e1e867ae) SHA1(fe4cb560860579102aedad2c81fd7bed5825f484) )
+	ROM_LOAD( "fxl-8b",   0x0100, 0x0020, CRC(0da1bdf9) SHA1(0c2d85da59cf86f2d9cf5f33bdc63902ca5507d3) )
+	ROM_LOAD( "fxl-11b",  0x0120, 0x0020, CRC(f76b4fcf) SHA1(197e0cc508ffeb5cefa4046bdfb158939d598225) )
+	ROM_LOAD( "fxl-12b",  0x0140, 0x0100, CRC(6b5aa3d7) SHA1(bfc4a6d01b977d55ad4dadc0123339343f1aa975) )
 ROM_END
 
 
@@ -1389,6 +1396,13 @@
 
 	ROM_REGION( 0x0800, "gfx1", 0 )
 	ROM_LOAD( "fxl1-11d.32",   0x0000, 0x0800, CRC(62083db2) SHA1(0c6e90b73419bff53f991e66d4faa9495c7d8e09) )
+
+// loaded, but not hooked up
+	ROM_REGION( 0x0240, "proms", 0 )
+	ROM_LOAD( "fxl-6b",   0x0000, 0x0100, CRC(e1e867ae) SHA1(fe4cb560860579102aedad2c81fd7bed5825f484) )
+	ROM_LOAD( "fxl-8b",   0x0100, 0x0020, CRC(0da1bdf9) SHA1(0c2d85da59cf86f2d9cf5f33bdc63902ca5507d3) )
+	ROM_LOAD( "fxl-11b",  0x0120, 0x0020, CRC(f76b4fcf) SHA1(197e0cc508ffeb5cefa4046bdfb158939d598225) )
+	ROM_LOAD( "fxl-12b",  0x0140, 0x0100, CRC(6b5aa3d7) SHA1(bfc4a6d01b977d55ad4dadc0123339343f1aa975) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/funworld.c src/mame/drivers/funworld.c
--- src-old/mame/drivers/funworld.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/funworld.c	2012-02-22 00:51:07.000000000 +0100
@@ -3461,8 +3461,8 @@
 	ROM_LOAD( "r2.bin", 0x8000, 0x8000, CRC(25dfe0dc) SHA1(1a857a910d0c34b6b5bfc2b6ea2e08ed8ed0cae0) )
 
 	ROM_REGION( 0x10000, "gfx1", 0 )
-	ROM_LOAD( "rcd_2.bin", 0x0000, 0x8000, CRC(85e77661) SHA1(7d7a765c1bfcfeb9eb91d2519b22d734f20eab24) )
-	ROM_LOAD( "rcd_1.bin", 0x8000, 0x8000, CRC(41f7a0b3) SHA1(9aff2b8832d2a4f868daa9849a0bfe5e44f88fc0) )
+	ROM_LOAD( "2(__royalcrdd).bin", 0x0000, 0x8000, CRC(85e77661) SHA1(7d7a765c1bfcfeb9eb91d2519b22d734f20eab24) )
+	ROM_LOAD( "1(__royalcrdd).bin", 0x8000, 0x8000, CRC(41f7a0b3) SHA1(9aff2b8832d2a4f868daa9849a0bfe5e44f88fc0) )
 
 	ROM_REGION( 0x0800,	"nvram", 0 )	/* default NVRAM */
 	ROM_LOAD( "royalcrdd_nvram.bin", 0x0000, 0x0800, CRC(335bfa5a) SHA1(7e9cbb502f450c515ea03ffcf4b7fbae60af4e73) )
diff -Nru src-old/mame/drivers/galdrvr.c src/mame/drivers/galdrvr.c
--- src-old/mame/drivers/galdrvr.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/galdrvr.c	2012-02-22 00:51:07.000000000 +0100
@@ -4791,7 +4791,7 @@
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
 	ROM_LOAD( "my07",         0x0000, 0x1000, CRC(522a2920) SHA1(a64d821a8ff6bd6e2b0bdb1e632181e65a97363b) )
-	ROM_LOAD( "my06e",        0x1000, 0x1000, CRC(466415f2) SHA1(a05f8238cdcebe926a564ef6268b3cd677987fa2) )
+	ROM_LOAD( "my06(__eng)",        0x1000, 0x1000, CRC(466415f2) SHA1(a05f8238cdcebe926a564ef6268b3cd677987fa2) )
 ROM_END
 
 ROM_START( mshuttle2 )
@@ -4799,12 +4799,12 @@
 	ROM_LOAD( "my05",         0x0000, 0x1000, CRC(83574af1) SHA1(d69c2a0538a49d6c72c3346ac4e3959d91da6c98) )
 	ROM_LOAD( "my04",         0x1000, 0x1000, CRC(1cfae2c8) SHA1(6c7eeee70e91b8498c41525dcc60f8086cff8da7) )
 	ROM_LOAD( "my03",         0x2000, 0x1000, CRC(c8b8a368) SHA1(140ba60f55285d1e9f7a262634f5ce5c3470ab71) )
-	ROM_LOAD( "my02-2",         0x3000, 0x1000, CRC(9804061c) SHA1(d5147e827c5a851f6baadea4a0a3b1deb19dda16) )
-	ROM_LOAD( "my01-2",         0x4000, 0x1000, CRC(ca746a61) SHA1(259b1556b0646bf0108b1e3ffbd77bf7238350b0) )
+	ROM_LOAD( "my02(__mshuttle2)",         0x3000, 0x1000, CRC(9804061c) SHA1(d5147e827c5a851f6baadea4a0a3b1deb19dda16) )
+	ROM_LOAD( "my01(__mshuttle2)",         0x4000, 0x1000, CRC(ca746a61) SHA1(259b1556b0646bf0108b1e3ffbd77bf7238350b0) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
 	ROM_LOAD( "my09",         0x0000, 0x1000, CRC(3601b380) SHA1(c0b9d1801f58a16449708d514d2fd88e34af340b) )
-	ROM_LOAD( "my11-2",         0x1000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
+	ROM_LOAD( "my11(__mshuttle2)",         0x1000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
 	ROM_LOAD( "my08",         0x2000, 0x1000, CRC(992b06cd) SHA1(8645ccad8169601bbe25b9f2b17b99004c0a584f) )
 	ROM_LOAD( "my10",         0x3000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
 
diff -Nru src-old/mame/drivers/galivan.c src/mame/drivers/galivan.c
--- src-old/mame/drivers/galivan.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/galivan.c	2012-02-22 00:51:07.000000000 +0100
@@ -991,8 +991,8 @@
 
 ROM_START( youmab2 )
 	ROM_REGION( 0x18000, "maincpu", 0 )	/* main cpu code */
-	ROM_LOAD( "b2_1.1d",	  0x00000, 0x8000, CRC(692ae497) SHA1(572e5a1eae9b0bb48f65dce5de2df5c5ae95a3bd) )
-	ROM_LOAD( "b2_3.4d",     0x10000, 0x8000, CRC(ebf61afc) SHA1(30235a90e8316f5033d44d31f02cca97c64f2d5e) )
+	ROM_LOAD( "1(__bootleg).1d",	 0x00000, 0x8000, CRC(692ae497) SHA1(572e5a1eae9b0bb48f65dce5de2df5c5ae95a3bd) )
+	ROM_LOAD( "3(__bootleg).4d",     0x10000, 0x8000, CRC(ebf61afc) SHA1(30235a90e8316f5033d44d31f02cca97c64f2d5e) )
 
 	ROM_REGION( 0x10000, "user2", 0 )	/* main cpu code */
 	/* This rom is double the size of the original one, appears to have extra (banked) code for 0x8000 */
@@ -1003,7 +1003,7 @@
 	ROM_LOAD( "12.15b",  0x4000, 0x8000, CRC(ac3a0b81) SHA1(39f2c305706e313d5256c357a3c8b57bbe45d3d7) )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )
-	ROM_LOAD( "b2_4.7d",    0x00000, 0x8000, CRC(a1954f44) SHA1(b10a22b51bd1a02c0d7b116b4d7390003c41decf) )	/* chars */
+	ROM_LOAD( "4(__bootleg).7d",     0x00000, 0x8000, CRC(a1954f44) SHA1(b10a22b51bd1a02c0d7b116b4d7390003c41decf) )	/* chars */
 
 	ROM_REGION( 0x20000, "gfx2", 0 )
 	ROM_LOAD( "7.13f",   0x00000, 0x8000, CRC(655f0a58) SHA1(8ffe73cec68d52c7b09651b546289613d6d4dde4) ) /* tiles */
diff -Nru src-old/mame/drivers/goldnpkr.c src/mame/drivers/goldnpkr.c
--- src-old/mame/drivers/goldnpkr.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/goldnpkr.c	2012-02-26 15:31:24.000000000 +0100
@@ -1,701 +1,815 @@
-/******************************************************************************
+/***********************************************************************************
 
-    GOLDEN POKER DOUBLE UP (BONANZA ENTERPRISES, LTD)
-    -------------------------------------------------
+  GOLDEN POKER DOUBLE UP (BONANZA ENTERPRISES, LTD)
+  -------------------------------------------------
 
-    Driver by Roberto Fresca.
+  Driver by Roberto Fresca.
 
 
-    Games running on this hardware:
-
-    * Golden Poker Double Up (Big Boy).         1981, Bonanza Enterprises, Ltd.
-    * Golden Poker Double Up (Mini Boy).        1981, Bonanza Enterprises, Ltd.
-    * Jack Potten's Poker (set 1).              198?, Bootleg.
-    * Jack Potten's Poker (set 2).              198?, Bootleg in Coinmaster H/W.
-    * Jack Potten's Poker (set 3).              198?, Bootleg.
-    * Jack Potten's Poker (set 4).              198?, Bootleg.
-    * Jack Potten's Poker (set 5).              198?, Bootleg.
-    * Jack Potten's Poker (set 6).              198?, Bootleg.
-    * Good Luck.                                198?, Unknown.
-    * Super Double (french).                    198?, Karateco.
-    * Jack Potten's Poker (NGold, set 1).       198?, Unknown.
-    * Jack Potten's Poker (NGold, set 2).       198?, Unknown.
-    * Jack Potten's Poker (NGold, set 3).       198?, Unknown.
-    * Witch Card (Video Klein CPU box, set 1).  1991, Video Klein.
-    * Witch Card (Video Klein CPU box, set 2).  1991, Video Klein.
-    * Witch Card (Spanish, witch game, set 1).  1991, Unknown.
-    * Witch Card (Spanish, witch game, set 2).  1991, Unknown.
-    * Witch Card (English, no witch game).      1991, Unknown.
-    * Witch Card (German, WC3050, set 1 ).      1994, Proma.
-    * Witch Card (English, witch game, lamps).  1985, PlayMan.
-    * Witch Card (Falcon, enhanced sound).      199?, Falcon.
-    * Witch Card (German, WC3050, set 2 ).      1994, Proma.
-    * Witch Card (German, WC3050, 27-4-94),     1994, Proma.
-    * Witch Game (Video Klein, set 1).          1991, Video Klein.
-    * Witch Game (Video Klein, set 2).          1991, Video Klein.
-    * Jolli Witch (Export, 6T/12T ver 1.57D).   1994, Video Klein?.
-    * Wild Witch (Export, 6T/12T ver 1.74A).    1994, Video Klein.
-    * Buena Suerte (Spanish, set 1).            1990, Unknown.
-    * Buena Suerte (Spanish, set 2).            1991, Unknown.
-    * Buena Suerte (Spanish, set 3).            1991, Unknown.
-    * Buena Suerte (Spanish, set 4).            1991, Unknown.
-    * Buena Suerte (Spanish, set 5).            1991, Unknown.
-    * Buena Suerte (Spanish, set 6).            1991, Unknown.
-    * Buena Suerte (Spanish, set 7).            1991, Unknown.
-    * Buena Suerte (Spanish, set 8).            1991, Unknown.
-    * Buena Suerte (Spanish, set 9).            1991, Unknown.
-    * Buena Suerte (Spanish, set 10).           1991, Unknown.
-    * Buena Suerte (Spanish, set 11).           1991, Unknown.
-    * Buena Suerte (Spanish, set 12).           1991, Unknown.
-    * Buena Suerte (Spanish, set 13).           1991, Unknown.
-    * Buena Suerte (Spanish, set 14).           1991, Unknown.
-    * Buena Suerte (Spanish, set 15).           1991, Unknown.
-    * Buena Suerte (Spanish, set 16).           1991, Unknown.
-    * Buena Suerte (Spanish, set 17).           1991, Unknown.
-    * Buena Suerte (Spanish, set 18).           1991, Unknown.
-    * Buena Suerte (Spanish, set 19).           1991, Unknown.
-    * Buena Suerte (Spanish, set 20).           1991, Unknown.
-    * Buena Suerte (Spanish, set 21).           1991, Unknown.
-    * Buena Suerte (Spanish, set 22).           1991, Unknown.
-    * Falcons Wild - World Wide Poker.          1983, Falcon.
-    * Falcons Wild - World Wide Poker.          1990, Video Klein.
-    * Falcons Wild - Wild Card 1991.            1991, TVG.
-    * PlayMan Poker (german).                   1981, PlayMan.
-    * Super Loco 93 (Spanish, set 1).           1993, Unknown.
-    * Super Loco 93 (Spanish, set 2).           1993, Unknown.
-    * Royale (set 1).                           198?, Unknown.
-    * Royale (set 2).                           198?, Unknown.
-    * Maverik.                                  198?, Unknown.
-    * Brasil 86.                                1986, Unknown.
-    * Brasil 87.                                1987, Unknown.
-    * Brasil 89 (set 1).                        1989, Unknown.
-    * Brasil 89 (set 2).                        1989, Unknown.
-    * Brasil 93.                                1993, Unknown.
-    * Poker 91.                                 1991, Unknown.
-    * Genie.                                    198?, Video Fun Games Ltd.
-    * Silver Game.                              1983, Unknown.
-    * "Unknown french poker game".              198?, Unknown.
-    * "Unknown encrypted poker game".           198?, Unknown.
-
-
-*******************************************************************************
-
-
-    I think "Diamond Poker Double Up" from Bonanza Enterprises should run on this hardware too.
-    http://www.arcadeflyers.com/?page=thumbs&id=4539
-
-    Big-Boy and Mini-Boy are different sized cabinets for Bonanza Enterprises games.
-    http://www.arcadeflyers.com/?page=thumbs&id=4616
-    http://www.arcadeflyers.com/?page=thumbs&id=4274
-
-
-    Preliminary Notes (pmpoker):
-
-    - This set was found as "unknown playman-poker".
-    - The ROMs didn't match any currently supported set (0.108u2 romident switch).
-    - All this driver was made using reverse engineering in the program roms.
-
-
-    Game Notes:
-    ==========
-
-    * goldnpkr & goldnpkb:
-
-    "How to play"... (from "Golden Poker Double Up" instruction card)
-
-    1st GAME
-    - Insert coin / bank note.
-    - Push BET button, 1-10 credits multiple play.
-    - Push DEAL/DRAW button.
-    - Push HOLD buttons to hold cards you need.
-    - Cards held can be cancelled by pushing CANCEL button.
-    - Push DEAL/DRAW button to draw cards.
-
-    2nd GAME - Double Up game
-    - When you win, choose TAKE SCORE or DOUBLE UP game.
-    - Bet winnings on
-        "BIG (8 or more number)" or
-        "SMALL (6 and less number)" of next one card dealt.
-    - Over 5,000 winnings will be storaged automatically.
-
-
-    ----- Learn Mode (settings) -----
-    Press LEARN (F2) to enter the learn mode for settings.
-    This is a timed function and after 30-40 seconds switch back to the game.
-
-    Press DOUBLE UP to change Double Up 7 settings between 'Even' and 'Lose'.
-    Press BET to adjust the maximum bet (20-200).
-    Press HOLD4 for Meter Over (5000-50000).
-    Press BIG to change Double Up settings (Normal-Hard).
-    Press TAKE SCORE to set Half Gamble (Yes/No).
-    Press SMALL to set win sound (Yes/No).
-    Press HOLD1 to set coinage 1.
-    Press HOLD2 to set coinage 2.
-    Press HOLD3 to set coinage 3.
-    Press HOLD5 to exit.
-
-    ----- Meters Mode -----
-    Press METER SW (9) to enter the Meters mode. You also can switch between interim
-    and permanent meters using METER SW (only for goldnpkr).
-    This is a timed function and after 30-40 seconds switch back to the game.
-
-    To reset meters push CANCEL + SMALL buttons. HOLD5 to exit.
-    In goldnpkr you can switch between Permanent/Interim Meters.
-    In goldnpkb & pmpoker you can see only Permanent Meters.
-
-    ----- Percentage Mode -----
-    Press Meter SW (9), then DEAL/DRAW, to enter the percentage mode.
-    Press HOLD4 to change the value following the table below (from manual). HOLD1 to exit.
-
-    Number    Overall scoring percentage in the LONG RUN
-    - - - - - - - - - - - - - - - - - - - - - - - - - - -
-      0         about 85%
-      1         about 30%
-      2         about 40%
-      3         about 50%
-
-    ----- Test Mode -----
-    Press Meter SW (9), then DEAL/DRAW, then HOLD5 to enter the test mode.
-    After a RAM test, you can see an input test matrix. Press HOLD1+HOLD2+HOLD3 to exit
-    entering into a video grid test. Press HOLD5 to exit.
-
-
-    * Good Luck
-
-    This hybrid runs on Witch Card hardware.
-    Even when is shown on screen "Bet 1 to 10", you can bet up to 50.
-    There are extra graphics for a couple of jokers, but they never are shown.
-    Maybe some settings can enable the use of them...
+  Games running on this hardware:
+
+  * Golden Poker Double Up (Big Boy).         1981, Bonanza Enterprises, Ltd.
+  * Golden Poker Double Up (Mini Boy).        1981, Bonanza Enterprises, Ltd.
+  * Jack Potten's Poker (set 1).              198?, Bootleg.
+  * Jack Potten's Poker (set 2).              198?, Bootleg in Coinmaster H/W.
+  * Jack Potten's Poker (set 3).              198?, Bootleg.
+  * Jack Potten's Poker (set 4).              198?, Bootleg.
+  * Jack Potten's Poker (set 5).              198?, Bootleg.
+  * Jack Potten's Poker (set 6).              198?, Bootleg.
+  * Good Luck.                                198?, Unknown.
+  * Super Double (french).                    198?, Karateco.
+  * Jack Potten's Poker (NGold, set 1).       198?, Unknown.
+  * Jack Potten's Poker (NGold, set 2).       198?, Unknown.
+  * Jack Potten's Poker (NGold, set 3).       198?, Unknown.
+  * Witch Card (Video Klein CPU box, set 1).  1991, Video Klein.
+  * Witch Card (Video Klein CPU box, set 2).  1991, Video Klein.
+  * Witch Card (Spanish, witch game, set 1).  1991, Unknown.
+  * Witch Card (Spanish, witch game, set 2).  1991, Unknown.
+  * Witch Card (English, no witch game).      1991, Unknown.
+  * Witch Card (German, WC3050, set 1 ).      1994, Proma.
+  * Witch Card (English, witch game, lamps).  1985, PM / Beck Elektronik.
+  * Witch Card (Falcon, enhanced sound).      199?, Falcon.
+  * Witch Card (German, WC3050, set 2 ).      1994, Proma.
+  * Witch Card (German, WC3050, 27-4-94),     1994, Proma.
+  * Witch Game (Video Klein, set 1).          1991, Video Klein.
+  * Witch Game (Video Klein, set 2).          1991, Video Klein.
+  * Jolli Witch (Export, 6T/12T ver 1.57D).   1994, Video Klein?.
+  * Wild Witch (Export, 6T/12T ver 1.74A).    1994, Video Klein.
+  * Buena Suerte (Spanish, set 1).            1990, Unknown.
+  * Buena Suerte (Spanish, set 2).            1991, Unknown.
+  * Buena Suerte (Spanish, set 3).            1991, Unknown.
+  * Buena Suerte (Spanish, set 4).            1991, Unknown.
+  * Buena Suerte (Spanish, set 5).            1991, Unknown.
+  * Buena Suerte (Spanish, set 6).            1991, Unknown.
+  * Buena Suerte (Spanish, set 7).            1991, Unknown.
+  * Buena Suerte (Spanish, set 8).            1991, Unknown.
+  * Buena Suerte (Spanish, set 9).            1991, Unknown.
+  * Buena Suerte (Spanish, set 10).           1991, Unknown.
+  * Buena Suerte (Spanish, set 11).           1991, Unknown.
+  * Buena Suerte (Spanish, set 12).           1991, Unknown.
+  * Buena Suerte (Spanish, set 13).           1991, Unknown.
+  * Buena Suerte (Spanish, set 14).           1991, Unknown.
+  * Buena Suerte (Spanish, set 15).           1991, Unknown.
+  * Buena Suerte (Spanish, set 16).           1991, Unknown.
+  * Buena Suerte (Spanish, set 17).           1991, Unknown.
+  * Buena Suerte (Spanish, set 18).           1991, Unknown.
+  * Buena Suerte (Spanish, set 19).           1991, Unknown.
+  * Buena Suerte (Spanish, set 20).           1991, Unknown.
+  * Buena Suerte (Spanish, set 21).           1991, Unknown.
+  * Buena Suerte (Spanish, set 22).           1991, Unknown.
+  * Falcons Wild - World Wide Poker.          1983, Falcon.
+  * Falcons Wild - World Wide Poker.          1990, Video Klein.
+  * Falcons Wild - Wild Card 1991.            1991, TVG.
+  * PlayMan Poker (german).                   1981, PM / Beck Elektronik.
+  * Super Loco 93 (Spanish, set 1).           1993, Unknown.
+  * Super Loco 93 (Spanish, set 2).           1993, Unknown.
+  * Royale (set 1).                           198?, Unknown.
+  * Royale (set 2).                           198?, Unknown.
+  * Maverik.                                  198?, Unknown.
+  * Brasil 86.                                1986, Unknown.
+  * Brasil 87.                                1987, Unknown.
+  * Brasil 89 (set 1).                        1989, Unknown.
+  * Brasil 89 (set 2).                        1989, Unknown.
+  * Brasil 93.                                1993, Unknown.
+  * Poker 91.                                 1991, Unknown.
+  * Genie.                                    198?, Video Fun Games Ltd.
+  * Silver Game.                              1983, Unknown.
+  * Casino Poker (Ver PM86LO-35-5, German).   1987, PM / Beck Elektronik.
+  * "Unknown french poker game".              198?, Unknown.
+  * "Unknown encrypted poker game".           198?, Unknown.
+
+
+************************************************************************************
+
+
+  I think "Diamond Poker Double Up" from Bonanza Enterprises should run on this hardware too.
+  http://www.arcadeflyers.com/?page=thumbs&id=4539
+
+  Big-Boy and Mini-Boy are different sized cabinets for Bonanza Enterprises games.
+  http://www.arcadeflyers.com/?page=thumbs&id=4616
+  http://www.arcadeflyers.com/?page=thumbs&id=4274
+
+
+  Preliminary Notes (pmpoker):
+
+  - This set was found as "unknown playman-poker".
+  - The ROMs didn't match any currently supported set (0.108u2 romident switch).
+  - All this driver was made using reverse engineering in the program roms.
+
+
+  Game Notes:
+  ==========
+
+  * goldnpkr & goldnpkb:
+
+  "How to play"... (from "Golden Poker Double Up" instruction card)
+
+  1st GAME
+  - Insert coin / bank note.
+  - Push BET button, 1-10 credits multiple play.
+  - Push DEAL/DRAW button.
+  - Push HOLD buttons to hold cards you need.
+  - Cards held can be cancelled by pushing CANCEL button.
+  - Push DEAL/DRAW button to draw cards.
+
+  2nd GAME - Double Up game
+  - When you win, choose TAKE SCORE or DOUBLE UP game.
+  - Bet winnings on
+      "BIG (8 or more number)" or
+      "SMALL (6 and less number)" of next one card dealt.
+  - Over 5,000 winnings will be storaged automatically.
+
+
+  ----- Learn Mode (settings) -----
+  Press LEARN (F2) to enter the learn mode for settings.
+  This is a timed function and after 30-40 seconds switch back to the game.
+
+  Press DOUBLE UP to change Double Up 7 settings between 'Even' and 'Lose'.
+  Press BET to adjust the maximum bet (20-200).
+  Press HOLD4 for Meter Over (5000-50000).
+  Press BIG to change Double Up settings (Normal-Hard).
+  Press TAKE SCORE to set Half Gamble (Yes/No).
+  Press SMALL to set win sound (Yes/No).
+  Press HOLD1 to set coinage 1.
+  Press HOLD2 to set coinage 2.
+  Press HOLD3 to set coinage 3.
+  Press HOLD5 to exit.
+
+  ----- Meters Mode -----
+  Press METER SW (9) to enter the Meters mode. You also can switch between interim
+  and permanent meters using METER SW (only for goldnpkr).
+  This is a timed function and after 30-40 seconds switch back to the game.
+
+  To reset meters push CANCEL + SMALL buttons. HOLD5 to exit.
+  In goldnpkr you can switch between Permanent/Interim Meters.
+  In goldnpkb & pmpoker you can see only Permanent Meters.
+
+  ----- Percentage Mode -----
+  Press Meter SW (9), then DEAL/DRAW, to enter the percentage mode.
+  Press HOLD4 to change the value following the table below (from manual). HOLD1 to exit.
+
+  Number    Overall scoring percentage in the LONG RUN
+  - - - - - - - - - - - - - - - - - - - - - - - - - - -
+    0         about 85%
+    1         about 30%
+    2         about 40%
+    3         about 50%
+
+  ----- Test Mode -----
+  Press Meter SW (9), then DEAL/DRAW, then HOLD5 to enter the test mode.
+  After a RAM test, you can see an input test matrix. Press HOLD1+HOLD2+HOLD3 to exit
+  entering into a video grid test. Press HOLD5 to exit.
+
+
+  * Good Luck
+
+  This hybrid runs on Witch Card hardware.
+  Even when is shown on screen "Bet 1 to 10", you can bet up to 50.
+  There are extra graphics for a couple of jokers, but they never are shown.
+  Maybe some settings can enable the use of them...
+
+
+  * Witch Card (spanish sets)
+
+  This game is derivated from Golden Poker.
+
+  The hardware has a feature called BLUE KILLER.
+  Using the original intensity line, the PCB has a bridge
+  that allow (as default) turn the background black.
+
+  Except goodluck, all other games running in this hardware
+  were designed to wear black background.
+
+  - Settings:
+
+  There are 12 parameters to program. All of them are unknown.
+  To program them, enter the settings mode with F2 and use the HOLD keys,
+  CANCEL key, DEAL + HOLD keys, and DEAL + CANCEL. To exit the mode press BET.
+
+  Settings are still unknown, but put the max value for each parameter to allow
+  all the game features.
+
+  First Line:  32 32 32 32 32 64
+  Second Line: 40 40 40 40 50 16
+
+  - Play:
+
+  The game is like other poker games, but with 2 jokers.
+  Each time you win a hand, a double up game appear...
+
+  - Double Up:
+
+  You must to choose High or Low to guess the card. If you win,
+  you can take the credits or continue into double up.
+  Each time you win a double up hand, the card is indicated on the screen.
+  The first 3 consecutive winning hands will add a witch with a running number.
+  Further winning hands only add the card/kind indication. When you lose, or
+  take your credits, the 3 witches start to roll their own numbers like a
+  slot machine. There is an attempt for each winning hand. the bonus ends when
+  you win a prize, or when all attempts are done.
+
+
+  * Super Loco 93
+
+  I like this game!... This one has nothing to do with poker games.
+  The objective is to get the higher sum with 2 or 3 cards. Is clearly
+  based on a passage (Envido) of the famous argentine's game called "Truco".
+
+  - How to play?...
+
+  Like in Truco's envido, You must add 20 to the sum of your cards.
+  If you have 7 and 5 of the same kind, you have 7 + 5 + 20 = 32 points.
+
+  "Flor", is 3 cards of the same kind.
+  "Simple", is 2 cards of the same kind.
+
+  HAND             WIN    DESCRIPTION
+  ----------------------------------------------
+  38  Corazones   1000    7, 6 and 5 of hearts.
+  777 Loco Loco    200    3x sevens.
+  38  Flor          80    7, 6 and 5 of the same kind (except hearts).
+  37  Flor          20    7, 6 and 4 of the same kind.
+  36  Flor          14    7, 5 and 4 of the same kind.
+  35  Flor          10    6, 5 and 4 of the same kind.
+  32-33-34 Flor      6    3 of the same kind that sum 32, 33 or 34.
+  33  Simple         4    7 and 6 of the same kind.
+  32  Simple         2    7 and 5 of the same kind.
+
+  After bet (apuesta) some credits, Press deal (reparte) button.
+  The game will deals 3 cards. You can discard up to all your 3 cards.
+  Pressing the deal button again, new cards will appear in the place
+  of the previously selected cards.
+
+  - Double Up:
+
+  You must to choose Red or Black to guess the card.
+  If you win, you can take the credits or continue into double up.
+  The rest is similar to Witch Card, but with 3 big numbers instead of
+  witches. Once you lose or take your credits, the big numbers start to
+  run 'alla' slot game, giving 1 attempt by each time you won a double-up
+  hand.
+
+  - Settings:
+
+  There are 12 parameters to program.
+  To program them, use the HOLD keys, CANCEL key, DEAL + HOLD keys,
+  and DEAL + CANCEL.
+
+
+  * Wild Witch / Jolli Witch
+
+  These sets have a switch to change the game. Wild Witch comes with a complete
+  Witch Game as switchable alternative, and Jolli Witch has Witch Card in the same
+  package. Both are based in the 6T/12T program made by Video Klein, However, Jolli
+  Witch seems to be a bootleg CPU box on an original Bonanza mainboard.
+
+  The first time the game boots, will show a black & red screen with some options
+  due to the lack or corrupt NVRAM. You must choose HOLD1 to create a new default
+  NVRAM. In case you have corrupt NVRAM (not first boot), you can choose HOLD5 to
+  attempt recover the old settings.
+
+
+  * Witch Card (Proma)
+
+  For the first time: You must coin-up and play at least one hand, then Payout
+  to get the proper coinage settings.
+
+
+  * Casino Poker
+
+  Bipolar PROM 24sa10 is filled with 0x09, so has at least
+  fixed bits 0 and 3 along the whole data. Needs a redump using a supported
+  EEPROM programmer.
+
+  Discrete sound circuitry was traced, being identical to the Golden Poker one.
+  Only difference is the PC617 replaced by one PC817.
+
+  The sound is ugly and seems that was programmed that way.
+  Also the lamps work in test mode, but seems to be avoided in the game code.
+
+  The game has 2 service switches/buttons:
+  One for settings, and other just for bookkeeping.
+
+  Here the original Service Card (in german), and the english translation:
+   _____________________________________     _____________________________________
+  |                                     |   |                                     |
+  |          SERVICE ANLEITUNG          |   |           SERVICE MANUAL            |
+  |   _____________   _____________     |   |   _____________   _____________     |
+  |  |  +-------+  | |  +-------+  |    |   |  |  +-------+  | |  +-------+  |    |
+  |  |  |0000000|  | |  |0000000|  |    |   |  |  |0000000|  | |  |0000000|  |    |
+  |  |  +-------+  | |  +-------+  |    |   |  |  +-------+  | |  +-------+  |    |
+  |  |             | |             |    |   |  |             | |             |    |
+  |  |             | |             |    |   |  |             | |             |    |
+  |  |             | |             |    |   |  |             | |             |    |
+  |  | +---------+ | |+-----------+|    |   |  | +---------+ | |+-----------+|    |
+  |  | |Einnahmen| | ||Kredit Off ||    |   |  | |Earnings | | ||Credit Off ||    |
+  |  | +---------+ | |+-----------+|    |   |  | +---------+ | |+-----------+|    |
+  |  |             | |             |    |   |  |             | |             |    |
+  |  |_____________| |_____________|    |   |  |_____________| |_____________|    |
+  |                                     |   |                                     |
+  |  Zaehler zeigen volle DM-Betraege   |   |     METER SHOW FULL DM-AMOUNTS      |
+  |                                     |   |                                     |
+  |       _____            _____        |   |       _____            _____        |
+  |      |     |     |    |     |       |   |      |     |     |    |     |       |
+  |      | SW  |     |    | RT  |       |   |      | SW  |     |    | RT  |       |
+  |      |_____|     |    |_____|       |   |      |_____|     |    |_____|       |
+  |                  |                  |   |                  |                  |
+  |      SERVICE     |     METER        |   |      SERVICE     |     METER        |
+  |                  |                  |   |                  |                  |
+  |    +---------+   | ZEIGT DIE        |   |    +---------+   | SHOWS THE        |
+  |    |  LEARN  |   | ELEKT. ZAEHLER-  |   |    |  LEARN  |   | ELECTRONIC METER-|
+  |    +---------+   | STAENDE UND      |   |    +---------+   | READING AND      |
+  |                  | STATISTIK AN     |   |                  | STATISTIC        |
+  |   PROGRAMMIER.   |                  |   |   PROGRAMMING    |                  |
+  |   DER KREDIT-    |                  |   |   THE CREDIT-    |                  |
+  |   EINGAENGE UND  +------------------|   |   INPUT AND      +------------------|
+  |   GEWINNQUOTE    |                  |   |   PROFIT SHARE   |                  |
+  |                  |    < POT >       |   |                  |    < POT >       |
+  |    +---------+   |  +         -     |   |    +---------+   |  +         -     |
+  |    |   NEU   |   |  LAUTSTAERKE     |   |    |   NEW   |   |  SOUND VOLUME    |
+  |    +---------+   |                  |   |    +---------+   |                  |
+  |                  |                  |   |                  |                  |
+  |   SETZT DIE      |                  |   |   RESET THE      |                  |
+  |   ELEKT. ZAEHLER |    < POT >       |   |   ELECTRONIC     |    < POT >       |
+  |   ZURUECK        |                  |   |   COUNTER        |                  |
+  |                  | BLAU<->SCHWARZ   |   |                  | BLUE <-> BLACK   |
+  |    +---------+   | HINTERGRUND      |   |    +---------+   | BACKGROUND       |
+  |    |  TEST   |   |                  |   |    |  TEST   |   |                  |
+  |    +---------+   |                  |   |    +---------+   |                  |
+  |                  |                  |   |                  |                  |
+  |   CPU, TASTATUR  |                  |   |   CPU, KEYBOARD  |                  |
+  |   UND LAMPEN     |                  |   |   AND LAMPS      |                  |
+  |   TEST           |                  |   |   TEST           |                  |
+  |   GITTERMUSTER   |                  |   |   LATTICE DESIGN |                  |
+  |                  |                  |   |                  |                  |
+  |    +---------+   |                  |   |    +---------+   |                  |
+  |    |  RESET  |   |                  |   |    |  RESET  |   |                  |
+  |    +---------+   |                  |   |    +---------+   |                  |
+  |                  |                  |   |                  |                  |
+  |   LOESCHT ALLES  |                  |   |    DELETE ALL    |                  |
+  |                  |                  |   |                  |                  |
+  |------------------+------------------|   |------------------+------------------|
+  |        DIPSWITCHEINSTELLUNG         |   |        DIPSWITCH SETTINGS           |
+  |                                     |   |                                     |
+  |            ON      OFF              |   |            ON      OFF              |
+  |           +-----------+             |   |           +-----------+             |
+  |           | +-------+ |             |   |           | +-------+ |             |
+  |       ON  | |###|   |8|             |   |       ON  | |###|   |8|             |
+  |           | +---+---+ |             |   |           | +---+---+ |             |
+  |       ON  | |###|   | |             |   |       ON  | |###|   | |             |
+  |           | +-------+ |             |   |           | +-------+ |             |
+  |           | |   |###| |             |   |           | |   |###| |             |
+  |           | +---+---+ |             |   |           | +---+---+ |             |
+  |           | |   |###| |             |   |           | |   |###| |             |
+  |           | +-------+ |             |   |           | +-------+ |             |
+  |R-FLUSH EIN| |###|   | |R-FLUSH AUS  |   | R-FLUSH ON| |###|   | |R-FLUSH OFF  |
+  |           | +---+---+ |             |   |           | +---+---+ |             |
+  |           | |###|   | |             |   |           | |###|   | |             |
+  |           | +-------+ |             |   |           | +-------+ |             |
+  |           | |   |###| |AUSZAHLUNG   |   |           | |   |###| |PAYOUT       |
+  |           | +---+---+ |             |   |           | +---+---+ |             |
+  |           | |###|   |1|AUSZAHLUNG   |   |           | |###|   |1|PAYOUT       |
+  |           | +-------+ |             |   |           | +-------+ |             |
+  |           +-----------+             |   |           +-----------+             |
+  |                                     |   |                                     |
+  |  0=WENIG GEWINNE    1=STANDARD      |   |  0=LITTLE GAININGS   1=DEFAULT      |
+  |  2=MEHR GEWINNE     3=VIELE GEWIN.  |   |  2=MORE GAININGS    3=MANY GAININGS |
+  |                                     |   |                                     |
+  |                                     |   |                                     |
+  |   PM 1987 - BECK D-6330 WETZLAR     |   |   PM 1987 - BECK D-6330 WETZLAR     |
+  |_____________________________________|   |_____________________________________|
+
+
+************************************************************************************
+
+
+  Hardware Notes (pmpoker):
+
+  - CPU:            1x M6502.
+  - Video:          1x MC6845.
+  - RAM:            4x uPD2114LC
+  - I/O             2x 6821 PIAs.
+  - prg ROMs:       3x 2732 (32Kb) or similar.
+  - gfx ROMs:       4x 2716 (16Kb) or similar.
+  - sound:          (discrete).
+  - battery backup: 2x S8423
+
+
+  PCB Layout (pmpoker): (XX) = unreadable.
+   _______________________________________________________________________________
+  |   _________                                                                   |
+  |  |         |               -- DIP SW x8 --                                    |
+  |  | Battery |   _________   _______________   _________  _________   ________  |
+  |  |   055   |  | 74LS32  | |1|2|3|4|5|6|7|8| | HCF4011 || HCF4096 | | LM339N | |
+  |  |_________|  |_________| |_|_|_|_|_|_|_|_| |_________||_________| |________| |
+  |       _________     _________   _________   _________                         |
+  |      | 74LS138 |   | S-8423  | | 74LS08N | | 74LS(XX)|                        |
+  |      |_________|   |_________| |_________| |_________|                        |
+  |  _______________    _________   ____________________                      ____|
+  | |               |  | S-8423  | |                    |                    |
+  | |     2732      |  |_________| |       6502P        |                    |
+  | |_______________|   _________  |____________________|                    |
+  |  _______________   |  7432   |  ____________________                     |____
+  | |               |  |_________| |                    |                     ____|
+  | |     2732      |   _________  |       6821P        |                     ____|
+  | |_______________|  | 74LS157 | |____________________|                     ____|
+  |  _______________   |_________|  ____________________                      ____|
+  | |               |   _________  |                    |                     ____|
+  | |     2732      |  | 74LS157 | |       6821P        |                     ____|
+  | |_______________|  |_________| |____________________|                     ____|
+  |  _______________    _________   ____________________                      ____|
+  | |               |  | 74LS157 | |                    |                     ____|
+  | |     2732      |  |_________| |       6845SP       |                     ____|
+  | |_______________|   _________  |____________________|                     ____|
+  |                    | 2114-LC |                                            ____| 28x2
+  |                    |_________|                                            ____| connector
+  |       _________     _________                                             ____|
+  |      | 74LS245 |   | 2114-LC |                                            ____|
+  |      |_________|   |_________|                                            ____|
+  |       _________     _________               _________                     ____|
+  |      | 74LS245 |   | 2114-LC |             | 74LS174 |                    ____|
+  |      |_________|   |_________|             |_________|                    ____|
+  |  ________________   _________   _________   _________                     ____|
+  | |                | | 2114-LC | | 74LS08H | | TI (XX) | <-- socketed.      ____|
+  | |      2716      | |_________| |_________| |_________|       PROM         ____|
+  | |________________|              _________   _________                     ____|
+  |  ________________              | 74LS04P | | 74LS174 |                    ____|
+  | |                |             |_________| |_________|                    ____|
+  | |      2716      |              _________   _________                     ____|
+  | |________________|             | 74166P  | | 74LS86C |                    ____|
+  |  ________________              |_________| |_________|                    ____|
+  | |                |              _________    _______                     |
+  | |      2716      |             | 74166P  |  | 555TC |                    |
+  | |________________|             |_________|  |_______|                    |
+  |  ________________                                                        |____
+  | |                |                                                        ____|
+  | |      2716      |              _________   _________      ________       ____| 5x2
+  | |________________|             | 74166P  | |  7407N  |    | LM380N |      ____| connector
+  |                                |_________| |_________|    |________|      ____|
+  |  ________  ______               _________   _________      ___            ____|
+  | | 74LS04 || osc. |             | 74LS193 | |  7407N  |    /   \          |
+  | |________||10 MHz|             |_________| |_________|   | POT |         |
+  |           |______|                                        \___/          |
+  |__________________________________________________________________________|
+
+
+
+  Some odds:
+
+  - There are unused pieces of code like the following sub:
+
+  78DE: 18         clc
+  78DF: 69 07      adc  #$07
+  78E1: 9D 20 10   sta  $1020,x
+  78E4: A9 00      lda  #$00
+  78E6: 9D 20 18   sta  $1820,x
+  78E9: E8         inx
+
+  78EA: 82         DOP        ; use of DOP (double NOP)
+  78EB: A2 0A      dummy (ldx #$0A)
+
+  78ED: AD 82 08   lda  $0882
+
+  78F0: 82         DOP        ; use of DOP (double NOP)
+  78F1: 48 08      dummy
+  78F3: D0 F6      bne  $78EB ; branch to the 1st DOP dummy arguments (now ldx #$0A).
+  78F5: CA         dex
+  78F6: D0 F8      bne  $78F0
+  78F8: 29 10      and  #$10
+  78FA: 60         rts
+
+  Offset $78EA and $78F0 contains an undocumented 6502 opcode (0x82).
+
+  At beginning, I thought that the main processor was a 65sc816, since 0x82 is a documented opcode (BRL) for this CPU.
+  Even the vector $FFF8 contain 0x09 (used to indicate "Emulation Mode" for the 65sc816).
+  I dropped the idea following the code. Impossible to use BRL (branch relative long) in this structure.
+
+  Some 6502 sources list the 0x82 mnemonic as DOP (double NOP), with 2 dummy bytes as argument.
+  The above routine dynamically change the X register value using the DOP undocumented opcode.
+  Since the opcode DOP in fact has only 1 dummy byte as argument, they apparently dropped this
+  piece of code due to it didn't work as expected. Now all have sense.
+
+
+************************************************************************************
+
+
+  -----------------------------------------------
+  ***  Memory Map (pmpoker/goldnpkr hardware) ***
+  -----------------------------------------------
+
+  $0000 - $00FF   RAM     ; Zero Page (pointers and registers)
+
+                          ; $45 to $47 - Coin settings.
+                          ; $50 - Input port register.
+                          ; $5C - Input port register.
+                          ; $5D - Input port register.
+                          ; $5E - Input port register.
+                          ; $5F - Input port register.
+
+  $0100 - $01FF   RAM     ; 6502 Stack Pointer.
+
+  $0200 - $02FF   RAM     ; R/W. (settings)
+  $0300 - $03FF   RAM     ; R/W (mainly to $0383). $0340 - $035f (settings).
+
+  $0800 - $0801   MC6845  ; MC6845 use $0800 for register addressing and $0801 for register values.
+
+                          *** pmpoker mc6845 init at $65B9 ***
+                          *** goldnpkr mc6845 init at $5E75 ***
+                          *** sloco93 mc6845 init at $D765 ***
+                          register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
+                          value:     0x27  0x20  0x22  0x02  0x1F  0x04  0x1D  0x1E  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
+
+                          *** goodluck mc6845 init at $527B ***
+                          register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
+                          value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1F  0x00  0x00  0x26  0x00  0x20  0x22  0x58  0xA5  0x4F  0xC9.
+
+                          *** witchcrd mc6845 init at $D765 ***
+                          register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
+                          value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1F  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
+
+                          *** witchcrd (Video Klein) mc6845 init at $627B ***
+                          register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
+                          value:     0x27  0x20  0x23  0x33  0x1F  0x04  0x1D  0x1F  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
+
+                          *** witchcrd (Video Klein) mc6845 mod at $6293 ($2000 and #$20) ***
+                          register:   04    05    06    07
+                          value:     0x26  0x00  0x20  0x22
+
+                          *** royale mc6845 init at $6581 ***
+                          register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
+                          value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1E  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
+
+  $0844 - $0847   PIA0    ; Muxed inputs and lamps. Initialized at $5000.
+  $0848 - $084B   PIA1    ; Sound writes and muxed inputs selector. Initialized at $5000.
+
+  $1000 - $13FF   Video RAM   ; Initialized in subroutine starting at $5042.
+  $1800 - $1BFF   Color RAM   ; Initialized in subroutine starting at $5042.
+
+  $4000 - $7FFF   ROM
+
+  $8000 - $FFFF           ; Mirrored from $0000 - $7FFF due to lack of A15 line connection.
+
+
+
+  ---------------------------------------
+  ***  Memory Map (pottnpkr hardware) ***
+  ---------------------------------------
+
+  $0000 - $00FF   RAM     ; Zero Page (pointers and registers)
+  $0100 - $01FF   RAM     ; 6502 Stack Pointer.
+  $0200 - $02FF   RAM     ; R/W. (settings)
+  $0300 - $03FF   RAM     ; R/W (mainly to $0383). $0340 - $035f (settings).
+
+  $0800 - $0801   MC6845  ; MC6845 use $0800 for register addressing and $0801 for register values.
+
+  $0844 - $0847   PIA0    ; Muxed inputs and lamps.
+  $0848 - $084B   PIA1    ; Sound writes and muxed inputs selector.
+
+  $1000 - $13FF   Video RAM
+  $1800 - $1BFF   Color RAM
+
+  $2000 - $3FFF   ROM space
+
+  $4000 - $7FFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
+  $8000 - $BFFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
+  $C000 - $FFFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
+
+
+************************************************************************************
+
+
+  Buttons/Inputs   goldnpkr goldnpkb  pmpoker  bsuerte goodluck pottnpkr potnpkra potnpkrc potnpkrb
+  -------------------------------------------------------------------------------------------------
+
+  HOLD (5 buttons)  mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  CANCEL            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  BIG               mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
+  SMALL             mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
+  DOUBLE UP         mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
+  TAKE SCORE        mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
+  DEAL/DRAW         mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  BET               mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+
+  Coin 1 (coins)    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  Coin 2 (notes)    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   fixed 1c-1c
+  Coin 3 (coupons)  mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
+  Payout            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  Manual Collect    mapped   mapped   mapped    ----    mapped   mapped   mapped   mapped   mapped
+
+  LEARN/SETTINGS    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+  METERS            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
+
+
+  Inputs are different for some games. Normally each button has only one function.
+  In pmpoker some buttons have different functions.
+
+
+************************************************************************************
+
+
+  DRIVER UPDATES:
+
+
+  [2006-09-02]
+
+  - Initial release.
+
+
+  [2006-09-06]
+
+  - Understood the GFX banks:
+      - 1 bank (1bpp) for text layer and minor graphics.
+      - 1 bank (3bpp) for the undumped cards deck graphics.
+
+  - Partially added inputs through 6821 PIAs.
+      ("Bitte techniker rufen" error messages. Press 'W' to reset the machine)
+
+  - Confirmed the CPU as 6502. (was in doubt due to use of illegal opcodes)
+
+
+  [2006-09-15]
+
+  - Confirmed the GFX banks (a complete dump appeared!).
+  - Improved technical notes and added a PCB layout based on PCB picture.
+  - Found and fixed the 3rd bitplane of BigBoy gfx.
+  - Renamed Big-Boy to Golden Poker Double Up. (Big-Boy and Mini-Boy are names of cabinet models).
+  - Added 'Joker Poker' (Golden Poker version without the 'double-up' feature).
+  - Added 'Jack Potten's Poker' (same as Joker Poker, but with 'Aces or better' instead of jacks).
+  - Simulated colors for all sets till color PROMs appear.
+  - Fixed bit corruption in goldnpkr rom u40_4a.bin.
+  - Completed inputs in all sets (except DIP switches).
+  - Removed flags GAME_WRONG_COLORS and GAME_IMPERFECT_GRAPHICS in all sets.
+  - Removed flag GAME_NOT_WORKING. All sets are now playable. :)
+
+
+  [2006-10-09]
+
+  - Added service/settings mode to pmpoker.
+  - Added PORT_IMPULSE to manage correct timings for most inputs in all games.
+    (jokerpkr still trigger more than 1 credit for coin pulse).
+
+
+  [2007-02-01]
+
+  - Crystal documented via #define.
+  - CPU clock derived from #defined crystal value.
+  - Replaced simulated colors with proper color prom decode.
+  - Renamed "Golden Poker Double Up" to "Golden Poker Double Up (Big Boy)".
+  - Added set Golden Poker Double Up (Mini Boy).
+  - Cleaned up the driver a bit.
+  - Updated technical notes.
+
+
+  [2007-05-05]
+
+  - Removed all inputs hacks.
+  - Connected both PIAs properly.
+  - Demuxed all inputs for each game.
+  - Documented all outputs.
+  - Added lamps support.
+  - Created different layout files to cover each game.
+  - Add NVRAM support to all games.
+  - Corrected the color PROM status for each set.
+  - Figured out most of the DIP switches.
+  - Added diplocations to goldnpkb.
+  - Replaced the remaining IPT_SERVICE with IPT_BUTTON for regular buttons.
+  - Updated technical notes.
+  - Cleaned up the driver. Now is better organized and documented.
+
+
+  [2007-07-07]
+
+  - Added set goldnpkc (Golden Poker without the double up feature).
+  - Updated technical notes.
+
+
+  [2008-10-12] *** REWRITE ***
+
+  - Added discrete sound support to Golden Poker hardware games based on schematics.
+  - Added discrete sound support to Potten's Poker hardware games based on PCB analysis.
+  - Added discrete circuitry diagrams for both hardware types.
+  - Adjusted the CPU addressing to 15 bits for pmpoker/goldenpkr hardware.
+  - Adjusted the CPU addressing to 14 bits for pottnpkr hardware.
+  - Rewrote all the ROM loads based on these changes.
+  - Defined MASTER Xtal & CPU clock.
+  - Fixed the visible area based on M6845 registers.
+  - Improved the lamps layouts to be more realistic.
+  - Added Good Luck (potten's poker hybrid running in goldnpkr hardware).
+  - Added Buena Suerte (spanish) x 2 sets.
+  - Added set Royale.
+  - Added Witch Card and spanish variants.
+  - Added Super Loco 93 (spanish) x 2 sets.
+  - Renamed set goldnpkc to pottnpkr (parent Jack Potten's Poker set).
+  - Renamed set jokerpkr to potnpkra, since is another Jack Potten's Poker set.
+  - Added other 2 clones of Jack Potten's Poker.
+  - Renamed/cleaned all sets based on code/hardware analysis.
+  - Added intensity bit to the color system.
+  - Implemented the blue killer bit for Witch Card hardware.
+  - Implemented the extended graphics addressing bit for Witch Card hardware.
+  - Added proper visible area to sloco93.
+  - Rewrote the graphics & color decode system based on schematics. No more patched codes.
+  - Changed the char gfx bank structure and rom load according to the new routines.
+  - Adjusted the amount of color codes and PROM region size accordingly.
+  - Updated all notes.
+
+
+  [2008-11-29] *** REWRITE (part II) ***
+
+  - Changed the driver name to goldnpkr.c (Golden Poker is the most representative hardware).
+  - Splitted the PIA interfases to cover witchcrd/pottenpkr connections.
+  - Fixed the witchcrd/pottnpkr/sloco93 double up mode.
+  - Replaced the pottenpkr layout with goldnpkr one in all Jack Potten's Poker sets.
+  - Updated game notes for Witch Card and Super Loco 93 sets.
+  - Fixed al inputs & lamps to allow double up mode to the above games.
+  - Added Witch Card (Video Klein) but still not working.
+  - Added several Buena Suerte! sets.
+  - Added new games: Maverik, Brasil 89 & Poker'91.
+  - Reworked the sets parent-clone relationship (still in progress).
+
+
+  [2008-12-26]
+
+  - Correctly setup the MC6845 device for all systems.
+  - Added common MC6845 device interface.
+  - Merged witchcrd and sloco93 machine drivers.
+  - Added/corrected the 50/60 Hz. DIP switches to all games.
+    The 50hz mode needs to be corrected. Some games as most bsuerte sets have
+    the 50/60 Hz. DIP switch connection patched.
+
+
+  [2009-09-05]
+
+  - Added 2 new Witch Card sets.
+  - Reworked inputs for Witch Card (german set 1).
+  - Created new inputs for Witch Card (english, witch game, lamps).
+  - Added and connected lamps for both sets.
+  - Added minimal bet and 50/60 Hz. switches to both sets.
+  - Added DIP switches info for Witch Card (german, set 2).
+
+  - Added Genius, running in a modified Golden Poker board.
+
+
+  [2010-09-28]
+
+  - Added 3 new Witch Card sets.
+  - Added 3 new Falcons Wild sets (from 3 different hardwares).
+  - Hooked the second CPU (still encrypted) to the Falcon hardware.
+  - Partially decrypted the second CPU program from Falcon hardware.
+  - Figured out the Falcons Wild (Video Klein) memory map and machine.
+  - Defeated the evil Video Klein's Witch Card hardware.
+  - Reworked inputs for some sets.
+  - Added lamps layouts/connections to the new sets.
+  - Figured out the multiplexed data/address from Falcon's boards sound.
+  - Added full sound support to Falcon hardware.
+  - Reorganized and partially cleaned-up the driver.
+  - Added more technical notes.
+
+
+  [2010-11-18]
+
+  - Added Karateco Super Double (french)
+  - Extended ROM space for goldnpkr game to include the 0x2000..0x3fff range
+
+
+  [2011-01-20]
+
+  - Lots of changes to get working the Video Klein games.
+  - Renamed witchcde to witchjol --> Jolly Witch (Export, 6T/12T ver 1.57D).
+  - Added Wild Witch (Export, 6T/12T ver 1.74A).
+  - New video hardware and machine driver for Video Klein's extended tiles games.
+  - Added Dallas DS1210 + battery backed RAM support to the Video Klein CPU boxed games.
+  - Improved inputs for Jolli Witch and Wild Witch. Added the game selector switch.
+  - Cleaned up some witch card sets.
+  - Added technical and game notes.
+
+
+  [2011-10-19]
+
+  - Mapped the Dallas DS1210 for Video Klein sets that have one.
+  - Mapped the 2800-2fff range as RAM for the non-Dallas Video Klein sets.
+  - Added Witch Card (Video Klein CPU box, set 2)
+  - Added Witch Game (Video Klein, set 2)
+  - Some minor fixes.
+
+
+  [2012-02-19]
+
+  - Added Casino Poker (Ver PM86LO-35-5, German).
+  - Inputs from the scratch.
+  - Switched manufacturer 'Playman' to PM / Beck Elektronik, since
+     it's PM and Beck Elektronik/Computer/etc...
+  - Added technical and game notes.
+
+
+
+  TODO:
+
+  - Missing PIA connections.
+  - Code analysis, Inputs & lamps for Royale.
+  - Final cleanup and split the driver.
 
 
-    * Witch Card (spanish sets)
-
-    This game is derivated from Golden Poker.
-
-    The hardware has a feature called BLUE KILLER.
-    Using the original intensity line, the PCB has a bridge
-    that allow (as default) turn the background black.
-
-    Except goodluck, all other games running in this hardware
-    were designed to wear black background.
-
-    - Settings:
-
-    There are 12 parameters to program. All of them are unknown.
-    To program them, enter the settings mode with F2 and use the HOLD keys,
-    CANCEL key, DEAL + HOLD keys, and DEAL + CANCEL. To exit the mode press BET.
-
-    Settings are still unknown, but put the max value for each parameter to allow
-    all the game features.
-
-    First Line:  32 32 32 32 32 64
-    Second Line: 40 40 40 40 50 16
-
-    - Play:
-
-    The game is like other poker games, but with 2 jokers.
-    Each time you win a hand, a double up game appear...
-
-    - Double Up:
-
-    You must to choose High or Low to guess the card. If you win,
-    you can take the credits or continue into double up.
-    Each time you win a double up hand, the card is indicated on the screen.
-    The first 3 consecutive winning hands will add a witch with a running number.
-    Further winning hands only add the card/kind indication. When you lose, or
-    take your credits, the 3 witches start to roll their own numbers like a
-    slot machine. There is an attempt for each winning hand. the bonus ends when
-    you win a prize, or when all attempts are done.
-
-
-    * Super Loco 93
-
-    I like this game!... This one has nothing to do with poker games.
-    The objective is to get the higher sum with 2 or 3 cards. Is clearly
-    based on a passage (Envido) of the famous argentine's game called "Truco".
-
-    - How to play?...
-
-    Like in Truco's envido, You must add 20 to the sum of your cards.
-    If you have 7 and 5 of the same kind, you have 7 + 5 + 20 = 32 points.
-
-    "Flor", is 3 cards of the same kind.
-    "Simple", is 2 cards of the same kind.
-
-    HAND             WIN    DESCRIPTION
-    ----------------------------------------------
-    38  Corazones   1000    7, 6 and 5 of hearts.
-    777 Loco Loco    200    3x sevens.
-    38  Flor          80    7, 6 and 5 of the same kind (except hearts).
-    37  Flor          20    7, 6 and 4 of the same kind.
-    36  Flor          14    7, 5 and 4 of the same kind.
-    35  Flor          10    6, 5 and 4 of the same kind.
-    32-33-34 Flor      6    3 of the same kind that sum 32, 33 or 34.
-    33  Simple         4    7 and 6 of the same kind.
-    32  Simple         2    7 and 5 of the same kind.
-
-    After bet (apuesta) some credits, Press deal (reparte) button.
-    The game will deals 3 cards. You can discard up to all your 3 cards.
-    Pressing the deal button again, new cards will appear in the place
-    of the previously selected cards.
-
-    - Double Up:
-
-    You must to choose Red or Black to guess the card.
-    If you win, you can take the credits or continue into double up.
-    The rest is similar to Witch Card, but with 3 big numbers instead of
-    witches. Once you lose or take your credits, the big numbers start to
-    run 'alla' slot game, giving 1 attempt by each time you won a double-up
-    hand.
-
-    - Settings:
-
-    There are 12 parameters to program.
-    To program them, use the HOLD keys, CANCEL key, DEAL + HOLD keys,
-    and DEAL + CANCEL.
-
-
-    * Wild Witch / Jolli Witch
-
-    These sets have a switch to change the game. Wild Witch comes with a complete
-    Witch Game as switchable alternative, and Jolli Witch has Witch Card in the same
-    package. Both are based in the 6T/12T program made by Video Klein, However, Jolli
-    Witch seems to be a bootleg CPU box on an original Bonanza mainboard.
-
-    The first time the game boots, will show a black & red screen with some options
-    due to the lack or corrupt NVRAM. You must choose HOLD1 to create a new default
-    NVRAM. In case you have corrupt NVRAM (not first boot), you can choose HOLD5 to
-    attempt recover the old settings.
-
-
-    * Witch Card (Proma)
-
-    For the first time: You must coin-up and play at least one hand, then Payout
-    to get the proper coinage settings.
-
-
-*******************************************************************************
-
-
-    Hardware Notes (pmpoker):
-
-    - CPU:            1x M6502.
-    - Video:          1x MC6845.
-    - RAM:            4x uPD2114LC
-    - I/O             2x 6821 PIAs.
-    - prg ROMs:       3x 2732 (32Kb) or similar.
-    - gfx ROMs:       4x 2716 (16Kb) or similar.
-    - sound:          (discrete).
-    - battery backup: 2x S8423
-
-
-    PCB Layout (pmpoker): (XX) = unreadable.
-     _______________________________________________________________________________
-    |   _________                                                                   |
-    |  |         |               -- DIP SW x8 --                                    |
-    |  | Battery |   _________   _______________   _________  _________   ________  |
-    |  |   055   |  | 74LS32  | |1|2|3|4|5|6|7|8| | HCF4011 || HCF4096 | | LM339N | |
-    |  |_________|  |_________| |_|_|_|_|_|_|_|_| |_________||_________| |________| |
-    |       _________     _________   _________   _________                         |
-    |      | 74LS138 |   | S-8423  | | 74LS08N | | 74LS(XX)|                        |
-    |      |_________|   |_________| |_________| |_________|                        |
-    |  _______________    _________   ____________________                      ____|
-    | |               |  | S-8423  | |                    |                    |
-    | |     2732      |  |_________| |       6502P        |                    |
-    | |_______________|   _________  |____________________|                    |
-    |  _______________   |  7432   |  ____________________                     |____
-    | |               |  |_________| |                    |                     ____|
-    | |     2732      |   _________  |       6821P        |                     ____|
-    | |_______________|  | 74LS157 | |____________________|                     ____|
-    |  _______________   |_________|  ____________________                      ____|
-    | |               |   _________  |                    |                     ____|
-    | |     2732      |  | 74LS157 | |       6821P        |                     ____|
-    | |_______________|  |_________| |____________________|                     ____|
-    |  _______________    _________   ____________________                      ____|
-    | |               |  | 74LS157 | |                    |                     ____|
-    | |     2732      |  |_________| |       6845SP       |                     ____|
-    | |_______________|   _________  |____________________|                     ____|
-    |                    | 2114-LC |                                            ____| 28x2
-    |                    |_________|                                            ____| connector
-    |       _________     _________                                             ____|
-    |      | 74LS245 |   | 2114-LC |                                            ____|
-    |      |_________|   |_________|                                            ____|
-    |       _________     _________               _________                     ____|
-    |      | 74LS245 |   | 2114-LC |             | 74LS174 |                    ____|
-    |      |_________|   |_________|             |_________|                    ____|
-    |  ________________   _________   _________   _________                     ____|
-    | |                | | 2114-LC | | 74LS08H | | TI (XX) | <-- socketed.      ____|
-    | |      2716      | |_________| |_________| |_________|       PROM         ____|
-    | |________________|              _________   _________                     ____|
-    |  ________________              | 74LS04P | | 74LS174 |                    ____|
-    | |                |             |_________| |_________|                    ____|
-    | |      2716      |              _________   _________                     ____|
-    | |________________|             | 74166P  | | 74LS86C |                    ____|
-    |  ________________              |_________| |_________|                    ____|
-    | |                |              _________    _______                     |
-    | |      2716      |             | 74166P  |  | 555TC |                    |
-    | |________________|             |_________|  |_______|                    |
-    |  ________________                                                        |____
-    | |                |                                                        ____|
-    | |      2716      |              _________   _________      ________       ____| 5x2
-    | |________________|             | 74166P  | |  7407N  |    | LM380N |      ____| connector
-    |                                |_________| |_________|    |________|      ____|
-    |  ________  ______               _________   _________      ___            ____|
-    | | 74LS04 || osc. |             | 74LS193 | |  7407N  |    /   \          |
-    | |________||10 MHz|             |_________| |_________|   | POT |         |
-    |           |______|                                        \___/          |
-    |__________________________________________________________________________|
-
-
-
-    Some odds:
-
-    - There are unused pieces of code like the following sub:
-
-    78DE: 18         clc
-    78DF: 69 07      adc  #$07
-    78E1: 9D 20 10   sta  $1020,x
-    78E4: A9 00      lda  #$00
-    78E6: 9D 20 18   sta  $1820,x
-    78E9: E8         inx
-
-    78EA: 82         DOP        ; use of DOP (double NOP)
-    78EB: A2 0A      dummy (ldx #$0A)
-
-    78ED: AD 82 08   lda  $0882
-
-    78F0: 82         DOP        ; use of DOP (double NOP)
-    78F1: 48 08      dummy
-    78F3: D0 F6      bne  $78EB ; branch to the 1st DOP dummy arguments (now ldx #$0A).
-    78F5: CA         dex
-    78F6: D0 F8      bne  $78F0
-    78F8: 29 10      and  #$10
-    78FA: 60         rts
-
-    Offset $78EA and $78F0 contains an undocumented 6502 opcode (0x82).
-
-    At beginning, I thought that the main processor was a 65sc816, since 0x82 is a documented opcode (BRL) for this CPU.
-    Even the vector $FFF8 contain 0x09 (used to indicate "Emulation Mode" for the 65sc816).
-    I dropped the idea following the code. Impossible to use BRL (branch relative long) in this structure.
-
-    Some 6502 sources list the 0x82 mnemonic as DOP (double NOP), with 2 dummy bytes as argument.
-    The above routine dynamically change the X register value using the DOP undocumented opcode.
-    Since the opcode DOP in fact has only 1 dummy byte as argument, they apparently dropped this
-    piece of code due to it didn't work as expected. Now all have sense.
-
-
-*******************************************************************************
-
-
-    -----------------------------------------------
-    ***  Memory Map (pmpoker/goldnpkr hardware) ***
-    -----------------------------------------------
-
-    $0000 - $00FF   RAM     ; Zero Page (pointers and registers)
-
-                            ; $45 to $47 - Coin settings.
-                            ; $50 - Input port register.
-                            ; $5C - Input port register.
-                            ; $5D - Input port register.
-                            ; $5E - Input port register.
-                            ; $5F - Input port register.
-
-    $0100 - $01FF   RAM     ; 6502 Stack Pointer.
-
-    $0200 - $02FF   RAM     ; R/W. (settings)
-    $0300 - $03FF   RAM     ; R/W (mainly to $0383). $0340 - $035f (settings).
-
-    $0800 - $0801   MC6845  ; MC6845 use $0800 for register addressing and $0801 for register values.
-
-                            *** pmpoker mc6845 init at $65B9 ***
-                            *** goldnpkr mc6845 init at $5E75 ***
-                            *** sloco93 mc6845 init at $D765 ***
-                            register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
-                            value:     0x27  0x20  0x22  0x02  0x1F  0x04  0x1D  0x1E  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
-
-                            *** goodluck mc6845 init at $527B ***
-                            register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
-                            value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1F  0x00  0x00  0x26  0x00  0x20  0x22  0x58  0xA5  0x4F  0xC9.
-
-                            *** witchcrd mc6845 init at $D765 ***
-                            register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
-                            value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1F  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
-
-                            *** witchcrd (Video Klein) mc6845 init at $627B ***
-                            register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
-                            value:     0x27  0x20  0x23  0x33  0x1F  0x04  0x1D  0x1F  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
-
-                            *** witchcrd (Video Klein) mc6845 mod at $6293 ($2000 and #$20) ***
-                            register:   04    05    06    07
-                            value:     0x26  0x00  0x20  0x22
-
-                            *** royale mc6845 init at $6581 ***
-                            register:   00    01    02    03    04    05    06    07    08    09    10    11    12    13    14    15    16    17
-                            value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1D  0x1E  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
-
-    $0844 - $0847   PIA0    ; Muxed inputs and lamps. Initialized at $5000.
-    $0848 - $084B   PIA1    ; Sound writes and muxed inputs selector. Initialized at $5000.
-
-    $1000 - $13FF   Video RAM   ; Initialized in subroutine starting at $5042.
-    $1800 - $1BFF   Color RAM   ; Initialized in subroutine starting at $5042.
-
-    $4000 - $7FFF   ROM
-
-    $8000 - $FFFF           ; Mirrored from $0000 - $7FFF due to lack of A15 line connection.
-
-
-
-    ---------------------------------------
-    ***  Memory Map (pottnpkr hardware) ***
-    ---------------------------------------
-
-    $0000 - $00FF   RAM     ; Zero Page (pointers and registers)
-    $0100 - $01FF   RAM     ; 6502 Stack Pointer.
-    $0200 - $02FF   RAM     ; R/W. (settings)
-    $0300 - $03FF   RAM     ; R/W (mainly to $0383). $0340 - $035f (settings).
-
-    $0800 - $0801   MC6845  ; MC6845 use $0800 for register addressing and $0801 for register values.
-
-    $0844 - $0847   PIA0    ; Muxed inputs and lamps.
-    $0848 - $084B   PIA1    ; Sound writes and muxed inputs selector.
-
-    $1000 - $13FF   Video RAM
-    $1800 - $1BFF   Color RAM
-
-    $2000 - $3FFF   ROM space
-
-    $4000 - $7FFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
-    $8000 - $BFFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
-    $C000 - $FFFF           ; Mirrored from $0000 - $3FFF due to lack of A14 & A15 lines connection.
-
-
-
-*******************************************************************************
-
-
-    Buttons/Inputs   goldnpkr goldnpkb  pmpoker  bsuerte goodluck pottnpkr potnpkra potnpkrc potnpkrb
-    -------------------------------------------------------------------------------------------------
-
-    HOLD (5 buttons)  mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    CANCEL            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    BIG               mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
-    SMALL             mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
-    DOUBLE UP         mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
-    TAKE SCORE        mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
-    DEAL/DRAW         mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    BET               mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-
-    Coin 1 (coins)    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    Coin 2 (notes)    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   fixed 1c-1c
-    Coin 3 (coupons)  mapped   mapped   mapped   mapped    ----     ----     ----     ----     ----
-    Payout            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    Manual Collect    mapped   mapped   mapped    ----    mapped   mapped   mapped   mapped   mapped
-
-    LEARN/SETTINGS    mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-    METERS            mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped   mapped
-
-
-    Inputs are different for some games. Normally each button has only one function.
-    In pmpoker some buttons have different functions.
-
-
-*******************************************************************************
-
-
-    DRIVER UPDATES:
-
-
-    [2006-09-02]
-
-    - Initial release.
-
-
-    [2006-09-06]
-
-    - Understood the GFX banks:
-        - 1 bank (1bpp) for text layer and minor graphics.
-        - 1 bank (3bpp) for the undumped cards deck graphics.
-
-    - Partially added inputs through 6821 PIAs.
-        ("Bitte techniker rufen" error messages. Press 'W' to reset the machine)
-
-    - Confirmed the CPU as 6502. (was in doubt due to use of illegal opcodes)
-
-
-    [2006-09-15]
-
-    - Confirmed the GFX banks (a complete dump appeared!).
-    - Improved technical notes and added a PCB layout based on PCB picture.
-    - Found and fixed the 3rd bitplane of BigBoy gfx.
-    - Renamed Big-Boy to Golden Poker Double Up. (Big-Boy and Mini-Boy are names of cabinet models).
-    - Added 'Joker Poker' (Golden Poker version without the 'double-up' feature).
-    - Added 'Jack Potten's Poker' (same as Joker Poker, but with 'Aces or better' instead of jacks).
-    - Simulated colors for all sets till color PROMs appear.
-    - Fixed bit corruption in goldnpkr rom u40_4a.bin.
-    - Completed inputs in all sets (except DIP switches).
-    - Removed flags GAME_WRONG_COLORS and GAME_IMPERFECT_GRAPHICS in all sets.
-    - Removed flag GAME_NOT_WORKING. All sets are now playable. :)
-
-
-    [2006-10-09]
-
-    - Added service/settings mode to pmpoker.
-    - Added PORT_IMPULSE to manage correct timings for most inputs in all games.
-      (jokerpkr still trigger more than 1 credit for coin pulse).
-
-
-    [2007-02-01]
-
-    - Crystal documented via #define.
-    - CPU clock derived from #defined crystal value.
-    - Replaced simulated colors with proper color prom decode.
-    - Renamed "Golden Poker Double Up" to "Golden Poker Double Up (Big Boy)".
-    - Added set Golden Poker Double Up (Mini Boy).
-    - Cleaned up the driver a bit.
-    - Updated technical notes.
-
-
-    [2007-05-05]
-
-    - Removed all inputs hacks.
-    - Connected both PIAs properly.
-    - Demuxed all inputs for each game.
-    - Documented all outputs.
-    - Added lamps support.
-    - Created different layout files to cover each game.
-    - Add NVRAM support to all games.
-    - Corrected the color PROM status for each set.
-    - Figured out most of the DIP switches.
-    - Added diplocations to goldnpkb.
-    - Replaced the remaining IPT_SERVICE with IPT_BUTTON for regular buttons.
-    - Updated technical notes.
-    - Cleaned up the driver. Now is better organized and documented.
-
-
-    [2007-07-07]
-
-    - Added set goldnpkc (Golden Poker without the double up feature).
-    - Updated technical notes.
-
-
-    [2008-10-12] *** REWRITE ***
-
-    - Added discrete sound support to Golden Poker hardware games based on schematics.
-    - Added discrete sound support to Potten's Poker hardware games based on PCB analysis.
-    - Added discrete circuitry diagrams for both hardware types.
-    - Adjusted the CPU addressing to 15 bits for pmpoker/goldenpkr hardware.
-    - Adjusted the CPU addressing to 14 bits for pottnpkr hardware.
-    - Rewrote all the ROM loads based on these changes.
-    - Defined MASTER Xtal & CPU clock.
-    - Fixed the visible area based on M6845 registers.
-    - Improved the lamps layouts to be more realistic.
-    - Added Good Luck (potten's poker hybrid running in goldnpkr hardware).
-    - Added Buena Suerte (spanish) x 2 sets.
-    - Added set Royale.
-    - Added Witch Card and spanish variants.
-    - Added Super Loco 93 (spanish) x 2 sets.
-    - Renamed set goldnpkc to pottnpkr (parent Jack Potten's Poker set).
-    - Renamed set jokerpkr to potnpkra, since is another Jack Potten's Poker set.
-    - Added other 2 clones of Jack Potten's Poker.
-    - Renamed/cleaned all sets based on code/hardware analysis.
-    - Added intensity bit to the color system.
-    - Implemented the blue killer bit for Witch Card hardware.
-    - Implemented the extended graphics addressing bit for Witch Card hardware.
-    - Added proper visible area to sloco93.
-    - Rewrote the graphics & color decode system based on schematics. No more patched codes.
-    - Changed the char gfx bank structure and rom load according to the new routines.
-    - Adjusted the amount of color codes and PROM region size accordingly.
-    - Updated all notes.
-
-
-    [2008-11-29] *** REWRITE (part II) ***
-
-    - Changed the driver name to goldnpkr.c (Golden Poker is the most representative hardware).
-    - Splitted the PIA interfases to cover witchcrd/pottenpkr connections.
-    - Fixed the witchcrd/pottnpkr/sloco93 double up mode.
-    - Replaced the pottenpkr layout with goldnpkr one in all Jack Potten's Poker sets.
-    - Updated game notes for Witch Card and Super Loco 93 sets.
-    - Fixed al inputs & lamps to allow double up mode to the above games.
-    - Added Witch Card (Video Klein) but still not working.
-    - Added several Buena Suerte! sets.
-    - Added new games: Maverik, Brasil 89 & Poker'91.
-    - Reworked the sets parent-clone relationship (still in progress).
-
-
-    [2008-12-26]
-
-    - Correctly setup the MC6845 device for all systems.
-    - Added common MC6845 device interface.
-    - Merged witchcrd and sloco93 machine drivers.
-    - Added/corrected the 50/60 Hz. DIP switches to all games.
-      The 50hz mode needs to be corrected. Some games as most bsuerte sets have
-      the 50/60 Hz. DIP switch connection patched.
-
-
-    [2009-09-05]
-
-    - Added 2 new Witch Card sets.
-    - Reworked inputs for Witch Card (german set 1).
-    - Created new inputs for Witch Card (english, witch game, lamps).
-    - Added and connected lamps for both sets.
-    - Added minimal bet and 50/60 Hz. switches to both sets.
-    - Added DIP switches info for Witch Card (german, set 2).
-
-
-    - Added Genius, running in a modified Golden Poker board.
-
-
-    [2010-09-28]
-
-    - Added 3 new Witch Card sets.
-    - Added 3 new Falcons Wild sets (from 3 different hardwares).
-    - Hooked the second CPU (still encrypted) to the Falcon hardware.
-    - Partially decrypted the second CPU program from Falcon hardware.
-    - Figured out the Falcons Wild (Video Klein) memory map and machine.
-    - Defeated the evil Video Klein's Witch Card hardware.
-    - Reworked inputs for some sets.
-    - Added lamps layouts/connections to the new sets.
-    - Figured out the multiplexed data/address from Falcon's boards sound.
-    - Added full sound support to Falcon hardware.
-    - Reorganized and partially cleaned-up the driver.
-    - Added more technical notes.
-
-
-    [2010-11-18]
-
-    - Added Karateco Super Double (french)
-    - Extended ROM space for goldnpkr game to include the 0x2000..0x3fff range
-
-
-    [2011-01-20]
-
-    - Lots of changes to get working the Video Klein games.
-    - Renamed witchcde to witchjol --> Jolly Witch (Export, 6T/12T ver 1.57D).
-    - Added Wild Witch (Export, 6T/12T ver 1.74A).
-    - New video hardware and machine driver for Video Klein's extended tiles games.
-    - Added Dallas DS1210 + battery backed RAM support to the Video Klein CPU boxed games.
-    - Improved inputs for Jolli Witch and Wild Witch. Added the game selector switch.
-    - Cleaned up some witch card sets.
-    - Added technical and game notes.
-
-
-    [2011-10-19]
-
-    - Mapped the Dallas DS1210 for Video Klein sets that have one.
-    - Mapped the 2800-2fff range as RAM for the non-Dallas Video Klein sets.
-    - Added Witch Card (Video Klein CPU box, set 2)
-    - Added Witch Game (Video Klein, set 2)
-    - Some minor fixes.
-
-
-    TODO:
-
-    - Missing PIA connections.
-    - Code analysis, Inputs & lamps for Royale.
-    - Final cleanup and split the driver.
-
-
-*******************************************************************************/
+************************************************************************************/
 
 
 #define MASTER_CLOCK	XTAL_10MHz
@@ -708,7 +822,7 @@
 #include "sound/discrete.h"
 #include "machine/nvram.h"
 
-/* Extra CPUs, MCUs, etc... */
+/* Extra CPUs, MCUs, devices, etc... */
 #include "cpu/z80/z80.h"
 #include "sound/ay8910.h"
 
@@ -1016,35 +1130,35 @@
 
 /***** Lamps wiring *****
 
-    -------------------
-    pmpoker
-    -------------------
-    L0 = Deal
-    L1 = Hold3
-    L2 = Hold1
-    L3 = Hold5
-    L4 = Hold2 & Hold4
-
-    -----------------------
-    goldnpkr sets & bsuerte
-    -----------------------
-    L0 = Bet
-    L1 = Deal
-    L2 = Holds (all)
-    L3 = Double Up & Take
-    L4 = Big & Small
-
-    ----------------------------------
-    pottnpkr sets, jokerpkr & goodluck
-    ----------------------------------
-    L0 = Bet
-    L1 = Deal
-    L2 = Holds (all)
-
-    ------------------
-    witchcrd & sloco93
-    ------------------
-    NONE. Just they lack of lamps...
+  -------------------
+  pmpoker
+  -------------------
+  L0 = Deal
+  L1 = Hold3
+  L2 = Hold1
+  L3 = Hold5
+  L4 = Hold2 & Hold4
+
+  -----------------------
+  goldnpkr sets & bsuerte
+  -----------------------
+  L0 = Bet
+  L1 = Deal
+  L2 = Holds (all)
+  L3 = Double Up & Take
+  L4 = Big & Small
+
+  ----------------------------------
+  pottnpkr sets, jokerpkr & goodluck
+  ----------------------------------
+  L0 = Bet
+  L1 = Deal
+  L2 = Holds (all)
+
+  ------------------
+  witchcrd & sloco93
+  ------------------
+  NONE. Just they lack of lamps...
 
 */
 
@@ -2621,6 +2735,75 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( caspoker )
+	/* Multiplexed - 4x5bits */
+	PORT_START("IN0-0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_GAMBLE_BOOK ) PORT_NAME("Bookkeeping")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_DEAL ) PORT_NAME("Deal / Draw")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_IMPULSE(3) PORT_NAME("Out (Manual Collect)") PORT_CODE(KEYCODE_Q)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON7 ) PORT_NAME("Payout") PORT_CODE(KEYCODE_W)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_POKER_HOLD1 ) PORT_NAME("Hold 1 / Take Score (Kasse)")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_POKER_HOLD2 ) PORT_NAME("Hold 2 / Small (Tief)")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_POKER_HOLD3 ) PORT_NAME("Hold 3 / Bet (Setzen)")
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_POKER_HOLD4 ) PORT_NAME("Hold 4 / Big (Hoch)")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_POKER_HOLD5 ) PORT_NAME("Hold 5 / Double Up (Doppeln)")
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Settings") PORT_CODE(KEYCODE_F2)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN3 )   PORT_IMPULSE(3)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )   PORT_IMPULSE(3)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN1 )   PORT_IMPULSE(3)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN4 )   PORT_IMPULSE(3)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("SW1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
+
 
 /*********************************************
 *              Graphics Layouts              *
@@ -3629,8 +3812,8 @@
 	ROM_LOAD( "wc3050.a5",	0x4000, 0x2000, CRC(6f35b9c4) SHA1(df86687164f18f2bfe71e73cccd28fe4117e748c) )    /* text layer, alt gfx */
 
 	ROM_REGION( 0x6000, "gfx2", 0 )
-	ROM_LOAD( "wch1.a2",	0x0000, 0x2000, CRC(10b34856) SHA1(52e4cc81b36b4c807b1d4471c0f7bea66108d3fd) )    /* cards deck gfx, bitplane1 */
-	ROM_LOAD( "wch2.a4",	0x2000, 0x2000, CRC(5fc965ef) SHA1(d9ecd7e9b4915750400e76ca604bec8152df1fe4) )    /* cards deck gfx, bitplane2 */
+	ROM_LOAD( "wc1(__witchcdh).a2",	0x0000, 0x2000, CRC(10b34856) SHA1(52e4cc81b36b4c807b1d4471c0f7bea66108d3fd) )    /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "wc1(__witchcdh).a4",	0x2000, 0x2000, CRC(5fc965ef) SHA1(d9ecd7e9b4915750400e76ca604bec8152df1fe4) )    /* cards deck gfx, bitplane2 */
 	ROM_COPY( "gfx1",	0x4800, 0x4000, 0x0800 )    /* cards deck gfx, bitplane3. found in the 2nd quarter of the text layer rom */
 
 	ROM_REGION( 0x0100, "proms", 0 )
@@ -3728,11 +3911,11 @@
 
 	ROM_REGION( 0x3000, "gfx1", 0 )
 	ROM_FILL(			 0x0000, 0x2000, 0 ) /* filling the R-G bitplanes */
-	ROM_LOAD( "wc4.7a_bad",	 0x2000, 0x1000, BAD_DUMP CRC(3bf07c44) SHA1(f6e859b142b7d4585b89ca609d8bc85c84fe2b09) )    /* text chars, corrupt */
+	ROM_LOAD( "wc4(__baddump).7a",	 0x2000, 0x1000, BAD_DUMP CRC(3bf07c44) SHA1(f6e859b142b7d4585b89ca609d8bc85c84fe2b09) )    /* text chars, corrupt */
 	ROM_COPY( "gfx1",    0x2800, 0x2000, 0x0800 )	/* srctag, srcoffs, offset, length */
 
 	ROM_REGION( 0x3000, "gfx2", 0 )
-	ROM_LOAD( "wck1.2a",	0x0000, 0x1000, CRC(f59c6fd2) SHA1(bea4b6043728311ca9fff36e2d7e24254af5b97a) )    /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "wc1(__witchcdk).2a",	0x0000, 0x1000, CRC(f59c6fd2) SHA1(bea4b6043728311ca9fff36e2d7e24254af5b97a) )    /* cards deck gfx, bitplane1 */
 	ROM_LOAD( "wc2.4a",	0x1000, 0x1000, CRC(40e426af) SHA1(7e7cb30dafc96bcb87a05d3e0ef5c2d426ed6a74) )    /* cards deck gfx, bitplane2 */
 	ROM_LOAD( "wc3.5a",	0x2000, 0x1000, CRC(232374f3) SHA1(b75907edbf769b8c46fb1ebdb301c325c556e6c2) )    /* cards deck gfx, bitplane3 */
 
@@ -4184,10 +4367,10 @@
 	ROM_LOAD( "fw4.7a",	0x1000, 0x0800, CRC(f0517b0d) SHA1(474bcf429f2539ff1f3d7d32d259c5973ccb0234) )  /* text layer */
 
 	ROM_REGION( 0x1800, "gfx2", 0 )
-	ROM_LOAD( "fw1.2a_bad",	0x0000, 0x0800, BAD_DUMP CRC(229cedde) SHA1(5b6d0b900714924c7a2390151ee65f36bdb02e8b) )  /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "fw1.2a(__baddump)",	0x0000, 0x0800, BAD_DUMP CRC(229cedde) SHA1(5b6d0b900714924c7a2390151ee65f36bdb02e8b) )  /* cards deck gfx, bitplane1 */
 	ROM_IGNORE(                 0x0800)
-	ROM_LOAD( "fw2.4a_bad",	0x0800, 0x0800, BAD_DUMP CRC(9ad3c578) SHA1(a69385a807e3270d90040c44721bfff21e95706a) )  /* cards deck gfx, bitplane2 */
-	ROM_LOAD( "fw3.5a_bad",	0x1000, 0x0800, BAD_DUMP CRC(87abebe5) SHA1(5950082b563718476576dbc9f45439019209493e) )  /* cards deck gfx, bitplane3 */
+	ROM_LOAD( "fw2.4a(__baddump)",	0x0800, 0x0800, BAD_DUMP CRC(9ad3c578) SHA1(a69385a807e3270d90040c44721bfff21e95706a) )  /* cards deck gfx, bitplane2 */
+	ROM_LOAD( "fw3.5a(__baddump)",	0x1000, 0x0800, BAD_DUMP CRC(87abebe5) SHA1(5950082b563718476576dbc9f45439019209493e) )  /* cards deck gfx, bitplane3 */
 
 	ROM_REGION( 0x0100, "proms", 0 )
 	ROM_LOAD( "n82s137f.box",	0x0000, 0x0100, BAD_DUMP CRC(7f31066b) SHA1(15420780ec6b2870fc4539ec3afe4f0c58eedf12) )
@@ -4686,45 +4869,96 @@
 ROM_END
 
 
+/***************************************************************
+
+  Casino Poker
+  1987, PM / Beck Elektronik
+
+  1x Xtal 10.000 MHz.
+  1x UM6502A
+  2x UM6521A
+  1x UM6845
+
+  GFX ROMS 051, 052, 053 and 054 have duplicated halves.
+
+  Bipolar PROM 24sa10 is filled with 0x09, so has at least
+  fixed bits 0 and 3 along the whole data. Needs a redump
+  using a supported EEPROM programmer.
+
+  Discrete sound circuitry was traced, being identical to the Golden Poker one.
+  Only difference is the PC617 replaced by one PC817.
+
+  The sound is ugly and seems that was programmed that way.
+
+***************************************************************/
+
+ROM_START( caspoker )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "234.bin",	0x4000, 0x1000, CRC(174bc526) SHA1(faef01484f0e0ea769d7bd2c5ad03369a6fdf037) )
+	ROM_LOAD( "235.bin",	0x5000, 0x1000, CRC(2e43552f) SHA1(5fbe0e62dec960850ef5f937254858fcd4da9e64) )
+	ROM_LOAD( "236.bin",	0x6000, 0x1000, CRC(3f4cfa39) SHA1(e2750a9c5d12c668e599181ee3972c5d78bd0006) )
+	ROM_LOAD( "237.bin",	0x7000, 0x1000, CRC(b411d0c4) SHA1(0617cd312026da78a171fc23f4788393d70371cf) )
+
+	ROM_REGION( 0x1800, "gfx1", 0 )
+	ROM_FILL(				0x0000, 0x1000, 0 ) /* filling the R-G bitplanes */
+	ROM_LOAD( "054.bin",	0x1000, 0x0800, CRC(7b401a09) SHA1(affb90a52761c36be7c67f7606f3f982f6dc724e) )    /* text chars */
+	ROM_IGNORE(                     0x0800)	/* identical halves, discarding the 2nd half */
+
+	ROM_REGION( 0x1800, "gfx2", 0 )
+	ROM_LOAD( "051.bin",	0x0000, 0x0800, CRC(82d823e5) SHA1(75bdf427a6204ef87444be0d8b06a07c5a2fc38f) )    /* cards deck gfx, bitplane1 */
+	ROM_IGNORE(                     0x0800)	/* identical halves, discarding the 2nd half */
+	ROM_LOAD( "052.bin",	0x0800, 0x0800, CRC(eda12738) SHA1(ec7806c2bf1a238f489459c3c3653f43febaa464) )    /* cards deck gfx, bitplane2 */
+	ROM_IGNORE(                     0x0800)	/* identical halves, discarding the 2nd half */
+	ROM_LOAD( "053.bin",	0x1000, 0x0800, CRC(d147ae0a) SHA1(dfdf0a42eb0a6f2afc9f301b0cf01411085247bd) )    /* cards deck gfx, bitplane3 */
+	ROM_IGNORE(                     0x0800)	/* identical halves, discarding the 2nd half */
+
+	ROM_REGION( 0x0800,	"nvram", 0 )	/* default NVRAM, otherwise settings parameters are incorrect */
+	ROM_LOAD( "caspoker_nvram.bin", 0x0000, 0x0800, CRC(be6e2671) SHA1(aef1b09d09e07eb39480a7901ed8535f74e461fa) )
+
+	ROM_REGION( 0x0100, "proms", 0 )	/* from other games */
+	ROM_LOAD( "24sa10.bin",	0x0000, 0x0100, BAD_DUMP CRC(7f31066b) SHA1(15420780ec6b2870fc4539ec3afe4f0c58eedf12) ) /* PROM dump needed */
+ROM_END
+
+
 /*********************************************
 *                Driver Init                 *
 *********************************************/
 
 /*
-    Golden Poker H/W sets:
+  Golden Poker H/W sets:
 
-    newname    oldname    gameplay  music      settings    testmode
-    ===================================================================
-    pmpoker    pmpoker    fast      minimal    hack        matrix/grill
-    goldnpkr   goldnpkr   fast      y.doodle   excellent   matrix/grill
-    goldnpkb   goldnpkb   normal    minimal    normal      matrix/grill
-
-
-    Potten's Poker H/W sets:
-
-    newname    oldname    gameplay  music      settings    testmode
-    ===================================================================
-    pottnpkr   goldnpkc   fast      y.doodle   normal      only grid
-    potnpkra   jokerpkr   normal    normal     normal      only skill
-    potnpkrb   pottnpkb   slow      y.doodle   normal      only grid
-    potnpkrc   pottnpkr   normal    minimal    hack        only skill
-    potnpkrd   --------   normal    minimal    hack        only skill
-    potnpkre   --------   slow      y.doodle   normal      matrix/grill
-
-
-    Witch Card H/W sets:
-
-    newname    oldname    gameplay  music      settings    testmode
-    ===================================================================
-    bsuerte    --------   normal    minimal    only 1-10   matrix/grill
-    bsuertea   --------   normal    minimal    only 1-10   matrix/grill
-    goodluck   --------   fast      y.doodle   normal      matrix/grill
-    royale     --------
-    witchcrd   --------   normal    y.doodle   12-param    only grid
-    witchcda   --------   fast      y.doodle   12-param    only grid
-    witchcdb   --------   normal    y.doodle   12-param    only grid
-    sloco93    --------   fast      custom     complete    only grid
-    sloco93a   --------   fast      custom     complete    only grid
+  newname    oldname    gameplay  music      settings    testmode
+  ===================================================================
+  pmpoker    pmpoker    fast      minimal    hack        matrix/grill
+  goldnpkr   goldnpkr   fast      y.doodle   excellent   matrix/grill
+  goldnpkb   goldnpkb   normal    minimal    normal      matrix/grill
+
+
+  Potten's Poker H/W sets:
+
+  newname    oldname    gameplay  music      settings    testmode
+  ===================================================================
+  pottnpkr   goldnpkc   fast      y.doodle   normal      only grid
+  potnpkra   jokerpkr   normal    normal     normal      only skill
+  potnpkrb   pottnpkb   slow      y.doodle   normal      only grid
+  potnpkrc   pottnpkr   normal    minimal    hack        only skill
+  potnpkrd   --------   normal    minimal    hack        only skill
+  potnpkre   --------   slow      y.doodle   normal      matrix/grill
+
+
+  Witch Card H/W sets:
+
+  newname    oldname    gameplay  music      settings    testmode
+  ===================================================================
+  bsuerte    --------   normal    minimal    only 1-10   matrix/grill
+  bsuertea   --------   normal    minimal    only 1-10   matrix/grill
+  goodluck   --------   fast      y.doodle   normal      matrix/grill
+  royale     --------
+  witchcrd   --------   normal    y.doodle   12-param    only grid
+  witchcda   --------   fast      y.doodle   12-param    only grid
+  witchcdb   --------   normal    y.doodle   12-param    only grid
+  sloco93    --------   fast      custom     complete    only grid
+  sloco93a   --------   fast      custom     complete    only grid
 
 */
 static DRIVER_INIT( royale )
@@ -4916,7 +5150,7 @@
 GAME(  1991, witchcdc, witchcrd, witchcrd, witchcdc, 0,        ROT0,   "<unknown>",                "Witch Card (English, no witch game)",     0 )
 GAMEL( 1994, witchcdd, witchcrd, witchcrd, witchcdd, 0,        ROT0,   "Proma",                    "Witch Card (German, WC3050, set 1 )",     0,                layout_goldnpkr )
 GAMEL( 1991, witchcde, witchcrd, witchcrd, witchcrd, vkdlsc,   ROT0,   "Video Klein",              "Witch Card (Video Klein CPU box, set 2)", 0,                layout_goldnpkr )
-GAMEL( 1985, witchcdf, witchcrd, witchcrd, witchcdf, 0,        ROT0,   "PlayMan",                  "Witch Card (English, witch game, lamps)", 0,                layout_goldnpkr )
+GAMEL( 1985, witchcdf, witchcrd, witchcrd, witchcdf, 0,        ROT0,   "PM / Beck Elektronik",     "Witch Card (English, witch game, lamps)", 0,                layout_goldnpkr )
 GAMEL( 199?, witchcdg, witchcrd, wcfalcon, witchcrd, 0,        ROT0,   "Falcon",                   "Witch Card (Falcon, enhanced sound)",     0,                layout_goldnpkr )
 GAMEL( 1994, witchcdh, witchcrd, witchcrd, witchcdd, 0,        ROT0,   "Proma",                    "Witch Card (German, WC3050, set 2 )",     0,                layout_goldnpkr )
 GAMEL( 1994, witchcdi, witchcrd, witchcrd, witchcdd, 0,        ROT0,   "Proma",                    "Witch Card (German, WC3050, 27-4-94)",    0,                layout_goldnpkr )
@@ -4956,7 +5190,7 @@
 /*************************************** OTHER SETS ***************************************/
 
 /*     YEAR  NAME      PARENT    MACHINE   INPUT     INIT      ROT      COMPANY                     FULLNAME                                  FLAGS             LAYOUT  */
-GAMEL( 1981, pmpoker,  0,        goldnpkr, pmpoker,  0,        ROT0,   "PlayMan",                  "PlayMan Poker (German)",                  0,                layout_pmpoker  )
+GAMEL( 1981, pmpoker,  0,        goldnpkr, pmpoker,  0,        ROT0,   "PM / Beck Elektronik",     "PlayMan Poker (German)",                  0,                layout_pmpoker  )
 GAMEL( 198?, royale,   0,        goldnpkr, royale,   royale,   ROT0,   "<unknown>",                "Royale (set 1)",                          GAME_NOT_WORKING, layout_goldnpkr )
 GAMEL( 198?, royalea,  royale,   goldnpkr, royale,   royale,   ROT0,   "<unknown>",                "Royale (set 2)",                          GAME_NOT_WORKING, layout_goldnpkr )
 GAME(  1993, sloco93,  0,        witchcrd, sloco93,  0,        ROT0,   "<unknown>",                "Super Loco 93 (Spanish, set 1)",          0 )
@@ -4969,9 +5203,11 @@
 GAME(  1993, brasil93, 0,        witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                "Brasil 93",                               0 )				// no lamps
 GAME(  1991, poker91,  0,        witchcrd, poker91,  0,        ROT0,   "<unknown>",                "Poker 91",                                0 )
 GAME(  198?, genie,    0,        genie,    genie,    0,        ROT0,   "Video Fun Games Ltd.",     "Genie",                                   0 )
-
 GAMEL( 1983, silverga, 0,        goldnpkr, goldnpkr, 0,        ROT0,   "<unknown>",                "Silver Game",                             0,                layout_goldnpkr )
+GAME(  1987, caspoker, 0,        goldnpkr, caspoker, 0,        ROT0,   "PM / Beck Elektronik",     "Casino Poker (Ver PM86LO-35-5, German)",  GAME_IMPERFECT_COLORS )
+
 GAME(  198?, pokerdub, 0,        pottnpkr, goldnpkr, 0,        ROT0,   "<unknown>",                "unknown French poker game",               GAME_NOT_WORKING )	// lacks of 2nd program ROM.
 GAME(  198?, pokerduc, 0,        goldnpkr, goldnpkr, icp1db,   ROT0,   "<unknown>",                "unknown encrypted poker game",            GAME_NOT_WORKING )	// encrypted.
 
 
+
diff -Nru src-old/mame/drivers/goldstar.c src/mame/drivers/goldstar.c
--- src-old/mame/drivers/goldstar.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/goldstar.c	2012-02-22 00:51:07.000000000 +0100
@@ -7979,18 +7979,18 @@
 ROM_START( lucky8a )
 	ROM_REGION( 0x8000, "maincpu", 0 )
 	// we have to patch this, it might be bad
-	ROM_LOAD( "1_bad", 0x0000, 0x8000, BAD_DUMP CRC(554cddff) SHA1(8a0678993c7010f70adc9e9443b51cf5929bf110) )
+	ROM_LOAD( "1(__baddump)",  0x0000, 0x8000, BAD_DUMP CRC(554cddff) SHA1(8a0678993c7010f70adc9e9443b51cf5929bf110) )
 
 	ROM_REGION( 0x18000, "gfx1", 0 )
-	ROM_LOAD( "6a",  0x00000, 0x8000, CRC(59026af3) SHA1(3d7f7e78968ca26275635aeaa0e994468a3da575) )
-	ROM_LOAD( "7a",  0x08000, 0x8000, CRC(67a073c1) SHA1(36194d57d0dc0601fa1fdf2e6806f11b2ea6da36) )
-	ROM_LOAD( "8a",  0x10000, 0x8000, CRC(80b35f06) SHA1(561d257d7bc8976cfa08f36d84961f1263509b5b) )
+	ROM_LOAD( "6(__lucky8a)",  0x00000, 0x8000, CRC(59026af3) SHA1(3d7f7e78968ca26275635aeaa0e994468a3da575) )
+	ROM_LOAD( "7(__lucky8a)",  0x08000, 0x8000, CRC(67a073c1) SHA1(36194d57d0dc0601fa1fdf2e6806f11b2ea6da36) )
+	ROM_LOAD( "8(__lucky8a)",  0x10000, 0x8000, CRC(80b35f06) SHA1(561d257d7bc8976cfa08f36d84961f1263509b5b) )
 
 	ROM_REGION( 0x8000, "gfx2", 0 )
-	ROM_LOAD( "2a",  0x0000, 0x2000, CRC(29d6f197) SHA1(1542ca457594f6b7fe8f28f7d78023edd7021bc8) )
-	ROM_LOAD( "3a",  0x2000, 0x2000, CRC(5f812e65) SHA1(70d9ea82f9337936bf21f82b6961768d436f3a6f) )
-	ROM_LOAD( "4a",  0x4000, 0x2000, CRC(898b9ed5) SHA1(11b7d1cfcf425d00d086c74e0dbcb72068dda9fe) )
-	ROM_LOAD( "5a",  0x6000, 0x2000, CRC(4f7cfb35) SHA1(0617cf4419be00d9bacc78724089cb8af4104d68) )
+	ROM_LOAD( "2(__lucky8a)",  0x0000, 0x2000, CRC(29d6f197) SHA1(1542ca457594f6b7fe8f28f7d78023edd7021bc8) )
+	ROM_LOAD( "3(__lucky8a)",  0x2000, 0x2000, CRC(5f812e65) SHA1(70d9ea82f9337936bf21f82b6961768d436f3a6f) )
+	ROM_LOAD( "4(__lucky8a)",  0x4000, 0x2000, CRC(898b9ed5) SHA1(11b7d1cfcf425d00d086c74e0dbcb72068dda9fe) )
+	ROM_LOAD( "5(__lucky8a)",  0x6000, 0x2000, CRC(4f7cfb35) SHA1(0617cf4419be00d9bacc78724089cb8af4104d68) )
 
 	ROM_REGION( 0x200, "proms", 0 )
 	ROM_LOAD( "prom3", 0x0000, 0x0100, CRC(23e81049) SHA1(78071dae70fad870e972d944642fb3a2374be5e4) )
diff -Nru src-old/mame/drivers/itgamble.c src/mame/drivers/itgamble.c
--- src-old/mame/drivers/itgamble.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/itgamble.c	2012-02-22 00:51:07.000000000 +0100
@@ -519,10 +519,10 @@
 	ROM_LOAD( "4a.ic18", 0x000000, 0x80000, CRC(5decae2d) SHA1(d918aad0e2a1249b18677833f743c92fb678050a) )
 	ROM_LOAD( "5a.ic17", 0x080000, 0x80000, CRC(8f1bbbf3) SHA1(5efcf77674f8737fc1b98881acebacb26b10adc1) )
 	ROM_LOAD( "2a.ic20", 0x100000, 0x40000, CRC(f9bffb07) SHA1(efba175189d99a4548739a72f8a1f03c2782a3d0) )
-	ROM_LOAD( "euro2k2a_3a.ic19", 0x140000, 0x80000, CRC(56c8a73d) SHA1(49b44e5604cd8675d8f9770e5fb68dad4394e11d) ) /* identical halves */
+	ROM_LOAD( "3a(__euro2k2a).ic19", 0x140000, 0x80000, CRC(56c8a73d) SHA1(49b44e5604cd8675d8f9770e5fb68dad4394e11d) ) /* identical halves */
 
 	ROM_REGION( 0x40000, "oki", 0 ) /* M6295 samples */
-	ROM_LOAD( "euro2k2a_1.ic25", 0x00000, 0x40000, CRC(4fe79e43) SHA1(7c154cb00e9b64fbdcc218280f2183b816cef20b) )
+	ROM_LOAD( "1(__euro2k2a).ic25", 0x00000, 0x40000, CRC(4fe79e43) SHA1(7c154cb00e9b64fbdcc218280f2183b816cef20b) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/jaguar.c src/mame/drivers/jaguar.c
--- src-old/mame/drivers/jaguar.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/jaguar.c	2012-02-22 00:51:07.000000000 +0100
@@ -2157,132 +2157,132 @@
 
 ROM_START( freezeat2 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "961018_prog.hh",              0x000000, 0x040000, CRC(a8aefa52) SHA1(ba95da93035520de4b15245f68217c59dfb69dbd) )
-	ROM_LOAD32_BYTE( "961018_prog.hl",              0x000001, 0x040000, CRC(152dd641) SHA1(52fa260baf1979ed8f15f8abcbbeebd8e595d0e4) )
-	ROM_LOAD32_BYTE( "961018_prog.lh",              0x000002, 0x040000, CRC(416d26ed) SHA1(11cf3b88415a8a5d0bb8e1df08603a85202186ef) )
-	ROM_LOAD32_BYTE( "961018_prog.ll",              0x000003, 0x040000, CRC(d6a5dbc8) SHA1(0e2176c35cbc59b2a5283366210409d0e930bac7) )
+	ROM_LOAD32_BYTE( "prog(__961018).hh",  0x000000, 0x040000, CRC(a8aefa52) SHA1(ba95da93035520de4b15245f68217c59dfb69dbd) )
+	ROM_LOAD32_BYTE( "prog(__961018).hl",  0x000001, 0x040000, CRC(152dd641) SHA1(52fa260baf1979ed8f15f8abcbbeebd8e595d0e4) )
+	ROM_LOAD32_BYTE( "prog(__961018).lh",  0x000002, 0x040000, CRC(416d26ed) SHA1(11cf3b88415a8a5d0bb8e1df08603a85202186ef) )
+	ROM_LOAD32_BYTE( "prog(__961018).ll",  0x000003, 0x040000, CRC(d6a5dbc8) SHA1(0e2176c35cbc59b2a5283366210409d0e930bac7) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish961018_gr0.63-56", 0x000000, 0x100000, CRC(99d0dc75) SHA1(b32126eea70c7584d1c34a6ca33282fbaf4b03aa), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.55-48", 0x000001, 0x100000, CRC(2dfdfe62) SHA1(e0554d36ef5cf4b6ce171857ea4f2737f11286a5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.47-40", 0x000002, 0x100000, CRC(722aee2a) SHA1(bc79433131bed5b08453d1b80324a28a552783de), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.39-32", 0x000003, 0x100000, CRC(919e31b4) SHA1(3807d4629d8277c780dba888c23d17ba47803f27), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.31-24", 0x000004, 0x100000, CRC(a957ac95) SHA1(ddfaca994c06976bee8b123857904e64f40b7f31), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.23-16", 0x000005, 0x100000, CRC(a147ec66) SHA1(6291008158d581b81e025ed34ff0950983c12c67), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.15-08", 0x000006, 0x100000, CRC(206d2f38) SHA1(6aca89df26d3602ff1da3c23f19e0782439623ff), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr0.07-00", 0x000007, 0x100000, CRC(06559831) SHA1(b2c022457425d7900337cfa2fd1622336c0c0bc5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.63-56", 0x800000, 0x100000, CRC(30c624d2) SHA1(4ced77d1663169d0cb37d6728ec52e67f05064c5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.55-48", 0x800001, 0x100000, CRC(049cd60f) SHA1(8a7615a76b57a4e6ef5d95a5ee6c56086671dbb6), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.47-40", 0x800002, 0x100000, CRC(d6aaf3bf) SHA1(1c597bdc0e61fd0941cff5a8a93f24f108bd0daa), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.39-32", 0x800003, 0x100000, CRC(7d6ebc69) SHA1(668769297f75f9c367bc5cde26419ed092fc9dd8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.31-24", 0x800004, 0x100000, CRC(6e5fee1f) SHA1(1eca79c8d395f881d0a05f10073998fcae70c3b1), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.23-16", 0x800005, 0x100000, CRC(a8b1e9b4) SHA1(066285928e574e656510b90bc212a8d86660bd07), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.15-08", 0x800006, 0x100000, CRC(c90080e6) SHA1(a764bdd6b4e9e727f7468a53424a9211ec5fd5a8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961018_gr1.07-00", 0x800007, 0x100000, CRC(1f20c020) SHA1(71b32386dc0444264f2f1e2a81899e0e9260994c), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).63-56", 0x000000, 0x100000, CRC(99d0dc75) SHA1(b32126eea70c7584d1c34a6ca33282fbaf4b03aa), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).55-48", 0x000001, 0x100000, CRC(2dfdfe62) SHA1(e0554d36ef5cf4b6ce171857ea4f2737f11286a5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).47-40", 0x000002, 0x100000, CRC(722aee2a) SHA1(bc79433131bed5b08453d1b80324a28a552783de), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).39-32", 0x000003, 0x100000, CRC(919e31b4) SHA1(3807d4629d8277c780dba888c23d17ba47803f27), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).31-24", 0x000004, 0x100000, CRC(a957ac95) SHA1(ddfaca994c06976bee8b123857904e64f40b7f31), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).23-16", 0x000005, 0x100000, CRC(a147ec66) SHA1(6291008158d581b81e025ed34ff0950983c12c67), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).15-08", 0x000006, 0x100000, CRC(206d2f38) SHA1(6aca89df26d3602ff1da3c23f19e0782439623ff), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961018).07-00", 0x000007, 0x100000, CRC(06559831) SHA1(b2c022457425d7900337cfa2fd1622336c0c0bc5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).63-56", 0x800000, 0x100000, CRC(30c624d2) SHA1(4ced77d1663169d0cb37d6728ec52e67f05064c5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).55-48", 0x800001, 0x100000, CRC(049cd60f) SHA1(8a7615a76b57a4e6ef5d95a5ee6c56086671dbb6), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).47-40", 0x800002, 0x100000, CRC(d6aaf3bf) SHA1(1c597bdc0e61fd0941cff5a8a93f24f108bd0daa), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).39-32", 0x800003, 0x100000, CRC(7d6ebc69) SHA1(668769297f75f9c367bc5cde26419ed092fc9dd8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).31-24", 0x800004, 0x100000, CRC(6e5fee1f) SHA1(1eca79c8d395f881d0a05f10073998fcae70c3b1), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).23-16", 0x800005, 0x100000, CRC(a8b1e9b4) SHA1(066285928e574e656510b90bc212a8d86660bd07), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).15-08", 0x800006, 0x100000, CRC(c90080e6) SHA1(a764bdd6b4e9e727f7468a53424a9211ec5fd5a8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961018).07-00", 0x800007, 0x100000, CRC(1f20c020) SHA1(71b32386dc0444264f2f1e2a81899e0e9260994c), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat3 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "961007_prog.hh",              0x000000, 0x040000, CRC(863942e6) SHA1(c7429c8a5c86ff93c64950e201cffca83dd7b7b0) )
-	ROM_LOAD32_BYTE( "961007_prog.hl",              0x000001, 0x040000, CRC(2acc18ef) SHA1(ead02566f7641b1d1066bd2e257b695e5c7e8437) )
-	ROM_LOAD32_BYTE( "961007_prog.lh",              0x000002, 0x040000, CRC(948cf20c) SHA1(86c757aa3c849ef5ba94ed4d5dbf10e833dab6bd) )
-	ROM_LOAD32_BYTE( "961007_prog.ll",              0x000003, 0x040000, CRC(5f44969e) SHA1(32345d7c56a3a890e71f8c71f25414d442b60af8) )
+	ROM_LOAD32_BYTE( "prog(__961007).hh",  0x000000, 0x040000, CRC(863942e6) SHA1(c7429c8a5c86ff93c64950e201cffca83dd7b7b0) )
+	ROM_LOAD32_BYTE( "prog(__961007).hl",  0x000001, 0x040000, CRC(2acc18ef) SHA1(ead02566f7641b1d1066bd2e257b695e5c7e8437) )
+	ROM_LOAD32_BYTE( "prog(__961007).lh",  0x000002, 0x040000, CRC(948cf20c) SHA1(86c757aa3c849ef5ba94ed4d5dbf10e833dab6bd) )
+	ROM_LOAD32_BYTE( "prog(__961007).ll",  0x000003, 0x040000, CRC(5f44969e) SHA1(32345d7c56a3a890e71f8c71f25414d442b60af8) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish961007_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.63-56", 0x800000, 0x100000, CRC(ead678c9) SHA1(f83d467f6685965b6176b10adbd4e35ef808baf3), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.55-48", 0x800001, 0x100000, CRC(3591e752) SHA1(df242d2f724edfd78f7191f0ba7a8cde2c09b25f), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.47-40", 0x800002, 0x100000, CRC(e29a7a6c) SHA1(0bfb26076b390492eed81d4c4f0852c64fdccfce), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.39-32", 0x800003, 0x100000, CRC(e980f957) SHA1(78e8ef07f443ce7991a46005627d5802d36d731c), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.31-24", 0x800004, 0x100000, CRC(d90c5221) SHA1(7a330f39f3751d58157f872d92c3c2b91fe60d14), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.23-16", 0x800005, 0x100000, CRC(9be0d4de) SHA1(9bb67a1f1db77483e896fed7096c1e23c153ede4), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.15-08", 0x800006, 0x100000, CRC(122248af) SHA1(80dd5486106d475bd9f6d78919ebeb176e7becff), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961007_gr1.07-00", 0x800007, 0x100000, CRC(5ae08327) SHA1(822d8292793509ebfbfce27e92a74c78c4328bda), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961007).07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).63-56", 0x800000, 0x100000, CRC(ead678c9) SHA1(f83d467f6685965b6176b10adbd4e35ef808baf3), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).55-48", 0x800001, 0x100000, CRC(3591e752) SHA1(df242d2f724edfd78f7191f0ba7a8cde2c09b25f), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).47-40", 0x800002, 0x100000, CRC(e29a7a6c) SHA1(0bfb26076b390492eed81d4c4f0852c64fdccfce), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).39-32", 0x800003, 0x100000, CRC(e980f957) SHA1(78e8ef07f443ce7991a46005627d5802d36d731c), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).31-24", 0x800004, 0x100000, CRC(d90c5221) SHA1(7a330f39f3751d58157f872d92c3c2b91fe60d14), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).23-16", 0x800005, 0x100000, CRC(9be0d4de) SHA1(9bb67a1f1db77483e896fed7096c1e23c153ede4), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).15-08", 0x800006, 0x100000, CRC(122248af) SHA1(80dd5486106d475bd9f6d78919ebeb176e7becff), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961007).07-00", 0x800007, 0x100000, CRC(5ae08327) SHA1(822d8292793509ebfbfce27e92a74c78c4328bda), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat4 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "961003_prog.hh",              0x000000, 0x040000, CRC(80336f5e) SHA1(9946e8eebec2cd68db059f40f535ea212f41913d) )
-	ROM_LOAD32_BYTE( "961003_prog.hl",              0x000001, 0x040000, CRC(55125520) SHA1(13be4fbf32bcd94a2ea97fd690bd1dfdff146d33) )
-	ROM_LOAD32_BYTE( "961003_prog.lh",              0x000002, 0x040000, CRC(9d99c794) SHA1(f443f05a5979db66d61ef4174f0369a1cf4b7793) )
-	ROM_LOAD32_BYTE( "961003_prog.ll",              0x000003, 0x040000, CRC(e03700e0) SHA1(24d41750f02ee7e8fb379e517751b661400aa521) )
+	ROM_LOAD32_BYTE( "prog(__961003).hh",  0x000000, 0x040000, CRC(80336f5e) SHA1(9946e8eebec2cd68db059f40f535ea212f41913d) )
+	ROM_LOAD32_BYTE( "prog(__961003).hl",  0x000001, 0x040000, CRC(55125520) SHA1(13be4fbf32bcd94a2ea97fd690bd1dfdff146d33) )
+	ROM_LOAD32_BYTE( "prog(__961003).lh",  0x000002, 0x040000, CRC(9d99c794) SHA1(f443f05a5979db66d61ef4174f0369a1cf4b7793) )
+	ROM_LOAD32_BYTE( "prog(__961003).ll",  0x000003, 0x040000, CRC(e03700e0) SHA1(24d41750f02ee7e8fb379e517751b661400aa521) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish961003_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.63-56", 0x800000, 0x100000, CRC(c91b6ee4) SHA1(58d2d6b1b9847150b8b3e358842c4a097ef91475), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.55-48", 0x800001, 0x100000, CRC(65528e55) SHA1(18020cababed379f77149b7e89e80b294766df31), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.47-40", 0x800002, 0x100000, CRC(8fe4187f) SHA1(c9ceec40688617e1251142465d0e608f80a83e40), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.39-32", 0x800003, 0x100000, CRC(fdf05a42) SHA1(849e224b68be2fb396ee4cb4729517470af7c282), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.31-24", 0x800004, 0x100000, CRC(bb2cd741) SHA1(ac55a54c702d222cb1b9bb480b0f7a71bc315878), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.23-16", 0x800005, 0x100000, CRC(ea8c5984) SHA1(eca1619c17dfac154a2024ec49b4b4f9f06a50c9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.15-08", 0x800006, 0x100000, CRC(0b00c816) SHA1(879b0e9d92fe737d740c348dc1cc376c8abfbdb8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish961003_gr1.07-00", 0x800007, 0x100000, CRC(a84335c3) SHA1(340f5ddb9bff1ecd469eab8be36cc0ede84f1f5e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__961003).07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).63-56", 0x800000, 0x100000, CRC(c91b6ee4) SHA1(58d2d6b1b9847150b8b3e358842c4a097ef91475), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).55-48", 0x800001, 0x100000, CRC(65528e55) SHA1(18020cababed379f77149b7e89e80b294766df31), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).47-40", 0x800002, 0x100000, CRC(8fe4187f) SHA1(c9ceec40688617e1251142465d0e608f80a83e40), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).39-32", 0x800003, 0x100000, CRC(fdf05a42) SHA1(849e224b68be2fb396ee4cb4729517470af7c282), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).31-24", 0x800004, 0x100000, CRC(bb2cd741) SHA1(ac55a54c702d222cb1b9bb480b0f7a71bc315878), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).23-16", 0x800005, 0x100000, CRC(ea8c5984) SHA1(eca1619c17dfac154a2024ec49b4b4f9f06a50c9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).15-08", 0x800006, 0x100000, CRC(0b00c816) SHA1(879b0e9d92fe737d740c348dc1cc376c8abfbdb8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__961003).07-00", 0x800007, 0x100000, CRC(a84335c3) SHA1(340f5ddb9bff1ecd469eab8be36cc0ede84f1f5e), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat5 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "960920_prog.hh",              0x000000, 0x040000, CRC(95c4fc64) SHA1(cd00efe7f760ef1e4cdc4bc8a3b368427cb15d8a) )
-	ROM_LOAD32_BYTE( "960920_prog.hl",              0x000001, 0x040000, CRC(ffb9cb71) SHA1(35d6a5440d63bc5b94c4447645365039169da368) )
-	ROM_LOAD32_BYTE( "960920_prog.lh",              0x000002, 0x040000, CRC(3ddacd80) SHA1(79f9650531847eefd83908b6ea1e8362688b377c) )
-	ROM_LOAD32_BYTE( "960920_prog.ll",              0x000003, 0x040000, CRC(95ebefb0) SHA1(b88b12adabd7b0902c3a78919bcec8d9a2b04168) )
+	ROM_LOAD32_BYTE( "prog(__960920).hh",  0x000000, 0x040000, CRC(95c4fc64) SHA1(cd00efe7f760ef1e4cdc4bc8a3b368427cb15d8a) )
+	ROM_LOAD32_BYTE( "prog(__960920).hl",  0x000001, 0x040000, CRC(ffb9cb71) SHA1(35d6a5440d63bc5b94c4447645365039169da368) )
+	ROM_LOAD32_BYTE( "prog(__960920).lh",  0x000002, 0x040000, CRC(3ddacd80) SHA1(79f9650531847eefd83908b6ea1e8362688b377c) )
+	ROM_LOAD32_BYTE( "prog(__960920).ll",  0x000003, 0x040000, CRC(95ebefb0) SHA1(b88b12adabd7b0902c3a78919bcec8d9a2b04168) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish960920_gr0.63-56", 0x000000, 0x100000, CRC(404a10c3) SHA1(8e353ac7608bd54f0fea610c85166ad14f2faadb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.55-48", 0x000001, 0x100000, CRC(0b262f2f) SHA1(2a963cb5c3344091406d090edfdda498709c6aa6), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.47-40", 0x000002, 0x100000, CRC(43f86d26) SHA1(b31d36b11052514b5bcd5bf8e400457ca572c306), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.39-32", 0x000003, 0x100000, CRC(5cf0228f) SHA1(7a8c59cf9a7744e9f332db5f661f507323375968), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.31-24", 0x000004, 0x100000, CRC(7a24ff98) SHA1(db9e0e8bb417f187267a6e4fc1e66ff060ee4096), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.23-16", 0x000005, 0x100000, CRC(ea163c93) SHA1(d07ed26191d36497c56b15774625a49ecb958386), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.15-08", 0x000006, 0x100000, CRC(d364534f) SHA1(153908bb8929a898945f768f8bc3d853c6aeaceb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr0.07-00", 0x000007, 0x100000, CRC(7ba4cb0d) SHA1(16bd487123f499b7080596dc76253081179a0f66), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.63-56", 0x800000, 0x100000, CRC(0e1fc4a9) SHA1(a200bb0af5f1e2c3f8d221ae4e9ba55b9dfb8550), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.55-48", 0x800001, 0x100000, CRC(b696b875) SHA1(16dc4d5cee3f08360cf19926584419c21d781f45), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.47-40", 0x800002, 0x100000, CRC(e78d9302) SHA1(f8b5ed992c433d63677edbeafd3e465b1d42b455), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.39-32", 0x800003, 0x100000, CRC(9b50374c) SHA1(d8af3c9d8e0459e24b974cdf2e75c7c39582912f), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.31-24", 0x800004, 0x100000, CRC(b6a19b7e) SHA1(5668b27db4dade8efb1524b8ecd1fe78498e8460), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.23-16", 0x800005, 0x100000, CRC(ff835b67) SHA1(19da2de1d067069871c33c8b25fd2eac2d03f627), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.15-08", 0x800006, 0x100000, CRC(8daf6995) SHA1(2f44031378b5fb1ba1f80a966dbe902316dc6fe8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960920_gr1.07-00", 0x800007, 0x100000, CRC(3676ac70) SHA1(640c4d4f53ca2bcae2009e402fd6ad70e40defa4), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).63-56", 0x000000, 0x100000, CRC(404a10c3) SHA1(8e353ac7608bd54f0fea610c85166ad14f2faadb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).55-48", 0x000001, 0x100000, CRC(0b262f2f) SHA1(2a963cb5c3344091406d090edfdda498709c6aa6), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).47-40", 0x000002, 0x100000, CRC(43f86d26) SHA1(b31d36b11052514b5bcd5bf8e400457ca572c306), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).39-32", 0x000003, 0x100000, CRC(5cf0228f) SHA1(7a8c59cf9a7744e9f332db5f661f507323375968), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).31-24", 0x000004, 0x100000, CRC(7a24ff98) SHA1(db9e0e8bb417f187267a6e4fc1e66ff060ee4096), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).23-16", 0x000005, 0x100000, CRC(ea163c93) SHA1(d07ed26191d36497c56b15774625a49ecb958386), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).15-08", 0x000006, 0x100000, CRC(d364534f) SHA1(153908bb8929a898945f768f8bc3d853c6aeaceb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960920).07-00", 0x000007, 0x100000, CRC(7ba4cb0d) SHA1(16bd487123f499b7080596dc76253081179a0f66), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).63-56", 0x800000, 0x100000, CRC(0e1fc4a9) SHA1(a200bb0af5f1e2c3f8d221ae4e9ba55b9dfb8550), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).55-48", 0x800001, 0x100000, CRC(b696b875) SHA1(16dc4d5cee3f08360cf19926584419c21d781f45), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).47-40", 0x800002, 0x100000, CRC(e78d9302) SHA1(f8b5ed992c433d63677edbeafd3e465b1d42b455), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).39-32", 0x800003, 0x100000, CRC(9b50374c) SHA1(d8af3c9d8e0459e24b974cdf2e75c7c39582912f), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).31-24", 0x800004, 0x100000, CRC(b6a19b7e) SHA1(5668b27db4dade8efb1524b8ecd1fe78498e8460), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).23-16", 0x800005, 0x100000, CRC(ff835b67) SHA1(19da2de1d067069871c33c8b25fd2eac2d03f627), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).15-08", 0x800006, 0x100000, CRC(8daf6995) SHA1(2f44031378b5fb1ba1f80a966dbe902316dc6fe8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960920).07-00", 0x800007, 0x100000, CRC(3676ac70) SHA1(640c4d4f53ca2bcae2009e402fd6ad70e40defa4), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat6 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "960907_prog.hh",              0x000000, 0x040000, CRC(120711fe) SHA1(387e3cc8a1a9ea7d65c528387891d09ed9889fe3) )
-	ROM_LOAD32_BYTE( "960907_prog.hl",              0x000001, 0x040000, CRC(18dd292a) SHA1(00e79851140716985f43594142c97e510a06b24a) )
-	ROM_LOAD32_BYTE( "960907_prog.lh",              0x000002, 0x040000, CRC(ce387e72) SHA1(021a274da0b828550a47c3778e1059d4e759693a) )
-	ROM_LOAD32_BYTE( "960907_prog.ll",              0x000003, 0x040000, CRC(9b307b7c) SHA1(71b696802fe7c867525d2626351dcfacedabd696) )
+	ROM_LOAD32_BYTE( "prog(__960907).hh",  0x000000, 0x040000, CRC(120711fe) SHA1(387e3cc8a1a9ea7d65c528387891d09ed9889fe3) )
+	ROM_LOAD32_BYTE( "prog(__960907).hl",  0x000001, 0x040000, CRC(18dd292a) SHA1(00e79851140716985f43594142c97e510a06b24a) )
+	ROM_LOAD32_BYTE( "prog(__960907).lh",  0x000002, 0x040000, CRC(ce387e72) SHA1(021a274da0b828550a47c3778e1059d4e759693a) )
+	ROM_LOAD32_BYTE( "prog(__960907).ll",  0x000003, 0x040000, CRC(9b307b7c) SHA1(71b696802fe7c867525d2626351dcfacedabd696) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish960907_gr0.63-56", 0x000000, 0x100000, CRC(293a3308) SHA1(e4c88759c3b8f8a359db83817dbd0428350b4f7e), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.55-48", 0x000001, 0x100000, CRC(18bb4bdf) SHA1(1f6c49b3b5946390fa7582b531f8d9af3baa2567), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.47-40", 0x000002, 0x100000, CRC(1faedcc6) SHA1(1e4ecbe4553fb3ebfbd03bd7e16066ccb531d00b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.39-32", 0x000003, 0x100000, CRC(536bc349) SHA1(06d7ac38b2c8cdc85e2cb531bba9c836e50c8247), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.31-24", 0x000004, 0x100000, CRC(813d4a31) SHA1(e024f9da2f15a482d8142870baf487297b995ed9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.23-16", 0x000005, 0x100000, CRC(f881514b) SHA1(a694f90621e2c1569a6a5ed8920838ba5506f72e), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.15-08", 0x000006, 0x100000, CRC(d7634655) SHA1(d7ac83c0fa5d0ec57d096d4d704fe99ee8160e09), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr0.07-00", 0x000007, 0x100000, CRC(3fca32a3) SHA1(22753a9678e04d9355238e013e58d9f45315579d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.63-56", 0x800000, 0x100000, CRC(a2b89d3a) SHA1(9cfcd0b88dea192ba39efcdccc78d1a0fd8f3388), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.55-48", 0x800001, 0x100000, CRC(766822a8) SHA1(2c9b14542a5467c1a3451559ea296da09c2cfdb9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.47-40", 0x800002, 0x100000, CRC(112b519c) SHA1(f0e1ed1b8ad271fa9708f513b11d5cca6e550668), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.39-32", 0x800003, 0x100000, CRC(435b5d37) SHA1(ecb6e7271d993f8e315b85e69166838e66dd41a8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.31-24", 0x800004, 0x100000, CRC(2637ae7f) SHA1(5e0bd0e08d8c1eaae725b4d55030c2698abd46e7), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.23-16", 0x800005, 0x100000, CRC(e732f1bf) SHA1(a228aee0cc36a0089716f20bfa75d87750692adb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.15-08", 0x800006, 0x100000, CRC(7d4e2d9e) SHA1(4cb9b754b7585df4cae6bdd7085a57729d53e643), ROM_SKIP(7) )
-	ROMX_LOAD( "fish960907_gr1.07-00", 0x800007, 0x100000, CRC(8ea036af) SHA1(1f9baec6712e0ba0e8a744529e41799217760194), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).63-56", 0x000000, 0x100000, CRC(293a3308) SHA1(e4c88759c3b8f8a359db83817dbd0428350b4f7e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).55-48", 0x000001, 0x100000, CRC(18bb4bdf) SHA1(1f6c49b3b5946390fa7582b531f8d9af3baa2567), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).47-40", 0x000002, 0x100000, CRC(1faedcc6) SHA1(1e4ecbe4553fb3ebfbd03bd7e16066ccb531d00b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).39-32", 0x000003, 0x100000, CRC(536bc349) SHA1(06d7ac38b2c8cdc85e2cb531bba9c836e50c8247), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).31-24", 0x000004, 0x100000, CRC(813d4a31) SHA1(e024f9da2f15a482d8142870baf487297b995ed9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).23-16", 0x000005, 0x100000, CRC(f881514b) SHA1(a694f90621e2c1569a6a5ed8920838ba5506f72e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).15-08", 0x000006, 0x100000, CRC(d7634655) SHA1(d7ac83c0fa5d0ec57d096d4d704fe99ee8160e09), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr0(__960907).07-00", 0x000007, 0x100000, CRC(3fca32a3) SHA1(22753a9678e04d9355238e013e58d9f45315579d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).63-56", 0x800000, 0x100000, CRC(a2b89d3a) SHA1(9cfcd0b88dea192ba39efcdccc78d1a0fd8f3388), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).55-48", 0x800001, 0x100000, CRC(766822a8) SHA1(2c9b14542a5467c1a3451559ea296da09c2cfdb9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).47-40", 0x800002, 0x100000, CRC(112b519c) SHA1(f0e1ed1b8ad271fa9708f513b11d5cca6e550668), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).39-32", 0x800003, 0x100000, CRC(435b5d37) SHA1(ecb6e7271d993f8e315b85e69166838e66dd41a8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).31-24", 0x800004, 0x100000, CRC(2637ae7f) SHA1(5e0bd0e08d8c1eaae725b4d55030c2698abd46e7), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).23-16", 0x800005, 0x100000, CRC(e732f1bf) SHA1(a228aee0cc36a0089716f20bfa75d87750692adb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).15-08", 0x800006, 0x100000, CRC(7d4e2d9e) SHA1(4cb9b754b7585df4cae6bdd7085a57729d53e643), ROM_SKIP(7) )
+	ROMX_LOAD( "fish_gr1(__960907).07-00", 0x800007, 0x100000, CRC(8ea036af) SHA1(1f9baec6712e0ba0e8a744529e41799217760194), ROM_SKIP(7) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/jpmimpct.c src/mame/drivers/jpmimpct.c
--- src-old/mame/drivers/jpmimpct.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/jpmimpct.c	2012-02-24 04:31:09.000000000 +0100
@@ -5697,9 +5697,9 @@
 GAME( 199?, j6bmc		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Big Money Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6bno		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Big Nite Out (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6btbw		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Born To Be Wild Club (Crystal) (IMPACT)", GAME_FLAGS )
-GAME( 199?, j6cpal		, 0			, impctawp, tbirds, 0, ROT0, "Whitbread / Crystal", "Caesar's Palace (Whitbread / Crystal) (IMPACT, set 1)", GAME_FLAGS )
-GAME( 199?, j6cpala		, 0			, impctawp, tbirds, 0, ROT0, "Whitbread / Crystal", "Caesar's Palace (Whitbread / Crystal) (IMPACT, set 2)", GAME_FLAGS ) // marked as ACE
-GAME( 1998, j6cpalb		, 0			, impctawp, tbirds, 0, ROT0, "Whitbread / Ace", "Caesar's Palace (Whitbread / Ace) (IMPACT)", GAME_FLAGS )
+GAME( 199?, j6cpal		, 0			, impctawp, tbirds, 0, ROT0, "Whitbread / Crystal", "Caesars Palace (Whitbread / Crystal) (IMPACT, set 1)", GAME_FLAGS )
+GAME( 199?, j6cpala		, j6cpal		, impctawp, tbirds, 0, ROT0, "Whitbread / Crystal", "Caesars Palace (Whitbread / Crystal) (IMPACT, set 2)", GAME_FLAGS ) // marked as ACE
+GAME( 1998, j6cpalb		, j6cpal		, impctawp, tbirds, 0, ROT0, "Whitbread / Ace", "Caesars Palace (Whitbread / Ace) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6cdivr		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Cash Diver (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6ccc		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Casino Crazy Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6colic		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Coliseum (Crystal) (IMPACT)", GAME_FLAGS )
@@ -5710,7 +5710,7 @@
 GAME( 199?, j6grc		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Gold Rush Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6hdc		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Hot Dogs Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6impls		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Impulse (Crystal) (IMPACT)", GAME_FLAGS )
-GAME( 199?, j6kapang	, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Kapang (Crystal) (IMPACT)", GAME_FLAGS )
+GAME( 199?, j6kapang	, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Kapang! (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6kfc		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Kung Fu Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6lucklo	, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Lucky Lottery Club (Crystal) (IMPACT)", GAME_FLAGS )
 GAME( 199?, j6monst		, 0			, impctawp, tbirds, 0, ROT0, "Crystal", "Monster Cash Club (Crystal) (IMPACT)", GAME_FLAGS )
diff -Nru src-old/mame/drivers/konamigv.c src/mame/drivers/konamigv.c
--- src-old/mame/drivers/konamigv.c	2012-01-28 20:48:44.000000000 +0100
+++ src/mame/drivers/konamigv.c	2012-02-26 03:37:27.000000000 +0100
@@ -765,7 +765,7 @@
 	ROM_REGION16_BE( 0x0000080, "eeprom", 0 ) /* default eeprom */
 	ROM_LOAD( "susume.25c",   0x000000, 0x000080, CRC(52f17df7) SHA1(b8ad7787b0692713439d7d9bebfa0c801c806006) )
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "gv027j1", 0, SHA1(ad474c60ee68202324a31cc106f2054dc465f4b7) )
+	DISK_IMAGE_READONLY( "gv027j1", 0, BAD_DUMP SHA1(e7e6749ac65de7771eb8fed7d5eefaec3f902255) )
 ROM_END
 
 ROM_START( hyperath )
@@ -775,7 +775,7 @@
 	ROM_LOAD( "hyperath.25c", 0x000000, 0x000080, CRC(20a8c435) SHA1(a0f203a999757fba68b391c525ac4b9684a57ba9) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "hyperath", 0, SHA1(8638dcb27d53a30ea66c09349f6ff0b78910bf79) )
+	DISK_IMAGE_READONLY( "hyperath", 0, BAD_DUMP SHA1(694ef6200c61d3052316100cd9251b495eab88a1) )
 ROM_END
 
 ROM_START( pbball96 )
@@ -785,7 +785,7 @@
 	ROM_LOAD( "pbball96.25c", 0x000000, 0x000080, CRC(405a7fc9) SHA1(e2d978f49748ba3c4a425188abcd3d272ec23907) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "pbball96", 0, SHA1(6d47624e86f97c0b8ea4ebb84cc5446aa4f11fcf) )
+	DISK_IMAGE_READONLY( "pbball96", 0, BAD_DUMP SHA1(ebd0ea18ff9ce300ea1e30d66a739a96acfb0621) )
 ROM_END
 
 ROM_START( weddingr )
@@ -795,7 +795,7 @@
 	ROM_LOAD( "weddingr.25c", 0x000000, 0x000080, CRC(b90509a0) SHA1(41510a0ceded81dcb26a70eba97636d38d3742c3) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "weddingr", 0, SHA1(798686b410cb43b60d6ae91507d034db2db1b185) )
+	DISK_IMAGE_READONLY( "weddingr", 0, BAD_DUMP SHA1(4e7122b191747ab7220fe4ce1b4483d62ab579af) )
 ROM_END
 
 ROM_START( simpbowl )
@@ -805,7 +805,7 @@
 	ROM_LOAD( "simpbowl.25c", 0x000000, 0x000080, CRC(2c61050c) SHA1(16ae7f81cbe841c429c5c7326cf83e87db1782bf) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "simpbowl", 0, SHA1(476f100b6c420343e16a18575bbedf1f15fbd274) )
+	DISK_IMAGE_READONLY( "simpbowl", 0, BAD_DUMP SHA1(72b32a863e6891ad3bfc1fdfe9cb90a2bd334d71) )
 ROM_END
 
 ROM_START( btchamp )
@@ -815,7 +815,7 @@
 	ROM_LOAD( "btchmp.25c", 0x000000, 0x000080, CRC(6d02ea54) SHA1(d3babf481fd89db3aec17f589d0d3d999a2aa6e1) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "btchamp", 0, SHA1(c9c858e9034826e1a12c3c003dd068a49a3577e1) )
+	DISK_IMAGE_READONLY( "btchamp", 0, BAD_DUMP SHA1(c9c858e9034826e1a12c3c003dd068a49a3577e1) )
 ROM_END
 
 ROM_START( kdeadeye )
@@ -825,7 +825,7 @@
 	ROM_LOAD( "kdeadeye.25c", 0x000000, 0x000080, CRC(3935d2df) SHA1(cbb855c475269077803c380dbc3621e522efe51e) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "kdeadeye", 0, SHA1(55a86ad568069f3799125b47253d579793276fab) )
+	DISK_IMAGE_READONLY( "kdeadeye", 0, BAD_DUMP SHA1(3c737c51717925be724dcb93d30769649029b8ce) )
 ROM_END
 
 ROM_START( nagano98 )
@@ -835,7 +835,7 @@
 	ROM_LOAD( "nagano98.25c",  0x000000, 0x000080, CRC(b64b7451) SHA1(a77a37e0cc580934d1e7e05d523bae0acd2c1480) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "nagano98", 0, SHA1(efe09a23dfbb957574b8989b5672af1ab5e27640) )
+	DISK_IMAGE_READONLY( "nagano98", 0, BAD_DUMP SHA1(1be7bd4531f249ff2233dd40a206c8d60054a8c6) )
 ROM_END
 
 ROM_START( tokimosh )
@@ -845,7 +845,7 @@
         ROM_LOAD( "tokimosh.25c", 0x000000, 0x000080, CRC(e57b833f) SHA1(f18a0974a6be69dc179706643aab837ff61c2738) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "755jaa01", 0, SHA1(f7f1545658b430f60edccf448b2832dab9984b19) )
+	DISK_IMAGE_READONLY( "755jaa01", 0, BAD_DUMP SHA1(4af080f9650e34d1ddb91bb763469d5fb3c754bd) )
 ROM_END
 
 ROM_START( tokimosp )
@@ -855,7 +855,7 @@
 	ROM_LOAD( "tokimosp.25c", 0x000000, 0x000080, CRC(af4cdd87) SHA1(97041e287e4c80066043967450779b81b62b2b8e) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "756jab01", 0, SHA1(ef76fc27e43f7e4cff16bf88458e7ee327c11ca3) )
+	DISK_IMAGE_READONLY( "756jab01", 0, BAD_DUMP SHA1(7bd974d908ae5a7bfa8d30db185ab01ac38dff28) )
 ROM_END
 
 /* BIOS placeholder */
diff -Nru src-old/mame/drivers/magicard.c src/mame/drivers/magicard.c
--- src-old/mame/drivers/magicard.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/magicard.c	2012-02-22 00:51:07.000000000 +0100
@@ -760,7 +760,7 @@
 
 ROM_START( magicardj )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68070 Code & GFX */
-	ROM_LOAD16_WORD_SWAP( "27c4002j.ic21", 0x00000, 0x80000, CRC(ab2ed583) SHA1(a2d7148b785a8dfce8cff3b15ada293d65561c98) )
+	ROM_LOAD16_WORD_SWAP( "27c4002(__magicardj).ic21", 0x00000, 0x80000, CRC(ab2ed583) SHA1(a2d7148b785a8dfce8cff3b15ada293d65561c98) )
 
 	ROM_REGION( 0x0100, "pic16f84", 0 ) /* protected */
 	ROM_LOAD("pic16f84.ic29",	0x0000, 0x0100, BAD_DUMP CRC(0d968558) SHA1(b376885ac8452b6cbf9ced81b1080bfd570d9b91) )
diff -Nru src-old/mame/drivers/magtouch.c src/mame/drivers/magtouch.c
--- src-old/mame/drivers/magtouch.c	2012-01-24 15:16:25.000000000 +0100
+++ src/mame/drivers/magtouch.c	2012-02-26 15:31:24.000000000 +0100
@@ -85,8 +85,16 @@
 {
 public:
 	magtouch_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_uart(*this, "ns16450_0"),
+		  m_microtouch(*this, "microtouch")
+	{ }
 
+	required_device<ns16450_device> m_uart;
+	required_device<microtouch_serial_device> m_microtouch;
+
+	DECLARE_WRITE_LINE_MEMBER(microtouch_out);
+	DECLARE_WRITE_LINE_MEMBER(microtouch_in);
 };
 
 
@@ -96,15 +104,14 @@
  *
  *************************************/
 
-static void magtouch_microtouch_tx_callback(running_machine &machine, UINT8 data)
+WRITE_LINE_MEMBER(magtouch_state::microtouch_out)
 {
-	ins8250_receive(machine.device("ns16450_0"), data);
-};
+	m_microtouch->rx(state);
+}
 
-static INS8250_TRANSMIT( magtouch_com_transmit )
+WRITE_LINE_MEMBER(magtouch_state::microtouch_in)
 {
-	UINT8 data8 = data;
-	microtouch_rx(1, &data8);
+	m_uart->rx_w(state);
 }
 
 static WRITE_LINE_DEVICE_HANDLER( at_com_interrupt_1 )
@@ -114,11 +121,17 @@
 
 static const ins8250_interface magtouch_com0_interface =
 {
-	1843200,
+	DEVCB_DRIVER_LINE_MEMBER(magtouch_state, microtouch_out),
+	DEVCB_NULL,
+	DEVCB_NULL,
 	DEVCB_LINE(at_com_interrupt_1),
-	magtouch_com_transmit,
-	NULL,
-	NULL
+	DEVCB_NULL,
+	DEVCB_NULL
+};
+
+static const microtouch_serial_interface magtouch_microtouch_interface =
+{
+	DEVCB_DRIVER_LINE_MEMBER(magtouch_state, microtouch_in)
 };
 
 /*************************************
@@ -161,12 +174,10 @@
 static ADDRESS_MAP_START( magtouch_io, AS_IO, 32 )
 	AM_IMPORT_FROM(pcat32_io_common)
 	AM_RANGE(0x02e0, 0x02e7) AM_READWRITE8(magtouch_io_r, magtouch_io_w, 0xffffffff)
-	AM_RANGE(0x03f8, 0x03ff) AM_DEVREADWRITE8("ns16450_0", ins8250_r, ins8250_w, 0xffffffff)
+	AM_RANGE(0x03f8, 0x03ff) AM_DEVREADWRITE8_MODERN("ns16450_0", ns16450_device, ins8250_r, ins8250_w, 0xffffffff)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( magtouch )
-	PORT_INCLUDE(microtouch)
-
 	PORT_START("IN0")
 	PORT_BIT(0x80, IP_ACTIVE_LOW, IPT_OTHER) PORT_NAME("Clear") PORT_CODE(KEYCODE_C)
 	PORT_BIT(0x40, IP_ACTIVE_LOW, IPT_SERVICE)
@@ -191,7 +202,7 @@
 	memory_configure_bank(machine, "rombank", 0, 0x80, machine.region("game_prg")->base(), 0x8000 );
 	memory_set_bank(machine, "rombank", 0);
 
-	microtouch_init(machine, magtouch_microtouch_tx_callback, NULL);
+//  microtouch_init(machine, magtouch_microtouch_tx_callback, NULL);
 }
 
 static MACHINE_CONFIG_START( magtouch, magtouch_state )
@@ -212,8 +223,8 @@
 
 //  MCFG_FRAGMENT_ADD( at_kbdc8042 )
 	MCFG_FRAGMENT_ADD( pcat_common )
-	MCFG_NS16450_ADD( "ns16450_0", magtouch_com0_interface )
-
+	MCFG_NS16450_ADD( "ns16450_0", magtouch_com0_interface, XTAL_1_8432MHz )
+	MCFG_MICROTOUCH_SERIAL_ADD( "microtouch", magtouch_microtouch_interface, 9600 ) // rate?
 MACHINE_CONFIG_END
 
 
diff -Nru src-old/mame/drivers/manohman.c src/mame/drivers/manohman.c
--- src-old/mame/drivers/manohman.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/manohman.c	2012-02-26 15:31:24.000000000 +0100
@@ -0,0 +1,235 @@
+/***************************************************************************
+
+  MANN, OH-MANN
+  199? - MERKUR
+
+  Preliminary driver by Roberto Fresca.
+
+
+  German board game similar to Ludo, derivated from the indian game Parchisi.
+  Coin-operated machine for 1-4 players. No screen, just artwork and lamps.
+  The machine was designed for pubs, etc...
+
+  Field: 93 cm.
+  High:  105 cm.
+
+  1x keylock.
+  Accept DM and Euro.
+
+
+  It's all a challenge. Even once emulated, the game will need a lot of
+  artwork and lamps work...
+
+  Currently sits in a loop between 0x100000 and 0x600006 addresses r/w,
+  the snippet is there:
+
+  001BB8: move.b  (A2), D0
+  001BBA: jsr     $6dc0.l
+  001BC0: tst.b   D0
+  001BC2: bne     $1bb8
+
+  Passing this loop it checks the i/o stuff, including the sound addresses
+
+****************************************************************************
+
+  Hardware Notes...
+
+  - XTAL1 = 8.000 MHz.
+  - XTAL2 = 3.6864 MHz.
+
+  1x MC68000P8        ; Motorola, 16-bits CPU.
+  1x SAA1099P         ; Philips, 6-Voice Sound Generator.
+  2x LC3664BL-10      ; Sanyo, 64K Static RAM.
+  1x M62X42B          : OKI, Real Time Clock with built in crystal.
+  1x MC68230P8        ; Motorola, Parallel Interface / Timer.
+  1x SCN68681C1N40    ; Philips, Dual Asynchronous Receiver/Transmitter (DUART).
+  1x MAX696CP         ; Maxim, Microprocessor Supervisory Circuits.
+
+
+  PCB Layout:
+  .------------------------------------------------------.
+  | .-------------.    .-----.    .---------.            |
+  | |:::::::::::::|    |:::::|    |:::::::::|            |
+  | '-------------'    '-----'    '---------'            |
+  |         .------------------------.  .-------.        |
+  | .-.     |       MC68230P8        |  | L4962 |        |
+  | |.|     |         1C10R          |  '-------'        |
+  | |.|     |         WC9336         |                   |
+  |R|.|     '------------------------'                   |
+  |E|.|                                                  |
+  |S|.|                                                  |
+  |E|.| .---------.      .-----------.                   |
+  |R|.| |74HC245N |      | POWER     |                   |
+  |V|.| '---------'      |  MODULE   |                   |
+  |E|.|                  |           |                   |
+  | |.| .---------.      |  3 VOLTS  |    .--------.     |
+  | |.| |74HC273B1|      |           |    |MAX696CP|     |
+  | '-' '---------'      |           |    '--------'     |
+  |                      |           |                   |
+  |     .--------.       '-----------'                   |
+  |     |74HC4094|                                       |
+  |     '--------' .-------------.   .-------------.     |
+  |                |    SANYO    |   |    SANYO    |     |
+  |  .--------.    | LC3664BL-10 |   | LC3664BL-10 |     |
+  |  |74HC04B1|    |             |   |             |     |
+  |  '--------'    '-------------'   '-------------'     |
+  |  .--------.                                          |
+  |  |74HC164B|                                          |
+  |  '--------'    .-------------.   .-------------.     |
+  |                |Mann,oh-Mann |   |Mann,oh-Mann |     |
+  |                |Austria      |   |Austria      |     |
+  |   .---. XTAL1  |Vorserie II  |   |Vorserie I   |     |
+  |                '-------------'   '-------------'     |
+  |  .--------.      .---------.       .---------.       |
+  |  |74HC04B1|      |74HC245N |       |74HC245N |       |
+  |  '--------'      '---------'       '---------'       |
+  |                   .........         .........        |
+  |                    8x10K             8x10K           |
+  |  .--------.                                          |
+  |  |74HC139N|    .--------------------------------.    |
+  |  '--------'    |                                |    |
+  |                |           MC68000P8            |    |
+  |                |                                |    |
+  |  .--------.    |                                |    |
+  |  |74HC30B1|    '--------------------------------'    |
+  |  '--------'          .........  .........            |
+  |                        8x10K      8x10K              |
+  |  .--------.        .--------.  .----------.          |
+  |  |74HC32N |        |74HC138B|  | 74HC245N |          |
+  |  '--------'        '--------'  '----------'          |
+  |  .--------.       .---------.                        |
+  |  |74HC00B1|       | M62X42B |                        |
+  |  '--------'       '---------'                        |
+  |  .--------.       .---------.                        |
+  |  |74HC74B1|       |SAA1099P |                        |
+  |  '--------'       '---------'                        |
+  |           .---. XTAL2                                |
+  | . .------------------------.                         |
+  |8. |                        |                         |
+  |x. |     SCN68681C1N40      |                         |
+  |1. |                        |                         |
+  |0. '------------------------'                         |
+  |K.     .........                                      |
+  | .       8x10K                                        |
+  |  .--------.  .--------.  .--------.  .----.  .--.    |
+  |  |::::::::|  |::::::::|  |::::::::|  |::::|  |::|    |
+  |  '--------'  '--------'  '--------'  '----'  '--'    |
+  |   SERVICE                 SERIAL1   SERIAL2 SPEAKER  |
+  '------------------------------------------------------'
+
+
+****************************************************************************
+
+  Memory Map:
+  -----------
+
+  000000-01FFFF   ROM Space.
+  500000-503FFF   RAM.
+
+
+***************************************************************************/
+
+#define MASTER_CLOCK		XTAL_8MHz
+#define SECONDARY_CLOCK		XTAL_3_6864MHz
+
+#include "emu.h"
+#include "cpu/m68000/m68000.h"
+#include "sound/saa1099.h"
+
+
+class _manohman_state : public driver_device
+{
+public:
+	_manohman_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag) { }
+
+};
+
+
+/*********************************************
+*           Memory Map Definition            *
+*********************************************/
+
+static ADDRESS_MAP_START( manohman_map, AS_PROGRAM, 16 )
+	AM_RANGE(0x000000, 0x01ffff) AM_ROM
+	AM_RANGE(0x100000, 0x100001) AM_NOP		// smell to MAX696 watchdog...
+	AM_RANGE(0x300000, 0x300001) AM_DEVWRITE8("saa", saa1099_data_w, 0x00ff)
+	AM_RANGE(0x300002, 0x300003) AM_DEVWRITE8("saa", saa1099_control_w, 0x00ff)
+	AM_RANGE(0x500000, 0x503fff) AM_RAM
+	AM_RANGE(0x600006, 0x600007) AM_RAM		// write bitpatterns to compare with the 500000-503ff8 RAM testing.
+//  AM_RANGE(0xYYYYYY, 0xYYYYYY) AM_RAM
+ADDRESS_MAP_END
+
+/*
+
+  RW
+
+  100000 ; R      \
+  100000 ; W 0000  | Constant after RAM test... Seems for the MAX696's watchdog.
+  100000 ; W 00FF /
+
+  500000-503FF9 ; R
+  500000-503FF9 ; W FFFF \
+  500000-503FF9 ; W AAAA  | Seems bit patterns for testing RAM...
+  500000-503FF9 ; W 5555  |
+  500000-503FF9 ; W 0000 /
+
+  503FFA - 503FFF RW
+
+  500300 ; R
+  500302 ; R
+
+  600006 ; R
+  600006 ; W FFFF \
+  600006 ; W AAAA  | These bit patterns are for 500000-503ff8 comparison.
+  600006 ; W 5555  |
+  600006 ; W 0000 /
+
+
+  BP at 0x1880 to point to the end of RAM test.
+
+*/
+
+/*********************************************
+*          Input Ports Definitions           *
+*********************************************/
+
+static INPUT_PORTS_START( manohman )
+
+INPUT_PORTS_END
+
+
+
+/*********************************************
+*               Machine Config               *
+*********************************************/
+
+static MACHINE_CONFIG_START( manohman, _manohman_state )
+	// basic machine hardware
+	MCFG_CPU_ADD("maincpu", M68000, MASTER_CLOCK)	// 8 MHz
+	MCFG_CPU_PROGRAM_MAP(manohman_map)
+
+	// sound hardware
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+	MCFG_SOUND_ADD("saa", SAA1099, MASTER_CLOCK /* guess */)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_CONFIG_END
+
+
+/*********************************************
+*                  Rom Load                  *
+*********************************************/
+
+ROM_START( manohman )
+	ROM_REGION( 0x100000, "maincpu", 0 )	/* 68000 code */
+	ROM_LOAD16_BYTE( "mom_austria_vorserie_ii.bin", 0x000000, 0x010000, CRC(4b57409c) SHA1(0438f5d52f4de2ece8fb684cf2d82bdea0eacf0b) )
+	ROM_LOAD16_BYTE( "mom_austria_vorserie_i.bin",  0x000001, 0x010000, CRC(3c9507f9) SHA1(489a6aadfb7d61be0873bf48d428e9d915268f95) )
+ROM_END
+
+
+/*********************************************
+*                Game Drivers                *
+*********************************************/
+
+/*    YEAR  NAME      PARENT  MACHINE   INPUT     INIT    ROT    COMPANY   FULLNAME        FLAGS... */
+GAME( 199?, manohman, 0,      manohman, manohman, 0,      ROT0, "Merkur", "Mann, oh-Mann", GAME_NOT_WORKING | GAME_NO_SOUND | GAME_REQUIRES_ARTWORK )
diff -Nru src-old/mame/drivers/maygay1b.c src/mame/drivers/maygay1b.c
--- src-old/mame/drivers/maygay1b.c	2012-01-31 15:50:49.000000000 +0100
+++ src/mame/drivers/maygay1b.c	2012-02-26 15:31:24.000000000 +0100
@@ -979,6 +979,25 @@
 	ROM_LOAD( "digi0421.bin", 0x000000, 0x080000, CRC(9489c9cd) SHA1(1a858b2a6f41898bbf95611e9f13d668c8a05c9c) )\
 	ROM_LOAD( "digi0422.bin", 0x080000, 0x080000, CRC(cf17088e) SHA1(54c9a52ccdd1ca622367367e1304fe4e4037b0b9) )\
 
+#define m1_cororr_sound \
+	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )\
+	ROM_LOAD( "roversreturn.p1", 0x000000, 0x080000, CRC(b21d4cca) SHA1(ad54c4f44de2c596fd5e8330666d0f4f859bfcb2) )\
+	ROM_LOAD( "roversreturn.p2", 0x080000, 0x080000, CRC(354a91e0) SHA1(13f3e1eacba3c80c83f12491d2668cc54536245a) )\
+
+#define m1_corocb_sound \
+	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )\
+	ROM_LOAD( "clubcorriesnd.p1snd", 0x000000, 0x080000, CRC(e4cf4412) SHA1(6849fb9a71a6f0bbf40368238ed9104026013d36) )\
+	ROM_LOAD( "clubcorriesnd.p2snd", 0x080000, 0x080000, CRC(e33d2c08) SHA1(fd30b9c2936659a793d83e283d920c46990633c4) )\
+
+#define m1_dxmono_sound\
+	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )\
+	ROM_LOAD( "delmonopolysound.bin", 0x0000, 0x040000, CRC(8742981e) SHA1(1ba33c59ec5f878ebab111a77551213aad4b0993) )\
+
+#define m1_dkong_sound\
+	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )\
+	ROM_LOAD( "donkeykong.p1", 0x0000, 0x080000, CRC(11019875) SHA1(b171b46a7a98967668793a7ea7b5931c7a76dd82) )\
+	ROM_LOAD( "donkeykong.p2", 0x0000, 0x080000, CRC(e28f406f) SHA1(42a58c0f5c4f25dec4c0c49eb8415971a515c5a6) )\
+
 ROM_START( m1albsq )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa5-056", 0x0000, 0x010000, CRC(6f3bc318) SHA1(6dbe6e02ca762a8ffaed9c89a0da5f6a10d829cc) )//4.1 Normal Token
@@ -2035,67 +2054,224 @@
 
 ROM_START( m1cororr )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "rov5.10", 0x0000, 0x010000, CRC(04b421ca) SHA1(c0992edf4ecdfcf7231ae560f38954ce3a4db735) )
+	ROM_LOAD( "sa8-066", 0x0000, 0x010000, CRC(0656ad1b) SHA1(d1efb0cde9354087815ea260ccc81152c1ccf354) )// 1.1 5p
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
-	ROM_LOAD( "rov5.8", 0x0000, 0x010000, CRC(79be1896) SHA1(78a3f62fcbb2073257eeebc03524852d0c9d4648) )
-	ROM_LOAD( "rover8ac", 0x0000, 0x010000, CRC(1f6bff96) SHA1(862e32dc9ea3fad5ef27b9146a8a62138d3b6406) )
-	ROM_LOAD( "roversprog", 0x0000, 0x010000, CRC(35aded03) SHA1(978c49dad02cd1bb290028aa52d3048c5f2b9bdd) )
-	ROM_LOAD( "roversreturn20p8ptokenv2.1", 0x0000, 0x010000, CRC(ee5020fa) SHA1(926c217d345a62b2b5073f35463ba67cf03b068b) )
-	ROM_LOAD( "rovr208a", 0x0000, 0x010000, CRC(ee5020fa) SHA1(926c217d345a62b2b5073f35463ba67cf03b068b) )
-	ROM_LOAD( "rovr5.10", 0x0000, 0x010000, CRC(2de4c3a0) SHA1(3342d3a6ca7a6f20aa0e094f64f757f1dcc43fa9) )
-	ROM_LOAD( "rovr5.8", 0x0000, 0x010000, CRC(ff6bd9fe) SHA1(39e6ba2ee37ea029d307456b3e254e26d34697f3) )
-	ROM_LOAD( "rret5p5c", 0x0000, 0x010000, CRC(ce590a5a) SHA1(f9b93fa830c7d49b52c327a7cf7fa98b357ea695) )
-	ROM_LOAD( "rret5p8c", 0x0000, 0x010000, CRC(7183b915) SHA1(dd0bc6668013774e429d6fcaa82d518232c08ada) )
-	ROM_LOAD( "rret5p8cbin", 0x0000, 0x010000, CRC(3fd51c76) SHA1(dd466b34277611dc8e61d182dbf35be2f4771ce3) )
-	ROM_LOAD( "rret665p", 0x0000, 0x010000, CRC(0656ad1b) SHA1(d1efb0cde9354087815ea260ccc81152c1ccf354) )
-	ROM_LOAD( "sa5-342", 0x0000, 0x010000, CRC(735e8151) SHA1(25b9f183e03c74fd918c9c540e5ebd0dc0d38fcd) )
-	ROM_LOAD( "sa5-343", 0x0000, 0x010000, CRC(9bb61cb7) SHA1(0c42d7db308dac80a4910b2d2327833562e9c887) )
-	ROM_LOAD( "sa5-344", 0x0000, 0x010000, CRC(ee5020fa) SHA1(926c217d345a62b2b5073f35463ba67cf03b068b) )
-	ROM_LOAD( "sa5-345", 0x0000, 0x010000, CRC(06b8bd1c) SHA1(52c43b7f2774accdde4c153c84b5051df84cbe29) )
-	ROM_LOAD( "sa5-354", 0x0000, 0x010000, CRC(132d0aec) SHA1(fd7febd1b7098a6a3b00fa5ed5f0323821fea9da) )
-	ROM_LOAD( "sa5-355", 0x0000, 0x010000, CRC(fbc5970a) SHA1(41cf94e2ab0dc3d020cf30cf63c8939958e7805a) )
-	ROM_LOAD( "sa5-539", 0x0000, 0x010000, CRC(8ba27a8e) SHA1(27ec7503d84585bbb791f6b4ee1ef538dcd5f619) )
-	ROM_LOAD( "sa6-203", 0x0000, 0x010000, CRC(dd4570e5) SHA1(16f1530d68dcd043f67084c339b02f093d45c6cb) )
-	ROM_LOAD( "sa6-252", 0x0000, 0x010000, CRC(31d81c51) SHA1(65d5578c7837499d0bfdacbe95400adff00cd24c) )
-	ROM_LOAD( "sa6-253", 0x0000, 0x010000, CRC(d93081b7) SHA1(634fe0a75be7d4a175f11da6a6c045e215a8c139) )
-	ROM_LOAD( "sa7-176", 0x0000, 0x010000, CRC(fd89552f) SHA1(cdb38e6388ada9a893dfc4971d2c2c2898b755a7) )
-	ROM_LOAD( "sa7-177", 0x0000, 0x010000, CRC(1561c8c9) SHA1(8eea26e72f96413a6bff6b14e6acc4d311c1ea72) )
-	ROM_LOAD( "sa8-062", 0x0000, 0x010000, CRC(5eebd57e) SHA1(e4b4de1388f28e0819baca4ba9c96573c367a4a1) )
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+
+	ROM_LOAD( "sa8-067", 0x0000, 0x010000, CRC(eebe30fd) SHA1(adc278973a08a81c4a62176e6ec33af570d719ac) )//protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororra )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rov5.10", 0x0000, 0x010000, CRC(04b421ca) SHA1(c0992edf4ecdfcf7231ae560f38954ce3a4db735) )//1.1 10GBP 1995 sa8066
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrb )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-062", 0x0000, 0x010000, CRC(5eebd57e) SHA1(e4b4de1388f28e0819baca4ba9c96573c367a4a1) )//2.1
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrbh )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rret5p8c", 0x0000, 0x010000, CRC(7183b915) SHA1(dd0bc6668013774e429d6fcaa82d518232c08ada) )//2.1 sa8062 hack
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrb1 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rov5.8", 0x0000, 0x010000, CRC(79be1896) SHA1(78a3f62fcbb2073257eeebc03524852d0c9d4648) )//2.1 8GBP 1995 sa8062
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrbp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa8-063", 0x0000, 0x010000, CRC(b6034898) SHA1(167f37456b9f3ffcc10adc910a5003b044473634) )
-	ROM_LOAD( "sa8-066", 0x0000, 0x010000, CRC(0656ad1b) SHA1(d1efb0cde9354087815ea260ccc81152c1ccf354) )
-	ROM_LOAD( "sa8-067", 0x0000, 0x010000, CRC(eebe30fd) SHA1(adc278973a08a81c4a62176e6ec33af570d719ac) )
 
-	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )
-	ROM_LOAD( "roversreturn.p1", 0x000000, 0x080000, CRC(b21d4cca) SHA1(ad54c4f44de2c596fd5e8330666d0f4f859bfcb2) )
-	ROM_LOAD( "roversreturn.p2", 0x080000, 0x080000, CRC(354a91e0) SHA1(13f3e1eacba3c80c83f12491d2668cc54536245a) )
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrc )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rovr5.10", 0x0000, 0x010000, CRC(2de4c3a0) SHA1(3342d3a6ca7a6f20aa0e094f64f757f1dcc43fa9) ) // 1.1 sa7178
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrc1 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rret5p5c", 0x0000, 0x010000, CRC(ce590a5a) SHA1(f9b93fa830c7d49b52c327a7cf7fa98b357ea695) )//1.1 sa7178
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrc2 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rret5p8cbin", 0x0000, 0x010000, CRC(3fd51c76) SHA1(dd466b34277611dc8e61d182dbf35be2f4771ce3) )//1.1 sa7178
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrd )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rovr5.8", 0x0000, 0x010000, CRC(ff6bd9fe) SHA1(39e6ba2ee37ea029d307456b3e254e26d34697f3) )//1.1 sa7176
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrdp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-177", 0x0000, 0x010000, CRC(1561c8c9) SHA1(8eea26e72f96413a6bff6b14e6acc4d311c1ea72) )//protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororre )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-176", 0x0000, 0x010000, CRC(fd89552f) SHA1(cdb38e6388ada9a893dfc4971d2c2c2898b755a7) )
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrf )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa6-252", 0x0000, 0x010000, CRC(31d81c51) SHA1(65d5578c7837499d0bfdacbe95400adff00cd24c) )//BW code?
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrfp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa6-253", 0x0000, 0x010000, CRC(d93081b7) SHA1(634fe0a75be7d4a175f11da6a6c045e215a8c139) )//BW protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrg )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "roversprog", 0x0000, 0x010000, CRC(35aded03) SHA1(978c49dad02cd1bb290028aa52d3048c5f2b9bdd) )//1.1 1995 sa6-202
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrgp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa6-203", 0x0000, 0x010000, CRC(dd4570e5) SHA1(16f1530d68dcd043f67084c339b02f093d45c6cb) )//protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrh )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-539", 0x0000, 0x010000, CRC(8ba27a8e) SHA1(27ec7503d84585bbb791f6b4ee1ef538dcd5f619) )
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororri )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-354", 0x0000, 0x010000, CRC(132d0aec) SHA1(fd7febd1b7098a6a3b00fa5ed5f0323821fea9da) ) //3.1
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrip )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-355", 0x0000, 0x010000, CRC(fbc5970a) SHA1(41cf94e2ab0dc3d020cf30cf63c8939958e7805a) )//protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrj )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "rover8ac", 0x0000, 0x010000, CRC(1f6bff96) SHA1(862e32dc9ea3fad5ef27b9146a8a62138d3b6406) )//5.1 8GBP 1995 All cash sa5-354
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrjp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-345", 0x0000, 0x010000, CRC(06b8bd1c) SHA1(52c43b7f2774accdde4c153c84b5051df84cbe29) ) //protocol
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrk )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-344", 0x0000, 0x010000, CRC(ee5020fa) SHA1(926c217d345a62b2b5073f35463ba67cf03b068b) ) //2.1 8gbp token
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrl )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-342", 0x0000, 0x010000, CRC(735e8151) SHA1(25b9f183e03c74fd918c9c540e5ebd0dc0d38fcd) )
+
+	m1_cororr_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1cororrlp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-343", 0x0000, 0x010000, CRC(9bb61cb7) SHA1(0c42d7db308dac80a4910b2d2327833562e9c887) )//protocol
+
+	m1_cororr_sound
 ROM_END_M1A_MCU
 
 ROM_START( m1corocb )
 	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "ccoro250v1-1.rom", 0x0000, 0x020000, CRC(e2188b21) SHA1(86238d31595814d9d1f82544c9766d068b6df132) )
+	ROM_LOAD( "sc7-198", 0x0000, 0x020000, CRC(905b916d) SHA1(4c244ee49b4528e05cb074f0df0b3bbfd6b28fd2) )//2.1
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
-	ROM_LOAD( "sc7-197", 0x0000, 0x020000, CRC(b259759d) SHA1(cd84d959a4bcfcd942322af9f33893e626fe8759) )
-	ROM_LOAD( "sc7-198", 0x0000, 0x020000, CRC(905b916d) SHA1(4c244ee49b4528e05cb074f0df0b3bbfd6b28fd2) )
-	ROM_LOAD( "sc7-199", 0x0000, 0x020000, CRC(c01a6fd1) SHA1(2bb62f190843acb8850241ccd45fb17167c18376) )
+	m1_corocb_sound
+ROM_END_M1A_MCU
 
-	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )
-	ROM_LOAD( "clubcorriesnd.p1snd", 0x000000, 0x080000, CRC(e4cf4412) SHA1(6849fb9a71a6f0bbf40368238ed9104026013d36) )
-	ROM_LOAD( "clubcorriesnd.p2snd", 0x080000, 0x080000, CRC(e33d2c08) SHA1(fd30b9c2936659a793d83e283d920c46990633c4) )
+ROM_START( m1corocbp )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sc7-199", 0x0000, 0x020000, CRC(c01a6fd1) SHA1(2bb62f190843acb8850241ccd45fb17167c18376) )//2.1 protocol
+
+	m1_corocb_sound
 ROM_END_M1A_MCU
 
+ROM_START( m1corocb1 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sc7-196", 0x0000, 0x020000, CRC(e2188b21) SHA1(86238d31595814d9d1f82544c9766d068b6df132) )//sc7196 250 GBP 1.1
+
+	m1_corocb_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1corocb1p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sc7-197", 0x0000, 0x020000, CRC(b259759d) SHA1(cd84d959a4bcfcd942322af9f33893e626fe8759) )//protocol
+
+	m1_corocb_sound
+ROM_END_M1A_MCU
+
+//TODO: No audio ROMs, it may use the main Coronation Street set (m1_coro_sound) as this is a prize vending version of same
+//That would make it a clone of m1coro, need to check that
+
 ROM_START( m1corosh )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa4-342", 0x0000, 0x010000, CRC(47ac83cf) SHA1(d23e14a714121bb67c130aae4b85bdcf62a949b6) )
+ROM_END_M1A_MCU
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
+ROM_START( m1coroshp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa4-343", 0x0000, 0x010000, CRC(af441e29) SHA1(6631d5282f896c9a7fe1b2e41c19d58dfef4e644) )
 ROM_END_M1A_MCU
 
 ROM_START( m1criss )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "crisscross.bin", 0x0000, 0x010000, CRC(422c5c6d) SHA1(b3a86f7482f0376b93899d28d4e6c610200fcd3a) )
+	ROM_LOAD( "sdt-050", 0x0000, 0x010000, CRC(422c5c6d) SHA1(b3a86f7482f0376b93899d28d4e6c610200fcd3a) )
 
 	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )
 	ROM_LOAD( "ccsound.bin", 0x0000, 0x040000, CRC(8742981e) SHA1(1ba33c59ec5f878ebab111a77551213aad4b0993) )
@@ -2103,39 +2279,143 @@
 
 ROM_START( m1dxmono )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "delmonopolygame.bin", 0x0000, 0x010000, CRC(b15da041) SHA1(caf85c80fc6128c8c28bdb9ea3e37308a15279de) )
+	ROM_LOAD( "sa6-018", 0x0000, 0x010000, CRC(134e772a) SHA1(e85a90ed475cd3b38e9174146b15c66c958116e5) )//M5.1 (code 48)
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
-	ROM_LOAD( "deluxe_monopoly_v1_1", 0x0000, 0x010000, CRC(303bea68) SHA1(987f015818a1d97299af824c0ab58c9c6f8a2acb) )
-	ROM_LOAD( "mondx5p5bin", 0x0000, 0x010000, CRC(53d44098) SHA1(45ae90464e2f9d4a2c7dc846acbc8f48449b3dab) )
-	ROM_LOAD( "monodx8", 0x0000, 0x010000, CRC(4d6101a3) SHA1(86f9bde8aec67566b7b58fec8f01f09878773dc1) )
-	ROM_LOAD( "sa3-032", 0x0000, 0x010000, CRC(8fe139f6) SHA1(0a7f78d284706199993a5f41adcf70bc50faa433) )
-	ROM_LOAD( "sa4-098.bin", 0x0000, 0x010000, CRC(1775f26d) SHA1(89a96955ca4f345b0451c652939e93c93629c0d4) )
-	ROM_LOAD( "sa4-261.bin", 0x0000, 0x010000, CRC(10854aab) SHA1(1b61d435814aa2f0eba565a5ac095e47f61bd0b2) )
-	ROM_LOAD( "sa4-376.bin", 0x0000, 0x010000, CRC(44a94d58) SHA1(194e004dd68125f0c5bd83ea467cc1ebb5e616d6) )
-	ROM_LOAD( "sa4-377.bin", 0x0000, 0x010000, CRC(ac41d0be) SHA1(bf049f247c273f9c09b02157a2e1d2af39ba612b) )
-	ROM_LOAD( "sa5-078", 0x0000, 0x010000, CRC(f8eeb449) SHA1(820b075c931918a86c06946a7a6ce0b6db2c44b2) )
-	ROM_LOAD( "sa6-015", 0x0000, 0x010000, CRC(fc7a30aa) SHA1(9133894464ba6bfb64996edb5bd99d88e34340c4) )
-	ROM_LOAD( "sa6-018", 0x0000, 0x010000, CRC(134e772a) SHA1(e85a90ed475cd3b38e9174146b15c66c958116e5) )
-	ROM_LOAD( "sa6-019", 0x0000, 0x010000, CRC(fba6eacc) SHA1(80576722f5862c1f27eb6e6d43d9a0a665e611c6) )
-
-	// BWB Sets
-	ROM_LOAD( "dm_x6_b_.1o1", 0x0000, 0x010000, CRC(77824728) SHA1(b836a6a2f42d2d8e46cc532db5b4052e16dafa87) )
-	ROM_LOAD( "dm_x6_d_.1o1", 0x0000, 0x010000, CRC(05d4c471) SHA1(b5a26ff4824dd68de629911a60705375748cba1c) )
-	ROM_LOAD( "dm_x6_k_.1o1", 0x0000, 0x010000, CRC(9f6adace) SHA1(958c710736d661756a1f25ba3d51554c2f05e4fc) )
-	ROM_LOAD( "dmix6___.1o1", 0x0000, 0x010000, CRC(82f472a4) SHA1(c5cda8f7ae6fe69e1cd4044b3816da665b6ba9bc) )
-	ROM_LOAD( "dmix6_d_.1o1", 0x0000, 0x010000, CRC(6a1cef42) SHA1(e9178fbcf29ff565d0672b550a92516c92ebfaa4) )
-	ROM_LOAD( "mdlx10", 0x0000, 0x010000, CRC(e87ff39a) SHA1(4a5bc1d094b18cec55b7ed8291db68b73ee860ae) )
-	ROM_LOAD( "monodeluxesa2-356 nd.bin", 0x0000, 0x010000, CRC(3d4394e9) SHA1(43da2007f1408d45764f0eba8594c800ad7ffc60) )
-
-	ROM_LOAD( "sa4-196", 0x0000, 0x010000, CRC(9f6adace) SHA1(958c710736d661756a1f25ba3d51554c2f05e4fc) )
-	ROM_LOAD( "sa4-197", 0x0000, 0x010000, CRC(77824728) SHA1(b836a6a2f42d2d8e46cc532db5b4052e16dafa87) )
-	ROM_LOAD( "sa4-199", 0x0000, 0x010000, CRC(05d4c471) SHA1(b5a26ff4824dd68de629911a60705375748cba1c) )
-	ROM_LOAD( "sa5-080", 0x0000, 0x010000, CRC(82f472a4) SHA1(c5cda8f7ae6fe69e1cd4044b3816da665b6ba9bc) )
+	m1_dxmono_sound
+ROM_END_M1A_MCU
 
+ROM_START( m1dxmonop )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa6-019", 0x0000, 0x010000, CRC(fba6eacc) SHA1(80576722f5862c1f27eb6e6d43d9a0a665e611c6) )//M5.1 Protocol (code 48)
 
-	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )
-	ROM_LOAD( "delmonopolysound.bin", 0x0000, 0x040000, CRC(8742981e) SHA1(1ba33c59ec5f878ebab111a77551213aad4b0993) )
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono12n )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa6-015", 0x0000, 0x010000, CRC(fc7a30aa) SHA1(9133894464ba6bfb64996edb5bd99d88e34340c4) )//M1.2 (code 48)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono31b )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-080", 0x0000, 0x010000, CRC(82f472a4) SHA1(c5cda8f7ae6fe69e1cd4044b3816da665b6ba9bc) )//f3.1 (dmix6___.1o1 BWB)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono31p )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-081", 0x0000, 0x010000, CRC(6a1cef42) SHA1(e9178fbcf29ff565d0672b550a92516c92ebfaa4) )//f3.1  Protocol (dmix6_d_.1o1 BWB)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono31h )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "mondx5p5bin", 0x0000, 0x010000, CRC(53d44098) SHA1(45ae90464e2f9d4a2c7dc846acbc8f48449b3dab) )//sa5080 hack 5p 5GBP
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono31h2 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "monodx8", 0x0000, 0x010000, CRC(4d6101a3) SHA1(86f9bde8aec67566b7b58fec8f01f09878773dc1) )//sa5080 hack 8GBP (part no deleted)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono51 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa5-078", 0x0000, 0x010000, CRC(f8eeb449) SHA1(820b075c931918a86c06946a7a6ce0b6db2c44b2) )//M5.1
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono12 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-376", 0x0000, 0x010000, CRC(44a94d58) SHA1(194e004dd68125f0c5bd83ea467cc1ebb5e616d6) )//M1.2
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono12p )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-377", 0x0000, 0x010000, CRC(ac41d0be) SHA1(bf049f247c273f9c09b02157a2e1d2af39ba612b) )//M1.2 Protocol
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono12a )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-261", 0x0000, 0x010000, CRC(10854aab) SHA1(1b61d435814aa2f0eba565a5ac095e47f61bd0b2) )//M1.2
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono21p )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-199", 0x0000, 0x010000, CRC(05d4c471) SHA1(b5a26ff4824dd68de629911a60705375748cba1c) )//f2.1 Protocol (dm_x6_d_.1o1 BWB)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono11p )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-197", 0x0000, 0x010000, CRC(77824728) SHA1(b836a6a2f42d2d8e46cc532db5b4052e16dafa87) )//f1.1 Protocol (dm_x6_b_.1o1 BWB)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+
+ROM_START( m1dxmono11 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-196", 0x0000, 0x010000, CRC(9f6adace) SHA1(958c710736d661756a1f25ba3d51554c2f05e4fc) )//f1.1 (dm_x6_k_.1o1 BWB)
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono51o )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-097", 0x0000, 0x010000, CRC(b15da041) SHA1(caf85c80fc6128c8c28bdb9ea3e37308a15279de) )//M5.1 92
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono51p )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-098", 0x0000, 0x010000, CRC(1775f26d) SHA1(89a96955ca4f345b0451c652939e93c93629c0d4) ) //M5.1 protocol
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono30h )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "mdlx10", 0x0000, 0x010000, CRC(e87ff39a) SHA1(4a5bc1d094b18cec55b7ed8291db68b73ee860ae) )//m3.0 hack
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono11o )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa3-032", 0x0000, 0x010000, CRC(8fe139f6) SHA1(0a7f78d284706199993a5f41adcf70bc50faa433) )//O11
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono11m )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa3-007", 0x0000, 0x010000, CRC(303bea68) SHA1(987f015818a1d97299af824c0ab58c9c6f8a2acb) )//sa3007 M 1.1 92
+
+	m1_dxmono_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dxmono11mb )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa2-356", 0x0000, 0x010000, CRC(3d4394e9) SHA1(43da2007f1408d45764f0eba8594c800ad7ffc60) )//m1.1 sa2356
+
+	m1_dxmono_sound
 ROM_END_M1A_MCU
 
 ROM_START( m1dmnhrt )
@@ -2145,51 +2425,207 @@
 
 ROM_START( m1dm4ev )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "dafor200", 0x0000, 0x010000, CRC(0a1a3906) SHA1(bb16251bdf4726799218bf252b47184d999f97dc) )
+	ROM_LOAD( "sc4-085.bin", 0x0000, 0x010000, CRC(80cc889e) SHA1(464f08523754454e97e00108edc28a4accef204a) )//5.1
+ROM_END_M1A_MCU
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
-	ROM_LOAD( "sc4-085.bin", 0x0000, 0x010000, CRC(80cc889e) SHA1(464f08523754454e97e00108edc28a4accef204a) )
-	ROM_LOAD( "sc4-086.bin", 0x0000, 0x010000, CRC(7eccadaa) SHA1(9d3d3f990960cf57eac033786826b046e15d594e) )
+ROM_START( m1dm4evp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sc4-086", 0x0000, 0x010000, CRC(7eccadaa) SHA1(9d3d3f990960cf57eac033786826b046e15d594e) )//5.1 p
+ROM_END_M1A_MCU
+
+ROM_START( m1dm4ev11 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sc3-301", 0x0000, 0x010000, CRC(0a1a3906) SHA1(bb16251bdf4726799218bf252b47184d999f97dc) )//200 GBP
 ROM_END_M1A_MCU
 
 ROM_START( m1dkong )
 	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "dko6615r", 0x0000, 0x020000, CRC(63768b11) SHA1(b7b0be4efcf61fb4c3c20c98844cadf879eba871) )
+	ROM_LOAD( "sa001014", 0x0000, 0x020000, CRC(1c6db3b3) SHA1(2ae8797d1794358bde6dca296a921d0a96277531) )//9_2
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
-	ROM_LOAD( "dkon510", 0x0000, 0x020000, CRC(56338a54) SHA1(b066bdf7f18793936790211c6d1eecb23391e63f) )
-	ROM_LOAD( "dkon55", 0x0000, 0x020000, CRC(37305db5) SHA1(977d960931151b3c11a191c4661ee374e4f2dc45) )
-	ROM_LOAD( "dkong.bin", 0x0000, 0x020000, CRC(c6a63fe4) SHA1(090fa72ce5329b0bf1aec3bdf6cf1abc8298b3dd) )
-	ROM_LOAD( "dkong10", 0x0000, 0x020000, CRC(d4793c7f) SHA1(677b1f1065be15ec4b431a67138358830c687549) )
-	ROM_LOAD( "dkong15.bin", 0x0000, 0x020000, CRC(c6a63fe4) SHA1(090fa72ce5329b0bf1aec3bdf6cf1abc8298b3dd) )
-	ROM_LOAD( "dkong5.bin", 0x0000, 0x020000, CRC(cc3a66e6) SHA1(77e5cd98cb060e7730a66e35023d051ed606ed03) )
-	ROM_LOAD( "dkong8.bin", 0x0000, 0x020000, CRC(023a660a) SHA1(a64c6d415ef1990d55abdc3cad8af81d3dac8369) )
-	ROM_LOAD( "donk10fo", 0x0000, 0x020000, CRC(39fa98ea) SHA1(8405fa612c1e2bd1c8df260737072f46931cc303) )
-	ROM_LOAD( "kong15f", 0x0000, 0x020000, CRC(367ab43f) SHA1(6940e6922d32126d67c2b0c47282e4bf42ebaf04) )
-	ROM_LOAD( "kong5p8.bin", 0x0000, 0x020000, CRC(14380d4c) SHA1(3e66809af45f216489a5c65930726be0f5a6c555) )
-	ROM_LOAD( "sa001014", 0x0000, 0x020000, CRC(1c6db3b3) SHA1(2ae8797d1794358bde6dca296a921d0a96277531) )
-	ROM_LOAD( "sa001015", 0x0000, 0x020000, CRC(1a796fce) SHA1(163d58a3258309f5183b575b9e651f1c2f53ce36) )
-	ROM_LOAD( "sa7-109", 0x0000, 0x020000, CRC(06aec0d7) SHA1(aa1dd411aa43ecf0908cb9db64636de319041159) )
-	ROM_LOAD( "sa7-110", 0x0000, 0x020000, CRC(7f2bd92c) SHA1(d0f41d63db4e71ee4a7cc2ea878add0c72b1c7bb) )
-	ROM_LOAD( "sa7-115", 0x0000, 0x020000, CRC(09efe6ed) SHA1(120615bb9b69386b5fffdf8756de16415b8ce778) )
-	ROM_LOAD( "sa7-116", 0x0000, 0x020000, CRC(1a28ddbb) SHA1(e28297885c1321cff5bf87cbf9d98f3b6ae005d6) )
-	ROM_LOAD( "sa7-284", 0x0000, 0x020000, CRC(d4793c7f) SHA1(677b1f1065be15ec4b431a67138358830c687549) )
-	ROM_LOAD( "sa7-285", 0x0000, 0x020000, CRC(8438c2c3) SHA1(4fce8a96def574b7a44f45163b2141eb5629a5f1) )
-	ROM_LOAD( "sa7-288", 0x0000, 0x020000, CRC(adc1603a) SHA1(6f34234dbfb8e042819c5ea4a11be7029949fa96) )
-	ROM_LOAD( "sa7-289", 0x0000, 0x020000, CRC(fd809e86) SHA1(e41cef2cc6b3eee39ac3344b1573822c6f681c8f) )
-	ROM_LOAD( "sa7-293", 0x0000, 0x020000, CRC(527b98b6) SHA1(4d3c317a1719f7efa2825da60b75e1beed698ecf) )
-	ROM_LOAD( "sa7-731", 0x0000, 0x020000, CRC(39fa98ea) SHA1(8405fa612c1e2bd1c8df260737072f46931cc303) )
-	ROM_LOAD( "sa7-732", 0x0000, 0x020000, CRC(2a3da3bc) SHA1(7a56e4e3bd12e900ed0f36241891b73f1981586a) )
-	ROM_LOAD( "sa8-052", 0x0000, 0x020000, CRC(00671257) SHA1(e977b764dbaeb519f6d3174f786ba75628733bf8) )
-	ROM_LOAD( "sa8-053", 0x0000, 0x020000, CRC(5026eceb) SHA1(7c444c380ee888e43e0f95577f09a1d949f1e010) )
-	ROM_LOAD( "sa8-068", 0x0000, 0x020000, CRC(a5bfa528) SHA1(3b7619af8b4908986c15b777c953f34792126c31) )
-	ROM_LOAD( "sa8-069", 0x0000, 0x020000, CRC(f5fe5b94) SHA1(49d3ae41c013140dbae32b9a4ab62202a39fd761) )
-	ROM_LOAD( "sa8-112", 0x0000, 0x020000, CRC(658ba678) SHA1(2b95d2fcb14f6d10adf2db075b2598c262994fe1) )
-	ROM_LOAD( "sa991072", 0x0000, 0x020000, CRC(2f9e63f1) SHA1(e912bee785f4b3d5b1894a42dbceadded34b0776) )
+	m1_dkong_sound
+ROM_END_M1A_MCU
 
-	ROM_REGION( 0x100000, "oki", ROMREGION_ERASE00  )
-	ROM_LOAD( "donkeykong.p1", 0x0000, 0x080000, CRC(11019875) SHA1(b171b46a7a98967668793a7ea7b5931c7a76dd82) )
-	ROM_LOAD( "donkeykong.p2", 0x0000, 0x080000, CRC(e28f406f) SHA1(42a58c0f5c4f25dec4c0c49eb8415971a515c5a6) )
+ROM_START( m1dkongp )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa001015", 0x0000, 0x020000, CRC(1a796fce) SHA1(163d58a3258309f5183b575b9e651f1c2f53ce36) )//9_2 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkonga )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-168", 0x0000, 0x020000, CRC(367ab43f) SHA1(6940e6922d32126d67c2b0c47282e4bf42ebaf04) )//sa8168 9_2 15gbp
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91n )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa991071", 0x0000, 0x020000, CRC(c6a63fe4) SHA1(090fa72ce5329b0bf1aec3bdf6cf1abc8298b3dd) )//sa991071 9_1 Newest
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91np )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa991072", 0x0000, 0x020000, CRC(2f9e63f1) SHA1(e912bee785f4b3d5b1894a42dbceadded34b0776) )//9_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+
+ROM_START( m1dkong91na )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-166", 0x0000, 0x020000, CRC(63768b11) SHA1(b7b0be4efcf61fb4c3c20c98844cadf879eba871) )//sa8166 9_1 15gbp
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong21n )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-112", 0x0000, 0x020000, CRC(658ba678) SHA1(2b95d2fcb14f6d10adf2db075b2598c262994fe1) )//2_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-068", 0x0000, 0x020000, CRC(a5bfa528) SHA1(3b7619af8b4908986c15b777c953f34792126c31) )//9_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-069", 0x0000, 0x020000, CRC(f5fe5b94) SHA1(49d3ae41c013140dbae32b9a4ab62202a39fd761) )//9_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91a )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "dkon55", 0x0000, 0x020000, CRC(37305db5) SHA1(977d960931151b3c11a191c4661ee374e4f2dc45) )//sa8068 9_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91h1 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "dkong5.bin", 0x0000, 0x020000, CRC(cc3a66e6) SHA1(77e5cd98cb060e7730a66e35023d051ed606ed03) )//sa8068 hack
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong91h2 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "kong5p8.bin", 0x0000, 0x020000, CRC(14380d4c) SHA1(3e66809af45f216489a5c65930726be0f5a6c555) )//sa8068 hack
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong81n )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-052", 0x0000, 0x020000, CRC(00671257) SHA1(e977b764dbaeb519f6d3174f786ba75628733bf8) )//8_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong81na )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "dkon510", 0x0000, 0x020000, CRC(56338a54) SHA1(b066bdf7f18793936790211c6d1eecb23391e63f) )//sa8052 8_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong81np )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa8-053", 0x0000, 0x020000, CRC(5026eceb) SHA1(7c444c380ee888e43e0f95577f09a1d949f1e010) )//8_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong21 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-731", 0x0000, 0x020000, CRC(39fa98ea) SHA1(8405fa612c1e2bd1c8df260737072f46931cc303) )//10GBP FO 2_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong21p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-732", 0x0000, 0x020000, CRC(2a3da3bc) SHA1(7a56e4e3bd12e900ed0f36241891b73f1981586a) )//2_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong31 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-288", 0x0000, 0x020000, CRC(adc1603a) SHA1(6f34234dbfb8e042819c5ea4a11be7029949fa96) )//3_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong31p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-289", 0x0000, 0x020000, CRC(fd809e86) SHA1(e41cef2cc6b3eee39ac3344b1573822c6f681c8f) )//3_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong51 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "dkong8.bin", 0x0000, 0x020000, CRC(023a660a) SHA1(a64c6d415ef1990d55abdc3cad8af81d3dac8369) )//sa7292 5_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong51p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-293", 0x0000, 0x020000, CRC(527b98b6) SHA1(4d3c317a1719f7efa2825da60b75e1beed698ecf) )//5_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong11 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-284", 0x0000, 0x020000, CRC(d4793c7f) SHA1(677b1f1065be15ec4b431a67138358830c687549) )//10GBP 1_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong11p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-285", 0x0000, 0x020000, CRC(8438c2c3) SHA1(4fce8a96def574b7a44f45163b2141eb5629a5f1) )//1_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong81 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-115", 0x0000, 0x020000, CRC(09efe6ed) SHA1(120615bb9b69386b5fffdf8756de16415b8ce778) )//8_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong81p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-116", 0x0000, 0x020000, CRC(1a28ddbb) SHA1(e28297885c1321cff5bf87cbf9d98f3b6ae005d6) )//8_1 Protocol
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong41 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-109", 0x0000, 0x020000, CRC(06aec0d7) SHA1(aa1dd411aa43ecf0908cb9db64636de319041159) )//4_1
+
+	m1_dkong_sound
+ROM_END_M1A_MCU
+
+ROM_START( m1dkong41p )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa7-110", 0x0000, 0x020000, CRC(7f2bd92c) SHA1(d0f41d63db4e71ee4a7cc2ea878add0c72b1c7bb) )//4_1 Protocol
+
+	m1_dkong_sound
 ROM_END_M1A_MCU
 
 ROM_START( m1ee )
@@ -2831,11 +3267,17 @@
 
 ROM_START( m1liveam )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "sa4-446", 0x0000, 0x010000, CRC(bb3c979a) SHA1(ea5aff8a689a8cee30088e64f94d6a8787a85100) )
+ROM_END_M1A_MCU
+
+ROM_START( m1liveama )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa3-473", 0x0000, 0x010000, CRC(e8688274) SHA1(685de7fa350d80946d3dfe9b2d25ed07c2a493c2) )
+ROM_END_M1A_MCU
 
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
+ROM_START( m1liveamp )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00  )
 	ROM_LOAD( "sa3-502.bin", 0x0000, 0x010000, CRC(a65f5f5f) SHA1(dd02db137ad195845630f47a3c42b38d7a2cb8f3) )
-	ROM_LOAD( "sa4-446", 0x0000, 0x010000, CRC(bb3c979a) SHA1(ea5aff8a689a8cee30088e64f94d6a8787a85100) )
 ROM_END_M1A_MCU
 
 
@@ -3914,11 +4356,22 @@
 
 ROM_START( m1luxor )
 	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
-	ROM_LOAD( "luxor_pound5f.3v3", 0x0000, 0x020000, CRC(75a95629) SHA1(1366f1bf1f88feee14af306d15fe74c2c9d1dff8) )
-	ROM_REGION( 0x20000, "altrevs", ROMREGION_ERASE00  )
 	ROM_LOAD( "luxor_pound8f.4_0", 0x0000, 0x020000, CRC(3a0fdf4a) SHA1(4a3797ea5440df8a0d40ea187d0b41a77407e9ef) )
-	ROM_LOAD( "lux_pound15", 0x0000, 0x020000, CRC(94e8d1c2) SHA1(7a50477cf2d4bb404d2e33dd545c51e62bf4031d) )
-	ROM_LOAD( "lux_pound5", 0x0000, 0x020000, CRC(a5d78869) SHA1(0b76345374554d467c78751083a6b3ce2499f795) )
+ROM_END
+
+ROM_START( m1luxor33 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "luxor_pound5f.3v3", 0x0000, 0x020000, CRC(75a95629) SHA1(1366f1bf1f88feee14af306d15fe74c2c9d1dff8) )
+ROM_END
+
+ROM_START( m1luxor32 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "lux_pound5", 0x0000, 0x020000, CRC(a5d78869) SHA1(0b76345374554d467c78751083a6b3ce2499f795) )//3_2
+ROM_END
+
+ROM_START( m1luxor21 )
+	ROM_REGION( 0x20000, "maincpu", ROMREGION_ERASE00  )
+	ROM_LOAD( "lux_pound15", 0x0000, 0x020000, CRC(94e8d1c2) SHA1(7a50477cf2d4bb404d2e33dd545c51e62bf4031d) )//2_1
 ROM_END
 
 
@@ -4180,14 +4633,95 @@
 GAME( 1993, m1coro21v	,m1coro		,m1,m1,m1, ROT0, "Maygay", "Coronation Street (Maygay) v2.1 (Multivend) (M1A/B)",GAME_FLAGS )
 GAME( 1993, m1coro21vp	,m1coro		,m1,m1,m1, ROT0, "Maygay", "Coronation Street (Maygay) v2.1 (Multivend) (Protocol)(M1A/B)",GAME_FLAGS )
 
-GAME( 199?, m1cororr	,0			,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1corocb	,0			,m1,m1,m1, ROT0, "Maygay", "Coronation Street Club (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1corosh	,0			,m1,m1,m1, ROT0, "Maygay", "Coronation Street Showcase (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1criss		,0			,m1,m1,m1, ROT0, "Maygay", "Criss Cross Club (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1dxmono	,0			,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororr	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 1) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 1) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororra	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 1) (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrb	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 2) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrbh	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 2) (Hack) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrb1	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 2) (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrbp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 2) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrc	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 3) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrc1	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 3) (Alternate 1) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrc2	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 3) (Alternate 2) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrd	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 4) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrdp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 4) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororre	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 5) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrf	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 6) (BW) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrfp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 6) (BW) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrg	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 7) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrgp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 7) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrh	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 8) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororri	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 9) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrip	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 9) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrj	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 10) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrjp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 10) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrk	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 11) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrl	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 12) (M1A/B)",GAME_FLAGS )
+GAME( 1995, m1cororrlp	,m1cororr	,m1,m1,m1, ROT0, "Maygay", "Coronation Street - Rovers Return (Maygay) (set 12) (Protocol) (M1A/B)",GAME_FLAGS )
+
+GAME( 1994, m1corocb	,0			,m1,m1,m1, ROT0, "Maygay", "Coronation Street Club (Maygay) v2.1 (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1corocbp	,m1corocb	,m1,m1,m1, ROT0, "Maygay", "Coronation Street Club (Maygay) v2.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1corocb1	,m1corocb	,m1,m1,m1, ROT0, "Maygay", "Coronation Street Club (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1corocb1p	,m1corocb	,m1,m1,m1, ROT0, "Maygay", "Coronation Street Club (Maygay) v1.1 (Protocol)(M1A/B)",GAME_FLAGS )
+
+GAME( 1993, m1corosh	,0			,m1,m1,m1, ROT0, "Maygay", "Coronation Street Showcase (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+GAME( 1993, m1coroshp	,m1corosh	,m1,m1,m1, ROT0, "Maygay", "Coronation Street Showcase (Maygay) v1.1 (Protocol)(M1A/B)",GAME_FLAGS )
+
+GAME( 199?, m1criss		,0			,m1,m1,m1, ROT0, "Maygay", "Criss Cross Club (Maygay) (Dutch) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono	,0			,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v5.1 (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmonop	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v5.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono12n	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.2 (Newer) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono31b	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v3.1 (BwB set) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono31p	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v3.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono31h	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v3.1 (Hack) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono31h2,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v3.1 (Alternate Hack) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono51	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v5.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono12	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.2 (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono12p	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.2 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono12a	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.2 (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono21p	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v2.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono11p	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono11	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono51o	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v5.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono51p	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v5.1 (Older) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono30h	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v3.0 (Hack) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono11o	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono11m	,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.1 (Code M) (M1A/B)",GAME_FLAGS )
+GAME( 1992, m1dxmono11mb,m1dxmono	,m1,m1,m1, ROT0, "Maygay", "Deluxe Monopoly (Maygay) v1.1 (Code M, Alternate) (M1A/B)",GAME_FLAGS )
+
 GAME( 199?, m1dmnhrt	,0			,m1,m1,m1, ROT0, "Maygay", "Diamond Hearts (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1dm4ev		,0			,m1,m1,m1, ROT0, "Maygay", "Diamonds Are Forever Club (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1dkong		,0			,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) (M1A/B)",GAME_FLAGS )
+GAME( 199?, m1dm4ev		,0			,m1,m1,m1, ROT0, "Maygay", "Diamonds Are Forever Club (Maygay) v5.1 (M1A/B)",GAME_FLAGS )
+GAME( 199?, m1dm4evp	,m1dm4ev	,m1,m1,m1, ROT0, "Maygay", "Diamonds Are Forever Club (Maygay) v5.1 (Protocol) n(M1A/B)",GAME_FLAGS )
+GAME( 199?, m1dm4ev11	,m1dm4ev	,m1,m1,m1, ROT0, "Maygay", "Diamonds Are Forever Club (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+
+GAME( 1996, m1dkong		,0			,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.2 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkongp	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.2 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkonga	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.2 (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91n	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91np	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91na	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong81n	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v8.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong81na	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v8.1 (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong81np	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v8.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong21n	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v2.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Older) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91a	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Older) (Alternate) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91h1	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Older) (Hack 1) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong91h2	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v9.1 (Older) (Hack 2) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong81	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v8.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong81p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v8.1 (Older) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong51	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v5.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong51p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v5.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong41	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v4.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong41p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v4.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong31	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v3.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong31p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v3.1 (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong21	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v2.1 (Older) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong21p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v2.1 (Older) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong11	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+GAME( 1996, m1dkong11p	,m1dkong	,m1,m1,m1, ROT0, "Maygay", "Donkey Kong (Maygay) v1.1 (M1A/B)",GAME_FLAGS )
+
 GAME( 199?, m1ee		,0			,m1,m1,m1, ROT0, "Maygay", "Eastenders (Bwb) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1eea		,m1ee		,m1,m1,m1, ROT0, "Maygay", "Eastenders (Maygay - Bwb) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1eeb		,m1ee		,m1,m1,m1, ROT0, "Maygay", "Eastenders (Maygay) (M1A/B)",GAME_FLAGS )
@@ -4216,7 +4750,9 @@
 GAME( 199?, m1jpmult	,0			,m1,m1,m1, ROT0, "Maygay", "Jackpot Multiplier (Maygay) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1jbond		,0			,m1,m1,m1, ROT0, "Maygay", "James Bond (Maygay) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1jdwins	,0			,m1,m1,m1, ROT0, "Maygay", "Jim Davison's Winning Streak (Maygay) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1liveam	,0			,m1,m1,m1, ROT0, "Maygay", "Living In America (Maygay) (M1A/B)",GAME_FLAGS )
+GAME( 1993, m1liveam	,m1liveam	,m1,m1,m1, ROT0, "Maygay", "Living In America (Maygay) (Alternate 1) (M1A/B)",GAME_FLAGS )
+GAME( 1993, m1liveamp	,m1liveam	,m1,m1,m1, ROT0, "Maygay", "Living In America (Maygay) (Protocol) (M1A/B)",GAME_FLAGS )
+GAME( 1993, m1liveama	,m1liveam	,m1,m1,m1, ROT0, "Maygay", "Living In America (Maygay) (Alternate 2)(M1A/B)",GAME_FLAGS )
 GAME( 199?, m1lotmil	,0			,m1,m1,m1, ROT0, "Maygay", "Lottery Millionaire Club (Maygay) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1luckno	,0			,m1,m1,m1, ROT0, "Maygay", "Lucky Numbers (Maygay) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1magic		,0			,m1,m1,m1, ROT0, "Maygay", "Magic Squares (Maygay) (M1A/B)",GAME_FLAGS )
@@ -4269,7 +4805,10 @@
 
 GAME( 199?, m1bghou		,0			,m1,m1,m1, ROT0, "Gemini", "Big Ghoulies (Gemini) (M1A/B)",GAME_FLAGS )
 GAME( 199?, m1crzco		,0			,m1,m1,m1, ROT0, "Gemini", "Crazy Cobra (Gemini) (M1A/B)",GAME_FLAGS )
-GAME( 199?, m1luxor		,0			,m1,m1,m1, ROT0, "Gemini", "Luxor Casino (Gemini) (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1luxor		,0			,m1,m1,m1, ROT0, "Gemini", "Luxor Casino (Gemini) v4.0 (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1luxor33	,m1luxor	,m1,m1,m1, ROT0, "Gemini", "Luxor Casino (Gemini) v3.3 (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1luxor32	,m1luxor	,m1,m1,m1, ROT0, "Gemini", "Luxor Casino (Gemini) v3.2 (M1A/B)",GAME_FLAGS )
+GAME( 1994, m1luxor21	,m1luxor	,m1,m1,m1, ROT0, "Gemini", "Luxor Casino (Gemini) v2.1 (M1A/B)",GAME_FLAGS )
 
 // guessing these are M1A/B based on data/code starting at 0x2800
 GAME( 199?, m1hiloc		,0			,m1,m1,m1, ROT0, "Global", "Hi Lo Casino (Global) (M1A/B)",GAME_FLAGS )
diff -Nru src-old/mame/drivers/mcr.c src/mame/drivers/mcr.c
--- src-old/mame/drivers/mcr.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/mcr.c	2012-02-22 00:51:07.000000000 +0100
@@ -1994,12 +1994,12 @@
 
 ROM_START( tron3 )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* ROM's located on the Super CPU Board (90010) */
-	ROM_LOAD( "scpu_pga_3.d2", 0x0000, 0x2000, CRC(fc33afd7) SHA1(99a2ed972c3db477f35a7162079563367864f207) )
-	ROM_LOAD( "scpu_pgb_3.d3", 0x2000, 0x2000, CRC(7d9e22ac) SHA1(16a6e9651d5f764e8762fd8d6e53d13fda7473de) )
-	ROM_LOAD( "scpu_pgc_3.d4", 0x4000, 0x2000, CRC(902011c6) SHA1(17ac768a0fd1278ae83414f0d67d6ac8337f4773) )
-	ROM_LOAD( "scpu_pgd_3.d5", 0x6000, 0x2000, CRC(86477e89) SHA1(196f0d3930d10bfe4ddee82ce8b28bb99324069e) )
-	ROM_LOAD( "scpu_pge_3.d6", 0x8000, 0x2000, CRC(ea198fa8) SHA1(d8c97ea87d504e77edc38c87c2953c8c4f1a405b) )
-	ROM_LOAD( "scpu_pgf_3.d7", 0xa000, 0x2000, CRC(4325fb08) SHA1(70727aa37354425315d8a8b3ca07bbe91f7e8f08) )
+	ROM_LOAD( "scpu_pga(__0617).d2", 0x0000, 0x2000, CRC(fc33afd7) SHA1(99a2ed972c3db477f35a7162079563367864f207) )
+	ROM_LOAD( "scpu_pgb(__0617).d3", 0x2000, 0x2000, CRC(7d9e22ac) SHA1(16a6e9651d5f764e8762fd8d6e53d13fda7473de) )
+	ROM_LOAD( "scpu_pgc(__0617).d4", 0x4000, 0x2000, CRC(902011c6) SHA1(17ac768a0fd1278ae83414f0d67d6ac8337f4773) )
+	ROM_LOAD( "scpu_pgd(__0617).d5", 0x6000, 0x2000, CRC(86477e89) SHA1(196f0d3930d10bfe4ddee82ce8b28bb99324069e) )
+	ROM_LOAD( "scpu_pge(__0617).d6", 0x8000, 0x2000, CRC(ea198fa8) SHA1(d8c97ea87d504e77edc38c87c2953c8c4f1a405b) )
+	ROM_LOAD( "scpu_pgf(__0617).d7", 0xa000, 0x2000, CRC(4325fb08) SHA1(70727aa37354425315d8a8b3ca07bbe91f7e8f08) )
 
 	ROM_REGION( 0x10000, "ssiocpu", 0 ) /* ROM's located on the Super Sound I/O Board (90913) */
 	ROM_LOAD( "ssi_0a.a7",   0x0000, 0x1000, CRC(765e6eba) SHA1(42efeefc8571dfc237c0be3368248f1e56add92e) )
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2012-02-09 11:27:12.000000000 +0100
+++ src/mame/drivers/mediagx.c	2012-02-23 05:39:44.000000000 +0100
@@ -61,6 +61,34 @@
     LS14 (SOIC14)
     74F244 (x2, SOIC20)
     ST ULN2064B (DIP16)
+
+Notes related to Area 51: Site 4 from:
+http://www.mameworld.info/ubbthreads/showthreaded.php?Cat=&Number=276606
+
+Regarding the (a51site4a.chd)
+
+I own a dedicated cab and have sold HD replacements that use an SD card and
+IDE adapter.  So I have done some research and have purchased enough board sets
+and HD's that I have some idea what I'm talking about.  Anyhoo, The currently
+supported image is Rev. 2.01 as is still sold by happ.  The only difference
+between the current MAME chd and a fresh Happ HD is that the MAME chd has had
+it's serial # cleared, but it STILL has statistical data saved. IE. credits
+inserted, games played, play times, etc...  I know it's that version by the size
+of the CHD. I have compressed several STOCK HD's including my own and they all are
+the same size.  The only HD that I have compressed that was the same as the currently
+supported chd was a happ replacement HD.  So in conclusion, There are two different
+versions of the Area 51 Site 4 HD one that was shipped in dedicated cabs dated
+Sep. 11 1998 and another Rev. 2.01 dated Sep. 7 1998 for whatever reason I cannot say.
+
+I do have clean copies of both in chd format, stripped of ALL statistical info. but
+they still retain their serial #'s.  BTW: I did use chdman to copy the currently
+supported chd to a card and put it in my cab just to clear all the stats and make a clean
+copy as it should be.  Also, Just to be clear the size of the chd is not determined by
+the original HD as I'm talking about their size after using chdman to put them onto a
+SD card and then using chdman to make a chd from the SD card. They are different sizes!
+
+-ninjakid
+
 */
 
 #include "emu.h"
@@ -1330,6 +1358,23 @@
 	DISK_IMAGE( "a51site4", 0, SHA1(48496666d1613700ae9274f9a5361ea5bbaebea0) )
 ROM_END
 
+ROM_START( a51site4a )
+	ROM_REGION32_LE(0x40000, "bios", 0)
+	ROM_SYSTEM_BIOS(0, "new", "v1.0h" )
+	ROMX_LOAD("a51s4_bios_09-15-98.u1", 0x00000, 0x40000, CRC(f8cd6a6b) SHA1(75f851ae21517b729a5596ce5e042ebfaac51778), ROM_BIOS(1)) /* Build date 09/15/98 string stored at 0x3fff5 */
+	ROM_SYSTEM_BIOS(1, "old", "v1.0f" )
+	ROMX_LOAD("a51s4_bios_07-11-98.u1", 0x00000, 0x40000, CRC(5ee189cc) SHA1(0b0d9321a4c59b1deea6854923e655a4d8c4fcfe), ROM_BIOS(2)) /* Build date 07/11/98 string stored at 0x3fff5 */
+
+	ROM_REGION(0x08100, "gfx1", 0)
+	ROM_LOAD("cga.chr",     0x00000, 0x01000, CRC(42009069) SHA1(ed08559ce2d7f97f68b9f540bddad5b6295294dd))
+
+	DISK_REGION( "drive_0" )
+// Not sure why this does not boot.  Information (at the top of the driver) might indicate this as an SD Card bootleg of the original HD.
+	DISK_IMAGE( "a51site4a", 0, SHA1(a0962b35c265154e571f973a819efdd06109e543) )
+ROM_END
+
+
 /*****************************************************************************/
 
-GAME( 1998, a51site4, 0,	mediagx, mediagx, a51site4,	ROT0,   "Atari Games",  "Area 51: Site 4", GAME_NOT_WORKING )
+GAME( 1998, a51site4, 0       , mediagx, mediagx, a51site4,	ROT0,   "Atari Games",  "Area 51: Site 4", GAME_NOT_WORKING )
+GAME( 1998, a51site4a,a51site4,	mediagx, mediagx, a51site4,	ROT0,   "Atari Games",  "Area 51: Site 4 (September 11, 1998)", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/meritm.c src/mame/drivers/meritm.c
--- src-old/mame/drivers/meritm.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/meritm.c	2012-02-22 00:51:07.000000000 +0100
@@ -129,8 +129,10 @@
 	meritm_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		  m_v9938_0(*this, "v9938_0"),
-		  m_v9938_1(*this, "v9938_1") { }
+		  m_v9938_1(*this, "v9938_1"),
+		  m_microtouch(*this, "microtouch") { }
 
+	DECLARE_WRITE8_MEMBER(microtouch_tx);
 	UINT8* m_ram;
 	device_t *m_z80pio[2];
 	int m_vint;
@@ -144,6 +146,7 @@
 	ds1204_t m_ds1204;
 	required_device<v9938_device> m_v9938_0;
 	required_device<v9938_device> m_v9938_1;
+	required_device<microtouch_device> m_microtouch;
 };
 
 
@@ -271,22 +274,24 @@
  *
  *************************************/
 
-static void pc16650d_tx_callback(int channel, int count, UINT8* data)
+static void pc16650d_tx_callback(running_machine &machine, int channel, int count, UINT8* data)
 {
-	microtouch_rx(count, data);
-};
+	meritm_state *state = machine.driver_data<meritm_state>();
+	for(int i = 0; i < count; i++)
+		state->m_microtouch->rx(*memory_nonspecific_space(machine), 0, data[i]);
+}
 
-static void meritm_microtouch_tx_callback(running_machine &machine, UINT8 data)
+WRITE8_MEMBER(meritm_state::microtouch_tx)
 {
-	pc16552d_rx_data(machine, 0, 0, data);
-};
+	pc16552d_rx_data(space.machine(), 0, 0, data);
+}
 
 /*************************************
  *
  *  Microtouch touch coordinate transformation
  *
  *************************************/
-static int meritm_touch_coord_transform(running_machine &machine, int *touch_x, int *touch_y)
+MICROTOUCH_TOUCH(meritm_touch_coord_transform)
 {
 	int xscr = (int)((double)(*touch_x)/0x4000*544);
 	int yscr = (int)((double)(*touch_y)/0x4000*480);
@@ -311,6 +316,12 @@
 	return 1;
 }
 
+static const microtouch_interface meritm_microtouch_config =
+{
+	DEVCB_DRIVER_MEMBER(meritm_state, microtouch_tx),
+	meritm_touch_coord_transform
+};
+
 /*************************************
  *
  *  Video
@@ -627,8 +638,6 @@
  *************************************/
 
 static INPUT_PORTS_START(meritm_crt260)
-	PORT_INCLUDE(microtouch)
-
 	PORT_START("PIO1_PORTA")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -997,7 +1006,6 @@
 {
 	MACHINE_START_CALL(meritm_crt250_questions);
 	pc16552d_init(machine, 0, UART_CLK, NULL, pc16650d_tx_callback);
-	microtouch_init(machine, meritm_microtouch_tx_callback, meritm_touch_coord_transform);
 }
 
 static MACHINE_START(meritm_crt260)
@@ -1014,7 +1022,6 @@
 	meritm_switch_banks(machine);
 	MACHINE_START_CALL(merit_common);
 	pc16552d_init(machine, 0, UART_CLK, NULL, pc16650d_tx_callback);
-	microtouch_init(machine, meritm_microtouch_tx_callback, meritm_touch_coord_transform);
 	state_save_register_global(machine, state->m_bank);
 	state_save_register_global(machine, state->m_psd_a15);
 	state_save_register_global_pointer(machine, state->m_ram, 0x8000);
@@ -1089,6 +1096,8 @@
 	MCFG_SOUND_ADD("aysnd", AY8910, SYSTEM_CLK/12)
 	MCFG_SOUND_CONFIG(ay8910_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+
+	MCFG_MICROTOUCH_ADD("microtouch", meritm_microtouch_config)
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( meritm_crt250_questions, meritm_crt250 )
@@ -1578,8 +1587,8 @@
 	ROM_RELOAD(                     0x380000, 0x80000)
 
 	ROM_REGION( 0x1000, "user2", 0 ) // PALs
-	ROM_LOAD( "super_sc3943.u20",     0x000, 0x117, CRC(f31864ff) SHA1(ff44820379a350e7bd788ffb6926612b3483e114) )
-	ROM_LOAD( "super_sc3944-0a.u19",  0x000, 0x2dd, CRC(ad4fddaa) SHA1(10c1575dcaa5ca4af5dc630d84f43a9ed1cb3ace) )
+	ROM_LOAD( "sc3943(__megat4s).u20",     0x000, 0x117, CRC(f31864ff) SHA1(ff44820379a350e7bd788ffb6926612b3483e114) )
+	ROM_LOAD( "sc3944-0a(__megat4s).u19",  0x000, 0x2dd, CRC(ad4fddaa) SHA1(10c1575dcaa5ca4af5dc630d84f43a9ed1cb3ace) )
 	ROM_LOAD( "sc3980.u40",     0x000, 0x117, CRC(ee0cdab5) SHA1(216fef50a8a0f6a33b704d3501a4c5c3cbac2bad) )
 	ROM_LOAD( "sc3981-0a.u51",  0x000, 0x117, CRC(4fc750d0) SHA1(d09ff7a8c66aeb5c49e9fec84bd1521e3f5d8d0a) )
 ROM_END
diff -Nru src-old/mame/drivers/midyunit.c src/mame/drivers/midyunit.c
--- src-old/mame/drivers/midyunit.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/midyunit.c	2012-02-23 05:39:44.000000000 +0100
@@ -2424,6 +2424,35 @@
 	ROM_LOAD ( "mkg-u109.rom",  0x580000, 0x80000, CRC(cafc47bb) SHA1(8610af6e52f7089ff4acd850c53ab8b4119e4445) )
 ROM_END
 
+ROM_START( mkyawdim2 )
+	ROM_REGION( 0x10000, "audiocpu", 0 )	/* sound CPU */
+        // Differs from other yawdim set - sound doesn't want to work
+	ROM_LOAD ( "yawdim.u167", 0x00000, 0x10000, CRC(16da7efb) SHA1(ac1db81a55aca36136b94977a91a1fc778b7b164) )
+
+	ROM_REGION( 0x100000, "oki", 0 )	/* ADPCM */
+        // Half size as other yawdim set
+	ROM_LOAD( "yawdim.u159",  0x00000, 0x20000, CRC(95b120af) SHA1(41b6fb384e5048926b87959a2c58d96b95698aba) )
+	ROM_CONTINUE(       0x40000, 0x20000 )
+	ROM_LOAD( "mw-15.u160",  0x20000, 0x20000, CRC(6e68e0b0) SHA1(edb7aa6507452ffa5ce7097e3b1855a69542971c) )
+	ROM_CONTINUE(       0x60000, 0x20000 )
+	ROM_CONTINUE(       0xa0000, 0x20000 )
+	ROM_CONTINUE(       0xe0000, 0x20000 )
+
+	ROM_REGION16_LE( 0x100000, "user1", 0 )	/* 34010 code */
+	ROM_LOAD16_BYTE( "4.u25",  0x00000, 0x80000, CRC(b12b3bf2) SHA1(deb7755e8407d9de25124b3fdbc4c834a25d8252) )
+	ROM_LOAD16_BYTE( "5.u26",  0x00001, 0x80000, CRC(7a37dc5c) SHA1(c4fc6933d8b990c5c56c65282b1f72b90b5d5435) )
+
+	ROM_REGION( 0x800000, "gfx1", 0 ) /* 8mbit dumps */
+	ROM_LOAD ( "b-1.bin",  0x000000, 0x100000, CRC(f41e61c6) SHA1(7dad38839d5c9aa0cfa7b2f7199f14e0f2c4494b) )
+	ROM_LOAD ( "b-2.bin",  0x100000, 0x100000, CRC(8052740b) SHA1(f1b7fd536966d9d0ce690cdec635069c340d678e) )
+
+	ROM_LOAD ( "a-1.bin",  0x200000, 0x100000, CRC(7da3cb93) SHA1(23b9053b3241b69988f7f2e6a9d1353dac4fc8ab) )
+	ROM_LOAD ( "a-2.bin",  0x300000, 0x100000, CRC(1eedb0f8) SHA1(27c056c469c17bb176325b91cf92296c89681ac6) )
+
+	ROM_LOAD ( "c-1.bin",  0x400000, 0x100000, CRC(de27c4c3) SHA1(a7760d239749c7463808adec72795f9785f553ec) )
+	ROM_LOAD ( "c-2.bin",  0x500000, 0x100000, CRC(d99203f3) SHA1(46ea21cbedfd42838562594b9bdc5d80360b7e5e) )
+ROM_END
+
 
 ROM_START( term2 )
 	ROM_REGION( 0x50000, "adpcm", 0 )	/* sound CPU */
@@ -2676,6 +2705,7 @@
 GAME( 1992, mknifty,  mk,       yunit_adpcm_6bit_fast,   mkla4,    mkyturbo, ROT0, "hack",     "Mortal Kombat (Nifty Kombo, hack)", GAME_SUPPORTS_SAVE )
 GAME( 1992, mknifty666, mk,     yunit_adpcm_6bit_fast,   mkla4,    mkyturbo, ROT0, "hack",     "Mortal Kombat (Nifty Kombo 666, hack)", GAME_SUPPORTS_SAVE )
 GAME( 1992, mkyawdim, mk,       mkyawdim,                mkla4,    mkyawdim, ROT0, "bootleg (Yawdim)", "Mortal Kombat (Yawdim bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1992, mkyawdim2,mk,       mkyawdim,                mkla4,    mkyawdim, ROT0, "bootleg (Yawdim)", "Mortal Kombat (Yawdim bootleg - Set 2)", GAME_SUPPORTS_SAVE | GAME_NO_SOUND )
 
 GAME( 1992, totcarn,  0,        yunit_adpcm_6bit_fast,   totcarn,  totcarn,  ROT0, "Midway",   "Total Carnage (rev LA1 03/10/92)", GAME_SUPPORTS_SAVE )
 GAME( 1992, totcarnp, totcarn,  yunit_adpcm_6bit_fast,   totcarn,  totcarn,  ROT0, "Midway",   "Total Carnage (prototype, rev 1.0 01/25/92)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/mil4000.c src/mame/drivers/mil4000.c
--- src-old/mame/drivers/mil4000.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/mil4000.c	2012-02-22 00:51:07.000000000 +0100
@@ -436,8 +436,8 @@
 
 ROM_START( mil4000b )
 	ROM_REGION( 0x100000, "maincpu", 0 ) // 68000 code
-	ROM_LOAD16_BYTE( "b27.u75", 0x000001, 0x20000, CRC(a5ca8a1e) SHA1(c42244e27031175c37e83995f548d960708eabab) )
-	ROM_LOAD16_BYTE( "b28.u76", 0x000000, 0x20000, CRC(5bf4e681) SHA1(818d0ec1b2cc544334b0349ae15fd53ff32ef8c1) )
+	ROM_LOAD16_BYTE( "27(__mil4000b).u75", 0x000001, 0x20000, CRC(a5ca8a1e) SHA1(c42244e27031175c37e83995f548d960708eabab) )
+	ROM_LOAD16_BYTE( "28(__mil4000b).u76", 0x000000, 0x20000, CRC(5bf4e681) SHA1(818d0ec1b2cc544334b0349ae15fd53ff32ef8c1) )
 
 	ROM_REGION( 0xa0000, "gfx1", 0 ) // 5bpp?
 	ROM_LOAD( "2.u36",   0x000000, 0x20000, CRC(bb4fcfde) SHA1(7e19722ce42b9ec86faac32a526429b0e56639b5) )
diff -Nru src-old/mame/drivers/mpu5.c src/mame/drivers/mpu5.c
--- src-old/mame/drivers/mpu5.c	2011-12-23 18:29:55.000000000 +0100
+++ src/mame/drivers/mpu5.c	2012-02-21 22:00:29.000000000 +0100
@@ -5917,7 +5917,7 @@
 GAME( 199?, m5centcl	,0,			mpu5, mpu5, 0, ROT0, "Empire","Centurion Club (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5cworan	,0,			mpu5, mpu5, 0, ROT0, "Empire","Clockwork Oranges (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5clbtro	,0,			mpu5, mpu5, 0, ROT0, "Empire","Club Tropicana (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, m5cockdd	,0,			mpu5, mpu5, 0, ROT0, "Empire","Cock A Doodle Dough (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, m5cockdd	,0,			mpu5, mpu5, 0, ROT0, "Empire","Cock A Doodle Dough! (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5coloss	,0,			mpu5, mpu5, 0, ROT0, "Empire","Colossus Club (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5crocrk	,0,			mpu5, mpu5, 0, ROT0, "Empire","Crocodile Rock (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5croclb	,0,			mpu5, mpu5, 0, ROT0, "Empire","Crocodile Rock Club (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
@@ -5929,7 +5929,7 @@
 GAME( 199?, m5fatcat	,0,			mpu5, mpu5, 0, ROT0, "Empire","Fat Cat (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5fishdl	,0,			mpu5, mpu5, 0, ROT0, "Empire","Fish Full Of Dollars (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5fishcl	,0,			mpu5, mpu5, 0, ROT0, "Empire","Fish Full Of Dollars Club (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, m5fmonty	,0,			mpu5, mpu5, 0, ROT0, "Empire","Full Monty (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, m5fmonty	,0,			mpu5, mpu5, 0, ROT0, "Empire","The Full Monty (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5fmount	,0,			mpu5, mpu5, 0, ROT0, "Empire","Full Mountie (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5gophr		,0,			mpu5, mpu5, 0, ROT0, "Empire","Gopher Gold (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5gophcl	,0,			mpu5, mpu5, 0, ROT0, "Empire","Gopher Gold Club (Empire) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/mw18w.c src/mame/drivers/mw18w.c
--- src-old/mame/drivers/mw18w.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/mw18w.c	2012-02-22 00:51:07.000000000 +0100
@@ -192,7 +192,7 @@
 
 ROM_START(18w2)
 	ROM_REGION(0x10000, "maincpu", 0)
-	ROM_LOAD( "18w2_b1.rom1",0x0000, 0x0800, CRC(cbc0fb2c) SHA1(66b14f0d76baebbd64e8ed107e536ad811d55273))
+	ROM_LOAD( "18w_b1(__18w2).rom1",0x0000, 0x0800, CRC(cbc0fb2c) SHA1(66b14f0d76baebbd64e8ed107e536ad811d55273))
 	ROM_LOAD( "18w_b2.rom2", 0x0800, 0x0800, CRC(efbadee8) SHA1(834eaf8ca50544123de7529b90b828cf46b1c001))
 	ROM_LOAD( "18w_b3.rom3", 0x1000, 0x0800, CRC(214606f6) SHA1(9a9dc20259b4462661c6be410d98d2be54657a0e))
 	ROM_LOAD( "18w_b4.rom4", 0x1800, 0x0800, CRC(e88ad6a9) SHA1(ac010aa7e0288197ff9342801522623b64dd2a47))
diff -Nru src-old/mame/drivers/namcos10.c src/mame/drivers/namcos10.c
--- src-old/mame/drivers/namcos10.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/namcos10.c	2012-02-23 02:02:10.000000000 +0100
@@ -28,7 +28,7 @@
 Mr Driller 2 (DR21 Ver.A)                        (C) Namco, 2000
 Mr Driller 2 (DR22 Ver.A)                        (C) Namco, 2000
 Mr Driller G (DRG1 Ver.A)                        (C) Namco, 2001
-*NFL Classic Football                            (C) Namco, 2003
+NFL Classic Football (NCF3 Ver.A)                (C) Namco, 2003 - Has a noticable red dot the right right of the version printed on PCB.  Something to determine region?
 Panicuru Panekuru (PPA1 Ver.A)                   (C) Namco, 2001
 *Photo Battole                                   (C) Namco, 2001
 Point Blank 3 / Gunbalina (GNN2 Ver. A)          (C) Namco, 2000
@@ -469,6 +469,14 @@
 }
 
 
+//  This is not the actual decrpyt for NFL Classic Football.  This still needs to be divined.
+static DRIVER_INIT( nflclsfb )
+{
+	memn_driver_init(machine);
+	decrypt_bios( machine, 0x6, 0x4, 0x7, 0x5, 0x0, 0x1, 0x2, 0x3, 0xc, 0xf, 0xe, 0xd, 0x9, 0x8, 0xb, 0xa );
+}
+
+
 static MACHINE_RESET( namcos10 )
 {
 }
@@ -647,6 +655,17 @@
 	ROM_LOAD( "2.7e",         0x2100000, 0x1080000, CRC(cd3b25e0) SHA1(39dfebc59e71b8f1c28e718ee71032620f11440c) )
 ROM_END
 
+ROM_START( nflclsfb )
+	ROM_REGION32_LE( 0x400000, "user1", 0 ) /* bios */
+	ROM_FILL( 0x0000000, 0x400000, 0x55 )
+
+	ROM_REGION( 0x4200000, "user2", 0 ) /* main prg */
+	ROM_LOAD( "0.8e",         0x0000000, 0x1080000, CRC(b08d4270) SHA1(5f5dc1c2862292a9e597f6a21c0f9db2e5796ded) )
+	ROM_LOAD( "1.8d",         0x1080000, 0x1080000, CRC(d3f519d8) SHA1(60d5f2fafd700e39245bed17e3cc6d608cc2c088) )
+	ROM_LOAD( "2.7e",         0x2100000, 0x1080000, CRC(0c65fdc2) SHA1(fa5d41a7b10ae8f8d312b61cc6d34408123bda97) )
+	ROM_LOAD( "3.7d",         0x3180000, 0x1080000, CRC(0a4e601d) SHA1(9c302a0b5aaf7046390982e62092b867c3a534a5) )
+ROM_END
+
 
 GAME( 2000, mrdrilr2,  0,        namcos10, namcos10, mrdrilr2, ROT0, "Namco", "Mr. Driller 2 (Japan, DR21 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND ) // PORT_4WAY joysticks
 GAME( 2000, mrdrlr2a,  mrdrilr2, namcos10, namcos10, mrdrilr2, ROT0, "Namco", "Mr. Driller 2 (Japan, DR22 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND ) // PORT_4WAY joysticks
@@ -658,4 +677,5 @@
 GAME( 2002, chocovdr,  0,        namcos10, namcos10, chocovdr, ROT0, "Namco", "Uchuu Daisakusen: Chocovader Contactee (Japan, CVC1 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND )
 GAME( 2002, startrgn,  0,        namcos10, namcos10, startrgn, ROT0, "Namco", "Star Trigon (Japan, STT1 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND )
 GAME( 2002, panikuru,  0,        namcos10, namcos10, panikuru, ROT0, "Namco", "Panicuru Panekuru (Japan, PPA1 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND )
+GAME( 2003, nflclsfb,  0,        namcos10, namcos10, nflclsfb, ROT0, "Namco", "NFL Classic Football (NCF3 Ver.A.)", GAME_NOT_WORKING | GAME_NO_SOUND )
 GAME( 2003, gamshara,  0,        namcos10, namcos10, gamshara, ROT0, "Mitchell", "Gamshara (10021 Ver.A)", GAME_NOT_WORKING | GAME_NO_SOUND )
diff -Nru src-old/mame/drivers/naughtyb.c src/mame/drivers/naughtyb.c
--- src-old/mame/drivers/naughtyb.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/naughtyb.c	2012-02-22 00:51:07.000000000 +0100
@@ -746,9 +746,9 @@
 
 ROM_START( trvmstrb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ic30_b.bin",   0x0000, 0x1000, CRC(d3eb4197) SHA1(5843ffc8ec82ffe9a6519180e54c82b0375cc3dc) )
-	ROM_LOAD( "ic28_b.bin",   0x1000, 0x1000, CRC(70322d65) SHA1(498102236390f2e15444943e0fff8a53f37db083) )
-	ROM_LOAD( "ic26_b.bin",   0x2000, 0x1000, CRC(31dfa9cf) SHA1(007c6ef2381ce9e707932c66a451805cec342eeb) )
+	ROM_LOAD( "ic30b.bin",   0x0000, 0x1000, CRC(d3eb4197) SHA1(5843ffc8ec82ffe9a6519180e54c82b0375cc3dc) )
+	ROM_LOAD( "ic28b.bin",   0x1000, 0x1000, CRC(70322d65) SHA1(498102236390f2e15444943e0fff8a53f37db083) )
+	ROM_LOAD( "ic26b.bin",   0x2000, 0x1000, CRC(31dfa9cf) SHA1(007c6ef2381ce9e707932c66a451805cec342eeb) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
 	ROM_LOAD( "ic44.bin",     0x0000, 0x1000, CRC(dac8cff7) SHA1(21da2b2ceb4a726d03b2e49a2df75ca66b89a197) )
diff -Nru src-old/mame/drivers/nightgal.c src/mame/drivers/nightgal.c
--- src-old/mame/drivers/nightgal.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/nightgal.c	2012-02-22 00:51:07.000000000 +0100
@@ -1131,11 +1131,11 @@
 
 ROM_START( sweetgal )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "10_sw.3n",  0x00000, 0x04000, CRC(0f6c4bf0) SHA1(50e5c6f08e124641f5df8938ccfcdebde18f6a0f) )
+	ROM_LOAD( "10(__sweetgal).3n",  0x00000, 0x04000, CRC(0f6c4bf0) SHA1(50e5c6f08e124641f5df8938ccfcdebde18f6a0f) )
 	ROM_LOAD( "11.3p", 0x04000, 0x04000, CRC(7388e9b3) SHA1(e318d2d3888679bbd43a0aab68252fd359b7969d) )
 
 	ROM_REGION( 0x10000, "sub", 0 )
-	ROM_LOAD( "1_sw.3a", 0x0e000, 0x2000, CRC(5342c757) SHA1(b4ff84c45bd2c6a6a468f1d0daaf5b19c4dbf8fe) )
+	ROM_LOAD( "1(__sweetgal).3a", 0x0e000, 0x2000, CRC(5342c757) SHA1(b4ff84c45bd2c6a6a468f1d0daaf5b19c4dbf8fe) )
 
 	ROM_REGION( 0xc000, "samples", 0 ) // sound samples
 	ROM_LOAD( "v2_12.bin",  0x00000, 0x04000, CRC(66a35be2) SHA1(4f0d73d753387acacc5ccc90e91d848a5ecce55e) )
@@ -1143,8 +1143,8 @@
 	ROM_LOAD( "v2_14.bin",  0x08000, 0x04000, CRC(149e84c1) SHA1(5c4e18637bef2f31bc3578cae6525fb6280fbc06) )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "2_sw.3c",  0x00000, 0x04000, CRC(3a3d78f7) SHA1(71e35529f30c43ee8ec2363f85fe17042f1d304e) )
-	ROM_LOAD( "3_sw.3d",  0x04000, 0x04000, CRC(c6f9b884) SHA1(32d6fe1906a3f1f528f30dbd3f89971b2ea1925b) )
+	ROM_LOAD( "2(__sweetgal).3c",  0x00000, 0x04000, CRC(3a3d78f7) SHA1(71e35529f30c43ee8ec2363f85fe17042f1d304e) )
+	ROM_LOAD( "3(__sweetgal).3d",  0x04000, 0x04000, CRC(c6f9b884) SHA1(32d6fe1906a3f1f528f30dbd3f89971b2ea1925b) )
 	// all roms below match sexygal
 	ROM_LOAD( "4.3e",  0x08000, 0x04000, CRC(f1cdbedb) SHA1(caacf2887a3a05e498d57d570a1e9873f95a5d5f) )
 	ROM_LOAD( "5.3f",  0x0c000, 0x04000, CRC(76569186) SHA1(79cb32c1f1a96f90d59f331a01ca548936933b87) )
diff -Nru src-old/mame/drivers/nwk-tr.c src/mame/drivers/nwk-tr.c
--- src-old/mame/drivers/nwk-tr.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/nwk-tr.c	2012-02-22 21:55:18.000000000 +0100
@@ -766,7 +766,7 @@
 	ROM_LOAD( "676a10.14p",   0x400000, 0x400000, CRC(7b5b7828) SHA1(aec224d62e4b1e8fdb929d7947ce70d84ba676cf) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "racingj_m48t58y-70pc1", 0x000000, 0x002000, CRC(47e1628c) SHA1(7c42d06ae2f2cd24d083890f333552cbf4f1d3c9) )
+	ROM_LOAD( "676jac_m48t58y.35d", 0x000000, 0x002000, CRC(47e1628c) SHA1(7c42d06ae2f2cd24d083890f333552cbf4f1d3c9) )
 ROM_END
 
 ROM_START(racingj2j)
@@ -790,7 +790,7 @@
 	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "racingj2j_m48t58y-70pc1", 0x000000, 0x002000, CRC(f691f5ab) SHA1(e81f652c5caa2caa8bd1c6d6db488d849bda058e) )
+	ROM_LOAD( "676eae_m48t58y.35d", 0x000000, 0x002000, CRC(f691f5ab) SHA1(e81f652c5caa2caa8bd1c6d6db488d849bda058e) )
 ROM_END
 
 ROM_START(racingj2)
@@ -814,7 +814,7 @@
 	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "racingj2_m48t58y-70pc1.35d", 0x000000, 0x002000, CRC(1aa43a1f) SHA1(814b691b8a358bf1545a13d595d17070e612e9a4) )
+	ROM_LOAD( "676jae_m48t58y.35d", 0x000000, 0x002000, CRC(1aa43a1f) SHA1(814b691b8a358bf1545a13d595d17070e612e9a4) )
 ROM_END
 
 ROM_START(thrilld)
@@ -837,7 +837,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "thrilld_m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
+	ROM_LOAD( "713jae_m48t58y.35d", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
 ROM_END
 
 ROM_START(thrilldb)
@@ -860,7 +860,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "thrilldb_m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
+	ROM_LOAD( "713jab_m48t58y.35d", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
 ROM_END
 
 ROM_START(thrilldae)
@@ -883,7 +883,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "thrilldae_m48t58y-70pc1", 0x000000, 0x002000, CRC(056ea8fa) SHA1(23574e0c1d011dab8644f3d98763d4a2d11a05b3)  )
+	ROM_LOAD( "713eaa_m48t58y.35d", 0x000000, 0x002000, CRC(056ea8fa) SHA1(23574e0c1d011dab8644f3d98763d4a2d11a05b3)  )
 ROM_END
 
 /*****************************************************************************/
diff -Nru src-old/mame/drivers/pcat_nit.c src/mame/drivers/pcat_nit.c
--- src-old/mame/drivers/pcat_nit.c	2012-02-02 02:34:55.000000000 +0100
+++ src/mame/drivers/pcat_nit.c	2012-02-19 17:46:00.000000000 +0100
@@ -96,21 +96,27 @@
 {
 public:
 	pcat_nit_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_uart(*this, "ns16450_0"),
+		  m_microtouch(*this, "microtouch")
+		{ }
 
 	UINT8 *m_banked_nvram;
-};
+	required_device<ns16450_device> m_uart;
+	required_device<microtouch_serial_device> m_microtouch;
 
+	DECLARE_WRITE_LINE_MEMBER(microtouch_out);
+	DECLARE_WRITE_LINE_MEMBER(microtouch_in);
+};
 
-static void pcat_nit_microtouch_tx_callback(running_machine &machine, UINT8 data)
+WRITE_LINE_MEMBER(pcat_nit_state::microtouch_out)
 {
-	ins8250_receive(machine.device("ns16450_0"), data);
-};
+	m_microtouch->rx(state);
+}
 
-static INS8250_TRANSMIT( pcat_nit_com_transmit )
+WRITE_LINE_MEMBER(pcat_nit_state::microtouch_in)
 {
-	UINT8 data8 = data;
-	microtouch_rx(1, &data8);
+	m_uart->rx_w(state);
 }
 
 static WRITE_LINE_DEVICE_HANDLER( at_com_interrupt_1 )
@@ -120,11 +126,17 @@
 
 static const ins8250_interface pcat_nit_com0_interface =
 {
-	1843200,
+	DEVCB_DRIVER_LINE_MEMBER(pcat_nit_state, microtouch_out),
+	DEVCB_NULL,
+	DEVCB_NULL,
 	DEVCB_LINE(at_com_interrupt_1),
-	pcat_nit_com_transmit,
-	NULL,
-	NULL
+	DEVCB_NULL,
+	DEVCB_NULL
+};
+
+static const microtouch_serial_interface pcat_nit_microtouch_interface =
+{
+	DEVCB_DRIVER_LINE_MEMBER(pcat_nit_state, microtouch_in)
 };
 
 /*************************************
@@ -194,12 +206,10 @@
 	AM_IMPORT_FROM(pcat32_io_common)
 	AM_RANGE(0x0278, 0x027f) AM_READ8(pcat_nit_io_r, 0xffffffff) AM_WRITENOP
 	AM_RANGE(0x0280, 0x0283) AM_READNOP
-	AM_RANGE(0x03f8, 0x03ff) AM_DEVREADWRITE8("ns16450_0", ins8250_r, ins8250_w, 0xffffffff)
+	AM_RANGE(0x03f8, 0x03ff) AM_DEVREADWRITE8_MODERN("ns16450_0", ns16450_device, ins8250_r, ins8250_w, 0xffffffff)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( pcat_nit )
-	PORT_INCLUDE(microtouch)
-
 	PORT_START("IN0")
 	PORT_BIT(0x80, IP_ACTIVE_LOW, IPT_OTHER) PORT_NAME("Clear") PORT_CODE(KEYCODE_C)
 	PORT_BIT(0x40, IP_ACTIVE_LOW, IPT_SERVICE)
@@ -224,7 +234,7 @@
 	memory_configure_bank(machine, "rombank", 0, 0x80, machine.region("game_prg")->base(), 0x8000 );
 	memory_set_bank(machine, "rombank", 0);
 
-	microtouch_init(machine, pcat_nit_microtouch_tx_callback, NULL);
+	//microtouch_init(machine, pcat_nit_microtouch_tx_callback, NULL);
 }
 
 static MACHINE_CONFIG_START( pcat_nit, pcat_nit_state )
@@ -245,7 +255,8 @@
 
 //  MCFG_FRAGMENT_ADD( at_kbdc8042 )
 	MCFG_FRAGMENT_ADD( pcat_common )
-	MCFG_NS16450_ADD( "ns16450_0", pcat_nit_com0_interface )
+	MCFG_NS16450_ADD( "ns16450_0", pcat_nit_com0_interface, XTAL_1_8432MHz )
+	MCFG_MICROTOUCH_SERIAL_ADD( "microtouch", pcat_nit_microtouch_interface, 9600 ) // rate?
 
 	MCFG_NVRAM_ADD_0FILL("nvram")
 
diff -Nru src-old/mame/drivers/potgoldu.c src/mame/drivers/potgoldu.c
--- src-old/mame/drivers/potgoldu.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/potgoldu.c	2012-02-26 15:31:24.000000000 +0100
@@ -0,0 +1,117 @@
+/***************************************************************************
+
+ Pot of Gold (c)200? U. S. Games
+ it appears this is just the name of a series of machines with different
+ software themes?
+
+ board has the followng etched
+
+     US GAMES
+   MADE IN USA
+ P/N: 34010  REV C-1
+
+ not sure this is a good dump.. one rom is much bigger than the others
+ and doesn't seem to pair with the ROM I'd expect it to pair with...
+
+ I'm just tagging the whole thing as BAD_DUMP for now.
+
+***************************************************************************/
+
+#include "emu.h"
+#include "cpu/tms34010/tms34010.h"
+
+
+class potgold_state : public driver_device
+{
+public:
+	potgold_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag) { }
+};
+
+
+#define CPU_CLOCK			XTAL_40MHz
+#define VIDEO_CLOCK			(22118400) // ?
+#define SOUND_CLOCK			(3579645)
+
+
+
+
+
+static VIDEO_START( potgold )
+{
+
+}
+
+static void scanline_update(screen_device &screen, bitmap_rgb32 &bitmap, int scanline, const tms34010_display_params *params)
+{
+
+}
+
+
+static MACHINE_RESET( potgold )
+{
+
+}
+
+
+static ADDRESS_MAP_START( potgold_map, AS_PROGRAM, 16 )
+	AM_RANGE(0xff000000, 0xffffffff) AM_ROM AM_REGION("user1", 0)
+ADDRESS_MAP_END
+
+
+static INPUT_PORTS_START( potgold )
+INPUT_PORTS_END
+
+
+static const tms34010_config tms_config =
+{
+	FALSE,							/* halt on reset */
+	"screen",						/* the screen operated on */
+	VIDEO_CLOCK/2,					/* pixel clock */
+	1,								/* pixels per clock */
+	NULL,							/* scanline callback (indexed16) */
+	scanline_update,				/* scanline callback (rgb32) */
+	NULL,							/* generate interrupt */
+	NULL,							/* write to shiftreg function */
+	NULL							/* read from shiftreg function */
+};
+
+
+static MACHINE_CONFIG_START( potgold, potgold_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu", TMS34010, XTAL_40MHz)
+	MCFG_CPU_CONFIG(tms_config)
+	MCFG_CPU_PROGRAM_MAP(potgold_map)
+
+	MCFG_MACHINE_RESET(potgold)
+
+	MCFG_VIDEO_START(potgold)
+
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_RAW_PARAMS(VIDEO_CLOCK/2, 444, 0, 320, 233, 0, 200)
+	MCFG_SCREEN_UPDATE_STATIC(tms340x0_rgb32)
+
+	/* sound hardware */
+	/* YM2413 */
+MACHINE_CONFIG_END
+
+ROM_START( potgoldu )
+	ROM_REGION16_LE( 0x200000, "user1", 0 )	/* 34010 code */
+
+	// these two are definitely a pair
+	ROM_LOAD16_BYTE( "400x.u5",  0x180000, 0x20000, BAD_DUMP CRC(4949300b) SHA1(edf5e3de8561258ceb8fc0ab0291859d2cf7c21b) )
+	ROM_LOAD16_BYTE( "400x.u9",  0x180001, 0x20000, BAD_DUMP CRC(80e1ab14) SHA1(36595446d73dc5bf5c7f47b9385e5fdc84cce195) )
+
+	// these two.. don't match up
+	ROM_LOAD16_BYTE( "400x.u4",  0x180000, 0x20000, BAD_DUMP CRC(66d6697c) SHA1(6e1072cce70b56b8bf186cbb0f3dcc970ef6ca39) ) // the end of this seems to fit in as you'd expect, before u3
+	ROM_LOAD16_BYTE( "400x.u8",  0x180001, 0x80000, BAD_DUMP CRC(0496bc92) SHA1(ae80b3de856ae60de29e2d7e05c6ed5fb37232a9) ) // the start of this resembles u9.. the rest doesn't seem to match up with anything? there are odd bytes of text strings etc.
+
+	// these two are definitely a pair
+	ROM_LOAD16_BYTE( "400x.u3",  0x1c0000, 0x20000, BAD_DUMP CRC(c0894db0) SHA1(d68321949250bfe0f14bd5ef8d115ba4b3786b8b) )
+	ROM_LOAD16_BYTE( "400x.u7",  0x1c0001, 0x20000, BAD_DUMP CRC(0953ecf7) SHA1(91cbe5d9aff171902dc3eb43a308a7a833c8fb71) )
+ROM_END
+
+
+GAME( 200?, potgoldu,    0,        potgold,   potgold,   0, ROT0, "U.S. Games Inc.",  "Pot O' Gold (U.S. Games, v400x?)", GAME_IS_SKELETON | GAME_NO_SOUND )
+
diff -Nru src-old/mame/drivers/punchout.c src/mame/drivers/punchout.c
--- src-old/mame/drivers/punchout.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/punchout.c	2012-02-22 00:51:07.000000000 +0100
@@ -1079,33 +1079,33 @@
 ROM_START( punchita )
 	/* Unique to this set */
 	ROM_REGION( 0x10000, "maincpu", 0 )	/* 64k for code */
-	ROM_LOAD( "ita_chp1-c.8l",    0x0000, 0x2000, CRC(1d595ce2) SHA1(affd43bef96c68f953e66cfa14ad4e9c304dc022) )
-	ROM_LOAD( "ita_chp1-c.8k",    0x2000, 0x2000, CRC(c062fa5c) SHA1(8ebd6fd76f1fd1b85216a4e21d8a13be8317b9e2) )
-	ROM_LOAD( "ita_chp1-c.8j",    0x4000, 0x2000, CRC(48d453ef) SHA1(145f3ace8bec87e83b64c6472e2b71f1ebea13ea) )
-	ROM_LOAD( "ita_chp1-c.8h",    0x6000, 0x2000, CRC(67f5aedc) SHA1(c63a8b0696eec87bb147d435c18ee7e26d19e2a4) )
-	ROM_LOAD( "ita_chp1-c.8f",    0x8000, 0x4000, CRC(761de4f3) SHA1(66754bc762c14fea620fabf408f85e6e3acb89ad) )
+	ROM_LOAD( "chp1-c(__ita).8l",    0x0000, 0x2000, CRC(1d595ce2) SHA1(affd43bef96c68f953e66cfa14ad4e9c304dc022) )
+	ROM_LOAD( "chp1-c(__ita).8k",    0x2000, 0x2000, CRC(c062fa5c) SHA1(8ebd6fd76f1fd1b85216a4e21d8a13be8317b9e2) )
+	ROM_LOAD( "chp1-c(__ita).8j",    0x4000, 0x2000, CRC(48d453ef) SHA1(145f3ace8bec87e83b64c6472e2b71f1ebea13ea) )
+	ROM_LOAD( "chp1-c(__ita).8h",    0x6000, 0x2000, CRC(67f5aedc) SHA1(c63a8b0696eec87bb147d435c18ee7e26d19e2a4) )
+	ROM_LOAD( "chp1-c(__ita).8f",    0x8000, 0x4000, CRC(761de4f3) SHA1(66754bc762c14fea620fabf408f85e6e3acb89ad) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* 64k for the sound CPU */
 	ROM_LOAD( "chp1-c.4k",    0xe000, 0x2000, CRC(cb6ef376) SHA1(503dbcc1b18a497311bf129689d5650860bf96c7) )
 
 	/* Unique to this set */
 	ROM_REGION( 0x04000, "gfx1", ROMREGION_ERASEFF )
-	ROM_LOAD( "ita_chp1-b.4c",    0x00000, 0x0800, CRC(9a9ff1d3) SHA1(d91adf69acb717f238cd5954909701a8748f2185) )	/* chars #1 */
+	ROM_LOAD( "chp1-b(__ita).4c",    0x00000, 0x0800, CRC(9a9ff1d3) SHA1(d91adf69acb717f238cd5954909701a8748f2185) )	/* chars #1 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "ita_chp1-b.4d",    0x02000, 0x0800, CRC(4c23350f) SHA1(70a76002db9209699cdf1f092b2b5ef32d0b7b75) )
+	ROM_LOAD( "chp1-b(__ita).4d",    0x02000, 0x0800, CRC(4c23350f) SHA1(70a76002db9209699cdf1f092b2b5ef32d0b7b75) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
 
 	/* These match SUPER PunchOut */
 	ROM_REGION( 0x04000, "gfx2", ROMREGION_ERASEFF )
-	ROM_LOAD( "ita_chp1-b.4a",    0x00000, 0x0800, CRC(c075f831) SHA1(f22d9e415637599420c443ce08e7e70d1eb1c6f5) )	/* chars #2 */
+	ROM_LOAD( "chp1-b(__ita).4a",    0x00000, 0x0800, CRC(c075f831) SHA1(f22d9e415637599420c443ce08e7e70d1eb1c6f5) )	/* chars #2 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "ita_chp1-b.4b",    0x02000, 0x0800, CRC(c4cc2b5a) SHA1(7b9d4dcecc67271980c3c44561fc25a6f6c93ee3) )
+	ROM_LOAD( "chp1-b(__ita).4b",    0x02000, 0x0800, CRC(c4cc2b5a) SHA1(7b9d4dcecc67271980c3c44561fc25a6f6c93ee3) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
@@ -1131,20 +1131,20 @@
 
 	/* These match SUPER PunchOut */
 	ROM_REGION( 0x10000, "gfx4", ROMREGION_ERASEFF )
-	ROM_LOAD( "ita_chp1-v.6p",    0x00000, 0x0800, CRC(75be7aae) SHA1(396bc1d301b99e064de4dad699882618b1b9c958) )	/* chars #4 */
+	ROM_LOAD( "chp1-v(__ita).6p",    0x00000, 0x0800, CRC(75be7aae) SHA1(396bc1d301b99e064de4dad699882618b1b9c958) )	/* chars #4 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "ita_chp1-v.6n",    0x02000, 0x0800, CRC(daf74de0) SHA1(9373d4527b675b3128a5a830f42e1dc5dcb85307) )
+	ROM_LOAD( "chp1-v(__ita).6n",    0x02000, 0x0800, CRC(daf74de0) SHA1(9373d4527b675b3128a5a830f42e1dc5dcb85307) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
 	/* 04000-07fff empty (space for 6l and 6k) */
-	ROM_LOAD( "ita_chp1-v.8p",    0x08000, 0x0800, CRC(4cb7ea82) SHA1(213b7c1431f4c92e5519a8771035bda28b3bab8a) )
+	ROM_LOAD( "chp1-v(__ita).8p",    0x08000, 0x0800, CRC(4cb7ea82) SHA1(213b7c1431f4c92e5519a8771035bda28b3bab8a) )
 	ROM_CONTINUE(             0x09000, 0x0800 )
 	ROM_CONTINUE(             0x08800, 0x0800 )
 	ROM_CONTINUE(             0x09800, 0x0800 )
-	ROM_LOAD( "ita_chp1-v.8n",    0x0a000, 0x0800, CRC(1c0d09aa) SHA1(3276bae7400453f3612f53d7b47fb199cbe53e6d) )
+	ROM_LOAD( "chp1-v(__ita).8n",    0x0a000, 0x0800, CRC(1c0d09aa) SHA1(3276bae7400453f3612f53d7b47fb199cbe53e6d) )
 	ROM_CONTINUE(             0x0b000, 0x0800 )
 	ROM_CONTINUE(             0x0a800, 0x0800 )
 	ROM_CONTINUE(             0x0b800, 0x0800 )
diff -Nru src-old/mame/drivers/rastan.c src/mame/drivers/rastan.c
--- src-old/mame/drivers/rastan.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/rastan.c	2012-02-22 00:51:07.000000000 +0100
@@ -552,9 +552,9 @@
 	ROM_REGION( 0x60000, "maincpu", 0 ) /* 6*64k for 68000 code */
 	ROM_LOAD16_BYTE( "b04-38.19", 0x00000, 0x10000, CRC(a38ac909) SHA1(66d792fee03c6bd87d15060b9d5cae74137c5ebd) )
 	ROM_LOAD16_BYTE( "b04-37.7",  0x00001, 0x10000, CRC(bad60872) SHA1(e020f79b3ac3d2abccfcd5d135d2dc49e1335c7d) )
-	ROM_LOAD16_BYTE( "rs_b04-40.20", 0x20000, 0x10000, CRC(6bcf70dc) SHA1(3e369548ac01981c503150b44c2747e6c2cec12a) )
+	ROM_LOAD16_BYTE( "b04-40(__rastsaga).20", 0x20000, 0x10000, CRC(6bcf70dc) SHA1(3e369548ac01981c503150b44c2747e6c2cec12a) )
 	ROM_LOAD16_BYTE( "b04-39.8",  0x20001, 0x10000, CRC(8838ecc5) SHA1(42b43ab77969bbacdf178fbe73a0a27652ccb297) )
-	ROM_LOAD16_BYTE( "rs_b04-42.21", 0x40000, 0x10000, CRC(b626c439) SHA1(976e820edc4ba107c5b579edaaee1e354e85fb67) )
+	ROM_LOAD16_BYTE( "b04-42(__rastsaga).21", 0x40000, 0x10000, CRC(b626c439) SHA1(976e820edc4ba107c5b579edaaee1e354e85fb67) )
 	ROM_LOAD16_BYTE( "b04-43.9",  0x40001, 0x10000, CRC(c928a516) SHA1(fe87fdf2d1b7ba93e1986460eb6af648b58f42e4) )
 
 	ROM_REGION( 0x1c000, "audiocpu", 0 )
diff -Nru src-old/mame/drivers/sderby.c src/mame/drivers/sderby.c
--- src-old/mame/drivers/sderby.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/sderby.c	2012-02-22 00:51:07.000000000 +0100
@@ -704,8 +704,8 @@
 
 ROM_START( croupiera )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "2a.bin", 0x00000, 0x20000, CRC(1677a2de) SHA1(4dcbb3c1ce9b65e06ba7e0cffa00c0c8016538f5))
-	ROM_LOAD16_BYTE( "3a.bin", 0x00001, 0x20000, CRC(11acaac2) SHA1(19e7bbbf4356fc9a866f9f36d0568c42d6a36c07))
+	ROM_LOAD16_BYTE( "2(__alt).bin", 0x00000, 0x20000, CRC(1677a2de) SHA1(4dcbb3c1ce9b65e06ba7e0cffa00c0c8016538f5))
+	ROM_LOAD16_BYTE( "3(__alt).bin", 0x00001, 0x20000, CRC(11acaac2) SHA1(19e7bbbf4356fc9a866f9f36d0568c42d6a36c07))
 
 	ROM_REGION( 0x080000, "oki", 0 ) /* samples are ok */
 	ROM_LOAD( "1.bin", 0x00000, 0x40000, CRC(6673de85) SHA1(df390cd6268efc0e743a9020f19bc0cbeb757cfa))
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2012-02-11 11:01:01.000000000 +0100
+++ src/mame/drivers/segas16b.c	2012-02-20 01:12:44.000000000 +0100
@@ -3711,7 +3711,7 @@
     CPU: 68000 + i8751 (317-0076)
     ROM Board: 171-5521
 */
-ROM_START( altbeast5 )
+ROM_START( altbeast6 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
 	ROM_LOAD16_BYTE( "epr-11883.a7", 0x000000, 0x20000, CRC(c5b3e8f7) SHA1(06c59d38093330b74f685cb02f8c7311e4a7b38c) )
 	ROM_LOAD16_BYTE( "epr-11882.a5", 0x000001, 0x20000, CRC(9c01170b) SHA1(7651f791e5488ce1143eeb4ad01eb924d1460170) )
@@ -3751,6 +3751,50 @@
 
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
+    CPU: FD1094 (317-0069)
+    ROM Board: 171-5521
+    Sega ID# for ROM board: 834-6661-07
+*/
+ROM_START( altbeast5 )
+	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
+	ROM_LOAD16_BYTE( "epr-11742.a7", 0x000000, 0x20000, CRC(61839534) SHA1(0246985ec642fb44d33acbbbec9f6a1936afb302) )
+	ROM_LOAD16_BYTE( "epr-11741.a5", 0x000001, 0x20000, CRC(9b2159cb) SHA1(dba53afcbb42be3e2611d00324bca6544faec071) )
+
+	ROM_REGION( 0x2000, "user1", 0 ) /* decryption key */
+	ROM_LOAD( "317-0069.key", 0x0000, 0x2000, CRC(959e256a) SHA1(392832620ddbe549b3a807ef226dadbf861a16ee) ) /* The "9" was printed over a "3" */
+
+	ROM_REGION( 0xc0000, "gfx1", 0 ) /* tiles */
+	ROM_LOAD( "epr-11722.a14", 0x00000, 0x10000,  CRC(adaa8db5) SHA1(3262c98d13d08c333d16052cac841f44d2f99743) ) /* plane 1 */
+	ROM_LOAD( "epr-11736.b14", 0x20000, 0x10000,  CRC(e9ad5e89) SHA1(769628eee6e194a84aa8a3729f4e7d07dd3ba25c) )
+	ROM_LOAD( "epr-11723.a15", 0x40000, 0x10000,  CRC(131a3f9a) SHA1(8182c3b8ce7a2f02b226cfa2081187593c9d0d0b) ) /* plane 2 */
+	ROM_LOAD( "epr-11737.b15", 0x60000, 0x10000,  CRC(2e420023) SHA1(3aa2c3b6fccafb4d53b6ab99b95181d3eed7c77f) )
+	ROM_LOAD( "epr-11724.a16", 0x80000, 0x10000,  CRC(6f2ed50a) SHA1(55d0c4299e7240b0ef5316b48db7a158145c76ab) ) /* plane 3 */
+	ROM_LOAD( "epr-11738.b16", 0xa0000, 0x10000,  CRC(de3d6d02) SHA1(428811f21c68761022521a17fc4716f6e7214b20) )
+
+	ROM_REGION16_BE( 0x200000, "gfx2", 0 ) /* sprites */
+	ROM_LOAD16_BYTE( "epr-11725.b1",  0x000001, 0x010000, CRC(f8b3684e) SHA1(3de2685cae5fb3c954b8440fafce313072747469) )
+	ROM_LOAD16_BYTE( "epr-11729.b5",  0x000000, 0x010000, CRC(ae3c2793) SHA1(c4f46861ea63ffa3c038a1ef931479b94e5382df) )
+	ROM_LOAD16_BYTE( "epr-11726.b2",  0x040001, 0x010000, CRC(3cce5419) SHA1(fccdbd6d05f5927272e7d6e5f997418d4fa2baf5) )
+	ROM_LOAD16_BYTE( "epr-11730.b6",  0x040000, 0x010000, CRC(3af62b55) SHA1(9f079af88aaf2447948c9ac01c6cbd1e79539704) )
+	ROM_LOAD16_BYTE( "epr-11727.b3",  0x080001, 0x010000, CRC(b0390078) SHA1(9035d9f45c67bdc802710018722943f5b63e8b5d) )
+	ROM_LOAD16_BYTE( "epr-11731.b7",  0x080000, 0x010000, CRC(2a87744a) SHA1(421b3926de046ddeddad05f65fc6b5078af28dbd) )
+	ROM_LOAD16_BYTE( "epr-11728.b4",  0x0c0001, 0x010000, CRC(f3a43fd8) SHA1(d42833ecd0c1920f1a6904d32c096f12d8622141) )
+	ROM_LOAD16_BYTE( "epr-11732.b8",  0x0c0000, 0x010000, CRC(2fb3e355) SHA1(960e0a66b23f79833b011ea35a5a412dffb47083) )
+	ROM_LOAD16_BYTE( "epr-11717.a1",  0x100001, 0x010000, CRC(676be0cb) SHA1(1e7d4c5f231992f111cc7885e97bc5a7267a5e89) )
+	ROM_LOAD16_BYTE( "epr-11733.b10", 0x100000, 0x010000, CRC(802cac94) SHA1(24e5aa74ce8b6c53c78cc33a41a473df3fbce639) )
+	ROM_LOAD16_BYTE( "epr-11718.a2",  0x140001, 0x010000, CRC(882864c2) SHA1(bd44bbdc13e5fd1b5c31c343da00a75b9dd90478) )
+	ROM_LOAD16_BYTE( "epr-11734.b11", 0x140000, 0x010000, CRC(76c704d2) SHA1(35b393071e29b8d122d3f904b923689a7dddc808) )
+	ROM_LOAD16_BYTE( "epr-11719.a3",  0x180001, 0x010000, CRC(339987f7) SHA1(b5650f8bdbd44510e84686b20daf70bc4a564f28) )
+	ROM_LOAD16_BYTE( "epr-11735.b12", 0x180000, 0x010000, CRC(4fe406aa) SHA1(7f068b81f35be4cc4785824ed524d28f201ff0a5) )
+
+	ROM_REGION( 0x50000, "soundcpu", 0 ) /* sound CPU */
+	ROM_LOAD( "epr-11671.a10", 0x00000, 0x08000, CRC(2b71343b) SHA1(8a657f787de2b9d5161ed2c109642a148348af09) )
+	ROM_LOAD( "opr-11672.a11", 0x10000, 0x20000, CRC(bbd7f460) SHA1(bbc5c2219cb3a827d84062b19affd9780da2a3cf) )
+	ROM_LOAD( "opr-11673.a12", 0x30000, 0x20000, CRC(400c4a36) SHA1(de4bdfa91734410e0a7f6a16bf8336db172f458a) )
+ROM_END
+
+/**************************************************************************************************************************
+    Altered Beast, Sega System 16B
     CPU: 68000 + MC-8123B 317-0066
     ROM Board: 171-5521
     Sega ID# for ROM board: 834-6661-06
@@ -3873,50 +3917,6 @@
 
 /**************************************************************************************************************************
     Jyuohki (Altered Beast), Sega System 16B
-    CPU: FD1094 (317-0069)
-    ROM Board: 171-5521
-    Sega ID# for ROM board: 834-6661-07
-*/
-ROM_START( altbeastj2 )
-	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "epr-11742.a7", 0x000000, 0x20000, CRC(61839534) SHA1(0246985ec642fb44d33acbbbec9f6a1936afb302) )
-	ROM_LOAD16_BYTE( "epr-11741.a5", 0x000001, 0x20000, CRC(9b2159cb) SHA1(dba53afcbb42be3e2611d00324bca6544faec071) )
-
-	ROM_REGION( 0x2000, "user1", 0 ) /* decryption key */
-	ROM_LOAD( "317-0069.key", 0x0000, 0x2000, NO_DUMP ) /* The "9" was printed over a "3" */
-
-	ROM_REGION( 0xc0000, "gfx1", 0 ) /* tiles */
-	ROM_LOAD( "epr-11722.a14", 0x00000, 0x10000,  CRC(adaa8db5) SHA1(3262c98d13d08c333d16052cac841f44d2f99743) ) /* plane 1 */
-	ROM_LOAD( "epr-11736.b14", 0x20000, 0x10000,  CRC(e9ad5e89) SHA1(769628eee6e194a84aa8a3729f4e7d07dd3ba25c) )
-	ROM_LOAD( "epr-11723.a15", 0x40000, 0x10000,  CRC(131a3f9a) SHA1(8182c3b8ce7a2f02b226cfa2081187593c9d0d0b) ) /* plane 2 */
-	ROM_LOAD( "epr-11737.b15", 0x60000, 0x10000,  CRC(2e420023) SHA1(3aa2c3b6fccafb4d53b6ab99b95181d3eed7c77f) )
-	ROM_LOAD( "epr-11724.a16", 0x80000, 0x10000,  CRC(6f2ed50a) SHA1(55d0c4299e7240b0ef5316b48db7a158145c76ab) ) /* plane 3 */
-	ROM_LOAD( "epr-11738.b16", 0xa0000, 0x10000,  CRC(de3d6d02) SHA1(428811f21c68761022521a17fc4716f6e7214b20) )
-
-	ROM_REGION16_BE( 0x200000, "gfx2", 0 ) /* sprites */
-	ROM_LOAD16_BYTE( "epr-11725.b1",  0x000001, 0x010000, CRC(f8b3684e) SHA1(3de2685cae5fb3c954b8440fafce313072747469) )
-	ROM_LOAD16_BYTE( "epr-11729.b5",  0x000000, 0x010000, CRC(ae3c2793) SHA1(c4f46861ea63ffa3c038a1ef931479b94e5382df) )
-	ROM_LOAD16_BYTE( "epr-11726.b2",  0x040001, 0x010000, CRC(3cce5419) SHA1(fccdbd6d05f5927272e7d6e5f997418d4fa2baf5) )
-	ROM_LOAD16_BYTE( "epr-11730.b6",  0x040000, 0x010000, CRC(3af62b55) SHA1(9f079af88aaf2447948c9ac01c6cbd1e79539704) )
-	ROM_LOAD16_BYTE( "epr-11727.b3",  0x080001, 0x010000, CRC(b0390078) SHA1(9035d9f45c67bdc802710018722943f5b63e8b5d) )
-	ROM_LOAD16_BYTE( "epr-11731.b7",  0x080000, 0x010000, CRC(2a87744a) SHA1(421b3926de046ddeddad05f65fc6b5078af28dbd) )
-	ROM_LOAD16_BYTE( "epr-11728.b4",  0x0c0001, 0x010000, CRC(f3a43fd8) SHA1(d42833ecd0c1920f1a6904d32c096f12d8622141) )
-	ROM_LOAD16_BYTE( "epr-11732.b8",  0x0c0000, 0x010000, CRC(2fb3e355) SHA1(960e0a66b23f79833b011ea35a5a412dffb47083) )
-	ROM_LOAD16_BYTE( "epr-11717.a1",  0x100001, 0x010000, CRC(676be0cb) SHA1(1e7d4c5f231992f111cc7885e97bc5a7267a5e89) )
-	ROM_LOAD16_BYTE( "epr-11733.b10", 0x100000, 0x010000, CRC(802cac94) SHA1(24e5aa74ce8b6c53c78cc33a41a473df3fbce639) )
-	ROM_LOAD16_BYTE( "epr-11718.a2",  0x140001, 0x010000, CRC(882864c2) SHA1(bd44bbdc13e5fd1b5c31c343da00a75b9dd90478) )
-	ROM_LOAD16_BYTE( "epr-11734.b11", 0x140000, 0x010000, CRC(76c704d2) SHA1(35b393071e29b8d122d3f904b923689a7dddc808) )
-	ROM_LOAD16_BYTE( "epr-11719.a3",  0x180001, 0x010000, CRC(339987f7) SHA1(b5650f8bdbd44510e84686b20daf70bc4a564f28) )
-	ROM_LOAD16_BYTE( "epr-11735.b12", 0x180000, 0x010000, CRC(4fe406aa) SHA1(7f068b81f35be4cc4785824ed524d28f201ff0a5) )
-
-	ROM_REGION( 0x50000, "soundcpu", 0 ) /* sound CPU */
-	ROM_LOAD( "epr-11671.a10", 0x00000, 0x08000, CRC(2b71343b) SHA1(8a657f787de2b9d5161ed2c109642a148348af09) )
-	ROM_LOAD( "opr-11672.a11", 0x10000, 0x20000, CRC(bbd7f460) SHA1(bbc5c2219cb3a827d84062b19affd9780da2a3cf) )
-	ROM_LOAD( "opr-11673.a12", 0x30000, 0x20000, CRC(400c4a36) SHA1(de4bdfa91734410e0a7f6a16bf8336db172f458a) )
-ROM_END
-
-/**************************************************************************************************************************
-    Jyuohki (Altered Beast), Sega System 16B
     CPU: FD1094 (317-0065)
     ROM Board: 171-5521
 */
@@ -3932,14 +3932,6 @@
 	ROM_LOAD( "opr-11674.a14", 0x00000, 0x20000, CRC(a57a66d5) SHA1(5103583d48997abad12a0c5fee26431c486ced52) )
 	ROM_LOAD( "opr-11675.a15", 0x20000, 0x20000, CRC(2ef2f144) SHA1(38d22d609db2d9b6067b5d12f6499436de4605cb) )
 	ROM_LOAD( "opr-11676.a16", 0x40000, 0x20000, CRC(0c04acac) SHA1(87fe2a0dd9913f9550e9b4cbc7e7465b61640e07) )
-/* If this is truly a Japanese set it should use these roms:
-    ROM_LOAD( "epr-11722.a14", 0x00000, 0x10000,  CRC(adaa8db5) SHA1(3262c98d13d08c333d16052cac841f44d2f99743) )
-    ROM_LOAD( "epr-11736.b14", 0x20000, 0x10000,  CRC(e9ad5e89) SHA1(769628eee6e194a84aa8a3729f4e7d07dd3ba25c) )
-    ROM_LOAD( "epr-11723.a15", 0x40000, 0x10000,  CRC(131a3f9a) SHA1(8182c3b8ce7a2f02b226cfa2081187593c9d0d0b) )
-    ROM_LOAD( "epr-11737.b15", 0x60000, 0x10000,  CRC(2e420023) SHA1(3aa2c3b6fccafb4d53b6ab99b95181d3eed7c77f) )
-    ROM_LOAD( "epr-11724.a16", 0x80000, 0x10000,  CRC(6f2ed50a) SHA1(55d0c4299e7240b0ef5316b48db7a158145c76ab) )
-    ROM_LOAD( "epr-11738.b16", 0xa0000, 0x10000,  CRC(de3d6d02) SHA1(428811f21c68761022521a17fc4716f6e7214b20) )
-*/
 
 	ROM_REGION16_BE( 0x100000, "gfx2", 0 ) /* sprites */
 	ROM_LOAD16_BYTE( "epr-11677.b1", 0x00001, 0x20000, CRC(a01425cd) SHA1(72be5ec29e476601f9bf6aaedef9b73cedeb42f0) )
@@ -3950,22 +3942,6 @@
 	ROM_LOAD16_BYTE( "epr-11683.b7", 0x80000, 0x20000, CRC(f9a60f06) SHA1(0cffcfdb02733feaa869198b7e668c58b47c321a) )
 	ROM_LOAD16_BYTE( "epr-11680.b4", 0xc0001, 0x20000, CRC(f43dcdec) SHA1(2941500cf33afca487f19f2329033d5d17aad826) )
 	ROM_LOAD16_BYTE( "epr-11684.b8", 0xc0000, 0x20000, CRC(b20c0edb) SHA1(6c8694d05e3adac37c9015037ab800233371db36) )
-/* If this is truly a Japanese set it should use these roms:
-    ROM_LOAD16_BYTE( "epr-11725.b1",  0x000001, 0x010000, CRC(f8b3684e) SHA1(3de2685cae5fb3c954b8440fafce313072747469) )
-    ROM_LOAD16_BYTE( "epr-11729.b5",  0x000000, 0x010000, CRC(ae3c2793) SHA1(c4f46861ea63ffa3c038a1ef931479b94e5382df) )
-    ROM_LOAD16_BYTE( "epr-11726.b2",  0x040001, 0x010000, CRC(3cce5419) SHA1(fccdbd6d05f5927272e7d6e5f997418d4fa2baf5) )
-    ROM_LOAD16_BYTE( "epr-11730.b6",  0x040000, 0x010000, CRC(3af62b55) SHA1(9f079af88aaf2447948c9ac01c6cbd1e79539704) )
-    ROM_LOAD16_BYTE( "epr-11727.b3",  0x080001, 0x010000, CRC(b0390078) SHA1(9035d9f45c67bdc802710018722943f5b63e8b5d) )
-    ROM_LOAD16_BYTE( "epr-11731.b7",  0x080000, 0x010000, CRC(2a87744a) SHA1(421b3926de046ddeddad05f65fc6b5078af28dbd) )
-    ROM_LOAD16_BYTE( "epr-11728.b4",  0x0c0001, 0x010000, CRC(f3a43fd8) SHA1(d42833ecd0c1920f1a6904d32c096f12d8622141) )
-    ROM_LOAD16_BYTE( "epr-11732.b8",  0x0c0000, 0x010000, CRC(2fb3e355) SHA1(960e0a66b23f79833b011ea35a5a412dffb47083) )
-    ROM_LOAD16_BYTE( "epr-11717.a1",  0x100001, 0x010000, CRC(676be0cb) SHA1(1e7d4c5f231992f111cc7885e97bc5a7267a5e89) )
-    ROM_LOAD16_BYTE( "epr-11733.b10", 0x100000, 0x010000, CRC(802cac94) SHA1(24e5aa74ce8b6c53c78cc33a41a473df3fbce639) )
-    ROM_LOAD16_BYTE( "epr-11718.a2",  0x140001, 0x010000, CRC(882864c2) SHA1(bd44bbdc13e5fd1b5c31c343da00a75b9dd90478) )
-    ROM_LOAD16_BYTE( "epr-11734.b11", 0x140000, 0x010000, CRC(76c704d2) SHA1(35b393071e29b8d122d3f904b923689a7dddc808) )
-    ROM_LOAD16_BYTE( "epr-11719.a3",  0x180001, 0x010000, CRC(339987f7) SHA1(b5650f8bdbd44510e84686b20daf70bc4a564f28) )
-    ROM_LOAD16_BYTE( "epr-11735.b12", 0x180000, 0x010000, CRC(4fe406aa) SHA1(7f068b81f35be4cc4785824ed524d28f201ff0a5) )
-*/
 
 	ROM_REGION( 0x50000, "soundcpu", 0 ) /* sound CPU */
 	ROM_LOAD( "epr-11671.a10", 0x00000, 0x08000, CRC(2b71343b) SHA1(8a657f787de2b9d5161ed2c109642a148348af09) )
@@ -6682,12 +6658,12 @@
 
 GAME( 1988, altbeast,   0,        system16b_8751,      altbeast, altbeast_5521,      ROT0,   "Sega", "Altered Beast (set 8, 8751 317-0078)", 0 )
 GAME( 1988, altbeastj,  altbeast, system16b_8751,      altbeast, altbeasj_5521,      ROT0,   "Sega", "Juuouki (set 7, Japan, 8751 317-0077)", 0 )
-GAME( 1988, altbeast5,  altbeast, system16b_8751,      altbeast, altbeas5_5521,      ROT0,   "Sega", "Altered Beast (set 6, 8751 317-0076)", 0 )
+GAME( 1988, altbeast6,  altbeast, system16b_8751,      altbeast, altbeas5_5521,      ROT0,   "Sega", "Altered Beast (set 6, 8751 317-0076)", 0 )
+GAME( 1988, altbeast5,  altbeast, system16b,           altbeast, generic_5521,       ROT0,   "Sega", "Altered Beast (set 5, FD1094 317-0069)", 0 )
 GAME( 1988, altbeast4,  altbeast, system16b,           altbeast, altbeas4_5521,      ROT0,   "Sega", "Altered Beast (set 4, MC-8123B 317-0066)", 0 )
 GAME( 1988, altbeastj3, altbeast, system16b,           altbeast, generic_5521,       ROT0,   "Sega", "Juuouki (set 3, Japan, FD1094 317-0068)", 0 )
 GAME( 1988, altbeast2,  altbeast, system16b,           altbeast, altbeas4_5521,      ROT0,   "Sega", "Altered Beast (set 2, MC-8123B 317-0066)", 0 )
 GAME( 1988, altbeastj1, altbeast, system16b,           altbeast, generic_5521,       ROT0,   "Sega", "Juuouki (set 1, Japan, FD1094 317-0065)", GAME_NOT_WORKING ) /* No CPU decrypt key */
-GAME( 1988, altbeastj2, altbeast, system16b,           altbeast, generic_5521,       ROT0,   "Sega", "Juuouki (set 5, Japan, FD1094 317-0069)", GAME_NOT_WORKING ) /* No CPU decrypt key */
 
 GAME( 1990, aurail,     0,        system16b,           aurail,   generic_5704,       ROT0,   "Sega / Westone", "Aurail (set 3, US, unprotected)", 0 )
 GAME( 1990, aurail1,    aurail,   system16b,           aurail,   aurail1_5704,       ROT0,   "Sega / Westone", "Aurail (set 2, World, FD1089B 317-0168)", 0 )
diff -Nru src-old/mame/drivers/spoker.c src/mame/drivers/spoker.c
--- src-old/mame/drivers/spoker.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/spoker.c	2012-02-22 00:51:07.000000000 +0100
@@ -607,12 +607,12 @@
 
 ROM_START( spk115it )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "v_115.bin",   0x0000, 0x10000, CRC(df52997b) SHA1(72a76e84aeedfdebd4c6cb47809117a28b5d3892) )
+	ROM_LOAD( "v(__115).bin",   0x0000, 0x10000, CRC(df52997b) SHA1(72a76e84aeedfdebd4c6cb47809117a28b5d3892) )
 
 	ROM_REGION( 0xc0000, "gfx1", 0 )
-	ROM_LOAD( "6_115.bin",  0x80000, 0x40000, CRC(f9b027f8) SHA1(c4686a4024062482f9864e0445087e32899fc775) )
-	ROM_LOAD( "5_115.bin",  0x40000, 0x40000, CRC(baca51b6) SHA1(c97322c814729332378b6304a79062fea385ca97) )
-	ROM_LOAD( "4_115.bin",  0x00000, 0x40000, CRC(1172c790) SHA1(43f1d019ecae5c605722e3fe77ae2f022b01260b) )
+	ROM_LOAD( "6(__115).bin",  0x80000, 0x40000, CRC(f9b027f8) SHA1(c4686a4024062482f9864e0445087e32899fc775) )
+	ROM_LOAD( "5(__115).bin",  0x40000, 0x40000, CRC(baca51b6) SHA1(c97322c814729332378b6304a79062fea385ca97) )
+	ROM_LOAD( "4(__115).bin",  0x00000, 0x40000, CRC(1172c790) SHA1(43f1d019ecae5c605722e3fe77ae2f022b01260b) )
 
 	ROM_REGION( 0x30000, "gfx2", 0 )
 	ROM_LOAD( "3.bin",  0x20000, 0x10000, CRC(5f18b012) SHA1(c9a96237eaf3138f136bbaffb29dde0ef568ce73) )
@@ -661,9 +661,9 @@
 	ROM_LOAD( "pic16c65a-20-p", 0x0000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0xc0000, "gfx1", 0 )
-	ROM_LOAD( "1_bad.bin", 0x00000, 0x40000, BAD_DUMP CRC(d9d3e21e) SHA1(2f3f07ca427d9f56f0ff143d15d95cbf15255e33) )
-	ROM_LOAD( "2_bad.bin", 0x40000, 0x40000, BAD_DUMP CRC(fbb50ab1) SHA1(50a7ef9219c38d59117c510fe6d53fb3ba1fa456) )
-	ROM_LOAD( "3_bad.bin", 0x80000, 0x40000, BAD_DUMP CRC(545aa4e6) SHA1(3348d4b692900c9e9cd4a52b20922a84e596cd35) )
+	ROM_LOAD( "1(__baddump).bin", 0x00000, 0x40000, BAD_DUMP CRC(d9d3e21e) SHA1(2f3f07ca427d9f56f0ff143d15d95cbf15255e33) )
+	ROM_LOAD( "2(__baddump).bin", 0x40000, 0x40000, BAD_DUMP CRC(fbb50ab1) SHA1(50a7ef9219c38d59117c510fe6d53fb3ba1fa456) )
+	ROM_LOAD( "3(__baddump).bin", 0x80000, 0x40000, BAD_DUMP CRC(545aa4e6) SHA1(3348d4b692900c9e9cd4a52b20922a84e596cd35) )
 	ROM_FILL( 0x00000 ,0x20000, 0x00 )
 	ROM_FILL( 0x40000 ,0x20000, 0x00 )
 	ROM_FILL( 0x80000 ,0x20000, 0x00 )
diff -Nru src-old/mame/drivers/stfight.c src/mame/drivers/stfight.c
--- src-old/mame/drivers/stfight.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/stfight.c	2012-02-22 00:51:07.000000000 +0100
@@ -599,8 +599,8 @@
 
 ROM_START( empcityj )
 	ROM_REGION( 2*0x18000, "maincpu", 0 )	/* 96k for code + 96k for decrypted opcodes */
-	ROM_LOAD( "ec_1.bin",   0x00000, 0x8000, CRC(8162331c) SHA1(f2fdf5fbc52d4ea692fb87fa049c48935a73d67b) )
-	ROM_LOAD( "ec_2.bin",   0x10000, 0x8000, CRC(960edea6) SHA1(fd19475e841defe42625a94c40c6390b7e6e7682) )	/* bank switched */
+	ROM_LOAD( "1(__empcityj).bin",   0x00000, 0x8000, CRC(8162331c) SHA1(f2fdf5fbc52d4ea692fb87fa049c48935a73d67b) )
+	ROM_LOAD( "2(__empcityj).bin",   0x10000, 0x8000, CRC(960edea6) SHA1(fd19475e841defe42625a94c40c6390b7e6e7682) )	/* bank switched */
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* 64k for the second CPU */
 	ROM_LOAD( "ec_04.rom",  0x0000,  0x8000, CRC(aa3e7d1e) SHA1(da350384d55f011253d19ce17fc327cd2604257f) )
diff -Nru src-old/mame/drivers/system1.c src/mame/drivers/system1.c
--- src-old/mame/drivers/system1.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/system1.c	2012-02-22 00:51:07.000000000 +0100
@@ -3423,7 +3423,7 @@
 */
 ROM_START( shtngmste )
 	ROM_REGION( 0x20000, "maincpu", 0 )
-	ROM_LOAD( "epr7100_evg.ic18", 0x00000, 0x8000, CRC(268ecb1d) SHA1(a9274c9718f7244235cc6df76331d6a0b7e4e4c8) )
+	ROM_LOAD( "epr7100(__evg).ic18", 0x00000, 0x8000, CRC(268ecb1d) SHA1(a9274c9718f7244235cc6df76331d6a0b7e4e4c8) )
 	ROM_LOAD( "epr7101.ic91", 0x10000, 0x8000, CRC(ebf5ff72) SHA1(13ae06e3a81cf00b80ec939d5baf30143d61d480) )
 	ROM_LOAD( "epr7102.ic92", 0x18000, 0x8000, CRC(c890a4ad) SHA1(4b59d37902ace3a69b380ff40652ee37c85f0e9d) )
 
diff -Nru src-old/mame/drivers/thayers.c src/mame/drivers/thayers.c
--- src-old/mame/drivers/thayers.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/thayers.c	2012-02-22 00:51:07.000000000 +0100
@@ -821,7 +821,7 @@
 ROM_START( thayersa )
 	ROM_REGION( 0xe000, "maincpu", 0 )
 	ROM_LOAD( "tq_u33.bin", 0x0000, 0x8000, CRC(82df5d89) SHA1(58dfd62bf8c5a55d1eba397d2c284e99a4685a3f) )
-	ROM_LOAD( "tq_u1_alt.bin",  0xc000, 0x2000, CRC(33817e25) SHA1(f9750da863dd57fe2f5b6e8fce9c6695dc5c9adc) )
+	ROM_LOAD( "tq_u1(__alt).bin",  0xc000, 0x2000, CRC(33817e25) SHA1(f9750da863dd57fe2f5b6e8fce9c6695dc5c9adc) )
 
 	ROM_REGION( 0x400, "mcu", 0 )
 	ROM_LOAD( "tq_cop.bin", 0x000, 0x400, CRC(6748e6b3) SHA1(5d7d1ecb57c1501ef6a2d9691eecc9970586606b) )
diff -Nru src-old/mame/drivers/thepit.c src/mame/drivers/thepit.c
--- src-old/mame/drivers/thepit.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/thepit.c	2012-02-22 00:51:07.000000000 +0100
@@ -827,18 +827,18 @@
 
 ROM_START( fitterbl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "bl-ic38.bin",  0x0000, 0x1000, CRC(805c6974) SHA1(b1a41df746a347df6f47578fc59a7393e5195ada) )
-	ROM_LOAD( "bl-ic39.bin",  0x1000, 0x1000, CRC(37bf554b) SHA1(773279fb21c56221d5f29fd31c2149e68dcf3909) )
-	ROM_LOAD( "bl-ic40.bin",  0x2000, 0x1000, CRC(c5f7156e) SHA1(3702a0eb4c395217a8f761133dba7871a96b7f38) )
-	ROM_LOAD( "bl-ic41.bin",  0x3000, 0x1000, CRC(a67d5bda) SHA1(86d1628d4f0bcd3c3099f99ab92b3ac758ffec71) )
-	ROM_LOAD( "bl-ic33.bin",  0x4000, 0x1000, CRC(1f3c78ee) SHA1(961b6ba8d08ddcbeda52b98a2f181f37beed5fb1) )
+	ROM_LOAD( "ic38(__bootleg).bin",  0x0000, 0x1000, CRC(805c6974) SHA1(b1a41df746a347df6f47578fc59a7393e5195ada) )
+	ROM_LOAD( "ic39(__bootleg).bin",  0x1000, 0x1000, CRC(37bf554b) SHA1(773279fb21c56221d5f29fd31c2149e68dcf3909) )
+	ROM_LOAD( "ic40(__bootleg).bin",  0x2000, 0x1000, CRC(c5f7156e) SHA1(3702a0eb4c395217a8f761133dba7871a96b7f38) )
+	ROM_LOAD( "ic41(__bootleg).bin",  0x3000, 0x1000, CRC(a67d5bda) SHA1(86d1628d4f0bcd3c3099f99ab92b3ac758ffec71) )
+	ROM_LOAD( "ic33(__bootleg).bin",  0x4000, 0x1000, CRC(1f3c78ee) SHA1(961b6ba8d08ddcbeda52b98a2f181f37beed5fb1) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "bl-ic30.bin",  0x0000, 0x0800, CRC(1b18faee) SHA1(b4002e2fdaa6bb966da4faa46ac56751a3841f5f) )
-	ROM_LOAD( "bl-ic31.bin",  0x0800, 0x0800, CRC(76cf4394) SHA1(5dc13bd5fc92ce4ce12bab60576292a6028891c3) )
+	ROM_LOAD( "ic30(__bootleg).bin",  0x0000, 0x0800, CRC(1b18faee) SHA1(b4002e2fdaa6bb966da4faa46ac56751a3841f5f) )
+	ROM_LOAD( "ic31(__bootleg).bin",  0x0800, 0x0800, CRC(76cf4394) SHA1(5dc13bd5fc92ce4ce12bab60576292a6028891c3) )
 
 	ROM_REGION( 0x1800, "gfx1", 0 ) /* chars and sprites */
-	ROM_LOAD( "bl-ic9.bin",   0x0000, 0x0800, CRC(394676a2) SHA1(5bd26d717e25b7c192af8173db9ae18371dbcfbe) )
+	ROM_LOAD( "ic9(__bootleg).bin",   0x0000, 0x0800, CRC(394676a2) SHA1(5bd26d717e25b7c192af8173db9ae18371dbcfbe) )
 	ROM_LOAD( "ic10.bin",     0x1000, 0x0800, CRC(a38d708d) SHA1(6632392cece34332a2a4427ec14d95f201319c67) )
 
 	ROM_REGION( 0x0020, "proms", 0 )
diff -Nru src-old/mame/drivers/tmaster.c src/mame/drivers/tmaster.c
--- src-old/mame/drivers/tmaster.c	2012-01-27 15:57:03.000000000 +0100
+++ src/mame/drivers/tmaster.c	2012-02-19 17:46:00.000000000 +0100
@@ -121,9 +121,12 @@
 public:
 	tmaster_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this,"maincpu"),
+		m_microtouch(*this,"microtouch")
 		{ }
 
+	DECLARE_WRITE8_MEMBER(microtouch_tx);
+
 	int m_okibank;
 	UINT8 m_rtc_ram[8];
 	bitmap_ind16 m_bitmap[2][2];
@@ -141,6 +144,7 @@
 	device_t *m_duart68681;
 
 	required_device<cpu_device> m_maincpu;
+	optional_device<microtouch_device> m_microtouch;
 };
 
 
@@ -179,18 +183,23 @@
 
 static void duart_tx(device_t *device, int channel, UINT8 data)
 {
+	tmaster_state *state = device->machine().driver_data<tmaster_state>();
 	if ( channel == 0 )
 	{
-		microtouch_rx(1, &data);
+		state->m_microtouch->rx(*memory_nonspecific_space(device->machine()), 0, data);
 	}
 };
 
-static void microtouch_tx(running_machine &machine, UINT8 data)
+WRITE8_MEMBER( tmaster_state::microtouch_tx )
 {
-	tmaster_state *state = machine.driver_data<tmaster_state>();
-	duart68681_rx_data(state->m_duart68681, 0, data);
+	duart68681_rx_data(m_duart68681, 0, data);
 }
 
+static const microtouch_interface tmaster_microtouch_config =
+{
+	DEVCB_DRIVER_MEMBER(tmaster_state, microtouch_tx),
+	NULL
+};
 
 /***************************************************************************
 
@@ -766,8 +775,6 @@
 
 ***************************************************************************/
 static INPUT_PORTS_START( tm )
-	PORT_INCLUDE( microtouch )
-
 	PORT_START("COIN")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN5 )	// "M. Coin 1 Input"
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN6 )	// "M. Coin 2 Input"
@@ -788,8 +795,6 @@
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( tmaster )
-	PORT_INCLUDE( microtouch )
-
 	PORT_START("COIN")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )	// "M. Coin 1 Input"
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )	// "M. Coin 2 Input"
@@ -863,11 +868,6 @@
 
 ***************************************************************************/
 
-static MACHINE_START( tmaster )
-{
-	microtouch_init(machine, microtouch_tx, 0);
-}
-
 static MACHINE_RESET( tmaster )
 {
 	tmaster_state *state = machine.driver_data<tmaster_state>();
@@ -904,10 +904,10 @@
 	MCFG_CPU_PROGRAM_MAP(tmaster_map)
 	MCFG_TIMER_ADD_SCANLINE("scantimer", tm3k_interrupt, "screen", 0, 1)
 
-	MCFG_MACHINE_START(tmaster)
 	MCFG_MACHINE_RESET(tmaster)
 
 	MCFG_DUART68681_ADD( "duart68681", XTAL_8_664MHz / 2 /*??*/, tmaster_duart68681_config )
+	MCFG_MICROTOUCH_ADD( "microtouch", tmaster_microtouch_config )
 
 	MCFG_NVRAM_ADD_0FILL("nvram")
 
diff -Nru src-old/mame/drivers/vamphalf.c src/mame/drivers/vamphalf.c
--- src-old/mame/drivers/vamphalf.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/drivers/vamphalf.c	2012-02-22 00:51:07.000000000 +0100
@@ -1654,8 +1654,8 @@
 
 ROM_START( wyvernwga )
 	ROM_REGION32_BE( 0x100000, "user1", ROMREGION_ERASE00 ) /* Hyperstone CPU Code */
-	ROM_LOAD( "rom1_alt.rom", 0x000000, 0x080000, CRC(586881fd) SHA1(d335bbd91def8fa4935eb2375c9b00471a1f40eb) )
-	ROM_LOAD( "rom2_alt.rom", 0x080000, 0x080000, CRC(938049ec) SHA1(cc10944c99ceb388dd4aafc93377c40540861d14) )
+	ROM_LOAD( "rom1(__alt).rom", 0x000000, 0x080000, CRC(586881fd) SHA1(d335bbd91def8fa4935eb2375c9b00471a1f40eb) )
+	ROM_LOAD( "rom2(__alt).rom", 0x080000, 0x080000, CRC(938049ec) SHA1(cc10944c99ceb388dd4aafc93377c40540861d14) )
 
 	ROM_REGION( 0x020000, "audiocpu", 0 ) /* QDSP ('51) Code */
 	ROM_LOAD( "u7", 0x0000, 0x20000, CRC(00a3f705) SHA1(f0a6bafd16bea53d4c05c8cc108983cbd41e5757) )
diff -Nru src-old/mame/drivers/white_mod.c src/mame/drivers/white_mod.c
--- src-old/mame/drivers/white_mod.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/white_mod.c	2012-02-22 00:51:07.000000000 +0100
@@ -3140,12 +3140,12 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3_400.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
+	ROM_LOAD("sopsnd3(__400).u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnda.u17", 0x000000, 0x100000, CRC(21e0cfd2) SHA1(d2ff1242f1f4a206e0b2884c079ef2be5df143ac))
-	ROM_LOAD("sopsnda_400.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
-	ROM_LOAD("sopsnda_400.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
-	ROM_LOAD("sopsnda_400.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
+	ROM_LOAD("sopsnda(__400).u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
+	ROM_LOAD("sopsnda(__400).u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
+	ROM_LOAD("sopsnda(__400).u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
 ROM_END
 
 ROM_START(sopranos_300)
@@ -3163,12 +3163,12 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3_300.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
+	ROM_LOAD("sopsnd3(__300).u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnda.u17", 0x000000, 0x100000, CRC(21e0cfd2) SHA1(d2ff1242f1f4a206e0b2884c079ef2be5df143ac))
-	ROM_LOAD("sopsnda_300.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
-	ROM_LOAD("sopsnda_300.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
-	ROM_LOAD("sopsnda_300.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
+	ROM_LOAD("sopsnda(__300).u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
+	ROM_LOAD("sopsnda(__300).u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
+	ROM_LOAD("sopsnda(__300).u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
 ROM_END
 
 ROM_START(sopranos_204)
@@ -3186,7 +3186,7 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3_204.u7",0x0000,0x10000,CRC(4f6748b5) SHA1(63e953a1455dee2a44484fef951fa34cb2e55d7b))
+	ROM_LOAD("sopsnd3(__204).u7",0x0000,0x10000,CRC(4f6748b5) SHA1(63e953a1455dee2a44484fef951fa34cb2e55d7b))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnd1.u17", 0x000000, 0x100000, CRC(1ecc5ecc) SHA1(42897387b90df8da8ae556ccc46e281ca461c063))
 	ROM_LOAD("sopsnd1.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
diff -Nru src-old/mame/drivers/williams.c src/mame/drivers/williams.c
--- src-old/mame/drivers/williams.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/williams.c	2012-02-22 00:51:07.000000000 +0100
@@ -2397,12 +2397,12 @@
 
 ROM_START( blastero )
 	ROM_REGION( 0x54000, "maincpu", 0 )
-	ROM_LOAD( "o_16.ic39",   0x0d000, 0x1000, CRC(2db032d2) SHA1(287769361639695b1c1ceae0fe6899d83b4575d5) )
-	ROM_LOAD( "o_13.ic27",   0x0e000, 0x2000, CRC(c99213c7) SHA1(d1c1549c053de3d862d8ef3ebca02811ed289464) )
+	ROM_LOAD( "16(__30wave).ic39",   0x0d000, 0x1000, CRC(2db032d2) SHA1(287769361639695b1c1ceae0fe6899d83b4575d5) )
+	ROM_LOAD( "13(__30wave).ic27",   0x0e000, 0x2000, CRC(c99213c7) SHA1(d1c1549c053de3d862d8ef3ebca02811ed289464) )
 
-	ROM_LOAD( "o_11.ic25",   0x10000, 0x2000, CRC(bc2d7eda) SHA1(831e9ecb75b143f9770eab1939136092a29e64f7) )
-	ROM_LOAD( "o_12.ic26",   0x12000, 0x2000, CRC(8a215017) SHA1(ee9233134907c03f7a1221d9daa84fe047c2db94) )
-	ROM_LOAD( "o_17.ic41",   0x14000, 0x1000, CRC(b308f0e5) SHA1(262e25be40dff66e65a0fe34c9d013a750b90876) )
+	ROM_LOAD( "11(__30wave).ic25",   0x10000, 0x2000, CRC(bc2d7eda) SHA1(831e9ecb75b143f9770eab1939136092a29e64f7) )
+	ROM_LOAD( "12(__30wave).ic26",   0x12000, 0x2000, CRC(8a215017) SHA1(ee9233134907c03f7a1221d9daa84fe047c2db94) )
+	ROM_LOAD( "17(__30wave).ic41",   0x14000, 0x1000, CRC(b308f0e5) SHA1(262e25be40dff66e65a0fe34c9d013a750b90876) )
 
 	ROM_LOAD( "15.ic38",     0x18000, 0x4000, CRC(1ad146a4) SHA1(5ab3d9618023b59bc329a9eeef986901867a639b) )
 	ROM_LOAD( "8.ic20",      0x1c000, 0x4000, CRC(f110bbb0) SHA1(314dea232a3706509399348c7415f933c64cea1b) )
@@ -2411,11 +2411,11 @@
 	ROM_LOAD( "6.ic13",      0x28000, 0x4000, CRC(47fc007e) SHA1(3a80b9b7ae460e9732f7c1cdd465a5b06ded970f) )
 	ROM_LOAD( "5.ic11",      0x2c000, 0x4000, CRC(15c1b94d) SHA1(5d97628541eb8933870c3ffd3646b7aaf8af6af5) )
 	ROM_LOAD( "14.ic35",     0x30000, 0x4000, CRC(aea6b846) SHA1(04cb4b5eb000471a0cec377a5236ac8c83529528) )
-	ROM_LOAD( "o_7.ic15",    0x34000, 0x4000, CRC(a1c4db77) SHA1(7a878d44b6ca7444ecbb6c8f75e5e91de149daf3) )
+	ROM_LOAD( "7(__30wave).ic15",    0x34000, 0x4000, CRC(a1c4db77) SHA1(7a878d44b6ca7444ecbb6c8f75e5e91de149daf3) )
 	ROM_LOAD( "1.ic1",       0x38000, 0x4000, CRC(8d0ea9e7) SHA1(34f8e2e99748bed29285f7e4929bb920960ab03e) )
 	ROM_LOAD( "2.ic3",       0x3c000, 0x4000, CRC(03c4012c) SHA1(53f0adc91e5f1ac58b08b3a6d2de8de5a40bebab) )
-	ROM_LOAD( "o_4.ic7",     0x40000, 0x4000, CRC(39d2a32c) SHA1(33707877e841ef86a11b47ffabddce7f3d2a7030) )
-	ROM_LOAD( "o_3.ic6",     0x44000, 0x4000, CRC(054c9f1c) SHA1(c21e3493f1ae506ab9fd28ed9ecc67d3305e9d7a) )
+	ROM_LOAD( "4(__30wave).ic7",     0x40000, 0x4000, CRC(39d2a32c) SHA1(33707877e841ef86a11b47ffabddce7f3d2a7030) )
+	ROM_LOAD( "3(__30wave).ic6",     0x44000, 0x4000, CRC(054c9f1c) SHA1(c21e3493f1ae506ab9fd28ed9ecc67d3305e9d7a) )
 
 	ROM_REGION( 0x10000, "soundcpu", 0 )
 	ROM_LOAD( "18.sb13",      0xf000, 0x1000, CRC(c33a3145) SHA1(6ffe2da7b70c0b576fbc1790a33eecdbb9ee3d02) )
diff -Nru src-old/mame/includes/cd32.h src/mame/includes/cd32.h
--- src-old/mame/includes/cd32.h	2011-04-27 06:11:18.000000000 +0200
+++ src/mame/includes/cd32.h	2012-02-26 15:31:24.000000000 +0100
@@ -8,13 +8,19 @@
 #define __CUBOCD32_H__
 
 #include "includes/amiga.h"
+#include "machine/microtch.h"
 
 class cd32_state : public amiga_state
 {
 public:
 	cd32_state(const machine_config &mconfig, device_type type, const char *tag)
-		: amiga_state(mconfig, type, tag) { }
+		: amiga_state(mconfig, type, tag),
+		  m_microtouch(*this, "microtouch")
+		{ }
 
+	required_device<microtouch_device> m_microtouch;
+
+	DECLARE_WRITE8_MEMBER(microtouch_tx);
 	UINT16 m_potgo_value;
 	int m_cd32_shifter[2];
 	void (*m_input_hack)(running_machine &machine);
diff -Nru src-old/mame/machine/n64.c src/mame/machine/n64.c
--- src-old/mame/machine/n64.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/machine/n64.c	2012-02-26 15:31:24.000000000 +0100
@@ -76,7 +76,7 @@
 	rspcpu = machine().device("rsp");
 	mem_map = maincpu->memory().space(AS_PROGRAM);
 
-	mi_version = 0x02020102;
+	mi_version = 0x01010101;
 	mi_interrupt = 0;
 	mi_intr_mask = 0;
 	mi_mode = 0;
@@ -144,6 +144,9 @@
 	dd_seq_ctrl_reg = 0;
 	dd_int = 0;
 
+	memset(ri_regs, 0, sizeof(ri_regs));
+
+	//ri_regs[3] = 1;
 	memset(pif_ram, 0, sizeof(pif_ram));
 	memset(pif_cmd, 0, sizeof(pif_cmd));
 	si_dram_addr = 0;
@@ -263,13 +266,13 @@
 			break;
 	}
 
-	//printf("mi_reg_r %08x = %08x\n", offset * 4, ret);
+	//printf("mi_reg_r %08x = %08x\n", offset * 4, ret); fflush(stdout);
 	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::mi_reg_w )
 {
-	//printf("mi_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
+	//printf("mi_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask); fflush(stdout);
 	switch (offset)
 	{
 		case 0x00/4:		// MI_INIT_MODE_REG
@@ -360,12 +363,12 @@
 {
 	if (mi_intr_mask & mi_interrupt)
 	{
-		//printf("Asserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt);
+		//printf("Asserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt); fflush(stdout);
 		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, ASSERT_LINE);
 	}
 	else
 	{
-		//printf("Deasserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt);
+		//printf("Deasserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt); fflush(stdout);
 		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, CLEAR_LINE);
 	}
 }
@@ -462,7 +465,7 @@
 
 READ32_MEMBER( n64_periphs::rdram_reg_r )
 {
-	//printf("rdram_reg_r %08x = %08x\n", offset * 4, rdram_regs[offset]);
+	//printf("rdram_reg_r %08x = %08x\n", offset * 4, rdram_regs[offset]); fflush(stdout);
 	if(offset > 0x24/4)
 	{
 		logerror("rdram_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
@@ -473,7 +476,7 @@
 
 WRITE32_MEMBER( n64_periphs::rdram_reg_w )
 {
-	//printf("rdram_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
+	//printf("rdram_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask); fflush(stdout);
 	if(offset > 0x24/4)
 	{
 		logerror("rdram_reg_w: %08X, %08X, %08X at %08X\n", data, offset, mem_mask, cpu_get_pc(maincpu));
@@ -493,7 +496,7 @@
         length = (length + 7) & ~7;
 	}
 
-	//printf("Length %08x Skip %08x Count %08x\n", length, sp_dma_skip, sp_dma_count);
+	//printf("Length %08x Skip %08x Count %08x\n", length, sp_dma_skip, sp_dma_count); fflush(stdout);
 	if (sp_mem_addr & 0x3)
 	{
         sp_mem_addr = sp_mem_addr & ~3;
@@ -608,12 +611,14 @@
 
 		case 0x1c/4:		// SP_SEMAPHORE_REG
 			//machine().scheduler().boost_interleave(attotime::from_usec(1), attotime::from_usec(1));
+			device_yield(machine().device("maincpu"));
             if( sp_semaphore )
             {
                 ret = 1;
             }
             else
             {
+				//printf("Semaphore is now acquired, returning 0\n");
                 sp_semaphore = 1;
                 ret = 0;
             }
@@ -671,7 +676,7 @@
             break;
 	}
 
-	//printf("%08x sp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, ret);
+	//printf("%08x sp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, ret); fflush(stdout);
 	return ret;
 }
 
@@ -682,7 +687,7 @@
 
 void n64_periphs::sp_reg_w(UINT32 offset, UINT32 data, UINT32 mem_mask)
 {
-	//printf("%08x sp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, data, mem_mask);
+	//printf("%08x sp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, data, mem_mask); fflush(stdout);
 
 	if ((offset & 0x10000) == 0)
 	{
@@ -720,108 +725,133 @@
                 {
 					device_set_input_line(rspcpu, INPUT_LINE_HALT, CLEAR_LINE);
 					newstatus &= ~RSP_STATUS_HALT;
+					//printf("***SP HALT CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00000002)      // set halt
                 {
                     device_set_input_line(rspcpu, INPUT_LINE_HALT, ASSERT_LINE);
                     newstatus |= RSP_STATUS_HALT;
+					//printf("***SP HALT SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00000004)
                 {
                     newstatus &= ~RSP_STATUS_BROKE;
+					//printf("***SP BROKE CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00000008)      // clear interrupt
                 {
+					//printf("***SP INT CLR***\n"); fflush(stdout);
                     clear_rcp_interrupt(SP_INTERRUPT);
                 }
                 if (data & 0x00000010)      // set interrupt
                 {
+					//printf("***SP INT SET***\n"); fflush(stdout);
                     signal_rcp_interrupt(SP_INTERRUPT);
                 }
                 if (data & 0x00000020)
                 {
                     newstatus &= ~RSP_STATUS_SSTEP;
+					//printf("***SP SSTEP CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00000040)
                 {
                     newstatus |= RSP_STATUS_SSTEP;	// set single step
+					//printf("***SP SSTEP SET***\n"); fflush(stdout);
                     if(!(oldstatus & (RSP_STATUS_BROKE | RSP_STATUS_HALT)))
                     {
                         cpu_set_reg(rspcpu, RSP_STEPCNT, 1 );
-                        device_yield(machine().device("maincpu"));
+                        device_yield(machine().device("rsp"));
                     }
                 }
                 if (data & 0x00000080)
                 {
                     newstatus &= ~RSP_STATUS_INTR_BREAK;	// clear interrupt on break
+					//printf("***SP INTRBRK CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00000100)
                 {
                     newstatus |= RSP_STATUS_INTR_BREAK;		// set interrupt on break
+					//printf("***SP INTRBRK SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00000200)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL0;		// clear signal 0
+					//printf("***SP YIELD CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00000400)
                 {
                     newstatus |= RSP_STATUS_SIGNAL0;		// set signal 0
+					//printf("***SP YIELD SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00000800)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL1;		// clear signal 1
+					//printf("***SP YIELDED CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00001000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL1;		// set signal 1
+					//printf("***SP YIELDED SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00002000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL2 ;		// clear signal 2
+					//printf("***SP TASKDONE CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00004000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL2;		// set signal 2
+					//printf("***SP TASKDONE SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00008000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL3;		// clear signal 3
+					//printf("***SP SIG3 CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00010000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL3;		// set signal 3
+					//printf("***SP SIG3 SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00020000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL4;		// clear signal 4
+					//printf("***SP SIG4 CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00040000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL4;		// set signal 4
+					//printf("***SP SIG4 SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00080000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL5;		// clear signal 5
+					//printf("***SP SIG5 CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00100000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL5;		// set signal 5
+					//printf("***SP SIG5 SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00200000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL6;		// clear signal 6
+					//printf("***SP SIG6 CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x00400000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL6;		// set signal 6
+					//printf("***SP SIG6 SET***\n"); fflush(stdout);
                 }
                 if (data & 0x00800000)
                 {
                     newstatus &= ~RSP_STATUS_SIGNAL7;		// clear signal 7
+					//printf("***SP SIG7 CLR***\n"); fflush(stdout);
                 }
                 if (data & 0x01000000)
                 {
                     newstatus |= RSP_STATUS_SIGNAL7;		// set signal 7
+					//printf("***SP SIG7 SET***\n"); fflush(stdout);
                 }
                 cpu_set_reg(rspcpu, RSP_SR, newstatus);
                 break;
@@ -829,6 +859,7 @@
 
 			case 0x1c/4:		// SP_SEMAPHORE_REG
 				//machine().scheduler().boost_interleave(attotime::from_usec(1), attotime::from_usec(1));
+				//printf("Semaphore is being released\n");
 				if(data == 0)
 				{
                 	sp_semaphore = 0;
@@ -912,7 +943,7 @@
 			break;
 	}
 
-	//printf("%08x dp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, ret);
+	//printf("%08x dp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, ret); fflush(stdout);
 	return ret;
 }
 
@@ -921,7 +952,7 @@
 	n64_state *state = device->machine().driver_data<n64_state>();
 	n64_periphs *periphs = device->machine().device<n64_periphs>("rcp");
 
-	//printf("%08x dp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, data, mem_mask);
+	//printf("%08x dp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, data, mem_mask); fflush(stdout);
 	switch (offset)
 	{
 		case 0x00/4:		// DP_START_REG
@@ -1268,7 +1299,7 @@
     ai_status |= 0x40000000;
 
    // adjust the timer
-   period = attotime::from_hz(DACRATE_NTSC) * ((ai_dacrate + 1) * (current->length / 4));
+   period = attotime::from_hz(DACRATE_NTSC) * ((ai_dacrate + 1) * (current->length / 8));
    ai_timer->adjust(period);
 }
 
@@ -1307,8 +1338,8 @@
             else if (ai_status & 0x40000000)
             {
                 double secs_left = (ai_timer->expire() - machine().time()).as_double();
-                unsigned int samples_left = secs_left * DACRATE_NTSC / (ai_dacrate + 1);
-                ret = samples_left * 4;
+                unsigned int samples_left = (UINT32)(secs_left * (double)DACRATE_NTSC / (double)(ai_dacrate + 1));
+                ret = samples_left * 8;
             }
             else
             {
@@ -1336,7 +1367,7 @@
     switch (offset)
     {
         case 0x00/4:        // AI_DRAM_ADDR_REG
-            ai_dram_addr = data & 0xffffff;
+            ai_dram_addr = data & 0xfffff8;
             break;
 
         case 0x04/4:        // AI_LEN_REG
@@ -1375,6 +1406,7 @@
 static TIMER_CALLBACK(pi_dma_callback)
 {
 	machine.device<n64_periphs>("rcp")->pi_dma_tick();
+	device_yield(machine.device("rsp"));
 }
 
 void n64_periphs::pi_dma_tick()
@@ -1400,7 +1432,7 @@
     	cart_addr &= ((machine().region("user2")->bytes() >> 1) - 1);
 	}
 
-	//printf("%08x Cart, %08x Dram\n", cart_addr << 1, dram_addr << 1);
+	//printf("%08x Cart, %08x Dram\n", cart_addr << 1, dram_addr << 1); fflush(stdout);
 
 	if(pi_dma_dir == 1)
 	{
@@ -1420,14 +1452,6 @@
 			pi_cart_addr += dma_length;
 			pi_dram_addr += dma_length;
 		}
-
-		if (pi_first_dma)
-		{
-			// TODO: CIC-6105 has different address...
-			mem_map->write_dword(0x00000318, 0x400000);
-			mem_map->write_dword(0x000003f0, 0x800000);
-			pi_first_dma = 0;
-		}
 	}
 	else
 	{
@@ -1517,7 +1541,7 @@
 
 WRITE32_MEMBER( n64_periphs::pi_reg_w )
 {
-	//printf("pi_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
+	//printf("pi_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask); fflush(stdout);
 	switch (offset)
 	{
 		case 0x00/4:		// PI_DRAM_ADDR_REG
@@ -1538,7 +1562,7 @@
 			pi_dma_dir = 0;
 			pi_status |= 1;
 
-			attotime dma_period = attotime::from_hz(93750000) * (pi_rd_len + 1) * 3;
+			attotime dma_period = attotime::from_hz(93750000) * (int)((float)(pi_rd_len + 1) * 5.08f); // Measured as between 2.53 cycles per byte and 2.55 cycles per byte
 			//printf("want read dma in %d\n", (pi_rd_len + 1));
 			pi_dma_timer->adjust(dma_period);
 			//pi_dma_tick();
@@ -1551,9 +1575,18 @@
 			pi_dma_dir = 1;
 			pi_status |= 1;
 
-			attotime dma_period = attotime::from_hz(93750000) * (pi_wr_len + 1) * 3;
+			attotime dma_period = attotime::from_hz(93750000) * (int)((float)(pi_wr_len + 1) * 5.08f); // Measured as between 2.53 cycles per byte and 2.55 cycles per byte
 			//printf("want write dma in %d\n", (pi_wr_len + 1));
 			pi_dma_timer->adjust(dma_period);
+
+			if (pi_first_dma)
+			{
+				// TODO: CIC-6105 has different address...
+				mem_map->write_dword(0x00000318, 0x800000);
+				mem_map->write_dword(0x000003f0, 0x800000);
+				pi_first_dma = 0;
+			}
+
 			//pi_dma_tick();
 			break;
 		}
@@ -1682,7 +1715,16 @@
 	switch (command)
 	{
 		case 0x00:		// Read status
+		case 0xff:		// Reset
 		{
+			if(command == 0)
+			{
+				//printf("Read status\n");
+			}
+			else
+			{
+				//printf("Reset\n");
+			}
 			switch (channel)
 			{
 				case 0:
@@ -1705,10 +1747,10 @@
 				{
 					//printf("Read EEPROM status\n");
 					rdata[0] = 0x00;
-					rdata[1] = 0xc0;
+					rdata[1] = 0x80;
 					rdata[2] = 0x00;
 
-					return 1;
+					return 0;
 				}
 				case 5:
 				{
@@ -1767,7 +1809,7 @@
 			address = (sdata[1] << 8) | (sdata[2]);
 			address &= ~0x1f;
 
-			//printf("Read mempak at %04x\n", address);
+			////printf("Read mempak at %04x\n", address);
 
 			if(address == 0x8000)
 			{
@@ -1797,7 +1839,7 @@
 			UINT32 address = (sdata[1] << 8) | (sdata[2]);
 			address &= ~0x1f;
 
-			//printf("Write mempak at %04x\n", address);
+			////printf("Write mempak at %04x\n", address);
 			if (address >= 0x8000)
 			{
 
@@ -1904,15 +1946,6 @@
 			return 1;
 		}
 
-		case 0xff:		// reset
-		{
-			//printf("Reset\n");
-			rdata[0] = 0xff;
-			rdata[1] = 0xff;
-			rdata[2] = 0xff;
-			return 0;
-		}
-
 		default:
 		{
 			mame_printf_debug("handle_pif: unknown/unimplemented command %02X\n", command);
@@ -1925,13 +1958,13 @@
 
 void n64_periphs::handle_pif()
 {
-	//printf("Before:\n");
-	/*for(int i = 0; i < 0x40; i++)
+	/*printf("Before:\n"); fflush(stdout);
+    for(int i = 0; i < 0x40; i++)
     {
         printf("%02x ", pif_cmd[i]);
         if((i & 0xf) == 0xf)
         {
-            printf("\n");
+            printf("\n"); fflush(stdout);
         }
     }*/
 	if(pif_cmd[0x3f] == 0x1)		// only handle the command if the last byte is 1
@@ -2004,13 +2037,13 @@
 		pif_ram[0x3f] = 0;
 	}
 
-	/*printf("After:\n");
+	/*printf("After:\n"); fflush(stdout);
     for(int i = 0; i < 0x40; i++)
     {
-        printf("%02x ", pif_ram[i]);
+        printf("%02x ", pif_ram[i]); fflush(stdout);
         if((i & 0xf) == 0xf)
         {
-            printf("\n");
+            printf("\n"); fflush(stdout);
         }
     }*/
 }
@@ -2073,13 +2106,13 @@
 			ret = si_status;
 	}
 
-	//printf("si_reg_r %08x = %08x\n", offset * 4, ret);
+	//printf("si_reg_r %08x = %08x\n", offset * 4, ret); fflush(stdout);
 	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::si_reg_w )
 {
-	//printf("si_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
+	//printf("si_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask); fflush(stdout);
 	switch (offset)
 	{
 		case 0x00/4:		// SI_DRAM_ADDR_REG
diff -Nru src-old/mame/mame.lst src/mame/mame.lst
--- src-old/mame/mame.lst	2012-02-19 02:23:50.000000000 +0100
+++ src/mame/mame.lst	2012-02-26 15:05:46.000000000 +0100
@@ -2865,6 +2865,7 @@
 sf2ceub			// 13/05/1992 (c) 1992 (USA)
 sf2ceuc			// 03/08/1992 (c) 1992 (USA)
 sf2cej			// 13/05/1992 (c) 1992 (Japan)
+sf2ceja			// 22/03/1992 (c) 1992 (Japan)
 sf2rb			// hack
 sf2rb2			// hack
 sf2rb3			// hack
@@ -3161,7 +3162,8 @@
 progearj		// 17/01/2001 (c) 2001 Cave (Japan)
 progeara		// 17/01/2001 (c) 2001 Cave (Asia)
 pzloop2			// 02/03/2001 (c) 2001 Mitchell (Euro)
-pzloop2j		// 05/02/2001 (c) 2001 Mitchell (Japan)
+pzloop2j		// 26/02/2001 (c) 2001 Mitchell (Japan)
+pzloop2jr1		// 05/02/2001 (c) 2001 Mitchell (Japan)
 choko			// 20/08/2001 (c) 2001 Mitchell (Japan)
 hsf2			// 02/02/2004 (c) 2003, 2004 (USA)
 hsf2j			// 22/12/2003 (c) 2003, 2004 (Japan)
@@ -3496,6 +3498,7 @@
 gamshara		// 2002.08 Gamshara (10021 Ver.A)
 chocovdr		// 2002.10 Uchuu Daisakusen : Chocovader Contactee
 				// 2002.12 Taiko no Tatsujin 4
+nflclsfb		// 2003.?? NFL Classic Football
 				// 2003.04 Seisyun Quiz Colorful High School
 				// 2003.10 Taiko no Tatsujin 5
 				// 2004.07 Taiko no Tatsujin 6
@@ -4124,11 +4127,11 @@
 aliensynj		// (c) 1987 (FD1089A, decrypted)
 altbeast		// (c) 1988 (8751)
 altbeastj		// (c) 1988 (8751)
-altbeast5		// (c) 1988 (8751)
+altbeast6		// (c) 1988 (8751)
+altbeast5		// (c) 1988 (FD1094, decrypted)
 altbeast4		// (c) 1988 (MC-8123B)
 altbeast2		// (c) 1988 (MC-8123B)
 altbeastj1		// (c) 1988 (protected)
-altbeastj2		// (c) 1988 (protected)
 altbeastj3		// (c) 1988 (FD1094, decrypted)
 aurail			// (c) 1990 Sega / Westone
 aurail1			// (c) 1990 Sega / Westone (FD1089B, decrypted)
@@ -4525,7 +4528,7 @@
 vf2			// 1995.09 Virtua Fighter 2.1
 skytargt		// 1995.10 Sky Target
 manxtt			// 1995.11 Manx T.T.
-doaa			// 1996.11 Dead or Alive (Model 2A)
+doaa			// 1996.11 Dead or Alive
 motoraid		// 1997.10 Motor Raid
 zeroguna		// 1997.12 Zero Gunner
 zerogunaj		// 1997.12 Zero Gunner (Japan)
@@ -6658,6 +6661,8 @@
 maxf_ng			//     ??           (c) 1996
 vcircle			// (proto)          (c) 1996
 a51site4		//     ??           (c) 1998
+a51site4a		// Sept.11,1998     (c) 1998
+
 
 // SNK / Rock-ola games
 sasuke			// [1980] Shin Nihon Kikaku (SNK)
@@ -7368,6 +7373,7 @@
 mkla3			// (c) 1992 Midway
 mkla4			// (c) 1992 Midway
 mkyawdim		// bootleg
+mkyawdim2		// bootleg
 term2			// (c) 1992 Midway
 term2la3		// (c) 1992 Midway
 term2la2		// (c) 1992 Midway
@@ -9821,9 +9827,9 @@
 j6bmc		// Big Money Club (Crystal)
 j6bno		// Big Nite Out (Crystal)
 j6btbw		// Born To Be Wild Club (Crystal)
-j6cpal		// Caesar's Palace (Crystal)
-j6cpala		// Caesar's Palace (Crystal)
-j6cpalb		// Caesar's Palace (Ace)
+j6cpal		// Caesars Palace (Crystal)
+j6cpala		// Caesars Palace (Crystal)
+j6cpalb		// Caesars Palace (Ace)
 j6cdivr		// Cash Diver (Crystal)
 j6ccc		// Casino Crazy Club (Crystal)
 j6colic		// Coliseum (Crystal)
@@ -9834,7 +9840,7 @@
 j6grc		// Gold Rush Club (Crystal)
 j6hdc		// Hot Dogs Club (Crystal)
 j6impls		// Impulse (Crystal)
-j6kapang	// Kapang (Crystal)
+j6kapang	// Kapang! (Crystal)
 j6kfc		// Kung Fu Club (Crystal)
 j6lucklo	// Lucky Lottery Club (Crystal)
 j6monst		// Monster Cash Club (Crystal)
@@ -10072,6 +10078,7 @@
 rapidfira		// (c) 1998 Hanaho Games
 rapidfire		// (c) 1998 Hanaho Games
 maletmad		// (c) 1999 Hanaho Games, licensed to Capcom
+potgoldu		// (c) 200? U.S. Games
 crgolf			// (c) 1984 Nasco Japan
 crgolfa			// (c) 1984 Nasco Japan
 crgolfb			// (c) 1984 Nasco Japan
@@ -16889,13 +16896,88 @@
 m1coro21v
 m1coro21vp
 m1cororr	// Coronation Street - Rovers Return (Maygay)
+m1cororrp
+m1cororra
+m1cororrb
+m1cororrbh
+m1cororrb1
+m1cororrbp
+m1cororrc
+m1cororrc1
+m1cororrc2
+m1cororrd
+m1cororrdp
+m1cororre
+m1cororrf
+m1cororrfp
+m1cororrg
+m1cororrgp
+m1cororrh
+m1cororri
+m1cororrip
+m1cororrj
+m1cororrjp
+m1cororrk
+m1cororrl
+m1cororrlp
 m1corocb	// Coronation Street Club (Maygay)
+m1corocbp
+m1corocb1
+m1corocb1p
 m1corosh	// Coronation Street Showcase (Maygay)
-m1criss		// Criss Cross Club (Maygay)
+m1coroshp
+m1criss		// Criss Cross Club (Maygay) (Dutch)
 m1dxmono	// Deluxe Monopoly (Maygay)
+m1dxmonop
+m1dxmono12n
+m1dxmono31b
+m1dxmono31p
+m1dxmono31h
+m1dxmono31h2
+m1dxmono51
+m1dxmono12
+m1dxmono12p
+m1dxmono12a
+m1dxmono21p
+m1dxmono11p
+m1dxmono11
+m1dxmono51o
+m1dxmono51p
+m1dxmono30h
+m1dxmono11o
+m1dxmono11m
+m1dxmono11mb
 m1dmnhrt	// Diamond Hearts (Maygay)
 m1dm4ev		// Diamonds Are Forever Club (Maygay)
+m1dm4evp
+m1dm4ev11
 m1dkong		// Donkey Kong (Maygay)
+m1dkongp
+m1dkonga
+m1dkong91n
+m1dkong91np
+m1dkong91na
+m1dkong81n
+m1dkong81na
+m1dkong81np
+m1dkong21n
+m1dkong91
+m1dkong91p
+m1dkong91a
+m1dkong91h1
+m1dkong91h2
+m1dkong81
+m1dkong81p
+m1dkong51
+m1dkong51p
+m1dkong41
+m1dkong41p
+m1dkong31
+m1dkong31p
+m1dkong21
+m1dkong21p
+m1dkong11
+m1dkong11p
 m1ee		// Eastenders (Bwb)
 m1eea		//
 m1eeb		//
@@ -16925,6 +17007,8 @@
 m1jbond		// James Bond (Maygay)
 m1jdwins	// Jim Davison's Winning Streak (Maygay)
 m1liveam	// Living In America (Maygay)
+m1liveamp
+m1liveama
 m1lotmil	// Lottery Millionaire Club (Maygay)
 m1luckno	// Lucky Numbers (Maygay)
 m1magic		// Magic Squares (Maygay)
@@ -17000,6 +17084,9 @@
 m1sirich	// Strike It Rich
 m1gskill	// Greek Skill
 m1luxor		// Luxor Casino
+m1luxor33
+m1luxor32
+m1luxor21
 m1atunk
 
 // Maygay MV1 hardware
@@ -18454,7 +18541,7 @@
 m5centcl	// Centurion Club (Empire)
 m5cworan	// Clockwork Oranges (Empire)
 m5clbtro	// Club Tropicana (Empire)
-m5cockdd	// Cock A Doodle Dough (Empire)
+m5cockdd	// Cock A Doodle Dough! (Empire)
 m5coloss	// Colossus Club (Empire)
 m5crocrk	// Crocodile Rock (Empire)
 m5croclb	// Crocodile Rock Club (Empire)
@@ -18466,7 +18553,7 @@
 m5fatcat	// Fat Cat (Empire)
 m5fishdl	// Fish Full Of Dollars (Empire)
 m5fishcl	// Fish Full Of Dollars Club (Empire)
-m5fmonty	// Full Monty (Empire)
+m5fmonty	// The Full Monty (Empire)
 m5fmount	// Full Mountie (Empire)
 m5gophr		// Gopher Gold (Empire)
 m5gophcl	// Gopher Gold Club (Empire)
@@ -20663,5 +20750,7 @@
 saiyukip
 
 tmspoker
-tonton
-kas89
+tonton			// 199?, Success.
+kas89			// 1989, SFC S.R.L.
+caspoker		// 1987, PM / Beck Elektronik.
+manohman		// 199?, Merkur.
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2012-02-11 17:05:10.000000000 +0100
+++ src/mame/mame.mak	2012-02-24 04:31:09.000000000 +0100
@@ -597,7 +597,7 @@
 	$(DRIVERS)/deco_ld.o \
 	$(DRIVERS)/deco_mlc.o $(VIDEO)/deco_mlc.o \
 	$(DRIVERS)/deco156.o $(MACHINE)/deco156.o \
-	$(DRIVERS)/deco32.o $(VIDEO)/deco32.o \
+	$(DRIVERS)/deco32.o $(VIDEO)/deco32.o $(VIDEO)/dvi.o \
     $(AUDIO)/decobsmt.o \
 	$(DRIVERS)/decocass.o $(MACHINE)/decocass.o $(VIDEO)/decocass.o \
 	$(DRIVERS)/deshoros.o \
@@ -1803,6 +1803,7 @@
 	$(DRIVERS)/polyplay.o $(AUDIO)/polyplay.o $(VIDEO)/polyplay.o \
 	$(DRIVERS)/poker72.o \
 	$(DRIVERS)/poo.o \
+	$(DRIVERS)/potgoldu.o \
 	$(DRIVERS)/proconn.o \
 	$(DRIVERS)/psattack.o \
 	$(DRIVERS)/quizo.o \
@@ -1872,6 +1873,7 @@
 	$(DRIVERS)/cupidon.o \
 	$(DRIVERS)/extrema.o \
 	$(DRIVERS)/tmspoker.o \
+	$(DRIVERS)/manohman.o \
 
 
 #-------------------------------------------------
diff -Nru src-old/mame/mame_dev.lst src/mame/mame_dev.lst
--- src-old/mame/mame_dev.lst	2011-09-19 11:15:29.000000000 +0200
+++ src/mame/mame_dev.lst	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/******************************************************************************
-
-    mame_dev.lst
-
-    List of all enabled devices in the system. This file is parsed by
-    makedev.exe, sorted, and output as C code describing the devices.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-BSMT2000
-H63484
-NAMCO_50XX
-NAMCO_51XX
-NAMCO_52XX
-NAMCO_53XX
-NAMCO_54XX
-NAMCO_62XX
-MIE
-PHILLIPS_22VP931
-PIONEER_LDV1000
-PIONEER_PR8210
-SIMUTREK_SPECIAL
diff -Nru src-old/mame/tiny_dev.lst src/mame/tiny_dev.lst
--- src-old/mame/tiny_dev.lst	2011-08-02 16:09:21.000000000 +0200
+++ src/mame/tiny_dev.lst	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/******************************************************************************
-
-    tiny_dev.lst
-
-    List of all enabled devices in the system. This file is parsed by
-    makedev.exe, sorted, and output as C code describing the devices.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
diff -Nru src-old/mame/video/cps1.c src/mame/video/cps1.c
--- src-old/mame/video/cps1.c	2012-01-27 08:45:25.000000000 +0100
+++ src/mame/video/cps1.c	2012-02-21 19:11:26.000000000 +0100
@@ -1354,6 +1354,7 @@
 	{"sf2ceub",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2ceuc",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2cej",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2ceja",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb2",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb3",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
diff -Nru src-old/mame/video/dvi.c src/mame/video/dvi.c
--- src-old/mame/video/dvi.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/video/dvi.c	2012-02-26 15:31:24.000000000 +0100
@@ -0,0 +1,386 @@
+#include "emu.h"
+
+// This just attempts to parse some of the header structures in the DVI data Dragon Gun uses...
+// see http://www.fileformat.info/format/dvi/egff.htm
+// I don't know if there are any software decoders for this format, I think it was a hardware solution?
+// The Dragon Gun data doesn't seem to have all fields filled in..
+//
+// Hopefully somebody who actually understands video (de)compression can actually flesh this out...
+
+
+//#define dviprintf printf
+#define dviprintf logerror
+
+
+struct DVI_Header
+{
+	UINT32 dv1;     // header ID (VDVI)
+	UINT16 dv2;     // header size (sometimes just 1)
+	UINT16 dv3;     // header version
+	UINT32 dv4;     // offset of annotation data
+};
+
+
+struct AVSS_Header
+{
+	UINT32 av1;       // header ID (AVSS)
+	UINT16 av2;		// header size
+	UINT16 av3;		// header version
+	UINT16 av4;       // number of stream groups
+	UINT16 av5;       // size of each stream group
+	UINT32 av6;       // offset to first stream group
+	UINT16 av7;       // format of stream groups
+	UINT16 av8;       // size of stream header
+	UINT16 av9;       // format of stream header
+	UINT16 av10;      // number of stream headers
+	UINT32 av11;      // offset to stream structures array
+	UINT32 av12;      // offset to substream headers array
+	UINT32 av13;      // number of labels
+	UINT32 av14;      // offset to first label
+	UINT16 av15;      // label size
+	UINT16 av16;      // label format
+	UINT32 av17;      // offset to video sequence header
+	UINT16 av18;      // size of video sequence header
+	UINT16 av19;      // version of frame headers
+	UINT32 av20;      // number of frame headers
+	UINT32 av21;      // size of frame headers
+	UINT32 av22;      // offset to first frame
+	UINT32 av23;      // offset of last frame
+	UINT16 av24;      // size of frame header
+	UINT16 av25;      // size of frame dictionary
+	UINT32 av26;      // offset of frame dictionary
+	UINT16 av27;      // format of frame dictionary
+	UINT16 av28;      // framerate
+	UINT32 av29;      // streaming data?
+	UINT32 av30;      // unused
+	UINT8  av31[32];  // unused
+};
+
+struct STRM_Header
+{
+	UINT32 st1;       // header ID (STRM)
+	UINT16 st2;       // header size
+	UINT16 st3;       // stream type
+	UINT16 st4;       // stream subtype
+	UINT16 st5;       // number of substream headers
+	UINT16 st6;       // next stream ID
+	UINT16 st7;       // group IP
+	UINT16 st8;       // unused (Pad)
+	UINT16 st9;       // frame size flag..
+	UINT32 st10;      // max data per frame
+	UINT32 st11;      // offset to first substream header
+	UINT8  st12[16];  // name
+};
+
+#if 0
+struct AUDI_Header
+{
+	UINT32 au1;      // header iID (AUDI)
+	UINT16 au2;      // header size
+	UINT16 au3;      // header format
+	UINT8  au4[80];  // original media filename
+	UINT32 au5;      // original media frame ID
+	UINT16 au6;	   // original media frame ID
+	UINT16 au7;      // unused (Pad)
+	UINT32 au8;      // number of frames
+	UINT32 au9;      // offset of next header
+	UINT8  au10[16]; // library stream name
+	UINT8  au11[16]; // compression algorithm name
+	UINT32 au12;     // sample freq
+	UINT16 au13;     // filter cutoff
+	UINT16 au14;     // unused
+	UINT16 au15;     // left volume
+	UINT16 au16;     // right volume
+	UINT32 au17;     // unused
+	UINT32 au18;     // first frame ID
+	UINT32 au19;     // mono / stereo
+	UINT16 au20;     // playback rate
+	UINT16 au21;     // unused (Pad)
+	UINT32 au22;     // Digital Compression ID
+};
+#endif
+
+struct CIMG_Header
+{
+	UINT32 ci1;     // header ID (CIMG)
+	UINT16 ci2;     // header size
+	UINT16 ci3;     // header format
+	UINT8  ci4[80]; // source media filename
+	UINT32 ci5;     // source media frame ID
+	UINT16 ci6;     // source media stream ID
+	UINT16 ci7;     // Unused (Pad value)
+	UINT32 ci8;     // Frames before next header
+	UINT32 ci9;     // Next Header Pos
+	UINT16 ci10;    // X Pos
+	UINT16 ci11;    // Y Pos
+	UINT16 ci12;    // Width
+	UINT16 ci13;    // Height
+	UINT16 ci14;    // X Crop
+	UINT16 ci15;    // Y Crop
+	UINT16 ci16;    // Unused
+	UINT16 ci17;    // Unused
+	UINT32 ci18;    // Interframe Frequency
+	UINT16 ci19;    // Min Buffer Size
+	UINT16 ci20;    // Max Buffer Size
+	UINT16 ci21;    // Decompression ID
+	UINT16 ci22;    // Unused (Pad Value)
+	UINT32 ci23;    // Digitial Compression ID
+};
+
+struct FHEAD_Header
+{
+	UINT32 fh1;              // frame number
+	UINT32 fh2;              // offset of previous frame
+	UINT32 fh3;              // checksum
+	//UINT32 framesizearray? // just the frame data?
+};
+
+struct FDICT_Header
+{
+	UINT32 fd1;	// offset of frame header
+};
+
+static UINT32 R32(UINT8 **currptr)
+{
+	UINT32 ret = 0;
+	ret |= *(*currptr)++; ret <<=8;
+	ret |= *(*currptr)++; ret <<=8;
+	ret |= *(*currptr)++; ret <<=8;
+	ret |= *(*currptr)++;
+
+	return ret;
+}
+
+static UINT16 R16(UINT8 **currptr)
+{
+	UINT16 ret = 0;
+	ret |= *(*currptr)++; ret <<=8;
+	ret |= *(*currptr)++;
+
+	return ret;
+}
+
+static UINT8 R8(UINT8 **currptr)
+{
+	UINT8 ret = 0;
+	ret |= *(*currptr)++;
+	return ret;
+}
+
+void process_dvi_data(UINT8* dvi_data, int baseoffset, int regionsize)
+{
+	DVI_Header DVI;
+
+	UINT8* currptr = dvi_data + baseoffset;
+
+	DVI.dv1 = R32(&currptr);
+	DVI.dv2 = R16(&currptr);
+	DVI.dv3 = R16(&currptr);
+	DVI.dv4 = R32(&currptr);
+
+	dviprintf("DVI Header\n");
+	dviprintf("Header ID          %08x %c%c%c%c\n", DVI.dv1, (DVI.dv1>>24)&0xff,  (DVI.dv1>>16)&0xff,  (DVI.dv1>>8)&0xff,  (DVI.dv1>>0)&0xff);
+	dviprintf("Header Size (or 1) %04x\n", DVI.dv2);
+	dviprintf("Header Version     %04x\n", DVI.dv3);
+	dviprintf("Annotation Offset  %08x\n", DVI.dv4);
+	if (DVI.dv1 != 0x56445649) { dviprintf("Header Error\n"); return; }
+	dviprintf("\n");
+
+	AVSS_Header AVSS;
+
+	AVSS.av1 = R32(&currptr);
+	AVSS.av2 = R16(&currptr);
+	AVSS.av3 = R16(&currptr);
+	AVSS.av4 = R16(&currptr);
+	AVSS.av5 = R16(&currptr);
+	AVSS.av6 = R32(&currptr);
+	AVSS.av7 = R16(&currptr);
+	AVSS.av8 = R16(&currptr);
+	AVSS.av9 = R16(&currptr);
+	AVSS.av10 = R16(&currptr);
+	AVSS.av11 = R32(&currptr);
+	AVSS.av12 = R32(&currptr);
+	AVSS.av13 = R32(&currptr);
+	AVSS.av14 = R32(&currptr);
+	AVSS.av15 = R16(&currptr);
+	AVSS.av16 = R16(&currptr);
+	AVSS.av17 = R32(&currptr);
+	AVSS.av18 = R16(&currptr);
+	AVSS.av19 = R16(&currptr);
+	AVSS.av20 = R32(&currptr);
+	AVSS.av21 = R32(&currptr);
+	AVSS.av22 = R32(&currptr);
+	AVSS.av23 = R32(&currptr);
+	AVSS.av24 = R16(&currptr);
+	AVSS.av25 = R16(&currptr);
+	AVSS.av26 = R32(&currptr);
+	AVSS.av27 = R16(&currptr);
+	AVSS.av28 = R16(&currptr);
+	AVSS.av29 = R32(&currptr);
+	AVSS.av30 = R32(&currptr);
+	for (int i=0;i<32;i++) { AVSS.av31[i] = R8(&currptr); }
+
+	dviprintf("	AVSS Header\n");
+	dviprintf("	Header ID          %08x %c%c%c%c\n", AVSS.av1, (AVSS.av1>>24)&0xff,  (AVSS.av1>>16)&0xff,  (AVSS.av1>>8)&0xff,  (AVSS.av1>>0)&0xff);
+	dviprintf("	Header Size        %04x\n", AVSS.av2);
+	dviprintf("	Header Version     %04x\n", AVSS.av3);
+	dviprintf("	Stream Group Count %04x\n", AVSS.av4);
+	dviprintf("	Stream Group Size  %04x\n", AVSS.av5);
+	dviprintf("	Stream Group Offs  %08x\n", AVSS.av6);
+	dviprintf("	Stream Group Vers  %04x\n", AVSS.av7);
+	dviprintf("	Stream Size        %04x\n", AVSS.av8);
+	dviprintf("	Stream Version     %04x\n", AVSS.av9);
+	dviprintf("	Stream Count       %04x\n", AVSS.av10);
+	dviprintf("	Stream Offset      %08x\n", AVSS.av11);
+	dviprintf("	Header Pool Offset %08x\n", AVSS.av12);
+	dviprintf("	Label Count        %08x\n", AVSS.av13);
+	dviprintf("	Label Offset       %08x\n", AVSS.av14);
+	dviprintf("	Label Size         %04x\n", AVSS.av15);
+	dviprintf("	Label Version      %04x\n", AVSS.av16);
+	dviprintf("	Vid Seq Hdr Offset %08x\n", AVSS.av17);
+	dviprintf("	Vid Seq Hdr Size   %04x\n", AVSS.av18);
+	dviprintf("	Frame Version      %04x\n", AVSS.av19);
+	dviprintf("	Frame Count        %08x\n", AVSS.av20);
+	dviprintf("	Frame Size         %08x\n", AVSS.av21);
+	dviprintf("	First Frame Offset %08x\n", AVSS.av22);
+	dviprintf("	EO Frame Offset    %08x\n", AVSS.av23);
+	dviprintf("	Frame Header Size  %04x\n", AVSS.av24);
+	dviprintf("	Frame Dir Size     %04x\n", AVSS.av25);
+	dviprintf("	Frame Dir Offset   %08x\n", AVSS.av26);
+	dviprintf("	Frame Dir Vers     %04x\n", AVSS.av27);
+	dviprintf("	Frame PerSec       %04x\n", AVSS.av28);
+	dviprintf("	UpdateFlag         %08x\n", AVSS.av29);
+	dviprintf("	FreeBlock          %08x\n", AVSS.av30);
+	dviprintf("	Patch              ");	for (int i=0;i<32;i++) { dviprintf("%02x", AVSS.av31[i]); }; dviprintf("\n");
+	dviprintf("\n");
+
+	for (int s=0;s<AVSS.av10;s++)
+	{
+		STRM_Header STRM;
+
+		STRM.st1 = R32(&currptr);
+		STRM.st2 = R16(&currptr);
+		STRM.st3 = R16(&currptr);
+		STRM.st4 = R16(&currptr);
+		STRM.st5 = R16(&currptr);
+		STRM.st6 = R16(&currptr);
+		STRM.st7 = R16(&currptr);
+		STRM.st8 = R16(&currptr);
+		STRM.st9 = R16(&currptr);
+		STRM.st10 = R32(&currptr);
+		STRM.st11 = R32(&currptr);
+		for (int i=0;i<16;i++) { STRM.st12[i] = R8(&currptr); }
+
+		dviprintf("		STRM Header\n");
+		dviprintf("		Header ID          %08x %c%c%c%c\n", STRM.st1, (STRM.st1>>24)&0xff,  (STRM.st1>>16)&0xff,  (STRM.st1>>8)&0xff,  (STRM.st1>>0)&0xff);
+		dviprintf("		Header Size        %04x\n", STRM.st2);
+		dviprintf("		Type               %04x\n", STRM.st3);
+		dviprintf("		SubType            %04x\n", STRM.st4);
+		dviprintf("		Header Count       %04x\n", STRM.st5);
+		dviprintf("		Next Stream Number %04x\n", STRM.st6);
+		dviprintf("		Stream Group Numbr %04x\n", STRM.st7);
+		dviprintf("		Padding            %04x\n", STRM.st8);
+		dviprintf("		Flag               %04x\n", STRM.st9);
+		dviprintf("		FrameSize          %08x\n", STRM.st10);
+		dviprintf("		FirstHeaderOffset  %08x\n", STRM.st11);
+		dviprintf("		Name               ");	for (int i=0;i<16;i++) { dviprintf("%02x", STRM.st12[i]); }; dviprintf("\n");
+		dviprintf("\n");
+
+		UINT8* subptr = dvi_data+STRM.st11+baseoffset;
+
+		for (int h=0;h<STRM.st5;h++)
+		{
+			// I believe in these can be either CIMG or AUDI blocks, but we don't have any of the latter
+			CIMG_Header CIMG;
+
+
+			CIMG.ci1 = R32(&subptr);
+    		CIMG.ci2 = R16(&subptr);
+			CIMG.ci3 = R16(&subptr);
+			for (int i=0;i<80;i++) { CIMG.ci4[i] = R8(&subptr); }
+			CIMG.ci5 = R32(&subptr);
+			CIMG.ci6 = R16(&subptr);
+			CIMG.ci7 = R16(&subptr);
+			CIMG.ci8 = R32(&subptr);
+			CIMG.ci9 = R32(&subptr);
+			CIMG.ci10 = R16(&subptr);
+			CIMG.ci11 = R16(&subptr);
+			CIMG.ci12 = R16(&subptr);
+			CIMG.ci13 = R16(&subptr);
+			CIMG.ci14 = R16(&subptr);
+			CIMG.ci15 = R16(&subptr);
+			CIMG.ci16 = R16(&subptr);
+			CIMG.ci17 = R16(&subptr);
+			CIMG.ci18 = R32(&subptr);
+			CIMG.ci19 = R16(&subptr);
+			CIMG.ci20 = R16(&subptr);
+			CIMG.ci21 = R16(&subptr);
+			CIMG.ci22 = R16(&subptr);
+			CIMG.ci23 = R32(&subptr);
+
+			dviprintf("			CIMG Header\n");
+			dviprintf("			Header ID          %08x %c%c%c%c\n", CIMG.ci1, (CIMG.ci1>>24)&0xff,  (CIMG.ci1>>16)&0xff,  (CIMG.ci1>>8)&0xff,  (CIMG.ci1>>0)&0xff);
+			dviprintf("			Header Size        %04x\n", CIMG.ci2);
+			dviprintf("			Version            %04x\n", CIMG.ci3);
+			dviprintf("			Original Name      ");	for (int i=0;i<80;i++) { dviprintf("%02x", CIMG.ci4[i]); }; dviprintf("\n");
+			dviprintf("			Original Frame     %08x\n", CIMG.ci5);
+			dviprintf("			Original Stream    %04x\n", CIMG.ci6);
+			dviprintf("			Padding            %04x\n", CIMG.ci7);
+			dviprintf("			Frame Count        %08x\n", CIMG.ci8);
+			dviprintf("			Next Header Offset %08x\n", CIMG.ci9);
+			dviprintf("			X Position         %04x\n", CIMG.ci10);
+			dviprintf("			Y Position         %04x\n", CIMG.ci11);
+			dviprintf("			X Length           %04x\n", CIMG.ci12);
+			dviprintf("			Y Length           %04x\n", CIMG.ci13);
+			dviprintf("			X Crop             %04x\n", CIMG.ci14);
+			dviprintf("			Y Crop             %04x\n", CIMG.ci15);
+			dviprintf("			Drop Frame         %04x\n", CIMG.ci16);
+			dviprintf("			Drop Phrase        %04x\n", CIMG.ci17);
+			dviprintf("			Still Period       %08x\n", CIMG.ci18);
+			dviprintf("			Buffer Minimum     %04x\n", CIMG.ci19);
+			dviprintf("			Buffer Maximum     %04x\n", CIMG.ci20);
+			dviprintf("			Decode Algorithm   %04x\n", CIMG.ci21);
+			dviprintf("			Padding(2)         %04x\n", CIMG.ci22);
+			dviprintf("			DCFID              %08x\n", CIMG.ci23);
+			dviprintf("\n");
+
+			subptr = dvi_data+CIMG.ci9+baseoffset;
+		}
+
+	}
+
+	/* Frame Dictionaries etc. */
+	/* is this just a seek table of sorts? the first doesn't have an entry (pointed to by First Frame Offset - AVSS.av22) the first two here are actually bad values, and the last one points to nothing */
+	/* some entries also seem to point to the wrong places?? I'm guessing this isn't used when playing back the data ... it seems like the upper and lower words are out of sync... */
+	dviprintf("Frame Dictionaries\n\n");
+
+	UINT8* frameptr = dvi_data + AVSS.av26 + 2 + baseoffset; // +2 ??
+//  UINT8* frameptr = dvi_data + AVSS.av26 + baseoffset;
+
+	for (int f=0;f<AVSS.av20;f++)
+	{
+		FDICT_Header FDICT;
+		FDICT.fd1 = R32(&frameptr);
+
+		FDICT.fd1 = ((FDICT.fd1 & 0xffff0000)>>16) |  ((FDICT.fd1 & 0x0000ffff)<<16);
+
+		dviprintf("	%04d Frame Offset %08x\n", f, FDICT.fd1);
+
+			UINT8* frameptr2 = dvi_data + ((FDICT.fd1 + baseoffset)&(regionsize-1)) ;
+		FHEAD_Header FHEAD;
+		FHEAD.fh1 = R32(&frameptr2);
+		FHEAD.fh2 = R32(&frameptr2);
+		FHEAD.fh3 = R32(&frameptr2);
+
+		dviprintf("		Frame Num         %08x\n", FHEAD.fh1);
+		dviprintf("		Previous Offset   %08x\n", FHEAD.fh2);
+		dviprintf("		Frame Checksum    %08x\n", FHEAD.fh3);
+
+
+	}
+
+	dviprintf("\n");
+
+
+
+}
diff -Nru src-old/mame/video/gticlub.c src/mame/video/gticlub.c
--- src-old/mame/video/gticlub.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/gticlub.c	2012-02-26 15:31:24.000000000 +0100
@@ -6,16 +6,44 @@
 #include "video/konicdev.h"
 #include "video/gticlub.h"
 
+/*
+    TODO:
+        - Fog equation and parameters are probably not accurate.
+        - Winding Heat (and maybe others) have slight Z-fighting problems.
+        - 3D isn't always turned off properly (during title screens for example).
+          Figure out what controls this. Video mixer, layer priority or some 3D register?
+
+*/
+
+#define POLY_Z		0
+#define POLY_BRI	2
+#define POLY_FOG	1
+#define POLY_U		3
+#define POLY_V		4
+#define POLY_W		5
+
+#define ZBUFFER_MAX					10000000000.0f
+
+#define LOG_POLY_FIFO				0
+
+#if LOG_POLY_FIFO
+static int count = 0;
+#endif
 
 typedef struct _poly_extra_data poly_extra_data;
 struct _poly_extra_data
 {
 	UINT32 color;
 	int texture_x, texture_y;
+	int texture_width, texture_height;
 	int texture_page;
 	int texture_palette;
 	int texture_mirror_x;
 	int texture_mirror_y;
+	int light_r, light_g, light_b;
+	int ambient_r, ambient_g, ambient_b;
+	int fog_r, fog_g, fog_b;
+	UINT32 flags;
 };
 
 static UINT8 gticlub_led_reg[2];
@@ -120,7 +148,7 @@
 			}
 			default:
 			{
-				mame_printf_debug("K001006_w: chip %d, device %02X, write %04X to %08X\n", chip, K001006_device_sel[chip], data & 0xffff, K001006_addr[0]++);
+				//mame_printf_debug("K001006_w: chip %d, device %02X, write %04X to %08X\n", chip, K001006_device_sel[chip], data & 0xffff, K001006_addr[0]++);
 			}
 		}
 	}
@@ -181,16 +209,22 @@
 static UINT32 *K001005_3d_fifo;
 static int K001005_3d_fifo_ptr = 0;
 
-static int tex_mirror_table[4][128];
+static int *tex_mirror_table[2][8];
 
 static int K001005_bitmap_page = 0;
 
 static poly_manager *poly;
 static poly_vertex prev_v[4];
-static int prev_poly_type;
 
-static UINT8 *gfxrom;
+static UINT32 fog_r, fog_g, fog_b;
+static UINT32 ambient_r, ambient_g, ambient_b;
+static UINT32 light_r, light_g, light_b;
+
+static UINT32 reg_far_z;
+static float far_z;
+static float fog_density = 1.5f;
 
+static UINT8 *gfxrom;
 
 static void K001005_exit(running_machine &machine)
 {
@@ -199,7 +233,7 @@
 
 void K001005_init(running_machine &machine)
 {
-	int i;
+	int i,k;
 
 	int width = machine.primary_screen->width();
 	int height = machine.primary_screen->height();
@@ -219,15 +253,21 @@
 
 	K001005_3d_fifo = auto_alloc_array(machine, UINT32, 0x10000);
 
-	poly = poly_alloc(machine, 4000, sizeof(poly_extra_data), POLYFLAG_ALLOW_QUADS);
+	poly = poly_alloc(machine, 10000, sizeof(poly_extra_data), POLYFLAG_ALLOW_QUADS);
 	machine.add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(K001005_exit), &machine));
 
-	for (i=0; i < 128; i++)
+	for (k=0; k < 8; k++)
 	{
-		tex_mirror_table[0][i] = i & 0x3f;
-		tex_mirror_table[1][i] = i & 0x3f;
-		tex_mirror_table[2][i] = ((i & 0x3f) >= 0x20) ? (0x1f - (i & 0x1f)) : i & 0x1f;
-		tex_mirror_table[3][i] = ((i & 0x7f) >= 0x40) ? (0x3f - (i & 0x3f)) : i & 0x3f;
+		tex_mirror_table[0][k] = auto_alloc_array(machine, int, 128);
+		tex_mirror_table[1][k] = auto_alloc_array(machine, int, 128);
+
+		int size = (k+1)*8;
+
+		for (i=0; i < 128; i++)
+		{
+			tex_mirror_table[0][k][i] = i % size;
+			tex_mirror_table[1][k][i] = (i % (size*2)) >= size ? ((size - 1) - (i % size)) : i % size;
+		}
 	}
 
 	K001005_status = 0;
@@ -237,8 +277,7 @@
 	K001005_3d_fifo_ptr = 0;
 	K001005_bitmap_page = 0;
 
-	memset(prev_v, 0, sizeof(prev_v));
-	prev_poly_type = 0;
+	memset(prev_v, 0, sizeof(poly_vertex)*4);
 }
 
 // rearranges the texture data to a more practical order
@@ -386,8 +425,25 @@
 			K001005_fifo_write_ptr++;
 			K001005_fifo_write_ptr &= 0x7ff;
 
+			// process the current vertex data if a sync command is being sent (usually means the global registers are being changed)
+			if (data == 0x80000000)
+			{
+				render_polygons(space->machine());
+				K001005_3d_fifo_ptr = 0;
+			}
+
 			K001005_3d_fifo[K001005_3d_fifo_ptr++] = data;
 
+#if LOG_POLY_FIFO
+			printf("0x%08X, ", data);
+			count++;
+			if (count >= 8)
+			{
+				count = 0;
+				printf("\n");
+			}
+#endif
+
 			// !!! HACK to get past the FIFO B test (GTI Club & Thunder Hurricane) !!!
 			if (cpu_get_pc(&space->device()) == 0x201ee)
 			{
@@ -404,11 +460,47 @@
 			break;
 		}
 
-		case 0x100: break;
+		case 0x100:		break;
+
+		case 0x101:		break;		// viewport x and width?
+		case 0x102:		break;		// viewport y and height?
 
-	//  case 0x10a:     poly_r = data & 0xff; break;
-	//  case 0x10b:     poly_g = data & 0xff; break;
-	//  case 0x10c:     poly_b = data & 0xff; break;
+		case 0x104:		break;		// viewport center x? (usually 0xff)
+		case 0x105:		break;		// viewport center y? (usually 0xbf)
+
+		case 0x108:					// far Z value, 4 exponent bits?
+			{
+				// this register seems to hold the 4 missing exponent bits...
+				reg_far_z = (reg_far_z & 0x0000ffff) | ((data & 0xf) << 16);
+				UINT32 fz = reg_far_z << 11;
+				far_z = *(float*)&fz;
+				if (far_z == 0.0f)		// just in case...
+					far_z = 1.0f;
+				break;
+			}
+
+		case 0x109:					// far Z value
+			{
+				// the SHARC code throws away the bottom 11 bits of mantissa and the top 5 bits (to fit in a 16-bit register?)
+				reg_far_z = (reg_far_z & 0xffff0000) | (data & 0xffff);
+				UINT32 fz = reg_far_z << 11;
+				far_z = *(float*)&fz;
+				if (far_z == 0.0f)		// just in case...
+					far_z = 1.0f;
+				break;
+			}
+
+		case 0x10a:     light_r = data & 0xff; break;
+		case 0x10b:     light_g = data & 0xff; break;
+		case 0x10c:     light_b = data & 0xff; break;
+
+		case 0x10d:		ambient_r = data & 0xff; break;
+		case 0x10e:		ambient_g = data & 0xff; break;
+		case 0x10f:		ambient_b = data & 0xff; break;
+
+		case 0x110:		fog_r = data & 0xff; break;
+		case 0x111:		fog_g = data & 0xff; break;
+		case 0x112:		fog_b = data & 0xff; break;
 
 		case 0x11a:
 			K001005_status = data;
@@ -417,10 +509,17 @@
 
 			if (data == 2 && K001005_3d_fifo_ptr > 0)
 			{
-				K001005_swap_buffers(space->machine());
 				render_polygons(space->machine());
 				poly_wait(poly, "render_polygons");
+
+#if LOG_POLY_FIFO
+				count = 0;
+				printf("\nrender %d\n", K001005_3d_fifo_ptr);
+				printf("------------------------------------\n");
+#endif
+
 				K001005_3d_fifo_ptr = 0;
+				K001005_swap_buffers(space->machine());
 			}
 			break;
 
@@ -451,31 +550,130 @@
 
 }
 
+static void draw_scanline_2d(void *dest, INT32 scanline, const poly_extent *extent, const void *extradata, int threadid)
+{
+	const poly_extra_data *extra = (const poly_extra_data *)extradata;
+	bitmap_rgb32 *destmap = (bitmap_rgb32 *)dest;
+	UINT32 *fb = &destmap->pix32(scanline);
+	float *zb = (float*)&K001005_zbuffer->pix32(scanline);
+	UINT32 color = extra->color;
+	int x;
+
+	for (x = extent->startx; x < extent->stopx; x++)
+	{
+		if (color & 0xff000000)
+		{
+			fb[x] = color;
+			zb[x] = 0x7fffffff;		// FIXME
+		}
+	}
+}
+
+static void draw_scanline_2d_tex(void *dest, INT32 scanline, const poly_extent *extent, const void *extradata, int threadid)
+{
+	const poly_extra_data *extra = (const poly_extra_data *)extradata;
+	bitmap_rgb32 *destmap = (bitmap_rgb32 *)dest;
+	UINT8 *texrom = gfxrom + (extra->texture_page * 0x40000);
+	int pal_chip = (extra->texture_palette & 0x8) ? 1 : 0;
+	int palette_index = (extra->texture_palette & 0x7) * 256;
+	float u = extent->param[POLY_U].start;
+	float v = extent->param[POLY_V].start;
+	float du = extent->param[POLY_U].dpdx;
+	float dv = extent->param[POLY_V].dpdx;
+	UINT32 *fb = &destmap->pix32(scanline);
+	float *zb = (float*)&K001005_zbuffer->pix32(scanline);
+	UINT32 color = extra->color;
+	int texture_mirror_x = extra->texture_mirror_x;
+	int texture_mirror_y = extra->texture_mirror_y;
+	int texture_x = extra->texture_x;
+	int texture_y = extra->texture_y;
+	int texture_width = extra->texture_width;
+	int texture_height = extra->texture_height;
+	int x;
+
+	int *x_mirror_table = tex_mirror_table[texture_mirror_x][texture_width];
+	int *y_mirror_table = tex_mirror_table[texture_mirror_y][texture_height];
+
+	for (x = extent->startx; x < extent->stopx; x++)
+	{
+		int iu = (int)(u);
+		int iv = (int)(v);
+		int iiv, iiu, texel;
+
+		iiu = texture_x + x_mirror_table[(iu >> 4) & 0x7f];
+		iiv = texture_y + y_mirror_table[(iv >> 4) & 0x7f];
+
+		texel = texrom[((iiv & 0x1ff) * 512) + (iiu & 0x1ff)];
+		color = K001006_palette[pal_chip][palette_index + texel];
+
+		if (color & 0xff000000)
+		{
+			fb[x] = color;
+			zb[x] = 0x7fffffff;		// FIXME
+		}
+
+		u += du;
+		v += dv;
+	}
+}
+
 static void draw_scanline(void *dest, INT32 scanline, const poly_extent *extent, const void *extradata, int threadid)
 {
 	const poly_extra_data *extra = (const poly_extra_data *)extradata;
 	bitmap_rgb32 *destmap = (bitmap_rgb32 *)dest;
-	float z = extent->param[0].start;
-	float dz = extent->param[0].dpdx;
+	float z = extent->param[POLY_Z].start;
+	float dz = extent->param[POLY_Z].dpdx;
+	float bri = extent->param[POLY_BRI].start;
+	float dbri = extent->param[POLY_BRI].dpdx;
+	float fog = extent->param[POLY_FOG].start;
+	float dfog = extent->param[POLY_FOG].dpdx;
 	UINT32 *fb = &destmap->pix32(scanline);
-	UINT32 *zb = &K001005_zbuffer->pix32(scanline);
+	float *zb = (float*)&K001005_zbuffer->pix32(scanline);
 	UINT32 color = extra->color;
 	int x;
 
+	int poly_light_r = extra->light_r + extra->ambient_r;
+	int poly_light_g = extra->light_g + extra->ambient_g;
+	int poly_light_b = extra->light_b + extra->ambient_b;
+	if (poly_light_r > 255) poly_light_r = 255;
+	if (poly_light_g > 255) poly_light_g = 255;
+	if (poly_light_b > 255) poly_light_b = 255;
+	int poly_fog_r = extra->fog_r;
+	int poly_fog_g = extra->fog_g;
+	int poly_fog_b = extra->fog_b;
+
 	for (x = extent->startx; x < extent->stopx; x++)
 	{
-		UINT32 iz = (UINT32)z >> 16;
+		int ibri = (int)(bri);
+		int ifog = (int)(fog);
+
+		if (ibri < 0) ibri = 0; if (ibri > 255) ibri = 255;
+		if (ifog < 0) ifog = 0; if (ifog > 65536) ifog = 65536;
 
-		if (iz <= zb[x])
+		if (z <= zb[x])
 		{
 			if (color & 0xff000000)
 			{
-				fb[x] = color;
-				zb[x] = iz;
+				int r = (color >> 16) & 0xff;
+				int g = (color >> 8) & 0xff;
+				int b = color & 0xff;
+
+				r = ((((r * poly_light_r * ibri) >> 16) * ifog) + (poly_fog_r * (65536 - ifog))) >> 16;
+				g = ((((g * poly_light_g * ibri) >> 16) * ifog) + (poly_fog_g * (65536 - ifog))) >> 16;
+				b = ((((b * poly_light_b * ibri) >> 16) * ifog) + (poly_fog_b * (65536 - ifog))) >> 16;
+
+				if (r < 0) r = 0; if (r > 255) r = 255;
+				if (g < 0) g = 0; if (g > 255) g = 255;
+				if (b < 0) b = 0; if (b > 255) b = 255;
+
+				fb[x] = (color & 0xff000000) | (r << 16) | (g << 8) | b;
+				zb[x] = z;
 			}
 		}
 
 		z += dz;
+		bri += dbri;
+		fog += dfog;
 	}
 }
 
@@ -486,30 +684,50 @@
 	UINT8 *texrom = gfxrom + (extra->texture_page * 0x40000);
 	int pal_chip = (extra->texture_palette & 0x8) ? 1 : 0;
 	int palette_index = (extra->texture_palette & 0x7) * 256;
-	float z = extent->param[0].start;
-	float u = extent->param[1].start;
-	float v = extent->param[2].start;
-	float w = extent->param[3].start;
-	float dz = extent->param[0].dpdx;
-	float du = extent->param[1].dpdx;
-	float dv = extent->param[2].dpdx;
-	float dw = extent->param[3].dpdx;
+	float z = extent->param[POLY_Z].start;
+	float u = extent->param[POLY_U].start;
+	float v = extent->param[POLY_V].start;
+	float w = extent->param[POLY_W].start;
+	float dz = extent->param[POLY_Z].dpdx;
+	float du = extent->param[POLY_U].dpdx;
+	float dv = extent->param[POLY_V].dpdx;
+	float dw = extent->param[POLY_W].dpdx;
+	float bri = extent->param[POLY_BRI].start;
+	float dbri = extent->param[POLY_BRI].dpdx;
+	float fog = extent->param[POLY_FOG].start;
+	float dfog = extent->param[POLY_FOG].dpdx;
 	int texture_mirror_x = extra->texture_mirror_x;
 	int texture_mirror_y = extra->texture_mirror_y;
 	int texture_x = extra->texture_x;
 	int texture_y = extra->texture_y;
+	int texture_width = extra->texture_width;
+	int texture_height = extra->texture_height;
 	int x;
 
+	int poly_light_r = extra->light_r + extra->ambient_r;
+	int poly_light_g = extra->light_g + extra->ambient_g;
+	int poly_light_b = extra->light_b + extra->ambient_b;
+	if (poly_light_r > 255) poly_light_r = 255;
+	if (poly_light_g > 255) poly_light_g = 255;
+	if (poly_light_b > 255) poly_light_b = 255;
+	int poly_fog_r = extra->fog_r;
+	int poly_fog_g = extra->fog_g;
+	int poly_fog_b = extra->fog_b;
+
 	UINT32 *fb = &destmap->pix32(scanline);
-	UINT32 *zb = &K001005_zbuffer->pix32(scanline);
+	float *zb = (float*)&K001005_zbuffer->pix32(scanline);
+	int *x_mirror_table = tex_mirror_table[texture_mirror_x][texture_width];
+	int *y_mirror_table = tex_mirror_table[texture_mirror_y][texture_height];
 
 	for (x = extent->startx; x < extent->stopx; x++)
 	{
-		UINT32 iz = (UINT32)z >> 16;
-		//int iu = u >> 16;
-		//int iv = v >> 16;
+		int ibri = (int)(bri);
+		int ifog = (int)(fog);
 
-		if (iz < zb[x])
+		if (ibri < 0) ibri = 0; if (ibri > 255) ibri = 255;
+		if (ifog < 0) ifog = 0; if (ifog > 65536) ifog = 65536;
+
+		if (z <= zb[x])
 		{
 			float oow = 1.0f / w;
 			UINT32 color;
@@ -519,15 +737,28 @@
 			iu = u * oow;
 			iv = v * oow;
 
-			iiu = texture_x + tex_mirror_table[texture_mirror_x][(iu >> 4) & 0x7f];
-			iiv = texture_y + tex_mirror_table[texture_mirror_y][(iv >> 4) & 0x7f];
+			iiu = texture_x + x_mirror_table[(iu >> 4) & 0x7f];
+			iiv = texture_y + y_mirror_table[(iv >> 4) & 0x7f];
+
 			texel = texrom[((iiv & 0x1ff) * 512) + (iiu & 0x1ff)];
 			color = K001006_palette[pal_chip][palette_index + texel];
 
 			if (color & 0xff000000)
 			{
-				fb[x] = color;
-				zb[x] = iz;
+				int r = (color >> 16) & 0xff;
+				int g = (color >> 8) & 0xff;
+				int b = color & 0xff;
+
+				r = ((((r * poly_light_r * ibri) >> 16) * ifog) + (poly_fog_r * (65536 - ifog))) >> 16;
+				g = ((((g * poly_light_g * ibri) >> 16) * ifog) + (poly_fog_g * (65536 - ifog))) >> 16;
+				b = ((((b * poly_light_b * ibri) >> 16) * ifog) + (poly_fog_b * (65536 - ifog))) >> 16;
+
+				if (r < 0) r = 0; if (r > 255) r = 255;
+				if (g < 0) g = 0; if (g > 255) g = 255;
+				if (b < 0) b = 0; if (b > 255) b = 255;
+
+				fb[x] = 0xff000000 | (r << 16) | (g << 8) | b;
+				zb[x] = z;
 			}
 		}
 
@@ -535,405 +766,683 @@
 		v += dv;
 		z += dz;
 		w += dw;
+		bri += dbri;
+		fog += dfog;
 	}
 }
 
 static void render_polygons(running_machine &machine)
 {
-	int i, j;
 	const rectangle visarea = machine.primary_screen->visible_area();
+	poly_vertex v[4];
+	int poly_type;
+	int brightness;
 
-//  mame_printf_debug("K001005_fifo_ptr = %08X\n", K001005_3d_fifo_ptr);
-
-	for (i=0; i < K001005_3d_fifo_ptr; i++)
-	{
-		if (K001005_3d_fifo[i] == 0x80000003)
-		{
-			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
-			poly_vertex v[4];
-			int r, g, b, a;
-			UINT32 color;
-			int index = i;
-
-			++index;
+	poly_vertex *vertex1;
+	poly_vertex *vertex2;
+	poly_vertex *vertex3;
+	poly_vertex *vertex4;
 
-			for (j=0; j < 4; j++)
-			{
-				int x, y;
+	UINT32 *fifo = K001005_3d_fifo;
 
-				x = ((K001005_3d_fifo[index] >>  0) & 0x3fff);
-				y = ((K001005_3d_fifo[index] >> 16) & 0x1fff);
-				x |= ((x & 0x2000) ? 0xffffc000 : 0);
-				y |= ((y & 0x1000) ? 0xffffe000 : 0);
-				++index;
+	int index = 0;
 
-				v[j].x = ((float)(x) / 16.0f) + 256.0f;
-				v[j].y = ((float)(-y) / 16.0f) + 192.0f;
-				v[j].p[0] = 0;	/* ??? */
-			}
-
-			++index;
-
-			r = (K001005_3d_fifo[index] >>  0) & 0xff;
-			g = (K001005_3d_fifo[index] >>  8) & 0xff;
-			b = (K001005_3d_fifo[index] >> 16) & 0xff;
-			a = (K001005_3d_fifo[index] >> 24) & 0xff;
-			color = (a << 24) | (r << 16) | (g << 8) | (b);
-			++index;
+	do
+	{
+		UINT32 cmd = fifo[index++];
 
-			extra->color = color;
-			poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[0], &v[1], &v[2]);
-			poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[0], &v[2], &v[3]);
-//          poly_render_polygon(poly, K001005_bitmap[K001005_bitmap_page],  visarea, draw_scanline, 1, 4, v);
-
-			i = index - 1;
-		}
-		else if (K001005_3d_fifo[i] == 0x800000ae || K001005_3d_fifo[i] == 0x8000008e ||
-				 K001005_3d_fifo[i] == 0x80000096 || K001005_3d_fifo[i] == 0x800000b6 ||
-				 K001005_3d_fifo[i] == 0x8000002e || K001005_3d_fifo[i] == 0x8000000e ||
-				 K001005_3d_fifo[i] == 0x80000016 || K001005_3d_fifo[i] == 0x80000036 ||
-				 K001005_3d_fifo[i] == 0x800000aa || K001005_3d_fifo[i] == 0x800000a8 ||
-				 K001005_3d_fifo[i] == 0x800000b2)
+		// Current guesswork on the command word bits:
+		// 0x01: Z-buffer disable?
+		// 0x02: Almost always set (only exception is 0x80000020 in Thunder Hurricane attract mode)
+		// 0x04:
+		// 0x08:
+		// 0x10: Texture mirror enable
+		// 0x20: Gouraud shading enable?
+		// 0x40: Unused?
+		// 0x80: Used by textured polygons.
+
+		if (cmd == 0x800000ae || cmd == 0x8000008e || cmd == 0x80000096 || cmd == 0x800000b6 ||
+			cmd == 0x8000002e || cmd == 0x8000000e || cmd == 0x80000016 || cmd == 0x80000036 ||
+			cmd == 0x800000aa || cmd == 0x800000a8 || cmd == 0x800000b2 || cmd == 0x8000009e ||
+			cmd == 0x80000092 || cmd == 0x8000008a || cmd == 0x80000094 || cmd == 0x8000009a ||
+			cmd == 0x8000009c || cmd == 0x8000008c || cmd == 0x800000ac || cmd == 0x800000b4)
 		{
 			// 0x00: xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx    Command
 			//
 			// 0x01: xxxx---- -------- -------- --------    Texture palette
+			// 0x01: ----xx-- -------- -------- --------    Unknown flags, set by commands 0x7b...0x7e
+			// 0x01: ------xx x------- -------- --------    Texture width / 8 - 1
+			// 0x01: -------- -xxx---- -------- --------    Texture height / 8 - 1
 			// 0x01: -------- -------x xxxx---- --------    Texture page
 			// 0x01: -------- -------- ----x-x- x-x-x-x-    Texture X / 8
 			// 0x01: -------- -------- -----x-x -x-x-x-x    Texture Y / 8
 
-			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
-			poly_vertex v[4];
-			int tx, ty;
+			// texture, Z
+
+			int tex_x, tex_y;
 			UINT32 color = 0;
-			UINT32 header;
-			UINT32 command;
-			int num_verts = 0;
-			int index = i;
-			int poly_type = 0;
+			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
 
-			command = K001005_3d_fifo[index++];
-			header = K001005_3d_fifo[index++];
+			UINT32 header = fifo[index++];
 
-			for (j=0; j < 4; j++)
+			int last_vertex = 0;
+			int vert_num = 0;
+			do
 			{
-				INT16 u2, v2;
 				int x, y, z;
-				int end = 0;
+				INT16 tu, tv;
 
-				x = ((K001005_3d_fifo[index] >>  0) & 0x3fff);
-				y = ((K001005_3d_fifo[index] >> 16) & 0x1fff);
+				x = (fifo[index] >> 0) & 0x3fff;
+				y = (fifo[index] >> 16) & 0x1fff;
 				x |= ((x & 0x2000) ? 0xffffc000 : 0);
 				y |= ((y & 0x1000) ? 0xffffe000 : 0);
 
-				poly_type = K001005_3d_fifo[index] & 0x4000;
-				end = K001005_3d_fifo[index] & 0x8000;
-				++index;
+				poly_type = fifo[index] & 0x4000;		// 0 = triangle, 1 = quad
+				last_vertex = fifo[index] & 0x8000;
+				index++;
 
-				z = K001005_3d_fifo[index];
-				++index;
+				z = fifo[index] & 0xffffff00;
+				brightness = fifo[index] & 0xff;
+				index++;
 
-				if (end)
+				if (last_vertex)
 				{
-					color = K001005_3d_fifo[index];
-					++index;
-
-					u2 = (K001005_3d_fifo[index] >> 16) & 0xffff;
-					v2 = (K001005_3d_fifo[index] >>  0) & 0xffff;
-					++index;
+					color = fifo[index++];
 				}
-				else
-				{
-					u2 = (K001005_3d_fifo[index] >> 16) & 0xffff;
-					v2 = (K001005_3d_fifo[index] >>  0) & 0xffff;
-					++index;
-				}
-
-				v[j].x = ((float)(x) / 16.0f) + 256.0f;
-				v[j].y = ((float)(-y) / 16.0f) + 192.0f;
-				v[j].p[0] = *(float*)(&z);
-				v[j].p[3] = 1.0f / v[j].p[0];
-				v[j].p[1] = u2 * v[j].p[3];
-				v[j].p[2] = v2 * v[j].p[3];
-
-				++num_verts;
-
-				if (end)
-					break;
-			}
-
-			ty = ((header & 0x400) >> 5) |
-				 ((header & 0x100) >> 4) |
-				 ((header & 0x040) >> 3) |
-				 ((header & 0x010) >> 2) |
-				 ((header & 0x004) >> 1) |
-				 ((header & 0x001) >> 0);
-
-			tx = ((header & 0x800) >> 6) |
-				 ((header & 0x200) >> 5) |
-				 ((header & 0x080) >> 4) |
-				 ((header & 0x020) >> 3) |
-				 ((header & 0x008) >> 2) |
-				 ((header & 0x002) >> 1);
 
-			extra->texture_x = tx * 8;
-			extra->texture_y = ty * 8;
+				tu = (fifo[index] >> 16) & 0xffff;
+				tv = (fifo[index] & 0xffff);
+				index++;
 
+				v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+				v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+				v[vert_num].p[POLY_Z] = *(float*)(&z);
+				v[vert_num].p[POLY_W] = 1.0f / v[vert_num].p[POLY_Z];
+				v[vert_num].p[POLY_U] = tu * v[vert_num].p[POLY_W];
+				v[vert_num].p[POLY_V] = tv * v[vert_num].p[POLY_W];
+				v[vert_num].p[POLY_BRI] = brightness;
+				v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) * ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+				//v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+				if (v[vert_num].p[POLY_FOG] < 0.0f) v[vert_num].p[POLY_FOG] = 0.0f;
+				if (v[vert_num].p[POLY_FOG] > 65536.0f) v[vert_num].p[POLY_FOG] = 65536.0f;
+				vert_num++;
+			}
+			while (!last_vertex);
+
+			tex_y = ((header & 0x400) >> 5) |
+					((header & 0x100) >> 4) |
+					((header & 0x040) >> 3) |
+					((header & 0x010) >> 2) |
+					((header & 0x004) >> 1) |
+					((header & 0x001) >> 0);
+
+			tex_x = ((header & 0x800) >> 6) |
+					((header & 0x200) >> 5) |
+					((header & 0x080) >> 4) |
+					((header & 0x020) >> 3) |
+					((header & 0x008) >> 2) |
+					((header & 0x002) >> 1);
+
+			extra->texture_x = tex_x * 8;
+			extra->texture_y = tex_y * 8;
+			extra->texture_width = (header >> 23) & 0x7;
+			extra->texture_height = (header >> 20) & 0x7;
 			extra->texture_page = (header >> 12) & 0x1f;
 			extra->texture_palette = (header >> 28) & 0xf;
-
-			extra->texture_mirror_x = ((command & 0x10) ? 0x2 : 0) | ((header & 0x00400000) ? 0x1 : 0);
-			extra->texture_mirror_y = ((command & 0x10) ? 0x2 : 0) | ((header & 0x00400000) ? 0x1 : 0);
-
+			extra->texture_mirror_x = ((cmd & 0x10) ? 0x1 : 0);
+			extra->texture_mirror_y = ((cmd & 0x10) ? 0x1 : 0);
 			extra->color = color;
+			extra->light_r = light_r;		extra->light_g = light_g;		extra->light_b = light_b;
+			extra->ambient_r = ambient_r;	extra->ambient_g = ambient_g;	extra->ambient_b = ambient_b;
+			extra->fog_r = fog_r;			extra->fog_g = fog_g;			extra->fog_b = fog_b;
+			extra->flags = cmd;
 
-			if (num_verts < 3)
+			if ((cmd & 0x20) == 0)		// possibly enable flag for gouraud shading (fixes some shading errors)
 			{
-				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &prev_v[2], &v[0], &v[1]);
-				if (prev_poly_type)
-					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &prev_v[2], &prev_v[3], &v[0]);
-//              if (prev_poly_type)
-//                  poly_render_quad(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &prev_v[2], &prev_v[3], &v[0], &v[1]);
-//              else
-//                  poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &prev_v[2], &v[0], &v[1]);
-
-				memcpy(&prev_v[0], &prev_v[2], sizeof(poly_vertex));
-				memcpy(&prev_v[1], &prev_v[3], sizeof(poly_vertex));
-				memcpy(&prev_v[2], &v[0], sizeof(poly_vertex));
-				memcpy(&prev_v[3], &v[1], sizeof(poly_vertex));
+				v[0].p[POLY_BRI] = brightness;
+				v[1].p[POLY_BRI] = brightness;
 			}
-			else
-			{
-				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &v[0], &v[1], &v[2]);
-				if (num_verts > 3)
-					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &v[2], &v[3], &v[0]);
-//              poly_render_polygon(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, num_verts, v);
 
-				memcpy(prev_v, v, sizeof(poly_vertex) * 4);
-			}
+			if (poly_type == 0)		// triangle
+			{
+				if (vert_num == 1)
+				{
+					vertex1 = &prev_v[2];
+					vertex2 = &prev_v[3];
+					vertex3 = &v[0];
+				}
+				else if (vert_num == 2)
+				{
+					vertex1 = &prev_v[3];
+					vertex2 = &v[0];
+					vertex3 = &v[1];
+				}
+				else
+				{
+					vertex1 = &v[0];
+					vertex2 = &v[1];
+					vertex3 = &v[2];
+				}
 
-			prev_poly_type = poly_type;
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, vertex1, vertex2, vertex3);
 
-			while ((K001005_3d_fifo[index] & 0xffffff00) != 0x80000000 && index < K001005_3d_fifo_ptr)
+				memcpy(&prev_v[1], vertex1, sizeof(poly_vertex));
+				memcpy(&prev_v[2], vertex2, sizeof(poly_vertex));
+				memcpy(&prev_v[3], vertex3, sizeof(poly_vertex));
+			}
+			else					// quad
 			{
-				poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
-				int new_verts = 0;
-
-				if (poly_type)
+				if (vert_num == 1)
+				{
+					vertex1 = &prev_v[1];
+					vertex2 = &prev_v[2];
+					vertex3 = &prev_v[3];
+					vertex4 = &v[0];
+				}
+				else if (vert_num == 2)
 				{
-					memcpy(&v[0], &prev_v[2], sizeof(poly_vertex));
-					memcpy(&v[1], &prev_v[3], sizeof(poly_vertex));
+					vertex1 = &prev_v[2];
+					vertex2 = &prev_v[3];
+					vertex3 = &v[0];
+					vertex4 = &v[1];
+				}
+				else if (vert_num == 3)
+				{
+					vertex1 = &prev_v[3];
+					vertex2 = &v[0];
+					vertex3 = &v[1];
+					vertex4 = &v[2];
 				}
 				else
 				{
-					memcpy(&v[0], &prev_v[1], sizeof(poly_vertex));
-					memcpy(&v[1], &prev_v[2], sizeof(poly_vertex));
+					vertex1 = &v[0];
+					vertex2 = &v[1];
+					vertex3 = &v[2];
+					vertex4 = &v[3];
 				}
 
-				for (j=2; j < 4; j++)
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, vertex1, vertex2, vertex3);
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, vertex3, vertex4, vertex1);
+
+				memcpy(&prev_v[0], vertex1, sizeof(poly_vertex));
+				memcpy(&prev_v[1], vertex2, sizeof(poly_vertex));
+				memcpy(&prev_v[2], vertex3, sizeof(poly_vertex));
+				memcpy(&prev_v[3], vertex4, sizeof(poly_vertex));
+			}
+
+			while ((fifo[index] & 0xffffff00) != 0x80000000 && index < K001005_3d_fifo_ptr)
+			{
+				poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
+				int new_verts = 0;
+
+				memcpy(&v[0], &prev_v[2], sizeof(poly_vertex));
+				memcpy(&v[1], &prev_v[3], sizeof(poly_vertex));
+
+				last_vertex = 0;
+				vert_num = 2;
+				do
 				{
-					INT16 u2, v2;
 					int x, y, z;
-					int end = 0;
+					INT16 tu, tv;
 
 					x = ((K001005_3d_fifo[index] >>  0) & 0x3fff);
 					y = ((K001005_3d_fifo[index] >> 16) & 0x1fff);
 					x |= ((x & 0x2000) ? 0xffffc000 : 0);
 					y |= ((y & 0x1000) ? 0xffffe000 : 0);
 
-					poly_type = K001005_3d_fifo[index] & 0x4000;
-					end = K001005_3d_fifo[index] & 0x8000;
-					++index;
-
-					z = K001005_3d_fifo[index];
-					++index;
+					poly_type = fifo[index] & 0x4000;
+					last_vertex = fifo[index] & 0x8000;
+					index++;
+
+					z = fifo[index] & 0xffffff00;
+					brightness = fifo[index] & 0xff;
+					index++;
 
-					if (end)
+					if (last_vertex)
 					{
-						color = K001005_3d_fifo[index];
-						++index;
-
-						u2 = (K001005_3d_fifo[index] >> 16) & 0xffff;
-						v2 = (K001005_3d_fifo[index] >>  0) & 0xffff;
-						++index;
+						color = fifo[index++];
 					}
-					else
-					{
-						u2 = (K001005_3d_fifo[index] >> 16) & 0xffff;
-						v2 = (K001005_3d_fifo[index] >>  0) & 0xffff;
-						++index;
-					}
-
-					v[j].x = ((float)(x) / 16.0f) + 256.0f;
-					v[j].y = ((float)(-y) / 16.0f) + 192.0f;
-					v[j].p[0] = *(float*)(&z);
-					v[j].p[3] = 1.0f / v[j].p[0];
-					v[j].p[1] = u2 * v[j].p[3];
-					v[j].p[2] = v2 * v[j].p[3];
 
-					++new_verts;
+					tu = (K001005_3d_fifo[index] >> 16) & 0xffff;
+					tv = (K001005_3d_fifo[index] >>  0) & 0xffff;
+					index++;
+
+					v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+					v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+					v[vert_num].p[POLY_Z] = *(float*)(&z);
+					v[vert_num].p[POLY_W] = 1.0f / v[vert_num].p[POLY_Z];
+					v[vert_num].p[POLY_U] = tu * v[vert_num].p[POLY_W];
+					v[vert_num].p[POLY_V] = tv * v[vert_num].p[POLY_W];
+					v[vert_num].p[POLY_BRI] = brightness;
+					v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) * ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+					//v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+					if (v[vert_num].p[POLY_FOG] < 0.0f) v[vert_num].p[POLY_FOG] = 0.0f;
+					if (v[vert_num].p[POLY_FOG] > 65536.0f) v[vert_num].p[POLY_FOG] = 65536.0f;
 
-					if (end)
-						break;
+					vert_num++;
+					new_verts++;
 				}
+				while (!last_vertex);
 
-				extra->texture_x = tx * 8;
-				extra->texture_y = ty * 8;
+				extra->texture_x = tex_x * 8;
+				extra->texture_y = tex_y * 8;
+				extra->texture_width = (header >> 23) & 0x7;
+				extra->texture_height = (header >> 20) & 0x7;
 
 				extra->texture_page = (header >> 12) & 0x1f;
 				extra->texture_palette = (header >> 28) & 0xf;
 
-				extra->texture_mirror_x = ((command & 0x10) ? 0x2 : 0) | ((header & 0x00400000) ? 0x1 : 0);
-				extra->texture_mirror_y = ((command & 0x10) ? 0x2 : 0) | ((header & 0x00400000) ? 0x1 : 0);
+				extra->texture_mirror_x = ((cmd & 0x10) ? 0x1 : 0);// & ((header & 0x00400000) ? 0x1 : 0);
+				extra->texture_mirror_y = ((cmd & 0x10) ? 0x1 : 0);// & ((header & 0x00400000) ? 0x1 : 0);
 
 				extra->color = color;
+				extra->light_r = light_r;		extra->light_g = light_g;		extra->light_b = light_b;
+				extra->ambient_r = ambient_r;	extra->ambient_g = ambient_g;	extra->ambient_b = ambient_b;
+				extra->fog_r = fog_r;			extra->fog_g = fog_g;			extra->fog_b = fog_b;
+				extra->flags = cmd;
+
+				if ((cmd & 0x20) == 0)		// possibly enable flag for gouraud shading (fixes some shading errors)
+				{
+					v[0].p[POLY_BRI] = brightness;
+					v[1].p[POLY_BRI] = brightness;
+				}
 
-				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &v[0], &v[1], &v[2]);
-				if (new_verts > 1)
-					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, &v[2], &v[3], &v[0]);
-//              poly_render_polygon(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 4, new_verts + 2, v);
+				if (new_verts == 1)
+				{
+					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, &v[0], &v[1], &v[2]);
 
-				memcpy(prev_v, v, sizeof(poly_vertex) * 4);
-			};
+					memcpy(&prev_v[1], &v[0], sizeof(poly_vertex));
+					memcpy(&prev_v[2], &v[1], sizeof(poly_vertex));
+					memcpy(&prev_v[3], &v[2], sizeof(poly_vertex));
+				}
+				else if (new_verts == 2)
+				{
+					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, &v[0], &v[1], &v[2]);
+					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_tex, 6, &v[2], &v[3], &v[0]);
 
-			i = index - 1;
+					memcpy(&prev_v[0], &v[0], sizeof(poly_vertex));
+					memcpy(&prev_v[1], &v[1], sizeof(poly_vertex));
+					memcpy(&prev_v[2], &v[2], sizeof(poly_vertex));
+					memcpy(&prev_v[3], &v[3], sizeof(poly_vertex));
+				}
+			};
 		}
-		else if (K001005_3d_fifo[i] == 0x80000006 || K001005_3d_fifo[i] == 0x80000026 ||
-				 K001005_3d_fifo[i] == 0x80000020 || K001005_3d_fifo[i] == 0x80000022)
+		else if (cmd == 0x80000006 || cmd == 0x80000026 || cmd == 0x80000002 || cmd == 0x80000020 || cmd == 0x80000022)
 		{
+			// no texture, Z
+
 			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
-			poly_vertex v[4];
-			int r, g, b, a;
 			UINT32 color;
-			int num_verts = 0;
-			int index = i;
-			int poly_type = 0;
-
-			++index;
+			int r, g, b, a;
 
-			for (j=0; j < 4; j++)
+			int last_vertex = 0;
+			int vert_num = 0;
+			do
 			{
 				int x, y, z;
-				int end = 0;
 
-				x = ((K001005_3d_fifo[index] >>  0) & 0x3fff);
-				y = ((K001005_3d_fifo[index] >> 16) & 0x1fff);
+				x = (fifo[index] >> 0) & 0x3fff;
+				y = (fifo[index] >> 16) & 0x1fff;
 				x |= ((x & 0x2000) ? 0xffffc000 : 0);
 				y |= ((y & 0x1000) ? 0xffffe000 : 0);
 
-				poly_type = K001005_3d_fifo[index] & 0x4000;
-				end = K001005_3d_fifo[index] & 0x8000;
-				++index;
-
-				z = K001005_3d_fifo[index];
-				++index;
-
-				v[j].x = ((float)(x) / 16.0f) + 256.0f;
-				v[j].y = ((float)(-y) / 16.0f) + 192.0f;
-				v[j].p[0] = *(float*)(&z);
-
-				++num_verts;
+				poly_type = fifo[index] & 0x4000;		// 0 = triangle, 1 = quad
+				last_vertex = fifo[index] & 0x8000;
+				index++;
 
-				if (end)
-					break;
-			}
+				z = fifo[index] & 0xffffff00;
+				brightness = fifo[index] & 0xff;
+				index++;
 
-			r = (K001005_3d_fifo[index] >>  0) & 0xff;
-			g = (K001005_3d_fifo[index] >>  8) & 0xff;
-			b = (K001005_3d_fifo[index] >> 16) & 0xff;
-			a = (K001005_3d_fifo[index] >> 24) & 0xff;
+				v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+				v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+				v[vert_num].p[POLY_Z] = *(float*)(&z);
+				v[vert_num].p[POLY_BRI] = brightness;
+				v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) * ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+				//v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+				if (v[vert_num].p[POLY_FOG] < 0.0f) v[vert_num].p[POLY_FOG] = 0.0f;
+				if (v[vert_num].p[POLY_FOG] > 65536.0f) v[vert_num].p[POLY_FOG] = 65536.0f;
+				vert_num++;
+			}
+			while (!last_vertex);
+
+			r = (fifo[index] >>  0) & 0xff;
+			g = (fifo[index] >>  8) & 0xff;
+			b = (fifo[index] >> 16) & 0xff;
+			a = (fifo[index] >> 24) & 0xff;
 			color = (a << 24) | (r << 16) | (g << 8) | (b);
 			index++;
 
 			extra->color = color;
+			extra->light_r = light_r;		extra->light_g = light_g;		extra->light_b = light_b;
+			extra->ambient_r = ambient_r;	extra->ambient_g = ambient_g;	extra->ambient_b = ambient_b;
+			extra->fog_r = fog_r;			extra->fog_g = fog_g;			extra->fog_b = fog_b;
+			extra->flags = cmd;
 
-			poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[0], &v[1], &v[2]);
-			if (num_verts > 3)
-				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[2], &v[3], &v[0]);
-//          poly_render_polygon(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, num_verts, v);
-
-			memcpy(prev_v, v, sizeof(poly_vertex) * 4);
+			if ((cmd & 0x20) == 0)		// possibly enable flag for gouraud shading (fixes some shading errors)
+			{
+				v[0].p[POLY_BRI] = brightness;
+				v[1].p[POLY_BRI] = brightness;
+			}
 
-			while ((K001005_3d_fifo[index] & 0xffffff00) != 0x80000000 && index < K001005_3d_fifo_ptr)
+			if (poly_type == 0)		// triangle
 			{
-				poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
-				int new_verts = 0;
+				if (vert_num == 1)
+				{
+					vertex1 = &prev_v[2];
+					vertex2 = &prev_v[3];
+					vertex3 = &v[0];
+				}
+				else if (vert_num == 2)
+				{
+					vertex1 = &prev_v[3];
+					vertex2 = &v[0];
+					vertex3 = &v[1];
+				}
+				else
+				{
+					vertex1 = &v[0];
+					vertex2 = &v[1];
+					vertex3 = &v[2];
+				}
 
-				if (poly_type)
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 3, vertex1, vertex2, vertex3);
+
+				memcpy(&prev_v[1], vertex1, sizeof(poly_vertex));
+				memcpy(&prev_v[2], vertex2, sizeof(poly_vertex));
+				memcpy(&prev_v[3], vertex3, sizeof(poly_vertex));
+			}
+			else					// quad
+			{
+				if (vert_num == 1)
+				{
+					vertex1 = &prev_v[1];
+					vertex2 = &prev_v[2];
+					vertex3 = &prev_v[3];
+					vertex4 = &v[0];
+				}
+				else if (vert_num == 2)
 				{
-					memcpy(&v[0], &prev_v[2], sizeof(poly_vertex));
-					memcpy(&v[1], &prev_v[3], sizeof(poly_vertex));
+					vertex1 = &prev_v[2];
+					vertex2 = &prev_v[3];
+					vertex3 = &v[0];
+					vertex4 = &v[1];
+				}
+				else if (vert_num == 3)
+				{
+					vertex1 = &prev_v[3];
+					vertex2 = &v[0];
+					vertex3 = &v[1];
+					vertex4 = &v[2];
 				}
 				else
 				{
-					memcpy(&v[0], &prev_v[1], sizeof(poly_vertex));
-					memcpy(&v[1], &prev_v[2], sizeof(poly_vertex));
+					vertex1 = &v[0];
+					vertex2 = &v[1];
+					vertex3 = &v[2];
+					vertex4 = &v[3];
 				}
 
-				for (j=2; j < 4; j++)
+				poly_render_quad(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 3, vertex1, vertex2, vertex3, vertex4);
+
+				memcpy(&prev_v[0], vertex1, sizeof(poly_vertex));
+				memcpy(&prev_v[1], vertex2, sizeof(poly_vertex));
+				memcpy(&prev_v[2], vertex3, sizeof(poly_vertex));
+				memcpy(&prev_v[3], vertex4, sizeof(poly_vertex));
+			}
+
+			while ((fifo[index] & 0xffffff00) != 0x80000000 && index < K001005_3d_fifo_ptr)
+			{
+				int new_verts = 0;
+
+				memcpy(&v[0], &prev_v[2], sizeof(poly_vertex));
+				memcpy(&v[1], &prev_v[3], sizeof(poly_vertex));
+
+				last_vertex = 0;
+				vert_num = 2;
+				do
 				{
 					int x, y, z;
-					int end = 0;
 
-					x = ((K001005_3d_fifo[index] >>  0) & 0x3fff);
-					y = ((K001005_3d_fifo[index] >> 16) & 0x1fff);
+					x = ((fifo[index] >>  0) & 0x3fff);
+					y = ((fifo[index] >> 16) & 0x1fff);
 					x |= ((x & 0x2000) ? 0xffffc000 : 0);
 					y |= ((y & 0x1000) ? 0xffffe000 : 0);
 
-					poly_type = K001005_3d_fifo[index] & 0x4000;
-					end = K001005_3d_fifo[index] & 0x8000;
-					++index;
+					poly_type = fifo[index] & 0x4000;
+					last_vertex = fifo[index] & 0x8000;
+					index++;
+
+					z = fifo[index] & 0xffffff00;
+					brightness = fifo[index] & 0xff;
+					index++;
+
+					v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+					v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+					v[vert_num].p[POLY_Z] = *(float*)(&z);
+					v[vert_num].p[POLY_BRI] = brightness;
+					v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) * ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+					//v[vert_num].p[POLY_FOG] = (1.0f / (exp( ((v[vert_num].p[POLY_Z] * fog_density) / far_z) ))) * 65536.0f;
+					if (v[vert_num].p[POLY_FOG] < 0.0f) v[vert_num].p[POLY_FOG] = 0.0f;
+					if (v[vert_num].p[POLY_FOG] > 65536.0f) v[vert_num].p[POLY_FOG] = 65536.0f;
 
-					z = K001005_3d_fifo[index];
-					++index;
+					vert_num++;
+					new_verts++;
+				}
+				while (!last_vertex);
 
-					v[j].x = ((float)(x) / 16.0f) + 256.0f;
-					v[j].y = ((float)(-y) / 16.0f) + 192.0f;
-					v[j].p[0] = *(float*)(&z);
+				r = (fifo[index] >>  0) & 0xff;
+				g = (fifo[index] >>  8) & 0xff;
+				b = (fifo[index] >> 16) & 0xff;
+				a = (fifo[index] >> 24) & 0xff;
+				color = (a << 24) | (r << 16) | (g << 8) | (b);
+				index++;
 
-					++new_verts;
+				extra->color = color;
+				extra->light_r = light_r;		extra->light_g = light_g;		extra->light_b = light_b;
+				extra->ambient_r = ambient_r;	extra->ambient_g = ambient_g;	extra->ambient_b = ambient_b;
+				extra->fog_r = fog_r;			extra->fog_g = fog_g;			extra->fog_b = fog_b;
+				extra->flags = cmd;
 
-					if (end)
-						break;
+				if ((cmd & 0x20) == 0)		// possibly enable flag for gouraud shading (fixes some shading errors)
+				{
+					v[0].p[POLY_BRI] = brightness;
+					v[1].p[POLY_BRI] = brightness;
 				}
 
-				r = (K001005_3d_fifo[index] >>  0) & 0xff;
-				g = (K001005_3d_fifo[index] >>  8) & 0xff;
-				b = (K001005_3d_fifo[index] >> 16) & 0xff;
-				a = (K001005_3d_fifo[index] >> 24) & 0xff;
-				color = (a << 24) | (r << 16) | (g << 8) | (b);
+				if (new_verts == 1)
+				{
+					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 3, &v[0], &v[1], &v[2]);
+
+					memcpy(&prev_v[1], &v[0], sizeof(poly_vertex));
+					memcpy(&prev_v[2], &v[1], sizeof(poly_vertex));
+					memcpy(&prev_v[3], &v[2], sizeof(poly_vertex));
+				}
+				else if (new_verts == 2)
+				{
+					poly_render_quad(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 3, &v[0], &v[1], &v[2], &v[3]);
+
+					memcpy(&prev_v[0], &v[0], sizeof(poly_vertex));
+					memcpy(&prev_v[1], &v[1], sizeof(poly_vertex));
+					memcpy(&prev_v[2], &v[2], sizeof(poly_vertex));
+					memcpy(&prev_v[3], &v[3], sizeof(poly_vertex));
+				}
+			}
+		}
+		else if (cmd == 0x80000003 || cmd == 0x80000001)
+		{
+			// no texture, no Z
+
+			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
+			int r, g, b, a;
+			UINT32 color;
+
+			int last_vertex = 0;
+			int vert_num = 0;
+			do
+			{
+				int x, y;
+
+				x = ((fifo[index] >>  0) & 0x3fff);
+				y = ((fifo[index] >> 16) & 0x1fff);
+				x |= ((x & 0x2000) ? 0xffffc000 : 0);
+				y |= ((y & 0x1000) ? 0xffffe000 : 0);
+
+				poly_type = fifo[index] & 0x4000;
+				last_vertex = fifo[index] & 0x8000;
 				index++;
 
-				extra->color = color;
+				v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+				v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+				vert_num++;
+			}
+			while (!last_vertex);
 
-				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[0], &v[1], &v[2]);
-				if (new_verts > 1)
-					poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, &v[0], &v[2], &v[3]);
-//              poly_render_polygon(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline, 1, new_verts + 2, v);
+			// unknown word
+			index++;
 
-				memcpy(prev_v, v, sizeof(poly_vertex) * 4);
-			};
+			r = (fifo[index] >>  0) & 0xff;
+			g = (fifo[index] >>  8) & 0xff;
+			b = (fifo[index] >> 16) & 0xff;
+			a = (fifo[index] >> 24) & 0xff;
+			color = (a << 24) | (r << 16) | (g << 8) | (b);
+			index++;
+
+			extra->color = color;
+			extra->flags = cmd;
+
+			if (poly_type == 0)
+			{
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_2d, 0, &v[0], &v[1], &v[2]);
+			}
+			else
+			{
+				poly_render_quad(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_2d, 0, &v[0], &v[1], &v[2], &v[3]);
+			}
+		}
+		else if (cmd == 0x8000008b)
+		{
+			// texture, no Z
+
+			int tex_x, tex_y;
+			poly_extra_data *extra = (poly_extra_data *)poly_get_extra_data(poly);
+			int r, g, b, a;
+			UINT32 color = 0;
+
+			UINT32 header = fifo[index++];
+
+			int last_vertex = 0;
+			int vert_num = 0;
+			do
+			{
+				int x, y;
+				INT16 tu, tv;
+
+				x = ((fifo[index] >>  0) & 0x3fff);
+				y = ((fifo[index] >> 16) & 0x1fff);
+				x |= ((x & 0x2000) ? 0xffffc000 : 0);
+				y |= ((y & 0x1000) ? 0xffffe000 : 0);
+
+				poly_type = fifo[index] & 0x4000;
+				last_vertex = fifo[index] & 0x8000;
+				index++;
+
+				if (last_vertex)
+				{
+					// unknown word
+					index++;
+
+					color = fifo[index++];
+				}
+
+				tu = (fifo[index] >> 16) & 0xffff;
+				tv = (fifo[index] & 0xffff);
+				index++;
+
+				v[vert_num].x = ((float)(x) / 16.0f) + 256.0f;
+				v[vert_num].y = ((float)(-y) / 16.0f) + 192.0f + 8;
+				v[vert_num].p[POLY_U] = tu;
+				v[vert_num].p[POLY_V] = tv;
+				vert_num++;
+			}
+			while (!last_vertex);
+
+			r = (color >>  0) & 0xff;
+			g = (color >>  8) & 0xff;
+			b = (color >> 16) & 0xff;
+			a = (color >> 24) & 0xff;
+			extra->color = (a << 24) | (r << 16) | (g << 8) | (b);
+			extra->flags = cmd;
+
+			tex_y = ((header & 0x400) >> 5) |
+					((header & 0x100) >> 4) |
+					((header & 0x040) >> 3) |
+					((header & 0x010) >> 2) |
+					((header & 0x004) >> 1) |
+					((header & 0x001) >> 0);
+
+			tex_x = ((header & 0x800) >> 6) |
+					((header & 0x200) >> 5) |
+					((header & 0x080) >> 4) |
+					((header & 0x020) >> 3) |
+					((header & 0x008) >> 2) |
+					((header & 0x002) >> 1);
+
+			extra->texture_x = tex_x * 8;
+			extra->texture_y = tex_y * 8;
+			extra->texture_width = (header >> 23) & 0x7;
+			extra->texture_height = (header >> 20) & 0x7;
+
+			extra->texture_page = (header >> 12) & 0x1f;
+			extra->texture_palette = (header >> 28) & 0xf;
+
+			extra->texture_mirror_x = ((cmd & 0x10) ? 0x1 : 0);
+			extra->texture_mirror_y = ((cmd & 0x10) ? 0x1 : 0);
 
-			i = index - 1;
+			if (poly_type == 0)
+			{
+				poly_render_triangle(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_2d_tex, 5, &v[0], &v[1], &v[2]);
+			}
+			else
+			{
+				poly_render_quad(poly, K001005_bitmap[K001005_bitmap_page], visarea, draw_scanline_2d_tex, 5, &v[0], &v[1], &v[2], &v[3]);
+			}
 		}
-		else if (K001005_3d_fifo[i] == 0x80000000)
+		else if (cmd == 0x80000000)
 		{
 
 		}
-		else if ((K001005_3d_fifo[i] & 0xffffff00) == 0x80000000)
+		else if (cmd == 0x80000018)
+		{
+
+		}
+		else if ((cmd & 0xffffff00) == 0x80000000)
 		{
 			/*
-            mame_printf_debug("Unknown polygon type %08X:\n", K001005_3d_fifo[i]);
-            for (j=0; j < 0x20; j++)
+            mame_printf_debug("Unknown polygon type %08X:\n", fifo[index-1]);
+            for (int i=0; i < 0x20; i++)
             {
-                mame_printf_debug("  %02X: %08X\n", j, K001005_3d_fifo[i+1+j]);
+                mame_printf_debug("  %02X: %08X\n", i, fifo[index+i]);
             }
             mame_printf_debug("\n");
             */
+
+			printf("Unknown polygon type %08X:\n", fifo[index-1]);
+			for (int i=0; i < 0x20; i++)
+			{
+				printf("  %02X: %08X\n", i, fifo[index+i]);
+			}
+			printf("\n");
+		}
+		else
+		{
+
 		}
 	}
+	while (index < K001005_3d_fifo_ptr);
 }
 
+
 void K001005_draw(bitmap_rgb32 &bitmap, const rectangle &cliprect)
 {
 	int i, j;
@@ -961,21 +1470,26 @@
 
 	//if (K001005_status == 2)
 	{
+		float zvalue = ZBUFFER_MAX;
 		K001005_bitmap[K001005_bitmap_page]->fill(machine.pens[0]&0x00ffffff, K001005_cliprect);
-		K001005_zbuffer->fill(0xffffffff, K001005_cliprect);
+		K001005_zbuffer->fill(*(int*)&zvalue, K001005_cliprect);
 	}
 }
 
+/*
 static int tick = 0;
 static int debug_tex_page = 0;
 static int debug_tex_palette = 0;
+*/
 
 VIDEO_START( gticlub )
 {
 	gticlub_led_reg[0] = gticlub_led_reg[1] = 0x7f;
-	tick = 0;
-	debug_tex_page = 0;
-	debug_tex_palette = 0;
+	/*
+    tick = 0;
+    debug_tex_page = 0;
+    debug_tex_palette = 0;
+    */
 
 	K001006_init(machine);
 	K001005_init(machine);
@@ -991,6 +1505,7 @@
 
 	k001604_draw_front_layer(k001604, bitmap, cliprect);
 
+#if 0
 	tick++;
 	if( tick >= 5 ) {
 		tick = 0;
@@ -1017,7 +1532,6 @@
 			debug_tex_palette = 0;
 	}
 
-#if 0
     if (debug_tex_page > 0)
     {
         char string[200];
diff -Nru src-old/mame/video/n64.c src/mame/video/n64.c
--- src-old/mame/video/n64.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/video/n64.c	2012-02-20 22:10:04.000000000 +0100
@@ -2110,6 +2110,19 @@
 
 	int xfrac = ((xright >> 8) & 0xff);
 
+	int clipy1 = Scissor.m_yh;
+	int clipy2 = Scissor.m_yl;
+
+	// Trivial reject
+	if((ycur >> 2) >= clipy2 && (ylfar >> 2) >= clipy2)
+	{
+		return;
+	}
+	if((ycur >> 2) < clipy1 && (ylfar >> 2) < clipy1)
+	{
+		return;
+	}
+
 	bool new_object = true;
 	rdp_poly_state *object = NULL;
 
diff -Nru src-old/mame/video/williams.c src/mame/video/williams.c
--- src-old/mame/video/williams.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/williams.c	2012-02-20 09:41:18.000000000 +0100
@@ -542,7 +542,7 @@
 
 	/* based on the number of memory accesses needed to do the blit, compute how long the blit will take */
 	/* this is just a guess */
-	estimated_clocks_at_4MHz = 20 + 2 * accesses;
+	estimated_clocks_at_4MHz = 20 + ((data & 4) ? 4 : 2) * accesses;
 	device_adjust_icount(&space->device(), -((estimated_clocks_at_4MHz + 3) / 4));
 
 	/* Log blits */
diff -Nru src-old/tools/chdman.c src/tools/chdman.c
--- src-old/tools/chdman.c	2012-02-19 16:23:23.000000000 +0100
+++ src/tools/chdman.c	2012-02-26 15:31:24.000000000 +0100
@@ -87,6 +87,7 @@
 #define COMMAND_COPY "copy"
 #define COMMAND_ADD_METADATA "addmeta"
 #define COMMAND_DEL_METADATA "delmeta"
+#define COMMAND_DUMP_METADATA "dumpmeta"
 
 // option strings
 #define OPTION_INPUT "input"
@@ -137,6 +138,7 @@
 static void do_extract_ld(parameters_t &params);
 static void do_add_metadata(parameters_t &params);
 static void do_del_metadata(parameters_t &params);
+static void do_dump_metadata(parameters_t &params);
 
 
 
@@ -431,12 +433,15 @@
 				}
 
 				// assemble the data into final form
-				avhuff_error averr = avhuff_encoder::assemble_data(m_rawdata, m_rawdata.count(), subbitmap, channels, samples, samplesptr);
+				avhuff_error averr = avhuff_encoder::assemble_data(m_rawdata, subbitmap, channels, samples, samplesptr);
 				if (averr != AVHERR_NONE)
 					report_error(1, "Error assembling data for frame %d", framenum);
-				UINT32 rawsize = avhuff_encoder::raw_data_size(m_rawdata);
-				if (rawsize < m_rawdata.count())
-					memset(&m_rawdata[rawsize], 0, m_rawdata.count() - rawsize);
+				if (m_rawdata.count() < m_info.bytes_per_frame)
+				{
+					UINT32 delta = m_info.bytes_per_frame - m_rawdata.count();
+					m_rawdata.resize(m_info.bytes_per_frame, true);
+					memset(&m_rawdata[m_info.bytes_per_frame - delta], 0, delta);
+				}
 
 				// copy to the destination
 				UINT64 start_offset = UINT64(framenum) * UINT64(m_info.bytes_per_frame);
@@ -476,8 +481,8 @@
 
 
 // default compressors
-static const chd_codec_type s_default_raw_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN };
-static const chd_codec_type s_default_hd_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN };
+static const chd_codec_type s_default_raw_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN, CHD_CODEC_FLAC };
+static const chd_codec_type s_default_hd_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN, CHD_CODEC_FLAC };
 static const chd_codec_type s_default_cd_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN, CHD_CODEC_CD_FLAC };
 static const chd_codec_type s_default_ld_compression[4] = { CHD_CODEC_AVHUFF };
 
@@ -686,6 +691,16 @@
 			REQUIRED OPTION_TAG,
 			OPTION_INDEX
 		}
+	},
+
+	{ COMMAND_DUMP_METADATA, do_dump_metadata, ": dump metadata from the CHD to stdout or to a file",
+		{
+			REQUIRED OPTION_INPUT,
+			OPTION_OUTPUT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_TAG,
+			OPTION_INDEX
+		}
 	}
 };
 
@@ -1608,9 +1623,10 @@
 	parse_hunk_size(params, sector_size, hunk_size);
 
 	// process input start/end (needs to know hunk_size)
-	UINT64 input_start;
-	UINT64 input_end;
-	parse_input_start_end(params, core_fsize(input_file), hunk_size, hunk_size, input_start, input_end);
+	UINT64 input_start = 0;
+	UINT64 input_end = 0;
+	if (input_file != NULL)
+		parse_input_start_end(params, core_fsize(input_file), hunk_size, hunk_size, input_start, input_end);
 
 	// process compression
 	chd_codec_type compression[4];
@@ -1756,7 +1772,7 @@
 	{
 		chd_error err = chdcd_parse_toc(*input_file_str, toc, track_info);
 		if (err != CHDERR_NONE)
-			report_error(1, "Error parsing input file (%s: %s\n", input_file_str->cstr(), chd_file::error_string(err));
+			report_error(1, "Error parsing input file (%s: %s)\n", input_file_str->cstr(), chd_file::error_string(err));
 	}
 
 	// process output CHD
@@ -2557,6 +2573,83 @@
 
 
 //-------------------------------------------------
+//  do_dump_metadata - dump metadata from a CHD
+//-------------------------------------------------
+
+static void do_dump_metadata(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
+
+	// verify output file doesn't exist
+	astring *output_file_str = params.find(OPTION_OUTPUT);
+	if (output_file_str != NULL)
+		check_existing_output_file(params, *output_file_str);
+
+	// process tag
+	chd_metadata_tag tag = CHD_MAKE_TAG('?','?','?','?');
+	astring *tag_str = params.find(OPTION_TAG);
+	if (tag_str != NULL)
+	{
+		tag_str->cat("    ");
+		tag = CHD_MAKE_TAG((*tag_str)[0], (*tag_str)[1], (*tag_str)[2], (*tag_str)[3]);
+	}
+
+	// process index
+	UINT32 index = 0;
+	astring *index_str = params.find(OPTION_INDEX);
+	if (index_str != NULL)
+		index = atoi(*index_str);
+
+	// write the metadata
+	dynamic_buffer buffer;
+	chd_error err = input_chd.read_metadata(tag, index, buffer);
+	if (err != CHDERR_NONE)
+		report_error(1, "Error reading metadata: %s", chd_file::error_string(err));
+
+	// catch errors so we can close & delete the output file
+	core_file *output_file = NULL;
+	try
+	{
+		// create the file
+		if (output_file_str != NULL)
+		{
+			file_error filerr = core_fopen(*output_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_file);
+			if (filerr != FILERR_NONE)
+				report_error(1, "Unable to open file (%s)", output_file_str->cstr());
+
+			// output the metadata
+			UINT32 count = core_fwrite(output_file, buffer, buffer.count());
+			if (count != buffer.count())
+				report_error(1, "Error writing file (%s)", output_file_str->cstr());
+			core_fclose(output_file);
+
+			// provide some feedback
+			astring tempstr;
+			printf("File (%s) written, %s bytes\n", output_file_str->cstr(), big_int_string(tempstr, buffer.count()));
+		}
+
+		// flush to stdout
+		else
+		{
+			fwrite(buffer, 1, buffer.count(), stdout);
+			fflush(stdout);
+		}
+	}
+	catch (...)
+	{
+		// delete the output file
+		if (output_file != NULL)
+			core_fclose(output_file);
+		osd_rmfile(*output_file_str);
+		throw;
+	}
+}
+
+
+//-------------------------------------------------
 //  main - entry point
 //-------------------------------------------------
 
diff -Nru src-old/tools/ldresample.c src/tools/ldresample.c
--- src-old/tools/ldresample.c	2012-02-17 19:37:10.000000000 +0100
+++ src/tools/ldresample.c	2012-02-26 15:31:24.000000000 +0100
@@ -44,90 +44,126 @@
 #include <new>
 #include "bitmap.h"
 #include "chd.h"
+#include "avhuff.h"
 #include "vbiparse.h"
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-/* size of window where we scan ahead to find maximum; this should be large enough to
-   catch peaks of even slow waves */
-#define MAXIMUM_WINDOW_SIZE		40
+// size of window where we scan ahead to find maximum; this should be large enough to
+// catch peaks of even slow waves
+const UINT32 MAXIMUM_WINDOW_SIZE = 40;
 
-/* number of standard deviations away from silence that we consider a real signal */
-#define SIGNAL_DEVIATIONS		100
+// number of standard deviations away from silence that we consider a real signal
+const UINT32 SIGNAL_DEVIATIONS = 100;
 
-/* number of standard deviations away from silence that we consider the start of a signal */
-#define SIGNAL_START_DEVIATIONS	5
+// number of standard deviations away from silence that we consider the start of a signal
+const UINT32 SIGNAL_START_DEVIATIONS = 5;
 
-/* number of consecutive entries of signal before we consider that we found it */
-#define MINIMUM_SIGNAL_COUNT	20
+// number of consecutive entries of signal before we consider that we found it
+const UINT32 MINIMUM_SIGNAL_COUNT = 20;
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-typedef struct _movie_info movie_info;
-struct _movie_info
+struct movie_info
 {
-	double		framerate;
-	int			iframerate;
-	int			numfields;
-	int			width;
-	int			height;
-	int			samplerate;
-	int			channels;
-	int			interlaced;
-	bitmap_yuy16 bitmap;
+	double			framerate;
+	int				iframerate;
+	int				numfields;
+	int				width;
+	int				height;
+	int				samplerate;
+	int				channels;
+	int				interlaced;
+	bitmap_yuy16	bitmap;
 	dynamic_array<INT16> lsound;
 	dynamic_array<INT16> rsound;
-	UINT32		samples;
+	UINT32			samples;
 };
 
 
+// ======================> chd_resample_compressor
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
+class chd_resample_compressor : public chd_file_compressor
+{
+public:
+	// construction/destruction
+	chd_resample_compressor(chd_file &source, movie_info &info, INT64 ioffset, INT64 islope)
+		: m_source(source),
+		  m_info(info),
+		  m_ioffset(ioffset),
+		  m_islope(islope) { }
+
+	// read interface
+	virtual UINT32 read_data(void *_dest, UINT64 offset, UINT32 length)
+	{
+		assert(offset % m_source.hunk_bytes() == 0);
+		assert(length % m_source.hunk_bytes() == 0);
+
+		UINT32 startfield = offset / m_source.hunk_bytes();
+		UINT32 endfield = startfield + length / m_source.hunk_bytes();
+		UINT8 *dest = reinterpret_cast<UINT8 *>(_dest);
+
+		for (UINT32 fieldnum = startfield; fieldnum < endfield; fieldnum++)
+		{
+			generate_one_frame(dest, m_source.hunk_bytes(), fieldnum);
+			dest += m_source.hunk_bytes();
+		}
+		return length;
+	}
+
+private:
+	// internal helpers
+	void generate_one_frame(UINT8 *dest, UINT32 datasize, UINT32 fieldnum);
+
+	// internal state
+	chd_file &					m_source;
+	movie_info &				m_info;
+	INT64						m_ioffset;
+	INT64						m_islope;
+};
 
 
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
 
-/*-------------------------------------------------
-    field_to_sample_number - given a field number
-    compute the absolute sample number for the
-    first sample of that field
--------------------------------------------------*/
+//-------------------------------------------------
+//  field_to_sample_number - given a field number
+//  compute the absolute sample number for the
+//  first sample of that field
+//-------------------------------------------------
 
-INLINE UINT32 field_to_sample_number(const movie_info *info, UINT32 field)
+inline UINT32 field_to_sample_number(const movie_info &info, UINT32 field)
 {
-	return ((UINT64)info->samplerate * (UINT64)field * (UINT64)1000000 + info->iframerate - 1) / (UINT64)info->iframerate;
+	return (UINT64(info.samplerate) * UINT64(field) * UINT64(1000000) + info.iframerate - 1) / UINT64(info.iframerate);
 }
 
 
-/*-------------------------------------------------
-    sample_number_to_field - given a sample number
-    compute the field where it is located and
-    the offset within the field
--------------------------------------------------*/
+//-------------------------------------------------
+//  sample_number_to_field - given a sample number
+//  compute the field where it is located and
+//  the offset within the field
+//-------------------------------------------------
 
-INLINE UINT32 sample_number_to_field(const movie_info *info, UINT32 samplenum, UINT32 *offset)
+inline UINT32 sample_number_to_field(const movie_info &info, UINT32 samplenum, UINT32 &offset)
 {
-	UINT32 guess = ((UINT64)samplenum * (UINT64)info->iframerate + ((UINT64)info->samplerate * (UINT64)1000000 - 1)) / ((UINT64)info->samplerate * (UINT64)1000000);
+	UINT32 guess = (UINT64(samplenum) * UINT64(info.iframerate) + (UINT64(info.samplerate) * UINT64(1000000) - 1)) / (UINT64(info.samplerate) * UINT64(1000000));
 	while (1)
 	{
 		UINT32 fieldstart = field_to_sample_number(info, guess);
 		UINT32 fieldend = field_to_sample_number(info, guess + 1);
 		if (samplenum >= fieldstart && samplenum < fieldend)
 		{
-			*offset = samplenum - fieldstart;
+			offset = samplenum - fieldstart;
 			return guess;
 		}
 		else if (samplenum < fieldstart)
@@ -139,35 +175,35 @@
 
 
 
-/***************************************************************************
-    CHD HANDLING
-***************************************************************************/
-
-/*-------------------------------------------------
-    open_chd - open a CHD file and return
-    information about it
--------------------------------------------------*/
+//**************************************************************************
+//  CHD HANDLING
+//**************************************************************************
+
+//-------------------------------------------------
+//  open_chd - open a CHD file and return
+//  information about it
+//-------------------------------------------------
 
 static chd_error open_chd(chd_file &file, const char *filename, movie_info &info)
 {
-	/* open the file */
+	// open the file
 	chd_error chderr = file.open(filename);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error opening CHD file: %s\n", chd_error_string(chderr));
+		fprintf(stderr, "Error opening CHD file: %s\n", chd_file::error_string(chderr));
 		return chderr;
 	}
 
-	/* get the metadata */
+	// get the metadata
 	astring metadata;
-	chderr = chd.read_metadata(chd, AV_METADATA_TAG, 0, metadata);
+	chderr = file.read_metadata(AV_METADATA_TAG, 0, metadata);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_error_string(chderr));
+		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_file::error_string(chderr));
 		return chderr;
 	}
 
-	/* extract the info */
+	// extract the info
 	int fps, fpsfrac, width, height, interlaced, channels, rate;
 	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
 	{
@@ -175,17 +211,17 @@
 		return CHDERR_INVALID_DATA;
 	}
 
-	/* extract movie info */
+	// extract movie info
 	info.iframerate = fps * 1000000 + fpsfrac;
 	info.framerate = info.iframerate / 1000000.0;
-	info.numfields = file->hunk_count();
+	info.numfields = file.hunk_count();
 	info.width = width;
 	info.height = height;
 	info.interlaced = interlaced;
 	info.samplerate = rate;
 	info.channels = channels;
 
-	/* allocate buffers */
+	// allocate buffers
 	info.bitmap.resize(info.width, info.height);
 	info.lsound.resize(info.samplerate);
 	info.rsound.resize(info.samplerate);
@@ -193,279 +229,289 @@
 }
 
 
-/*-------------------------------------------------
-    create_chd - create a new CHD file
--------------------------------------------------*/
+//-------------------------------------------------
+//  create_chd - create a new CHD file
+//-------------------------------------------------
 
-static chd_error create_chd(chd_compressor &file, const char *filename, chd_file &source, const movie_info &info)
+static chd_error create_chd(chd_file_compressor &file, const char *filename, chd_file &source, const movie_info &info)
 {
-	/* create the file */
-	chd_codec_type compression = { CHD_CODEC_AVHUFF };
+	// create the file
+	chd_codec_type compression[4] = { CHD_CODEC_AVHUFF };
 	chd_error chderr = file.create(filename, source.logical_bytes(), source.hunk_bytes(), source.unit_bytes(), compression);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error creating new CHD file: %s\n", chd_error_string(chderr));
+		fprintf(stderr, "Error creating new CHD file: %s\n", chd_file::error_string(chderr));
 		return chderr;
 	}
 
-	/* clone the metadata */
+	// clone the metadata
 	chderr = file.clone_all_metadata(source);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error cloning metadata: %s\n", chd_error_string(chderr));
-		return chderr;
-	}
-
-	/* begin compressing */
-	chderr = file.compress_begin();
-	if (chderr != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error beginning compression: %s\n", chd_error_string(chderr));
+		fprintf(stderr, "Error cloning metadata: %s\n", chd_file::error_string(chderr));
 		return chderr;
 	}
 
+	// begin compressing
+	file.compress_begin();
 	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    read_chd - read a field from a CHD file
--------------------------------------------------*/
-
-static int read_chd(chd_file *file, UINT32 field, movie_info *info, UINT32 soundoffs)
-{
-	av_codec_decompress_config avconfig;
-	chd_error chderr;
-
-	/* configure the codec */
-	avconfig.video.wrap(*info->bitmap, info->bitmap->cliprect());
-	avconfig.maxsamples = 48000;
-	avconfig.actsamples = &info->samples;
-	avconfig.audio[0] = info->lsound + soundoffs;
-	avconfig.audio[1] = info->rsound + soundoffs;
+//-------------------------------------------------
+//  read_chd - read a field from a CHD file
+//-------------------------------------------------
 
-	/* configure the decompressor for this field */
-	chd_codec_config(file, AV_CODEC_DECOMPRESS_CONFIG, &avconfig);
+static bool read_chd(chd_file &file, UINT32 field, movie_info &info, UINT32 soundoffs)
+{
+	// configure the codec
+	avhuff_decompress_config avconfig;
+	avconfig.video.wrap(info.bitmap, info.bitmap.cliprect());
+	avconfig.maxsamples = info.lsound.count();
+	avconfig.actsamples = &info.samples;
+	avconfig.audio[0] = info.lsound + soundoffs;
+	avconfig.audio[1] = info.rsound + soundoffs;
 
-	/* read the field */
-	chderr = chd_read(file, field, NULL);
-	if (chderr != CHDERR_NONE)
-		return FALSE;
+	// configure the decompressor for this field
+	file.codec_configure(CHD_CODEC_AVHUFF, AVHUFF_CODEC_DECOMPRESS_CONFIG, &avconfig);
 
-	return TRUE;
+	// read the field
+	chd_error chderr = file.read_hunk(field, NULL);
+	return (chderr == CHDERR_NONE);
 }
 
 
-/*-------------------------------------------------
-    write_chd - write a field to a CHD file
--------------------------------------------------*/
-
-static int write_chd(chd_file *file, UINT32 field, movie_info *info)
-{
-	av_codec_compress_config avconfig;
-	chd_error chderr;
-
-	/* configure the codec */
-	avconfig.video.wrap(*info->bitmap, info->bitmap->cliprect());
-	avconfig.channels = 2;
-	avconfig.samples = info->samples;
-	avconfig.audio[0] = info->lsound;
-	avconfig.audio[1] = info->rsound;
 
-	/* configure the decompressor for this field */
-	chd_codec_config(file, AV_CODEC_COMPRESS_CONFIG, &avconfig);
+//**************************************************************************
+//  CORE IMPLEMENTATION
+//**************************************************************************
 
-	/* read the field */
-	chderr = chd_compress_hunk(file, NULL, NULL);
-	if (chderr != CHDERR_NONE)
-		return FALSE;
+//-------------------------------------------------
+//  find_edge_near_field - given a field number,
+//  load +/- 1/2 second on either side and find
+//  an audio edge
+//-------------------------------------------------
 
-	return TRUE;
-}
-
-
-/*-------------------------------------------------
-    create_close_chd - close a CHD file
--------------------------------------------------*/
-
-static void create_close_chd(chd_file *file)
+static bool find_edge_near_field(chd_file &srcfile, UINT32 fieldnum, movie_info &info, bool report_best_field, INT32 &delta)
 {
-	chd_error err;
+	// clear the sound buffers
+	memset(info.lsound, 0, info.lsound.count() * 2);
+	memset(info.rsound, 0, info.rsound.count() * 2);
 
-	err = chd_compress_finish(file, TRUE);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error finishing compression: %s\n", chd_error_string(err));
-
-	chd_close(file);
-}
-
-
-/*-------------------------------------------------
-    close_chd - close a CHD file
--------------------------------------------------*/
-
-static void close_chd(chd_file *file, movie_info *info)
-{
-	if (info != NULL)
-		chd_free_buffers(info);
-	chd_close(file);
-}
-
-
-
-/***************************************************************************
-    CORE IMPLEMENTATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    find_edge_near_field - given a field number,
-    load +/- 1/2 second on either side and find
-    an audio edge
--------------------------------------------------*/
-
-static int find_edge_near_field(chd_file *srcfile, UINT32 fieldnum, movie_info *info, int report_best_field, INT32 *delta)
-{
-	int fields_to_read = info->iframerate / 1000000;
-	UINT32 firstlavg = 0, firstravg = 0;
-	UINT32 firstldev = 0, firstrdev = 0;
-	UINT32 lcount = 0, rcount = 0;
+	// read 1 second around the target area
+	int fields_to_read = info.iframerate / 1000000;
+	INT32 firstfield = fieldnum - (fields_to_read / 2);
 	UINT32 targetsoundstart = 0;
 	UINT32 firstfieldend = 0;
-	INT32 firstfield, curfield;
 	UINT32 fieldstart[100];
 	UINT32 soundend = 0;
-	UINT32 sampnum;
-
-	/* clear the sound buffers */
-	memset(info->lsound, 0, info->samplerate * sizeof(*info->lsound));
-	memset(info->rsound, 0, info->samplerate * sizeof(*info->rsound));
-
-	/* read 1 second around the target area */
-	firstfield = fieldnum - (fields_to_read / 2);
-	for (curfield = 0; curfield < fields_to_read; curfield++)
+	for (INT32 curfield = 0; curfield < fields_to_read; curfield++)
 	{
-		/* remember the start of each field */
+		// remember the start of each field
 		fieldstart[curfield] = soundend;
 
-		/* remember the sound offset where the initial fieldnum is */
+		// remember the sound offset where the initial fieldnum is
 		if (firstfield + curfield == fieldnum)
 			targetsoundstart = soundend;
 
-		/* read the frame and samples */
+		// read the frame and samples
 		if (firstfield + curfield >= 0)
 		{
 			read_chd(srcfile, firstfield + curfield, info, soundend);
-			soundend += info->samples;
+			soundend += info.samples;
 
-			/* also remember the offset at the end of the first field */
+			// also remember the offset at the end of the first field
 			if (firstfieldend == 0)
 				firstfieldend = soundend;
 		}
 	}
 
-	/* compute absolute deltas across the samples */
-	for (sampnum = 0; sampnum < soundend; sampnum++)
+	// compute absolute deltas across the samples
+	for (UINT32 sampnum = 0; sampnum < soundend; sampnum++)
 	{
-		info->lsound[sampnum] = labs(info->lsound[sampnum + 1] - info->lsound[sampnum]);
-		info->rsound[sampnum] = labs(info->rsound[sampnum + 1] - info->rsound[sampnum]);
+		info.lsound[sampnum] = labs(info.lsound[sampnum + 1] - info.lsound[sampnum]);
+		info.rsound[sampnum] = labs(info.rsound[sampnum + 1] - info.rsound[sampnum]);
 	}
 
-	/* for each sample in the collection, find the highest deltas over the
-       next few samples, and take the nth highest value (to remove outliers) */
-	for (sampnum = 0; sampnum < soundend - MAXIMUM_WINDOW_SIZE; sampnum++)
+	// for each sample in the collection, find the highest deltas over the
+    // next few samples, and take the nth highest value (to remove outliers)
+	for (UINT32 sampnum = 0; sampnum < soundend - MAXIMUM_WINDOW_SIZE; sampnum++)
 	{
+		// scan forward over the maximum window
 		UINT32 lmax = 0, rmax = 0;
-		UINT32 scannum;
-
-		/* scan forward over the maximum window */
-		for (scannum = 0; scannum < MAXIMUM_WINDOW_SIZE; scannum++)
+		for (UINT32 scannum = 0; scannum < MAXIMUM_WINDOW_SIZE; scannum++)
 		{
-			if (info->lsound[sampnum + scannum] > lmax)
-				lmax = info->lsound[sampnum + scannum];
-			if (info->rsound[sampnum + scannum] > rmax)
-				rmax = info->rsound[sampnum + scannum];
+			if (info.lsound[sampnum + scannum] > lmax)
+				lmax = info.lsound[sampnum + scannum];
+			if (info.rsound[sampnum + scannum] > rmax)
+				rmax = info.rsound[sampnum + scannum];
 		}
 
-		/* replace this sample with the maximum value found */
-		info->lsound[sampnum] = lmax;
-		info->rsound[sampnum] = rmax;
+		// replace this sample with the maximum value found
+		info.lsound[sampnum] = lmax;
+		info.rsound[sampnum] = rmax;
 	}
 
-	/* now compute the average over the first field, which is assumed to be silence */
-	for (sampnum = 0; sampnum < firstfieldend; sampnum++)
+	// now compute the average over the first field, which is assumed to be silence
+	UINT32 firstlavg = 0;
+	UINT32 firstravg = 0;
+	for (UINT32 sampnum = 0; sampnum < firstfieldend; sampnum++)
 	{
-		firstlavg += info->lsound[sampnum];
-		firstravg += info->rsound[sampnum];
+		firstlavg += info.lsound[sampnum];
+		firstravg += info.rsound[sampnum];
 	}
 	firstlavg /= firstfieldend;
 	firstravg /= firstfieldend;
 
-	/* then compute the standard deviation over the first field */
-	for (sampnum = 0; sampnum < firstfieldend; sampnum++)
-	{
-		firstldev += (info->lsound[sampnum] - firstlavg) * (info->lsound[sampnum] - firstlavg);
-		firstrdev += (info->rsound[sampnum] - firstravg) * (info->rsound[sampnum] - firstravg);
-	}
-	firstldev = sqrt((double)firstldev / firstfieldend);
-	firstrdev = sqrt((double)firstrdev / firstfieldend);
-
-	/* scan forward through the samples, counting consecutive samples more than
-       SIGNAL_DEVIATIONS standard deviations away from silence */
+	// then compute the standard deviation over the first field
+	UINT32 firstldev = 0;
+	UINT32 firstrdev = 0;
+	for (UINT32 sampnum = 0; sampnum < firstfieldend; sampnum++)
+	{
+		firstldev += (info.lsound[sampnum] - firstlavg) * (info.lsound[sampnum] - firstlavg);
+		firstrdev += (info.rsound[sampnum] - firstravg) * (info.rsound[sampnum] - firstravg);
+	}
+	firstldev = sqrt(double(firstldev) / firstfieldend);
+	firstrdev = sqrt(double(firstrdev) / firstfieldend);
+
+	// scan forward through the samples, counting consecutive samples more than
+    // SIGNAL_DEVIATIONS standard deviations away from silence
+	UINT32 lcount = 0;
+	UINT32 rcount = 0;
+	UINT32 sampnum = 0;
 	for (sampnum = 0; sampnum < soundend; sampnum++)
 	{
-		/* left speaker */
-		if (info->lsound[sampnum] > firstlavg + SIGNAL_DEVIATIONS * firstldev)
+		// left speaker
+		if (info.lsound[sampnum] > firstlavg + SIGNAL_DEVIATIONS * firstldev)
 			lcount++;
 		else
 			lcount = 0;
 
-		/* right speaker */
-		if (info->rsound[sampnum] > firstravg + SIGNAL_DEVIATIONS * firstrdev)
+		// right speaker
+		if (info.rsound[sampnum] > firstravg + SIGNAL_DEVIATIONS * firstrdev)
 			rcount++;
 		else
 			rcount = 0;
 
-		/* stop if we find enough */
+		// stop if we find enough
 		if (lcount > MINIMUM_SIGNAL_COUNT || rcount > MINIMUM_SIGNAL_COUNT)
 			break;
 	}
 
-	/* if we didn't find any, return failure */
+	// if we didn't find any, return failure
 	if (sampnum >= soundend)
 	{
 		if (!report_best_field)
 			printf("Field %5d: Unable to find edge\n", fieldnum);
-		return FALSE;
+		return false;
 	}
 
-	/* scan backwards to find the start of the signal */
+	// scan backwards to find the start of the signal
 	for ( ; sampnum > 0; sampnum--)
-		if (info->lsound[sampnum - 1] < firstlavg + SIGNAL_START_DEVIATIONS * firstldev ||
-			info->rsound[sampnum - 1] < firstravg + SIGNAL_START_DEVIATIONS * firstrdev)
+		if (info.lsound[sampnum - 1] < firstlavg + SIGNAL_START_DEVIATIONS * firstldev ||
+			info.rsound[sampnum - 1] < firstravg + SIGNAL_START_DEVIATIONS * firstrdev)
 			break;
 
-	/* if we're to report the best field, figure out which field we are in */
+	// if we're to report the best field, figure out which field we are in
 	if (report_best_field)
 	{
+		INT32 curfield;
 		for (curfield = 0; curfield < fields_to_read - 1; curfield++)
 			if (sampnum < fieldstart[curfield + 1])
 				break;
 		printf("Field %5d: Edge found at offset %d (frame %.1f)\n", firstfield + curfield, sampnum - fieldstart[curfield], (double)(firstfield + curfield) * 0.5);
 	}
 
-	/* otherwise, compute the delta from the provided field number */
+	// otherwise, compute the delta from the provided field number
 	else
 	{
 		printf("Field %5d: Edge at offset %d from expected (found at %d, expected %d)\n", fieldnum, sampnum - targetsoundstart, sampnum, targetsoundstart);
-		*delta = sampnum - targetsoundstart;
+		delta = sampnum - targetsoundstart;
 	}
-	return TRUE;
+	return true;
 }
 
 
-/*-------------------------------------------------
-    usage - display program usage
--------------------------------------------------*/
+//-------------------------------------------------
+//  generate_one_frame - generate a single
+//  resampled frame
+//-------------------------------------------------
+
+void chd_resample_compressor::generate_one_frame(UINT8 *dest, UINT32 datasize, UINT32 fieldnum)
+{
+	// determine the first field needed to cover this range of samples
+	UINT32 srcbegin = field_to_sample_number(m_info, fieldnum);
+	INT64 dstbegin = (INT64(srcbegin) << 24) + m_ioffset + m_islope * fieldnum;
+	UINT32 dstbeginoffset;
+	INT32 dstbeginfield;
+	if (dstbegin >= 0)
+		dstbeginfield = sample_number_to_field(m_info, dstbegin >> 24, dstbeginoffset);
+	else
+	{
+		dstbeginfield = -1 - sample_number_to_field(m_info, -dstbegin >> 24, dstbeginoffset);
+		dstbeginoffset = (field_to_sample_number(m_info, -dstbeginfield) - field_to_sample_number(m_info, -dstbeginfield - 1)) - dstbeginoffset;
+	}
+
+	// determine the last field needed to cover this range of samples
+	UINT32 srcend = field_to_sample_number(m_info, fieldnum + 1);
+	INT64 dstend = (INT64(srcend) << 24) + m_ioffset + m_islope * (fieldnum + 1);
+	UINT32 dstendoffset;
+	INT32 dstendfield;
+	if (dstend >= 0)
+		dstendfield = sample_number_to_field(m_info, dstend >> 24, dstendoffset);
+	else
+	{
+		dstendfield = -1 - -sample_number_to_field(m_info, -dstend >> 24, dstendoffset);
+		dstendoffset = (field_to_sample_number(m_info, -dstendfield) - field_to_sample_number(m_info, -dstendfield - 1)) - dstendoffset;
+	}
+/*
+printf("%5d: start=%10d (%5d.%03d) end=%10d (%5d.%03d)\n",
+        fieldnum,
+        (INT32)(dstbegin >> 24), dstbeginfield, dstbeginoffset,
+        (INT32)(dstend >> 24), dstendfield, dstendoffset);
+*/
+	// read all samples required into the end of the sound buffers
+	UINT32 dstoffset = srcend - srcbegin;
+	for (INT32 dstfield = dstbeginfield; dstfield <= dstendfield; dstfield++)
+	{
+		if (dstfield >= 0)
+			read_chd(m_source, dstfield, m_info, dstoffset);
+		else
+		{
+			m_info.samples = field_to_sample_number(m_info, -dstfield) - field_to_sample_number(m_info, -dstfield - 1);
+			memset(&m_info.lsound[dstoffset], 0, m_info.samples * sizeof(m_info.lsound[0]));
+			memset(&m_info.rsound[dstoffset], 0, m_info.samples * sizeof(m_info.rsound[0]));
+		}
+		dstoffset += m_info.samples;
+	}
+
+	// resample the destination samples to the source
+	dstoffset = srcend - srcbegin;
+	INT64 dstpos = dstbegin;
+	INT64 dststep = (dstend - dstbegin) / INT64(srcend - srcbegin);
+	for (UINT32 srcoffset = 0; srcoffset < srcend - srcbegin; srcoffset++)
+	{
+		m_info.lsound[srcoffset] = m_info.lsound[(int)(dstoffset + dstbeginoffset + (dstpos >> 24) - (dstbegin >> 24))];
+		m_info.rsound[srcoffset] = m_info.rsound[(int)(dstoffset + dstbeginoffset + (dstpos >> 24) - (dstbegin >> 24))];
+		dstpos += dststep;
+	}
+
+	// read the original frame, pointing the sound buffer past where we've calculated
+	read_chd(m_source, fieldnum, m_info, srcend - srcbegin);
+
+	// assemble the final frame
+	dynamic_buffer buffer;
+	INT16 *sampledata[2] = { m_info.lsound, m_info.rsound };
+	avhuff_encoder::assemble_data(buffer, m_info.bitmap, m_info.channels, m_info.samples, sampledata);
+	memcpy(dest, buffer, MIN(buffer.count(), datasize));
+	if (buffer.count() < datasize)
+		memset(&dest[buffer.count()], 0, datasize - buffer.count());
+}
+
+
+//-------------------------------------------------
+//  usage - display program usage
+//-------------------------------------------------
 
 static int usage(void)
 {
@@ -480,27 +526,21 @@
 }
 
 
-/*-------------------------------------------------
-    main - main entry point
--------------------------------------------------*/
+//-------------------------------------------------
+//  main - main entry point
+//-------------------------------------------------
 
 int main(int argc, char *argv[])
 {
-	movie_info info = { 0 };
-	const char *srcfilename;
-	const char *dstfilename;
-	double offset, slope;
-	chd_file *dstfile;
-
-	/* verify arguments */
+	// verify arguments
 	if (argc < 2)
 		return usage();
-	srcfilename = argv[1];
-	dstfilename = (argc < 3) ? NULL : argv[2];
-	offset = (argc < 4) ? 0.0 : atof(argv[3]);
-	slope = (argc < 5) ? 1.0 : atof(argv[4]);
+	const char *srcfilename = argv[1];
+	const char *dstfilename = (argc < 3) ? NULL : argv[2];
+	double offset = (argc < 4) ? 0.0 : atof(argv[3]);
+	double slope = (argc < 5) ? 1.0 : atof(argv[4]);
 
-	/* print basic information */
+	// print basic information
 	printf("Input file: %s\n", srcfilename);
 	if (dstfilename != NULL)
 	{
@@ -509,8 +549,9 @@
 		printf("Slope: %f\n", slope);
 	}
 
-	/* open the source file */
+	// open the source file
 	chd_file srcfile;
+	movie_info info;
 	chd_error err = open_chd(srcfile, srcfilename, info);
 	if (err != CHDERR_NONE)
 	{
@@ -518,33 +559,28 @@
 		return 1;
 	}
 
-	/* output some basics */
+	// output some basics
 	printf("Video dimensions: %dx%d\n", info.width, info.height);
 	printf("Video frame rate: %.2fHz\n", info.framerate);
 	printf("Sample rate: %dHz\n", info.samplerate);
 	printf("Total fields: %d\n", info.numfields);
 
-	/* if we don't have a destination file, scan for edges */
+	// if we don't have a destination file, scan for edges
 	if (dstfilename == NULL)
 	{
-		UINT32 fieldnum;
-		INT32 delta;
-
-		for (fieldnum = 60; fieldnum < info.numfields - 60; fieldnum += 30)
+		for (UINT32 fieldnum = 60; fieldnum < info.numfields - 60; fieldnum += 30)
 		{
 			fprintf(stderr, "Field %5d\r", fieldnum);
-			find_edge_near_field(srcfile, fieldnum, &info, TRUE, &delta);
+			INT32 delta;
+			find_edge_near_field(srcfile, fieldnum, info, true, delta);
 		}
 	}
 
-	/* otherwise, resample the source to the destination */
+	// otherwise, resample the source to the destination
 	else
 	{
-		INT64 ioffset = (INT64)(offset * 65536.0 * 256.0);
-		INT64 islope = (INT64)(slope * 65536.0 * 256.0);
-		UINT32 fieldnum;
-
-		/* open the destination file */
+		// open the destination file
+		chd_resample_compressor dstfile(srcfile, info, INT64(offset * 65536.0 * 256.0), INT64(slope * 65536.0 * 256.0));
 		err = create_chd(dstfile, dstfilename, srcfile, info);
 		if (dstfile == NULL)
 		{
@@ -552,82 +588,15 @@
 			return 1;
 		}
 
-		/* loop over all the fields in the source file */
-		for (fieldnum = 0; fieldnum < info.numfields; fieldnum++)
-		{
-			UINT32 srcbegin = field_to_sample_number(&info, fieldnum);
-			UINT32 srcend = field_to_sample_number(&info, fieldnum + 1);
-			INT64 dstbegin = ((INT64)srcbegin << 24) + ioffset + islope * fieldnum;
-			INT64 dstend = ((INT64)srcend << 24) + ioffset + islope * (fieldnum + 1);
-			UINT32 dstbeginoffset, dstendoffset, dstoffset;
-			INT32 dstbeginfield, dstendfield, dstfield;
-			INT64 dstpos, dststep;
-			UINT32 srcoffset;
-
-			/* update progress (this ain't fast!) */
-			if (fieldnum % 10 == 0)
-				fprintf(stderr, "Field %d\r", fieldnum);
-
-			/* determine the first and last fields needed to cover this range of samples */
-			if (dstbegin >= 0)
-				dstbeginfield = sample_number_to_field(&info, dstbegin >> 24, &dstbeginoffset);
-			else
-			{
-				dstbeginfield = -1 - sample_number_to_field(&info, -dstbegin >> 24, &dstbeginoffset);
-				dstbeginoffset = (field_to_sample_number(&info, -dstbeginfield) - field_to_sample_number(&info, -dstbeginfield - 1)) - dstbeginoffset;
-			}
-			if (dstend >= 0)
-				dstendfield = sample_number_to_field(&info, dstend >> 24, &dstendoffset);
-			else
-			{
-				dstendfield = -1 - -sample_number_to_field(&info, -dstend >> 24, &dstendoffset);
-				dstendoffset = (field_to_sample_number(&info, -dstendfield) - field_to_sample_number(&info, -dstendfield - 1)) - dstendoffset;
-			}
-/*
-printf("%5d: start=%10d (%5d.%03d) end=%10d (%5d.%03d)\n",
-        fieldnum,
-        (INT32)(dstbegin >> 24), dstbeginfield, dstbeginoffset,
-        (INT32)(dstend >> 24), dstendfield, dstendoffset);
-*/
-			/* read all samples required into the end of the sound buffers */
-			dstoffset = srcend - srcbegin;
-			for (dstfield = dstbeginfield; dstfield <= dstendfield; dstfield++)
-			{
-				if (dstfield >= 0)
-					read_chd(srcfile, dstfield, &info, dstoffset);
-				else
-				{
-					info.samples = field_to_sample_number(&info, -dstfield) - field_to_sample_number(&info, -dstfield - 1);
-					memset(&info.lsound[dstoffset], 0, info.samples * sizeof(info.lsound[0]));
-					memset(&info.rsound[dstoffset], 0, info.samples * sizeof(info.rsound[0]));
-				}
-				dstoffset += info.samples;
-			}
-
-			/* resample the destination samples to the source */
-			dstoffset = srcend - srcbegin;
-			dstpos = dstbegin;
-			dststep = (dstend - dstbegin) / (INT64)(srcend - srcbegin);
-			for (srcoffset = 0; srcoffset < srcend - srcbegin; srcoffset++)
+		// loop over all the fields in the source file
+		double progress, ratio;
+		osd_ticks_t last_update = 0;
+		while (dstfile.compress_continue(progress, ratio) == CHDERR_COMPRESSING)
+			if (osd_ticks() - last_update > osd_ticks_per_second() / 4)
 			{
-				info.lsound[srcoffset] = info.lsound[dstoffset + dstbeginoffset + (dstpos >> 24) - (dstbegin >> 24)];
-				info.rsound[srcoffset] = info.rsound[dstoffset + dstbeginoffset + (dstpos >> 24) - (dstbegin >> 24)];
-				dstpos += dststep;
+				last_update = osd_ticks();
+				printf("Processing, %.1f%% complete....\r", progress * 100.0);
 			}
-
-			/* read the original frame, pointing the sound buffer past where we've calculated */
-			read_chd(srcfile, fieldnum, &info, srcend - srcbegin);
-
-			/* write it to the destination */
-			write_chd(dstfile, fieldnum, &info);
-		}
-
-		/* close the destination file */
-		create_close_chd(dstfile);
 	}
-
-	/* close the source file */
-	close_chd(srcfile, &info);
-
 	return 0;
 }
diff -Nru src-old/tools/ldverify.c src/tools/ldverify.c
--- src-old/tools/ldverify.c	2012-01-12 22:19:49.000000000 +0100
+++ src/tools/ldverify.c	2012-02-26 15:31:24.000000000 +0100
@@ -41,27 +41,28 @@
 #include <stdlib.h>
 #include <ctype.h>
 #include <new>
+#include "coretmpl.h"
 #include "aviio.h"
+#include "avhuff.h"
 #include "bitmap.h"
 #include "chd.h"
 #include "vbiparse.h"
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-#define REPORT_BLANKS_THRESHOLD		50
+const int REPORT_BLANKS_THRESHOLD = 50;
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-typedef struct _movie_info movie_info;
-struct _movie_info
+struct movie_info
 {
 	double	framerate;
 	int		numframes;
@@ -71,12 +72,11 @@
 	int		channels;
 };
 
-typedef struct _video_info video_info;
-struct _video_info
+struct video_info
 {
 	int first_whitefield;
-	int saw_leadin;
-	int saw_leadout;
+	bool saw_leadin;
+	bool saw_leadout;
 	int last_frame;
 	int last_chapter;
 	int cadence;
@@ -95,8 +95,7 @@
 	int num_high_fields;
 };
 
-typedef struct _audio_info audio_info;
-struct _audio_info
+struct audio_info
 {
 	int min_lsample;
 	int min_rsample;
@@ -111,315 +110,301 @@
 
 
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-static UINT8 chdinterlaced;
+static bool chdinterlaced;
 
 
 
-/***************************************************************************
-    AVI HANDLING
-***************************************************************************/
+//**************************************************************************
+//  AVI HANDLING
+//**************************************************************************
 
-/*-------------------------------------------------
-    open_avi - open an AVI file and return
-    information about it
--------------------------------------------------*/
+//-------------------------------------------------
+//  open_avi - open an AVI file and return
+//  information about it
+//-------------------------------------------------
 
-static void *open_avi(const char *filename, movie_info *info)
+static void *open_avi(const char *filename, movie_info &info)
 {
-	const avi_movie_info *aviinfo;
-	avi_error avierr;
+	// open the file
 	avi_file *avi;
-
-	/* open the file */
-	avierr = avi_open(filename, &avi);
+	avi_error avierr = avi_open(filename, &avi);
 	if (avierr != AVIERR_NONE)
 	{
 		fprintf(stderr, "Error opening AVI file: %s\n", avi_error_string(avierr));
 		return NULL;
 	}
 
-	/* extract movie info */
-	aviinfo = avi_get_movie_info(avi);
-	info->framerate = (double)aviinfo->video_timescale / (double)aviinfo->video_sampletime;
-	info->numframes = aviinfo->video_numsamples;
-	info->width = aviinfo->video_width;
-	info->height = aviinfo->video_height;
-	info->samplerate = aviinfo->audio_samplerate;
-	info->channels = aviinfo->audio_channels;
-
+	// extract movie info
+	const avi_movie_info *aviinfo = avi_get_movie_info(avi);
+	info.framerate = (double)aviinfo->video_timescale / (double)aviinfo->video_sampletime;
+	info.numframes = aviinfo->video_numsamples;
+	info.width = aviinfo->video_width;
+	info.height = aviinfo->video_height;
+	info.samplerate = aviinfo->audio_samplerate;
+	info.channels = aviinfo->audio_channels;
 	return avi;
 }
 
 
-/*-------------------------------------------------
-    read_avi - read a frame from an AVI file
--------------------------------------------------*/
-
-static int read_avi(void *file, int frame, bitmap_yuy16 &bitmap, INT16 *lsound, INT16 *rsound, int *samples)
-{
-	const avi_movie_info *aviinfo = avi_get_movie_info((avi_file *)file);
-	UINT32 firstsample = ((UINT64)aviinfo->audio_samplerate * (UINT64)frame * (UINT64)aviinfo->video_sampletime + aviinfo->video_timescale - 1) / (UINT64)aviinfo->video_timescale;
-	UINT32 lastsample = ((UINT64)aviinfo->audio_samplerate * (UINT64)(frame + 1) * (UINT64)aviinfo->video_sampletime + aviinfo->video_timescale - 1) / (UINT64)aviinfo->video_timescale;
-	avi_error avierr;
+//-------------------------------------------------
+//  read_avi - read a frame from an AVI file
+//-------------------------------------------------
+
+static bool read_avi(void *file, int frame, bitmap_yuy16 &bitmap, INT16 *lsound, INT16 *rsound, int &samples)
+{
+	avi_file *avifile = reinterpret_cast<avi_file *>(file);
 
-	/* read the frame */
-	avierr = avi_read_video_frame((avi_file *)file, frame, bitmap);
+	// read the frame
+	avi_error avierr = avi_read_video_frame(avifile, frame, bitmap);
 	if (avierr != AVIERR_NONE)
 		return FALSE;
 
-	/* read the samples */
-	avierr = avi_read_sound_samples((avi_file *)file, 0, firstsample, lastsample - firstsample, lsound);
-	avierr = avi_read_sound_samples((avi_file *)file, 1, firstsample, lastsample - firstsample, rsound);
+	// read the samples
+	const avi_movie_info *aviinfo = avi_get_movie_info(avifile);
+	UINT32 firstsample = (UINT64(aviinfo->audio_samplerate) * UINT64(frame) * UINT64(aviinfo->video_sampletime) + aviinfo->video_timescale - 1) / UINT64(aviinfo->video_timescale);
+	UINT32 lastsample = (UINT64(aviinfo->audio_samplerate) * UINT64(frame + 1) * UINT64(aviinfo->video_sampletime) + aviinfo->video_timescale - 1) / UINT64(aviinfo->video_timescale);
+	avierr = avi_read_sound_samples(avifile, 0, firstsample, lastsample - firstsample, lsound);
+	avierr = avi_read_sound_samples(avifile, 1, firstsample, lastsample - firstsample, rsound);
 	if (avierr != AVIERR_NONE)
-		return FALSE;
-	*samples = lastsample - firstsample;
-	return TRUE;
+		return false;
+	samples = lastsample - firstsample;
+	return true;
 }
 
 
-/*-------------------------------------------------
-    close_avi - close an AVI file
--------------------------------------------------*/
+//-------------------------------------------------
+//  close_avi - close an AVI file
+//-------------------------------------------------
 
 static void close_avi(void *file)
 {
-	avi_close((avi_file *)file);
+	avi_file *avifile = reinterpret_cast<avi_file *>(file);
+	avi_close(avifile);
 }
 
 
 
-/***************************************************************************
-    CHD HANDLING
-***************************************************************************/
+//**************************************************************************
+//  CHD HANDLING
+//**************************************************************************
 
-/*-------------------------------------------------
-    open_chd - open a CHD file and return
-    information about it
--------------------------------------------------*/
+//-------------------------------------------------
+//  open_chd - open a CHD file and return
+//  information about it
+//-------------------------------------------------
 
-static void *open_chd(const char *filename, movie_info *info)
+static void *open_chd(const char *filename, movie_info &info)
 {
-	int fps, fpsfrac, width, height, interlaced, channels, rate;
-	char metadata[256];
-	chd_error chderr;
-	chd_file *chd;
+	chd_file *chd = new chd_file;
 
-	/* open the file */
-	chderr = chd_open(filename, CHD_OPEN_READ, NULL, &chd);
+	// open the file
+	chd_error chderr = chd->open(filename);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error opening CHD file: %s\n", chd_error_string(chderr));
+		fprintf(stderr, "Error opening CHD file: %s\n", chd_file::error_string(chderr));
+		delete chd;
 		return NULL;
 	}
 
-	/* get the metadata */
-	chderr = chd_get_metadata(chd, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
+	// get the metadata
+	astring metadata;
+	chderr = chd->read_metadata(AV_METADATA_TAG, 0, metadata);
 	if (chderr != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_error_string(chderr));
-		chd_close(chd);
+		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_file::error_string(chderr));
+		delete chd;
 		return NULL;
 	}
 
-	/* extract the info */
+	// extract the info
+	int fps, fpsfrac, width, height, interlaced, channels, rate;
 	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
 	{
 		fprintf(stderr, "Improperly formatted metadata\n");
-		chd_close(chd);
+		delete chd;
 		return NULL;
 	}
 
-	/* extract movie info */
-	info->framerate = (fps * 1000000 + fpsfrac) / 1000000.0;
-	info->numframes = chd_get_header(chd)->totalhunks;
-	info->width = width;
-	info->height = height;
-	info->samplerate = rate;
-	info->channels = channels;
+	// extract movie info
+	info.framerate = (fps * 1000000 + fpsfrac) / 1000000.0;
+	info.numframes = chd->hunk_count();
+	info.width = width;
+	info.height = height;
+	info.samplerate = rate;
+	info.channels = channels;
 
-	/* convert to an interlaced frame */
+	// convert to an interlaced frame
 	chdinterlaced = interlaced;
 	if (interlaced)
 	{
-		info->framerate /= 2;
-		info->numframes = (info->numframes + 1) / 2;
-		info->height *= 2;
+		info.framerate /= 2;
+		info.numframes = (info.numframes + 1) / 2;
+		info.height *= 2;
 	}
-
 	return chd;
 }
 
 
-/*-------------------------------------------------
-    read_chd - read a frame from a CHD file
--------------------------------------------------*/
+//-------------------------------------------------
+//  read_chd - read a frame from a CHD file
+//-------------------------------------------------
 
-static int read_chd(void *file, int frame, bitmap_yuy16 &bitmap, INT16 *lsound, INT16 *rsound, int *samples)
+static int read_chd(void *file, int frame, bitmap_yuy16 &bitmap, INT16 *lsound, INT16 *rsound, int &samples)
 {
-	av_codec_decompress_config avconfig;
+	chd_file *chdfile = reinterpret_cast<chd_file *>(file);
+
+	// loop over fields
 	int interlace_factor = chdinterlaced ? 2 : 1;
-	bitmap_yuy16 fakebitmap;
-	UINT32 numsamples;
-	chd_error chderr;
-	int fieldnum;
-
-	/* loop over fields */
-	*samples = 0;
-	for (fieldnum = 0; fieldnum < interlace_factor; fieldnum++)
+	samples = 0;
+	for (int fieldnum = 0; fieldnum < interlace_factor; fieldnum++)
 	{
-		/* make a fake bitmap for this field */
+		// make a fake bitmap for this field
+		avhuff_decompress_config avconfig;
 		avconfig.video.wrap(&bitmap.pix16(fieldnum), bitmap.width(), bitmap.height() / interlace_factor, bitmap.rowpixels() * interlace_factor);
 
-		/* configure the codec */
+		// configure the codec
+		UINT32 numsamples;
 		avconfig.maxsamples = 48000;
 		avconfig.actsamples = &numsamples;
-		avconfig.audio[0] = &lsound[*samples];
-		avconfig.audio[1] = &rsound[*samples];
+		avconfig.audio[0] = &lsound[samples];
+		avconfig.audio[1] = &rsound[samples];
 
-		/* configure the decompressor for this frame */
-		chd_codec_config((chd_file *)file, AV_CODEC_DECOMPRESS_CONFIG, &avconfig);
+		// configure the decompressor for this frame
+		chdfile->codec_configure(CHD_CODEC_AVHUFF, AVHUFF_CODEC_DECOMPRESS_CONFIG, &avconfig);
 
-		/* read the frame */
-		chderr = chd_read((chd_file *)file, frame * interlace_factor + fieldnum, NULL);
+		// read the frame
+		chd_error chderr = chdfile->read_hunk(frame * interlace_factor + fieldnum, NULL);
 		if (chderr != CHDERR_NONE)
-			return FALSE;
+			return false;
 
-		/* account for samples read */
-		*samples += numsamples;
+		// account for samples read
+		samples += numsamples;
 	}
-	return TRUE;
+	return true;
 }
 
 
-/*-------------------------------------------------
-    close_chd - close a CHD file
--------------------------------------------------*/
+//-------------------------------------------------
+//  close_chd - close a CHD file
+//-------------------------------------------------
 
 static void close_chd(void *file)
 {
-	chd_close((chd_file *)file);
+	chd_file *chdfile = reinterpret_cast<chd_file *>(file);
+	delete chdfile;
 }
 
 
 
-/***************************************************************************
-    CORE IMPLEMENTATION
-***************************************************************************/
+//**************************************************************************
+//  CORE IMPLEMENTATION
+//**************************************************************************
 
-/*-------------------------------------------------
-    init_video - init video info structure
--------------------------------------------------*/
+//-------------------------------------------------
+//  init_video - init video info structure
+//-------------------------------------------------
 
-static void init_video(video_info *video)
+static void init_video(video_info &video)
 {
-	video->first_whitefield = -1;
-	video->saw_leadin = FALSE;
-	video->saw_leadout = FALSE;
-	video->last_frame = -1;
-	video->last_chapter = -1;
-	video->cadence = -1;
-	video->cadence_history = 0;
-	video->prev_whitefield = -1;
-	video->min_overall = 255;
-	video->max_overall = 0;
-	video->first_blank_frame = -1;
-	video->first_blank_field = -1;
-	video->num_blank_fields = -1;
-	video->first_low_frame = -1;
-	video->first_low_field = -1;
-	video->num_low_fields = -1;
-	video->first_high_frame = -1;
-	video->first_high_field = -1;
-	video->num_high_fields = -1;
+	video.first_whitefield = -1;
+	video.saw_leadin = false;
+	video.saw_leadout = false;
+	video.last_frame = -1;
+	video.last_chapter = -1;
+	video.cadence = -1;
+	video.cadence_history = 0;
+	video.prev_whitefield = -1;
+	video.min_overall = 255;
+	video.max_overall = 0;
+	video.first_blank_frame = -1;
+	video.first_blank_field = -1;
+	video.num_blank_fields = -1;
+	video.first_low_frame = -1;
+	video.first_low_field = -1;
+	video.num_low_fields = -1;
+	video.first_high_frame = -1;
+	video.first_high_field = -1;
+	video.num_high_fields = -1;
 }
 
 
-/*-------------------------------------------------
-    verify_video - verify video frame
--------------------------------------------------*/
+//-------------------------------------------------
+//  verify_video - verify video frame
+//-------------------------------------------------
 
-static void verify_video(video_info *video, int frame, bitmap_yuy16 &bitmap)
+static void verify_video(video_info &video, int frame, bitmap_yuy16 &bitmap)
 {
+	// loop over fields
 	const int fields_per_frame = 2;
-	int fieldnum;
-
-	/* loop over fields */
-	for (fieldnum = 0; fieldnum < fields_per_frame; fieldnum++)
+	for (int fieldnum = 0; fieldnum < fields_per_frame; fieldnum++)
 	{
-		int yminval, ymaxval, cbminval, cbmaxval, crminval, crmaxval;
-		int field = frame * fields_per_frame + fieldnum;
-		int x, y, pixels, remaining;
-		UINT32 yhisto[256] = { 0 };
-		UINT32 crhisto[256] = { 0 };
-		UINT32 cbhisto[256] = { 0 };
-		vbi_metadata metadata;
-
-		/* output status */
+		// output status
 		if (frame % 10 == 0 && fieldnum == 0)
 			fprintf(stderr, "%6d.%d...\r", frame, fieldnum);
 
-		/* parse the VBI data */
+		// parse the VBI data
+		vbi_metadata metadata;
 		vbi_parse_all(&bitmap.pix16(fieldnum), bitmap.rowpixels() * 2, bitmap.width(), 8, &metadata);
 
-		/* if we have data in both 17 and 18, it should match */
+		// if we have data in both 17 and 18, it should match
 		if (metadata.line17 != 0 && metadata.line18 != 0 && metadata.line17 != metadata.line18)
 		{
 			printf("%6d.%d: line 17 and 18 data does not match (17=%06X 18=%06X) (WARNING)\n", frame, fieldnum, metadata.line17, metadata.line18);
 			printf("%6d.%d: selected %06X based on bit confidence\n", frame, fieldnum, metadata.line1718);
 		}
 
-		/* is this a lead-in code? */
+		// is this a lead-in code?
 		if (metadata.line1718 == VBI_CODE_LEADIN)
 		{
-			/* if we haven't seen lead-in yet, detect it */
-			if (!video->saw_leadin)
+			// if we haven't seen lead-in yet, detect it
+			if (!video.saw_leadin)
 			{
-				video->saw_leadin = TRUE;
+				video.saw_leadin = TRUE;
 				printf("%6d.%d: lead-in code detected\n", frame, fieldnum);
 			}
 
-			/* if we've previously seen chapters/frames, that's weird */
-			if (video->last_frame != -1 || video->last_chapter != -1)
+			// if we've previously seen chapters/frames, that's weird
+			if (video.last_frame != -1 || video.last_chapter != -1)
 				printf("%6d.%d: lead-in code detected after frame/chapter data (WARNING)\n", frame, fieldnum);
 		}
 
-		/* is this a lead-out code? */
+		// is this a lead-out code?
 		if (metadata.line1718 == VBI_CODE_LEADOUT)
 		{
-			/* if we haven't seen lead-in yet, detect it */
-			if (!video->saw_leadout)
+			// if we haven't seen lead-in yet, detect it
+			if (!video.saw_leadout)
 			{
-				video->saw_leadout = TRUE;
+				video.saw_leadout = TRUE;
 				printf("%6d.%d: lead-out code detected\n", frame, fieldnum);
-				if (video->last_frame != -1)
-					printf("%6d.%d: final frame number was %d\n", frame, fieldnum, video->last_frame);
+				if (video.last_frame != -1)
+					printf("%6d.%d: final frame number was %d\n", frame, fieldnum, video.last_frame);
 				else
 					printf("%6d.%d: never detected any frame numbers (ERROR)\n", frame, fieldnum);
 			}
 
-			/* if we've previously seen chapters/frames, that's weird */
-			if (video->last_frame == -1)
+			// if we've previously seen chapters/frames, that's weird
+			if (video.last_frame == -1)
 				printf("%6d.%d: lead-out code detected with no frames detected beforehand (WARNING)\n", frame, fieldnum);
 		}
 
-		/* is this a frame code? */
+		// is this a frame code?
 		if ((metadata.line1718 & VBI_MASK_CAV_PICTURE) == VBI_CODE_CAV_PICTURE)
 		{
 			int framenum = VBI_CAV_PICTURE(metadata.line1718);
 
-			/* did we see any leadin? */
-			if (!video->saw_leadin)
+			// did we see any leadin?
+			if (!video.saw_leadin)
 			{
 				printf("%6d.%d: detected frame number but never saw any lead-in (WARNING)\n", frame, fieldnum);
-				video->saw_leadin = TRUE;
+				video.saw_leadin = TRUE;
 			}
 
-			/* if this is the first frame, make sure it's 1 */
-			if (video->last_frame == -1)
+			// if this is the first frame, make sure it's 1
+			if (video.last_frame == -1)
 			{
 				if (framenum == 0)
 					printf("%6d.%d: detected frame 0\n", frame, fieldnum);
@@ -429,99 +414,103 @@
 					printf("%6d.%d: first frame number is not 0 or 1 (%d) (ERROR)\n", frame, fieldnum, framenum);
 			}
 
-			/* print an update every 10000 frames */
+			// print an update every 10000 frames
 			if (framenum != 0 && framenum % 10000 == 0)
 				printf("%6d.%d: detected frame %d\n", frame, fieldnum, framenum);
 
-			/* if this frame is not consecutive, it's an error */
-			if (video->last_frame != -1 && framenum != video->last_frame + 1)
-				printf("%6d.%d: gap in frame number sequence (%d->%d) (ERROR)\n", frame, fieldnum, video->last_frame, framenum);
+			// if this frame is not consecutive, it's an error
+			if (video.last_frame != -1 && framenum != video.last_frame + 1)
+				printf("%6d.%d: gap in frame number sequence (%d->%d) (ERROR)\n", frame, fieldnum, video.last_frame, framenum);
 
-			/* remember the frame number */
-			video->last_frame = framenum;
+			// remember the frame number
+			video.last_frame = framenum;
 
-			/* if we've seen a white flag before, but it's not here, warn */
-			if (video->first_whitefield != -1 && !metadata.white)
+			// if we've seen a white flag before, but it's not here, warn
+			if (video.first_whitefield != -1 && !metadata.white)
 				printf("%6d.%d: detected frame number but no white flag (WARNING)\n", frame, fieldnum);
 		}
 
-		/* is the whiteflag set? */
+		// is the whiteflag set?
+		int field = frame * fields_per_frame + fieldnum;
 		if (metadata.white)
 		{
-			/* if this is the first white flag we see, count it */
-			if (video->first_whitefield == -1)
+			// if this is the first white flag we see, count it
+			if (video.first_whitefield == -1)
 			{
-				video->first_whitefield = field;
+				video.first_whitefield = field;
 				printf("%6d.%d: first white flag seen\n", frame, fieldnum);
 			}
 
-			/* if we've seen frame numbers before, but not here, warn */
-			if (video->last_frame != -1 && (metadata.line1718 & VBI_MASK_CAV_PICTURE) != VBI_CODE_CAV_PICTURE)
+			// if we've seen frame numbers before, but not here, warn
+			if (video.last_frame != -1 && (metadata.line1718 & VBI_MASK_CAV_PICTURE) != VBI_CODE_CAV_PICTURE)
 				printf("%6d.%d: detected white flag but no frame number (WARNING)\n", frame, fieldnum);
 		}
 
-		/* if this is the start of a frame, handle cadence */
+		// if this is the start of a frame, handle cadence
 		if (metadata.white || (metadata.line1718 & VBI_MASK_CAV_PICTURE) == VBI_CODE_CAV_PICTURE)
 		{
-			/* if we've seen frames, but we're not yet to the lead-out, check the cadence */
-			if (video->last_frame != -1 && !video->saw_leadout)
+			// if we've seen frames, but we're not yet to the lead-out, check the cadence
+			if (video.last_frame != -1 && !video.saw_leadout)
 			{
-				/* make sure we have a proper history */
-				if (video->prev_whitefield != -1)
-					video->cadence_history = (video->cadence_history << 4) | ((field - video->prev_whitefield) & 0x0f);
-				video->prev_whitefield = field;
+				// make sure we have a proper history
+				if (video.prev_whitefield != -1)
+					video.cadence_history = (video.cadence_history << 4) | ((field - video.prev_whitefield) & 0x0f);
+				video.prev_whitefield = field;
 
-				/* if we don't know our cadence yet, determine it */
-				if (video->cadence == -1 && (video->cadence_history & 0xf00) != 0)
+				// if we don't know our cadence yet, determine it
+				if (video.cadence == -1 && (video.cadence_history & 0xf00) != 0)
 				{
-					if ((video->cadence_history & 0xfff) == 0x222)
+					if ((video.cadence_history & 0xfff) == 0x222)
 					{
 						printf("%6d.%d: detected 2:2 cadence\n", frame, fieldnum);
-						video->cadence = 4;
+						video.cadence = 4;
 					}
-					else if ((video->cadence_history & 0xfff) == 0x323)
+					else if ((video.cadence_history & 0xfff) == 0x323)
 					{
 						printf("%6d.%d: detected 3:2 cadence\n", frame, fieldnum);
-						video->cadence = 5;
+						video.cadence = 5;
 					}
-					else if ((video->cadence_history & 0xfff) == 0x232)
+					else if ((video.cadence_history & 0xfff) == 0x232)
 					{
 						printf("%6d.%d: detected 2:3 cadence\n", frame, fieldnum);
-						video->cadence = 5;
+						video.cadence = 5;
 					}
 					else
 					{
 						printf("%6d.%d: unknown cadence (history %d:%d:%d) (WARNING)\n", frame, fieldnum,
-								(video->cadence_history >> 8) & 15, (video->cadence_history >> 4) & 15, video->cadence_history & 15);
+								(video.cadence_history >> 8) & 15, (video.cadence_history >> 4) & 15, video.cadence_history & 15);
 					}
 				}
 
-				/* if we know our cadence, make sure we stick to it */
-				if (video->cadence != -1)
+				// if we know our cadence, make sure we stick to it
+				if (video.cadence != -1)
 				{
-					if (video->cadence == 4 && (video->cadence_history & 0xfff) != 0x222)
+					if (video.cadence == 4 && (video.cadence_history & 0xfff) != 0x222)
 					{
 						printf("%6d.%d: missed cadence (history %d:%d:%d) (WARNING)\n", frame, fieldnum,
-								(video->cadence_history >> 8) & 15, (video->cadence_history >> 4) & 15, video->cadence_history & 15);
-						video->cadence = -1;
-						video->cadence_history = 0;
+								(video.cadence_history >> 8) & 15, (video.cadence_history >> 4) & 15, video.cadence_history & 15);
+						video.cadence = -1;
+						video.cadence_history = 0;
 					}
-					else if (video->cadence == 5 && (video->cadence_history & 0xfff) != 0x323 && (video->cadence_history & 0xfff) != 0x232)
+					else if (video.cadence == 5 && (video.cadence_history & 0xfff) != 0x323 && (video.cadence_history & 0xfff) != 0x232)
 					{
 						printf("%6d.%d: missed cadence (history %d:%d:%d) (WARNING)\n", frame, fieldnum,
-								(video->cadence_history >> 8) & 15, (video->cadence_history >> 4) & 15, video->cadence_history & 15);
-						video->cadence = -1;
-						video->cadence_history = 0;
+								(video.cadence_history >> 8) & 15, (video.cadence_history >> 4) & 15, video.cadence_history & 15);
+						video.cadence = -1;
+						video.cadence_history = 0;
 					}
 				}
 			}
 		}
 
-		/* now examine the active video signal */
-		pixels = 0;
-		for (y = 22*2 + fieldnum; y < bitmap.height(); y += 2)
+		// now examine the active video signal
+		UINT32 yhisto[256] = { 0 };
+		UINT32 crhisto[256] = { 0 };
+		UINT32 cbhisto[256] = { 0 };
+		int pixels = 0;
+		for (int y = 22*2 + fieldnum; y < bitmap.height(); y += 2)
 		{
-			for (x = 16; x < 720 - 16; x++)
+			for (int x = 16; x < 720 - 16; x++)
 			{
 				yhisto[bitmap.pix16(y, x) >> 8]++;
 				if (x % 2 == 0)
@@ -532,200 +521,204 @@
 			pixels += 720 - 16 - 16;
 		}
 
-		/* remove the top/bottom 0.1% of Y */
-		remaining = pixels / 1000;
+		// remove the top/bottom 0.1% of Y
+		int remaining = pixels / 1000;
+		int yminval;
 		for (yminval = 0; (remaining -= yhisto[yminval]) >= 0; yminval++) ;
 		remaining = pixels / 1000;
+		int ymaxval;
 		for (ymaxval = 255; (remaining -= yhisto[ymaxval]) >= 0; ymaxval--) ;
 
-		/* remove the top/bottom 0.1% of Cb */
+		// remove the top/bottom 0.1% of Cb
 		remaining = pixels / 500;
+		int cbminval;
 		for (cbminval = 0; (remaining -= cbhisto[cbminval]) >= 0; cbminval++) ;
 		remaining = pixels / 500;
+		int cbmaxval;
 		for (cbmaxval = 255; (remaining -= cbhisto[cbmaxval]) >= 0; cbmaxval--) ;
 
-		/* remove the top/bottom 0.1% of Cr */
+		// remove the top/bottom 0.1% of Cr
 		remaining = pixels / 500;
+		int crminval;
 		for (crminval = 0; (remaining -= crhisto[crminval]) >= 0; crminval++) ;
 		remaining = pixels / 500;
+		int crmaxval;
 		for (crmaxval = 255; (remaining -= crhisto[crmaxval]) >= 0; crmaxval--) ;
 
-		/* track blank frames */
+		// track blank frames
 		if (ymaxval - yminval < 10 && cbmaxval - cbminval < 10 && crmaxval - cbmaxval < 10)
 		{
-			if (video->first_blank_frame == -1)
+			if (video.first_blank_frame == -1)
 			{
-				video->first_blank_frame = frame;
-				video->first_blank_field = fieldnum;
-				video->num_blank_fields = 0;
+				video.first_blank_frame = frame;
+				video.first_blank_field = fieldnum;
+				video.num_blank_fields = 0;
 			}
-			video->num_blank_fields++;
+			video.num_blank_fields++;
 		}
-		else if (video->num_blank_fields > 0)
+		else if (video.num_blank_fields > 0)
 		{
-			if (video->num_blank_fields >= REPORT_BLANKS_THRESHOLD)
-				printf("%6d.%d-%6d.%d: blank frames for %d fields (INFO)\n", video->first_blank_frame, video->first_blank_field, frame, fieldnum, video->num_blank_fields);
-			video->first_blank_frame = video->first_blank_field = video->num_blank_fields = -1;
+			if (video.num_blank_fields >= REPORT_BLANKS_THRESHOLD)
+				printf("%6d.%d-%6d.%d: blank frames for %d fields (INFO)\n", video.first_blank_frame, video.first_blank_field, frame, fieldnum, video.num_blank_fields);
+			video.first_blank_frame = video.first_blank_field = video.num_blank_fields = -1;
 		}
 
-		/* update the overall min/max */
-		video->min_overall = MIN(yminval, video->min_overall);
-		video->max_overall = MAX(ymaxval, video->max_overall);
+		// update the overall min/max
+		video.min_overall = MIN(yminval, video.min_overall);
+		video.max_overall = MAX(ymaxval, video.max_overall);
 
-		/* track low fields */
+		// track low fields
 		if (yminval <= 0)
 		{
-			if (video->first_low_frame == -1)
+			if (video.first_low_frame == -1)
 			{
-				video->first_low_frame = frame;
-				video->first_low_field = fieldnum;
-				video->num_low_fields = 0;
+				video.first_low_frame = frame;
+				video.first_low_field = fieldnum;
+				video.num_low_fields = 0;
 			}
-			video->num_low_fields++;
+			video.num_low_fields++;
 		}
-		else if (video->num_low_fields > 0)
+		else if (video.num_low_fields > 0)
 		{
-			printf("%6d.%d-%6d.%d: active video signal level low for %d fields (WARNING)\n", video->first_low_frame, video->first_low_field, frame, fieldnum, video->num_low_fields);
-			video->first_low_frame = video->first_low_field = video->num_low_fields = -1;
+			printf("%6d.%d-%6d.%d: active video signal level low for %d fields (WARNING)\n", video.first_low_frame, video.first_low_field, frame, fieldnum, video.num_low_fields);
+			video.first_low_frame = video.first_low_field = video.num_low_fields = -1;
 		}
 
-		/* track high fields */
+		// track high fields
 		if (ymaxval >= 255)
 		{
-			if (video->first_high_frame == -1)
+			if (video.first_high_frame == -1)
 			{
-				video->first_high_frame = frame;
-				video->first_high_field = fieldnum;
-				video->num_high_fields = 0;
+				video.first_high_frame = frame;
+				video.first_high_field = fieldnum;
+				video.num_high_fields = 0;
 			}
-			video->num_high_fields++;
+			video.num_high_fields++;
 		}
-		else if (video->num_high_fields > 0)
+		else if (video.num_high_fields > 0)
 		{
-			printf("%6d.%d-%6d.%d: active video signal level high for %d fields (WARNING)\n", video->first_high_frame, video->first_high_field, frame, fieldnum, video->num_high_fields);
-			video->first_high_frame = video->first_high_field = video->num_high_fields = -1;
+			printf("%6d.%d-%6d.%d: active video signal level high for %d fields (WARNING)\n", video.first_high_frame, video.first_high_field, frame, fieldnum, video.num_high_fields);
+			video.first_high_frame = video.first_high_field = video.num_high_fields = -1;
 		}
 	}
 }
 
 
-/*-------------------------------------------------
-    verify_video_final - final verification
--------------------------------------------------*/
+//-------------------------------------------------
+//  verify_video_final - final verification
+//-------------------------------------------------
 
-static void verify_video_final(video_info *video, int frame, bitmap_yuy16 &bitmap)
+static void verify_video_final(video_info &video, int frame, bitmap_yuy16 &bitmap)
 {
 	int fields_per_frame = (bitmap.height() >= 288) ? 2 : 1;
 	int field = frame * fields_per_frame;
 
-	/* did we ever see any white flags? */
-	if (video->first_whitefield == -1)
+	// did we ever see any white flags?
+	if (video.first_whitefield == -1)
 		printf("Track %6d.%d: never saw any white flags (WARNING)\n", field / fields_per_frame, 0);
 
-	/* did we ever see any lead-out? */
-	if (!video->saw_leadout)
+	// did we ever see any lead-out?
+	if (!video.saw_leadout)
 		printf("Track %6d.%d: never saw any lead-out (WARNING)\n", field / fields_per_frame, 0);
 
-	/* any remaining high/low reports? */
-	if (video->num_blank_fields >= REPORT_BLANKS_THRESHOLD)
-		printf("%6d.%d-%6d.%d: blank frames for %d fields (INFO)\n", video->first_blank_frame, video->first_blank_field, frame, 0, video->num_blank_fields);
-	if (video->num_low_fields > 0)
-		printf("%6d.%d-%6d.%d: active video signal level low for %d fields (WARNING)\n", video->first_low_frame, video->first_low_field, frame, 0, video->num_low_fields);
-	if (video->num_high_fields > 0)
-		printf("%6d.%d-%6d.%d: active video signal level high for %d fields (WARNING)\n", video->first_high_frame, video->first_high_field, frame, 0, video->num_high_fields);
+	// any remaining high/low reports?
+	if (video.num_blank_fields >= REPORT_BLANKS_THRESHOLD)
+		printf("%6d.%d-%6d.%d: blank frames for %d fields (INFO)\n", video.first_blank_frame, video.first_blank_field, frame, 0, video.num_blank_fields);
+	if (video.num_low_fields > 0)
+		printf("%6d.%d-%6d.%d: active video signal level low for %d fields (WARNING)\n", video.first_low_frame, video.first_low_field, frame, 0, video.num_low_fields);
+	if (video.num_high_fields > 0)
+		printf("%6d.%d-%6d.%d: active video signal level high for %d fields (WARNING)\n", video.first_high_frame, video.first_high_field, frame, 0, video.num_high_fields);
 
-	/* summary info */
+	// summary info
 	printf("\nVideo summary:\n");
-	printf("  Overall video range: %d-%d (%02X-%02X)\n", video->min_overall, video->max_overall, video->min_overall, video->max_overall);
+	printf("  Overall video range: %d-%d (%02X-%02X)\n", video.min_overall, video.max_overall, video.min_overall, video.max_overall);
 }
 
 
-/*-------------------------------------------------
-    init_audio - init audio info structure
--------------------------------------------------*/
+//-------------------------------------------------
+//  init_audio - init audio info structure
+//-------------------------------------------------
 
-static void init_audio(audio_info *audio)
+static void init_audio(audio_info &audio)
 {
-	audio->min_lsample = 32767;
-	audio->min_rsample = 32767;
-	audio->max_lsample = -32768;
-	audio->max_rsample = -32768;
-	audio->min_lsample_count = 0;
-	audio->min_rsample_count = 0;
-	audio->max_lsample_count = 0;
-	audio->max_rsample_count = 0;
-	audio->sample_count = 0;
+	audio.min_lsample = 32767;
+	audio.min_rsample = 32767;
+	audio.max_lsample = -32768;
+	audio.max_rsample = -32768;
+	audio.min_lsample_count = 0;
+	audio.min_rsample_count = 0;
+	audio.max_lsample_count = 0;
+	audio.max_rsample_count = 0;
+	audio.sample_count = 0;
 }
 
 
-/*-------------------------------------------------
-    verify_audio - verify audio data
--------------------------------------------------*/
+//-------------------------------------------------
+//  verify_audio - verify audio data
+//-------------------------------------------------
 
-static void verify_audio(audio_info *audio, const INT16 *lsound, const INT16 *rsound, int samples)
+static void verify_audio(audio_info &audio, const INT16 *lsound, const INT16 *rsound, int samples)
 {
-	int sampnum;
-
-	/* count the overall samples */
-	audio->sample_count += samples;
+	// count the overall samples
+	audio.sample_count += samples;
 
-	/* iterate over samples, tracking min/max */
-	for (sampnum = 0; sampnum < samples; sampnum++)
+	// iterate over samples, tracking min/max
+	for (int sampnum = 0; sampnum < samples; sampnum++)
 	{
-		/* did we hit a minimum on the left? */
-		if (lsound[sampnum] < audio->min_lsample)
+		// did we hit a minimum on the left?
+		if (lsound[sampnum] < audio.min_lsample)
 		{
-			audio->min_lsample = lsound[sampnum];
-			audio->min_lsample_count = 1;
+			audio.min_lsample = lsound[sampnum];
+			audio.min_lsample_count = 1;
 		}
-		else if (lsound[sampnum] == audio->min_lsample)
-			audio->min_lsample_count++;
+		else if (lsound[sampnum] == audio.min_lsample)
+			audio.min_lsample_count++;
 
-		/* did we hit a maximum on the left? */
-		if (lsound[sampnum] > audio->max_lsample)
+		// did we hit a maximum on the left?
+		if (lsound[sampnum] > audio.max_lsample)
 		{
-			audio->max_lsample = lsound[sampnum];
-			audio->max_lsample_count = 1;
+			audio.max_lsample = lsound[sampnum];
+			audio.max_lsample_count = 1;
 		}
-		else if (lsound[sampnum] == audio->max_lsample)
-			audio->max_lsample_count++;
+		else if (lsound[sampnum] == audio.max_lsample)
+			audio.max_lsample_count++;
 
-		/* did we hit a minimum on the right? */
-		if (rsound[sampnum] < audio->min_rsample)
+		// did we hit a minimum on the right?
+		if (rsound[sampnum] < audio.min_rsample)
 		{
-			audio->min_rsample = rsound[sampnum];
-			audio->min_rsample_count = 1;
+			audio.min_rsample = rsound[sampnum];
+			audio.min_rsample_count = 1;
 		}
-		else if (rsound[sampnum] == audio->min_rsample)
-			audio->min_rsample_count++;
+		else if (rsound[sampnum] == audio.min_rsample)
+			audio.min_rsample_count++;
 
-		/* did we hit a maximum on the right? */
-		if (rsound[sampnum] > audio->max_rsample)
+		// did we hit a maximum on the right?
+		if (rsound[sampnum] > audio.max_rsample)
 		{
-			audio->max_rsample = rsound[sampnum];
-			audio->max_rsample_count = 1;
+			audio.max_rsample = rsound[sampnum];
+			audio.max_rsample_count = 1;
 		}
-		else if (rsound[sampnum] == audio->max_rsample)
-			audio->max_rsample_count++;
+		else if (rsound[sampnum] == audio.max_rsample)
+			audio.max_rsample_count++;
 	}
 }
 
 
-/*-------------------------------------------------
-    verify_audio_final - final verification
--------------------------------------------------*/
+//-------------------------------------------------
+//  verify_audio_final - final verification
+//-------------------------------------------------
 
-static void verify_audio_final(audio_info *audio)
+static void verify_audio_final(audio_info &audio)
 {
 	printf("\nAudio summary:\n");
-	printf("  Overall channel 0 range: %d-%d (%04X-%04X)\n", audio->min_lsample, audio->max_lsample, (UINT16)audio->min_lsample, (UINT16)audio->max_lsample);
-	printf("  Overall channel 1 range: %d-%d (%04X-%04X)\n", audio->min_rsample, audio->max_rsample, (UINT16)audio->min_rsample, (UINT16)audio->max_rsample);
+	printf("  Overall channel 0 range: %d-%d (%04X-%04X)\n", audio.min_lsample, audio.max_lsample, UINT16(audio.min_lsample), UINT16(audio.max_lsample));
+	printf("  Overall channel 1 range: %d-%d (%04X-%04X)\n", audio.min_rsample, audio.max_rsample, UINT16(audio.min_rsample), UINT16(audio.max_rsample));
 }
 
 
-/*-------------------------------------------------
-    usage - display program usage
--------------------------------------------------*/
+//-------------------------------------------------
+//  usage - display program usage
+//-------------------------------------------------
 
 static int usage(void)
 {
@@ -735,108 +728,87 @@
 }
 
 
-/*-------------------------------------------------
-    main - main entry point
--------------------------------------------------*/
+//-------------------------------------------------
+//  main - main entry point
+//-------------------------------------------------
 
 int main(int argc, char *argv[])
 {
 	try
 	{
-		movie_info info = { 0 };
-		INT16 *lsound, *rsound;
-		const char *srcfile;
-		bitmap_yuy16 bitmap;
-		int srcfilelen;
-		int samples = 0;
-		void *file;
-		int isavi;
-		int frame;
+		// init globals
 		audio_info audio;
+		init_audio(audio);
 		video_info video;
+		init_video(video);
 
-		/* init globals */
-		init_audio(&audio);
-		init_video(&video);
-
-		/* verify arguments */
+		// verify arguments
 		if (argc < 2)
 			return usage();
-		srcfile = argv[1];
+		const char *srcfile = argv[1];
 
-		/* check extension of file */
-		srcfilelen = strlen(srcfile);
+		// check extension of file
+		int srcfilelen = strlen(srcfile);
 		if (srcfilelen < 4)
 			return usage();
+		bool isavi;
 		if (tolower((UINT8)srcfile[srcfilelen-3]) == 'a' && tolower((UINT8)srcfile[srcfilelen-2]) == 'v' && tolower((UINT8)srcfile[srcfilelen-1]) == 'i')
-			isavi = TRUE;
+			isavi = true;
 		else if (tolower((UINT8)srcfile[srcfilelen-3]) == 'c' && tolower((UINT8)srcfile[srcfilelen-2]) == 'h' && tolower((UINT8)srcfile[srcfilelen-1]) == 'd')
-			isavi = FALSE;
+			isavi = false;
 		else
 			return usage();
 
-		/* open the file */
+		// open the file
 		printf("Processing file: %s\n", srcfile);
-		file = isavi ? open_avi(srcfile, &info) : open_chd(srcfile, &info);
+		movie_info info = { 0 };
+		void *file = isavi ? open_avi(srcfile, info) : open_chd(srcfile, info);
 		if (file == NULL)
 		{
 			fprintf(stderr, "Unable to open file '%s'\n", srcfile);
 			return 1;
 		}
 
-		/* comment on the video dimensions */
+		// comment on the video dimensions
 		printf("Video dimensions: %dx%d\n", info.width, info.height);
 		if (info.width != 720)
 			printf("WARNING: Unexpected video width (should be 720)\n");
 		if (info.height != 524)
 			printf("WARNING: Unexpected video height (should be 262 or 524)\n");
 
-		/* comment on the video frame rate */
+		// comment on the video frame rate
 		printf("Video frame rate: %.2fHz\n", info.framerate);
-		if ((int)(info.framerate * 100.0 + 0.5) != 2997)
+		if (int(info.framerate * 100.0 + 0.5) != 2997)
 			printf("WARNING: Unexpected frame rate (should be 29.97Hz)\n");
 
-		/* comment on the sample rate */
+		// comment on the sample rate
 		printf("Sample rate: %dHz\n", info.samplerate);
 		if (info.samplerate != 48000)
 			printf("WARNING: Unexpected sampele rate (should be 48000Hz)\n");
 
-		/* allocate a bitmap */
-		bitmap.allocate(info.width, info.height);
+		// allocate a bitmap
+		bitmap_yuy16 bitmap(info.width, info.height);
 
-		/* allocate sound buffers */
-		lsound = (INT16 *)malloc(info.samplerate * sizeof(*lsound));
-		rsound = (INT16 *)malloc(info.samplerate * sizeof(*rsound));
-		if (lsound == NULL || rsound == NULL)
-		{
-			isavi ? close_avi(file) : close_chd(file);
-			if (rsound != NULL)
-				free(rsound);
-			if (lsound != NULL)
-				free(lsound);
-			fprintf(stderr, "Out of memory allocating sound buffers of %d bytes\n", (INT32)(info.samplerate * sizeof(*rsound)));
-			return 1;
-		}
+		// allocate sound buffers
+		dynamic_array<INT16> lsound(info.samplerate);
+		dynamic_array<INT16> rsound(info.samplerate);
 
-		/* loop over frames */
-		frame = 0;
-		while (isavi ? read_avi(file, frame, bitmap, lsound, rsound, &samples) : read_chd(file, frame, bitmap, lsound, rsound, &samples))
+		// loop over frames
+		int frame = 0;
+		int samples = 0;
+		while (isavi ? read_avi(file, frame, bitmap, lsound, rsound, samples) : read_chd(file, frame, bitmap, lsound, rsound, samples))
 		{
-			verify_video(&video, frame, bitmap);
-			verify_audio(&audio, lsound, rsound, samples);
+			verify_video(video, frame, bitmap);
+			verify_audio(audio, lsound, rsound, samples);
 			frame++;
 		}
 
-		/* close the files */
+		// close the files
 		isavi ? close_avi(file) : close_chd(file);
 
-		/* final output */
-		verify_video_final(&video, frame, bitmap);
-		verify_audio_final(&audio);
-
-		/* free memory */
-		free(lsound);
-		free(rsound);
+		// final output
+		verify_video_final(video, frame, bitmap);
+		verify_audio_final(audio);
 	}
 	catch (std::bad_alloc &)
 	{
diff -Nru src-old/tools/tools.mak src/tools/tools.mak
--- src-old/tools/tools.mak	2012-02-16 10:47:18.000000000 +0100
+++ src/tools/tools.mak	2012-02-20 08:26:05.000000000 +0100
@@ -124,7 +124,7 @@
 LDRESAMPLEOBJS = \
 	$(TOOLSOBJ)/ldresample.o \
 
-ldresample$(EXE): $(LDRESAMPLEOBJS) $(LIBUTIL) $(LIBOCORE) $(ZLIB) $(FLAC_LIB) $(EXPAT)
+ldresample$(EXE): $(LDRESAMPLEOBJS) $(LIBUTIL) $(LIBOCORE) $(ZLIB) $(FLAC_LIB) $(7Z_LIB) $(EXPAT)
 	@echo Linking $@...
 	$(LD) $(LDFLAGS) $^ $(LIBS) $(FLAC_LIB) -o $@
 
@@ -137,7 +137,7 @@
 LDVERIFYOBJS = \
 	$(TOOLSOBJ)/ldverify.o \
 
-ldverify$(EXE): $(LDVERIFYOBJS) $(LIBUTIL) $(LIBOCORE) $(ZLIB) $(FLAC_LIB) $(EXPAT)
+ldverify$(EXE): $(LDVERIFYOBJS) $(LIBUTIL) $(LIBOCORE) $(ZLIB) $(FLAC_LIB) $(7Z_LIB) $(EXPAT)
 	@echo Linking $@...
 	$(LD) $(LDFLAGS) $^ $(LIBS) $(FLAC_LIB) -o $@
 
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2012-02-19 16:23:23.000000000 +0100
+++ src/version.c	2012-02-26 15:31:24.000000000 +0100
@@ -38,4 +38,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.145u1 ("__DATE__")";
+const char build_version[] = "0.145u2 ("__DATE__")";
