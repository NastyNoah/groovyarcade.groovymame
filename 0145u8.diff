--- makefile-old	2012-03-29 23:56:18.000000000 +0200
+++ makefile	2012-05-03 11:00:08.000000000 +0200
@@ -163,9 +163,10 @@
 
 # uncomment and specify architecture-specific optimizations here
 # some examples:
-#   optimize for I686:   ARCHOPTS = -march=pentiumpro
-#   optimize for Core 2: ARCHOPTS = -march=core2
-#   optimize for G4:     ARCHOPTS = -mcpu=G4
+#   ARCHOPTS = -march=pentiumpro  # optimize for I686
+#   ARCHOPTS = -march=core2       # optimize for Core 2
+#   ARCHOPTS = -march=native      # optimize for local machine (auto detect)
+#   ARCHOPTS = -mcpu=G4           # optimize for G4
 # note that we leave this commented by default so that you can
 # configure this in your environment and never have to think about it
 # ARCHOPTS =
@@ -473,19 +474,15 @@
 # add the optimization flag
 CCOMFLAGS += -O$(OPTIMIZE)
 
-# if we are optimizing, include optimization options
-# and make all errors into warnings
-ifneq ($(OPTIMIZE),0)
-ifneq ($(TARGETOS),os2)
+# add the error warning flag
 ifndef NOWERROR
-CCOMFLAGS += -Werror -fno-strict-aliasing $(ARCHOPTS)
-else
-CCOMFLAGS += -fno-strict-aliasing $(ARCHOPTS)
+CCOMFLAGS += -Werror
 endif
-else
+
+# if we are optimizing, include optimization options
+ifneq ($(OPTIMIZE),0)
 CCOMFLAGS += -fno-strict-aliasing $(ARCHOPTS)
 endif
-endif
 
 # add a basic set of warnings
 CCOMFLAGS += \
diff -Nru src-old/emu/cpu/i386/i386.c src/emu/cpu/i386/i386.c
--- src-old/emu/cpu/i386/i386.c	2012-04-10 22:13:30.000000000 +0200
+++ src/emu/cpu/i386/i386.c	2012-05-07 08:57:50.000000000 +0200
@@ -53,9 +53,14 @@
 	if (limit == 0 || entry + 7 > limit)
 		return 0;
 
+	int cpl = cpustate->CPL;
+	cpustate->CPL = 0;
+
 	v1 = READ32(cpustate, base + entry );
 	v2 = READ32(cpustate, base + entry + 4 );
 
+	cpustate->CPL = cpl;
+
 	seg->flags = (v2 >> 8) & 0xf0ff;
 	seg->base = (v2 & 0xff000000) | ((v2 & 0xff) << 16) | ((v1 >> 16) & 0xffff);
 	seg->limit = (v2 & 0xf0000) | (v1 & 0xffff);
@@ -88,9 +93,14 @@
 	if (limit == 0 || entry + 7 > limit)
 		return;
 
+	int cpl = cpustate->CPL;
+	cpustate->CPL = 0;
+
 	v1 = READ32(cpustate, base + entry );
 	v2 = READ32(cpustate, base + entry + 4 );
 
+	cpustate->CPL = cpl;
+
 	/* Note that for task gates, offset and dword_count are not used */
 	gate->selector = (v1 >> 16) & 0xffff;
 	gate->offset = (v1 & 0x0000ffff) | (v2 & 0xffff0000);
@@ -129,35 +139,39 @@
 /* Retrieves the stack selector located in the current TSS */
 static UINT32 i386_get_stack_segment(i386_state* cpustate, UINT8 privilege)
 {
+	UINT32 ret;
 	if(privilege >= 3)
 		return 0;
 
-	return READ32(cpustate,(cpustate->task.base+8) + (8*privilege));
-}
+	int cpl = cpustate->CPL;
+	cpustate->CPL = 0;
 
-static UINT16 i286_get_stack_segment(i386_state* cpustate, UINT8 privilege)
-{
-	if(privilege >= 3)
-		return 0;
+	if(cpustate->task.flags & 8)
+		ret = READ32(cpustate,(cpustate->task.base+8) + (8*privilege));
+	else
+		ret = READ16(cpustate,(cpustate->task.base+4) + (4*privilege));
 
-	return READ16(cpustate,(cpustate->task.base+4) + (4*privilege));
+	cpustate->CPL = cpl;
+	return ret;
 }
 
 /* Retrieves the stack pointer located in the current TSS */
 static UINT32 i386_get_stack_ptr(i386_state* cpustate, UINT8 privilege)
 {
+	UINT32 ret;
 	if(privilege >= 3)
 		return 0;
 
-	return READ32(cpustate,(cpustate->task.base+4) + (8*privilege));
-}
+	int cpl = cpustate->CPL;
+	cpustate->CPL = 0;
 
-static UINT16 i286_get_stack_ptr(i386_state* cpustate, UINT8 privilege)
-{
-	if(privilege >= 3)
-		return 0;
+	if(cpustate->task.flags & 8)
+		ret = READ32(cpustate,(cpustate->task.base+4) + (8*privilege));
+	else
+		ret = READ16(cpustate,(cpustate->task.base+2) + (4*privilege));
 
-	return READ16(cpustate,(cpustate->task.base+2) + (4*privilege));
+	cpustate->CPL = cpl;
+	return ret;
 }
 
 static UINT32 get_flags(i386_state *cpustate)
@@ -335,11 +349,12 @@
 	}
 }
 
-static UINT32 GetNonTranslatedEA(i386_state *cpustate,UINT8 modrm)
+static UINT32 GetNonTranslatedEA(i386_state *cpustate,UINT8 modrm,UINT8 *seg)
 {
 	UINT8 segment;
 	UINT32 ea;
 	modrm_to_EA(cpustate, modrm, &ea, &segment );
+	if(seg) *seg = segment;
 	return ea;
 }
 
@@ -595,8 +610,10 @@
 		UINT8 CPL = cpustate->CPL, DPL = 0; //, RPL = 0;
 
 		/* 32-bit */
+		cpustate->CPL = 0;
 		v1 = READ32(cpustate, cpustate->idtr.base + entry );
 		v2 = READ32(cpustate, cpustate->idtr.base + entry + 4 );
+		cpustate->CPL = CPL;
 		offset = (v2 & 0xffff0000) | (v1 & 0xffff);
 		segment = (v1 >> 16) & 0xffff;
 		type = (v2>>8) & 0x1F;
@@ -660,6 +677,7 @@
 			/* Get privilege level 0 stack pointer from TSS */
 			cpustate->sreg[SS].selector = i386_get_stack_segment(cpustate,0);
 			REG32(ESP) = i386_get_stack_ptr(cpustate,0);
+			cpustate->CPL = segment & 0x03;
 			i386_load_segment_descriptor(cpustate,SS);
 			PUSH32(cpustate,cpustate->sreg[GS].selector & 0xffff);
 			PUSH32(cpustate,cpustate->sreg[FS].selector & 0xffff);
@@ -685,7 +703,6 @@
 			cpustate->sreg[CS].selector = segment;
 			cpustate->eip = offset;
 			// CPL set to CS RPL?
-			cpustate->CPL = segment & 0x03;
 
 			i386_load_segment_descriptor(cpustate,CS);
 			CHANGE_PC(cpustate,cpustate->eip);
@@ -701,25 +718,25 @@
 			if(segment & 0x04)
 			{
 				logerror("IRQ: Task gate: TSS is not in the GDT.\n");
-				FAULT_EXP(FAULT_TS,segment & ~0x07);
+				FAULT_EXP(FAULT_TS,segment & ~0x03);
 			}
 			else
 			{
 				if(segment > cpustate->gdtr.limit)
 				{
 					logerror("IRQ: Task gate: TSS is past GDT limit.\n");
-					FAULT_EXP(FAULT_TS,segment & ~0x07);
+					FAULT_EXP(FAULT_TS,segment & ~0x03);
 				}
 			}
 			if((desc.flags & 0x000f) != 0x09 && (desc.flags & 0x000f) != 0x01)
 			{
 				logerror("IRQ: Task gate: TSS is not an available TSS.\n");
-				FAULT_EXP(FAULT_TS,segment & ~0x07);
+				FAULT_EXP(FAULT_TS,segment & ~0x03);
 			}
 			if((desc.flags & 0x0080) == 0)
 			{
 				logerror("IRQ: Task gate: TSS is not present.\n");
-				FAULT_EXP(FAULT_NP,segment & ~0x07);
+				FAULT_EXP(FAULT_NP,segment & ~0x03);
 			}
 			if(!(irq == 3 || irq == 4 || irq == 9 || irq_gate == 1))
 				cpustate->eip = cpustate->prev_eip;
@@ -749,7 +766,7 @@
 				if((segment & ~0x07) > cpustate->ldtr.limit)
 				{
 					logerror("IRQ: Gate segment is past LDT limit.\n");
-					FAULT_EXP(FAULT_GP,(segment & 0x07)+cpustate->ext)
+					FAULT_EXP(FAULT_GP,(segment & 0x03)+cpustate->ext)
 				}
 			}
 			else
@@ -757,18 +774,18 @@
 				if((segment & ~0x07) > cpustate->gdtr.limit)
 				{
 					logerror("IRQ: Gate segment is past GDT limit.\n");
-					FAULT_EXP(FAULT_GP,(segment & 0x07)+cpustate->ext)
+					FAULT_EXP(FAULT_GP,(segment & 0x03)+cpustate->ext)
 				}
 			}
 			if((desc.flags & 0x0018) != 0x18)
 			{
 				logerror("IRQ: Gate descriptor is not a code segment.\n");
-				FAULT_EXP(FAULT_GP,(segment & 0x07)+cpustate->ext)
+				FAULT_EXP(FAULT_GP,(segment & 0x03)+cpustate->ext)
 			}
 			if((desc.flags & 0x0080) == 0)
 			{
 				logerror("IRQ: Gate segment is not present.\n");
-				FAULT_EXP(FAULT_NP,(segment & 0x07)+cpustate->ext)
+				FAULT_EXP(FAULT_NP,(segment & 0x03)+cpustate->ext)
 			}
 			if((desc.flags & 0x0004) == 0 && (DPL < CPL))
 			{
@@ -778,17 +795,14 @@
 
 				/* Check new stack segment in TSS */
 				memset(&stack, 0, sizeof(stack));
-				if(flags & 0x0008)
-					stack.selector = i386_get_stack_segment(cpustate,DPL);
-				else
-					stack.selector = i286_get_stack_segment(cpustate,DPL);
+				stack.selector = i386_get_stack_segment(cpustate,DPL);
 				i386_load_protected_mode_segment(cpustate,&stack,NULL);
 				oldSS = cpustate->sreg[SS].selector;
 				if(flags & 0x0008)
 					oldESP = REG32(ESP);
 				else
 					oldESP = REG16(SP);
-				if((stack.selector & ~0x07) == 0)
+				if((stack.selector & ~0x03) == 0)
 				{
 					logerror("IRQ: New stack selector is null.\n");
 					FAULT_EXP(FAULT_GP,cpustate->ext)
@@ -798,7 +812,7 @@
 					if((stack.selector & ~0x07) > cpustate->ldtr.base)
 					{
 						logerror("IRQ: New stack selector is past LDT limit.\n");
-						FAULT_EXP(FAULT_TS,(stack.selector & ~0x07)+cpustate->ext)
+						FAULT_EXP(FAULT_TS,(stack.selector & ~0x03)+cpustate->ext)
 					}
 				}
 				else
@@ -806,32 +820,32 @@
 					if((stack.selector & ~0x07) > cpustate->gdtr.base)
 					{
 						logerror("IRQ: New stack selector is past GDT limit.\n");
-						FAULT_EXP(FAULT_TS,(stack.selector & ~0x07)+cpustate->ext)
+						FAULT_EXP(FAULT_TS,(stack.selector & ~0x03)+cpustate->ext)
 					}
 				}
 				if((stack.selector & 0x03) != DPL)
 				{
 					logerror("IRQ: New stack selector RPL is not equal to code segment DPL.\n");
-					FAULT_EXP(FAULT_TS,(stack.selector & ~0x07)+cpustate->ext)
+					FAULT_EXP(FAULT_TS,(stack.selector & ~0x03)+cpustate->ext)
 				}
 				if(((stack.flags >> 5) & 0x03) != DPL)
 				{
 					logerror("IRQ: New stack segment DPL is not equal to code segment DPL.\n");
-					FAULT_EXP(FAULT_TS,(stack.selector & ~0x07)+cpustate->ext)
+					FAULT_EXP(FAULT_TS,(stack.selector & ~0x03)+cpustate->ext)
 				}
 				if(((stack.flags & 0x0018) != 0x10) && (stack.flags & 0x0002) != 0)
 				{
 					logerror("IRQ: New stack segment is not a writable data segment.\n");
-					FAULT_EXP(FAULT_TS,(stack.selector & ~0x07)+cpustate->ext) // #TS(stack selector + EXT)
+					FAULT_EXP(FAULT_TS,(stack.selector & ~0x03)+cpustate->ext) // #TS(stack selector + EXT)
 				}
 				if((stack.flags & 0x0080) == 0)
 				{
 					logerror("IRQ: New stack segment is not present.\n");
-					FAULT_EXP(FAULT_SS,(stack.selector & ~0x07)+cpustate->ext) // #TS(stack selector + EXT)
+					FAULT_EXP(FAULT_SS,(stack.selector & ~0x03)+cpustate->ext) // #TS(stack selector + EXT)
 				}
+				newESP = i386_get_stack_ptr(cpustate,DPL);
 				if(type & 0x08) // 32-bit gate
 				{
-					newESP = i386_get_stack_ptr(cpustate,DPL);
 					if(newESP < 20)
 					{
 						logerror("IRQ: New stack has no space for return addresses.\n");
@@ -840,7 +854,7 @@
 				}
 				else // 16-bit gate
 				{
-					newESP = i286_get_stack_ptr(cpustate,DPL);
+					newESP &= 0xffff;
 					if(newESP < 10)
 					{
 						logerror("IRQ: New stack has no space for return addresses.\n");
@@ -852,13 +866,17 @@
 					logerror("IRQ: New EIP is past code segment limit.\n");
 					FAULT_EXP(FAULT_GP,0)
 				}
+				/* change CPL before accessing the stack */
+				cpustate->CPL = DPL;
+				/* check for page fault at new stack TODO: check if stack frame crosses page boundary */
+				WRITE_TEST(cpustate, stack.base+newESP-1);
 				/* Load new stack segment descriptor */
 				cpustate->sreg[SS].selector = stack.selector;
 				i386_load_segment_descriptor(cpustate,SS);
 				if(flags & 0x0008)
 					REG32(ESP) = i386_get_stack_ptr(cpustate,DPL);
 				else
-					REG16(SP) = i286_get_stack_ptr(cpustate,DPL);
+					REG16(SP) = i386_get_stack_ptr(cpustate,DPL);
 				if(type & 0x08)
 				{
 					// 32-bit gate
@@ -871,7 +889,6 @@
 					PUSH16(cpustate,oldSS);
 					PUSH16(cpustate,oldESP);
 				}
-				cpustate->CPL = DPL;
 				SetRPL = 1;
 			}
 			else
@@ -950,6 +967,8 @@
 		{
 			UINT32 entry = irq * 8;
 			UINT32 v2,type;
+			int cpl = cpustate->CPL;
+			cpustate->CPL = 0;
 			v2 = READ32(cpustate, cpustate->idtr.base + entry + 4 );
 			type = (v2>>8) & 0x1F;
 			if(type == 5)
@@ -958,6 +977,7 @@
 				v2 = READ32(cpustate, cpustate->gdtr.base + ((v2 >> 16) & 0xfff8) + 4);
 				type = (v2>>8) & 0x1F;
 			}
+			cpustate->CPL = cpl;
 			if(type >= 9)
 				PUSH32(cpustate,error);
 			else
@@ -1135,6 +1155,7 @@
 	cpustate->cr[0] |= 0x08;
 
 	/* Load incoming task state from the new task's TSS */
+	cpustate->CPL = 0;
 	tss = cpustate->task.base;
 	cpustate->ldtr.segment = READ32(cpustate,tss+0x60) & 0xffff;
 	seg.selector = cpustate->ldtr.segment;
@@ -1350,19 +1371,17 @@
 				}
 				if(call_gate.selector & 0x04)
 				{
-					/* check GDT limit */
-					if((call_gate.selector & ~0x07) > cpustate->gdtr.limit)
+					if((call_gate.selector & ~0x07) > cpustate->ldtr.limit)
 					{
-						logerror("JMP: Call Gate: Gate Selector is past GDT segment limit\n");
+						logerror("JMP: Call Gate: Gate Selector is past LDT segment limit\n");
 						FAULT(FAULT_GP,call_gate.selector & 0xfffc)
 					}
 				}
 				else
 				{
-					/* check LDT limit */
-					if((call_gate.selector & ~0x07) > cpustate->ldtr.limit)
+					if((call_gate.selector & ~0x07) > cpustate->gdtr.limit)
 					{
-						logerror("JMP: Call Gate: Gate Selector is past LDT segment limit\n");
+						logerror("JMP: Call Gate: Gate Selector is past GDT segment limit\n");
 						FAULT(FAULT_GP,call_gate.selector & 0xfffc)
 					}
 				}
@@ -1637,7 +1656,7 @@
 					FAULT(FAULT_NP,desc.selector & ~0x03)  // #GP(selector)
 				}
 				desc.selector = gate.selector;
-				if((gate.selector & ~0x07) == 0)
+				if((gate.selector & ~0x03) == 0)
 				{
 					logerror("CALL: Call gate: Segment is null.\n");
 					FAULT(FAULT_GP,0)  // #GP(0)
@@ -1683,12 +1702,9 @@
 					/* more privilege */
 					/* Check new SS segment for privilege level from TSS */
 					memset(&stack, 0, sizeof(stack));
-					if(operand32 != 0)
-						stack.selector = i386_get_stack_segment(cpustate,DPL);
-					else
-						stack.selector = i286_get_stack_segment(cpustate,DPL);
+					stack.selector = i386_get_stack_segment(cpustate,DPL);
 					i386_load_protected_mode_segment(cpustate,&stack,NULL);
-					if((stack.selector & ~0x07) == 0)
+					if((stack.selector & ~0x03) == 0)
 					{
 						logerror("CALL: Call gate: TSS selector is null\n");
 						FAULT(FAULT_TS,0)  // #TS(0)
@@ -1729,9 +1745,9 @@
 						logerror("CALL: Call gate: Stack segment is not present\n");
 						FAULT(FAULT_SS,stack.selector)  // #SS(SS selector)
 					}
+					UINT32 newESP = i386_get_stack_ptr(cpustate,DPL);
 					if(operand32 != 0)
 					{
-						UINT32 newESP = i386_get_stack_ptr(cpustate,DPL);
 						if(newESP < ((gate.dword_count & 0x1f) + 16))
 						{
 							logerror("CALL: Call gate: New stack has no room for 32-bit return address and parameters.\n");
@@ -1745,7 +1761,7 @@
 					}
 					else
 					{
-						UINT32 newESP = i286_get_stack_ptr(cpustate,DPL) & 0x0000ffff;
+						newESP &= 0x0000ffff;
 						if(newESP < ((gate.dword_count & 0x1f) + 8))
 						{
 							logerror("CALL: Call gate: New stack has no room for 16-bit return address and parameters.\n");
@@ -1760,23 +1776,25 @@
 					selector = gate.selector;
 					offset = gate.offset;
 
+					cpustate->CPL = (stack.flags >> 5) & 0x03;
+					/* check for page fault at new stack TODO: check if stack frame crosses page boundary */
+					WRITE_TEST(cpustate, stack.base+newESP-1);
 					/* switch to new stack */
 					oldSS = cpustate->sreg[SS].selector;
+					cpustate->sreg[SS].selector = i386_get_stack_segment(cpustate,gate.selector & 0x03);
 					if(operand32 != 0)
 					{
 						oldESP = REG32(ESP);
-						cpustate->sreg[SS].selector = i386_get_stack_segment(cpustate,gate.selector & 0x03);
 					}
 					else
 					{
 						oldESP = REG16(SP);
-						cpustate->sreg[SS].selector = i286_get_stack_segment(cpustate,gate.selector & 0x03);
 					}
 					i386_load_segment_descriptor(cpustate, SS );
 					if(operand32 != 0)
 						REG32(ESP) = i386_get_stack_ptr(cpustate,gate.selector & 0x03);
 					else
-						REG16(SP) = i286_get_stack_ptr(cpustate,gate.selector & 0x03) & 0x0000ffff;
+						REG16(SP) = i386_get_stack_ptr(cpustate,gate.selector & 0x03) & 0x0000ffff;
 
 					if(operand32 != 0)
 					{
@@ -1795,10 +1813,13 @@
 					/* copy parameters from old stack to new stack */
 					for(x=(gate.dword_count & 0x1f)-1;x>=0;x--)
 					{
-						UINT32 addr = temp.base + oldESP + (x*2);
-						PUSH16(cpustate,READ16(cpustate,addr));
+						UINT32 addr = oldESP + (operand32?(x*4):(x*2));
+						addr = temp.base + (temp.d?addr:(addr&0xffff));
+						if(operand32)
+							PUSH32(cpustate,READ32(cpustate,addr));
+						else
+							PUSH16(cpustate,READ16(cpustate,addr));
 					}
-					cpustate->CPL = (stack.flags >> 5) & 0x03;
 					SetRPL = 1;
 				}
 				else
@@ -1841,17 +1862,17 @@
 				if(DPL < CPL)
 				{
 					logerror("CALL: Task Gate: Gate DPL is less than CPL.\n");
-					FAULT(FAULT_TS,selector & ~0x07) // #TS(selector)
+					FAULT(FAULT_TS,selector & ~0x03) // #TS(selector)
 				}
 				if(DPL < RPL)
 				{
 					logerror("CALL: Task Gate: Gate DPL is less than RPL.\n");
-					FAULT(FAULT_TS,selector & ~0x07) // #TS(selector)
+					FAULT(FAULT_TS,selector & ~0x03) // #TS(selector)
 				}
 				if(gate.ar & 0x0080)
 				{
 					logerror("CALL: Task Gate: Gate is not present.\n");
-					FAULT(FAULT_NP,selector & ~0x07) // #NP(selector)
+					FAULT(FAULT_NP,selector & ~0x03) // #NP(selector)
 				}
 				/* Check the TSS that the task gate points to */
 				desc.selector = gate.selector;
@@ -1859,25 +1880,25 @@
 				if(gate.selector & 0x04)
 				{
 					logerror("CALL: Task Gate: TSS is not global.\n");
-					FAULT(FAULT_TS,gate.selector & ~0x07) // #TS(selector)
+					FAULT(FAULT_TS,gate.selector & ~0x03) // #TS(selector)
 				}
 				else
 				{
 					if((gate.selector & ~0x07) > cpustate->gdtr.limit)
 					{
 						logerror("CALL: Task Gate: TSS is past GDT limit.\n");
-						FAULT(FAULT_TS,gate.selector & ~0x07) // #TS(selector)
+						FAULT(FAULT_TS,gate.selector & ~0x03) // #TS(selector)
 					}
 				}
 				if(desc.flags & 0x0002)
 				{
 					logerror("CALL: Task Gate: TSS is busy.\n");
-					FAULT(FAULT_TS,gate.selector & ~0x07) // #TS(selector)
+					FAULT(FAULT_TS,gate.selector & ~0x03) // #TS(selector)
 				}
 				if(desc.flags & 0x0080)
 				{
 					logerror("CALL: Task Gate: TSS is not present.\n");
-					FAULT(FAULT_NP,gate.selector & ~0x07) // #TS(selector)
+					FAULT(FAULT_NP,gate.selector & ~0x03) // #TS(selector)
 				}
 				if(desc.flags & 0x08)
 					i386_task_switch(cpustate,desc.selector,1);  // with nesting
@@ -1980,17 +2001,17 @@
 		}
 		if(desc.flags & 0x0004)
 		{
-			if(DPL > CPL)
+			if(DPL > RPL)
 			{
-				logerror("RETF: Conforming code segment DPL is greater than CPL.\n");
+				logerror("RETF: Conforming code segment DPL is greater than CS RPL.\n");
 				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
 		else
 		{
-			if(DPL != CPL)
+			if(DPL != RPL)
 			{
-				logerror("RETF: Non-conforming code segment DPL does not equal CPL.\n");
+				logerror("RETF: Non-conforming code segment DPL does not equal CS RPL.\n");
 				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
@@ -2060,7 +2081,7 @@
 			if((newCS & ~0x07) >= cpustate->ldtr.limit)
 			{
 				logerror("RETF: CS segment selector is past LDT limit.\n");
-				FAULT(FAULT_GP,newCS & ~0x07)
+				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
 		else
@@ -2068,20 +2089,20 @@
 			if((newCS & ~0x07) >= cpustate->gdtr.limit)
 			{
 				logerror("RETF: CS segment selector is past GDT limit.\n");
-				FAULT(FAULT_GP,newCS & ~0x07)
+				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
 		if((desc.flags & 0x0018) != 0x0018)
 		{
 			logerror("RETF: CS segment is not a code segment.\n");
-			FAULT(FAULT_GP,newCS & ~0x07)
+			FAULT(FAULT_GP,newCS & ~0x03)
 		}
 		if(desc.flags & 0x0004)
 		{
 			if(DPL > RPL)
 			{
 				logerror("RETF: Conforming CS segment DPL is greater than return selector RPL.\n");
-				FAULT(FAULT_GP,newCS & ~0x07)
+				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
 		else
@@ -2089,13 +2110,13 @@
 			if(DPL != RPL)
 			{
 				logerror("RETF: Non-conforming CS segment DPL is not equal to return selector RPL.\n");
-				FAULT(FAULT_GP,newCS & ~0x07)
+				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 		}
 		if((desc.flags & 0x0080) == 0)
 		{
 			logerror("RETF: CS segment is not present.\n");
-			FAULT(FAULT_NP,newCS & ~0x07)
+			FAULT(FAULT_NP,newCS & ~0x03)
 		}
 		if(newEIP > desc.limit)
 		{
@@ -2130,7 +2151,7 @@
 			if((newSS & ~0x07) > cpustate->ldtr.limit)
 			{
 				logerror("RETF (%08x): SS segment selector is past LDT limit.\n",cpustate->pc);
-				FAULT(FAULT_GP,newSS & ~0x07)
+				FAULT(FAULT_GP,newSS & ~0x03)
 			}
 		}
 		else
@@ -2138,28 +2159,28 @@
 			if((newSS & ~0x07) > cpustate->gdtr.limit)
 			{
 				logerror("RETF (%08x): SS segment selector is past GDT limit.\n",cpustate->pc);
-				FAULT(FAULT_GP,newSS & ~0x07)
+				FAULT(FAULT_GP,newSS & ~0x03)
 			}
 		}
 		if((newSS & 0x03) != RPL)
 		{
 			logerror("RETF: SS segment RPL is not equal to CS segment RPL.\n");
-			FAULT(FAULT_GP,newSS & ~0x07)
+			FAULT(FAULT_GP,newSS & ~0x03)
 		}
 		if((desc.flags & 0x0018) != 0x0010 || (desc.flags & 0x0002) == 0)
 		{
 			logerror("RETF: SS segment is not a writable data segment.\n");
-			FAULT(FAULT_GP,newSS & ~0x07)
+			FAULT(FAULT_GP,newSS & ~0x03)
 		}
 		if(((desc.flags >> 5) & 0x03) != RPL)
 		{
 			logerror("RETF: SS DPL is not equal to CS segment RPL.\n");
-			FAULT(FAULT_GP,newSS & ~0x07)
+			FAULT(FAULT_GP,newSS & ~0x03)
 		}
 		if((desc.flags & 0x0080) == 0)
 		{
 			logerror("RETF: SS segment is not present.\n");
-			FAULT(FAULT_GP,newSS & ~0x07)
+			FAULT(FAULT_GP,newSS & ~0x03)
 		}
 		cpustate->CPL = newCS & 0x03;
 
@@ -2248,12 +2269,12 @@
 		if(task & 0x04)
 		{
 			logerror("IRET: Task return: Back-linked TSS is not in GDT.\n");
-			FAULT(FAULT_TS,task & ~0x07)
+			FAULT(FAULT_TS,task & ~0x03)
 		}
 		if((task & ~0x07) >= cpustate->gdtr.limit)
 		{
 			logerror("IRET: Task return: Back-linked TSS is not in GDT.\n");
-			FAULT(FAULT_TS,task & ~0x07)
+			FAULT(FAULT_TS,task & ~0x03)
 		}
 		memset(&desc, 0, sizeof(desc));
 		desc.selector = task;
@@ -2261,12 +2282,12 @@
 		if((desc.flags & 0x001f) != 0x000b)
 		{
 			logerror("IRET (%08x): Task return: Back-linked TSS is not a busy TSS.\n",cpustate->pc);
-			FAULT(FAULT_TS,task & ~0x07)
+			FAULT(FAULT_TS,task & ~0x03)
 		}
 		if((desc.flags & 0x0080) == 0)
 		{
 			logerror("IRET: Task return: Back-linked TSS is not present.\n");
-			FAULT(FAULT_NP,task & ~0x07)
+			FAULT(FAULT_NP,task & ~0x03)
 		}
 		if(desc.flags & 0x08)
 			i386_task_switch(cpustate,desc.selector,0);
@@ -2461,7 +2482,7 @@
 			if(RPL < CPL)
 			{
 				logerror("IRET (%08x): Return CS RPL is less than CPL.\n",cpustate->pc);
-				FAULT(FAULT_GP,newCS & ~0x07)
+				FAULT(FAULT_GP,newCS & ~0x03)
 			}
 			if(RPL == CPL)
 			{
@@ -2494,7 +2515,7 @@
 					if((newCS & ~0x07) >= cpustate->ldtr.limit)
 					{
 						logerror("IRET: Return CS selector (%04x) is past LDT limit.\n",newCS);
-						FAULT(FAULT_GP,newCS & ~0x07)
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				else
@@ -2502,7 +2523,7 @@
 					if((newCS & ~0x07) >= cpustate->gdtr.limit)
 					{
 						logerror("IRET: Return CS selector is past GDT limit.\n");
-						FAULT(FAULT_GP,newCS & ~0x07)
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				memset(&desc, 0, sizeof(desc));
@@ -2517,24 +2538,24 @@
 				}
 				if(desc.flags & 0x0004)
 				{
-					if(DPL > CPL)
+					if(DPL > RPL)
 					{
-						logerror("IRET: Conforming return CS DPL is greater than CPL.\n");
-						FAULT(FAULT_GP,newCS & ~0x07)
+						logerror("IRET: Conforming return CS DPL is greater than CS RPL.\n");
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				else
 				{
-					if(DPL != CPL)
+					if(DPL != RPL)
 					{
-						logerror("IRET: Non-conforming return CS DPL is not equal to CPL.\n");
-						FAULT(FAULT_GP,newCS & ~0x07)
+						logerror("IRET: Non-conforming return CS DPL is not equal to CS RPL.\n");
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				if((desc.flags & 0x0080) == 0)
 				{
 					logerror("IRET: Return CS segment is not present.\n");
-					FAULT(FAULT_NP,newCS & ~0x07)
+					FAULT(FAULT_NP,newCS & ~0x03)
 				}
 				if(newEIP > desc.limit)
 				{
@@ -2600,7 +2621,7 @@
 					if((newCS & ~0x07) >= cpustate->ldtr.limit)
 					{
 						logerror("IRET: Return CS selector is past LDT limit.\n");
-						FAULT(FAULT_GP,newCS & ~0x07);
+						FAULT(FAULT_GP,newCS & ~0x03);
 					}
 				}
 				else
@@ -2608,20 +2629,20 @@
 					if((newCS & ~0x07) >= cpustate->gdtr.limit)
 					{
 						logerror("IRET: Return CS selector is past GDT limit.\n");
-						FAULT(FAULT_GP,newCS & ~0x07);
+						FAULT(FAULT_GP,newCS & ~0x03);
 					}
 				}
 				if((desc.flags & 0x0018) != 0x0018)
 				{
 					logerror("IRET: Return CS segment is not a code segment.\n");
-					FAULT(FAULT_GP,newCS & ~0x07)
+					FAULT(FAULT_GP,newCS & ~0x03)
 				}
 				if(desc.flags & 0x0004)
 				{
-					if(DPL <= CPL)
+					if(DPL > RPL)
 					{
-						logerror("IRET: Conforming return CS DPL is not greater than CPL.\n");
-						FAULT(FAULT_GP,newCS & ~0x07)
+						logerror("IRET: Conforming return CS DPL is greater than CS RPL.\n");
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				else
@@ -2629,13 +2650,13 @@
 					if(DPL != RPL)
 					{
 						logerror("IRET: Non-conforming return CS DPL does not equal CS RPL.\n");
-						FAULT(FAULT_GP,newCS & ~0x07)
+						FAULT(FAULT_GP,newCS & ~0x03)
 					}
 				}
 				if((desc.flags & 0x0080) == 0)
 				{
 					logerror("IRET: Return CS segment is not present.\n");
-					FAULT(FAULT_NP,newCS & ~0x07)
+					FAULT(FAULT_NP,newCS & ~0x03)
 				}
 
 				/* Check SS selector and descriptor */
@@ -2663,7 +2684,7 @@
 					if((newSS & ~0x07) >= cpustate->ldtr.limit)
 					{
 						logerror("IRET: Return SS selector is past LDT limit.\n");
-						FAULT(FAULT_GP,newSS & ~0x07);
+						FAULT(FAULT_GP,newSS & ~0x03);
 					}
 				}
 				else
@@ -2671,33 +2692,33 @@
 					if((newSS & ~0x07) >= cpustate->gdtr.limit)
 					{
 						logerror("IRET: Return SS selector is past GDT limit.\n");
-						FAULT(FAULT_GP,newSS & ~0x07);
+						FAULT(FAULT_GP,newSS & ~0x03);
 					}
 				}
 				if((newSS & 0x03) != RPL)
 				{
 					logerror("IRET: Return SS RPL is not equal to return CS RPL.\n");
-					FAULT(FAULT_GP,newSS & ~0x07)
+					FAULT(FAULT_GP,newSS & ~0x03)
 				}
 				if((stack.flags & 0x0018) != 0x0010)
 				{
 					logerror("IRET: Return SS segment is not a data segment.\n");
-					FAULT(FAULT_GP,newSS & ~0x07)
+					FAULT(FAULT_GP,newSS & ~0x03)
 				}
 				if((stack.flags & 0x0002) == 0)
 				{
 					logerror("IRET: Return SS segment is not writable.\n");
-					FAULT(FAULT_GP,newSS & ~0x07)
+					FAULT(FAULT_GP,newSS & ~0x03)
 				}
 				if(DPL != RPL)
 				{
 					logerror("IRET: Return SS DPL does not equal SS RPL.\n");
-					FAULT(FAULT_GP,newSS & ~0x07)
+					FAULT(FAULT_GP,newSS & ~0x03)
 				}
 				if((stack.flags & 0x0080) == 0)
 				{
 					logerror("IRET: Return SS segment is not present.\n");
-					FAULT(FAULT_NP,newSS & ~0x07)
+					FAULT(FAULT_NP,newSS & ~0x03)
 				}
 				if(newEIP > desc.limit)
 				{
@@ -3126,7 +3147,7 @@
 		cpustate->address_prefix = 0;
 
 		cpustate->ext = 1;
-		cpustate->old_tf = cpustate->TF;
+		int old_tf = cpustate->TF;
 
 		cpustate->segment_prefix = 0;
 		cpustate->prev_eip = cpustate->eip;
@@ -3141,7 +3162,7 @@
 		try
 		{
 			I386OP(decode_opcode)(cpustate);
-			if(cpustate->TF && cpustate->old_tf)
+			if(cpustate->TF && old_tf)
 			{
 				cpustate->prev_eip = cpustate->eip;
 				cpustate->ext = 1;
diff -Nru src-old/emu/cpu/i386/i386op16.c src/emu/cpu/i386/i386op16.c
--- src-old/emu/cpu/i386/i386op16.c	2012-03-09 23:54:29.000000000 +0100
+++ src/emu/cpu/i386/i386op16.c	2012-05-03 11:16:42.000000000 +0200
@@ -365,10 +365,11 @@
 
 		CYCLES(cpustate,CYCLES_BT_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,0);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),0);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -397,10 +398,11 @@
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTC_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -431,10 +433,11 @@
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTR_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -465,10 +468,11 @@
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTS_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -877,7 +881,7 @@
 static void I386OP(jge_rel16)(i386_state *cpustate)			// Opcode 0x0f 8d
 {
 	INT16 disp = FETCH16(cpustate);
-	if( (cpustate->SF == cpustate->OF) ) {
+	if(cpustate->SF == cpustate->OF) {
 		if (cpustate->sreg[CS].d)
 		{
 			cpustate->eip += disp;
@@ -1161,7 +1165,7 @@
 static void I386OP(lea16)(i386_state *cpustate)				// Opcode 0x8d
 {
 	UINT8 modrm = FETCH(cpustate);
-	UINT32 ea = GetNonTranslatedEA(cpustate,modrm);
+	UINT32 ea = GetNonTranslatedEA(cpustate,modrm,NULL);
 	STORE_REG16(modrm, ea);
 	CYCLES(cpustate,CYCLES_LEA);
 }
diff -Nru src-old/emu/cpu/i386/i386op32.c src/emu/cpu/i386/i386op32.c
--- src-old/emu/cpu/i386/i386op32.c	2012-03-09 23:54:29.000000000 +0100
+++ src/emu/cpu/i386/i386op32.c	2012-05-03 11:16:42.000000000 +0200
@@ -341,10 +341,11 @@
 
 		CYCLES(cpustate,CYCLES_BT_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,0);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),0);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -373,10 +374,11 @@
 		STORE_RM32(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTC_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -407,10 +409,11 @@
 		STORE_RM32(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTR_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -441,10 +444,11 @@
 		STORE_RM32(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTS_REG_REG);
 	} else {
-		UINT32 ea = GetEA(cpustate,modrm,1);
+		UINT8 segment;
+		UINT32 ea = GetNonTranslatedEA(cpustate,modrm,&segment);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
-		ea = (cpustate->address_size)?ea:(ea&0xffff);
+		ea = i386_translate(cpustate,segment,(cpustate->address_size)?ea:(ea&0xffff),1);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -816,7 +820,7 @@
 static void I386OP(jge_rel32)(i386_state *cpustate)			// Opcode 0x0f 8d
 {
 	INT32 disp = FETCH32(cpustate);
-	if( (cpustate->SF == cpustate->OF) ) {
+	if(cpustate->SF == cpustate->OF) {
 		cpustate->eip += disp;
 		CHANGE_PC(cpustate,cpustate->eip);
 		CYCLES(cpustate,CYCLES_JCC_FULL_DISP);		/* TODO: Timing = 7 + m */
@@ -1002,7 +1006,7 @@
 static void I386OP(lea32)(i386_state *cpustate)				// Opcode 0x8d
 {
 	UINT8 modrm = FETCH(cpustate);
-	UINT32 ea = GetNonTranslatedEA(cpustate,modrm);
+	UINT32 ea = GetNonTranslatedEA(cpustate,modrm,NULL);
 	if (!cpustate->address_size)
 	{
 		ea &= 0xffff;
diff -Nru src-old/emu/cpu/i386/i386ops.c src/emu/cpu/i386/i386ops.c
--- src-old/emu/cpu/i386/i386ops.c	2012-03-09 23:54:29.000000000 +0100
+++ src/emu/cpu/i386/i386ops.c	2012-05-03 11:16:42.000000000 +0200
@@ -449,7 +449,7 @@
 static void I386OP(jge_rel8)(i386_state *cpustate)			// Opcode 0x7d
 {
 	INT8 disp = FETCH(cpustate);
-	if( (cpustate->SF == cpustate->OF) ) {
+	if(cpustate->SF == cpustate->OF) {
 		NEAR_BRANCH(cpustate,disp);
 		CYCLES(cpustate,CYCLES_JCC_DISP8);		/* TODO: Timing = 7 + m */
 	} else {
@@ -1411,7 +1411,7 @@
 {
 	UINT8 modrm = FETCH(cpustate);
 	UINT8 value = 0;
-	if( (cpustate->SF == cpustate->OF) ) {
+	if(cpustate->SF == cpustate->OF) {
 		value = 1;
 	}
 	if( modrm >= 0xc0 ) {
diff -Nru src-old/emu/cpu/i386/i386priv.h src/emu/cpu/i386/i386priv.h
--- src-old/emu/cpu/i386/i386priv.h	2012-04-10 22:13:30.000000000 +0200
+++ src/emu/cpu/i386/i386priv.h	2012-05-03 07:58:32.000000000 +0200
@@ -240,7 +240,6 @@
 
 	UINT8 performed_intersegment_jump;
 	UINT8 delayed_interrupt_enable;
-	UINT8 old_tf;
 
 	UINT32 cr[5];		// Control registers
 	UINT32 dr[8];		// Debug registers
@@ -419,18 +418,19 @@
 	UINT32 offset = a & 0xfff;
 	UINT32 page_entry;
 	UINT32 ret = 1;
+	bool user = (cpustate->CPL == 3);
 	*error = 0;
 
 	// TODO: cr0 wp bit, 486 and higher
 	UINT32 page_dir = cpustate->program->read_dword(pdbr + directory * 4);
-	if(page_dir & 1)
+	if((page_dir & 1) && ((page_dir & 4) || !user))
 	{
 		if (!(cpustate->cr[4] & 0x10))
 		{
 			page_entry = cpustate->program->read_dword((page_dir & 0xfffff000) + (table * 4));
 			if(!(page_entry & 1))
 				ret = 0;
-			else if(!(page_entry & 2) && cpustate->CPL && (rwn == 1))
+			else if((!(page_entry & 2) && user && (rwn == 1)) || (!(page_entry & 4) && user))
 			{
 				*error = 1;
 				ret = 0;
@@ -450,7 +450,7 @@
 		{
 			if (page_dir & 0x80)
 			{
-				if(!(page_dir & 2) && cpustate->CPL && (rwn == 1))
+				if(!(page_dir & 2) && user && (rwn == 1))
 				{
 					*error = 1;
 					ret = 0;
@@ -469,7 +469,7 @@
 				page_entry = cpustate->program->read_dword((page_dir & 0xfffff000) + (table * 4));
 				if(!(page_entry & 1))
 					ret = 0;
-				else if(!(page_entry & 2) && cpustate->CPL && (rwn == 1))
+				else if((!(page_entry & 2) && user && (rwn == 1)) || (!(page_entry & 4) && user))
 				{
 					*error = 1;
 					ret = 0;
@@ -488,11 +488,15 @@
 		}
 	}
 	else
+	{
+		if(page_dir & 1)
+			*error = 1;
 		ret = 0;
+	}
 	if(!ret)
 	{
 		if(rwn != -1)
-			*error |= ((rwn & 1)<<1) | ((cpustate->CPL==3)?1<<2:0);
+			*error |= ((rwn & 1)<<1) | (user<<2);
 		return 0;
 	}
 	return 1;
@@ -672,6 +676,16 @@
 	return value;
 }
 
+INLINE void WRITE_TEST(i386_state *cpustate,UINT32 ea)
+{
+	UINT32 address = ea, error;
+	if (cpustate->cr[0] & 0x80000000)		// page translation enabled
+	{
+		if(!translate_address(cpustate,1,&address,&error))
+			PF_THROW(error);
+	}
+}
+
 INLINE void WRITE8(i386_state *cpustate,UINT32 ea, UINT8 value)
 {
 	UINT32 address = ea, error;
diff -Nru src-old/emu/cpu/m68000/m68000.h src/emu/cpu/m68000/m68000.h
--- src-old/emu/cpu/m68000/m68000.h	2012-04-17 05:39:11.000000000 +0200
+++ src/emu/cpu/m68000/m68000.h	2012-04-30 19:19:12.000000000 +0200
@@ -142,6 +142,7 @@
 
 void m68307_set_port_callbacks(device_t *device, m68307_porta_read_callback porta_r, m68307_porta_write_callback m_m68307_porta_w, m68307_portb_read_callback portb_r, m68307_portb_write_callback m_m68307_portb_w);
 UINT16 m68307_get_cs(device_t *device, offs_t address);
+UINT16 m68340_get_cs(device_t *device, offs_t address);
 void m68307_set_interrupt(device_t *device, int level, int vector);
 void m68307_timer0_interrupt(legacy_cpu_device *cpudev);
 void m68307_timer1_interrupt(legacy_cpu_device *cpudev);
diff -Nru src-old/emu/cpu/m68000/m68kcpu.c src/emu/cpu/m68000/m68kcpu.c
--- src-old/emu/cpu/m68000/m68kcpu.c	2012-04-17 05:39:11.000000000 +0200
+++ src/emu/cpu/m68000/m68kcpu.c	2012-04-30 19:19:12.000000000 +0200
@@ -1318,6 +1318,10 @@
 	write32 = m68k_write32_delegate(FUNC(address_space::write_dword), &space);
 }
 
+/* todo: is it possible to calculate the address map based on CS when they change
+   and install handlers?  Going through this logic for every memory access is
+   very slow */
+
 int m68307_calc_cs(m68ki_cpu_core *m68k, offs_t address)
 {
 	m68307_sim* sim = m68k->m68307SIM;
@@ -1333,6 +1337,32 @@
 	return 0;
 }
 
+/* see note above */
+
+int m68340_calc_cs(m68ki_cpu_core *m68k, offs_t address)
+{
+	m68340_sim* sim = m68k->m68340SIM;
+
+	if ( !(sim->m_ba[0] & 1) ) return 1;
+
+	for (int i=0;i<4;i++)
+	{
+		if (sim->m_ba[i] & 1)
+		{
+			int mask = ((sim->m_am[i]&0xffffff00) | 0xff);
+			int base = sim->m_ba[i] & 0xffffff00;
+			int fcmask = (sim->m_am[i] & 0xf0);
+			int fcbase = (sim->m_ba[i] & 0xf0) & ~(sim->m_am[i] & 0xf0);
+			int fc = m68k->mmu_tmp_fc;
+
+			if ((address & ~mask) == base && ((fc << 4) & ~fcmask ) == fcbase ) return i+1;
+		}
+	}
+
+	return 0;
+}
+
+
 
 
 UINT16 m68k_memory_interface::simple_read_immediate_16_m68307(offs_t address)
@@ -1820,6 +1850,15 @@
 	return m68k->m68307_currentcs;
 }
 
+UINT16 m68340_get_cs(device_t *device, offs_t address)
+{
+	m68ki_cpu_core *m68k = m68k_get_safe_token(device);
+
+	m68k->m68307_currentcs = m68340_calc_cs(m68k, address);
+
+	return m68k->m68307_currentcs;
+}
+
 /****************************************************************************
  * State definition
  ****************************************************************************/
diff -Nru src-old/emu/cpu/m68000/m68kcpu.h src/emu/cpu/m68000/m68kcpu.h
--- src-old/emu/cpu/m68000/m68kcpu.h	2012-04-10 22:13:30.000000000 +0200
+++ src/emu/cpu/m68000/m68kcpu.h	2012-05-03 11:16:42.000000000 +0200
@@ -1580,7 +1580,7 @@
 /* Format 8 stack frame (68010).
  * 68010 only.  This is the 29 word bus/address error frame.
  */
-void m68ki_stack_frame_1000(m68ki_cpu_core *m68k, UINT32 pc, UINT32 sr, UINT32 vector)
+INLINE void m68ki_stack_frame_1000(m68ki_cpu_core *m68k, UINT32 pc, UINT32 sr, UINT32 vector)
 {
 	/* VERSION
      * NUMBER
@@ -1634,7 +1634,7 @@
  * if the error happens at an instruction boundary.
  * PC stacked is address of next instruction.
  */
-void m68ki_stack_frame_1010(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
+INLINE void m68ki_stack_frame_1010(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
 	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
 	int orig_fc = m68k->mmu_tmp_buserror_fc;
@@ -1686,7 +1686,7 @@
  * if the error happens during instruction execution.
  * PC stacked is address of instruction in progress.
  */
-void m68ki_stack_frame_1011(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
+INLINE void m68ki_stack_frame_1011(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
 	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
 	int orig_fc = m68k->mmu_tmp_buserror_fc;
@@ -1760,7 +1760,7 @@
  * This is used by the 68040 for bus fault and mmu trap
  * 30 words
  */
-void m68ki_stack_frame_0111(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address, bool in_mmu)
+INLINE void m68ki_stack_frame_0111(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address, bool in_mmu)
 {
 	int orig_rw = m68k->mmu_tmp_buserror_rw;	// this gets splatted by the following pushes, so save it now
 	int orig_fc = m68k->mmu_tmp_buserror_fc;
@@ -1955,7 +1955,7 @@
 
 
 /* Service an interrupt request and start exception processing */
-void m68ki_exception_interrupt(m68ki_cpu_core *m68k, UINT32 int_level)
+INLINE void m68ki_exception_interrupt(m68ki_cpu_core *m68k, UINT32 int_level)
 {
 	UINT32 vector;
 	UINT32 sr;
diff -Nru src-old/emu/crsshair.c src/emu/crsshair.c
--- src-old/emu/crsshair.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/crsshair.c	2012-05-03 11:00:08.000000000 +0200
@@ -221,11 +221,11 @@
 	global.auto_time = CROSSHAIR_VISIBILITY_AUTOTIME_DEFAULT;
 
 	/* determine who needs crosshairs */
-	for (input_port_config *port = machine.ioport().first_port(); port != NULL; port = port->next())
-		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->crossaxis != CROSSHAIR_AXIS_NONE)
+	for (ioport_port *port = machine.ioport().first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->crosshair_axis() != CROSSHAIR_AXIS_NONE)
 			{
-				int player = field->player;
+				int player = field->player();
 
 				assert(player < MAX_PLAYERS);
 
@@ -347,7 +347,7 @@
 	{
 		/* read all the lightgun values */
 		if (global.used[player])
-			input_port_get_crosshair_position(device.machine(), player, &global.x[player], &global.y[player]);
+			device.machine().ioport().crosshair_position(player, global.x[player], global.y[player]);
 
 		/* auto visibility */
 		if (global.mode[player] == CROSSHAIR_VISIBILITY_AUTO)
diff -Nru src-old/emu/devcb.c src/emu/devcb.c
--- src-old/emu/devcb.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/devcb.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 class devcb_resolver
 {
 public:
-	static const input_port_config *resolve_port(const char *tag, device_t &current);
+	static ioport_port *resolve_port(const char *tag, device_t &current);
 	static device_t *resolve_device(int index, const char *tag, device_t &current);
 	static device_execute_interface *resolve_execute_interface(const char *tag, device_t &current);
 	static address_space *resolve_space(int index, const char *tag, device_t &current);
@@ -80,10 +80,10 @@
 //  based on the provided tag
 //-------------------------------------------------
 
-const input_port_config *devcb_resolver::resolve_port(const char *tag, device_t &current)
+ioport_port *devcb_resolver::resolve_port(const char *tag, device_t &current)
 {
 	astring fullname;
-	const input_port_config *result = current.ioport(current.siblingtag(fullname, tag));
+	ioport_port *result = current.ioport(current.siblingtag(fullname, tag));
 	if (result == NULL)
 		throw emu_fatalerror("Unable to find input port '%s' (requested by %s '%s')", fullname.cstr(), current.name(), current.tag());
 	return result;
@@ -221,7 +221,7 @@
 
 int devcb_resolved_read_line::from_port()
 {
-	return (input_port_read_direct(m_object.port) & 1) ? ASSERT_LINE : CLEAR_LINE;
+	return (m_object.port->read() & 1) ? ASSERT_LINE : CLEAR_LINE;
 }
 
 
@@ -325,7 +325,7 @@
 
 void devcb_resolved_write_line::to_port(int state)
 {
-	input_port_write_direct(m_object.port, state, 0xffffffff);
+	m_object.port->write(state, 0xffffffff);
 }
 
 
@@ -419,7 +419,7 @@
 
 UINT8 devcb_resolved_read8::from_port(offs_t offset)
 {
-	return input_port_read_direct(m_object.port);
+	return m_object.port->read();
 }
 
 
@@ -522,7 +522,7 @@
 
 void devcb_resolved_write8::to_port(offs_t offset, UINT8 data)
 {
-	input_port_write_direct(m_object.port, data, 0xff);
+	m_object.port->write(data, 0xff);
 }
 
 
@@ -616,7 +616,7 @@
 
 UINT16 devcb_resolved_read16::from_port(offs_t offset, UINT16 mask)
 {
-	return input_port_read_direct(m_object.port);
+	return m_object.port->read();
 }
 
 
@@ -719,7 +719,7 @@
 
 void devcb_resolved_write16::to_port(offs_t offset, UINT16 data, UINT16 mask)
 {
-	input_port_write_direct(m_object.port, data, mask);
+	m_object.port->write(data, mask);
 }
 
 
diff -Nru src-old/emu/devcb.h src/emu/devcb.h
--- src-old/emu/devcb.h	2012-04-22 07:29:25.000000000 +0200
+++ src/emu/devcb.h	2012-05-03 11:00:08.000000000 +0200
@@ -117,7 +117,7 @@
 
 // static template for a read16 stub function that calls through a given READ16_MEMBER
 template<class _Class, UINT16 (_Class::*_Function)(address_space &, offs_t, UINT16)>
-UINT16 devcb_stub16(device_t *device, offs_t offset, UINT16 mask=0xffff)
+UINT16 devcb_stub16(device_t *device, offs_t offset, UINT16 mask)
 {
 	_Class *target = downcast<_Class *>(device);
 	return (target->*_Function)(*device->machine().memory().first_space(), offset, mask);
@@ -141,7 +141,7 @@
 
 // static template for a write16 stub function that calls through a given WRITE16_MEMBER
 template<class _Class, void (_Class::*_Function)(address_space &, offs_t, UINT16, UINT16)>
-void devcb_stub16(device_t *device, offs_t offset, UINT16 data, UINT16 mask=0xffff)
+void devcb_stub16(device_t *device, offs_t offset, UINT16 data, UINT16 mask)
 {
 	_Class *target = downcast<_Class *>(device);
 	(target->*_Function)(*device->machine().memory().first_space(), offset, data, mask);
@@ -203,7 +203,7 @@
 // resolving a devcb may produce one of the following object types
 union devcb_resolved_objects
 {
-	const input_port_config *	port;
+	ioport_port *	port;
 	address_space *				space;
 	device_t *					device;
 	device_execute_interface *	execute;
diff -Nru src-old/emu/device.c src/emu/device.c
--- src-old/emu/device.c	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/device.c	2012-05-03 11:00:08.000000000 +0200
@@ -239,7 +239,7 @@
 //  object for a given port name
 //-------------------------------------------------
 
-input_port_config *device_t::ioport(const char *tag) const
+ioport_port *device_t::ioport(const char *tag) const
 {
 	// safety first
 	if (this == NULL)
diff -Nru src-old/emu/device.h src/emu/device.h
--- src-old/emu/device.h	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/device.h	2012-05-03 11:00:08.000000000 +0200
@@ -95,7 +95,7 @@
 struct rom_entry;
 class machine_config;
 class emu_timer;
-typedef struct _input_device_default input_device_default;
+struct input_device_default;
 
 
 
@@ -164,6 +164,8 @@
 	const rom_entry *rom_region() const { return device_rom_region(); }
 	machine_config_constructor machine_config_additions() const { return device_mconfig_additions(); }
 	ioport_constructor input_ports() const { return device_input_ports(); }
+	UINT8 default_bios() const { return m_default_bios; }
+	UINT8 system_bios() const { return m_system_bios; }
 
 	// interface helpers
 	template<class _DeviceClass> bool interface(_DeviceClass *&intf) { intf = dynamic_cast<_DeviceClass *>(this); return (intf != NULL); }
@@ -186,7 +188,7 @@
 	memory_region *memregion(const char *tag) const;
 	memory_share *memshare(const char *tag) const;
 	memory_bank *membank(const char *tag) const;
-	input_port_config *ioport(const char *tag) const;
+	ioport_port *ioport(const char *tag) const;
 	device_t *subdevice(const char *tag) const;
 	device_t *siblingdevice(const char *tag) const;
 	template<class _DeviceClass> inline _DeviceClass *subdevice(const char *tag) const { return downcast<_DeviceClass *>(subdevice(tag)); }
@@ -229,6 +231,8 @@
 	// debugging
 	device_debug *debug() const { return m_debug; }
 
+	void set_default_bios(UINT8 bios) { m_default_bios = bios; }
+	void set_system_bios(UINT8 bios) { m_system_bios = bios; }
 protected:
 	// internal helper classes (defined below)
 	class finder_base;
@@ -313,6 +317,8 @@
 	const void *			m_static_config;		// static device configuration
 	const input_device_default *m_input_defaults;   // devices input ports default overrides
 
+	UINT8					m_system_bios;			// the system BIOS we wish to load
+	UINT8					m_default_bios;			// the default system BIOS
 private:
 	// private helpers
 	device_t *add_subdevice(device_type type, const char *tag, UINT32 clock);
@@ -500,12 +506,12 @@
 
 // device finder template
 template<bool _Required>
-class device_t::ioport_finder : public device_t::object_finder_base<input_port_config>
+class device_t::ioport_finder : public device_t::object_finder_base<ioport_port>
 {
 public:
 	// construction/destruction
 	ioport_finder(device_t &base, const char *tag)
-		: object_finder_base<input_port_config>(base, tag) { }
+		: object_finder_base<ioport_port>(base, tag) { }
 
 	// finder
 	virtual bool findit()
@@ -921,36 +927,6 @@
 };
 
 
-// ======================> device_delegate
-
-// device_delegate is a delegate that wraps with a device tag and can be easily
-// late bound without replicating logic everywhere
-template<typename _Signature>
-class device_delegate : public delegate<_Signature>
-{
-	typedef delegate<_Signature> basetype;
-
-public:
-	// provide same set of constructors as the base class, with additional device name
-	// parameter
-	device_delegate() : basetype(), m_device_name(NULL) { }
-	device_delegate(const basetype &src) : basetype(src), m_device_name(src.m_device_name) { }
-	device_delegate(const basetype &src, delegate_late_bind &object) : basetype(src, object), m_device_name(src.m_device_name) { }
-	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::member_func_type funcptr, const char *name, const char *devname) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
-	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::member_func_type funcptr, const char *name, const char *devname, _FunctionClass *object) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
-	device_delegate(typename basetype::template traits<device_t>::static_func_type funcptr, const char *name) : basetype(funcptr, name, (device_t *)0), m_device_name(NULL) { }
-	device_delegate(typename basetype::template traits<device_t>::static_ref_func_type funcptr, const char *name) : basetype(funcptr, name, (device_t *)0), m_device_name(NULL) { }
-	device_delegate &operator=(const basetype &src) { *static_cast<basetype *>(this) = src; m_device_name = src.m_device_name; return *this; }
-
-	// perform the binding
-	void bind_relative_to(device_t &search_root);
-
-private:
-	// internal state
-	const char *m_device_name;
-};
-
-
 
 //**************************************************************************
 //  INLINE FUNCTIONS
diff -Nru src-old/emu/dirtc.c src/emu/dirtc.c
--- src-old/emu/dirtc.c	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/dirtc.c	2012-05-07 08:57:50.000000000 +0200
@@ -11,6 +11,14 @@
 
 
 //**************************************************************************
+//  MACROS / CONSTANTS
+//**************************************************************************
+
+static const int DAYS_PER_MONTH[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+
+
+//**************************************************************************
 //  DEVICE RTC INTERFACE
 //**************************************************************************
 
@@ -31,3 +39,186 @@
 device_rtc_interface::~device_rtc_interface()
 {
 }
+
+
+//-------------------------------------------------
+//  set_time - called to initialize the RTC to
+//  a known date/time
+//-------------------------------------------------
+
+void device_rtc_interface::set_time(bool update, int year, int month, int day, int day_of_week, int hour, int minute, int second)
+{
+	if (!rtc_feature_y2k())
+	{
+		year %= 100;
+	}
+
+	set_clock_register(RTC_YEAR, year);
+	set_clock_register(RTC_MONTH, month);
+	set_clock_register(RTC_DAY, day);
+	set_clock_register(RTC_DAY_OF_WEEK, day_of_week);
+	set_clock_register(RTC_HOUR, hour);
+	set_clock_register(RTC_MINUTE, minute);
+	set_clock_register(RTC_SECOND, second);
+
+	if (update)
+	{
+		rtc_clock_updated(m_register[RTC_YEAR], m_register[RTC_MONTH], m_register[RTC_DAY], m_register[RTC_DAY_OF_WEEK],
+			m_register[RTC_HOUR], m_register[RTC_MINUTE], m_register[RTC_SECOND]);
+	}
+}
+
+
+//-------------------------------------------------
+//  set_current_time - called to initialize the RTC
+//  to the current system time
+//-------------------------------------------------
+
+void device_rtc_interface::set_current_time(running_machine &machine)
+{
+	system_time systime;
+	machine.base_datetime(systime);
+
+	set_time(true, systime.local_time.year, systime.local_time.month + 1, systime.local_time.mday, systime.local_time.weekday + 1,
+		systime.local_time.hour, systime.local_time.minute,	systime.local_time.second);
+}
+
+
+//-------------------------------------------------
+//  convert_to_bcd -
+//-------------------------------------------------
+
+UINT8 device_rtc_interface::convert_to_bcd(int val)
+{
+	return ((val / 10) << 4) | (val % 10);
+}
+
+
+//-------------------------------------------------
+//  bcd_to_integer -
+//-------------------------------------------------
+
+int device_rtc_interface::bcd_to_integer(UINT8 val)
+{
+	return (((val & 0xf0) >> 4) * 10) + (val & 0x0f);
+}
+
+
+//-------------------------------------------------
+//  set_clock_register -
+//-------------------------------------------------
+
+void device_rtc_interface::set_clock_register(int reg, int value)
+{
+	m_register[reg] = value;
+}
+
+
+//-------------------------------------------------
+//  get_clock_register -
+//-------------------------------------------------
+
+int device_rtc_interface::get_clock_register(int reg)
+{
+	return m_register[reg];
+}
+
+
+//-------------------------------------------------
+//  clock_updated -
+//-------------------------------------------------
+
+void device_rtc_interface::clock_updated()
+{
+	rtc_clock_updated(m_register[RTC_YEAR], m_register[RTC_MONTH], m_register[RTC_DAY], m_register[RTC_DAY_OF_WEEK],
+		m_register[RTC_HOUR], m_register[RTC_MINUTE], m_register[RTC_SECOND]);
+}
+
+
+//-------------------------------------------------
+//  advance_seconds -
+//-------------------------------------------------
+
+void device_rtc_interface::advance_seconds()
+{
+	m_register[RTC_SECOND]++;
+
+	if (m_register[RTC_SECOND] == 60)
+	{
+		m_register[RTC_SECOND] = 0;
+
+		advance_minutes();
+	}
+	else
+	{
+		clock_updated();
+	}
+}
+
+
+//-------------------------------------------------
+//  advance_clock -
+//-------------------------------------------------
+
+void device_rtc_interface::advance_minutes()
+{
+	m_register[RTC_MINUTE]++;
+
+	if (m_register[RTC_MINUTE] == 60)
+	{
+		m_register[RTC_MINUTE] = 0;
+		m_register[RTC_HOUR]++;
+	}
+
+	if (m_register[RTC_HOUR] == 24)
+	{
+		m_register[RTC_HOUR] = 0;
+		m_register[RTC_DAY]++;
+		m_register[RTC_DAY_OF_WEEK]++;
+	}
+
+	if (m_register[RTC_DAY_OF_WEEK] == 8)
+	{
+		m_register[RTC_DAY_OF_WEEK] = 1;
+	}
+
+	if (m_register[RTC_DAY] > DAYS_PER_MONTH[m_register[RTC_MONTH] - 1])
+	{
+		m_register[RTC_DAY] = 1;
+		m_register[RTC_MONTH]++;
+	}
+
+	if (m_register[RTC_MONTH] == 13)
+	{
+		m_register[RTC_MONTH] = 1;
+		m_register[RTC_YEAR]++;
+
+		if (!rtc_feature_y2k() && m_register[RTC_YEAR] == 100)
+		{
+			m_register[RTC_YEAR] = 0;
+		}
+	}
+
+	clock_updated();
+}
+
+
+//-------------------------------------------------
+//  adjust_seconds -
+//-------------------------------------------------
+
+void device_rtc_interface::adjust_seconds()
+{
+	int seconds = get_clock_register(RTC_SECOND);
+
+	set_clock_register(RTC_SECOND, 0);
+
+	if (seconds >= 30)
+	{
+		advance_minutes();
+	}
+	else
+	{
+		clock_updated();
+	}
+}
diff -Nru src-old/emu/dirtc.h src/emu/dirtc.h
--- src-old/emu/dirtc.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/dirtc.h	2012-04-27 23:23:39.000000000 +0200
@@ -16,10 +16,28 @@
 #define __DIRTC_H__
 
 
+
 //**************************************************************************
-//  TYPE DEFINITIONS
+//  MACROS / CONSTANTS
 //**************************************************************************
 
+// clock registers
+enum
+{
+	RTC_SECOND = 0,
+	RTC_MINUTE,
+	RTC_HOUR,
+	RTC_DAY,
+	RTC_MONTH,
+	RTC_DAY_OF_WEEK,
+	RTC_YEAR
+};
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
 // ======================> device_rtc_interface
 
@@ -31,10 +49,27 @@
 	device_rtc_interface(const machine_config &mconfig, device_t &device);
 	virtual ~device_rtc_interface();
 
+	void set_time(bool update, int year, int month, int day, int day_of_week, int hour, int minute, int second);
+	void set_current_time(running_machine &machine);
+
 protected:
+	UINT8 convert_to_bcd(int val);
+	int bcd_to_integer(UINT8 val);
+
+	void set_clock_register(int register, int value);
+	int get_clock_register(int register);
+	void clock_updated();
+
+	void advance_seconds();
+	void advance_minutes();
+	void adjust_seconds();
+
 	// derived class overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second) = 0;
-	virtual bool rtc_is_year_2000_compliant() = 0;
+	virtual bool rtc_feature_y2k() { return false; }
+	virtual bool rtc_feature_leap_year() { return false; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second) { }
+
+	int m_register[7];
 };
 
 
diff -Nru src-old/emu/disound.c src/emu/disound.c
--- src-old/emu/disound.c	2012-04-17 16:58:05.000000000 +0200
+++ src/emu/disound.c	2012-05-07 08:57:50.000000000 +0200
@@ -198,6 +198,20 @@
 
 
 //-------------------------------------------------
+//  set_input_gain - set the gain on the given
+//  input index of the device
+//-------------------------------------------------
+
+void device_sound_interface::set_input_gain(int inputnum, float gain)
+{
+	int stream_inputnum;
+	sound_stream *stream = input_to_stream_input(inputnum, stream_inputnum);
+	if (stream != NULL)
+		stream->set_input_gain(stream_inputnum, gain);
+}
+
+
+//-------------------------------------------------
 //  set_output_gain - set the gain on the given
 //  output index of the device
 //-------------------------------------------------
@@ -225,6 +239,23 @@
 
 
 //-------------------------------------------------
+//  inputnum_from_device - return the input number
+//  that is connected to the given device's output
+//-------------------------------------------------
+
+int device_sound_interface::inputnum_from_device(device_t &source_device, int outputnum) const
+{
+	int overall = 0;
+	for (sound_stream *stream = m_device.machine().sound().first_stream(); stream != NULL; stream = stream->next())
+		if (&stream->device() == &device())
+			for (int inputnum = 0; inputnum < stream->input_count(); inputnum++, overall++)
+				if (stream->input_source_device(inputnum) == &source_device && stream->input_source_outputnum(inputnum) == outputnum)
+					return overall;
+	return -1;
+}
+
+
+//-------------------------------------------------
 //  interface_validity_check - validation for a
 //  device after the configuration has been
 //  constructed
diff -Nru src-old/emu/disound.h src/emu/disound.h
--- src-old/emu/disound.h	2012-04-17 16:58:05.000000000 +0200
+++ src/emu/disound.h	2012-04-26 10:36:24.000000000 +0200
@@ -139,7 +139,9 @@
 	int outputs() const;
 	sound_stream *input_to_stream_input(int inputnum, int &stream_inputnum);
 	sound_stream *output_to_stream_output(int outputnum, int &stream_outputnum);
+	void set_input_gain(int inputnum, float gain);
 	void set_output_gain(int outputnum, float gain);
+	int inputnum_from_device(device_t &device, int outputnum = 0) const;
 
 protected:
 	// optional operation overrides
diff -Nru src-old/emu/driver.c src/emu/driver.c
--- src-old/emu/driver.c	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/driver.c	2012-05-01 21:24:55.000000000 +0200
@@ -712,6 +712,8 @@
 WRITE32_MEMBER( driver_device::paletteram_xRRRRRGGGGGBBBBB_dword_be_w ) { palette_16bit_dword_be_w<5,5,5, 10,5,0>(space, offset, data, mem_mask); }
 WRITE32_MEMBER( driver_device::paletteram_xRRRRRGGGGGBBBBB_dword_le_w ) { palette_16bit_dword_le_w<5,5,5, 10,5,0>(space, offset, data, mem_mask); }
 
+WRITE8_MEMBER( driver_device::paletteram_xGGGGGRRRRRBBBBB_byte_le_w ) { palette_16bit_byte_le_w<5,5,5, 5,10,0>(space, offset, data, mem_mask); }
+
 WRITE16_MEMBER( driver_device::paletteram_xGGGGGRRRRRBBBBB_word_w ) { palette_16bit_word_w<5,5,5, 5,10,0>(space, offset, data, mem_mask); }
 WRITE16_MEMBER( driver_device::paletteram_xGGGGGBBBBBRRRRR_word_w ) { palette_16bit_word_w<5,5,5, 0,10,5>(space, offset, data, mem_mask); }
 WRITE16_MEMBER( driver_device::paletteram_RRRRRGGGGGBBBBBx_word_w ) { palette_16bit_word_w<5,5,5, 11,6,1>(space, offset, data, mem_mask); }
diff -Nru src-old/emu/driver.h src/emu/driver.h
--- src-old/emu/driver.h	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/driver.h	2012-05-01 21:24:55.000000000 +0200
@@ -339,6 +339,8 @@
 	DECLARE_WRITE32_MEMBER( paletteram_xRRRRRGGGGGBBBBB_dword_be_w );
 	DECLARE_WRITE32_MEMBER( paletteram_xRRRRRGGGGGBBBBB_dword_le_w );
 
+	DECLARE_WRITE8_MEMBER( paletteram_xGGGGGRRRRRBBBBB_byte_le_w );
+
 	DECLARE_WRITE16_MEMBER( paletteram_xGGGGGRRRRRBBBBB_word_w );
 	DECLARE_WRITE16_MEMBER( paletteram_xGGGGGBBBBBRRRRR_word_w );
 	DECLARE_WRITE16_MEMBER( paletteram_RRRRRGGGGGBBBBBx_word_w );
diff -Nru src-old/emu/emu.h src/emu/emu.h
--- src-old/emu/emu.h	2012-04-12 10:33:20.000000000 +0200
+++ src/emu/emu.h	2012-05-03 11:00:08.000000000 +0200
@@ -81,6 +81,35 @@
 class machine_config;
 typedef device_t * (*machine_config_constructor)(machine_config &config, device_t *owner);
 
+// device_delegate is a delegate that wraps with a device tag and can be easily
+// late bound without replicating logic everywhere
+template<typename _Signature>
+class device_delegate : public delegate<_Signature>
+{
+	typedef delegate<_Signature> basetype;
+
+public:
+	// provide same set of constructors as the base class, with additional device name
+	// parameter
+	device_delegate() : basetype(), m_device_name(NULL) { }
+	device_delegate(const basetype &src) : basetype(src), m_device_name(src.m_device_name) { }
+	device_delegate(const basetype &src, delegate_late_bind &object) : basetype(src, object), m_device_name(src.m_device_name) { }
+	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::member_func_type funcptr, const char *name, const char *devname) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
+	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::member_func_type funcptr, const char *name, const char *devname, _FunctionClass *object) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
+	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::static_func_type funcptr, const char *name, const char *devname, _FunctionClass *object) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
+	template<class _FunctionClass> device_delegate(typename basetype::template traits<_FunctionClass>::static_ref_func_type funcptr, const char *name, const char *devname, _FunctionClass *object) : basetype(funcptr, name, (_FunctionClass *)0), m_device_name(devname) { }
+	device_delegate(typename basetype::template traits<device_t>::static_func_type funcptr, const char *name) : basetype(funcptr, name, (device_t *)0), m_device_name(NULL) { }
+	device_delegate(typename basetype::template traits<device_t>::static_ref_func_type funcptr, const char *name) : basetype(funcptr, name, (device_t *)0), m_device_name(NULL) { }
+	device_delegate &operator=(const basetype &src) { *static_cast<basetype *>(this) = src; m_device_name = src.m_device_name; return *this; }
+
+	// perform the binding
+	void bind_relative_to(device_t &search_root);
+
+private:
+	// internal state
+	const char *m_device_name;
+};
+
 // I/O
 #include "input.h"
 #include "ioport.h"
diff -Nru src-old/emu/info.c src/emu/info.c
--- src-old/emu/info.c	2012-04-21 18:07:01.000000000 +0200
+++ src/emu/info.c	2012-05-03 11:00:08.000000000 +0200
@@ -267,7 +267,7 @@
 	astring errors;
 	device_iterator iter(config.root_device());
 	for (device_t *device = iter.first(); device != NULL; device = iter.next())
-		input_port_list_init(*device, portlist, errors);
+		portlist.append(*device, errors);
 
 	// print the header and the game name
 	fprintf(m_output, "\t<%s",emulator_info::get_xml_top());
@@ -352,11 +352,11 @@
 	astring errors;
 	device_iterator iptiter(device);
 	for (device_t *dev = iptiter.first(); dev != NULL; dev = iptiter.next())
-		input_port_list_init(*dev, portlist, errors);
+		portlist.append(*dev, errors);
 	// check if the device adds player inputs (other than dsw and configs) to the system
-	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
-		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->type >= IPT_START1 && field->type < __ipt_ui_start)
+	for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->type() >= IPT_START1 && field->type() < IPT_UI_FIRST)
 			{
 				has_input = TRUE;
 				break;
@@ -830,33 +830,33 @@
 	bool gambling = false;
 
 	// iterate over the ports
-	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
-		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
+	for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
 		{
 			int analogtype = -1;
 
 			// track the highest player number
-			if (nplayer < field->player + 1)
-				nplayer = field->player + 1;
+			if (nplayer < field->player() + 1)
+				nplayer = field->player() + 1;
 
 			// switch off of the type
-			switch (field->type)
+			switch (field->type())
 			{
 				// map which joystick directions are present
-				case IPT_JOYSTICK_UP:			joytype[0] |= DIR_UP | ((field->way == 4) ? DIR_4WAY : 0);		break;
-				case IPT_JOYSTICK_DOWN:			joytype[0] |= DIR_DOWN | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICK_LEFT:			joytype[0] |= DIR_LEFT | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICK_RIGHT:		joytype[0] |= DIR_RIGHT | ((field->way == 4) ? DIR_4WAY : 0);	break;
-
-				case IPT_JOYSTICKLEFT_UP:		joytype[1] |= DIR_UP | ((field->way == 4) ? DIR_4WAY : 0);		break;
-				case IPT_JOYSTICKLEFT_DOWN:		joytype[1] |= DIR_DOWN | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICKLEFT_LEFT:		joytype[1] |= DIR_LEFT | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICKLEFT_RIGHT:	joytype[1] |= DIR_RIGHT | ((field->way == 4) ? DIR_4WAY : 0);	break;
-
-				case IPT_JOYSTICKRIGHT_UP:		joytype[2] |= DIR_UP | ((field->way == 4) ? DIR_4WAY : 0);		break;
-				case IPT_JOYSTICKRIGHT_DOWN:	joytype[2] |= DIR_DOWN | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICKRIGHT_LEFT:	joytype[2] |= DIR_LEFT | ((field->way == 4) ? DIR_4WAY : 0);	break;
-				case IPT_JOYSTICKRIGHT_RIGHT:	joytype[2] |= DIR_RIGHT | ((field->way == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICK_UP:			joytype[0] |= DIR_UP | ((field->way() == 4) ? DIR_4WAY : 0);		break;
+				case IPT_JOYSTICK_DOWN:			joytype[0] |= DIR_DOWN | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICK_LEFT:			joytype[0] |= DIR_LEFT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICK_RIGHT:		joytype[0] |= DIR_RIGHT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+
+				case IPT_JOYSTICKLEFT_UP:		joytype[1] |= DIR_UP | ((field->way() == 4) ? DIR_4WAY : 0);		break;
+				case IPT_JOYSTICKLEFT_DOWN:		joytype[1] |= DIR_DOWN | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICKLEFT_LEFT:		joytype[1] |= DIR_LEFT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICKLEFT_RIGHT:	joytype[1] |= DIR_RIGHT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+
+				case IPT_JOYSTICKRIGHT_UP:		joytype[2] |= DIR_UP | ((field->way() == 4) ? DIR_4WAY : 0);		break;
+				case IPT_JOYSTICKRIGHT_DOWN:	joytype[2] |= DIR_DOWN | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICKRIGHT_LEFT:	joytype[2] |= DIR_LEFT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
+				case IPT_JOYSTICKRIGHT_RIGHT:	joytype[2] |= DIR_RIGHT | ((field->way() == 4) ? DIR_4WAY : 0);	break;
 
 				// mark as an analog input, and get analog stats after switch
 				case IPT_AD_STICK_X:
@@ -918,7 +918,7 @@
 				case IPT_BUTTON14:
 				case IPT_BUTTON15:
 				case IPT_BUTTON16:
-					nbutton = MAX(nbutton, field->type - IPT_BUTTON1 + 1);
+					nbutton = MAX(nbutton, field->type() - IPT_BUTTON1 + 1);
 					break;
 
 				// track maximum coin index
@@ -930,7 +930,7 @@
 				case IPT_COIN6:
 				case IPT_COIN7:
 				case IPT_COIN8:
-					ncoin = MAX(ncoin, field->type - IPT_COIN1 + 1);
+					ncoin = MAX(ncoin, field->type() - IPT_COIN1 + 1);
 					break;
 
 				// track presence of these guys
@@ -952,11 +952,11 @@
 					break;
 
 				default:
-					if (field->type >= __ipt_mahjong_start && field->type <= __ipt_mahjong_end)
+					if (field->type() > IPT_MAHJONG_FIRST && field->type() < IPT_MAHJONG_LAST)
 						mahjong = true;
-					else if (field->type >= __ipt_hanafuda_start && field->type <= __ipt_hanafuda_end)
+					else if (field->type() > IPT_HANAFUDA_FIRST && field->type() < IPT_HANAFUDA_LAST)
 						hanafuda = true;
-					else if (field->type >= __ipt_gambling_start && field->type <= __ipt_gambling_end)
+					else if (field->type() > IPT_GAMBLING_FIRST && field->type() < IPT_GAMBLING_LAST)
 						gambling = true;
 					break;
 			}
@@ -964,15 +964,15 @@
 			// get the analog stats
 			if (analogtype != -1)
 			{
-				if (field->min != 0)
-					control_info[analogtype].min = field->min;
-				if (field->max != 0)
-					control_info[analogtype].max = field->max;
-				if (field->sensitivity != 0)
-					control_info[analogtype].sensitivity = field->sensitivity;
-				if (field->delta != 0)
-					control_info[analogtype].keydelta = field->delta;
-				if ((field->flags & ANALOG_FLAG_REVERSE) != 0)
+				if (field->minval() != 0)
+					control_info[analogtype].min = field->minval();
+				if (field->maxval() != 0)
+					control_info[analogtype].max = field->maxval();
+				if (field->sensitivity() != 0)
+					control_info[analogtype].sensitivity = field->sensitivity();
+				if (field->delta() != 0)
+					control_info[analogtype].keydelta = field->delta();
+				if (field->analog_reverse() != 0)
 					control_info[analogtype].reverse = true;
 			}
 		}
@@ -1080,25 +1080,25 @@
 void info_xml_creator::output_switches(const ioport_list &portlist, const char *root_tag, int type, const char *outertag, const char *innertag)
 {
 	// iterate looking for DIP switches
-	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
-		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->type == type)
+	for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->type() == type)
 			{
-				astring newtag(field->port().tag()), oldtag(":");
+				astring newtag(port->tag()), oldtag(":");
 				newtag.substr(newtag.find(oldtag.cat(root_tag)) + oldtag.len());
 
 				// output the switch name information
-				fprintf(m_output, "\t\t<%s name=\"%s\"", outertag, xml_normalize_string(input_field_name(field)));
+				fprintf(m_output, "\t\t<%s name=\"%s\"", outertag, xml_normalize_string(field->name()));
 				fprintf(m_output, " tag=\"%s\"", xml_normalize_string(newtag));
-				fprintf(m_output, " mask=\"%u\"", field->mask);
+				fprintf(m_output, " mask=\"%u\"", field->mask());
 				fprintf(m_output, ">\n");
 
 				// loop over settings
-				for (input_setting_config *setting = field->settinglist().first(); setting != NULL; setting = setting->next())
+				for (ioport_setting *setting = field->first_setting(); setting != NULL; setting = setting->next())
 				{
-					fprintf(m_output, "\t\t\t<%s name=\"%s\"", innertag, xml_normalize_string(setting->name));
-					fprintf(m_output, " value=\"%u\"", setting->value);
-					if (setting->value == field->defvalue)
+					fprintf(m_output, "\t\t\t<%s name=\"%s\"", innertag, xml_normalize_string(setting->name()));
+					fprintf(m_output, " value=\"%u\"", setting->value());
+					if (setting->value() == field->defvalue())
 						fprintf(m_output, " default=\"yes\"");
 					fprintf(m_output, "/>\n");
 				}
@@ -1117,10 +1117,10 @@
 void info_xml_creator::output_adjusters(const ioport_list &portlist)
 {
 	// iterate looking for Adjusters
-	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
-		for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->type == IPT_ADJUSTER)
-				fprintf(m_output, "\t\t<adjuster name=\"%s\" default=\"%d\"/>\n", xml_normalize_string(input_field_name(field)), field->defvalue);
+	for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->type() == IPT_ADJUSTER)
+				fprintf(m_output, "\t\t<adjuster name=\"%s\" default=\"%d\"/>\n", xml_normalize_string(field->name()), field->defvalue());
 }
 
 
diff -Nru src-old/emu/ioport.c src/emu/ioport.c
--- src-old/emu/ioport.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/ioport.c	2012-05-07 08:57:50.000000000 +0200
@@ -4,8 +4,36 @@
 
     Input/output port handling.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ****************************************************************************
 
@@ -103,459 +131,527 @@
 #include <ctype.h>
 #include <time.h>
 
-/* temporary: set this to 1 to enable the originally defined behavior that
-   a field specified via PORT_MODIFY which intersects a previously-defined
-   field completely wipes out the previous definition */
+// temporary: set this to 1 to enable the originally defined behavior that
+// a field specified via PORT_MODIFY which intersects a previously-defined
+// field completely wipes out the previous definition
 #define INPUT_PORT_OVERRIDE_FULLY_NUKES_PREVIOUS	1
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-/* these constants must match the order of the joystick directions in the IPT definition */
-#define JOYDIR_UP			0
-#define JOYDIR_DOWN			1
-#define JOYDIR_LEFT			2
-#define JOYDIR_RIGHT		3
-
-#define JOYDIR_UP_BIT		(1 << JOYDIR_UP)
-#define JOYDIR_DOWN_BIT		(1 << JOYDIR_DOWN)
-#define JOYDIR_LEFT_BIT		(1 << JOYDIR_LEFT)
-#define JOYDIR_RIGHT_BIT	(1 << JOYDIR_RIGHT)
-
-#define LOG_INPUTX		0
-#define SPACE_COUNT		3
-#define INVALID_CHAR	'?'
-#define IP_NAME_DEFAULT	NULL
+//**************************************************************************
+//  DEBUGGING
+//**************************************************************************
+
+#define LOG_NATURAL_KEYBOARD	0
+
+
+
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+const int SPACE_COUNT = 3;
+const int KEY_BUFFER_SIZE = 4096;
+const unicode_char INVALID_CHAR = '?';
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// live analog field information
+class analog_field
+{
+	friend class simple_list<analog_field>;
+	friend class ioport_manager;
+	friend void ioport_field::set_user_settings(const ioport_field::user_settings &settings);
+
+public:
+	// construction/destruction
+	analog_field(ioport_field &field);
+
+	// getters
+	analog_field *next() const { return m_next; }
+	ioport_manager &manager() const { return m_field.manager(); }
+	ioport_field &field() const { return m_field; }
+	INT32 sensitivity() const { return m_sensitivity; }
+	bool reverse() const { return m_reverse; }
+	INT32 delta() const { return m_delta; }
+	INT32 centerdelta() const { return m_centerdelta; }
+
+	// readers
+	void read(ioport_value &value);
+	float crosshair_read();
+	void frame_update(running_machine &machine);
+
+private:
+	// helpers
+	INT32 apply_min_max(INT32 value) const;
+	INT32 apply_settings(INT32 value) const;
+	INT32 apply_sensitivity(INT32 value) const;
+	INT32 apply_inverse_sensitivity(INT32 value) const;
+
+	// internal state
+	analog_field *		m_next;					// link to the next analog state for this port
+	ioport_field &		m_field;				// pointer to the input field referenced
+
+	// adjusted values (right-justified and tweaked)
+	UINT8				m_shift;				// shift to align final value in the port
+	INT32				m_adjdefvalue;			// adjusted default value from the config
+	INT32				m_adjmin;				// adjusted minimum value from the config
+	INT32				m_adjmax;				// adjusted maximum value from the config
+
+	// live values of configurable parameters
+	INT32				m_sensitivity;			// current live sensitivity (100=normal)
+	bool				m_reverse;				// current live reverse flag
+	INT32				m_delta;				// current live delta to apply each frame a digital inc/dec key is pressed
+	INT32				m_centerdelta;			// current live delta to apply each frame no digital inputs are pressed
+
+	// live analog value tracking
+	INT32				m_accum;				// accumulated value (including relative adjustments)
+	INT32				m_previous;				// previous adjusted value
+	INT32				m_previousanalog;		// previous analog value
+
+	// parameters for modifying live values
+	INT32				m_minimum;				// minimum adjusted value
+	INT32				m_maximum;				// maximum adjusted value
+	INT32				m_center;				// center adjusted value for autocentering
+	INT32				m_reverse_val;			// value where we subtract from to reverse directions
+
+	// scaling factors
+	INT64				m_scalepos;				// scale factor to apply to positive adjusted values
+	INT64				m_scaleneg;				// scale factor to apply to negative adjusted values
+	INT64				m_keyscalepos;			// scale factor to apply to the key delta field when pos
+	INT64				m_keyscaleneg;			// scale factor to apply to the key delta field when neg
+	INT64				m_positionalscale;		// scale factor to divide a joystick into positions
+
+	// misc flags
+	bool				m_absolute;				// is this an absolute or relative input?
+	bool				m_wraps;				// does the control wrap around?
+	bool				m_autocenter;			// autocenter this input?
+	bool				m_single_scale;			// scale joystick differently if default is between min/max
+	bool				m_interpolate;			// should we do linear interpolation for mid-frame reads?
+	bool				m_lastdigital;			// was the last modification caused by a digital form?
+};
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+// live device field information
+class dynamic_field
+{
+	friend class simple_list<dynamic_field>;
 
-/* live analog field information */
-typedef struct _analog_field_state analog_field_state;
-struct _analog_field_state
-{
-	analog_field_state *		next;				/* link to the next analog state for this port */
-	const input_field_config *	field;				/* pointer to the input field referenced */
-
-	/* adjusted values (right-justified and tweaked) */
-	UINT8						shift;				/* shift to align final value in the port */
-	INT32						adjdefvalue;		/* adjusted default value from the config */
-	INT32						adjmin;				/* adjusted minimum value from the config */
-	INT32						adjmax;				/* adjusted maximum value from the config */
-
-	/* live values of configurable parameters */
-	INT32						sensitivity;		/* current live sensitivity (100=normal) */
-	UINT8						reverse;			/* current live reverse flag */
-	INT32						delta;				/* current live delta to apply each frame a digital inc/dec key is pressed */
-	INT32						centerdelta;		/* current live delta to apply each frame no digital inputs are pressed */
-
-	/* live analog value tracking */
-	INT32						accum;				/* accumulated value (including relative adjustments) */
-	INT32						previous;			/* previous adjusted value */
-	INT32						previousanalog;		/* previous analog value */
-
-	/* parameters for modifying live values */
-	INT32						minimum;			/* minimum adjusted value */
-	INT32						maximum;			/* maximum adjusted value */
-	INT32						center;				/* center adjusted value for autocentering */
-	INT32						reverse_val;		/* value where we subtract from to reverse directions */
-
-	/* scaling factors */
-	INT64						scalepos;			/* scale factor to apply to positive adjusted values */
-	INT64						scaleneg;			/* scale factor to apply to negative adjusted values */
-	INT64						keyscalepos;		/* scale factor to apply to the key delta field when pos */
-	INT64						keyscaleneg;		/* scale factor to apply to the key delta field when neg */
-	INT64						positionalscale;	/* scale factor to divide a joystick into positions */
-
-	/* misc flags */
-	UINT8						absolute;			/* is this an absolute or relative input? */
-	UINT8						wraps;				/* does the control wrap around? */
-	UINT8						autocenter;			/* autocenter this input? */
-	UINT8						single_scale;		/* scale joystick differently if default is between min/max */
-	UINT8						interpolate;		/* should we do linear interpolation for mid-frame reads? */
-	UINT8						lastdigital;		/* was the last modification caused by a digital form? */
+public:
+	// construction/destruction
+	dynamic_field(ioport_field &field);
+
+	// getters
+	dynamic_field *next() const { return m_next; }
+	ioport_field &field() const { return m_field; }
+
+	// read/write
+	void read(ioport_value &result);
+	void write(ioport_value newval);
+
+private:
+	// internal state
+	dynamic_field *			m_next;				// linked list of info for this port
+	ioport_field &			m_field;			// reference to the input field
+	UINT8					m_shift;			// shift to apply to the final result
+	ioport_value			m_oldval;			// last value
 };
 
 
-/* live device field information */
-typedef struct _device_field_info device_field_info;
-struct _device_field_info
-{
-	device_field_info *			next;				/* linked list of info for this port */
-	const input_field_config *	field;				/* pointer to the input field referenced */
-	device_t *					device;				/* device */
-	UINT8						shift;				/* shift to apply to the final result */
-	input_port_value			oldval;				/* last value */
+// internal live state of an input field
+struct ioport_field_live
+{
+	// construction/destruction
+	ioport_field_live(ioport_field &field, analog_field *analog);
+
+	// public state
+	analog_field *			analog;				// pointer to live analog data if this is an analog field
+	digital_joystick *		joystick;			// pointer to digital joystick information
+	input_seq				seq[SEQ_TYPE_TOTAL];// currently configured input sequences
+	ioport_value			value;				// current value of this port
+	UINT8					impulse;			// counter for impulse controls
+	bool					last;				// were we pressed last time?
+	digital_joystick::direction_t joydir;		// digital joystick direction index
+	astring					name;				// overridden name
 };
 
 
-/* internal live state of an input field */
-struct _input_field_state
+// internal live state of an input port
+struct ioport_port_live
 {
-	analog_field_state *		analog;				/* pointer to live analog data if this is an analog field */
-	digital_joystick_state *	joystick;			/* pointer to digital joystick information */
-	input_seq					seq[SEQ_TYPE_TOTAL];/* currently configured input sequences */
-	input_port_value			value;				/* current value of this port */
-	UINT8						impulse;			/* counter for impulse controls */
-	UINT8						last;				/* were we pressed last time? */
-	UINT8						joydir;				/* digital joystick direction index */
-	char *						name;				/* overridden name */
+	// construction/destruction
+	ioport_port_live(ioport_port &port);
+
+	// public state
+	simple_list<analog_field> analoglist;		// list of analog port info
+	simple_list<dynamic_field> readlist;		// list of dynamic read fields
+	simple_list<dynamic_field> writelist;		// list of dynamic write fields
+	ioport_value			defvalue;			// combined default value across the port
+	ioport_value			digital;			// current value from all digital inputs
+	ioport_value			outputvalue;		// current value for outputs
 };
 
 
-/* internal live state of an input port */
-struct _input_port_state
+// character information
+struct char_info
 {
-	analog_field_state *		analoglist;			/* pointer to list of analog port info */
-	device_field_info *			readdevicelist;		/* pointer to list of input device info */
-	device_field_info *			writedevicelist;	/* pointer to list of output device info */
-	input_port_value			defvalue;			/* combined default value across the port */
-	input_port_value			digital;			/* current value from all digital inputs */
-	input_port_value			vblank;				/* value of all IPT_VBLANK bits */
-	input_port_value			outputvalue;		/* current value for outputs */
+	unicode_char ch;
+	const char *name;
+	const char *alternate;	// alternative string, in UTF-8
+
+	static const char_info *find(unicode_char target);
 };
 
 
-#define KEY_BUFFER_SIZE	4096
 
-typedef struct _char_info char_info;
-struct _char_info
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  compute_scale -- compute an 8.24 scale value
+//  from a numerator and a denominator
+//-------------------------------------------------
+
+inline INT64 compute_scale(INT32 num, INT32 den)
 {
-	unicode_char ch;
-	const char *name;
-	const char *alternate;	/* alternative string, in UTF-8 */
-};
+	return (INT64(num) << 24) / den;
+}
 
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+//-------------------------------------------------
+//  recip_scale -- compute an 8.24 reciprocal of
+//  an 8.24 scale value
+//-------------------------------------------------
 
-#define APPLY_SENSITIVITY(x,s)		(((INT64)(x) * (s)) / 100.0 + 0.5)
-#define APPLY_INVERSE_SENSITIVITY(x,s) (((INT64)(x) * 100) / (s))
+inline INT64 recip_scale(INT64 scale)
+{
+	return (INT64(1) << 48) / scale;
+}
 
-#define COMPUTE_SCALE(num,den)		(((INT64)(num) << 24) / (den))
-#define RECIP_SCALE(s)				(((INT64)1 << 48) / (s))
-#define APPLY_SCALE(x,s)			(((INT64)(x) * (s)) >> 24)
 
+//-------------------------------------------------
+//  apply_scale -- apply an 8.24 scale value to
+//  a 32-bit value
+//-------------------------------------------------
+
+inline INT32 apply_scale(INT32 value, INT64 scale)
+{
+	return (INT64(value) * scale) >> 24;
+}
 
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
 
-/* XML attributes for the different types */
-static const char *const seqtypestrings[] = { "standard", "increment", "decrement" };
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
+// XML attributes for the different types
+static const char *const seqtypestrings[] = { "standard", "increment", "decrement" };
 
+// master character info table
 static const char_info charinfo[] =
 {
-	{ 0x0008,					"Backspace",	NULL },		/* Backspace */
-	{ 0x0009,					"Tab",			"    " },	/* Tab */
-	{ 0x000c,					"Clear",		NULL },		/* Clear */
-	{ 0x000d,					"Enter",		NULL },		/* Enter */
-	{ 0x001a,					"Esc",			NULL },		/* Esc */
-	{ 0x0020,					"Space",		" " },		/* Space */
-	{ 0x0061,					NULL,			"A" },		/* a */
-	{ 0x0062,					NULL,			"B" },		/* b */
-	{ 0x0063,					NULL,			"C" },		/* c */
-	{ 0x0064,					NULL,			"D" },		/* d */
-	{ 0x0065,					NULL,			"E" },		/* e */
-	{ 0x0066,					NULL,			"F" },		/* f */
-	{ 0x0067,					NULL,			"G" },		/* g */
-	{ 0x0068,					NULL,			"H" },		/* h */
-	{ 0x0069,					NULL,			"I" },		/* i */
-	{ 0x006a,					NULL,			"J" },		/* j */
-	{ 0x006b,					NULL,			"K" },		/* k */
-	{ 0x006c,					NULL,			"L" },		/* l */
-	{ 0x006d,					NULL,			"M" },		/* m */
-	{ 0x006e,					NULL,			"N" },		/* n */
-	{ 0x006f,					NULL,			"O" },		/* o */
-	{ 0x0070,					NULL,			"P" },		/* p */
-	{ 0x0071,					NULL,			"Q" },		/* q */
-	{ 0x0072,					NULL,			"R" },		/* r */
-	{ 0x0073,					NULL,			"S" },		/* s */
-	{ 0x0074,					NULL,			"T" },		/* t */
-	{ 0x0075,					NULL,			"U" },		/* u */
-	{ 0x0076,					NULL,			"V" },		/* v */
-	{ 0x0077,					NULL,			"W" },		/* w */
-	{ 0x0078,					NULL,			"X" },		/* x */
-	{ 0x0079,					NULL,			"Y" },		/* y */
-	{ 0x007a,					NULL,			"Z" },		/* z */
-	{ 0x00a0,					NULL,			" " },		/* non breaking space */
-	{ 0x00a1,					NULL,			"!" },		/* inverted exclaimation mark */
-	{ 0x00a6,					NULL,			"|" },		/* broken bar */
-	{ 0x00a9,					NULL,			"(c)" },	/* copyright sign */
-	{ 0x00ab,					NULL,			"<<" },		/* left pointing double angle */
-	{ 0x00ae,					NULL,			"(r)" },	/* registered sign */
-	{ 0x00bb,					NULL,			">>" },		/* right pointing double angle */
-	{ 0x00bc,					NULL,			"1/4" },	/* vulgar fraction one quarter */
-	{ 0x00bd,					NULL,			"1/2" },	/* vulgar fraction one half */
-	{ 0x00be,					NULL,			"3/4" },	/* vulgar fraction three quarters */
-	{ 0x00bf,					NULL,			"?" },		/* inverted question mark */
-	{ 0x00c0,					NULL,			"A" },		/* 'A' grave */
-	{ 0x00c1,					NULL,			"A" },		/* 'A' acute */
-	{ 0x00c2,					NULL,			"A" },		/* 'A' circumflex */
-	{ 0x00c3,					NULL,			"A" },		/* 'A' tilde */
-	{ 0x00c4,					NULL,			"A" },		/* 'A' diaeresis */
-	{ 0x00c5,					NULL,			"A" },		/* 'A' ring above */
-	{ 0x00c6,					NULL,			"AE" },		/* 'AE' ligature */
-	{ 0x00c7,					NULL,			"C" },		/* 'C' cedilla */
-	{ 0x00c8,					NULL,			"E" },		/* 'E' grave */
-	{ 0x00c9,					NULL,			"E" },		/* 'E' acute */
-	{ 0x00ca,					NULL,			"E" },		/* 'E' circumflex */
-	{ 0x00cb,					NULL,			"E" },		/* 'E' diaeresis */
-	{ 0x00cc,					NULL,			"I" },		/* 'I' grave */
-	{ 0x00cd,					NULL,			"I" },		/* 'I' acute */
-	{ 0x00ce,					NULL,			"I" },		/* 'I' circumflex */
-	{ 0x00cf,					NULL,			"I" },		/* 'I' diaeresis */
-	{ 0x00d0,					NULL,			"D" },		/* 'ETH' */
-	{ 0x00d1,					NULL,			"N" },		/* 'N' tilde */
-	{ 0x00d2,					NULL,			"O" },		/* 'O' grave */
-	{ 0x00d3,					NULL,			"O" },		/* 'O' acute */
-	{ 0x00d4,					NULL,			"O" },		/* 'O' circumflex */
-	{ 0x00d5,					NULL,			"O" },		/* 'O' tilde */
-	{ 0x00d6,					NULL,			"O" },		/* 'O' diaeresis */
-	{ 0x00d7,					NULL,			"X" },		/* multiplication sign */
-	{ 0x00d8,					NULL,			"O" },		/* 'O' stroke */
-	{ 0x00d9,					NULL,			"U" },		/* 'U' grave */
-	{ 0x00da,					NULL,			"U" },		/* 'U' acute */
-	{ 0x00db,					NULL,			"U" },		/* 'U' circumflex */
-	{ 0x00dc,					NULL,			"U" },		/* 'U' diaeresis */
-	{ 0x00dd,					NULL,			"Y" },		/* 'Y' acute */
-	{ 0x00df,					NULL,			"SS" },		/* sharp S */
-	{ 0x00e0,					NULL,			"a" },		/* 'a' grave */
-	{ 0x00e1,					NULL,			"a" },		/* 'a' acute */
-	{ 0x00e2,					NULL,			"a" },		/* 'a' circumflex */
-	{ 0x00e3,					NULL,			"a" },		/* 'a' tilde */
-	{ 0x00e4,					NULL,			"a" },		/* 'a' diaeresis */
-	{ 0x00e5,					NULL,			"a" },		/* 'a' ring above */
-	{ 0x00e6,					NULL,			"ae" },		/* 'ae' ligature */
-	{ 0x00e7,					NULL,			"c" },		/* 'c' cedilla */
-	{ 0x00e8,					NULL,			"e" },		/* 'e' grave */
-	{ 0x00e9,					NULL,			"e" },		/* 'e' acute */
-	{ 0x00ea,					NULL,			"e" },		/* 'e' circumflex */
-	{ 0x00eb,					NULL,			"e" },		/* 'e' diaeresis */
-	{ 0x00ec,					NULL,			"i" },		/* 'i' grave */
-	{ 0x00ed,					NULL,			"i" },		/* 'i' acute */
-	{ 0x00ee,					NULL,			"i" },		/* 'i' circumflex */
-	{ 0x00ef,					NULL,			"i" },		/* 'i' diaeresis */
-	{ 0x00f0,					NULL,			"d" },		/* 'eth' */
-	{ 0x00f1,					NULL,			"n" },		/* 'n' tilde */
-	{ 0x00f2,					NULL,			"o" },		/* 'o' grave */
-	{ 0x00f3,					NULL,			"o" },		/* 'o' acute */
-	{ 0x00f4,					NULL,			"o" },		/* 'o' circumflex */
-	{ 0x00f5,					NULL,			"o" },		/* 'o' tilde */
-	{ 0x00f6,					NULL,			"o" },		/* 'o' diaeresis */
-	{ 0x00f8,					NULL,			"o" },		/* 'o' stroke */
-	{ 0x00f9,					NULL,			"u" },		/* 'u' grave */
-	{ 0x00fa,					NULL,			"u" },		/* 'u' acute */
-	{ 0x00fb,					NULL,			"u" },		/* 'u' circumflex */
-	{ 0x00fc,					NULL,			"u" },		/* 'u' diaeresis */
-	{ 0x00fd,					NULL,			"y" },		/* 'y' acute */
-	{ 0x00ff,					NULL,			"y" },		/* 'y' diaeresis */
-	{ 0x2010,					NULL,			"-" },		/* hyphen */
-	{ 0x2011,					NULL,			"-" },		/* non-breaking hyphen */
-	{ 0x2012,					NULL,			"-" },		/* figure dash */
-	{ 0x2013,					NULL,			"-" },		/* en dash */
-	{ 0x2014,					NULL,			"-" },		/* em dash */
-	{ 0x2015,					NULL,			"-" },		/* horizontal dash */
-	{ 0x2018,					NULL,			"\'" },		/* left single quotation mark */
-	{ 0x2019,					NULL,			"\'" },		/* right single quotation mark */
-	{ 0x201a,					NULL,			"\'" },		/* single low quotation mark */
-	{ 0x201b,					NULL,			"\'" },		/* single high reversed quotation mark */
-	{ 0x201c,					NULL,			"\"" },		/* left double quotation mark */
-	{ 0x201d,					NULL,			"\"" },		/* right double quotation mark */
-	{ 0x201e,					NULL,			"\"" },		/* double low quotation mark */
-	{ 0x201f,					NULL,			"\"" },		/* double high reversed quotation mark */
-	{ 0x2024,					NULL,			"." },		/* one dot leader */
-	{ 0x2025,					NULL,			".." },		/* two dot leader */
-	{ 0x2026,					NULL,			"..." },	/* horizontal ellipsis */
-	{ 0x2047,					NULL,			"??" },		/* double question mark */
-	{ 0x2048,					NULL,			"?!" },		/* question exclamation mark */
-	{ 0x2049,					NULL,			"!?" },		/* exclamation question mark */
-	{ 0xff01,					NULL,			"!" },		/* fullwidth exclamation point */
-	{ 0xff02,					NULL,			"\"" },		/* fullwidth quotation mark */
-	{ 0xff03,					NULL,			"#" },		/* fullwidth number sign */
-	{ 0xff04,					NULL,			"$" },		/* fullwidth dollar sign */
-	{ 0xff05,					NULL,			"%" },		/* fullwidth percent sign */
-	{ 0xff06,					NULL,			"&" },		/* fullwidth ampersand */
-	{ 0xff07,					NULL,			"\'" },		/* fullwidth apostrophe */
-	{ 0xff08,					NULL,			"(" },		/* fullwidth left parenthesis */
-	{ 0xff09,					NULL,			")" },		/* fullwidth right parenthesis */
-	{ 0xff0a,					NULL,			"*" },		/* fullwidth asterisk */
-	{ 0xff0b,					NULL,			"+" },		/* fullwidth plus */
-	{ 0xff0c,					NULL,			"," },		/* fullwidth comma */
-	{ 0xff0d,					NULL,			"-" },		/* fullwidth minus */
-	{ 0xff0e,					NULL,			"." },		/* fullwidth period */
-	{ 0xff0f,					NULL,			"/" },		/* fullwidth slash */
-	{ 0xff10,					NULL,			"0" },		/* fullwidth zero */
-	{ 0xff11,					NULL,			"1" },		/* fullwidth one */
-	{ 0xff12,					NULL,			"2" },		/* fullwidth two */
-	{ 0xff13,					NULL,			"3" },		/* fullwidth three */
-	{ 0xff14,					NULL,			"4" },		/* fullwidth four */
-	{ 0xff15,					NULL,			"5" },		/* fullwidth five */
-	{ 0xff16,					NULL,			"6" },		/* fullwidth six */
-	{ 0xff17,					NULL,			"7" },		/* fullwidth seven */
-	{ 0xff18,					NULL,			"8" },		/* fullwidth eight */
-	{ 0xff19,					NULL,			"9" },		/* fullwidth nine */
-	{ 0xff1a,					NULL,			":" },		/* fullwidth colon */
-	{ 0xff1b,					NULL,			";" },		/* fullwidth semicolon */
-	{ 0xff1c,					NULL,			"<" },		/* fullwidth less than sign */
-	{ 0xff1d,					NULL,			"=" },		/* fullwidth equals sign */
-	{ 0xff1e,					NULL,			">" },		/* fullwidth greater than sign */
-	{ 0xff1f,					NULL,			"?" },		/* fullwidth question mark */
-	{ 0xff20,					NULL,			"@" },		/* fullwidth at sign */
-	{ 0xff21,					NULL,			"A" },		/* fullwidth 'A' */
-	{ 0xff22,					NULL,			"B" },		/* fullwidth 'B' */
-	{ 0xff23,					NULL,			"C" },		/* fullwidth 'C' */
-	{ 0xff24,					NULL,			"D" },		/* fullwidth 'D' */
-	{ 0xff25,					NULL,			"E" },		/* fullwidth 'E' */
-	{ 0xff26,					NULL,			"F" },		/* fullwidth 'F' */
-	{ 0xff27,					NULL,			"G" },		/* fullwidth 'G' */
-	{ 0xff28,					NULL,			"H" },		/* fullwidth 'H' */
-	{ 0xff29,					NULL,			"I" },		/* fullwidth 'I' */
-	{ 0xff2a,					NULL,			"J" },		/* fullwidth 'J' */
-	{ 0xff2b,					NULL,			"K" },		/* fullwidth 'K' */
-	{ 0xff2c,					NULL,			"L" },		/* fullwidth 'L' */
-	{ 0xff2d,					NULL,			"M" },		/* fullwidth 'M' */
-	{ 0xff2e,					NULL,			"N" },		/* fullwidth 'N' */
-	{ 0xff2f,					NULL,			"O" },		/* fullwidth 'O' */
-	{ 0xff30,					NULL,			"P" },		/* fullwidth 'P' */
-	{ 0xff31,					NULL,			"Q" },		/* fullwidth 'Q' */
-	{ 0xff32,					NULL,			"R" },		/* fullwidth 'R' */
-	{ 0xff33,					NULL,			"S" },		/* fullwidth 'S' */
-	{ 0xff34,					NULL,			"T" },		/* fullwidth 'T' */
-	{ 0xff35,					NULL,			"U" },		/* fullwidth 'U' */
-	{ 0xff36,					NULL,			"V" },		/* fullwidth 'V' */
-	{ 0xff37,					NULL,			"W" },		/* fullwidth 'W' */
-	{ 0xff38,					NULL,			"X" },		/* fullwidth 'X' */
-	{ 0xff39,					NULL,			"Y" },		/* fullwidth 'Y' */
-	{ 0xff3a,					NULL,			"Z" },		/* fullwidth 'Z' */
-	{ 0xff3b,					NULL,			"[" },		/* fullwidth left bracket */
-	{ 0xff3c,					NULL,			"\\" },		/* fullwidth backslash */
-	{ 0xff3d,					NULL,			"]"	},		/* fullwidth right bracket */
-	{ 0xff3e,					NULL,			"^" },		/* fullwidth caret */
-	{ 0xff3f,					NULL,			"_" },		/* fullwidth underscore */
-	{ 0xff40,					NULL,			"`" },		/* fullwidth backquote */
-	{ 0xff41,					NULL,			"a" },		/* fullwidth 'a' */
-	{ 0xff42,					NULL,			"b" },		/* fullwidth 'b' */
-	{ 0xff43,					NULL,			"c" },		/* fullwidth 'c' */
-	{ 0xff44,					NULL,			"d" },		/* fullwidth 'd' */
-	{ 0xff45,					NULL,			"e" },		/* fullwidth 'e' */
-	{ 0xff46,					NULL,			"f" },		/* fullwidth 'f' */
-	{ 0xff47,					NULL,			"g" },		/* fullwidth 'g' */
-	{ 0xff48,					NULL,			"h" },		/* fullwidth 'h' */
-	{ 0xff49,					NULL,			"i" },		/* fullwidth 'i' */
-	{ 0xff4a,					NULL,			"j" },		/* fullwidth 'j' */
-	{ 0xff4b,					NULL,			"k" },		/* fullwidth 'k' */
-	{ 0xff4c,					NULL,			"l" },		/* fullwidth 'l' */
-	{ 0xff4d,					NULL,			"m" },		/* fullwidth 'm' */
-	{ 0xff4e,					NULL,			"n" },		/* fullwidth 'n' */
-	{ 0xff4f,					NULL,			"o" },		/* fullwidth 'o' */
-	{ 0xff50,					NULL,			"p" },		/* fullwidth 'p' */
-	{ 0xff51,					NULL,			"q" },		/* fullwidth 'q' */
-	{ 0xff52,					NULL,			"r" },		/* fullwidth 'r' */
-	{ 0xff53,					NULL,			"s" },		/* fullwidth 's' */
-	{ 0xff54,					NULL,			"t" },		/* fullwidth 't' */
-	{ 0xff55,					NULL,			"u" },		/* fullwidth 'u' */
-	{ 0xff56,					NULL,			"v" },		/* fullwidth 'v' */
-	{ 0xff57,					NULL,			"w" },		/* fullwidth 'w' */
-	{ 0xff58,					NULL,			"x" },		/* fullwidth 'x' */
-	{ 0xff59,					NULL,			"y" },		/* fullwidth 'y' */
-	{ 0xff5a,					NULL,			"z" },		/* fullwidth 'z' */
-	{ 0xff5b,					NULL,			"{" },		/* fullwidth left brace */
-	{ 0xff5c,					NULL,			"|" },		/* fullwidth vertical bar */
-	{ 0xff5d,					NULL,			"}" },		/* fullwidth right brace */
-	{ 0xff5e,					NULL,			"~" },		/* fullwidth tilde */
-	{ 0xff5f,					NULL,			"((" },		/* fullwidth double left parenthesis */
-	{ 0xff60,					NULL,			"))" },		/* fullwidth double right parenthesis */
-	{ 0xffe0,					NULL,			"\xC2\xA2" },		/* fullwidth cent sign */
-	{ 0xffe1,					NULL,			"\xC2\xA3" },		/* fullwidth pound sign */
-	{ 0xffe4,					NULL,			"\xC2\xA4" },		/* fullwidth broken bar */
-	{ 0xffe5,					NULL,			"\xC2\xA5" },		/* fullwidth yen sign */
-	{ 0xffe6,					NULL,			"\xE2\x82\xA9" },	/* fullwidth won sign */
-	{ 0xffe9,					NULL,			"\xE2\x86\x90" },	/* fullwidth left arrow */
-	{ 0xffea,					NULL,			"\xE2\x86\x91" },	/* fullwidth up arrow */
-	{ 0xffeb,					NULL,			"\xE2\x86\x92" },	/* fullwidth right arrow */
-	{ 0xffec,					NULL,			"\xE2\x86\x93" },	/* fullwidth down arrow */
-	{ 0xffed,					NULL,			"\xE2\x96\xAA" },	/* fullwidth solid box */
-	{ 0xffee,					NULL,			"\xE2\x97\xA6" },	/* fullwidth open circle */
-	{ UCHAR_SHIFT_1,			"Shift",		NULL },		/* Shift key */
-	{ UCHAR_SHIFT_2,			"Ctrl",			NULL },		/* Ctrl key */
-	{ UCHAR_MAMEKEY(F1),		"F1",			NULL },		/* F1 function key */
-	{ UCHAR_MAMEKEY(F2),		"F2",			NULL },		/* F2 function key */
-	{ UCHAR_MAMEKEY(F3),		"F3",			NULL },		/* F3 function key */
-	{ UCHAR_MAMEKEY(F4),		"F4",			NULL },		/* F4 function key */
-	{ UCHAR_MAMEKEY(F5),		"F5",			NULL },		/* F5 function key */
-	{ UCHAR_MAMEKEY(F6),		"F6",			NULL },		/* F6 function key */
-	{ UCHAR_MAMEKEY(F7),		"F7",			NULL },		/* F7 function key */
-	{ UCHAR_MAMEKEY(F8),		"F8",			NULL },		/* F8 function key */
-	{ UCHAR_MAMEKEY(F9),		"F9",			NULL },		/* F9 function key */
-	{ UCHAR_MAMEKEY(F10),		"F10",			NULL },		/* F10 function key */
-	{ UCHAR_MAMEKEY(F11),		"F11",			NULL },		/* F11 function key */
-	{ UCHAR_MAMEKEY(F12),		"F12",			NULL },		/* F12 function key */
-	{ UCHAR_MAMEKEY(F13),		"F13",			NULL },		/* F13 function key */
-	{ UCHAR_MAMEKEY(F14),		"F14",			NULL },		/* F14 function key */
-	{ UCHAR_MAMEKEY(F15),		"F15",			NULL },		/* F15 function key */
-	{ UCHAR_MAMEKEY(ESC),		"Esc",			"\033" },	/* Esc key */
-	{ UCHAR_MAMEKEY(INSERT),	"Insert",		NULL },		/* Insert key */
-	{ UCHAR_MAMEKEY(DEL),		"Delete",		"\010" },	/* Delete key */
-	{ UCHAR_MAMEKEY(HOME),		"Home",			"\014" },	/* Home key */
-	{ UCHAR_MAMEKEY(END),		"End",			NULL },		/* End key */
-	{ UCHAR_MAMEKEY(PGUP),		"Page Up",		NULL },		/* Page Up key */
-	{ UCHAR_MAMEKEY(PGDN),		"Page Down",	NULL },		/* Page Down key */
-	{ UCHAR_MAMEKEY(LEFT),		"Cursor Left",	NULL },		/* Cursor Left */
-	{ UCHAR_MAMEKEY(RIGHT),		"Cursor Right",	NULL },		/* Cursor Right */
-	{ UCHAR_MAMEKEY(UP),		"Cursor Up",	NULL },		/* Cursor Up */
-	{ UCHAR_MAMEKEY(DOWN),		"Cursor Down",	NULL },		/* Cursor Down */
-	{ UCHAR_MAMEKEY(0_PAD),		"Keypad 0",		NULL },		/* 0 on the numeric keypad */
-	{ UCHAR_MAMEKEY(1_PAD),		"Keypad 1",		NULL },		/* 1 on the numeric keypad */
-	{ UCHAR_MAMEKEY(2_PAD),		"Keypad 2",		NULL },		/* 2 on the numeric keypad */
-	{ UCHAR_MAMEKEY(3_PAD),		"Keypad 3",		NULL },		/* 3 on the numeric keypad */
-	{ UCHAR_MAMEKEY(4_PAD),		"Keypad 4",		NULL },		/* 4 on the numeric keypad */
-	{ UCHAR_MAMEKEY(5_PAD),		"Keypad 5",		NULL },		/* 5 on the numeric keypad */
-	{ UCHAR_MAMEKEY(6_PAD),		"Keypad 6",		NULL },		/* 6 on the numeric keypad */
-	{ UCHAR_MAMEKEY(7_PAD),		"Keypad 7",		NULL },		/* 7 on the numeric keypad */
-	{ UCHAR_MAMEKEY(8_PAD),		"Keypad 8",		NULL },		/* 8 on the numeric keypad */
-	{ UCHAR_MAMEKEY(9_PAD),		"Keypad 9",		NULL },		/* 9 on the numeric keypad */
-	{ UCHAR_MAMEKEY(SLASH_PAD),	"Keypad /",		NULL },		/* / on the numeric keypad */
-	{ UCHAR_MAMEKEY(ASTERISK),	"Keypad *",		NULL },		/* * on the numeric keypad */
-	{ UCHAR_MAMEKEY(MINUS_PAD),	"Keypad -",		NULL },		/* - on the numeric Keypad */
-	{ UCHAR_MAMEKEY(PLUS_PAD),	"Keypad +",		NULL },		/* + on the numeric Keypad */
-	{ UCHAR_MAMEKEY(DEL_PAD),	"Keypad .",		NULL },		/* . on the numeric keypad */
-	{ UCHAR_MAMEKEY(ENTER_PAD),	"Keypad Enter",	NULL },		/* Enter on the numeric keypad */
-	{ UCHAR_MAMEKEY(PRTSCR),	"Print Screen",	NULL },		/* Print Screen key */
-	{ UCHAR_MAMEKEY(PAUSE),		"Pause",		NULL },		/* Pause key */
-	{ UCHAR_MAMEKEY(LSHIFT),	"Left Shift",	NULL },		/* Left Shift key */
-	{ UCHAR_MAMEKEY(RSHIFT),	"Right Shift",	NULL },		/* Right Shift key */
-	{ UCHAR_MAMEKEY(LCONTROL),	"Left Ctrl",	NULL },		/* Left Control key */
-	{ UCHAR_MAMEKEY(RCONTROL),	"Right Ctrl",	NULL },		/* Right Control key */
-	{ UCHAR_MAMEKEY(LALT),		"Left Alt",		NULL },		/* Left Alt key */
-	{ UCHAR_MAMEKEY(RALT),		"Right Alt",	NULL },		/* Right Alt key */
-	{ UCHAR_MAMEKEY(SCRLOCK),	"Scroll Lock",	NULL },		/* Scroll Lock key */
-	{ UCHAR_MAMEKEY(NUMLOCK),	"Num Lock",		NULL },		/* Num Lock key */
-	{ UCHAR_MAMEKEY(CAPSLOCK),	"Caps Lock",	NULL },		/* Caps Lock key */
-	{ UCHAR_MAMEKEY(LWIN),		"Left Win",		NULL },		/* Left Win key */
-	{ UCHAR_MAMEKEY(RWIN),		"Right Win",	NULL },		/* Right Win key */
-	{ UCHAR_MAMEKEY(MENU),		"Menu",			NULL },		/* Menu key */
-	{ UCHAR_MAMEKEY(CANCEL),	"Break",		NULL }		/* Break/Pause key */
+	{ 0x0008,					"Backspace",	NULL },		// Backspace
+	{ 0x0009,					"Tab",			"    " },	// Tab
+	{ 0x000c,					"Clear",		NULL },		// Clear
+	{ 0x000d,					"Enter",		NULL },		// Enter
+	{ 0x001a,					"Esc",			NULL },		// Esc
+	{ 0x0020,					"Space",		" " },		// Space
+	{ 0x0061,					NULL,			"A" },		// a
+	{ 0x0062,					NULL,			"B" },		// b
+	{ 0x0063,					NULL,			"C" },		// c
+	{ 0x0064,					NULL,			"D" },		// d
+	{ 0x0065,					NULL,			"E" },		// e
+	{ 0x0066,					NULL,			"F" },		// f
+	{ 0x0067,					NULL,			"G" },		// g
+	{ 0x0068,					NULL,			"H" },		// h
+	{ 0x0069,					NULL,			"I" },		// i
+	{ 0x006a,					NULL,			"J" },		// j
+	{ 0x006b,					NULL,			"K" },		// k
+	{ 0x006c,					NULL,			"L" },		// l
+	{ 0x006d,					NULL,			"M" },		// m
+	{ 0x006e,					NULL,			"N" },		// n
+	{ 0x006f,					NULL,			"O" },		// o
+	{ 0x0070,					NULL,			"P" },		// p
+	{ 0x0071,					NULL,			"Q" },		// q
+	{ 0x0072,					NULL,			"R" },		// r
+	{ 0x0073,					NULL,			"S" },		// s
+	{ 0x0074,					NULL,			"T" },		// t
+	{ 0x0075,					NULL,			"U" },		// u
+	{ 0x0076,					NULL,			"V" },		// v
+	{ 0x0077,					NULL,			"W" },		// w
+	{ 0x0078,					NULL,			"X" },		// x
+	{ 0x0079,					NULL,			"Y" },		// y
+	{ 0x007a,					NULL,			"Z" },		// z
+	{ 0x00a0,					NULL,			" " },		// non breaking space
+	{ 0x00a1,					NULL,			"!" },		// inverted exclaimation mark
+	{ 0x00a6,					NULL,			"|" },		// broken bar
+	{ 0x00a9,					NULL,			"(c)" },	// copyright sign
+	{ 0x00ab,					NULL,			"<<" },		// left pointing double angle
+	{ 0x00ae,					NULL,			"(r)" },	// registered sign
+	{ 0x00bb,					NULL,			">>" },		// right pointing double angle
+	{ 0x00bc,					NULL,			"1/4" },	// vulgar fraction one quarter
+	{ 0x00bd,					NULL,			"1/2" },	// vulgar fraction one half
+	{ 0x00be,					NULL,			"3/4" },	// vulgar fraction three quarters
+	{ 0x00bf,					NULL,			"?" },		// inverted question mark
+	{ 0x00c0,					NULL,			"A" },		// 'A' grave
+	{ 0x00c1,					NULL,			"A" },		// 'A' acute
+	{ 0x00c2,					NULL,			"A" },		// 'A' circumflex
+	{ 0x00c3,					NULL,			"A" },		// 'A' tilde
+	{ 0x00c4,					NULL,			"A" },		// 'A' diaeresis
+	{ 0x00c5,					NULL,			"A" },		// 'A' ring above
+	{ 0x00c6,					NULL,			"AE" },		// 'AE' ligature
+	{ 0x00c7,					NULL,			"C" },		// 'C' cedilla
+	{ 0x00c8,					NULL,			"E" },		// 'E' grave
+	{ 0x00c9,					NULL,			"E" },		// 'E' acute
+	{ 0x00ca,					NULL,			"E" },		// 'E' circumflex
+	{ 0x00cb,					NULL,			"E" },		// 'E' diaeresis
+	{ 0x00cc,					NULL,			"I" },		// 'I' grave
+	{ 0x00cd,					NULL,			"I" },		// 'I' acute
+	{ 0x00ce,					NULL,			"I" },		// 'I' circumflex
+	{ 0x00cf,					NULL,			"I" },		// 'I' diaeresis
+	{ 0x00d0,					NULL,			"D" },		// 'ETH'
+	{ 0x00d1,					NULL,			"N" },		// 'N' tilde
+	{ 0x00d2,					NULL,			"O" },		// 'O' grave
+	{ 0x00d3,					NULL,			"O" },		// 'O' acute
+	{ 0x00d4,					NULL,			"O" },		// 'O' circumflex
+	{ 0x00d5,					NULL,			"O" },		// 'O' tilde
+	{ 0x00d6,					NULL,			"O" },		// 'O' diaeresis
+	{ 0x00d7,					NULL,			"X" },		// multiplication sign
+	{ 0x00d8,					NULL,			"O" },		// 'O' stroke
+	{ 0x00d9,					NULL,			"U" },		// 'U' grave
+	{ 0x00da,					NULL,			"U" },		// 'U' acute
+	{ 0x00db,					NULL,			"U" },		// 'U' circumflex
+	{ 0x00dc,					NULL,			"U" },		// 'U' diaeresis
+	{ 0x00dd,					NULL,			"Y" },		// 'Y' acute
+	{ 0x00df,					NULL,			"SS" },		// sharp S
+	{ 0x00e0,					NULL,			"a" },		// 'a' grave
+	{ 0x00e1,					NULL,			"a" },		// 'a' acute
+	{ 0x00e2,					NULL,			"a" },		// 'a' circumflex
+	{ 0x00e3,					NULL,			"a" },		// 'a' tilde
+	{ 0x00e4,					NULL,			"a" },		// 'a' diaeresis
+	{ 0x00e5,					NULL,			"a" },		// 'a' ring above
+	{ 0x00e6,					NULL,			"ae" },		// 'ae' ligature
+	{ 0x00e7,					NULL,			"c" },		// 'c' cedilla
+	{ 0x00e8,					NULL,			"e" },		// 'e' grave
+	{ 0x00e9,					NULL,			"e" },		// 'e' acute
+	{ 0x00ea,					NULL,			"e" },		// 'e' circumflex
+	{ 0x00eb,					NULL,			"e" },		// 'e' diaeresis
+	{ 0x00ec,					NULL,			"i" },		// 'i' grave
+	{ 0x00ed,					NULL,			"i" },		// 'i' acute
+	{ 0x00ee,					NULL,			"i" },		// 'i' circumflex
+	{ 0x00ef,					NULL,			"i" },		// 'i' diaeresis
+	{ 0x00f0,					NULL,			"d" },		// 'eth'
+	{ 0x00f1,					NULL,			"n" },		// 'n' tilde
+	{ 0x00f2,					NULL,			"o" },		// 'o' grave
+	{ 0x00f3,					NULL,			"o" },		// 'o' acute
+	{ 0x00f4,					NULL,			"o" },		// 'o' circumflex
+	{ 0x00f5,					NULL,			"o" },		// 'o' tilde
+	{ 0x00f6,					NULL,			"o" },		// 'o' diaeresis
+	{ 0x00f8,					NULL,			"o" },		// 'o' stroke
+	{ 0x00f9,					NULL,			"u" },		// 'u' grave
+	{ 0x00fa,					NULL,			"u" },		// 'u' acute
+	{ 0x00fb,					NULL,			"u" },		// 'u' circumflex
+	{ 0x00fc,					NULL,			"u" },		// 'u' diaeresis
+	{ 0x00fd,					NULL,			"y" },		// 'y' acute
+	{ 0x00ff,					NULL,			"y" },		// 'y' diaeresis
+	{ 0x2010,					NULL,			"-" },		// hyphen
+	{ 0x2011,					NULL,			"-" },		// non-breaking hyphen
+	{ 0x2012,					NULL,			"-" },		// figure dash
+	{ 0x2013,					NULL,			"-" },		// en dash
+	{ 0x2014,					NULL,			"-" },		// em dash
+	{ 0x2015,					NULL,			"-" },		// horizontal dash
+	{ 0x2018,					NULL,			"\'" },		// left single quotation mark
+	{ 0x2019,					NULL,			"\'" },		// right single quotation mark
+	{ 0x201a,					NULL,			"\'" },		// single low quotation mark
+	{ 0x201b,					NULL,			"\'" },		// single high reversed quotation mark
+	{ 0x201c,					NULL,			"\"" },		// left double quotation mark
+	{ 0x201d,					NULL,			"\"" },		// right double quotation mark
+	{ 0x201e,					NULL,			"\"" },		// double low quotation mark
+	{ 0x201f,					NULL,			"\"" },		// double high reversed quotation mark
+	{ 0x2024,					NULL,			"." },		// one dot leader
+	{ 0x2025,					NULL,			".." },		// two dot leader
+	{ 0x2026,					NULL,			"..." },	// horizontal ellipsis
+	{ 0x2047,					NULL,			"??" },		// double question mark
+	{ 0x2048,					NULL,			"?!" },		// question exclamation mark
+	{ 0x2049,					NULL,			"!?" },		// exclamation question mark
+	{ 0xff01,					NULL,			"!" },		// fullwidth exclamation point
+	{ 0xff02,					NULL,			"\"" },		// fullwidth quotation mark
+	{ 0xff03,					NULL,			"#" },		// fullwidth number sign
+	{ 0xff04,					NULL,			"$" },		// fullwidth dollar sign
+	{ 0xff05,					NULL,			"%" },		// fullwidth percent sign
+	{ 0xff06,					NULL,			"&" },		// fullwidth ampersand
+	{ 0xff07,					NULL,			"\'" },		// fullwidth apostrophe
+	{ 0xff08,					NULL,			"(" },		// fullwidth left parenthesis
+	{ 0xff09,					NULL,			")" },		// fullwidth right parenthesis
+	{ 0xff0a,					NULL,			"*" },		// fullwidth asterisk
+	{ 0xff0b,					NULL,			"+" },		// fullwidth plus
+	{ 0xff0c,					NULL,			"," },		// fullwidth comma
+	{ 0xff0d,					NULL,			"-" },		// fullwidth minus
+	{ 0xff0e,					NULL,			"." },		// fullwidth period
+	{ 0xff0f,					NULL,			"/" },		// fullwidth slash
+	{ 0xff10,					NULL,			"0" },		// fullwidth zero
+	{ 0xff11,					NULL,			"1" },		// fullwidth one
+	{ 0xff12,					NULL,			"2" },		// fullwidth two
+	{ 0xff13,					NULL,			"3" },		// fullwidth three
+	{ 0xff14,					NULL,			"4" },		// fullwidth four
+	{ 0xff15,					NULL,			"5" },		// fullwidth five
+	{ 0xff16,					NULL,			"6" },		// fullwidth six
+	{ 0xff17,					NULL,			"7" },		// fullwidth seven
+	{ 0xff18,					NULL,			"8" },		// fullwidth eight
+	{ 0xff19,					NULL,			"9" },		// fullwidth nine
+	{ 0xff1a,					NULL,			":" },		// fullwidth colon
+	{ 0xff1b,					NULL,			";" },		// fullwidth semicolon
+	{ 0xff1c,					NULL,			"<" },		// fullwidth less than sign
+	{ 0xff1d,					NULL,			"=" },		// fullwidth equals sign
+	{ 0xff1e,					NULL,			">" },		// fullwidth greater than sign
+	{ 0xff1f,					NULL,			"?" },		// fullwidth question mark
+	{ 0xff20,					NULL,			"@" },		// fullwidth at sign
+	{ 0xff21,					NULL,			"A" },		// fullwidth 'A'
+	{ 0xff22,					NULL,			"B" },		// fullwidth 'B'
+	{ 0xff23,					NULL,			"C" },		// fullwidth 'C'
+	{ 0xff24,					NULL,			"D" },		// fullwidth 'D'
+	{ 0xff25,					NULL,			"E" },		// fullwidth 'E'
+	{ 0xff26,					NULL,			"F" },		// fullwidth 'F'
+	{ 0xff27,					NULL,			"G" },		// fullwidth 'G'
+	{ 0xff28,					NULL,			"H" },		// fullwidth 'H'
+	{ 0xff29,					NULL,			"I" },		// fullwidth 'I'
+	{ 0xff2a,					NULL,			"J" },		// fullwidth 'J'
+	{ 0xff2b,					NULL,			"K" },		// fullwidth 'K'
+	{ 0xff2c,					NULL,			"L" },		// fullwidth 'L'
+	{ 0xff2d,					NULL,			"M" },		// fullwidth 'M'
+	{ 0xff2e,					NULL,			"N" },		// fullwidth 'N'
+	{ 0xff2f,					NULL,			"O" },		// fullwidth 'O'
+	{ 0xff30,					NULL,			"P" },		// fullwidth 'P'
+	{ 0xff31,					NULL,			"Q" },		// fullwidth 'Q'
+	{ 0xff32,					NULL,			"R" },		// fullwidth 'R'
+	{ 0xff33,					NULL,			"S" },		// fullwidth 'S'
+	{ 0xff34,					NULL,			"T" },		// fullwidth 'T'
+	{ 0xff35,					NULL,			"U" },		// fullwidth 'U'
+	{ 0xff36,					NULL,			"V" },		// fullwidth 'V'
+	{ 0xff37,					NULL,			"W" },		// fullwidth 'W'
+	{ 0xff38,					NULL,			"X" },		// fullwidth 'X'
+	{ 0xff39,					NULL,			"Y" },		// fullwidth 'Y'
+	{ 0xff3a,					NULL,			"Z" },		// fullwidth 'Z'
+	{ 0xff3b,					NULL,			"[" },		// fullwidth left bracket
+	{ 0xff3c,					NULL,			"\\" },		// fullwidth backslash
+	{ 0xff3d,					NULL,			"]"	},		// fullwidth right bracket
+	{ 0xff3e,					NULL,			"^" },		// fullwidth caret
+	{ 0xff3f,					NULL,			"_" },		// fullwidth underscore
+	{ 0xff40,					NULL,			"`" },		// fullwidth backquote
+	{ 0xff41,					NULL,			"a" },		// fullwidth 'a'
+	{ 0xff42,					NULL,			"b" },		// fullwidth 'b'
+	{ 0xff43,					NULL,			"c" },		// fullwidth 'c'
+	{ 0xff44,					NULL,			"d" },		// fullwidth 'd'
+	{ 0xff45,					NULL,			"e" },		// fullwidth 'e'
+	{ 0xff46,					NULL,			"f" },		// fullwidth 'f'
+	{ 0xff47,					NULL,			"g" },		// fullwidth 'g'
+	{ 0xff48,					NULL,			"h" },		// fullwidth 'h'
+	{ 0xff49,					NULL,			"i" },		// fullwidth 'i'
+	{ 0xff4a,					NULL,			"j" },		// fullwidth 'j'
+	{ 0xff4b,					NULL,			"k" },		// fullwidth 'k'
+	{ 0xff4c,					NULL,			"l" },		// fullwidth 'l'
+	{ 0xff4d,					NULL,			"m" },		// fullwidth 'm'
+	{ 0xff4e,					NULL,			"n" },		// fullwidth 'n'
+	{ 0xff4f,					NULL,			"o" },		// fullwidth 'o'
+	{ 0xff50,					NULL,			"p" },		// fullwidth 'p'
+	{ 0xff51,					NULL,			"q" },		// fullwidth 'q'
+	{ 0xff52,					NULL,			"r" },		// fullwidth 'r'
+	{ 0xff53,					NULL,			"s" },		// fullwidth 's'
+	{ 0xff54,					NULL,			"t" },		// fullwidth 't'
+	{ 0xff55,					NULL,			"u" },		// fullwidth 'u'
+	{ 0xff56,					NULL,			"v" },		// fullwidth 'v'
+	{ 0xff57,					NULL,			"w" },		// fullwidth 'w'
+	{ 0xff58,					NULL,			"x" },		// fullwidth 'x'
+	{ 0xff59,					NULL,			"y" },		// fullwidth 'y'
+	{ 0xff5a,					NULL,			"z" },		// fullwidth 'z'
+	{ 0xff5b,					NULL,			"{" },		// fullwidth left brace
+	{ 0xff5c,					NULL,			"|" },		// fullwidth vertical bar
+	{ 0xff5d,					NULL,			"}" },		// fullwidth right brace
+	{ 0xff5e,					NULL,			"~" },		// fullwidth tilde
+	{ 0xff5f,					NULL,			"((" },		// fullwidth double left parenthesis
+	{ 0xff60,					NULL,			"))" },		// fullwidth double right parenthesis
+	{ 0xffe0,					NULL,			"\xC2\xA2" },		// fullwidth cent sign
+	{ 0xffe1,					NULL,			"\xC2\xA3" },		// fullwidth pound sign
+	{ 0xffe4,					NULL,			"\xC2\xA4" },		// fullwidth broken bar
+	{ 0xffe5,					NULL,			"\xC2\xA5" },		// fullwidth yen sign
+	{ 0xffe6,					NULL,			"\xE2\x82\xA9" },	// fullwidth won sign
+	{ 0xffe9,					NULL,			"\xE2\x86\x90" },	// fullwidth left arrow
+	{ 0xffea,					NULL,			"\xE2\x86\x91" },	// fullwidth up arrow
+	{ 0xffeb,					NULL,			"\xE2\x86\x92" },	// fullwidth right arrow
+	{ 0xffec,					NULL,			"\xE2\x86\x93" },	// fullwidth down arrow
+	{ 0xffed,					NULL,			"\xE2\x96\xAA" },	// fullwidth solid box
+	{ 0xffee,					NULL,			"\xE2\x97\xA6" },	// fullwidth open circle
+	{ UCHAR_SHIFT_1,			"Shift",		NULL },		// Shift key
+	{ UCHAR_SHIFT_2,			"Ctrl",			NULL },		// Ctrl key
+	{ UCHAR_MAMEKEY(F1),		"F1",			NULL },		// F1 function key
+	{ UCHAR_MAMEKEY(F2),		"F2",			NULL },		// F2 function key
+	{ UCHAR_MAMEKEY(F3),		"F3",			NULL },		// F3 function key
+	{ UCHAR_MAMEKEY(F4),		"F4",			NULL },		// F4 function key
+	{ UCHAR_MAMEKEY(F5),		"F5",			NULL },		// F5 function key
+	{ UCHAR_MAMEKEY(F6),		"F6",			NULL },		// F6 function key
+	{ UCHAR_MAMEKEY(F7),		"F7",			NULL },		// F7 function key
+	{ UCHAR_MAMEKEY(F8),		"F8",			NULL },		// F8 function key
+	{ UCHAR_MAMEKEY(F9),		"F9",			NULL },		// F9 function key
+	{ UCHAR_MAMEKEY(F10),		"F10",			NULL },		// F10 function key
+	{ UCHAR_MAMEKEY(F11),		"F11",			NULL },		// F11 function key
+	{ UCHAR_MAMEKEY(F12),		"F12",			NULL },		// F12 function key
+	{ UCHAR_MAMEKEY(F13),		"F13",			NULL },		// F13 function key
+	{ UCHAR_MAMEKEY(F14),		"F14",			NULL },		// F14 function key
+	{ UCHAR_MAMEKEY(F15),		"F15",			NULL },		// F15 function key
+	{ UCHAR_MAMEKEY(ESC),		"Esc",			"\033" },	// Esc key
+	{ UCHAR_MAMEKEY(INSERT),	"Insert",		NULL },		// Insert key
+	{ UCHAR_MAMEKEY(DEL),		"Delete",		"\010" },	// Delete key
+	{ UCHAR_MAMEKEY(HOME),		"Home",			"\014" },	// Home key
+	{ UCHAR_MAMEKEY(END),		"End",			NULL },		// End key
+	{ UCHAR_MAMEKEY(PGUP),		"Page Up",		NULL },		// Page Up key
+	{ UCHAR_MAMEKEY(PGDN),		"Page Down",	NULL },		// Page Down key
+	{ UCHAR_MAMEKEY(LEFT),		"Cursor Left",	NULL },		// Cursor Left
+	{ UCHAR_MAMEKEY(RIGHT),		"Cursor Right",	NULL },		// Cursor Right
+	{ UCHAR_MAMEKEY(UP),		"Cursor Up",	NULL },		// Cursor Up
+	{ UCHAR_MAMEKEY(DOWN),		"Cursor Down",	NULL },		// Cursor Down
+	{ UCHAR_MAMEKEY(0_PAD),		"Keypad 0",		NULL },		// 0 on the numeric keypad
+	{ UCHAR_MAMEKEY(1_PAD),		"Keypad 1",		NULL },		// 1 on the numeric keypad
+	{ UCHAR_MAMEKEY(2_PAD),		"Keypad 2",		NULL },		// 2 on the numeric keypad
+	{ UCHAR_MAMEKEY(3_PAD),		"Keypad 3",		NULL },		// 3 on the numeric keypad
+	{ UCHAR_MAMEKEY(4_PAD),		"Keypad 4",		NULL },		// 4 on the numeric keypad
+	{ UCHAR_MAMEKEY(5_PAD),		"Keypad 5",		NULL },		// 5 on the numeric keypad
+	{ UCHAR_MAMEKEY(6_PAD),		"Keypad 6",		NULL },		// 6 on the numeric keypad
+	{ UCHAR_MAMEKEY(7_PAD),		"Keypad 7",		NULL },		// 7 on the numeric keypad
+	{ UCHAR_MAMEKEY(8_PAD),		"Keypad 8",		NULL },		// 8 on the numeric keypad
+	{ UCHAR_MAMEKEY(9_PAD),		"Keypad 9",		NULL },		// 9 on the numeric keypad
+	{ UCHAR_MAMEKEY(SLASH_PAD),	"Keypad /",		NULL },		// / on the numeric keypad
+	{ UCHAR_MAMEKEY(ASTERISK),	"Keypad *",		NULL },		// * on the numeric keypad
+	{ UCHAR_MAMEKEY(MINUS_PAD),	"Keypad -",		NULL },		// - on the numeric Keypad
+	{ UCHAR_MAMEKEY(PLUS_PAD),	"Keypad +",		NULL },		// + on the numeric Keypad
+	{ UCHAR_MAMEKEY(DEL_PAD),	"Keypad .",		NULL },		// . on the numeric keypad
+	{ UCHAR_MAMEKEY(ENTER_PAD),	"Keypad Enter",	NULL },		// Enter on the numeric keypad
+	{ UCHAR_MAMEKEY(PRTSCR),	"Print Screen",	NULL },		// Print Screen key
+	{ UCHAR_MAMEKEY(PAUSE),		"Pause",		NULL },		// Pause key
+	{ UCHAR_MAMEKEY(LSHIFT),	"Left Shift",	NULL },		// Left Shift key
+	{ UCHAR_MAMEKEY(RSHIFT),	"Right Shift",	NULL },		// Right Shift key
+	{ UCHAR_MAMEKEY(LCONTROL),	"Left Ctrl",	NULL },		// Left Control key
+	{ UCHAR_MAMEKEY(RCONTROL),	"Right Ctrl",	NULL },		// Right Control key
+	{ UCHAR_MAMEKEY(LALT),		"Left Alt",		NULL },		// Left Alt key
+	{ UCHAR_MAMEKEY(RALT),		"Right Alt",	NULL },		// Right Alt key
+	{ UCHAR_MAMEKEY(SCRLOCK),	"Scroll Lock",	NULL },		// Scroll Lock key
+	{ UCHAR_MAMEKEY(NUMLOCK),	"Num Lock",		NULL },		// Num Lock key
+	{ UCHAR_MAMEKEY(CAPSLOCK),	"Caps Lock",	NULL },		// Caps Lock key
+	{ UCHAR_MAMEKEY(LWIN),		"Left Win",		NULL },		// Left Win key
+	{ UCHAR_MAMEKEY(RWIN),		"Right Win",	NULL },		// Right Win key
+	{ UCHAR_MAMEKEY(MENU),		"Menu",			NULL },		// Menu key
+	{ UCHAR_MAMEKEY(CANCEL),	"Break",		NULL }		// Break/Pause key
 };
 
-static TIMER_CALLBACK(inputx_timerproc);
-
 
-/*  Debugging commands and handlers. */
-static void execute_input(running_machine &machine, int ref, int params, const char *param[]);
-static void execute_dumpkbd(running_machine &machine, int ref, int params, const char *param[]);
 
-/***************************************************************************
-    COMMON SHARED STRINGS
-***************************************************************************/
+//**************************************************************************
+//  COMMON SHARED STRINGS
+//**************************************************************************
 
 static const struct
 {
@@ -686,2304 +782,1446 @@
 
 
 
-/***************************************************************************
-    BUILT-IN CORE MAPPINGS
-***************************************************************************/
+//**************************************************************************
+//  BUILT-IN CORE MAPPINGS
+//**************************************************************************
 
 #include "inpttype.h"
 
 
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-/* core system management */
-static void input_port_exit(running_machine &machine);
+//**************************************************************************
+//  PORT CONFIGURATIONS
+//**************************************************************************
+
+//**************************************************************************
+//  I/O PORT LIST
+//**************************************************************************
+
+//-------------------------------------------------
+//  append - append the given device's input ports
+//  to the current list
+//-------------------------------------------------
 
-/* port reading */
-static INT32 apply_analog_settings(INT32 current, analog_field_state *analog);
+void ioport_list::append(device_t &device, astring &errorbuf)
+{
+	// no constructor, no list
+	ioport_constructor constructor = device.input_ports();
+	if (constructor == NULL)
+		return;
 
-/* initialization helpers */
-static void init_port_types(running_machine &machine);
-static void init_port_state(running_machine &machine);
-static void init_autoselect_devices(running_machine &machine, int type1, int type2, int type3, const char *option, const char *ananame);
-static device_field_info *init_field_device_info(const input_field_config *field,const char *device_name);
-static analog_field_state *init_field_analog_state(const input_field_config *field);
-
-/* once-per-frame updates */
-static void frame_update_callback(running_machine &machine);
-static void frame_update(running_machine &machine);
-static void frame_update_digital_joysticks(running_machine &machine);
-static void frame_update_analog_field(running_machine &machine, analog_field_state *analog);
-static int frame_get_digital_field_state(const input_field_config *field, int mouse_down);
-
-/* tokenization helpers */
-static int token_to_input_field_type(running_machine &machine, const char *string, int *player);
-static const char *input_field_type_to_token(running_machine &machine, int type, int player);
-static int token_to_seq_type(const char *string);
-
-/* settings load */
-static void load_config_callback(running_machine &machine, int config_type, xml_data_node *parentnode);
-static void load_remap_table(running_machine &machine, xml_data_node *parentnode);
-static int load_default_config(running_machine &machine, xml_data_node *portnode, int type, int player, const input_seq *newseq);
-static int load_game_config(running_machine &machine, xml_data_node *portnode, int type, int player, const input_seq *newseq);
-
-/* settings save */
-static void save_config_callback(running_machine &machine, int config_type, xml_data_node *parentnode);
-static void save_sequence(running_machine &machine, xml_data_node *parentnode, int type, int porttype, const input_seq &seq);
-static int save_this_input_field_type(int type);
-static void save_default_inputs(running_machine &machine, xml_data_node *parentnode);
-static void save_game_inputs(running_machine &machine, xml_data_node *parentnode);
-
-/* input playback */
-static time_t playback_init(running_machine &machine);
-static void playback_end(running_machine &machine, const char *message);
-static void playback_frame(running_machine &machine, attotime curtime);
-static void playback_port(const input_port_config *port);
-
-/* input recording */
-static void record_init(running_machine &machine);
-static void record_end(running_machine &machine, const char *message);
-static void record_frame(running_machine &machine, attotime curtime);
-static void record_port(const input_port_config *port);
+	// reset error buffer
+	errorbuf.reset();
 
+	// detokenize into the list
+	(*constructor)(device, *this, errorbuf);
 
+	// collapse fields and sort the list
+	for (ioport_port *port = first(); port != NULL; port = port->next())
+		port->collapse_fields(errorbuf);
+}
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
 
-/*-------------------------------------------------
-    apply_analog_min_max - clamp the given input
-    value to the appropriate min/max for the
-    analog control
--------------------------------------------------*/
-
-INLINE INT32 apply_analog_min_max(const analog_field_state *analog, INT32 value)
-{
-	/* take the analog minimum and maximum values and apply the inverse of the */
-	/* sensitivity so that we can clamp against them before applying sensitivity */
-	INT32 adjmin = APPLY_INVERSE_SENSITIVITY(analog->minimum, analog->sensitivity);
-	INT32 adjmax = APPLY_INVERSE_SENSITIVITY(analog->maximum, analog->sensitivity);
 
-	/* for absolute devices, clamp to the bounds absolutely */
-	if (!analog->wraps)
-	{
-		if (value > adjmax)
-			value = adjmax;
-		else if (value < adjmin)
-			value = adjmin;
-	}
+//**************************************************************************
+//  INPUT TYPE ENTRY
+//**************************************************************************
 
-	/* for relative devices, wrap around when we go past the edge */
-	else
-	{
-		INT32 range = adjmax - adjmin;
-		/* rolls to other end when 1 position past end. */
-		value = (value - adjmin) % range;
-		if (value < 0)
-			value += range;
-		value += adjmin;
-	}
+//-------------------------------------------------
+//  input_type_entry - constructors
+//-------------------------------------------------
 
-	return value;
+input_type_entry::input_type_entry(ioport_type type, ioport_group group, int player, const char *token, const char *name, input_seq standard)
+	: m_next(NULL),
+	  m_type(type),
+	  m_group(group),
+	  m_player(player),
+	  m_token(token),
+	  m_name(name)
+{
+	m_defseq[SEQ_TYPE_STANDARD] = m_seq[SEQ_TYPE_STANDARD] = standard;
 }
 
-
-/*-------------------------------------------------
-    get_port_tag - return a guaranteed tag for
-    a port
--------------------------------------------------*/
-
-INLINE const char *get_port_tag(const input_port_config *port, char *tempbuffer)
+input_type_entry::input_type_entry(ioport_type type, ioport_group group, int player, const char *token, const char *name, input_seq standard, input_seq decrement, input_seq increment)
+	: m_next(NULL),
+	  m_type(type),
+	  m_group(group),
+	  m_player(player),
+	  m_token(token),
+	  m_name(name)
 {
-	return port->tag();
+	m_defseq[SEQ_TYPE_STANDARD] = m_seq[SEQ_TYPE_STANDARD] = standard;
+	m_defseq[SEQ_TYPE_INCREMENT] = m_seq[SEQ_TYPE_INCREMENT] = increment;
+	m_defseq[SEQ_TYPE_DECREMENT] = m_seq[SEQ_TYPE_DECREMENT] = decrement;
 }
 
 
-/*-------------------------------------------------
-    condition_equal - TRUE if two conditions are
-    equivalent
--------------------------------------------------*/
+//-------------------------------------------------
+//  configure_osd - set the token and name of an
+//  OSD entry
+//-------------------------------------------------
 
-INLINE int condition_equal(const input_condition *cond1, const input_condition *cond2)
+void input_type_entry::configure_osd(const char *token, const char *name)
 {
-	return (cond1->mask == cond2->mask && cond1->value == cond2->value && cond1->condition == cond2->condition && strcmp(cond1->tag, cond2->tag) == 0);
+	assert(m_type >= IPT_OSD_1 && m_type <= IPT_OSD_16);
+	m_token = token;
+	m_name = name;
 }
 
 
+//**************************************************************************
+//  DIGITAL JOYSTICKS
+//**************************************************************************
 
-/***************************************************************************
-    CORE SYSTEM MANAGEMENT
-***************************************************************************/
-
-/*-------------------------------------------------
-    input_port_init - initialize the input port
-    system
--------------------------------------------------*/
+//-------------------------------------------------
+//  digital_joystick - constructor
+//-------------------------------------------------
 
-ioport_manager::ioport_manager(running_machine &machine)
-	: safe_to_read(false),
-	  last_frame_time(attotime::zero),
-	  last_delta_nsec(0),
-	  record_file(NULL),
-	  playback_file(NULL),
-	  playback_accumulated_speed(0),
-	  playback_accumulated_frames(0),
-	  codes(NULL),
-	  inputx_timer(NULL),
-	  queue_chars(NULL),
-	  accept_char(NULL),
-	  charqueue_empty(NULL),
-	  current_rate(attotime::zero),
-	  m_machine(machine)
+digital_joystick::digital_joystick(int player, int number)
+	: m_player(player),
+	  m_number(number),
+	  m_current(0),
+	  m_current4way(0),
+	  m_previous(0)
 {
-	memset(type_to_entry, 0, sizeof(type_to_entry));
-	memset(joystick_info, 0, sizeof(joystick_info));
+	memset(m_field, 0, sizeof(m_field));
 }
 
-time_t ioport_manager::initialize()
-{
-	/* add an exit callback and a frame callback */
-	machine().add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(input_port_exit), &machine()));
-	machine().add_notifier(MACHINE_NOTIFY_FRAME, machine_notify_delegate(FUNC(frame_update_callback), &machine()));
-
-	/* initialize the default port info from the OSD */
-	init_port_types(machine());
-
-	/* if we have a token list, proceed */
-	device_iterator iter(machine().root_device());
-	for (device_t *device = iter.first(); device != NULL; device = iter.next())
-	{
-		astring errors;
-		input_port_list_init(*device, m_portlist, errors);
-		if (errors)
-			mame_printf_error("Input port errors:\n%s", errors.cstr());
-	}
-
-	init_port_state(machine());
-	/* register callbacks for when we load configurations */
-	config_register(machine(), "input", config_saveload_delegate(FUNC(load_config_callback), &machine()), config_saveload_delegate(FUNC(save_config_callback), &machine()));
-
-	/* open playback and record files if specified */
-	time_t basetime = playback_init(machine());
-	record_init(machine());
-
-	return basetime;
-}
 
+//-------------------------------------------------
+//  set_axis - configure a single axis of a
+//  digital joystick
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    input_port_exit - exit callback to ensure
-    we clean up and close our files
--------------------------------------------------*/
-
-static void input_port_exit(running_machine &machine)
-{
-	/* close any playback or recording files */
-	playback_end(machine, NULL);
-	record_end(machine, NULL);
+digital_joystick::direction_t digital_joystick::set_axis(ioport_field &field)
+{
+	direction_t direction = direction_t((field.type() - (IPT_DIGITAL_JOYSTICK_FIRST + 1)) % 4);
+	m_field[direction] = &field;
+	return direction;
 }
 
 
+//-------------------------------------------------
+//  frame_update - update the state of digital
+//  joysticks prior to accumulating the results
+//  in a port
+//-------------------------------------------------
 
-/***************************************************************************
-    PORT CONFIGURATIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    input_port_list_init - initialize an input
-    port list structure and allocate ports
-    according to the given tokens
--------------------------------------------------*/
-
-void input_port_list_init(device_t &device, ioport_list &portlist, astring &errorbuf)
+void digital_joystick::frame_update()
 {
-	/* no constructor, no list */
-	ioport_constructor constructor = device.input_ports();
-	if (constructor == NULL)
-		return;
+	// remember previous state and reset current state
+	m_previous = m_current;
+	m_current = 0;
 
-	/* reset error buffer */
-	errorbuf.reset();
-
-	/* detokenize into the list */
-	(*constructor)(device, portlist, errorbuf);
+	// read all the associated ports
+	running_machine *machine = NULL;
+	for (direction_t direction = JOYDIR_UP; direction < JOYDIR_COUNT; direction++)
+		if (m_field[direction] != NULL)
+		{
+			machine = &m_field[direction]->machine();
+			if (machine->input().seq_pressed(m_field[direction]->seq(SEQ_TYPE_STANDARD)))
+				m_current |= 1 << direction;
+		}
 
-	// collapse fields and sort the list
-	for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
-		port->collapse_fields(errorbuf);
-}
+	// lock out opposing directions (left + right or up + down)
+	if ((m_current & (UP_BIT | DOWN_BIT)) == (UP_BIT | DOWN_BIT))
+		m_current &= ~(UP_BIT | DOWN_BIT);
+	if ((m_current & (LEFT_BIT | RIGHT_BIT)) == (LEFT_BIT | RIGHT_BIT))
+		m_current &= ~(LEFT_BIT | RIGHT_BIT);
 
+	// only update 4-way case if joystick has moved
+	if (m_current != m_previous)
+	{
+		m_current4way = m_current;
 
-/*-------------------------------------------------
-    input_field_by_tag_and_mask - return a pointer
-    to the first field that intersects the given
-    mask on the tagged port
--------------------------------------------------*/
-
-const input_field_config *input_field_by_tag_and_mask(running_machine &machine, const char *tag, input_port_value mask)
-{
-	const input_port_config *port = machine.root_device().ioport(tag);
-
-	/* if we got the port, look for the field */
-	if (port != NULL)
-		for (const input_field_config *field = port->first_field(); field != NULL; field = field->next())
-			if ((field->mask & mask) != 0)
-				return field;
+		//
+		//  If joystick is pointing at a diagonal, acknowledge that the player moved
+		//  the joystick by favoring a direction change.  This minimizes frustration
+		//  when using a keyboard for input, and maximizes responsiveness.
+		//
+		//  For example, if you are holding "left" then switch to "up" (where both left
+		//  and up are briefly pressed at the same time), we'll transition immediately
+		//  to "up."
+		//
+		//  Zero any switches that didn't change from the previous to current state.
+		//
+		if ((m_current4way & (UP_BIT | DOWN_BIT)) &&
+			(m_current4way & (LEFT_BIT | RIGHT_BIT)))
+		{
+			m_current4way ^= m_current4way & m_previous;
+		}
 
-	return NULL;
+		//
+		//  If we are still pointing at a diagonal, we are in an indeterminant state.
+		//
+		//  This could happen if the player moved the joystick from the idle position directly
+		//  to a diagonal, or from one diagonal directly to an extreme diagonal.
+		//
+		//  The chances of this happening with a keyboard are slim, but we still need to
+		//  constrain this case.
+		//
+		//  For now, just resolve randomly.
+		//
+		if ((m_current4way & (UP_BIT | DOWN_BIT)) &&
+			(m_current4way & (LEFT_BIT | RIGHT_BIT)))
+		{
+			if (machine->rand() & 1)
+				m_current4way &= ~(LEFT_BIT | RIGHT_BIT);
+			else
+				m_current4way &= ~(UP_BIT | DOWN_BIT);
+		}
+	}
 }
 
 
 
-/***************************************************************************
-    ACCESSORS FOR INPUT FIELDS
-***************************************************************************/
+//**************************************************************************
+//  NATURAL KEYBOARD
+//**************************************************************************
 
-/*-------------------------------------------------
-    input_field_name - return the field name for
-    a given input field
--------------------------------------------------*/
+//-------------------------------------------------
+//  natural_keyboard - constructor
+//-------------------------------------------------
 
-const char *input_field_name(const input_field_config *field)
+natural_keyboard::natural_keyboard(running_machine &machine)
+	: m_machine(machine),
+	  m_bufbegin(0),
+	  m_bufend(0),
+	  m_status_keydown(false),
+	  m_last_cr(false),
+	  m_timer(NULL),
+	  m_current_rate(attotime::zero)
 {
-	/* if we have a non-default name, use that */
-	if ((field->state != NULL) && (field->state->name != NULL))
-		return field->state->name;
-	if (field->name != NULL)
-		return field->name;
+	// reigster debugger commands
+	if (machine.debug_flags & DEBUG_FLAG_ENABLED)
+	{
+		debug_console_register_command(machine, "input", CMDFLAG_NONE, 0, 1, 1, execute_input);
+		debug_console_register_command(machine, "dumpkbd", CMDFLAG_NONE, 0, 0, 1, execute_dumpkbd);
+	}
 
-	/* otherwise, return the name associated with the type */
-	return input_type_name(field->machine(), field->type, field->player);
+	// posting keys directly only makes sense for a computer
+	if (machine.ioport().has_keyboard())
+	{
+		m_buffer.resize(KEY_BUFFER_SIZE);
+		m_timer = machine.scheduler().timer_alloc(timer_expired_delegate(FUNC(natural_keyboard::timer), this));
+		build_codes(machine.ioport());
+	}
 }
 
 
-/*-------------------------------------------------
-    input_field_seq - return the input sequence
-    for the given input field
--------------------------------------------------*/
+//-------------------------------------------------
+//  configure - configure callbacks for full-
+//  featured keyboard support
+//-------------------------------------------------
 
-const input_seq &input_field_seq(const input_field_config *field, input_seq_type seqtype)
+void natural_keyboard::configure(ioport_queue_chars_delegate queue_chars, ioport_accept_char_delegate accept_char, ioport_charqueue_empty_delegate charqueue_empty)
 {
-	/* if the field is disabled, return no key */
-	if (field->flags & FIELD_FLAG_UNUSED)
-		return input_seq::empty_seq;
-
-	/* select either the live or config state depending on whether we have live state */
-	const input_seq &portseq = (field->state == NULL) ? field->seq[seqtype] : field->state->seq[seqtype];
-
-	/* if the portseq is the special default code, return the expanded default value */
-	if (portseq.is_default())
-		return input_type_seq(field->machine(), field->type, field->player, seqtype);
-
-	/* otherwise, return the sequence as-is */
-	return portseq;
+	// set the callbacks
+	m_queue_chars = queue_chars;
+	m_accept_char = accept_char;
+	m_charqueue_empty = charqueue_empty;
 }
 
 
-/*-------------------------------------------------
-    input_field_get_user_settings - return the current
-    settings for the given input field
--------------------------------------------------*/
+//-------------------------------------------------
+//  post - post a single character
+//-------------------------------------------------
 
-void input_field_get_user_settings(const input_field_config *field, input_field_user_settings *settings)
+void natural_keyboard::post(unicode_char ch)
 {
-	int seqtype;
-
-	/* zap the entire structure */
-	memset(settings, 0, sizeof(*settings));
-
-	/* copy the basics */
-	for (seqtype = 0; seqtype < ARRAY_LENGTH(settings->seq); seqtype++)
-		settings->seq[seqtype] = field->state->seq[seqtype];
-
-	/* if there's a list of settings or we're an adjuster, copy the current value */
-	if (field->settinglist().count() != 0 || field->type == IPT_ADJUSTER)
-		settings->value = field->state->value;
-
-	/* if there's analog data, extract the analog settings */
-	if (field->state->analog != NULL)
+	// ignore any \n that are preceded by \r
+	if (m_last_cr && ch == '\n')
 	{
-		settings->sensitivity = field->state->analog->sensitivity;
-		settings->delta = field->state->analog->delta;
-		settings->centerdelta = field->state->analog->centerdelta;
-		settings->reverse = field->state->analog->reverse;
+		m_last_cr = false;
+		return;
 	}
-}
-
-
-/*-------------------------------------------------
-    input_field_set_user_settings - modify the current
-    settings for the given input field
--------------------------------------------------*/
 
-void input_field_set_user_settings(const input_field_config *field, const input_field_user_settings *settings)
-{
-	int seqtype;
+	// change all eolns to '\r'
+	if (ch == '\n')
+		ch = '\r';
+	else
+		m_last_cr = (ch == '\r');
 
-	/* copy the basics */
-	for (seqtype = 0; seqtype < ARRAY_LENGTH(settings->seq); seqtype++)
+	// logging
+	if (LOG_NATURAL_KEYBOARD)
 	{
-		const input_seq &defseq = input_type_seq(field->machine(), field->type, field->player, (input_seq_type)seqtype);
-		if (defseq == settings->seq[seqtype])
-			field->state->seq[seqtype].set_default();
-		else
-			field->state->seq[seqtype] = settings->seq[seqtype];
+		const keycode_map_entry *code = find_code(ch);
+		astring tempstr;
+		logerror("natural_keyboard::post(): code=%i (%s) field->name='%s'\n", int(ch), unicode_to_string(tempstr, ch), (code != NULL && code->field[0] != NULL) ? code->field[0]->name() : "<null>");
 	}
 
-	/* if there's a list of settings or we're an adjuster, copy the current value */
-	if (field->settinglist().count() != 0 || field->type == IPT_ADJUSTER)
-		field->state->value = settings->value;
+	// can we post this key in the queue directly?
+	if (can_post_directly(ch))
+		internal_post(ch);
 
-	/* if there's analog data, extract the analog settings */
-	if (field->state->analog != NULL)
+	// can we post this key with an alternate representation?
+	else if (can_post_alternate(ch))
 	{
-		field->state->analog->sensitivity = settings->sensitivity;
-		field->state->analog->delta = settings->delta;
-		field->state->analog->centerdelta = settings->centerdelta;
-		field->state->analog->reverse = settings->reverse;
+		const char_info *info = char_info::find(ch);
+		assert(info != NULL && info->alternate != NULL);
+		const char *altstring = info->alternate;
+		while (*altstring != 0)
+		{
+			altstring += uchar_from_utf8(&ch, altstring, strlen(altstring));
+			internal_post(ch);
+		}
 	}
 }
 
 
-/*-------------------------------------------------
-    input_field_setting_name - return the expanded
-    setting name for a field
--------------------------------------------------*/
+//-------------------------------------------------
+//  post - post a unicode encoded string
+//-------------------------------------------------
 
-const char *input_field_setting_name(const input_field_config *field)
+void natural_keyboard::post(const unicode_char *text, size_t length, attotime rate)
 {
-	const input_setting_config *setting;
+	// set the fixed rate
+	m_current_rate = rate;
 
-	/* only makes sense if we have settings */
-	assert(field->settinglist().count() != 0);
+	// 0 length means strlen
+	if (length == 0)
+		for (const unicode_char *scan = text; *scan != 0; scan++)
+			length++;
 
-	/* scan the list of settings looking for a match on the current value */
-	for (setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-		if (input_condition_true(field->machine(), &setting->condition, field->port().owner()))
-			if (setting->value == field->state->value)
-				return setting->name;
-
-	return "INVALID";
+	// iterate over characters or until the buffer is full up
+	while (length > 0 && !full())
+	{
+		// fetch next character
+		post(*text++);
+		length--;
+	}
 }
 
 
-/*-------------------------------------------------
-    input_field_has_previous_setting - return TRUE
-    if the given field has a "previous" setting
--------------------------------------------------*/
+//-------------------------------------------------
+//  post_utf8 - post a UTF-8 encoded string
+//-------------------------------------------------
 
-int input_field_has_previous_setting(const input_field_config *field)
+void natural_keyboard::post_utf8(const char *text, size_t length, attotime rate)
 {
-	const input_setting_config *setting;
+	// set the fixed rate
+	m_current_rate = rate;
 
-	/* only makes sense if we have settings */
-	assert(field->settinglist().count() != 0);
+	// 0-length means strlen
+	if (length == 0)
+		length = strlen(text);
 
-	/* scan the list of settings looking for a match on the current value */
-	for (setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-		if (input_condition_true(field->machine(), &setting->condition, field->port().owner()))
-			return (setting->value != field->state->value);
+	// iterate until out of characters
+	while (length > 0)
+	{
+		// decode the next character
+		unicode_char uc;
+		int count = uchar_from_utf8(&uc, text, length);
+		if (count < 0)
+		{
+			count = 1;
+			uc = INVALID_CHAR;
+		}
 
-	return FALSE;
+		// append to the buffer
+		post(uc);
+		text += count;
+		length -= count;
+	}
 }
 
 
-/*-------------------------------------------------
-    input_field_select_previous_setting - select
-    the previous item for a DIP switch or
-    configuration field
--------------------------------------------------*/
+//-------------------------------------------------
+//  post_coded - post a coded string
+//-------------------------------------------------
 
-void input_field_select_previous_setting(const input_field_config *field)
+void natural_keyboard::post_coded(const char *text, size_t length, attotime rate)
 {
-	const input_setting_config *setting, *prevsetting;
-	int found_match = FALSE;
+	static const struct
+	{
+		const char *key;
+		unicode_char code;
+	} codes[] =
+	{
+		{ "BACKSPACE",	8 },
+		{ "BS",			8 },
+		{ "BKSP",		8 },
+		{ "DEL",		UCHAR_MAMEKEY(DEL) },
+		{ "DELETE",		UCHAR_MAMEKEY(DEL) },
+		{ "END",		UCHAR_MAMEKEY(END) },
+		{ "ENTER",		13 },
+		{ "ESC",		'\033' },
+		{ "HOME",		UCHAR_MAMEKEY(HOME) },
+		{ "INS",		UCHAR_MAMEKEY(INSERT) },
+		{ "INSERT",		UCHAR_MAMEKEY(INSERT) },
+		{ "PGDN",		UCHAR_MAMEKEY(PGDN) },
+		{ "PGUP",		UCHAR_MAMEKEY(PGUP) },
+		{ "SPACE",		32 },
+		{ "TAB",		9 },
+		{ "F1",			UCHAR_MAMEKEY(F1) },
+		{ "F2",			UCHAR_MAMEKEY(F2) },
+		{ "F3",			UCHAR_MAMEKEY(F3) },
+		{ "F4",			UCHAR_MAMEKEY(F4) },
+		{ "F5",			UCHAR_MAMEKEY(F5) },
+		{ "F6",			UCHAR_MAMEKEY(F6) },
+		{ "F7",			UCHAR_MAMEKEY(F7) },
+		{ "F8",			UCHAR_MAMEKEY(F8) },
+		{ "F9",			UCHAR_MAMEKEY(F9) },
+		{ "F10",		UCHAR_MAMEKEY(F10) },
+		{ "F11",		UCHAR_MAMEKEY(F11) },
+		{ "F12",		UCHAR_MAMEKEY(F12) },
+		{ "QUOTE",		'\"' }
+	};
 
-	/* only makes sense if we have settings */
-	assert(field->settinglist().count() != 0);
+	// set the fixed rate
+	m_current_rate = rate;
 
-	/* scan the list of settings looking for a match on the current value */
-	prevsetting = NULL;
-	for (setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-		if (input_condition_true(field->machine(), &setting->condition, field->port().owner()))
-		{
-			if (setting->value == field->state->value)
+	// 0-length means strlen
+	if (length == 0)
+		length = strlen(text);
+
+	// iterate through the source string
+	size_t curpos = 0;
+	while (curpos < length)
+	{
+		// extract next character
+		unicode_char ch = text[curpos];
+		size_t increment = 1;
+
+		// look for escape characters
+		if (ch == '{')
+			for (int codenum = 0; codenum < ARRAY_LENGTH(codes); codenum++)
 			{
-				found_match = TRUE;
-				if (prevsetting != NULL)
-					break;
+				size_t keylen = strlen(codes[codenum].key);
+				if (curpos + keylen + 2 <= length)
+					if (core_strnicmp(codes[codenum].key, &text[curpos + 1], keylen) == 0 && text[curpos + keylen + 1] == '}')
+					{
+						ch = codes[codenum].code;
+						increment = keylen + 2;
+					}
 			}
-			prevsetting = setting;
-		}
 
-	/* if we didn't find a matching value, select the first */
-	if (!found_match)
-	{
-		for (prevsetting = field->settinglist().first(); prevsetting != NULL; prevsetting = prevsetting->next())
-			if (input_condition_true(field->machine(), &prevsetting->condition, field->port().owner()))
-				break;
+		// if we got a code, post it
+		if (ch != 0)
+			post(ch);
+		curpos += increment;
 	}
-
-	/* update the value to the previous one */
-	if (prevsetting != NULL)
-		field->state->value = prevsetting->value;
 }
 
 
-/*-------------------------------------------------
-    input_field_has_next_setting - return TRUE
-    if the given field has a "next" setting
--------------------------------------------------*/
+//-------------------------------------------------
+//  build_codes - given an input port table, create
+//  an input code table useful for mapping unicode
+//  chars
+//-------------------------------------------------
 
-int input_field_has_next_setting(const input_field_config *field)
+void natural_keyboard::build_codes(ioport_manager &manager)
 {
-	const input_setting_config *setting;
-	int found = FALSE;
-
-	/* only makes sense if we have settings */
-	assert(field->settinglist().count() != 0);
+	// iterate over shift keys
+	ioport_field *shift[UCHAR_SHIFT_END + 1 - UCHAR_SHIFT_BEGIN] = { 0 };
+	for (int curshift = 0; curshift <= ARRAY_LENGTH(shift); curshift++)
+		if (curshift == 0 || shift[curshift - 1] != NULL)
 
-	/* scan the list of settings looking for a match on the current value */
-	for (setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-		if (input_condition_true(field->machine(), &setting->condition, field->port().owner()))
-		{
-			if (found)
-				return TRUE;
-			if (setting->value == field->state->value)
-				found = TRUE;
-		}
+			// iterate over ports and fields
+			for (ioport_port *port = manager.first_port(); port != NULL; port = port->next())
+				for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+					if (field->type() == IPT_KEYBOARD)
+					{
+						// fetch the code, ignoring 0
+						unicode_char code = field->keyboard_code(curshift);
+						if (code == 0)
+							continue;
+
+						// is this a shifter key?
+						if (code >= UCHAR_SHIFT_BEGIN && code <= UCHAR_SHIFT_END)
+							shift[code - UCHAR_SHIFT_BEGIN] = field;
 
-	return FALSE;
+						// not a shifter key; record normally
+						else
+						{
+							keycode_map_entry newcode;
+							if (curshift == 0)
+								newcode.field[0] = field;
+							else
+							{
+								newcode.field[0] = shift[curshift - 1];
+								newcode.field[1] = field;
+							}
+							newcode.ch = code;
+							m_keycode_map.append(newcode);
+
+							if (LOG_NATURAL_KEYBOARD)
+							{
+								astring tempstr;
+								logerror("natural_keyboard: code=%i (%s) port=%p field->name='%s'\n", int(code), unicode_to_string(tempstr, code), port, field->name());
+							}
+						}
+					}
 }
 
 
-/*-------------------------------------------------
-    input_field_select_next_setting - select the
-    next item for a DIP switch or
-    configuration field
--------------------------------------------------*/
+//-------------------------------------------------
+//  can_post_directly - determine if the given
+//  unicode character can be directly posted
+//-------------------------------------------------
 
-void input_field_select_next_setting(const input_field_config *field)
+bool natural_keyboard::can_post_directly(unicode_char ch)
 {
-	const input_setting_config *setting, *nextsetting;
+	// if we have a queueing callback, then it depends on whether we can accept the character
+	if (!m_queue_chars.isnull())
+		return m_accept_char.isnull() ? true : m_accept_char(ch);
 
-	/* only makes sense if we have settings */
-	assert(field->settinglist().count() != 0);
+	// otherwise, it depends on the input codes
+	const keycode_map_entry *code = find_code(ch);
+	return (code != NULL && code->field[0] != NULL);
+}
 
-	/* scan the list of settings looking for a match on the current value */
-	nextsetting = NULL;
-	for (setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-		if (input_condition_true(field->machine(), &setting->condition, field->port().owner()))
-			if (setting->value == field->state->value)
-				break;
 
-	/* if we found one, scan forward for the next valid one */
-	if (setting != NULL)
-		for (nextsetting = setting->next(); nextsetting != NULL; nextsetting = nextsetting->next())
-			if (input_condition_true(field->machine(), &nextsetting->condition, field->port().owner()))
-				break;
+//-------------------------------------------------
+//  can_post_alternate - determine if the given
+//  unicode character can be posted via translation
+//-------------------------------------------------
 
-	/* if we hit the end, search from the beginning */
-	if (nextsetting == NULL)
-		for (nextsetting = field->settinglist().first(); nextsetting != NULL; nextsetting = nextsetting->next())
-			if (input_condition_true(field->machine(), &nextsetting->condition, field->port().owner()))
-				break;
+bool natural_keyboard::can_post_alternate(unicode_char ch)
+{
+	const char_info *info = char_info::find(ch);
+	if (info == NULL)
+		return false;
 
-	/* update the value to the previous one */
-	if (nextsetting != NULL)
-		field->state->value = nextsetting->value;
+	const char *altstring = info->alternate;
+	if (altstring == NULL)
+		return false;
+
+	while (*altstring != 0)
+	{
+		unicode_char uchar;
+		int count = uchar_from_utf8(&uchar, altstring, strlen(altstring));
+		if (count <= 0)
+			return false;
+		if (!can_post_directly(uchar))
+			return false;
+		altstring += count;
+	}
+	return true;
 }
 
 
+//-------------------------------------------------
+//  choose_delay - determine the delay between
+//  posting keyboard events
+//-------------------------------------------------
 
-/***************************************************************************
-    ACCESSORS FOR INPUT TYPES
-***************************************************************************/
+attotime natural_keyboard::choose_delay(unicode_char ch)
+{
+	// if we have a live rate, just use that
+	if (m_current_rate != attotime::zero)
+		return m_current_rate;
 
-/*-------------------------------------------------
-    input_type_is_analog - return TRUE if
-    the given type represents an analog control
--------------------------------------------------*/
+	// systems with queue_chars can afford a much smaller delay
+	if (!m_queue_chars.isnull())
+		return attotime::from_msec(10);
 
-int input_type_is_analog(int type)
-{
-	return (type >= __ipt_analog_start && type <= __ipt_analog_end);
+	// otherwise, default to constant delay with a longer delay on CR
+	return attotime::from_msec((ch == '\r') ? 200 : 50);
 }
 
 
-/*-------------------------------------------------
-    input_type_name - return the name
-    for the given type/player
--------------------------------------------------*/
+//-------------------------------------------------
+//  internal_post - post a keyboard event
+//-------------------------------------------------
 
-const char *input_type_name(running_machine &machine, int type, int player)
+void natural_keyboard::internal_post(unicode_char ch)
 {
-	/* if we have a machine, use the live state and quick lookup */
-	ioport_manager &portdata = machine.ioport();
-	input_type_entry *entry = portdata.type_to_entry[type][player];
-	if (entry != NULL)
-		return entry->name;
+	// need to start up the timer?
+	if (empty())
+	{
+		m_timer->adjust(choose_delay(ch));
+		m_status_keydown = 0;
+	}
 
-	/* if we find nothing, return an invalid group */
-	return "???";
+	// add to the buffer, resizing if necessary
+	m_buffer[m_bufend++] = ch;
+	if ((m_bufend + 1) % m_buffer.count() == m_bufbegin)
+		m_buffer.resize(m_buffer.count() + KEY_BUFFER_SIZE, true);
+	m_bufend %= m_buffer.count();
 }
 
 
-/*-------------------------------------------------
-    input_type_group - return the group
-    for the given type/player
--------------------------------------------------*/
+//-------------------------------------------------
+//  timer - timer callback to keep things flowing
+//  when posting a string of characters
+//-------------------------------------------------
 
-int input_type_group(running_machine &machine, int type, int player)
+void natural_keyboard::timer(void *ptr, int param)
 {
-	ioport_manager &portdata = machine.ioport();
-	input_type_entry *entry = portdata.type_to_entry[type][player];
-	if (entry != NULL)
-		return entry->group;
+	// the driver has a queue_chars handler
+	if (!m_queue_chars.isnull())
+	{
+		while (!empty() && m_queue_chars(&m_buffer[m_bufbegin], 1))
+		{
+			m_bufbegin = (m_bufbegin + 1) % m_buffer.count();
+			if (m_current_rate != attotime::zero)
+				break;
+		}
+	}
 
-	/* if we find nothing, return an invalid group */
-	return IPG_INVALID;
+	// the driver does not have a queue_chars handler
+	else
+	{
+		if (m_status_keydown)
+			m_bufbegin = (m_bufbegin + 1) % m_buffer.count();
+		m_status_keydown = !m_status_keydown;
+	}
+
+	// need to make sure timerproc is called again if buffer not empty
+	if (!empty())
+		m_timer->adjust(choose_delay(m_buffer[m_bufbegin]));
 }
 
 
-/*-------------------------------------------------
-    input_type_seq - return the input
-    sequence for the given type/player
--------------------------------------------------*/
+//-------------------------------------------------
+//  unicode_to_string - obtain a string
+//  representation of a given code; used for
+//  logging and debugging
+//-------------------------------------------------
 
-const input_seq &input_type_seq(running_machine &machine, int type, int player, input_seq_type seqtype)
+const char *natural_keyboard::unicode_to_string(astring &buffer, unicode_char ch)
 {
-	assert(type >= 0 && type < __ipt_max);
-	assert(player >= 0 && player < MAX_PLAYERS);
+	buffer.reset();
+	switch (ch)
+	{
+		// check some magic values
+		case '\0':	buffer.cpy("\\0");		break;
+		case '\r':	buffer.cpy("\\r");		break;
+		case '\n':	buffer.cpy("\\n");		break;
+		case '\t':	buffer.cpy("\\t");		break;
 
-	/* if we have a machine, use the live state and quick lookup */
-	ioport_manager &portdata = machine.ioport();
-	input_type_entry *entry = portdata.type_to_entry[type][player];
-	if (entry != NULL)
-		return entry->seq[seqtype];
+		default:
+			// seven bit ASCII is easy
+			if (ch >= 32 && ch < 128)
+			{
+				char temp[2] = { char(ch), 0 };
+				buffer.cpy(temp);
+			}
+			else if (ch >= UCHAR_MAMEKEY_BEGIN)
+			{
+				// try to obtain a codename with code_name(); this can result in an empty string
+				input_code code(DEVICE_CLASS_KEYBOARD, 0, ITEM_CLASS_SWITCH, ITEM_MODIFIER_NONE, input_item_id(ch - UCHAR_MAMEKEY_BEGIN));
+				machine().input().code_name(buffer, code);
+			}
 
-	/* if we find nothing, return an empty sequence */
-	return input_seq::empty_seq;
+			// did we fail to resolve? if so, we have a last resort
+			if (buffer.len() == 0)
+				buffer.format("U+%04X", unsigned(ch));
+			break;
+	}
+	return buffer;
 }
 
 
-/*-------------------------------------------------
-    input_type_set_seq - change the input
-    sequence for the given type/player
--------------------------------------------------*/
+//-------------------------------------------------
+//  find_code - find a code in our lookup table
+//-------------------------------------------------
 
-void input_type_set_seq(running_machine &machine, int type, int player, input_seq_type seqtype, const input_seq *newseq)
+const natural_keyboard::keycode_map_entry *natural_keyboard::find_code(unicode_char ch) const
 {
-	ioport_manager &portdata = machine.ioport();
-	input_type_entry *entry = portdata.type_to_entry[type][player];
-	if (entry != NULL)
-		entry->seq[seqtype] = *newseq;
+	for (int code = 0; m_keycode_map[code].ch != 0; code++)
+		if (m_keycode_map[code].ch == ch)
+			return &m_keycode_map[code];
+	return NULL;
 }
 
 
-/*-------------------------------------------------
-    input_type_pressed - return TRUE if
-    the sequence for the given input type/player
-    is pressed
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_update - once per frame update of the
+//  natural keyboard state
+//-------------------------------------------------
 
-int input_type_pressed(running_machine &machine, int type, int player)
+void natural_keyboard::frame_update(ioport_port &port, ioport_value &digital)
 {
-	return machine.input().seq_pressed(input_type_seq(machine, type, player, SEQ_TYPE_STANDARD));
+	// is there currently a key down?
+	if (m_status_keydown && !empty())
+	{
+		// loop through this character's component codes
+		const keycode_map_entry *code = find_code(m_buffer[m_bufbegin]);
+		if (code != NULL)
+			for (int fieldnum = 0; fieldnum < ARRAY_LENGTH(code->field) && code->field[fieldnum] != NULL; fieldnum++)
+				if (&code->field[fieldnum]->port() == &port)
+					digital |= code->field[fieldnum]->mask();
+	}
 }
 
 
-/*-------------------------------------------------
-    input_type_list - return the list of types
--------------------------------------------------*/
+//-------------------------------------------------
+//  key_name - returns the name of a specific key
+//-------------------------------------------------
 
-const simple_list<input_type_entry> &input_type_list(running_machine &machine)
+const char *natural_keyboard::key_name(astring &string, unicode_char ch)
 {
-	ioport_manager &portdata = machine.ioport();
-	return portdata.typelist;
-}
-
+	// attempt to get the string from the character info table
+	const char_info *ci = char_info::find(ch);
+	const char *result = (ci != NULL) ? ci->name : NULL;
+	if (result != NULL)
+		string.cpy(result);
 
+	// if that doesn't work, convert to UTF-8
+	else if (ch > 0x7F || isprint(ch))
+	{
+		char buf[10];
+		int count = utf8_from_uchar(buf, ARRAY_LENGTH(buf), ch);
+		buf[count] = 0;
+		string.cpy(buf);
+	}
 
-/***************************************************************************
-    PORT CHECKING
-***************************************************************************/
+	// otherwise, opt for question marks
+	else
+		string.cpy("???");
+	return string;
+}
 
 
-/*-------------------------------------------------
-    input_port_exists - return whether an input
-    port exists
--------------------------------------------------*/
+//-------------------------------------------------
+//  execute_input - debugger command to enter
+//  natural keyboard input
+//-------------------------------------------------
 
-bool input_port_exists(running_machine &machine, const char *tag)
+void natural_keyboard::execute_input(running_machine &machine, int ref, int params, const char *param[])
 {
-	return machine.root_device().ioport(tag) != 0;
+	machine.ioport().natkeyboard().post_coded(param[0]);
 }
 
 
-/*-------------------------------------------------
-    input_port_active - return a bitmask of which
-    bits of an input port are active (i.e. not
-    unused or unknown)
--------------------------------------------------*/
+//-------------------------------------------------
+//  execute_dumpkbd - debugger command to natural
+//  keyboard codes
+//-------------------------------------------------
 
-input_port_value input_port_active(running_machine &machine, const char *tag)
+void natural_keyboard::execute_dumpkbd(running_machine &machine, int ref, int params, const char *param[])
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	if (port == NULL)
-		fatalerror("Unable to locate input port '%s'", tag);
-	return port->active;
+	// was there a file specified?
+	const char *filename = (params > 0) ? param[0] : NULL;
+	FILE *file = NULL;
+	if (filename != NULL)
+	{
+		// if so, open it
+		file = fopen(filename, "w");
+		if (file == NULL)
+		{
+			debug_console_printf(machine, "Cannot open \"%s\"\n", filename);
+			return;
+		}
+	}
+
+	// loop through all codes
+	natural_keyboard &natkeyboard = machine.ioport().natkeyboard();
+	dynamic_array<keycode_map_entry> &keycode_map = natkeyboard.m_keycode_map;
+	astring buffer, tempstr;
+	const size_t left_column_width = 24;
+	for (int index = 0; index < keycode_map.count(); index++)
+	{
+		// describe the character code
+		const keycode_map_entry &code = keycode_map[index];
+		buffer.printf("%08X (%s) ", code.ch, natkeyboard.unicode_to_string(tempstr, code.ch));
+
+		// pad with spaces
+		while (buffer.len() < left_column_width)
+			buffer.cat(' ');
+
+		// identify the keys used
+		for (int field = 0; field < ARRAY_LENGTH(code.field) && code.field[field] != 0; field++)
+			buffer.catprintf("%s'%s'", (field > 0) ? ", " : "", code.field[field]->name());
+
+		// and output it as appropriate
+		if (file != NULL)
+			fprintf(file, "%s\n", buffer.cstr());
+		else
+			debug_console_printf(machine, "%s\n", buffer.cstr());
+	}
+
+	// cleanup
+	if (file != NULL)
+		fclose(file);
 }
 
 
-/*-------------------------------------------------
-    input_port_active_safe - return a bitmask of
-    which bits of an input port are active (i.e.
-    not unused or unknown), or a default value if
-    the port does not exist
--------------------------------------------------*/
 
-input_port_value input_port_active_safe(running_machine &machine, const char *tag, input_port_value defvalue)
+//**************************************************************************
+//  I/O PORT CONDITION
+//**************************************************************************
+
+//-------------------------------------------------
+//  eval - evaluate condition
+//-------------------------------------------------
+
+bool ioport_condition::eval(device_t &device) const
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	return port == NULL ? defvalue : port->active;
+	// always condition is always true
+	if (m_condition == ALWAYS)
+		return true;
+
+	// otherwise, read the referenced port and switch off the condition type
+	ioport_value condvalue = device.ioport(m_tag)->read();
+	switch (m_condition)
+	{
+		case ALWAYS:			return true;
+		case EQUALS:			return ((condvalue & m_mask) == m_value);
+		case NOTEQUALS:			return ((condvalue & m_mask) != m_value);
+		case GREATERTHAN:		return ((condvalue & m_mask) > m_value);
+		case NOTGREATERTHAN:	return ((condvalue & m_mask) <= m_value);
+		case LESSTHAN:			return ((condvalue & m_mask) < m_value);
+		case NOTLESSTHAN:		return ((condvalue & m_mask) >= m_value);
+	}
+	return true;
 }
 
 
 
-/***************************************************************************
-    PORT READING
-***************************************************************************/
+//**************************************************************************
+//  I/O PORT SETTING
+//**************************************************************************
 
-/*-------------------------------------------------
-    input_port_read_direct - return the value of
-    an input port
--------------------------------------------------*/
+//-------------------------------------------------
+//  ioport_setting - constructor
+//-------------------------------------------------
 
-input_port_value input_port_read_direct(const input_port_config *port)
+ioport_setting::ioport_setting(ioport_field &field, ioport_value _value, const char *_name)
+	: m_next(NULL),
+	  m_field(field),
+	  m_value(_value),
+	  m_name(_name)
 {
-	assert(port != NULL);
+}
 
-	ioport_manager &portdata = port->machine().ioport();
-	analog_field_state *analog;
-	device_field_info *device_field;
-	input_port_value result;
 
-	assert_always(portdata.safe_to_read, "Input ports cannot be read at init time!");
 
-	/* start with the digital */
-	result = port->state->digital;
+//**************************************************************************
+//  I/O PORT DIP LOCATION
+//**************************************************************************
 
-	/* update read values */
-	for (device_field = port->state->readdevicelist; device_field != NULL; device_field = device_field->next)
-		if (input_condition_true(port->machine(), &device_field->field->condition, port->owner()))
-		{
-			/* replace the bits with bits from the device */
-			input_port_value newval = device_field->field->read(*device_field->field, device_field->field->read_param);
-			device_field->oldval = newval;
-			result = (result & ~device_field->field->mask) | ((newval << device_field->shift) & device_field->field->mask);
-		}
+//-------------------------------------------------
+//  ioport_diplocation - constructor
+//-------------------------------------------------
 
-	/* update VBLANK bits */
-	if (port->state->vblank != 0)
-	{
-		if (port->machine().primary_screen->vblank())
-			result |= port->state->vblank;
-		else
-			result &= ~port->state->vblank;
-	}
+ioport_diplocation::ioport_diplocation(const char *name, UINT8 swnum, bool invert)
+	: m_next(NULL),
+	  m_name(name),
+	  m_number(swnum),
+	  m_invert(invert)
+{
+}
 
-	/* apply active high/low state to digital, read, and VBLANK inputs */
-	result ^= port->state->defvalue;
 
-	/* merge in analog portions */
-	for (analog = port->state->analoglist; analog != NULL; analog = analog->next)
-		if (input_condition_true(port->machine(), &analog->field->condition, port->owner()))
-		{
-			/* start with the raw value */
-			INT32 value = analog->accum;
 
-			/* interpolate if appropriate and if time has passed since the last update */
-			if (analog->interpolate && !(analog->field->flags & ANALOG_FLAG_RESET) && portdata.last_delta_nsec != 0)
-			{
-				attoseconds_t nsec_since_last = (port->machine().time() - portdata.last_frame_time).as_attoseconds() / ATTOSECONDS_PER_NANOSECOND;
-				value = analog->previous + ((INT64)(analog->accum - analog->previous) * nsec_since_last / portdata.last_delta_nsec);
-			}
+//**************************************************************************
+//  I/O PORT FIELD
+//**************************************************************************
 
-			/* apply standard analog settings */
-			value = apply_analog_settings(value, analog);
+//-------------------------------------------------
+//  ioport_field - constructor
+//-------------------------------------------------
 
-			/* remap the value if needed */
-			if (analog->field->remap_table != NULL)
-				value = analog->field->remap_table[value];
-
-			/* invert bits if needed */
-			if (analog->field->flags & ANALOG_FLAG_INVERT)
-				value = ~value;
+ioport_field::ioport_field(ioport_port &port, ioport_type type, ioport_value defvalue, ioport_value maskbits, const char *name)
+	: m_next(NULL),
+	  m_port(port),
+	  m_live(NULL),
+	  m_modcount(port.modcount()),
+	  m_mask(maskbits),
+	  m_defvalue(defvalue & maskbits),
+	  m_type(type),
+	  m_player(0),
+	  m_flags(0),
+	  m_impulse(0),
+	  m_name(name),
+	  m_read_param(NULL),
+	  m_write_param(NULL),
+	  m_min(0),
+	  m_max(maskbits),
+	  m_sensitivity(0),
+	  m_delta(0),
+	  m_centerdelta(0),
+	  m_crosshair_axis(CROSSHAIR_AXIS_NONE),
+	  m_crosshair_scale(1.0),
+	  m_crosshair_offset(0),
+	  m_crosshair_altaxis(0),
+	  m_full_turn_count(0),
+	  m_remap_table(NULL),
+	  m_way(0)
+{
+	// reset sequences and chars
+	for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+		m_seq[seqtype].set_default();
+	m_chars[0] = m_chars[1] = m_chars[2] = unicode_char(0);
 
-			/* insert into the port */
-			result = (result & ~analog->field->mask) | ((value << analog->shift) & analog->field->mask);
+	// for DIP switches and configs, look for a default value from the owner
+	if (type == IPT_DIPSWITCH || type == IPT_CONFIG)
+	{
+		const input_device_default *def = device().input_ports_defaults();
+		if (def != NULL)
+		{
+			const char *fulltag = port.tag();
+			astring fullpath;
+			for ( ; def->tag != NULL; def++)
+				if (device().subtag(fullpath, def->tag) == fulltag && def->mask == m_mask)
+					m_defvalue = def->defvalue & m_mask;
 		}
-
-	return result;
+	}
 }
 
 
-/*-------------------------------------------------
-    input_port_read - return the value of
-    an input port specified by tag
--------------------------------------------------*/
+//-------------------------------------------------
+//  ~ioport_field - destructor
+//-------------------------------------------------
 
-input_port_value input_port_read(running_machine &machine, const char *tag)
+ioport_field::~ioport_field()
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	if (port == NULL)
-		fatalerror("Unable to locate input port '%s'", tag);
-	return input_port_read_direct(port);
+	global_free(m_live);
 }
 
 
-/*-------------------------------------------------
-    input_port_read - return the value of
-    a device input port specified by tag
--------------------------------------------------*/
+//-------------------------------------------------
+//  name - return the field name for a given input
+//  field
+//-------------------------------------------------
 
-input_port_value input_port_read(device_t &device, const char *tag)
+const char *ioport_field::name() const
 {
-	const input_port_config *port = device.ioport(tag);
-	if (port == NULL)
-		fatalerror("Unable to locate input port '%s'", tag);
-	return input_port_read_direct(port);
+	// if we have a non-default name, use that
+	if (m_live != NULL && m_live->name)
+		return m_live->name;
+	if (m_name != NULL)
+		return m_name;
+
+	// otherwise, return the name associated with the type
+	return manager().type_name(m_type, m_player);
 }
 
 
-/*-------------------------------------------------
-    input_port_read_safe - return the value of
-    an input port specified by tag, or a default
-    value if the port does not exist
--------------------------------------------------*/
+//-------------------------------------------------
+//  seq - return the live input sequence for the
+//  given input field
+//-------------------------------------------------
 
-input_port_value input_port_read_safe(running_machine &machine, const char *tag, UINT32 defvalue)
+const input_seq &ioport_field::seq(input_seq_type seqtype) const
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	return (port == NULL) ? defvalue : input_port_read_direct(port);
-}
+	// if no live state, return default
+	if (m_live == NULL)
+		return defseq(seqtype);
 
+	// if the field is disabled, return no key
+	if (unused())
+		return input_seq::empty_seq;
 
-/*-------------------------------------------------
-    input_port_read_crosshair - return the
-    extracted crosshair values for the given
-    player
--------------------------------------------------*/
-
-int input_port_get_crosshair_position(running_machine &machine, int player, float *x, float *y)
-{
-	const input_port_config *port;
-	const input_field_config *field;
-	int gotx = FALSE, goty = FALSE;
+	// if the sequence is the special default code, return the expanded default value
+	if (m_live->seq[seqtype].is_default())
+		return manager().type_seq(m_type, m_player, seqtype);
 
-	/* read all the lightgun values */
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->first_field(); field != NULL; field = field->next())
-			if (field->player == player && field->crossaxis != CROSSHAIR_AXIS_NONE)
-				if (input_condition_true(machine, &field->condition, port->owner()))
-				{
-					analog_field_state *analog = field->state->analog;
-					INT32 rawvalue = apply_analog_settings(analog->accum, analog) & (analog->field->mask >> analog->shift);
-					float value = (float)(rawvalue - field->state->analog->adjmin) / (float)(field->state->analog->adjmax - field->state->analog->adjmin);
-
-					/* apply the scale and offset */
-					if (field->crossscale < 0)
-						value = -(1.0 - value) * field->crossscale;
-					else
-						value *= field->crossscale;
-					value += field->crossoffset;
+	// otherwise, return the sequence as-is
+	return m_live->seq[seqtype];
+}
 
-					/* apply custom mapping if necessary */
-					if (!field->crossmapper.isnull())
-						value = field->crossmapper(*field, value);
 
-					/* handle X axis */
-					if (field->crossaxis == CROSSHAIR_AXIS_X)
-					{
-						*x = value;
-						gotx = TRUE;
-						if (field->crossaltaxis != 0)
-						{
-							*y = field->crossaltaxis;
-							goty = TRUE;
-						}
-					}
+//-------------------------------------------------
+//  defseq - return the default input sequence for
+//  the given input field
+//-------------------------------------------------
 
-					/* handle Y axis */
-					else
-					{
-						*y = value;
-						goty = TRUE;
-						if (field->crossaltaxis != 0)
-						{
-							*x = field->crossaltaxis;
-							gotx = TRUE;
-						}
-					}
+const input_seq &ioport_field::defseq(input_seq_type seqtype) const
+{
+	// if the field is disabled, return no key
+	if (unused())
+		return input_seq::empty_seq;
 
-					/* if we got both, stop */
-					if (gotx && goty)
-						break;
-				}
+	// if the sequence is the special default code, return the expanded default value
+	if (m_seq[seqtype].is_default())
+		return manager().type_seq(m_type, m_player, seqtype);
 
-	return (gotx && goty);
+	// otherwise, return the sequence as-is
+	return m_seq[seqtype];
 }
 
 
-/*-------------------------------------------------
-    input_port_update_defaults - force an update
-    to the input port values based on current
-    conditions
--------------------------------------------------*/
+//-------------------------------------------------
+//  type_class - return the type class for this
+//  field
+//-------------------------------------------------
 
-void input_port_update_defaults(running_machine &machine)
+ioport_type_class ioport_field::type_class() const
 {
-	int loopnum;
+	ioport_type_class result;
 
-	/* two passes to catch conditionals properly */
-	for (loopnum = 0; loopnum < 2; loopnum++)
+	switch (m_type)
 	{
-		const input_port_config *port;
+		case IPT_JOYSTICK_UP:
+		case IPT_JOYSTICK_DOWN:
+		case IPT_JOYSTICK_LEFT:
+		case IPT_JOYSTICK_RIGHT:
+		case IPT_JOYSTICKLEFT_UP:
+		case IPT_JOYSTICKLEFT_DOWN:
+		case IPT_JOYSTICKLEFT_LEFT:
+		case IPT_JOYSTICKLEFT_RIGHT:
+		case IPT_JOYSTICKRIGHT_UP:
+		case IPT_JOYSTICKRIGHT_DOWN:
+		case IPT_JOYSTICKRIGHT_LEFT:
+		case IPT_JOYSTICKRIGHT_RIGHT:
+		case IPT_BUTTON1:
+		case IPT_BUTTON2:
+		case IPT_BUTTON3:
+		case IPT_BUTTON4:
+		case IPT_BUTTON5:
+		case IPT_BUTTON6:
+		case IPT_BUTTON7:
+		case IPT_BUTTON8:
+		case IPT_BUTTON9:
+		case IPT_BUTTON10:
+		case IPT_AD_STICK_X:
+		case IPT_AD_STICK_Y:
+		case IPT_AD_STICK_Z:
+		case IPT_TRACKBALL_X:
+		case IPT_TRACKBALL_Y:
+		case IPT_LIGHTGUN_X:
+		case IPT_LIGHTGUN_Y:
+		case IPT_MOUSE_X:
+		case IPT_MOUSE_Y:
+		case IPT_START:
+		case IPT_SELECT:
+			result = INPUT_CLASS_CONTROLLER;
+			break;
 
-		/* loop over all input ports */
-		for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		{
-			const input_field_config *field;
+		case IPT_KEYPAD:
+		case IPT_KEYBOARD:
+			result = INPUT_CLASS_KEYBOARD;
+			break;
 
-			/* only clear on the first pass */
-			if (loopnum == 0)
-				port->state->defvalue = 0;
+		case IPT_CONFIG:
+			result = INPUT_CLASS_CONFIG;
+			break;
 
-			/* first compute the default value for the entire port */
-			for (field = port->first_field(); field != NULL; field = field->next())
-				if (input_condition_true(machine, &field->condition, port->owner()))
-					port->state->defvalue = (port->state->defvalue & ~field->mask) | (field->state->value & field->mask);
-		}
-	}
-}
+		case IPT_DIPSWITCH:
+			result = INPUT_CLASS_DIPSWITCH;
+			break;
 
+		case 0:
+			if (m_name != NULL && m_name != (const char *)-1)
+				result = INPUT_CLASS_MISC;
+			else
+				result = INPUT_CLASS_INTERNAL;
+			break;
 
-/*-------------------------------------------------
-    apply_analog_settings - return the value of
-    an input port
--------------------------------------------------*/
-
-static INT32 apply_analog_settings(INT32 value, analog_field_state *analog)
-{
-	/* apply the min/max and then the sensitivity */
-	value = apply_analog_min_max(analog, value);
-	value = APPLY_SENSITIVITY(value, analog->sensitivity);
-
-	/* apply reversal if needed */
-	if (analog->reverse)
-		value = analog->reverse_val - value;
-	else if (analog->single_scale)
-		/* it's a pedal or the default value is equal to min/max */
-		/* so we need to adjust the center to the minimum */
-		value -= INPUT_ABSOLUTE_MIN;
+		default:
+			result = INPUT_CLASS_INTERNAL;
+			break;
+	}
+	return result;
+}
 
-	/* map differently for positive and negative values */
-	if (value >= 0)
-		value = APPLY_SCALE(value, analog->scalepos);
-	else
-		value = APPLY_SCALE(value, analog->scaleneg);
-	value += analog->adjdefvalue;
 
-	return value;
+//-------------------------------------------------
+//  keyboard_code - accesses a particular keyboard
+//  code
+//-------------------------------------------------
+
+unicode_char ioport_field::keyboard_code(int which) const
+{
+	unicode_char ch = m_chars[which];
+
+	// special hack to allow for PORT_CODE('\xA3')
+	if (ch >= 0xffffff80 && ch <= 0xffffffff)
+		ch &= 0xff;
+	return ch;
 }
 
 
-/***************************************************************************
-    PORT WRITING
-***************************************************************************/
-
-/*-------------------------------------------------
-    input_port_write_direct - write a value
-    to a port
--------------------------------------------------*/
+//-------------------------------------------------
+//  get_user_settings - return the current
+//  settings for the given input field
+//-------------------------------------------------
 
-void input_port_write_direct(const input_port_config *port, input_port_value data, input_port_value mem_mask)
+void ioport_field::get_user_settings(user_settings &settings)
 {
-	/* call device line write handlers */
-	device_field_info *device_field;
+	// zap the entire structure
+	memset(&settings, 0, sizeof(settings));
 
-	COMBINE_DATA(&port->state->outputvalue);
+	// copy the basics
+	for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+		settings.seq[seqtype] = seq(seqtype);
 
-	for (device_field = port->state->writedevicelist; device_field; device_field = device_field->next)
-		if (device_field->field->type == IPT_OUTPUT && input_condition_true(port->machine(), &device_field->field->condition, port->owner()))
-		{
-			input_port_value newval = ( (port->state->outputvalue ^ device_field->field->defvalue ) & device_field->field->mask) >> device_field->shift;
-
-			/* if the bits have write, call the handler */
-			if (device_field->oldval != newval)
-			{
-				device_field->field->write(*device_field->field, device_field->field->write_param, device_field->oldval, newval);
+	// if there's a list of settings or we're an adjuster, copy the current value
+	if (first_setting() != NULL || m_type == IPT_ADJUSTER)
+		settings.value = m_live->value;
 
-				device_field->oldval = newval;
-			}
-		}
+	// if there's analog data, extract the analog settings
+	if (m_live->analog != NULL)
+	{
+		settings.sensitivity = m_live->analog->sensitivity();
+		settings.delta = m_live->analog->delta();
+		settings.centerdelta = m_live->analog->centerdelta();
+		settings.reverse = m_live->analog->reverse();
+	}
 }
 
 
-/*-------------------------------------------------
-    input_port_write - write a value to a
-    port specified by tag
--------------------------------------------------*/
+//-------------------------------------------------
+//  set_user_settings - modify the current
+//  settings for the given input field
+//-------------------------------------------------
 
-void input_port_write(running_machine &machine, const char *tag, input_port_value value, input_port_value mask)
+void ioport_field::set_user_settings(const user_settings &settings)
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	if (port == NULL)
-		fatalerror("Unable to locate input port '%s'", tag);
-	input_port_write_direct(port, value, mask);
+	// copy the basics
+	for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+	{
+		const input_seq &defseq = manager().type_seq(m_type, m_player, input_seq_type(seqtype));
+		if (defseq == settings.seq[seqtype])
+			m_live->seq[seqtype].set_default();
+		else
+			m_live->seq[seqtype] = settings.seq[seqtype];
+	}
+
+	// if there's a list of settings or we're an adjuster, copy the current value
+	if (first_setting() != NULL || m_type == IPT_ADJUSTER)
+		m_live->value = settings.value;
+
+	// if there's analog data, extract the analog settings
+	if (m_live->analog != NULL)
+	{
+		m_live->analog->m_sensitivity = settings.sensitivity;
+		m_live->analog->m_delta = settings.delta;
+		m_live->analog->m_centerdelta = settings.centerdelta;
+		m_live->analog->m_reverse = settings.reverse;
+	}
 }
 
 
-/*-------------------------------------------------
-    input_port_write_safe - write a value to
-    a port, ignore if the port does not exist
--------------------------------------------------*/
+//-------------------------------------------------
+//  setting_name - return the expanded setting
+//  name for a field
+//-------------------------------------------------
 
-void input_port_write_safe(running_machine &machine, const char *tag, input_port_value value, input_port_value mask)
+const char *ioport_field::setting_name() const
 {
-	const input_port_config *port = machine.root_device().ioport(tag);
-	if (port != NULL)
-		input_port_write_direct(port, value, mask);
-}
+	// only makes sense if we have settings
+	assert(first_setting() != NULL);
 
+	// scan the list of settings looking for a match on the current value
+	for (ioport_setting *setting = first_setting(); setting != NULL; setting = setting->next())
+		if (setting->enabled())
+			if (setting->value() == m_live->value)
+				return setting->name();
 
+	return "INVALID";
+}
 
-/***************************************************************************
-    MISC HELPER FUNCTIONS
-***************************************************************************/
 
-/*-------------------------------------------------
-    input_condition_true - return the TRUE
-    if the given condition attached is true
--------------------------------------------------*/
+//-------------------------------------------------
+//  has_previous_setting - return true if the
+//  given field has a "previous" setting
+//-------------------------------------------------
 
-int input_condition_true(running_machine &machine, const input_condition *condition, device_t &owner)
+bool ioport_field::has_previous_setting() const
 {
-	input_port_value condvalue;
-
-	/* always condition is always true */
-	if (condition->condition == PORTCOND_ALWAYS)
-		return TRUE;
+	// only makes sense if we have settings
+	assert(first_setting() != NULL);
 
-	/* otherwise, read the referenced port */
-	astring conditiontag;
-	owner.subtag(conditiontag, condition->tag);
-	condvalue = input_port_read(machine, conditiontag.cstr());
+	// scan the list of settings looking for a match on the current value
+	for (ioport_setting *setting = first_setting(); setting != NULL; setting = setting->next())
+		if (setting->enabled())
+			return (setting->value() != m_live->value);
 
-	/* based on the condition encoded, determine truth */
-	switch (condition->condition)
-	{
-		case PORTCOND_EQUALS:
-			return ((condvalue & condition->mask) == condition->value);
+	return false;
+}
 
-		case PORTCOND_NOTEQUALS:
-			return ((condvalue & condition->mask) != condition->value);
 
-		case PORTCOND_GREATERTHAN:
-			return ((condvalue & condition->mask) > condition->value);
+//-------------------------------------------------
+//  select_previous_setting - select the previous
+//  item for a DIP switch or configuration field
+//-------------------------------------------------
 
-		case PORTCOND_NOTGREATERTHAN:
-			return ((condvalue & condition->mask) <= condition->value);
+void ioport_field::select_previous_setting()
+{
+	// only makes sense if we have settings
+	assert(first_setting() != NULL);
 
-		case PORTCOND_LESSTHAN:
-			return ((condvalue & condition->mask) < condition->value);
+	// scan the list of settings looking for a match on the current value
+	ioport_setting *prevsetting = NULL;
+	bool found_match = false;
+	for (ioport_setting *setting = first_setting(); setting != NULL; setting = setting->next())
+		if (setting->enabled())
+		{
+			if (setting->value() == m_live->value)
+			{
+				found_match = true;
+				if (prevsetting != NULL)
+					break;
+			}
+			prevsetting = setting;
+		}
 
-		case PORTCOND_NOTLESSTHAN:
-			return ((condvalue & condition->mask) >= condition->value);
+	// if we didn't find a matching value, select the first
+	if (!found_match)
+	{
+		for (prevsetting = first_setting(); prevsetting != NULL; prevsetting = prevsetting->next())
+			if (prevsetting->enabled())
+				break;
 	}
-	return TRUE;
+
+	// update the value to the previous one
+	if (prevsetting != NULL)
+		m_live->value = prevsetting->value();
 }
 
 
-/*-------------------------------------------------
-    input_port_string_from_token - convert an
-    input_port_token to a default string
--------------------------------------------------*/
+//-------------------------------------------------
+//  has_next_setting - return true if the given
+//  field has a "next" setting
+//-------------------------------------------------
 
-const char *input_port_string_from_token(const char *string)
+bool ioport_field::has_next_setting() const
 {
-	/* 0 is an invalid index */
-	if (string == NULL)
-		return NULL;
+	// only makes sense if we have settings
+	assert(first_setting() != NULL);
 
-	/* if the index is greater than the count, assume it to be a pointer */
-	if (FPTR(string) >= INPUT_STRING_COUNT)
-		return string;
+	// scan the list of settings looking for a match on the current value
+	bool found = false;
+	for (ioport_setting *setting = first_setting(); setting != NULL; setting = setting->next())
+		if (setting->enabled())
+		{
+			if (found)
+				return true;
+			if (setting->value() == m_live->value)
+				found = true;
+		}
 
-#if FALSE // Set TRUE, If you want to take care missing-token or wrong-sorting
+	return false;
+}
 
-	/* otherwise, scan the list for a matching string and return it */
-	{
-	int index;
-	for (index = 0; index < ARRAY_LENGTH(input_port_default_strings); index++)
-		if (input_port_default_strings[index].id == FPTR(string))
-			return input_port_default_strings[index].string;
-	}
-	return "(Unknown Default)";
 
-#else
+//-------------------------------------------------
+//  select_next_setting - select the next item for
+//  a DIP switch or configuration field
+//-------------------------------------------------
 
-	return input_port_default_strings[FPTR(string)-1].string;
+void ioport_field::select_next_setting()
+{
+	// only makes sense if we have settings
+	assert(first_setting() != NULL);
 
-#endif
-}
+	// scan the list of settings looking for a match on the current value
+	ioport_setting *nextsetting = NULL;
+	ioport_setting *setting;
+	for (setting = first_setting(); setting != NULL; setting = setting->next())
+		if (setting->enabled())
+			if (setting->value() == m_live->value)
+				break;
 
+	// if we found one, scan forward for the next valid one
+	if (setting != NULL)
+		for (nextsetting = setting->next(); nextsetting != NULL; nextsetting = nextsetting->next())
+			if (nextsetting->enabled())
+				break;
 
+	// if we hit the end, search from the beginning
+	if (nextsetting == NULL)
+		for (nextsetting = first_setting(); nextsetting != NULL; nextsetting = nextsetting->next())
+			if (nextsetting->enabled())
+				break;
 
-/***************************************************************************
-    INITIALIZATION HELPERS
-***************************************************************************/
+	// update the value to the previous one
+	if (nextsetting != NULL)
+		m_live->value = nextsetting->value();
+}
 
-/*-------------------------------------------------
-    init_port_types - initialize the default
-    type list
--------------------------------------------------*/
 
-static void init_port_types(running_machine &machine)
+//-------------------------------------------------
+//  frame_update_digital - get the state of a
+//  digital field
+//-------------------------------------------------
+
+void ioport_field::frame_update(ioport_value &result, bool mouse_down)
 {
-	ioport_manager &portdata = machine.ioport();
+	// skip if not enabled
+	if (!enabled())
+		return;
 
-	/* convert the array into a list of type states that can be modified */
-	construct_core_types(portdata.typelist);
+	// handle analog inputs first
+	if (m_live->analog != NULL)
+	{
+		m_live->analog->frame_update(machine());
+		return;
+	}
 
-	/* ask the OSD to customize the list */
-	machine.osd().customize_input_type_list(portdata.typelist);
+	// if UI is active, ignore digital inputs
+	if (ui_is_menu_active())
+		return;
 
-	/* now iterate over the OSD-modified types */
-	for (input_type_entry *curtype = portdata.typelist.first(); curtype != NULL; curtype = curtype->next())
+	// if the state changed, look for switch down/switch up
+	bool curstate = mouse_down || machine().input().seq_pressed(seq());
+	bool changed = false;
+	if (curstate != m_live->last)
 	{
-		/* first copy all the OSD-updated sequences into our current state */
-		for (int seqtype = 0; seqtype < ARRAY_LENGTH(curtype->seq); seqtype++)
-			curtype->seq[seqtype] = curtype->defseq[seqtype];
-
-		/* also make a lookup table mapping type/player to the appropriate type list entry */
-		portdata.type_to_entry[curtype->type][curtype->player] = curtype;
+		m_live->last = curstate;
+		changed = true;
 	}
-}
 
+	// if we're a keyboard type and using natural keyboard, bail
+	if (m_type == IPT_KEYBOARD && ui_get_use_natural_keyboard(machine()))
+		return;
 
-/*-------------------------------------------------
-    get_keyboard_code - accesses a particular
-    keyboard code
--------------------------------------------------*/
-
-static unicode_char get_keyboard_code(const input_field_config *field, int i)
-{
-	unicode_char ch = field->chars[i];
+	// coin impulse option
+	int effective_impulse = m_impulse;
+	int impulse_option_val = machine().options().coin_impulse();
+	if (impulse_option_val != 0)
+	{
+		if (impulse_option_val < 0)
+			effective_impulse = 0;
+		else if ((m_type >= IPT_COIN1 && m_type <= IPT_COIN12) || m_impulse != 0)
+			effective_impulse = impulse_option_val;
+	}
 
-	/* special hack to allow for PORT_CODE('\xA3') */
-	if ((ch >= 0xFFFFFF80) && (ch <= 0xFFFFFFFF))
-		ch &= 0xFF;
-	return ch;
-}
+	// if this is a switch-down event, handle impulse and toggle
+	if (changed && curstate)
+	{
+		// impluse controls: reset the impulse counter
+		if (effective_impulse != 0 && m_live->impulse == 0)
+			m_live->impulse = effective_impulse;
 
+		// toggle controls: flip the toggle state or advance to the next setting
+		if (toggle())
+		{
+			if (m_settinglist.count() == 0)
+				m_live->value ^= m_mask;
+			else
+				select_next_setting();
+		}
+	}
 
-/***************************************************************************
-    MISCELLANEOUS
-***************************************************************************/
+	// update the current state with the impulse state
+	if (effective_impulse != 0)
+	{
+		curstate = (m_live->impulse != 0);
+		if (curstate)
+			m_live->impulse--;
+	}
 
-/*-------------------------------------------------
-    find_charinfo - looks up information about a
-    particular character
--------------------------------------------------*/
+	// for toggle switches, the current value is folded into the port's default value
+	// so we always return FALSE here
+	if (toggle())
+		curstate = false;
 
-static const char_info *find_charinfo(unicode_char target_char)
-{
-	int low = 0;
-	int high = ARRAY_LENGTH(charinfo);
-	int i;
-	unicode_char ch;
+	// additional logic to restrict digital joysticks
+	if (curstate && !mouse_down && m_live->joystick != NULL && m_way != 16 && !machine().options().joystick_contradictory())
+	{
+		UINT8 mask = (m_way == 4) ? m_live->joystick->current4way() : m_live->joystick->current();
+		if (!(mask & (1 << m_live->joydir)))
+			curstate = false;
+	}
 
-	/* perform a simple binary search to find the proper alternate */
-	while(high > low)
+	// skip locked-out coin inputs
+	if (curstate && m_type >= IPT_COIN1 && m_type <= IPT_COIN12 && coin_lockout_get_state(machine(), m_type - IPT_COIN1))
 	{
-		i = (high + low) / 2;
-		ch = charinfo[i].ch;
-		if (ch < target_char)
-			low = i + 1;
-		else if (ch > target_char)
-			high = i;
+		bool verbose = machine().options().verbose();
+#ifdef MAME_DEBUG
+		verbose = true;
+#endif
+		if (machine().options().coin_lockout())
+		{
+			if (verbose)
+				ui_popup_time(3, "Coinlock disabled %s.", name());
+			curstate = false;
+		}
 		else
-			return &charinfo[i];
+			if (verbose)
+				ui_popup_time(3, "Coinlock disabled, but broken through %s.", name());
 	}
-	return NULL;
+
+	// if we're active, set the appropriate bits in the digital state
+	if (curstate)
+		result |= m_mask;
 }
 
-/*-------------------------------------------------
-    inputx_key_name - returns the name of a
-    specific key
--------------------------------------------------*/
 
-static const char *inputx_key_name(unicode_char ch)
+//-------------------------------------------------
+//  crosshair_position - compute the crosshair
+//  position
+//-------------------------------------------------
+
+void ioport_field::crosshair_position(float &x, float &y, bool &gotx, bool &goty)
 {
-	static char buf[UTF8_CHAR_MAX + 1];
-	const char_info *ci;
-	const char *result;
-	int pos;
+	float value = m_live->analog->crosshair_read();
+
+	// apply the scale and offset
+	if (m_crosshair_scale < 0)
+		value = -(1.0 - value) * m_crosshair_scale;
+	else
+		value *= m_crosshair_scale;
+	value += m_crosshair_offset;
 
-	ci = find_charinfo(ch);
-	result = ci ? ci->name : NULL;
+	// apply custom mapping if necessary
+	if (!m_crosshair_mapper.isnull())
+		value = m_crosshair_mapper(*this, value);
 
-	if (ci && ci->name)
+	// handle X axis
+	if (m_crosshair_axis == CROSSHAIR_AXIS_X)
 	{
-		result = ci->name;
+		x = value;
+		gotx = true;
+		if (m_crosshair_altaxis != 0)
+		{
+			y = m_crosshair_altaxis;
+			goty = true;
+		}
 	}
+
+	// handle Y axis
 	else
 	{
-		if ((ch > 0x7F) || isprint(ch))
+		y = value;
+		goty = true;
+		if (m_crosshair_altaxis != 0)
 		{
-			pos = utf8_from_uchar(buf, ARRAY_LENGTH(buf), ch);
-			buf[pos] = '\0';
-			result = buf;
+			x = m_crosshair_altaxis;
+			gotx = true;
 		}
-		else
-			result = "???";
 	}
-	return result;
 }
 
-/*-------------------------------------------------
-    get_keyboard_key_name - builds the name of
-    a key based on natural keyboard characters
--------------------------------------------------*/
 
-static astring &get_keyboard_key_name(astring &name, const input_field_config *field)
-{
-	int i;
-	unicode_char ch;
+//-------------------------------------------------
+//  expand_diplocation - expand a string-based
+//  DIP location into a linked list of
+//  descriptions
+//-------------------------------------------------
 
-	name.reset();
-	/* loop through each character on the field*/
-	for (i = 0; i < ARRAY_LENGTH(field->chars) && (field->chars[i] != '\0'); i++)
-	{
-		ch = get_keyboard_code(field, i);
-		name.catprintf("%-*s ", MAX(SPACE_COUNT - 1, 0), inputx_key_name(ch));
-	}
+void ioport_field::expand_diplocation(const char *location, astring &errorbuf)
+{
+	// if nothing present, bail
+	if (location == NULL)
+		return;
 
-	/* trim extra spaces */
-	name.trimspace();
+	m_diploclist.reset();
 
-	/* special case */
-	if (name.len() == 0)
-		name.cpy("Unnamed Key");
-
-	return name;
-}
-
-/*-------------------------------------------------
-    init_port_state - initialize the live port
-    states based on the tokens
--------------------------------------------------*/
-
-static void init_port_state(running_machine &machine)
-{
-	const char *joystick_map_default = machine.options().joystick_map();
-	ioport_manager &portdata = machine.ioport();
-	input_field_config *field;
-	input_port_config *port;
-
-	/* allocate live structures to mirror the configuration */
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-	{
-		analog_field_state **analogstatetail;
-		device_field_info **readdevicetail;
-		device_field_info **writedevicetail;
-		input_port_state *portstate;
-
-		/* allocate a new input_port_info structure */
-		portstate = auto_alloc_clear(machine, input_port_state);
-		((input_port_config *)port)->state = portstate;
-
-		/* start with tail pointers to all the data */
-		analogstatetail = &portstate->analoglist;
-		readdevicetail = &portstate->readdevicelist;
-		writedevicetail = &portstate->writedevicelist;
-
-		/* iterate over fields */
-		for (field = port->first_field(); field != NULL; field = field->next())
-		{
-			input_field_state *fieldstate;
-			int seqtype;
-
-			/* allocate a new input_field_info structure */
-			fieldstate = auto_alloc_clear(machine, input_field_state);
-			((input_field_config *)field)->state = fieldstate;
-
-			/* fill in the basic values */
-			for (seqtype = 0; seqtype < ARRAY_LENGTH(fieldstate->seq); seqtype++)
-				fieldstate->seq[seqtype] = field->seq[seqtype];
-			fieldstate->value = field->defvalue;
-
-			/* if this is an analog field, allocate memory for the analog data */
-			if (field->type >= __ipt_analog_start && field->type <= __ipt_analog_end)
-			{
-				*analogstatetail = fieldstate->analog = init_field_analog_state(field);
-				analogstatetail = &(*analogstatetail)->next;
-			}
-
-			/* if this is a digital joystick field, make a note of it */
-			if (field->type >= __ipt_digital_joystick_start && field->type <= __ipt_digital_joystick_end)
-			{
-				fieldstate->joystick = &portdata.joystick_info[field->player][(field->type - __ipt_digital_joystick_start) / 4];
-				fieldstate->joydir = (field->type - __ipt_digital_joystick_start) % 4;
-				fieldstate->joystick->field[fieldstate->joydir] = field;
-				fieldstate->joystick->inuse = TRUE;
-			}
-
-			/* if this entry has device input, allocate memory for the tracking structure */
-			astring devicetag;
-			if (!field->read.isnull())
-			{
-				*readdevicetail = init_field_device_info(field, port->owner().subtag(devicetag, field->read_device));
-				field->read.late_bind(*(*readdevicetail)->device);
-				if (!field->read.has_object())
-					fatalerror("Input port %s, unable to find valid device with tag '%s'", port->tag(), devicetag.cstr());
-				readdevicetail = &(*readdevicetail)->next;
-			}
-
-			/* if this entry has device output, allocate memory for the tracking structure */
-			if (!field->write.isnull())
-			{
-				*writedevicetail = init_field_device_info(field, port->owner().subtag(devicetag, field->write_device));
-				field->write.late_bind(*(*writedevicetail)->device);
-				if (!field->write.has_object())
-					fatalerror("Input port %s, unable to find valid device with tag '%s'", port->tag(), devicetag.cstr());
-				writedevicetail = &(*writedevicetail)->next;
-			}
-
-			/* if this entry has device output, allocate memory for the tracking structure */
-			if (!field->crossmapper.isnull())
-			{
-				device_t *device = machine.device(port->owner().subtag(devicetag, field->crossmapper_device));
-				field->crossmapper.late_bind(*device);
-			}
-
-			/* Name keyboard key names */
-			if ((field->type == IPT_KEYBOARD || field->type == IPT_KEYPAD) && (field->name == NULL))
-			{
-				astring name;
-				field->state->name = auto_strdup(machine, get_keyboard_key_name(name, field));
-			}
-		}
-	}
-
-	/* handle autoselection of devices */
-	init_autoselect_devices(machine, IPT_AD_STICK_X,  IPT_AD_STICK_Y,   IPT_AD_STICK_Z, OPTION_ADSTICK_DEVICE,    "analog joystick");
-	init_autoselect_devices(machine, IPT_PADDLE,      IPT_PADDLE_V,     0,              OPTION_PADDLE_DEVICE,     "paddle");
-	init_autoselect_devices(machine, IPT_PEDAL,       IPT_PEDAL2,       IPT_PEDAL3,     OPTION_PEDAL_DEVICE,      "pedal");
-	init_autoselect_devices(machine, IPT_LIGHTGUN_X,  IPT_LIGHTGUN_Y,   0,              OPTION_LIGHTGUN_DEVICE,   "lightgun");
-	init_autoselect_devices(machine, IPT_POSITIONAL,  IPT_POSITIONAL_V, 0,              OPTION_POSITIONAL_DEVICE, "positional");
-	init_autoselect_devices(machine, IPT_DIAL,        IPT_DIAL_V,       0,              OPTION_DIAL_DEVICE,       "dial");
-	init_autoselect_devices(machine, IPT_TRACKBALL_X, IPT_TRACKBALL_Y,  0,              OPTION_TRACKBALL_DEVICE,  "trackball");
-	init_autoselect_devices(machine, IPT_MOUSE_X,     IPT_MOUSE_Y,      0,              OPTION_MOUSE_DEVICE,      "mouse");
-
-	/* look for 4-way joysticks and change the default map if we find any */
-	if (joystick_map_default[0] == 0 || strcmp(joystick_map_default, "auto") == 0)
-		for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-			for (field = port->first_field(); field != NULL; field = field->next())
-				if (field->state->joystick != NULL && field->way == 4)
-				{
-					machine.input().set_global_joystick_map((field->flags & FIELD_FLAG_ROTATED) ? joystick_map_4way_diagonal : joystick_map_4way_sticky);
-					break;
-				}
-}
-
-
-/*-------------------------------------------------
-    init_autoselect_devices - autoselect a single
-    device based on the input port list passed
-    in and the corresponding option
--------------------------------------------------*/
-
-static void init_autoselect_devices(running_machine &machine, int type1, int type2, int type3, const char *option, const char *ananame)
-{
-	const char *stemp = machine.options().value(option);
-	input_device_class autoenable = DEVICE_CLASS_KEYBOARD;
-	const char *autostring = "keyboard";
-	const input_field_config *field;
-	const input_port_config *port;
-
-	/* if nothing specified, ignore the option */
-	if (stemp[0] == 0)
-		return;
-
-	/* extract valid strings */
-	if (strcmp(stemp, "mouse") == 0)
-	{
-		autoenable = DEVICE_CLASS_MOUSE;
-		autostring = "mouse";
-	}
-	else if (strcmp(stemp, "joystick") == 0)
-	{
-		autoenable = DEVICE_CLASS_JOYSTICK;
-		autostring = "joystick";
-	}
-	else if (strcmp(stemp, "lightgun") == 0)
-	{
-		autoenable = DEVICE_CLASS_LIGHTGUN;
-		autostring = "lightgun";
-	}
-	else if (strcmp(stemp, "none") == 0)
-	{
-		/* nothing specified */
-		return;
-	}
-	else if (strcmp(stemp, "keyboard") != 0)
-		mame_printf_error("Invalid %s value %s; reverting to keyboard\n", option, stemp);
-
-	/* only scan the list if we haven't already enabled this class of control */
-	if (machine.ioport().first_port() != NULL && !machine.input().device_class(autoenable).enabled())
-		for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-			for (field = port->first_field(); field != NULL; field = field->next())
-
-				/* if this port type is in use, apply the autoselect criteria */
-				if ((type1 != 0 && field->type == type1) ||
-					(type2 != 0 && field->type == type2) ||
-					(type3 != 0 && field->type == type3))
-				{
-					mame_printf_verbose("Input: Autoenabling %s due to presence of a %s\n", autostring, ananame);
-					machine.input().device_class(autoenable).enable();
-					break;
-				}
-}
-
-
-/*-------------------------------------------------
-    init_field_device_info - allocate and populate
-    information about a device callback
--------------------------------------------------*/
-
-static device_field_info *init_field_device_info(const input_field_config *field, const char *device_name)
-{
-	device_field_info *info;
-	input_port_value mask;
-
-	/* allocate memory */
-	info = auto_alloc_clear(field->machine(), device_field_info);
-
-	/* fill in the data */
-	info->field = field;
-	for (mask = field->mask; !(mask & 1); mask >>= 1)
-		info->shift++;
-
-	info->device = (device_name != NULL) ? field->machine().device(device_name) : &field->port().owner();
-
-	info->oldval = field->defvalue >> info->shift;
-	return info;
-}
-
-
-/*-------------------------------------------------
-    init_field_analog_state - allocate and populate
-    information about an analog port
--------------------------------------------------*/
-
-static analog_field_state *init_field_analog_state(const input_field_config *field)
-{
-	analog_field_state *state;
-	input_port_value mask;
-
-	/* allocate memory */
-	state = auto_alloc_clear(field->machine(), analog_field_state);
-
-	/* compute the shift amount and number of bits */
-	for (mask = field->mask; !(mask & 1); mask >>= 1)
-		state->shift++;
-
-	/* initialize core data */
-	state->field = field;
-	state->adjdefvalue = (field->defvalue & field->mask) >> state->shift;
-	state->adjmin = (field->min & field->mask) >> state->shift;
-	state->adjmax = (field->max & field->mask) >> state->shift;
-	state->sensitivity = field->sensitivity;
-	state->reverse = ((field->flags & ANALOG_FLAG_REVERSE) != 0);
-	state->delta = field->delta;
-	state->centerdelta = field->centerdelta;
-	state->minimum = INPUT_ABSOLUTE_MIN;
-	state->maximum = INPUT_ABSOLUTE_MAX;
-
-	/* set basic parameters based on the configured type */
-	switch (field->type)
-	{
-		/* paddles and analog joysticks are absolute and autocenter */
-		case IPT_AD_STICK_X:
-		case IPT_AD_STICK_Y:
-		case IPT_AD_STICK_Z:
-		case IPT_PADDLE:
-		case IPT_PADDLE_V:
-			state->absolute = TRUE;
-			state->autocenter = TRUE;
-			state->interpolate = TRUE;
-			break;
-
-		/* pedals start at and autocenter to the min range */
-		case IPT_PEDAL:
-		case IPT_PEDAL2:
-		case IPT_PEDAL3:
-			state->center = INPUT_ABSOLUTE_MIN;
-			state->accum = APPLY_INVERSE_SENSITIVITY(state->center, state->sensitivity);
-			state->absolute = TRUE;
-			state->autocenter = TRUE;
-			state->interpolate = TRUE;
-			break;
-
-		/* lightguns are absolute as well, but don't autocenter and don't interpolate their values */
-		case IPT_LIGHTGUN_X:
-		case IPT_LIGHTGUN_Y:
-			state->absolute = TRUE;
-			state->autocenter = FALSE;
-			state->interpolate = FALSE;
-			break;
-
-		/* positional devices are absolute, but can also wrap like relative devices */
-		/* set each position to be 512 units */
-		case IPT_POSITIONAL:
-		case IPT_POSITIONAL_V:
-			state->positionalscale = COMPUTE_SCALE(field->max, INPUT_ABSOLUTE_MAX - INPUT_ABSOLUTE_MIN);
-			state->adjmin = 0;
-			state->adjmax = field->max - 1;
-			state->wraps = ((field->flags & ANALOG_FLAG_WRAPS) != 0);
-			state->autocenter = !state->wraps;
-			break;
-
-		/* dials, mice and trackballs are relative devices */
-		/* these have fixed "min" and "max" values based on how many bits are in the port */
-		/* in addition, we set the wrap around min/max values to 512 * the min/max values */
-		/* this takes into account the mapping that one mouse unit ~= 512 analog units */
-		case IPT_DIAL:
-		case IPT_DIAL_V:
-		case IPT_TRACKBALL_X:
-		case IPT_TRACKBALL_Y:
-		case IPT_MOUSE_X:
-		case IPT_MOUSE_Y:
-			state->absolute = FALSE;
-			state->wraps = TRUE;
-			state->interpolate = TRUE;
-			break;
-
-		default:
-			fatalerror("Unknown analog port type -- don't know if it is absolute or not");
-			break;
-	}
-
-	/* further processing for absolute controls */
-	if (state->absolute)
-	{
-		/* if the default value is pegged at the min or max, use a single scale value for the whole axis */
-		state->single_scale = (state->adjdefvalue == state->adjmin) || (state->adjdefvalue == state->adjmax);
-
-		/* if not "single scale", compute separate scales for each side of the default */
-		if (!state->single_scale)
-		{
-			/* unsigned */
-			state->scalepos = COMPUTE_SCALE(state->adjmax - state->adjdefvalue, INPUT_ABSOLUTE_MAX - 0);
-			state->scaleneg = COMPUTE_SCALE(state->adjdefvalue - state->adjmin, 0 - INPUT_ABSOLUTE_MIN);
-
-			if (state->adjmin > state->adjmax)
-				state->scaleneg = -state->scaleneg;
-
-			/* reverse point is at center */
-			state->reverse_val = 0;
-		}
-		else
-		{
-			/* single axis that increases from default */
-			state->scalepos = COMPUTE_SCALE(state->adjmax - state->adjmin, INPUT_ABSOLUTE_MAX - INPUT_ABSOLUTE_MIN);
-
-			/* move from default */
-			if (state->adjdefvalue == state->adjmax)
-				state->scalepos = -state->scalepos;
-
-			/* make the scaling the same for easier coding when we need to scale */
-			state->scaleneg = state->scalepos;
-
-			/* reverse point is at max */
-			state->reverse_val = state->maximum;
-		}
-	}
-
-	/* relative and positional controls all map directly with a 512x scale factor */
-	else
-	{
-		/* The relative code is set up to allow specifing PORT_MINMAX and default values. */
-		/* The validity checks are purposely set up to not allow you to use anything other */
-		/* a default of 0 and PORT_MINMAX(0,mask).  This is in case the need arises to use */
-		/* this feature in the future.  Keeping the code in does not hurt anything. */
-		if (state->adjmin > state->adjmax)
-			/* adjust for signed */
-			state->adjmin = -state->adjmin;
-
-		if (state->wraps)
-			state->adjmax++;
-
-		state->minimum = (state->adjmin - state->adjdefvalue) * INPUT_RELATIVE_PER_PIXEL;
-		state->maximum = (state->adjmax - state->adjdefvalue) * INPUT_RELATIVE_PER_PIXEL;
-
-		/* make the scaling the same for easier coding when we need to scale */
-		state->scaleneg = state->scalepos = COMPUTE_SCALE(1, INPUT_RELATIVE_PER_PIXEL);
-
-		if (field->flags & ANALOG_FLAG_RESET)
-			/* delta values reverse from center */
-			state->reverse_val = 0;
-		else
-		{
-			/* positional controls reverse from their max range */
-			state->reverse_val = state->maximum + state->minimum;
-
-			/* relative controls reverse from 1 past their max range */
-			if (state->wraps)
-				state->reverse_val -= INPUT_RELATIVE_PER_PIXEL;
-		}
-	}
-
-	/* compute scale for keypresses */
-	state->keyscalepos = RECIP_SCALE(state->scalepos);
-	state->keyscaleneg = RECIP_SCALE(state->scaleneg);
-
-	return state;
-}
-
-
-
-/***************************************************************************
-    ONCE-PER-FRAME UPDATES
-***************************************************************************/
-
-/*-------------------------------------------------
-    frame_update_callback - system-wide callback to
-    update the input ports once per frame, but
-    only if we are not paused
--------------------------------------------------*/
-
-static void frame_update_callback(running_machine &machine)
-{
-	/* if we're paused, don't do anything */
-	if (machine.paused())
-		return;
-
-	/* otherwise, use the common code */
-	frame_update(machine);
-}
-
-static key_buffer *get_buffer(running_machine &machine)
-{
-	ioport_manager &portdata = machine.ioport();
-	assert(inputx_can_post(machine));
-	return (key_buffer *)&portdata.keybuffer;
-}
-
-
-
-static const inputx_code *find_code(inputx_code *codes, unicode_char ch)
-{
-	int i;
-
-	assert(codes);
-	for (i = 0; codes[i].ch; i++)
-	{
-		if (codes[i].ch == ch)
-			return &codes[i];
-	}
-	return NULL;
-}
-
-/*-------------------------------------------------
-    input_port_update_hook - hook function
-    called from core to allow for natural keyboard
--------------------------------------------------*/
-
-static void input_port_update_hook(running_machine &machine, const input_port_config *port, input_port_value *digital)
-{
-	ioport_manager &portdata = machine.ioport();
-	const key_buffer *keybuf;
-	const inputx_code *code;
-	unicode_char ch;
-	int i;
-	UINT32 value;
-
-	if (inputx_can_post(machine))
-	{
-		keybuf = get_buffer(machine);
-
-		/* is the key down right now? */
-		if (keybuf && keybuf->status_keydown && (keybuf->begin_pos != keybuf->end_pos))
-		{
-			/* identify the character that is down right now, and its component codes */
-			ch = keybuf->buffer[keybuf->begin_pos];
-			code = find_code(portdata.codes, ch);
-
-			/* loop through this character's component codes */
-			if (code != NULL)
-			{
-				for (i = 0; i < ARRAY_LENGTH(code->field) && (code->field[i] != NULL); i++)
-				{
-					if (&code->field[i]->port() == port)
-					{
-						value = code->field[i]->mask;
-						*digital |= value;
-					}
-				}
-			}
-		}
-	}
-}
-
-
-/*-------------------------------------------------
-    frame_update - core logic for per-frame input
-    port updating
--------------------------------------------------*/
-
-static void frame_update(running_machine &machine)
-{
-	ioport_manager &portdata = machine.ioport();
-	const input_field_config *mouse_field = NULL;
-	int ui_visible = ui_is_menu_active();
-	attotime curtime = machine.time();
-	const input_port_config *port;
-	render_target *mouse_target;
-	INT32 mouse_target_x;
-	INT32 mouse_target_y;
-	int mouse_button;
-
-g_profiler.start(PROFILER_INPUT);
-
-	/* record/playback information about the current frame */
-	playback_frame(machine, curtime);
-	record_frame(machine, curtime);
-
-	/* track the duration of the previous frame */
-	portdata.last_delta_nsec = (curtime - portdata.last_frame_time).as_attoseconds() / ATTOSECONDS_PER_NANOSECOND;
-	portdata.last_frame_time = curtime;
-
-	/* update the digital joysticks */
-	frame_update_digital_joysticks(machine);
-
-	/* compute default values for all the ports */
-	input_port_update_defaults(machine);
-
-	/* perform the mouse hit test */
-	mouse_target = ui_input_find_mouse(machine, &mouse_target_x, &mouse_target_y, &mouse_button);
-	if (mouse_button && mouse_target)
-	{
-		const char *tag = NULL;
-		input_port_value mask;
-		float x, y;
-		if (mouse_target->map_point_input(mouse_target_x, mouse_target_y, tag, mask, x, y))
-			mouse_field = input_field_by_tag_and_mask(machine, tag, mask);
-	}
-
-	/* loop over all input ports */
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-	{
-		const input_field_config *field;
-		device_field_info *device_field;
-		input_port_value newvalue;
-
-		/* start with 0 values for the digital and VBLANK bits */
-		port->state->digital = 0;
-		port->state->vblank = 0;
-
-		/* now loop back and modify based on the inputs */
-		for (field = port->first_field(); field != NULL; field = field->next())
-			if (input_condition_true(port->machine(), &field->condition, port->owner()))
-			{
-				/* accumulate VBLANK bits */
-				if (field->type == IPT_VBLANK)
-					port->state->vblank ^= field->mask;
-
-				/* handle analog inputs */
-				else if (field->state->analog != NULL)
-					frame_update_analog_field(machine, field->state->analog);
-
-				/* handle non-analog types, but only when the UI isn't visible */
-				else if (!ui_visible && frame_get_digital_field_state(field, field == mouse_field))
-					port->state->digital |= field->mask;
-			}
-
-		/* hook for MESS's natural keyboard support */
-		input_port_update_hook(machine, port, &port->state->digital);
-
-		/* handle playback/record */
-		playback_port(port);
-		record_port(port);
-
-		/* call device line write handlers */
-		newvalue = input_port_read_direct(port);
-		for (device_field = port->state->writedevicelist; device_field; device_field = device_field->next)
-			if (device_field->field->type != IPT_OUTPUT && input_condition_true(port->machine(), &device_field->field->condition, port->owner()))
-			{
-				input_port_value newval = (newvalue & device_field->field->mask) >> device_field->shift;
-
-				/* if the bits have  write, call the handler */
-				if (device_field->oldval != newval)
-				{
-					device_field->field->write(*device_field->field, device_field->field->write_param, device_field->oldval, newval);
-
-					device_field->oldval = newval;
-				}
-			}
-	}
-
-g_profiler.stop();
-}
-
-
-/*-------------------------------------------------
-    frame_update_digital_joysticks - update the
-    state of digital joysticks prior to
-    accumulating the results in a port
--------------------------------------------------*/
-
-static void frame_update_digital_joysticks(running_machine &machine)
-{
-	ioport_manager &portdata = machine.ioport();
-	int player, joyindex;
-
-	/* loop over all the joysticks */
-	for (player = 0; player < MAX_PLAYERS; player++)
-		for (joyindex = 0; joyindex < DIGITAL_JOYSTICKS_PER_PLAYER; joyindex++)
-		{
-			digital_joystick_state *joystick = &portdata.joystick_info[player][joyindex];
-			if (joystick->inuse)
-			{
-				joystick->previous = joystick->current;
-				joystick->current = 0;
-
-				/* read all the associated ports */
-				if (joystick->field[JOYDIR_UP] != NULL && machine.input().seq_pressed(input_field_seq(joystick->field[JOYDIR_UP], SEQ_TYPE_STANDARD)))
-					joystick->current |= JOYDIR_UP_BIT;
-				if (joystick->field[JOYDIR_DOWN] != NULL && machine.input().seq_pressed(input_field_seq(joystick->field[JOYDIR_DOWN], SEQ_TYPE_STANDARD)))
-					joystick->current |= JOYDIR_DOWN_BIT;
-				if (joystick->field[JOYDIR_LEFT] != NULL && machine.input().seq_pressed(input_field_seq(joystick->field[JOYDIR_LEFT], SEQ_TYPE_STANDARD)))
-					joystick->current |= JOYDIR_LEFT_BIT;
-				if (joystick->field[JOYDIR_RIGHT] != NULL && machine.input().seq_pressed(input_field_seq(joystick->field[JOYDIR_RIGHT], SEQ_TYPE_STANDARD)))
-					joystick->current |= JOYDIR_RIGHT_BIT;
-
-				/* lock out opposing directions (left + right or up + down) */
-				if ((joystick->current & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) == (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT))
-					joystick->current &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
-				if ((joystick->current & (JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT)) == (JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT))
-					joystick->current &= ~(JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT);
-
-				/* only update 4-way case if joystick has moved */
-				if (joystick->current != joystick->previous)
-				{
-					joystick->current4way = joystick->current;
-
-					/*
-                        If joystick is pointing at a diagonal, acknowledge that the player moved
-                        the joystick by favoring a direction change.  This minimizes frustration
-                        when using a keyboard for input, and maximizes responsiveness.
-
-                        For example, if you are holding "left" then switch to "up" (where both left
-                        and up are briefly pressed at the same time), we'll transition immediately
-                        to "up."
-
-                        Zero any switches that didn't change from the previous to current state.
-                     */
-					if ((joystick->current4way & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) &&
-						(joystick->current4way & (JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT)))
-					{
-						joystick->current4way ^= joystick->current4way & joystick->previous;
-					}
-
-					/*
-                        If we are still pointing at a diagonal, we are in an indeterminant state.
-
-                        This could happen if the player moved the joystick from the idle position directly
-                        to a diagonal, or from one diagonal directly to an extreme diagonal.
-
-                        The chances of this happening with a keyboard are slim, but we still need to
-                        constrain this case.
-
-                        For now, just resolve randomly.
-                     */
-					if ((joystick->current4way & (JOYDIR_UP_BIT | JOYDIR_DOWN_BIT)) &&
-						(joystick->current4way & (JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT)))
-					{
-						if (machine.rand() & 1)
-							joystick->current4way &= ~(JOYDIR_LEFT_BIT | JOYDIR_RIGHT_BIT);
-						else
-							joystick->current4way &= ~(JOYDIR_UP_BIT | JOYDIR_DOWN_BIT);
-					}
-				}
-			}
-		}
-}
-
-
-/*-------------------------------------------------
-    frame_update_analog_field - update the
-    internals of a single analog field
--------------------------------------------------*/
-
-static void frame_update_analog_field(running_machine &machine, analog_field_state *analog)
-{
-	input_item_class itemclass;
-	int keypressed = FALSE;
-	INT64 keyscale;
-	INT32 rawvalue;
-	INT32 delta = 0;
-
-	/* clamp the previous value to the min/max range and remember it */
-	analog->previous = analog->accum = apply_analog_min_max(analog, analog->accum);
-
-	/* get the new raw analog value and its type */
-	rawvalue = machine.input().seq_axis_value(input_field_seq(analog->field, SEQ_TYPE_STANDARD), itemclass);
-
-	/* if we got an absolute input, it overrides everything else */
-	if (itemclass == ITEM_CLASS_ABSOLUTE)
-	{
-		if (analog->previousanalog != rawvalue)
-		{
-			/* only update if analog value changed */
-			analog->previousanalog = rawvalue;
-
-			/* apply the inverse of the sensitivity to the raw value so that */
-			/* it will still cover the full min->max range requested after */
-			/* we apply the sensitivity adjustment */
-			if (analog->absolute || (analog->field->flags & ANALOG_FLAG_RESET))
-			{
-				/* if port is absolute, then just return the absolute data supplied */
-				analog->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, analog->sensitivity);
-			}
-			else if (analog->positionalscale != 0)
-			{
-				/* if port is positional, we will take the full analog control and divide it */
-				/* into positions, that way as the control is moved full scale, */
-				/* it moves through all the positions */
-				rawvalue = APPLY_SCALE(rawvalue - INPUT_ABSOLUTE_MIN, analog->positionalscale) * INPUT_RELATIVE_PER_PIXEL + analog->minimum;
-
-				/* clamp the high value so it does not roll over */
-				rawvalue = MIN(rawvalue, analog->maximum);
-				analog->accum = APPLY_INVERSE_SENSITIVITY(rawvalue, analog->sensitivity);
-			}
-			else
-				/* if port is relative, we use the value to simulate the speed of relative movement */
-				/* sensitivity adjustment is allowed for this mode */
-				analog->accum += rawvalue;
-
-			analog->lastdigital = FALSE;
-			/* do not bother with other control types if the analog data is changing */
-			return;
-		}
-		else
-		{
-			/* we still have to update fake relative from joystick control */
-			if (!analog->absolute && analog->positionalscale == 0)
-				analog->accum += rawvalue;
-		}
-	}
-
-	/* if we got it from a relative device, use that as the starting delta */
-	/* also note that the last input was not a digital one */
-	if (itemclass == ITEM_CLASS_RELATIVE && rawvalue != 0)
-	{
-		delta = rawvalue;
-		analog->lastdigital = FALSE;
-	}
-
-	keyscale = (analog->accum >= 0) ? analog->keyscalepos : analog->keyscaleneg;
-
-	/* if the decrement code sequence is pressed, add the key delta to */
-	/* the accumulated delta; also note that the last input was a digital one */
-	if (machine.input().seq_pressed(input_field_seq(analog->field, SEQ_TYPE_DECREMENT)))
-	{
-		keypressed = TRUE;
-		if (analog->delta != 0)
-			delta -= APPLY_SCALE(analog->delta, keyscale);
-		else if (!analog->lastdigital)
-			/* decrement only once when first pressed */
-			delta -= APPLY_SCALE(1, keyscale);
-		analog->lastdigital = TRUE;
-	}
-
-	/* same for the increment code sequence */
-	if (machine.input().seq_pressed(input_field_seq(analog->field, SEQ_TYPE_INCREMENT)))
-	{
-		keypressed = TRUE;
-		if (analog->delta)
-			delta += APPLY_SCALE(analog->delta, keyscale);
-		else if (!analog->lastdigital)
-			/* increment only once when first pressed */
-			delta += APPLY_SCALE(1, keyscale);
-		analog->lastdigital = TRUE;
-	}
-
-	/* if resetting is requested, clear the accumulated position to 0 before */
-	/* applying the deltas so that we only return this frame's delta */
-	/* note that centering only works for relative controls */
-	/* no need to check if absolute here because it is checked by the validity tests */
-	if (analog->field->flags & ANALOG_FLAG_RESET)
-		analog->accum = 0;
-
-	/* apply the delta to the accumulated value */
-	analog->accum += delta;
-
-	/* if our last movement was due to a digital input, and if this control */
-	/* type autocenters, and if neither the increment nor the decrement seq */
-	/* was pressed, apply autocentering */
-	if (analog->autocenter)
-	{
-		INT32 center = APPLY_INVERSE_SENSITIVITY(analog->center, analog->sensitivity);
-		if (analog->lastdigital && !keypressed)
-		{
-			/* autocenter from positive values */
-			if (analog->accum >= center)
-			{
-				analog->accum -= APPLY_SCALE(analog->centerdelta, analog->keyscalepos);
-				if (analog->accum < center)
-				{
-					analog->accum = center;
-					analog->lastdigital = FALSE;
-				}
-			}
-
-			/* autocenter from negative values */
-			else
-			{
-				analog->accum += APPLY_SCALE(analog->centerdelta, analog->keyscaleneg);
-				if (analog->accum > center)
-				{
-					analog->accum = center;
-					analog->lastdigital = FALSE;
-				}
-			}
-		}
-	}
-	else if (!keypressed)
-		analog->lastdigital = FALSE;
-}
-
-
-/*-------------------------------------------------
-    frame_get_digital_field_state - get the state
-    of a digital field
--------------------------------------------------*/
-
-static int frame_get_digital_field_state(const input_field_config *field, int mouse_down)
-{
-	int curstate = mouse_down || field->machine().input().seq_pressed(input_field_seq(field, SEQ_TYPE_STANDARD));
-	int changed = FALSE;
-	int temp_field_impulse;
-
-	/* if the state changed, look for switch down/switch up */
-	if (curstate != field->state->last)
-	{
-		field->state->last = curstate;
-		changed = TRUE;
-	}
-
-	if (field->type == IPT_KEYBOARD && ui_get_use_natural_keyboard(field->machine()))
-		return FALSE;
-
-	/* coin impulse option */
-	{
-		int temp_option_impulse = field->machine().options().coin_impulse();
-		temp_field_impulse = field->impulse;
-		if ( temp_option_impulse != 0)
-		{
-			if (temp_option_impulse < 0)
-				temp_field_impulse = 0;
-			else if ((field->type >= IPT_COIN1 && field->type <= IPT_COIN12) || field->impulse != 0)
-				temp_field_impulse = temp_option_impulse;
-		}
-	}
-
-	/* if this is a switch-down event, handle impulse and toggle */
-	if (changed && curstate)
-	{
-		/* impluse controls: reset the impulse counter */
-		if (temp_field_impulse != 0 && field->state->impulse == 0)
-			field->state->impulse = temp_field_impulse;
-
-		/* toggle controls: flip the toggle state or advance to the next setting */
-		if (field->flags & FIELD_FLAG_TOGGLE)
-		{
-			if (field->settinglist().count() == 0)
-				field->state->value ^= field->mask;
-			else
-				input_field_select_next_setting(field);
-		}
-	}
-
-	/* update the current state with the impulse state */
-	if (temp_field_impulse != 0)
-	{
-		if (field->state->impulse != 0)
-		{
-			field->state->impulse--;
-			curstate = TRUE;
-		}
-		else
-			curstate = FALSE;
-	}
-
-	/* for toggle switches, the current value is folded into the port's default value */
-	/* so we always return FALSE here */
-	if (field->flags & FIELD_FLAG_TOGGLE)
-		curstate = FALSE;
-
-	/* additional logic to restrict digital joysticks */
-	if (curstate && !mouse_down && field->state->joystick != NULL && field->way != 16 && !field->machine().options().joystick_contradictory())
-	{
-		UINT8 mask = (field->way == 4) ? field->state->joystick->current4way : field->state->joystick->current;
-		if (!(mask & (1 << field->state->joydir)))
-			curstate = FALSE;
-	}
-
-	/* skip locked-out coin inputs */
-	if (curstate && field->type >= IPT_COIN1 && field->type <= IPT_COIN12 && coin_lockout_get_state(field->machine(), field->type - IPT_COIN1))
-	{
-		int verbose = field->machine().options().verbose();
-#ifdef MAME_DEBUG
-		verbose = 1;
-#endif
-		if (field->machine().options().coin_lockout())
-		{
-			if (verbose)
-				ui_popup_time(3, "Coinlock disabled %s.", input_field_name(field));
-			return FALSE; /* curstate = FALSE; */
-		}
-		else
-			if (verbose)
-				ui_popup_time(3, "Coinlock disabled, but broken through %s.", input_field_name(field));
-	}
-
-	return curstate;
-}
-
-
-
-/***************************************************************************
-    PORT CONFIGURATION HELPERS
-***************************************************************************/
-
-/*-------------------------------------------------
-    port_default_value - updates default value
-    of port settings according to device settings
--------------------------------------------------*/
-
-UINT32 port_default_value(const char *fulltag, UINT32 mask, UINT32 defval, device_t &owner)
-{
-	const input_device_default *def = owner.input_ports_defaults();
-	if (def != NULL)
-	{
-		astring fullpath;
-		for ( ; def->tag != NULL; def++)
-			if (owner.subtag(fullpath, def->tag) == fulltag && def->mask == mask)
-				return def->defvalue;
-	}
-	return defval;
-}
-
-
-/*-------------------------------------------------
-    input_port_config - constructor for an
-    I/O port configuration object
--------------------------------------------------*/
-
-input_port_config::input_port_config(device_t &owner, const char *tag)
-	: state(NULL),
-	  active(0),
-	  m_next(NULL),
-	  m_owner(owner),
-	  m_tag(tag),
-	  m_modcount(0)
-{
-}
-
-
-running_machine &input_port_config::machine() const
-{
-	return m_owner.machine();
-}
-
-
-/*-------------------------------------------------
-    field_config_alloc - allocate a new input
-    port field config
--------------------------------------------------*/
-
-input_field_config::input_field_config(input_port_config &port, int _type, input_port_value _defvalue, input_port_value _maskbits, const char *_name)
-	: mask(_maskbits),
-	  defvalue(_defvalue & _maskbits),
-	  type(_type),
-	  player(0),
-	  flags(0),
-	  impulse(0),
-	  name(_name),
-	  read_param(NULL),
-	  read_device(DEVICE_SELF),
-	  write_param(NULL),
-	  write_device(DEVICE_SELF),
-	  min(0),
-	  max(_maskbits),
-	  sensitivity(0),
-	  delta(0),
-	  centerdelta(0),
-	  crossaxis(0),
-	  crossscale(0),
-	  crossoffset(0),
-	  crossaltaxis(0),
-	  crossmapper_device(DEVICE_SELF),
-	  full_turn_count(0),
-	  remap_table(NULL),
-	  way(0),
-	  state(NULL),
-	  m_next(NULL),
-	  m_port(port),
-	  m_modcount(port.modcount())
-{
-	memset(&condition, 0, sizeof(condition));
-	for (int seqtype = 0; seqtype < ARRAY_LENGTH(seq); seqtype++)
-		seq[seqtype].set_default();
-	chars[0] = chars[1] = chars[2] = (unicode_char) 0;
-}
-
-
-input_setting_config::input_setting_config(input_field_config &field, input_port_value _value, const char *_name)
-	: value(_value),
-	  name(_name),
-	  m_field(field),
-	  m_next(NULL)
-{
-	memset(&condition, 0, sizeof(condition));
-}
-
-input_field_diplocation::input_field_diplocation(const char *string, UINT8 _swnum, bool _invert)
-	: swname(string),
-	  swnum(_swnum),
-	  invert(_invert)
-{
-}
-
-/*-------------------------------------------------
-    field_config_insert - insert an allocated
-    input port field config, replacing any
-    intersecting fields already present and
-    inserting at the correct sorted location
--------------------------------------------------*/
-
-void input_port_config::collapse_fields(astring &errorbuf)
-{
-	input_field_config *list = m_fieldlist.detach_all();
-	input_port_value maskbits = 0;
-	int lastmodcount = -1;
-	while (list != NULL)
-	{
-		if (list->modcount() != lastmodcount)
-		{
-			lastmodcount = list->modcount();
-			maskbits = 0;
-		}
-		input_field_config *current = list;
-		list = list->next();
-		field_config_insert(*current, maskbits, errorbuf);
-	}
-}
-
-void field_config_insert(input_field_config &newfield, input_port_value &disallowedbits, astring &errorbuf)
-{
-	input_port_value lowbit;
-
-	/* verify against the disallowed bits, but only if we are condition-free */
-	if (newfield.condition.condition == PORTCOND_ALWAYS)
-	{
-		if ((newfield.mask & disallowedbits) != 0)
-			errorbuf.catprintf("INPUT_TOKEN_FIELD specifies duplicate port bits (port=%s mask=%X)\n", newfield.port().tag(), newfield.mask);
-		disallowedbits |= newfield.mask;
-	}
-
-	/* first modify/nuke any entries that intersect our maskbits */
-	input_field_config *nextfield;
-	for (input_field_config *field = newfield.port().fieldlist().first(); field != NULL; field = nextfield)
-	{
-		nextfield = field->next();
-		if ((field->mask & newfield.mask) != 0 && (newfield.condition.condition == PORTCOND_ALWAYS ||
-		                                           field->condition.condition == PORTCOND_ALWAYS ||
-		                                           condition_equal(&field->condition, &newfield.condition)))
-		{
-			/* reduce the mask of the field we found */
-			field->mask &= ~newfield.mask;
-
-			/* if the new entry fully overrides the previous one, we nuke */
-			if (INPUT_PORT_OVERRIDE_FULLY_NUKES_PREVIOUS || field->mask == 0)
-				newfield.port().fieldlist().remove(*field);
-		}
-	}
-
-	/* make a mask of just the low bit */
-	lowbit = (newfield.mask ^ (newfield.mask - 1)) & newfield.mask;
-
-	/* scan forward to find where to insert ourselves */
-	input_field_config *field;
-	for (field = newfield.port().fieldlist().first(); field != NULL; field = field->next())
-		if (field->mask > lowbit)
-			break;
-
-	/* insert it into the list */
-	newfield.port().fieldlist().insert_before(newfield, field);
-}
-
-
-/*-------------------------------------------------
-    diplocation_expand - expand a string-based
-    DIP location into a linked list of
-    descriptions
--------------------------------------------------*/
-
-void diplocation_list_alloc(input_field_config &field, const char *location, astring &errorbuf)
-{
-	/* if nothing present, bail */
-	if (location == NULL)
-		return;
-
-	field.diploclist().reset();
-
-	/* parse the string */
+	// parse the string
 	astring name; // Don't move this variable inside the loop, lastname's lifetime depends on it being outside
 	const char *lastname = NULL;
 	const char *curentry = location;
 	int entries = 0;
 	while (*curentry != 0)
 	{
-		/* find the end of this entry */
+		// find the end of this entry
 		const char *comma = strchr(curentry, ',');
 		if (comma == NULL)
 			comma = curentry + strlen(curentry);
 
-		/* extract it to tempbuf */
+		// extract it to tempbuf
 		astring tempstr;
 		tempstr.cpy(curentry, comma - curentry);
 
-		/* first extract the switch name if present */
+		// first extract the switch name if present
 		const char *number = tempstr;
 		const char *colon = strchr(tempstr, ':');
 
-		/* allocate and copy the name if it is present */
+		// allocate and copy the name if it is present
 		if (colon != NULL)
 		{
 			lastname = name.cpy(number, colon - number);
 			number = colon + 1;
 		}
 
-		/* otherwise, just copy the last name */
+		// otherwise, just copy the last name
 		else
 		{
 			if (lastname == NULL)
@@ -2994,7 +2232,7 @@
 			name.cpy(lastname);
 		}
 
-		/* if the number is preceded by a '!' it's active high */
+		// if the number is preceded by a '!' it's active high
 		bool invert = false;
 		if (*number == '!')
 		{
@@ -3002,1866 +2240,2306 @@
 			number++;
 		}
 
-		/* now scan the switch number */
+		// now scan the switch number
 		int swnum = -1;
 		if (sscanf(number, "%d", &swnum) != 1)
 			errorbuf.catprintf("Switch location '%s' has invalid format!\n", location);
 
-		/* allocate a new entry */
-		field.diploclist().append(*global_alloc(input_field_diplocation(name, swnum, invert)));
+		// allocate a new entry
+		m_diploclist.append(*global_alloc(ioport_diplocation(name, swnum, invert)));
 		entries++;
 
-		/* advance to the next item */
+		// advance to the next item
 		curentry = comma;
 		if (*curentry != 0)
 			curentry++;
 	}
 
-	/* then verify the number of bits in the mask matches */
-	input_port_value temp;
+	// then verify the number of bits in the mask matches
+	ioport_value temp;
 	int bits;
-	for (bits = 0, temp = field.mask; temp != 0 && bits < 32; bits++)
+	for (bits = 0, temp = m_mask; temp != 0 && bits < 32; bits++)
 		temp &= temp - 1;
 	if (bits != entries)
-		errorbuf.catprintf("Switch location '%s' does not describe enough bits for mask %X\n", location, field.mask);
+		errorbuf.catprintf("Switch location '%s' does not describe enough bits for mask %X\n", location, m_mask);
 }
 
 
+//-------------------------------------------------
+//  init_live_state - create live state structures
+//-------------------------------------------------
 
-/***************************************************************************
-    TOKENIZATION HELPERS
-***************************************************************************/
+void ioport_field::init_live_state(analog_field *analog)
+{
+	// resolve callbacks
+	m_read.bind_relative_to(device());
+	m_write.bind_relative_to(device());
+	m_crosshair_mapper.bind_relative_to(device());
 
-/*-------------------------------------------------
-    token_to_input_field_type - convert a string
-    token to an input field type and player
--------------------------------------------------*/
+	// allocate live state
+	m_live = global_alloc(ioport_field_live(*this, analog));
+}
+
+
+
+//**************************************************************************
+//  I/O PORT FIELD LIVE
+//**************************************************************************
 
-static int token_to_input_field_type(running_machine &machine, const char *string, int *player)
+//-------------------------------------------------
+//  ioport_field_live - constructor
+//-------------------------------------------------
+
+ioport_field_live::ioport_field_live(ioport_field &field, analog_field *analog)
+	: analog(analog),
+	  joystick(NULL),
+	  value(field.defvalue()),
+	  impulse(0),
+	  last(0),
+	  joydir(digital_joystick::JOYDIR_COUNT)
 {
-	ioport_manager &portdata = machine.ioport();
-	int ipnum;
+	// fill in the basic values
+	for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+		seq[seqtype] = field.defseq_unresolved(seqtype);
+
+	// if this is a digital joystick field, make a note of it
+	if (field.is_digital_joystick())
+	{
+		joystick = &field.manager().digjoystick(field.player(), (field.type() - (IPT_DIGITAL_JOYSTICK_FIRST + 1)) / 4);
+		joydir = joystick->set_axis(field);
+	}
 
-	/* check for our failsafe case first */
-	if (sscanf(string, "TYPE_OTHER(%d,%d)", &ipnum, player) == 2)
-		return ipnum;
-
-	/* find the token in the list */
-	for (input_type_entry *entry = portdata.typelist.first(); entry != NULL; entry = entry->next())
-		if (entry->token != NULL && !strcmp(entry->token, string))
+	// Name keyboard key names
+	if (field.type_class() == INPUT_CLASS_KEYBOARD && field.specific_name() == NULL)
+	{
+		// loop through each character on the field
+		astring tempstr;
+		for (int which = 0; ; which++)
 		{
-			*player = entry->player;
-			return entry->type;
+			unicode_char ch = field.keyboard_code(which);
+			if (ch == 0)
+				break;
+			name.catprintf("%-*s ", MAX(SPACE_COUNT - 1, 0), field.manager().natkeyboard().key_name(tempstr, ch));
 		}
 
-	/* if we fail, return IPT_UNKNOWN */
-	*player = 0;
-	return IPT_UNKNOWN;
+		// trim extra spaces
+		name.trimspace();
+
+		// special case
+		if (name.len() == 0)
+			name.cpy("Unnamed Key");
+	}
 }
 
 
-/*-------------------------------------------------
-    input_field_type_to_token - convert an input
-    field type and player to a string token
--------------------------------------------------*/
 
-static const char *input_field_type_to_token(running_machine &machine, int type, int player)
+//**************************************************************************
+//  I/O PORT
+//**************************************************************************
+
+//-------------------------------------------------
+//  ioport_port - constructor
+//-------------------------------------------------
+
+ioport_port::ioport_port(device_t &owner, const char *tag)
+	: m_next(NULL),
+	  m_device(owner),
+	  m_tag(tag),
+	  m_modcount(0),
+	  m_active(0),
+	  m_live(NULL)
 {
-	ioport_manager &portdata = machine.ioport();
-	static char tempbuf[32];
+}
 
-	/* look up the port and return the token */
-	input_type_entry *entry = portdata.type_to_entry[type][player];
-	if (entry != NULL)
-		return entry->token;
 
-	/* if that fails, carry on */
-	sprintf(tempbuf, "TYPE_OTHER(%d,%d)", type, player);
-	return tempbuf;
+//-------------------------------------------------
+//  ~ioport_port - destructor
+//-------------------------------------------------
+
+ioport_port::~ioport_port()
+{
+	global_free(m_live);
 }
 
 
-/*-------------------------------------------------
-    token_to_seq_type - convert a string to
-    a sequence type
--------------------------------------------------*/
+//-------------------------------------------------
+//  machine - return a reference to the running
+//  machine
+//-------------------------------------------------
 
-static int token_to_seq_type(const char *string)
+running_machine &ioport_port::machine() const
 {
-	int seqindex;
+	return m_device.machine();
+}
 
-	/* look up the string in the table of possible sequence types and return the index */
-	for (seqindex = 0; seqindex < ARRAY_LENGTH(seqtypestrings); seqindex++)
-		if (!mame_stricmp(string, seqtypestrings[seqindex]))
-			return seqindex;
 
-	return -1;
+//-------------------------------------------------
+//  manager - return a reference to the
+//  ioport_manager on the running machine
+//-------------------------------------------------
+
+ioport_manager &ioport_port::manager() const
+{
+	return machine().ioport();
 }
 
 
+//-------------------------------------------------
+//  field - return a pointer to the first field
+//  that intersects the given mask
+//-------------------------------------------------
 
-/***************************************************************************
-    SETTINGS LOAD
-***************************************************************************/
+ioport_field *ioport_port::field(ioport_value mask)
+{
+	// if we got the port, look for the field
+	for (ioport_field *field = first_field(); field != NULL; field = field->next())
+		if ((field->mask() & mask) != 0)
+			return field;
+	return NULL;
+}
 
-/*-------------------------------------------------
-    load_config_callback - callback to extract
-    configuration data from the XML nodes
--------------------------------------------------*/
-
-static void load_config_callback(running_machine &machine, int config_type, xml_data_node *parentnode)
-{
-	ioport_manager &portdata = machine.ioport();
-	xml_data_node *portnode;
-	int seqtype;
 
-	/* in the completion phase, we finish the initialization with the final ports */
-	if (config_type == CONFIG_TYPE_FINAL)
-	{
-		portdata.safe_to_read = TRUE;
-		frame_update(machine);
-	}
+//-------------------------------------------------
+//  read - return the value of an I/O port
+//-------------------------------------------------
 
-	/* early exit if no data to parse */
-	if (parentnode == NULL)
-		return;
+ioport_value ioport_port::read()
+{
+	assert_always(manager().safe_to_read(), "Input ports cannot be read at init time!");
 
-	/* iterate over all the remap nodes for controller configs only */
-	if (config_type == CONFIG_TYPE_CONTROLLER)
-		load_remap_table(machine, parentnode);
+	// start with the digital state
+	ioport_value result = m_live->digital;
 
-	/* iterate over all the port nodes */
-	for (portnode = xml_get_sibling(parentnode->child, "port"); portnode; portnode = xml_get_sibling(portnode->next, "port"))
-	{
-		input_seq newseq[SEQ_TYPE_TOTAL], tempseq;
-		xml_data_node *seqnode;
-		int type, player;
+	// insert dynamic read values
+	for (dynamic_field *dynfield = m_live->readlist.first(); dynfield != NULL; dynfield = dynfield->next())
+		dynfield->read(result);
 
-		/* get the basic port info from the attributes */
-		type = token_to_input_field_type(machine, xml_get_attribute_string(portnode, "type", ""), &player);
+	// apply active high/low state to digital and dynamic read inputs
+	result ^= m_live->defvalue;
 
-		/* initialize sequences to invalid defaults */
-		for (seqtype = 0; seqtype < ARRAY_LENGTH(newseq); seqtype++)
-			newseq[seqtype].set(INPUT_CODE_INVALID);
+	// insert analog portions
+	for (analog_field *analog = m_live->analoglist.first(); analog != NULL; analog = analog->next())
+		analog->read(result);
 
-		/* loop over new sequences */
-		for (seqnode = xml_get_sibling(portnode->child, "newseq"); seqnode; seqnode = xml_get_sibling(seqnode->next, "newseq"))
-		{
-			/* with a valid type, parse out the new sequence */
-			seqtype = token_to_seq_type(xml_get_attribute_string(seqnode, "type", ""));
-			if (seqtype != -1 && seqnode->value != NULL)
-			{
-				if (strcmp(seqnode->value, "NONE") == 0)
-					newseq[seqtype].set();
-				else
-					machine.input().seq_from_tokens(newseq[seqtype], seqnode->value);
-			}
-		}
+	return result;
+}
 
-		/* if we're loading default ports, apply to the defaults */
-		if (config_type != CONFIG_TYPE_GAME)
-			load_default_config(machine, portnode, type, player, newseq);
-		else
-			load_game_config(machine, portnode, type, player, newseq);
-	}
 
-	/* after applying the controller config, push that back into the backup, since that is */
-	/* what we will diff against */
-	if (config_type == CONFIG_TYPE_CONTROLLER)
-		for (input_type_entry *entry = portdata.typelist.first(); entry != NULL; entry = entry->next())
-			for (seqtype = 0; seqtype < ARRAY_LENGTH(entry->seq); seqtype++)
-				entry->defseq[seqtype] = entry->seq[seqtype];
+//-------------------------------------------------
+//  write - write a value to a port
+//-------------------------------------------------
+
+void ioport_port::write(ioport_value data, ioport_value mem_mask)
+{
+	// call device line write handlers
+	COMBINE_DATA(&m_live->outputvalue);
+	for (dynamic_field *dynfield = m_live->writelist.first(); dynfield != NULL; dynfield = dynfield->next())
+		if (dynfield->field().type() == IPT_OUTPUT)
+			dynfield->write(m_live->outputvalue);
 }
 
 
-/*-------------------------------------------------
-    load_remap_table - extract and apply the
-    global remapping table
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_update - once/frame update
+//-------------------------------------------------
 
-static void load_remap_table(running_machine &machine, xml_data_node *parentnode)
+void ioport_port::frame_update(ioport_field *mouse_field)
 {
-	ioport_manager &portdata = machine.ioport();
-	input_code *oldtable, *newtable;
-	xml_data_node *remapnode;
-	int count;
+	// start with 0 values for the digital bits
+	m_live->digital = 0;
 
-	/* count items first so we can allocate */
-	count = 0;
-	for (remapnode = xml_get_sibling(parentnode->child, "remap"); remapnode != NULL; remapnode = xml_get_sibling(remapnode->next, "remap"))
-		count++;
+	// now loop back and modify based on the inputs
+	for (ioport_field *field = first_field(); field != NULL; field = field->next())
+		field->frame_update(m_live->digital, field == mouse_field);
 
-	/* if we have some, deal with them */
-	if (count > 0)
-	{
-		int remapnum;
+	// hook for MESS's natural keyboard support
+	manager().natkeyboard().frame_update(*this, m_live->digital);
 
-		/* allocate tables */
-		oldtable = global_alloc_array(input_code, count);
-		newtable = global_alloc_array(input_code, count);
+	// call device line write handlers
+	ioport_value newvalue = read();
+	for (dynamic_field *dynfield = m_live->writelist.first(); dynfield != NULL; dynfield = dynfield->next())
+		if (dynfield->field().type() != IPT_OUTPUT)
+			dynfield->write(newvalue);
+}
 
-		/* build up the remap table */
-		count = 0;
-		for (remapnode = xml_get_sibling(parentnode->child, "remap"); remapnode != NULL; remapnode = xml_get_sibling(remapnode->next, "remap"))
-		{
-			input_code origcode = machine.input().code_from_token(xml_get_attribute_string(remapnode, "origcode", ""));
-			input_code newcode = machine.input().code_from_token(xml_get_attribute_string(remapnode, "newcode", ""));
-			if (origcode != INPUT_CODE_INVALID && newcode != INPUT_CODE_INVALID)
-			{
-				oldtable[count] = origcode;
-				newtable[count] = newcode;
-				count++;
-			}
-		}
 
-		/* loop over the remapping table, operating only if something was specified */
-		for (remapnum = 0; remapnum < count; remapnum++)
-		{
-			input_code oldcode = oldtable[remapnum];
-			input_code newcode = newtable[remapnum];
+//-------------------------------------------------
+//  collapse_fields - remove any fields that are
+//  wholly overlapped by other fields
+//-------------------------------------------------
 
-			/* loop over all default ports, remapping the requested keys */
-			for (input_type_entry *entry = portdata.typelist.first(); entry != NULL; entry = entry->next())
-			{
-				/* remap anything in the default sequences */
-				for (int seqtype = 0; seqtype < ARRAY_LENGTH(entry->seq); seqtype++)
-					entry->seq[seqtype].replace(oldcode, newcode);
-			}
+void ioport_port::collapse_fields(astring &errorbuf)
+{
+	ioport_value maskbits = 0;
+	int lastmodcount = -1;
+
+	// remove the whole list and start from scratch
+	ioport_field *field = m_fieldlist.detach_all();
+	while (field != NULL)
+	{
+		// if this modcount doesn't match, reset
+		if (field->modcount() != lastmodcount)
+		{
+			lastmodcount = field->modcount();
+			maskbits = 0;
 		}
 
-		/* release the tables */
-		global_free(oldtable);
-		global_free(newtable);
+		// reinsert this field
+		ioport_field *current = field;
+		field = field->next();
+		insert_field(*current, maskbits, errorbuf);
 	}
 }
 
 
-/*-------------------------------------------------
-    load_default_config - apply configuration
-    data to the default mappings
--------------------------------------------------*/
+//-------------------------------------------------
+//  insert_field - insert a new field, checking
+//  for errors
+//-------------------------------------------------
 
-static int load_default_config(running_machine &machine, xml_data_node *portnode, int type, int player, const input_seq *newseq)
+void ioport_port::insert_field(ioport_field &newfield, ioport_value &disallowedbits, astring &errorbuf)
 {
-	ioport_manager &portdata = machine.ioport();
+	// verify against the disallowed bits, but only if we are condition-free
+	if (newfield.condition().none())
+	{
+		if ((newfield.mask() & disallowedbits) != 0)
+			errorbuf.catprintf("INPUT_TOKEN_FIELD specifies duplicate port bits (port=%s mask=%X)\n", tag(), newfield.mask());
+		disallowedbits |= newfield.mask();
+	}
 
-	/* find a matching port in the list */
-	for (input_type_entry *entry = portdata.typelist.first(); entry != NULL; entry = entry->next())
-		if (entry->type == type && entry->player == player)
+	// first modify/nuke any entries that intersect our maskbits
+	ioport_field *nextfield;
+	for (ioport_field *field = first_field(); field != NULL; field = nextfield)
+	{
+		nextfield = field->next();
+		if ((field->mask() & newfield.mask()) != 0 &&
+			(newfield.condition().none() || field->condition().none() || field->condition() == newfield.condition()))
 		{
-			for (int seqtype = 0; seqtype < ARRAY_LENGTH(entry->seq); seqtype++)
-				if (newseq[seqtype][0] != INPUT_CODE_INVALID)
-					entry->seq[seqtype] = newseq[seqtype];
-			return TRUE;
+			// reduce the mask of the field we found
+			field->reduce_mask(newfield.mask());
+
+			// if the new entry fully overrides the previous one, we nuke
+			if (INPUT_PORT_OVERRIDE_FULLY_NUKES_PREVIOUS || field->mask() == 0)
+				m_fieldlist.remove(*field);
 		}
+	}
+
+	// make a mask of just the low bit
+	ioport_value lowbit = (newfield.mask() ^ (newfield.mask() - 1)) & newfield.mask();
+
+	// scan forward to find where to insert ourselves
+	ioport_field *field;
+	for (field = first_field(); field != NULL; field = field->next())
+		if (field->mask() > lowbit)
+			break;
 
-	return FALSE;
+	// insert it into the list
+	m_fieldlist.insert_before(newfield, field);
 }
 
 
-/*-------------------------------------------------
-    load_game_config - apply configuration
-    data to the current set of input ports
--------------------------------------------------*/
+//-------------------------------------------------
+//  init_live_state - create the live state
+//-------------------------------------------------
 
-static int load_game_config(running_machine &machine, xml_data_node *portnode, int type, int player, const input_seq *newseq)
+void ioport_port::init_live_state()
 {
-	input_port_value mask, defvalue;
-	const input_field_config *field;
-	const input_port_config *port;
-	char tempbuffer[20];
-	const char *tag;
+	m_live = global_alloc(ioport_port_live(*this));
+}
 
-	/* read the mask, index, and defvalue attributes */
-	tag = xml_get_attribute_string(portnode, "tag", NULL);
-	mask = xml_get_attribute_int(portnode, "mask", 0);
-	defvalue = xml_get_attribute_int(portnode, "defvalue", 0);
 
-	/* find the port we want; if no tag, search them all */
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		if (tag == NULL || strcmp(get_port_tag(port, tempbuffer), tag) == 0)
-			for (field = port->first_field(); field != NULL; field = field->next())
 
-				/* find the matching mask and defvalue */
-				if (field->type == type && field->player == player &&
-					field->mask == mask && (field->defvalue & mask) == (defvalue & mask))
-				{
-					const char *revstring;
-					int seqtype;
+//**************************************************************************
+//  I/O PORT LIVE STATE
+//**************************************************************************
 
-					/* if a sequence was specified, copy it in */
-					for (seqtype = 0; seqtype < ARRAY_LENGTH(field->state->seq); seqtype++)
-						if (newseq[seqtype][0] != INPUT_CODE_INVALID)
-							field->state->seq[seqtype] = newseq[seqtype];
+//-------------------------------------------------
+//  ioport_port_live - constructor
+//-------------------------------------------------
 
-					/* for non-analog fields, fetch the value */
-					if (field->state->analog == NULL)
-						field->state->value = xml_get_attribute_int(portnode, "value", field->defvalue);
+ioport_port_live::ioport_port_live(ioport_port &port)
+	: defvalue(0),
+	  digital(0),
+	  outputvalue(0)
+{
+	// iterate over fields
+	for (ioport_field *field = port.first_field(); field != NULL; field = field->next())
+	{
+		// allocate analog state if it's analog
+		analog_field *analog = NULL;
+		if (field->is_analog())
+			analog = &analoglist.append(*global_alloc(analog_field(*field)));
 
-					/* for analog fields, fetch configurable analog attributes */
-					else
-					{
-						/* get base attributes */
-						field->state->analog->delta = xml_get_attribute_int(portnode, "keydelta", field->delta);
-						field->state->analog->centerdelta = xml_get_attribute_int(portnode, "centerdelta", field->centerdelta);
-						field->state->analog->sensitivity = xml_get_attribute_int(portnode, "sensitivity", field->sensitivity);
+		// allocate a dynamic field for reading
+		if (field->has_dynamic_read())
+			readlist.append(*global_alloc(dynamic_field(*field)));
 
-						/* fetch yes/no for reverse setting */
-						revstring = xml_get_attribute_string(portnode, "reverse", NULL);
-						if (revstring != NULL)
-							field->state->analog->reverse = (strcmp(revstring, "yes") == 0);
-					}
-					return TRUE;
-				}
+		// allocate a dynamic field for writing
+		if (field->has_dynamic_write())
+			writelist.append(*global_alloc(dynamic_field(*field)));
 
-	return FALSE;
+		// let the field initialize its live state
+		field->init_live_state(analog);
+	}
 }
 
 
 
-/***************************************************************************
-    SETTINGS SAVE
-***************************************************************************/
+//**************************************************************************
+//  I/O PORT MANAGER
+//**************************************************************************
+
+//-------------------------------------------------
+//  ioport_manager - constructor
+//-------------------------------------------------
+
+ioport_manager::ioport_manager(running_machine &machine)
+	: m_machine(machine),
+	  m_safe_to_read(false),
+	  m_natkeyboard(machine),
+	  m_last_frame_time(attotime::zero),
+	  m_last_delta_nsec(0),
+	  m_record_file(machine.options().input_directory(), OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS),
+	  m_playback_file(machine.options().input_directory(), OPEN_FLAG_READ),
+	  m_playback_accumulated_speed(0),
+	  m_playback_accumulated_frames(0)
+{
+	memset(m_type_to_entry, 0, sizeof(m_type_to_entry));
+}
 
-/*-------------------------------------------------
-    save_config_callback - config callback for
-    saving input port configuration
--------------------------------------------------*/
 
-static void save_config_callback(running_machine &machine, int config_type, xml_data_node *parentnode)
+//-------------------------------------------------
+//  initialize - walk the configured ports and
+//  create live state information
+//-------------------------------------------------
+
+time_t ioport_manager::initialize()
 {
-	/* if no parentnode, ignore */
-	if (parentnode == NULL)
-		return;
+	// add an exit callback and a frame callback
+	machine().add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(ioport_manager::exit), this));
+	machine().add_notifier(MACHINE_NOTIFY_FRAME, machine_notify_delegate(FUNC(ioport_manager::frame_update_callback), this));
 
-	/* default ports save differently */
-	if (config_type == CONFIG_TYPE_DEFAULT)
-		save_default_inputs(machine, parentnode);
-	else
-		save_game_inputs(machine, parentnode);
+	// initialize the default port info from the OSD
+	init_port_types();
+
+	// if we have a token list, proceed
+	device_iterator iter(machine().root_device());
+	for (device_t *device = iter.first(); device != NULL; device = iter.next())
+	{
+		astring errors;
+		m_portlist.append(*device, errors);
+		if (errors)
+			mame_printf_error("Input port errors:\n%s", errors.cstr());
+	}
+
+	// allocate live structures to mirror the configuration
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		port->init_live_state();
+
+	// handle autoselection of devices
+	init_autoselect_devices(IPT_AD_STICK_X,  IPT_AD_STICK_Y,   IPT_AD_STICK_Z, OPTION_ADSTICK_DEVICE,    "analog joystick");
+	init_autoselect_devices(IPT_PADDLE,      IPT_PADDLE_V,     0,              OPTION_PADDLE_DEVICE,     "paddle");
+	init_autoselect_devices(IPT_PEDAL,       IPT_PEDAL2,       IPT_PEDAL3,     OPTION_PEDAL_DEVICE,      "pedal");
+	init_autoselect_devices(IPT_LIGHTGUN_X,  IPT_LIGHTGUN_Y,   0,              OPTION_LIGHTGUN_DEVICE,   "lightgun");
+	init_autoselect_devices(IPT_POSITIONAL,  IPT_POSITIONAL_V, 0,              OPTION_POSITIONAL_DEVICE, "positional");
+	init_autoselect_devices(IPT_DIAL,        IPT_DIAL_V,       0,              OPTION_DIAL_DEVICE,       "dial");
+	init_autoselect_devices(IPT_TRACKBALL_X, IPT_TRACKBALL_Y,  0,              OPTION_TRACKBALL_DEVICE,  "trackball");
+	init_autoselect_devices(IPT_MOUSE_X,     IPT_MOUSE_Y,      0,              OPTION_MOUSE_DEVICE,      "mouse");
+
+	// look for 4-way joysticks and change the default map if we find any
+	const char *joystick_map_default = machine().options().joystick_map();
+	if (joystick_map_default[0] == 0 || strcmp(joystick_map_default, "auto") == 0)
+		for (ioport_port *port = first_port(); port != NULL; port = port->next())
+			for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+				if (field->live().joystick != NULL && field->way() == 4)
+				{
+					machine().input().set_global_joystick_map(field->rotated() ? joystick_map_4way_diagonal : joystick_map_4way_sticky);
+					break;
+				}
+
+	// register callbacks for when we load configurations
+	config_register(machine(), "input", config_saveload_delegate(FUNC(ioport_manager::load_config), this), config_saveload_delegate(FUNC(ioport_manager::save_config), this));
+
+	// open playback and record files if specified
+	time_t basetime = playback_init();
+	record_init();
+	return basetime;
 }
 
 
-/*-------------------------------------------------
-    save_sequence - add a node for an input
-    sequence
--------------------------------------------------*/
+//-------------------------------------------------
+//  init_port_types - initialize the default
+//  type list
+//-------------------------------------------------
 
-static void save_sequence(running_machine &machine, xml_data_node *parentnode, int type, int porttype, const input_seq &seq)
+void ioport_manager::init_port_types()
 {
-	astring seqstring;
-	xml_data_node *seqnode;
+	// convert the array into a list of type states that can be modified
+	construct_core_types(m_typelist);
 
-	/* get the string for the sequence */
-	if (seq.length() == 0)
-		seqstring.cpy("NONE");
-	else
-		machine.input().seq_to_tokens(seqstring, seq);
+	// ask the OSD to customize the list
+	machine().osd().customize_input_type_list(m_typelist);
 
-	/* add the new node */
-	seqnode = xml_add_child(parentnode, "newseq", seqstring);
-	if (seqnode != NULL)
-		xml_set_attribute(seqnode, "type", seqtypestrings[type]);
+	// now iterate over the OSD-modified types
+	for (input_type_entry *curtype = first_type(); curtype != NULL; curtype = curtype->next())
+	{
+		// first copy all the OSD-updated sequences into our current state
+		for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+			curtype->m_seq[seqtype] = curtype->defseq(seqtype);
+
+		// also make a lookup table mapping type/player to the appropriate type list entry
+		m_type_to_entry[curtype->type()][curtype->player()] = curtype;
+	}
 }
 
 
-/*-------------------------------------------------
-    save_this_input_field_type - determine if the given
-    port type is worth saving
--------------------------------------------------*/
+//-------------------------------------------------
+//  init_autoselect_devices - autoselect a single
+//  device based on the input port list passed
+//  in and the corresponding option
+//-------------------------------------------------
 
-static int save_this_input_field_type(int type)
+void ioport_manager::init_autoselect_devices(int type1, int type2, int type3, const char *option, const char *ananame)
 {
-	switch (type)
+	// if nothing specified, ignore the option
+	const char *stemp = machine().options().value(option);
+	if (stemp[0] == 0)
+		return;
+
+	// extract valid strings
+	const char *autostring = "keyboard";
+	input_device_class autoenable = DEVICE_CLASS_KEYBOARD;
+	if (strcmp(stemp, "mouse") == 0)
+	{
+		autoenable = DEVICE_CLASS_MOUSE;
+		autostring = "mouse";
+	}
+	else if (strcmp(stemp, "joystick") == 0)
+	{
+		autoenable = DEVICE_CLASS_JOYSTICK;
+		autostring = "joystick";
+	}
+	else if (strcmp(stemp, "lightgun") == 0)
+	{
+		autoenable = DEVICE_CLASS_LIGHTGUN;
+		autostring = "lightgun";
+	}
+	else if (strcmp(stemp, "none") == 0)
 	{
-		case IPT_UNUSED:
-		case IPT_END:
-		case IPT_PORT:
-		case IPT_VBLANK:
-		case IPT_UNKNOWN:
-			return FALSE;
+		// nothing specified
+		return;
 	}
-	return TRUE;
+	else if (strcmp(stemp, "keyboard") != 0)
+		mame_printf_error("Invalid %s value %s; reverting to keyboard\n", option, stemp);
+
+	// only scan the list if we haven't already enabled this class of control
+	if (first_port() != NULL && !machine().input().device_class(autoenable).enabled())
+		for (ioport_port *port = first_port(); port != NULL; port = port->next())
+			for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+
+				// if this port type is in use, apply the autoselect criteria
+				if ((type1 != 0 && field->type() == type1) || (type2 != 0 && field->type() == type2) || (type3 != 0 && field->type() == type3))
+				{
+					mame_printf_verbose("Input: Autoenabling %s due to presence of a %s\n", autostring, ananame);
+					machine().input().device_class(autoenable).enable();
+					break;
+				}
 }
 
 
-/*-------------------------------------------------
-    save_default_inputs - add nodes for any default
-    mappings that have changed
--------------------------------------------------*/
+//-------------------------------------------------
+//  exit - exit callback to ensure we clean up
+//  and close our files
+//-------------------------------------------------
 
-static void save_default_inputs(running_machine &machine, xml_data_node *parentnode)
+void ioport_manager::exit()
 {
-	ioport_manager &portdata = machine.ioport();
-	input_type_entry *entry;
+	// close any playback or recording files
+	playback_end();
+	record_end();
+}
 
-	/* iterate over ports */
-	for (entry = portdata.typelist.first(); entry != NULL; entry = entry->next())
-	{
-		/* only save if this port is a type we save */
-		if (save_this_input_field_type(entry->type))
-		{
-			int seqtype;
 
-			/* see if any of the sequences have changed */
-			for (seqtype = 0; seqtype < ARRAY_LENGTH(entry->seq); seqtype++)
-				if (entry->seq[seqtype] != entry->defseq[seqtype])
-					break;
+//-------------------------------------------------
+//  type_name - return the name for the given
+//  type/player
+//-------------------------------------------------
 
-			/* if so, we need to add a node */
-			if (seqtype < ARRAY_LENGTH(entry->seq))
-			{
-				/* add a new port node */
-				xml_data_node *portnode = xml_add_child(parentnode, "port", NULL);
-				if (portnode != NULL)
-				{
-					/* add the port information and attributes */
-					xml_set_attribute(portnode, "type", input_field_type_to_token(machine, entry->type, entry->player));
+const char *ioport_manager::type_name(ioport_type type, UINT8 player)
+{
+	// if we have a machine, use the live state and quick lookup
+	input_type_entry *entry = m_type_to_entry[type][player];
+	if (entry != NULL)
+		return entry->name();
 
-					/* add only the sequences that have changed from the defaults */
-					for (seqtype = 0; seqtype < ARRAY_LENGTH(entry->seq); seqtype++)
-						if (entry->seq[seqtype] != entry->defseq[seqtype])
-							save_sequence(machine, portnode, seqtype, entry->type, entry->seq[seqtype]);
-				}
-			}
-		}
-	}
+	// if we find nothing, return an invalid group
+	return "???";
 }
 
 
-/*-------------------------------------------------
-    save_game_inputs - add nodes for any game
-    mappings that have changed
--------------------------------------------------*/
-
-static void save_game_inputs(running_machine &machine, xml_data_node *parentnode)
-{
-	const input_field_config *field;
-	const input_port_config *port;
-
-	/* iterate over ports */
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->first_field(); field != NULL; field = field->next())
-			if (save_this_input_field_type(field->type))
-			{
-				bool changed = false;
-				int seqtype;
+//-------------------------------------------------
+//  type_group - return the group for the given
+//  type/player
+//-------------------------------------------------
 
-				/* determine if we changed */
-				for (seqtype = 0; seqtype < ARRAY_LENGTH(field->state->seq); seqtype++)
-					changed |= (field->state->seq[seqtype] != field->seq[seqtype]);
+ioport_group ioport_manager::type_group(ioport_type type, int player)
+{
+	input_type_entry *entry = m_type_to_entry[type][player];
+	if (entry != NULL)
+		return entry->group();
 
-				/* non-analog changes */
-				if (field->state->analog == NULL)
-					changed |= ((field->state->value & field->mask) != (field->defvalue & field->mask));
+	// if we find nothing, return an invalid group
+	return IPG_INVALID;
+}
 
-				/* analog changes */
-				else
-				{
-					changed |= (field->state->analog->delta != field->delta);
-					changed |= (field->state->analog->centerdelta != field->centerdelta);
-					changed |= (field->state->analog->sensitivity != field->sensitivity);
-					changed |= (field->state->analog->reverse != ((field->flags & ANALOG_FLAG_REVERSE) != 0));
-				}
 
-				/* if we did change, add a new node */
-				if (changed)
-				{
-					/* add a new port node */
-					xml_data_node *portnode = xml_add_child(parentnode, "port", NULL);
-					if (portnode != NULL)
-					{
-						char tempbuffer[20];
+//-------------------------------------------------
+//  type_seq - return the input sequence for the
+//  given type/player
+//-------------------------------------------------
 
-						/* add the identifying information and attributes */
-						xml_set_attribute(portnode, "tag", get_port_tag(port, tempbuffer));
-						xml_set_attribute(portnode, "type", input_field_type_to_token(machine, field->type, field->player));
-						xml_set_attribute_int(portnode, "mask", field->mask);
-						xml_set_attribute_int(portnode, "defvalue", field->defvalue & field->mask);
-
-						/* add sequences if changed */
-						for (seqtype = 0; seqtype < ARRAY_LENGTH(field->state->seq); seqtype++)
-							if (field->state->seq[seqtype] != field->seq[seqtype])
-								save_sequence(machine, portnode, seqtype, field->type, field->state->seq[seqtype]);
+const input_seq &ioport_manager::type_seq(ioport_type type, int player, input_seq_type seqtype)
+{
+	assert(type >= 0 && type < IPT_COUNT);
+	assert(player >= 0 && player < MAX_PLAYERS);
 
-						/* write out non-analog changes */
-						if (field->state->analog == NULL)
-						{
-							if ((field->state->value & field->mask) != (field->defvalue & field->mask))
-								xml_set_attribute_int(portnode, "value", field->state->value & field->mask);
-						}
+	// if we have a machine, use the live state and quick lookup
+	input_type_entry *entry = m_type_to_entry[type][player];
+	if (entry != NULL)
+		return entry->seq(seqtype);
 
-						/* write out analog changes */
-						else
-						{
-							if (field->state->analog->delta != field->delta)
-								xml_set_attribute_int(portnode, "keydelta", field->state->analog->delta);
-							if (field->state->analog->centerdelta != field->centerdelta)
-								xml_set_attribute_int(portnode, "centerdelta", field->state->analog->centerdelta);
-							if (field->state->analog->sensitivity != field->sensitivity)
-								xml_set_attribute_int(portnode, "sensitivity", field->state->analog->sensitivity);
-							if (field->state->analog->reverse != ((field->flags & ANALOG_FLAG_REVERSE) != 0))
-								xml_set_attribute(portnode, "reverse", field->state->analog->reverse ? "yes" : "no");
-						}
-					}
-				}
-			}
+	// if we find nothing, return an empty sequence
+	return input_seq::empty_seq;
 }
 
 
+//-------------------------------------------------
+//  set_type_seq - change the input sequence for
+//  the given type/player
+//-------------------------------------------------
 
-/***************************************************************************
-    INPUT PLAYBACK
-***************************************************************************/
-
-/*-------------------------------------------------
-    playback_read_uint8 - read an 8-bit value
-    from the playback file
--------------------------------------------------*/
-
-static UINT8 playback_read_uint8(running_machine &machine)
+void ioport_manager::set_type_seq(ioport_type type, int player, input_seq_type seqtype, const input_seq &newseq)
 {
-	ioport_manager &portdata = machine.ioport();
-	UINT8 result;
-
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.playback_file == NULL)
-		return 0;
-
-	/* read the value; if we fail, end playback */
-	if (portdata.playback_file->read(&result, sizeof(result)) != sizeof(result))
-	{
-		playback_end(machine, "End of file");
-		return 0;
-	}
-
-	/* return the appropriate value */
-	return result;
+	input_type_entry *entry = m_type_to_entry[type][player];
+	if (entry != NULL)
+		entry->m_seq[seqtype] = newseq;
 }
 
 
-/*-------------------------------------------------
-    playback_read_uint32 - read a 32-bit value
-    from the playback file
--------------------------------------------------*/
+//-------------------------------------------------
+//  type_pressed - return true if the sequence for
+//  the given input type/player is pressed
+//-------------------------------------------------
 
-static UINT32 playback_read_uint32(running_machine &machine)
+bool ioport_manager::type_pressed(ioport_type type, int player)
 {
-	ioport_manager &portdata = machine.ioport();
-	UINT32 result;
+	return machine().input().seq_pressed(type_seq(type, player));
+}
 
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.playback_file == NULL)
-		return 0;
 
-	/* read the value; if we fail, end playback */
-	if (portdata.playback_file->read(&result, sizeof(result)) != sizeof(result))
-	{
-		playback_end(machine, "End of file");
-		return 0;
-	}
+//-------------------------------------------------
+//  type_class_present - return true if the given
+//  ioport_type_class exists in at least one port
+//-------------------------------------------------
 
-	/* return the appropriate value */
-	return LITTLE_ENDIANIZE_INT32(result);
+bool ioport_manager::type_class_present(ioport_type_class inputclass)
+{
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->type_class() == inputclass)
+				return true;
+	return false;
 }
 
 
-/*-------------------------------------------------
-    playback_read_uint64 - read a 64-bit value
-    from the playback file
--------------------------------------------------*/
+//-------------------------------------------------
+//  has_keyboard - determine if there is a
+//  keyboard present in the control list
+//-------------------------------------------------
 
-static UINT64 playback_read_uint64(running_machine &machine)
+bool ioport_manager::has_keyboard() const
 {
-	ioport_manager &portdata = machine.ioport();
-	UINT64 result;
-
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.playback_file == NULL)
-		return 0;
+	// iterate over ports and fields
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+		{
+			// if we are at init, check IPT_KEYBOARD
+			if (!m_safe_to_read && field->type() == IPT_KEYBOARD)
+				return true;
 
-	/* read the value; if we fail, end playback */
-	if (portdata.playback_file->read(&result, sizeof(result)) != sizeof(result))
-	{
-		playback_end(machine, "End of file");
-		return 0;
-	}
+			// else, check if there is a keyboard and if such a keyboard is enabled
+			if (field->type() == IPT_KEYBOARD && field->enabled())
+				return true;
+		}
 
-	/* return the appropriate value */
-	return LITTLE_ENDIANIZE_INT64(result);
+	return false;
 }
 
+//-------------------------------------------------
+//  count_players - counts the number of active
+//  players
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    playback_init - initialize INP playback
--------------------------------------------------*/
-
-static time_t playback_init(running_machine &machine)
+int ioport_manager::count_players() const
 {
-	const char *filename = machine.options().playback();
-	ioport_manager &portdata = machine.ioport();
-	UINT8 header[INP_HEADER_SIZE];
-	time_t basetime;
-
-	/* if no file, nothing to do */
-	if (filename[0] == 0)
-		return 0;
+	int max_player = 0;
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->type_class() == INPUT_CLASS_CONTROLLER && max_player <= field->player() + 1)
+				max_player = field->player() + 1;
 
-	/* open the playback file */
-	portdata.playback_file = auto_alloc(machine, emu_file(machine.options().input_directory(), OPEN_FLAG_READ));
-	file_error filerr = portdata.playback_file->open(filename);
-	assert_always(filerr == FILERR_NONE, "Failed to open file for playback");
+	return max_player;
+}
 
-	/* read the header and verify that it is a modern version; if not, print an error */
-	if (portdata.playback_file->read(header, sizeof(header)) != sizeof(header))
-		fatalerror("Input file is corrupt or invalid (missing header)");
-	if (memcmp(header, "MAMEINP\0", 8) != 0)
-		fatalerror("Input file invalid or in an older, unsupported format");
-	if (header[0x10] != INP_HEADER_MAJVERSION)
-		fatalerror("Input file format version mismatch");
 
-	/* output info to console */
-	mame_printf_info("Input file: %s\n", filename);
-	mame_printf_info("INP version %d.%d\n", header[0x10], header[0x11]);
-	basetime = header[0x08] | (header[0x09] << 8) | (header[0x0a] << 16) | (header[0x0b] << 24) |
-				((UINT64)header[0x0c] << 32) | ((UINT64)header[0x0d] << 40) | ((UINT64)header[0x0e] << 48) | ((UINT64)header[0x0f] << 56);
-	mame_printf_info("Created %s", ctime(&basetime));
-	mame_printf_info("Recorded using %s\n", header + 0x20);
+//-------------------------------------------------
+//  crosshair_position - return the extracted
+//  crosshair values for the given player
+//-------------------------------------------------
 
-	/* verify the header against the current game */
-	if (memcmp(machine.system().name, header + 0x14, strlen(machine.system().name) + 1) != 0)
-		mame_printf_info("Input file is for %s '%s', not for current %s '%s'\n", emulator_info::get_gamenoun(), header + 0x14, emulator_info::get_gamenoun(), machine.system().name);
+bool ioport_manager::crosshair_position(int player, float &x, float &y)
+{
+	// read all the lightgun values
+	bool gotx = false, goty = false;
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (field->player() == player && field->crosshair_axis() != CROSSHAIR_AXIS_NONE && field->enabled())
+			{
+				field->crosshair_position(x, y, gotx, goty);
 
-	/* enable compression */
-	portdata.playback_file->compress(FCOMPRESS_MEDIUM);
+				// if we got both, stop
+				if (gotx && goty)
+					break;
+			}
 
-	return basetime;
+	return (gotx && goty);
 }
 
 
-/*-------------------------------------------------
-    playback_end - end INP playback
--------------------------------------------------*/
+//-------------------------------------------------
+//  update_defaults - force an update to the input
+//  port values based on current conditions
+//-------------------------------------------------
 
-static void playback_end(running_machine &machine, const char *message)
+void ioport_manager::update_defaults()
 {
-	ioport_manager &portdata = machine.ioport();
-
-	/* only applies if we have a live file */
-	if (portdata.playback_file != NULL)
+	// two passes to catch conditionals properly
+	for (int loopnum = 0; loopnum < 2; loopnum++)
 	{
-		/* close the file */
-		auto_free(machine, portdata.playback_file);
-		portdata.playback_file = NULL;
-
-		/* pop a message */
-		if (message != NULL)
-			popmessage("Playback Ended\nReason: %s", message);
+		// loop over all input ports
+		for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		{
+			// only clear on the first pass
+			if (loopnum == 0)
+				port->live().defvalue = 0;
 
-		/* display speed stats */
-		portdata.playback_accumulated_speed /= portdata.playback_accumulated_frames;
-		mame_printf_info("Total playback frames: %d\n", (UINT32)portdata.playback_accumulated_frames);
-		mame_printf_info("Average recorded speed: %d%%\n", (UINT32)((portdata.playback_accumulated_speed * 200 + 1) >> 21));
+			// first compute the default value for the entire port
+			for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+				if (field->enabled())
+					port->live().defvalue = (port->live().defvalue & ~field->mask()) | (field->live().value & field->mask());
+		}
 	}
 }
 
 
-/*-------------------------------------------------
-    playback_frame - start of frame callback for
-    playback
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_update - core logic for per-frame input
+//  port updating
+//-------------------------------------------------
 
-static void playback_frame(running_machine &machine, attotime curtime)
+digital_joystick &ioport_manager::digjoystick(int player, int number)
 {
-	ioport_manager &portdata = machine.ioport();
+	// find it in the list
+	for (digital_joystick *joystick = m_joystick_list.first(); joystick != NULL; joystick = joystick->next())
+		if (joystick->player() == player && joystick->number() == number)
+			return *joystick;
 
-	/* if playing back, fetch the information and verify */
-	if (portdata.playback_file != NULL)
-	{
-		attotime readtime;
+	// create a new one
+	return m_joystick_list.append(*global_alloc(digital_joystick(player, number)));
+}
 
-		/* first the absolute time */
-		readtime.seconds = playback_read_uint32(machine);
-		readtime.attoseconds = playback_read_uint64(machine);
-		if (readtime != curtime)
-			playback_end(machine, "Out of sync");
 
-		/* then the speed */
-		portdata.playback_accumulated_speed += playback_read_uint32(machine);
-		portdata.playback_accumulated_frames++;
-	}
+//-------------------------------------------------
+//  frame_update - callback for once/frame updating
+//-------------------------------------------------
+
+void ioport_manager::frame_update_callback()
+{
+	// if we're paused, don't do anything
+	if (!machine().paused())
+		frame_update();
 }
 
 
-/*-------------------------------------------------
-    playback_port - per-port callback for playback
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_update_internal - core logic for
+//  per-frame input port updating
+//-------------------------------------------------
 
-static void playback_port(const input_port_config *port)
+void ioport_manager::frame_update()
 {
-	ioport_manager &portdata = port->machine().ioport();
+g_profiler.start(PROFILER_INPUT);
 
-	/* if playing back, fetch information about this port */
-	if (portdata.playback_file != NULL)
-	{
-		analog_field_state *analog;
+	// record/playback information about the current frame
+	attotime curtime = machine().time();
+	playback_frame(curtime);
+	record_frame(curtime);
+
+	// track the duration of the previous frame
+	m_last_delta_nsec = (curtime - m_last_frame_time).as_attoseconds() / ATTOSECONDS_PER_NANOSECOND;
+	m_last_frame_time = curtime;
+
+	// update the digital joysticks
+	for (digital_joystick *joystick = m_joystick_list.first(); joystick != NULL; joystick = joystick->next())
+		joystick->frame_update();
+
+	// compute default values for all the ports
+	update_defaults();
 
-		/* read the default value and the digital state */
-		port->state->defvalue = playback_read_uint32(port->machine());
-		port->state->digital = playback_read_uint32(port->machine());
+	// perform mouse hit testing
+	INT32 mouse_target_x, mouse_target_y;
+	int mouse_button;
+	render_target *mouse_target = ui_input_find_mouse(machine(), &mouse_target_x, &mouse_target_y, &mouse_button);
 
-		/* loop over analog ports and save their data */
-		for (analog = port->state->analoglist; analog != NULL; analog = analog->next)
+	// if the button is pressed, map the point and determine what was hit
+	ioport_field *mouse_field = NULL;
+	if (mouse_button && mouse_target != NULL)
+	{
+		const char *tag = NULL;
+		ioport_value mask;
+		float x, y;
+		if (mouse_target->map_point_input(mouse_target_x, mouse_target_y, tag, mask, x, y))
 		{
-			/* read current and previous values */
-			analog->accum = playback_read_uint32(port->machine());
-			analog->previous = playback_read_uint32(port->machine());
-
-			/* read configuration information */
-			analog->sensitivity = playback_read_uint32(port->machine());
-			analog->reverse = playback_read_uint8(port->machine());
+			ioport_port *port = machine().root_device().ioport(tag);
+			if (port != NULL)
+				mouse_field = port->field(mask);
 		}
 	}
-}
 
+	// loop over all input ports
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+	{
+		port->frame_update(mouse_field);
+
+		// handle playback/record
+		playback_port(*port);
+		record_port(*port);
+	}
 
+g_profiler.stop();
+}
 
-/***************************************************************************
-    INPUT RECORDING
-***************************************************************************/
 
-/*-------------------------------------------------
-    record_write_uint8 - write an 8-bit value
-    to the record file
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_interpolate - interpolate between two
+//  values based on the time between frames
+//-------------------------------------------------
 
-static void record_write_uint8(running_machine &machine, UINT8 data)
+INT32 ioport_manager::frame_interpolate(INT32 oldval, INT32 newval)
 {
-	ioport_manager &portdata = machine.ioport();
-	UINT8 result = data;
-
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.record_file == NULL)
-		return;
+	// if no last delta, just use new value
+	if (m_last_delta_nsec == 0)
+		return newval;
 
-	/* read the value; if we fail, end playback */
-	if (portdata.record_file->write(&result, sizeof(result)) != sizeof(result))
-		record_end(machine, "Out of space");
+	// otherwise, interpolate
+	attoseconds_t nsec_since_last = (machine().time() - m_last_frame_time).as_attoseconds() / ATTOSECONDS_PER_NANOSECOND;
+	return oldval + (INT64(newval - oldval) * nsec_since_last / m_last_delta_nsec);
 }
 
 
-/*-------------------------------------------------
-    record_write_uint32 - write a 32-bit value
-    to the record file
--------------------------------------------------*/
+//-------------------------------------------------
+//  load_config - callback to extract configuration
+//  data from the XML nodes
+//-------------------------------------------------
 
-static void record_write_uint32(running_machine &machine, UINT32 data)
+void ioport_manager::load_config(int config_type, xml_data_node *parentnode)
 {
-	ioport_manager &portdata = machine.ioport();
-	UINT32 result = LITTLE_ENDIANIZE_INT32(data);
+	// in the completion phase, we finish the initialization with the final ports
+	if (config_type == CONFIG_TYPE_FINAL)
+	{
+		m_safe_to_read = true;
+		frame_update();
+	}
 
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.record_file == NULL)
+	// early exit if no data to parse
+	if (parentnode == NULL)
 		return;
 
-	/* read the value; if we fail, end playback */
-	if (portdata.record_file->write(&result, sizeof(result)) != sizeof(result))
-		record_end(machine, "Out of space");
-}
-
+	// iterate over all the remap nodes for controller configs only
+	if (config_type == CONFIG_TYPE_CONTROLLER)
+		load_remap_table(parentnode);
 
-/*-------------------------------------------------
-    record_write_uint64 - write a 64-bit value
-    to the record file
--------------------------------------------------*/
+	// iterate over all the port nodes
+	for (xml_data_node *portnode = xml_get_sibling(parentnode->child, "port"); portnode; portnode = xml_get_sibling(portnode->next, "port"))
+	{
+		// get the basic port info from the attributes
+		int player;
+		int type = token_to_input_type(xml_get_attribute_string(portnode, "type", ""), player);
+
+		// initialize sequences to invalid defaults
+		input_seq newseq[SEQ_TYPE_TOTAL];
+		for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+			newseq[seqtype].set(INPUT_CODE_INVALID);
 
-static void record_write_uint64(running_machine &machine, UINT64 data)
-{
-	ioport_manager &portdata = machine.ioport();
-	UINT64 result = LITTLE_ENDIANIZE_INT64(data);
+		// loop over new sequences
+		for (xml_data_node *seqnode = xml_get_sibling(portnode->child, "newseq"); seqnode; seqnode = xml_get_sibling(seqnode->next, "newseq"))
+		{
+			// with a valid type, parse out the new sequence
+			input_seq_type seqtype = token_to_seq_type(xml_get_attribute_string(seqnode, "type", ""));
+			if (seqtype != -1 && seqnode->value != NULL)
+			{
+				if (strcmp(seqnode->value, "NONE") == 0)
+					newseq[seqtype].set();
+				else
+					machine().input().seq_from_tokens(newseq[seqtype], seqnode->value);
+			}
+		}
 
-	/* protect against NULL handles if previous reads fail */
-	if (portdata.record_file == NULL)
-		return;
+		// if we're loading default ports, apply to the defaults
+		if (config_type != CONFIG_TYPE_GAME)
+			load_default_config(portnode, type, player, newseq);
+		else
+			load_game_config(portnode, type, player, newseq);
+	}
 
-	/* read the value; if we fail, end playback */
-	if (portdata.record_file->write(&result, sizeof(result)) != sizeof(result))
-		record_end(machine, "Out of space");
+	// after applying the controller config, push that back into the backup, since that is
+	// what we will diff against
+	if (config_type == CONFIG_TYPE_CONTROLLER)
+		for (input_type_entry *entry = m_typelist.first(); entry != NULL; entry = entry->next())
+			for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+				entry->defseq(seqtype) = entry->seq(seqtype);
 }
 
 
-/*-------------------------------------------------
-    record_init - initialize INP recording
--------------------------------------------------*/
+//-------------------------------------------------
+//  load_remap_table - extract and apply the
+//  global remapping table
+//-------------------------------------------------
 
-static void record_init(running_machine &machine)
+void ioport_manager::load_remap_table(xml_data_node *parentnode)
 {
-	const char *filename = machine.options().record();
-	ioport_manager &portdata = machine.ioport();
-	UINT8 header[INP_HEADER_SIZE];
-	system_time systime;
+	// count items first so we can allocate
+	int count = 0;
+	for (xml_data_node *remapnode = xml_get_sibling(parentnode->child, "remap"); remapnode != NULL; remapnode = xml_get_sibling(remapnode->next, "remap"))
+		count++;
 
-	/* if no file, nothing to do */
-	if (filename[0] == 0)
-		return;
+	// if we have some, deal with them
+	if (count > 0)
+	{
+		// allocate tables
+		dynamic_array<input_code> oldtable(count);
+		dynamic_array<input_code> newtable(count);
 
-	/* open the record file  */
-	portdata.record_file = auto_alloc(machine, emu_file(machine.options().input_directory(), OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS));
-	file_error filerr = portdata.record_file->open(filename);
-	assert_always(filerr == FILERR_NONE, "Failed to open file for recording");
+		// build up the remap table
+		count = 0;
+		for (xml_data_node *remapnode = xml_get_sibling(parentnode->child, "remap"); remapnode != NULL; remapnode = xml_get_sibling(remapnode->next, "remap"))
+		{
+			input_code origcode = machine().input().code_from_token(xml_get_attribute_string(remapnode, "origcode", ""));
+			input_code newcode = machine().input().code_from_token(xml_get_attribute_string(remapnode, "newcode", ""));
+			if (origcode != INPUT_CODE_INVALID && newcode != INPUT_CODE_INVALID)
+			{
+				oldtable[count] = origcode;
+				newtable[count] = newcode;
+				count++;
+			}
+		}
+
+		// loop over the remapping table, then over default ports, replacing old with new
+		for (int remapnum = 0; remapnum < count; remapnum++)
+			for (input_type_entry *entry = m_typelist.first(); entry != NULL; entry = entry->next())
+				for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+					entry->m_seq[seqtype].replace(oldtable[remapnum], newtable[remapnum]);
+	}
+}
 
-	/* get the base time */
-	machine.base_datetime(systime);
 
-	/* fill in the header */
-	memset(header, 0, sizeof(header));
-	memcpy(header, "MAMEINP\0", 8);
-	header[0x08] = systime.time >> 0;
-	header[0x09] = systime.time >> 8;
-	header[0x0a] = systime.time >> 16;
-	header[0x0b] = systime.time >> 24;
-	header[0x0c] = systime.time >> 32;
-	header[0x0d] = systime.time >> 40;
-	header[0x0e] = systime.time >> 48;
-	header[0x0f] = systime.time >> 56;
-	header[0x10] = INP_HEADER_MAJVERSION;
-	header[0x11] = INP_HEADER_MINVERSION;
-	strcpy((char *)header + 0x14, machine.system().name);
-	sprintf((char *)header + 0x20, "%s %s", emulator_info::get_appname(), build_version);
+//-------------------------------------------------
+//  load_default_config - apply configuration
+//  data to the default mappings
+//-------------------------------------------------
 
-	/* write it */
-	portdata.record_file->write(header, sizeof(header));
+bool ioport_manager::load_default_config(xml_data_node *portnode, int type, int player, const input_seq *newseq)
+{
+	// find a matching port in the list
+	for (input_type_entry *entry = m_typelist.first(); entry != NULL; entry = entry->next())
+		if (entry->type() == type && entry->player() == player)
+		{
+			for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+				if (newseq[seqtype][0] != INPUT_CODE_INVALID)
+					entry->m_seq[seqtype] = newseq[seqtype];
+			return true;
+		}
 
-	/* enable compression */
-	portdata.record_file->compress(FCOMPRESS_MEDIUM);
+	return false;
 }
 
 
-/*-------------------------------------------------
-    record_end - end INP recording
--------------------------------------------------*/
+//-------------------------------------------------
+//  load_game_config - apply configuration
+//  data to the current set of input ports
+//-------------------------------------------------
 
-static void record_end(running_machine &machine, const char *message)
+bool ioport_manager::load_game_config(xml_data_node *portnode, int type, int player, const input_seq *newseq)
 {
-	ioport_manager &portdata = machine.ioport();
-
-	/* only applies if we have a live file */
-	if (portdata.record_file != NULL)
-	{
-		/* close the file */
-		auto_free(machine, portdata.record_file);
-		portdata.record_file = NULL;
+	// read the mask, index, and defvalue attributes
+	const char *tag = xml_get_attribute_string(portnode, "tag", NULL);
+	ioport_value mask = xml_get_attribute_int(portnode, "mask", 0);
+	ioport_value defvalue = xml_get_attribute_int(portnode, "defvalue", 0);
 
-		/* pop a message */
-		if (message != NULL)
-			popmessage("Recording Ended\nReason: %s", message);
-	}
-}
+	// find the port we want; if no tag, search them all
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		if (tag == NULL || strcmp(port->tag(), tag) == 0)
+			for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
 
+				// find the matching mask and defvalue
+				if (field->type() == type && field->player() == player &&
+					field->mask() == mask && (field->defvalue() & mask) == (defvalue & mask))
+				{
+					// if a sequence was specified, copy it in
+					for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+						if (newseq[seqtype][0] != INPUT_CODE_INVALID)
+							field->live().seq[seqtype] = newseq[seqtype];
 
-/*-------------------------------------------------
-    record_frame - start of frame callback for
-    recording
--------------------------------------------------*/
+					// for non-analog fields, fetch the value
+					if (field->live().analog == NULL)
+						field->live().value = xml_get_attribute_int(portnode, "value", field->defvalue());
 
-static void record_frame(running_machine &machine, attotime curtime)
-{
-	ioport_manager &portdata = machine.ioport();
+					// for analog fields, fetch configurable analog attributes
+					else
+					{
+						// get base attributes
+						field->live().analog->m_delta = xml_get_attribute_int(portnode, "keydelta", field->delta());
+						field->live().analog->m_centerdelta = xml_get_attribute_int(portnode, "centerdelta", field->centerdelta());
+						field->live().analog->m_sensitivity = xml_get_attribute_int(portnode, "sensitivity", field->sensitivity());
 
-	/* if recording, record information about the current frame */
-	if (portdata.record_file != NULL)
-	{
-		/* first the absolute time */
-		record_write_uint32(machine, curtime.seconds);
-		record_write_uint64(machine, curtime.attoseconds);
+						// fetch yes/no for reverse setting
+						const char *revstring = xml_get_attribute_string(portnode, "reverse", NULL);
+						if (revstring != NULL)
+							field->live().analog->m_reverse = (strcmp(revstring, "yes") == 0);
+					}
+					return true;
+				}
 
-		/* then the current speed */
-		record_write_uint32(machine, machine.video().speed_percent() * (double)(1 << 20));
-	}
+	return false;
 }
 
 
-/*-------------------------------------------------
-    record_port - per-port callback for record
--------------------------------------------------*/
 
-static void record_port(const input_port_config *port)
-{
-	ioport_manager &portdata = port->machine().ioport();
+//**************************************************************************
+//  SETTINGS SAVE
+//**************************************************************************
 
-	/* if recording, store information about this port */
-	if (portdata.record_file != NULL)
-	{
-		analog_field_state *analog;
+//-------------------------------------------------
+//  save_config - config callback for saving input
+//  port configuration
+//-------------------------------------------------
 
-		/* store the default value and digital state */
-		record_write_uint32(port->machine(), port->state->defvalue);
-		record_write_uint32(port->machine(), port->state->digital);
+void ioport_manager::save_config(int config_type, xml_data_node *parentnode)
+{
+	// if no parentnode, ignore
+	if (parentnode == NULL)
+		return;
 
-		/* loop over analog ports and save their data */
-		for (analog = port->state->analoglist; analog != NULL; analog = analog->next)
-		{
-			/* store current and previous values */
-			record_write_uint32(port->machine(), analog->accum);
-			record_write_uint32(port->machine(), analog->previous);
-
-			/* store configuration information */
-			record_write_uint32(port->machine(), analog->sensitivity);
-			record_write_uint8(port->machine(), analog->reverse);
-		}
-	}
+	// default ports save differently
+	if (config_type == CONFIG_TYPE_DEFAULT)
+		save_default_inputs(parentnode);
+	else
+		save_game_inputs(parentnode);
 }
 
-int input_machine_has_keyboard(running_machine &machine)
+
+//-------------------------------------------------
+//  save_sequence - add a node for an input
+//  sequence
+//-------------------------------------------------
+
+void ioport_manager::save_sequence(xml_data_node *parentnode, input_seq_type type, ioport_type porttype, const input_seq &seq)
 {
-	int have_keyboard = FALSE;
-	const input_field_config *field;
-	const input_port_config *port;
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-	{
-		for (field = port->first_field(); field != NULL; field = field->next())
-		{
-			// if we are at init, check IPT_KEYBOARD for inputx_init
-			if (!port->machine().ioport().safe_to_read && field->type == IPT_KEYBOARD)
-			{
-				have_keyboard = TRUE;
-				break;
-			}
+	// get the string for the sequence
+	astring seqstring;
+	if (seq.length() == 0)
+		seqstring.cpy("NONE");
+	else
+		machine().input().seq_to_tokens(seqstring, seq);
 
-			// else, check if there is a keyboard and if such a keyboard is enabled
-			if (field->type == IPT_KEYBOARD && input_condition_true(field->machine(), &field->condition, field->port().owner()))
-			{
-				have_keyboard = TRUE;
-				break;
-			}
-		}
-	}
-	return have_keyboard;
+	// add the new node
+	xml_data_node *seqnode = xml_add_child(parentnode, "newseq", seqstring);
+	if (seqnode != NULL)
+		xml_set_attribute(seqnode, "type", seqtypestrings[type]);
 }
 
-/***************************************************************************
-    CODE ASSEMBLING
-***************************************************************************/
 
-/*-------------------------------------------------
-    code_point_string - obtain a string representation of a
-    given code; used for logging and debugging
--------------------------------------------------*/
-
-static const char *code_point_string(running_machine &machine, unicode_char ch)
-{
-	static char buf[16];
-	const char *result = buf;
-
-	switch(ch)
-	{
-		/* check some magic values */
-		case '\0':	strcpy(buf, "\\0");		break;
-		case '\r':	strcpy(buf, "\\r");		break;
-		case '\n':	strcpy(buf, "\\n");		break;
-		case '\t':	strcpy(buf, "\\t");		break;
+//-------------------------------------------------
+//  save_this_input_field_type - determine if the
+//  given port type is worth saving
+//-------------------------------------------------
 
-		default:
-			if ((ch >= 32) && (ch < 128))
-			{
-				/* seven bit ASCII is easy */
-				buf[0] = (char) ch;
-				buf[1] = '\0';
-			}
-			else if (ch >= UCHAR_MAMEKEY_BEGIN)
-			{
-				/* try to obtain a codename with code_name(); this can result in an empty string */
-				input_code code(DEVICE_CLASS_KEYBOARD, 0, ITEM_CLASS_SWITCH, ITEM_MODIFIER_NONE, input_item_id(ch - UCHAR_MAMEKEY_BEGIN));
-				astring tempstr;
-				snprintf(buf, ARRAY_LENGTH(buf), "%s", machine.input().code_name(tempstr, code));
-			}
-			else
-			{
-				/* empty string; resolve later */
-				buf[0] = '\0';
-			}
+bool ioport_manager::save_this_input_field_type(ioport_type type)
+{
+	switch (type)
+	{
+		case IPT_UNUSED:
+		case IPT_END:
+		case IPT_PORT:
+		case IPT_UNKNOWN:
+			return false;
 
-			/* did we fail to resolve? if so, we have a last resort */
-			if (buf[0] == '\0')
-				snprintf(buf, ARRAY_LENGTH(buf), "U+%04X", (unsigned) ch);
+		default:
 			break;
 	}
-	return result;
+	return true;
 }
 
 
-/*-------------------------------------------------
-    scan_keys - scans through input ports and
-    sets up natural keyboard input mapping
--------------------------------------------------*/
+//-------------------------------------------------
+//  save_default_inputs - add nodes for any default
+//  mappings that have changed
+//-------------------------------------------------
 
-static int scan_keys(running_machine &machine, const input_port_config *portconfig, inputx_code *codes, const input_port_config * *ports, const input_field_config * *shift_ports, int keys, int shift)
+void ioport_manager::save_default_inputs(xml_data_node *parentnode)
 {
-	int code_count = 0;
-	const input_port_config *port;
-	const input_field_config *field;
-	unicode_char code;
-
-	assert(keys < NUM_SIMUL_KEYS);
-
-	for (port = portconfig; port != NULL; port = port->next())
+	// iterate over ports
+	for (input_type_entry *entry = m_typelist.first(); entry != NULL; entry = entry->next())
 	{
-		for (field = port->first_field(); field != NULL; field = field->next())
+		// only save if this port is a type we save
+		if (save_this_input_field_type(entry->type()))
 		{
-			if (field->type == IPT_KEYBOARD)
+			// see if any of the sequences have changed
+			input_seq_type seqtype;
+			for (seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+				if (entry->seq(seqtype) != entry->defseq(seqtype))
+					break;
+
+			// if so, we need to add a node
+			if (seqtype < SEQ_TYPE_TOTAL)
 			{
-				code = get_keyboard_code(field, shift);
-				if (code != 0)
+				// add a new port node
+				xml_data_node *portnode = xml_add_child(parentnode, "port", NULL);
+				if (portnode != NULL)
 				{
-					/* is this a shifter key? */
-					if ((code >= UCHAR_SHIFT_BEGIN) && (code <= UCHAR_SHIFT_END))
-					{
-						shift_ports[keys] = field;
-						code_count += scan_keys(machine,
-							portconfig,
-							codes ? &codes[code_count] : NULL,
-							ports,
-							shift_ports,
-							keys+1,
-							code - UCHAR_SHIFT_1 + 1);
-					}
-					else
+					// add the port information and attributes
+					astring tempstr;
+					xml_set_attribute(portnode, "type", input_type_to_token(tempstr, entry->type(), entry->player()));
+
+					// add only the sequences that have changed from the defaults
+					for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+						if (entry->seq(seqtype) != entry->defseq(seqtype))
+							save_sequence(portnode, seqtype, entry->type(), entry->seq(seqtype));
+				}
+			}
+		}
+	}
+}
+
+
+//-------------------------------------------------
+//  save_game_inputs - add nodes for any game
+//  mappings that have changed
+//-------------------------------------------------
+
+void ioport_manager::save_game_inputs(xml_data_node *parentnode)
+{
+	// iterate over ports
+	for (ioport_port *port = first_port(); port != NULL; port = port->next())
+		for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
+			if (save_this_input_field_type(field->type()))
+			{
+				// determine if we changed
+				bool changed = false;
+				for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+					changed |= (field->seq(seqtype) != field->defseq(seqtype));
+
+				// non-analog changes
+				if (!field->is_analog())
+					changed |= ((field->live().value & field->mask()) != (field->defvalue() & field->mask()));
+
+				// analog changes
+				else
+				{
+					changed |= (field->live().analog->m_delta != field->delta());
+					changed |= (field->live().analog->m_centerdelta != field->centerdelta());
+					changed |= (field->live().analog->m_sensitivity != field->sensitivity());
+					changed |= (field->live().analog->m_reverse != field->analog_reverse());
+				}
+
+				// if we did change, add a new node
+				if (changed)
+				{
+					// add a new port node
+					xml_data_node *portnode = xml_add_child(parentnode, "port", NULL);
+					if (portnode != NULL)
 					{
-						/* not a shifter key; record normally */
-						if (codes)
+						// add the identifying information and attributes
+						astring tempstr;
+						xml_set_attribute(portnode, "tag", port->tag());
+						xml_set_attribute(portnode, "type", input_type_to_token(tempstr, field->type(), field->player()));
+						xml_set_attribute_int(portnode, "mask", field->mask());
+						xml_set_attribute_int(portnode, "defvalue", field->defvalue() & field->mask());
+
+						// add sequences if changed
+						for (input_seq_type seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
+							if (field->seq(seqtype) != field->defseq(seqtype))
+								save_sequence(portnode, seqtype, field->type(), field->seq(seqtype));
+
+						// write out non-analog changes
+						if (!field->is_analog())
 						{
-							/* if we have a destination, record the codes used here */
-							memcpy((void *) codes[code_count].field, shift_ports, sizeof(shift_ports[0]) * keys);
-							codes[code_count].ch = code;
-							codes[code_count].field[keys] = field;
+							if ((field->live().value & field->mask()) != (field->defvalue() & field->mask()))
+								xml_set_attribute_int(portnode, "value", field->live().value & field->mask());
 						}
 
-						/* increment the count */
-						code_count++;
-
-						if (LOG_INPUTX)
-							logerror("inputx: code=%i (%s) port=%p field->name='%s'\n", (int) code, code_point_string(machine, code), port, field->name);
+						// write out analog changes
+						else
+						{
+							if (field->live().analog->m_delta != field->delta())
+								xml_set_attribute_int(portnode, "keydelta", field->live().analog->m_delta);
+							if (field->live().analog->m_centerdelta != field->centerdelta())
+								xml_set_attribute_int(portnode, "centerdelta", field->live().analog->m_centerdelta);
+							if (field->live().analog->m_sensitivity != field->sensitivity())
+								xml_set_attribute_int(portnode, "sensitivity", field->live().analog->m_sensitivity);
+							if (field->live().analog->m_reverse != field->analog_reverse())
+								xml_set_attribute(portnode, "reverse", field->live().analog->m_reverse ? "yes" : "no");
+						}
 					}
 				}
 			}
-		}
-	}
-	return code_count;
 }
 
 
 
-/*-------------------------------------------------
-    build_codes - given an input port table, create
-    a input code table useful for mapping unicode
-    chars
--------------------------------------------------*/
+//**************************************************************************
+//  INPUT PLAYBACK
+//**************************************************************************
+
+//-------------------------------------------------
+//  playback_read - read a value from the playback
+//  file
+//-------------------------------------------------
+
+template<typename _Type>
+_Type ioport_manager::playback_read(_Type &result)
+{
+	// protect against NULL handles if previous reads fail
+	if (!m_playback_file.is_open())
+		result = 0;
+
+	// read the value; if we fail, end playback
+	else if (m_playback_file.read(&result, sizeof(result)) != sizeof(result))
+	{
+		playback_end("End of file");
+		result = 0;
+	}
+
+	// return the appropriate value
+	else if (sizeof(result) == 8)
+		result = LITTLE_ENDIANIZE_INT64(result);
+	else if (sizeof(result) == 4)
+		result = LITTLE_ENDIANIZE_INT32(result);
+	else if (sizeof(result) == 2)
+		result = LITTLE_ENDIANIZE_INT16(result);
+	return result;
+}
 
-static inputx_code *build_codes(running_machine &machine, const input_port_config *portconfig)
+template<>
+bool ioport_manager::playback_read<bool>(bool &result)
 {
-	inputx_code *codes = NULL;
-	const input_port_config *ports[NUM_SIMUL_KEYS];
-	const input_field_config *fields[NUM_SIMUL_KEYS];
-	int code_count;
-
-	/* first count the number of codes */
-	code_count = scan_keys(machine, portconfig, NULL, ports, fields, 0, 0);
-	if (code_count > 0)
-	{
-		/* allocate the codes */
-		codes = auto_alloc_array_clear(machine, inputx_code, code_count + 1);
-
-		/* and populate them */
-		scan_keys(machine, portconfig, codes, ports, fields, 0, 0);
-	}
-	return codes;
+	UINT8 temp;
+	playback_read(temp);
+	return result = bool(temp);
 }
 
 
+//-------------------------------------------------
+//  playback_init - initialize INP playback
+//-------------------------------------------------
 
-/***************************************************************************
-    VALIDITY CHECKS
-***************************************************************************/
+time_t ioport_manager::playback_init()
+{
+	// if no file, nothing to do
+	const char *filename = machine().options().playback();
+	if (filename[0] == 0)
+		return 0;
 
-/*-------------------------------------------------
-    validate_natural_keyboard_statics -
-    validates natural keyboard static data
--------------------------------------------------*/
+	// open the playback file
+	file_error filerr = m_playback_file.open(filename);
+	assert_always(filerr == FILERR_NONE, "Failed to open file for playback");
 
-int validate_natural_keyboard_statics(void)
-{
-	int i;
-	int error = FALSE;
-	unicode_char last_char = 0;
-	const char_info *ci;
+	// read the header and verify that it is a modern version; if not, print an error
+	UINT8 header[INP_HEADER_SIZE];
+	if (m_playback_file.read(header, sizeof(header)) != sizeof(header))
+		fatalerror("Input file is corrupt or invalid (missing header)");
+	if (memcmp(header, "MAMEINP\0", 8) != 0)
+		fatalerror("Input file invalid or in an older, unsupported format");
+	if (header[0x10] != INP_HEADER_MAJVERSION)
+		fatalerror("Input file format version mismatch");
 
-	/* check to make sure that charinfo is in order */
-	for (i = 0; i < ARRAY_LENGTH(charinfo); i++)
-	{
-		if (last_char >= charinfo[i].ch)
-		{
-			mame_printf_error("inputx: charinfo is out of order; 0x%08x should be higher than 0x%08x\n", charinfo[i].ch, last_char);
-			error = TRUE;
-		}
-		last_char = charinfo[i].ch;
-	}
+	// output info to console
+	mame_printf_info("Input file: %s\n", filename);
+	mame_printf_info("INP version %d.%d\n", header[0x10], header[0x11]);
+	time_t basetime = header[0x08] | (header[0x09] << 8) | (header[0x0a] << 16) | (header[0x0b] << 24) |
+						((UINT64)header[0x0c] << 32) | ((UINT64)header[0x0d] << 40) | ((UINT64)header[0x0e] << 48) | ((UINT64)header[0x0f] << 56);
+	mame_printf_info("Created %s", ctime(&basetime));
+	mame_printf_info("Recorded using %s\n", header + 0x20);
 
-	/* check to make sure that I can look up everything on alternate_charmap */
-	for (i = 0; i < ARRAY_LENGTH(charinfo); i++)
-	{
-		ci = find_charinfo(charinfo[i].ch);
-		if (ci != &charinfo[i])
-		{
-			mame_printf_error("inputx: expected find_charinfo(0x%08x) to work properly\n", charinfo[i].ch);
-			error = TRUE;
-		}
-	}
-	return error;
-}
+	// verify the header against the current game
+	if (memcmp(machine().system().name, header + 0x14, strlen(machine().system().name) + 1) != 0)
+		mame_printf_info("Input file is for %s '%s', not for current %s '%s'\n", emulator_info::get_gamenoun(), header + 0x14, emulator_info::get_gamenoun(), machine().system().name);
 
+	// enable compression
+	m_playback_file.compress(FCOMPRESS_MEDIUM);
+	return basetime;
+}
 
 
-/***************************************************************************
-    CORE IMPLEMENTATION
-***************************************************************************/
+//-------------------------------------------------
+//  playback_end - end INP playback
+//-------------------------------------------------
 
-static void clear_keybuffer(running_machine &machine)
+void ioport_manager::playback_end(const char *message)
 {
-	ioport_manager &portdata = machine.ioport();
-	portdata.keybuffer.buffer = NULL;
-	portdata.queue_chars = NULL;
-	portdata.codes = NULL;
+	// only applies if we have a live file
+	if (m_playback_file.is_open())
+	{
+		// close the file
+		m_playback_file.close();
+
+		// pop a message
+		if (message != NULL)
+			popmessage("Playback Ended\nReason: %s", message);
+
+		// display speed stats
+		m_playback_accumulated_speed /= m_playback_accumulated_frames;
+		mame_printf_info("Total playback frames: %d\n", UINT32(m_playback_accumulated_frames));
+		mame_printf_info("Average recorded speed: %d%%\n", UINT32((m_playback_accumulated_speed * 200 + 1) >> 21));
+	}
 }
 
 
+//-------------------------------------------------
+//  playback_frame - start of frame callback for
+//  playback
+//-------------------------------------------------
 
-static void setup_keybuffer(running_machine &machine)
+void ioport_manager::playback_frame(attotime curtime)
 {
-	ioport_manager &portdata = machine.ioport();
-	portdata.inputx_timer = machine.scheduler().timer_alloc(FUNC(inputx_timerproc));
-	portdata.keybuffer.begin_pos = 0;
-	portdata.keybuffer.end_pos = 0;
-	portdata.keybuffer.status_keydown = 0;
-	portdata.keybuffer.size = KEY_BUFFER_SIZE;
-	portdata.keybuffer.buffer = auto_alloc_array(machine, unicode_char, portdata.keybuffer.size);
-	machine.add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(clear_keybuffer), &machine));
+	// if playing back, fetch the information and verify
+	if (m_playback_file.is_open())
+	{
+		// first the absolute time
+		attotime readtime;
+		playback_read(readtime.seconds);
+		playback_read(readtime.attoseconds);
+		if (readtime != curtime)
+			playback_end("Out of sync");
+
+		// then the speed
+		UINT32 curspeed;
+		m_playback_accumulated_speed += playback_read(curspeed);
+		m_playback_accumulated_frames++;
+	}
 }
 
 
+//-------------------------------------------------
+//  playback_port - per-port callback for playback
+//-------------------------------------------------
 
-void inputx_init(running_machine &machine)
+void ioport_manager::playback_port(ioport_port &port)
 {
-	ioport_manager &portdata = machine.ioport();
-	portdata.inputx_timer = NULL;
-	portdata.accept_char = NULL;
-	portdata.charqueue_empty = NULL;
-	clear_keybuffer(machine);
-
-	if (machine.debug_flags & DEBUG_FLAG_ENABLED)
+	// if playing back, fetch information about this port
+	if (m_playback_file.is_open())
 	{
-		debug_console_register_command(machine, "input", CMDFLAG_NONE, 0, 1, 1, execute_input);
-		debug_console_register_command(machine, "dumpkbd", CMDFLAG_NONE, 0, 0, 1, execute_dumpkbd);
-	}
+		// read the default value and the digital state
+		playback_read(port.live().defvalue);
+		playback_read(port.live().digital);
 
-	/* posting keys directly only makes sense for a computer */
-	if (input_machine_has_keyboard(machine))
-	{
-		portdata.codes = build_codes(machine, machine.ioport().first_port());
-		setup_keybuffer(machine);
+		// loop over analog ports and save their data
+		for (analog_field *analog = port.live().analoglist.first(); analog != NULL; analog = analog->next())
+		{
+			// read current and previous values
+			playback_read(analog->m_accum);
+			playback_read(analog->m_previous);
+
+			// read configuration information
+			playback_read(analog->m_sensitivity);
+			playback_read(analog->m_reverse);
+		}
 	}
 }
 
 
+//-------------------------------------------------
+//  record_write - write a value to the record file
+//-------------------------------------------------
 
-void inputx_setup_natural_keyboard(
-	running_machine &machine,
-	int (*queue_chars)(running_machine &machine, const unicode_char *text, size_t text_len),
-	int (*accept_char)(running_machine &machine, unicode_char ch),
-	int (*charqueue_empty)(running_machine &machine))
+template<typename _Type>
+void ioport_manager::record_write(_Type value)
 {
-	ioport_manager &portdata = machine.ioport();
-	portdata.queue_chars = queue_chars;
-	portdata.accept_char = accept_char;
-	portdata.charqueue_empty = charqueue_empty;
+	// protect against NULL handles if previous reads fail
+	if (!m_record_file.is_open())
+		return;
+
+	// read the value; if we fail, end playback
+	if (m_record_file.write(&value, sizeof(value)) != sizeof(value))
+		record_end("Out of space");
 }
 
-int inputx_can_post(running_machine &machine)
+template<>
+void ioport_manager::record_write<bool>(bool value)
 {
-	ioport_manager &portdata = machine.ioport();
-	return portdata.queue_chars || portdata.codes;
+	UINT8 byte = UINT8(value);
+	record_write(byte);
 }
 
 
-static int can_post_key_directly(running_machine &machine, unicode_char ch)
+//-------------------------------------------------
+//  record_init - initialize INP recording
+//-------------------------------------------------
+
+void ioport_manager::record_init()
 {
-	ioport_manager &portdata = machine.ioport();
-	int rc = FALSE;
-	const inputx_code *code;
+	// if no file, nothing to do
+	const char *filename = machine().options().record();
+	if (filename[0] == 0)
+		return;
 
-	if (portdata.queue_chars)
-	{
-		rc = portdata.accept_char ? (*portdata.accept_char)(machine, ch) : TRUE;
-	}
-	else
-	{
-		code = find_code(portdata.codes, ch);
-		if (code)
-			rc = code->field[0] != NULL;
-	}
-	return rc;
-}
+	// open the record file
+	file_error filerr = m_record_file.open(filename);
+	assert_always(filerr == FILERR_NONE, "Failed to open file for recording");
+
+	// get the base time
+	system_time systime;
+	machine().base_datetime(systime);
+
+	// fill in the header
+	UINT8 header[INP_HEADER_SIZE] = { 0 };
+	memcpy(header, "MAMEINP\0", 8);
+	header[0x08] = systime.time >> 0;
+	header[0x09] = systime.time >> 8;
+	header[0x0a] = systime.time >> 16;
+	header[0x0b] = systime.time >> 24;
+	header[0x0c] = systime.time >> 32;
+	header[0x0d] = systime.time >> 40;
+	header[0x0e] = systime.time >> 48;
+	header[0x0f] = systime.time >> 56;
+	header[0x10] = INP_HEADER_MAJVERSION;
+	header[0x11] = INP_HEADER_MINVERSION;
+	strcpy((char *)header + 0x14, machine().system().name);
+	sprintf((char *)header + 0x20, "%s %s", emulator_info::get_appname(), build_version);
 
+	// write it
+	m_record_file.write(header, sizeof(header));
 
+	// enable compression
+	m_record_file.compress(FCOMPRESS_MEDIUM);
+}
 
-static int can_post_key_alternate(running_machine &machine, unicode_char ch)
-{
-	const char *s;
-	const char_info *ci;
-	unicode_char uchar;
-	int rc;
 
-	ci = find_charinfo(ch);
-	s = ci ? ci->alternate : NULL;
-	if (!s)
-		return 0;
+//-------------------------------------------------
+//  record_end - end INP recording
+//-------------------------------------------------
 
-	while(*s)
+void ioport_manager::record_end(const char *message)
+{
+	// only applies if we have a live file
+	if (m_record_file.is_open())
 	{
-		rc = uchar_from_utf8(&uchar, s, strlen(s));
-		if (rc <= 0)
-			return 0;
-		if (!can_post_key_directly(machine, uchar))
-			return 0;
-		s += rc;
+		// close the file
+		m_record_file.close();
+
+		// pop a message
+		if (message != NULL)
+			popmessage("Recording Ended\nReason: %s", message);
 	}
-	return 1;
 }
 
-static attotime choose_delay(ioport_manager &portdata, unicode_char ch)
-{
-	if (portdata.current_rate != attotime::zero)
-		return portdata.current_rate;
 
-	attotime delay = attotime::zero;
-	if (portdata.queue_chars)
-	{
-		/* systems with queue_chars can afford a much smaller delay */
-		delay = attotime::from_msec(10);
-	}
-	else
+//-------------------------------------------------
+//  record_frame - start of frame callback for
+//  recording
+//-------------------------------------------------
+
+void ioport_manager::record_frame(attotime curtime)
+{
+	// if recording, record information about the current frame
+	if (m_record_file.is_open())
 	{
-		switch(ch) {
-		case '\r':
-			delay = attotime::from_msec(200);
-			break;
+		// first the absolute time
+		record_write(curtime.seconds);
+		record_write(curtime.attoseconds);
 
-		default:
-			delay = attotime::from_msec(50);
-			break;
-		}
+		// then the current speed
+		record_write(UINT32(machine().video().speed_percent() * double(1 << 20)));
 	}
-	return delay;
 }
 
 
+//-------------------------------------------------
+//  record_port - per-port callback for record
+//-------------------------------------------------
 
-static void internal_post_key(running_machine &machine, unicode_char ch)
+void ioport_manager::record_port(ioport_port &port)
 {
-	ioport_manager &portdata = machine.ioport();
-	key_buffer *keybuf;
-
-	keybuf = get_buffer(machine);
-
-	/* need to start up the timer? */
-	if (keybuf->begin_pos == keybuf->end_pos)
+	// if recording, store information about this port
+	if (m_record_file.is_open())
 	{
-		portdata.inputx_timer->adjust(choose_delay(portdata, ch));
-		keybuf->status_keydown = 0;
-	}
+		// store the default value and digital state
+		record_write(port.live().defvalue);
+		record_write(port.live().digital);
 
-	keybuf->buffer[keybuf->end_pos++] = ch;
-	if ((keybuf->end_pos+1) % keybuf->size == keybuf->begin_pos)
-	{
-		// Buffer full
-		unicode_char *old_buffer = keybuf->buffer;
-		keybuf->size = keybuf->size + KEY_BUFFER_SIZE;
-		keybuf->buffer = auto_alloc_array(machine, unicode_char, keybuf->size);
-		for( int i = keybuf->begin_pos; i <= keybuf->end_pos; i++ )
+		// loop over analog ports and save their data
+		for (analog_field *analog = port.live().analoglist.first(); analog != NULL; analog = analog->next())
 		{
-			keybuf->buffer[i] = old_buffer[i];
+			// store current and previous values
+			record_write(analog->m_accum);
+			record_write(analog->m_previous);
+
+			// store configuration information
+			record_write(analog->m_sensitivity);
+			record_write(analog->m_reverse);
 		}
-		auto_free(machine, old_buffer);
 	}
-	keybuf->end_pos %= keybuf->size;
 }
 
 
 
-static int buffer_full(running_machine &machine)
+//**************************************************************************
+//  I/O PORT CONFIGURER
+//**************************************************************************
+
+//-------------------------------------------------
+//  ioport_configurer - constructor
+//-------------------------------------------------
+
+ioport_configurer::ioport_configurer(device_t &owner, ioport_list &portlist, astring &errorbuf)
+	: m_owner(owner),
+	  m_portlist(portlist),
+	  m_errorbuf(errorbuf),
+	  m_curport(NULL),
+	  m_curfield(NULL),
+	  m_cursetting(NULL)
 {
-	key_buffer *keybuf;
-	keybuf = get_buffer(machine);
-	return ((keybuf->end_pos + 1) % keybuf->size) == keybuf->begin_pos;
 }
 
 
+//-------------------------------------------------
+//  string_from_token - convert an
+//  ioport_token to a default string
+//-------------------------------------------------
 
-static void inputx_postn_rate(running_machine &machine, const unicode_char *text, size_t text_len, attotime rate)
+const char *ioport_configurer::string_from_token(const char *string)
 {
-	ioport_manager &portdata = machine.ioport();
-	int last_cr = 0;
-	unicode_char ch;
-	const char *s;
-	const char_info *ci;
-	const inputx_code *code;
+	// 0 is an invalid index
+	if (string == NULL)
+		return NULL;
+
+	// if the index is greater than the count, assume it to be a pointer
+	if (FPTR(string) >= INPUT_STRING_COUNT)
+		return string;
 
-	portdata.current_rate = rate;
+#if FALSE // Set TRUE, If you want to take care missing-token or wrong-sorting
 
-	if (inputx_can_post(machine))
+	// otherwise, scan the list for a matching string and return it
 	{
-		while((text_len > 0) && !buffer_full(machine))
-		{
-			ch = *(text++);
-			text_len--;
+	int index;
+	for (index = 0; index < ARRAY_LENGTH(input_port_default_strings); index++)
+		if (input_port_default_strings[index].id == FPTR(string))
+			return input_port_default_strings[index].string;
+	}
+	return "(Unknown Default)";
 
-			/* change all eolns to '\r' */
-			if ((ch != '\n') || !last_cr)
-			{
-				if (ch == '\n')
-					ch = '\r';
-				else
-					last_cr = (ch == '\r');
+#else
 
-				if (LOG_INPUTX)
-				{
-					code = find_code(portdata.codes, ch);
-					logerror("inputx_postn(): code=%i (%s) field->name='%s'\n", (int) ch, code_point_string(machine, ch), (code && code->field[0]) ? code->field[0]->name : "<null>");
-				}
+	return input_port_default_strings[FPTR(string)-1].string;
 
-				if (can_post_key_directly(machine, ch))
-				{
-					/* we can post this key in the queue directly */
-					internal_post_key(machine, ch);
-				}
-				else if (can_post_key_alternate(machine, ch))
-				{
-					/* we can post this key with an alternate representation */
-					ci = find_charinfo(ch);
-					assert(ci && ci->alternate);
-					s = ci->alternate;
-					while(*s)
-					{
-						s += uchar_from_utf8(&ch, s, strlen(s));
-						internal_post_key(machine, ch);
-					}
-				}
-			}
-			else
-			{
-				last_cr = 0;
-			}
-		}
-	}
+#endif
 }
 
 
+//-------------------------------------------------
+//  port_alloc - allocate a new port
+//-------------------------------------------------
 
-static TIMER_CALLBACK(inputx_timerproc)
+void ioport_configurer::port_alloc(const char *tag)
 {
-	ioport_manager &portdata = machine.ioport();
-	key_buffer *keybuf;
-	attotime delay;
-
-	keybuf = get_buffer(machine);
+	// create the full tag
+	astring fulltag;
+	m_owner.subtag(fulltag, tag);
 
-	if (portdata.queue_chars)
-	{
-		/* the driver has a queue_chars handler */
-		while((keybuf->begin_pos != keybuf->end_pos) && (*portdata.queue_chars)(machine, &keybuf->buffer[keybuf->begin_pos], 1))
-		{
-			keybuf->begin_pos++;
-			keybuf->begin_pos %= keybuf->size;
+	// add it to the list, and reset current field/setting
+	m_curport = &m_portlist.append(fulltag, *global_alloc(ioport_port(m_owner, fulltag)));
+	m_curfield = NULL;
+	m_cursetting = NULL;
+}
 
-			if (portdata.current_rate != attotime::zero)
-				break;
-		}
-	}
-	else
-	{
-		/* the driver does not have a queue_chars handler */
-		if (keybuf->status_keydown)
-		{
-			keybuf->status_keydown = FALSE;
-			keybuf->begin_pos++;
-			keybuf->begin_pos %= keybuf->size;
-		}
-		else
-		{
-			keybuf->status_keydown = TRUE;
-		}
-	}
 
-	/* need to make sure timerproc is called again if buffer not empty */
-	if (keybuf->begin_pos != keybuf->end_pos)
-	{
-		delay = choose_delay(portdata, keybuf->buffer[keybuf->begin_pos]);
-		portdata.inputx_timer->adjust(delay);
-	}
-}
+//-------------------------------------------------
+//  port_modify - find an existing port and
+//  modify it
+//-------------------------------------------------
 
-int inputx_is_posting(running_machine &machine)
+void ioport_configurer::port_modify(const char *tag)
 {
-	ioport_manager &portdata = machine.ioport();
-	const key_buffer *keybuf;
-	keybuf = get_buffer(machine);
-	return (keybuf->begin_pos != keybuf->end_pos) || (portdata.charqueue_empty && !(*portdata.charqueue_empty)(machine));
-}
+	// create the full tag
+	astring fulltag;
+	m_owner.subtag(fulltag, tag);
 
-/***************************************************************************
+	// find the existing port
+	m_curport = m_portlist.find(fulltag.cstr());
+	if (m_curport == NULL)
+		throw emu_fatalerror("Requested to modify nonexistent port '%s'", fulltag.cstr());
+
+	// bump the modification count, and reset current field/setting
+	m_curport->m_modcount++;
+	m_curfield = NULL;
+	m_cursetting = NULL;
+}
 
-    Coded input
 
-***************************************************************************/
-static void inputx_postc_rate(running_machine &machine, unicode_char ch, attotime rate);
+//-------------------------------------------------
+//  field_alloc - allocate a new field
+//-------------------------------------------------
 
-static void inputx_postn_coded_rate(running_machine &machine, const char *text, size_t text_len, attotime rate)
+void ioport_configurer::field_alloc(ioport_type type, ioport_value defval, ioport_value mask, const char *name)
 {
-	size_t i, j, key_len, increment;
-	unicode_char ch;
+	// make sure we have a port
+	if (m_curport == NULL)
+		throw emu_fatalerror("alloc_field called with no active port (mask=%X defval=%X)\n", mask, defval); \
 
-	static const struct
-	{
-		const char *key;
-		unicode_char code;
-	} codes[] =
-	{
-		{ "BACKSPACE",	8 },
-		{ "BS",			8 },
-		{ "BKSP",		8 },
-		{ "DEL",		UCHAR_MAMEKEY(DEL) },
-		{ "DELETE",		UCHAR_MAMEKEY(DEL) },
-		{ "END",		UCHAR_MAMEKEY(END) },
-		{ "ENTER",		13 },
-		{ "ESC",		'\033' },
-		{ "HOME",		UCHAR_MAMEKEY(HOME) },
-		{ "INS",		UCHAR_MAMEKEY(INSERT) },
-		{ "INSERT",		UCHAR_MAMEKEY(INSERT) },
-		{ "PGDN",		UCHAR_MAMEKEY(PGDN) },
-		{ "PGUP",		UCHAR_MAMEKEY(PGUP) },
-		{ "SPACE",		32 },
-		{ "TAB",		9 },
-		{ "F1",			UCHAR_MAMEKEY(F1) },
-		{ "F2",			UCHAR_MAMEKEY(F2) },
-		{ "F3",			UCHAR_MAMEKEY(F3) },
-		{ "F4",			UCHAR_MAMEKEY(F4) },
-		{ "F5",			UCHAR_MAMEKEY(F5) },
-		{ "F6",			UCHAR_MAMEKEY(F6) },
-		{ "F7",			UCHAR_MAMEKEY(F7) },
-		{ "F8",			UCHAR_MAMEKEY(F8) },
-		{ "F9",			UCHAR_MAMEKEY(F9) },
-		{ "F10",		UCHAR_MAMEKEY(F10) },
-		{ "F11",		UCHAR_MAMEKEY(F11) },
-		{ "F12",		UCHAR_MAMEKEY(F12) },
-		{ "QUOTE",		'\"' }
-	};
+	// append the field
+	if (type != IPT_UNKNOWN && type != IPT_UNUSED)
+		m_curport->m_active |= mask;
+	m_curfield = &m_curport->m_fieldlist.append(*global_alloc(ioport_field(*m_curport, type, defval, mask, string_from_token(name))));
 
-	i = 0;
-	while(i < text_len)
-	{
-		ch = text[i];
-		increment = 1;
+	// reset the current setting
+	m_cursetting = NULL;
+}
 
-		if (ch == '{')
+
+//-------------------------------------------------
+//  field_add_char - add a character to a field
+//-------------------------------------------------
+
+void ioport_configurer::field_add_char(unicode_char ch)
+{
+	for (int index = 0; index < ARRAY_LENGTH(m_curfield->m_chars); index++)
+		if (m_curfield->m_chars[index] == 0)
 		{
-			for (j = 0; j < ARRAY_LENGTH(codes); j++)
-			{
-				key_len = strlen(codes[j].key);
-				if (i + key_len + 2 <= text_len)
-				{
-					if (!core_strnicmp(codes[j].key, &text[i + 1], key_len) && (text[i + key_len + 1] == '}'))
-					{
-						ch = codes[j].code;
-						increment = key_len + 2;
-					}
-				}
-			}
+			m_curfield->m_chars[index] = ch;
+			break;
 		}
-
-		if (ch)
-			inputx_postc_rate(machine, ch, rate);
-		i += increment;
-	}
 }
 
 
+//-------------------------------------------------
+//  field_add_code - add a character to a field
+//-------------------------------------------------
 
-/***************************************************************************
+void ioport_configurer::field_add_code(input_seq_type which, input_code code)
+{
+	m_curfield->m_seq[which] |= code;
+}
 
-    Alternative calls
 
-***************************************************************************/
+//-------------------------------------------------
+//  setting_alloc - allocate a new setting
+//-------------------------------------------------
 
-static void inputx_postc_rate(running_machine &machine, unicode_char ch, attotime rate)
+void ioport_configurer::setting_alloc(ioport_value value, const char *name)
 {
-	inputx_postn_rate(machine, &ch, 1, rate);
+	// make sure we have a field
+	if (m_curfield == NULL)
+		throw emu_fatalerror("alloc_setting called with no active field (value=%X name=%s)\n", value, name);
+
+	// append a new setting
+	m_curfield->m_settinglist.append(*global_alloc(ioport_setting(*m_curfield, value & m_curfield->mask(), string_from_token(name))));
 }
 
-void inputx_postc(running_machine &machine, unicode_char ch)
+
+//-------------------------------------------------
+//  set_condition - set the condition for either
+//  the current setting or field
+//-------------------------------------------------
+
+void ioport_configurer::set_condition(ioport_condition::condition_t condition, const char *tag, ioport_value mask, ioport_value value)
 {
-	inputx_postc_rate(machine, ch, attotime::zero);
+	ioport_condition &target = (m_cursetting != NULL) ? m_cursetting->condition() : m_curfield->condition();
+	target.set(condition, tag, mask, value);
 }
 
-static void inputx_postn_utf8_rate(running_machine &machine, const char *text, size_t text_len, attotime rate)
+
+//-------------------------------------------------
+//  onoff_alloc - allocate an on/off DIP switch
+//-------------------------------------------------
+
+void ioport_configurer::onoff_alloc(const char *name, ioport_value defval, ioport_value mask, const char *diplocation)
 {
-	size_t len = 0;
-	unicode_char buf[256];
-	unicode_char c;
-	int rc;
+	// allocate a field normally
+	field_alloc(IPT_DIPSWITCH, defval, mask, name);
 
-	while(text_len > 0)
+	// special case service mode
+	if (name == DEF_STR(Service_Mode))
 	{
-		if (len == ARRAY_LENGTH(buf))
-		{
-			inputx_postn_rate(machine, buf, len, attotime::zero);
-			len = 0;
-		}
-
-		rc = uchar_from_utf8(&c, text, text_len);
-		if (rc < 0)
-		{
-			rc = 1;
-			c = INVALID_CHAR;
-		}
-		text += rc;
-		text_len -= rc;
-		buf[len++] = c;
+		field_set_toggle();
+		m_curfield->m_seq[SEQ_TYPE_STANDARD].set(KEYCODE_F2);
 	}
-	inputx_postn_rate(machine, buf, len, rate);
+
+	// expand the diplocation
+	if (diplocation != NULL)
+		field_set_diplocation(diplocation);
+
+	// allocate settings
+	setting_alloc(defval & mask, DEF_STR(Off));
+	setting_alloc(~defval & mask, DEF_STR(On));
 }
 
-void inputx_post_utf8(running_machine &machine, const char *text)
+
+
+/***************************************************************************
+    MISCELLANEOUS
+***************************************************************************/
+
+//-------------------------------------------------
+//  find - look up information about a particular
+//  character
+//-------------------------------------------------
+
+const char_info *char_info::find(unicode_char target)
 {
-	inputx_postn_utf8_rate(machine, text, strlen(text), attotime::zero);
+	// perform a simple binary search to find the proper alternate
+	int low = 0;
+	int high = ARRAY_LENGTH(charinfo);
+	while (high > low)
+	{
+		int middle = (high + low) / 2;
+		unicode_char ch = charinfo[middle].ch;
+		if (ch < target)
+			low = middle + 1;
+		else if (ch > target)
+			high = middle;
+		else
+			return &charinfo[middle];
+	}
+	return NULL;
 }
 
-void inputx_post_utf8_rate(running_machine &machine, const char *text, attotime rate)
+
+//-------------------------------------------------
+//  dynamic_field - constructor
+//-------------------------------------------------
+
+dynamic_field::dynamic_field(ioport_field &field)
+	: m_next(NULL),
+	  m_field(field),
+	  m_shift(0),
+	  m_oldval(field.defvalue())
 {
-	inputx_postn_utf8_rate(machine, text, strlen(text), rate);
+	// fill in the data
+	for (ioport_value mask = field.mask(); !(mask & 1); mask >>= 1)
+		m_shift++;
+	m_oldval >>= m_shift;
 }
 
-/***************************************************************************
 
-    Other stuff
+//-------------------------------------------------
+//  read - read the updated value and merge it
+//  into the target
+//-------------------------------------------------
 
-    This stuff is here more out of convienience than anything else
-***************************************************************************/
+void dynamic_field::read(ioport_value &result)
+{
+	// skip if not enabled
+	if (!m_field.enabled())
+		return;
 
-int input_classify_port(const input_field_config *field)
+	// call the callback to read a new value
+	ioport_value newval = m_field.m_read(m_field, m_field.m_read_param);
+	m_oldval = newval;
+
+	// merge in the bits (don't invert yet, as all digitals are inverted together)
+	result = (result & ~m_field.mask()) | ((newval << m_shift) & m_field.mask());
+}
+
+
+//-------------------------------------------------
+//  write - track a change to a value and call
+//  the write callback if there's something new
+//-------------------------------------------------
+
+void dynamic_field::write(ioport_value newval)
 {
-	int result;
+	// skip if not enabled
+	if (!m_field.enabled())
+		return;
 
-	switch(field->type)
+	// if the bits have changed, call the handler
+	newval = ((newval ^ m_field.defvalue()) & m_field.mask()) >> m_shift;
+	if (m_oldval != newval)
 	{
-		case IPT_JOYSTICK_UP:
-		case IPT_JOYSTICK_DOWN:
-		case IPT_JOYSTICK_LEFT:
-		case IPT_JOYSTICK_RIGHT:
-		case IPT_JOYSTICKLEFT_UP:
-		case IPT_JOYSTICKLEFT_DOWN:
-		case IPT_JOYSTICKLEFT_LEFT:
-		case IPT_JOYSTICKLEFT_RIGHT:
-		case IPT_JOYSTICKRIGHT_UP:
-		case IPT_JOYSTICKRIGHT_DOWN:
-		case IPT_JOYSTICKRIGHT_LEFT:
-		case IPT_JOYSTICKRIGHT_RIGHT:
-		case IPT_BUTTON1:
-		case IPT_BUTTON2:
-		case IPT_BUTTON3:
-		case IPT_BUTTON4:
-		case IPT_BUTTON5:
-		case IPT_BUTTON6:
-		case IPT_BUTTON7:
-		case IPT_BUTTON8:
-		case IPT_BUTTON9:
-		case IPT_BUTTON10:
+		m_field.m_write(m_field, m_field.m_write_param, m_oldval, newval);
+		m_oldval = newval;
+	}
+}
+
+
+//-------------------------------------------------
+//  analog_field - constructor
+//-------------------------------------------------
+
+analog_field::analog_field(ioport_field &field)
+	: m_next(NULL),
+	  m_field(field),
+	  m_shift(0),
+	  m_adjdefvalue(field.defvalue() & field.mask()),
+	  m_adjmin(field.minval() & field.mask()),
+	  m_adjmax(field.maxval() & field.mask()),
+	  m_sensitivity(field.sensitivity()),
+	  m_reverse(field.analog_reverse()),
+	  m_delta(field.delta()),
+	  m_centerdelta(field.centerdelta()),
+	  m_accum(0),
+	  m_previous(0),
+	  m_previousanalog(0),
+	  m_minimum(INPUT_ABSOLUTE_MIN),
+	  m_maximum(INPUT_ABSOLUTE_MAX),
+	  m_center(0),
+	  m_reverse_val(0),
+	  m_scalepos(0),
+	  m_scaleneg(0),
+	  m_keyscalepos(0),
+	  m_keyscaleneg(0),
+	  m_positionalscale(0),
+	  m_absolute(false),
+	  m_wraps(false),
+	  m_autocenter(false),
+	  m_single_scale(false),
+	  m_interpolate(false),
+	  m_lastdigital(false)
+{
+	// compute the shift amount and number of bits
+	for (ioport_value mask = field.mask(); !(mask & 1); mask >>= 1)
+		m_shift++;
+
+	// initialize core data
+	m_adjdefvalue >>= m_shift;
+	m_adjmin >>= m_shift;
+	m_adjmax >>= m_shift;
+
+	// set basic parameters based on the configured type
+	switch (field.type())
+	{
+		// paddles and analog joysticks are absolute and autocenter
 		case IPT_AD_STICK_X:
 		case IPT_AD_STICK_Y:
 		case IPT_AD_STICK_Z:
-		case IPT_TRACKBALL_X:
-		case IPT_TRACKBALL_Y:
-		case IPT_LIGHTGUN_X:
-		case IPT_LIGHTGUN_Y:
-		case IPT_MOUSE_X:
-		case IPT_MOUSE_Y:
-		case IPT_START:
-		case IPT_SELECT:
-			result = INPUT_CLASS_CONTROLLER;
+		case IPT_PADDLE:
+		case IPT_PADDLE_V:
+			m_absolute = true;
+			m_autocenter = true;
+			m_interpolate = !field.analog_reset();
 			break;
 
-		case IPT_KEYPAD:
-		case IPT_KEYBOARD:
-			result = INPUT_CLASS_KEYBOARD;
+		// pedals start at and autocenter to the min range
+		case IPT_PEDAL:
+		case IPT_PEDAL2:
+		case IPT_PEDAL3:
+			m_center = INPUT_ABSOLUTE_MIN;
+			m_accum = apply_inverse_sensitivity(m_center);
+			m_absolute = true;
+			m_autocenter = true;
+			m_interpolate = !field.analog_reset();
 			break;
 
-		case IPT_CONFIG:
-			result = INPUT_CLASS_CONFIG;
+		// lightguns are absolute as well, but don't autocenter and don't interpolate their values
+		case IPT_LIGHTGUN_X:
+		case IPT_LIGHTGUN_Y:
+			m_absolute = true;
+			m_autocenter = false;
+			m_interpolate = false;
 			break;
 
-		case IPT_DIPSWITCH:
-			result = INPUT_CLASS_DIPSWITCH;
+		// positional devices are absolute, but can also wrap like relative devices
+		// set each position to be 512 units
+		case IPT_POSITIONAL:
+		case IPT_POSITIONAL_V:
+			m_positionalscale = compute_scale(field.maxval(), INPUT_ABSOLUTE_MAX - INPUT_ABSOLUTE_MIN);
+			m_adjmin = 0;
+			m_adjmax = field.maxval() - 1;
+			m_wraps = field.analog_wraps();
+			m_autocenter = !m_wraps;
 			break;
 
-		case 0:
-			if (field->name && (field->name != (const char *) -1))
-				result = INPUT_CLASS_MISC;
-			else
-				result = INPUT_CLASS_INTERNAL;
+		// dials, mice and trackballs are relative devices
+		// these have fixed "min" and "max" values based on how many bits are in the port
+		// in addition, we set the wrap around min/max values to 512 * the min/max values
+		// this takes into account the mapping that one mouse unit ~= 512 analog units
+		case IPT_DIAL:
+		case IPT_DIAL_V:
+		case IPT_TRACKBALL_X:
+		case IPT_TRACKBALL_Y:
+		case IPT_MOUSE_X:
+		case IPT_MOUSE_Y:
+			m_absolute = false;
+			m_wraps = true;
+			m_interpolate = !field.analog_reset();
 			break;
 
 		default:
-			result = INPUT_CLASS_INTERNAL;
+			fatalerror("Unknown analog port type -- don't know if it is absolute or not");
 			break;
 	}
-	return result;
-}
 
+	// further processing for absolute controls
+	if (m_absolute)
+	{
+		// if the default value is pegged at the min or max, use a single scale value for the whole axis
+		m_single_scale = (m_adjdefvalue == m_adjmin) || (m_adjdefvalue == m_adjmax);
 
+		// if not "single scale", compute separate scales for each side of the default
+		if (!m_single_scale)
+		{
+			// unsigned
+			m_scalepos = compute_scale(m_adjmax - m_adjdefvalue, INPUT_ABSOLUTE_MAX - 0);
+			m_scaleneg = compute_scale(m_adjdefvalue - m_adjmin, 0 - INPUT_ABSOLUTE_MIN);
 
-int input_player_number(const input_field_config *port)
-{
-	return port->player;
-}
+			if (m_adjmin > m_adjmax)
+				m_scaleneg = -m_scaleneg;
 
+			// reverse point is at center
+			m_reverse_val = 0;
+		}
+		else
+		{
+			// single axis that increases from default
+			m_scalepos = compute_scale(m_adjmax - m_adjmin, INPUT_ABSOLUTE_MAX - INPUT_ABSOLUTE_MIN);
 
+			// move from default
+			if (m_adjdefvalue == m_adjmax)
+				m_scalepos = -m_scalepos;
 
-/*-------------------------------------------------
-    input_has_input_class - checks to see if a
-    particular input class is present
--------------------------------------------------*/
+			// make the scaling the same for easier coding when we need to scale
+			m_scaleneg = m_scalepos;
 
-int input_has_input_class(running_machine &machine, int inputclass)
-{
-	const input_port_config *port;
-	const input_field_config *field;
+			// reverse point is at max
+			m_reverse_val = m_maximum;
+		}
+	}
 
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
+	// relative and positional controls all map directly with a 512x scale factor
+	else
 	{
-		for (field = port->first_field(); field != NULL; field = field->next())
+		// The relative code is set up to allow specifing PORT_MINMAX and default values.
+		// The validity checks are purposely set up to not allow you to use anything other
+		// a default of 0 and PORT_MINMAX(0,mask).  This is in case the need arises to use
+		// this feature in the future.  Keeping the code in does not hurt anything.
+		if (m_adjmin > m_adjmax)
+			// adjust for signed
+			m_adjmin = -m_adjmin;
+
+		if (m_wraps)
+			m_adjmax++;
+
+		m_minimum = (m_adjmin - m_adjdefvalue) * INPUT_RELATIVE_PER_PIXEL;
+		m_maximum = (m_adjmax - m_adjdefvalue) * INPUT_RELATIVE_PER_PIXEL;
+
+		// make the scaling the same for easier coding when we need to scale
+		m_scaleneg = m_scalepos = compute_scale(1, INPUT_RELATIVE_PER_PIXEL);
+
+		if (m_field.analog_reset())
+			// delta values reverse from center
+			m_reverse_val = 0;
+		else
 		{
-			if (input_classify_port(field) == inputclass)
-				return TRUE;
+			// positional controls reverse from their max range
+			m_reverse_val = m_maximum + m_minimum;
+
+			// relative controls reverse from 1 past their max range
+			if (m_wraps)
+				m_reverse_val -= INPUT_RELATIVE_PER_PIXEL;
 		}
 	}
-	return FALSE;
-}
 
+	// compute scale for keypresses
+	m_keyscalepos = recip_scale(m_scalepos);
+	m_keyscaleneg = recip_scale(m_scaleneg);
+}
 
 
-/*-------------------------------------------------
-    input_count_players - counts the number of
-    active players
--------------------------------------------------*/
+//-------------------------------------------------
+//  apply_min_max - clamp the given input value to
+//  the appropriate min/max for the analog control
+//-------------------------------------------------
 
-int input_count_players(running_machine &machine)
+inline INT32 analog_field::apply_min_max(INT32 value) const
 {
-	const input_port_config *port;
-	const input_field_config *field;
-	int joystick_count;
+	// take the analog minimum and maximum values and apply the inverse of the
+	// sensitivity so that we can clamp against them before applying sensitivity
+	INT32 adjmin = apply_inverse_sensitivity(m_minimum);
+	INT32 adjmax = apply_inverse_sensitivity(m_maximum);
 
-	joystick_count = 0;
-	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
+	// for absolute devices, clamp to the bounds absolutely
+	if (!m_wraps)
 	{
-		for (field = port->first_field(); field != NULL; field = field->next())
-		{
-			if (input_classify_port(field) == INPUT_CLASS_CONTROLLER)
-			{
-				if (joystick_count <= field->player + 1)
-					joystick_count = field->player + 1;
-			}
-		}
+		if (value > adjmax)
+			value = adjmax;
+		else if (value < adjmin)
+			value = adjmin;
+	}
+
+	// for relative devices, wrap around when we go past the edge
+	else
+	{
+		INT32 range = adjmax - adjmin;
+		// rolls to other end when 1 position past end.
+		value = (value - adjmin) % range;
+		if (value < 0)
+			value += range;
+		value += adjmin;
 	}
-	return joystick_count;
+
+	return value;
 }
 
 
+//-------------------------------------------------
+//  apply_sensitivity - apply a sensitivity
+//  adjustment for a current value
+//-------------------------------------------------
+
+inline INT32 analog_field::apply_sensitivity(INT32 value) const
+{
+	return INT32((INT64(value) * m_sensitivity) / 100.0 + 0.5);
+}
 
-/***************************************************************************
-    DEBUGGER SUPPORT
-***************************************************************************/
 
-/*-------------------------------------------------
-    execute_input - debugger command to enter
-    natural keyboard input
--------------------------------------------------*/
+//-------------------------------------------------
+//  apply_inverse_sensitivity - reverse-apply the
+//  sensitivity adjustment for a current value
+//-------------------------------------------------
 
-static void execute_input(running_machine &machine, int ref, int params, const char *param[])
+inline INT32 analog_field::apply_inverse_sensitivity(INT32 value) const
 {
-	inputx_postn_coded_rate(machine, param[0], strlen(param[0]), attotime::zero);
+	return INT32((INT64(value) * 100) / m_sensitivity);
 }
 
 
+//-------------------------------------------------
+//  apply_settings - return the value of an
+//  analog input
+//-------------------------------------------------
+
+INT32 analog_field::apply_settings(INT32 value) const
+{
+	// apply the min/max and then the sensitivity
+	value = apply_min_max(value);
+	value = apply_sensitivity(value);
+
+	// apply reversal if needed
+	if (m_reverse)
+		value = m_reverse_val - value;
+	else if (m_single_scale)
+		// it's a pedal or the default value is equal to min/max
+		// so we need to adjust the center to the minimum
+		value -= INPUT_ABSOLUTE_MIN;
+
+	// map differently for positive and negative values
+	if (value >= 0)
+		value = apply_scale(value, m_scalepos);
+	else
+		value = apply_scale(value, m_scaleneg);
+	value += m_adjdefvalue;
+
+	return value;
+}
+
 
-/*-------------------------------------------------
-    execute_dumpkbd - debugger command to natural
-    keyboard codes
--------------------------------------------------*/
+//-------------------------------------------------
+//  frame_update - update the internals of a
+//  single analog field periodically
+//-------------------------------------------------
 
-static void execute_dumpkbd(running_machine &machine, int ref, int params, const char *param[])
+void analog_field::frame_update(running_machine &machine)
 {
-	inputx_code *codes = machine.ioport().codes;
-	const char *filename;
-	FILE *file = NULL;
-	const inputx_code *code;
-	char buffer[512];
-	size_t pos;
-	int i, j;
-	size_t left_column_width = 24;
+	// clamp the previous value to the min/max range and remember it
+	m_previous = m_accum = apply_min_max(m_accum);
 
-	/* was there a file specified? */
-	filename = (params > 0) ? param[0] : NULL;
-	if (filename != NULL)
+	// get the new raw analog value and its type
+	input_item_class itemclass;
+	INT32 rawvalue = machine.input().seq_axis_value(m_field.seq(SEQ_TYPE_STANDARD), itemclass);
+
+	// if we got an absolute input, it overrides everything else
+	if (itemclass == ITEM_CLASS_ABSOLUTE)
 	{
-		/* if so, open it */
-		file = fopen(filename, "w");
-		if (file == NULL)
+		if (m_previousanalog != rawvalue)
 		{
-			debug_console_printf(machine, "Cannot open \"%s\"\n", filename);
+			// only update if analog value changed
+			m_previousanalog = rawvalue;
+
+			// apply the inverse of the sensitivity to the raw value so that
+			// it will still cover the full min->max range requested after
+			// we apply the sensitivity adjustment
+			if (m_absolute || m_field.analog_reset())
+			{
+				// if port is absolute, then just return the absolute data supplied
+				m_accum = apply_inverse_sensitivity(rawvalue);
+			}
+			else if (m_positionalscale != 0)
+			{
+				// if port is positional, we will take the full analog control and divide it
+				// into positions, that way as the control is moved full scale,
+				// it moves through all the positions
+				rawvalue = apply_scale(rawvalue - INPUT_ABSOLUTE_MIN, m_positionalscale) * INPUT_RELATIVE_PER_PIXEL + m_minimum;
+
+				// clamp the high value so it does not roll over
+				rawvalue = MIN(rawvalue, m_maximum);
+				m_accum = apply_inverse_sensitivity(rawvalue);
+			}
+			else
+				// if port is relative, we use the value to simulate the speed of relative movement
+				// sensitivity adjustment is allowed for this mode
+				m_accum += rawvalue;
+
+			m_lastdigital = false;
+			// do not bother with other control types if the analog data is changing
 			return;
 		}
+		else
+		{
+			// we still have to update fake relative from joystick control
+			if (!m_absolute && m_positionalscale == 0)
+				m_accum += rawvalue;
+		}
+	}
+
+	// if we got it from a relative device, use that as the starting delta
+	// also note that the last input was not a digital one
+	INT32 delta = 0;
+	if (itemclass == ITEM_CLASS_RELATIVE && rawvalue != 0)
+	{
+		delta = rawvalue;
+		m_lastdigital = false;
 	}
 
-	if ((codes != NULL) && (codes[0].ch != 0))
+	INT64 keyscale = (m_accum >= 0) ? m_keyscalepos : m_keyscaleneg;
+
+	// if the decrement code sequence is pressed, add the key delta to
+	// the accumulated delta; also note that the last input was a digital one
+	bool keypressed = false;
+	if (machine.input().seq_pressed(m_field.seq(SEQ_TYPE_DECREMENT)))
 	{
-		/* loop through all codes */
-		for (i = 0; codes[i].ch; i++)
-		{
-			code = &codes[i];
-			pos = 0;
+		keypressed = true;
+		if (m_delta != 0)
+			delta -= apply_scale(m_delta, keyscale);
+		else if (!m_lastdigital)
+			// decrement only once when first pressed
+			delta -= apply_scale(1, keyscale);
+		m_lastdigital = true;
+	}
 
-			/* describe the character code */
-			pos += snprintf(&buffer[pos], ARRAY_LENGTH(buffer) - pos, "%08X (%s) ",
-				code->ch,
-				code_point_string(machine, code->ch));
-
-			/* pad with spaces */
-			while(pos < left_column_width)
-				buffer[pos++] = ' ';
-			buffer[pos] = '\0';
+	// same for the increment code sequence
+	if (machine.input().seq_pressed(m_field.seq(SEQ_TYPE_INCREMENT)))
+	{
+		keypressed = true;
+		if (m_delta)
+			delta += apply_scale(m_delta, keyscale);
+		else if (!m_lastdigital)
+			// increment only once when first pressed
+			delta += apply_scale(1, keyscale);
+		m_lastdigital = true;
+	}
+
+	// if resetting is requested, clear the accumulated position to 0 before
+	// applying the deltas so that we only return this frame's delta
+	// note that centering only works for relative controls
+	// no need to check if absolute here because it is checked by the validity tests
+	if (m_field.analog_reset())
+		m_accum = 0;
+
+	// apply the delta to the accumulated value
+	m_accum += delta;
 
-			/* identify the keys used */
-			for (j = 0; j < ARRAY_LENGTH(code->field) && (code->field[j] != NULL); j++)
+	// if our last movement was due to a digital input, and if this control
+	// type autocenters, and if neither the increment nor the decrement seq
+	// was pressed, apply autocentering
+	if (m_autocenter)
+	{
+		INT32 center = apply_inverse_sensitivity(m_center);
+		if (m_lastdigital && !keypressed)
+		{
+			// autocenter from positive values
+			if (m_accum >= center)
 			{
-				pos += snprintf(&buffer[pos], ARRAY_LENGTH(buffer) - pos, "%s'%s'",
-					(j > 0) ? ", " : "",
-					code->field[j]->name);
+				m_accum -= apply_scale(m_centerdelta, m_keyscalepos);
+				if (m_accum < center)
+				{
+					m_accum = center;
+					m_lastdigital = false;
+				}
 			}
 
-			/* and output it as appropriate */
-			if (file != NULL)
-				fprintf(file, "%s\n", buffer);
+			// autocenter from negative values
 			else
-				debug_console_printf(machine, "%s\n", buffer);
+			{
+				m_accum += apply_scale(m_centerdelta, m_keyscaleneg);
+				if (m_accum > center)
+				{
+					m_accum = center;
+					m_lastdigital = false;
+				}
+			}
 		}
 	}
-	else
-	{
-		debug_console_printf(machine, "No natural keyboard support\n");
-	}
-
-	/* cleanup */
-	if (file != NULL)
-		fclose(file);
-
+	else if (!keypressed)
+		m_lastdigital = false;
 }
 
 
+//-------------------------------------------------
+//  read - read the current value and insert into
+//  the provided ioport_value
+//-------------------------------------------------
 
-input_port_config *ioconfig_alloc_port(ioport_list &portlist, device_t &device, const char *tag)
+void analog_field::read(ioport_value &result)
 {
-	astring fulltag;
-	device.subtag(fulltag, tag);
-	return &portlist.append(fulltag, *global_alloc(input_port_config(device, fulltag)));
-}
+	// do nothing if we're not enabled
+	if (!m_field.enabled())
+		return;
 
-input_port_config *ioconfig_modify_port(ioport_list &portlist, device_t &device, const char *tag)
-{
-	astring fulltag;
-	device.subtag(fulltag, tag);
-	input_port_config *port = portlist.find(fulltag.cstr());
-	if (port == NULL)
-		throw emu_fatalerror("Requested to modify nonexistent port '%s'", fulltag.cstr());
-	port->bump_modcount();
-	return port;
-}
+	// start with the raw value
+	INT32 value = m_accum;
 
-input_field_config *ioconfig_alloc_field(input_port_config &port, int type, input_port_value defval, input_port_value mask, const char *name)
-{
-	if (&port == NULL)
-		throw emu_fatalerror("INPUT_TOKEN_FIELD encountered with no active port (mask=%X defval=%X)\n", mask, defval); \
-	if (type != IPT_UNKNOWN && type != IPT_UNUSED)
-		port.active |= mask;
-	if (type == IPT_DIPSWITCH || type == IPT_CONFIG)
-		defval = port_default_value(port.tag(), mask, defval, port.owner());
-	return &port.fieldlist().append(*global_alloc(input_field_config(port, type, defval, mask, input_port_string_from_token(name))));
-}
+	// interpolate if appropriate and if time has passed since the last update
+	if (m_interpolate)
+		value = manager().frame_interpolate(m_previous, m_accum);
 
-input_field_config *ioconfig_alloc_onoff(input_port_config &port, const char *name, input_port_value defval, input_port_value mask, const char *diplocation, astring &errorbuf)
-{
-	input_field_config *curfield = ioconfig_alloc_field(port, IPT_DIPSWITCH, defval, mask, name);
-	if (name == DEF_STR(Service_Mode))
-	{
-		curfield->flags |= FIELD_FLAG_TOGGLE;
-		curfield->seq[SEQ_TYPE_STANDARD].set(KEYCODE_F2);
-	}
-	if (diplocation != NULL)
-		diplocation_list_alloc(*curfield, diplocation, errorbuf);
-	ioconfig_alloc_setting(*curfield, defval & mask, DEF_STR(Off));
-	ioconfig_alloc_setting(*curfield, ~defval & mask, DEF_STR(On));
-	return curfield;
+	// apply standard analog settings
+	value = apply_settings(value);
+
+	// remap the value if needed
+	if (m_field.remap_table() != NULL)
+		value = m_field.remap_table()[value];
+
+	// invert bits if needed
+	if (m_field.analog_invert())
+		value = ~value;
+
+	// insert into the port
+	result = (result & ~m_field.mask()) | ((value << m_shift) & m_field.mask());
 }
 
-input_setting_config *ioconfig_alloc_setting(input_field_config &field, input_port_value value, const char *name)
+
+//-------------------------------------------------
+//  crosshair_read - read a value for crosshairs,
+//  scaled between 0 and 1
+//-------------------------------------------------
+
+float analog_field::crosshair_read()
 {
-	return &field.settinglist().append(*global_alloc(input_setting_config(field, value, input_port_string_from_token(name))));
+	INT32 rawvalue = apply_settings(m_accum) & (m_field.mask() >> m_shift);
+	return float(rawvalue - m_adjmin) / float(m_adjmax - m_adjmin);
 }
 
-void ioconfig_field_add_char(input_field_config &field, unicode_char ch, astring &errorbuf)
+
+
+/***************************************************************************
+    TOKENIZATION HELPERS
+***************************************************************************/
+
+//-------------------------------------------------
+//  token_to_input_type - convert a string token
+//  to an input field type and player
+//-------------------------------------------------
+
+ioport_type ioport_manager::token_to_input_type(const char *string, int &player) const
 {
-	for (int index = 0; index < ARRAY_LENGTH(field.chars); index++)
-		if (field.chars[index] == 0)
+	// check for our failsafe case first
+	int ipnum;
+	if (sscanf(string, "TYPE_OTHER(%d,%d)", &ipnum, &player) == 2)
+		return ioport_type(ipnum);
+
+	// find the token in the list
+	for (input_type_entry *entry = m_typelist.first(); entry != NULL; entry = entry->next())
+		if (entry->token() != NULL && !strcmp(entry->token(), string))
 		{
-			field.chars[index] = ch;
-			break;
+			player = entry->player();
+			return entry->type();
 		}
+
+	// if we fail, return IPT_UNKNOWN
+	player = 0;
+	return IPT_UNKNOWN;
 }
 
-void ioconfig_add_code(input_field_config &field, int which, input_code code)
+
+//-------------------------------------------------
+//  input_type_to_token - convert an input field
+//  type and player to a string token
+//-------------------------------------------------
+
+const char *ioport_manager::input_type_to_token(astring &string, ioport_type type, int player)
 {
-	field.seq[which] |= code;
+	// look up the port and return the token
+	input_type_entry *entry = m_type_to_entry[type][player];
+	if (entry != NULL)
+		return string.cpy(entry->token());
+
+	// if that fails, carry on
+	return string.format("TYPE_OTHER(%d,%d)", type, player);
 }
 
 
+//-------------------------------------------------
+//  token_to_seq_type - convert a string to
+//  a sequence type
+//-------------------------------------------------
 
-input_type_entry::input_type_entry(UINT32 _type, ioport_group _group, int _player, const char *_token, const char *_name, input_seq standard)
-	: type(_type),
-	  group(_group),
-	  player(_player),
-	  token(_token),
-	  name(_name),
-	  m_next(NULL)
+input_seq_type ioport_manager::token_to_seq_type(const char *string)
 {
-	defseq[SEQ_TYPE_STANDARD] = seq[SEQ_TYPE_STANDARD] = standard;
+	// look up the string in the table of possible sequence types and return the index
+	for (int seqindex = 0; seqindex < ARRAY_LENGTH(seqtypestrings); seqindex++)
+		if (!mame_stricmp(string, seqtypestrings[seqindex]))
+			return input_seq_type(seqindex);
+	return SEQ_TYPE_INVALID;
 }
 
-input_type_entry::input_type_entry(UINT32 _type, ioport_group _group, int _player, const char *_token, const char *_name, input_seq standard, input_seq decrement, input_seq increment)
-	: type(_type),
-	  group(_group),
-	  player(_player),
-	  token(_token),
-	  name(_name),
-	  m_next(NULL)
+
+
+//-------------------------------------------------
+//  validate_natural_keyboard_statics -
+//  validates natural keyboard static data
+//-------------------------------------------------
+
+/*
+int validate_natural_keyboard_statics(void)
 {
-	defseq[SEQ_TYPE_STANDARD] = seq[SEQ_TYPE_STANDARD] = standard;
-	defseq[SEQ_TYPE_INCREMENT] = seq[SEQ_TYPE_INCREMENT] = increment;
-	defseq[SEQ_TYPE_DECREMENT] = seq[SEQ_TYPE_DECREMENT] = decrement;
+    int i;
+    int error = FALSE;
+    unicode_char last_char = 0;
+    const char_info *ci;
+
+    // check to make sure that charinfo is in order
+    for (i = 0; i < ARRAY_LENGTH(charinfo); i++)
+    {
+        if (last_char >= charinfo[i].ch)
+        {
+            mame_printf_error("inputx: charinfo is out of order; 0x%08x should be higher than 0x%08x\n", charinfo[i].ch, last_char);
+            error = TRUE;
+        }
+        last_char = charinfo[i].ch;
+    }
+
+    // check to make sure that I can look up everything on alternate_charmap
+    for (i = 0; i < ARRAY_LENGTH(charinfo); i++)
+    {
+        ci = char_info::find(charinfo[i].ch);
+        if (ci != &charinfo[i])
+        {
+            mame_printf_error("ioport: expected char_info::find(0x%08x) to work properly\n", charinfo[i].ch);
+            error = TRUE;
+        }
+    }
+    return error;
 }
+*/
+
+
diff -Nru src-old/emu/ioport.h src/emu/ioport.h
--- src-old/emu/ioport.h	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/ioport.h	2012-05-07 08:57:50.000000000 +0200
@@ -4,8 +4,36 @@
 
     Input/output port handling.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ***************************************************************************/
 
@@ -21,61 +49,48 @@
 #include <time.h>
 
 
-
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-#define MAX_PLAYERS			8
-
-#define IP_ACTIVE_HIGH		0x00000000
-#define IP_ACTIVE_LOW		0xffffffff
-
-
-/* flags for input_field_configs */
-#define FIELD_FLAG_UNUSED	0x01			/* set if this field is unused but relevant to other games on the same hw */
-#define FIELD_FLAG_COCKTAIL	0x02			/* set if this field is relevant only for cocktail cabinets */
-#define FIELD_FLAG_TOGGLE	0x04			/* set if this field should behave as a toggle */
-#define FIELD_FLAG_ROTATED	0x08			/* set if this field represents a rotated control */
-#define ANALOG_FLAG_REVERSE	0x10			/* analog only: reverse the sense of the axis */
-#define ANALOG_FLAG_RESET	0x20			/* analog only: always preload in->default for relative axes, returning only deltas */
-#define ANALOG_FLAG_WRAPS	0x40			/* analog only: positional count wraps around */
-#define ANALOG_FLAG_INVERT	0x80			/* analog only: bitwise invert bits */
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+// input ports support up to 32 bits each
+typedef UINT32 ioport_value;
+
+// active high/low values for input ports
+const ioport_value IP_ACTIVE_HIGH = 0x00000000;
+const ioport_value IP_ACTIVE_LOW = 0xffffffff;
+
+// maximum number of players supported
+const int MAX_PLAYERS = 8;
+
+// INP file parameters
+const UINT32 INP_HEADER_SIZE = 64;
+const UINT32 INP_HEADER_MAJVERSION = 3;
+const UINT32 INP_HEADER_MINVERSION = 0;
+
+// unicode constants
+const unicode_char UCHAR_PRIVATE = 0x100000;
+const unicode_char UCHAR_SHIFT_1 = UCHAR_PRIVATE + 0;
+const unicode_char UCHAR_SHIFT_2 = UCHAR_PRIVATE + 1;
+const unicode_char UCHAR_SHIFT_BEGIN = UCHAR_SHIFT_1;
+const unicode_char UCHAR_SHIFT_END = UCHAR_SHIFT_2;
+const unicode_char UCHAR_MAMEKEY_BEGIN = UCHAR_PRIVATE + 2;
 
 
-/* INP file information */
-#define INP_HEADER_SIZE			64
-#define INP_HEADER_MAJVERSION	3
-#define INP_HEADER_MINVERSION	0
-
-
-/* sequence types for input_port_seq() call */
-enum _input_seq_type
+// sequence types for input_port_seq() call
+enum input_seq_type
 {
+	SEQ_TYPE_INVALID = -1,
 	SEQ_TYPE_STANDARD = 0,
 	SEQ_TYPE_INCREMENT,
 	SEQ_TYPE_DECREMENT,
 	SEQ_TYPE_TOTAL
 };
-typedef enum _input_seq_type input_seq_type;
 DECLARE_ENUM_OPERATORS(input_seq_type)
 
 
-/* conditions for DIP switches */
-enum
-{
-	PORTCOND_ALWAYS = 0,
-	PORTCOND_EQUALS,
-	PORTCOND_NOTEQUALS,
-	PORTCOND_GREATERTHAN,
-	PORTCOND_NOTGREATERTHAN,
-	PORTCOND_LESSTHAN,
-	PORTCOND_NOTLESSTHAN
-};
-
-
-/* crosshair types */
-enum
+// crosshair types
+enum crosshair_axis_t
 {
 	CROSSHAIR_AXIS_NONE = 0,
 	CROSSHAIR_AXIS_X,
@@ -83,7 +98,7 @@
 };
 
 
-/* groups for input ports */
+// groups for input ports
 enum ioport_group
 {
 	IPG_UI = 0,
@@ -101,20 +116,19 @@
 };
 
 
-/* various input port types */
-enum
+// various input port types
+enum ioport_type
 {
-	/* pseudo-port types */
+	// pseudo-port types
 	IPT_INVALID = 0,
 	IPT_UNUSED,
 	IPT_END,
 	IPT_UNKNOWN,
 	IPT_PORT,
 	IPT_DIPSWITCH,
-	IPT_VBLANK,
 	IPT_CONFIG,
 
-	/* start buttons */
+	// start buttons
 	IPT_START1,
 	IPT_START2,
 	IPT_START3,
@@ -124,7 +138,7 @@
 	IPT_START7,
 	IPT_START8,
 
-	/* coin slots */
+	// coin slots
 	IPT_COIN1,
 	IPT_COIN2,
 	IPT_COIN3,
@@ -139,48 +153,51 @@
 	IPT_COIN12,
 	IPT_BILL1,
 
-	/* service coin */
+	// service coin
 	IPT_SERVICE1,
 	IPT_SERVICE2,
 	IPT_SERVICE3,
 	IPT_SERVICE4,
 
-	/* tilt inputs */
+	// tilt inputs
 	IPT_TILT1,
 	IPT_TILT2,
 	IPT_TILT3,
 	IPT_TILT4,
 
-	/* misc other digital inputs */
+	// misc other digital inputs
 	IPT_SERVICE,
 	IPT_TILT,
 	IPT_INTERLOCK,
 	IPT_VOLUME_UP,
 	IPT_VOLUME_DOWN,
-	IPT_START,					/* MESS only */
-	IPT_SELECT,					/* MESS only */
-	IPT_KEYPAD,					/* MESS only */
-	IPT_KEYBOARD,				/* MESS only */
-
-#define __ipt_digital_joystick_start IPT_JOYSTICK_UP
-	/* use IPT_JOYSTICK for panels where the player has one single joystick */
-	IPT_JOYSTICK_UP,
-	IPT_JOYSTICK_DOWN,
-	IPT_JOYSTICK_LEFT,
-	IPT_JOYSTICK_RIGHT,
-
-	/* use IPT_JOYSTICKLEFT and IPT_JOYSTICKRIGHT for dual joystick panels */
-	IPT_JOYSTICKRIGHT_UP,
-	IPT_JOYSTICKRIGHT_DOWN,
-	IPT_JOYSTICKRIGHT_LEFT,
-	IPT_JOYSTICKRIGHT_RIGHT,
-	IPT_JOYSTICKLEFT_UP,
-	IPT_JOYSTICKLEFT_DOWN,
-	IPT_JOYSTICKLEFT_LEFT,
-	IPT_JOYSTICKLEFT_RIGHT,
-#define __ipt_digital_joystick_end IPT_JOYSTICKLEFT_RIGHT
+	IPT_START,					// MESS only
+	IPT_SELECT,					// MESS only
+	IPT_KEYPAD,					// MESS only
+	IPT_KEYBOARD,				// MESS only
+
+	// digital joystick inputs
+	IPT_DIGITAL_JOYSTICK_FIRST,
+
+		// use IPT_JOYSTICK for panels where the player has one single joystick
+		IPT_JOYSTICK_UP,
+		IPT_JOYSTICK_DOWN,
+		IPT_JOYSTICK_LEFT,
+		IPT_JOYSTICK_RIGHT,
+
+		// use IPT_JOYSTICKLEFT and IPT_JOYSTICKRIGHT for dual joystick panels
+		IPT_JOYSTICKRIGHT_UP,
+		IPT_JOYSTICKRIGHT_DOWN,
+		IPT_JOYSTICKRIGHT_LEFT,
+		IPT_JOYSTICKRIGHT_RIGHT,
+		IPT_JOYSTICKLEFT_UP,
+		IPT_JOYSTICKLEFT_DOWN,
+		IPT_JOYSTICKLEFT_LEFT,
+		IPT_JOYSTICKLEFT_RIGHT,
 
-	/* action buttons */
+	IPT_DIGITAL_JOYSTICK_LAST,
+
+	// action buttons
 	IPT_BUTTON1,
 	IPT_BUTTON2,
 	IPT_BUTTON3,
@@ -198,210 +215,234 @@
 	IPT_BUTTON15,
 	IPT_BUTTON16,
 
-	/* mahjong inputs */
-#define __ipt_mahjong_start IPT_MAHJONG_A
-	IPT_MAHJONG_A,
-	IPT_MAHJONG_B,
-	IPT_MAHJONG_C,
-	IPT_MAHJONG_D,
-	IPT_MAHJONG_E,
-	IPT_MAHJONG_F,
-	IPT_MAHJONG_G,
-	IPT_MAHJONG_H,
-	IPT_MAHJONG_I,
-	IPT_MAHJONG_J,
-	IPT_MAHJONG_K,
-	IPT_MAHJONG_L,
-	IPT_MAHJONG_M,
-	IPT_MAHJONG_N,
-	IPT_MAHJONG_O,
-	IPT_MAHJONG_P,
-	IPT_MAHJONG_Q,
-	IPT_MAHJONG_KAN,
-	IPT_MAHJONG_PON,
-	IPT_MAHJONG_CHI,
-	IPT_MAHJONG_REACH,	//IPT_MAHJONG_RIICHI,   // REACH is Japanglish
-	IPT_MAHJONG_RON,
-	IPT_MAHJONG_BET,
-	IPT_MAHJONG_LAST_CHANCE,
-	IPT_MAHJONG_SCORE,
-	IPT_MAHJONG_DOUBLE_UP,
-	IPT_MAHJONG_FLIP_FLOP,
-	IPT_MAHJONG_BIG,
-	IPT_MAHJONG_SMALL,
-#define __ipt_mahjong_end IPT_MAHJONG_SMALL
-
-	/* hanafuda inputs */
-#define __ipt_hanafuda_start IPT_HANAFUDA_A
-	IPT_HANAFUDA_A,
-	IPT_HANAFUDA_B,
-	IPT_HANAFUDA_C,
-	IPT_HANAFUDA_D,
-	IPT_HANAFUDA_E,
-	IPT_HANAFUDA_F,
-	IPT_HANAFUDA_G,
-	IPT_HANAFUDA_H,
-	IPT_HANAFUDA_YES,
-	IPT_HANAFUDA_NO,
-#define __ipt_hanafuda_end IPT_HANAFUDA_NO
-
-#define __ipt_gambling_start IPT_GAMBLE_KEYIN
-
-	/* gambling inputs */
-	IPT_GAMBLE_KEYIN,	// attendant
-	IPT_GAMBLE_KEYOUT,	// attendant
-	IPT_GAMBLE_SERVICE,	// attendant
-	IPT_GAMBLE_BOOK,	// attendant
-	IPT_GAMBLE_DOOR,	// attendant
-//  IPT_GAMBLE_DOOR2,   // many gambling games have several doors.
-//  IPT_GAMBLE_DOOR3,
-//  IPT_GAMBLE_DOOR4,
-//  IPT_GAMBLE_DOOR5,
-
-	IPT_GAMBLE_HIGH,	// player
-	IPT_GAMBLE_LOW,		// player
-	IPT_GAMBLE_HALF,	// player
-	IPT_GAMBLE_DEAL,	// player
-	IPT_GAMBLE_D_UP,	// player
-	IPT_GAMBLE_TAKE,	// player
-	IPT_GAMBLE_STAND,	// player
-	IPT_GAMBLE_BET,		// player
-	IPT_GAMBLE_PAYOUT,	// player
-//  IPT_GAMBLE_BUTTON1, // player
-//  IPT_GAMBLE_BUTTON2, // many many gambling games have multi-games and/or multi-function-buttons
-//  IPT_GAMBLE_BUTTON3, // I suggest to eliminate specific names
-//  IPT_GAMBLE_BUTTON4,
-//  IPT_GAMBLE_BUTTON5,
-//  IPT_GAMBLE_BUTTON6,
-//  IPT_GAMBLE_BUTTON7,
-//  IPT_GAMBLE_BUTTON8,
-//  IPT_GAMBLE_BUTTON9,
-//  IPT_GAMBLE_BUTTON10,
-//  IPT_GAMBLE_BUTTON11,
-//  IPT_GAMBLE_BUTTON12,
-//  IPT_GAMBLE_BUTTON13,
-//  IPT_GAMBLE_BUTTON14,
-//  IPT_GAMBLE_BUTTON15,
-//  IPT_GAMBLE_BUTTON16,
-
-	/* poker-specific inputs */
-	IPT_POKER_HOLD1,
-	IPT_POKER_HOLD2,
-	IPT_POKER_HOLD3,
-	IPT_POKER_HOLD4,
-	IPT_POKER_HOLD5,
-	IPT_POKER_CANCEL,
-	IPT_POKER_BET,
-
-	/* slot-specific inputs */
-	IPT_SLOT_STOP1,
-	IPT_SLOT_STOP2,
-	IPT_SLOT_STOP3,
-	IPT_SLOT_STOP4,
-	IPT_SLOT_STOP_ALL,
-
-#define __ipt_gambling_end IPT_SLOT_STOP_ALL
-
-	/* analog inputs */
-#define __ipt_analog_start IPT_AD_STICK_X
-#define __ipt_analog_absolute_start IPT_AD_STICK_X
-	IPT_AD_STICK_X,		// absolute // autocenter
-	IPT_AD_STICK_Y,		// absolute // autocenter
-	IPT_AD_STICK_Z,		// absolute // autocenter
-	IPT_PADDLE,			// absolute // autocenter
-	IPT_PADDLE_V,		// absolute // autocenter
-	IPT_PEDAL,			// absolute // autocenter
-	IPT_PEDAL2,			// absolute // autocenter
-	IPT_PEDAL3,			// absolute // autocenter
-	IPT_LIGHTGUN_X,		// absolute
-	IPT_LIGHTGUN_Y,		// absolute
-	IPT_POSITIONAL,		// absolute // autocenter if not wraps
-	IPT_POSITIONAL_V,	// absolute // autocenter if not wraps
-#define __ipt_analog_absolute_end IPT_POSITIONAL_V
-
-	IPT_DIAL,			// relative
-	IPT_DIAL_V,			// relative
-	IPT_TRACKBALL_X,	// relative
-	IPT_TRACKBALL_Y,	// relative
-	IPT_MOUSE_X,		// relative
-	IPT_MOUSE_Y,		// relative
-#define __ipt_analog_end IPT_MOUSE_Y
+	// mahjong inputs
+	IPT_MAHJONG_FIRST,
+
+		IPT_MAHJONG_A,
+		IPT_MAHJONG_B,
+		IPT_MAHJONG_C,
+		IPT_MAHJONG_D,
+		IPT_MAHJONG_E,
+		IPT_MAHJONG_F,
+		IPT_MAHJONG_G,
+		IPT_MAHJONG_H,
+		IPT_MAHJONG_I,
+		IPT_MAHJONG_J,
+		IPT_MAHJONG_K,
+		IPT_MAHJONG_L,
+		IPT_MAHJONG_M,
+		IPT_MAHJONG_N,
+		IPT_MAHJONG_O,
+		IPT_MAHJONG_P,
+		IPT_MAHJONG_Q,
+		IPT_MAHJONG_KAN,
+		IPT_MAHJONG_PON,
+		IPT_MAHJONG_CHI,
+		IPT_MAHJONG_REACH,	//IPT_MAHJONG_RIICHI,   // REACH is Japanglish
+		IPT_MAHJONG_RON,
+		IPT_MAHJONG_BET,
+		IPT_MAHJONG_LAST_CHANCE,
+		IPT_MAHJONG_SCORE,
+		IPT_MAHJONG_DOUBLE_UP,
+		IPT_MAHJONG_FLIP_FLOP,
+		IPT_MAHJONG_BIG,
+		IPT_MAHJONG_SMALL,
+
+	IPT_MAHJONG_LAST,
+
+	// hanafuda inputs
+	IPT_HANAFUDA_FIRST,
+
+		IPT_HANAFUDA_A,
+		IPT_HANAFUDA_B,
+		IPT_HANAFUDA_C,
+		IPT_HANAFUDA_D,
+		IPT_HANAFUDA_E,
+		IPT_HANAFUDA_F,
+		IPT_HANAFUDA_G,
+		IPT_HANAFUDA_H,
+		IPT_HANAFUDA_YES,
+		IPT_HANAFUDA_NO,
+
+	IPT_HANAFUDA_LAST,
+
+	// gambling inputs
+	IPT_GAMBLING_FIRST,
+
+		IPT_GAMBLE_KEYIN,	// attendant
+		IPT_GAMBLE_KEYOUT,	// attendant
+		IPT_GAMBLE_SERVICE,	// attendant
+		IPT_GAMBLE_BOOK,	// attendant
+		IPT_GAMBLE_DOOR,	// attendant
+	//  IPT_GAMBLE_DOOR2,   // many gambling games have several doors.
+	//  IPT_GAMBLE_DOOR3,
+	//  IPT_GAMBLE_DOOR4,
+	//  IPT_GAMBLE_DOOR5,
+
+		IPT_GAMBLE_HIGH,	// player
+		IPT_GAMBLE_LOW,		// player
+		IPT_GAMBLE_HALF,	// player
+		IPT_GAMBLE_DEAL,	// player
+		IPT_GAMBLE_D_UP,	// player
+		IPT_GAMBLE_TAKE,	// player
+		IPT_GAMBLE_STAND,	// player
+		IPT_GAMBLE_BET,		// player
+		IPT_GAMBLE_PAYOUT,	// player
+	//  IPT_GAMBLE_BUTTON1, // player
+	//  IPT_GAMBLE_BUTTON2, // many many gambling games have multi-games and/or multi-function-buttons
+	//  IPT_GAMBLE_BUTTON3, // I suggest to eliminate specific names
+	//  IPT_GAMBLE_BUTTON4,
+	//  IPT_GAMBLE_BUTTON5,
+	//  IPT_GAMBLE_BUTTON6,
+	//  IPT_GAMBLE_BUTTON7,
+	//  IPT_GAMBLE_BUTTON8,
+	//  IPT_GAMBLE_BUTTON9,
+	//  IPT_GAMBLE_BUTTON10,
+	//  IPT_GAMBLE_BUTTON11,
+	//  IPT_GAMBLE_BUTTON12,
+	//  IPT_GAMBLE_BUTTON13,
+	//  IPT_GAMBLE_BUTTON14,
+	//  IPT_GAMBLE_BUTTON15,
+	//  IPT_GAMBLE_BUTTON16,
+
+		// poker-specific inputs
+		IPT_POKER_HOLD1,
+		IPT_POKER_HOLD2,
+		IPT_POKER_HOLD3,
+		IPT_POKER_HOLD4,
+		IPT_POKER_HOLD5,
+		IPT_POKER_CANCEL,
+		IPT_POKER_BET,
+
+		// slot-specific inputs
+		IPT_SLOT_STOP1,
+		IPT_SLOT_STOP2,
+		IPT_SLOT_STOP3,
+		IPT_SLOT_STOP4,
+		IPT_SLOT_STOP_ALL,
+
+	IPT_GAMBLING_LAST,
+
+	// analog inputs
+	IPT_ANALOG_FIRST,
+
+		IPT_ANALOG_ABSOLUTE_FIRST,
+
+			IPT_AD_STICK_X,		// absolute // autocenter
+			IPT_AD_STICK_Y,		// absolute // autocenter
+			IPT_AD_STICK_Z,		// absolute // autocenter
+			IPT_PADDLE,			// absolute // autocenter
+			IPT_PADDLE_V,		// absolute // autocenter
+			IPT_PEDAL,			// absolute // autocenter
+			IPT_PEDAL2,			// absolute // autocenter
+			IPT_PEDAL3,			// absolute // autocenter
+			IPT_LIGHTGUN_X,		// absolute
+			IPT_LIGHTGUN_Y,		// absolute
+			IPT_POSITIONAL,		// absolute // autocenter if not wraps
+			IPT_POSITIONAL_V,	// absolute // autocenter if not wraps
+
+		IPT_ANALOG_ABSOLUTE_LAST,
+
+		IPT_DIAL,			// relative
+		IPT_DIAL_V,			// relative
+		IPT_TRACKBALL_X,	// relative
+		IPT_TRACKBALL_Y,	// relative
+		IPT_MOUSE_X,		// relative
+		IPT_MOUSE_Y,		// relative
 
-	/* analog adjuster support */
+	IPT_ANALOG_LAST,
+
+	// analog adjuster support
 	IPT_ADJUSTER,
 
-	/* the following are special codes for user interface handling - not to be used by drivers! */
-#define __ipt_ui_start IPT_UI_CONFIGURE
-	IPT_UI_CONFIGURE,
-	IPT_UI_ON_SCREEN_DISPLAY,
-	IPT_UI_DEBUG_BREAK,
-	IPT_UI_PAUSE,
-	IPT_UI_RESET_MACHINE,
-	IPT_UI_SOFT_RESET,
-	IPT_UI_SHOW_GFX,
-	IPT_UI_FRAMESKIP_DEC,
-	IPT_UI_FRAMESKIP_INC,
-	IPT_UI_THROTTLE,
-	IPT_UI_FAST_FORWARD,
-	IPT_UI_SHOW_FPS,
-	IPT_UI_SNAPSHOT,
-	IPT_UI_RECORD_MOVIE,
-	IPT_UI_TOGGLE_CHEAT,
-	IPT_UI_UP,
-	IPT_UI_DOWN,
-	IPT_UI_LEFT,
-	IPT_UI_RIGHT,
-	IPT_UI_HOME,
-	IPT_UI_END,
-	IPT_UI_PAGE_UP,
-	IPT_UI_PAGE_DOWN,
-	IPT_UI_SELECT,
-	IPT_UI_CANCEL,
-	IPT_UI_DISPLAY_COMMENT,
-	IPT_UI_CLEAR,
-	IPT_UI_ZOOM_IN,
-	IPT_UI_ZOOM_OUT,
-	IPT_UI_PREV_GROUP,
-	IPT_UI_NEXT_GROUP,
-	IPT_UI_ROTATE,
-	IPT_UI_SHOW_PROFILER,
-	IPT_UI_TOGGLE_UI,
-	IPT_UI_TOGGLE_DEBUG,
-	IPT_UI_PASTE,
-	IPT_UI_SAVE_STATE,
-	IPT_UI_LOAD_STATE,
-
-	/* additional OSD-specified UI port types (up to 16) */
-	IPT_OSD_1,
-	IPT_OSD_2,
-	IPT_OSD_3,
-	IPT_OSD_4,
-	IPT_OSD_5,
-	IPT_OSD_6,
-	IPT_OSD_7,
-	IPT_OSD_8,
-	IPT_OSD_9,
-	IPT_OSD_10,
-	IPT_OSD_11,
-	IPT_OSD_12,
-	IPT_OSD_13,
-	IPT_OSD_14,
-	IPT_OSD_15,
-	IPT_OSD_16,
-#define __ipt_ui_end IPT_OSD_16
+	// the following are special codes for user interface handling - not to be used by drivers!
+	IPT_UI_FIRST,
+
+		IPT_UI_CONFIGURE,
+		IPT_UI_ON_SCREEN_DISPLAY,
+		IPT_UI_DEBUG_BREAK,
+		IPT_UI_PAUSE,
+		IPT_UI_RESET_MACHINE,
+		IPT_UI_SOFT_RESET,
+		IPT_UI_SHOW_GFX,
+		IPT_UI_FRAMESKIP_DEC,
+		IPT_UI_FRAMESKIP_INC,
+		IPT_UI_THROTTLE,
+		IPT_UI_FAST_FORWARD,
+		IPT_UI_SHOW_FPS,
+		IPT_UI_SNAPSHOT,
+		IPT_UI_RECORD_MOVIE,
+		IPT_UI_TOGGLE_CHEAT,
+		IPT_UI_UP,
+		IPT_UI_DOWN,
+		IPT_UI_LEFT,
+		IPT_UI_RIGHT,
+		IPT_UI_HOME,
+		IPT_UI_END,
+		IPT_UI_PAGE_UP,
+		IPT_UI_PAGE_DOWN,
+		IPT_UI_SELECT,
+		IPT_UI_CANCEL,
+		IPT_UI_DISPLAY_COMMENT,
+		IPT_UI_CLEAR,
+		IPT_UI_ZOOM_IN,
+		IPT_UI_ZOOM_OUT,
+		IPT_UI_PREV_GROUP,
+		IPT_UI_NEXT_GROUP,
+		IPT_UI_ROTATE,
+		IPT_UI_SHOW_PROFILER,
+		IPT_UI_TOGGLE_UI,
+		IPT_UI_TOGGLE_DEBUG,
+		IPT_UI_PASTE,
+		IPT_UI_SAVE_STATE,
+		IPT_UI_LOAD_STATE,
+
+		// additional OSD-specified UI port types (up to 16)
+		IPT_OSD_1,
+		IPT_OSD_2,
+		IPT_OSD_3,
+		IPT_OSD_4,
+		IPT_OSD_5,
+		IPT_OSD_6,
+		IPT_OSD_7,
+		IPT_OSD_8,
+		IPT_OSD_9,
+		IPT_OSD_10,
+		IPT_OSD_11,
+		IPT_OSD_12,
+		IPT_OSD_13,
+		IPT_OSD_14,
+		IPT_OSD_15,
+		IPT_OSD_16,
 
-	/* other meaning not mapped to standard defaults */
+	IPT_UI_LAST,
+
+	// other meaning not mapped to standard defaults
 	IPT_OTHER,
 
-	/* special meaning handled by custom code */
+	// special meaning handled by custom code
 	IPT_SPECIAL,
+	IPT_CUSTOM,
 	IPT_OUTPUT,
 
-	__ipt_max
+	IPT_COUNT
+};
+DECLARE_ENUM_OPERATORS(ioport_type)
+
+
+// input type classes
+enum ioport_type_class
+{
+	INPUT_CLASS_INTERNAL,
+	INPUT_CLASS_KEYBOARD,
+	INPUT_CLASS_CONTROLLER,
+	INPUT_CLASS_CONFIG,
+	INPUT_CLASS_DIPSWITCH,
+	INPUT_CLASS_MISC
 };
 
 
-/* default strings used in port definitions */
+// default strings used in port definitions
 enum
 {
 	INPUT_STRING_Off = 1,
@@ -627,300 +668,567 @@
 };
 
 
-/* input classes */
-enum
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// opaque types pointing to live state
+struct input_port_state;
+struct input_field_state;
+
+// forward declarations
+class ioport_list;
+class ioport_port;
+struct ioport_port_live;
+class ioport_field;
+struct ioport_field_live;
+class ioport_manager;
+class emu_timer;
+typedef struct _xml_data_node xml_data_node;
+class analog_field;
+
+// constructor function pointer
+typedef void (*ioport_constructor)(device_t &owner, ioport_list &portlist, astring &errorbuf);
+
+// I/O port callback function delegates
+typedef device_delegate<ioport_value (ioport_field &, void *)> ioport_field_read_delegate;
+typedef device_delegate<void (ioport_field &, void *, ioport_value, ioport_value)> ioport_field_write_delegate;
+typedef device_delegate<float (ioport_field &, float)> ioport_field_crossmap_delegate;
+
+// keyboard helper function delegates
+typedef delegate<int (const unicode_char *, size_t)> ioport_queue_chars_delegate;
+typedef delegate<bool (unicode_char)> ioport_accept_char_delegate;
+typedef delegate<bool ()> ioport_charqueue_empty_delegate;
+
+
+// ======================> inp_header
+
+// header at the front of INP files
+struct inp_header
+{
+	char						header[8];		// +00: 8 byte header - must be "MAMEINP\0"
+	UINT64						basetime;		// +08: base time of recording
+	UINT8						majversion;		// +10: major INP version
+	UINT8						minversion;		// +11: minor INP version
+	UINT8						reserved[2];	// +12: must be zero
+	char						gamename[12];	// +14: game name string, NULL-terminated
+	char						version[32];	// +20: system version string, NULL-terminated
+};
+
+
+// ======================> input_device_default
+
+// device defined default input settings
+struct input_device_default
 {
-	INPUT_CLASS_INTERNAL,
-	INPUT_CLASS_KEYBOARD,
-	INPUT_CLASS_CONTROLLER,
-	INPUT_CLASS_CONFIG,
-	INPUT_CLASS_DIPSWITCH,
-	INPUT_CLASS_MISC
+	const char *			tag;			// tag of port to update
+	ioport_value			mask;			// mask to apply to the port
+	ioport_value			defvalue;		// new default value
 };
 
-#define UCHAR_PRIVATE		(0x100000)
-#define UCHAR_SHIFT_1		(UCHAR_PRIVATE + 0)
-#define UCHAR_SHIFT_2		(UCHAR_PRIVATE + 1)
-#define UCHAR_MAMEKEY_BEGIN	(UCHAR_PRIVATE + 2)
-#define UCHAR_MAMEKEY(code)	(UCHAR_MAMEKEY_BEGIN + ITEM_ID_##code)
 
-#define UCHAR_SHIFT_BEGIN	(UCHAR_SHIFT_1)
-#define UCHAR_SHIFT_END		(UCHAR_SHIFT_2)
+// ======================> input_type_entry
 
+// describes a fundamental input type, including default input sequences
+class input_type_entry
+{
+	friend class simple_list<input_type_entry>;
+	friend class ioport_manager;
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+public:
+	// construction/destruction
+	input_type_entry(ioport_type type, ioport_group group, int player, const char *token, const char *name, input_seq standard);
+	input_type_entry(ioport_type type, ioport_group group, int player, const char *token, const char *name, input_seq standard, input_seq decrement, input_seq increment);
 
-/* input ports support up to 32 bits each */
-typedef UINT32 input_port_value;
+	// getters
+	input_type_entry *next() const { return m_next; }
+	ioport_type type() const { return m_type; }
+	ioport_group group() const { return m_group; }
+	UINT8 player() const { return m_player; }
+	const char *token() const { return m_token; }
+	const char *name() const { return m_name; }
+	input_seq &defseq(input_seq_type seqtype = SEQ_TYPE_STANDARD) { return m_defseq[seqtype]; }
+	const input_seq &seq(input_seq_type seqtype = SEQ_TYPE_STANDARD) const { return m_seq[seqtype]; }
 
+	// setters
+	void configure_osd(const char *token, const char *name);
 
-/* opaque types pointing to live state */
-typedef struct _input_port_state input_port_state;
-typedef struct _input_field_state input_field_state;
+private:
+	// internal state
+	input_type_entry *	m_next;				// next description in the list
+	ioport_type			m_type;				// IPT_* for this entry
+	ioport_group		m_group;			// which group the port belongs to
+	UINT8				m_player;			// player number (0 is player 1)
+	const char *		m_token;			// token used to store settings
+	const char *		m_name;				// user-friendly name
+	input_seq			m_defseq[SEQ_TYPE_TOTAL];// default input sequence
+	input_seq			m_seq[SEQ_TYPE_TOTAL];// currently configured sequences
+};
 
 
-/* forward declarations */
-class input_port_config;
-class input_field_config;
-class emu_timer;
+// ======================> digital_joystick
 
-/* template specializations */
-typedef tagged_list<input_port_config> ioport_list;
+// tracking information about a digital joystick input
+class digital_joystick
+{
+	DISABLE_COPYING(digital_joystick);
+	friend class simple_list<digital_joystick>;
 
+public:
+	// directions
+	enum direction_t
+	{
+		JOYDIR_UP,
+		JOYDIR_DOWN,
+		JOYDIR_LEFT,
+		JOYDIR_RIGHT,
+		JOYDIR_COUNT
+	};
+
+	// bit constants
+	static const UINT8 UP_BIT = 1 << JOYDIR_UP;
+	static const UINT8 DOWN_BIT = 1 << JOYDIR_DOWN;
+	static const UINT8 LEFT_BIT = 1 << JOYDIR_LEFT;
+	static const UINT8 RIGHT_BIT = 1 << JOYDIR_RIGHT;
 
-/* read input port callback function */
-typedef delegate<UINT32 (const input_field_config &, void *)> input_field_read_delegate;
+	// construction/destruction
+	digital_joystick(int player, int number);
 
-/* input port write callback function */
-typedef delegate<void (const input_field_config &, void *, input_port_value, input_port_value)> input_field_write_delegate;
+	// getters
+	digital_joystick *next() const { return m_next; }
+	int player() const { return m_player; }
+	int number() const { return m_number; }
+	UINT8 current() const { return m_current; }
+	UINT8 current4way() const { return m_current4way; }
 
-/* crosshair mapping function */
-typedef delegate<float (const input_field_config &, float)> input_field_crossmap_delegate;
+	// configuration
+	direction_t set_axis(ioport_field &field);
 
+	// updates
+	void frame_update();
 
-/* encapsulates a condition on a port field or setting */
-typedef struct _input_condition input_condition;
-struct _input_condition
-{
-	const char *				tag;			/* tag of port whose condition is to be tested */
-	input_port_value			mask;			/* mask to apply to the port */
-	input_port_value			value;			/* value to compare against */
-	UINT8						condition;		/* condition to use */
+private:
+	// internal state
+	digital_joystick *	m_next;					// next joystick in the list
+	int					m_player;				// player number represented
+	int					m_number;				// joystick number represented
+	ioport_field *		m_field[JOYDIR_COUNT];	// input field for each direction
+	UINT8				m_current;				// current value
+	UINT8				m_current4way;			// current 4-way value
+	UINT8				m_previous;				// previous value
 };
+DECLARE_ENUM_OPERATORS(digital_joystick::direction_t)
 
 
-/* a single setting for a configuration or DIP switch */
-class input_setting_config
+// ======================> natural_keyboard
+
+// buffer to handle copy/paste/insert of keys
+class natural_keyboard
 {
-	DISABLE_COPYING(input_setting_config);
-	friend class simple_list<input_setting_config>;
+	DISABLE_COPYING(natural_keyboard);
 
 public:
-	input_setting_config(input_field_config &field, input_port_value value, const char *name);
-	input_setting_config *next() const { return m_next; }
+	// construction/destruction
+	natural_keyboard(running_machine &machine);
+
+	// getters and queries
+	running_machine &machine() const { return m_machine; }
+	bool empty() const { return (m_bufbegin == m_bufend); }
+	bool full() const { return ((m_bufend + 1) % m_buffer.count()) == m_bufbegin; }
+	bool can_post() const { return (!m_queue_chars.isnull() || m_keycode_map.count() == 0); }
+	bool is_posting() const { return (!empty() || (!m_charqueue_empty.isnull() && !m_charqueue_empty())); }
+
+	// configuration
+	void configure(ioport_queue_chars_delegate queue_chars, ioport_accept_char_delegate accept_char, ioport_charqueue_empty_delegate charqueue_empty);
+
+	// posting
+	void post(unicode_char ch);
+	void post(const unicode_char *text, size_t length = 0, attotime rate = attotime::zero);
+	void post_utf8(const char *text, size_t length = 0, attotime rate = attotime::zero);
+	void post_coded(const char *text, size_t length = 0, attotime rate = attotime::zero);
 
-	input_port_value			value;			/* value of the bits in this setting */
-	input_condition				condition;		/* condition under which this setting is valid */
-	const char *				name;			/* user-friendly name to display */
+	void frame_update(ioport_port &port, ioport_value &digital);
+	const char *key_name(astring &string, unicode_char ch);
 
 private:
-	input_field_config &		m_field;			/* pointer back to the field that owns us */
-	input_setting_config *		m_next;			/* pointer to next setting in sequence */
+	// internal keyboard code information
+	struct keycode_map_entry
+	{
+		unicode_char	ch;
+		ioport_field *	field[UCHAR_SHIFT_END + 1 - UCHAR_SHIFT_BEGIN];
+	};
+
+	// internal helpers
+	void build_codes(ioport_manager &manager);
+	bool can_post_directly(unicode_char ch);
+	bool can_post_alternate(unicode_char ch);
+	attotime choose_delay(unicode_char ch);
+	void internal_post(unicode_char ch);
+	void timer(void *ptr, int param);
+	const char *unicode_to_string(astring &buffer, unicode_char ch);
+	const keycode_map_entry *find_code(unicode_char ch) const;
+
+	// debugger helpers
+	static void execute_input(running_machine &machine, int ref, int params, const char *param[]);
+	static void execute_dumpkbd(running_machine &machine, int ref, int params, const char *param[]);
+
+	// internal state
+	running_machine &		m_machine;				// reference to our machine
+	UINT32					m_bufbegin;				// index of starting character
+	UINT32					m_bufend;				// index of ending character
+	dynamic_array<unicode_char> m_buffer;			// actual buffer
+	bool					m_status_keydown;		// current keydown status
+	bool					m_last_cr;				// was the last char a CR?
+	emu_timer *				m_timer;				// timer for posting characters
+	attotime				m_current_rate;			// current rate for posting
+	ioport_queue_chars_delegate m_queue_chars;		// queue characters callback
+	ioport_accept_char_delegate m_accept_char;		// accept character callback
+	ioport_charqueue_empty_delegate m_charqueue_empty; // character queue empty callback
+	dynamic_array<keycode_map_entry> m_keycode_map;	// keycode map
 };
 
 
-/* a mapping from a bit to a physical DIP switch description */
-class input_field_diplocation
-{
-	DISABLE_COPYING(input_field_diplocation);
-	friend class simple_list<input_field_diplocation>;
+// ======================> ioport_condition
 
+// encapsulates a condition on a port field or setting
+class ioport_condition
+{
 public:
-	input_field_diplocation(const char *string, UINT8 swnum, bool invert);
-	input_field_diplocation *next() const { return m_next; }
+	// condition types
+	enum condition_t
+	{
+		ALWAYS = 0,
+		EQUALS,
+		NOTEQUALS,
+		GREATERTHAN,
+		NOTGREATERTHAN,
+		LESSTHAN,
+		NOTLESSTHAN
+	};
+
+	// construction/destruction
+	ioport_condition() { reset(); }
+	ioport_condition(condition_t condition, const char *tag, ioport_value mask, ioport_value value) { set(condition, tag, mask, value); }
+
+	// getters
+	const char *tag() const { return m_tag; }
 
-	astring						swname;			/* name of the physical DIP switch */
-	UINT8						swnum;			/* physical switch number */
-	bool						invert;			/* is this an active-high DIP? */
+	// operators
+	bool operator==(const ioport_condition &rhs) const { return (m_mask == rhs.m_mask && m_value == rhs.m_value && m_condition == rhs.m_condition && strcmp(m_tag, rhs.m_tag) == 0); }
+	bool eval(device_t &device) const;
+	bool none() const { return (m_condition == ALWAYS); }
+
+	// configuration
+	void reset() { set(ALWAYS, NULL, 0, 0); }
+	void set(condition_t condition, const char *tag, ioport_value mask, ioport_value value)
+	{
+		m_condition = condition;
+		m_tag = tag;
+		m_mask = mask;
+		m_value = value;
+	}
 
 private:
-	input_field_diplocation *	m_next;			/* pointer to the next bit */
+	// internal state
+	condition_t		m_condition;	// condition to use
+	const char *	m_tag;			// tag of port whose condition is to be tested
+	ioport_value	m_mask;			// mask to apply to the port
+	ioport_value	m_value;		// value to compare against
 };
 
 
-/* a single bitfield within an input port */
-class input_field_config
+// ======================> ioport_setting
+
+// a single setting for a configuration or DIP switch
+class ioport_setting
 {
-	DISABLE_COPYING(input_field_config);
-	friend class simple_list<input_field_config>;
+	DISABLE_COPYING(ioport_setting);
+	friend class simple_list<ioport_setting>;
 
 public:
-	input_field_config(input_port_config &port, int type, input_port_value defvalue, input_port_value maskbits, const char *name = NULL);
+	// construction/destruction
+	ioport_setting(ioport_field &field, ioport_value value, const char *name);
 
-	input_field_config *next() const { return m_next; }
-	input_port_config &port() const { return m_port; }
+	// getters
+	ioport_setting *next() const { return m_next; }
+	ioport_field &field() const { return m_field; }
+	device_t &device() const;
 	running_machine &machine() const;
-	simple_list<input_setting_config> &settinglist() { return m_settinglist; }
-	const simple_list<input_setting_config> &settinglist() const { return m_settinglist; }
-	simple_list<input_field_diplocation> &diploclist() { return m_diploclist; }
-	int modcount() const { return m_modcount; }
-
-	/* generally-applicable data */
-	input_port_value			mask;			/* mask of bits belonging to the field */
-	input_port_value			defvalue;		/* default value of these bits */
-	input_condition				condition;		/* condition under which this field is relevant */
-	UINT32						type;			/* IPT_* type for this port */
-	UINT8						player;			/* player number (0-based) */
-	UINT32						flags;			/* combination of FIELD_FLAG_* and ANALOG_FLAG_* above */
-	UINT8						impulse;		/* number of frames before reverting to defvalue */
-	const char *				name;			/* user-friendly name to display */
-	input_seq					seq[SEQ_TYPE_TOTAL];/* sequences of all types */
-	input_field_read_delegate	read;			/* read callback routine */
-	void *						read_param;		/* parameter for read callback routine */
-	const char *				read_device;	/* parameter for read callback routine */
-	input_field_write_delegate	write;			/* write callback routine */
-	void *						write_param;	/* parameter for write callback routine */
-	const char *				write_device;	/* parameter for write callback routine */
-
-	/* data relevant to analog control types */
-	INT32						min;			/* minimum value for absolute axes */
-	INT32						max;			/* maximum value for absolute axes */
-	INT32						sensitivity;	/* sensitivity (100=normal) */
-	INT32						delta;			/* delta to apply each frame a digital inc/dec key is pressed */
-	INT32						centerdelta;	/* delta to apply each frame no digital inputs are pressed */
-	UINT8						crossaxis;		/* crosshair axis */
-	double						crossscale;		/* crosshair scale */
-	double						crossoffset;	/* crosshair offset */
-	double						crossaltaxis;	/* crosshair alternate axis value */
-	input_field_crossmap_delegate crossmapper;	/* crosshair mapping function */
-	const char *				crossmapper_device;	/* parameter for write callback routine */
-	UINT16						full_turn_count;/* number of optical counts for 1 full turn of the original control */
-	const input_port_value *	remap_table;	/* pointer to an array that remaps the port value */
-
-	/* data relevant to other specific types */
-	UINT8						way;			/* digital joystick 2/4/8-way descriptions */
-	unicode_char				chars[3];		/* (MESS-specific) unicode key data */
+	ioport_value value() const { return m_value; }
+	ioport_condition &condition() { return m_condition; }
+	const char *name() const { return m_name; }
 
-	/* this field is only valid if the device is live */
-	input_field_state *			state;			/* live state of field (NULL if not live) */
+	// helpers
+	bool enabled() { return m_condition.eval(device()); }
 
 private:
-	input_field_config *		m_next;				/* pointer to next field in sequence */
-	input_port_config &			m_port;				/* pointer back to the port that owns us */
-	int							m_modcount;
-	simple_list<input_setting_config> m_settinglist;	/* list of input_setting_configs */
-	simple_list<input_field_diplocation> m_diploclist;	/* list of locations for various bits */
+	// internal state
+	ioport_setting *	m_next;				// pointer to next setting in sequence
+	ioport_field &		m_field;			// pointer back to the field that owns us
+	ioport_value		m_value;			// value of the bits in this setting
+	const char *		m_name;				// user-friendly name to display
+	ioport_condition	m_condition;		// condition under which this setting is valid
 };
 
 
-/* user-controllable settings for a field */
-typedef struct _input_field_user_settings input_field_user_settings;
-struct _input_field_user_settings
-{
-	input_port_value			value;			/* for DIP switches */
-	input_seq					seq[SEQ_TYPE_TOTAL];/* sequences of all types */
-	INT32						sensitivity;	/* for analog controls */
-	INT32						delta;			/* for analog controls */
-	INT32						centerdelta;	/* for analog controls */
-	UINT8						reverse;		/* for analog controls */
-};
+// ======================> ioport_diplocation
+
+// a mapping from a bit to a physical DIP switch description
+class ioport_diplocation
+{
+	DISABLE_COPYING(ioport_diplocation);
+	friend class simple_list<ioport_diplocation>;
+
+public:
+	// construction/destruction
+	ioport_diplocation(const char *name, UINT8 swnum, bool invert);
 
-/* device defined default input settings */
-typedef struct _input_device_default input_device_default;
-struct _input_device_default
-{
-	const char *				tag;			/* tag of port to update */
-	input_port_value			mask;			/* mask to apply to the port */
-	input_port_value			defvalue;		/* new default value */
+	// getters
+	ioport_diplocation *next() const { return m_next; }
+	const char *name() const { return m_name; }
+	UINT8 number() const { return m_number; }
+	bool inverted() const { return m_invert; }
+
+private:
+	ioport_diplocation *	m_next;			// pointer to the next bit
+	astring					m_name;			// name of the physical DIP switch
+	UINT8					m_number;		// physical switch number
+	bool					m_invert;		// is this an active-high DIP?
 };
 
-/* a single input port configuration */
-class input_port_config
+
+// ======================> ioport_field
+
+// a single bitfield within an input port
+class ioport_field
 {
-	DISABLE_COPYING(input_port_config);
-	friend class simple_list<input_port_config>;
+	DISABLE_COPYING(ioport_field);
+	friend class simple_list<ioport_field>;
+	friend class ioport_configurer;
+	friend class dynamic_field;
+
+	// flags for ioport_fields
+	static const int FIELD_FLAG_UNUSED = 0x01;		// set if this field is unused but relevant to other games on the same hw
+	static const int FIELD_FLAG_COCKTAIL = 0x02;	// set if this field is relevant only for cocktail cabinets
+	static const int FIELD_FLAG_TOGGLE = 0x04;		// set if this field should behave as a toggle
+	static const int FIELD_FLAG_ROTATED = 0x08;		// set if this field represents a rotated control
+	static const int ANALOG_FLAG_REVERSE = 0x10;	// analog only: reverse the sense of the axis
+	static const int ANALOG_FLAG_RESET = 0x20;		// analog only: always preload in->default for relative axes, returning only deltas
+	static const int ANALOG_FLAG_WRAPS = 0x40;		// analog only: positional count wraps around
+	static const int ANALOG_FLAG_INVERT = 0x80;		// analog only: bitwise invert bits
 
 public:
 	// construction/destruction
-	input_port_config(device_t &owner, const char *tag);
+	ioport_field(ioport_port &port, ioport_type type, ioport_value defvalue, ioport_value maskbits, const char *name = NULL);
+	~ioport_field();
 
 	// getters
-	input_port_config *next() const { return m_next; }
-	device_t &owner() const { return m_owner; }
+	ioport_field *next() const { return m_next; }
+	ioport_port &port() const { return m_port; }
+	device_t &device() const;
+	ioport_manager &manager() const;
 	running_machine &machine() const;
-	input_field_config *first_field() const { return m_fieldlist.first(); }
-	simple_list<input_field_config> &fieldlist() { return m_fieldlist; }
-	const char *tag() const { return m_tag; }
 	int modcount() const { return m_modcount; }
+	ioport_setting *first_setting() const { return m_settinglist.first(); }
+	ioport_diplocation *first_diplocation() const { return m_diploclist.first(); }
 
-	void bump_modcount() { m_modcount++; }
-
-	void collapse_fields(astring &errorbuf);
-
-	/* these fields are only valid if the port is live */
-	input_port_state *			state;			/* live state of port (NULL if not live) */
-	input_port_value			active;			/* mask of active bits in the port */
+	ioport_value mask() const { return m_mask; }
+	ioport_value defvalue() const { return m_defvalue; }
+	ioport_condition &condition() { return m_condition; }
+	ioport_type type() const { return m_type; }
+	UINT8 player() const { return m_player; }
+
+	bool unused() const { return ((m_flags & FIELD_FLAG_UNUSED) != 0); }
+	bool cocktail() const { return ((m_flags & FIELD_FLAG_COCKTAIL) != 0); }
+	bool toggle() const { return ((m_flags & FIELD_FLAG_TOGGLE) != 0); }
+	bool rotated() const { return ((m_flags & FIELD_FLAG_ROTATED) != 0); }
+	bool analog_reverse() const { return ((m_flags & ANALOG_FLAG_REVERSE) != 0); }
+	bool analog_reset() const { return ((m_flags & ANALOG_FLAG_RESET) != 0); }
+	bool analog_wraps() const { return ((m_flags & ANALOG_FLAG_WRAPS) != 0); }
+	bool analog_invert() const { return ((m_flags & ANALOG_FLAG_INVERT) != 0); }
+
+	UINT8 impulse() const { return m_impulse; }
+	const char *name() const;
+	const char *specific_name() const { return m_name; }
+	const input_seq &seq(input_seq_type seqtype = SEQ_TYPE_STANDARD) const;
+	const input_seq &defseq(input_seq_type seqtype = SEQ_TYPE_STANDARD) const;
+	const input_seq &defseq_unresolved(input_seq_type seqtype = SEQ_TYPE_STANDARD) const { return m_seq[seqtype]; }
+	bool has_dynamic_read() const { return !m_read.isnull(); }
+	bool has_dynamic_write() const { return !m_write.isnull(); }
+
+	ioport_value minval() const { return m_min; }
+	ioport_value maxval() const { return m_max; }
+	INT32 sensitivity() const { return m_sensitivity; }
+	INT32 delta() const { return m_delta; }
+	INT32 centerdelta() const { return m_centerdelta; }
+	crosshair_axis_t crosshair_axis() const { return m_crosshair_axis; }
+	double crosshair_scale() const { return m_crosshair_scale; }
+	double crosshair_offset() const { return m_crosshair_offset; }
+	UINT16 full_turn_count() const { return m_full_turn_count; }
+	const ioport_value *remap_table() const { return m_remap_table; }
+
+	UINT8 way() const { return m_way; }
+	unicode_char keyboard_code(int which) const;
+	ioport_field_live &live() const { assert(m_live != NULL); return *m_live; }
+
+	// setters
+	void set_crosshair_scale(double scale) { m_crosshair_scale = scale; }
+	void set_crosshair_offset(double offset) { m_crosshair_offset = offset; }
+
+	// derived getters
+	ioport_type_class type_class() const;
+	bool is_analog() const { return (m_type > IPT_ANALOG_FIRST && m_type < IPT_ANALOG_LAST); }
+	bool is_digital_joystick() const { return (m_type > IPT_DIGITAL_JOYSTICK_FIRST && m_type < IPT_DIGITAL_JOYSTICK_LAST); }
+
+	// additional operations
+	bool enabled() const { return m_condition.eval(device()); }
+	const char *setting_name() const;
+	bool has_previous_setting() const;
+	void select_previous_setting();
+	bool has_next_setting() const;
+	void select_next_setting();
+	void crosshair_position(float &x, float &y, bool &gotx, bool &goty);
+	void init_live_state(analog_field *analog);
+	void frame_update(ioport_value &result, bool mouse_down);
+	void reduce_mask(ioport_value bits_to_remove) { m_mask &= ~bits_to_remove; }
+
+	// user-controllable settings for a field
+	struct user_settings
+	{
+		ioport_value	value;					// for DIP switches
+		input_seq		seq[SEQ_TYPE_TOTAL];	// sequences of all types
+		INT32			sensitivity;			// for analog controls
+		INT32			delta;					// for analog controls
+		INT32			centerdelta;			// for analog controls
+		bool			reverse;				// for analog controls
+	};
+	void get_user_settings(user_settings &settings);
+	void set_user_settings(const user_settings &settings);
 
 private:
-	input_port_config *			m_next;			/* pointer to next port */
-	device_t &					m_owner;			/* associated device, when appropriate */
-	simple_list<input_field_config> m_fieldlist;		/* list of input_field_configs */
-	astring						m_tag;			/* pointer to this port's tag */
-	int							m_modcount;
+	void expand_diplocation(const char *location, astring &errorbuf);
+
+	// internal state
+	ioport_field *				m_next;				// pointer to next field in sequence
+	ioport_port &				m_port;				// reference to the port that owns us
+	ioport_field_live *			m_live;				// live state of field (NULL if not live)
+	int							m_modcount;			// modification count
+	simple_list<ioport_setting> m_settinglist;		// list of input_setting_configs
+	simple_list<ioport_diplocation> m_diploclist;	// list of locations for various bits
+
+	// generally-applicable data
+	ioport_value				m_mask;				// mask of bits belonging to the field
+	ioport_value				m_defvalue;			// default value of these bits
+	ioport_condition			m_condition;		// condition under which this field is relevant
+	ioport_type					m_type;				// IPT_* type for this port
+	UINT8						m_player;			// player number (0-based)
+	UINT32						m_flags;			// combination of FIELD_FLAG_* and ANALOG_FLAG_* above
+	UINT8						m_impulse;			// number of frames before reverting to defvalue
+	const char *				m_name;				// user-friendly name to display
+	input_seq					m_seq[SEQ_TYPE_TOTAL];// sequences of all types
+	ioport_field_read_delegate	m_read;				// read callback routine
+	void *						m_read_param;		// parameter for read callback routine
+	ioport_field_write_delegate	m_write;			// write callback routine
+	void *						m_write_param;		// parameter for write callback routine
+
+	// data relevant to analog control types
+	ioport_value				m_min;				// minimum value for absolute axes
+	ioport_value				m_max;				// maximum value for absolute axes
+	INT32						m_sensitivity;		// sensitivity (100=normal)
+	INT32						m_delta;			// delta to apply each frame a digital inc/dec key is pressed
+	INT32						m_centerdelta;		// delta to apply each frame no digital inputs are pressed
+	crosshair_axis_t			m_crosshair_axis;	// crosshair axis
+	double						m_crosshair_scale;	// crosshair scale
+	double						m_crosshair_offset;	// crosshair offset
+	double						m_crosshair_altaxis;// crosshair alternate axis value
+	ioport_field_crossmap_delegate m_crosshair_mapper; // crosshair mapping function
+	UINT16						m_full_turn_count;	// number of optical counts for 1 full turn of the original control
+	const ioport_value *		m_remap_table;		// pointer to an array that remaps the port value
+
+	// data relevant to other specific types
+	UINT8						m_way;				// digital joystick 2/4/8-way descriptions
+	unicode_char				m_chars[4];			// unicode key data
 };
 
 
-/* describes a fundamental input type, including default input sequences */
-class input_type_entry
+// ======================> ioport_list
+
+// class that holds a list of I/O ports
+class ioport_list : public tagged_list<ioport_port>
 {
-	friend class simple_list<input_type_entry>;
+	DISABLE_COPYING(ioport_list);
 
 public:
-	input_type_entry(UINT32 type, ioport_group group, int player, const char *token, const char *name, input_seq standard);
-	input_type_entry(UINT32 type, ioport_group group, int player, const char *token, const char *name, input_seq standard, input_seq decrement, input_seq increment);
+	// construction/destruction
+	ioport_list(resource_pool &pool = global_resource_pool())
+		: tagged_list<ioport_port>(pool) { }
 
-	input_type_entry *next() const { return m_next; }
+	using tagged_list<ioport_port>::append;
+	void append(device_t &device, astring &errorbuf);
+};
 
-	UINT32						type;			/* IPT_* for this entry */
-	ioport_group				group;			/* which group the port belongs to */
-	UINT8						player;			/* player number (0 is player 1) */
-	const char *				token;			/* token used to store settings */
-	const char *				name;			/* user-friendly name */
-	input_seq					defseq[SEQ_TYPE_TOTAL];/* default input sequence */
-	input_seq					seq[SEQ_TYPE_TOTAL];/* currently configured sequences */
 
-private:
-	input_type_entry *			m_next;			/* next description in the list */
-};
+// ======================> ioport_port
 
+// a single input port configuration
+class ioport_port
+{
+	DISABLE_COPYING(ioport_port);
+	friend class simple_list<ioport_port>;
+	friend class ioport_configurer;
 
-/* header at the front of INP files */
-typedef struct _inp_header inp_header;
-struct _inp_header
-{
-	char						header[8];		/* +00: 8 byte header - must be "MAMEINP\0" */
-	UINT64						basetime;		/* +08: base time of recording */
-	UINT8						majversion;		/* +10: major INP version */
-	UINT8						minversion;		/* +11: minor INP version */
-	UINT8						reserved[2];	/* +12: must be zero */
-	char						gamename[12];	/* +14: game name string, NULL-terminated */
-	char						version[32];	/* +20: system version string, NULL-terminated */
-};
+public:
+	// construction/destruction
+	ioport_port(device_t &owner, const char *tag);
+	~ioport_port();
 
+	// getters
+	ioport_port *next() const { return m_next; }
+	ioport_manager &manager() const;
+	device_t &device() const { return m_device; }
+	running_machine &machine() const;
+	ioport_field *first_field() const { return m_fieldlist.first(); }
+	const char *tag() const { return m_tag; }
+	int modcount() const { return m_modcount; }
+	ioport_value active() const { return m_active; }
+	ioport_value active_safe(ioport_value defval) const { return (this == NULL) ? defval : active(); }
+	ioport_port_live &live() const { assert(m_live != NULL); return *m_live; }
+
+	// read/write to the port
+	ioport_value read();
+	ioport_value read_safe(ioport_value defval) { return (this == NULL) ? defval : read(); }
+	void write(ioport_value value, ioport_value mask = ~0);
+	void write_safe(ioport_value value, ioport_value mask = ~0) { if (this != NULL) write(value, mask); }
 
-struct digital_joystick_state
-{
-	const input_field_config *	field[4];			/* input field for up, down, left, right respectively */
-	UINT8						inuse;				/* is this joystick used? */
-	UINT8						current;			/* current value */
-	UINT8						current4way;		/* current 4-way value */
-	UINT8						previous;			/* previous value */
-};
+	// other operations
+	ioport_field *field(ioport_value mask);
+	void collapse_fields(astring &errorbuf);
+	void frame_update(ioport_field *mouse_field);
+	void init_live_state();
 
-#define DIGITAL_JOYSTICKS_PER_PLAYER	3
+private:
+	void insert_field(ioport_field &newfield, ioport_value &disallowedbits, astring &errorbuf);
 
-#define NUM_SIMUL_KEYS	(UCHAR_SHIFT_END - UCHAR_SHIFT_BEGIN + 1)
-struct inputx_code
-{
-	unicode_char ch;
-	const input_field_config * field[NUM_SIMUL_KEYS];
+	// internal state
+	ioport_port *				m_next;			// pointer to next port
+	device_t &					m_device;		// associated device
+	simple_list<ioport_field>	m_fieldlist;	// list of ioport_fields
+	astring						m_tag;			// copy of this port's tag
+	int							m_modcount;		// modification count
+	ioport_value				m_active;		// mask of active bits in the port
+	ioport_port_live *			m_live;			// live state of port (NULL if not live)
 };
 
-struct key_buffer
-{
-	int begin_pos;
-	int end_pos;
-	unsigned int status_keydown : 1;
-	int size;
-	unicode_char *buffer;
-};
 
-/* private input port state */
+// ======================> ioport_manager
+
+// private input port state
 class ioport_manager
 {
+	DISABLE_COPYING(ioport_manager);
 	friend class device_t;
+	friend class ioport_configurer;
 
 public:
 	// construction/destruction
@@ -929,368 +1237,408 @@
 
 	// getters
 	running_machine &machine() const { return m_machine; }
-	input_port_config *first_port() const { return m_portlist.first(); }
-
-	/* global state */
-	UINT8						safe_to_read;		/* clear at start; set after state is loaded */
-
-	/* types */
-	simple_list<input_type_entry> typelist;		/* list of live type states */
-	input_type_entry *			type_to_entry[__ipt_max][MAX_PLAYERS]; /* map from type/player to type state */
-
-	/* specific special global input states */
-	digital_joystick_state		joystick_info[MAX_PLAYERS][DIGITAL_JOYSTICKS_PER_PLAYER]; /* joystick states */
-
-	/* frame time tracking */
-	attotime					last_frame_time;	/* time of the last frame callback */
-	attoseconds_t				last_delta_nsec;	/* nanoseconds that passed since the previous callback */
-
-	/* playback/record information */
-	emu_file *					record_file;		/* recording file (NULL if not recording) */
-	emu_file *					playback_file;		/* playback file (NULL if not recording) */
-	UINT64						playback_accumulated_speed;/* accumulated speed during playback */
-	UINT32						playback_accumulated_frames;/* accumulated frames during playback */
-
-	/* inputx */
-	inputx_code *codes;
-	key_buffer keybuffer;
-	emu_timer *inputx_timer;
-	int (*queue_chars)(running_machine &machine, const unicode_char *text, size_t text_len);
-	int (*accept_char)(running_machine &machine, unicode_char ch);
-	int (*charqueue_empty)(running_machine &machine);
-	attotime current_rate;
+	ioport_port *first_port() const { return m_portlist.first(); }
+	bool safe_to_read() const { return m_safe_to_read; }
+	natural_keyboard &natkeyboard() { return m_natkeyboard; }
+
+	// type helpers
+	input_type_entry *first_type() const { return m_typelist.first(); }
+	bool type_pressed(ioport_type type, int player = 0);
+	const char *type_name(ioport_type type, UINT8 player);
+	ioport_group type_group(ioport_type type, int player);
+	const input_seq &type_seq(ioport_type type, int player = 0, input_seq_type seqtype = SEQ_TYPE_STANDARD);
+	void set_type_seq(ioport_type type, int player, input_seq_type seqtype, const input_seq &newseq);
+	static bool type_is_analog(ioport_type type) { return (type > IPT_ANALOG_FIRST && type < IPT_ANALOG_LAST); }
+	bool type_class_present(ioport_type_class inputclass);
+
+	// other helpers
+	digital_joystick &digjoystick(int player, int joysticknum);
+	int count_players() const;
+	bool crosshair_position(int player, float &x, float &y);
+	bool has_keyboard() const;
+	void setup_natural_keyboard(ioport_queue_chars_delegate queue_chars, ioport_accept_char_delegate accept_char, ioport_charqueue_empty_delegate charqueue_empty);
+	INT32 frame_interpolate(INT32 oldval, INT32 newval);
+	ioport_type token_to_input_type(const char *string, int &player) const;
+	const char *input_type_to_token(astring &string, ioport_type type, int player);
 
 private:
-	input_port_config *port(const char *tag) const { return m_portlist.find(tag); }
-
-	// internals
-	ioport_list				m_portlist;			// points to a list of input port configurations
+	// internal helpers
+	void init_port_types();
+	void init_autoselect_devices(int type1, int type2, int type3, const char *option, const char *ananame);
+
+	void frame_update_callback();
+	void frame_update();
+
+	ioport_port *port(const char *tag) const { return m_portlist.find(tag); }
+	void exit();
+	input_seq_type token_to_seq_type(const char *string);
+	void update_defaults();
+
+	void load_config(int config_type, xml_data_node *parentnode);
+	void load_remap_table(xml_data_node *parentnode);
+	bool load_default_config(xml_data_node *portnode, int type, int player, const input_seq *newseq);
+	bool load_game_config(xml_data_node *portnode, int type, int player, const input_seq *newseq);
+
+	void save_config(int config_type, xml_data_node *parentnode);
+	void save_sequence(xml_data_node *parentnode, input_seq_type type, ioport_type porttype, const input_seq &seq);
+	bool save_this_input_field_type(ioport_type type);
+	void save_default_inputs(xml_data_node *parentnode);
+	void save_game_inputs(xml_data_node *parentnode);
+
+	template<typename _Type> _Type playback_read(_Type &result);
+	time_t playback_init();
+	void playback_end(const char *message = NULL);
+	void playback_frame(attotime curtime);
+	void playback_port(ioport_port &port);
+
+	template<typename _Type> void record_write(_Type value);
+	void record_init();
+	void record_end(const char *message = NULL);
+	void record_frame(attotime curtime);
+	void record_port(ioport_port &port);
 
 	// internal state
-	running_machine &		m_machine;
+	running_machine &		m_machine;				// reference to owning machine
+	bool					m_safe_to_read;			// clear at start; set after state is loaded
+	ioport_list				m_portlist;				// list of input port configurations
+
+	// types
+	simple_list<input_type_entry> m_typelist;		// list of live type states
+	input_type_entry *		m_type_to_entry[IPT_COUNT][MAX_PLAYERS]; // map from type/player to type state
+
+	// specific special global input states
+	simple_list<digital_joystick> m_joystick_list;	// list of digital joysticks
+	natural_keyboard		m_natkeyboard;			// natural keyboard support
+
+	// frame time tracking
+	attotime				m_last_frame_time;		// time of the last frame callback
+	attoseconds_t			m_last_delta_nsec;		// nanoseconds that passed since the previous callback
+
+	// playback/record information
+	emu_file				m_record_file;			// recording file (NULL if not recording)
+	emu_file				m_playback_file;		// playback file (NULL if not recording)
+	UINT64					m_playback_accumulated_speed; // accumulated speed during playback
+	UINT32					m_playback_accumulated_frames; // accumulated frames during playback
 };
 
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+// ======================> ioport_configurer
 
-/* macro for a read callback function (PORT_CUSTOM) */
-#define CUSTOM_INPUT(name)	input_port_value name(device_t &device, const input_field_config &field, void *param)
-#define CUSTOM_INPUT_MEMBER(name)	input_port_value name(const input_field_config &field, void *param)
-#define DECLARE_CUSTOM_INPUT_MEMBER(name)	input_port_value name(const input_field_config &field, void *param)
-
-/* macro for port write callback functions (PORT_CHANGED) */
-#define INPUT_CHANGED(name)	void name(device_t &device, const input_field_config &field, void *param, input_port_value oldval, input_port_value newval)
-#define INPUT_CHANGED_MEMBER(name)	void name(const input_field_config &field, void *param, input_port_value oldval, input_port_value newval)
-#define DECLARE_INPUT_CHANGED_MEMBER(name)	void name(const input_field_config &field, void *param, input_port_value oldval, input_port_value newval)
-
-/* macro for port changed callback functions (PORT_CROSSHAIR_MAPPER) */
-#define CROSSHAIR_MAPPER(name)	float name(device_t &device, const input_field_config &field, float linear_value)
-#define CROSSHAIR_MAPPER_MEMBER(name)	float name(const input_field_config &field, float linear_value)
-#define DECLARE_CROSSHAIR_MAPPER_MEMBER(name)	float name(const input_field_config &field, float linear_value)
+// class to wrap helper functions
+class ioport_configurer
+{
+public:
+	// construction/destruction
+	ioport_configurer(device_t &owner, ioport_list &portlist, astring &errorbuf);
 
-/* macro for wrapping a default string */
-#define DEF_STR(str_num) ((const char *)INPUT_STRING_##str_num)
+	// static helpers
+	static const char *string_from_token(const char *string);
 
+	// port helpers
+	void port_alloc(const char *tag);
+	void port_modify(const char *tag);
+
+	// field helpers
+	void field_alloc(ioport_type type, ioport_value defval, ioport_value mask, const char *name = NULL);
+	void field_add_char(unicode_char ch);
+	void field_add_code(input_seq_type which, input_code code);
+	void field_set_way(int way) const { m_curfield->m_way = way; }
+	void field_set_rotated() const { m_curfield->m_flags |= ioport_field::FIELD_FLAG_ROTATED; }
+	void field_set_name(const char *name) const { m_curfield->m_name = string_from_token(name); }
+	void field_set_player(int player) const { m_curfield->m_player = player - 1; }
+	void field_set_cocktail() const { m_curfield->m_flags |= ioport_field::FIELD_FLAG_COCKTAIL; field_set_player(2); }
+	void field_set_toggle() const { m_curfield->m_flags |= ioport_field::FIELD_FLAG_TOGGLE; }
+	void field_set_impulse(UINT8 impulse) const { m_curfield->m_impulse = impulse; }
+	void field_set_analog_reverse() const { m_curfield->m_flags |= ioport_field::ANALOG_FLAG_REVERSE; }
+	void field_set_analog_reset() const { m_curfield->m_flags |= ioport_field::ANALOG_FLAG_RESET; }
+	void field_set_unused() const { m_curfield->m_flags |= ioport_field::FIELD_FLAG_UNUSED; }
+	void field_set_min_max(ioport_value minval, ioport_value maxval) const { m_curfield->m_min = minval; m_curfield->m_max = maxval; }
+	void field_set_sensitivity(INT32 sensitivity) const { m_curfield->m_sensitivity = sensitivity; }
+	void field_set_delta(INT32 delta) const { m_curfield->m_centerdelta = m_curfield->m_delta = delta; }
+	void field_set_centerdelta(INT32 delta) const { m_curfield->m_centerdelta = delta; }
+	void field_set_crosshair(crosshair_axis_t axis, double altaxis, double scale, double offset) const { m_curfield->m_crosshair_axis = axis; m_curfield->m_crosshair_altaxis = altaxis; m_curfield->m_crosshair_scale = scale; m_curfield->m_crosshair_offset = offset; }
+	void field_set_crossmapper(ioport_field_crossmap_delegate callback) const { m_curfield->m_crosshair_mapper = callback; }
+	void field_set_full_turn_count(UINT16 count) const { m_curfield->m_full_turn_count = count; }
+	void field_set_analog_wraps() const { m_curfield->m_flags |= ioport_field::ANALOG_FLAG_WRAPS; }
+	void field_set_remap_table(const ioport_value *table) { m_curfield->m_remap_table = table; }
+	void field_set_analog_invert() const { m_curfield->m_flags |= ioport_field::ANALOG_FLAG_INVERT; }
+	void field_set_dynamic_read(ioport_field_read_delegate delegate, void *param = NULL) const { m_curfield->m_read = delegate; m_curfield->m_read_param = param; }
+	void field_set_dynamic_write(ioport_field_write_delegate delegate, void *param = NULL) const { m_curfield->m_write = delegate; m_curfield->m_write_param = param; }
+	void field_set_diplocation(const char *location) const { m_curfield->expand_diplocation(location, m_errorbuf); }
+
+	// setting helpers
+	void setting_alloc(ioport_value value, const char *name);
+
+	// misc helpers
+	void set_condition(ioport_condition::condition_t condition, const char *tag, ioport_value mask, ioport_value value);
+	void onoff_alloc(const char *name, ioport_value defval, ioport_value mask, const char *diplocation);
 
-template<int (*_FunctionPointer)(device_t *)>
-input_port_value ioport_read_line_wrapper(device_t &device, const input_field_config &field, void *param)
-{
-	return (*_FunctionPointer)(&device);
-}
+private:
+	// internal state
+	device_t &			m_owner;
+	ioport_list &		m_portlist;
+	astring &			m_errorbuf;
+
+	ioport_port *		m_curport;
+	ioport_field *		m_curfield;
+	ioport_setting *	m_cursetting;
+};
 
-template<class _FunctionClass, int (_FunctionClass::*_FunctionPointer)()>
-input_port_value ioport_read_line_wrapper(_FunctionClass &device, const input_field_config &field, void *param)
-{
-	return (device.*_FunctionPointer)();
-}
 
-template<void (*_FunctionPointer)(device_t *, int)>
-void ioport_write_line_wrapper(device_t &device, const input_field_config &field, void *param, input_port_value oldval, input_port_value newval)
-{
-	return (*_FunctionPointer)(&device, newval);
-}
 
-template<class _FunctionClass, void (_FunctionClass::*_FunctionPointer)(int)>
-void ioport_write_line_wrapper(_FunctionClass &device, const input_field_config &field, void *param, input_port_value oldval, input_port_value newval)
-{
-	return (device.*_FunctionPointer)(newval);
-}
+//**************************************************************************
+//  MACROS
+//**************************************************************************
 
+#define UCHAR_MAMEKEY(code)	(UCHAR_MAMEKEY_BEGIN + ITEM_ID_##code)
 
+// macro for a read callback function (PORT_CUSTOM)
+#define CUSTOM_INPUT(name)	ioport_value name(device_t &device, ioport_field &field, void *param)
+#define CUSTOM_INPUT_MEMBER(name)	ioport_value name(ioport_field &field, void *param)
+#define DECLARE_CUSTOM_INPUT_MEMBER(name)	ioport_value name(ioport_field &field, void *param)
+
+// macro for port write callback functions (PORT_CHANGED)
+#define INPUT_CHANGED(name)	void name(device_t &device, ioport_field &field, void *param, ioport_value oldval, ioport_value newval)
+#define INPUT_CHANGED_MEMBER(name)	void name(ioport_field &field, void *param, ioport_value oldval, ioport_value newval)
+#define DECLARE_INPUT_CHANGED_MEMBER(name)	void name(ioport_field &field, void *param, ioport_value oldval, ioport_value newval)
+
+// macro for port changed callback functions (PORT_CROSSHAIR_MAPPER)
+#define CROSSHAIR_MAPPER(name)	float name(device_t &device, ioport_field &field, float linear_value)
+#define CROSSHAIR_MAPPER_MEMBER(name)	float name(ioport_field &field, float linear_value)
+#define DECLARE_CROSSHAIR_MAPPER_MEMBER(name)	float name(ioport_field &field, float linear_value)
+
+// macro for wrapping a default string
+#define DEF_STR(str_num) ((const char *)INPUT_STRING_##str_num)
 
-/***************************************************************************
-    MACROS FOR BUILDING INPUT PORTS
-***************************************************************************/
 
-typedef void (*ioport_constructor)(device_t &owner, ioport_list &portlist, astring &errorbuf);
 
-/* so that "0" can be used for unneeded input ports */
+//**************************************************************************
+//  MACROS FOR BUILDING INPUT PORTS
+//**************************************************************************
+
+// so that "0" can be used for unneeded input ports
 #define construct_ioport_0 NULL
 
-/* name of table */
+// name of table
 #define INPUT_PORTS_NAME(_name) construct_ioport_##_name
 
-/* start of table */
+// start of table
 #define INPUT_PORTS_START(_name) \
 ATTR_COLD void INPUT_PORTS_NAME(_name)(device_t &owner, ioport_list &portlist, astring &errorbuf) \
 { \
-	astring fulltag; \
-	input_setting_config *cursetting = NULL; \
-	input_field_config *curfield = NULL; \
-	input_port_config *curport = NULL; \
-	input_port_value maskbits = 0; \
-	(void)cursetting; (void)curfield; (void)curport; (void)maskbits; \
+	ioport_configurer configurer(owner, portlist, errorbuf); \
 
-/* end of table */
+// end of table
 #define INPUT_PORTS_END \
 }
 
-/* aliasing */
+// aliasing
 #define INPUT_PORTS_EXTERN(_name) \
 	extern void INPUT_PORTS_NAME(_name)(device_t &owner, ioport_list &portlist, astring &errorbuf)
 
-/* including */
+// including
 #define PORT_INCLUDE(_name) \
 	INPUT_PORTS_NAME(_name)(owner, portlist, errorbuf); \
 
-/* start of a new input port (with included tag) */
+// start of a new input port (with included tag)
 #define PORT_START(_tag) \
-	curport = ioconfig_alloc_port(portlist, owner, _tag); \
-	curfield = NULL; \
-	cursetting = NULL; \
-	maskbits = 0; \
+	configurer.port_alloc(_tag); \
 
-/* modify an existing port */
+// modify an existing port
 #define PORT_MODIFY(_tag) \
-	curport = ioconfig_modify_port(portlist, owner, _tag); \
-	curfield = NULL; \
-	cursetting = NULL; \
-	maskbits = 0; \
+	configurer.port_modify(_tag); \
 
-/* input bit definition */
+// input bit definition
 #define PORT_BIT(_mask, _default, _type) \
-	curfield = ioconfig_alloc_field(*curport, (_type), (_default), (_mask)); \
-	cursetting = NULL;
+	configurer.field_alloc((_type), (_default), (_mask)); \
 
-#define PORT_SPECIAL_ONOFF(_mask, _default, _strindex) PORT_SPECIAL_ONOFF_DIPLOC(_mask, _default, _strindex, NULL)
+#define PORT_SPECIAL_ONOFF(_mask, _default, _strindex) \
+	PORT_SPECIAL_ONOFF_DIPLOC(_mask, _default, _strindex, NULL)
 
 #define PORT_SPECIAL_ONOFF_DIPLOC(_mask, _default, _strindex, _diploc) \
-	curfield = ioconfig_alloc_onoff(*curport, DEF_STR(_strindex), _default, _mask, _diploc, errorbuf); \
-	cursetting = NULL;
+	configurer.onoff_alloc(DEF_STR(_strindex), _default, _mask, _diploc); \
 
-/* append a code */
+// append a code
 #define PORT_CODE(_code) \
-	ioconfig_add_code(*curfield, SEQ_TYPE_STANDARD, _code);
+	configurer.field_add_code(SEQ_TYPE_STANDARD, _code);
 
 #define PORT_CODE_DEC(_code) \
-	ioconfig_add_code(*curfield, SEQ_TYPE_DECREMENT, _code);
+	configurer.field_add_code(SEQ_TYPE_DECREMENT, _code);
 
 #define PORT_CODE_INC(_code) \
-	ioconfig_add_code(*curfield, SEQ_TYPE_INCREMENT, _code);
+	configurer.field_add_code(SEQ_TYPE_INCREMENT, _code);
 
-/* joystick flags */
+// joystick flags
 #define PORT_2WAY \
-	curfield->way = 2;
+	configurer.field_set_way(2);
 
 #define PORT_4WAY \
-	curfield->way = 4;
+	configurer.field_set_way(4);
 
 #define PORT_8WAY \
-	curfield->way = 8;
+	configurer.field_set_way(8);
 
 #define PORT_16WAY \
-	curfield->way = 16;
+	configurer.field_set_way(16);
 
 #define PORT_ROTATED \
-	curfield->flags |= FIELD_FLAG_ROTATED
+	configurer.field_set_rotated();
 
-/* general flags */
+// general flags
 #define PORT_NAME(_name) \
-	curfield->name = input_port_string_from_token(_name);
+	configurer.field_set_name(_name);
 
 #define PORT_PLAYER(_player) \
-	curfield->player = (_player) - 1;
+	configurer.field_set_player(_player);
 
 #define PORT_COCKTAIL \
-	curfield->flags |= FIELD_FLAG_COCKTAIL; \
-	curfield->player = 1;
+	configurer.field_set_cocktail();
 
 #define PORT_TOGGLE \
-	curfield->flags |= FIELD_FLAG_TOGGLE;
+	configurer.field_set_toggle();
 
 #define PORT_IMPULSE(_duration) \
-	curfield->impulse = _duration;
+	configurer.field_set_impulse(_duration);
 
 #define PORT_REVERSE \
-	curfield->flags |= ANALOG_FLAG_REVERSE;
+	configurer.field_set_analog_reverse();
 
 #define PORT_RESET \
-	curfield->flags |= ANALOG_FLAG_RESET;
+	configurer.field_set_analog_reset();
 
 #define PORT_UNUSED \
-	curfield->flags |= FIELD_FLAG_UNUSED;
+	configurer.field_set_unused();
 
-/* analog settings */
-/* if this macro is not used, the minimum defaluts to 0 and maximum defaults to the mask value */
+// analog settings
+// if this macro is not used, the minimum defaluts to 0 and maximum defaults to the mask value
 #define PORT_MINMAX(_min, _max) \
-	curfield->min = _min; \
-	curfield->max = _max;
+	configurer.field_set_min_max(_min, _max);
 
 #define PORT_SENSITIVITY(_sensitivity) \
-	curfield->sensitivity = _sensitivity;
+	configurer.field_set_sensitivity(_sensitivity);
 
 #define PORT_KEYDELTA(_delta) \
-	curfield->delta = curfield->centerdelta = _delta;
+	configurer.field_set_delta(_delta); \
 
-/* note that PORT_CENTERDELTA must appear after PORT_KEYDELTA */
+// note that PORT_CENTERDELTA must appear after PORT_KEYDELTA
 #define PORT_CENTERDELTA(_delta) \
-	curfield->centerdelta = _delta;
+	configurer.field_set_centerdelta(_delta);
 
 #define PORT_CROSSHAIR(axis, scale, offset, altaxis) \
-	curfield->crossaxis = CROSSHAIR_AXIS_##axis; \
-	curfield->crossaltaxis = altaxis; \
-	curfield->crossscale = scale; \
-	curfield->crossoffset = offset;
+	configurer.field_set_crosshair(CROSSHAIR_AXIS_##axis, altaxis, scale, offset);
 
 #define PORT_CROSSHAIR_MAPPER(_callback) \
-	curfield->crossmapper = input_field_crossmap_delegate(_callback, #_callback, (device_t *)NULL); \
-	curfield->crossmapper_device = DEVICE_SELF;
+	configurer.field_set_crossmapper(ioport_field_crossmap_delegate(_callback, #_callback, DEVICE_SELF, (device_t *)NULL));
 
 #define PORT_CROSSHAIR_MAPPER_MEMBER(_device, _class, _member) \
-	curfield->crossmapper = input_field_crossmap_delegate(&_class::_member, #_class "::" #_member, (_class *)NULL); \
-	curfield->crossmapper_device = _device;
+	configurer.field_set_crossmapper(ioport_field_crossmap_delegate(&_class::_member, #_class "::" #_member, _device, (_class *)NULL));
 
-/* how many optical counts for 1 full turn of the control */
+// how many optical counts for 1 full turn of the control
 #define PORT_FULL_TURN_COUNT(_count) \
-	curfield->full_turn_count = _count;
+	configurer.field_set_full_turn_count(_count);
 
-/* positional controls can be binary or 1 of X */
-/* 1 of X not completed yet */
-/* if it is specified as PORT_REMAP_TABLE then it is binary, but remapped */
-/* otherwise it is binary */
+// positional controls can be binary or 1 of X
+// 1 of X not completed yet
+// if it is specified as PORT_REMAP_TABLE then it is binary, but remapped
+// otherwise it is binary
 #define PORT_POSITIONS(_positions) \
-	curfield->max = _positions;
+	configurer.field_set_min_max(0, _positions);
 
-/* positional control wraps at min/max */
+// positional control wraps at min/max
 #define PORT_WRAPS \
-	curfield->flags |= ANALOG_FLAG_WRAPS;
+	configurer.field_set_analog_wraps();
 
-/* positional control uses this remap table */
+// positional control uses this remap table
 #define PORT_REMAP_TABLE(_table) \
-	curfield->remap_table = _table;
+	configurer.field_set_remap_table(_table);
 
-/* positional control bits are active low */
+// positional control bits are active low
 #define PORT_INVERT \
-	curfield->flags |= ANALOG_FLAG_INVERT;
+	configurer.field_set_analog_invert();
 
-/* read callbacks */
+// read callbacks
 #define PORT_CUSTOM(_callback, _param) \
-	curfield->read = input_field_read_delegate(_callback, #_callback, (device_t *)NULL); \
-	curfield->read_param = (void *)(_param); \
-	curfield->read_device = DEVICE_SELF;
+	configurer.field_set_dynamic_read(ioport_field_read_delegate(_callback, #_callback, DEVICE_SELF, (device_t *)NULL), (void *)(_param));
 
 #define PORT_CUSTOM_MEMBER(_device, _class, _member, _param) \
-	curfield->read = input_field_read_delegate(&_class::_member, #_class "::" #_member, (_class *)NULL); \
-	curfield->read_param = (void *)(_param); \
-	curfield->read_device = (_device);
+	configurer.field_set_dynamic_read(ioport_field_read_delegate(&_class::_member, #_class "::" #_member, _device, (_class *)NULL), (void *)(_param));
 
-/* write callbacks */
+// write callbacks
 #define PORT_CHANGED(_callback, _param) \
-	curfield->write = input_field_write_delegate(_callback, #_callback, (device_t *)NULL); \
-	curfield->write_param = (void *)(_param); \
-	curfield->write_device = DEVICE_SELF;
+	configurer.field_set_dynamic_write(ioport_field_write_delegate(_callback, #_callback, DEVICE_SELF, (device_t *)NULL), (void *)(_param));
 
 #define PORT_CHANGED_MEMBER(_device, _class, _member, _param) \
-	curfield->write = input_field_write_delegate(&_class::_member, #_class "::" #_member, (_class *)NULL); \
-	curfield->write_param = (void *)(_param); \
-	curfield->write_device = (_device);
+	configurer.field_set_dynamic_write(ioport_field_write_delegate(&_class::_member, #_class "::" #_member, _device, (_class *)NULL), (void *)(_param));
 
-/* input device handler */
+// input device handler
 #define PORT_READ_LINE_DEVICE(_device, _read_line_device) \
-	curfield->read = input_field_read_delegate(&ioport_read_line_wrapper<_read_line_device>, #_read_line_device, (device_t *)NULL); \
-	curfield->read_param = NULL; \
-	curfield->read_device = _device;
+	configurer.field_set_dynamic_read(ioport_field_read_delegate(&ioport_read_line_wrapper<_read_line_device>, #_read_line_device, _device, (device_t *)NULL));
 
 #define PORT_READ_LINE_DEVICE_MEMBER(_device, _class, _member) \
-	curfield->read = input_field_read_delegate(&ioport_read_line_wrapper<_class, &_class::_member>, #_class "::" #_member, (_class *)NULL); \
-	curfield->read_param = NULL; \
-	curfield->read_device = _device;
+	configurer.field_set_dynamic_read(ioport_field_read_delegate(&ioport_read_line_wrapper<_class, &_class::_member>, #_class "::" #_member, _device, (_class *)NULL));
 
-/* output device handler */
+// output device handler
 #define PORT_WRITE_LINE_DEVICE(_device, _write_line_device) \
-	curfield->write = input_field_write_delegate(&ioport_write_line_wrapper<_write_line_device>, #_write_line_device, (device_t *)NULL); \
-	curfield->write_param = NULL; \
-	curfield->write_device = _device;
+	configurer.field_set_dynamic_write(ioport_field_write_delegate(&ioport_write_line_wrapper<_write_line_device>, #_write_line_device, _device, (device_t *)NULL));
 
 #define PORT_WRITE_LINE_DEVICE_MEMBER(_device, _class, _member) \
-	curfield->write = input_field_write_delegate(&ioport_write_line_wrapper<_class, &_class::_member>, #_class "::" #_member, (_class *)NULL); \
-	curfield->write_param = NULL; \
-	curfield->write_device = _device;
+	configurer.field_set_dynamic_write(ioport_field_write_delegate(&ioport_write_line_wrapper<_class, &_class::_member>, #_class "::" #_member, _device, (_class *)NULL));
 
-/* dip switch definition */
+// dip switch definition
 #define PORT_DIPNAME(_mask, _default, _name) \
-	curfield = ioconfig_alloc_field(*curport, IPT_DIPSWITCH, (_default), (_mask), (_name)); \
-	cursetting = NULL;
+	configurer.field_alloc(IPT_DIPSWITCH, (_default), (_mask), (_name)); \
 
 #define PORT_DIPSETTING(_default, _name) \
-	cursetting = ioconfig_alloc_setting(*curfield, (_default) & curfield->mask, (_name));
+	configurer.setting_alloc((_default), (_name)); \
 
-/* physical location, of the form: name:[!]sw,[name:][!]sw,... */
-/* note that these are specified LSB-first */
+// physical location, of the form: name:[!]sw,[name:][!]sw,...
+// note that these are specified LSB-first
 #define PORT_DIPLOCATION(_location) \
-	diplocation_list_alloc(*curfield, _location, errorbuf);
+	configurer.field_set_diplocation(_location); \
 
-/* conditionals for dip switch settings */
+// conditionals for dip switch settings
 #define PORT_CONDITION(_tag, _mask, _condition, _value) \
-{ \
-	input_condition &condition = (cursetting != NULL) ? cursetting->condition : curfield->condition; \
-	condition.tag = (_tag); \
-	condition.mask = (_mask); \
-	condition.condition = (_condition); \
-	condition.value = (_value); \
-}
+	configurer.set_condition(ioport_condition::_condition, _tag, _mask, _value); \
 
-/* analog adjuster definition */
+// analog adjuster definition
 #define PORT_ADJUSTER(_default, _name) \
-	curfield = ioconfig_alloc_field(*curport, IPT_ADJUSTER, (_default), 0xff, (_name)); \
-	cursetting = NULL; \
+	configurer.field_alloc(IPT_ADJUSTER, (_default), 0xff, (_name)); \
 
-/* config definition */
+// config definition
 #define PORT_CONFNAME(_mask, _default, _name) \
-	curfield = ioconfig_alloc_field(*curport, IPT_CONFIG, (_default), (_mask), (_name)); \
-	cursetting = NULL; \
+	configurer.field_alloc(IPT_CONFIG, (_default), (_mask), (_name)); \
 
 #define PORT_CONFSETTING(_default, _name) \
-	cursetting = ioconfig_alloc_setting(*curfield, (_default) & curfield->mask, (_name));
+	configurer.setting_alloc((_default), (_name));
 
-/* keyboard chars */
+// keyboard chars
 #define PORT_CHAR(_ch) \
-	ioconfig_field_add_char(*curfield, _ch, errorbuf);
+	configurer.field_add_char(_ch);
 
 
-/* name of table */
+// name of table
 #define DEVICE_INPUT_DEFAULTS_NAME(_name) device_iptdef_##_name
 
 #define device_iptdef_0 NULL
 #define device_iptdef___null NULL
 
-/* start of table */
+// start of table
 #define DEVICE_INPUT_DEFAULTS_START(_name) \
 	const input_device_default DEVICE_INPUT_DEFAULTS_NAME(_name)[] = {
 
-/* end of table */
+// end of table
 #define DEVICE_INPUT_DEFAULTS(_tag,_mask,_defval) \
 	{ _tag ,_mask, _defval }, \
 
-/* end of table */
+// end of table
 #define DEVICE_INPUT_DEFAULTS_END \
 	{NULL,0,0} };
 
-/***************************************************************************
-    HELPER MACROS
-***************************************************************************/
+
+
+//**************************************************************************
+//  HELPER MACROS
+//**************************************************************************
 
 #define PORT_DIPUNUSED_DIPLOC(_mask, _default, _diploc) \
 	PORT_SPECIAL_ONOFF_DIPLOC(_mask, _default, Unused, _diploc)
@@ -1313,181 +1661,51 @@
 #define PORT_SERVICE_NO_TOGGLE(_mask, _default) \
 	PORT_BIT( _mask, _mask & _default, IPT_SERVICE ) PORT_NAME( DEF_STR( Service_Mode ))
 
+#define PORT_VBLANK(_screen) \
+	PORT_READ_LINE_DEVICE_MEMBER(_screen, screen_device, vblank_port_read)
 
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-
-/* ----- port configurations ----- */
-
-/* initialize an input port list structure and allocate ports according to the given tokens */
-void input_port_list_init(device_t &device, ioport_list &portlist, astring &errorbuf);
-
-/* return the field that matches the given tag and mask */
-const input_field_config *input_field_by_tag_and_mask(running_machine &machine, const char *tag, input_port_value mask);
-
-
-
-/* ----- accessors for input types ----- */
-
-/* return TRUE if the given type represents an analog control */
-int input_type_is_analog(int type);
-
-/* return the name for the given type/player */
-const char *input_type_name(running_machine &machine, int type, int player);
-
-/* return the group for the given type/player */
-int input_type_group(running_machine &machine, int type, int player);
-
-/* return the global input mapping sequence for the given type/player */
-const input_seq &input_type_seq(running_machine &machine, int type, int player, input_seq_type seqtype);
 
-/* change the global input sequence for the given type/player */
-void input_type_set_seq(running_machine &machine, int type, int player, input_seq_type seqtype, const input_seq *newseq);
+//**************************************************************************
+//  INLINE TEMPLATES
+//**************************************************************************
 
-/* return TRUE if the sequence for the given input type/player is pressed */
-int input_type_pressed(running_machine &machine, int type, int player);
-
-/* return the list of default mappings */
-const simple_list<input_type_entry> &input_type_list(running_machine &machine);
-
-
-
-/* ----- accessors for input fields ----- */
-
-/* return the expanded string name of the field */
-const char *input_field_name(const input_field_config *field);
-
-/* return the input sequence for the given input field */
-const input_seq &input_field_seq(const input_field_config *field, input_seq_type seqtype);
-
-/* return the current settings for the given input field */
-void input_field_get_user_settings(const input_field_config *field, input_field_user_settings *settings);
-
-/* modify the current settings for the given input field */
-void input_field_set_user_settings(const input_field_config *field, const input_field_user_settings *settings);
-
-/* return the expanded setting name for a field */
-const char *input_field_setting_name(const input_field_config *field);
-
-/* return TRUE if the given field has a "previous" setting */
-int input_field_has_previous_setting(const input_field_config *field);
-
-/* select the previous item for a DIP switch or configuration field */
-void input_field_select_previous_setting(const input_field_config *field);
-
-/* return TRUE if the given field has a "next" setting */
-int input_field_has_next_setting(const input_field_config *field);
-
-/* select the next item for a DIP switch or configuration field */
-void input_field_select_next_setting(const input_field_config *field);
-
-
-/* ----- port checking ----- */
-
-/* return whether an input port exists */
-bool input_port_exists(running_machine &machine, const char *tag);
-
-/* return a bitmask of which bits of an input port are active (i.e. not unused or unknown) */
-input_port_value input_port_active(running_machine &machine, const char *tag);
-
-/* return a bitmask of which bits of an input port are active (i.e. not unused or unknown), or a default value if the port does not exist */
-input_port_value input_port_active_safe(running_machine &machine, const char *tag, input_port_value defvalue);
-
-
-/* ----- port reading ----- */
-
-/* return the value of an input port */
-input_port_value input_port_read_direct(const input_port_config *port);
-
-/* return the value of an input port specified by tag */
-input_port_value input_port_read(running_machine &machine, const char *tag);
-
-/* return the value of a device input port specified by tag */
-input_port_value input_port_read(device_t &device, const char *tag);
-
-/* return the value of an input port specified by tag, or a default value if the port does not exist */
-input_port_value input_port_read_safe(running_machine &machine, const char *tag, input_port_value defvalue);
-
-/* return the extracted crosshair values for the given player */
-int input_port_get_crosshair_position(running_machine &machine, int player, float *x, float *y);
-
-/* force an update to the input port values based on current conditions */
-void input_port_update_defaults(running_machine &machine);
-
-
-
-/* ----- port writing ----- */
-
-/* write a value to a port */
-void input_port_write_direct(const input_port_config *port, input_port_value value, input_port_value mask);
-
-/* write a value to a port specified by tag */
-void input_port_write(running_machine &machine, const char *tag, input_port_value value, input_port_value mask);
-
-/* write a value to a port, ignore if the port does not exist */
-void input_port_write_safe(running_machine &machine, const char *tag, input_port_value value, input_port_value mask);
-
-
-
-/* ----- misc helper functions ----- */
-
-/* return the TRUE if the given condition attached is true */
-int input_condition_true(running_machine &machine, const input_condition *condition,device_t &owner);
-
-/* convert an input_port_token to a default string */
-const char *input_port_string_from_token(const char *token);
-
-/* return TRUE if machine use full keyboard emulation */
-int input_machine_has_keyboard(running_machine &machine);
-
-/* these are called by the core; they should not be called from FEs */
-void inputx_init(running_machine &machine);
-
-/* called by drivers to setup natural keyboard support */
-void inputx_setup_natural_keyboard(running_machine &machine,
-	int (*queue_chars)(running_machine &machine, const unicode_char *text, size_t text_len),
-	int (*accept_char)(running_machine &machine, unicode_char ch),
-	int (*charqueue_empty)(running_machine &machine));
-
-/* validity checks */
-int validate_natural_keyboard_statics(void);
-
-/* these can be called from FEs */
-int inputx_can_post(running_machine &machine);
-
-/* various posting functions; can be called from FEs */
-void inputx_postc(running_machine &machine, unicode_char ch);
-void inputx_post_utf8(running_machine &machine, const char *text);
-void inputx_post_utf8_rate(running_machine &machine, const char *text, attotime rate);
-int inputx_is_posting(running_machine &machine);
+template<int (*_FunctionPointer)(device_t *)>
+ioport_value ioport_read_line_wrapper(device_t &device, ioport_field &field, void *param)
+{
+	return (*_FunctionPointer)(&device);
+}
 
-/* miscellaneous functions */
-int input_classify_port(const input_field_config *field);
-int input_has_input_class(running_machine &machine, int inputclass);
-int input_player_number(const input_field_config *field);
-int input_count_players(running_machine &machine);
+template<class _FunctionClass, int (_FunctionClass::*_FunctionPointer)()>
+ioport_value ioport_read_line_wrapper(_FunctionClass &device, ioport_field &field, void *param)
+{
+	return (device.*_FunctionPointer)();
+}
 
+template<void (*_FunctionPointer)(device_t *, int)>
+void ioport_write_line_wrapper(device_t &device, ioport_field &field, void *param, ioport_value oldval, ioport_value newval)
+{
+	return (*_FunctionPointer)(&device, newval);
+}
 
-inline running_machine &input_field_config::machine() const
+template<class _FunctionClass, void (_FunctionClass::*_FunctionPointer)(int)>
+void ioport_write_line_wrapper(_FunctionClass &device, ioport_field &field, void *param, ioport_value oldval, ioport_value newval)
 {
-	return m_port.machine();
+	return (device.*_FunctionPointer)(newval);
 }
 
 
-// temporary construction helpers
-void field_config_insert(input_field_config &newfield, input_port_value &disallowedbits, astring &errorbuf);
-void diplocation_list_alloc(input_field_config &field, const char *location, astring &errorbuf);
 
+//**************************************************************************
+//  INLINE FUNCITONS
+//**************************************************************************
+
+inline ioport_manager &ioport_field::manager() const { return m_port.manager(); }
+inline device_t &ioport_field::device() const { return m_port.device(); }
+inline running_machine &ioport_field::machine() const { return m_port.machine(); }
+
+inline device_t &ioport_setting::device() const { return m_field.device(); }
+inline running_machine &ioport_setting::machine() const { return m_field.machine(); }
 
-input_port_config *ioconfig_alloc_port(ioport_list &portlist, device_t &device, const char *tag);
-input_port_config *ioconfig_modify_port(ioport_list &portlist, device_t &device, const char *tag);
-input_field_config *ioconfig_alloc_field(input_port_config &port, int type, input_port_value defval, input_port_value mask, const char *name = NULL);
-input_field_config *ioconfig_alloc_onoff(input_port_config &port, const char *name, input_port_value defval, input_port_value mask, const char *diplocation, astring &errorbuf);
-input_setting_config *ioconfig_alloc_setting(input_field_config &field, input_port_value value, const char *name);
-void ioconfig_field_add_char(input_field_config &field, unicode_char ch, astring &errorbuf);
-void ioconfig_add_code(input_field_config &field, int which, input_code code);
 
-#endif	/* __INPTPORT_H__ */
+#endif	// __INPTPORT_H__ */
diff -Nru src-old/emu/machine/6551acia.c src/emu/machine/6551acia.c
--- src-old/emu/machine/6551acia.c	2011-09-06 15:39:18.000000000 +0200
+++ src/emu/machine/6551acia.c	2012-05-03 01:07:40.000000000 +0200
@@ -94,7 +94,7 @@
 void acia6551_device::device_start()
 {
 	/* transmit data reg is empty */
-	m_status_register |= (1<<4);
+	m_status_register = (1<<4);
 	m_timer = machine().scheduler().timer_alloc(FUNC(acia_6551_timer_callback), (void *) this);
 
 	transmit_register_reset();
diff -Nru src-old/emu/machine/ctronics.c src/emu/machine/ctronics.c
--- src-old/emu/machine/ctronics.c	2012-02-05 17:14:28.000000000 +0100
+++ src/emu/machine/ctronics.c	2012-04-27 23:23:39.000000000 +0200
@@ -97,6 +97,7 @@
 	m_fault = FALSE;
 	m_busy = TRUE;
 	m_strobe = TRUE;
+	m_ack = FALSE;
 	m_data = 0x00;
 }
 
diff -Nru src-old/emu/machine/ds1302.c src/emu/machine/ds1302.c
--- src-old/emu/machine/ds1302.c	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/ds1302.c	2012-05-07 08:57:50.000000000 +0200
@@ -1,43 +1,65 @@
-/************************************************************
+/**********************************************************************
 
-    DALLAS DS1302
+    Dallas DS1302 Trickle-Charge Timekeeping Chip emulation
 
-    RTC + BACKUP RAM
+    Copyright MESS Team.
+    Visit http://mamedev.org for licensing and usage restrictions.
 
+**********************************************************************/
 
+/*
 
-    Emulation by ElSemi
+    TODO:
 
+    - 12 hour format
+    - synchronize user buffers on falling edge of CE after write
 
-    Missing Features:
-      - Burst Mode
-      - Clock programming (useless)
+*/
 
+#include "ds1302.h"
 
 
-    2009-05 Converted to be a device
 
-************************************************************/
+//**************************************************************************
+//  MACROS / CONSTANTS
+//**************************************************************************
 
+#define LOG 0
 
-#include "emu.h"
-#include "ds1302.h"
-#include "devhelpr.h"
 
+#define RAM_SIZE	0x1f	// 31 bytes
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
 
-INLINE UINT8 convert_to_bcd(int val)
+enum
 {
-	return ((val / 10) << 4) | (val % 10);
-}
+	STATE_COMMAND,
+	STATE_INPUT,
+	STATE_OUTPUT
+};
+
+enum
+{
+	REGISTER_SECONDS = 0,
+	REGISTER_MINUTES,
+	REGISTER_HOUR,
+	REGISTER_DATE,
+	REGISTER_MONTH,
+	REGISTER_DAY,
+	REGISTER_YEAR,
+	REGISTER_CONTROL,
+	REGISTER_TRICKLE
+};
+
+
+#define COMMAND_READ	(m_cmd & 0x01)
+#define COMMAND_RAM		(m_cmd & 0x40)
+#define COMMAND_VALID	(m_cmd & 0x80)
+#define COMMAND_BURST	(((m_cmd >> 1) & 0x1f) == 0x1f)
+#define CLOCK_HALT		(m_reg[REGISTER_SECONDS] & 0x80)
+#define WRITE_PROTECT	(m_reg[REGISTER_CONTROL] & 0x80)
+#define BURST_END		(COMMAND_RAM ? 0x1f : 0x09)
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
 
 //**************************************************************************
 //  LIVE DEVICE
@@ -46,28 +68,43 @@
 // device type definition
 const device_type DS1302 = &device_creator<ds1302_device>;
 
+
 //-------------------------------------------------
 //  ds1302_device - constructor
 //-------------------------------------------------
 
 ds1302_device::ds1302_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
-    : device_t(mconfig, DS1302, "Dallas DS1302 RTC", tag, owner, clock)
+    : device_t(mconfig, DS1302, "Dallas DS1302", tag, owner, clock),
+	  device_rtc_interface(mconfig, *this),
+	  device_nvram_interface(mconfig, *this)
 {
-
 }
 
+
 //-------------------------------------------------
 //  device_start - device-specific startup
 //-------------------------------------------------
 
 void ds1302_device::device_start()
 {
-	save_item(NAME(m_shift_in));
-	save_item(NAME(m_shift_out));
-	save_item(NAME(m_icount));
-	save_item(NAME(m_last_clk));
-	save_item(NAME(m_last_cmd));
-	save_item(NAME(m_sram));
+	// allocate timers
+	m_clock_timer = timer_alloc();
+	m_clock_timer->adjust(attotime::from_hz(clock() / 32768), 0, attotime::from_hz(clock() / 32768));
+
+	for (int i = 0; i < 9; i++)
+		m_reg[i] = 0;
+
+	// state saving
+	save_item(NAME(m_ce));
+	save_item(NAME(m_clk));
+	save_item(NAME(m_io));
+	save_item(NAME(m_state));
+	save_item(NAME(m_bits));
+	save_item(NAME(m_cmd));
+	save_item(NAME(m_data));
+	save_item(NAME(m_addr));
+	save_item(NAME(m_reg));
+	save_item(NAME(m_user));
 }
 
 
@@ -77,139 +114,300 @@
 
 void ds1302_device::device_reset()
 {
-	m_shift_in  = 0;
-	m_shift_out = 0;
-	m_icount    = 0;
-	m_last_clk  = 0;
-	m_last_cmd  = 0;
+	set_current_time(machine());
+
+	m_clk = 0;
+	m_ce = 0;
+	m_state = STATE_COMMAND;
+	m_bits = 0;
+}
+
+
+//-------------------------------------------------
+//  device_timer - handler timer events
+//-------------------------------------------------
+
+void ds1302_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	if (!CLOCK_HALT)
+	{
+		advance_seconds();
+	}
+}
+
+
+//-------------------------------------------------
+//  nvram_default - called to initialize NVRAM to
+//  its default state
+//-------------------------------------------------
+
+void ds1302_device::nvram_default()
+{
+	memset(m_ram, 0, RAM_SIZE);
+}
+
+
+//-------------------------------------------------
+//  nvram_read - called to read NVRAM from the
+//  .nv file
+//-------------------------------------------------
+
+void ds1302_device::nvram_read(emu_file &file)
+{
+	file.read(m_ram, RAM_SIZE);
+}
+
+
+//-------------------------------------------------
+//  nvram_write - called to write NVRAM to the
+//  .nv file
+//-------------------------------------------------
+
+void ds1302_device::nvram_write(emu_file &file)
+{
+	file.write(m_ram, RAM_SIZE);
+}
+
+
+//-------------------------------------------------
+//  rtc_clock_updated -
+//-------------------------------------------------
+
+void ds1302_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+{
+	m_reg[REGISTER_YEAR] = convert_to_bcd(year);
+	m_reg[REGISTER_DAY] = day_of_week;
+	m_reg[REGISTER_MONTH] = convert_to_bcd(month);
+	m_reg[REGISTER_DATE] = convert_to_bcd(day);
+	m_reg[REGISTER_HOUR] = convert_to_bcd(hour);
+	m_reg[REGISTER_MINUTES] = convert_to_bcd(minute);
+	m_reg[REGISTER_SECONDS] = (m_reg[REGISTER_SECONDS] & 0x80) | convert_to_bcd(second);
 }
 
 
-/*-------------------------------------------------
-    ds1302_dat_w
--------------------------------------------------*/
+//-------------------------------------------------
+//  ce_w - chip enable write
+//-------------------------------------------------
 
-WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_dat_w)
+WRITE_LINE_MEMBER( ds1302_device::ce_w )
 {
-	if (data)
+	if (LOG) logerror("DS1302 '%s' CE: %u\n", tag(), state);
+
+	if (!state && m_ce)
 	{
-		m_shift_in |= (1 << m_icount);
+		// synchronize user buffers
+		for (int i = 0; i < 9; i++)
+		{
+			m_user[i] = m_reg[i];
+		}
+	}
+	else if (state && !m_ce)
+	{
+		// terminate data transfer
+		m_state = STATE_COMMAND;
+		m_bits = 0;
+	}
+
+	m_ce = state;
+}
+
+
+//-------------------------------------------------
+//  load_shift_register -
+//-------------------------------------------------
+
+void ds1302_device::load_shift_register()
+{
+	if (COMMAND_READ)
+	{
+		if (COMMAND_RAM)
+		{
+			m_data = m_ram[m_addr];
+
+			if (LOG) logerror("DS1302 '%s' Read RAM %u:%02x\n", tag(), m_addr, m_data);
+		}
+		else
+		{
+			m_data = m_user[m_addr];
+
+			if (LOG) logerror("DS1302 '%s' Read Clock %u:%02x\n", tag(), m_addr, m_data);
+		}
 	}
 	else
 	{
-		m_shift_in &= ~(1 << m_icount);
+		if (COMMAND_RAM)
+		{
+			if (LOG) logerror("DS1302 '%s' Write RAM %u:%02x\n", tag(), m_addr, m_data);
+
+			m_ram[m_addr] = m_data;
+		}
+		else if (m_addr < 9)
+		{
+			if (LOG) logerror("DS1302 '%s' Write Clock %u:%02x\n", tag(), m_addr, m_data);
+
+			m_reg[m_addr] = m_data;
+		}
 	}
 }
 
 
-/*-------------------------------------------------
-    ds1302_clk_w
--------------------------------------------------*/
+//-------------------------------------------------
+//  input_bit -
+//-------------------------------------------------
 
-WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_clk_w)
+void ds1302_device::input_bit()
 {
-	if (data != m_last_clk)
+	switch (m_state)
 	{
-		if (data)	//Rising, shift in command
+	case STATE_COMMAND:
+		m_cmd >>= 1;
+		m_cmd |= (m_io << 7);
+		m_bits++;
+
+		if (m_bits == 8)
 		{
-			m_icount++;
-			if(m_icount == 8)	//Command start
+			if (LOG) logerror("DS1302 '%s' Command: %02x\n", tag(), m_cmd);
+
+			m_bits = 0;
+			m_addr = (m_cmd >> 1) & 0x1f;
+
+			if (COMMAND_VALID)
 			{
-				system_time systime;
-				machine().base_datetime(systime);
+				if (COMMAND_BURST)
+				{
+					m_addr = 0;
+				}
 
-				switch(m_shift_in)
+				if (COMMAND_READ)
 				{
-					case 0x81:	//Sec
-						m_shift_out = convert_to_bcd(systime.local_time.second);
-						break;
-
-					case 0x83:	//Min
-						m_shift_out = convert_to_bcd(systime.local_time.minute);
-						break;
-
-					case 0x85:	//Hour
-						m_shift_out = convert_to_bcd(systime.local_time.hour);
-						break;
-
-					case 0x87:	//Day
-						m_shift_out = convert_to_bcd(systime.local_time.mday);
-						break;
-
-					case 0x89:	//Month
-						m_shift_out = convert_to_bcd(systime.local_time.month + 1);
-						break;
-
-					case 0x8b:	//weekday
-						m_shift_out = convert_to_bcd(systime.local_time.weekday);
-						break;
-
-					case 0x8d:	//Year
-						m_shift_out = convert_to_bcd(systime.local_time.year % 100);
-						break;
+					load_shift_register();
 
-					default:
-						m_shift_out = 0x0;
+					m_state = STATE_OUTPUT;
 				}
-
-				if(m_shift_in > 0xc0)
+				else
 				{
-					m_shift_out = m_sram[(m_shift_in >> 1) & 0x1f];
+					m_state = STATE_INPUT;
 				}
-				m_last_cmd = m_shift_in & 0xff;
-				m_icount++;
 			}
-
-			if(m_icount == 17 && !(m_last_cmd & 1))
+			else
 			{
-				UINT8 val = (m_shift_in >> 9) & 0xff;
+				m_state = STATE_COMMAND;
+			}
+		}
+		break;
 
-				switch(m_last_cmd)
-				{
-					case 0x80:	//Sec
-						break;
+	case STATE_INPUT:
+		m_data >>= 1;
+		m_data |= (m_io << 7);
+		m_bits++;
 
-					case 0x82:	//Min
-						break;
+		if (m_bits == 8)
+		{
+			if (LOG) logerror("DS1302 '%s' Data: %02x\n", tag(), m_data);
 
-					case 0x84:	//Hour
-						break;
+			m_bits = 0;
 
-					case 0x86:	//Day
-						break;
+			if (!WRITE_PROTECT)
+			{
+				load_shift_register();
+			}
 
-					case 0x88:	//Month
-						break;
+			if (COMMAND_BURST)
+			{
+				m_addr++;
 
-					case 0x8a:	//weekday
-						break;
+				if (m_addr == BURST_END)
+				{
+					m_state = STATE_COMMAND;
+				}
+			}
+			else
+			{
+				m_state = STATE_COMMAND;
+			}
+		}
+		break;
+	}
+}
 
-					case 0x8c:	//Year
-						break;
 
-					default:
-						m_shift_out = 0x0;
-				}
+//-------------------------------------------------
+//  output_bit -
+//-------------------------------------------------
 
-				if(m_last_cmd > 0xc0)
-				{
-					m_sram[(m_last_cmd >> 1) & 0x1f] = val;
-				}
+void ds1302_device::output_bit()
+{
+	if (m_state != STATE_OUTPUT) return;
 
+	m_io = BIT(m_data, 0);
+	m_data >>= 1;
+	m_bits++;
 
+	if (m_bits == 8)
+	{
+		m_bits = 0;
+
+		if (COMMAND_BURST)
+		{
+			m_addr++;
 
+			if (m_addr == BURST_END)
+			{
+				m_state = STATE_COMMAND;
+			}
+			else
+			{
+				load_shift_register();
 			}
 		}
+		else
+		{
+			m_state = STATE_COMMAND;
+		}
+	}
+}
+
+
+//-------------------------------------------------
+//  sclk_w - serial clock write
+//-------------------------------------------------
+
+WRITE_LINE_MEMBER( ds1302_device::sclk_w )
+{
+	if (LOG) logerror("DS1302 '%s' CLK: %u\n", tag(), state);
+
+	if (!m_ce) return;
+
+	if (!m_clk && state) // rising edge
+	{
+		input_bit();
 	}
-	m_last_clk = data;
+	else if (m_clk && !state) // falling edge
+	{
+		output_bit();
+	}
+
+	m_clk = state;
 }
 
 
-/*-------------------------------------------------
-    ds1302_read
--------------------------------------------------*/
+//-------------------------------------------------
+//  io_w - I/O write
+//-------------------------------------------------
+
+WRITE_LINE_MEMBER( ds1302_device::io_w )
+{
+	if (LOG) logerror("DS1302 '%s' I/O: %u\n", tag(), state);
+
+	m_io = state;
+}
+
+
+//-------------------------------------------------
+//  io_r - I/O read
+//-------------------------------------------------
 
-READ8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_read)
+READ_LINE_MEMBER( ds1302_device::io_r )
 {
-	return (m_shift_out & (1 << (m_icount - 9))) ? 1 : 0;
+	return m_io;
 }
diff -Nru src-old/emu/machine/ds1302.h src/emu/machine/ds1302.h
--- src-old/emu/machine/ds1302.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/ds1302.h	2012-04-27 23:23:39.000000000 +0200
@@ -1,8 +1,16 @@
 /**********************************************************************
 
-    DALLAS DS1302
+    Dallas DS1302 Trickle-Charge Timekeeping Chip emulation
 
-    RTC + BACKUP RAM
+    Copyright MESS Team.
+    Visit http://mamedev.org for licensing and usage restrictions.
+
+**********************************************************************
+                            _____   _____
+                  Vcc2   1 |*    \_/     | 8   Vcc1
+                    X1   2 |             | 7   SCLK
+                    X2   3 |             | 6   I/O
+                   GND   4 |_____________| 5   CE
 
 **********************************************************************/
 
@@ -15,46 +23,69 @@
 
 
 
-/***************************************************************************
-    DEVICE CONFIGURATION MACROS
-***************************************************************************/
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
 
-#define MCFG_DS1302_ADD(_tag) \
-	MCFG_DEVICE_ADD(_tag, DS1302, 0)
+#define MCFG_DS1302_ADD(_tag, _clock) \
+	MCFG_DEVICE_ADD(_tag, DS1302, _clock)
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
 
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
 // ======================> ds1302_device
 
-class ds1302_device :  public device_t
+class ds1302_device :  public device_t,
+                       public device_rtc_interface,
+                       public device_nvram_interface
 {
 public:
     // construction/destruction
     ds1302_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 
-	void ds1302_dat_w(UINT32 offset, UINT8 data);
-	void ds1302_clk_w(UINT32 offset, UINT8 data);
-	UINT8 ds1302_read(UINT32 offset);
+    DECLARE_WRITE_LINE_MEMBER( ce_w );
+    DECLARE_WRITE_LINE_MEMBER( sclk_w );
+    DECLARE_WRITE_LINE_MEMBER( io_w );
+    DECLARE_READ_LINE_MEMBER( io_r );
 
 protected:
     // device-level overrides
     virtual void device_start();
     virtual void device_reset();
-    virtual void device_post_load() { }
-    virtual void device_clock_changed() { }
+    virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+    // device_nvram_interface overrides
+    virtual void nvram_default();
+    virtual void nvram_read(emu_file &file);
+    virtual void nvram_write(emu_file &file);
+
+    // device_rtc_interface overrides
+    virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
+    virtual bool rtc_feature_leap_year() { return true; }
 
 private:
+    void load_shift_register();
+    void input_bit();
+    void output_bit();
+
+    int m_ce;
+    int m_clk;
+    int m_io;
+    int m_state;
+    int m_bits;
+    UINT8 m_cmd;
+    UINT8 m_data;
+    int m_addr;
+
+    UINT8 m_reg[9];
+    UINT8 m_user[9];
+	UINT8 m_ram[0x20];
 
-	UINT32 m_shift_in;
-	UINT8  m_shift_out;
-	UINT8  m_icount;
-	UINT8  m_last_clk;
-	UINT8  m_last_cmd;
-	UINT8  m_sram[0x20];
+    // timers
+    emu_timer *m_clock_timer;
 };
 
 
@@ -63,13 +94,4 @@
 
 
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
-
-extern WRITE8_DEVICE_HANDLER( ds1302_dat_w );
-extern WRITE8_DEVICE_HANDLER( ds1302_clk_w );
-extern READ8_DEVICE_HANDLER( ds1302_read );
-
-
-#endif /* __DS1302_H__ */
+#endif
diff -Nru src-old/emu/machine/e0516.c src/emu/machine/e0516.c
--- src-old/emu/machine/e0516.c	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/e0516.c	2012-04-27 23:23:39.000000000 +0200
@@ -1,6 +1,6 @@
 /**********************************************************************
 
-    E05-16 Real Time Clock emulation
+    Microelectronic-Marin E050-16 Real Time Clock emulation
 
     Copyright MESS Team.
     Visit http://mamedev.org for licensing and usage restrictions.
@@ -27,70 +27,6 @@
 };
 
 
-// registers
-enum
-{
-	SECOND = 0,
-	MINUTE,
-	HOUR,
-	DAY,
-	MONTH,
-	DAY_OF_WEEK,
-	YEAR,
-	ALL
-};
-
-
-//**************************************************************************
-//  INLINE HELPERS
-//**************************************************************************
-
-//-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void e0516_device::advance_seconds()
-{
-	m_register[SECOND]++;
-
-	if (m_register[SECOND] == 60)
-	{
-		m_register[SECOND] = 0;
-		m_register[MINUTE]++;
-	}
-
-	if (m_register[MINUTE] == 60)
-	{
-		m_register[MINUTE] = 0;
-		m_register[HOUR]++;
-	}
-
-	if (m_register[HOUR] == 24)
-	{
-		m_register[HOUR] = 0;
-		m_register[DAY]++;
-		m_register[DAY_OF_WEEK]++;
-	}
-
-	if (m_register[DAY_OF_WEEK] == 8)
-	{
-		m_register[DAY_OF_WEEK] = 1;
-	}
-
-	if (m_register[DAY] == 32)
-	{
-		m_register[DAY] = 1;
-		m_register[MONTH]++;
-	}
-
-	if (m_register[MONTH] == 13)
-	{
-		m_register[MONTH] = 1;
-		m_register[YEAR]++;
-	}
-}
-
-
 
 //**************************************************************************
 //  LIVE DEVICE
@@ -129,16 +65,16 @@
 	save_item(NAME(m_state));
 	save_item(NAME(m_bits));
 	save_item(NAME(m_dio));
-	save_item(NAME(m_register));
 }
 
 
 //-------------------------------------------------
-//  device_start - device-specific reset
+//  device_reset - device-specific reset
 //-------------------------------------------------
 
 void e0516_device::device_reset()
 {
+	set_current_time(machine());
 }
 
 
@@ -153,28 +89,13 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
-//-------------------------------------------------
-
-void e0516_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
-{
-	m_register[YEAR] = year;
-	m_register[MONTH] = month;
-	m_register[DAY] = day;
-	m_register[DAY_OF_WEEK] = day_of_week + 1;
-	m_register[HOUR] = hour;
-	m_register[MINUTE] = minute;
-	m_register[SECOND] = second;
-}
-
-
-//-------------------------------------------------
 //  cs_w - chip select input
 //-------------------------------------------------
 
 WRITE_LINE_MEMBER( e0516_device::cs_w )
 {
+	if (LOG) logerror("E05-16 '%s' CS %u\n", tag(), state);
+
 	m_cs = state;
 
 	if (m_cs)
@@ -193,6 +114,8 @@
 
 WRITE_LINE_MEMBER( e0516_device::clk_w )
 {
+	if (LOG) logerror("E05-16 '%s' CLK %u\n", tag(), state);
+
 	m_clk = state;
 
 	if (m_cs || m_clk) return;
@@ -215,7 +138,7 @@
 			if (BIT(m_reg_latch, 0))
 			{
 				// load register value to data latch
-				m_data_latch = m_register[m_reg_latch >> 1];
+				m_data_latch = convert_to_bcd(get_clock_register(m_reg_latch >> 1));
 			}
 		}
 	}
@@ -247,7 +170,7 @@
 			if (!BIT(m_reg_latch, 0))
 			{
 				// write latched data to register
-				m_register[m_reg_latch >> 1] = m_data_latch;
+				set_clock_register(m_reg_latch >> 1, bcd_to_integer(m_data_latch));
 			}
 		}
 	}
@@ -260,6 +183,8 @@
 
 WRITE_LINE_MEMBER( e0516_device::dio_w )
 {
+	if (LOG) logerror("E05-16 '%s' DIO %u\n", tag(), state);
+
 	m_dio = state;
 }
 
diff -Nru src-old/emu/machine/e0516.h src/emu/machine/e0516.h
--- src-old/emu/machine/e0516.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/e0516.h	2012-04-27 23:23:39.000000000 +0200
@@ -1,6 +1,6 @@
 /**********************************************************************
 
-    E05-16 Real Time Clock emulation
+    Microelectronic-Marin E050-16 Real Time Clock emulation
 
     Copyright MESS Team.
     Visit http://mamedev.org for licensing and usage restrictions.
@@ -40,7 +40,6 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-
 // ======================> e0516_device
 
 class e0516_device :  public device_t,
@@ -61,13 +60,7 @@
     virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
-	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
-
 private:
-	inline void advance_seconds();
-
 	int m_cs;						// chip select
 	int m_clk;						// clock
 	int m_data_latch;				// data latch
@@ -77,8 +70,6 @@
 	int m_bits;						// number of bits transferred
 	int m_dio;						// data pin
 
-	UINT8 m_register[8];			// registers
-
 	// timers
 	emu_timer *m_timer;
 };
diff -Nru src-old/emu/machine/eeprom.c src/emu/machine/eeprom.c
--- src-old/emu/machine/eeprom.c	2012-03-31 15:39:09.000000000 +0200
+++ src/emu/machine/eeprom.c	2012-05-03 11:16:42.000000000 +0200
@@ -240,11 +240,12 @@
 
 	/* handle hard-coded data from the driver */
 	if (m_default_data.u8 != NULL)
-		for (offs_t offs = 0; offs < m_default_data_size; offs++)
+		for (offs_t offs = 0; offs < m_default_data_size; offs++) {
 			if (m_data_bits == 8)
 				m_addrspace[0]->write_byte(offs, m_default_data.u8[offs]);
 			else
 				m_addrspace[0]->write_word(offs * 2, m_default_data.u16[offs]);
+		}
 
 	/* populate from a memory region if present */
 	if (m_region != NULL)
diff -Nru src-old/emu/machine/generic.c src/emu/machine/generic.c
--- src-old/emu/machine/generic.c	2012-04-11 00:08:28.000000000 +0200
+++ src/emu/machine/generic.c	2012-05-03 11:00:08.000000000 +0200
@@ -286,8 +286,8 @@
 
 	// start with either basename or basename_biosnum
 	result.cpy(machine.basename());
-	if (rom_system_bios(machine) != 0 && rom_default_bios(machine) != rom_system_bios(machine))
-		result.catprintf("_%d", rom_system_bios(machine) - 1);
+	if (device.machine().root_device().system_bios() != 0 && device.machine().root_device().default_bios() != device.machine().root_device().system_bios())
+		result.catprintf("_%d", device.machine().root_device().system_bios() - 1);
 
 	// device-based NVRAM gets its own name in a subdirectory
 	if (&device != &device.machine().root_device())
@@ -528,7 +528,7 @@
 CUSTOM_INPUT_MEMBER( driver_device::custom_port_read )
 {
 	const char *tag = (const char *)param;
-	return input_port_read(machine(), tag);
+	return ioport(tag)->read();
 }
 
 
diff -Nru src-old/emu/machine/i8155.c src/emu/machine/i8155.c
--- src-old/emu/machine/i8155.c	2012-04-20 22:40:44.000000000 +0200
+++ src/emu/machine/i8155.c	2012-04-30 21:37:30.000000000 +0200
@@ -159,36 +159,19 @@
 {
 	UINT8 data = 0;
 
-	switch (port)
+	switch (get_port_mode(port))
 	{
-	case PORT_A:
-	case PORT_B:
-		switch (get_port_mode(port))
-		{
-		case PORT_MODE_INPUT:
-			data = m_in_port_func[port](0);
-			break;
-
-		case PORT_MODE_OUTPUT:
-			data = m_output[port];
-			break;
-		}
+	case PORT_MODE_INPUT:
+		data = m_in_port_func[port](0);
 		break;
 
-	case PORT_C:
-		switch (get_port_mode(PORT_C))
-		{
-		case PORT_MODE_INPUT:
-			data = m_in_port_func[port](0) & 0x3f;
-			break;
-
-		case PORT_MODE_OUTPUT:
-			data = m_output[port] & 0x3f;
-			break;
+	case PORT_MODE_OUTPUT:
+		data = m_output[port];
+		break;
 
-		default:
-			logerror("8155 '%s' Unsupported Port C mode!\n", tag());
-		}
+	default:
+		// strobed mode not implemented yet
+		logerror("8155 '%s' Unsupported Port C mode!\n", tag());
 		break;
 	}
 
@@ -386,7 +369,7 @@
 {
 	UINT8 data = 0;
 
-	switch (offset & 0x03)
+	switch (offset & 0x07)
 	{
 	case REGISTER_STATUS:
 		data = m_status;
@@ -404,7 +387,15 @@
 		break;
 
 	case REGISTER_PORT_C:
-		data = read_port(PORT_C);
+		data = read_port(PORT_C) | 0xc0;
+		break;
+
+	case REGISTER_TIMER_LOW:
+		data = m_counter & 0xff;
+		break;
+
+	case REGISTER_TIMER_HIGH:
+		data = (m_counter >> 8 & 0x3f) | get_timer_mode();
 		break;
 	}
 
@@ -477,7 +468,7 @@
 			else
 			{
 				// load mode and CNT length and start immediately after loading (if timer is not running)
-				m_counter = m_count_length;
+				m_counter = m_count_length & 0x3fff;
 				m_timer->adjust(attotime::zero, 0, attotime::from_hz(clock()));
 			}
 			break;
@@ -493,7 +484,7 @@
 		break;
 
 	case REGISTER_PORT_C:
-		write_port(PORT_C, data);
+		write_port(PORT_C, data & 0x3f);
 		break;
 
 	case REGISTER_TIMER_LOW:
diff -Nru src-old/emu/machine/idectrl.c src/emu/machine/idectrl.c
--- src-old/emu/machine/idectrl.c	2012-02-29 11:13:22.000000000 +0100
+++ src/emu/machine/idectrl.c	2012-04-27 23:23:39.000000000 +0200
@@ -1289,7 +1289,7 @@
 	if (ide->drive[ide->cur_drive].slot->is_ready()) {
 		ide->status |= IDE_STATUS_DRIVE_READY;
 	} else {
-		ide->status &= ~IDE_STATUS_DRIVE_READY;
+		ide->status = 0;
 	}
 
 	switch (BANK(bank, offset))
diff -Nru src-old/emu/machine/intelfsh.c src/emu/machine/intelfsh.c
--- src-old/emu/machine/intelfsh.c	2012-04-21 10:47:50.000000000 +0200
+++ src/emu/machine/intelfsh.c	2012-05-07 08:57:50.000000000 +0200
@@ -36,6 +36,37 @@
 	FM_ERASEAMD4,	// part 4 of AMD erase sequence
 	FM_BYTEPROGRAM,
 	FM_BANKSELECT,
+	FM_WRITEPAGEATMEL
+};
+
+
+enum
+{
+	MFG_ALLIANCE = 0x52,
+	MFG_AMD = 0x01,
+	MFG_AMIC = 0x37,
+	MFG_ATMEL = 0x1f,
+	MFG_BRIGHT = 0xad,
+	MFG_CATALYST = 0x31,
+	MFG_EON = 0x1c,
+	MFG_FUJITSU = 0x04,
+	MFG_GIGADEVICE = 0xc8,
+	MFG_HYUNDAI = 0xad,
+	MFG_INTEL = 0x89,
+	MFG_ISSI = 0xd5,
+	MFG_MACRONIX = 0xc2,
+	MFG_PANASONIC = 0x32,
+	MFG_PMC = 0x9d,
+	MFG_SANYO = 0x62,
+	MFG_SHARP = 0xb0,
+	MFG_SPANSION = 0x01,
+	MFG_SST = 0xbf,
+	MFG_ST = 0x20,
+	MFG_SYNCMOS = 0x40,
+	MFG_TI = 0x97,
+	MFG_TI_OLD = 0x01,
+	MFG_WINBOND_NEX = 0xef,
+	MFG_WINBOND = 0xda
 };
 
 
@@ -130,28 +161,29 @@
 	case FLASH_SHARP_LH28F016S:
 		m_bits = 8;
 		m_size = 0x200000;
-		m_maker_id = 0x89;
+		m_maker_id = MFG_INTEL;
 		m_device_id = 0xaa;
 		map = ADDRESS_MAP_NAME( memory_map8_16Mb );
 		break;
 	case FLASH_ATMEL_29C010:
 		m_bits = 8;
 		m_size = 0x20000;
-		m_maker_id = 0x1f;
+		m_page_size = 0x80;
+		m_maker_id = MFG_ATMEL;
 		m_device_id = 0xd5;
 		map = ADDRESS_MAP_NAME( memory_map8_1Mb );
 		break;
 	case FLASH_AMD_29F040:
 		m_bits = 8;
 		m_size = 0x80000;
-		m_maker_id = 0x01;
+		m_maker_id = MFG_AMD;
 		m_device_id = 0xa4;
 		map = ADDRESS_MAP_NAME( memory_map8_4Mb );
 		break;
 	case FLASH_AMD_29F080:
 		m_bits = 8;
 		m_size = 0x100000;
-		m_maker_id = 0x01;
+		m_maker_id = MFG_AMD;
 		m_device_id = 0xd5;
 		map = ADDRESS_MAP_NAME( memory_map8_8Mb );
 		break;
@@ -159,56 +191,56 @@
 	case FLASH_INTEL_E28F400:
 		m_bits = 16;
 		m_size = 0x80000;
-		m_maker_id = 0xb0;
+		m_maker_id = MFG_SHARP;
 		m_device_id = 0xed;
 		map = ADDRESS_MAP_NAME( memory_map16_4Mb );
 		break;
 	case FLASH_FUJITSU_29F016A:
 		m_bits = 8;
 		m_size = 0x200000;
-		m_maker_id = 0x04;
+		m_maker_id = MFG_FUJITSU;
 		m_device_id = 0xad;
 		map = ADDRESS_MAP_NAME( memory_map8_16Mb );
 		break;
 	case FLASH_FUJITSU_29DL16X:
 		m_bits = 8;
 		m_size = 0x200000;
-		m_maker_id = 0x04;
+		m_maker_id = MFG_FUJITSU;
 		m_device_id = 0x35;
 		map = ADDRESS_MAP_NAME( memory_map8_16Mb );
 		break;
 	case FLASH_INTEL_E28F008SA:
 		m_bits = 8;
 		m_size = 0x100000;
-		m_maker_id = 0x89;
+		m_maker_id = MFG_INTEL;
 		m_device_id = 0xa2;
 		map = ADDRESS_MAP_NAME( memory_map8_8Mb );
 		break;
 	case FLASH_INTEL_TE28F160:
 		m_bits = 16;
 		m_size = 0x200000;
-		m_maker_id = 0xb0;
+		m_maker_id = MFG_SHARP;
 		m_device_id = 0xd0;
 		map = ADDRESS_MAP_NAME( memory_map16_16Mb );
 		break;
 	case FLASH_SHARP_UNK128MBIT:
 		m_bits = 16;
 		m_size = 0x800000;
-		m_maker_id = 0xb0;
+		m_maker_id = MFG_SHARP;
 		m_device_id = 0xb0;
 		map = ADDRESS_MAP_NAME( memory_map16_64Mb );
 		break;
 	case FLASH_MACRONIX_29L001MC:
 		m_bits = 8;
 		m_size = 0x20000;
-		m_maker_id = 0xc2;
+		m_maker_id = MFG_MACRONIX;
 		m_device_id = 0x51;
 		map = ADDRESS_MAP_NAME( memory_map8_1Mb );
 		break;
 	case FLASH_PANASONIC_MN63F805MNP:
 		m_bits = 8;
 		m_size = 0x10000;
-		m_maker_id = 0x32;
+		m_maker_id = MFG_PANASONIC;
 		m_device_id = 0x1b;
 		m_sector_is_4k = true;
 		map = ADDRESS_MAP_NAME( memory_map8_512Kb );
@@ -216,7 +248,7 @@
 	case FLASH_SANYO_LE26FV10N1TS:
 		m_bits = 8;
 		m_size = 0x20000;
-		m_maker_id = 0x62;
+		m_maker_id = MFG_SANYO;
 		m_device_id = 0x13;
 		m_sector_is_4k = true;
 		map = ADDRESS_MAP_NAME( memory_map8_1Mb );
@@ -492,7 +524,7 @@
 		break;
 	}
 
-//  logerror( "intelflash_read( %d, %08x ) %08x\n", chip, address, data );
+	//logerror( "intelflash_read( %08x ) %08x\n", address, data );
 
 	return data;
 }
@@ -505,7 +537,7 @@
 
 void intelfsh_device::write_full(UINT32 address, UINT32 data)
 {
-//  logerror( "intelflash_write( %d, %08x, %08x )\n", chip, address, data );
+	//logerror( "intelflash_write( %u : %08x, %08x )\n", m_flash_mode, address, data );
 
 	address += m_bank << 16;
 
@@ -610,7 +642,15 @@
 		}
 		else if( ( address & 0xffff ) == 0x5555 && ( data & 0xff ) == 0xa0 )
 		{
-			m_flash_mode = FM_BYTEPROGRAM;
+			if (m_type == FLASH_ATMEL_29C010)
+			{
+				m_flash_mode = FM_WRITEPAGEATMEL;
+				m_byte_count = 0;
+			}
+			else
+			{
+				m_flash_mode = FM_BYTEPROGRAM;
+			}
 		}
 		else if( ( address & 0xfff ) == 0xaaa && ( data & 0xff ) == 0xa0 )
 		{
@@ -770,6 +810,31 @@
 		m_status = 0x80;
 		m_flash_mode = FM_READSTATUS;
 		break;
+	case FM_WRITEPAGEATMEL:
+		switch( m_bits )
+		{
+		case 8:
+			{
+				m_addrspace[0]->write_byte(address, data);
+			}
+			break;
+		case 16:
+			{
+				m_addrspace[0]->write_word(address * 2, data);
+			}
+			break;
+		default:
+			logerror( "FM_WRITEPAGEATMEL not supported when m_bits == %d\n", m_bits );
+			break;
+		}
+
+		m_byte_count++;
+
+		if (m_byte_count == m_page_size)
+		{
+			m_flash_mode = FM_NORMAL;
+		}
+		break;
 	case FM_CLEARPART1:
 		if( ( data & 0xff ) == 0xd0 )
 		{
diff -Nru src-old/emu/machine/intelfsh.h src/emu/machine/intelfsh.h
--- src-old/emu/machine/intelfsh.h	2012-04-21 10:47:50.000000000 +0200
+++ src/emu/machine/intelfsh.h	2012-05-07 08:57:50.000000000 +0200
@@ -122,6 +122,7 @@
 	UINT8					m_device_id;
 	UINT8					m_maker_id;
 	bool					m_sector_is_4k;
+	UINT8					m_page_size;
 
 	// internal state
 	UINT8					m_status;
@@ -130,6 +131,7 @@
 	bool					m_flash_master_lock;
 	emu_timer *				m_timer;
 	INT32					m_bank;
+	UINT8					m_byte_count;
 };
 
 
diff -Nru src-old/emu/machine/jvsdev.c src/emu/machine/jvsdev.c
--- src-old/emu/machine/jvsdev.c	2011-06-13 12:00:59.000000000 +0200
+++ src/emu/machine/jvsdev.c	2012-05-03 11:00:08.000000000 +0200
@@ -249,6 +249,6 @@
 	case 2: jvs_outputs ^=  m;  break;
 	}
 
-	input_port_write_safe(machine(), tag, jvs_outputs, m);
+	machine().root_device().ioport(tag)->write_safe(jvs_outputs, m);
 }
 
diff -Nru src-old/emu/machine/mc146818.c src/emu/machine/mc146818.c
--- src-old/emu/machine/mc146818.c	2012-02-20 10:05:19.000000000 +0100
+++ src/emu/machine/mc146818.c	2012-05-07 08:57:50.000000000 +0200
@@ -300,11 +300,10 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void mc146818_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void mc146818_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
 	YEAR = year;
 	MONTH = month;
diff -Nru src-old/emu/machine/mc146818.h src/emu/machine/mc146818.h
--- src-old/emu/machine/mc146818.h	2011-06-06 00:35:20.000000000 +0200
+++ src/emu/machine/mc146818.h	2012-04-27 23:23:39.000000000 +0200
@@ -73,8 +73,7 @@
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 	// device_nvram_interface overrides
 	virtual void nvram_default();
diff -Nru src-old/emu/machine/mccs1850.c src/emu/machine/mccs1850.c
--- src-old/emu/machine/mccs1850.c	2012-04-20 07:54:39.000000000 +0200
+++ src/emu/machine/mccs1850.c	2012-04-27 23:23:39.000000000 +0200
@@ -353,16 +353,6 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
-//-------------------------------------------------
-
-void mccs1850_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
-{
-}
-
-
-//-------------------------------------------------
 //  nvram_default - called to initialize NVRAM to
 //  its default state
 //-------------------------------------------------
diff -Nru src-old/emu/machine/mccs1850.h src/emu/machine/mccs1850.h
--- src-old/emu/machine/mccs1850.h	2012-02-12 11:45:38.000000000 +0100
+++ src/emu/machine/mccs1850.h	2012-04-27 23:23:39.000000000 +0200
@@ -65,10 +65,6 @@
     virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
-	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
-
 	// device_nvram_interface overrides
 	virtual void nvram_default();
 	virtual void nvram_read(emu_file &file);
diff -Nru src-old/emu/machine/microtch.c src/emu/machine/microtch.c
--- src-old/emu/machine/microtch.c	2012-04-05 20:25:39.000000000 +0200
+++ src/emu/machine/microtch.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,8 +82,8 @@
 
 void microtouch_device::send_touch_packet()
 {
-	int tx = input_port_read(*this, "TOUCH_X");
-	int ty = input_port_read(*this, "TOUCH_Y");
+	int tx = ioport("TOUCH_X")->read();
+	int ty = ioport("TOUCH_Y")->read();
 
 	if ( m_out_touch_cb == NULL ||
 		 m_out_touch_cb( &tx, &ty ) != 0 )
@@ -127,7 +127,7 @@
 	}
 
 	// send format tablet packet
-	if ( input_port_read(*this, "TOUCH") & 0x01 )
+	if ( ioport("TOUCH")->read() & 0x01 )
 	{
 		send_touch_packet();
 	}
diff -Nru src-old/emu/machine/msm5832.c src/emu/machine/msm5832.c
--- src-old/emu/machine/msm5832.c	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/msm5832.c	2012-05-07 08:57:50.000000000 +0200
@@ -53,10 +53,6 @@
 };
 
 
-// days per month
-static const int DAYS_PER_MONTH[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-
 
 //**************************************************************************
 //  INLINE HELPERS
@@ -83,86 +79,6 @@
 }
 
 
-//-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void msm5832_device::advance_seconds()
-{
-	int seconds = read_counter(REGISTER_S1);
-
-	seconds++;
-
-	if (seconds > 59)
-	{
-		seconds = 0;
-
-		advance_minutes();
-	}
-
-	write_counter(REGISTER_S1, seconds);
-}
-
-
-//-------------------------------------------------
-//  advance_minutes -
-//-------------------------------------------------
-
-inline void msm5832_device::advance_minutes()
-{
-	int minutes = read_counter(REGISTER_MI1);
-	int hours = read_counter(REGISTER_H1);
-	int days = read_counter(REGISTER_D1);
-	int month = read_counter(REGISTER_MO1);
-	int year = read_counter(REGISTER_Y1);
-	int day_of_week = m_reg[REGISTER_W];
-
-	minutes++;
-
-	if (minutes > 59)
-	{
-		minutes = 0;
-		hours++;
-	}
-
-	if (hours > 23)
-	{
-		hours = 0;
-		days++;
-		day_of_week++;
-	}
-
-	if (day_of_week > 6)
-	{
-		day_of_week++;
-	}
-
-	if (days > DAYS_PER_MONTH[month - 1])
-	{
-		days = 1;
-		month++;
-	}
-
-	if (month > 12)
-	{
-		month = 1;
-		year++;
-	}
-
-	if (year > 99)
-	{
-		year = 0;
-	}
-
-	write_counter(REGISTER_MI1, minutes);
-	write_counter(REGISTER_H1, hours);
-	write_counter(REGISTER_D1, days);
-	write_counter(REGISTER_MO1, month);
-	write_counter(REGISTER_Y1, year);
-	m_reg[REGISTER_W] = day_of_week;
-}
-
-
 
 //**************************************************************************
 //  LIVE DEVICE
@@ -207,6 +123,16 @@
 
 
 //-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void msm5832_device::device_reset()
+{
+	set_current_time(machine());
+}
+
+
+//-------------------------------------------------
 //  device_timer - handler timer events
 //-------------------------------------------------
 
@@ -225,11 +151,10 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void msm5832_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void msm5832_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
 	write_counter(REGISTER_Y1, year);
 	write_counter(REGISTER_MO1, month);
@@ -278,6 +203,9 @@
 	if (m_cs && m_write)
 	{
 		m_reg[m_address] = data & 0x0f;
+
+		set_time(false, read_counter(REGISTER_Y1), read_counter(REGISTER_MO1), read_counter(REGISTER_D1), m_reg[REGISTER_W],
+			read_counter(REGISTER_H1), read_counter(REGISTER_MI1), read_counter(REGISTER_S1));
 	}
 }
 
@@ -304,17 +232,7 @@
 
 	if (state)
 	{
-		int seconds = read_counter(REGISTER_S1);
-
-		if (seconds < 30)
-		{
-			write_counter(REGISTER_S1, 0);
-		}
-		else
-		{
-			write_counter(REGISTER_S1, 0);
-			advance_minutes();
-		}
+		adjust_seconds();
 	}
 }
 
diff -Nru src-old/emu/machine/msm5832.h src/emu/machine/msm5832.h
--- src-old/emu/machine/msm5832.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/msm5832.h	2012-05-07 08:57:50.000000000 +0200
@@ -66,19 +66,17 @@
 protected:
     // device-level overrides
     virtual void device_start();
+    virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 private:
 	static const device_timer_id TIMER_CLOCK = 0;
 
 	inline int read_counter(int counter);
 	inline void write_counter(int counter, int value);
-	inline void advance_seconds();
-	inline void advance_minutes();
 
 	UINT8 m_reg[13];			// registers
 
diff -Nru src-old/emu/machine/msm58321.c src/emu/machine/msm58321.c
--- src-old/emu/machine/msm58321.c	2011-05-02 05:32:58.000000000 +0200
+++ src/emu/machine/msm58321.c	2012-04-27 23:23:39.000000000 +0200
@@ -56,10 +56,6 @@
 };
 
 
-// days per month
-static const int DAYS_PER_MONTH[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-
 
 //**************************************************************************
 //  INLINE HELPERS
@@ -86,86 +82,6 @@
 }
 
 
-//-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void msm58321_device::advance_seconds()
-{
-	int seconds = read_counter(REGISTER_S1);
-
-	seconds++;
-
-	if (seconds > 59)
-	{
-		seconds = 0;
-
-		advance_minutes();
-	}
-
-	write_counter(REGISTER_S1, seconds);
-}
-
-
-//-------------------------------------------------
-//  advance_minutes -
-//-------------------------------------------------
-
-inline void msm58321_device::advance_minutes()
-{
-	int minutes = read_counter(REGISTER_MI1);
-	int hours = read_counter(REGISTER_H1);
-	int days = read_counter(REGISTER_D1);
-	int month = read_counter(REGISTER_MO1);
-	int year = read_counter(REGISTER_Y1);
-	int day_of_week = m_reg[REGISTER_W];
-
-	minutes++;
-
-	if (minutes > 59)
-	{
-		minutes = 0;
-		hours++;
-	}
-
-	if (hours > 23)
-	{
-		hours = 0;
-		days++;
-		day_of_week++;
-	}
-
-	if (day_of_week > 6)
-	{
-		day_of_week++;
-	}
-
-	if (days > DAYS_PER_MONTH[month - 1])
-	{
-		days = 1;
-		month++;
-	}
-
-	if (month > 12)
-	{
-		month = 1;
-		year++;
-	}
-
-	if (year > 99)
-	{
-		year = 0;
-	}
-
-	write_counter(REGISTER_MI1, minutes);
-	write_counter(REGISTER_H1, hours);
-	write_counter(REGISTER_D1, days);
-	write_counter(REGISTER_MO1, month);
-	write_counter(REGISTER_Y1, year);
-	m_reg[REGISTER_W] = day_of_week;
-}
-
-
 
 //**************************************************************************
 //  LIVE DEVICE
@@ -235,6 +151,16 @@
 
 
 //-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void msm58321_device::device_reset()
+{
+	set_current_time(machine());
+}
+
+
+//-------------------------------------------------
 //  device_timer - handler timer events
 //-------------------------------------------------
 
@@ -255,11 +181,10 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void msm58321_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void msm58321_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
 	write_counter(REGISTER_Y1, year);
 	write_counter(REGISTER_MO1, month);
@@ -348,6 +273,9 @@
 		default:
 			if (LOG) logerror("MSM58321 '%s' Register Write %01x: %01x\n", tag(), m_address, data & 0x0f);
 			m_reg[m_address] = m_latch & 0x0f;
+
+			set_time(false, read_counter(REGISTER_Y1), read_counter(REGISTER_MO1), read_counter(REGISTER_D1), m_reg[REGISTER_W],
+				read_counter(REGISTER_H1), read_counter(REGISTER_MI1), read_counter(REGISTER_S1));
 			break;
 		}
 	}
diff -Nru src-old/emu/machine/msm58321.h src/emu/machine/msm58321.h
--- src-old/emu/machine/msm58321.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/msm58321.h	2012-04-27 23:23:39.000000000 +0200
@@ -79,11 +79,11 @@
     // device-level overrides
 	virtual void device_config_complete();
     virtual void device_start();
+    virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 private:
 	static const device_timer_id TIMER_CLOCK = 0;
@@ -91,8 +91,6 @@
 
 	inline int read_counter(int counter);
 	inline void write_counter(int counter, int value);
-	inline void advance_seconds();
-	inline void advance_minutes();
 
 	devcb_resolved_write_line	m_out_busy_func;
 
diff -Nru src-old/emu/machine/rp5c01.c src/emu/machine/rp5c01.c
--- src-old/emu/machine/rp5c01.c	2011-05-02 05:32:58.000000000 +0200
+++ src/emu/machine/rp5c01.c	2012-05-07 08:57:50.000000000 +0200
@@ -145,111 +145,6 @@
 
 
 //-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void rp5c01_device::advance_seconds()
-{
-	int seconds = read_counter(REGISTER_1_SECOND);
-
-	seconds++;
-
-	if (seconds > 59)
-	{
-		seconds = 0;
-
-		advance_minutes();
-	}
-
-	write_counter(REGISTER_1_SECOND, seconds);
-}
-
-
-//-------------------------------------------------
-//  advance_minutes -
-//-------------------------------------------------
-
-inline void rp5c01_device::advance_minutes()
-{
-	int minutes = read_counter(REGISTER_1_MINUTE);
-	int hours = read_counter(REGISTER_1_HOUR);
-	int days = read_counter(REGISTER_1_DAY);
-	int month = read_counter(REGISTER_1_MONTH);
-	int year = read_counter(REGISTER_1_YEAR);
-	int day_of_week = m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK];
-
-	minutes++;
-
-	if (minutes > 59)
-	{
-		minutes = 0;
-		hours++;
-	}
-
-	if (hours > 23)
-	{
-		hours = 0;
-		days++;
-		day_of_week++;
-	}
-
-	if (day_of_week > 6)
-	{
-		day_of_week++;
-	}
-
-	if (days > DAYS_PER_MONTH[month - 1])
-	{
-		days = 1;
-		month++;
-	}
-
-	if (month > 12)
-	{
-		month = 1;
-		year++;
-		m_reg[MODE01][REGISTER_LEAP_YEAR]++;
-		m_reg[MODE01][REGISTER_LEAP_YEAR] &= 0x03;
-	}
-
-	if (year > 99)
-	{
-		year = 0;
-	}
-
-	write_counter(REGISTER_1_MINUTE, minutes);
-	write_counter(REGISTER_1_HOUR, hours);
-	write_counter(REGISTER_1_DAY, days);
-	write_counter(REGISTER_1_MONTH, month);
-	write_counter(REGISTER_1_YEAR, year);
-	m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK] = day_of_week;
-
-	check_alarm();
-	set_alarm_line();
-}
-
-
-//-------------------------------------------------
-//  adjust_seconds -
-//-------------------------------------------------
-
-inline void rp5c01_device::adjust_seconds()
-{
-	int seconds = read_counter(REGISTER_1_SECOND);
-
-	if (seconds < 30)
-	{
-		write_counter(REGISTER_1_SECOND, 0);
-	}
-	else
-	{
-		write_counter(REGISTER_1_SECOND, 0);
-		advance_minutes();
-	}
-}
-
-
-//-------------------------------------------------
 //  check_alarm -
 //-------------------------------------------------
 
@@ -339,6 +234,16 @@
 
 
 //-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void rp5c01_device::device_reset()
+{
+	set_current_time(machine());
+}
+
+
+//-------------------------------------------------
 //  device_timer - handler timer events
 //-------------------------------------------------
 
@@ -365,12 +270,12 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void rp5c01_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void rp5c01_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
+	m_reg[MODE01][REGISTER_LEAP_YEAR] = year % 4;
 	write_counter(REGISTER_1_YEAR, year);
 	write_counter(REGISTER_1_MONTH, month);
 	write_counter(REGISTER_1_DAY, day);
@@ -378,6 +283,9 @@
 	write_counter(REGISTER_1_HOUR, hour);
 	write_counter(REGISTER_1_MINUTE, minute);
 	write_counter(REGISTER_1_SECOND, second);
+
+	check_alarm();
+	set_alarm_line();
 }
 
 
@@ -510,6 +418,9 @@
 		case MODE00:
 		case MODE01:
 			m_reg[mode][offset & 0x0f] = data & REGISTER_WRITE_MASK[mode][offset & 0x0f];
+
+			set_time(false, read_counter(REGISTER_1_YEAR), read_counter(REGISTER_1_MONTH), read_counter(REGISTER_1_DAY), m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK],
+				read_counter(REGISTER_1_HOUR), read_counter(REGISTER_1_MINUTE), read_counter(REGISTER_1_SECOND));
 			break;
 
 		case BLOCK10:
diff -Nru src-old/emu/machine/rp5c01.h src/emu/machine/rp5c01.h
--- src-old/emu/machine/rp5c01.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/rp5c01.h	2012-04-27 23:23:39.000000000 +0200
@@ -74,11 +74,12 @@
     // device-level overrides
 	virtual void device_config_complete();
     virtual void device_start();
+    virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual bool rtc_feature_leap_year() { return true; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 	// device_nvram_interface overrides
 	virtual void nvram_default();
@@ -89,9 +90,6 @@
 	inline void set_alarm_line();
 	inline int read_counter(int counter);
 	inline void write_counter(int counter, int value);
-	inline void advance_seconds();
-	inline void advance_minutes();
-	inline void adjust_seconds();
 	inline void check_alarm();
 
 	static const device_timer_id TIMER_CLOCK = 0;
diff -Nru src-old/emu/machine/rp5c15.c src/emu/machine/rp5c15.c
--- src-old/emu/machine/rp5c15.c	2011-05-02 05:32:58.000000000 +0200
+++ src/emu/machine/rp5c15.c	2012-05-07 08:57:50.000000000 +0200
@@ -72,10 +72,6 @@
 };
 
 
-// days per month
-static const int DAYS_PER_MONTH[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-
 // modes
 enum
 {
@@ -160,111 +156,6 @@
 
 
 //-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void rp5c15_device::advance_seconds()
-{
-	int seconds = read_counter(REGISTER_1_SECOND);
-
-	seconds++;
-
-	if (seconds > 59)
-	{
-		seconds = 0;
-
-		advance_minutes();
-	}
-
-	write_counter(REGISTER_1_SECOND, seconds);
-}
-
-
-//-------------------------------------------------
-//  advance_minutes -
-//-------------------------------------------------
-
-inline void rp5c15_device::advance_minutes()
-{
-	int minutes = read_counter(REGISTER_1_MINUTE);
-	int hours = read_counter(REGISTER_1_HOUR);
-	int days = read_counter(REGISTER_1_DAY);
-	int month = read_counter(REGISTER_1_MONTH);
-	int year = read_counter(REGISTER_1_YEAR);
-	int day_of_week = m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK];
-
-	minutes++;
-
-	if (minutes > 59)
-	{
-		minutes = 0;
-		hours++;
-	}
-
-	if (hours > 23)
-	{
-		hours = 0;
-		days++;
-		day_of_week++;
-	}
-
-	if (day_of_week > 6)
-	{
-		day_of_week++;
-	}
-
-	if (days > DAYS_PER_MONTH[month - 1])
-	{
-		days = 1;
-		month++;
-	}
-
-	if (month > 12)
-	{
-		month = 1;
-		year++;
-		m_reg[MODE01][REGISTER_LEAP_YEAR]++;
-		m_reg[MODE01][REGISTER_LEAP_YEAR] &= 0x03;
-	}
-
-	if (year > 99)
-	{
-		year = 0;
-	}
-
-	write_counter(REGISTER_1_MINUTE, minutes);
-	write_counter(REGISTER_1_HOUR, hours);
-	write_counter(REGISTER_1_DAY, days);
-	write_counter(REGISTER_1_MONTH, month);
-	write_counter(REGISTER_1_YEAR, year);
-	m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK] = day_of_week;
-
-	check_alarm();
-	set_alarm_line();
-}
-
-
-//-------------------------------------------------
-//  adjust_seconds -
-//-------------------------------------------------
-
-inline void rp5c15_device::adjust_seconds()
-{
-	int seconds = read_counter(REGISTER_1_SECOND);
-
-	if (seconds < 30)
-	{
-		write_counter(REGISTER_1_SECOND, 0);
-	}
-	else
-	{
-		write_counter(REGISTER_1_SECOND, 0);
-		advance_minutes();
-	}
-}
-
-
-//-------------------------------------------------
 //  check_alarm -
 //-------------------------------------------------
 
@@ -359,6 +250,16 @@
 
 
 //-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void rp5c15_device::device_reset()
+{
+	set_current_time(machine());
+}
+
+
+//-------------------------------------------------
 //  device_timer - handler timer events
 //-------------------------------------------------
 
@@ -390,12 +291,12 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void rp5c15_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void rp5c15_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
+	m_reg[MODE01][REGISTER_LEAP_YEAR] = year % 4;
 	write_counter(REGISTER_1_YEAR, year);
 	write_counter(REGISTER_1_MONTH, month);
 	write_counter(REGISTER_1_DAY, day);
@@ -403,6 +304,9 @@
 	write_counter(REGISTER_1_HOUR, hour);
 	write_counter(REGISTER_1_MINUTE, minute);
 	write_counter(REGISTER_1_SECOND, second);
+
+	check_alarm();
+	set_alarm_line();
 }
 
 
@@ -489,6 +393,9 @@
 		{
 		case MODE00:
 			m_reg[mode][offset & 0x0f] = data & REGISTER_WRITE_MASK[mode][offset & 0x0f];
+
+			set_time(false, read_counter(REGISTER_1_YEAR), read_counter(REGISTER_1_MONTH), read_counter(REGISTER_1_DAY), m_reg[MODE00][REGISTER_DAY_OF_THE_WEEK],
+				read_counter(REGISTER_1_HOUR), read_counter(REGISTER_1_MINUTE), read_counter(REGISTER_1_SECOND));
 			break;
 
 		case MODE01:
diff -Nru src-old/emu/machine/rp5c15.h src/emu/machine/rp5c15.h
--- src-old/emu/machine/rp5c15.h	2011-04-27 07:11:18.000000000 +0200
+++ src/emu/machine/rp5c15.h	2012-04-27 23:23:39.000000000 +0200
@@ -74,19 +74,17 @@
     // device-level overrides
 	virtual void device_config_complete();
     virtual void device_start();
+    virtual void device_reset();
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual bool rtc_feature_leap_year() { return true; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 private:
 	inline void set_alarm_line();
 	inline int read_counter(int counter);
 	inline void write_counter(int counter, int value);
-	inline void advance_seconds();
-	inline void advance_minutes();
-	inline void adjust_seconds();
 	inline void check_alarm();
 
 	static const device_timer_id TIMER_CLOCK = 0;
diff -Nru src-old/emu/machine/upd1990a.c src/emu/machine/upd1990a.c
--- src-old/emu/machine/upd1990a.c	2012-04-11 05:43:39.000000000 +0200
+++ src/emu/machine/upd1990a.c	2012-04-27 23:23:39.000000000 +0200
@@ -45,91 +45,6 @@
 
 
 //**************************************************************************
-//  INLINE HELPERS
-//**************************************************************************
-
-//-------------------------------------------------
-//  convert_to_bcd -
-//-------------------------------------------------
-
-inline UINT8 upd1990a_device::convert_to_bcd(int val)
-{
-	return ((val / 10) << 4) | (val % 10);
-}
-
-
-//-------------------------------------------------
-//  bcd_to_integer -
-//-------------------------------------------------
-
-inline int upd1990a_device::bcd_to_integer(UINT8 val)
-{
-	return (((val & 0xf0) >> 4) * 10) + (val & 0x0f);
-}
-
-
-//-------------------------------------------------
-//  advance_seconds -
-//-------------------------------------------------
-
-inline void upd1990a_device::advance_seconds()
-{
-	static const int days_per_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-	int seconds = bcd_to_integer(m_time_counter[0]);
-	int minutes = bcd_to_integer(m_time_counter[1]);
-	int hours = bcd_to_integer(m_time_counter[2]);
-	int days = bcd_to_integer(m_time_counter[3]);
-	int day_of_week = m_time_counter[4] & 0x0f;
-	int month = (m_time_counter[4] & 0xf0) >> 4;
-
-	seconds++;
-
-	if (seconds > 59)
-	{
-		seconds = 0;
-		minutes++;
-	}
-
-	if (minutes > 59)
-	{
-		minutes = 0;
-		hours++;
-	}
-
-	if (hours > 23)
-	{
-		hours = 0;
-		days++;
-		day_of_week++;
-	}
-
-	if (day_of_week > 6)
-	{
-		day_of_week++;
-	}
-
-	if (days > days_per_month[month - 1])
-	{
-		days = 1;
-		month++;
-	}
-
-	if (month > 12)
-	{
-		month = 1;
-	}
-
-	m_time_counter[0] = convert_to_bcd(seconds);
-	m_time_counter[1] = convert_to_bcd(minutes);
-	m_time_counter[2] = convert_to_bcd(hours);
-	m_time_counter[3] = convert_to_bcd(days);
-	m_time_counter[4] = (month << 4) | day_of_week;
-}
-
-
-
-//**************************************************************************
 //  LIVE DEVICE
 //**************************************************************************
 
@@ -139,7 +54,8 @@
 
 upd1990a_device::upd1990a_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
     : device_t(mconfig, UPD1990A, "uPD1990A", tag, owner, clock),
-      device_rtc_interface(mconfig, *this)
+      device_rtc_interface(mconfig, *this),
+      m_data_out(0)
 {
 }
 
@@ -203,17 +119,7 @@
 
 void upd1990a_device::device_reset()
 {
-	system_time curtime, *systime = &curtime;
-
-	machine().current_datetime(curtime);
-
-	// HACK: load time counter from system time
-	m_time_counter[0] = convert_to_bcd(systime->local_time.second);
-	m_time_counter[1] = convert_to_bcd(systime->local_time.minute);
-	m_time_counter[2] = convert_to_bcd(systime->local_time.hour);
-	m_time_counter[3] = convert_to_bcd(systime->local_time.mday);
-	m_time_counter[4] = systime->local_time.weekday;
-	m_time_counter[4] |= (systime->local_time.month + 1) << 4;
+	set_current_time(machine());
 }
 
 
@@ -249,11 +155,10 @@
 
 
 //-------------------------------------------------
-//  rtc_set_time - called to initialize the RTC to
-//  a known state
+//  rtc_clock_updated -
 //-------------------------------------------------
 
-void upd1990a_device::rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second)
+void upd1990a_device::rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second)
 {
 	m_time_counter[0] = convert_to_bcd(second);
 	m_time_counter[1] = convert_to_bcd(minute);
@@ -352,6 +257,8 @@
 			for (int i = 0; i < 5; i++)
 			{
 				m_time_counter[i] = m_shift_reg[i];
+
+				set_time(false, 0, m_time_counter[4] >> 4, m_time_counter[4] & 0x0f, m_time_counter[3], m_time_counter[2], m_time_counter[1], m_time_counter[0]);
 			}
 
 			/* 32 Hz time pulse */
diff -Nru src-old/emu/machine/upd1990a.h src/emu/machine/upd1990a.h
--- src-old/emu/machine/upd1990a.h	2012-04-11 05:40:16.000000000 +0200
+++ src/emu/machine/upd1990a.h	2012-04-27 23:23:39.000000000 +0200
@@ -59,7 +59,6 @@
 };
 
 
-
 // ======================> upd1990a_device
 
 class upd1990a_device :	public device_t,
@@ -89,14 +88,9 @@
 	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
 
 	// device_rtc_interface overrides
-	virtual void rtc_set_time(int year, int month, int day, int day_of_week, int hour, int minute, int second);
-	virtual bool rtc_is_year_2000_compliant() { return false; }
+	virtual void rtc_clock_updated(int year, int month, int day, int day_of_week, int hour, int minute, int second);
 
 private:
-	inline UINT8 convert_to_bcd(int val);
-	inline int bcd_to_integer(UINT8 val);
-	inline void advance_seconds();
-
 	static const device_timer_id TIMER_CLOCK = 0;
 	static const device_timer_id TIMER_TP = 1;
 	static const device_timer_id TIMER_DATA_OUT = 2;
diff -Nru src-old/emu/machine.c src/emu/machine.c
--- src-old/emu/machine.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/machine.c	2012-05-03 11:00:08.000000000 +0200
@@ -284,9 +284,6 @@
 	// allocate the gfx elements prior to device initialization
 	gfx_init(*this);
 
-	// initialize natural keyboard support
-	inputx_init(*this);
-
 	// initialize image devices
 	image_init(*this);
 	m_tilemap = auto_alloc(*this, tilemap_manager(*this));
diff -Nru src-old/emu/memory.c src/emu/memory.c
--- src-old/emu/memory.c	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/memory.c	2012-05-03 11:00:08.000000000 +0200
@@ -397,7 +397,7 @@
 	void set_legacy_func(device_t &device, read64_device_func func, const char *name, UINT64 mask = 0);
 
 	// configure I/O port access
-	void set_ioport(const input_port_config &ioport);
+	void set_ioport(ioport_port &ioport);
 
 	// read via the underlying delegates
 	UINT8 read8(address_space &space, offs_t offset, UINT8 mask) const { return m_read.r8(space, offset, mask); }
@@ -419,7 +419,7 @@
 
 	// stubs for reading I/O ports
 	template<typename _UintType>
-	_UintType read_stub_ioport(address_space &space, offs_t offset, _UintType mask) { return input_port_read_direct(m_ioport); }
+	_UintType read_stub_ioport(address_space &space, offs_t offset, _UintType mask) { return m_ioport->read(); }
 
 	// internal helper
 	virtual void remove_subunit(int entry);
@@ -427,7 +427,7 @@
 	// internal state
 	access_handler				m_read;
 	access_handler				m_subread[8];
-	const input_port_config *	m_ioport;
+	ioport_port *	m_ioport;
 
 	bool m_sub_is_legacy[8];
 	legacy_info m_legacy_info;
@@ -504,7 +504,7 @@
 	void set_legacy_func(device_t &device, write64_device_func func, const char *name, UINT64 mask = 0);
 
 	// configure I/O port access
-	void set_ioport(const input_port_config &ioport);
+	void set_ioport(ioport_port &ioport);
 
 	// write via the underlying delegates
 	void write8(address_space &space, offs_t offset, UINT8 data, UINT8 mask) const { m_write.w8(space, offset, data, mask); }
@@ -526,7 +526,7 @@
 
 	// stubs for writing I/O ports
 	template<typename _UintType>
-	void write_stub_ioport(address_space &space, offs_t offset, _UintType data, _UintType mask) { input_port_write_direct(m_ioport, data, mask); }
+	void write_stub_ioport(address_space &space, offs_t offset, _UintType data, _UintType mask) { m_ioport->write(data, mask); }
 
 	// internal helper
 	virtual void remove_subunit(int entry);
@@ -534,7 +534,7 @@
 	// internal state
 	access_handler				m_write;
 	access_handler				m_subwrite[8];
-	const input_port_config *	m_ioport;
+	ioport_port *	m_ioport;
 
 	bool m_sub_is_legacy[8];
 	legacy_info m_legacy_info;
@@ -571,7 +571,7 @@
 	}
 
 	// forward I/O port access configuration
-	void set_ioport(const input_port_config &ioport) const {
+	void set_ioport(ioport_port &ioport) const {
 		for (typename std::list<_HandlerEntry *>::const_iterator i = handlers.begin(); i != handlers.end(); i++)
 			(*i)->set_ioport(ioport);
 	}
@@ -2323,7 +2323,7 @@
 	{
 		// find the port
 		astring fulltag;
-		input_port_config *port = machine().root_device().ioport(device().siblingtag(fulltag, rtag));
+		ioport_port *port = machine().root_device().ioport(device().siblingtag(fulltag, rtag));
 		if (port == NULL)
 			throw emu_fatalerror("Attempted to map non-existent port '%s' for read in space %s of device '%s'\n", rtag, m_name, m_device.tag());
 
@@ -2335,7 +2335,7 @@
 	{
 		// find the port
 		astring fulltag;
-		input_port_config *port = machine().root_device().ioport(device().siblingtag(fulltag, wtag));
+		ioport_port *port = machine().root_device().ioport(device().siblingtag(fulltag, wtag));
 		if (port == NULL)
 			fatalerror("Attempted to map non-existent port '%s' for write in space %s of device '%s'\n", wtag, m_name, m_device.tag());
 
@@ -2930,13 +2930,12 @@
 				throw emu_fatalerror("Unable to allocate bank for RAM/ROM area %X-%X\n", bytestart, byteend);
 		}
 
-		// allocate the bank
+		// if no tag, create a unique one
 		membank = global_alloc(memory_bank(*this, banknum, bytestart, byteend, tag));
-		manager().m_banklist.append(*membank);
-
-		// for named banks, add to the map and register for save states
-		if (tag != NULL)
-			manager().m_bankmap.add_unique_hash(tag, membank, false);
+		astring temptag;
+		if (tag == NULL)
+			tag = temptag.format("anon_%p", membank);
+		manager().m_banklist.append(tag, *membank);
 	}
 
 	// add a reference for this space
@@ -4959,7 +4958,7 @@
 //  of the appropriate size
 //-------------------------------------------------
 
-void handler_entry_read::set_ioport(const input_port_config &ioport)
+void handler_entry_read::set_ioport(ioport_port &ioport)
 {
 	m_ioport = &ioport;
 	if (m_datawidth == 8)
@@ -5414,7 +5413,7 @@
 //  of the appropriate size
 //-------------------------------------------------
 
-void handler_entry_write::set_ioport(const input_port_config &ioport)
+void handler_entry_write::set_ioport(ioport_port &ioport)
 {
 	m_ioport = &ioport;
 	if (m_datawidth == 8)
diff -Nru src-old/emu/memory.h src/emu/memory.h
--- src-old/emu/memory.h	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/memory.h	2012-04-24 06:47:27.000000000 +0200
@@ -829,7 +829,7 @@
 private:
 	// internal helpers
 	memory_bank *first_bank() const { return m_banklist.first(); }
-	memory_bank *bank(const char *tag) const { return m_bankmap.find(tag); }
+	memory_bank *bank(const char *tag) const { return m_banklist.find(tag); }
 	memory_region *region(const char *tag) { return m_regionlist.find(tag); }
 	memory_share *shared(const char *tag) { return m_sharelist.find(tag); }
 	void bank_reattach();
@@ -844,8 +844,7 @@
 	simple_list<address_space>	m_spacelist;			// list of address spaces
 	simple_list<memory_block>	m_blocklist;			// head of the list of memory blocks
 
-	simple_list<memory_bank>	m_banklist;				// data gathered for each bank
-	tagmap_t<memory_bank *>		m_bankmap;				// map for fast bank lookups
+	tagged_list<memory_bank>	m_banklist;				// data gathered for each bank
 	UINT8						m_banknext;				// next bank to allocate
 
 	tagged_list<memory_share>	m_sharelist;			// map for share lookups
diff -Nru src-old/emu/render.c src/emu/render.c
--- src-old/emu/render.c	2012-04-06 21:59:27.000000000 +0200
+++ src/emu/render.c	2012-05-05 22:08:22.000000000 +0200
@@ -1455,7 +1455,7 @@
 bool render_target::map_point_container(INT32 target_x, INT32 target_y, render_container &container, float &container_x, float &container_y)
 {
 	const char *input_tag;
-	UINT32 input_mask;
+	ioport_value input_mask;
 	return map_point_internal(target_x, target_y, &container, container_x, container_y, input_tag, input_mask);
 }
 
@@ -1466,7 +1466,7 @@
 //  container, if possible
 //-------------------------------------------------
 
-bool render_target::map_point_input(INT32 target_x, INT32 target_y, const char *&input_tag, UINT32 &input_mask, float &input_x, float &input_y)
+bool render_target::map_point_input(INT32 target_x, INT32 target_y, const char *&input_tag, ioport_value &input_mask, float &input_x, float &input_y)
 {
 	return map_point_internal(target_x, target_y, NULL, input_x, input_y, input_tag, input_mask);
 }
@@ -1918,7 +1918,7 @@
 //  mapping points
 //-------------------------------------------------
 
-bool render_target::map_point_internal(INT32 target_x, INT32 target_y, render_container *container, float &mapped_x, float &mapped_y, const char *&mapped_input_tag, UINT32 &mapped_input_mask)
+bool render_target::map_point_internal(INT32 target_x, INT32 target_y, render_container *container, float &mapped_x, float &mapped_y, const char *&mapped_input_tag, ioport_value &mapped_input_mask)
 {
 	// default to point not mapped
 	mapped_x = -1.0;
diff -Nru src-old/emu/render.h src/emu/render.h
--- src-old/emu/render.h	2012-01-29 18:34:26.000000000 +0100
+++ src/emu/render.h	2012-05-05 22:08:22.000000000 +0200
@@ -663,7 +663,7 @@
 
 	// hit testing
 	bool map_point_container(INT32 target_x, INT32 target_y, render_container &container, float &container_x, float &container_y);
-	bool map_point_input(INT32 target_x, INT32 target_y, const char *&input_tag, UINT32 &input_mask, float &input_x, float &input_y);
+	bool map_point_input(INT32 target_x, INT32 target_y, const char *&input_tag, ioport_value &input_mask, float &input_x, float &input_y);
 
 	// reference tracking
 	void invalidate_all(void *refptr);
@@ -680,7 +680,7 @@
 	bool load_layout_file(const char *dirname, const char *filename);
 	void add_container_primitives(render_primitive_list &list, const object_transform &xform, render_container &container, int blendmode);
 	void add_element_primitives(render_primitive_list &list, const object_transform &xform, layout_element &element, int state, int blendmode);
-	bool map_point_internal(INT32 target_x, INT32 target_y, render_container *container, float &mapped_x, float &mapped_y, const char *&mapped_input_tag, UINT32 &mapped_input_mask);
+	bool map_point_internal(INT32 target_x, INT32 target_y, render_container *container, float &mapped_x, float &mapped_y, const char *&mapped_input_tag, ioport_value &mapped_input_mask);
 
 	// config callbacks
 	void config_load(xml_data_node &targetnode);
diff -Nru src-old/emu/rendersw.c src/emu/rendersw.c
--- src-old/emu/rendersw.c	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/rendersw.c	2012-04-24 06:54:48.000000000 +0200
@@ -60,7 +60,7 @@
 	// internal helpers
 	static inline bool is_opaque(float alpha) { return (alpha >= (_NoDestRead ? 0.5f : 1.0f)); }
 	static inline bool is_transparent(float alpha) { return (alpha < (_NoDestRead ? 0.5f : 0.0001f)); }
-	static inline rgb_t apply_intensity(rgb_t color, int intensity) { return MAKE_RGB((RGB_RED(color) * intensity) >> 8, (RGB_GREEN(color) * intensity) >> 8, (RGB_BLUE(color) * intensity) >> 8); }
+	static inline rgb_t apply_intensity(int intensity, rgb_t color) { return MAKE_RGB((RGB_RED(color) * intensity) >> 8, (RGB_GREEN(color) * intensity) >> 8, (RGB_BLUE(color) * intensity) >> 8); }
 	static inline float round_nearest(float f) { return floor(f + 0.5f); }
 
 	// destination pixels are written based on the values of the template parameters
diff -Nru src-old/emu/rendlay.c src/emu/rendlay.c
--- src-old/emu/rendlay.c	2012-04-20 16:51:24.000000000 +0200
+++ src/emu/rendlay.c	2012-05-07 08:57:50.000000000 +0200
@@ -486,6 +486,10 @@
 		{
 			m_maxstate = xml_get_attribute_int_with_subst(machine, *compnode, "maxstate", 999);
 		}
+		if (newcomp.m_type == component::CTYPE_REEL)
+		{
+			m_maxstate = 65536;
+		}
 	}
 
 	// determine the scale/offset for normalization
@@ -605,10 +609,16 @@
 layout_element::component::component(running_machine &machine, xml_data_node &compnode, const char *dirname)
 	: m_next(NULL),
 	  m_type(CTYPE_INVALID),
-	  m_state(0),
-	  m_file(NULL),
-	  m_hasalpha(false)
+	  m_state(0)
 {
+	for (int i=0;i<MAX_BITMAPS;i++)
+	{
+		m_hasalpha[i] = false;
+		m_file[i] = NULL;
+	}
+
+
+
 	// fetch common data
 	m_state = xml_get_attribute_int_with_subst(machine, compnode, "state", -1);
 	parse_bounds(machine, xml_get_sibling(compnode.child, "bounds"), m_bounds);
@@ -619,9 +629,9 @@
 	{
 		m_type = CTYPE_IMAGE;
 		m_dirname = dirname;
-		m_imagefile = xml_get_attribute_string_with_subst(machine, compnode, "file", "");
-		m_alphafile = xml_get_attribute_string_with_subst(machine, compnode, "alphafile", "");
-		m_file = global_alloc(emu_file(machine.options().art_path(), OPEN_FLAG_READ));
+		m_imagefile[0] = xml_get_attribute_string_with_subst(machine, compnode, "file", "");
+		m_alphafile[0] = xml_get_attribute_string_with_subst(machine, compnode, "alphafile", "");
+		m_file[0] = global_alloc(emu_file(machine.options().art_path(), OPEN_FLAG_READ));
 	}
 
 	// text nodes
@@ -642,7 +652,55 @@
 		m_type = CTYPE_SIMPLECOUNTER;
 		m_digits = xml_get_attribute_int_with_subst(machine, compnode, "digits", 2);
 	}
+	// fruit machine reels
+	else if (strcmp(compnode.name, "reel") == 0)
+	{
+		m_type = CTYPE_REEL;
+
+		astring symbollist = xml_get_attribute_string_with_subst(machine, compnode, "symbollist", "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
+
+		// split out position names from string and figure out our number of symbols
+		int location = -1;
+		m_numstops = 0;
+		location=symbollist.find(0,",");
+		while (location!=-1)
+		{
+			m_stopnames[m_numstops] = symbollist;
+			m_stopnames[m_numstops].substr(0, location);
+			symbollist.substr(location+1, symbollist.len()-(location-1));
+			m_numstops++;
+			location=symbollist.find(0,",");
+		}
+		m_stopnames[m_numstops++] = symbollist;
+
+		// careful, dirname is NULL if we're coming from internal layout, and our string assignment doesn't like that
+		if (dirname != NULL)
+			m_dirname = dirname;
+
+		for (int i=0;i<m_numstops;i++)
+		{
+			location=m_stopnames[i].find(0,":");
+			if (location!=-1)
+			{
+				m_imagefile[i] = m_stopnames[i];
+				m_stopnames[i].substr(0, location);
+				m_imagefile[i].substr(location+1, m_imagefile[i].len()-(location-1));
+
+				//m_alphafile[i] =
+				m_file[i] = global_alloc(emu_file(machine.options().art_path(), OPEN_FLAG_READ));
+			}
+			else
+			{
+				//m_imagefile[i] = 0;
+				//m_alphafile[i] = 0;
+				m_file[i] = 0;
+			}
+		}
 
+		m_stateoffset = xml_get_attribute_int_with_subst(machine, compnode, "stateoffset", 0);
+		m_numsymbolsvisible = xml_get_attribute_int_with_subst(machine, compnode, "numsymbolsvisible", 3);
+		m_reelreversed = xml_get_attribute_int_with_subst(machine, compnode, "reelreversed", 0);
+	}
 	// led7seg nodes
 	else if (strcmp(compnode.name, "led7seg") == 0)
 		m_type = CTYPE_LED7SEG;
@@ -683,7 +741,10 @@
 
 layout_element::component::~component()
 {
-	global_free(m_file);
+	for (int i=0;i<MAX_BITMAPS;i++)
+	{
+		global_free(m_file[i]);
+	}
 }
 
 
@@ -696,11 +757,11 @@
 	switch (m_type)
 	{
 		case CTYPE_IMAGE:
-			if (!m_bitmap.valid())
+			if (!m_bitmap[0].valid())
 				load_bitmap();
 			{
 				bitmap_argb32 destsub(dest, bounds);
-				render_resample_argb_bitmap_hq(destsub, m_bitmap, m_color);
+				render_resample_argb_bitmap_hq(destsub, m_bitmap[0], m_color);
 			}
 			break;
 
@@ -744,6 +805,11 @@
 			draw_simplecounter(machine, dest, bounds, state);
 			break;
 
+		case CTYPE_REEL:
+
+			draw_reel(machine, dest, bounds, state);
+			break;
+
 		default:
 			throw emu_fatalerror("Unknown component type requested draw()");
 	}
@@ -940,6 +1006,166 @@
 	draw_text(machine, dest, bounds);
 }
 
+/* state is a normalized value between 0 and 65536 so that we don't need to worry about how many motor steps here or in the .lay, only the number of symbols */
+void layout_element::component::draw_reel(running_machine &machine, bitmap_argb32 &dest, const rectangle &bounds, int state)
+{
+
+
+	const int max_state_used = 0x10000;
+
+	// shift the reels a bit based on this param, allows fine tuning
+	int use_state = (state + m_stateoffset) % max_state_used;
+
+	// compute premultiplied colors
+	UINT32 r = m_color.r * 255.0;
+	UINT32 g = m_color.g * 255.0;
+	UINT32 b = m_color.b * 255.0;
+	UINT32 a = m_color.a * 255.0;
+
+	// get the width of the string
+	render_font *font = machine.render().font_alloc("default");
+	float aspect = 1.0f;
+	INT32 width;
+	int curry = 0;
+	int num_shown = m_numsymbolsvisible;
+
+	int ourheight = bounds.height();
+
+	for (int fruit = 0;fruit<m_numstops;fruit++)
+	{
+
+
+		int basey;
+
+		if (m_reelreversed==1)
+		{
+			basey = bounds.min_y + ((use_state)*(ourheight/num_shown)/(max_state_used/m_numstops)) + curry;
+		}
+		else
+		{
+			basey = bounds.min_y - ((use_state)*(ourheight/num_shown)/(max_state_used/m_numstops)) + curry;
+		}
+
+		// wrap around...
+		if (basey < bounds.min_y)
+			basey += ((max_state_used)*(ourheight/num_shown)/(max_state_used/m_numstops));
+		if (basey > bounds.max_y)
+			basey -= ((max_state_used)*(ourheight/num_shown)/(max_state_used/m_numstops));
+
+		int endpos = basey+ourheight/num_shown;
+
+		// only render the symbol / text if it's atually in view because the code is SLOW
+		if ((endpos >= bounds.min_y) && (basey <= bounds.max_y))
+		{
+
+			while (1)
+			{
+				width = font->string_width(ourheight/num_shown, aspect, m_stopnames[fruit]);
+				if (width < bounds.width())
+					break;
+				aspect *= 0.9f;
+			}
+
+			INT32 curx;
+			curx = bounds.min_x + (bounds.width() - width) / 2;
+
+			if (m_file[fruit])
+				if (!m_bitmap[fruit].valid())
+					load_reel_bitmap(fruit);
+
+			if (m_file[fruit]) // render gfx
+			{
+				bitmap_argb32 tempbitmap2(dest.width(), ourheight/num_shown);
+
+				if (m_bitmap[fruit].valid())
+				{
+					render_resample_argb_bitmap_hq(tempbitmap2, m_bitmap[fruit], m_color);
+
+					for (int y = 0; y < ourheight/num_shown; y++)
+					{
+						int effy = basey + y;
+
+						if (effy >= bounds.min_y && effy <= bounds.max_y)
+						{
+							UINT32 *src = &tempbitmap2.pix32(y);
+							UINT32 *d = &dest.pix32(effy);
+							for (int x = 0; x < dest.width(); x++)
+							{
+								int effx = x;
+								if (effx >= bounds.min_x && effx <= bounds.max_x)
+								{
+
+									UINT32 spix = RGB_ALPHA(src[x]);
+									if (spix != 0)
+									{
+										d[effx] = src[x];
+									}
+								}
+							}
+						}
+
+					}
+				}
+			}
+			else // render text (fallback)
+			{
+				// allocate a temporary bitmap
+				bitmap_argb32 tempbitmap(dest.width(), dest.height());
+
+				// loop over characters
+				for (const char *s = m_stopnames[fruit]; *s != 0; s++)
+				{
+					// get the font bitmap
+					rectangle chbounds;
+					font->get_scaled_bitmap_and_bounds(tempbitmap, ourheight/num_shown, aspect, *s, chbounds);
+
+					// copy the data into the target
+					for (int y = 0; y < chbounds.height(); y++)
+					{
+						int effy = basey + y;
+
+						if (effy >= bounds.min_y && effy <= bounds.max_y)
+						{
+							UINT32 *src = &tempbitmap.pix32(y);
+							UINT32 *d = &dest.pix32(effy);
+							for (int x = 0; x < chbounds.width(); x++)
+							{
+								int effx = curx + x + chbounds.min_x;
+								if (effx >= bounds.min_x && effx <= bounds.max_x)
+								{
+
+									UINT32 spix = RGB_ALPHA(src[x]);
+									if (spix != 0)
+									{
+										UINT32 dpix = d[effx];
+										UINT32 ta = (a * (spix + 1)) >> 8;
+										UINT32 tr = (r * ta + RGB_RED(dpix) * (0x100 - ta)) >> 8;
+										UINT32 tg = (g * ta + RGB_GREEN(dpix) * (0x100 - ta)) >> 8;
+										UINT32 tb = (b * ta + RGB_BLUE(dpix) * (0x100 - ta)) >> 8;
+										d[effx] = MAKE_ARGB(0xff, tr, tg, tb);
+									}
+								}
+							}
+						}
+					}
+
+					// advance in the X direction
+					curx += font->char_width(ourheight/num_shown, aspect, *s);
+
+				}
+
+			}
+		}
+
+		curry += ourheight/num_shown;
+	}
+
+	// free the temporary bitmap and font
+	machine.render().font_free(font);
+}
+
+
+
 
 //-------------------------------------------------
 //  load_bitmap - load a PNG file with artwork for
@@ -949,32 +1175,55 @@
 void layout_element::component::load_bitmap()
 {
 	// load the basic bitmap
-	assert(m_file != NULL);
-	m_hasalpha = render_load_png(m_bitmap, *m_file, m_dirname, m_imagefile);
+	assert(m_file[0] != NULL);
+	m_hasalpha[0] = render_load_png(m_bitmap[0], *m_file[0], m_dirname, m_imagefile[0]);
 
 	// load the alpha bitmap if specified
-	if (m_bitmap.valid() && m_alphafile)
-		render_load_png(m_bitmap, *m_file, m_dirname, m_alphafile, true);
+	if (m_bitmap[0].valid() && m_alphafile[0])
+		render_load_png(m_bitmap[0], *m_file[0], m_dirname, m_alphafile[0], true);
 
 	// if we can't load the bitmap, allocate a dummy one and report an error
-	if (!m_bitmap.valid())
+	if (!m_bitmap[0].valid())
 	{
 		// draw some stripes in the bitmap
-		m_bitmap.allocate(100, 100);
-		m_bitmap.fill(0);
+		m_bitmap[0].allocate(100, 100);
+		m_bitmap[0].fill(0);
 		for (int step = 0; step < 100; step += 25)
 			for (int line = 0; line < 100; line++)
-				m_bitmap.pix32((step + line) % 100, line % 100) = MAKE_ARGB(0xff,0xff,0xff,0xff);
+				m_bitmap[0].pix32((step + line) % 100, line % 100) = MAKE_ARGB(0xff,0xff,0xff,0xff);
 
 		// log an error
-		if (!m_alphafile)
-			mame_printf_warning("Unable to load component bitmap '%s'", m_imagefile.cstr());
+		if (!m_alphafile[0])
+			mame_printf_warning("Unable to load component bitmap '%s'", m_imagefile[0].cstr());
 		else
-			mame_printf_warning("Unable to load component bitmap '%s'/'%s'", m_imagefile.cstr(), m_alphafile.cstr());
+			mame_printf_warning("Unable to load component bitmap '%s'/'%s'", m_imagefile[0].cstr(), m_alphafile[0].cstr());
 	}
 }
 
 
+void layout_element::component::load_reel_bitmap(int number)
+{
+
+	// load the basic bitmap
+	assert(m_file != NULL);
+	/*m_hasalpha[number] = */ render_load_png(m_bitmap[number], *m_file[number], m_dirname, m_imagefile[number]);
+
+	// load the alpha bitmap if specified
+	//if (m_bitmap[number].valid() && m_alphafile[number])
+	//  render_load_png(m_bitmap[number], *m_file[number], m_dirname, m_alphafile[number], true);
+
+	// if we can't load the bitmap just use text rendering
+	if (!m_bitmap[number].valid())
+	{
+		// fallback to text rendering
+		global_free(m_file[number]);
+		m_file[number] = NULL;
+	}
+
+}
+
+
+
 //-------------------------------------------------
 //  draw_led7seg - draw a 7-segment LCD
 //-------------------------------------------------
@@ -1959,9 +2208,13 @@
 	// if configured to an input, fetch the input value
 	else if (m_input_tag[0] != 0)
 	{
-		const input_field_config *field = input_field_by_tag_and_mask(m_element->machine(), m_input_tag, m_input_mask);
-		if (field != NULL)
-			state = ((input_port_read_safe(m_element->machine(), m_input_tag, 0) ^ field->defvalue) & m_input_mask) ? 1 : 0;
+		ioport_port *port = m_element->machine().root_device().ioport(m_input_tag);
+		if (port != NULL)
+		{
+			ioport_field *field = port->field(m_input_mask);
+			if (field != NULL)
+				state = ((port->read() ^ field->defvalue()) & m_input_mask) ? 1 : 0;
+		}
 	}
 	return state;
 }
diff -Nru src-old/emu/rendlay.h src/emu/rendlay.h
--- src-old/emu/rendlay.h	2012-04-20 16:51:24.000000000 +0200
+++ src/emu/rendlay.h	2012-05-05 22:08:22.000000000 +0200
@@ -122,6 +122,7 @@
 			CTYPE_LED16SEGSC,
 			CTYPE_DOTMATRIX,
 			CTYPE_SIMPLECOUNTER,
+			CTYPE_REEL,
 			CTYPE_MAX
 		};
 
@@ -130,7 +131,9 @@
 		void draw_disk(bitmap_argb32 &dest, const rectangle &bounds);
 		void draw_text(running_machine &machine, bitmap_argb32 &dest, const rectangle &bounds);
 		void draw_simplecounter(running_machine &machine, bitmap_argb32 &dest, const rectangle &bounds, int state);
+		void draw_reel(running_machine &machine, bitmap_argb32 &dest, const rectangle &bounds, int state);
 		void load_bitmap();
+		void load_reel_bitmap(int number);
 		void draw_led7seg(bitmap_argb32 &dest, const rectangle &bounds, int pattern);
 		void draw_led14seg(bitmap_argb32 &dest, const rectangle &bounds, int pattern);
 		void draw_led14segsc(bitmap_argb32 &dest, const rectangle &bounds, int pattern);
@@ -147,21 +150,32 @@
 		void draw_segment_comma(bitmap_argb32 &dest, int minx, int maxx, int miny, int maxy, int width, rgb_t color);
 		void apply_skew(bitmap_argb32 &dest, int skewwidth);
 
+		#define MAX_BITMAPS 32
+
 		// internal state
-		component *			m_next;			// link to next component
-		component_type		m_type;			// type of component
-		int					m_state;		// state where this component is visible (-1 means all states)
-		render_bounds		m_bounds;		// bounds of the element
-		render_color		m_color;		// color of the element
-		astring				m_string;		// string for text components
-		int					m_digits;		// number of digits for simple counters
-		int					m_textalign;	// text alignment to box
-		bitmap_argb32		m_bitmap;		// source bitmap for images
-		astring				m_dirname;		// directory name of image file (for lazy loading)
-		emu_file *			m_file;			// file object for reading image/alpha files
-		astring				m_imagefile;	// name of the image file (for lazy loading)
-		astring				m_alphafile;	// name of the alpha file (for lazy loading)
-		bool				m_hasalpha;		// is there any alpha component present?
+		component *			m_next;						// link to next component
+		component_type		m_type;						// type of component
+		int					m_state;					// state where this component is visible (-1 means all states)
+		render_bounds		m_bounds;					// bounds of the element
+		render_color		m_color;					// color of the element
+		astring				m_string;					// string for text components
+		int					m_digits;					// number of digits for simple counters
+		int					m_textalign;				// text alignment to box
+		bitmap_argb32		m_bitmap[MAX_BITMAPS];		// source bitmap for images
+		astring				m_dirname;					// directory name of image file (for lazy loading)
+		emu_file *			m_file[MAX_BITMAPS];		// file object for reading image/alpha files
+		astring				m_imagefile[MAX_BITMAPS];	// name of the image file (for lazy loading)
+		astring				m_alphafile[MAX_BITMAPS];	// name of the alpha file (for lazy loading)
+		bool				m_hasalpha[MAX_BITMAPS];	// is there any alpha component present?
+
+		// stuff for fruit machine reels
+		// basically made up of multiple text strings / gfx
+		int					m_numstops;
+		astring				m_stopnames[MAX_BITMAPS];
+		int					m_stateoffset;
+		int					m_reelreversed;
+		int					m_numsymbolsvisible;
+
 	};
 
 	// a texture encapsulates a texture for a given element in a given state
@@ -218,7 +232,7 @@
 		int orientation() const { return m_orientation; }
 		render_container *screen_container(running_machine &machine) const { return (m_screen != NULL) ? &m_screen->container() : NULL; }
 		bool has_input() const { return bool(m_input_tag); }
-		const char *input_tag_and_mask(UINT32 &mask) const { mask = m_input_mask; return m_input_tag; }
+		const char *input_tag_and_mask(ioport_value &mask) const { mask = m_input_mask; return m_input_tag; }
 
 		// fetch state based on configured source
 		int state() const;
@@ -229,7 +243,7 @@
 		layout_element *	m_element;			// pointer to the associated element (non-screens only)
 		astring				m_output_name;		// name of this item
 		astring				m_input_tag;		// input tag of this item
-		UINT32				m_input_mask;		// input mask of this item
+		ioport_value		m_input_mask;		// input mask of this item
 		screen_device *		m_screen;			// pointer to screen
 		int					m_orientation;		// orientation of this item
 		render_bounds		m_bounds;			// bounds of the item
diff -Nru src-old/emu/romload.c src/emu/romload.c
--- src-old/emu/romload.c	2012-04-20 07:54:39.000000000 +0200
+++ src/emu/romload.c	2012-04-30 15:39:32.000000000 +0200
@@ -63,8 +63,6 @@
 	running_machine &machine() const { assert(m_machine != NULL); return *m_machine; }
 
 	running_machine *m_machine;			/* machine object where needed */
-	int				system_bios;		/* the system BIOS we wish to load */
-	int				default_bios;		/* the default system BIOS */
 
 	int				warnings;			/* warning count during processing */
 	int				knownbad;			/* BAD_DUMP/NO_DUMP count during processing */
@@ -292,10 +290,9 @@
 	int default_no = 1;
 	int bios_count = 0;
 
-	romdata->system_bios = 0;
 
 	device_t &rootdevice = romdata->machine().config().root_device();
-
+	rootdevice.set_system_bios(0);
 	/* first determine the default BIOS name */
 	for (rom = rootdevice.rom_region(); !ROMENTRY_ISEND(rom); rom++)
 		if (ROMENTRY_ISDEFAULT_BIOS(rom))
@@ -312,14 +309,14 @@
 			/* Allow '-bios n' to still be used */
 			sprintf(bios_number, "%d", bios_flags - 1);
 			if (mame_stricmp(bios_number, specbios) == 0 || mame_stricmp(biosname, specbios) == 0)
-				romdata->system_bios = bios_flags;
+				rootdevice.set_system_bios(bios_flags);
 			if (defaultname != NULL && mame_stricmp(biosname, defaultname) == 0)
 				default_no = bios_flags;
 			bios_count++;
 		}
 
 	/* if none found, use the default */
-	if (romdata->system_bios == 0 && bios_count > 0)
+	if (rootdevice.system_bios() == 0 && bios_count > 0)
 	{
 		/* if we got neither an empty string nor 'default' then warn the user */
 		if (specbios[0] != 0 && strcmp(specbios, "default") != 0 && romdata != NULL)
@@ -329,10 +326,10 @@
 		}
 
 		/* set to default */
-		romdata->system_bios = default_no;
+		rootdevice.set_system_bios(default_no);
 	}
-	romdata->default_bios = default_no;
-	LOG(("Using System BIOS: %d\n", romdata->system_bios));
+	rootdevice.set_default_bios(default_no);
+	LOG(("Using System BIOS: %d\n", rootdevice.system_bios()));
 }
 
 
@@ -354,7 +351,7 @@
 	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
 		for (region = rom_first_region(*device); region != NULL; region = rom_next_region(region))
 			for (rom = rom_first_file(region); rom != NULL; rom = rom_next_file(rom))
-				if (ROM_GETBIOSFLAGS(rom) == 0 || ROM_GETBIOSFLAGS(rom) == romdata->system_bios)
+				if (ROM_GETBIOSFLAGS(rom) == 0 || ROM_GETBIOSFLAGS(rom) == romdata->machine().config().root_device().system_bios())
 				{
 					romdata->romstotal++;
 					romdata->romstotalsize += rom_file_size(rom);
@@ -880,7 +877,7 @@
 		/* handle files */
 		else if (ROMENTRY_ISFILE(romp))
 		{
-			int irrelevantbios = (ROM_GETBIOSFLAGS(romp) != 0 && ROM_GETBIOSFLAGS(romp) != romdata->system_bios);
+			int irrelevantbios = (ROM_GETBIOSFLAGS(romp) != 0 && ROM_GETBIOSFLAGS(romp) != romdata->machine().config().root_device().system_bios());
 			const rom_entry *baserom = romp;
 			int explength = 0;
 
@@ -1503,21 +1500,3 @@
 	return machine.romload_data->knownbad;
 }
 
-
-/*-------------------------------------------------
-    rom_system_bios - return id of selected bios
--------------------------------------------------*/
-
-int rom_system_bios(running_machine &machine)
-{
-	return machine.romload_data->system_bios;
-}
-
-/*-------------------------------------------------
-    rom_default_bios - return id of default bios
--------------------------------------------------*/
-
-int rom_default_bios(running_machine &machine)
-{
-	return machine.romload_data->default_bios;
-}
diff -Nru src-old/emu/romload.h src/emu/romload.h
--- src-old/emu/romload.h	2012-02-20 08:06:58.000000000 +0100
+++ src/emu/romload.h	2012-04-30 15:39:32.000000000 +0200
@@ -268,12 +268,6 @@
 /* return the number of BAD_DUMP/NO_DUMP warnings we generated */
 int rom_load_knownbad(running_machine &machine);
 
-/* return id of selected bios */
-int rom_system_bios(running_machine &machine);
-
-/* return id of default bios */
-int rom_default_bios(running_machine &machine);
-
 /* ----- Helpers ----- */
 
 file_error common_process_file(emu_options &options, const char *location, const char *ext, const rom_entry *romp, emu_file **image_file);
diff -Nru src-old/emu/screen.c src/emu/screen.c
--- src-old/emu/screen.c	2012-04-20 07:54:39.000000000 +0200
+++ src/emu/screen.c	2012-05-07 08:57:50.000000000 +0200
@@ -782,6 +782,17 @@
 
 
 //-------------------------------------------------
+//  vblank_port_read - custom port handler to
+//  return a VBLANK state
+//-------------------------------------------------
+
+int screen_device::vblank_port_read()
+{
+	return vblank();
+}
+
+
+//-------------------------------------------------
 //  vblank_begin - call any external callbacks to
 //  signal the VBLANK period has begun
 //-------------------------------------------------
diff -Nru src-old/emu/screen.h src/emu/screen.h
--- src-old/emu/screen.h	2012-04-06 21:59:27.000000000 +0200
+++ src/emu/screen.h	2012-05-03 11:00:08.000000000 +0200
@@ -227,6 +227,7 @@
 	// additional helpers
 	void register_vblank_callback(vblank_state_delegate vblank_callback);
 	void register_screen_bitmap(bitmap_t &bitmap);
+	int vblank_port_read();
 
 	// internal to the video system
 	bool update_quads();
diff -Nru src-old/emu/sound/disc_cls.h src/emu/sound/disc_cls.h
--- src-old/emu/sound/disc_cls.h	2011-01-24 07:09:05.000000000 +0100
+++ src/emu/sound/disc_cls.h	2012-05-03 11:00:08.000000000 +0200
@@ -149,7 +149,7 @@
 	void step(void);
 	void reset(void);
 private:
-	const input_port_config *m_port;
+	ioport_port *m_port;
 	INT32					m_lastpval;
 	INT32					m_pmin;
 	double					m_pscale;
diff -Nru src-old/emu/sound/disc_inp.c src/emu/sound/disc_inp.c
--- src-old/emu/sound/disc_inp.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/sound/disc_inp.c	2012-05-03 11:00:08.000000000 +0200
@@ -55,7 +55,7 @@
 
 DISCRETE_STEP(dss_adjustment)
 {
-	INT32  rawportval = input_port_read_direct(m_port);
+	INT32  rawportval = m_port->read();
 
 	/* only recompute if the value changed from last time */
 	if (UNEXPECTED(rawportval != m_lastpval))
diff -Nru src-old/emu/sound/i5000.c src/emu/sound/i5000.c
--- src-old/emu/sound/i5000.c	2012-04-22 16:10:44.000000000 +0200
+++ src/emu/sound/i5000.c	2012-05-07 08:57:50.000000000 +0200
@@ -45,6 +45,29 @@
 
 	m_rom_base = (UINT16 *)device().machine().root_device().memregion(":i5000snd")->base();
 	m_rom_mask = device().machine().root_device().memregion(":i5000snd")->bytes() / 2 - 1;
+
+	// register for savestates
+	for (int ch = 0; ch < 16; ch++)
+	{
+		save_item(NAME(m_channels[ch].is_playing), ch);
+		save_item(NAME(m_channels[ch].m_adpcm.m_signal), ch);
+		save_item(NAME(m_channels[ch].m_adpcm.m_step), ch);
+
+        save_item(NAME(m_channels[ch].address), ch);
+        save_item(NAME(m_channels[ch].freq_timer), ch);
+        save_item(NAME(m_channels[ch].freq_base), ch);
+        save_item(NAME(m_channels[ch].freq_min), ch);
+        save_item(NAME(m_channels[ch].sample), ch);
+        save_item(NAME(m_channels[ch].shift_pos), ch);
+        save_item(NAME(m_channels[ch].shift_amount), ch);
+        save_item(NAME(m_channels[ch].shift_mask), ch);
+        save_item(NAME(m_channels[ch].vol_r), ch);
+        save_item(NAME(m_channels[ch].vol_l), ch);
+        save_item(NAME(m_channels[ch].output_r), ch);
+        save_item(NAME(m_channels[ch].output_l), ch);
+	}
+
+	save_item(NAME(m_regs));
 }
 
 
diff -Nru src-old/emu/sound/pokey.c src/emu/sound/pokey.c
--- src-old/emu/sound/pokey.c	2011-05-02 05:32:58.000000000 +0200
+++ src/emu/sound/pokey.c	2012-05-03 11:16:42.000000000 +0200
@@ -274,7 +274,7 @@
 	/* is this a filtering channel (3/4) and is the filter active? */	\
 	if( chip->AUDCTL & ((CH1_FILTER|CH2_FILTER) & (0x10 >> ch)) )		\
     {                                                                   \
-		if( chip->output[ch-2] )										\
+		if( ch >= 2 && chip->output[ch-2] )								\
         {                                                               \
 			chip->output[ch-2] = 0;										\
 			if( chip->audible[ch] )										\
@@ -318,7 +318,7 @@
 	/* is this a filtering channel (3/4) and is the filter active? */	\
 	if( chip->AUDCTL & ((CH1_FILTER|CH2_FILTER) & (0x10 >> ch)) )		\
     {                                                                   \
-		if( chip->output[ch-2] )										\
+		if( ch >= 2 && chip->output[ch-2] )								\
         {                                                               \
 			chip->output[ch-2] = 0;										\
 			sum -= chip->volume[ch-2];									\
diff -Nru src-old/emu/sound/sound.mak src/emu/sound/sound.mak
--- src-old/emu/sound/sound.mak	2012-04-13 15:32:27.000000000 +0200
+++ src/emu/sound/sound.mak	2012-04-29 20:47:24.000000000 +0200
@@ -379,7 +379,7 @@
 # OKI ADPCM sample players
 #-------------------------------------------------
 
-ifneq ($(filter OKIM6258 OKIM9810,$(SOUNDS)),)
+ifneq ($(filter OKIM6258 OKIM6295 OKIM9810 I5000_SND,$(SOUNDS)),)
 SOUNDOBJS += $(SOUNDOBJ)/okiadpcm.o
 endif
 
diff -Nru src-old/emu/sound/tms5220.c src/emu/sound/tms5220.c
--- src-old/emu/sound/tms5220.c	2011-08-23 06:59:11.000000000 +0200
+++ src/emu/sound/tms5220.c	2012-05-03 11:16:42.000000000 +0200
@@ -988,7 +988,7 @@
 #endif
 
 			/* if TS is now 0, ramp the energy down to 0. Is this really correct to hardware? */
-			if ( (tms->talk_status == 0))
+			if (tms->talk_status == 0)
 			{
 #ifdef DEBUG_GENERATION
 				fprintf(stderr,"Talk status is 0, forcing target energy to 0\n");
diff -Nru src-old/emu/sound.c src/emu/sound.c
--- src-old/emu/sound.c	2012-02-28 11:21:05.000000000 +0100
+++ src/emu/sound.c	2012-05-07 08:57:50.000000000 +0200
@@ -84,13 +84,11 @@
 	  m_new_sample_rate(0),
 	  m_attoseconds_per_sample(0),
 	  m_max_samples_per_update(0),
-	  m_inputs(inputs),
-	  m_input((inputs == 0) ? NULL : auto_alloc_array_clear(device.machine(), stream_input, inputs)),
-	  m_input_array((inputs == 0) ? NULL : auto_alloc_array_clear(device.machine(), stream_sample_t *, inputs)),
+	  m_input(inputs),
+	  m_input_array(inputs),
 	  m_resample_bufalloc(0),
-	  m_outputs(outputs),
-	  m_output((outputs == 0) ? NULL : auto_alloc_array_clear(device.machine(), stream_output, outputs)),
-	  m_output_array((outputs == 0) ? NULL : auto_alloc_array_clear(device.machine(), stream_sample_t *, outputs)),
+	  m_output(outputs),
+	  m_output_array(outputs),
 	  m_output_bufalloc(0),
 	  m_output_sampindex(0),
 	  m_output_update_sampindex(0),
@@ -114,9 +112,12 @@
 	m_device.machine().save().register_postload(save_prepost_delegate(FUNC(sound_stream::postload), this));
 
 	// save the gain of each input and output
-	for (int inputnum = 0; inputnum < m_inputs; inputnum++)
+	for (int inputnum = 0; inputnum < m_input.count(); inputnum++)
+	{
 		m_device.machine().save().save_item("stream", state_tag, inputnum, NAME(m_input[inputnum].m_gain));
-	for (int outputnum = 0; outputnum < m_outputs; outputnum++)
+		m_device.machine().save().save_item("stream", state_tag, inputnum, NAME(m_input[inputnum].m_user_gain));
+	}
+	for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
 	{
 		m_output[outputnum].m_stream = this;
 		m_device.machine().save().save_item("stream", state_tag, outputnum, NAME(m_output[outputnum].m_gain));
@@ -143,26 +144,38 @@
 
 
 //-------------------------------------------------
+//  user_gain - return the user-controllable gain
+//  on a given stream's input
+//-------------------------------------------------
+
+float sound_stream::user_gain(int inputnum) const
+{
+	assert(inputnum >= 0 && inputnum < m_input.count());
+	return float(m_input[inputnum].m_user_gain) / 256.0f;
+}
+
+
+//-------------------------------------------------
 //  input_gain - return the input gain on a
 //  given stream's input
 //-------------------------------------------------
 
 float sound_stream::input_gain(int inputnum) const
 {
-	assert(inputnum >= 0 && inputnum < m_inputs);
+	assert(inputnum >= 0 && inputnum < m_input.count());
 	return float(m_input[inputnum].m_gain) / 256.0f;
 }
 
 
 //-------------------------------------------------
-//  initial_input_gain - return the original input
-//  gain on a given stream's input
+//  output_gain - return the output gain on a
+//  given stream's output
 //-------------------------------------------------
 
-float sound_stream::initial_input_gain(int inputnum) const
+float sound_stream::output_gain(int outputnum) const
 {
-	assert(inputnum >= 0 && inputnum < m_inputs);
-	return float(m_input[inputnum].m_initial_gain) / 256.0f;
+	assert(outputnum >= 0 && outputnum < m_output.count());
+	return float(m_output[outputnum].m_gain) / 256.0f;
 }
 
 
@@ -174,7 +187,7 @@
 const char *sound_stream::input_name(int inputnum, astring &string) const
 {
 	// start with our device name and tag
-	assert(inputnum >= 0 && inputnum < m_inputs);
+	assert(inputnum >= 0 && inputnum < m_input.count());
 	string.printf("%s '%s': ", m_device.name(), m_device.tag());
 
 	// if we have a source, indicate where the sound comes from by device name and tag
@@ -204,14 +217,26 @@
 
 
 //-------------------------------------------------
-//  output_gain - return the output gain on a
-//  given stream's output
+//  input_source_device - return the device
+//  attached as a given input's source
 //-------------------------------------------------
 
-float sound_stream::output_gain(int outputnum) const
+device_t *sound_stream::input_source_device(int inputnum) const
 {
-	assert(outputnum >= 0 && outputnum < m_outputs);
-	return float(m_output[outputnum].m_gain) / 256.0f;
+	assert(inputnum >= 0 && inputnum < m_input.count());
+	return (m_input[inputnum].m_source != NULL) ? &m_input[inputnum].m_source->m_stream->device() : NULL;
+}
+
+
+//-------------------------------------------------
+//  input_source_device - return the output number
+//  attached as a given input's source
+//-------------------------------------------------
+
+int sound_stream::input_source_outputnum(int inputnum) const
+{
+	assert(inputnum >= 0 && inputnum < m_input.count());
+	return (m_input[inputnum].m_source != NULL) ? (m_input[inputnum].m_source - &m_input[inputnum].m_source->m_stream->m_output[0]) : -1;
 }
 
 
@@ -224,12 +249,12 @@
 	VPRINTF(("stream_set_input(%p, '%s', %d, %p, %d, %f)\n", this, m_device.tag(), index, input_stream, output_index, gain));
 
 	// make sure it's a valid input
-	if (index >= m_inputs)
-		fatalerror("Fatal error: stream_set_input attempted to configure non-existant input %d (%d max)", index, m_inputs);
+	if (index >= m_input.count())
+		fatalerror("Fatal error: stream_set_input attempted to configure non-existant input %d (%d max)", index, m_input.count());
 
 	// make sure it's a valid output
-	if (input_stream != NULL && output_index >= input_stream->m_outputs)
-		fatalerror("Fatal error: stream_set_input attempted to use a non-existant output %d (%d max)", output_index, m_outputs);
+	if (input_stream != NULL && output_index >= input_stream->m_output.count())
+		fatalerror("Fatal error: stream_set_input attempted to use a non-existant output %d (%d max)", output_index, m_output.count());
 
 	// if this input is already wired, update the dependent info
 	stream_input &input = m_input[index];
@@ -238,7 +263,8 @@
 
 	// wire it up
 	input.m_source = (input_stream != NULL) ? &input_stream->m_output[output_index] : NULL;
-	input.m_gain = input.m_initial_gain = int(0x100 * gain);
+	input.m_gain = int(0x100 * gain);
+	input.m_user_gain = 0x100;
 
 	// update the dependent info
 	if (input.m_source != NULL)
@@ -300,7 +326,7 @@
 
 	// compute the number of samples and a pointer to the output buffer
 	numsamples = m_output_sampindex - m_output_update_sampindex;
-	return m_output[outputnum].m_buffer + (m_output_update_sampindex - m_output_base_sampindex);
+	return &m_output[outputnum].m_buffer[m_output_update_sampindex - m_output_base_sampindex];
 }
 
 
@@ -318,6 +344,19 @@
 
 
 //-------------------------------------------------
+//  set_user_gain - set the user-controllable gain
+//  on a given stream's input
+//-------------------------------------------------
+
+void sound_stream::set_user_gain(int inputnum, float gain)
+{
+	update();
+	assert(inputnum >= 0 && inputnum < m_input.count());
+	m_input[inputnum].m_user_gain = int(0x100 * gain);
+}
+
+
+//-------------------------------------------------
 //  set_input_gain - set the input gain on a
 //  given stream's input
 //-------------------------------------------------
@@ -325,7 +364,7 @@
 void sound_stream::set_input_gain(int inputnum, float gain)
 {
 	update();
-	assert(inputnum >= 0 && inputnum < m_inputs);
+	assert(inputnum >= 0 && inputnum < m_input.count());
 	m_input[inputnum].m_gain = int(0x100 * gain);
 }
 
@@ -338,7 +377,7 @@
 void sound_stream::set_output_gain(int outputnum, float gain)
 {
 	update();
-	assert(outputnum >= 0 && outputnum < m_outputs);
+	assert(outputnum >= 0 && outputnum < m_output.count());
 	m_output[outputnum].m_gain = int(0x100 * gain);
 }
 
@@ -374,7 +413,7 @@
 		{
 			// if we have samples to move, do so for each output
 			if (output_bufindex > 0)
-				for (int outputnum = 0; outputnum < m_outputs; outputnum++)
+				for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
 				{
 					stream_output &output = m_output[outputnum];
 					memmove(&output.m_buffer[0], &output.m_buffer[samples_to_lose], sizeof(output.m_buffer[0]) * (output_bufindex - samples_to_lose));
@@ -412,8 +451,8 @@
 	m_output_base_sampindex = m_output_sampindex - m_max_samples_per_update;
 
 	// clear out the buffer
-	for (int outputnum = 0; outputnum < m_outputs; outputnum++)
-		memset(m_output[outputnum].m_buffer, 0, m_max_samples_per_update * sizeof(m_output[outputnum].m_buffer[0]));
+	for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
+		memset(&m_output[outputnum].m_buffer[0], 0, m_max_samples_per_update * sizeof(m_output[outputnum].m_buffer[0]));
 }
 
 
@@ -447,7 +486,7 @@
 	allocate_output_buffers();
 
 	// iterate over each input
-	for (int inputnum = 0; inputnum < m_inputs; inputnum++)
+	for (int inputnum = 0; inputnum < m_input.count(); inputnum++)
 	{
 		// if we have a source, see if its sample rate changed
 		stream_input &input = m_input[inputnum];
@@ -494,13 +533,11 @@
 		m_resample_bufalloc = bufsize;
 
 		// iterate over outputs and realloc their buffers
-		for (int inputnum = 0; inputnum < m_inputs; inputnum++)
+		for (int inputnum = 0; inputnum < m_input.count(); inputnum++)
 		{
 			stream_input &input = m_input[inputnum];
-			stream_sample_t *newbuffer = auto_alloc_array(m_device.machine(), stream_sample_t, m_resample_bufalloc);
-			memcpy(newbuffer, input.m_resample, oldsize * sizeof(stream_sample_t));
-			auto_free(m_device.machine(), input.m_resample);
-			input.m_resample = newbuffer;
+			input.m_resample.resize(m_resample_bufalloc, true);
+			memset(&input.m_resample[oldsize], 0, (m_resample_bufalloc - oldsize) * sizeof(stream_sample_t));
 		}
 	}
 }
@@ -522,14 +559,11 @@
 		m_output_bufalloc = bufsize;
 
 		// iterate over outputs and realloc their buffers
-		for (int outputnum = 0; outputnum < m_outputs; outputnum++)
+		for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
 		{
 			stream_output &output = m_output[outputnum];
-			stream_sample_t *newbuffer = auto_alloc_array(m_device.machine(), stream_sample_t, m_output_bufalloc);
-			memcpy(newbuffer, output.m_buffer, oldsize * sizeof(stream_sample_t));
-			memset(newbuffer + oldsize, 0, (m_output_bufalloc - oldsize) * sizeof(stream_sample_t));
-			auto_free(m_device.machine(), output.m_buffer);
-			output.m_buffer = newbuffer;
+			output.m_buffer.resize(m_output_bufalloc, true);
+			memset(&output.m_buffer[oldsize], 0, (m_output_bufalloc - oldsize) * sizeof(stream_sample_t));
 		}
 	}
 }
@@ -545,7 +579,7 @@
 	recompute_sample_rate_data();
 
 	// make sure our output buffers are fully cleared
-	for (int outputnum = 0; outputnum < m_outputs; outputnum++)
+	for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
 		memset(m_output[outputnum].m_buffer, 0, m_output_bufalloc * sizeof(m_output[outputnum].m_buffer[0]));
 
 	// recompute the sample indexes to make sense
@@ -571,7 +605,7 @@
 	VPRINTF(("generate_samples(%p, %d)\n", this, samples));
 
 	// ensure all inputs are up to date and generate resampled data
-	for (int inputnum = 0; inputnum < m_inputs; inputnum++)
+	for (int inputnum = 0; inputnum < m_input.count(); inputnum++)
 	{
 		// update the stream to the current time
 		stream_input &input = m_input[inputnum];
@@ -583,10 +617,10 @@
 	}
 
 	// loop over all outputs and compute the output pointer
-	for (int outputnum = 0; outputnum < m_outputs; outputnum++)
+	for (int outputnum = 0; outputnum < m_output.count(); outputnum++)
 	{
 		stream_output &output = m_output[outputnum];
-		m_output_array[outputnum] = output.m_buffer + (m_output_sampindex - m_output_base_sampindex);
+		m_output_array[outputnum] = &output.m_buffer[m_output_sampindex - m_output_base_sampindex];
 	}
 
 	// run the callback
@@ -614,7 +648,7 @@
 	// grab data from the output
 	stream_output &output = *input.m_source;
 	sound_stream &input_stream = *output.m_stream;
-	int gain = (input.m_gain * output.m_gain) >> 8;
+	int gain = (input.m_gain * input.m_user_gain * output.m_gain) >> 16;
 
 	// determine the time at which the current sample begins, accounting for the
     // latency we calculated between the input and output streams
@@ -629,7 +663,7 @@
 
 	// compute a source pointer to the first sample
 	assert(basesample >= input_stream.m_output_base_sampindex);
-	stream_sample_t *source = output.m_buffer + (basesample - input_stream.m_output_base_sampindex);
+	stream_sample_t *source = &output.m_buffer[basesample - input_stream.m_output_base_sampindex];
 
 	// determine the current fraction of a sample
 	UINT32 basefrac = (basetime - basesample * input_stream.m_attoseconds_per_sample) / ((input_stream.m_attoseconds_per_sample + FRAC_ONE - 1) >> FRAC_BITS);
@@ -637,7 +671,7 @@
 	assert(basefrac < FRAC_ONE);
 
 	// compute the stepping fraction
-	UINT32 step = ((UINT64)input_stream.m_sample_rate << FRAC_BITS) / m_sample_rate;
+	UINT32 step = (UINT64(input_stream.m_sample_rate) << FRAC_BITS) / m_sample_rate;
 
 	// if we have equal sample rates, we just need to copy
 	if (step == FRAC_ONE)
@@ -664,7 +698,7 @@
 			}
 
 			// if we're done, we're done
-			if ((INT32)numsamples-- < 0)
+			if (INT32(numsamples--) < 0)
 				break;
 
 			// compute starting and ending fractional positions
@@ -727,12 +761,9 @@
 
 sound_stream::stream_input::stream_input()
 	: m_source(NULL),
-	  m_resample(NULL),
-	  m_bufsize(0),
-	  m_bufalloc(0),
 	  m_latency_attoseconds(0),
 	  m_gain(0x100),
-	  m_initial_gain(0x100)
+	  m_user_gain(0x100)
 {
 }
 
@@ -747,8 +778,7 @@
 //-------------------------------------------------
 
 sound_stream::stream_output::stream_output()
-	: m_buffer(NULL),
-	  m_dependents(0),
+	: m_dependents(0),
 	  m_gain(0x100)
 {
 }
@@ -765,16 +795,15 @@
 
 sound_manager::sound_manager(running_machine &machine)
 	: m_machine(machine),
-	  m_update_timer(machine.scheduler().timer_alloc(FUNC(update_static), this)),
+	  m_update_timer(NULL),
 	  m_finalmix_leftover(0),
-	  m_finalmix(NULL),
-	  m_leftmix(NULL),
-	  m_rightmix(NULL),
+	  m_finalmix(machine.sample_rate()),
+	  m_leftmix(machine.sample_rate()),
+	  m_rightmix(machine.sample_rate()),
 	  m_muted(0),
 	  m_attenuation(0),
 	  m_nosound_mode(!machine.options().sound()),
 	  m_wavfile(NULL),
-	  m_stream_list(machine.respool()),
 	  m_update_attoseconds(STREAMS_UPDATE_ATTOTIME.attoseconds),
 	  m_last_update(attotime::zero)
 {
@@ -792,11 +821,6 @@
 	VPRINTF(("total mixers = %d\n", iter.count()));
 #endif
 
-	// allocate memory for mix buffers
-	m_leftmix = auto_alloc_array(machine, INT32, machine.sample_rate());
-	m_rightmix = auto_alloc_array(machine, INT32, machine.sample_rate());
-	m_finalmix = auto_alloc_array(machine, INT16, machine.sample_rate());
-
 	// open the output WAV file if specified
 	if (wavfile[0] != 0)
 		m_wavfile = wav_open(wavfile, machine.sample_rate(), 2);
@@ -814,6 +838,7 @@
 	set_attenuation(machine.options().volume());
 
 	// start the periodic update flushing timer
+	m_update_timer = machine.scheduler().timer_alloc(timer_expired_delegate(FUNC(sound_manager::update), this));
 	m_update_timer->adjust(STREAMS_UPDATE_ATTOTIME, 0, STREAMS_UPDATE_ATTOTIME);
 }
 
@@ -838,9 +863,9 @@
 sound_stream *sound_manager::stream_alloc(device_t &device, int inputs, int outputs, int sample_rate, void *param, sound_stream::stream_update_func callback)
 {
 	if (callback != NULL)
-		return &m_stream_list.append(*auto_alloc(device.machine(), sound_stream(device, inputs, outputs, sample_rate, param, callback)));
+		return &m_stream_list.append(*global_alloc(sound_stream(device, inputs, outputs, sample_rate, param, callback)));
 	else
-		return &m_stream_list.append(*auto_alloc(device.machine(), sound_stream(device, inputs, outputs, sample_rate)));
+		return &m_stream_list.append(*global_alloc(sound_stream(device, inputs, outputs, sample_rate)));
 }
 
 
@@ -949,10 +974,10 @@
 		mixer_input info;
 		if (indexed_mixer_input(xml_get_attribute_int(channelnode, "index", -1), info))
 		{
-			float defvol = xml_get_attribute_float(channelnode, "defvol", -1000.0);
+			float defvol = xml_get_attribute_float(channelnode, "defvol", 1.0);
 			float newvol = xml_get_attribute_float(channelnode, "newvol", -1000.0);
-			if (fabs(defvol - info.stream->initial_input_gain(info.inputnum)) < 1e-6 && newvol != -1000.0)
-				info.stream->set_input_gain(info.inputnum, newvol);
+			if (newvol != -1000.0)
+				info.stream->set_user_gain(info.inputnum, newvol / defvol);
 		}
 	}
 }
@@ -976,16 +1001,14 @@
 			mixer_input info;
 			if (!indexed_mixer_input(mixernum, info))
 				break;
-			float defvol = info.stream->initial_input_gain(info.inputnum);
-			float newvol = info.stream->input_gain(info.inputnum);
+			float newvol = info.stream->user_gain(info.inputnum);
 
-			if (defvol != newvol)
+			if (newvol != 1.0f)
 			{
 				xml_data_node *channelnode = xml_add_child(parentnode, "channel", NULL);
 				if (channelnode != NULL)
 				{
 					xml_set_attribute_int(channelnode, "index", mixernum);
-					xml_set_attribute_float(channelnode, "defvol", defvol);
 					xml_set_attribute_float(channelnode, "newvol", newvol);
 				}
 			}
@@ -998,7 +1021,7 @@
 //  and send it to the OSD layer
 //-------------------------------------------------
 
-void sound_manager::update()
+void sound_manager::update(void *ptr, int param)
 {
 	VPRINTF(("sound_update\n"));
 
diff -Nru src-old/emu/sound.h src/emu/sound.h
--- src-old/emu/sound.h	2012-02-28 11:21:05.000000000 +0100
+++ src/emu/sound.h	2012-04-26 10:36:24.000000000 +0200
@@ -87,10 +87,11 @@
 	public:
 		// construction/destruction
 		stream_output();
+		stream_output &operator=(const stream_output &rhs) { assert(false); return *this; }
 
 		// internal state
 		sound_stream *		m_stream;				// owning stream
-		stream_sample_t *	m_buffer;				// output buffer
+		dynamic_array<stream_sample_t> m_buffer;	// output buffer
 		int					m_dependents;			// number of dependents
 		INT16				m_gain;					// gain to apply to the output
 	};
@@ -101,15 +102,14 @@
 	public:
 		// construction/destruction
 		stream_input();
+		stream_input &operator=(const stream_input &rhs) { assert(false); return *this; }
 
 		// internal state
 		stream_output *		m_source;				// pointer to the sound_output for this source
-		stream_sample_t *	m_resample;				// buffer for resampling to the stream's sample rate
-		UINT32				m_bufsize;				// size of output buffer, in samples
-		UINT32				m_bufalloc;				// allocated size of output buffer, in samples
+		dynamic_array<stream_sample_t> m_resample;	// buffer for resampling to the stream's sample rate
 		attoseconds_t		m_latency_attoseconds;	// latency between this stream and the input stream
 		INT16				m_gain;					// gain to apply to this input
-		INT16				m_initial_gain;			// initial gain supplied at creation
+		INT16				m_user_gain;			// user-controlled gain to apply to this input
 	};
 
 	// constants
@@ -128,11 +128,13 @@
 	int sample_rate() const { return (m_new_sample_rate != 0) ? m_new_sample_rate : m_sample_rate; }
 	attotime sample_time() const;
 	attotime sample_period() const { return attotime(0, m_attoseconds_per_sample); }
-	int input_count() const { return m_inputs; }
-	int output_count() const { return m_outputs; }
-	float input_gain(int inputnum) const;
-	float initial_input_gain(int inputnum) const;
+	int input_count() const { return m_input.count(); }
+	int output_count() const { return m_output.count(); }
 	const char *input_name(int inputnum, astring &string) const;
+	device_t *input_source_device(int inputnum) const;
+	int input_source_outputnum(int inputnum) const;
+	float user_gain(int inputnum) const;
+	float input_gain(int inputnum) const;
 	float output_gain(int outputnum) const;
 
 	// operations
@@ -142,6 +144,7 @@
 
 	// timing
 	void set_sample_rate(int sample_rate);
+	void set_user_gain(int inputnum, float gain);
 	void set_input_gain(int inputnum, float gain);
 	void set_output_gain(int outputnum, float gain);
 
@@ -172,17 +175,15 @@
 	INT32				m_max_samples_per_update;// maximum samples per update
 
 	// input information
-	int					m_inputs;				// number of inputs
-	stream_input *		m_input;				// list of streams we directly depend upon
-	stream_sample_t **	m_input_array;			// array of inputs for passing to the callback
+	dynamic_array<stream_input> m_input;		// list of streams we directly depend upon
+	dynamic_array<stream_sample_t *> m_input_array;	// array of inputs for passing to the callback
 
 	// resample buffer information
 	UINT32				m_resample_bufalloc;	// allocated size of each resample buffer
 
 	// output information
-	int					m_outputs;				// number of outputs
-	stream_output *		m_output;				// list of streams which directly depend upon us
-	stream_sample_t **	m_output_array;			// array of outputs for passing to the callback
+	dynamic_array<stream_output> m_output;		// list of streams which directly depend upon us
+	dynamic_array<stream_sample_t *> m_output_array; // array of outputs for passing to the callback
 
 	// output buffer information
 	UINT32				m_output_bufalloc;		// allocated size of each output buffer
@@ -247,17 +248,16 @@
 	void config_load(int config_type, xml_data_node *parentnode);
 	void config_save(int config_type, xml_data_node *parentnode);
 
-	static TIMER_CALLBACK( update_static ) { reinterpret_cast<sound_manager *>(ptr)->update(); }
-	void update();
+	void update(void *ptr = NULL, INT32 param = 0);
 
 	// internal state
 	running_machine &	m_machine;				// reference to our machine
 	emu_timer *			m_update_timer;			// timer to drive periodic updates
 
 	UINT32				m_finalmix_leftover;
-	INT16 *				m_finalmix;
-	INT32 *				m_leftmix;
-	INT32 *				m_rightmix;
+	dynamic_array<INT16> m_finalmix;
+	dynamic_array<INT32> m_leftmix;
+	dynamic_array<INT32> m_rightmix;
 
 	UINT8				m_muted;
 	int 				m_attenuation;
diff -Nru src-old/emu/ui.c src/emu/ui.c
--- src-old/emu/ui.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/ui.c	2012-05-03 11:00:08.000000000 +0200
@@ -935,7 +935,7 @@
 			string.cat(" have not been correctly dumped.\n");
 		}
 		/* add one line per warning flag */
-		if (input_machine_has_keyboard(machine))
+		if (machine.ioport().has_keyboard())
 			string.cat("The keyboard emulation may not be 100% accurate.\n");
 		if (machine.system().flags & GAME_IMPERFECT_COLORS)
 			string.cat("The colors aren't 100% accurate.\n");
@@ -1213,7 +1213,7 @@
 	{
 		/* if this was a UI_EVENT_CHAR event, post it */
 		if (event.event_type == UI_EVENT_CHAR)
-			inputx_postc(machine, event.ch);
+			machine.ioport().natkeyboard().post(event.ch);
 	}
 
 	/* process natural keyboard keys that don't get UI_EVENT_CHARs */
@@ -1236,7 +1236,7 @@
 			*key_down_ptr |= key_down_mask;
 
 			/* post the key */
-			inputx_postc(machine, UCHAR_MAMEKEY_BEGIN + code.item_id());
+			machine.ioport().natkeyboard().post(UCHAR_MAMEKEY_BEGIN + code.item_id());
 		}
 		else if (!pressed && (*key_down_ptr & key_down_mask))
 		{
@@ -1259,7 +1259,7 @@
 	if (text != NULL)
 	{
 		/* post the text */
-		inputx_post_utf8(machine, text);
+		machine.ioport().natkeyboard().post_utf8(text);
 
 		/* free the string */
 		osd_free(text);
@@ -1317,10 +1317,10 @@
 	}
 
 	/* determine if we should disable the rest of the UI */
-	int ui_disabled = (input_machine_has_keyboard(machine) && !machine.ui_active());
+	int ui_disabled = (machine.ioport().has_keyboard() && !machine.ui_active());
 
 	/* is ScrLk UI toggling applicable here? */
-	if (input_machine_has_keyboard(machine))
+	if (machine.ioport().has_keyboard())
 	{
 		/* are we toggling the UI with ScrLk? */
 		if (ui_input_pressed(machine, IPT_UI_TOGGLE_UI))
@@ -1488,7 +1488,7 @@
 		machine.video().set_throttled(!machine.video().throttled());
 
 	/* check for fast forward */
-	if (input_type_pressed(machine, IPT_UI_FAST_FORWARD, 0))
+	if (machine.ioport().type_pressed(IPT_UI_FAST_FORWARD))
 	{
 		machine.video().set_fastforward(true);
 		ui_show_fps_temp(0.5);
@@ -1640,8 +1640,8 @@
 
 static slider_state *slider_init(running_machine &machine)
 {
-	input_field_config *field;
-	input_port_config *port;
+	ioport_field *field;
+	ioport_port *port;
 	slider_state *listhead = NULL;
 	slider_state **tailptr = &listhead;
 	astring string;
@@ -1656,10 +1656,7 @@
 	for (item = 0; machine.sound().indexed_mixer_input(item, info); item++)
 	{
 		INT32 maxval = 2000;
-		INT32 defval = info.stream->initial_input_gain(info.inputnum) * 1000.0f + 0.5f;
-
-		if (defval > 1000)
-			maxval = 2 * defval;
+		INT32 defval = 1000;
 
 		info.stream->input_name(info.inputnum, string);
 		string.cat(" Volume");
@@ -1669,11 +1666,11 @@
 
 	/* add analog adjusters */
 	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->type == IPT_ADJUSTER)
+		for (field = port->first_field(); field != NULL; field = field->next())
+			if (field->type() == IPT_ADJUSTER)
 			{
 				void *param = (void *)field;
-				*tailptr = slider_alloc(machine, field->name, 0, field->defvalue, 100, 1, slider_adjuster, param);
+				*tailptr = slider_alloc(machine, field->name(), 0, field->defvalue(), 100, 1, slider_adjuster, param);
 				tailptr = &(*tailptr)->next;
 			}
 
@@ -1775,14 +1772,14 @@
 #ifdef MAME_DEBUG
 	/* add crosshair adjusters */
 	for (port = machine.ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->crossaxis != CROSSHAIR_AXIS_NONE && field->player == 0)
+		for (field = port->first_field(); field != NULL; field = field->next())
+			if (field->crosshair_axis() != CROSSHAIR_AXIS_NONE && field->player() == 0)
 			{
 				void *param = (void *)field;
-				string.printf("Crosshair Scale %s", (field->crossaxis == CROSSHAIR_AXIS_X) ? "X" : "Y");
+				string.printf("Crosshair Scale %s", (field->crosshair_axis() == CROSSHAIR_AXIS_X) ? "X" : "Y");
 				*tailptr = slider_alloc(machine, string, -3000, 1000, 3000, 100, slider_crossscale, param);
 				tailptr = &(*tailptr)->next;
-				string.printf("Crosshair Offset %s", (field->crossaxis == CROSSHAIR_AXIS_X) ? "X" : "Y");
+				string.printf("Crosshair Offset %s", (field->crosshair_axis() == CROSSHAIR_AXIS_X) ? "X" : "Y");
 				*tailptr = slider_alloc(machine, string, -3000, 0, 3000, 100, slider_crossoffset, param);
 				tailptr = &(*tailptr)->next;
 			}
@@ -1818,13 +1815,13 @@
 		return 0;
 	if (newval != SLIDER_NOCHANGE)
 	{
-		INT32 curval = floor(info.stream->input_gain(info.inputnum) * 1000.0f + 0.5f);
+		INT32 curval = floor(info.stream->user_gain(info.inputnum) * 1000.0f + 0.5f);
 		if (newval > curval && (newval - curval) <= 4) newval += 4; // round up on increment
-		info.stream->set_input_gain(info.inputnum, (float)newval * 0.001f);
+		info.stream->set_user_gain(info.inputnum, (float)newval * 0.001f);
 	}
 	if (string != NULL)
-		string->printf("%4.2f", info.stream->input_gain(info.inputnum));
-	return floor(info.stream->input_gain(info.inputnum) * 1000.0f + 0.5f);
+		string->printf("%4.2f", info.stream->user_gain(info.inputnum));
+	return floor(info.stream->user_gain(info.inputnum) * 1000.0f + 0.5f);
 }
 
 
@@ -1835,14 +1832,14 @@
 
 static INT32 slider_adjuster(running_machine &machine, void *arg, astring *string, INT32 newval)
 {
-	const input_field_config *field = (const input_field_config *)arg;
-	input_field_user_settings settings;
+	ioport_field *field = (ioport_field *)arg;
+	ioport_field::user_settings settings;
 
-	input_field_get_user_settings(field, &settings);
+	field->get_user_settings(settings);
 	if (newval != SLIDER_NOCHANGE)
 	{
 		settings.value = newval;
-		input_field_set_user_settings(field, &settings);
+		field->set_user_settings(settings);
 	}
 	if (string != NULL)
 		string->printf("%d%%", settings.value);
@@ -2188,13 +2185,13 @@
 #ifdef MAME_DEBUG
 static INT32 slider_crossscale(running_machine &machine, void *arg, astring *string, INT32 newval)
 {
-	input_field_config *field = (input_field_config *)arg;
+	ioport_field *field = (ioport_field *)arg;
 
 	if (newval != SLIDER_NOCHANGE)
-		field->crossscale = (float)newval * 0.001f;
+		field->set_crosshair_scale(float(newval) * 0.001);
 	if (string != NULL)
-		string->printf("%s %s %1.3f", "Crosshair Scale", (field->crossaxis == CROSSHAIR_AXIS_X) ? "X" : "Y", (float)newval * 0.001f);
-	return floor(field->crossscale * 1000.0f + 0.5f);
+		string->printf("%s %s %1.3f", "Crosshair Scale", (field->crosshair_axis() == CROSSHAIR_AXIS_X) ? "X" : "Y", float(newval) * 0.001f);
+	return floor(field->crosshair_scale() * 1000.0f + 0.5f);
 }
 #endif
 
@@ -2207,13 +2204,13 @@
 #ifdef MAME_DEBUG
 static INT32 slider_crossoffset(running_machine &machine, void *arg, astring *string, INT32 newval)
 {
-	input_field_config *field = (input_field_config *)arg;
+	ioport_field *field = (ioport_field *)arg;
 
 	if (newval != SLIDER_NOCHANGE)
-		field->crossoffset = (float)newval * 0.001f;
+		field->set_crosshair_offset(float(newval) * 0.001f);
 	if (string != NULL)
-		string->printf("%s %s %1.3f", "Crosshair Offset", (field->crossaxis == CROSSHAIR_AXIS_X) ? "X" : "Y", (float)newval * 0.001f);
-	return field->crossoffset;
+		string->printf("%s %s %1.3f", "Crosshair Offset", (field->crosshair_axis() == CROSSHAIR_AXIS_X) ? "X" : "Y", float(newval) * 0.001f);
+	return field->crosshair_offset();
 }
 #endif
 
diff -Nru src-old/emu/uiinput.c src/emu/uiinput.c
--- src-old/emu/uiinput.c	2012-02-06 03:30:22.000000000 +0100
+++ src/emu/uiinput.c	2012-05-03 11:00:08.000000000 +0200
@@ -37,8 +37,8 @@
 struct _ui_input_private
 {
 	/* pressed states; retrieved with ui_input_pressed() */
-	osd_ticks_t					next_repeat[__ipt_max];
-	UINT8						seqpressed[__ipt_max];
+	osd_ticks_t					next_repeat[IPT_COUNT];
+	UINT8						seqpressed[IPT_COUNT];
 
 	/* mouse position/info */
 	render_target *				current_mouse_target;
@@ -97,12 +97,11 @@
 void ui_input_frame_update(running_machine &machine)
 {
 	ui_input_private *uidata = machine.ui_input_data;
-	int code;
 
 	/* update the state of all the UI keys */
-	for (code = __ipt_ui_start; code <= __ipt_ui_end; code++)
+	for (ioport_type code = ioport_type(IPT_UI_FIRST + 1); code < IPT_UI_LAST; code++)
 	{
-		int pressed = machine.input().seq_pressed(input_type_seq(machine, code, 0, SEQ_TYPE_STANDARD));
+		bool pressed = machine.ioport().type_pressed(code);
 		if (!pressed || uidata->seqpressed[code] != SEQ_PRESSED_RESET)
 			uidata->seqpressed[code] = pressed;
 	}
@@ -199,7 +198,7 @@
 
 	uidata->events_start = 0;
 	uidata->events_end = 0;
-	for (code = __ipt_ui_start; code <= __ipt_ui_end; code++)
+	for (code = IPT_UI_FIRST + 1; code < IPT_UI_LAST; code++)
 	{
 		uidata->seqpressed[code] = SEQ_PRESSED_RESET;
 		uidata->next_repeat[code] = 0;
diff -Nru src-old/emu/uimain.c src/emu/uimain.c
--- src-old/emu/uimain.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/uimain.c	2012-05-07 08:57:50.000000000 +0200
@@ -109,23 +109,29 @@
 
 void ui_menu_main::populate()
 {
-	input_field_config *field;
-	input_port_config *port;
+	ioport_field *field;
+	ioport_port *port;
 	int has_configs = false;
 	int has_analog = false;
 	int has_dips = false;
+	int has_bioses = false;
 	astring menu_text;
 	/* scan the input port array to see what options we need to enable */
 	for (port = machine().ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
+		for (field = port->first_field(); field != NULL; field = field->next())
 		{
-			if (field->type == IPT_DIPSWITCH)
+			if (field->type() == IPT_DIPSWITCH)
 				has_dips = true;
-			if (field->type == IPT_CONFIG)
+			if (field->type() == IPT_CONFIG)
 				has_configs = true;
-			if (input_type_is_analog(field->type))
+			if (field->is_analog())
 				has_analog = true;
 		}
+	device_iterator deviter(machine().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+		if (device->rom_region())
+			for (const rom_entry *rom = device->rom_region(); !ROMENTRY_ISEND(rom); rom++)
+				if (ROMENTRY_ISSYSTEM_BIOS(rom)) { has_bioses= true; break; }
 
 	/* add input menu items */
 	item_append("Input (general)", NULL, 0, (void *)INPUT_GROUPS);
@@ -168,6 +174,9 @@
 			item_append("Bitbanger Control", NULL, 0, (void *)MESS_MENU_BITBANGER_CONTROL);
 	}
 
+	if (has_bioses)
+		item_append("Bios Selection", NULL, 0, (void *)BIOS_SELECTION);
+
 	slot_interface_iterator slotiter(machine().root_device());
 	if (slotiter.first() != NULL)
 	{
@@ -183,7 +192,7 @@
 	}
 
 	/* add keyboard mode menu */
-	if (input_machine_has_keyboard(machine()) && inputx_can_post(machine()))
+	if (machine().ioport().has_keyboard() && machine().ioport().natkeyboard().can_post())
 		item_append("Keyboard Mode", NULL, 0, (void *)KEYBOARD_MODE);
 
 	/* add sliders menu */
@@ -307,6 +316,10 @@
 			ui_menu::stack_push(auto_alloc_clear(machine(), ui_menu_select_game(machine(), container, 0)));
 			break;
 
+		case BIOS_SELECTION:
+			ui_menu::stack_push(auto_alloc_clear(machine(), ui_menu_bios_selection(machine(), container)));
+			break;
+
 		default:
 			fatalerror("ui_menu_main::handle - unknown reference");
 		}
@@ -466,6 +479,76 @@
 	}
 }
 
+/*-------------------------------------------------
+    ui_menu_bios_selection - populates the main
+    bios selection menu
+-------------------------------------------------*/
+
+ui_menu_bios_selection::ui_menu_bios_selection(running_machine &machine, render_container *container) : ui_menu(machine, container)
+{
+}
+
+void ui_menu_bios_selection::populate()
+{
+	/* cycle through all devices for this system */
+	device_iterator deviter(machine().root_device());
+	for (device_t *device = deviter.first(); device != NULL; device = deviter.next())
+	{
+		if (device->rom_region()) {
+			const char *val = "default";
+			for (const rom_entry *rom = device->rom_region(); !ROMENTRY_ISEND(rom); rom++)
+			{
+				if (ROMENTRY_ISSYSTEM_BIOS(rom) && ROM_GETBIOSFLAGS(rom)==device->system_bios())
+				{
+					val = ROM_GETHASHDATA(rom);
+				}
+			}
+			item_append(strcmp(device->tag(),":")==0 ? "driver" : device->tag()+1, val, MENU_FLAG_LEFT_ARROW | MENU_FLAG_RIGHT_ARROW, (void *)device);
+		}
+	}
+
+	item_append(MENU_SEPARATOR_ITEM, NULL, 0, NULL);
+	item_append("Reset",  NULL, 0, NULL);
+}
+
+ui_menu_bios_selection::~ui_menu_bios_selection()
+{
+}
+
+/*-------------------------------------------------
+    ui_menu_bios_selection - menu that
+-------------------------------------------------*/
+
+void ui_menu_bios_selection::handle()
+{
+	/* process the menu */
+	const ui_menu_event *menu_event = process(0);
+
+	if (menu_event != NULL && menu_event->itemref != NULL)
+	{
+		if (menu_event->iptkey == IPT_UI_LEFT || menu_event->iptkey == IPT_UI_RIGHT) {
+			device_t *dev = (device_t *)menu_event->itemref;
+			int cnt = 0;
+			for (const rom_entry *rom = dev->rom_region(); !ROMENTRY_ISEND(rom); rom++)
+			{
+				if (ROMENTRY_ISSYSTEM_BIOS(rom)) cnt ++;
+			}
+			int val = dev->system_bios() + ((menu_event->iptkey == IPT_UI_LEFT) ? -1 : +1);
+			if (val<1) val=cnt;
+			if (val>cnt) val=1;
+			dev->set_system_bios(val);
+			if (strcmp(dev->tag(),":")==0) {
+				astring error;
+				machine().options().set_value("bios", val-1, OPTION_PRIORITY_CMDLINE, error);
+				assert(!error);
+			}
+			reset(UI_MENU_RESET_REMEMBER_REF);
+		}
+	} else if (menu_event != NULL && menu_event->iptkey == IPT_UI_SELECT) {
+		machine().schedule_hard_reset();
+	}
+}
+
 ui_menu_network_devices::ui_menu_network_devices(running_machine &machine, render_container *container) : ui_menu(machine, container)
 {
 }
@@ -588,10 +671,10 @@
 	suborder[SEQ_TYPE_INCREMENT] = 2;
 
 	/* iterate over the input ports and add menu items */
-	for (input_type_entry *entry = input_type_list(machine()).first(); entry != NULL; entry = entry->next())
+	for (input_type_entry *entry = machine().ioport().first_type(); entry != NULL; entry = entry->next())
 
 		/* add if we match the group and we have a valid name */
-		if (entry->group == group && entry->name != NULL && entry->name[0] != 0)
+		if (entry->group() == group && entry->name() != NULL && entry->name()[0] != 0)
 		{
 			input_seq_type seqtype;
 
@@ -606,11 +689,11 @@
 				if(pollingitem && pollingref == entry && pollingseq == seqtype)
 					pollingitem = item;
 				item->seqtype = seqtype;
-				item->seq = input_type_seq(machine(), entry->type, entry->player, seqtype);
-				item->defseq = &entry->defseq[seqtype];
+				item->seq = machine().ioport().type_seq(entry->type(), entry->player(), seqtype);
+				item->defseq = &entry->defseq(seqtype);
 				item->sortorder = sortorder * 4 + suborder[seqtype];
-				item->type = input_type_is_analog(entry->type) ? (INPUT_TYPE_ANALOG + seqtype) : INPUT_TYPE_DIGITAL;
-				item->name = entry->name;
+				item->type = ioport_manager::type_is_analog(entry->type()) ? (INPUT_TYPE_ANALOG + seqtype) : INPUT_TYPE_DIGITAL;
+				item->name = entry->name();
 				item->next = itemlist;
 				itemlist = item;
 
@@ -640,8 +723,8 @@
 void ui_menu_input_specific::populate()
 {
 	input_item_data *itemlist = NULL;
-	input_field_config *field;
-	input_port_config *port;
+	ioport_field *field;
+	ioport_port *port;
 	int suborder[SEQ_TYPE_TOTAL];
 	astring tempstring;
 
@@ -652,22 +735,22 @@
 
 	/* iterate over the input ports and add menu items */
 	for (port = machine().ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
+		for (field = port->first_field(); field != NULL; field = field->next())
 		{
-			const char *name = input_field_name(field);
+			const char *name = field->name();
 
 			/* add if we match the group and we have a valid name */
-			if (name != NULL && input_condition_true(machine(), &field->condition, port->owner()) &&
-				((field->type == IPT_OTHER && field->name != NULL) || input_type_group(machine(), field->type, field->player) != IPG_INVALID))
+			if (name != NULL && field->enabled() &&
+				((field->type() == IPT_OTHER && field->name() != NULL) || machine().ioport().type_group(field->type(), field->player()) != IPG_INVALID))
 			{
 				input_seq_type seqtype;
 				UINT16 sortorder;
 
 				/* determine the sorting order */
-				if (field->type >= IPT_START1 && field->type <= __ipt_analog_end)
-					sortorder = (field->type << 2) | (field->player << 12);
+				if (field->type() >= IPT_START1 && field->type() < IPT_ANALOG_LAST)
+					sortorder = (field->type() << 2) | (field->player() << 12);
 				else
-					sortorder = field->type | 0xf000;
+					sortorder = field->type() | 0xf000;
 
 				/* loop over all sequence types */
 				for (seqtype = SEQ_TYPE_STANDARD; seqtype < SEQ_TYPE_TOTAL; seqtype++)
@@ -679,10 +762,10 @@
 					item->seqtype = seqtype;
 					if(pollingitem && pollingref == field && pollingseq == seqtype)
 						pollingitem = item;
-					item->seq = input_field_seq(field, seqtype);
-					item->defseq = &get_field_default_seq(field, seqtype);
+					item->seq = field->seq(seqtype);
+					item->defseq = &field->defseq(seqtype);
 					item->sortorder = sortorder + suborder[seqtype];
-					item->type = input_type_is_analog(field->type) ? (INPUT_TYPE_ANALOG + seqtype) : INPUT_TYPE_DIGITAL;
+					item->type = field->is_analog() ? (INPUT_TYPE_ANALOG + seqtype) : INPUT_TYPE_DIGITAL;
 					item->name = name;
 					item->next = itemlist;
 					itemlist = item;
@@ -732,19 +815,6 @@
 		selected_seq.reset();
 }
 
-/*-------------------------------------------------
-    get_field_default_seq - return a pointer
-    to the default sequence for the given field
--------------------------------------------------*/
-
-const input_seq &ui_menu_input::get_field_default_seq(input_field_config *field, input_seq_type seqtype)
-{
-	if (field->seq[seqtype].is_default())
-		return input_type_seq(field->machine(), field->type, field->player, seqtype);
-	else
-		return field->seq[seqtype];
-}
-
 void ui_menu_input::handle()
 {
 	input_item_data *seqchangeditem = NULL;
@@ -833,16 +903,16 @@
 void ui_menu_input_general::update_input(struct input_item_data *seqchangeditem)
 {
 	const input_type_entry *entry = (const input_type_entry *)seqchangeditem->ref;
-	input_type_set_seq(machine(), entry->type, entry->player, seqchangeditem->seqtype, &seqchangeditem->seq);
+	machine().ioport().set_type_seq(entry->type(), entry->player(), seqchangeditem->seqtype, seqchangeditem->seq);
 }
 
 void ui_menu_input_specific::update_input(struct input_item_data *seqchangeditem)
 {
-	input_field_user_settings settings;
+	ioport_field::user_settings settings;
 
-	input_field_get_user_settings((input_field_config *)seqchangeditem->ref, &settings);
+	((ioport_field *)seqchangeditem->ref)->get_user_settings(settings);
 	settings.seq[seqchangeditem->seqtype] = seqchangeditem->seq;
-	input_field_set_user_settings((input_field_config *)seqchangeditem->ref, &settings);
+	((ioport_field *)seqchangeditem->ref)->set_user_settings(settings);
 }
 
 
@@ -964,29 +1034,29 @@
 	/* handle events */
 	if (menu_event != NULL && menu_event->itemref != NULL)
 	{
-		input_field_config *field = (input_field_config *)menu_event->itemref;
-		input_field_user_settings settings;
+		ioport_field *field = (ioport_field *)menu_event->itemref;
+		ioport_field::user_settings settings;
 		int changed = false;
 
 		switch (menu_event->iptkey)
 		{
 			/* if selected, reset to default value */
 			case IPT_UI_SELECT:
-				input_field_get_user_settings(field, &settings);
-				settings.value = field->defvalue;
-				input_field_set_user_settings(field, &settings);
+				field->get_user_settings(settings);
+				settings.value = field->defvalue();
+				field->set_user_settings(settings);
 				changed = true;
 				break;
 
 			/* left goes to previous setting */
 			case IPT_UI_LEFT:
-				input_field_select_previous_setting(field);
+				field->select_previous_setting();
 				changed = true;
 				break;
 
 			/* right goes to next setting */
 			case IPT_UI_RIGHT:
-				input_field_select_next_setting(field);
+				field->select_next_setting();
 				changed = true;
 				break;
 		}
@@ -1010,8 +1080,8 @@
 
 void ui_menu_settings::populate()
 {
-	input_field_config *field;
-	input_port_config *port;
+	ioport_field *field;
+	ioport_port *port;
 	dip_descriptor **diplist_tailptr;
 
 	/* reset the dip switch tracking */
@@ -1021,39 +1091,39 @@
 
 	/* loop over input ports and set up the current values */
 	for (port = machine().ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (field->type == type && input_condition_true(machine(), &field->condition, port->owner()))
+		for (field = port->first_field(); field != NULL; field = field->next())
+			if (field->type() == type && field->enabled())
 			{
 				UINT32 flags = 0;
 
 				/* set the left/right flags appropriately */
-				if (input_field_has_previous_setting(field))
+				if (field->has_previous_setting())
 					flags |= MENU_FLAG_LEFT_ARROW;
-				if (input_field_has_next_setting(field))
+				if (field->has_next_setting())
 					flags |= MENU_FLAG_RIGHT_ARROW;
 
 				/* add the menu item */
-				item_append(input_field_name(field), input_field_setting_name(field), flags, (void *)field);
+				item_append(field->name(), field->setting_name(), flags, (void *)field);
 
 				/* for DIP switches, build up the model */
-				if (type == IPT_DIPSWITCH && field->diploclist().count() != 0)
+				if (type == IPT_DIPSWITCH && field->first_diplocation() != NULL)
 				{
-					const input_field_diplocation *diploc;
-					input_field_user_settings settings;
-					UINT32 accummask = field->mask;
+					const ioport_diplocation *diploc;
+					ioport_field::user_settings settings;
+					UINT32 accummask = field->mask();
 
 					/* get current settings */
-					input_field_get_user_settings(field, &settings);
+					field->get_user_settings(settings);
 
 					/* iterate over each bit in the field */
-					for (diploc = field->diploclist().first(); diploc != NULL; diploc = diploc->next())
+					for (diploc = field->first_diplocation(); diploc != NULL; diploc = diploc->next())
 					{
 						UINT32 mask = accummask & ~(accummask - 1);
 						dip_descriptor *dip;
 
 						/* find the matching switch name */
 						for (dip = diplist; dip != NULL; dip = dip->next)
-							if (strcmp(dip->name, diploc->swname) == 0)
+							if (strcmp(dip->name, diploc->name()) == 0)
 								break;
 
 						/* allocate new if none */
@@ -1061,7 +1131,7 @@
 						{
 							dip = (dip_descriptor *)m_pool_alloc(sizeof(*dip));
 							dip->next = NULL;
-							dip->name = diploc->swname;
+							dip->name = diploc->name();
 							dip->mask = dip->state = 0;
 							*diplist_tailptr = dip;
 							diplist_tailptr = &dip->next;
@@ -1070,9 +1140,9 @@
 						}
 
 						/* apply the bits */
-						dip->mask |= 1 << (diploc->swnum - 1);
-						if (((settings.value & mask) != 0 && !diploc->invert) || ((settings.value & mask) == 0 && diploc->invert))
-							dip->state |= 1 << (diploc->swnum - 1);
+						dip->mask |= 1 << (diploc->number() - 1);
+						if (((settings.value & mask) != 0 && !diploc->inverted()) || ((settings.value & mask) == 0 && diploc->inverted()))
+							dip->state |= 1 << (diploc->number() - 1);
 
 						/* clear the relevant bit in the accumulated mask */
 						accummask &= ~mask;
@@ -1094,7 +1164,7 @@
 
 void ui_menu_settings_dip_switches::custom_render(void *selectedref, float top, float bottom, float x1, float y1, float x2, float y2)
 {
-	input_field_config *field = (input_field_config *)selectedref;
+	ioport_field *field = (ioport_field *)selectedref;
 	dip_descriptor *dip;
 
 	/* add borders */
@@ -1110,14 +1180,14 @@
 	{
 		if (mame_stricmp(dip->name, "FAKE") != 0)
 		{
-			const input_field_diplocation *diploc;
+			const ioport_diplocation *diploc;
 			UINT32 selectedmask = 0;
 
 			/* determine the mask of selected bits */
 			if (field != NULL)
-				for (diploc = field->diploclist().first(); diploc != NULL; diploc = diploc->next())
-					if (strcmp(dip->name, diploc->swname) == 0)
-						selectedmask |= 1 << (diploc->swnum - 1);
+				for (diploc = field->first_diplocation(); diploc != NULL; diploc = diploc->next())
+					if (strcmp(dip->name, diploc->name()) == 0)
+						selectedmask |= 1 << (diploc->number() - 1);
 
 			/* draw one switch */
 			custom_render_one(x1, y1, x2, y1 + DIP_SWITCH_HEIGHT, dip, selectedmask);
@@ -1239,10 +1309,10 @@
 		/* if things changed, update */
 		if (newval != data->cur)
 		{
-			input_field_user_settings settings;
+			ioport_field::user_settings settings;
 
 			/* get the settings and set the new value */
-			input_field_get_user_settings(data->field, &settings);
+			data->field->get_user_settings(settings);
 			switch (data->type)
 			{
 				case ANALOG_ITEM_KEYSPEED:		settings.delta = newval;		break;
@@ -1250,7 +1320,7 @@
 				case ANALOG_ITEM_REVERSE:		settings.reverse = newval;		break;
 				case ANALOG_ITEM_SENSITIVITY:	settings.sensitivity = newval;	break;
 			}
-			input_field_set_user_settings(data->field, &settings);
+			data->field->set_user_settings(settings);
 
 			/* rebuild the menu */
 			reset(UI_MENU_RESET_REMEMBER_POSITION);
@@ -1270,26 +1340,26 @@
 
 void ui_menu_analog::populate()
 {
-	input_field_config *field;
-	input_port_config *port;
+	ioport_field *field;
+	ioport_port *port;
 	astring subtext;
 	astring text;
 
 	/* loop over input ports and add the items */
 	for (port = machine().ioport().first_port(); port != NULL; port = port->next())
-		for (field = port->fieldlist().first(); field != NULL; field = field->next())
-			if (input_type_is_analog(field->type) && input_condition_true(machine(), &field->condition, port->owner()))
+		for (field = port->first_field(); field != NULL; field = field->next())
+			if (field->is_analog() && field->enabled())
 			{
-				input_field_user_settings settings;
+				ioport_field::user_settings settings;
 				int use_autocenter = false;
 				int type;
 
 				/* based on the type, determine if we enable autocenter */
-				switch (field->type)
+				switch (field->type())
 				{
 					case IPT_POSITIONAL:
 					case IPT_POSITIONAL_V:
-						if (field->flags & ANALOG_FLAG_WRAPS)
+						if (field->analog_wraps())
 							break;
 
 					case IPT_AD_STICK_X:
@@ -1302,10 +1372,13 @@
 					case IPT_PEDAL3:
 						use_autocenter = true;
 						break;
+
+					default:
+						break;
 				}
 
 				/* get the user settings */
-				input_field_get_user_settings(field, &settings);
+				field->get_user_settings(settings);
 
 				/* iterate over types */
 				for (type = 0; type < ANALOG_ITEM_COUNT; type++)
@@ -1324,39 +1397,39 @@
 						{
 							default:
 							case ANALOG_ITEM_KEYSPEED:
-								text.printf("%s Digital Speed", input_field_name(field));
+								text.printf("%s Digital Speed", field->name());
 								subtext.printf("%d", settings.delta);
 								data->min = 0;
 								data->max = 255;
 								data->cur = settings.delta;
-								data->defvalue = field->delta;
+								data->defvalue = field->delta();
 								break;
 
 							case ANALOG_ITEM_CENTERSPEED:
-								text.printf("%s Autocenter Speed", input_field_name(field));
+								text.printf("%s Autocenter Speed", field->name());
 								subtext.printf("%d", settings.centerdelta);
 								data->min = 0;
 								data->max = 255;
 								data->cur = settings.centerdelta;
-								data->defvalue = field->centerdelta;
+								data->defvalue = field->centerdelta();
 								break;
 
 							case ANALOG_ITEM_REVERSE:
-								text.printf("%s Reverse", input_field_name(field));
+								text.printf("%s Reverse", field->name());
 								subtext.cpy(settings.reverse ? "On" : "Off");
 								data->min = 0;
 								data->max = 1;
 								data->cur = settings.reverse;
-								data->defvalue = ((field->flags & ANALOG_FLAG_REVERSE) != 0);
+								data->defvalue = field->analog_reverse();
 								break;
 
 							case ANALOG_ITEM_SENSITIVITY:
-								text.printf("%s Sensitivity", input_field_name(field));
+								text.printf("%s Sensitivity", field->name());
 								subtext.printf("%d", settings.sensitivity);
 								data->min = 1;
 								data->max = 255;
 								data->cur = settings.sensitivity;
-								data->defvalue = field->sensitivity;
+								data->defvalue = field->sensitivity();
 								break;
 						}
 
@@ -2718,8 +2791,14 @@
 			if (!(*s == 0 || *s == '\n'))
 				tempbuf[line].cat(*s);
 
-			if (*s != 0)
+			if (*s == '\n')
+			{
+				line++;
+				s++;
+			} else if (*s != 0)
 				s++;
+			else
+				line++;
 		}
 	}
 
diff -Nru src-old/emu/uimain.h src/emu/uimain.h
--- src-old/emu/uimain.h	2012-04-06 21:59:27.000000000 +0200
+++ src/emu/uimain.h	2012-05-07 08:38:35.000000000 +0200
@@ -47,6 +47,7 @@
 		CHEAT,
 		MEMORY_CARD,
 		SELECT_GAME,
+		BIOS_SELECTION,
 	};
 };
 
@@ -120,7 +121,6 @@
 	void populate_and_sort(struct input_item_data *itemlist);
 	virtual void update_input(struct input_item_data *seqchangeditem) = 0;
 	void toggle_none_default(input_seq &selected_seq, input_seq &original_seq, const input_seq &selected_defseq);
-	const input_seq &get_field_default_seq(input_field_config *field, input_seq_type seqtype);
 
 protected:
 	const void *		pollingref;
@@ -211,7 +211,7 @@
 
 	/* internal analog menu item data */
 	struct analog_item_data {
-		input_field_config *field;
+		ioport_field *field;
 		int					type;
 		int					min, max;
 		int					cur;
@@ -364,6 +364,15 @@
 	void build_driver_list();
 };
 
+class ui_menu_bios_selection : public ui_menu {
+public:
+	ui_menu_bios_selection(running_machine &machine, render_container *container);
+	virtual ~ui_menu_bios_selection();
+	virtual void populate();
+	virtual void handle();
+
+private:
+};
 /* force game select menu */
 void ui_menu_force_game_select(running_machine &machine, render_container *container);
 
diff -Nru src-old/emu/uimenu.c src/emu/uimenu.c
--- src-old/emu/uimenu.c	2012-03-06 23:28:52.000000000 +0100
+++ src/emu/uimenu.c	2012-05-03 11:00:08.000000000 +0200
@@ -907,7 +907,7 @@
 
 	/* see if any other UI keys are pressed */
 	if (menu_event.iptkey == IPT_INVALID)
-		for (code = __ipt_ui_start; code <= __ipt_ui_end; code++)
+		for (code = IPT_UI_FIRST + 1; code < IPT_UI_LAST; code++)
 		{
 			if (code == IPT_UI_CONFIGURE || (code == IPT_UI_LEFT && ignoreleft) || (code == IPT_UI_RIGHT && ignoreright) || (code == IPT_UI_PAUSE && ignorepause))
 				continue;
diff -Nru src-old/emu/validity.c src/emu/validity.c
--- src-old/emu/validity.c	2012-04-15 07:44:22.000000000 +0200
+++ src/emu/validity.c	2012-05-03 11:00:08.000000000 +0200
@@ -71,7 +71,7 @@
 
 inline const char *validity_checker::ioport_string_from_index(UINT32 index)
 {
-	return input_port_string_from_token((const char *)(FPTR)index);
+	return ioport_configurer::string_from_token((const char *)(FPTR)index);
 }
 
 
@@ -808,38 +808,38 @@
 //  analog input field
 //-------------------------------------------------
 
-void validity_checker::validate_analog_input_field(input_field_config &field)
+void validity_checker::validate_analog_input_field(ioport_field &field)
 {
 	// analog ports must have a valid sensitivity
-	if (field.sensitivity == 0)
+	if (field.sensitivity() == 0)
 		mame_printf_error("Analog port with zero sensitivity\n");
 
 	// check that the default falls in the bitmask range
-	if (field.defvalue & ~field.mask)
-		mame_printf_error("Analog port with a default value (%X) out of the bitmask range (%X)\n", field.defvalue, field.mask);
+	if (field.defvalue() & ~field.mask())
+		mame_printf_error("Analog port with a default value (%X) out of the bitmask range (%X)\n", field.defvalue(), field.mask());
 
 	// tests for positional devices
-	if (field.type == IPT_POSITIONAL || field.type == IPT_POSITIONAL_V)
+	if (field.type() == IPT_POSITIONAL || field.type() == IPT_POSITIONAL_V)
 	{
 		int shift;
-		for (shift = 0; shift <= 31 && (~field.mask & (1 << shift)) != 0; shift++) ;
+		for (shift = 0; shift <= 31 && (~field.mask() & (1 << shift)) != 0; shift++) ;
 
 		// convert the positional max value to be in the bitmask for testing
-		INT32 analog_max = field.max;
+		INT32 analog_max = field.maxval();
 		analog_max = (analog_max - 1) << shift;
 
 		// positional port size must fit in bits used
-		if ((field.mask >> shift) + 1 < field.max)
+		if ((field.mask() >> shift) + 1 < field.maxval())
 			mame_printf_error("Analog port with a positional port size bigger then the mask size\n");
 	}
 
 	// tests for absolute devices
-	else if (field.type >= __ipt_analog_absolute_start && field.type <= __ipt_analog_absolute_end)
+	else if (field.type() > IPT_ANALOG_ABSOLUTE_FIRST && field.type() < IPT_ANALOG_ABSOLUTE_LAST)
 	{
 		// adjust for signed values
-		INT32 default_value = field.defvalue;
-		INT32 analog_min = field.min;
-		INT32 analog_max = field.max;
+		INT32 default_value = field.defvalue();
+		INT32 analog_min = field.minval();
+		INT32 analog_max = field.maxval();
 		if (analog_min > analog_max)
 		{
 			analog_min = -analog_min;
@@ -849,19 +849,19 @@
 
 		// check that the default falls in the MINMAX range
 		if (default_value < analog_min || default_value > analog_max)
-			mame_printf_error("Analog port with a default value (%X) out of PORT_MINMAX range (%X-%X)\n", field.defvalue, field.min, field.max);
+			mame_printf_error("Analog port with a default value (%X) out of PORT_MINMAX range (%X-%X)\n", field.defvalue(), field.minval(), field.maxval());
 
 		// check that the MINMAX falls in the bitmask range
 		// we use the unadjusted min for testing
-		if (field.min & ~field.mask || analog_max & ~field.mask)
-			mame_printf_error("Analog port with a PORT_MINMAX (%X-%X) value out of the bitmask range (%X)\n", field.min, field.max, field.mask);
+		if (field.minval() & ~field.mask() || analog_max & ~field.mask())
+			mame_printf_error("Analog port with a PORT_MINMAX (%X-%X) value out of the bitmask range (%X)\n", field.minval(), field.maxval(), field.mask());
 
 		// absolute analog ports do not use PORT_RESET
-		if (field.flags & ANALOG_FLAG_RESET)
+		if (field.analog_reset())
 			mame_printf_error("Absolute analog port using PORT_RESET\n");
 
 		// absolute analog ports do not use PORT_WRAPS
-		if (field.flags & ANALOG_FLAG_WRAPS)
+		if (field.analog_wraps())
 			mame_printf_error("Absolute analog port using PORT_WRAPS\n");
 	}
 
@@ -869,16 +869,16 @@
 	else
 	{
 		// relative devices do not use PORT_MINMAX
-		if (field.min != 0 || field.max != field.mask)
+		if (field.minval() != 0 || field.maxval() != field.mask())
 			mame_printf_error("Relative port using PORT_MINMAX\n");
 
 		// relative devices do not use a default value
 		// the counter is at 0 on power up
-		if (field.defvalue != 0)
+		if (field.defvalue() != 0)
 			mame_printf_error("Relative port using non-0 default value\n");
 
 		// relative analog ports do not use PORT_WRAPS
-		if (field.flags & ANALOG_FLAG_WRAPS)
+		if (field.analog_wraps())
 			mame_printf_error("Absolute analog port using PORT_WRAPS\n");
 	}
 }
@@ -889,7 +889,7 @@
 //  setting
 //-------------------------------------------------
 
-void validity_checker::validate_dip_settings(input_field_config &field)
+void validity_checker::validate_dip_settings(ioport_field &field)
 {
 	const char *demo_sounds = ioport_string_from_index(INPUT_STRING_Demo_Sounds);
 	const char *flipscreen = ioport_string_from_index(INPUT_STRING_Flip_Screen);
@@ -897,46 +897,46 @@
 	bool coin_error = false;
 
 	// iterate through the settings
-	for (const input_setting_config *setting = field.settinglist().first(); setting != NULL; setting = setting->next())
+	for (ioport_setting *setting = field.first_setting(); setting != NULL; setting = setting->next())
 	{
 		// note any coinage strings
-		int strindex = get_defstr_index(setting->name);
+		int strindex = get_defstr_index(setting->name());
 		if (strindex >= __input_string_coinage_start && strindex <= __input_string_coinage_end)
 			coin_list[strindex - __input_string_coinage_start] = 1;
 
 		// make sure demo sounds default to on
-		if (field.name == demo_sounds && strindex == INPUT_STRING_On && field.defvalue != setting->value)
+		if (field.name() == demo_sounds && strindex == INPUT_STRING_On && field.defvalue() != setting->value())
 			mame_printf_error("Demo Sounds must default to On\n");
 
 		// check for bad demo sounds options
-		if (field.name == demo_sounds && (strindex == INPUT_STRING_Yes || strindex == INPUT_STRING_No))
-			mame_printf_error("Demo Sounds option must be Off/On, not %s\n", setting->name);
+		if (field.name() == demo_sounds && (strindex == INPUT_STRING_Yes || strindex == INPUT_STRING_No))
+			mame_printf_error("Demo Sounds option must be Off/On, not %s\n", setting->name());
 
 		// check for bad flip screen options
-		if (field.name == flipscreen && (strindex == INPUT_STRING_Yes || strindex == INPUT_STRING_No))
-			mame_printf_error("Flip Screen option must be Off/On, not %s\n", setting->name);
+		if (field.name() == flipscreen && (strindex == INPUT_STRING_Yes || strindex == INPUT_STRING_No))
+			mame_printf_error("Flip Screen option must be Off/On, not %s\n", setting->name());
 
 		// if we have a neighbor, compare ourselves to him
 		if (setting->next() != NULL)
 		{
 			// check for inverted off/on dispswitch order
-			int next_strindex = get_defstr_index(setting->next()->name, true);
+			int next_strindex = get_defstr_index(setting->next()->name(), true);
 			if (strindex == INPUT_STRING_On && next_strindex == INPUT_STRING_Off)
-				mame_printf_error("%s option must have Off/On options in the order: Off, On\n", field.name);
+				mame_printf_error("%s option must have Off/On options in the order: Off, On\n", field.name());
 
 			// check for inverted yes/no dispswitch order
 			else if (strindex == INPUT_STRING_Yes && next_strindex == INPUT_STRING_No)
-				mame_printf_error("%s option must have Yes/No options in the order: No, Yes\n", field.name);
+				mame_printf_error("%s option must have Yes/No options in the order: No, Yes\n", field.name());
 
 			// check for inverted upright/cocktail dispswitch order
 			else if (strindex == INPUT_STRING_Cocktail && next_strindex == INPUT_STRING_Upright)
-				mame_printf_error("%s option must have Upright/Cocktail options in the order: Upright, Cocktail\n", field.name);
+				mame_printf_error("%s option must have Upright/Cocktail options in the order: Upright, Cocktail\n", field.name());
 
 			// check for proper coin ordering
 			else if (strindex >= __input_string_coinage_start && strindex <= __input_string_coinage_end && next_strindex >= __input_string_coinage_start && next_strindex <= __input_string_coinage_end &&
-					 strindex >= next_strindex && memcmp(&setting->condition, &setting->next()->condition, sizeof(setting->condition)) == 0)
+					 strindex >= next_strindex && setting->condition() == setting->next()->condition())
 			{
-				mame_printf_error("%s option has unsorted coinage %s > %s\n", field.name, setting->name, setting->next()->name);
+				mame_printf_error("%s option has unsorted coinage %s > %s\n", field.name(), setting->name(), setting->next()->name());
 				coin_error = true;
 			}
 		}
@@ -958,15 +958,15 @@
 //  stored within an ioport field or setting
 //-------------------------------------------------
 
-void validity_checker::validate_condition(input_condition &condition, device_t &device, int_map &port_map)
+void validity_checker::validate_condition(ioport_condition &condition, device_t &device, int_map &port_map)
 {
 	// resolve the tag
 	astring porttag;
-	device.subtag(porttag, condition.tag);
+	device.subtag(porttag, condition.tag());
 
 	// then find a matching port
 	if (port_map.find(porttag) == 0)
-		mame_printf_error("Condition referencing non-existent ioport tag '%s'\n", condition.tag);
+		mame_printf_error("Condition referencing non-existent ioport tag '%s'\n", condition.tag());
 }
 
 
@@ -992,38 +992,38 @@
 		// allocate the input ports
 		ioport_list portlist;
 		astring errorbuf;
-		input_port_list_init(*device, portlist, errorbuf);
+		portlist.append(*device, errorbuf);
 
 		// report any errors during construction
 		if (errorbuf)
 			mame_printf_error("I/O port error during construction:\n%s\n", errorbuf.cstr());
 
 		// do a first pass over ports to add their names and find duplicates
-		for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
 			if (port_map.add(port->tag(), 1, false) == TMERR_DUPLICATE)
 				mame_printf_error("Multiple I/O ports with the same tag '%s' defined\n", port->tag());
 
 		// iterate over ports
-		for (input_port_config *port = portlist.first(); port != NULL; port = port->next())
+		for (ioport_port *port = portlist.first(); port != NULL; port = port->next())
 		{
 			m_current_ioport = port->tag();
 
 			// iterate through the fields on this port
-			for (input_field_config *field = port->fieldlist().first(); field != NULL; field = field->next())
+			for (ioport_field *field = port->first_field(); field != NULL; field = field->next())
 			{
 				// verify analog inputs
-				if (input_type_is_analog(field->type))
+				if (field->is_analog())
 					validate_analog_input_field(*field);
 
 				// look for invalid (0) types which should be mapped to IPT_OTHER
-				if (field->type == IPT_INVALID)
+				if (field->type() == IPT_INVALID)
 					mame_printf_error("Field has an invalid type (0); use IPT_OTHER instead\n");
 
 				// verify dip switches
-				if (field->type == IPT_DIPSWITCH)
+				if (field->type() == IPT_DIPSWITCH)
 				{
 					// dip switch fields must have a name
-					if (field->name == NULL)
+					if (field->name() == NULL)
 						mame_printf_error("DIP switch has a NULL name\n");
 
 					// verify the settings list
@@ -1031,32 +1031,33 @@
 				}
 
 				// verify names
-				if (field->name != NULL)
+				const char *name = field->specific_name();
+				if (name != NULL)
 				{
 					// check for empty string
-					if (field->name[0] == 0)
+					if (name[0] == 0)
 						mame_printf_error("Field name is an empty string\n");
 
 					// check for trailing spaces
-					if (field->name[0] != 0 && field->name[strlen(field->name) - 1] == ' ')
-						mame_printf_error("Field '%s' has trailing spaces\n", field->name);
+					if (name[0] != 0 && name[strlen(name) - 1] == ' ')
+						mame_printf_error("Field '%s' has trailing spaces\n", name);
 
 					// check for invalid UTF-8
-					if (!utf8_is_valid_string(field->name))
-						mame_printf_error("Field '%s' has invalid characters\n", field->name);
+					if (!utf8_is_valid_string(name))
+						mame_printf_error("Field '%s' has invalid characters\n", name);
 
 					// look up the string and print an error if default strings are not used
-					/*strindex =get_defstr_index(defstr_map, field->name, driver, &error);*/
+					/*strindex =get_defstr_index(defstr_map, name, driver, &error);*/
 				}
 
 				// verify conditions on the field
-				if (field->condition.tag != NULL)
-					validate_condition(field->condition, *device, port_map);
+				if (!field->condition().none())
+					validate_condition(field->condition(), *device, port_map);
 
 				// verify conditions on the settings
-				for (input_setting_config *setting = field->settinglist().first(); setting != NULL; setting = setting->next())
-					if (setting->condition.tag != NULL)
-						validate_condition(setting->condition, *device, port_map);
+				for (ioport_setting *setting = field->first_setting(); setting != NULL; setting = setting->next())
+					if (!setting->condition().none())
+						validate_condition(setting->condition(), *device, port_map);
 			}
 
 			// done with this port
diff -Nru src-old/emu/validity.h src/emu/validity.h
--- src-old/emu/validity.h	2012-04-06 21:59:27.000000000 +0200
+++ src/emu/validity.h	2012-05-03 11:00:08.000000000 +0200
@@ -93,9 +93,9 @@
 	void validate_roms();
 	void validate_display();
 	void validate_gfx();
-	void validate_analog_input_field(input_field_config &field);
-	void validate_dip_settings(input_field_config &field);
-	void validate_condition(input_condition &condition, device_t &device, int_map &port_map);
+	void validate_analog_input_field(ioport_field &field);
+	void validate_dip_settings(ioport_field &field);
+	void validate_condition(ioport_condition &condition, device_t &device, int_map &port_map);
 	void validate_inputs();
 	void validate_devices();
 
diff -Nru src-old/emu/video/mc6845.c src/emu/video/mc6845.c
--- src-old/emu/video/mc6845.c	2012-01-24 22:18:55.000000000 +0100
+++ src/emu/video/mc6845.c	2012-04-26 21:59:07.000000000 +0200
@@ -236,7 +236,7 @@
 	/* display message if the Mode Control register is not zero */
 	if ((m_register_address_latch == 0x08) && (m_mode_control != 0))
 		if (!m_supports_transparent)
-			popmessage("Mode Control %02X is not supported!!!", m_mode_control);
+			logerror("M6845: Mode Control %02X is not supported!!!\n", m_mode_control);
 
 	recompute_parameters(false);
 }
@@ -747,7 +747,7 @@
 			m_end_update(this, bitmap, cliprect, param);
 	}
 	else
-		popmessage("Invalid MC6845 screen parameters - display disabled!!!");
+		logerror("M6845: Invalid screen parameters - display disabled!!!\n");
 	return 0;
 }
 
diff -Nru src-old/emu/video/pc_cga.c src/emu/video/pc_cga.c
--- src-old/emu/video/pc_cga.c	2012-04-22 07:07:46.000000000 +0200
+++ src/emu/video/pc_cga.c	2012-05-03 11:00:08.000000000 +0200
@@ -138,10 +138,10 @@
 INPUT_PORTS_END
 
 /* Dipswitch for font selection */
-#define CGA_FONT        (input_port_read_direct(cga.config_input_port)&3)
+#define CGA_FONT        (cga.config_input_port->read()&3)
 
 /* Dipswitch for monitor selection */
-#define CGA_MONITOR     (input_port_read_direct(cga.config_input_port)&0x1C)
+#define CGA_MONITOR     (cga.config_input_port->read()&0x1C)
 #define CGA_MONITOR_RGB         0x00    /* Colour RGB */
 #define CGA_MONITOR_MONO        0x04    /* Greyscale RGB */
 #define CGA_MONITOR_COMPOSITE   0x08    /* Colour composite */
@@ -150,7 +150,7 @@
 
 
 /* Dipswitch for chipset selection */
-#define CGA_CHIPSET     (input_port_read_direct(cga.config_input_port)&0xE0)
+#define CGA_CHIPSET     (cga.config_input_port->read()&0xE0)
 #define CGA_CHIPSET_IBM         0x00    /* Original IBM CGA */
 #define CGA_CHIPSET_PC1512      0x20    /* PC1512 CGA subset */
 #define CGA_CHIPSET_PC200       0x40    /* PC200 in CGA mode */
@@ -242,7 +242,7 @@
 
 	UINT8	*chr_gen;
 
-	const input_port_config *config_input_port;
+	ioport_port *config_input_port;
 
 	mc6845_update_row_func	update_row;
 	UINT8	palette_lut_2bpp[4];
diff -Nru src-old/emu/video/rgbvmx.h src/emu/video/rgbvmx.h
--- src-old/emu/video/rgbvmx.h	2011-10-13 04:29:27.000000000 +0200
+++ src/emu/video/rgbvmx.h	2012-04-30 00:36:17.000000000 +0200
@@ -432,7 +432,9 @@
 
 // altivec.h somehow redefines "bool" in a bad way on PowerPC Mac OS X.  really.
 #ifdef SDLMAME_MACOSX
-#include <stdbool.h>
+#undef vector
+#undef pixel
+#undef bool
 #endif
 
 #endif /* __RGBVMX__ */
diff -Nru src-old/ldplayer/ldplayer.c src/ldplayer/ldplayer.c
--- src-old/ldplayer/ldplayer.c	2012-02-19 17:23:23.000000000 +0100
+++ src/ldplayer/ldplayer.c	2012-05-03 11:00:08.000000000 +0200
@@ -97,7 +97,7 @@
 
 	// internal state
 	astring m_filename;
-	input_port_value m_last_controls;
+	ioport_value m_last_controls;
 	bool m_playing;
 	required_device<laserdisc_device> m_laserdisc;
 };
@@ -217,7 +217,7 @@
 
 void ldplayer_state::process_commands()
 {
-	input_port_value controls = input_port_read(machine(), "controls");
+	ioport_value controls = machine().root_device().ioport("controls")->read();
 	int number;
 
 	// step backwards
diff -Nru src-old/lib/formats/adam_cas.c src/lib/formats/adam_cas.c
--- src-old/lib/formats/adam_cas.c	2012-04-22 16:10:44.000000000 +0200
+++ src/lib/formats/adam_cas.c	2012-04-24 13:58:27.000000000 +0200
@@ -58,7 +58,7 @@
 // Store byte of data
 casserr_t coladam_put_byte(cassette_image *cass, int channel, double *time_index, int byte, int *prev_sign)
 {
-	casserr_t err;
+	casserr_t err = CASSETTE_ERROR_SUCCESS;
 	for (int i = 0; i < 8; i++)
 	{
 		if(byte & 0x80)
@@ -127,7 +127,7 @@
 	double time = 0.;
 	int i, block, prev_sign=-1;
 	UINT8 buffer[0x400];
-	casserr_t err;
+	casserr_t err = CASSETTE_ERROR_SUCCESS;
 
 	// It would appear that data packs that originally had the type GW data layout and headers work fine when converted to type
 	// HE. Thus we set all tapes to type HE.
@@ -194,10 +194,7 @@
 		}
 	}
 
-	if (err)
-		return err;
-
-	return CASSETTE_ERROR_SUCCESS;
+	return err;
 }
 
 
diff -Nru src-old/lib/formats/ap2_dsk.c src/lib/formats/ap2_dsk.c
--- src-old/lib/formats/ap2_dsk.c	2012-04-22 16:10:44.000000000 +0200
+++ src/lib/formats/ap2_dsk.c	2012-05-07 08:57:50.000000000 +0200
@@ -581,6 +581,7 @@
 		return size == expected_size;
 }
 
+// following is placeholder, is completely wrong.
 const floppy_image_format_t::desc_e a2_16sect_format::mac_gcr[] = {
 		{ SECTOR_LOOP_START, 0, -1 },
 		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
@@ -613,31 +614,32 @@
 
 bool a2_16sect_format::load(io_generic *io, UINT32 form_factor, floppy_image *image)
 {
-
-		UINT8 sector_data[(256)*16];
-		memset(sector_data, 0, sizeof(sector_data));
-
-		desc_s sectors[16];
-		int format = 0;
-		int pos_data = 0;
-
-		int head_count = 1;
-
-		for(int track=0; track < 35; track++) {
-				for(int head=0; head < head_count; head++) {
-						for(int si=0; si<16; si++) {
-								UINT8 *data = sector_data + (256)*si;
-								sectors[si].data = data;
-								sectors[si].size = 256;
-								sectors[si].sector_id = si;
-								sectors[si].sector_info = format;
-								io_generic_read(io, data, pos_data, 256);
-								pos_data += 256;
-						}
-						generate_track(mac_gcr, track, head, sectors, 16, 3104*16, image);
-				}
-		}
-		return true;
+/*      TODO: rewrite me properly
+        UINT8 sector_data[(256)*16];
+        memset(sector_data, 0, sizeof(sector_data));
+
+        desc_s sectors[16];
+        int format = 0;
+        int pos_data = 0;
+
+        int head_count = 1;
+
+        for(int track=0; track < 35; track++) {
+                for(int head=0; head < head_count; head++) {
+                        for(int si=0; si<16; si++) {
+                                UINT8 *data = sector_data + (256)*si;
+                                sectors[si].data = data;
+                                sectors[si].size = 256;
+                                sectors[si].sector_id = si;
+                                sectors[si].sector_info = format;
+                                io_generic_read(io, data, pos_data, 256);
+                                pos_data += 256;
+                        }
+                        generate_track(mac_gcr, track, head, sectors, 16, 3104*16, image);
+                }
+        }
+        return true;*/
+		return false; // I hope that throws an error...
 }
 
 UINT8 a2_16sect_format::gb(const UINT8 *buf, int ts, int &pos, int &wrap)
@@ -663,11 +665,25 @@
 {
 		int g_tracks, g_heads;
 		int visualgrid[16][35]; // visualizer grid, cleared/initialized below
+// lenient addr check: if unset, only accept an addr mark if the checksum was good
+// if set, accept an addr mark if the track and sector values are both sane
+#undef LENIENT_ADDR_CHECK
+// if set, use the old, not as robust logic for choosing which copy of a decoded sector to write
+// to the resulting image if the sector has a bad checksum and/or postamble
+#undef USE_OLD_BEST_SECTOR_PRIORITY
+// select a sector order for resulting file: 0 = logical, 1 = dos3.3, 2 = prodos
+#define SECTOR_ORDER 1
+// nothing found
 #define NOTFOUND 0
+// address mark was found
 #define ADDRFOUND 1
+// address checksum is good
 #define ADDRGOOD 2
+// data mark was found (requires addrfound and sane values)
 #define DATAFOUND 4
+// data checksum is good
 #define DATAGOOD 8
+// data postamble is good
 #define DATAPOST 16
 		for (int i = 0; i < 16; i++) {
 			for (int j = 0; j < 35; j++) {
@@ -686,12 +702,14 @@
 				int nsect = 16;
 				UINT8 buf[130000]; // originally 13000, multiread dfi disks need larger
 				int ts;
-fprintf(stderr,"DEBUG: a2_16sect_format::save() about to generate bitstream from physical track %d (logical %d)...", track, track/2);
-				generate_bitstream_from_track(track, head, 200000000/(3104*nsect*1), buf, ts, image); // 3104 needs tweaking, *3 is 3x multiread from a dfi disk
-fprintf(stderr,"done.\n");
+//fprintf(stderr,"DEBUG: a2_16sect_format::save() about to generate bitstream from physical track %d (logical %d)...", track, track/2);
+				//~332 samples per cell, times 3+8+3 (14) for address mark, 24 for sync, 3+343+3 (349) for data mark, 24 for sync is around 743, near 776 expected
+				generate_bitstream_from_track(track, head, 200000000/((3004*nsect*6)/2), buf, ts, image); // 3104 needs tweaking
+//fprintf(stderr,"done.\n");
 				int pos = 0;
 				int wrap = 0;
 				int hb = 0;
+				int dosver = 0; // apple dos version; 0 = >=3.3, 1 = <3.3
 				for(;;) {
 						UINT8 v = gb(buf, ts, pos, wrap);
 						if(v == 0xff)
@@ -700,8 +718,10 @@
 								hb = 2;
 						else if(hb == 2 && v == 0xaa)
 								hb = 3;
-						else if(hb == 3 && v == 0x96)
+						else if(hb == 3 && ((v == 0x96) || (v == 0xab))) { // 0x96 = dos 3.3/16sec, 0xab = dos 3.21 and below/13sec
 								hb = 4;
+								if (v == 0xab) dosver = 1;
+								}
 						else
 								hb = 0;
 
@@ -716,9 +736,15 @@
 								UINT8 chk = gcr4_decode(h[6],h[7]);
 								UINT32 post = (h[8]<<16)|(h[9]<<8)|h[10];
 								printf("Address Mark:\tVolume %d, Track %d, Sector %2d, Checksum %02X: %s, Postamble %03X: %s\n", vl, tr, se, chk, (chk ^ vl ^ tr ^ se)==0?"OK":"BAD", post, (post&0xFFFF00)==0xDEAA00?"OK":"BAD");
+								// sanity check
 								if (tr == track/2 && se < nsect) {
-										visualgrid[se][track/2] |= ADDRFOUND;
-										visualgrid[se][track/2] |= (chk ^ vl ^ tr ^ se)==0?ADDRGOOD:0;
+								visualgrid[se][track/2] |= ADDRFOUND;
+								visualgrid[se][track/2] |= ((chk ^ vl ^ tr ^ se)==0)?ADDRGOOD:0;
+#ifdef LENIENT_ADDR_CHECK
+									if ((visualgrid[se][track/2] & ADDRFOUND) == ADDRFOUND) {
+#else
+									if ((visualgrid[se][track/2] & ADDRGOOD) == ADDRGOOD) {
+#endif
 										int opos = pos;
 										int owrap = wrap;
 										hb = 0;
@@ -735,9 +761,24 @@
 												else
 														hb = 0;
 										}
-										if(hb == 4) {
+										if((hb == 4)&&(dosver == 0)) {
 												visualgrid[se][track/2] |= DATAFOUND;
-												UINT8 *dest = sectdata+(256)*se;
+												int sector_translate[16] = {
+#if SECTOR_ORDER == 0
+												// logical order (0-15)
+												0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+												0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
+#elif SECTOR_ORDER == 1
+												// DOS order (*.do)
+												0x00, 0x07, 0x0E, 0x06, 0x0D, 0x05, 0x0C, 0x04,
+												0x0B, 0x03, 0x0A, 0x02, 0x09, 0x01, 0x08, 0x0F
+#elif SECTOR_ORDER == 2
+												// prodos order (*.po)
+												0x00, 0x08, 0x01, 0x09, 0x02, 0x0A, 0x03, 0x0B,
+												0x04, 0x0C, 0x05, 0x0D, 0x06, 0x0E, 0x07, 0x0F
+#endif
+												};
+												UINT8 *dest = sectdata+(256)*sector_translate[se];
 												UINT8 data[0x157];
 												UINT32 dpost = 0;
 												UINT8 c = 0;
@@ -766,26 +807,45 @@
 												// now decode it into 256 bytes
 												// but only write it if the bitfield of the track shows datagood is NOT set.
 												// if it is set we don't want to overwrite a guaranteed good read with a bad one
-												if ((visualgrid[se][track/2]&DATAGOOD)==0) {
-													// TODO:
-													// if the current read is good but the postamble isn't, write it in.
-													// if the current read isn't good but the postamble is, its better than nothing.
+												// if past read had a bad checksum or bad postamble...
+#ifndef USE_OLD_BEST_SECTOR_PRIORITY
+												if (((visualgrid[se][track/2]&DATAGOOD)==0)||((visualgrid[se][track/2]&DATAPOST)==0)) {
+													// if the current read is good, and postamble is good, write it in, no matter what.
+													// if the current read is good and the current postamble is bad, write it in unless the postamble was good before
+													// if the current read is bad and the current postamble is good and the previous read had neither good, write it in
 													// if the current read isn't good and neither is the postamble but nothing better
 													// has been written before, write it anyway.
-													for(int i=0x56; i<0x156; i++) {
-														UINT8 dv = data[i];
-														*dest++ = dv;
+													if ( ((data[0x156] == c) && (dpost&0xFFFF00)==0xDEAA00) ||
+													(((data[0x156] == c) && (dpost&0xFFFF00)!=0xDEAA00) && ((visualgrid[se][track/2]&DATAPOST)==0)) ||
+													(((data[0x156] != c) && (dpost&0xFFFF00)==0xDEAA00) && (((visualgrid[se][track/2]&DATAGOOD)==0)&&(visualgrid[se][track/2]&DATAPOST)==0)) ||
+													(((data[0x156] != c) && (dpost&0xFFFF00)!=0xDEAA00) && (((visualgrid[se][track/2]&DATAGOOD)==0)&&(visualgrid[se][track/2]&DATAPOST)==0))
+													) {
+														for(int i=0x56; i<0x156; i++) {
+															UINT8 dv = data[i];
+															*dest++ = dv;
+														}
 													}
 												}
-												// do some checking
-												if ((data[0x156] != c) || (dpost&0xFFFF00)!=0xDEAA00) {
-												printf("Data Mark:\tChecksum xpctd %d found %d: %s, Postamble %03X: %s\n", data[0x156], c, (data[0x156]==c)?"OK":"BAD", dpost, (dpost&0xFFFF00)==0xDEAA00?"OK":"BAD");
+#else
+												if ((visualgrid[se][track/2]&DATAGOOD)==0) {
+														for(int i=0x56; i<0x156; i++) {
+															UINT8 dv = data[i];
+															*dest++ = dv;
+														}
 												}
-												else visualgrid[se][track/2] |= DATAGOOD;
+#endif
+												// do some checking
+												if ((data[0x156] != c) || (dpost&0xFFFF00)!=0xDEAA00)
+													fprintf(stderr,"Data Mark:\tChecksum xpctd %d found %d: %s, Postamble %03X: %s\n", data[0x156], c, (data[0x156]==c)?"OK":"BAD", dpost, (dpost&0xFFFF00)==0xDEAA00?"OK":"BAD");
+												if (data[0x156] == c) visualgrid[se][track/2] |= DATAGOOD;
+												if ((dpost&0xFFFF00)==0xDEAA00) visualgrid[se][track/2] |= DATAPOST;
+										} else if ((hb == 4)&&(dosver == 1)) {
+											fprintf(stderr,"ERROR: We don't handle dos sectors below 3.3 yet!\n");
 										} else {
 												pos = opos;
 												wrap = owrap;
 										}
+									}
 								}
 								hb = 0;
 						}
@@ -801,22 +861,517 @@
 				//printf("\n");
 		}
 		// display a little table of which sectors decoded ok
+		int total_good = 0;
 		for (int j = 0; j < 35; j++) {
 			printf("T%2d: ",j);
 			for (int i = 0; i < 16; i++) {
-				if (visualgrid[i][j] == NOTFOUND) printf("-NF-");
+				if (visualgrid[i][j] == NOTFOUND) printf("-NF- ");
 				else {
 				if (visualgrid[i][j] & ADDRFOUND) printf("a"); else printf(" ");
 				if (visualgrid[i][j] & ADDRGOOD) printf("A"); else printf(" ");
 				if (visualgrid[i][j] & DATAFOUND) printf("d"); else printf(" ");
-				if (visualgrid[i][j] & DATAGOOD) printf("D"); else printf(" ");
+				if (visualgrid[i][j] & DATAGOOD) { printf("D"); total_good++; } else printf(" ");
+				if (visualgrid[i][j] & DATAPOST) printf("."); else printf(" ");
 				}
-				printf(" ");
 			}
 			printf("\n");
 		}
+		printf("Total Good Sectors: %d\n", total_good);
 
 		return true;
 }
 
 const floppy_format_type FLOPPY_A216S_FORMAT = &floppy_image_format_creator<a2_16sect_format>;
+/* RWTS18 format
+ * Developed by Roland Gustafsson (http://www.acts.org/roland/index.html)
+   for Br0derbund Software around 1986
+   This format works as follows:
+ * Track 0, in its entirety, is a normal 16-sector track, nothing special.
+   (some disks may lack a normal sector 0 on this track, more info needed)
+ * Tracks 1 thru 34 are in the special "RWTS18" track format:
+   The format consists of six "large" sectors with 768 bytes each.
+   Each of those large sectors has a title-specific sync byte and contains
+   three "virtual" small sectors of 256 bytes, in an order like follows:
+   BigSector    Contains
+   0:           0,  6, 12
+   1:           1,  7, 13
+   2:           2,  8, 14
+   3:           3,  9, 15
+   4:           4, 10, 16
+   5:           5, 11, 17
+   The sector format is: (all gcr6)
+   D5 9D <track> <sector> <checksum> AA FF FF <titlespecific sync> <0x400 nybbles which represent 768 bytes> <data checksum> D6
+   Title-specific sync bytes are:
+    Airheart: D4
+    Toy Shop: unknown
+    Carmen USA: unknown (not all released versions used RWTS18)
+    Wings of Fury: 96
+    Prince of Persia: unknown
+    And several others.
+*/
+a2_rwts18_format::a2_rwts18_format() : floppy_image_format_t()
+{
+}
+
+const char *a2_rwts18_format::name() const
+{
+		return "a2_rwts18";
+}
+
+const char *a2_rwts18_format::description() const
+{
+		return "Apple II RWTS18-type Image";
+}
+
+const char *a2_rwts18_format::extensions() const
+{
+		return "rti";
+}
+
+bool a2_rwts18_format::supports_save() const
+{
+		return true;
+}
+
+int a2_rwts18_format::identify(io_generic *io, UINT32 form_factor)
+{
+		int size = io_generic_size(io);
+		int expected_size = 35 * 16 * 256;
+		return size == expected_size;
+}
+
+// following is placeholder, is completely wrong.
+const floppy_image_format_t::desc_e a2_rwts18_format::mac_gcr[] = {
+		{ SECTOR_LOOP_START, 0, -1 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xd5aa96, 24 },
+		{   CRC_MACHEAD_START, 0 },
+		{     TRACK_ID_GCR6 },
+		{     SECTOR_ID_GCR6 },
+		{     TRACK_HEAD_ID_GCR6 },
+		{     SECTOR_INFO_GCR6 },
+		{   CRC_END, 0 },
+		{   CRC, 0 },
+		{   RAWBITS, 0xdeaaff, 24 },
+		{   RAWBITS, 0xff3fcf, 24 }, { RAWBITS, 0xf3fcff, 24 },
+		{   RAWBITS, 0xd5aaad, 24 },
+		{   SECTOR_ID_GCR6 },
+		{   SECTOR_DATA_MAC, -1 },
+		{   RAWBITS, 0xdeaaff, 24 },
+		{   RAWBITS, 0xff, 8 },
+		{ SECTOR_LOOP_END },
+		{ END },
+};
+
+
+bool a2_rwts18_format::load(io_generic *io, UINT32 form_factor, floppy_image *image)
+{
+/*      TODO: rewrite me properly
+        UINT8 sector_data[(256)*16];
+        memset(sector_data, 0, sizeof(sector_data));
+
+        desc_s sectors[16];
+        int format = 0;
+        int pos_data = 0;
+
+        int head_count = 1;
+
+        for(int track=0; track < 35; track++) {
+                for(int head=0; head < head_count; head++) {
+                        for(int si=0; si<16; si++) {
+                                UINT8 *data = sector_data + (256)*si;
+                                sectors[si].data = data;
+                                sectors[si].size = 256;
+                                sectors[si].sector_id = si;
+                                sectors[si].sector_info = format;
+                                io_generic_read(io, data, pos_data, 256);
+                                pos_data += 256;
+                        }
+                        generate_track(mac_gcr, track, head, sectors, 16, 3104*16, image);
+                }
+        }
+        return true;*/
+		return false; // I hope that throws an error...
+}
+
+UINT8 a2_rwts18_format::gb(const UINT8 *buf, int ts, int &pos, int &wrap)
+{
+		UINT8 v = 0;
+		int w1 = wrap;
+		while(wrap != w1+2 && !(v & 0x80)) {
+				v = v << 1 | ((buf[pos >> 3] >> (7-(pos & 7))) & 1);
+				pos++;
+				if(pos == ts) {
+						pos = 0;
+						wrap++;
+				}
+		}
+		return v;
+}
+
+void a2_rwts18_format::update_chk(const UINT8 *data, int size, UINT32 &chk)
+{
+}
+
+bool a2_rwts18_format::save(io_generic *io, floppy_image *image)
+{
+		int g_tracks, g_heads;
+		int visualgrid[18][35]; // visualizer grid, cleared/initialized below
+// lenient addr check: if unset, only accept an addr mark if the checksum was good
+// if set, accept an addr mark if the track and sector values are both sane
+#undef LENIENT_ADDR_CHECK
+// if set, use the old, not as robust logic for choosing which copy of a decoded sector to write
+// to the resulting image if the sector has a bad checksum and/or postamble
+#undef USE_OLD_BEST_SECTOR_PRIORITY
+// select a sector order for resulting file: 0 = logical, 1 = dos3.3, 2 = prodos
+#define SECTOR_ORDER 1
+// nothing found
+#define NOTFOUND 0
+// address mark was found
+#define ADDRFOUND 1
+// address checksum is good
+#define ADDRGOOD 2
+// data mark was found (requires addrfound and sane values)
+#define DATAFOUND 4
+// data checksum is good
+#define DATAGOOD 8
+// data postamble is good
+#define DATAPOST 16
+		for (int i = 0; i < 18; i++) {
+			for (int j = 0; j < 35; j++) {
+				visualgrid[i][j] = 0;
+			}
+		}
+		image->get_actual_geometry(g_tracks, g_heads);
+
+		int head = 0;
+
+		int pos_data = 0;
+
+		// for track 0 ONLY:
+		UINT8 sectdata[(768)*6];
+		memset(sectdata, 0, sizeof(sectdata));
+		int nsect = 18;
+		UINT8 buf[130000]; // originally 13000, multiread dfi disks need larger
+		int ts;
+//fprintf(stderr,"DEBUG: a2_rwts18_format::save() about to generate bitstream from physical track %d (logical %d)...", track, track/2);
+		//~332 samples per cell, times 3+8+3 (14) for address mark, 24 for sync, 3+343+3 (349) for data mark, 24 for sync is around 743, near 776 expected
+		generate_bitstream_from_track(0, head, 200000000/((3004*nsect*6)/2), buf, ts, image); // 3104 needs tweaking
+//fprintf(stderr,"done.\n");
+		int pos = 0;
+		int wrap = 0;
+		int hb = 0;
+		int dosver = 0; // apple dos version; 0 = >=3.3, 1 = <3.3
+		for(;;) {
+				UINT8 v = gb(buf, ts, pos, wrap);
+				if(v == 0xff)
+						hb = 1;
+				else if(hb == 1 && v == 0xd5)
+						hb = 2;
+				else if(hb == 2 && v == 0xaa)
+						hb = 3;
+				else if(hb == 3 && ((v == 0x96) || (v == 0xab))) { // 0x96 = dos 3.3/16sec, 0xab = dos 3.21 and below/13sec
+						hb = 4;
+						if (v == 0xab) dosver = 1;
+						}
+				else
+						hb = 0;
+
+				if(hb == 4) {
+						UINT8 h[11];
+						for(int i=0; i<11; i++)
+								h[i] = gb(buf, ts, pos, wrap);
+						//UINT8 v2 = gcr6bw_tb[h[2]];
+						UINT8 vl = gcr4_decode(h[0],h[1]);
+						UINT8 tr = gcr4_decode(h[2],h[3]);
+						UINT8 se = gcr4_decode(h[4],h[5]);
+						UINT8 chk = gcr4_decode(h[6],h[7]);
+						UINT32 post = (h[8]<<16)|(h[9]<<8)|h[10];
+						printf("Address Mark:\tVolume %d, Track %d, Sector %2d, Checksum %02X: %s, Postamble %03X: %s\n", vl, tr, se, chk, (chk ^ vl ^ tr ^ se)==0?"OK":"BAD", post, (post&0xFFFF00)==0xDEAA00?"OK":"BAD");
+						// sanity check
+						if (tr == 0 && se < nsect) {
+						visualgrid[se][0] |= ADDRFOUND;
+						visualgrid[se][0] |= ((chk ^ vl ^ tr ^ se)==0)?ADDRGOOD:0;
+#ifdef LENIENT_ADDR_CHECK
+//                          if ((visualgrid[se][0] & ADDRFOUND) == ADDRFOUND) {
+#else
+							if ((visualgrid[se][0] & ADDRGOOD) == ADDRGOOD) {
+#endif
+								int opos = pos;
+								int owrap = wrap;
+								hb = 0;
+								for(int i=0; i<20 && hb != 4; i++) {
+										v = gb(buf, ts, pos, wrap);
+										if(v == 0xff)
+												hb = 1;
+										else if(hb == 1 && v == 0xd5)
+												hb = 2;
+										else if(hb == 2 && v == 0xaa)
+												hb = 3;
+										else if(hb == 3 && v == 0xad)
+												hb = 4;
+										else
+												hb = 0;
+								}
+								if((hb == 4)&&(dosver == 0)) {
+										visualgrid[se][0] |= DATAFOUND;
+										int sector_translate[16] = {
+#if SECTOR_ORDER == 0
+										// logical order (0-15)
+										0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+										0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
+#elif SECTOR_ORDER == 1
+										// DOS order (*.do)
+										0x00, 0x07, 0x0E, 0x06, 0x0D, 0x05, 0x0C, 0x04,
+										0x0B, 0x03, 0x0A, 0x02, 0x09, 0x01, 0x08, 0x0F
+#elif SECTOR_ORDER == 2
+										// prodos order (*.po)
+										0x00, 0x08, 0x01, 0x09, 0x02, 0x0A, 0x03, 0x0B,
+										0x04, 0x0C, 0x05, 0x0D, 0x06, 0x0E, 0x07, 0x0F
+#endif
+										};
+										UINT8 *dest = sectdata+(256)*sector_translate[se];
+										UINT8 data[0x157];
+										UINT32 dpost = 0;
+										UINT8 c = 0;
+										// first read in sector and decode to 6bit form
+										for(int i=0; i<0x156; i++) {
+												data[i] = gcr6bw_tb[gb(buf, ts, pos, wrap)] ^ c;
+												c = data[i];
+										//  printf("%02x ", c);
+										//  if (((i&0xf)+1)==0x10) printf("\n");
+										}
+										// read the checksum byte
+										data[0x156] = gcr6bw_tb[gb(buf,ts,pos,wrap)];
+										// now read the postamble bytes
+										for(int i=0; i<3; i++) {
+												dpost <<= 8;
+												dpost |= gb(buf, ts, pos, wrap);
+										}
+										// next combine in the upper 2 bits of each byte
+										UINT8 bit_swap[4] = { 0, 2, 1, 3 };
+										for(int i=0; i<0x56; i++)
+												data[i+0x056] = data[i+0x056]<<2 |  bit_swap[data[i]&3];
+										for(int i=0; i<0x56; i++)
+												data[i+0x0ac] = data[i+0x0ac]<<2 |  bit_swap[(data[i]>>2)&3];
+										for(int i=0; i<0x54; i++)
+												data[i+0x102] = data[i+0x102]<<2 |  bit_swap[(data[i]>>4)&3];
+										// now decode it into 256 bytes
+										// but only write it if the bitfield of the track shows datagood is NOT set.
+										// if it is set we don't want to overwrite a guaranteed good read with a bad one
+										// if past read had a bad checksum or bad postamble...
+#ifndef USE_OLD_BEST_SECTOR_PRIORITY
+										if (((visualgrid[se][0]&DATAGOOD)==0)||((visualgrid[se][0]&DATAPOST)==0)) {
+											// if the current read is good, and postamble is good, write it in, no matter what.
+											// if the current read is good and the current postamble is bad, write it in unless the postamble was good before
+											// if the current read is bad and the current postamble is good and the previous read had neither good, write it in
+											// if the current read isn't good and neither is the postamble but nothing better
+											// has been written before, write it anyway.
+											if ( ((data[0x156] == c) && (dpost&0xFFFF00)==0xDEAA00) ||
+											(((data[0x156] == c) && (dpost&0xFFFF00)!=0xDEAA00) && ((visualgrid[se][0]&DATAPOST)==0)) ||
+											(((data[0x156] != c) && (dpost&0xFFFF00)==0xDEAA00) && (((visualgrid[se][0]&DATAGOOD)==0)&&(visualgrid[se][0]&DATAPOST)==0)) ||
+											(((data[0x156] != c) && (dpost&0xFFFF00)!=0xDEAA00) && (((visualgrid[se][0]&DATAGOOD)==0)&&(visualgrid[se][0]&DATAPOST)==0))
+											) {
+												for(int i=0x56; i<0x156; i++) {
+													UINT8 dv = data[i];
+													*dest++ = dv;
+												}
+											}
+										}
+#else
+										if ((visualgrid[se][0]&DATAGOOD)==0) {
+												for(int i=0x56; i<0x156; i++) {
+													UINT8 dv = data[i];
+													*dest++ = dv;
+												}
+										}
+#endif
+										// do some checking
+										if ((data[0x156] != c) || (dpost&0xFFFF00)!=0xDEAA00)
+											fprintf(stderr,"Data Mark:\tChecksum xpctd %d found %d: %s, Postamble %03X: %s\n", data[0x156], c, (data[0x156]==c)?"OK":"BAD", dpost, (dpost&0xFFFF00)==0xDEAA00?"OK":"BAD");
+										if (data[0x156] == c) visualgrid[se][0] |= DATAGOOD;
+										if ((dpost&0xFFFF00)==0xDEAA00) visualgrid[se][0] |= DATAPOST;
+								} else if ((hb == 4)&&(dosver == 1)) {
+									fprintf(stderr,"ERROR: We don't handle dos sectors below 3.3 yet!\n");
+								} else {
+										pos = opos;
+										wrap = owrap;
+								}
+							}
+						}
+						hb = 0;
+				}
+				if(wrap)
+						break;
+		}
+		for(int i=0; i<nsect; i++) {
+				//if(nsect>0) printf("t%d,", track);
+				UINT8 *data = sectdata + (256)*i;
+				io_generic_write(io, data, pos_data, 256);
+				pos_data += 256;
+		}
+
+		// for the rest of the tracks
+		for(int track=2; track < 70; track+=2) {
+				UINT8 sectdata[(768)*6];
+				memset(sectdata, 0, sizeof(sectdata));
+				int nsect = 18;
+				UINT8 buf[130000]; // originally 13000, multiread dfi disks need larger
+				int ts;
+//fprintf(stderr,"DEBUG: a2_rwts18_format::save() about to generate bitstream from physical track %d (logical %d)...", track, track/2);
+				//~332 samples per cell, times 3+8+3 (14) for address mark, 24 for sync, 3+343+3 (349) for data mark, 24 for sync is around 743, near 776 expected
+				generate_bitstream_from_track(track, head, 200000000/((3004*nsect*6)/2), buf, ts, image); // 3104 needs tweaking
+//fprintf(stderr,"done.\n");
+				int pos = 0;
+				int wrap = 0;
+				int hb = 0;
+				for(;;) {
+						UINT8 v = gb(buf, ts, pos, wrap);
+						if(v == 0xff)
+								hb = 1;
+						else if(hb == 1 && v == 0xd5)
+								hb = 2;
+						else if(hb == 2 && v == 0x9d)
+								hb = 3;
+						else
+								hb = 0;
+
+						if(hb == 3) {
+								UINT8 h[11];
+								for(int i=0; i<7; i++)
+										h[i] = gb(buf, ts, pos, wrap);
+								UINT8 tr = gcr6bw_tb[h[0]];
+								UINT8 se = gcr6bw_tb[h[1]];
+								UINT8 chk = gcr6bw_tb[h[2]];
+								UINT32 post = (h[3]<<16)|(h[4]<<8)|h[5];
+								printf("RWTS18 AM:\t Track %d, Sector %2d, Checksum %02X: %s, Postamble %03X: %s\n", tr, se, chk, (chk ^ tr ^ se)==0?"OK":"BAD", post, post==0xAAFFFF?"OK":"BAD");
+								// sanity check
+								if (tr == track/2 && se < nsect) {
+								visualgrid[se][track/2] |= ADDRFOUND;
+								visualgrid[se][track/2] |= ((chk ^ tr ^ se)==0)?ADDRGOOD:0;
+#ifdef LENIENT_ADDR_CHECK
+//                                  if ((visualgrid[se][track/2] & ADDRFOUND) == ADDRFOUND) {
+#else
+									if ((visualgrid[se][track/2] & ADDRGOOD) == ADDRGOOD) {
+#endif
+										//int opos = pos;
+										//int owrap = wrap;
+										// RWTS18 doesn't have a true data mark, its part of the address header
+										// The next byte however is unique per title
+										v = gb(buf, ts, pos, wrap);
+										printf("Data mark header per-title byte = 0x%2x\n", v);
+
+										visualgrid[se][track/2] |= DATAFOUND;
+										//UINT8 *dest = sectdata+(768)*se;
+										UINT8 data[0x401];
+										UINT32 dpost = 0;
+										UINT8 c = 0;
+										// first read in the ENTIRE sector and decode to 6bit form
+										for(int i=0; i<0x400; i++) {
+												data[i] = gcr6bw_tb[gb(buf, ts, pos, wrap)] ^ c;
+												c = data[i];
+										  printf("%02x ", c);
+										  if (((i&0xf)+1)==0x10) printf("\n");
+										}
+										// read the checksum byte
+										data[0x400] = gcr6bw_tb[gb(buf,ts,pos,wrap)];
+										// now read the postamble byte
+										for(int i=0; i<1; i++) {
+												dpost <<= 8;
+												dpost |= gb(buf, ts, pos, wrap);
+										}
+										printf("Data Postamble was 0x%02x\n", dpost);
+										/*
+                                        // next combine in the upper 2 bits of each byte
+                                        UINT8 bit_swap[4] = { 0, 2, 1, 3 };
+                                        for(int i=0; i<0x56; i++)
+                                                data[i+0x056] = data[i+0x056]<<2 |  bit_swap[data[i]&3];
+                                        for(int i=0; i<0x56; i++)
+                                                data[i+0x0ac] = data[i+0x0ac]<<2 |  bit_swap[(data[i]>>2)&3];
+                                        for(int i=0; i<0x54; i++)
+                                                data[i+0x102] = data[i+0x102]<<2 |  bit_swap[(data[i]>>4)&3];
+                                        // now decode it into 256 bytes
+                                        // but only write it if the bitfield of the track shows datagood is NOT set.
+                                        // if it is set we don't want to overwrite a guaranteed good read with a bad one
+                                        // if past read had a bad checksum or bad postamble...
+#ifndef USE_OLD_BEST_SECTOR_PRIORITY
+                                        if (((visualgrid[se][track/2]&DATAGOOD)==0)||((visualgrid[se][track/2]&DATAPOST)==0)) {
+                                            // if the current read is good, and postamble is good, write it in, no matter what.
+                                            // if the current read is good and the current postamble is bad, write it in unless the postamble was good before
+                                            // if the current read is bad and the current postamble is good and the previous read had neither good, write it in
+                                            // if the current read isn't good and neither is the postamble but nothing better
+                                            // has been written before, write it anyway.
+                                            if ( ((data[0x156] == c) && (dpost&0xFFFF00)==0xDEAA00) ||
+                                            (((data[0x156] == c) && (dpost&0xFFFF00)!=0xDEAA00) && ((visualgrid[se][track/2]&DATAPOST)==0)) ||
+                                            (((data[0x156] != c) && (dpost&0xFFFF00)==0xDEAA00) && (((visualgrid[se][track/2]&DATAGOOD)==0)&&(visualgrid[se][track/2]&DATAPOST)==0)) ||
+                                            (((data[0x156] != c) && (dpost&0xFFFF00)!=0xDEAA00) && (((visualgrid[se][track/2]&DATAGOOD)==0)&&(visualgrid[se][track/2]&DATAPOST)==0))
+                                            ) {
+                                                for(int i=0x56; i<0x156; i++) {
+                                                    UINT8 dv = data[i];
+                                                    *dest++ = dv;
+                                                }
+                                            }
+                                        }
+#else
+                                        if ((visualgrid[se][track/2]&DATAGOOD)==0) {
+                                                for(int i=0x56; i<0x156; i++) {
+                                                    UINT8 dv = data[i];
+                                                    *dest++ = dv;
+                                                }
+                                        }
+#endif
+                                        // do some checking
+                                        if ((data[0x156] != c) || (dpost&0xFFFF00)!=0xDEAA00)
+                                            fprintf(stderr,"Data Mark:\tChecksum xpctd %d found %d: %s, Postamble %03X: %s\n", data[0x156], c, (data[0x156]==c)?"OK":"BAD", dpost, (dpost&0xFFFF00)==0xDEAA00?"OK":"BAD");
+                                        if (data[0x156] == c) visualgrid[se][track/2] |= DATAGOOD;
+                                        if ((dpost&0xFFFF00)==0xDEAA00) visualgrid[se][track/2] |= DATAPOST;
+                                        } else if ((hb == 4)&&(dosver == 1)) {
+                                            fprintf(stderr,"ERROR: We don't handle dos sectors below 3.3 yet!\n");
+                                        } else {
+                                                pos = opos;
+                                                wrap = owrap;
+                                        }*/
+									}
+								}
+								hb = 0;
+						}
+						if(wrap)
+								break;
+				}
+				for(int i=0; i<nsect; i++) {
+						//if(nsect>0) printf("t%d,", track);
+						UINT8 *data = sectdata + (256)*i;
+						io_generic_write(io, data, pos_data, 256);
+						pos_data += 256;
+				}
+				//printf("\n");
+		}
+		// display a little table of which sectors decoded ok
+		int total_good = 0;
+		for (int j = 0; j < 35; j++) {
+			printf("T%2d: ",j);
+			for (int i = 0; i < 16; i++) {
+				if (visualgrid[i][j] == NOTFOUND) printf("-NF- ");
+				else {
+				if (visualgrid[i][j] & ADDRFOUND) printf("a"); else printf(" ");
+				if (visualgrid[i][j] & ADDRGOOD) printf("A"); else printf(" ");
+				if (visualgrid[i][j] & DATAFOUND) printf("d"); else printf(" ");
+				if (visualgrid[i][j] & DATAGOOD) { printf("D"); total_good++; } else printf(" ");
+				if (visualgrid[i][j] & DATAPOST) printf("."); else printf(" ");
+				}
+			}
+			printf("\n");
+		}
+		printf("Total Good Sectors: %d\n", total_good);
+
+		return true;
+}
+
+const floppy_format_type FLOPPY_RWTS18_FORMAT = &floppy_image_format_creator<a2_rwts18_format>;
diff -Nru src-old/lib/formats/ap2_dsk.h src/lib/formats/ap2_dsk.h
--- src-old/lib/formats/ap2_dsk.h	2012-04-22 16:10:44.000000000 +0200
+++ src/lib/formats/ap2_dsk.h	2012-05-03 11:16:42.000000000 +0200
@@ -55,4 +55,27 @@
 
 extern const floppy_format_type FLOPPY_A216S_FORMAT;
 
+class a2_rwts18_format : public floppy_image_format_t
+{
+public:
+		a2_rwts18_format();
+
+		virtual int identify(io_generic *io, UINT32 form_factor);
+		virtual bool load(io_generic *io, UINT32 form_factor, floppy_image *image);
+		virtual bool save(io_generic *io, floppy_image *image);
+
+		virtual const char *name() const;
+		virtual const char *description() const;
+		virtual const char *extensions() const;
+		virtual bool supports_save() const;
+
+private:
+		static const desc_e mac_gcr[];
+
+		UINT8 gb(const UINT8 *buf, int ts, int &pos, int &wrap);
+		void update_chk(const UINT8 *data, int size, UINT32 &chk);
+};
+
+extern const floppy_format_type FLOPPY_RWTS18_FORMAT;
+
 #endif /* AP2_DISK_H */
diff -Nru src-old/lib/formats/apridisk.c src/lib/formats/apridisk.c
--- src-old/lib/formats/apridisk.c	2011-07-20 11:35:15.000000000 +0200
+++ src/lib/formats/apridisk.c	2012-05-03 11:16:42.000000000 +0200
@@ -125,7 +125,7 @@
 	floppy_image_read(floppy, &header, 0, sizeof(header));
 
 	/* look for the magic string */
-	if (memcmp(header, apr_magic, sizeof(apr_magic)) == 0)
+	if (memcmp(header, apr_magic, sizeof(*apr_magic)) == 0)
 		*vote = 100;
 	else
 		*vote = 0;
diff -Nru src-old/lib/formats/coco_dsk.c src/lib/formats/coco_dsk.c
--- src-old/lib/formats/coco_dsk.c	2011-08-23 06:59:11.000000000 +0200
+++ src/lib/formats/coco_dsk.c	2012-05-03 11:16:42.000000000 +0200
@@ -914,7 +914,7 @@
 			else
 			{
 				/* check IDAM integrity and check for matching sector */
-				if ((sector == dmk_idam_sector(&track_data[idam_offset]))
+				if (sector == dmk_idam_sector(&track_data[idam_offset])
 /*                  && (track == dmk_idam_track(&track_data[idam_offset]))  */
 /*                  && (head == dmk_idam_side(&track_data[idam_offset]))    */
 					)
diff -Nru src-old/lib/formats/dfi_dsk.c src/lib/formats/dfi_dsk.c
--- src-old/lib/formats/dfi_dsk.c	2012-04-20 11:59:23.000000000 +0200
+++ src/lib/formats/dfi_dsk.c	2012-05-07 08:57:50.000000000 +0200
@@ -31,10 +31,35 @@
 
 ****************************************************************************/
 
+/* DONE:
+ * Support auto-identification heuristics for determining disk image speed,
+   capture clock rate, and number of multireads per image.
+ * TODO:
+ * Scale captured data based on the guessed clock rate and samplerate to match
+   the internal 200mhz representation
+ * Handle 0xFF bytes properly
+ * Correctly note exact index timing.
+ */
+
 #include "emu.h"
 #include "dfi_dsk.h"
 #include <zlib.h>
-#define NUMBER_OF_MULTIREADS 1
+#define NUMBER_OF_MULTIREADS 3
+// threshholds for brickwall windowing
+//define MIN_CLOCKS 65
+// number_please apple2 wants 40 min
+#define MIN_CLOCKS 60
+//define MAX_CLOCKS 260
+#define MAX_CLOCKS 270
+#define MIN_THRESH (MIN_CLOCKS*(clock_rate/25000000))
+#define MAX_THRESH (MAX_CLOCKS*(clock_rate/25000000))
+// constants to help guess clockrate and rpm
+// constant is 25mhz / 6 revolutions per second (360rpm) = 4166667 +- 2.5%
+#define REV25_MIN 4062500
+#define REV25_MAX 4270833
+// define the following to show a histogram per track
+//define TRACK_HISTOGRAM 1
+#undef TRACK_HISTOGRAM
 
 dfi_format::dfi_format() : floppy_image_format_t()
 {
@@ -64,6 +89,8 @@
 {
 	char sign[4];
 	io_generic_read(io, sign, 0, 4);
+	if (memcmp(sign, "DFER", 4)==0)
+		fatalerror("Old type Discferret image detected; the mess Discferret decoder will not handle this properly, bailing out!\n");
 	return memcmp(sign, "DFE2", 4) ? 0 : 100;
 }
 
@@ -72,8 +99,10 @@
 	int size = io_generic_size(io);
 	int pos = 4;
 	UINT8 *data = 0;
-	int data_size = 0;
-
+	int data_size = 0; // size of currently allocated array for a track
+	int onerev_time = 0; // time for one revolution, used to guess clock and rpm for DFE2 files
+	unsigned long clock_rate = 100000000; // sample clock rate in megahertz
+	int rpm=360; // drive rpm
 	while(pos < size) {
 		UINT8 h[10];
 		io_generic_read(io, h, pos, 10);
@@ -82,12 +111,15 @@
 		// Ignore sector
 		UINT32 tsize = (h[6] << 24) | (h[7] << 16) | (h[8] << 8) | h[9];
 
+		// if the position-so-far-in-file plus 10 (for the header) plus track size
+		// is larger than the size of the file, free buffers and bail out
 		if(pos+tsize+10 > size) {
 			if(data)
 				global_free(data);
 			return false;
 		}
 
+		// reallocate the data array if it gets too small
 		if(tsize > data_size) {
 			if(data)
 				global_free(data);
@@ -95,28 +127,62 @@
 			data = global_alloc_array(UINT8, data_size);
 		}
 
-		io_generic_read(io, data, pos+16, tsize);
-		pos += tsize+10;
-		tsize--; // Drop the extra 0x00 at the end
-
-		int index_time = 0;
-		int index_count = 0;
-		int total_time = 0;
+		pos += 10; // skip the header, we already read it
+		io_generic_read(io, data, pos, tsize);
+		pos += tsize; // for next time we read, increment to the beginning of next header
+
+		int index_time = 0; // what point the last index happened
+		int index_count = 0; // number of index pulses per track
+		//int index_polarity = 1; // current polarity of index, starts high
+		int total_time = 0; // total sampled time per track
 		for(int i=0; i<tsize; i++) {
 			UINT8 v = data[i];
+			if (v == 0xFF) { fprintf(stderr,"DFI stream contained a 0xFF at t%d, position%d, THIS SHOULD NEVER HAPPEN! Bailing out!\n", track, i); exit(1); }
 			if((v & 0x7f) == 0x7f)
 				total_time += 0x7f;
-			else {
+			else if(v & 0x80) {
+				total_time += v & 0x7f;
+				index_time = total_time;
+				//index_polarity ^= 1;
+				//fprintf(stderr,"index state changed to %d at time=%d\n", index_polarity, total_time);
+				//fprintf(stderr,"index rising edge seen at time=%d\n", total_time);
+				if (onerev_time == 0) onerev_time = total_time;
+				index_count += 1;//index_polarity;
+			} else // (v & 0x80) == 0
 				total_time += v & 0x7f;
-				if((v & 0x80) && (index_count<NUMBER_OF_MULTIREADS)) {
-					index_time = total_time;///NUMBER_OF_MULTIREADS;
-					index_count++;
-				}
-			}
 		}
 
+		// its possible on single read images for there to be no index pulse during the image at all!
+		if (onerev_time == 0) onerev_time = total_time;
+
 		if(!track && !head)
 			fprintf(stderr, "%02d:%d tt=%10d it=%10d\n", track, head, total_time, index_time);
+		if(!track && !head) {
+			fprintf(stderr, "index_count: %d, onerev_time: %d\n", index_count, onerev_time);
+			if ((onerev_time > REV25_MIN) && (onerev_time < REV25_MAX)) {
+				fprintf(stderr, "Guess: speed: 360rpm, clock 25MHz\n");
+				clock_rate = 25000000; rpm = 360;
+			} else if ((onerev_time > REV25_MIN*1.2) && (onerev_time < REV25_MAX*1.2)) {
+				fprintf(stderr, "Guess: speed: 300rpm, clock 25MHz\n");
+				clock_rate = 25000000; rpm = 300;
+			} else if ((onerev_time > REV25_MIN*2) && (onerev_time < REV25_MAX*2)) {
+				fprintf(stderr, "Guess: speed: 360rpm, clock 50MHz\n");
+				clock_rate = 50000000; rpm = 360;
+			} else if ((onerev_time > (REV25_MIN*2)*1.2) && (onerev_time < (REV25_MAX*2)*1.2)) {
+				fprintf(stderr, "Guess: speed: 300rpm, clock 50MHz\n");
+				clock_rate = 50000000; rpm = 300;
+			} else if ((onerev_time > REV25_MIN*4) && (onerev_time < REV25_MAX*4)) {
+				fprintf(stderr, "Guess: speed: 360rpm, clock 100MHz\n");
+				clock_rate = 100000000; rpm = 360;
+			} else if ((onerev_time > (REV25_MIN*4)*1.2) && (onerev_time < (REV25_MAX*4)*1.2)) {
+				fprintf(stderr, "Guess: speed: 300rpm, clock 100MHz\n");
+				clock_rate = 100000000; rpm = 300;
+			} else
+				fprintf(stderr, "WARNING: Cannot Guess Speed! Assuming 360rpm, 100Mhz clock!\n");
+			fprintf(stderr,"Actual rpm based on index: %f\n", ((double)clock_rate/(double)onerev_time)*60);
+		}
+
+        rpm += 0;   // HACK: prevent GCC 4.6+ from warning "variable set but unused"
 
 		if(!index_time)
 			index_time = total_time;
@@ -124,26 +190,72 @@
 		image->set_track_size(track, head, tsize);
 
 		int cur_time = 0;
+		int prev_time = 0;
+#ifdef TRACK_HISTOGRAM
+		// histogram
+		int time_buckets[4096];
+		for (int i = 0; i < 4096; i++)
+			time_buckets[i] = 0;
+#endif
 		index_count = 0;
-		int index_polarity = 0;
+		//index_polarity = 0;
 		UINT32 mg = floppy_image::MG_A;
 		UINT32 *buf = image->get_buffer(track, head);
 		int tpos = 0;
 		buf[tpos++] = mg;
 		for(int i=0; i<tsize; i++) {
 			UINT8 v = data[i];
-			if((v & 0x7f) == 0x7f) // 0x7F or 0xFF: no transition, but a carry
+			if((v & 0x7f) == 0x7f) // 0x7F : no transition, but a carry (FF is a board-on-fire error and is checked for above)
 				cur_time += 0x7f;
+			else if(v & 0x80) { // 0x80 set, note the index (TODO: actually do this!) and add number to count
+				cur_time += v & 0x7f;
+				//index_polarity ^= 1;
+				index_count += 1;//index_polarity;
+				//if (index_count == NUMBER_OF_MULTIREADS) break;
+				}
 			else if((v & 0x80) == 0) { // 0x00-0x7E: not an index or carry, add the number and store transition
 				cur_time += v & 0x7f;
-				mg = mg == floppy_image::MG_A ? floppy_image::MG_B : floppy_image::MG_A;
-				buf[tpos++] = mg | UINT32(200000000ULL*cur_time/index_time);
-			} else if(v & 0x80) { // 0x80-0xFF an index, note the index (TODO: actually do this!) and do not add number
-				index_polarity ^= 1;
-				index_count += index_polarity;
-				if (index_count == NUMBER_OF_MULTIREADS) break;
+				int trans_time = cur_time - prev_time;
+#ifdef TRACK_HISTOGRAM
+				time_buckets[(trans_time<4096)?trans_time:4095]++;
+#endif
+				// cur_time and onerev_time need to be converted to something standard, so we'll stick with 300rpm at the standard 200mhz rate that mfi uses internally
+				// TODO for 4/22/2012: ACTUALLY DO THIS RESCALING STEP
+				// filter out spurious crap
+				//if (trans_time <= MIN_THRESH) fprintf(stderr, "DFI: Throwing out short transition of length %d\n", trans_time);
+				// the normal case: write the transition at the appropriate time
+				if ((prev_time == 0) || ((trans_time > MIN_THRESH) && (trans_time <= MAX_THRESH))) {
+					mg = mg == floppy_image::MG_A ? floppy_image::MG_B : floppy_image::MG_A;
+					buf[tpos++] = mg | UINT32((200000000ULL*cur_time)/index_time);
+					prev_time = cur_time;
+				}
+				// the long case: we probably missed a transition, stuff an extra guessed one in there to see if it helps
+				if (trans_time > MAX_THRESH) {
+					mg = mg == floppy_image::MG_A ? floppy_image::MG_B : floppy_image::MG_A;
+					if (((track%2)==0)&&(head==0)) fprintf(stderr,"missed transition, total time for transition is %d\n",trans_time);
+#ifndef FAKETRANS_ONE
+					buf[tpos++] = mg | UINT32((200000000ULL*(cur_time-(trans_time/2)))/index_time); // generate imaginary transition at half period
+#else
+					buf[tpos++] = mg | UINT32((200000000ULL*(cur_time-((trans_time*2)/3)))/index_time);
+					mg = mg == floppy_image::MG_A ? floppy_image::MG_B : floppy_image::MG_A;
+					buf[tpos++] = mg | UINT32((200000000ULL*(cur_time-(trans_time/3)))/index_time);
+#endif
+					mg = mg == floppy_image::MG_A ? floppy_image::MG_B : floppy_image::MG_A;
+					buf[tpos++] = mg | UINT32(200000000ULL*cur_time/index_time); // generate transition now
+					prev_time = cur_time;
+					}
 			}
 		}
+#ifdef TRACK_HISTOGRAM
+		if (((track%2)==0)&&(head==0)) {
+			for (int i = 0; i < 4096; i++) {
+				fprintf(stderr,"%4d:%4d ", i, time_buckets[i]);
+				if (((i+1)%10)==0) fprintf(stderr,"\n");
+			}
+		}
+		fprintf(stderr,"\n");
+#endif
+		index_count = 0;
 		image->set_track_size(track, head, tpos);
 	}
 
diff -Nru src-old/lib/formats/flopimg.c src/lib/formats/flopimg.c
--- src-old/lib/formats/flopimg.c	2012-01-29 18:34:26.000000000 +0100
+++ src/lib/formats/flopimg.c	2012-04-24 13:58:27.000000000 +0200
@@ -1162,7 +1162,7 @@
 {
 	UINT32 r = 0;
 	for(int i=0; i<count; i++)
-		r = (r << 1) | bit_r(buffer, offset+i);
+		r = (r << 1) | (UINT32) bit_r(buffer, offset+i);
 	return r;
 }
 
diff -Nru src-old/lib/formats/ioprocs.c src/lib/formats/ioprocs.c
--- src-old/lib/formats/ioprocs.c	2011-05-06 21:42:26.000000000 +0200
+++ src/lib/formats/ioprocs.c	2012-05-03 11:16:42.000000000 +0200
@@ -106,11 +106,6 @@
 	size_t bytes_to_write;
 	UINT64 size;
 
-	if (offset > 0x29c50)
-	{
-		offset = offset;
-	}
-
 	size = io_generic_size(generic);
 
 	if (size < offset)
diff -Nru src-old/lib/formats/pasti_dsk.c src/lib/formats/pasti_dsk.c
--- src-old/lib/formats/pasti_dsk.c	2011-12-30 10:56:30.000000000 +0100
+++ src/lib/formats/pasti_dsk.c	2012-04-24 13:58:27.000000000 +0200
@@ -535,7 +535,7 @@
 			int hpos = (i+3) % tsize;
 			int j;
 			bool synced = false;
-			int bcount, tend;
+			int bcount=0, tend=0;
 			int best_bcount=0, best_j=0;
 			for(j=0; j != obs.sector_count; j++) {
 				match_mfm_data(obs, hpos, obs.sectors[j].id, 6, hbyte, bcount, tend, synced);
diff -Nru src-old/lib/lib.mak src/lib/lib.mak
--- src-old/lib/lib.mak	2012-04-16 16:20:10.000000000 +0200
+++ src/lib/lib.mak	2012-04-30 08:44:14.000000000 +0200
@@ -21,7 +21,6 @@
 	$(LIBOBJ)/softfloat \
 	$(LIBOBJ)/libjpeg \
 	$(LIBOBJ)/libflac \
-	$(LIBOBJ)/libflacpp \
 	$(LIBOBJ)/lib7z \
 
 
@@ -302,7 +301,7 @@
 ARCHFLAGS = -DWORDS_BIGENDIAN=0
 endif   # ifeq ($(TARGETOS),macosx)
 
-FLACOPTS=-DFLAC__NO_ASM -DHAVE_INTTYPES_H -DHAVE_ICONV -DHAVE_LANGINFO_CODESET -DHAVE_SOCKLEN_T -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 $(ARCHFLAGS)
+FLACOPTS=-DFLAC__NO_ASM -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -DHAVE_CONFIG_H=0 -DFLAC__HAS_OGG=0 -Wno-unused-function $(ARCHFLAGS)
 
 LIBFLACOBJS = \
 	$(LIBOBJ)/libflac/bitmath.o \
@@ -325,7 +324,7 @@
 
 $(LIBOBJ)/libflac/%.o: $(LIBSRC)/libflac/libflac/%.c | $(OSPREBUILD)
 	@echo Compiling $<...
-	$(CC) $(CDEFS) $(FLACOPTS) $(CONLYFLAGS) -I$(LIBSRC)/libflac/include -c $< -o $@
+	$(CC) $(CDEFS) $(CONLYFLAGS) $(CCOMFLAGS) $(FLACOPTS) -I$(LIBSRC)/libflac/include -c $< -o $@
 
 
 
@@ -359,4 +358,4 @@
 
 $(LIBOBJ)/lib7z/%.o: $(LIBSRC)/lib7z/%.c | $(OSPREBUILD)
 	@echo Compiling $<...
-	$(CC) $(CDEFS) $(7ZOPTS) $(CONLYFLAGS) -I$(LIBSRC)/lib7z/ -c $< -o $@
+	$(CC) $(CDEFS) $(7ZOPTS) $(CCOMFLAGS) $(CONLYFLAGS) -I$(LIBSRC)/lib7z/ -c $< -o $@
diff -Nru src-old/lib/lib7z/CpuArch.h src/lib/lib7z/CpuArch.h
--- src-old/lib/lib7z/CpuArch.h	2012-02-29 11:13:22.000000000 +0100
+++ src/lib/lib7z/CpuArch.h	2012-04-30 08:44:14.000000000 +0200
@@ -97,7 +97,7 @@
 
 #endif
 
-#if defined(MY_CPU_LE_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)
+#if defined(MY_CPU_LE_UNALIGN) && defined(_WIN64) && (defined(_MSC_VER) && (_MSC_VER >= 1300))
 #include <stdlib.h>
 
 #pragma intrinsic(_byteswap_ulong)
diff -Nru src-old/lib/lib7z/LzmaEnc.c src/lib/lib7z/LzmaEnc.c
--- src-old/lib/lib7z/LzmaEnc.c	2012-02-19 17:23:23.000000000 +0100
+++ src/lib/lib7z/LzmaEnc.c	2012-05-03 11:16:42.000000000 +0200
@@ -1905,11 +1905,13 @@
 static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
 {
   UInt32 beforeSize = kNumOpts;
+  #ifndef _7ZIP_ST
   Bool btMode;
+  #endif
   if (!RangeEnc_Alloc(&p->rc, alloc))
     return SZ_ERROR_MEM;
-  btMode = (p->matchFinderBase.btMode != 0);
   #ifndef _7ZIP_ST
+  btMode = (p->matchFinderBase.btMode != 0);
   p->mtMode = (p->multiThread && !p->fastMode && btMode);
   #endif
 
@@ -2085,8 +2087,6 @@
   CLzmaEnc *p = (CLzmaEnc *)pp;
   if (p->mtMode)
     MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-  #else
-  pp = pp;
   #endif
 }
 
diff -Nru src-old/lib/libflac/include/private/cpu.h src/lib/libflac/include/private/cpu.h
--- src-old/lib/libflac/include/private/cpu.h	2012-01-22 20:38:22.000000000 +0100
+++ src/lib/libflac/include/private/cpu.h	2012-04-30 08:44:14.000000000 +0200
@@ -34,7 +34,7 @@
 
 #include "flac/ordinals.h"
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/include/private/fixed.h src/lib/libflac/include/private/fixed.h
--- src-old/lib/libflac/include/private/fixed.h	2012-01-29 18:34:26.000000000 +0100
+++ src/lib/libflac/include/private/fixed.h	2012-04-30 08:44:14.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef FLAC__PRIVATE__FIXED_H
 #define FLAC__PRIVATE__FIXED_H
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/include/private/float.h src/lib/libflac/include/private/float.h
--- src-old/lib/libflac/include/private/float.h	2012-01-29 18:34:26.000000000 +0100
+++ src/lib/libflac/include/private/float.h	2012-04-30 08:44:14.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef FLAC__PRIVATE__FLOAT_H
 #define FLAC__PRIVATE__FLOAT_H
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/include/private/lpc.h src/lib/libflac/include/private/lpc.h
--- src-old/lib/libflac/include/private/lpc.h	2012-01-29 18:34:26.000000000 +0100
+++ src/lib/libflac/include/private/lpc.h	2012-04-30 08:44:14.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef FLAC__PRIVATE__LPC_H
 #define FLAC__PRIVATE__LPC_H
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/include/private/memory.h src/lib/libflac/include/private/memory.h
--- src-old/lib/libflac/include/private/memory.h	2012-01-22 20:38:22.000000000 +0100
+++ src/lib/libflac/include/private/memory.h	2012-04-30 08:44:14.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef FLAC__PRIVATE__MEMORY_H
 #define FLAC__PRIVATE__MEMORY_H
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/include/private/window.h src/lib/libflac/include/private/window.h
--- src-old/lib/libflac/include/private/window.h	2012-01-29 18:34:26.000000000 +0100
+++ src/lib/libflac/include/private/window.h	2012-04-30 08:44:14.000000000 +0200
@@ -32,7 +32,7 @@
 #ifndef FLAC__PRIVATE__WINDOW_H
 #define FLAC__PRIVATE__WINDOW_H
 
-#ifdef HAVE_CONFIG_H
+#if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
diff -Nru src-old/lib/libflac/libflac/lpc.c src/lib/libflac/libflac/lpc.c
--- src-old/lib/libflac/libflac/lpc.c	2012-03-04 17:25:10.000000000 +0100
+++ src/lib/libflac/libflac/lpc.c	2012-04-30 08:44:14.000000000 +0200
@@ -112,7 +112,7 @@
 void FLAC__lpc_compute_lp_coefficients(const FLAC__real autoc[], unsigned *max_order, FLAC__real lp_coeff[][FLAC__MAX_LPC_ORDER], FLAC__double error[])
 {
 	unsigned i, j;
-	FLAC__double r, err, ref[FLAC__MAX_LPC_ORDER], lpc[FLAC__MAX_LPC_ORDER];
+	FLAC__double r, err, /*ref[FLAC__MAX_LPC_ORDER],*/ lpc[FLAC__MAX_LPC_ORDER];
 
 	FLAC__ASSERT(0 != max_order);
 	FLAC__ASSERT(0 < *max_order);
@@ -126,7 +126,7 @@
 		r = -autoc[i+1];
 		for(j = 0; j < i; j++)
 			r -= lpc[j] * autoc[i-j];
-		ref[i] = (r/=err);
+		//ref[i] = (r/=err);
 
 		/* Update LPC coefficients and total error. */
 		lpc[i]=r;
diff -Nru src-old/lib/libflac/libflac/md5.c src/lib/libflac/libflac/md5.c
--- src-old/lib/libflac/libflac/md5.c	2012-03-04 17:25:10.000000000 +0100
+++ src/lib/libflac/libflac/md5.c	2012-05-03 11:16:42.000000000 +0200
@@ -263,7 +263,7 @@
 
 	byteSwap(ctx->buf, 4);
 	memcpy(digest, ctx->buf, 16);
-	memset(ctx, 0, sizeof(ctx));	/* In case it's sensitive */
+	memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
 	if(0 != ctx->internal_buf) {
 		free(ctx->internal_buf);
 		ctx->internal_buf = 0;
diff -Nru src-old/lib/libflac/libflac/memory.c src/lib/libflac/libflac/memory.c
--- src-old/lib/libflac/libflac/memory.c	2012-03-04 17:25:10.000000000 +0100
+++ src/lib/libflac/libflac/memory.c	2012-05-07 08:57:50.000000000 +0200
@@ -84,8 +84,8 @@
 	FLAC__ASSERT(0 != aligned_pointer);
 	FLAC__ASSERT(unaligned_pointer != aligned_pointer);
 
-	if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
-		return false;
+//  if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
+//      return false;
 
 	pu = (FLAC__int32*)FLAC__memory_alloc_aligned(sizeof(*pu) * (size_t)elements, &u.pv);
 	if(0 == pu) {
@@ -113,8 +113,8 @@
 	FLAC__ASSERT(0 != aligned_pointer);
 	FLAC__ASSERT(unaligned_pointer != aligned_pointer);
 
-	if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
-		return false;
+//  if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
+//      return false;
 
 	pu = (FLAC__uint32*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
 	if(0 == pu) {
@@ -142,8 +142,8 @@
 	FLAC__ASSERT(0 != aligned_pointer);
 	FLAC__ASSERT(unaligned_pointer != aligned_pointer);
 
-	if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
-		return false;
+//  if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
+//      return false;
 
 	pu = (FLAC__uint64*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
 	if(0 == pu) {
@@ -171,8 +171,8 @@
 	FLAC__ASSERT(0 != aligned_pointer);
 	FLAC__ASSERT(unaligned_pointer != aligned_pointer);
 
-	if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
-		return false;
+//  if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
+//      return false;
 
 	pu = (unsigned*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
 	if(0 == pu) {
@@ -202,8 +202,8 @@
 	FLAC__ASSERT(0 != aligned_pointer);
 	FLAC__ASSERT(unaligned_pointer != aligned_pointer);
 
-	if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
-		return false;
+//  if((size_t)elements > SIZE_MAX / sizeof(*pu)) /* overflow check */
+//      return false;
 
 	pu = (FLAC__real*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
 	if(0 == pu) {
diff -Nru src-old/lib/libflac/libflac/stream_decoder.c src/lib/libflac/libflac/stream_decoder.c
--- src-old/lib/libflac/libflac/stream_decoder.c	2012-03-04 17:25:10.000000000 +0100
+++ src/lib/libflac/libflac/stream_decoder.c	2012-05-03 17:28:54.000000000 +0200
@@ -39,11 +39,15 @@
 #include <sys/stat.h> /* for stat() */
 #include <sys/types.h> /* for off_t */
 #if defined _MSC_VER || defined __BORLANDC__ || defined __MINGW32__
-#if _MSC_VER <= 1600 || defined __BORLANDC__ /* @@@ [2G limit] */
+#if (!defined(_MSC_VER) || _MSC_VER <= 1600) || defined __BORLANDC__ /* @@@ [2G limit] */
+#ifndef fseeko
 #define fseeko fseek
+#endif
+#ifndef ftello
 #define ftello ftell
 #endif
 #endif
+#endif
 #include "flac/assert.h"
 #include "share/alloc.h"
 #include "protected/stream_decoder.h"
@@ -1460,6 +1464,7 @@
 		block.is_last = is_last;
 		block.type = (FLAC__MetadataType)type;
 		block.length = length;
+		memset(&block.data, 0, sizeof(block.data));
 
 		if(type == FLAC__METADATA_TYPE_APPLICATION) {
 			if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.application.id, FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8))
diff -Nru src-old/lib/libflac/libflac/stream_encoder.c src/lib/libflac/libflac/stream_encoder.c
--- src-old/lib/libflac/libflac/stream_encoder.c	2012-03-04 17:25:10.000000000 +0100
+++ src/lib/libflac/libflac/stream_encoder.c	2012-04-30 08:44:14.000000000 +0200
@@ -39,11 +39,15 @@
 #include <string.h> /* for memcpy() */
 #include <sys/types.h> /* for off_t */
 #if defined _MSC_VER || defined __BORLANDC__ || defined __MINGW32__
-#if _MSC_VER <= 1600 || defined __BORLANDC__ /* @@@ [2G limit] */
+#if (!defined(_MSC_VER) || _MSC_VER <= 1600) || defined __BORLANDC__ /* @@@ [2G limit] */
+#ifndef fseeko
 #define fseeko fseek
+#endif
+#ifndef ftello
 #define ftello ftell
 #endif
 #endif
+#endif
 #include "flac/assert.h"
 #include "flac/stream_decoder.h"
 #include "share/alloc.h"
diff -Nru src-old/lib/util/avhuff.c src/lib/util/avhuff.c
--- src-old/lib/util/avhuff.c	2012-02-20 09:26:05.000000000 +0100
+++ src/lib/util/avhuff.c	2012-05-07 08:37:39.000000000 +0200
@@ -675,7 +675,9 @@
 	if (complength < 10 + 2 * channels)
 		return AVHERR_INVALID_DATA;
 	UINT32 totalsize = 10 + 2 * channels;
-	totalsize += (source[8] << 8) | source[9];
+	UINT32 treesize = (source[8] << 8) | source[9];
+	if (treesize != 0xffff)
+		totalsize += treesize;
 	for (int chnum = 0; chnum < channels; chnum++)
 		totalsize += (source[10 + 2 * chnum] << 8) | source[11 + 2 * chnum];
 	if (totalsize >= complength)
diff -Nru src-old/lib/util/cdrom.c src/lib/util/cdrom.c
--- src-old/lib/util/cdrom.c	2012-04-08 16:12:02.000000000 +0200
+++ src/lib/util/cdrom.c	2012-04-30 08:44:14.000000000 +0200
@@ -146,6 +146,7 @@
 	if (err != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error reading input file: %s\n", chd_file::error_string(err));
+		delete file;
 		return NULL;
 	}
 
@@ -160,6 +161,7 @@
 		if (filerr != FILERR_NONE)
 		{
 			fprintf(stderr, "Unable to open file: %s\n", file->track_info.track[i].fname.cstr());
+			cdrom_close(file);
 			return NULL;
 		}
 	}
@@ -215,7 +217,7 @@
 		return NULL;
 
 	/* allocate memory for the CD-ROM file */
-	file = (cdrom_file *)malloc(sizeof(cdrom_file));
+	file = new cdrom_file();
 	if (file == NULL)
 		return NULL;
 
@@ -226,7 +228,7 @@
 	err = cdrom_parse_metadata(chd, &file->cdtoc);
 	if (err != CHDERR_NONE)
 	{
-		delete(file);
+		delete file;
 		return NULL;
 	}
 
@@ -281,7 +283,7 @@
 		}
 	}
 
-	delete(file);
+	delete file;
 }
 
 
diff -Nru src-old/lib/util/coretmpl.h src/lib/util/coretmpl.h
--- src-old/lib/util/coretmpl.h	2012-02-19 17:23:23.000000000 +0100
+++ src/lib/util/coretmpl.h	2012-04-26 10:36:24.000000000 +0200
@@ -68,8 +68,8 @@
 	// operators
 	operator _ElementType *() { return &m_array[0]; }
 	operator const _ElementType *() const { return &m_array[0]; }
-	_ElementType operator[](int index) const { assert(index < m_count); return m_array[index]; }
 	_ElementType &operator[](int index) { assert(index < m_count); return m_array[index]; }
+	const _ElementType &operator[](int index) const { assert(index < m_count); return m_array[index]; }
 
 	// simple getters
 	int count() const { return m_count; }
diff -Nru src-old/lib/util/un7z.c src/lib/util/un7z.c
--- src-old/lib/util/un7z.c	2012-02-19 17:23:23.000000000 +0100
+++ src/lib/util/un7z.c	2012-05-03 11:16:42.000000000 +0200
@@ -52,7 +52,6 @@
 
 void *SZipAlloc(void *p, size_t size)
 {
-	p = p;
 	if (size == 0)
 		return 0;
 
@@ -61,7 +60,6 @@
 
 void SZipFree(void *p, void *address)
 {
-	p = p;
 	free(address);
 }
 
diff -Nru src-old/mame/audio/8080bw.c src/mame/audio/8080bw.c
--- src-old/mame/audio/8080bw.c	2012-04-11 09:56:42.000000000 +0200
+++ src/mame/audio/8080bw.c	2012-05-03 11:00:08.000000000 +0200
@@ -865,7 +865,7 @@
 	m_schaser_background_disable = (data >> 3) & 0x01;
 	m_schaser_background_select = (data >> 4) & 0x01;
 
-	m_c8080bw_flip_screen = (data & 0x20) && (input_port_read(machine(), CABINET_PORT_TAG) & 0x01);
+	m_c8080bw_flip_screen = (data & 0x20) && (ioport(CABINET_PORT_TAG)->read() & 0x01);
 
 	m_port_2_last_extra = data;
 }
@@ -1032,7 +1032,7 @@
 
 	m_color_map = data & 0x40;
 
-	m_c8080bw_flip_screen = (data & 0x20) && (input_port_read(machine(), "IN2") & 0x04);
+	m_c8080bw_flip_screen = (data & 0x20) && (ioport("IN2")->read() & 0x04);
 
 	m_port_2_last_extra = data;
 }
diff -Nru src-old/mame/audio/atarijsa.c src/mame/audio/atarijsa.c
--- src-old/mame/audio/atarijsa.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/audio/atarijsa.c	2012-05-03 11:00:08.000000000 +0200
@@ -227,8 +227,8 @@
                 0x02 = coin 2
                 0x01 = coin 1
             */
-			result = input_port_read(space->machine(), "JSAI");
-			if (!(input_port_read(space->machine(), test_port) & test_mask)) result ^= 0x80;
+			result = space->machine().root_device().ioport("JSAI")->read();
+			if (!(space->machine().root_device().ioport(test_port)->read() & test_mask)) result ^= 0x80;
 			if (atarigen->m_cpu_to_sound_ready) result ^= 0x40;
 			if (atarigen->m_sound_to_cpu_ready) result ^= 0x20;
 			if ((tms5220 != NULL) && (tms5220_readyq_r(tms5220) == 0))
@@ -360,8 +360,8 @@
                 0x02 = coin 2
                 0x01 = coin 1
             */
-			result = input_port_read(space->machine(), "JSAII");
-			if (!(input_port_read(space->machine(), test_port) & test_mask)) result ^= 0x80;
+			result = space->machine().root_device().ioport("JSAII")->read();
+			if (!(space->machine().root_device().ioport(test_port)->read() & test_mask)) result ^= 0x80;
 			if (atarigen->m_cpu_to_sound_ready) result ^= 0x40;
 			if (atarigen->m_sound_to_cpu_ready) result ^= 0x20;
 			break;
@@ -483,8 +483,8 @@
                 0x02 = coin L (active high)
                 0x01 = coin R (active high)
             */
-			result = input_port_read(space->machine(), "JSAIII");
-			if (!(input_port_read(space->machine(), test_port) & test_mask)) result ^= 0x90;
+			result = space->machine().root_device().ioport("JSAIII")->read();
+			if (!(space->machine().root_device().ioport(test_port)->read() & test_mask)) result ^= 0x90;
 			if (atarigen->m_cpu_to_sound_ready) result ^= 0x40;
 			if (atarigen->m_sound_to_cpu_ready) result ^= 0x20;
 			break;
@@ -617,8 +617,8 @@
                 0x02 = coin L (active high)
                 0x01 = coin R (active high)
             */
-			result = input_port_read(space->machine(), "JSAIII");
-			if (!(input_port_read(space->machine(), test_port) & test_mask)) result ^= 0x90;
+			result = space->machine().root_device().ioport("JSAIII")->read();
+			if (!(space->machine().root_device().ioport(test_port)->read() & test_mask)) result ^= 0x90;
 			if (atarigen->m_cpu_to_sound_ready) result ^= 0x40;
 			if (atarigen->m_sound_to_cpu_ready) result ^= 0x20;
 			break;
diff -Nru src-old/mame/audio/cchasm.c src/mame/audio/cchasm.c
--- src-old/mame/audio/cchasm.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/audio/cchasm.c	2012-05-03 11:00:08.000000000 +0200
@@ -32,7 +32,7 @@
 
 READ8_MEMBER(cchasm_state::cchasm_coin_sound_r)
 {
-	UINT8 coin = (input_port_read(machine(), "IN3") >> 4) & 0x7;
+	UINT8 coin = (ioport("IN3")->read() >> 4) & 0x7;
 	return m_sound_flags | (m_coin_flag << 3) | coin;
 }
 
@@ -85,11 +85,11 @@
 		m_sound_flags &= ~0x40;
 		return soundlatch4_byte_r(space,offset) << 8;
 	case 0x2:
-		return (m_sound_flags| (input_port_read(machine(), "IN3") & 0x07) | 0x08) << 8;
+		return (m_sound_flags| (ioport("IN3")->read() & 0x07) | 0x08) << 8;
 	case 0x5:
-		return input_port_read(machine(), "IN2") << 8;
+		return ioport("IN2")->read() << 8;
 	case 0x8:
-		return input_port_read(machine(), "IN1") << 8;
+		return ioport("IN1")->read() << 8;
 	default:
 		return 0xff << 8;
 	}
diff -Nru src-old/mame/audio/cyberbal.c src/mame/audio/cyberbal.c
--- src-old/mame/audio/cyberbal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/audio/cyberbal.c	2012-05-03 11:00:08.000000000 +0200
@@ -37,8 +37,8 @@
 
 READ8_MEMBER(cyberbal_state::cyberbal_special_port3_r)
 {
-	int temp = input_port_read(machine(), "JSAII");
-	if (!(input_port_read(machine(), "IN0") & 0x8000)) temp ^= 0x80;
+	int temp = ioport("JSAII")->read();
+	if (!(ioport("IN0")->read() & 0x8000)) temp ^= 0x80;
 	if (m_cpu_to_sound_ready) temp ^= 0x40;
 	if (m_sound_to_cpu_ready) temp ^= 0x20;
 	return temp;
diff -Nru src-old/mame/audio/harddriv.c src/mame/audio/harddriv.c
--- src-old/mame/audio/harddriv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/audio/harddriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -144,7 +144,7 @@
 //            D13 = Test Switch
 //            D12 = 5220 Ready Flag (0=Ready)
 	logerror("%06X:hdsnd68k_status_r(%04X)\n", cpu_get_previouspc(&space.device()), offset);
-	return (m_mainflag << 15) | (m_soundflag << 14) | 0x2000 | 0;//((input_port_read(machine(), "IN0") & 0x0020) << 8) | 0;
+	return (m_mainflag << 15) | (m_soundflag << 14) | 0x2000 | 0;//((ioport("IN0")->read() & 0x0020) << 8) | 0;
 }
 
 
diff -Nru src-old/mame/audio/mario.c src/mame/audio/mario.c
--- src-old/mame/audio/mario.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/audio/mario.c	2012-05-03 11:00:08.000000000 +0200
@@ -416,7 +416,7 @@
 	mario_state	*state = machine.driver_data<mario_state>();
 	device_t *audiocpu = machine.device("audiocpu");
 #if USE_8039
-	UINT8 *SND = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *SND = state->memregion("audiocpu")->base();
 
 	SND[0x1001] = 0x01;
 #endif
@@ -426,7 +426,7 @@
 	{
 		state->m_eabank = "bank1";
 		audiocpu->memory().space(AS_PROGRAM)->install_read_bank(0x000, 0x7ff, "bank1");
-		state->membank("bank1")->configure_entry(0, machine.root_device().memregion("audiocpu")->base());
+		state->membank("bank1")->configure_entry(0, state->memregion("audiocpu")->base());
 	    state->membank("bank1")->configure_entry(1, state->memregion("audiocpu")->base() + 0x1000);
 	}
 
diff -Nru src-old/mame/audio/micro3d.c src/mame/audio/micro3d.c
--- src-old/mame/audio/micro3d.c	2012-04-11 09:56:42.000000000 +0200
+++ src/mame/audio/micro3d.c	2012-05-03 11:00:08.000000000 +0200
@@ -407,7 +407,7 @@
 
 	switch (offset)
 	{
-		case 0x01:	return (m_sound_port_latch[offset] & 0x7f) | input_port_read(machine(), "SOUND_SW");
+		case 0x01:	return (m_sound_port_latch[offset] & 0x7f) | ioport("SOUND_SW")->read();
 		case 0x03:	return (m_sound_port_latch[offset] & 0xf7) | (upd7759_busy_r(machine().device("upd7759")) ? 0x08 : 0);
 		default:	return 0;
 	}
diff -Nru src-old/mame/audio/midway.c src/mame/audio/midway.c
--- src-old/mame/audio/midway.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/audio/midway.c	2012-05-03 11:00:08.000000000 +0200
@@ -144,7 +144,7 @@
 {
 	static const char *const port[] = { "IP0", "IP1", "IP2", "IP3", "IP4" };
 	astring tempstr;
-	UINT8 result = input_port_read_safe(machine(), subtag(tempstr, port[offset]), 0xff);
+	UINT8 result = ioport(port[offset])->read_safe(0xff);
 	if (!m_custom_input[offset].isnull())
 		result = (result & ~m_custom_input_mask[offset]) |
 		         (m_custom_input[offset](space, offset, 0xff) & m_custom_input_mask[offset]);
diff -Nru src-old/mame/audio/mw8080bw.c src/mame/audio/mw8080bw.c
--- src-old/mame/audio/mw8080bw.c	2012-04-11 09:56:42.000000000 +0200
+++ src/mame/audio/mw8080bw.c	2012-05-03 11:00:08.000000000 +0200
@@ -575,7 +575,7 @@
 void maze_write_discrete(device_t *device, UINT8 maze_tone_timing_state)
 {
 	/* controls need to be active low */
-	int controls = ~input_port_read(device->machine(), "IN0") & 0xff;
+	int controls = ~device->machine().root_device().ioport("IN0")->read() & 0xff;
 
 	discrete_sound_w(device, MAZE_TONE_TIMING, maze_tone_timing_state);
 	discrete_sound_w(device, MAZE_P1_DATA, controls & 0x0f);
@@ -587,7 +587,7 @@
 	/* A better option might be to update it at vblank or set a timer to do it. */
 	/* The only noticeable difference doing it here, is that the controls don't */
 	/* immediately start making tones if pressed right after the coin is inserted. */
-	discrete_sound_w(device, MAZE_COIN, (~input_port_read(device->machine(), "IN1") >> 3) & 0x01);
+	discrete_sound_w(device, MAZE_COIN, (~device->machine().root_device().ioport("IN1")->read() >> 3) & 0x01);
 }
 
 
diff -Nru src-old/mame/audio/suna8.c src/mame/audio/suna8.c
--- src-old/mame/audio/suna8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/audio/suna8.c	2012-05-03 11:00:08.000000000 +0200
@@ -52,7 +52,7 @@
 {
 	suna8_state *state = device.machine().driver_data<suna8_state>();
 	running_machine &machine = device.machine();
-	int i, len = machine.root_device().memregion("samples")->bytes();
+	int i, len = state->memregion("samples")->bytes();
 	UINT8 *ROM = state->memregion("samples")->base();
 
 	state->m_samplebuf = auto_alloc_array(machine, INT16, len);
diff -Nru src-old/mame/drivers/2mindril.c src/mame/drivers/2mindril.c
--- src-old/mame/drivers/2mindril.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/2mindril.c	2012-05-03 11:00:08.000000000 +0200
@@ -73,10 +73,10 @@
 
 	switch(offset)
 	{
-		case 0x0/2: return input_port_read(machine(), "DSW");
+		case 0x0/2: return ioport("DSW")->read();
 		case 0x2/2:
 		{
-			int arm_pwr = input_port_read(machine(), "IN0");//throw
+			int arm_pwr = ioport("IN0")->read();//throw
 			//popmessage("PC=%08x %02x",cpu_get_pc(&space.device()),arm_pwr);
 
 			if(arm_pwr > 0xe0) return ~0x1800;
@@ -86,7 +86,7 @@
 			else return ~0x0000;
 		}
 		case 0x4/2: return (m_defender_sensor) | (m_shutter_sensor);
-		case 0xe/2: return input_port_read(machine(), "IN2");//coins
+		case 0xe/2: return ioport("IN2")->read();//coins
 //      default:  printf("PC=%08x [%04x] -> %04x R\n", cpu_get_pc(&space.device()), offset * 2, m_iodata[offset]);
 	}
 
diff -Nru src-old/mame/drivers/30test.c src/mame/drivers/30test.c
--- src-old/mame/drivers/30test.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/30test.c	2012-05-03 11:00:08.000000000 +0200
@@ -93,10 +93,10 @@
 
 	switch(m_mux_data)
 	{
-		case 0x01: res = input_port_read(machine(), "IN0"); break;
-		case 0x02: res = input_port_read(machine(), "IN1"); break;
-		case 0x04: res = input_port_read(machine(), "IN2"); break;
-		case 0x08: res = input_port_read(machine(), "IN3"); break;
+		case 0x01: res = ioport("IN0")->read(); break;
+		case 0x02: res = ioport("IN1")->read(); break;
+		case 0x04: res = ioport("IN2")->read(); break;
+		case 0x08: res = ioport("IN3")->read(); break;
 	}
 
 	return res;
diff -Nru src-old/mame/drivers/39in1.c src/mame/drivers/39in1.c
--- src-old/mame/drivers/39in1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/39in1.c	2012-05-03 11:00:08.000000000 +0200
@@ -1377,7 +1377,7 @@
 	}
 	else if (cpu_get_pc(&space.device()) == 0xe3af4)
 	{
-		return input_port_read(machine(), "MCUIPT");
+		return ioport("MCUIPT")->read();
 	}
 	else
 	{
diff -Nru src-old/mame/drivers/3do.c src/mame/drivers/3do.c
--- src-old/mame/drivers/3do.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/3do.c	2012-05-03 11:00:08.000000000 +0200
@@ -135,7 +135,7 @@
 
 	state->m_maincpu = downcast<legacy_cpu_device*>( machine.device("maincpu") );
 
-	state->membank("bank2")->set_base(machine.root_device().memregion("user1")->base());
+	state->membank("bank2")->set_base(state->memregion("user1")->base());
 
 	/* configure overlay */
 	state->membank("bank1")->configure_entry(0, state->m_dram);
diff -Nru src-old/mame/drivers/40love.c src/mame/drivers/40love.c
--- src-old/mame/drivers/40love.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/40love.c	2012-05-03 11:00:08.000000000 +0200
@@ -578,7 +578,7 @@
 static DRIVER_INIT( 40love )
 {
 	fortyl_state *state = machine.driver_data<fortyl_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	state->membank("bank1")->configure_entries(0, 2, &ROM[0x10000], 0x2000);
 
 	#if 0
diff -Nru src-old/mame/drivers/5clown.c src/mame/drivers/5clown.c
--- src-old/mame/drivers/5clown.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/5clown.c	2012-05-03 11:00:08.000000000 +0200
@@ -591,10 +591,10 @@
 	_5clown_state *state = device->machine().driver_data<_5clown_state>();
 	switch( state->m_mux_data & 0xf0 )		/* bits 4-7 */
 	{
-		case 0x10: return input_port_read(device->machine(), "IN0-0");
-		case 0x20: return input_port_read(device->machine(), "IN0-1");
-		case 0x40: return input_port_read(device->machine(), "IN0-2");
-		case 0x80: return input_port_read(device->machine(), "IN0-3");
+		case 0x10: return state->ioport("IN0-0")->read();
+		case 0x20: return state->ioport("IN0-1")->read();
+		case 0x40: return state->ioport("IN0-2")->read();
+		case 0x80: return state->ioport("IN0-3")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/8080bw.c src/mame/drivers/8080bw.c
--- src-old/mame/drivers/8080bw.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/8080bw.c	2012-05-03 11:00:08.000000000 +0200
@@ -1892,7 +1892,7 @@
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_START1 )
@@ -1932,7 +1932,7 @@
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) ) // must be off to boot
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_START1 )
diff -Nru src-old/mame/drivers/ace.c src/mame/drivers/ace.c
--- src-old/mame/drivers/ace.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/ace.c	2012-05-03 11:00:08.000000000 +0200
@@ -248,7 +248,7 @@
 	//c012
 
 	PORT_START("c014")	/* VBLANK??? */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("c015")	/* coin input */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
diff -Nru src-old/mame/drivers/acefruit.c src/mame/drivers/acefruit.c
--- src-old/mame/drivers/acefruit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/acefruit.c	2012-05-03 11:00:08.000000000 +0200
@@ -179,9 +179,9 @@
 	switch (bit_mask)
 	{
 		case 0x01:
-			return ((input_port_read(machine(), "PAYOUT") & bit_mask) >> 0);
+			return ((ioport("PAYOUT")->read() & bit_mask) >> 0);
 		case 0x02:
-			return ((input_port_read(machine(), "PAYOUT") & bit_mask) >> 1);
+			return ((ioport("PAYOUT")->read() & bit_mask) >> 1);
 		default:
 			logerror("sidewndr_payout_r : invalid %02X bit_mask\n",bit_mask);
 			return 0;
@@ -195,13 +195,13 @@
 	switch (bit_mask)
 	{
 		case 0x01:
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 0);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 0);
 		case 0x02:
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 1);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 1);
 		case 0x04:
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 2);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 2);
 		case 0x08:
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 3);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 3);
 		default:
 			logerror("starspnr_coinage_r : invalid %02X bit_mask\n",bit_mask);
 			return 0;
@@ -215,11 +215,11 @@
 	switch (bit_mask)
 	{
 		case 0x01:
-			return ((input_port_read(machine(), "PAYOUT") & bit_mask) >> 0);
+			return ((ioport("PAYOUT")->read() & bit_mask) >> 0);
 		case 0x02:
-			return ((input_port_read(machine(), "PAYOUT") & bit_mask) >> 1);
+			return ((ioport("PAYOUT")->read() & bit_mask) >> 1);
 		case 0x04:
-			return ((input_port_read(machine(), "PAYOUT") & bit_mask) >> 2);
+			return ((ioport("PAYOUT")->read() & bit_mask) >> 2);
 		default:
 			logerror("starspnr_payout_r : invalid %02X bit_mask\n",bit_mask);
 			return 0;
@@ -316,7 +316,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME( "Stop Nudge/Nudge Up or Down" )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME( "Gamble" )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN1 )              /* "Cash in" */
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_VBLANK ) /* active low or high?? */
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") /* active low or high?? */
 	PORT_BIT( 0xd8, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN1")	// 1
@@ -437,7 +437,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN1 )
 	/* tested at 0xef77 after IN5 bit 1 and before IN2 bit 2 - after coins are tested - table at 0xefa5 (3 bytes) */
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_VBLANK ) /* active low or high?? */
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") /* active low or high?? */
 
 	PORT_START("IN1")	// 1
 	/* tested at 0xe77c - call from 0x012c */
diff -Nru src-old/mame/drivers/acommand.c src/mame/drivers/acommand.c
--- src-old/mame/drivers/acommand.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/acommand.c	2012-05-03 11:00:08.000000000 +0200
@@ -321,7 +321,7 @@
                 ---- ---- ---- --x- (Activate Test)
                 ---- ---- ---- ---x (Advance through Tests)
             */
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 0x0014/2:
 		case 0x0016/2:
 			return machine().device<okim6295_device>("oki1")->read(space,0);
@@ -392,7 +392,7 @@
                 xxxx xxxx ---- ---- DIPSW4
                 ---- ---- xxxx xxxx DIPSW3
             */
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 	}
 	return m_ac_devram[offset];
 }
diff -Nru src-old/mame/drivers/actfancr.c src/mame/drivers/actfancr.c
--- src-old/mame/drivers/actfancr.c	2012-04-20 21:57:41.000000000 +0200
+++ src/mame/drivers/actfancr.c	2012-05-03 11:00:08.000000000 +0200
@@ -43,11 +43,11 @@
 {
 	switch (m_trio_control_select)
 	{
-		case 0: return input_port_read(machine(), "P1");
-		case 1: return input_port_read(machine(), "P2");
-		case 2: return input_port_read(machine(), "DSW1");
-		case 3: return input_port_read(machine(), "DSW2");
-		case 4: return input_port_read(machine(), "SYSTEM");	/* VBL */
+		case 0: return ioport("P1")->read();
+		case 1: return ioport("P2")->read();
+		case 2: return ioport("DSW1")->read();
+		case 3: return ioport("DSW2")->read();
+		case 4: return ioport("SYSTEM")->read();	/* VBL */
 	}
 
 	return 0xff;
@@ -154,7 +154,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:1,2")
diff -Nru src-old/mame/drivers/adp.c src/mame/drivers/adp.c
--- src-old/mame/drivers/adp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/adp.c	2012-05-03 11:00:08.000000000 +0200
@@ -287,7 +287,7 @@
 
 static UINT8 duart_input( device_t *device )
 {
-	return input_port_read(device->machine(), "DSW1");
+	return device->machine().root_device().ioport("DSW1")->read();
 }
 
 static const microtouch_interface adb_microtouch_config =
@@ -386,22 +386,22 @@
 
 	switch (m_mux_data)
 	{
-		case 0x00: value = input_port_read(machine(), "x0"); break;
-		case 0x01: value = input_port_read(machine(), "x1"); break;
-		case 0x02: value = input_port_read(machine(), "x2"); break;
-		case 0x03: value = input_port_read(machine(), "1P_UP"); break;
-		case 0x04: value = input_port_read(machine(), "1P_B1"); break;
-		case 0x05: value = input_port_read(machine(), "x5"); break;
-		case 0x06: value = input_port_read(machine(), "1P_RIGHT"); break;
-		case 0x07: value = input_port_read(machine(), "1P_DOWN"); break;
-		case 0x08: value = input_port_read(machine(), "1P_LEFT"); break;
-		case 0x09: value = input_port_read(machine(), "x9"); break;
-		case 0x0a: value = input_port_read(machine(), "x10"); break;
-		case 0x0b: value = input_port_read(machine(), "x11"); break;
-		case 0x0c: value = input_port_read(machine(), "x12"); break;
-		case 0x0d: value = input_port_read(machine(), "x13"); break;
-		case 0x0e: value = input_port_read(machine(), "1P_START"); break;
-		case 0x0f: value = input_port_read(machine(), "1P_COIN"); break;
+		case 0x00: value = ioport("x0")->read(); break;
+		case 0x01: value = ioport("x1")->read(); break;
+		case 0x02: value = ioport("x2")->read(); break;
+		case 0x03: value = ioport("1P_UP")->read(); break;
+		case 0x04: value = ioport("1P_B1")->read(); break;
+		case 0x05: value = ioport("x5")->read(); break;
+		case 0x06: value = ioport("1P_RIGHT")->read(); break;
+		case 0x07: value = ioport("1P_DOWN")->read(); break;
+		case 0x08: value = ioport("1P_LEFT")->read(); break;
+		case 0x09: value = ioport("x9")->read(); break;
+		case 0x0a: value = ioport("x10")->read(); break;
+		case 0x0b: value = ioport("x11")->read(); break;
+		case 0x0c: value = ioport("x12")->read(); break;
+		case 0x0d: value = ioport("x13")->read(); break;
+		case 0x0e: value = ioport("1P_START")->read(); break;
+		case 0x0f: value = ioport("1P_COIN")->read(); break;
 	}
 
 	m_mux_data++;
diff -Nru src-old/mame/drivers/aeroboto.c src/mame/drivers/aeroboto.c
--- src-old/mame/drivers/aeroboto.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aeroboto.c	2012-05-03 11:00:08.000000000 +0200
@@ -227,7 +227,7 @@
 {
 	aeroboto_state *state = machine.driver_data<aeroboto_state>();
 
-	state->m_stars_rom = machine.root_device().memregion("gfx2")->base();
+	state->m_stars_rom = state->memregion("gfx2")->base();
 	state->m_stars_length = state->memregion("gfx2")->bytes();
 
 	state->save_item(NAME(state->m_disable_irq));
diff -Nru src-old/mame/drivers/airbustr.c src/mame/drivers/airbustr.c
--- src-old/mame/drivers/airbustr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/airbustr.c	2012-05-03 11:00:08.000000000 +0200
@@ -439,23 +439,23 @@
 	PORT_DIPSETTING(    0x08, "Mode 1" )			//     routine at 0x056d: 11 21 12 16 (bit 3 active)
 	PORT_DIPSETTING(    0x00, "Mode 2" )			//     11 21 13 14 (bit 3 not active)
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x08, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
@@ -571,8 +571,8 @@
 static MACHINE_START( airbustr )
 {
 	airbustr_state *state = machine.driver_data<airbustr_state>();
-	UINT8 *MASTER = machine.root_device().memregion("master")->base();
-	UINT8 *SLAVE = machine.root_device().memregion("slave")->base();
+	UINT8 *MASTER = state->memregion("master")->base();
+	UINT8 *SLAVE = state->memregion("slave")->base();
 	UINT8 *AUDIO = state->memregion("audiocpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 3, &MASTER[0x00000], 0x4000);
diff -Nru src-old/mame/drivers/albazg.c src/mame/drivers/albazg.c
--- src-old/mame/drivers/albazg.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/albazg.c	2012-05-03 11:00:08.000000000 +0200
@@ -154,13 +154,13 @@
 	albazg_state *state = device->machine().driver_data<albazg_state>();
 	switch(state->m_mux_data)
 	{
-		case 0x00: return input_port_read(device->machine(), "IN0");
-		case 0x01: return input_port_read(device->machine(), "IN1");
-		case 0x02: return input_port_read(device->machine(), "IN2");
-		case 0x04: return input_port_read(device->machine(), "IN3");
-		case 0x08: return input_port_read(device->machine(), "IN4");
-		case 0x10: return input_port_read(device->machine(), "IN5");
-		case 0x20: return input_port_read(device->machine(), "IN6");
+		case 0x00: return state->ioport("IN0")->read();
+		case 0x01: return state->ioport("IN1")->read();
+		case 0x02: return state->ioport("IN2")->read();
+		case 0x04: return state->ioport("IN3")->read();
+		case 0x08: return state->ioport("IN4")->read();
+		case 0x10: return state->ioport("IN5")->read();
+		case 0x20: return state->ioport("IN6")->read();
 	}
 
 	return 0xff;
@@ -276,32 +276,32 @@
 
 	PORT_START("IN1")
 	PORT_BIT( 0x0f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_A ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_B ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_C ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_D ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("P1 BET Button") PORT_CODE(KEYCODE_3) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 ) PORT_NAME("P1 Start") PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_A ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_B ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_C ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_D ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("P1 BET Button") PORT_CODE(KEYCODE_3) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 ) PORT_NAME("P1 Start") PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
 
 	PORT_START("IN2")
 	PORT_BIT( 0x0f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_E ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_NO ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_YES ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_F ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_C ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_B ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_A ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_D ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_E ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_NO ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_YES ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_F ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_HANAFUDA_C ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_B ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_A ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_HANAFUDA_D ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
 
 	PORT_START("IN3")
 	PORT_BIT( 0x9f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 ) PORT_NAME("P1 Start") PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("P1 BET Button") PORT_CODE(KEYCODE_3) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_F ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_E ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 ) PORT_NAME("P1 Start") PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("P1 BET Button") PORT_CODE(KEYCODE_3) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_F ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_E ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
 
 	/* Some bits of these three are actually used if you use the Royal Panel type */
 	PORT_START("IN4")
@@ -309,10 +309,10 @@
 
 	PORT_START("IN5")
 	PORT_BIT( 0x9f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_NO ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_YES ) PORT_CONDITION("DSW2", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x08)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_HANAFUDA_NO ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_HANAFUDA_YES ) PORT_CONDITION("DSW2", 0x08, EQUALS, 0x00)
 
 	PORT_START("IN6")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/aleck64.c src/mame/drivers/aleck64.c
--- src-old/mame/drivers/aleck64.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aleck64.c	2012-05-03 11:00:08.000000000 +0200
@@ -199,12 +199,12 @@
 	switch( offset )
 	{
 		case 0:
-			return (input_port_read(space->machine(), "IN0"));	/* mtetrisc has regular inputs here */
+			return (space->machine().root_device().ioport("IN0")->read());	/* mtetrisc has regular inputs here */
 		case 1:
-			return (input_port_read(space->machine(), "IN1"));
+			return (space->machine().root_device().ioport("IN1")->read());
 		case 2:
 		{
-			UINT32 val = input_port_read(space->machine(), "INMJ");
+			UINT32 val = space->machine().root_device().ioport("INMJ")->read();
 
 			switch( dip_read_offset >> 8 & 0xff )
 			{
diff -Nru src-old/mame/drivers/alg.c src/mame/drivers/alg.c
--- src-old/mame/drivers/alg.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/alg.c	2012-05-03 11:00:08.000000000 +0200
@@ -61,8 +61,8 @@
 {
 	const rectangle &visarea = screen.visible_area();
 
-	int xpos = input_port_read_safe(screen.machine(), (player == 0) ? "GUN1X" : "GUN2X", 0xffffffff);
-	int ypos = input_port_read_safe(screen.machine(), (player == 0) ? "GUN1Y" : "GUN2Y", 0xffffffff);
+	int xpos = screen.machine().root_device().ioport((player == 0) ? "GUN1X" : "GUN2X")->read_safe(0xffffffff);
+	int ypos = screen.machine().root_device().ioport((player == 0) ? "GUN1Y" : "GUN2Y")->read_safe(0xffffffff);
 
 	if (xpos == -1 || ypos == -1)
 		return FALSE;
@@ -201,7 +201,7 @@
 {
 
 	/* read the trigger control based on the input select */
-	return (input_port_read(machine(), "TRIGGERS") >> m_input_select) & 1;
+	return (ioport("TRIGGERS")->read() >> m_input_select) & 1;
 }
 
 
@@ -209,7 +209,7 @@
 {
 
 	/* read the holster control based on the input select */
-	return (input_port_read(machine(), "TRIGGERS") >> (2 + m_input_select)) & 1;
+	return (ioport("TRIGGERS")->read() >> (2 + m_input_select)) & 1;
 }
 
 
@@ -240,7 +240,7 @@
 
 static READ8_DEVICE_HANDLER( alg_cia_0_porta_r )
 {
-	return input_port_read(device->machine(), "FIRE") | 0x3f;
+	return device->machine().root_device().ioport("FIRE")->read() | 0x3f;
 }
 
 
diff -Nru src-old/mame/drivers/aliens.c src/mame/drivers/aliens.c
--- src-old/mame/drivers/aliens.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aliens.c	2012-05-07 08:57:50.000000000 +0200
@@ -19,12 +19,15 @@
 /* prototypes */
 static KONAMI_SETLINES_CALLBACK( aliens_banking );
 
-static INTERRUPT_GEN( aliens_interrupt )
+static TIMER_DEVICE_CALLBACK( aliens_scanline )
 {
-	aliens_state *state = device->machine().driver_data<aliens_state>();
+	aliens_state *state = timer.machine().driver_data<aliens_state>();
+	int scanline = param;
 
-	if (k051960_is_irq_enabled(state->m_k051960))
-		device_set_input_line(device, KONAMI_IRQ_LINE, HOLD_LINE);
+	if(scanline == 240 && k051960_is_irq_enabled(state->m_k051960)) // vblank irq
+		cputag_set_input_line(timer.machine(), "maincpu", KONAMI_IRQ_LINE, HOLD_LINE);
+	else if(((scanline % 32) == 0) && (k051960_is_nmi_enabled(state->m_k051960))) // timer irq
+		cputag_set_input_line(timer.machine(), "maincpu", INPUT_LINE_NMI, PULSE_LINE);
 }
 
 READ8_MEMBER(aliens_state::bankedram_r)
@@ -70,7 +73,7 @@
 {
 
 	soundlatch_byte_w(space, offset, data);
-	device_set_input_line_and_vector(m_audiocpu, 0, HOLD_LINE, 0xff);
+	device_set_input_line(m_audiocpu, 0, HOLD_LINE);
 }
 
 static WRITE8_DEVICE_HANDLER( aliens_snd_bankswitch_w )
@@ -117,23 +120,23 @@
 static ADDRESS_MAP_START( aliens_map, AS_PROGRAM, 8, aliens_state )
 	AM_RANGE(0x0000, 0x03ff) AM_READWRITE(bankedram_r, bankedram_w) AM_SHARE("ram")		/* palette + work RAM */
 	AM_RANGE(0x0400, 0x1fff) AM_RAM
-	AM_RANGE(0x2000, 0x3fff) AM_ROMBANK("bank1")												/* banked ROM */
+	AM_RANGE(0x2000, 0x3fff) AM_ROMBANK("bank1")								/* banked ROM */
 	AM_RANGE(0x5f80, 0x5f80) AM_READ_PORT("DSW3")
 	AM_RANGE(0x5f81, 0x5f81) AM_READ_PORT("P1")
 	AM_RANGE(0x5f82, 0x5f82) AM_READ_PORT("P2")
 	AM_RANGE(0x5f83, 0x5f83) AM_READ_PORT("DSW2")
 	AM_RANGE(0x5f84, 0x5f84) AM_READ_PORT("DSW1")
 	AM_RANGE(0x5f88, 0x5f88) AM_READ(watchdog_reset_r) AM_WRITE(aliens_coin_counter_w)		/* coin counters */
-	AM_RANGE(0x5f8c, 0x5f8c) AM_WRITE(aliens_sh_irqtrigger_w)							/* cause interrupt on audio CPU */
+	AM_RANGE(0x5f8c, 0x5f8c) AM_WRITE(aliens_sh_irqtrigger_w)						/* cause interrupt on audio CPU */
 	AM_RANGE(0x4000, 0x7fff) AM_READWRITE(k052109_051960_r, k052109_051960_w)
-	AM_RANGE(0x8000, 0xffff) AM_ROM														/* ROM e24_j02.bin */
+	AM_RANGE(0x8000, 0xffff) AM_ROM										/* ROM e24_j02.bin */
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( aliens_sound_map, AS_PROGRAM, 8, aliens_state )
-	AM_RANGE(0x0000, 0x7fff) AM_ROM								/* ROM g04_b03.bin */
-	AM_RANGE(0x8000, 0x87ff) AM_RAM								/* RAM */
+	AM_RANGE(0x0000, 0x7fff) AM_ROM										/* ROM g04_b03.bin */
+	AM_RANGE(0x8000, 0x87ff) AM_RAM										/* RAM */
 	AM_RANGE(0xa000, 0xa001) AM_DEVREADWRITE_LEGACY("ymsnd", ym2151_r, ym2151_w)
-	AM_RANGE(0xc000, 0xc000) AM_READ(soundlatch_byte_r)				/* soundlatch_byte_r */
+	AM_RANGE(0xc000, 0xc000) AM_READ(soundlatch_byte_r)							/* soundlatch_byte_r */
 	AM_RANGE(0xe000, 0xe00d) AM_DEVREADWRITE_LEGACY("k007232", k007232_r, k007232_w)
 ADDRESS_MAP_END
 
@@ -257,15 +260,15 @@
 
 	/* basic machine hardware */
 
-	/* external clock should be 12MHz probably, CPU internal divider and precise cycle timings */
-	/* are unknown though. 3MHz is too low, sprites flicker in the pseudo-3D levels */
-	MCFG_CPU_ADD("maincpu", KONAMI, 6000000)		/* ? */
+	MCFG_CPU_ADD("maincpu", KONAMI,XTAL_24MHz/8)		/* 052001 (verified on pcb) */
 	MCFG_CPU_PROGRAM_MAP(aliens_map)
-	MCFG_CPU_VBLANK_INT("screen", aliens_interrupt)
+	MCFG_TIMER_ADD_SCANLINE("scantimer", aliens_scanline, "screen", 0, 1)
 
-	MCFG_CPU_ADD("audiocpu", Z80, 3579545)
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_3_579545MHz) 	/* verified on pcb */
 	MCFG_CPU_PROGRAM_MAP(aliens_sound_map)
 
+	MCFG_QUANTUM_TIME(attotime::from_hz(600))
+
 	MCFG_MACHINE_START(aliens)
 	MCFG_MACHINE_RESET(aliens)
 
@@ -273,7 +276,7 @@
 	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_REFRESH_RATE(60)
+	MCFG_SCREEN_REFRESH_RATE(59.17)				/* verified on pcb */
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(14*8, (64-14)*8-1, 2*8, 30*8-1 )
@@ -289,12 +292,12 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ymsnd", YM2151, 3579545)
+	MCFG_SOUND_ADD("ymsnd", YM2151, XTAL_3_579545MHz)	/* verified on pcb */
 	MCFG_SOUND_CONFIG(ym2151_config)
 	MCFG_SOUND_ROUTE(0, "mono", 0.60)
 	MCFG_SOUND_ROUTE(1, "mono", 0.60)
 
-	MCFG_SOUND_ADD("k007232", K007232, 3579545)
+	MCFG_SOUND_ADD("k007232", K007232, XTAL_3_579545MHz)	/* verified on pcb */
 	MCFG_SOUND_CONFIG(k007232_config)
 	MCFG_SOUND_ROUTE(0, "mono", 0.20)
 	MCFG_SOUND_ROUTE(1, "mono", 0.20)
diff -Nru src-old/mame/drivers/alpha68k.c src/mame/drivers/alpha68k.c
--- src-old/mame/drivers/alpha68k.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/alpha68k.c	2012-05-03 11:00:08.000000000 +0200
@@ -233,40 +233,40 @@
 
 READ16_MEMBER(alpha68k_state::kyros_dip_r)
 {
-	return input_port_read(machine(), "IN1") << 8;
+	return ioport("IN1")->read() << 8;
 }
 
 READ16_MEMBER(alpha68k_state::control_1_r)
 {
 
 	if (m_invert_controls)
-		return ~(input_port_read(machine(), "IN0") + (input_port_read(machine(), "IN1") << 8));
+		return ~(ioport("IN0")->read() + (ioport("IN1")->read() << 8));
 
-	return (input_port_read(machine(), "IN0") + (input_port_read(machine(), "IN1") << 8));
+	return (ioport("IN1")->read() << 8);
 }
 
 READ16_MEMBER(alpha68k_state::control_2_r)
 {
 
 	if (m_invert_controls)
-		return ~(input_port_read(machine(), "IN3") + ((~(1 << input_port_read(machine(), "IN5"))) << 8));
+		return ~(ioport("IN3")->read() + ((~(1 << ioport("IN5")->read())) << 8));
 
-	return input_port_read(machine(), "IN3") + /* Low byte of CN1 */
-		((~(1 << input_port_read(machine(), "IN5"))) << 8);
+	return ioport("IN3")->read() + /* Low byte of CN1 */
+		((~(1 << ioport("IN5")->read())) << 8);
 }
 
 READ16_MEMBER(alpha68k_state::control_2_V_r)
 {
-	return input_port_read(machine(), "IN3");
+	return ioport("IN3")->read();
 }
 
 READ16_MEMBER(alpha68k_state::control_3_r)
 {
 
 	if (m_invert_controls)
-		return ~(((~(1 << input_port_read(machine(), "IN6"))) << 8) & 0xff00);
+		return ~(((~(1 << ioport("IN6")->read())) << 8) & 0xff00);
 
-	return ((~(1 << input_port_read(machine(), "IN6"))) << 8) & 0xff00;
+	return ((~(1 << ioport("IN6")->read())) << 8) & 0xff00;
 }
 
 /* High 4 bits of CN1 & CN2 */
@@ -274,20 +274,20 @@
 {
 
 	if (m_invert_controls)
-		return ~((((~(1 << input_port_read(machine(), "IN6"))) << 4) & 0xf000)
-		 + (((~(1 << input_port_read(machine(), "IN5")))) & 0x0f00));
+		return ~((((~(1 << ioport("IN6")->read())) << 4) & 0xf000)
+		 + (((~(1 << ioport("IN5")->read()))) & 0x0f00));
 
-	return (((~(1 << input_port_read(machine(), "IN6"))) << 4) & 0xf000)
-		 + (((~(1 << input_port_read(machine(), "IN5")))) & 0x0f00);
+	return (((~(1 << ioport("IN6")->read())) << 4) & 0xf000)
+		 + (((~(1 << ioport("IN5")->read()))) & 0x0f00);
 }
 
 READ16_MEMBER(alpha68k_state::jongbou_inputs_r)
 {
-	UINT8 inp1 = input_port_read(machine(), "IN3");
-	UINT8 inp2 = input_port_read(machine(), "IN4");
+	UINT8 inp1 = ioport("IN3")->read();
+	UINT8 inp2 = ioport("IN4")->read();
 	inp1 = ((inp1 & 0x01) << 3) + ((inp1 & 0x02) << 1) + ((inp1 & 0x04) >> 1) + ((inp1 & 0x08) >> 3);
 	inp2 = ((inp2 & 0x01) << 3) + ((inp2 & 0x02) << 1) + ((inp2 & 0x04) >> 1) + ((inp2 & 0x08) >> 3);
-	return input_port_read(machine(), "IN0") | inp1 | inp2 << 4;
+	return ioport("IN0")->read() | inp1 | inp2 << 4;
 }
 
 
@@ -353,15 +353,15 @@
 		return 0;
 	case 0x29: /* Query microcontroller for coin insert */
 		m_trigstate++;
-		if ((input_port_read(machine(), "IN2") & 0x3) == 3)
+		if ((ioport("IN2")->read() & 0x3) == 3)
 			m_latch = 0;
-		if ((input_port_read(machine(), "IN2") & 0x1) == 0 && !m_latch)
+		if ((ioport("IN2")->read() & 0x1) == 0 && !m_latch)
 		{
 			m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id & 0xff);	// coinA
 			m_shared_ram[0x22] = (source & 0xff00) | 0x0;
 			m_latch = 1;
 
-			m_coinvalue = (~input_port_read(machine(), "IN1") >> 1) & 7;
+			m_coinvalue = (~ioport("IN1")->read() >> 1) & 7;
 			m_deposits1++;
 			if (m_deposits1 == coinage1[m_coinvalue][0])
 			{
@@ -371,13 +371,13 @@
 			else
 				m_credits = 0;
 		}
-		else if ((input_port_read(machine(), "IN2") & 0x2) == 0 && !m_latch)
+		else if ((ioport("IN2")->read() & 0x2) == 0 && !m_latch)
 		{
 			m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id >> 8);	// coinB
 			m_shared_ram[0x22] = (source & 0xff00) | 0x0;
 			m_latch = 1;
 
-			m_coinvalue = (~input_port_read(machine(), "IN1") >>1 ) & 7;
+			m_coinvalue = (~ioport("IN1")->read() >>1 ) & 7;
 			m_deposits2++;
 			if (m_deposits2 == coinage2[m_coinvalue][0])
 			{
@@ -430,7 +430,7 @@
 	switch (offset)
 	{
 		case 0: /* Dipswitch 2 */
-			m_shared_ram[0] = (source & 0xff00) | input_port_read(machine(), "IN4");
+			m_shared_ram[0] = (source & 0xff00) | ioport("IN4")->read();
 			return 0;
 
 		case 0x22: /* Coin value */
@@ -438,9 +438,9 @@
 			return 0;
 
 		case 0x29: /* Query microcontroller for coin insert */
-			if ((input_port_read(machine(), "IN2") & 0x3) == 3)
+			if ((ioport("IN2")->read() & 0x3) == 3)
 				m_latch = 0;
-			if ((input_port_read(machine(), "IN2") & 0x1) == 0 && !m_latch)
+			if ((ioport("IN2")->read() & 0x1) == 0 && !m_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id & 0xff);	// coinA
 				m_shared_ram[0x22] = (source & 0xff00) | 0x0;
@@ -449,9 +449,9 @@
 				if ((m_coin_id & 0xff) == 0x22)
 				{
 					if (m_game_id == ALPHA68K_BTLFIELDB)
-						m_coinvalue = (input_port_read(machine(), "IN4") >> 0) & 7;
+						m_coinvalue = (ioport("IN4")->read() >> 0) & 7;
 					else
-						m_coinvalue = (~input_port_read(machine(), "IN4") >> 0) & 7;
+						m_coinvalue = (~ioport("IN4")->read() >> 0) & 7;
 
 					m_deposits1++;
 					if (m_deposits1 == coinage1[m_coinvalue][0])
@@ -463,7 +463,7 @@
 						m_credits = 0;
 				}
 			}
-			else if ((input_port_read(machine(), "IN2") & 0x2) == 0 && !m_latch)
+			else if ((ioport("IN2")->read() & 0x2) == 0 && !m_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id >> 8);	// coinB
 				m_shared_ram[0x22] = (source & 0xff00) | 0x0;
@@ -472,9 +472,9 @@
 				if ((m_coin_id >> 8) == 0x22)
 				{
 					if (m_game_id == ALPHA68K_BTLFIELDB)
-						m_coinvalue = (input_port_read(machine(), "IN4") >> 0) & 7;
+						m_coinvalue = (ioport("IN4")->read() >> 0) & 7;
 					else
-						m_coinvalue = (~input_port_read(machine(), "IN4") >> 0) & 7;
+						m_coinvalue = (~ioport("IN4")->read() >> 0) & 7;
 
 					m_deposits2++;
 					if (m_deposits2 == coinage2[m_coinvalue][0])
@@ -524,15 +524,15 @@
 	switch (offset)
 	{
 		case 0: /* Dipswitch 1 */
-			m_shared_ram[0] = (source & 0xff00) | input_port_read(machine(), "IN4");
+			m_shared_ram[0] = (source & 0xff00) | ioport("IN4")->read();
 			return 0;
 		case 0x22: /* Coin value */
 			m_shared_ram[0x22] = (source & 0xff00) | (m_credits & 0x00ff);
 			return 0;
 		case 0x29: /* Query microcontroller for coin insert */
-			if ((input_port_read(machine(), "IN2") & 0x3) == 3)
+			if ((ioport("IN2")->read() & 0x3) == 3)
 				m_latch = 0;
-			if ((input_port_read(machine(), "IN2") & 0x1) == 0 && !m_latch)
+			if ((ioport("IN2")->read() & 0x1) == 0 && !m_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id & 0xff);	// coinA
 				m_shared_ram[0x22] = (source & 0xff00) | 0x0;
@@ -540,7 +540,7 @@
 
 				if ((m_coin_id & 0xff) == 0x22)
 				{
-					m_coinvalue = (~input_port_read(machine(), "IN4") >> 1) & 7;
+					m_coinvalue = (~ioport("IN4")->read() >> 1) & 7;
 					m_deposits1++;
 					if (m_deposits1 == coinage1[m_coinvalue][0])
 					{
@@ -551,7 +551,7 @@
 						m_credits = 0;
 				}
 			}
-			else if ((input_port_read(machine(), "IN2") & 0x2) == 0 && !m_latch)
+			else if ((ioport("IN2")->read() & 0x2) == 0 && !m_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | (m_coin_id>>8);	// coinB
 				m_shared_ram[0x22] = (source & 0xff00) | 0x0;
@@ -559,7 +559,7 @@
 
 				if ((m_coin_id >> 8) == 0x22)
 				{
-					m_coinvalue = (~input_port_read(machine(), "IN4") >> 1) & 7;
+					m_coinvalue = (~ioport("IN4")->read() >> 1) & 7;
 					m_deposits2++;
 					if (m_deposits2 == coinage2[m_coinvalue][0])
 					{
@@ -585,12 +585,12 @@
 			break;
 
 		case 0x1f00: /* Dipswitch 1 */
-			m_shared_ram[0x1f00] = (source & 0xff00) | input_port_read(machine(), "IN4");
+			m_shared_ram[0x1f00] = (source & 0xff00) | ioport("IN4")->read();
 			return 0;
 		case 0x1f29: /* Query microcontroller for coin insert */
-			if ((input_port_read(machine(), "IN2") & 0x3) == 3)
+			if ((ioport("IN2")->read() & 0x3) == 3)
 				m_latch = 0;
-			if ((input_port_read(machine(), "IN2") & 0x1) == 0 && !m_latch)
+			if ((ioport("IN2")->read() & 0x1) == 0 && !m_latch)
 			{
 				m_shared_ram[0x1f29] = (source & 0xff00) | (m_coin_id & 0xff);	// coinA
 				m_shared_ram[0x1f22] = (source & 0xff00) | 0x0;
@@ -598,7 +598,7 @@
 
 				if ((m_coin_id & 0xff) == 0x22)
 				{
-					m_coinvalue = (~input_port_read(machine(), "IN4") >> 1) & 7;
+					m_coinvalue = (~ioport("IN4")->read() >> 1) & 7;
 					m_deposits1++;
 					if (m_deposits1 == coinage1[m_coinvalue][0])
 					{
@@ -609,7 +609,7 @@
 						m_credits = 0;
 				}
 			}
-			else if ((input_port_read(machine(), "IN2") & 0x2) == 0 && !m_latch)
+			else if ((ioport("IN2")->read() & 0x2) == 0 && !m_latch)
 			{
 				m_shared_ram[0x1f29] = (source & 0xff00) | (m_coin_id >> 8);	// coinB
 				m_shared_ram[0x1f22] = (source & 0xff00) | 0x0;
@@ -617,7 +617,7 @@
 
 				if ((m_coin_id >> 8) == 0x22)
 				{
-					m_coinvalue = (~input_port_read(machine(), "IN4") >> 1) & 7;
+					m_coinvalue = (~ioport("IN4")->read() >> 1) & 7;
 					m_deposits2++;
 					if (m_deposits2 == coinage2[m_coinvalue][0])
 					{
@@ -638,7 +638,7 @@
                the microcontroller supplies it (it does for all the other games,
                but usually to 0x0 in RAM) when 0x21 is read (code at 0x009332) */
 			source = m_shared_ram[0x0163];
-			m_shared_ram[0x0163] = (source & 0x00ff) | (input_port_read(machine(), "IN4") << 8);
+			m_shared_ram[0x0163] = (source & 0x00ff) | (ioport("IN4")->read() << 8);
 
 			return 0;
 		case 0x1ffe:  /* Custom ID check */
@@ -1568,10 +1568,10 @@
 	PORT_DIPSETTING(    0x03, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Demo_Sounds ) )		PORT_DIPLOCATION("SW2:3") PORT_CONDITION("DSW2",0x08,PORTCOND_EQUALS,0x08)
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Demo_Sounds ) )		PORT_DIPLOCATION("SW2:3") PORT_CONDITION("DSW2",0x08,EQUALS,0x08)
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, "Game Mode" )				PORT_DIPLOCATION("SW2:3") PORT_CONDITION("DSW2",0x08,PORTCOND_EQUALS,0x00)
+	PORT_DIPNAME( 0x04, 0x04, "Game Mode" )				PORT_DIPLOCATION("SW2:3") PORT_CONDITION("DSW2",0x08,EQUALS,0x00)
 	PORT_DIPSETTING(    0x00, "Freeze" )
 	PORT_DIPSETTING(    0x04, "Infinite Lives (Cheat)")
 	PORT_DIPNAME( 0x08, 0x08, "SW2:3 Demo Sound/Game Mode" )	PORT_DIPLOCATION("SW2:4")
diff -Nru src-old/mame/drivers/amaticmg.c src/mame/drivers/amaticmg.c
--- src-old/mame/drivers/amaticmg.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/amaticmg.c	2012-05-07 08:57:50.000000000 +0200
@@ -1,23 +1,20 @@
 /**********************************************************************************
 
-
-  AMATIC - MULTI GAME SYSTEM
-  --------------------------
-
-  Preliminary driver by Roberto Fresca.
-
+  AMA-8000-1 / AMA-8000-2 Multi Game System.
+  Amatic Trading GmbH.
 
   Encrypted gambling hardware based on a custom CPU.
 
+  Driver by Roberto Fresca & Angelo Salese.
 
-***********************************************************************************
 
+***********************************************************************************
 
   Hardware Notes
   --------------
 
   ------------------------------------------------
-    Board #1 (unknown slots game)
+    Board #1 (Super Stars) AMA-8000-1
   ------------------------------------------------
 
   1x 40-pin custom CPU labeled:
@@ -58,7 +55,7 @@
 
 
   ------------------------------------------------
-     Multi-Game I v2.4
+     Multi-Game I v2.4 (AMA-8000-2)
   ------------------------------------------------
 
   1x 40-pin custom CPU labeled:
@@ -185,7 +182,7 @@
 
 
   ------------------------------------------------
-     Multi-Game III v3.5
+     Multi-Game III v3.5 (AMA-8000-2)
   ------------------------------------------------
 
   1x 40-pin custom CPU labeled:
@@ -229,10 +226,25 @@
 ***********************************************************************************
 
 
-    Memory Map
-    ----------
+  Memory Map
+  ----------
 
-    $00000 - $FFFFF   Still unknown...
+  0000-7FFF   ROM Space.
+  8000-9FFF   NVRAM.
+  A000-AFFF   Video RAM.
+  B000-BFFF   RAM.
+  C000-FFFF   ROM Banking
+
+  I/O
+
+  00-03       PPI 8255 0
+  20-23       PPI 8255 1
+  40-41       YM3812 Sound device.
+  60-60       MC6845 CRTC Address.
+  61-61       MC6845 CRTC Register.
+  80-80       unknown (W)
+  C0-C0       ROM Bank selector.
+  E6-E6       NMI Mask.
 
 
 ***********************************************************************************
@@ -350,6 +362,26 @@
 ***********************************************************************************
 
 
+  [2012/04/27]
+
+  - Reworked the decryption function.
+  - Added Multi Game III (V.Ger 3.64).
+
+  [2012/04/23]
+
+  - A lot of work on AMA-8000-1 machine and gfx.
+  - Identified the slots game as Super Stars.
+  - Changed am_uslot to suprstar.
+  - Reworked inputs from the scratch.
+  - Added support for outputs: lamps & counters.
+  - Added a button-lamps layout.
+  - Promoted the game to working state.
+  - Added technical notes.
+  - Renamed amaticmg3 to amaticmg2 since is the AMA-8000-2 system.
+  - Found the hopper motor signal. Mapped the hopper pay pulse to
+     key 'Q'. Now is possible to payout manually, avoiding the hang
+     for hopper empty or timeout.
+
   [2009/09/11]
 
   - Initial release.
@@ -362,14 +394,11 @@
 
   *** TO DO ***
 
-  - Decrypt the program ROMs.
-  - Identify the CPU type.
-  - Memory map.
+  - Super Stars: video garbage at first boot (doesn't happen if you soft-reset), btanb?
   - Hook the remaining GFX bitplanes.
-  - CRTC
-  - Proper inputs.
   - Color decode routines.
-  - Sound support.
+  - Remaining sound devices.
+  - Hopper as device... ;)
 
 
 ***********************************************************************************/
@@ -384,17 +413,30 @@
 #include "emu.h"
 #include "cpu/z80/z80.h"
 #include "video/mc6845.h"
-#include "machine/8255ppi.h"
+#include "machine/i8255.h"
 #include "sound/3812intf.h"
 #include "sound/dac.h"
 
+#include "suprstar.lh"
+
 
 class amaticmg_state : public driver_device
 {
 public:
 	amaticmg_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		m_attr(*this, "attr"),
+		m_vram(*this, "vram")
+		{ }
+
+	required_shared_ptr<UINT8> m_attr;
+	required_shared_ptr<UINT8> m_vram;
+
+	DECLARE_WRITE8_MEMBER(rombank_w);
+	DECLARE_WRITE8_MEMBER(nmi_mask_w);
+	DECLARE_WRITE8_MEMBER(unk80_w);
 
+	UINT8 m_nmi_mask;
 };
 
 
@@ -408,6 +450,52 @@
 
 static SCREEN_UPDATE_IND16( amaticmg )
 {
+	amaticmg_state *state = screen.machine().driver_data<amaticmg_state>();
+	const gfx_element *gfx = screen.machine().gfx[0];
+	int y,x;
+	int count = 0;
+
+	for (y=0;y<32;y++)
+	{
+		for (x=0;x<96;x++)
+		{
+			UINT16 tile = state->m_vram[count];
+			UINT8 color;
+
+			tile += ((state->m_attr[count]&0x0f)<<8);
+			/* TODO: this looks so out of place ... */
+			color = (state->m_attr[count]&0xf0)>>3;
+
+			drawgfx_opaque(bitmap,cliprect,gfx,tile,color,0,0,x*4,y*8);
+			count++;
+		}
+	}
+
+	return 0;
+}
+
+static SCREEN_UPDATE_IND16( amaticmg2 )
+{
+	amaticmg_state *state = screen.machine().driver_data<amaticmg_state>();
+	const gfx_element *gfx = screen.machine().gfx[0];
+	int y,x;
+	int count = 0;
+
+	for (y=0;y<32;y++)
+	{
+		for (x=0;x<96;x++)
+		{
+			UINT16 tile = state->m_vram[count];
+			UINT8 color;
+
+			tile += ((state->m_attr[count]&0xff)<<8);
+			color = 0;
+
+			drawgfx_opaque(bitmap,cliprect,gfx,tile,color,0,0,x*4,y*8);
+			count++;
+		}
+	}
+
 	return 0;
 }
 
@@ -422,15 +510,15 @@
 		bit0 = 0;
 		bit1 = (color_prom[0] >> 6) & 0x01;
 		bit2 = (color_prom[0] >> 7) & 0x01;
-		b = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
-		bit0 = (color_prom[0] >> 3) & 0x01;
-		bit1 = (color_prom[0] >> 4) & 0x01;
-		bit2 = (color_prom[0] >> 5) & 0x01;
 		g = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 		bit0 = (color_prom[0] >> 0) & 0x01;
 		bit1 = (color_prom[0] >> 1) & 0x01;
 		bit2 = (color_prom[0] >> 2) & 0x01;
 		r = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
+		bit0 = (color_prom[0] >> 3) & 0x01;
+		bit1 = (color_prom[0] >> 4) & 0x01;
+		bit2 = (color_prom[0] >> 5) & 0x01;
+		b = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
 		palette_set_color(machine, i, MAKE_RGB(r, g, b));
 		color_prom++;
@@ -438,7 +526,7 @@
 }
 
 
-static PALETTE_INIT( amaticmg3 )
+static PALETTE_INIT( amaticmg2 )
 {
 	const UINT8 *color_prom = machine.root_device().memregion("proms")->base();
 	int	r, g, b;
@@ -459,6 +547,64 @@
 *       Read/Write Handlers         *
 ************************************/
 
+WRITE8_MEMBER( amaticmg_state::rombank_w )
+{
+	membank("bank1")->set_entry(data & 0xf);
+}
+
+WRITE8_MEMBER( amaticmg_state::nmi_mask_w )
+{
+	m_nmi_mask = (data & 1) ^ 1;
+}
+
+static WRITE8_DEVICE_HANDLER(out_a_w)
+{
+/*  LAMPS A:
+
+    7654 3210
+    x--- -xxx  (unknown)
+    ---- x---  START
+    ---x ----  BET
+    --x- ----  HOLD3
+    -x-- ----  HOLD4
+*/
+
+	output_set_lamp_value(0, (data >> 3) & 1);	/* START */
+	output_set_lamp_value(1, (data >> 4) & 1);	/* BET */
+	output_set_lamp_value(2, (data >> 5) & 1);	/* HOLD3 */
+	output_set_lamp_value(3, (data >> 6) & 1);	/* HOLD4 */
+
+	logerror("port A: %2X\n", data);
+}
+
+static WRITE8_DEVICE_HANDLER(out_c_w)
+{
+/*  LAMPS B:
+
+    7654 3210
+    ---- ---x  Coin Out counter
+    ---- --x-  HOLD1
+    ---- -x--  Coin In counter
+    ---x ----  HOLD2
+    -x-- ----  CANCEL
+    x--- ----  Hopper motor
+    --x- x---  (unknown)
+*/
+	output_set_lamp_value(4, (data >> 1) & 1);	/* HOLD1 */
+	output_set_lamp_value(5, (data >> 4) & 1);	/* HOLD2 */
+	output_set_lamp_value(6, (data >> 6) & 1);	/* CANCEL */
+
+//  coin_counter_w(machine(), 0, data & 0x04);  /* Coin In */
+//  coin_counter_w(machine(), 1, data & 0x01);  /* Coin Out */
+
+	logerror("port C: %2X\n", data);
+}
+
+WRITE8_MEMBER( amaticmg_state::unk80_w )
+{
+//  dac_data_w(machine().device("dac"), data & 0x01);       /* Sound DAC */
+}
+
 
 
 /************************************
@@ -466,25 +612,41 @@
 ************************************/
 
 static ADDRESS_MAP_START( amaticmg_map, AS_PROGRAM, 8, amaticmg_state )
-	AM_RANGE(0x00000, 0x3ffff) AM_ROM
-//  AM_RANGE(0x0000, 0x0000) AM_RAM // AM_SHARE("nvram")
-//  AM_RANGE(0x0000, 0x0000) AM_DEVWRITE_LEGACY("crtc", mc6845_address_w)
-//  AM_RANGE(0x0000, 0x0000) AM_DEVREADWRITE_LEGACY("crtc", mc6845_register_r, mc6845_register_w)
-//  AM_RANGE(0x0000, 0x0000) AM_RAM_WRITE_LEGACY(amaticmg_videoram_w) AM_BASE_LEGACY(&amaticmg_videoram)
-//  AM_RANGE(0x0000, 0x0000) AM_RAM_WRITE_LEGACY(amaticmg_colorram_w) AM_BASE_LEGACY(&amaticmg_colorram)
+	AM_RANGE(0x0000, 0x7fff) AM_ROM
+	AM_RANGE(0x8000, 0x9fff) AM_RAM // AM_SHARE("nvram")
+	AM_RANGE(0xa000, 0xafff) AM_RAM AM_SHARE("vram")
+	AM_RANGE(0xb000, 0xbfff) AM_RAM AM_SHARE("attr")
+	AM_RANGE(0xc000, 0xffff) AM_ROMBANK("bank1")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( amaticmg_portmap, AS_IO, 8, amaticmg_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
-//  AM_RANGE(0x00, 0x00) AM_DEVREADWRITE_LEGACY("ppi8255_0", ppi8255_r, ppi8255_w)
-//  AM_RANGE(0x00, 0x00) AM_DEVREADWRITE_LEGACY("ppi8255_1", ppi8255_r, ppi8255_w)
+	AM_RANGE(0x00, 0x03) AM_DEVREADWRITE("ppi8255_0", i8255_device, read, write)
+	AM_RANGE(0x20, 0x23) AM_DEVREADWRITE("ppi8255_1", i8255_device, read, write)
+	AM_RANGE(0x40, 0x41) AM_DEVWRITE_LEGACY("ymsnd", ym3812_w)
+	AM_RANGE(0x60, 0x60) AM_DEVWRITE("crtc", mc6845_device, address_w)
+	AM_RANGE(0x61, 0x61) AM_DEVREADWRITE("crtc", mc6845_device, register_r, register_w)
+	AM_RANGE(0x80, 0x80) AM_WRITE(unk80_w)
+	AM_RANGE(0xc0, 0xc0) AM_WRITE(rombank_w)
 //  AM_RANGE(0x00, 0x00) AM_DEVREADWRITE_LEGACY("ppi8255_2", ppi8255_r, ppi8255_w)
-//  AM_RANGE(0x00, 0x00) AM_DEVWRITE_LEGACY("ymsnd", ym3812_w)
 //  AM_RANGE(0x00, 0x00) AM_DEVWRITE_LEGACY("dac1", dac_signed_w)
 //  AM_RANGE(0x00, 0x00) AM_DEVWRITE_LEGACY("dac2", dac_signed_w)
 
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( amaticmg2_portmap, AS_IO, 8, amaticmg_state )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+//  ADDRESS_MAP_UNMAP_HIGH
+	AM_RANGE(0x00, 0x03) AM_DEVREADWRITE("ppi8255_0", i8255_device, read, write)
+	AM_RANGE(0x20, 0x23) AM_DEVREADWRITE("ppi8255_1", i8255_device, read, write)
+	AM_RANGE(0x40, 0x41) AM_DEVWRITE_LEGACY("ymsnd", ym3812_w)
+	AM_RANGE(0x60, 0x60) AM_DEVWRITE("crtc", mc6845_device, address_w)					// 0e for mg_iii_vger_3.64_v_8309
+	AM_RANGE(0x61, 0x61) AM_DEVREADWRITE("crtc", mc6845_device, register_r, register_w)	// 0f for mg_iii_vger_3.64_v_8309
+	AM_RANGE(0xc0, 0xc0) AM_WRITE(rombank_w)
+	AM_RANGE(0xe6, 0xe6) AM_WRITE(nmi_mask_w)
+ADDRESS_MAP_END
+
+
 /*
     Unknown R/W
     -----------
@@ -499,70 +661,70 @@
 
 static INPUT_PORTS_START( amaticmg )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-1") PORT_CODE(KEYCODE_1)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-2") PORT_CODE(KEYCODE_2)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-3") PORT_CODE(KEYCODE_3)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-4") PORT_CODE(KEYCODE_4)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-5") PORT_CODE(KEYCODE_5)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-6") PORT_CODE(KEYCODE_6)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-7") PORT_CODE(KEYCODE_7)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("0-8") PORT_CODE(KEYCODE_8)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 )          PORT_NAME("Coin 1 (Muenze 1)") PORT_IMPULSE(3)
 
 	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-1") PORT_CODE(KEYCODE_Q)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-2") PORT_CODE(KEYCODE_W)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-3") PORT_CODE(KEYCODE_E)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-4") PORT_CODE(KEYCODE_R)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-5") PORT_CODE(KEYCODE_T)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-6") PORT_CODE(KEYCODE_Y)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-7") PORT_CODE(KEYCODE_U)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-8") PORT_CODE(KEYCODE_I)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE2 )       PORT_NAME("Service B (Dienst B") PORT_CODE(KEYCODE_8) PORT_TOGGLE
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )          PORT_NAME("Coin 2 (Muenze 2)")   PORT_IMPULSE(3)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER )          PORT_NAME("Hopper Payout pulse") PORT_IMPULSE(3)      PORT_CODE(KEYCODE_Q)	// Hopper paying pulse
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_GAMBLE_PAYOUT )  PORT_CODE(KEYCODE_W)           // 'Ausgegeben 0 - Hopper Leer' (spent 0 - hopper empty)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_POKER_HOLD3 )	PORT_NAME("Hold 3 (Halten 3)")
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_POKER_HOLD2 )	PORT_NAME("Hold 2 (Halten 2)")
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-1") PORT_CODE(KEYCODE_A)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-2") PORT_CODE(KEYCODE_S)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-3") PORT_CODE(KEYCODE_D)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-4") PORT_CODE(KEYCODE_F)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-5") PORT_CODE(KEYCODE_G)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-6") PORT_CODE(KEYCODE_H)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-7") PORT_CODE(KEYCODE_J)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-8") PORT_CODE(KEYCODE_K)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )			PORT_NAME("Start")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_POKER_CANCEL )	PORT_NAME("Clear / Take (Loeschen)")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_POKER_HOLD1 )	PORT_NAME("Hold 1 (Halten 1)")
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )       PORT_NAME("Service A (Dienst A") PORT_CODE(KEYCODE_7) PORT_TOGGLE
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_BET )     PORT_NAME("Bet (Setzen) / Half Take")
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE3 )       PORT_NAME("Service C (Dienst C") PORT_CODE(KEYCODE_9) PORT_TOGGLE
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE )        PORT_NAME("Service (Master)")    PORT_CODE(KEYCODE_0)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_POKER_HOLD4 )	PORT_NAME("Hold 4 (Halten 4)")
 
 	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-1") PORT_CODE(KEYCODE_Z)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-2") PORT_CODE(KEYCODE_X)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-3") PORT_CODE(KEYCODE_C)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-4") PORT_CODE(KEYCODE_V)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-5") PORT_CODE(KEYCODE_B)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-6") PORT_CODE(KEYCODE_N)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-7") PORT_CODE(KEYCODE_M)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-8") PORT_CODE(KEYCODE_L)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("SW1")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x01, 0x01, "DIP1")					PORT_DIPLOCATION("DIP:1")
+	PORT_DIPSETTING(    0x01, "Off (Aus)" )
+	PORT_DIPSETTING(    0x00, "On (Ein)" )
+	PORT_DIPNAME( 0x02, 0x02, "DIP2")					PORT_DIPLOCATION("DIP:2")
+	PORT_DIPSETTING(    0x02, "Off (Aus)" )
+	PORT_DIPSETTING(    0x00, "On (Ein)" )
+	PORT_DIPNAME( 0x04, 0x04, "Coin 1 (Muenzen 1)" )	PORT_DIPLOCATION("DIP:3")
+	PORT_DIPSETTING(    0x04, "10" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x08, 0x08, "Coin 2 (Muenzen 2)" )	PORT_DIPLOCATION("DIP:4")
+	PORT_DIPSETTING(    0x08, "100" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x10, 0x10, "Jackpot")				PORT_DIPLOCATION("DIP:5")
+	PORT_DIPSETTING(    0x10, "Jackpot KZB")
+	PORT_DIPSETTING(    0x00, "Jackpot LZB")
+	PORT_DIPNAME( 0x20, 0x20, "Fruechtebonus" )			PORT_DIPLOCATION("DIP:6")
+	PORT_DIPSETTING(    0x20, "Fruechtebonus Bleibt" )
+	PORT_DIPSETTING(    0x00, "Fruechtebonus Clear" )
+	PORT_DIPNAME( 0x40, 0x40, "DIP7")					PORT_DIPLOCATION("DIP:7")
+	PORT_DIPSETTING(    0x40, "Off (Aus)" )
+	PORT_DIPSETTING(    0x00, "On (Ein)" )
+	PORT_DIPNAME( 0x80, 0x80, "BH") 					PORT_DIPLOCATION("DIP:8")
+	PORT_DIPSETTING(    0x80, "BH Dreifach")
+	PORT_DIPSETTING(    0x00, "BH Normal")
 INPUT_PORTS_END
 
 
@@ -575,8 +737,8 @@
 	4,8,
 	RGN_FRAC(1,2),
 	4,
-	{ RGN_FRAC(0,2) + 0, RGN_FRAC(0,2) + 4, RGN_FRAC(1,2) + 0, RGN_FRAC(1,2) + 4 }, //TODO: rom order is unknown
-	{ 3, 2, 1, 0 },	/* tiles are x-flipped */
+	{ RGN_FRAC(0,2), RGN_FRAC(0,2) + 4, RGN_FRAC(1,2), RGN_FRAC(1,2) + 4 },
+	{ 3, 2, 1, 0 },
 	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
 	8*4*2
 };
@@ -586,7 +748,7 @@
 	4,8,
 	RGN_FRAC(1,3),
 	6,
-	{ RGN_FRAC(0,3) + 0, RGN_FRAC(0,3) + 4, RGN_FRAC(1,3) + 0, RGN_FRAC(1,3) + 4,RGN_FRAC(2,3) + 0, RGN_FRAC(2,3) + 4, }, //TODO: rom order is unknown
+	{ RGN_FRAC(0,3) + 0, RGN_FRAC(0,3) + 4, RGN_FRAC(1,3) + 0, RGN_FRAC(1,3) + 4,RGN_FRAC(2,3) + 0, RGN_FRAC(2,3) + 4, },
 	{ 3, 2, 1, 0 },	/* tiles are x-flipped */
 	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
 	8*4*2
@@ -601,70 +763,77 @@
 	GFXDECODE_ENTRY( "gfx1", 0x0000, charlayout_4bpp, 0, 0x20 )
 GFXDECODE_END
 
-static GFXDECODE_START( amaticmg3 )
-	GFXDECODE_ENTRY( "gfx1", 0x0000, charlayout_6bpp, 0, 0x20 )
+static GFXDECODE_START( amaticmg2 )
+	GFXDECODE_ENTRY( "gfx1", 0x0000, charlayout_6bpp, 0, 0x10000/0x40 )
 GFXDECODE_END
 
 /************************************
 *          Sound Interface          *
 ************************************/
 
-//static const ym3812_interface ym3812_config =
-//{
-//  sound_irq
-//};
+static const ym3812_interface ym3812_config =
+{
+	0
+};
 
 
 /************************************
 *          CRTC Interface           *
 ************************************/
 
-//static const mc6845_interface mc6845_intf =
-//{
-//  "screen",   /* screen we are acting on */
-//  8,          /* number of pixels per video memory address */
-//  NULL,       /* before pixel update callback */
-//  NULL,       /* row update callback */
-//  NULL,       /* after pixel update callback */
-//  DEVCB_NULL, /* callback for display state changes */
-//  DEVCB_NULL, /* callback for cursor state changes */
-//  DEVCB_NULL, /* HSYNC callback */
-//  DEVCB_NULL, /* VSYNC callback */
-//  NULL        /* update address callback */
-//};
+static const mc6845_interface mc6845_intf =
+{
+	"screen",   /* screen we are acting on */
+	4,          /* number of pixels per video memory address */
+	NULL,       /* before pixel update callback */
+	NULL,       /* row update callback */
+	NULL,       /* after pixel update callback */
+	DEVCB_NULL, /* callback for display state changes */
+	DEVCB_NULL, /* callback for cursor state changes */
+	DEVCB_NULL, /* HSYNC callback */
+	DEVCB_NULL, /* VSYNC callback */
+	NULL        /* update address callback */
+};
 
 
 /************************************
 *      PPI 8255 (x3) Interface      *
 ************************************/
 
-//static const ppi8255_interface ppi8255_intf[3] =
-//{
-//  {   /* (00-00) Mode X - Port X set as input */
-//      DEVCB_NULL,                     /* Port A read */
-//      DEVCB_NULL,                     /* Port B read */
-//      DEVCB_NULL,                     /* Port C read */
-//      DEVCB_NULL,                     /* Port A write */
-//      DEVCB_NULL,                     /* Port B write */
-//      DEVCB_NULL,                     /* Port C write */
-//  },
-//  {   /* (00-00) Mode X - Port X set as input */
-//      DEVCB_NULL,                     /* Port A read */
-//      DEVCB_NULL,                     /* Port B read */
-//      DEVCB_NULL,                     /* Port C read */
-//      DEVCB_NULL,                     /* Port A write */
-//      DEVCB_NULL,                     /* Port B write */
-//      DEVCB_NULL,                     /* Port C write */
-//  },
-//  {   /* (00-00) Mode X - Port X set as input */
-//      DEVCB_NULL,                     /* Port A read */
-//      DEVCB_NULL,                     /* Port B read */
-//      DEVCB_NULL,                     /* Port C read */
-//      DEVCB_NULL,                     /* Port A write */
-//      DEVCB_NULL,                     /* Port B write */
-//      DEVCB_NULL,                     /* Port C write */
-//  }
-//};
+static I8255A_INTERFACE( ppi8255_intf_0 )
+{
+	DEVCB_INPUT_PORT("IN0"),		/* Port A read */
+	DEVCB_NULL,						/* Port A write */
+	DEVCB_INPUT_PORT("IN1"),		/* Port B read */
+	DEVCB_NULL,						/* Port B write */
+	DEVCB_INPUT_PORT("IN2"),		/* Port C read */
+	DEVCB_NULL						/* Port C write */
+};
+
+static I8255A_INTERFACE( ppi8255_intf_1 )
+{
+	DEVCB_NULL,						/* Port A read */
+	DEVCB_HANDLER(out_a_w),			/* Port A write */
+	DEVCB_INPUT_PORT("SW1"),		/* Port B read */
+	DEVCB_NULL,						/* Port B write */
+	DEVCB_NULL,						/* Port C read */
+	DEVCB_HANDLER(out_c_w)			/* Port C write */
+};
+
+static MACHINE_START( amaticmg )
+{
+	UINT8 *rombank = machine.root_device().memregion("maincpu")->base();
+
+	machine.root_device().membank("bank1")->configure_entries(0, 0x10, &rombank[0x8000], 0x4000);
+}
+
+static MACHINE_RESET( amaticmg )
+{
+	amaticmg_state *state = machine.driver_data<amaticmg_state>();
+
+	state->membank("bank1")->set_entry(0);
+	state->m_nmi_mask = 0;
+}
 
 /************************************
 *          Machine Drivers          *
@@ -675,13 +844,13 @@
 	MCFG_CPU_ADD("maincpu", Z80, CPU_CLOCK)		/* WRONG! */
 	MCFG_CPU_PROGRAM_MAP(amaticmg_map)
 	MCFG_CPU_IO_MAP(amaticmg_portmap)
-	MCFG_CPU_VBLANK_INT("screen", irq0_line_hold)
+	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse) // no NMI mask?
 
 //  MCFG_NVRAM_ADD_0FILL("nvram")
 
 	/* 3x 8255 */
-//  MCFG_PPI8255_ADD( "ppi8255_0", ppi8255_intf[0] )
-//  MCFG_PPI8255_ADD( "ppi8255_1", ppi8255_intf[1] )
+	MCFG_I8255A_ADD( "ppi8255_0", ppi8255_intf_0 )
+	MCFG_I8255A_ADD( "ppi8255_1", ppi8255_intf_1 )
 //  MCFG_PPI8255_ADD( "ppi8255_2", ppi8255_intf[2] )
 
 	/* video hardware */
@@ -692,7 +861,7 @@
 	MCFG_SCREEN_VISIBLE_AREA(0, 512-1, 0, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(amaticmg)
 
-//  MCFG_MC6845_ADD("crtc", MC6845, CRTC_CLOCK, mc6845_intf)
+	MCFG_MC6845_ADD("crtc", MC6845, CRTC_CLOCK, mc6845_intf)
 
 	MCFG_GFXDECODE(amaticmg)
 
@@ -700,38 +869,61 @@
 	MCFG_PALETTE_LENGTH(0x200)
 	MCFG_VIDEO_START(amaticmg)
 
+	MCFG_MACHINE_START(amaticmg)
+	MCFG_MACHINE_RESET(amaticmg)
+
 	/* sound hardware */
-//  MCFG_SPEAKER_STANDARD_MONO("mono")
+	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-//  MCFG_SOUND_ADD("ymsnd", YM3812, SND_CLOCK)
-//  MCFG_SOUND_CONFIG(ym3812_config)
-//  MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ADD("ymsnd", YM3812, SND_CLOCK)
+	MCFG_SOUND_CONFIG(ym3812_config)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
 //  MCFG_SOUND_ADD("dac", DAC, 0)   /* Y3014B */
 //  MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_DERIVED( amaticmg3, amaticmg )
 
-	MCFG_GFXDECODE(amaticmg3)
-	MCFG_PALETTE_INIT(amaticmg3)
+static INTERRUPT_GEN( amaticmg2_irq )
+{
+	amaticmg_state *state = device->machine().driver_data<amaticmg_state>();
+
+	if(state->m_nmi_mask)
+		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
+}
+
+
+static MACHINE_CONFIG_DERIVED( amaticmg2, amaticmg )
+
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_IO_MAP(amaticmg2_portmap)
+	MCFG_CPU_VBLANK_INT("screen", amaticmg2_irq)
+
+	MCFG_SCREEN_MODIFY("screen")
+	MCFG_SCREEN_UPDATE_STATIC(amaticmg2)
+
+	MCFG_GFXDECODE(amaticmg2)
+	MCFG_PALETTE_INIT(amaticmg2)
 	MCFG_PALETTE_LENGTH(0x10000)
 MACHINE_CONFIG_END
 
+
 /************************************
 *             Rom Load              *
 ************************************/
 
-ROM_START( am_uslot )
+ROM_START( suprstar )
 	ROM_REGION( 0x40000, "maincpu", ROMREGION_ERASE00 )
 
 	ROM_REGION( 0x20000, "mainprg", 0 )	/* encrypted program ROM...*/
 	ROM_LOAD( "u3.bin",  0x00000, 0x20000, CRC(29bf4a95) SHA1(a73873f7cd1fdf5accc3e79f4619949f261400b8) )
 
-	ROM_REGION( 0x30000, "gfx1", 0 )
-	ROM_LOAD( "u9.bin",  0x00000, 0x10000, CRC(823a736a) SHA1(a5227e3080367736aac1198d9dbb55efc4114624) )
-	ROM_LOAD( "u10.bin", 0x10000, 0x10000, CRC(6a811c81) SHA1(af01cd9b1ce6aca92df71febb05fe216b18cf42a) )
+	ROM_REGION( 0x10000, "gfx1", 0 )
+	ROM_LOAD( "u10.bin", 0x00000, 0x08000, CRC(6a811c81) SHA1(af01cd9b1ce6aca92df71febb05fe216b18cf42a) )
+	ROM_CONTINUE(        0x00000, 0x08000 )
+	ROM_LOAD( "u9.bin",  0x08000, 0x08000, CRC(823a736a) SHA1(a5227e3080367736aac1198d9dbb55efc4114624) )
+	ROM_CONTINUE(        0x08000, 0x08000 )
 
 	ROM_REGION( 0x0200, "proms", 0 )
 	ROM_LOAD( "n82s147a.bin", 0x0000, 0x0200, CRC(dfeabd11) SHA1(21e8bbcf4aba5e4d672e5585890baf8c5bc77c98) )
@@ -745,9 +937,9 @@
 	ROM_LOAD( "mgi_vger_3.9-i-8201.i6.bin", 0x00000, 0x40000, CRC(9ce159f7) SHA1(101c277d579a69cb03f879288b2cecf838cf1741) )
 
 	ROM_REGION( 0x180000, "gfx1", 0 )
-	ROM_LOAD( "multi_2.4_zg1.i17.bin", 0x000000, 0x80000, CRC(4a60a718) SHA1(626991abee768da58e87c7cdfc4fcbae86c6ea2a) )
+	ROM_LOAD( "multi_2.4_zg1.i17.bin", 0x100000, 0x80000, CRC(4a60a718) SHA1(626991abee768da58e87c7cdfc4fcbae86c6ea2a) )
 	ROM_LOAD( "multi_2.4_zg2.i18.bin", 0x080000, 0x80000, CRC(b504e1b8) SHA1(ffa17a2c212eb2fffb89b131868e69430cb41203) )
-	ROM_LOAD( "multi_2.4_zg3.i33.bin", 0x100000, 0x80000, CRC(9b66bb4d) SHA1(64035d2028a9b68164c87475a1ec9754453ad572) )
+	ROM_LOAD( "multi_2.4_zg3.i33.bin", 0x000000, 0x80000, CRC(9b66bb4d) SHA1(64035d2028a9b68164c87475a1ec9754453ad572) )
 
 	ROM_REGION( 0x20000/*0x0400*/, "proms", 0 )
 	ROM_LOAD( "n82s147a_1.bin", 0x0000, 0x0200, NO_DUMP )
@@ -761,14 +953,29 @@
 	ROM_LOAD( "mg_iii_vger_3.5-i-8205.bin", 0x00000, 0x40000, CRC(21d64029) SHA1(d5c3fde02833a96dd7a43481a489bfc4a5c9609d) )
 
 	ROM_REGION( 0x180000, "gfx1", 0 )
-	ROM_LOAD( "mg_iii_51_zg1.bin", 0x000000, 0x80000, CRC(84f86874) SHA1(c483a50df6a9a71ddfdf8530a894135f9b852b89) )
+	ROM_LOAD( "mg_iii_51_zg1.bin", 0x100000, 0x80000, CRC(84f86874) SHA1(c483a50df6a9a71ddfdf8530a894135f9b852b89) )
 	ROM_LOAD( "mg_iii_51_zg2.bin", 0x080000, 0x80000, CRC(4425e535) SHA1(726c322c5d0b391b82e49dd1797ebf0abfa4a65a) )
-	ROM_LOAD( "mg_iii_51_zg3.bin", 0x100000, 0x80000, CRC(36d4c0fa) SHA1(20352dbbb2ce2233be0f4f694ddf49b8f5d6a64f) )
+	ROM_LOAD( "mg_iii_51_zg3.bin", 0x000000, 0x80000, CRC(36d4c0fa) SHA1(20352dbbb2ce2233be0f4f694ddf49b8f5d6a64f) )
 
 	ROM_REGION( 0x20000, "proms", 0 )
 	ROM_LOAD( "v.bin", 0x00000, 0x20000, CRC(524767e2) SHA1(03a108494f42365c820fdfbcba9496bda86f3081) )
 ROM_END
 
+ROM_START( am_mg3a )
+	ROM_REGION( 0x40000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x40000, "mainprg", 0 )	/* encrypted program ROM...*/
+	ROM_LOAD( "mg_iii_vger_3.64_v_8309.i16", 0x00000, 0x40000, CRC(c54f97c4) SHA1(d5ce91be7332ada304d18d07706e3b98ac0fa74b) )
+
+	ROM_REGION( 0x180000, "gfx1", 0 )
+	ROM_LOAD( "mg_iii_51_zg1.i17", 0x100000, 0x80000, CRC(84f86874) SHA1(c483a50df6a9a71ddfdf8530a894135f9b852b89) )
+	ROM_LOAD( "mg_iii_51_zg2.i18", 0x080000, 0x80000, CRC(4425e535) SHA1(726c322c5d0b391b82e49dd1797ebf0abfa4a65a) )
+	ROM_LOAD( "mg_iii_51_zg3.i19", 0x000000, 0x80000, CRC(36d4c0fa) SHA1(20352dbbb2ce2233be0f4f694ddf49b8f5d6a64f) )
+
+	ROM_REGION( 0x20000, "proms", 0 )
+	ROM_LOAD( "iv.i35", 0x00000, 0x20000, CRC(82af7296) SHA1(1a07d6481e0f8fd785be9f1b737182d7e0b84605) )
+ROM_END
+
 
 /************************************
 *       Driver Initialization       *
@@ -800,18 +1007,23 @@
 	for (int i = 0; i < len; i++)
 	{
 		encf(src[i], i, plaintext, newaddress);
-		dest[newaddress^key1] = plaintext^key2;
+		dest[newaddress^(key1^(key1>>6))] = plaintext^key2;
 	}
 }
 
-static DRIVER_INIT( amaticmg )
+static DRIVER_INIT( ama8000_1_x )
+{
+	decrypt(machine, 0x4d1, 0xf5);
+}
+
+static DRIVER_INIT( ama8000_2_i )
 {
-	decrypt(machine, 0x4c2, 0xf5);
+	decrypt(machine, 0x436, 0x55);
 }
 
-static DRIVER_INIT( amaticmg3 )
+static DRIVER_INIT( ama8000_2_v )
 {
-	decrypt(machine, 0x426, 0x55);
+	decrypt(machine, 0x703, 0xaf);
 }
 
 
@@ -819,7 +1031,8 @@
 *           Game Drivers            *
 ************************************/
 
-/*    YEAR  NAME      PARENT  MACHINE   INPUT     INIT      ROT    COMPANY                FULLNAME                     FLAGS  */
-GAME( 1996, am_uslot, 0,      amaticmg, amaticmg, amaticmg, ROT0, "Amatic Trading GmbH", "Amatic Unknown Slots Game",  GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
-GAME( 2000, am_mg24,  0,      amaticmg3, amaticmg, amaticmg3, ROT0, "Amatic Trading GmbH", "Multi Game I (V.Ger 2.4)",   GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
-GAME( 2000, am_mg3,   0,      amaticmg3, amaticmg, amaticmg3, ROT0, "Amatic Trading GmbH", "Multi Game III (V.Ger 3.5)", GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
+/*     YEAR  NAME      PARENT  MACHINE    INPUT     INIT         ROT     COMPANY                FULLNAME                      FLAGS                                                                                                        LAYOUT */
+GAMEL( 1996, suprstar, 0,      amaticmg,  amaticmg, ama8000_1_x, ROT90, "Amatic Trading GmbH", "Super Stars",                 GAME_IMPERFECT_SOUND,                                                                                        layout_suprstar )
+GAME(  2000, am_mg24,  0,      amaticmg2, amaticmg, ama8000_2_i, ROT0,  "Amatic Trading GmbH", "Multi Game I (V.Ger 2.4)",    GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
+GAME(  2000, am_mg3,   0,      amaticmg2, amaticmg, ama8000_2_i, ROT0,  "Amatic Trading GmbH", "Multi Game III (V.Ger 3.5)",  GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
+GAME(  2000, am_mg3a,  0,      amaticmg2, amaticmg, ama8000_2_v, ROT0,  "Amatic Trading GmbH", "Multi Game III (V.Ger 3.64)", GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_UNEMULATED_PROTECTION | GAME_NO_SOUND | GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/ampoker2.c src/mame/drivers/ampoker2.c
--- src-old/mame/drivers/ampoker2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ampoker2.c	2012-05-03 11:00:08.000000000 +0200
@@ -703,10 +703,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Hopper Out") PORT_CODE(KEYCODE_G)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Supervisor Key") PORT_TOGGLE PORT_CODE(KEYCODE_0)
 	PORT_DIPNAME( 0x08, 0x08, "Remote Credits" ) PORT_DIPLOCATION("SW1:1") /* DSW1 */
-	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1", 0x08, PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1", 0x08, PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x08, "Cred x  20" ) PORT_CONDITION("IN1", 0x08, PORTCOND_EQUALS,0x00) /* x100 in ampkr95 */
-	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1", 0x08, PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1", 0x08, EQUALS,0x08)
+	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1", 0x08, EQUALS,0x08)
+	PORT_DIPSETTING(    0x08, "Cred x  20" ) PORT_CONDITION("IN1", 0x08, EQUALS,0x00) /* x100 in ampkr95 */
+	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1", 0x08, EQUALS,0x00)
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_LOW ) PORT_NAME("Black Card")
 
 	PORT_START("IN4")
@@ -788,10 +788,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Hopper Out") PORT_CODE(KEYCODE_G)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Supervisor Key") PORT_TOGGLE PORT_CODE(KEYCODE_0)
 	PORT_DIPNAME( 0x08, 0x08, "Remote Credits" ) PORT_DIPLOCATION("SW1:1") /* DSW1 */
-	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x00) /* x100 in ampkr95 */
-	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,EQUALS,0x08)
+	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1",0x08,EQUALS,0x08)
+	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,EQUALS,0x00) /* x100 in ampkr95 */
+	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1",0x08,EQUALS,0x00)
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_LOW ) PORT_NAME("Black Card")
 
 	PORT_START("IN4")
@@ -873,10 +873,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Hopper Out") PORT_CODE(KEYCODE_G)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Supervisor Key") PORT_TOGGLE PORT_CODE(KEYCODE_0)
 	PORT_DIPNAME( 0x08, 0x08, "Remote Credits" ) PORT_DIPLOCATION("SW1:1") /* DSW1 */
-	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x08)
-	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x00) /* x100 in ampkr95 */
-	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1",0x08,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,EQUALS,0x08)
+	PORT_DIPSETTING(    0x00, "Cred x  50" ) PORT_CONDITION("IN1",0x08,EQUALS,0x08)
+	PORT_DIPSETTING(    0x08, "Cred x 100" ) PORT_CONDITION("IN1",0x08,EQUALS,0x00) /* x100 in ampkr95 */
+	PORT_DIPSETTING(    0x00, "Remote Off" ) PORT_CONDITION("IN1",0x08,EQUALS,0x00)
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Double") PORT_CODE(KEYCODE_S)
 
 	PORT_START("IN4")
diff -Nru src-old/mame/drivers/amspdwy.c src/mame/drivers/amspdwy.c
--- src-old/mame/drivers/amspdwy.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/amspdwy.c	2012-05-03 11:00:08.000000000 +0200
@@ -38,7 +38,7 @@
 {
 	amspdwy_state *state = machine.driver_data<amspdwy_state>();
 	static const char *const portnames[] = { "WHEEL1", "WHEEL2", "AN1", "AN2" };
-	UINT8 wheel = input_port_read(machine, portnames[2 + index]);
+	UINT8 wheel = machine.root_device().ioport(portnames[2 + index])->read();
 	if (wheel != state->m_wheel_old[index])
 	{
 		wheel = (wheel & 0x7fff) - (wheel & 0x8000);
@@ -49,7 +49,7 @@
 
 	state->m_wheel_old[index] = wheel;
 	}
-	return state->m_wheel_return[index] | input_port_read(machine, portnames[index]);
+	return state->m_wheel_return[index] | machine.root_device().ioport(portnames[index])->read();
 }
 
 READ8_MEMBER(amspdwy_state::amspdwy_wheel_0_r)
@@ -64,7 +64,7 @@
 
 static READ8_DEVICE_HANDLER( amspdwy_sound_r )
 {
-	return (ym2151_status_port_r(device, 0) & ~ 0x30) | input_port_read(device->machine(), "IN0");
+	return (ym2151_status_port_r(device, 0) & ~ 0x30) | device->machine().root_device().ioport("IN0")->read();
 }
 
 WRITE8_MEMBER(amspdwy_state::amspdwy_sound_w)
diff -Nru src-old/mame/drivers/angelkds.c src/mame/drivers/angelkds.c
--- src-old/mame/drivers/angelkds.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/angelkds.c	2012-05-03 11:00:08.000000000 +0200
@@ -160,9 +160,9 @@
 	static const char *const portnames[] = { "I81", "I82" };
 	static const char *const fakenames[] = { "FAKE1", "FAKE2" };
 
-	fake = input_port_read(machine(), fakenames[offset]);
+	fake = ioport(fakenames[offset])->read();
 
-	return ((fake & 0x01) ? fake  : input_port_read(machine(), portnames[offset]));
+	return ((fake & 0x01) ? fake  : ioport(portnames[offset])->read());
 }
 
 #else
@@ -171,7 +171,7 @@
 {
 	static const char *const portnames[] = { "I81", "I82" };
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 #endif
diff -Nru src-old/mame/drivers/aquarium.c src/mame/drivers/aquarium.c
--- src-old/mame/drivers/aquarium.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aquarium.c	2012-05-03 11:00:08.000000000 +0200
@@ -46,7 +46,7 @@
 {
 
 	int data;
-	data = (input_port_read(machine(), "SYSTEM") & 0x7fff);
+	data = (ioport("SYSTEM")->read() & 0x7fff);
 	data |= m_aquarium_snd_ack;
 	m_aquarium_snd_ack = 0;
 
diff -Nru src-old/mame/drivers/arabian.c src/mame/drivers/arabian.c
--- src-old/mame/drivers/arabian.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/arabian.c	2012-05-03 11:00:08.000000000 +0200
@@ -145,7 +145,7 @@
 		{
 			if (~sel & (1 << i))
 			{
-				val = input_port_read(machine(), comnames[i]);
+				val = ioport(comnames[i])->read();
 				break;
 			}
 		}
diff -Nru src-old/mame/drivers/arcadecl.c src/mame/drivers/arcadecl.c
--- src-old/mame/drivers/arcadecl.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/arcadecl.c	2012-05-03 11:00:08.000000000 +0200
@@ -208,7 +208,7 @@
 	PORT_BIT(  0x0010, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT(  0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT(  0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT(  0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT(  0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("COIN")
@@ -268,7 +268,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("COIN")
diff -Nru src-old/mame/drivers/aristmk4.c src/mame/drivers/aristmk4.c
--- src-old/mame/drivers/aristmk4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aristmk4.c	2012-05-03 11:00:08.000000000 +0200
@@ -321,7 +321,7 @@
     There are 4 possible combinations for colour select via SW7, colours vary based on software installed.
     */
 
-	switch(input_port_read(machine, "SW7"))
+	switch(state->ioport("SW7")->read())
 	{
 	case 0x00:
 		// restore defaults
@@ -380,12 +380,12 @@
 READ8_MEMBER(aristmk4_state::ldsw)
 {
 
-	int U3_p2_ret= input_port_read(machine(), "5002");
+	int U3_p2_ret= ioport("5002")->read();
 	if(U3_p2_ret & 0x1)
 	{
 	return 0;
 	}
-	return m_cgdrsw = input_port_read(machine(), "5005");
+	return m_cgdrsw = ioport("5005")->read();
 }
 
 READ8_MEMBER(aristmk4_state::cgdrr)
@@ -420,8 +420,8 @@
 READ8_MEMBER(aristmk4_state::u3_p2)
 {
 
-	int u3_p2_ret= input_port_read(machine(), "5002");
-	int u3_p3_ret= input_port_read(machine(), "5003");
+	int u3_p2_ret= ioport("5002")->read();
+	int u3_p3_ret= ioport("5003")->read();
 
 	output_set_lamp_value(19, (u3_p2_ret >> 4) & 1); //auditkey light
 	output_set_lamp_value(20, (u3_p3_ret >> 2) & 1); //jackpotkey light
@@ -434,7 +434,7 @@
 
 	if (m_inscrd==0)
 	{
-		m_inscrd=input_port_read(machine(), "insertcoin");
+		m_inscrd=ioport("insertcoin")->read();
 	}
 
 	if (m_inscrd==1)
@@ -446,7 +446,7 @@
 READ8_MEMBER(aristmk4_state::u3_p3)
 {
 
-    int u3_p3_ret= input_port_read(machine(), "5003");
+    int u3_p3_ret= ioport("5003")->read();
 
     if ((m_printer_motor)==1) // Printer Motor Off
 
@@ -474,7 +474,7 @@
 	switch(m_insnote)
 	{
 	case 0x01:
-		bv_p0_ret=input_port_read(machine(), "NS")+0x81; //check note selector
+		bv_p0_ret=ioport("NS")->read()+0x81; //check note selector
 		m_insnote++;
 		break;
 	case 0x02:
@@ -496,7 +496,7 @@
 	int bv_p1_ret=0x00;
 
 	if (m_insnote==0)
-		m_insnote=input_port_read(machine(), "insertnote");
+		m_insnote=ioport("insertnote")->read();
 
 	if (m_insnote==1)
 			bv_p1_ret=0x08;
@@ -645,7 +645,7 @@
 {
 	aristmk4_state *state = device->machine().driver_data<aristmk4_state>();
 
-	int ret=input_port_read(device->machine(), "via_port_b");
+	int ret=state->ioport("via_port_b")->read();
 
 // Not expecting to read anything from port B on the AY8910's ( controls BC1, BC2 and BDIR )
 // However there are extra 4 bits not going to the AY8910's on the schematics, which get read from here.
@@ -1561,12 +1561,12 @@
 
 static READ8_DEVICE_HANDLER(pa1_r)
 {
-	return (input_port_read(device->machine(), "SW3") << 4) + input_port_read(device->machine(), "SW4");
+	return (device->machine().root_device().ioport("SW3")->read() << 4) + device->machine().root_device().ioport("SW4")->read();
 }
 
 static READ8_DEVICE_HANDLER(pb1_r)
 {
-	return (input_port_read(device->machine(), "SW5") << 4) + input_port_read(device->machine(), "SW6");
+	return (device->machine().root_device().ioport("SW5")->read() << 4) + device->machine().root_device().ioport("SW6")->read();
 }
 
 static READ8_DEVICE_HANDLER(pc1_r)
@@ -1630,7 +1630,7 @@
 static MACHINE_RESET( aristmk4 )
 {
 	/* mark 4 has a link on the motherboard to switch between 1.5MHz and 3MHz clock speed */
-	switch(input_port_read(machine, "LK13"))  // CPU speed control... 3mhz or 1.5MHz
+	switch(machine.root_device().ioport("LK13")->read())  // CPU speed control... 3mhz or 1.5MHz
 	{
 	case 0x00:
 		machine.device("maincpu")->set_unscaled_clock(MAIN_CLOCK/4);  // 3 MHz
@@ -1659,7 +1659,7 @@
     Note: The use of 1 Hz in the timer is to avoid unintentional triggering the NMI ( ie.. hold down L for at least 1 second )
     */
 
-	if(input_port_read(timer.machine(), "powerfail")) // send NMI signal if L pressed
+	if(timer.machine().root_device().ioport("powerfail")->read()) // send NMI signal if L pressed
 	{
 	cputag_set_input_line( timer.machine(), "maincpu", INPUT_LINE_NMI, ASSERT_LINE );
 	}
diff -Nru src-old/mame/drivers/aristmk5.c src/mame/drivers/aristmk5.c
--- src-old/mame/drivers/aristmk5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/aristmk5.c	2012-05-03 11:00:08.000000000 +0200
@@ -392,13 +392,13 @@
 
 	/* load the roms according to what the operator wants */
 	{
-		UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+		UINT8 *ROM = state->memregion("maincpu")->base();
 		UINT8 *PRG;// = state->memregion("prg_code")->base();
 		int i;
 		UINT8 op_mode;
 		static const char *const rom_region[] = { "set_chip_4.04", "set_chip_4.4", "clear_chip", "game_prg" };
 
-		op_mode = input_port_read(machine, "ROM_LOAD");
+		op_mode = machine.root_device().ioport("ROM_LOAD")->read();
 
 		PRG = machine.root_device().memregion(rom_region[op_mode & 3])->base();
 
diff -Nru src-old/mame/drivers/arkanoid.c src/mame/drivers/arkanoid.c
--- src-old/mame/drivers/arkanoid.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/arkanoid.c	2012-05-03 11:00:08.000000000 +0200
@@ -1643,7 +1643,7 @@
 static DRIVER_INIT( tetrsark )
 {
 	arkanoid_state *state = machine.driver_data<arkanoid_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	int x;
 
 	for (x = 0; x < 0x8000; x++)
diff -Nru src-old/mame/drivers/armedf.c src/mame/drivers/armedf.c
--- src-old/mame/drivers/armedf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/armedf.c	2012-05-03 11:00:08.000000000 +0200
@@ -556,16 +556,16 @@
 				break;
 
 			case 0x642/2:
-				return (input_port_read(machine(), "DSW0") & 0xffff) ^ 0xffff;
+				return (ioport("DSW0")->read() & 0xffff) ^ 0xffff;
 
 			case 0x644/2:
-				return (input_port_read(machine(), "DSW1") & 0xffff) ^ 0xffff;
+				return (ioport("DSW1")->read() & 0xffff) ^ 0xffff;
 
 			case 0x646/2:
-				return (input_port_read(machine(), "P1") & 0xffff) ^ 0xffff;
+				return (ioport("P1")->read() & 0xffff) ^ 0xffff;
 
 			case 0x648/2:
-				return (input_port_read(machine(), "P2") & 0xffff) ^ 0xffff;
+				return (ioport("P2")->read() & 0xffff) ^ 0xffff;
 		}
 	}
 
@@ -581,16 +581,16 @@
 				}
 				break;
 			case 0x642/2:
-				return (input_port_read(machine(), "DSW0") & 0xffff) ^ 0xffff;
+				return (ioport("DSW0")->read() & 0xffff) ^ 0xffff;
 
 			case 0x644/2:
-				return (input_port_read(machine(), "DSW1") & 0xffff) ^ 0xffff;
+				return (ioport("DSW1")->read() & 0xffff) ^ 0xffff;
 
 			case 0x646/2:
-				return (input_port_read(machine(), "P1") & 0xffff) ^ 0xffff;
+				return (ioport("P1")->read() & 0xffff) ^ 0xffff;
 
 			case 0x648/2:
-				return (input_port_read(machine(), "P2") & 0xffff) ^ 0xffff;
+				return (ioport("P2")->read() & 0xffff) ^ 0xffff;
 
 			/*
             protection controls where the program code should jump to.
diff -Nru src-old/mame/drivers/artmagic.c src/mame/drivers/artmagic.c
--- src-old/mame/drivers/artmagic.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/artmagic.c	2012-05-03 11:00:08.000000000 +0200
@@ -152,7 +152,7 @@
 		update_irq_state(machine());
 		machine().scheduler().timer_set(attotime::from_usec(1), FUNC(irq_off));
 	}
-	return input_port_read(machine(), "300000");
+	return ioport("300000")->read();
 }
 
 
diff -Nru src-old/mame/drivers/asterix.c src/mame/drivers/asterix.c
--- src-old/mame/drivers/asterix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/asterix.c	2012-05-03 11:00:08.000000000 +0200
@@ -46,7 +46,7 @@
 		/* bit 0 is data */
 		/* bit 1 is cs (active low) */
 		/* bit 2 is clock (active high) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 
 		/* bit 5 is select tile bank */
 		k056832_set_tile_bank(m_k056832, (data & 0x20) >> 5);
diff -Nru src-old/mame/drivers/asteroid.c src/mame/drivers/asteroid.c
--- src-old/mame/drivers/asteroid.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/asteroid.c	2012-05-03 11:00:08.000000000 +0200
@@ -422,14 +422,14 @@
 	PORT_DIPSETTING (	0x00, DEF_STR( Normal ) )
 	PORT_DIPSETTING (	0x20, "Special" )
 	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Coinage ) )					PORT_DIPLOCATION("SW:7,8")
-	PORT_DIPSETTING (	0xc0, DEF_STR( 2C_1C ) )					PORT_CONDITION("DSW1",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING (	0x80, DEF_STR( 1C_1C ) )					PORT_CONDITION("DSW1",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING (	0x40, DEF_STR( 1C_2C ) )					PORT_CONDITION("DSW1",0x20,PORTCOND_EQUALS,0x00)
-//  PORT_DIPSETTING (   0x00, DEF_STR( 1C_1C ) )                    PORT_CONDITION("DSW1",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING (	0xc0, "Coin A 2/1 Coin B 2/1 Coin C 1/1" )	PORT_CONDITION("DSW1",0x20,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING (	0x80, "Coin A 1/1 Coin B 1/1 Coin C 1/2" )	PORT_CONDITION("DSW1",0x20,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING (	0x40, "Coin A 1/2 Coin B 1/2 Coin C 1/4" )	PORT_CONDITION("DSW1",0x20,PORTCOND_NOTEQUALS,0x00)
-//  PORT_DIPSETTING (   0x00, "Coin A 1/1 Coin B 1/1 Coin C 1/2" )  PORT_CONDITION("DSW1",0x20,PORTCOND_NOTEQUALS,0x00)
+	PORT_DIPSETTING (	0xc0, DEF_STR( 2C_1C ) )					PORT_CONDITION("DSW1",0x20,EQUALS,0x00)
+	PORT_DIPSETTING (	0x80, DEF_STR( 1C_1C ) )					PORT_CONDITION("DSW1",0x20,EQUALS,0x00)
+	PORT_DIPSETTING (	0x40, DEF_STR( 1C_2C ) )					PORT_CONDITION("DSW1",0x20,EQUALS,0x00)
+//  PORT_DIPSETTING (   0x00, DEF_STR( 1C_1C ) )                    PORT_CONDITION("DSW1",0x20,EQUALS,0x00)
+	PORT_DIPSETTING (	0xc0, "Coin A 2/1 Coin B 2/1 Coin C 1/1" )	PORT_CONDITION("DSW1",0x20,NOTEQUALS,0x00)
+	PORT_DIPSETTING (	0x80, "Coin A 1/1 Coin B 1/1 Coin C 1/2" )	PORT_CONDITION("DSW1",0x20,NOTEQUALS,0x00)
+	PORT_DIPSETTING (	0x40, "Coin A 1/2 Coin B 1/2 Coin C 1/4" )	PORT_CONDITION("DSW1",0x20,NOTEQUALS,0x00)
+//  PORT_DIPSETTING (   0x00, "Coin A 1/1 Coin B 1/1 Coin C 1/2" )  PORT_CONDITION("DSW1",0x20,NOTEQUALS,0x00)
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/astinvad.c src/mame/drivers/astinvad.c
--- src-old/mame/drivers/astinvad.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/astinvad.c	2012-05-03 11:00:08.000000000 +0200
@@ -352,7 +352,7 @@
 	if (bits_gone_hi & 0x08) state->m_samples->start(5, SND_FLEET4);
 	if (bits_gone_hi & 0x10) state->m_samples->start(4, SND_UFOHIT);
 
-	state->m_screen_flip = (input_port_read(device->machine(), "CABINET") & data & 0x20) ? 0xff : 0x00;
+	state->m_screen_flip = (state->ioport("CABINET")->read() & data & 0x20) ? 0xff : 0x00;
 }
 
 
@@ -383,7 +383,7 @@
 
 	if (bits_gone_hi & 0x04) m_samples->start(3, SND_INVADERHIT);
 
-	m_screen_flip = (input_port_read(machine(), "CABINET") & data & 0x80) ? 0xff : 0x00;
+	m_screen_flip = (ioport("CABINET")->read() & data & 0x80) ? 0xff : 0x00;
 }
 
 
@@ -460,7 +460,7 @@
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 
 	PORT_START("CABINET")
diff -Nru src-old/mame/drivers/astrafr.c src/mame/drivers/astrafr.c
--- src-old/mame/drivers/astrafr.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/astrafr.c	2012-05-07 08:57:50.000000000 +0200
@@ -19,13 +19,33 @@
 {
 public:
 	astrafr_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag)
+		: driver_device(mconfig, type, tag),
+		  m_maincpu(*this, "maincpu"),
+		  m_slavecpu(*this, "slavecpu")
+
 	{
 		fgpa_first_read_addr = 0xffff;
 		fgpa_rom_write_addr = 0xffff;
 		fgpa_after_rom_write_addr = 0xffff;
 	}
 
+	UINT32* m_cpuregion;
+	int  m_cpuregion_size;
+	UINT32* m_mainram;
+
+	UINT32* m_slavecpuregion;
+	int  m_slavecpuregion_size;
+	UINT32* m_slaveram;
+
+
+
+	DECLARE_READ32_MEMBER(astrafr_mem_r);
+	DECLARE_WRITE32_MEMBER(astrafr_mem_w);
+
+	DECLARE_READ32_MEMBER(astrafr_slave_mem_r);
+	DECLARE_WRITE32_MEMBER(astrafr_slave_mem_w);
+
+
 	// ports move above from game to game..
 	UINT16 fgpa_rom_write_addr;
 	UINT16 fgpa_first_read_addr;
@@ -92,47 +112,165 @@
 		}
 	}
 
+	// devices
+	required_device<cpu_device> m_maincpu;
+	optional_device<cpu_device> m_slavecpu;
+
 };
 
 
-static ADDRESS_MAP_START( astrafr_master_map, AS_PROGRAM, 32, astrafr_state )
-	AM_RANGE(0x000000, 0x1fffff) AM_ROM
-	AM_RANGE(0x800000, 0x8000ff) AM_READWRITE8(astra_fgpa_r, astra_fgpa_w, 0xffffffff)
-	AM_RANGE(0x400000, 0x40ffff) AM_RAM // as_partyd set
-ADDRESS_MAP_END
 
-// probably identical, afaik they're linked units..
-static ADDRESS_MAP_START( astrafr_slave_map, AS_PROGRAM, 32, astrafr_state )
-	AM_RANGE(0x000000, 0x1fffff) AM_ROM
-	AM_RANGE(0x800000, 0x8000ff) AM_READWRITE8(astra_fgpa_slave_r, astra_fgpa_slave_w, 0xffffffff)
-	AM_RANGE(0x400000, 0x40ffff) AM_RAM // as_partyd set
-ADDRESS_MAP_END
+READ32_MEMBER(astrafr_state::astrafr_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
 
+	switch ( cs )
+	{
+		case 1:
+			if (offset<m_cpuregion_size)
+				return m_cpuregion[offset];
+			else
+				return 0x0000;
+
+		case 2:
+			offset &= 0x3fff;
+			return m_mainram[offset];
+
+		default:
+			logerror("%08x maincpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
 
-static ADDRESS_MAP_START( astrafr_master_alt_map, AS_PROGRAM, 32, astrafr_state )
-	AM_RANGE(0x0000000, 0x01fffff) AM_ROM
-	AM_RANGE(0x1000000, 0x1009fff) AM_RAM // ?
-	AM_RANGE(0x2000000, 0x20000ff) AM_READWRITE8(astra_fgpa_r, astra_fgpa_w, 0xffffffff)
-ADDRESS_MAP_END
 
 
+WRITE32_MEMBER(astrafr_state::astrafr_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int address = offset * 4;
+	int cs = m68340_get_cs(m_maincpu, address);
+
+
+	switch ( cs )
+	{
+		case 0: // some sets end up writng the FGPA data with CS0, I guess the CS logic is wrong??
+		case 3:
+			address &= 0xfffff;
+
+			if (mem_mask&0xff000000) astra_fgpa_w(space, address+0, data >> 24);
+			if (mem_mask&0x00ff0000) astra_fgpa_w(space, address+1, data >> 16);
+			if (mem_mask&0x0000ff00) astra_fgpa_w(space, address+2, data >> 8);
+			if (mem_mask&0x000000ff) astra_fgpa_w(space, address+3, data >> 0);
+			break;
+
+		case 2:
+			offset &= 0x3fff;
+			COMBINE_DATA(&m_mainram[offset]);
+			break;
+
+		default:
+			logerror("%08x maincpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, address, data, mem_mask, cs);
+
+	}
+}
+
+READ32_MEMBER(astrafr_state::astrafr_slave_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_slavecpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 1:
+			if (offset<m_slavecpuregion_size)
+				return m_slavecpuregion[offset];
+			else
+				return 0x0000;
+
+		case 2:
+			offset &= 0x3fff;
+			return m_slaveram[offset];
 
+		default:
+			logerror("%08x slavecpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
+
+WRITE32_MEMBER(astrafr_state::astrafr_slave_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int address = offset * 4;
+	int cs = m68340_get_cs(m_slavecpu, address);
+
+
+	switch ( cs )
+	{
+		case 0: // some sets end up writng the FGPA data with CS0, I guess the CS logic is wrong??
+		case 3:
+			address &= 0xfffff;
+
+			if (mem_mask&0xff000000) astra_fgpa_slave_w(space, address+0, data >> 24);
+			if (mem_mask&0x00ff0000) astra_fgpa_slave_w(space, address+1, data >> 16);
+			if (mem_mask&0x0000ff00) astra_fgpa_slave_w(space, address+2, data >> 8);
+			if (mem_mask&0x000000ff) astra_fgpa_slave_w(space, address+3, data >> 0);
+			break;
+
+		case 2:
+			offset &= 0x3fff;
+			COMBINE_DATA(&m_slaveram[offset]);
+			break;
+
+		default:
+			logerror("%08x slavecpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, address, data, mem_mask, cs);
+
+	}
+}
+
+
+
+static ADDRESS_MAP_START( astrafr_master_map, AS_PROGRAM, 32, astrafr_state )
+	AM_RANGE(0x000000, 0xffffffff) AM_READWRITE(astrafr_mem_r, astrafr_mem_w)
+ADDRESS_MAP_END
+
+
+static ADDRESS_MAP_START( astrafr_master_alt_map, AS_PROGRAM, 32, astrafr_state )
+	AM_RANGE(0x000000, 0xffffffff) AM_READWRITE(astrafr_mem_r, astrafr_mem_w)
+ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( astra_map, AS_PROGRAM, 32, astrafr_state )
-	AM_RANGE(0x000000, 0x1fffff) AM_ROM
-	AM_RANGE(0x800000, 0x8000ff) AM_READWRITE8(astra_fgpa_r, astra_fgpa_w, 0xffffffff)
-	AM_RANGE(0x400000, 0x40ffff) AM_RAM // as_partyd set
+	AM_RANGE(0x000000, 0xffffffff) AM_READWRITE(astrafr_mem_r, astrafr_mem_w)
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( astra_alt_map, AS_PROGRAM, 32, astrafr_state )
-	AM_RANGE(0x0000000, 0x01fffff) AM_ROM
-	AM_RANGE(0x1000000, 0x1009fff) AM_RAM // ?
-	AM_RANGE(0x2000000, 0x20000ff) AM_READWRITE8(astra_fgpa_r, astra_fgpa_w, 0xffffffff)
+// probably identical, afaik they're linked units..
+static ADDRESS_MAP_START( astrafr_slave_map, AS_PROGRAM, 32, astrafr_state )
+	AM_RANGE(0x000000, 0xffffffff) AM_READWRITE(astrafr_slave_mem_r, astrafr_slave_mem_w)
 ADDRESS_MAP_END
 
+
 static INPUT_PORTS_START( astrafr )
 INPUT_PORTS_END
 
+static MACHINE_START( astra_common )
+{
+	astrafr_state *state = machine.driver_data<astrafr_state>();
+
+	state->m_cpuregion = (UINT32*)state->memregion( "maincpu" )->base();
+	state->m_cpuregion_size = state->memregion( "maincpu" )->bytes()/4;
+	state->m_mainram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+
+	state->m_slavecpuregion = (UINT32*)state->memregion( "slavecpu" )->base();
+	state->m_slavecpuregion_size = state->memregion( "slavecpu" )->bytes()/4;
+	state->m_slaveram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+
+
+}
+
 /* the FPGA area read/write addresses move around ... */
 static MACHINE_START( astra_37 )
 {
@@ -140,6 +278,7 @@
 	state->fgpa_after_rom_write_addr = 0x30;
 	state->fgpa_first_read_addr = 0x33;
 	state->fgpa_rom_write_addr = 0x37;
+	MACHINE_START_CALL(astra_common);
 }
 
 static MACHINE_START( astra_2e )
@@ -148,6 +287,7 @@
 	state->fgpa_after_rom_write_addr = 0x20;
 	state->fgpa_first_read_addr = 0x23;
 	state->fgpa_rom_write_addr = 0x2e;
+	MACHINE_START_CALL(astra_common);
 }
 
 
@@ -157,6 +297,8 @@
 
 	MCFG_CPU_ADD("slavecpu", M68340, 16000000)
 	MCFG_CPU_PROGRAM_MAP(astrafr_slave_map)
+
+	MCFG_MACHINE_START( astra_common )
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( astrafr_dual_2e, astrafr_dual )
@@ -184,6 +326,7 @@
 static MACHINE_CONFIG_START( astra_single, astrafr_state )
 	MCFG_CPU_ADD("maincpu", M68340, 16000000)
 	MCFG_CPU_PROGRAM_MAP(astra_map)
+	MCFG_MACHINE_START( astra_common )
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( astra_single_37, astra_single )
@@ -200,12 +343,14 @@
 //  state->fgpa_after_rom_write_addr = 0x20;
 //  state->fgpa_first_read_addr = 0x23;
 	state->fgpa_rom_write_addr = 0x57;
+	MACHINE_START_CALL(astra_common);
 }
 
 
 static MACHINE_CONFIG_START( astra_single_alt, astrafr_state )
 	MCFG_CPU_ADD("maincpu", M68340, 16000000)
-	MCFG_CPU_PROGRAM_MAP(astra_alt_map)
+	MCFG_CPU_PROGRAM_MAP(astra_map)
+	MCFG_MACHINE_START( astra_common )
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( astra_single_alt_57, astra_single_alt )
@@ -2169,7 +2314,7 @@
 GAME( 200?, as_tblf,  as_tbl		  , astra_single,    astrafr,    0, 	ROT0,  "Astra", "Triple Bells (Astra, V301)"		, GAME_IS_SKELETON_MECHANICAL)
 GAME( 200?, as_td,   0  	  , astra_single_2e,    astrafr,    astradec,	ROT0,  "Astra", "Twin Dragons (Astra, V103)"		, GAME_IS_SKELETON_MECHANICAL)
 
-GAME( 200?, as_twp,   0     	  , astra_single,    astrafr,    0, 	ROT0,  "Astra", "Twin Pots (Astra, V106)"		, GAME_IS_SKELETON_MECHANICAL)
+GAME( 200?, as_twp,   0     	  , astra_single_2e,    astrafr,    0,	ROT0,  "Astra", "Twin Pots (Astra, V106)"		, GAME_IS_SKELETON_MECHANICAL)
 GAME( 200?, as_twpa,  as_twp      , astra_single,    astrafr,    0, 	ROT0,  "Astra", "Twin Pots (Astra, V104)"		, GAME_IS_SKELETON_MECHANICAL)
 GAME( 200?, as_vn,    0		  , astrafr_dual_alt_37,    astrafr,    astradec_dual,	ROT0,  "Astra", "Vegas Nights (Astra, V205)"		, GAME_IS_SKELETON_MECHANICAL)
 GAME( 200?, as_vcv,    0		  , astra_single,    astrafr,    astradec,	ROT0,  "Astra", "Viva Cash Vegas (Astra, V005)"		, GAME_IS_SKELETON_MECHANICAL)
diff -Nru src-old/mame/drivers/astrocde.c src/mame/drivers/astrocde.c
--- src-old/mame/drivers/astrocde.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/astrocde.c	2012-05-05 22:08:22.000000000 +0200
@@ -256,7 +256,7 @@
 CUSTOM_INPUT_MEMBER(astrocde_state::ebases_trackball_r)
 {
 	static const char *const names[] = { "TRACKX2", "TRACKY2", "TRACKX1", "TRACKY1" };
-	return input_port_read(machine(), names[m_input_select]);
+	return ioport(names[m_input_select])->read();
 }
 
 
@@ -283,7 +283,7 @@
 {
 	coin_counter_w(machine(), 0, (offset >> 8) & 1);
 	coin_counter_w(machine(), 1, (offset >> 9) & 1);
-	return input_port_read_safe(machine(), "P3HANDLE", 0xff);
+	return ioport("P3HANDLE")->read_safe(0xff);
 }
 
 
@@ -482,7 +482,7 @@
 CUSTOM_INPUT_MEMBER(astrocde_state::demndragn_joystick_r)
 {
 	static const char *const names[] = { "MOVEX", "MOVEY" };
-	return input_port_read(machine(), names[m_input_select]);
+	return ioport(names[m_input_select])->read();
 }
 
 
@@ -722,7 +722,7 @@
  *
  *************************************/
 
-static const UINT32 controller_table[64] =
+static const ioport_value controller_table[64] =
 {
 	0x20, 0x21, 0x23, 0x22, 0x26, 0x27, 0x25, 0x24,
 	0x2c, 0x2d, 0x2f, 0x2e, 0x2a, 0x2b, 0x29, 0x28,
diff -Nru src-old/mame/drivers/astrocorp.c src/mame/drivers/astrocorp.c
--- src-old/mame/drivers/astrocorp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/astrocorp.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,7 +177,7 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
diff -Nru src-old/mame/drivers/astrof.c src/mame/drivers/astrof.c
--- src-old/mame/drivers/astrof.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/astrof.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,7 +120,7 @@
 
 CUSTOM_INPUT_MEMBER(astrof_state::astrof_p1_controls_r)
 {
-	return input_port_read(machine(), "P1");
+	return ioport("P1")->read();
 }
 
 
@@ -131,10 +131,10 @@
 	/* on an upright cabinet, a single set of controls
        is connected to both sets of pins on the edge
        connector */
-	if (input_port_read(machine(), "CAB"))
-		ret = input_port_read(machine(), "P2");
+	if (ioport("CAB")->read())
+		ret = ioport("P2")->read();
 	else
-		ret = input_port_read(machine(), "P1");
+		ret = ioport("P1")->read();
 
 	return ret;
 }
@@ -149,9 +149,9 @@
          (not verified on pcb) */
 
 	if (m_flipscreen)
-		ret = input_port_read(machine(), "P2");
+		ret = ioport("P2")->read();
 	else
-		ret = input_port_read(machine(), "P1");
+		ret = ioport("P1")->read();
 
 	return ret;
 }
@@ -204,7 +204,7 @@
 	astrof_state *state = machine.driver_data<astrof_state>();
 	offs_t i;
 	UINT8 bank = (state->m_astrof_palette_bank ? 0x10 : 0x00);
-	UINT8 config = input_port_read_safe(machine, "FAKE", 0x00);
+	UINT8 config = state->ioport("FAKE")->read_safe(0x00);
 	UINT8 *prom = state->memregion("proms")->base();
 
 	/* a common wire hack to the pcb causes the prom halves to be inverted */
@@ -240,7 +240,7 @@
 {
 	offs_t i;
 	UINT8 *prom = machine.root_device().memregion("proms")->base();
-	UINT8 config = input_port_read_safe(machine, "FAKE", 0x00);
+	UINT8 config = machine.root_device().ioport("FAKE")->read_safe(0x00);
 
 	for (i = 0; i < TOMAHAWK_NUM_PENS; i++)
 	{
@@ -295,7 +295,7 @@
 WRITE8_MEMBER(astrof_state::video_control_1_w)
 {
 
-	m_flipscreen = ((data >> 0) & 0x01) & input_port_read(machine(), "CAB");
+	m_flipscreen = ((data >> 0) & 0x01) & ioport("CAB")->read();
 
 	/* this ties to the CLR pin of the shift registers */
 	m_screen_off = (data & 0x02) ? TRUE : FALSE;
@@ -690,7 +690,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Difficulty ) )       PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW:8")
@@ -745,7 +745,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Difficulty ) )       PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW:8")
@@ -797,7 +797,7 @@
 	PORT_DIPSETTING(    0x20, "2500" )
 	PORT_DIPSETTING(    0x30, "3000" )
 	PORT_DIPUNUSED_DIPLOC( 0x40, 0x00, "SW:7" )
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW:8")
@@ -852,7 +852,7 @@
 	PORT_DIPNAME( 0x40, 0x00, "Kill Saucer after Invaders" ) PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Yes ) )              /* if saucer lands, game is over */
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW:8")
@@ -911,7 +911,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Difficulty ) )       PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW:8")
diff -Nru src-old/mame/drivers/asuka.c src/mame/drivers/asuka.c
--- src-old/mame/drivers/asuka.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/asuka.c	2012-05-03 11:00:08.000000000 +0200
@@ -655,23 +655,23 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SWA:5,6")
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SWA:7,8")
-	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
 
 	/* 0x400002 -> 0x100984 */
 	PORT_MODIFY("DSWB")
@@ -842,7 +842,7 @@
 	state->m_tc0100scn = machine.device("tc0100scn");
 
 	/* configure the banks */
-	state->membank("bank1")->configure_entry(0, machine.root_device().memregion("audiocpu")->base());
+	state->membank("bank1")->configure_entry(0, state->memregion("audiocpu")->base());
 	state->membank("bank1")->configure_entries(1, 3, state->memregion("audiocpu")->base() + 0x10000, 0x04000);
 
 	state->save_item(NAME(state->m_adpcm_pos));
diff -Nru src-old/mame/drivers/atarifb.c src/mame/drivers/atarifb.c
--- src-old/mame/drivers/atarifb.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/atarifb.c	2012-05-03 11:00:08.000000000 +0200
@@ -240,7 +240,7 @@
 	PORT_BIT ( 0x0f, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT ( 0x10, IP_ACTIVE_LOW,  IPT_BUTTON1 )
 	PORT_BIT ( 0x20, IP_ACTIVE_LOW,  IPT_TILT )
-	PORT_BIT ( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT ( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT ( 0x80, IP_ACTIVE_LOW,  IPT_COIN1 )
 
 	PORT_START("IN1")
@@ -310,7 +310,7 @@
 	PORT_BIT ( 0x04, IP_ACTIVE_LOW,  IPT_COIN3 )
 	PORT_BIT ( 0x38, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT ( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -387,7 +387,7 @@
 	PORT_BIT ( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* unused on schematics */
 	PORT_BIT ( 0x20, IP_ACTIVE_LOW, IPT_TILT )
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT ( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x07, 0x00, "Time per coin" )		PORT_DIPLOCATION("SW1:1,2,3")
diff -Nru src-old/mame/drivers/atarig1.c src/mame/drivers/atarig1.c
--- src-old/mame/drivers/atarig1.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/atarig1.c	2012-05-03 11:00:08.000000000 +0200
@@ -92,7 +92,7 @@
 
 READ16_MEMBER(atarig1_state::special_port0_r)
 {
-	int temp = input_port_read(machine(), "IN0");
+	int temp = ioport("IN0")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x1000;
 	temp ^= 0x2000;		/* A2DOK always high for now */
 	return temp;
@@ -111,11 +111,11 @@
 
 	/* Pit Fighter has no A2D, just another input port */
 	if (m_is_pitfight)
-		return input_port_read(machine(), "ADC0");
+		return ioport("ADC0")->read();
 
 	/* otherwise, assume it's hydra */
 	if (m_which_input < 3)
-		return input_port_read(machine(), adcnames[m_which_input]) << 8;
+		return ioport(adcnames[m_which_input])->read() << 8;
 
 	return 0;
 }
@@ -247,7 +247,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x2000, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_SERVICE( 0x4000, IP_ACTIVE_LOW )
-	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("ADC0")		/* ADC 0 @ fc8000 */
 	PORT_BIT( 0x00ff, 0x0080, IPT_AD_STICK_X ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10)
@@ -279,7 +279,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x2000, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_SERVICE( 0x4000, IP_ACTIVE_LOW )
-	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("ADC0")		/* fc8000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(3)
@@ -324,7 +324,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x2000, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_SERVICE( 0x4000, IP_ACTIVE_LOW )
-	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("ADC0")      /* fc8000 */
 	PORT_BIT( 0x00ff, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/atarig42.c src/mame/drivers/atarig42.c
--- src-old/mame/drivers/atarig42.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/atarig42.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,7 +72,7 @@
 
 READ16_MEMBER(atarig42_state::special_port2_r)
 {
-	int temp = input_port_read(machine(), "IN2");
+	int temp = ioport("IN2")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0020;
 	if (m_sound_to_cpu_ready) temp ^= 0x0010;
 	temp ^= 0x0008;		/* A2D.EOC always high for now */
@@ -84,7 +84,7 @@
 {
 	static const char *const portnames[] = { "A2D0", "A2D1" };
 
-	m_analog_data = input_port_read(machine(), portnames[offset != 0]);
+	m_analog_data = ioport(portnames[offset != 0])->read();
 }
 
 
@@ -386,7 +386,7 @@
 	PORT_START("IN2")		/* e00010 */
 	PORT_BIT( 0x003f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT(  0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT(  0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_INCLUDE( atarijsa_iii )		/* audio board port */
@@ -437,7 +437,7 @@
 	PORT_START("IN2")		/* e00010 */
 	PORT_BIT( 0x003f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT(  0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT(  0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_INCLUDE( atarijsa_iii )		/* audio board port */
diff -Nru src-old/mame/drivers/atarigt.c src/mame/drivers/atarigt.c
--- src-old/mame/drivers/atarigt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/atarigt.c	2012-05-03 11:00:08.000000000 +0200
@@ -99,7 +99,7 @@
 
 READ32_MEMBER(atarigt_state::special_port2_r)
 {
-	int temp = input_port_read(machine(), "SERVICE");
+	int temp = ioport("SERVICE")->read();
 	temp ^= 0x0001;		/* /A2DRDY always high for now */
 	temp ^= 0x0008;		/* A2D.EOC always high for now */
 	return (temp << 16) | temp;
@@ -108,7 +108,7 @@
 
 READ32_MEMBER(atarigt_state::special_port3_r)
 {
-	int temp = input_port_read(machine(), "COIN");
+	int temp = ioport("COIN")->read();
 	if (m_video_int_state) temp ^= 0x0001;
 	if (m_scanline_int_state) temp ^= 0x0002;
 	return (temp << 16) | temp;
@@ -118,7 +118,7 @@
 #if (HACK_TMEK_CONTROLS)
 INLINE void compute_fake_pots(int *pots)
 {
-	int fake = input_port_read(machine, "FAKE");
+	int fake = machine.root_device().ioport("FAKE")->read();
 
 	pots[0] = pots[1] = pots[2] = pots[3] = 0x80;
 
@@ -155,7 +155,7 @@
 	compute_fake_pots(pots);
 	return (pots[0] << 24) | (pots[3] << 8);
 #else
-	return (input_port_read(machine(), "AN1") << 24) | (input_port_read(machine(), "AN2") << 8);
+	return (ioport("AN2")->read() << 8);
 #endif
 }
 
@@ -167,7 +167,7 @@
 	compute_fake_pots(pots);
 	return (pots[2] << 24) | (pots[1] << 8);
 #else
-	return (input_port_read(machine(), "AN3") << 24) | (input_port_read(machine(), "AN4") << 8);
+	return (ioport("AN4")->read() << 8);
 #endif
 }
 
@@ -658,7 +658,7 @@
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* A2D.EOC */
 	PORT_BIT( 0x0030, IP_ACTIVE_LOW, IPT_UNUSED )	/* NC */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )			/* SELFTEST */
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )	/* VBLANK */
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* VBLANK */
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("COIN")			/* 68.STATUS (A2=1) */
diff -Nru src-old/mame/drivers/atarigx2.c src/mame/drivers/atarigx2.c
--- src-old/mame/drivers/atarigx2.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/atarigx2.c	2012-05-03 11:00:08.000000000 +0200
@@ -67,7 +67,7 @@
 
 READ32_MEMBER(atarigx2_state::special_port2_r)
 {
-	int temp = input_port_read(machine(), "SERVICE");
+	int temp = ioport("SERVICE")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0020;
 	if (m_sound_to_cpu_ready) temp ^= 0x0010;
 	temp ^= 0x0008;		/* A2D.EOC always high for now */
@@ -77,7 +77,7 @@
 
 READ32_MEMBER(atarigx2_state::special_port3_r)
 {
-	int temp = input_port_read(machine(), "SPECIAL");
+	int temp = ioport("SPECIAL")->read();
 	return (temp << 16) | temp;
 }
 
@@ -89,9 +89,9 @@
 	switch (offset)
 	{
 		case 0:
-			return (input_port_read(machine(), "A2D0") << 24) | (input_port_read(machine(), "A2D1") << 8);
+			return (ioport("A2D1")->read() << 8);
 		case 1:
-			return (input_port_read(machine(), "A2D2") << 24) | (input_port_read(machine(), "A2D3") << 8);
+			return (ioport("A2D3")->read() << 8);
 	}
 
 	return 0;
@@ -1205,7 +1205,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDIRQ */
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDFULL */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("SPECIAL")     /* 68.STATUS (A2=1) */
@@ -1253,7 +1253,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDIRQ */
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDFULL */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("SPECIAL")		/* 68.STATUS (A2=1) */
@@ -1301,7 +1301,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDIRQ */
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_SPECIAL )	/* /AUDFULL */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("SPECIAL")		/* 68.STATUS (A2=1) */
diff -Nru src-old/mame/drivers/atarisy1.c src/mame/drivers/atarisy1.c
--- src-old/mame/drivers/atarisy1.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/atarisy1.c	2012-05-03 11:00:08.000000000 +0200
@@ -268,15 +268,15 @@
 
 	/* digital joystick type */
 	if (m_joystick_type == 1)
-		newval = (input_port_read(machine(), "IN0") & (0x80 >> offset)) ? 0xf0 : 0x00;
+		newval = (ioport("IN0")->read() & (0x80 >> offset)) ? 0xf0 : 0x00;
 
 	/* Hall-effect analog joystick */
 	else if (m_joystick_type == 2)
-		newval = input_port_read(machine(), portnames[offset & 1]);
+		newval = ioport(portnames[offset & 1])->read();
 
 	/* Road Blasters gas pedal */
 	else if (m_joystick_type == 3)
-		newval = input_port_read(machine(), "IN1");
+		newval = ioport("IN1")->read();
 
 	/* the A4 bit enables/disables joystick IRQs */
 	m_joystick_int_enable = ((offset >> 3) & 1) ^ 1;
@@ -321,13 +321,13 @@
 
 			if (player == 0)
 			{
-				posx = (INT8)input_port_read(machine(), "IN0");
-				posy = (INT8)input_port_read(machine(), "IN1");
+				posx = (INT8)ioport("IN0")->read();
+				posy = (INT8)ioport("IN1")->read();
 			}
 			else
 			{
-				posx = (INT8)input_port_read(machine(), "IN2");
-				posy = (INT8)input_port_read(machine(), "IN3");
+				posx = (INT8)ioport("IN2")->read();
+				posy = (INT8)ioport("IN3")->read();
 			}
 
 			m_cur[player][0] = posx + posy;
@@ -339,7 +339,7 @@
 
 	/* Road Blasters steering wheel */
 	else if (m_trackball_type == 2)
-		result = input_port_read(machine(), "IN0");
+		result = ioport("IN0")->read();
 
 	return result;
 }
@@ -354,7 +354,7 @@
 
 READ16_MEMBER(atarisy1_state::port4_r)
 {
-	int temp = input_port_read(machine(), "F60000");
+	int temp = ioport("F60000")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0080;
 	return temp;
 }
@@ -369,11 +369,11 @@
 
 READ8_MEMBER(atarisy1_state::switch_6502_r)
 {
-	int temp = input_port_read(machine(), "1820");
+	int temp = ioport("1820")->read();
 
 	if (m_cpu_to_sound_ready) temp ^= 0x08;
 	if (m_sound_to_cpu_ready) temp ^= 0x10;
-	if (!(input_port_read(machine(), "F60000") & 0x0040)) temp ^= 0x80;
+	if (!(ioport("F60000")->read() & 0x0040)) temp ^= 0x80;
 
 	return temp;
 }
@@ -534,7 +534,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_SPECIAL )
@@ -573,7 +573,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_START2 ) PORT_NAME("Right Throw/P2 Start")
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Jump")
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_SPECIAL )
@@ -612,7 +612,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_START2 ) PORT_NAME("Right Whip/P2 Start")
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* freeze? */
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_SPECIAL )
@@ -659,7 +659,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_START2 ) PORT_NAME("Right Hop/P2 Start")
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Unused Button 1")
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Unused Button 2")
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_SPECIAL )
@@ -694,7 +694,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Lasers")
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_SPECIAL )
diff -Nru src-old/mame/drivers/atarisy2.c src/mame/drivers/atarisy2.c
--- src-old/mame/drivers/atarisy2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/atarisy2.c	2012-05-03 11:00:08.000000000 +0200
@@ -360,7 +360,7 @@
 
 READ16_MEMBER(atarisy2_state::switch_r)
 {
-	int result = input_port_read(machine(), "1800") | (input_port_read(machine(), "1801") << 8);
+	int result = ioport("1800")->read() | (ioport("1801")->read() << 8);
 
 	if (m_cpu_to_sound_ready) result ^= 0x20;
 	if (m_sound_to_cpu_ready) result ^= 0x10;
@@ -371,13 +371,13 @@
 
 READ8_MEMBER(atarisy2_state::switch_6502_r)
 {
-	int result = input_port_read(machine(), "1840");
+	int result = ioport("1840")->read();
 
 	if (m_cpu_to_sound_ready) result |= 0x01;
 	if (m_sound_to_cpu_ready) result |= 0x02;
 	if ((m_has_tms5220) && (tms5220_readyq_r(machine().device("tms")) == 0))
 		result &= ~0x04;
-	if (!(input_port_read(machine(), "1801") & 0x80)) result |= 0x10;
+	if (!(ioport("1801")->read() & 0x80)) result |= 0x10;
 
 	return result;
 }
@@ -412,9 +412,9 @@
 	static const char *const adcnames[] = { "ADC0", "ADC1", "ADC2", "ADC3" };
 
 	if (m_which_adc < m_pedal_count)
-		return ~input_port_read(machine(), adcnames[m_which_adc]);
+		return ~ioport(adcnames[m_which_adc])->read();
 
-	return input_port_read(machine(), adcnames[m_which_adc]) | 0xff00;
+	return ioport(adcnames[m_which_adc])->read() | 0xff00;
 }
 
 
@@ -424,7 +424,7 @@
 
     if (offset <= 1 && m_pedal_count == -1)   /* 720 */
 	{
-		switch (input_port_read(machine(), "SELECT"))
+		switch (ioport("SELECT")->read())
 		{
 			case 0:	/* Real */
 				break;
@@ -432,8 +432,8 @@
 			case 1:	/* Fake Joystick */
 			/* special thanks to MAME Analog+ for the mapping code */
 			{
-				int analogx = input_port_read(machine(), "FAKE_JOY_X") - 128;
-				int analogy = input_port_read(machine(), "FAKE_JOY_Y") - 128;
+				int analogx = ioport("FAKE_JOY_X")->read() - 128;
+				int analogy = ioport("FAKE_JOY_Y")->read() - 128;
 				double angle;
 
 				/* if the joystick is centered, leave the rest of this alone */
@@ -472,7 +472,7 @@
 			{
 				INT32  diff;
 				UINT32 temp;
-				UINT32 rotate_count = input_port_read(machine(), "FAKE_SPINNER") & 0xffff;
+				UINT32 rotate_count = ioport("FAKE_SPINNER")->read() & 0xffff;
 				/* rotate_count behaves the same as the real LEAT1 Rotate encoder
                  * we use it to generate the LETA0 Center encoder count
                  */
@@ -550,7 +550,7 @@
 				return 0xff;
 		}
 	}
-	return input_port_read(machine(), letanames[offset]);
+	return ioport(letanames[offset])->read();
 }
 
 
@@ -962,25 +962,25 @@
 	/* Center disc */
 	/* X1, X2 LETA inputs */
 	PORT_MODIFY("LETA0")	/* not direct mapped */
-	PORT_BIT( 0xff, 0x00, IPT_DIAL_V ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_NAME("Center") PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0xff, 0x00, IPT_DIAL_V ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_NAME("Center") PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
 
 	/* Rotate disc */
 	/* Y1, Y2 LETA inputs */
 	/* The disc has 72 teeth which are read by the hardware at 2x */
 	/* Computer hardware reads at 4x, so we set the sensitivity to 50% */
 	PORT_MODIFY("LETA1")	/* not direct mapped */
-	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_FULL_TURN_COUNT(144) PORT_NAME("Rotate") PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_FULL_TURN_COUNT(144) PORT_NAME("Rotate") PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
 
 	PORT_START("FAKE_JOY_X")	/* not direct mapped */
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
 
 	PORT_START("FAKE_JOY_Y")	/* not direct mapped */
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_REVERSE PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_REVERSE PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
 
 	/* Let's assume we are using a 1200 count spinner.  We scale to get a 144 count.
      * 144/1200 = 0.12 = 12% */
 	PORT_START("FAKE_SPINNER")	/* not direct mapped */
-	PORT_BIT( 0xffff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(12) PORT_KEYDELTA(10) PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
+	PORT_BIT( 0xffff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(12) PORT_KEYDELTA(10) PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
 
 	PORT_START("SELECT")
     PORT_CONFNAME( 0x03, 0x02, "Controller Type" )
diff -Nru src-old/mame/drivers/atarisy4.c src/mame/drivers/atarisy4.c
--- src-old/mame/drivers/atarisy4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/atarisy4.c	2012-05-03 11:00:08.000000000 +0200
@@ -687,7 +687,7 @@
 
 READ16_MEMBER(atarisy4_state::analog_r)
 {
-	return (input_port_read(machine(), "STICKX") << 8) | input_port_read(machine(), "STICKY");
+	return (ioport("STICKX")->read() << 8) | ioport("STICKY")->read();
 }
 
 static INPUT_PORTS_START( atarisy4 )
@@ -969,8 +969,8 @@
 	state->m_shared_ram[0] = auto_alloc_array_clear(machine, UINT16, 0x2000);
 
 	/* Populate the 68000 address space with data from the HEX files */
-	load_hexfile(main, machine.root_device().memregion("code")->base());
-	load_hexfile(main, machine.root_device().memregion("data")->base());
+	load_hexfile(main, state->memregion("code")->base());
+	load_hexfile(main, state->memregion("data")->base());
 
 	/* Set up the DSP */
 	state->membank("dsp0_bank0")->set_base(state->m_shared_ram[0]);
@@ -986,12 +986,12 @@
 	state->m_shared_ram[1] = auto_alloc_array_clear(machine, UINT16, 0x4000);
 
 	/* Populate RAM with data from the HEX files */
-	load_hexfile(machine.device("maincpu")->memory().space(AS_PROGRAM), machine.root_device().memregion("code")->base());
+	load_hexfile(machine.device("maincpu")->memory().space(AS_PROGRAM), state->memregion("code")->base());
 
 	/* Set up the first DSP */
 	state->membank("dsp0_bank0")->set_base(state->m_shared_ram[0]);
 	state->membank("dsp0_bank1")->set_base(&state->m_shared_ram[0][0x800]);
-	load_ldafile(machine.device("dsp0")->memory().space(AS_PROGRAM), machine.root_device().memregion("dsp")->base());
+	load_ldafile(machine.device("dsp0")->memory().space(AS_PROGRAM), state->memregion("dsp")->base());
 
 	/* Set up the second DSP */
 	state->membank("dsp1_bank0")->set_base(state->m_shared_ram[1]);
diff -Nru src-old/mame/drivers/ataxx.c src/mame/drivers/ataxx.c
--- src-old/mame/drivers/ataxx.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/drivers/ataxx.c	2012-05-03 11:00:08.000000000 +0200
@@ -115,7 +115,7 @@
 
 	PORT_START("IN1")		/* 0xF7 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SLAVEHALT )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN2")		/* 0x20 */
@@ -146,7 +146,7 @@
 
 	PORT_START("IN1")		/* 0xF7 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SLAVEHALT )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN2")		/* 0x20 */
@@ -198,7 +198,7 @@
 
 	PORT_START("IN1")		/* 0xF7 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SLAVEHALT )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN2")		/* 0x20 */
@@ -244,7 +244,7 @@
 
 	PORT_START("IN1")		/* 0xF7 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SLAVEHALT )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN2")		/* 0x20 */
diff -Nru src-old/mame/drivers/atetris.c src/mame/drivers/atetris.c
--- src-old/mame/drivers/atetris.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/atetris.c	2012-05-03 11:00:08.000000000 +0200
@@ -255,7 +255,7 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
 	PORT_DIPUNUSED_DIPLOC( 0x10, 0x00, "50H:!2" )	/* Listed As "SPARE2 (Unused)" */
 	PORT_DIPUNUSED_DIPLOC( 0x20, 0x00, "50H:!1" )	/* Listed As "SPARE1 (Unused)" */
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x80, IP_ACTIVE_HIGH )
 
 	PORT_START("IN1")
diff -Nru src-old/mame/drivers/attckufo.c src/mame/drivers/attckufo.c
--- src-old/mame/drivers/attckufo.c	2012-04-11 16:10:06.000000000 +0200
+++ src/mame/drivers/attckufo.c	2012-05-03 11:00:08.000000000 +0200
@@ -104,8 +104,8 @@
 {
 	switch(offset)
 	{
-		case 0: return input_port_read(machine(), "DSW");
-		case 2: return input_port_read(machine(), "INPUT");
+		case 0: return ioport("DSW")->read();
+		case 2: return ioport("INPUT")->read();
 	}
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/avalnche.c src/mame/drivers/avalnche.c
--- src-old/mame/drivers/avalnche.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/avalnche.c	2012-05-03 11:00:08.000000000 +0200
@@ -181,7 +181,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* SLAM */
 	PORT_SERVICE( 0x20, IP_ACTIVE_HIGH)
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON1 )		/* Serve */
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )			/* VBLANK */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")			/* VBLANK */
 
 	PORT_START("PADDLE")
 	PORT_BIT( 0xff, 0x80, IPT_PADDLE ) PORT_MINMAX(0x40, 0xb7) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_CENTERDELTA(0)
diff -Nru src-old/mame/drivers/aztarac.c src/mame/drivers/aztarac.c
--- src-old/mame/drivers/aztarac.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/aztarac.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,8 +63,8 @@
 
 READ16_MEMBER(aztarac_state::joystick_r)
 {
-    return (((input_port_read(machine(), "STICKZ") - 0xf) << 8) |
-            ((input_port_read(machine(), "STICKY") - 0xf) & 0xff));
+    return (((ioport("STICKZ")->read() - 0xf) << 8) |
+            ((ioport("STICKY")->read() - 0xf) & 0xff));
 }
 
 
diff -Nru src-old/mame/drivers/backfire.c src/mame/drivers/backfire.c
--- src-old/mame/drivers/backfire.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/backfire.c	2012-05-05 16:28:21.000000000 +0200
@@ -177,16 +177,16 @@
 	/* some kind of screen indicator?  checked by backfirea set before it will boot */
 	int backfire_screen = device->machine().rand() & 1;
 	eeprom_device *eeprom = downcast<eeprom_device *>(device);
-	return ((eeprom->read_bit() << 24) | input_port_read(device->machine(), "IN0")
-			| ((input_port_read(device->machine(), "IN2") & 0xbf) << 16)
-			| ((input_port_read(device->machine(), "IN3") & 0x40) << 16)) ^ (backfire_screen << 26) ;
+	return ((eeprom->read_bit() << 24) | device->machine().root_device().ioport("IN0")->read()
+			| ((device->machine().root_device().ioport("IN2")->read() & 0xbf) << 16)
+			| ((device->machine().root_device().ioport("IN3")->read() & 0x40) << 16)) ^ (backfire_screen << 26) ;
 }
 
 READ32_MEMBER(backfire_state::backfire_control2_r)
 {
 
 //  logerror("%08x:Read eprom %08x (%08x)\n", cpu_get_pc(&space.device()), offset << 1, mem_mask);
-	return (m_eeprom->read_bit() << 24) | input_port_read(machine(), "IN1") | (input_port_read(machine(), "IN1") << 16);
+	return (m_eeprom->read_bit() << 24) | ioport("IN1")->read() | (ioport("IN1")->read() << 16);
 }
 
 #ifdef UNUSED_FUNCTION
@@ -194,7 +194,7 @@
 {
 
 //  logerror("%08x:Read eprom %08x (%08x)\n", cpu_get_pc(&space.device()), offset << 1, mem_mask);
-	return (m_eeprom->read_bit() << 24) | input_port_read(machine(), "IN2") | (input_port_read(machine(), "IN2") << 16);
+	return (m_eeprom->read_bit() << 24) | ioport("IN2")->read() | (ioport("IN2")->read() << 16);
 }
 #endif
 
@@ -233,7 +233,7 @@
 #ifdef UNUSED_FUNCTION
 READ32_MEMBER(backfire_state::backfire_unknown_wheel_r)
 {
-	return input_port_read(machine(), "PADDLE0");
+	return ioport("PADDLE0")->read();
 }
 
 READ32_MEMBER(backfire_state::backfire_wheel1_r)
@@ -339,7 +339,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("lscreen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED ) /* 'soundmask' */
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -354,7 +354,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x003f, IP_ACTIVE_LOW, IPT_UNUSED ) /* all other bits like low IN2 */
-	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("lscreen")
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("PADDLE0")
diff -Nru src-old/mame/drivers/badlands.c src/mame/drivers/badlands.c
--- src-old/mame/drivers/badlands.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/badlands.c	2012-05-03 11:00:08.000000000 +0200
@@ -192,7 +192,7 @@
 	/* sound IRQ is on 32V */
 	if (scanline & 32)
 		atarigen_6502_irq_ack_r(space, 0);
-	else if (!(input_port_read(screen.machine(), "FE4000") & 0x40))
+	else if (!(screen.machine().root_device().ioport("FE4000")->read() & 0x40))
 		atarigen_6502_irq_gen(screen.machine().device("audiocpu"));
 }
 
@@ -232,7 +232,7 @@
 static INTERRUPT_GEN( vblank_int )
 {
 	badlands_state *state = device->machine().driver_data<badlands_state>();
-	int pedal_state = input_port_read(device->machine(), "PEDALS");
+	int pedal_state = state->ioport("PEDALS")->read();
 	int i;
 
 	/* update the pedals once per frame */
@@ -306,8 +306,8 @@
                 0x02 = coin 2
                 0x01 = coin 1
             */
-			result = input_port_read(machine(), "AUDIO");
-			if (!(input_port_read(machine(), "FE4000") & 0x0080)) result ^= 0x90;
+			result = ioport("AUDIO")->read();
+			if (!(ioport("FE4000")->read() & 0x0080)) result ^= 0x90;
 			if (m_cpu_to_sound_ready) result ^= 0x40;
 			if (m_sound_to_cpu_ready) result ^= 0x20;
 			result ^= 0x10;
@@ -426,7 +426,7 @@
 	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
@@ -586,7 +586,7 @@
 	badlands_state *state = machine.driver_data<badlands_state>();
 
 	/* initialize the audio system */
-	state->m_bank_base = &machine.root_device().memregion("audiocpu")->base()[0x03000];
+	state->m_bank_base = &state->memregion("audiocpu")->base()[0x03000];
 	state->m_bank_source_data = &state->memregion("audiocpu")->base()[0x10000];
 }
 
@@ -688,7 +688,7 @@
 	/* sound IRQ is on 32V */
 //  if (scanline & 32)
 //      atarigen_6502_irq_ack_r(screen.machine(), 0);
-//  else if (!(input_port_read(machine, "FE4000") & 0x40))
+//  else if (!(machine.root_device().ioport("FE4000")->read() & 0x40))
 //      atarigen_6502_irq_gen(screen.machine().device("audiocpu"));
 }
 
diff -Nru src-old/mame/drivers/bagman.c src/mame/drivers/bagman.c
--- src-old/mame/drivers/bagman.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bagman.c	2012-05-03 11:00:08.000000000 +0200
@@ -379,7 +379,7 @@
 	bagman_state *state = device->machine().driver_data<bagman_state>();
 	UINT8 dial_val;
 
-	dial_val = input_port_read(device->machine(), "DIAL_P1");
+	dial_val = state->ioport("DIAL_P1")->read();
 
 	if(state->m_p1_res != 0x60)
 		state->m_p1_res = 0x60;
@@ -392,7 +392,7 @@
 
 	state->m_p1_old_val = dial_val;
 
-	return (input_port_read(device->machine(), "P1") & 0x9f) | (state->m_p1_res);
+	return (state->ioport("P1")->read() & 0x9f) | (state->m_p1_res);
 }
 
 static READ8_DEVICE_HANDLER( dial_input_p2_r )
@@ -400,7 +400,7 @@
 	bagman_state *state = device->machine().driver_data<bagman_state>();
 	UINT8 dial_val;
 
-	dial_val = input_port_read(device->machine(), "DIAL_P2");
+	dial_val = state->ioport("DIAL_P2")->read();
 
 	if(state->m_p2_res != 0x60)
 		state->m_p2_res = 0x60;
@@ -413,7 +413,7 @@
 
 	state->m_p2_old_val = dial_val;
 
-	return (input_port_read(device->machine(), "P2") & 0x9f) | (state->m_p2_res);
+	return (state->ioport("P2")->read() & 0x9f) | (state->m_p2_res);
 }
 
 static const ay8910_interface ay8910_dial_config =
diff -Nru src-old/mame/drivers/balsente.c src/mame/drivers/balsente.c
--- src-old/mame/drivers/balsente.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/balsente.c	2012-05-03 11:00:08.000000000 +0200
@@ -385,7 +385,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x38, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	/* Analog ports */
 	PORT_START("AN0")
diff -Nru src-old/mame/drivers/baraduke.c src/mame/drivers/baraduke.c
--- src-old/mame/drivers/baraduke.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/baraduke.c	2012-05-03 11:00:08.000000000 +0200
@@ -129,19 +129,19 @@
 	switch (m_inputport_selected)
 	{
 		case 0x00:	/* DSW A (bits 0-4) */
-			return (input_port_read(machine(), "DSWA") & 0xf8) >> 3;
+			return (ioport("DSWA")->read() & 0xf8) >> 3;
 		case 0x01:	/* DSW A (bits 5-7), DSW B (bits 0-1) */
-			return ((input_port_read(machine(), "DSWA") & 0x07) << 2) | ((input_port_read(machine(), "DSWB") & 0xc0) >> 6);
+			return ((ioport("DSWA")->read() & 0x07) << 2) | ((ioport("DSWB")->read() & 0xc0) >> 6);
 		case 0x02:	/* DSW B (bits 2-6) */
-			return (input_port_read(machine(), "DSWB") & 0x3e) >> 1;
+			return (ioport("DSWB")->read() & 0x3e) >> 1;
 		case 0x03:	/* DSW B (bit 7), DSW C (bits 0-3) */
-			return ((input_port_read(machine(), "DSWB") & 0x01) << 4) | (input_port_read(machine(), "EDGE") & 0x0f);
+			return ((ioport("DSWB")->read() & 0x01) << 4) | (ioport("EDGE")->read() & 0x0f);
 		case 0x04:	/* coins, start */
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 0x05:	/* 2P controls */
-			return input_port_read(machine(), "IN2");
+			return ioport("IN2")->read();
 		case 0x06:	/* 1P controls */
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 		default:
 			return 0xff;
 	}
diff -Nru src-old/mame/drivers/batman.c src/mame/drivers/batman.c
--- src-old/mame/drivers/batman.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/batman.c	2012-05-03 11:00:08.000000000 +0200
@@ -89,7 +89,7 @@
 
 READ16_MEMBER(batman_state::special_port2_r)
 {
-	int result = input_port_read(machine(), "260010");
+	int result = ioport("260010")->read();
 	if (m_sound_to_cpu_ready) result ^= 0x0010;
 	if (m_cpu_to_sound_ready) result ^= 0x0020;
 	return result;
@@ -180,7 +180,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNUSED )	/* Input buffer full (@260030) */
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )	/* Output buffer full (@260040) */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_INCLUDE( atarijsa_iii )		/* audio board port */
 INPUT_PORTS_END
diff -Nru src-old/mame/drivers/battlane.c src/mame/drivers/battlane.c
--- src-old/mame/drivers/battlane.c	2012-04-16 00:44:14.000000000 +0200
+++ src/mame/drivers/battlane.c	2012-05-03 11:00:08.000000000 +0200
@@ -137,7 +137,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:1,2")
diff -Nru src-old/mame/drivers/battlera.c src/mame/drivers/battlera.c
--- src-old/mame/drivers/battlera.c	2012-04-09 22:23:26.000000000 +0200
+++ src/mame/drivers/battlera.c	2012-05-03 11:00:08.000000000 +0200
@@ -51,11 +51,11 @@
 {
 	switch (m_control_port_select)
 	{
-		case 0xfe: return input_port_read(machine(), "IN0"); /* Player 1 */
-		case 0xfd: return input_port_read(machine(), "IN1"); /* Player 2 */
-		case 0xfb: return input_port_read(machine(), "IN2"); /* Coins */
-		case 0xf7: return input_port_read(machine(), "DSW2"); /* Dip 2 */
-		case 0xef: return input_port_read(machine(), "DSW1"); /* Dip 1 */
+		case 0xfe: return ioport("IN0")->read(); /* Player 1 */
+		case 0xfd: return ioport("IN1")->read(); /* Player 2 */
+		case 0xfb: return ioport("IN2")->read(); /* Coins */
+		case 0xf7: return ioport("DSW2")->read(); /* Dip 2 */
+		case 0xef: return ioport("DSW1")->read(); /* Dip 1 */
 	}
 
     return 0xff;
diff -Nru src-old/mame/drivers/bbusters.c src/mame/drivers/bbusters.c
--- src-old/mame/drivers/bbusters.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bbusters.c	2012-05-03 11:00:08.000000000 +0200
@@ -269,7 +269,7 @@
 {
 	static const char *const port[] = { "GUNX1", "GUNY1", "GUNX2", "GUNY2", "GUNX3", "GUNY3" };
 
-	UINT16 retdata = input_port_read(machine(), port[m_gun_select]);
+	UINT16 retdata = ioport(port[m_gun_select])->read();
 
 	retdata >>=1; // by lowering the precision of the gun reading hardware the game seems to work better
 
@@ -309,8 +309,8 @@
 {
 	int x, y;
 
-	x = input_port_read(machine(), offset ? "GUNX2" : "GUNX1");
-	y = input_port_read(machine(), offset ? "GUNY2" : "GUNY1");
+	x = ioport(offset ? "GUNX2" : "GUNX1")->read();
+	y = ioport(offset ? "GUNY2" : "GUNY1")->read();
 
 	/* Todo - does the hardware really clamp like this? */
 	x += 0x18;
diff -Nru src-old/mame/drivers/beaminv.c src/mame/drivers/beaminv.c
--- src-old/mame/drivers/beaminv.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/beaminv.c	2012-05-03 11:00:08.000000000 +0200
@@ -221,7 +221,7 @@
 
 READ8_MEMBER(beaminv_state::controller_r)
 {
-	return input_port_read(machine(), (m_controller_select == 1) ? P1_CONTROL_PORT_TAG : P2_CONTROL_PORT_TAG);
+	return ioport((m_controller_select == 1) ? P1_CONTROL_PORT_TAG : P2_CONTROL_PORT_TAG)->read();
 }
 
 
diff -Nru src-old/mame/drivers/beathead.c src/mame/drivers/beathead.c
--- src-old/mame/drivers/beathead.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/beathead.c	2012-05-03 11:00:08.000000000 +0200
@@ -256,7 +256,7 @@
 
 READ32_MEMBER( beathead_state::input_2_r )
 {
-	int result = input_port_read(machine(), "IN2");
+	int result = ioport("IN2")->read();
 	if (m_sound_to_cpu_ready) result ^= 0x10;
 	if (m_cpu_to_sound_ready) result ^= 0x20;
 	return result;
diff -Nru src-old/mame/drivers/berzerk.c src/mame/drivers/berzerk.c
--- src-old/mame/drivers/berzerk.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/berzerk.c	2012-05-03 11:00:08.000000000 +0200
@@ -426,7 +426,7 @@
 	int color;
 	double color_weights[2];
 
-	if (input_port_read(machine, MONITOR_TYPE_PORT_TAG) == 0)
+	if (machine.root_device().ioport(MONITOR_TYPE_PORT_TAG)->read() == 0)
 		compute_resistor_weights(0, 0xff, -1.0,
 								 2, resistances_wg, color_weights, 0, 270,
 								 2, resistances_wg, color_weights, 0, 270,
@@ -903,9 +903,9 @@
 	// one difference is it lacks the strobe input (does it?), which if not active causes
 	// the dial input to go open bus. This is used in moon war 2 to switch between player 1
 	// and player 2 dials, which share a single port. moonwarp uses separate ports for the dials.
-	signed char dialread = input_port_read(machine(),"P1_DIAL");
+	signed char dialread = ioport("P1_DIAL")->read();
 	UINT8 ret;
-	UINT8 buttons = (input_port_read(machine(),"P1")&0xe0);
+	UINT8 buttons = (ioport("P1")->read()&0xe0);
 	if (dialread < 0) m_p1_direction = 0;
 	else if (dialread > 0) m_p1_direction = 0x10;
 	m_p1_counter_74ls161 += abs(dialread);
@@ -918,9 +918,9 @@
 READ8_MEMBER(berzerk_state::moonwarp_p2_r)
 {
 	// same as above, but for player 2 in cocktail mode
-	signed char dialread = input_port_read(machine(),"P2_DIAL");
+	signed char dialread = ioport("P2_DIAL")->read();
 	UINT8 ret;
-	UINT8 buttons = (input_port_read(machine(),"P2")&0xe0);
+	UINT8 buttons = (ioport("P2")->read()&0xe0);
 	if (dialread < 0) m_p2_direction = 0;
 	else if (dialread > 0) m_p2_direction = 0x10;
 	m_p2_counter_74ls161 += abs(dialread);
diff -Nru src-old/mame/drivers/bfcobra.c src/mame/drivers/bfcobra.c
--- src-old/mame/drivers/bfcobra.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bfcobra.c	2012-05-03 11:00:08.000000000 +0200
@@ -914,7 +914,7 @@
 		}
 		case 0x22:
 		{
-			val = 0x40 | input_port_read(machine(), "JOYSTICK");
+			val = 0x40 | ioport("JOYSTICK")->read();
 			break;
 		}
 		default:
@@ -1433,7 +1433,7 @@
 
 				/* Clock is low */
 				if (!(data & 0x08))
-					m_mux_input = input_port_read(machine(), port[input_strobe]);
+					m_mux_input = ioport(port[input_strobe])->read();
 			}
 			break;
 		}
diff -Nru src-old/mame/drivers/bfm_sc1.c src/mame/drivers/bfm_sc1.c
--- src-old/mame/drivers/bfm_sc1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bfm_sc1.c	2012-05-03 19:38:32.000000000 +0200
@@ -205,7 +205,7 @@
 	{
 		state->m_irq_status = 0x01 |0x02; //0xff;
 
-	    state->m_sc1_Inputs[2] = input_port_read(device->machine(),"STROBE0");
+	    state->m_sc1_Inputs[2] = state->ioport("STROBE0")->read();
 
 		generic_pulse_irq_line(device->machine().device("maincpu"), M6809_IRQ_LINE, 1);
 	}
@@ -320,7 +320,7 @@
 
 READ8_MEMBER(bfm_sc1_state::dipcoin_r)
 {
-	return input_port_read(machine(),"STROBE0") & 0x1F;
+	return ioport("STROBE0")->read() & 0x1F;
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -444,7 +444,7 @@
 
 		if ( !(data & 0x08) )
 		{
-			m_sc1_Inputs[ input_strobe ] = input_port_read(machine(),portnames[input_strobe]);
+			m_sc1_Inputs[ input_strobe ] = ioport(portnames[input_strobe])->read();
 
 			m_mux1_input = m_sc1_Inputs[ input_strobe ];
 		}
@@ -1154,11 +1154,6 @@
 		stepper_config(machine, i, &starpoint_interface_48step);
 	}
 	if (decrypt) bfm_decode_mainrom(machine,"maincpu", state->m_codec_data);	// decode main rom
-	if (reels)
-	{
-		awp_reel_setup();
-	}
-
 
 	state->m_defaultbank = defaultbank;
 
diff -Nru src-old/mame/drivers/bfm_sc2.c src/mame/drivers/bfm_sc2.c
--- src-old/mame/drivers/bfm_sc2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bfm_sc2.c	2012-05-03 19:38:32.000000000 +0200
@@ -630,11 +630,11 @@
 		t1 = m_input_override[offset];	// strobe 0-7 data 0-4
 		t2 = m_input_override[offset+idx];	// strobe 8-B data 0-4
 
-		t1 = (m_sc2_Inputs[offset]   & t1) | ( ( input_port_read(machine(), port[offset])   & ~t1) & 0x1F);
+		t1 = (m_sc2_Inputs[offset]   & t1) | ( ( ioport(port[offset])->read()   & ~t1) & 0x1F);
 		if (idx == 8)
-			t2 = (m_sc2_Inputs[offset+8] & t2) | ( ( input_port_read(machine(), port[offset+8]) & ~t2) << 5);
+			t2 = (m_sc2_Inputs[offset+8] & t2) | ( ( ioport(port[offset+8])->read() & ~t2) << 5);
 		else
-			t2 =  (m_sc2_Inputs[offset+4] & t2) | ( ( ( input_port_read(machine(), port[offset+4]) & ~t2) << 2) & 0x60);
+			t2 =  (m_sc2_Inputs[offset+4] & t2) | ( ( ( ioport(port[offset+4])->read() & ~t2) << 2) & 0x60);
 
 		m_sc2_Inputs[offset]   = (m_sc2_Inputs[offset]   & ~0x1F) | t1;
 		m_sc2_Inputs[offset+idx] = (m_sc2_Inputs[offset+idx] & ~0x60) | t2;
@@ -857,7 +857,7 @@
 
 READ8_MEMBER(bfm_sc2_state::coin_input_r)
 {
-	return input_port_read(machine(), "COINS");
+	return ioport("COINS")->read();
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -1696,10 +1696,10 @@
 
 	PORT_MODIFY("STROBE11")
 	PORT_DIPNAME( 0x01, 0x00, "Credits required:" )PORT_DIPLOCATION("DIL:!12")
-	PORT_DIPSETTING(    0x00, "4 credits per game")PORT_CONDITION("STROBE10",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x01, "2 credits per game")PORT_CONDITION("STROBE10",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "1 credit  per round")PORT_CONDITION("STROBE10",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x01, "4 credits per round")PORT_CONDITION("STROBE10",0x10,PORTCOND_EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, "4 credits per game")PORT_CONDITION("STROBE10",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x01, "2 credits per game")PORT_CONDITION("STROBE10",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 credit  per round")PORT_CONDITION("STROBE10",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x01, "4 credits per round")PORT_CONDITION("STROBE10",0x10,EQUALS,0x10)
 	PORT_DIPNAME( 0x02, 0x00, "Attract Mode" )PORT_DIPLOCATION("DIL:!13")
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On  ) )
@@ -3753,10 +3753,6 @@
 	{
 		stepper_config(machine, n, &starpoint_interface_48step);
 	}
-	if (reels)
-	{
-		awp_reel_setup();
-	}
 }
 
 static DRIVER_INIT (bbrkfst)
diff -Nru src-old/mame/drivers/bfm_sc4.c src/mame/drivers/bfm_sc4.c
--- src-old/mame/drivers/bfm_sc4.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/bfm_sc4.c	2012-05-07 08:57:50.000000000 +0200
@@ -2457,8 +2457,36 @@
 	sc_cckey_others
 ROM_END
 
+ROM_START( sc4cckeyl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412918.lo", 0x00001, 0x080000, CRC(b268d275) SHA1(70b31512c0d8c8e0bf644fa1d5ea723c35c2a629) )
+    ROM_LOAD16_BYTE( "95412919.hi", 0x00000, 0x080000, CRC(d96df890) SHA1(65f8d2b4840efd5c3fe65b00ecbf2df7ac81cbe6) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4cckeym )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412920.lo", 0x00001, 0x080000, CRC(e047005e) SHA1(b3de1d863cda1945e1207b3df51a8b5172e65bb8) )
+    ROM_LOAD16_BYTE( "95412921.hi", 0x00000, 0x080000, CRC(7b903100) SHA1(1df4a5ded5cc195ee020f302870eb8bf4c8a14d3) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
+ROM_START( sc4cckeyn )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413918.lo", 0x00001, 0x080000, CRC(9062cdaa) SHA1(b8249ca6590aef5041315f1dbbdc019ffb5e8ac2) )
+    ROM_LOAD16_BYTE( "95413919.hi", 0x00000, 0x080000, CRC(de714343) SHA1(95f605d91e43c3bcd2a2799ecf385f1e75cc5413) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cckeyo )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413920.lo", 0x00001, 0x080000, CRC(deae622a) SHA1(7f8f7b93c734278d24f69fd4a491b3d4133d8b1d) )
+    ROM_LOAD16_BYTE( "95413921.hi", 0x00000, 0x080000, CRC(92671c85) SHA1(4444e3a54393f8fb824eeebfed8f2cbaf07e83ea) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
 
 ROM_START( sc4ckx )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -3110,7 +3138,19 @@
 	sc_crcp_others
 ROM_END
 
+ROM_START( sc4crcpi )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426474.lo", 0x00001, 0x080000, CRC(aa0a4d1d) SHA1(20ad278517287b3cbcd9f8275814635ea3ecb766) )
+    ROM_LOAD16_BYTE( "95426475.hi", 0x00000, 0x080000, CRC(ec216472) SHA1(19c4806834348d68e5d80234cd14ecde9cf8112c) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
+ROM_START( sc4crcpj )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427474.lo", 0x00001, 0x080000, CRC(e73365df) SHA1(6d8d918368350da76eec60b71c0dab6de7b970c7) )
+    ROM_LOAD16_BYTE( "95427475.hi", 0x00000, 0x080000, CRC(58fd6031) SHA1(beef4a6fd5e0d7bc68e9628073c0ce0035bd9168) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
 ROM_START( sc4crgc )
@@ -3522,10 +3562,43 @@
 	sc_cclim_others
 ROM_END
 
+ROM_START( sc4cclimq )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412772.lo", 0x00001, 0x080000, CRC(905a1d80) SHA1(04aee5ffb26a3f8c6def2f725f08ca1d8e6b61fd) )
+    ROM_LOAD16_BYTE( "95412773.hi", 0x00000, 0x080000, CRC(4aa622ee) SHA1(e999a9ae0e8ef2eb73a9115cd7bf7a8e3904a40b) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
+ROM_START( sc4cclimr )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412777.hi", 0x00000, 0x080000, CRC(e0e74ca2) SHA1(797fda3a4634bdd3f8ab0b31f7b880c8dbf23904) )
+    ROM_LOAD16_BYTE( "95412776.lo", 0x00001, 0x080000, CRC(4aac0ecd) SHA1(192cce8dfc93f44063134bae948d29d10528b83e) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
+ROM_START( sc4cclims )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412780.lo", 0x00001, 0x080000, CRC(978b1de6) SHA1(e601fbcb188a170f82b9e1092328cb5aea41b899) )
+    ROM_LOAD16_BYTE( "95412781.hi", 0x00000, 0x080000, CRC(7b241139) SHA1(62bbf20c3ad5ac251a0e0e017ca0b380ebf671b9) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cclimt )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413772.lo", 0x00001, 0x080000, CRC(3edcdd60) SHA1(40e30b4aba9fc05c781fba6a9d2089dcf1962a76) )
+    ROM_LOAD16_BYTE( "95413773.hi", 0x00000, 0x080000, CRC(6da80d25) SHA1(3467e24b60e0f6a7ae07555fc54a8a5bc3f25fed) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
+
+ROM_START( sc4cclimu )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413776.lo", 0x00001, 0x080000, CRC(4d339ce0) SHA1(f3152fbd69d277dd0e32179ab4f0c0b7148faa0b) )
+    ROM_LOAD16_BYTE( "95413777.hi", 0x00000, 0x080000, CRC(5875fc90) SHA1(996df61833df07f512c1039563917d40e6788f87) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
 ROM_START( sc4cfqps )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95402950.odd", 0x00001, 0x080000, CRC(f747af02) SHA1(1bb937c9af221c077f19045ab4c9cc8ec56011b1) )
@@ -3620,6 +3693,137 @@
 	sc_cfcla_others
 ROM_END
 
+
+ROM_START( sc4cfcasa )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95410450.lo", 0x00001, 0x080000, CRC(fc8a8427) SHA1(63bd12570a4f9d0a29e7e05a833976697db68e15) )
+    ROM_LOAD16_BYTE( "95410451.hi", 0x00000, 0x080000, CRC(99e8270f) SHA1(4529aecc88afc4739ddd5fd072241d577c455a8f) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasb )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95410453.hi", 0x00000, 0x080000, CRC(83ceb620) SHA1(a47f4972ef26593e0b9ce13ea4b3f1dc439925f5) )
+    ROM_LOAD16_BYTE( "95410452.lo", 0x00001, 0x080000, CRC(59a7f7cd) SHA1(1a40c341f4797e7ec8441f31bc83a59f37eba8fa) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasc )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95410530.lo", 0x00001, 0x080000, CRC(0559f269) SHA1(7c9766294f64f35e337796a24955d916231ed89d) )
+    ROM_LOAD16_BYTE( "95410531.hi", 0x00000, 0x080000, CRC(5f204ab2) SHA1(b4ba89d8d90175c68eac5346f51dd59465415d69) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasd )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95410532.lo", 0x00001, 0x080000, CRC(022b90e3) SHA1(dd8823b75a90896ee843139b696ee5e73f299a87) )
+    ROM_LOAD16_BYTE( "95410533.hi", 0x00000, 0x080000, CRC(af410ed5) SHA1(38bbd77789c9db49861dbf72cd23443ad5cfedfb) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcase )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95411450.lo", 0x00001, 0x080000, CRC(11cef6cf) SHA1(5364455b3ea34a11844b3b42c1a45a15c2bf126c) )
+    ROM_LOAD16_BYTE( "95411451.hi", 0x00000, 0x080000, CRC(f6d4c9e3) SHA1(5011b066375c7faa408ffbd1965c3b5d46836a72) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasf )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95411452.lo", 0x00001, 0x080000, CRC(9bd4d90f) SHA1(3a0c3e66a937ecf6d92cd2937a8d942cc40cf436) )
+    ROM_LOAD16_BYTE( "95411453.hi", 0x00000, 0x080000, CRC(d2c3aa4a) SHA1(a23c425f2df44525a4d1d95bdfd7ce4985f6a475) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasg )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95411530.lo", 0x00001, 0x080000, CRC(3543eb62) SHA1(d0b7afb5e731fbfd12109ba090037d98c69b8a26) )
+    ROM_LOAD16_BYTE( "95411531.hi", 0x00000, 0x080000, CRC(3c7955db) SHA1(41e92ed095c81e2f635d1a939c26bbe160eae756) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcash )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95411532.lo", 0x00001, 0x080000, CRC(525652ce) SHA1(da5a87c2ac2c2387f267837ceaaf6fbb42019036) )
+    ROM_LOAD16_BYTE( "95411533.hi", 0x00000, 0x080000, CRC(2834b509) SHA1(e50e94bda43814268d95cddb42a586bdf73b5efb) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasi )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412738.lo", 0x00001, 0x080000, CRC(3d4acd70) SHA1(3c8396c51b584bf651f7da99fba055ba39d22af9) )
+    ROM_LOAD16_BYTE( "95412739.hi", 0x00000, 0x080000, CRC(4d66828e) SHA1(456bd9038fb329c821eb4fd6d19fd41cc6d1ac93) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasj )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412740.lo", 0x00001, 0x080000, CRC(0840e5f9) SHA1(b5dfb30eb91e9f1133fd7ac58ff00186602fc64d) )
+    ROM_LOAD16_BYTE( "95412741.hi", 0x00000, 0x080000, CRC(23a85755) SHA1(5ed609ae4ac78294a11fbccd0a024513f97c7d72) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcask )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412754.lo", 0x00001, 0x080000, CRC(9a98fa55) SHA1(5db2401b1bf5904dffc771b54676e87c8eb279a7) )
+    ROM_LOAD16_BYTE( "95412755.hi", 0x00000, 0x080000, CRC(9495327b) SHA1(91571feb8d7718bee50ac29f29ef79628f9119cc) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412764.lo", 0x00001, 0x080000, CRC(46e535cc) SHA1(016232c6b235338f3affe913df08e13889d85f8d) )
+    ROM_LOAD16_BYTE( "95412765.hi", 0x00000, 0x080000, CRC(e907ee58) SHA1(9e9988b3c1f8fb4188a8e48338ece87a23181b87) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasm )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412766.lo", 0x00001, 0x080000, CRC(32339b1f) SHA1(5cdcf2e88bf887d7acc0a33b27ed722d5cba0dfd) )
+    ROM_LOAD16_BYTE( "95412767.hi", 0x00000, 0x080000, CRC(8f43e454) SHA1(c4fd0f210fc7074d435362162306b574d8a63d14) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+
+ROM_START( sc4cfcasn )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413738.lo", 0x00001, 0x080000, CRC(1367c7a9) SHA1(5089435b654173d3005d583fa530eda9a192937d) )
+    ROM_LOAD16_BYTE( "95413739.hi", 0x00000, 0x080000, CRC(eb8885e8) SHA1(0cc3d06956bfba56a1ed7315fe4fe3617d484b8f) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4cfcaso )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413740.lo", 0x00001, 0x080000, CRC(5a6465d1) SHA1(9981d9cf86514617a8aa3cb6730e0543b929399e) )
+    ROM_LOAD16_BYTE( "95413741.hi", 0x00000, 0x080000, CRC(7655f0d1) SHA1(9d64022d5ea8407eaa5a1d94dede93744845c83a) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasp )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413754.lo", 0x00001, 0x080000, CRC(17404e08) SHA1(d90399b069328200ff76663062dba12f3394e842) )
+    ROM_LOAD16_BYTE( "95413755.hi", 0x00000, 0x080000, CRC(861fb2d1) SHA1(2e4555e8754dbb758819dfa9c1a2e3eb09eacf5f) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasq )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413762.lo", 0x00001, 0x080000, CRC(f1e94a7f) SHA1(1c8e0579b61d558ee862b948df3c08812b61b3eb) )
+    ROM_LOAD16_BYTE( "95413763.hi", 0x00000, 0x080000, CRC(ec7006df) SHA1(164d2078b5a626c0a7d3aa176bc9ab5570e628c1) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4cfcasr )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413764.lo", 0x00001, 0x080000, CRC(0f652c25) SHA1(cf240682e214f1eaead7010d32a6056d8965a654) )
+    ROM_LOAD16_BYTE( "95413765.hi", 0x00000, 0x080000, CRC(3fc85422) SHA1(6f14fb68c327b52495386680d1de46006f1e4841) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
 ROM_START( sc4cfcla )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95408106.lo", 0x00001, 0x080000, CRC(72b84862) SHA1(971b67eaefc19b330e58a9fe81897fdf82c3a878) )
@@ -4145,8 +4349,36 @@
 	sc_crzky_others
 ROM_END
 
+ROM_START( sc4crzkyt )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412768.lo", 0x00001, 0x080000, CRC(8c0e64b9) SHA1(e67d84d384d4c5bb43c45768d538048fc456b90f) )
+    ROM_LOAD16_BYTE( "95412769.hi", 0x00000, 0x080000, CRC(e474d8fb) SHA1(55457253310084b51a7f0b3ad55cd56699505e66) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4crzkyu )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412770.lo", 0x00001, 0x080000, CRC(3d588dea) SHA1(0ccb0f2e4997340602ac095b94eb796a289e1125) )
+    ROM_LOAD16_BYTE( "95412771.hi", 0x00000, 0x080000, CRC(38deb018) SHA1(5ee9403b969dcccbc7387071923eb3bc4fab8c86) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4crzkyv )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413394.lo", 0x00001, 0x080000, CRC(482b8cd6) SHA1(aca9f1ac29d8323b215ed6b62621e357d03e6b60) )
+    ROM_LOAD16_BYTE( "95413395.hi", 0x00000, 0x080000, CRC(fecb656d) SHA1(99f52e5c61e71f032e579bc2bc08f415350459f8) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
 
 
+ROM_START( sc4crzkyw )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413396.lo", 0x00001, 0x080000, CRC(02cc445f) SHA1(2ca7589b403e2308d11de81400c4bd5811a3d1c1) )
+    ROM_LOAD16_BYTE( "95413397.hi", 0x00000, 0x080000, CRC(88774042) SHA1(3c75da111da7bdbf68bcbc08fc6db26122b04b0b) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
 
 ROM_START( sc4crzwl )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -4717,95 +4949,97 @@
 	sc_easy_others
 ROM_END
 
+ROM_START( sc4easyf )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "95407026.lo", 0x00001, 0x080000, CRC(3c207a4f) SHA1(9c8c100765b84ed50c2faa81b26efa8e639ef994) )
+	ROM_LOAD16_BYTE( "95407027.hi", 0x00000, 0x080000, CRC(d2819011) SHA1(410f40284b3d261d384e0017522518511f6ca105) )
+	sc_easy_others
+ROM_END
+
+
 ROM_START( sc4eascs )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406688.lo", 0x00001, 0x080000, CRC(ce13282c) SHA1(2e778af1de70d3e5d11df54ff85fc50645d85f08) )
 	ROM_LOAD16_BYTE( "95406689.hi", 0x00000, 0x080000, CRC(a05771f9) SHA1(7c234c49ad2d74ba150cc73da4adbfe733c5b224) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsa )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406690.lo", 0x00001, 0x080000, CRC(d72a4e94) SHA1(ef7ad4e2662b68679b84eb9418c1e9fb7c84e29c) )
 	ROM_LOAD16_BYTE( "95406691.hi", 0x00000, 0x080000, CRC(9ecd06c6) SHA1(83ef6bbd7a0c84b3e8c40217aa86d9c14b4521a5) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406884.lo", 0x00001, 0x080000, CRC(c17c9f70) SHA1(20c68c07be855e2f7aff1154072ad60140987c5a) )
 	ROM_LOAD16_BYTE( "95406885.hi", 0x00000, 0x080000, CRC(26702794) SHA1(06bcad6234be52f812b4fa3468adca13b16afbe4) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406886.lo", 0x00001, 0x080000, CRC(37e0a39a) SHA1(5430af8a09719883a16e88e3c63dfe4f67f7c231) )
 	ROM_LOAD16_BYTE( "95406887.hi", 0x00000, 0x080000, CRC(8e11985d) SHA1(7122d1fdf48953adee04d915f61be4e87d80cd26) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
-ROM_START( sc4easyf )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "95407026.lo", 0x00001, 0x080000, CRC(3c207a4f) SHA1(9c8c100765b84ed50c2faa81b26efa8e639ef994) )
-	ROM_LOAD16_BYTE( "95407027.hi", 0x00000, 0x080000, CRC(d2819011) SHA1(410f40284b3d261d384e0017522518511f6ca105) )
-	sc_easy_others
-ROM_END
 
 ROM_START( sc4eascsd )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407688.lo", 0x00001, 0x080000, CRC(802b17b9) SHA1(ee56083fdb1d45c27095c7561690d1a39154c0e6) )
 	ROM_LOAD16_BYTE( "95407689.hi", 0x00000, 0x080000, CRC(713a971c) SHA1(05cd1f6feec4c5296fe9da82a860d56117939cdb) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascse )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407690.lo", 0x00001, 0x080000, CRC(37218f3f) SHA1(3fe41a27f60b621f4d39eb8c9cc27a56481227b5) )
 	ROM_LOAD16_BYTE( "95407691.hi", 0x00000, 0x080000, CRC(1986504b) SHA1(126fc4486bcd2931849b2b51c694bb54403d7a8e) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsf )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407884.lo", 0x00001, 0x080000, CRC(24c50f8a) SHA1(75f98fc5dcffad2f47c012be66c157bd73f00cf3) )
 	ROM_LOAD16_BYTE( "95407885.hi", 0x00000, 0x080000, CRC(c3e37e0e) SHA1(eebd6264ee9efb955fee96017af2ea2678bbca8b) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsg )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407886.lo", 0x00001, 0x080000, CRC(3a41067c) SHA1(2e776a26a2436ba969220bf41832875a9bcd588c) )
 	ROM_LOAD16_BYTE( "95407887.hi", 0x00000, 0x080000, CRC(8c087f60) SHA1(4c0624d4c56d64008b12c8435f901fb732bbe506) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsh )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1326p11.hi", 0x00000, 0x080000, CRC(873c7a05) SHA1(201c287c36bf11832ea3736cee7a4b8bbe9f4254) )
 	ROM_LOAD16_BYTE( "p1326p11.lo", 0x00001, 0x080000, CRC(14101cd8) SHA1(b808c8447047b98306843e01fa3f2722e9d37769) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsi )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1326p41.hi", 0x00000, 0x080000, CRC(490e389d) SHA1(e1cfe5a64804662e637e3f05eea13902e4ba55a8) )
 	ROM_LOAD16_BYTE( "p1326p41.lo", 0x00001, 0x080000, CRC(764150c3) SHA1(1f22f22c72379ec9c1ca0da787366a8368c56303) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsj )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1326s11.hi", 0x00000, 0x080000, CRC(ae417ea4) SHA1(ba3876cfc9d7787d3a14b100f3f9e185b08cd207) )
 	ROM_LOAD16_BYTE( "p1326s11.lo", 0x00001, 0x080000, CRC(3a5cbcd0) SHA1(c36979d9b0045dbb103a665bde5a97a0a4a3b9b0) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 ROM_START( sc4eascsk )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1326s41.hi", 0x00000, 0x080000, CRC(e74d9798) SHA1(67a43317844a455addb624deea516354854ee0a8) )
 	ROM_LOAD16_BYTE( "p1326s41.lo", 0x00001, 0x080000, CRC(b74196f7) SHA1(67ab1a115bb2656951f187f47d6c4b9dca7481c0) )
-	sc_easy_others
+	PR1326_CAS_EASY_STREAK_SOUNDS11
 ROM_END
 
 
@@ -8669,6 +8903,33 @@
 	sc_luckb_others
 ROM_END
 
+ROM_START( sc4luckb1 )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412784.lo", 0x00001, 0x080000, CRC(5aa0e877) SHA1(61f5feb82da6120e9dc1e035ecc5014c0312cfe5) )
+    ROM_LOAD16_BYTE( "95412785.hi", 0x00000, 0x080000, CRC(71a8f0a7) SHA1(f15e021e2fd036e3b8e6df527dce247dcbcae183) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4luckb2 )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412786.lo", 0x00001, 0x080000, CRC(ef399481) SHA1(46f896e061b1e0952f344d8263733b4767f4fd33) )
+    ROM_LOAD16_BYTE( "95412787.hi", 0x00000, 0x080000, CRC(afba8e8f) SHA1(5263a8909e930eba04c9d2dd3cc561bc05dd98bc) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4luckb3 )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413784.lo", 0x00001, 0x080000, CRC(1f6e5750) SHA1(bf66ec55f95263b9609d540ff80ff6e30b412c8f) )
+    ROM_LOAD16_BYTE( "95413785.hi", 0x00000, 0x080000, CRC(1d94f72f) SHA1(cdb6f996738d24c5067930ef24699d851a0bbdc6) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4luckb4 )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413786.lo", 0x00001, 0x080000, CRC(afb1726c) SHA1(676e27a33da21a728129d179339aab761485b22d) )
+    ROM_LOAD16_BYTE( "95413787.hi", 0x00000, 0x080000, CRC(c3a6cc83) SHA1(399629c1a80790d4590b97d800f4dcf0ff7f7180) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
 
@@ -9011,74 +9272,103 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406738.lo", 0x00001, 0x080000, CRC(91e156b8) SHA1(3439f79e68c445960cf41b1f8a2b60e166e28024) )
 	ROM_LOAD16_BYTE( "95406739.hi", 0x00000, 0x080000, CRC(2e2ba90c) SHA1(cc09e392dbba2f75ed72fbff8c0ec6e47922cc0b) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11
 ROM_END
 
 ROM_START( sc4mgra )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407738.lo", 0x00001, 0x080000, CRC(6a1a091d) SHA1(93371ab90612ae6000d3cc6c3ddca8f90db803db) )
 	ROM_LOAD16_BYTE( "95407739.hi", 0x00000, 0x080000, CRC(cf883e87) SHA1(74edbaff54944f2a1ed6e7d99bbd9047dbd9fb4b) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11
+ROM_END
+
+ROM_START( sc4mgrh )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "p1132p72.hi", 0x00000, 0x080000, CRC(9cbaee34) SHA1(1d5713a4cd1f74c97b0879c2850fa994639f2370) )
+	ROM_LOAD16_BYTE( "p1132p72.lo", 0x00001, 0x080000, CRC(fb327c69) SHA1(b799290d2e4d0f071e7d97ab4817d8fdc14f9c2c) )
+	PR1132_MONEY_GO_ROUND_SOUNDS11
+ROM_END
+
+ROM_START( sc4mgri )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "p1132s72.hi", 0x00000, 0x080000, CRC(06f9462c) SHA1(865c4cab26b9265e0da1e53bdbd9fa1df1e1ea34) )
+	ROM_LOAD16_BYTE( "p1132s72.lo", 0x00001, 0x080000, CRC(3392c0b4) SHA1(231cd4ad13cb71d44e1bb0d6b4eb22ecd5240d8c) )
+	PR1132_MONEY_GO_ROUND_SOUNDS11
 ROM_END
 
 ROM_START( sc4mgrb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95410592.lo", 0x00001, 0x080000, CRC(578476ff) SHA1(ca115ed9a04efea369de6dbc7e0c999b0276e24e) )
 	ROM_LOAD16_BYTE( "95410593.hi", 0x00000, 0x080000, CRC(63bc7162) SHA1(15629023e84ae7a1b19201d24c0f74edd45c05e3) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
 ROM_START( sc4mgrc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95410594.lo", 0x00001, 0x080000, CRC(5d5ef370) SHA1(46253f4e6ac2b226b9cfb0c318dc3537700ab3db) )
 	ROM_LOAD16_BYTE( "95410595.hi", 0x00000, 0x080000, CRC(b24010eb) SHA1(ea3ea23665a5b9dcc5f861aad720313f832ee248) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
 ROM_START( sc4mgrd )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95411592.lo", 0x00001, 0x080000, CRC(d7865d1f) SHA1(203ef7d6ed1babd74c2d5dcc497347fa13a4c909) )
 	ROM_LOAD16_BYTE( "95411593.hi", 0x00000, 0x080000, CRC(57ceb99e) SHA1(6997e1e3dbe389d990c97eebd7397546e33bfb73) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
 ROM_START( sc4mgre )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95411594.lo", 0x00001, 0x080000, CRC(34ec80ae) SHA1(61373d443505f7656e56d1f0fe0ffdc61153db47) )
 	ROM_LOAD16_BYTE( "95411595.hi", 0x00000, 0x080000, CRC(78f7e5f8) SHA1(4993018f22d7223b1b0e1ed11899564298d666e6) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
 ROM_START( sc4mgrf )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95412214.lo", 0x00001, 0x080000, CRC(569b2591) SHA1(0e5c1e14e9b8de49e02a1efc02f50b6d632a2fa5) )
 	ROM_LOAD16_BYTE( "95412215.hi", 0x00000, 0x080000, CRC(cff9aefa) SHA1(c8a973429cec99010a4886ad88cde820ecbdf435) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
 ROM_START( sc4mgrg )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95413214.lo", 0x00001, 0x080000, CRC(645e63ff) SHA1(78e7e7a210eed5e8086483f7e8dac2a8f2cc4b91) )
 	ROM_LOAD16_BYTE( "95413215.hi", 0x00000, 0x080000, CRC(1ce43623) SHA1(9748d4df64f4282a141ca2907630badfdeb5c3bd) )
-	sc_mgr_others
+	PR1132_MONEY_GO_ROUND_SOUNDS11_ALT
 ROM_END
 
-ROM_START( sc4mgrh )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "p1132p72.hi", 0x00000, 0x080000, CRC(9cbaee34) SHA1(1d5713a4cd1f74c97b0879c2850fa994639f2370) )
-	ROM_LOAD16_BYTE( "p1132p72.lo", 0x00001, 0x080000, CRC(fb327c69) SHA1(b799290d2e4d0f071e7d97ab4817d8fdc14f9c2c) )
-	sc_mgr_others
+
+
+ROM_START( sc4mgrj )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412804.lo", 0x00001, 0x080000, CRC(0948aa27) SHA1(14a779bbe176e525b53ce9c7a0ac46d043afb47d) )
+    ROM_LOAD16_BYTE( "95412805.hi", 0x00000, 0x080000, CRC(5e7bf5e1) SHA1(f03880f80a154c408717c8d53121d1bde2e62ab5) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
 ROM_END
 
-ROM_START( sc4mgri )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "p1132s72.hi", 0x00000, 0x080000, CRC(06f9462c) SHA1(865c4cab26b9265e0da1e53bdbd9fa1df1e1ea34) )
-	ROM_LOAD16_BYTE( "p1132s72.lo", 0x00001, 0x080000, CRC(3392c0b4) SHA1(231cd4ad13cb71d44e1bb0d6b4eb22ecd5240d8c) )
-	sc_mgr_others
+
+ROM_START( sc4mgrk )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412808.lo", 0x00001, 0x080000, CRC(e500f4cf) SHA1(3d0738ab1b927887f257fe063b57ee4a76be6808) )
+    ROM_LOAD16_BYTE( "95412809.hi", 0x00000, 0x080000, CRC(4556db34) SHA1(a06dfa1a2389f0ae185b6cc520b7dca75dd9dd6a) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
 ROM_END
 
+ROM_START( sc4mgrl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413804.lo", 0x00001, 0x080000, CRC(9c1261ca) SHA1(50cce10f8736e982346aba313abd2e761d7286fc) )
+    ROM_LOAD16_BYTE( "95413805.hi", 0x00000, 0x080000, CRC(ae77f9cf) SHA1(e88d82e8711b81dce306db558c03141699b2a813) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
+ROM_START( sc4mgrm )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413808.lo", 0x00001, 0x080000, CRC(80630b04) SHA1(9393d9be92aca4eb4f4a774868fe8b6698139b67) )
+    ROM_LOAD16_BYTE( "95413809.hi", 0x00000, 0x080000, CRC(cf0a0b46) SHA1(434acbbe97748b96853f288b14cebcce02151515) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
 
@@ -10507,31 +10797,43 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95422368.lo", 0x00001, 0x080000, CRC(3d34c353) SHA1(9bab4bf469ed5c877bfb567e0cc4155b0dc37ac1) )
 	ROM_LOAD16_BYTE( "95422369.hi", 0x00000, 0x080000, CRC(98b01d37) SHA1(cd7d8334c7dd0078cebf066cc1ae0cc503743036) )
-	sc_pogbl_others
+	PR3082_C_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogbla )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95422932.lo", 0x00001, 0x080000, CRC(2c5ea61c) SHA1(56a8e6b8392ca76c864eab8060ce1cfbe04b9e54) )
 	ROM_LOAD16_BYTE( "95422933.hi", 0x00000, 0x080000, CRC(ec3d6a90) SHA1(5b030940775fdb4286efdd7357a276707d9eabde) )
-	sc_pogbl_others
+	PR3082_C_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogblb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95423368.lo", 0x00001, 0x080000, CRC(0c9a2240) SHA1(eab6b824b87a570b4236b649d138bb6babf6d766) )
 	ROM_LOAD16_BYTE( "95423369.hi", 0x00000, 0x080000, CRC(dd96eb1f) SHA1(c2fae68a39ddf476ac11fc03158ed5ecfbc6fc1a) )
-	sc_pogbl_others
+	PR3082_C_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogblc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95423932.lo", 0x00001, 0x080000, CRC(03cacc64) SHA1(99b776c529115da34413b507cdc20491bfdbd09e) )
 	ROM_LOAD16_BYTE( "95423933.hi", 0x00000, 0x080000, CRC(45faea1b) SHA1(1c6d8072086e2e0345bbae42978338eaa15e8304) )
-	sc_pogbl_others
+	PR3082_C_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
+ROM_START( sc4pogbld )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426590.lo", 0x00001, 0x080000, CRC(4bd1ca29) SHA1(9d9a3e14027b259c614780681d337d9004e5dbfd) )
+    ROM_LOAD16_BYTE( "95426591.hi", 0x00000, 0x080000, CRC(3e550a37) SHA1(48e2371953744e2d3b59833388be66484293dfe9) )
+    PR3082_C_POTS_OF_GOLD_SOUNDS11
+ROM_END
 
+ROM_START( sc4pogble )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427590.lo", 0x00001, 0x080000, CRC(0a7f6c5f) SHA1(cf8eb884d1980a1e136d2b1e52ba4d7dc7904896) )
+    ROM_LOAD16_BYTE( "95427591.hi", 0x00000, 0x080000, CRC(8802578a) SHA1(71c16bb83b858d42846703387976460812234771) )
+    PR3082_C_POTS_OF_GOLD_SOUNDS11
+ROM_END
 
 
 ROM_START( sc4pwcrz )
@@ -14072,21 +14374,21 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95404686.lo", 0x00001, 0x080000, CRC(f3d7d462) SHA1(3de86eab8cab50924d5186b57863260dfd555bd7) )
 	ROM_LOAD16_BYTE( "95404687.hi", 0x00000, 0x080000, CRC(07d6f891) SHA1(1b5ce61733b3c2adbda439dbca857693d34e3022) )
-	sc_vmclb_others
+	PR7132_CLUB_VIVA_SOUNDS11
 ROM_END
 
 ROM_START( sc4vmclba )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "viva_mex.hi", 0x00000, 0x080000, CRC(521cea58) SHA1(a2a193c23843195e6f7ef666f3785869e11c9baa) )
 	ROM_LOAD16_BYTE( "viva_mex.lo", 0x00001, 0x080000, CRC(ca5260f1) SHA1(1f2901e76db3c2cd615cf1efafc7e965c1ac48f1) )
-	sc_vmclb_others
+	PR7132_CLUB_VIVA_SOUNDS11
 ROM_END
 
 ROM_START( sc4vmclbb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95405686.lo", 0x00001, 0x080000, CRC(5852e489) SHA1(987918f92b2cd53e09696ccf795f0e50ee44cde4) )
 	ROM_LOAD16_BYTE( "95405687.hi", 0x00000, 0x080000, CRC(c73c6888) SHA1(6be3c7285ec975a4798c9ff9d59da3466e3b545a) )
-	sc_vmclb_others
+	PR7132_CLUB_VIVA_SOUNDS11
 ROM_END
 
 
@@ -14448,6 +14750,35 @@
 ROM_END
 
 
+ROM_START( sc4wldbnn )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412798.lo", 0x00001, 0x080000, CRC(b1faf86e) SHA1(59d28f3cc7e6102b6ab30cf8f3cf3ff330400935) )
+    ROM_LOAD16_BYTE( "95412799.hi", 0x00000, 0x080000, CRC(154696d1) SHA1(e36ac082a4d9217609d480c8ebe2a62ca5e05030) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4wldbno )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412802.lo", 0x00001, 0x080000, CRC(0707c737) SHA1(ab2b5654593af4b2ef3b967b922a140d254832cd) )
+    ROM_LOAD16_BYTE( "95412803.hi", 0x00000, 0x080000, CRC(7cba6d55) SHA1(7770f2cb130f54f4f43004b78e1494d0d067f444) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4wldbnp )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413798.lo", 0x00001, 0x080000, CRC(78d31c7e) SHA1(4ce9b96b039c2e70b53b7446cc7701cfa0d21f69) )
+    ROM_LOAD16_BYTE( "95413799.hi", 0x00000, 0x080000, CRC(969a883b) SHA1(9e23f39bdb3ac8819f2910d3ae86ffc63e36d78b) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4wldbnq )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413802.lo", 0x00001, 0x080000, CRC(cda11a90) SHA1(fcf4728cbc93b537283b06f7234dfdd1b1c986fe) )
+    ROM_LOAD16_BYTE( "95413803.hi", 0x00000, 0x080000, CRC(4e53c2cc) SHA1(9f844af4abb60c4616c840075e7f7bbadaad70be) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
 ROM_START( sc4wthng )
@@ -16030,6 +16361,13 @@
 ROM_END
 
 
+ROM_START( sc4cblasa )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95418020.lo", 0x00001, 0x080000, CRC(156f98d1) SHA1(7f7af9b194bd2866f82c7fcd6a19196b2bc7451c) )
+    ROM_LOAD16_BYTE( "95418021.hi", 0x00000, 0x080000, CRC(b6a36c59) SHA1(4d0764c1cf3a0036379e29fee244a075a4412800) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
 
 ROM_START( sc4casxt )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -16724,6 +17062,19 @@
 	PR1907_DEAL_OR_NO_DEAL_SOUNDS11
 ROM_END
 
+ROM_START( sc4dndcsd )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95422796.lo", 0x00001, 0x080000, CRC(e868d7b2) SHA1(9bfab76066bdd8c0189a3b076cb5fcaf9b319974) )
+    ROM_LOAD16_BYTE( "95422797.hi", 0x00000, 0x080000, CRC(7814d075) SHA1(2a5b3e2e9c6a2a1823ce952d978287c012e6bdb8) )
+	PR1907_DEAL_OR_NO_DEAL_SOUNDS11
+ROM_END
+
+ROM_START( sc4dndcse )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423796.lo", 0x00001, 0x080000, CRC(804c03c4) SHA1(f73c9655c1206334afeb6bbd73bd24579eb1d67c) )
+    ROM_LOAD16_BYTE( "95423797.hi", 0x00000, 0x080000, CRC(c5b8ef0a) SHA1(5ae7be45364c8db8425b1ea08d8705c1fe2e032a) )
+	PR1907_DEAL_OR_NO_DEAL_SOUNDS11
+ROM_END
 
 
 ROM_START( sc4dndbb )
@@ -16984,8 +17335,26 @@
 	sc_dndhf_others
 ROM_END
 
-
-
+ROM_START( sc4dndhfj )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423799.hi", 0x00000, 0x080000, CRC(922bf36c) SHA1(18bb9e38340dd0fd7e95fc0f70d0a47ef98f6d9c) )
+    ROM_LOAD16_BYTE( "95423798.lo", 0x00001, 0x080000, CRC(310e7ab7) SHA1(8ec44acd16dbe22837d365970e496640d1250355) )
+    sc_dndhf_others
+ROM_END
+
+ROM_START( sc4dndhfk )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95428082.lo", 0x00001, 0x080000, CRC(161690d0) SHA1(a9eb5d47b067897803814f7c5d5e3436002f278b) )
+    ROM_LOAD16_BYTE( "95428083.hi", 0x00000, 0x080000, CRC(72520ead) SHA1(bbaeeaddc98530eb879596a4526d0101a7912d20) )
+    sc_dndhf_others
+ROM_END
+
+ROM_START( sc4dndhfl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95429082.lo", 0x00001, 0x080000, CRC(5172b542) SHA1(f460fe62b12d709d528135603252951d306c64c9) )
+    ROM_LOAD16_BYTE( "95429083.hi", 0x00000, 0x080000, CRC(26040dae) SHA1(9302efb1a92e5c31dc22d0a6b4cc51f26c4bf5ab) )
+    sc_dndhf_others
+ROM_END
 
 
 ROM_START( sc4dndys )
@@ -17009,7 +17378,12 @@
 	sc_dndys_others
 ROM_END
 
-
+ROM_START( sc4dndysc )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426066.lo", 0x00001, 0x080000, CRC(9f388484) SHA1(abbf996d8dfca49302eada0d669477ceb6a74706) )
+    ROM_LOAD16_BYTE( "95426067.hi", 0x00000, 0x080000, CRC(9f5164c4) SHA1(ed68a46a05bcca3ed1478b6a31ca59cd870ebf7e) )
+	sc_dndys_others
+ROM_END
 
 ROM_START( sc4dndlp )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -18030,6 +18404,19 @@
 	sc_fguy_others
 ROM_END
 
+ROM_START( sc4fguyd )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426070.lo", 0x00001, 0x080000, CRC(fa164ebd) SHA1(b50b261ea503b1f56b99d692805fb90ca67e22e6) )
+    ROM_LOAD16_BYTE( "95426071.hi", 0x00000, 0x080000, CRC(304dc4dc) SHA1(045f639ffae4ac54e6554ca5c9a11516f0561e64) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4fguye )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427070.lo", 0x00001, 0x080000, CRC(916479f9) SHA1(d9f9a48c671ba046469ddcdcdfbf6de0c7ec703d) )
+    ROM_LOAD16_BYTE( "95427071.hi", 0x00000, 0x080000, CRC(85306584) SHA1(f844c345330b5d0983dacb693aa5bacaf5fd60b5) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 ROM_START( sc4fbspn )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -19084,6 +19471,36 @@
 	PR1327_CAS_HAPPY_NOTES_SOUNDS11
 ROM_END
 
+ROM_START( sc4hntcsp )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412788.lo", 0x00001, 0x080000, CRC(0d8a0e36) SHA1(258ec8aea8f820919e106eda3e774054bb3758cb) )
+    ROM_LOAD16_BYTE( "95412789.hi", 0x00000, 0x080000, CRC(0b15f31a) SHA1(051e047374fc3848a052b85bc54fb2a940fcd2f5) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4hntcsq )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95412792.lo", 0x00001, 0x080000, CRC(bebb8a6d) SHA1(e1009ff6af9f9cf5df3d3f35dcac254e9ba25a84) )
+    ROM_LOAD16_BYTE( "95412793.hi", 0x00000, 0x080000, CRC(fd18bea6) SHA1(94f3cf2ed593705a3caa788b3b55864f5726bb75) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4hntcsr )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413788.lo", 0x00001, 0x080000, CRC(223e4033) SHA1(47a335ef0d6964c7ef2ab8e4308323ac9269d98b) )
+    ROM_LOAD16_BYTE( "95413789.hi", 0x00000, 0x080000, CRC(51709e9c) SHA1(d9e3b4ebcf7acf0fc8bc546019b93338fe1a60e6) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( sc4hntcss )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95413792.lo", 0x00001, 0x080000, CRC(1dfb13f0) SHA1(aab4c67090ea5024fe8ac1b36855398cbd8f0eed) )
+    ROM_LOAD16_BYTE( "95413793.hi", 0x00000, 0x080000, CRC(57bf0935) SHA1(34ed890464aafd08e41d622367cc82898e9e07de) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 
 ROM_START( sc4hellb )
@@ -19479,6 +19896,19 @@
 	sc_ijob_others
 ROM_END
 
+ROM_START( sc4ijobl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426078.lo", 0x00001, 0x080000, CRC(42ea72a3) SHA1(da088b0322fe3fc89348f63d7b342d68be37906b) )
+    ROM_LOAD16_BYTE( "95426079.hi", 0x00000, 0x080000, CRC(49c8cf07) SHA1(af9a27e36ca5652ac542ad69b9987dd454b5bb7d) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+ROM_START( sc4ijobm )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427079.hi", 0x00000, 0x080000, CRC(ff90a41d) SHA1(cc3011bdee10214c2de15683c436f1819a3b0e89) )
+    ROM_LOAD16_BYTE( "95427078.lo", 0x00001, 0x080000, CRC(9b27c381) SHA1(f9a66f13d3ea1ca206ec2904e6944ed41fe83e63) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 ROM_START( sc4jjok )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -20366,7 +20796,26 @@
 	sc_mhp_others
 ROM_END
 
-
+ROM_START( sc4mhpl )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95419854.lo", 0x00001, 0x080000, CRC(8a7b8323) SHA1(7927df3bb734548c8464ca94a188f597b4d8f6aa) )
+    ROM_LOAD16_BYTE( "95419855.hi", 0x00000, 0x080000, CRC(52609c25) SHA1(af11b20e91f1a70dedd9570e9a14a6ff769641cc) )
+    sc_mhp_others
+ROM_END
+
+ROM_START( sc4mhpm )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95422770.lo", 0x00001, 0x080000, CRC(7aa35ca2) SHA1(67be41eb0d19b4bf1e5013249f08eb761c5c1276) )
+    ROM_LOAD16_BYTE( "95422771.hi", 0x00000, 0x080000, CRC(30a79dad) SHA1(4854f4427cf46bbe874b2937c22261df4c21af4e) )
+    sc_mhp_others
+ROM_END
+
+ROM_START( sc4mhpn )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423770.lo", 0x00001, 0x080000, CRC(fb478f7a) SHA1(cbf813b0ccfcaf6ce1a241c9479dc75d3623043c) )
+    ROM_LOAD16_BYTE( "95423771.hi", 0x00000, 0x080000, CRC(6217ded1) SHA1(c96041c00211a0cc938267cc39e968cdb93b48f0) )
+   sc_mhp_others
+ROM_END
 
 
 ROM_START( sc4mmb )
@@ -20906,69 +21355,89 @@
 	sc_popey_others
 ROM_END
 
+ROM_START( sc4popeyd )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426090.lo", 0x00001, 0x080000, CRC(f2439f57) SHA1(28c85aa4af37e0b6f4e593758c290d1dfabc01b3) )
+    ROM_LOAD16_BYTE( "95426091.hi", 0x00000, 0x080000, CRC(7fd3b733) SHA1(0f3fe3048c4b258c44b6f664249a16885033e242) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
+ROM_START( sc4popeye )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427090.lo", 0x00001, 0x080000, CRC(d18c6d3c) SHA1(5173df9b9c7a260153f03fa363eedad5eb3f3799) )
+    ROM_LOAD16_BYTE( "95427091.hi", 0x00000, 0x080000, CRC(6476ffc9) SHA1(ade7583943bd32bcada8d0cb33489ab50471f2e7) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
 
 ROM_START( sc4pog )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95418748.lo", 0x00001, 0x080000, CRC(e4532be2) SHA1(8e30052f398da4b5503f43b4da84515aea0609e4) )
 	ROM_LOAD16_BYTE( "95418749.hi", 0x00000, 0x080000, CRC(ddd43bef) SHA1(e8a987a01d3d5ec34fbb2f7751ae0c5738fe2d0e) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
-
-
 ROM_START( sc4poga )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95418832.lo", 0x00001, 0x080000, CRC(8cf1e293) SHA1(c3dcb8da31a4509b6845f0c3df9058f82a369919) )
 	ROM_LOAD16_BYTE( "95418833.hi", 0x00000, 0x080000, CRC(d314c0ae) SHA1(06307af500d28d05518c67f554955567d2d0e1ca) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95419748.lo", 0x00001, 0x080000, CRC(4a18ab52) SHA1(9230678bf1103a509a6d633ee23f314cee98df4b) )
 	ROM_LOAD16_BYTE( "95419749.hi", 0x00000, 0x080000, CRC(b288ef47) SHA1(419f22abe8bd8b5dd79e5b1610a6c4551af1abe8) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
-
-
 ROM_START( sc4pogc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95419832.lo", 0x00001, 0x080000, CRC(7e455361) SHA1(5f0ecd8ff94c720b378ea5b7523b9a8fc89e10c4) )
 	ROM_LOAD16_BYTE( "95419833.hi", 0x00000, 0x080000, CRC(36999e53) SHA1(e818fd7f758f312fe1308bd9c448e70b02fb991e) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogd )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95422098.lo", 0x00001, 0x080000, CRC(df9436de) SHA1(007f9b44c213975114e93300482238ecfb22e62e) )
 	ROM_LOAD16_BYTE( "95422099.hi", 0x00000, 0x080000, CRC(f943ec13) SHA1(d422a99531ae4ef7b04faa63aae3fa19b5135e7c) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4poge )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95423098.lo", 0x00001, 0x080000, CRC(5115ce33) SHA1(0038f1b1f7849f526ad857a0613ae5d9fd0160fe) )
 	ROM_LOAD16_BYTE( "95423099.hi", 0x00000, 0x080000, CRC(8f28229d) SHA1(c3a26273baf1c081cedc01446846115acad1e318) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogf )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1938p42.hi", 0x00000, 0x080000, CRC(c5798bd9) SHA1(4031e72a04db4b8a0248c47a62ec2e9c275e8b73) )
 	ROM_LOAD16_BYTE( "p1938p42.lo", 0x00001, 0x080000, CRC(72bfe669) SHA1(8f9b384c67cb0ee70b004195b05a4271a9a08ffe) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc4pogg )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p1938s42.hi", 0x00000, 0x080000, CRC(ae02b67f) SHA1(c873985cc941a6ce334b4ce23db1117bcaf95fad) )
 	ROM_LOAD16_BYTE( "p1938s42.lo", 0x00001, 0x080000, CRC(4e80e631) SHA1(8fe73e1fa1961b1ea693e394f88e453daf065305) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
+ROM_START( sc4pogh )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95422750.lo", 0x00001, 0x080000, CRC(72e10a5e) SHA1(2182fe643ae0442b1a116737d3a8c37af783a58f) )
+    ROM_LOAD16_BYTE( "95422751.hi", 0x00000, 0x080000, CRC(2c304af5) SHA1(fc2d659c0c372b9f2516cd60a4b0c568992288c7) )
+    PR1918_POTS_OF_GOLD_SOUNDS11
+ROM_END
 
+ROM_START( sc4pogi )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423750.lo", 0x00001, 0x080000, CRC(70582a43) SHA1(c84b5fdb729abc7f1ea82857bd717013199b04a4) )
+    ROM_LOAD16_BYTE( "95423751.hi", 0x00000, 0x080000, CRC(92f59096) SHA1(53f2ee3f11e119ca0daa7305f52f31e22a6f8315) )
+    PR1918_POTS_OF_GOLD_SOUNDS11
+ROM_END
 
 ROM_START( sc4pwrpl )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
@@ -21429,6 +21898,14 @@
 	sc_showt_others
 ROM_END
 
+ROM_START( sc4showtf )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423654.lo", 0x00001, 0x080000, CRC(15648452) SHA1(72619130fbcde1fb0b2f90f02769cbd0f6f1e64e) )
+    ROM_LOAD16_BYTE( "95423655.hi", 0x00000, 0x080000, CRC(9f6c934b) SHA1(28315b8bdc91355506ca150e1aeb3161e573bc5c) )
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00)
+ROM_END
+
+
 ROM_START( sc4slad )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95410302.lo", 0x00001, 0x080000, CRC(e32e673f) SHA1(a7ca66b1f7a0d82980ee897833adf0841ee7e112) )
@@ -21888,84 +22365,86 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95400703.lo", 0x00001, 0x080000, CRC(611bee94) SHA1(207bad11a23fd88258ceb8adccd24ca09dd35600) )
 	ROM_LOAD16_BYTE( "95400704.hi", 0x00000, 0x080000, CRC(62c4d22d) SHA1(e6a75ab77cdb01399f87a6b17d1f6b240c8e3fb2) )
-	sc_vivam_others
+	PR6907_VIVA_MEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc4vivama )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95400705.lo", 0x00001, 0x080000, CRC(23f82b23) SHA1(9a18705864c53609164720f48017a3f758e3c07e) )
 	ROM_LOAD16_BYTE( "95400706.hi", 0x00000, 0x080000, CRC(254244ea) SHA1(a861ff07ddefcc645cfe97990ad321968ac8352d) )
-	sc_vivam_others
-ROM_END
-
-ROM_START( sc4vivcs )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "95400985.lo", 0x00001, 0x080000, CRC(d2ccb5df) SHA1(40eaeaf23431846aed70a535dddc8ab4452c6934) )
-	ROM_LOAD16_BYTE( "95400986.hi", 0x00000, 0x080000, CRC(4d1a78d6) SHA1(0765bd2db52752fff21b7909f98536a788f54f58) )
-	sc_vivam_others
+	PR6907_VIVA_MEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc4vivamb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95401703.lo", 0x00001, 0x080000, CRC(bdd484d4) SHA1(48a5501f06a0992e95f9f1c2bbe2d6efeb4ea47d) )
 	ROM_LOAD16_BYTE( "95401704.hi", 0x00000, 0x080000, CRC(3aa93ae9) SHA1(4b98f5c1ebfd3326bbcb1d45d7adb788892a814d) )
-	sc_vivam_others
+	PR6907_VIVA_MEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc4vivamc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95401705.lo", 0x00001, 0x080000, CRC(583e6e00) SHA1(825d99d46adf12dfc3f7aa25e32a4faa28ae2535) )
 	ROM_LOAD16_BYTE( "95401706.hi", 0x00000, 0x080000, CRC(b9e0ca1c) SHA1(4c7f655e53d8f1bf3afdafcd1296b0f182626e61) )
-	sc_vivam_others
+	PR6907_VIVA_MEXICO_SOUNDS11
 ROM_END
 
+
+ROM_START( sc4vivcs )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "95400985.lo", 0x00001, 0x080000, CRC(d2ccb5df) SHA1(40eaeaf23431846aed70a535dddc8ab4452c6934) )
+	ROM_LOAD16_BYTE( "95400986.hi", 0x00000, 0x080000, CRC(4d1a78d6) SHA1(0765bd2db52752fff21b7909f98536a788f54f58) )
+	PR6927_CASINO_VMEXICO_SOUNDS11
+ROM_END
+
+
 ROM_START( sc4vivcsa )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95401985.lo", 0x00001, 0x080000, CRC(d7307e01) SHA1(06adc3c22000062beb4d16df6470a582fcd77fb6) )
 	ROM_LOAD16_BYTE( "95401986.hi", 0x00000, 0x080000, CRC(b27ebf71) SHA1(f90d908d1fdab7f81903a7af5c699bbbde1a7157) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc4vivcsb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95406530.lo", 0x00001, 0x080000, CRC(d7b0d682) SHA1(ea6a2d919a4066eb278bc6a74b354678afb264da) )
 	ROM_LOAD16_BYTE( "95406531.hi", 0x00000, 0x080000, CRC(6ced2032) SHA1(d89aa8d3d2a6aea92650634e9af63ded26b10265) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 ROM_START( sc4vivcsc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95407530.lo", 0x00001, 0x080000, CRC(f679842e) SHA1(eb11a0478295e7cc091d45957a6d1313098884b4) )
 	ROM_LOAD16_BYTE( "95407531.hi", 0x00000, 0x080000, CRC(3924f97f) SHA1(9c4b99e36b723adb53c0f229c95afa55a35c26ed) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 ROM_START( sc4vivcsd )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95410054.lo", 0x00001, 0x080000, CRC(6133a322) SHA1(fef8a250a15234c4edc9f0503b95d5fc39295383) )
 	ROM_LOAD16_BYTE( "95410055.hi", 0x00000, 0x080000, CRC(4aca6d50) SHA1(99e91c14cf19f4b14797f2b9ada0a1c7dc527e30) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 ROM_START( sc4vivcse )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95410058.lo", 0x00001, 0x080000, CRC(5688892a) SHA1(68edeb781623b9c5622f8523612faf7f9e012f3b) )
 	ROM_LOAD16_BYTE( "95410059.hi", 0x00000, 0x080000, CRC(4aa40ae2) SHA1(f9068b542697c188e26847205b7c72f518f987dc) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 ROM_START( sc4vivcsf )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95411054.lo", 0x00001, 0x080000, CRC(0bb6da59) SHA1(21fc9b6a2e294b7ec25054bc3c08e72806e85c3f) )
 	ROM_LOAD16_BYTE( "95411055.hi", 0x00000, 0x080000, CRC(3acd1951) SHA1(9250c42d28a6eb4364b3c30557d8270e85a56263) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 ROM_START( sc4vivcsg )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95411058.lo", 0x00001, 0x080000, CRC(e98505e3) SHA1(6254c7016672a92e189970fcf79e3c3414bb7436) )
 	ROM_LOAD16_BYTE( "95411059.hi", 0x00000, 0x080000, CRC(cedaf6bd) SHA1(9d459d8896d577d373e989042167ea46078de564) )
-	sc_vivam_others
+	PR6927_CASINO_VMEXICO_SOUNDS21
 ROM_END
 
 
@@ -22590,7 +23069,55 @@
 	sc_nunsm_others
 ROM_END
 
-/********* UNSORTED *************/
+
+
+
+ROM_START( sc4clbmn )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95418938.lo", 0x00001, 0x080000, CRC(59faf394) SHA1(a61158d582de97b0e1e613a984504066e56e237e) )
+    ROM_LOAD16_BYTE( "95418939.hi", 0x00000, 0x080000, CRC(ff6df292) SHA1(5d97c45b250ac7276520ead111186fb27846b085) )
+	sc_clbmn_others
+ROM_END
+
+ROM_START( sc4clbmna )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95419938.lo", 0x00001, 0x080000, CRC(e3316610) SHA1(b651136355adc6da794ce669bfaa9551c567d133) )
+    ROM_LOAD16_BYTE( "95419939.hi", 0x00000, 0x080000, CRC(54eda019) SHA1(762def4d175722222a8b17dd4278bc49f0f3b873) )
+	sc_clbmn_others
+ROM_END
+
+ROM_START( sc4clbmnb )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95422126.lo", 0x00001, 0x080000, CRC(09ddd2a8) SHA1(20bad26635c6277a2d556afaf52ffd38ee2ec99c) )
+    ROM_LOAD16_BYTE( "95422127.hi", 0x00000, 0x080000, CRC(b5f1deb6) SHA1(adf483b3194f17428c6f128378725c65ef186f65) )
+	sc_clbmn_others
+ROM_END
+
+ROM_START( sc4clbmnc )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95423126.lo", 0x00001, 0x080000, CRC(02953434) SHA1(329944baf10c305597bf137bfc9c6fdce2e30bd2) )
+    ROM_LOAD16_BYTE( "95423127.hi", 0x00000, 0x080000, CRC(6f03e758) SHA1(7317bd88df1c1c3f378cbbe30982c3e1479a1dc4) )
+	sc_clbmn_others
+ROM_END
+
+
+
+
+ROM_START( sc4boomb )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95426488.lo", 0x00001, 0x080000, CRC(b5ddf816) SHA1(3817eedab684ae06f3b079993d800c4000cf46dd) )
+    ROM_LOAD16_BYTE( "95426489.hi", 0x00000, 0x080000, CRC(c84a8b41) SHA1(86f2f14f9a66aa616f579c835d8111751f36a84e) )
+    sc_mobob_others
+ROM_END
+
+
+ROM_START( sc4boomba )
+    ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF)
+    ROM_LOAD16_BYTE( "95427489.hi", 0x00000, 0x080000, CRC(6dc23ad0) SHA1(5318dfffca7211600e0f64ea0ef1f45701f57401) )
+    ROM_LOAD16_BYTE( "95427488.lo", 0x00001, 0x080000, CRC(5ac5adbd) SHA1(a4cf828eb3d5d8e2603a1921e6f63e04348beb26) )
+    sc_mobob_others
+ROM_END
+
 
 
 ROM_START( ad4film )
@@ -22638,9 +23165,6 @@
 	ROM_LOAD( "95008136.bin", 0x0000, 0x100000, CRC(456cc709) SHA1(85ae7a81fbd1dc13b4395baefea82ba31e6c4d3f) )
 	// Cash Splash (Qps)
 	ROM_LOAD( "95008403.bin", 0x0000, 0x0facbf, CRC(cf3969bb) SHA1(4cb6fb4e536882a11bb6c1548ffb94daea70ca5f) )
-	// Casino Viva Mexico
-	ROM_LOAD( "95004209.lo", 0x00001, 0x080000, CRC(40247425) SHA1(54c8540f9ce45b8b02f6616233b81e33af804f63) )
-	ROM_LOAD( "95004210.hi", 0x00000, 0x080000, CRC(6f6ce2c8) SHA1(7e9ce336a1307b8290196d58c7419996d0758ab9) )
 	// Casino Triple Classic (Bellfruit)
 	// 95008423.bin =
 	// 95008423.bin          sc4bar7    Bar 7's (Bellfruit) (Scorpion 4)
@@ -23223,6 +23747,13 @@
 GAME( 200?, sc4cclimj	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4cclimk	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 16)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4ccliml	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 17)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cclimq	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 18)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cclimr	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 19)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cclims	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 20)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cclimt	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 21)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cclimu	,sc4cclim,	sc4, sc4, sc4, ROT0, "BFM","Crazy Climber (Bellfruit) (Scorpion 4) (set 22)", GAME_IS_SKELETON_MECHANICAL )
+
+
 
 // PR6813 CRAZY FRUITS         PR6813 CRAZY FRUITS SOUNDS11
 GAME( 200?, sc4cfqps	,0,			sc4, sc4, sc4, ROT0, "Qps","Crazy Fruits (PR6813) (Qps) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -23241,7 +23772,25 @@
 GAME( 200?, sc4cfqpsj	,sc4cfqps,	sc4, sc4, sc4, ROT0, "Qps","Crazy Fruits SP98 (PR4613) (Qps) (Scorpion 4)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR6923 CASINO CRAZY FRUITS         PR6923 CRAZY FRUITS SOUNDS11
-GAME( 200?, sc4cfcas	,0,			sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcas	,0,			sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasa	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasb	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasc	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasd	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcase	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasf	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasg	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcash	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasi	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasj	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcask	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasl	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasm	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasn	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcaso	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 16)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasp	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 17)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasq	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 18)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cfcasr	,sc4cfcas,	sc4, sc4, sc4, ROT0, "BFM","Crazy Fruits Casino (Bellfruit) (Scorpion 4) (set 19)", GAME_IS_SKELETON_MECHANICAL )
 
 
 // PR6931 CLUB CRAZY FRUITS         PR6931 CRZY SOUNDS11
@@ -23304,6 +23853,8 @@
 GAME( 200?, sc4crzkyl	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crzkym	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crzkyn	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crzkyt	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crzkyu	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
 // PR1128 CASINO CRAZY KEYS         CRAZY KEYS  ARCADE  PR1128 CRAZY KEYS SOUNDS11
 GAME( 200?, sc4crzkyi	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crzkyj	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
@@ -23313,6 +23864,9 @@
 GAME( 200?, sc4crzkyq	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crzkyr	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crzkys	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crzkyv	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crzkyw	,sc4crzky,	sc4, sc4, sc4, ROT0, "BFM","Crazy Keys Casino Arcade (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+
 
 //  PR7001 IT'S A CRAZY WORLD         CRAZY WORLD SOUNDS
 GAME( 200?, sc4crzwl	,0,			sc4, sc4, sc4, ROT0, "Mazooma","Crazy World (Mazooma) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -23399,19 +23953,19 @@
 GAME( 200?, sc4duckqa	,sc4duckq,	sc4, sc4, sc4, ROT0, "Qps","Ducks Of Hazzard (Qps) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 
 
-// PR1326 CASINO EASY STREAK         PR1326 EASY STREAK SOUNDS11
-GAME( 200?, sc4eascs	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsa	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsb	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsc	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsd	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascse	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsf	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsg	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsh	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsi	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsj	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4eascsk	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+// PR1326 CASINO EASY STREAK         PR1326 EASY STREAK SOUNDS11  (actually expects PR1326_CAS_EASY_STREAK_SOUNDS11 ? )
+GAME( 200?, sc4eascs	,0,     	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsa	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsb	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsc	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsd	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascse	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsf	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsg	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsh	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsi	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsj	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4eascsk	,sc4eascs,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak Casino (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
 
 
 // PR2071 FAST 'N' FURIOUS         FNF SOUNDS         FAST 'N' FURIOUS
@@ -23839,16 +24393,16 @@
 GAME( 200?, sc4jackg	,sc4jack,	sc4, sc4, sc4, ROT0, "Mazooma","Jack The Kipper (Mazooma) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1304 JACKPOT JUNCTION         PR1304 JACKPOT JUNCTION SOUNDS11
-GAME( 200?, sc4jjunc	,0,			sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjunca	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjuncb	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjuncc	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjuncd	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjunce	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjuncf	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjuncg	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjunch	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4jjunci	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjunc	,0,			sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjunca	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjuncb	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjuncc	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjuncd	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjunce	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjuncf	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjuncg	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjunch	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2002, sc4jjunci	,sc4jjunc,	sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1422 CLUB JACKPOT JUNCTION          PR1422 JACKPOT JUNCTION SOUNDS11
 GAME( 200?, sc4jjucl	,0,			sc4, sc4, sc4, ROT0, "BFM","Jackpot Junction Club (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -24129,6 +24683,11 @@
 GAME( 200?, sc4luckbv	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 20)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4luckbw	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 21)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4luckbx	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 22)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4luckb1	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 23)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4luckb2	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 24)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4luckb3	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 25)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4luckb4	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino (Bellfruit) (Scorpion 4) (set 26)", GAME_IS_SKELETON_MECHANICAL )
+
 // PR1033 CASINO LUCKY BALLS         PR1033 LUCKY BALLS SOUNDS11       LUCKY BALLS ARCADE
 GAME( 200?, sc4luckbq	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino Arcade (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4luckbr	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino Arcade (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
@@ -24137,6 +24696,7 @@
 GAME( 200?, sc4luckbz	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino Arcade (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL ) // incomplete pairing
 GAME( 200?, sc4luckb0	,sc4luckb,	sc4, sc4, sc4luckb, ROT0, "BFM","Lucky Balls Casino Arcade (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 
+
 // PR2535 MAGIC CIRCLE STANDARD 011         MAGICSND
 GAME( 200?, sc4magci	,0,			sc4, sc4, sc4, ROT0, "Qps","Magic Circle (011) (Qps) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4magcik	,sc4magci,	sc4, sc4, sc4, ROT0, "Qps","Magic Circle (011) (Qps) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
@@ -24204,18 +24764,47 @@
 GAME( 200?, sc4mbagsb	,sc4mbags,	sc4, sc4, sc4, ROT0, "BFM","Money Bags (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4mbagsc	,sc4mbags,	sc4, sc4, sc4, ROT0, "BFM","Money Bags (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
 
+
+const stepper_interface* sc4mgr_reel_configs[6] =
+{
+	&starpoint_interface_48step,
+	&starpoint_interface_48step,
+	&starpoint_interface_48step,
+	&starpoint_interface_200step_reel,
+	0,
+	0,
+};
+
+static DRIVER_INIT( sc4mgr )
+{
+	sc4_state *state = machine.driver_data<sc4_state>();
+	DRIVER_INIT_CALL( sc4 );
+	state->m_reel_setup = sc4mgr_reel_configs;
+}
+
+static DRIVER_INIT( sc4mgrm )
+{
+	sc4_state *state = machine.driver_data<sc4_state>();
+	DRIVER_INIT_CALL( sc4mbus );
+	state->m_reel_setup = sc4mgr_reel_configs;
+}
+
 // PR1132 CASINO MONEY GO ROUND         PR1132 MONEY GO ROUND SOUNDS11
-GAME( 200?, sc4mgr		,0,			sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgra		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgrh		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgri		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgr		,0,			sc4, sc4, sc4mgr, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgra		,sc4mgr,	sc4, sc4, sc4mgr, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrh		,sc4mgr,	sc4, sc4, sc4mgr, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgri		,sc4mgr,	sc4, sc4, sc4mgr, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
 // PR1132 CASINO MONEY GO ROUND         PR1132 MONEY GO ROUND SOUNDS11    MONEY GO ROUND  S.SITE
-GAME( 200?, sc4mgrb		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgrc		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgrd		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgre		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgrf		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mgrg		,sc4mgr,	sc4, sc4, sc4, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrb		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrc		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrd		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgre		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrf		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrg		,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrj	    ,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrk	    ,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrl	    ,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mgrm	    ,sc4mgr,	sc4, sc4, sc4mgrm, ROT0, "BFM","Money Go Round Casino (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
 
 
 // PR1325 CASINO MONEY SPIDER         PR1325 MONEYSPIDER SOUNDS11
@@ -24507,6 +25096,8 @@
 GAME( 200?, sc4pogbla	,sc4pogbl,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold Club (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4pogblb	,sc4pogbl,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold Club (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4pogblc	,sc4pogbl,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold Club (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4pogbld	,sc4pogbl,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold Club (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4pogble	,sc4pogbl,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold Club (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR6810 POWER CRAZY         PR6810 POWER SOUNDS11
 GAME( 200?, sc4pwcrz	,0,			sc4, sc4, sc4, ROT0, "BFM","Power Crazy (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -24831,22 +25422,22 @@
 
 
 // PR1423 CLUB SNAKES N LADDERS         PR1423 CSNK SOUNDS11         SNAKES N LADDERS
-GAME( 200?, sc4slc		,0,			sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcb		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcc		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slce		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slci		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcm		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcn		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slc		,0,			sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcb		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcc		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slce		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slci		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcm		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcn		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
 // PR1423 CLUB SNAKES N LADDERS         SNAKES N LADDERS  CLUB  PR1423 CSNK SOUNDS11         SNAKES N LADDERS
-GAME( 200?, sc4slca		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcd		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcf		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcg		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slch		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcj		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slck		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4slcl		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slca		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcd		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcf		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcg		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slch		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcj		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slck		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2003, sc4slcl		,sc4slc,	sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders Club (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1010  SOLID GOLD         PR1010 SOLID GOLD SOUNDS11
 GAME( 200?, sc4solgl	,0,			sc4, sc4, sc4, ROT0, "BFM","Solid Gold (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -25288,11 +25879,16 @@
 GAME( 200?, sc4wldbni	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4wldbnj	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4wldbnk	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnn	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbno	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnp	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnq	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
+
 // PR7144 WILD BUNCH         PR7144 WILD BUNCH SOUNDS11        CAS WILD BUNCH  S.SITE
-GAME( 200?, sc4wldbng	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4wldbnh	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4wldbnl	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4wldbnm	,sc4wldbn,	sc4, sc4, sc4, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbng	,sc4wldbn,	sc4, sc4, sc4mbus, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnh	,sc4wldbn,	sc4, sc4, sc4mbus, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnl	,sc4wldbn,	sc4, sc4, sc4mbus, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4wldbnm	,sc4wldbn,	sc4, sc4, sc4mbus, ROT0, "BFM","Wild Bunch Casino (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR7110 WILD THING         PR7110 WILD THING SOUNDS11
 GAME( 200?, sc4wthng	,0,			sc4, sc4, sc4, ROT0, "BFM","Wild Thing (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -25633,7 +26229,8 @@
 GAME( 200?, sc4cariqg	,sc4cariq,	sc4, sc4, sc4, ROT0, "Qps","Caribbean Cash (Qps) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1683 BLAS14
-GAME( 200?, sc4cblas	,0,			sc4, sc4, sc4, ROT0, "BFM","Cash Blast (Bellfruit) (Scorpion 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cblas	,0,			sc4, sc4, sc4, ROT0, "Voodoo Games","Cash Blast (Voodoo Games) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cblasa	,sc4cblas,	sc4, sc4, sc4, ROT0, "Voodoo Games","Cash Blast (Voodoo Games) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2338 XTRAVAGANZA         XTRV SOUNDS         XTRAVAGANZA
 GAME( 200?, sc4casxt	,0,			sc4, sc4, sc4, ROT0, "Mazooma","Casino Xtravaganza (Mazooma) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -25819,6 +26416,8 @@
 GAME( 200?, sc4dndcsb	,sc4dndcs,	sc4, sc4dndcs5, sc4dndcs, ROT0, "BFM","Deal Or No Deal Classic (Bellfruit) (Scorpion 4) (CLDD211, set 2)", GAME_IS_SKELETON_MECHANICAL ) // CLDD 211
 GAME( 200?, sc4dndcsa	,sc4dndcs,	sc4, sc4dndcs5, sc4dndcs, ROT0, "BFM","Deal Or No Deal Classic (Bellfruit) (Scorpion 4) (CLDD212, set 1)", GAME_IS_SKELETON_MECHANICAL ) // CLDD 212
 GAME( 200?, sc4dndcsc	,sc4dndcs,	sc4, sc4dndcs5, sc4dndcs, ROT0, "BFM","Deal Or No Deal Classic (Bellfruit) (Scorpion 4) (CLDD212, set 2)", GAME_IS_SKELETON_MECHANICAL ) // CLDD 212
+GAME( 200?, sc4dndcsd	,sc4dndcs,	sc4, sc4dndcs5, sc4dndcs, ROT0, "BFM","Deal Or No Deal Classic (Bellfruit) (Scorpion 4) (CLDD215, set 1)", GAME_IS_SKELETON_MECHANICAL ) // CLDD 215
+GAME( 200?, sc4dndcse	,sc4dndcs,	sc4, sc4dndcs5, sc4dndcs, ROT0, "BFM","Deal Or No Deal Classic (Bellfruit) (Scorpion 4) (CLDD215, set 2)", GAME_IS_SKELETON_MECHANICAL ) // CLDD 215
 
 const stepper_interface* sc4dndbb_reel_configs[6] =
 {
@@ -25985,10 +26584,13 @@
 GAME( 200?, sc4dndhfi	,sc4dndhf,	sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA472, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 472
 GAME( 200?, sc4dndhf	,0,			sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA473, set 1)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 473
 GAME( 200?, sc4dndhfa	,sc4dndhf,	sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA473, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 473
+GAME( 200?, sc4dndhfj	,sc4dndhf,	sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA476)",        GAME_IS_SKELETON_MECHANICAL ) // DNHA 476
 GAME( 200?, sc4dndhfb	,sc4dndhf,	sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA477, set 1)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 477
 GAME( 200?, sc4dndhfd	,sc4dndhf,	sc4, sc4dndhf35, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA477, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 477
 GAME( 200?, sc4dndhfc	,sc4dndhf,	sc4, sc4dndhf70, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA571, set 1)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 571
 GAME( 200?, sc4dndhfe	,sc4dndhf,	sc4, sc4dndhf70, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA571, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DNHA 571
+GAME( 200?, sc4dndhfk	,sc4dndhf,	sc4, sc4dndhf70, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA572, set 1, bad?)", GAME_IS_SKELETON_MECHANICAL ) // error 51 (bad rom?)
+GAME( 200?, sc4dndhfl	,sc4dndhf,	sc4, sc4dndhf70, sc4dndhf, ROT0, "BFM","Deal Or No Deal Hall Of Fame (Bellfruit) (Scorpion 4) (DNHA572, set 2, bad?)", GAME_IS_SKELETON_MECHANICAL ) // error 51 (bad rom?)
 
 const stepper_interface* sc4dndys_reel_configs[6] =
 {
@@ -26026,7 +26628,8 @@
 // PR3227 AWP DEAL OR NO DEAL ITS YOUR SHOW SCORP4         PR3207 ITS YOUR SHOW SOUNDS11     ITS YOUR SHOW S.SITE
 GAME( 200?, sc4dndys	,0,			sc4, sc4dndys70, sc4dndys, ROT0, "BFM","Deal Or No Deal It's Your Show (Bellfruit) (Scorpion 4) (DOBO571, set 1)", GAME_IS_SKELETON_MECHANICAL ) // DOBO 571
 GAME( 200?, sc4dndysb	,sc4dndys,	sc4, sc4dndys70, sc4dndys, ROT0, "BFM","Deal Or No Deal It's Your Show (Bellfruit) (Scorpion 4) (DOBO571, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DOBO 571
-GAME( 200?, sc4dndysa	,sc4dndys,	sc4, sc4dndys35, sc4dndys, ROT0, "BFM","Deal Or No Deal It's Your Show (Bellfruit) (Scorpion 4) (DOBO474)",        GAME_IS_SKELETON_MECHANICAL ) // DOBO 474
+GAME( 200?, sc4dndysa	,sc4dndys,	sc4, sc4dndys35, sc4dndys, ROT0, "BFM","Deal Or No Deal It's Your Show (Bellfruit) (Scorpion 4) (DOBO474, set 1)", GAME_IS_SKELETON_MECHANICAL ) // DOBO 474
+GAME( 200?, sc4dndysc	,sc4dndys,	sc4, sc4dndys35, sc4dndys, ROT0, "BFM","Deal Or No Deal It's Your Show (Bellfruit) (Scorpion 4) (DOBO474, set 2)", GAME_IS_SKELETON_MECHANICAL ) // DOBO 474
 
 const stepper_interface* sc4dndlp_reel_configs[6] =
 {
@@ -26689,6 +27292,8 @@
 GAME( 200?, sc4fguyb	,sc4fguy,	sc4, sc4fguy35, sc4fguy, ROT0, "BFM","Family Guy (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL ) // FAMY 471
 GAME( 200?, sc4fguya	,sc4fguy,	sc4, sc4fguy70, sc4fguy, ROT0, "BFM","Family Guy (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL ) // FAMY 572
 GAME( 200?, sc4fguyc	,sc4fguy,	sc4, sc4fguy70, sc4fguy, ROT0, "BFM","Family Guy (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL ) // FAMY 572
+GAME( 200?, sc4fguyd	,sc4fguy,	sc4, sc4, sc4fguy, ROT0, "BFM","Family Guy (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4fguye	,sc4fguy,	sc4, sc4, sc4fguy, ROT0, "BFM","Family Guy (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1721 AWP FAT BOY SPIN SCORP4         PR1701 FAT BOY SPIN SOUNDS11      FAT BOY SPIN  S.SITE
 GAME( 200?, sc4fbspn	,0,			sc4, sc4, sc4mbus, ROT0, "BFM","Fat Boy Spin (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -26919,6 +27524,10 @@
 GAME( 200?, sc4hntcsm	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4hntcsn	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4hntcso	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 16)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4hntcsp	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 17)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4hntcsq	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 18)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4hntcsr	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 19)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4hntcss	,sc4hntcs,	sc4, sc4, sc4hntcs, ROT0, "BFM","Happy Notes Casino (Bellfruit) (Scorpion 4) (set 20)", GAME_IS_SKELETON_MECHANICAL )
 
 
 
@@ -27017,6 +27626,8 @@
 GAME( 200?, sc4ijobi	,sc4ijob,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Italian Job (Mazooma) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4ijobj	,sc4ijob,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Italian Job (Mazooma) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4ijobk	,sc4ijob,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Italian Job (Mazooma) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4ijobl	,sc4ijob,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Italian Job (Mazooma) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4ijobm	,sc4ijob,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Italian Job (Mazooma) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
 
 
 // PR1609 JACKPOT JOKERS         PR1609 JACKPOT JOKERS SOUNDS11    JACKPOT JOKERS  S.SITE
@@ -27160,18 +27771,21 @@
 GAME( 200?, sc4mhna		,sc4mhn,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Monopoly Here & Now (Mazooma) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2345 AWP MONOPOLY HOT PROPERTY S4         PR2345 HOT PROPERTY SOUNDS11      HOT PROPERTY  S.SITE
-GAME( 200?, sc4mhp		,0,			sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpa		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpb		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpc		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpd		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpe		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpf		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpg		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhph		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpi		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpj		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4mhpk		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4mhp		,0,			sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL ) // 471
+GAME( 200?, sc4mhpa		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL ) // 472
+GAME( 200?, sc4mhpb		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL ) // 271
+GAME( 200?, sc4mhpc		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL ) // 471
+GAME( 200?, sc4mhpd		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL ) // 472
+GAME( 200?, sc4mhpe		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL ) // 271
+GAME( 200?, sc4mhpf		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL ) // 475
+GAME( 200?, sc4mhpg		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL ) // 571
+GAME( 200?, sc4mhph		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL ) // 572
+GAME( 200?, sc4mhpi		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL ) // 475
+GAME( 200?, sc4mhpj		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL ) // 571
+GAME( 200?, sc4mhpk		,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL ) // 572
+GAME( 200?, sc4mhpl	    ,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL ) // 411
+GAME( 200?, sc4mhpm	    ,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL ) // 272
+GAME( 200?, sc4mhpn	    ,sc4mhp,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Hot Property (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL ) // 272
 
 
 // PR1931 AWP MONOLOLY MONEY BAGS SCORP4         PR1911 MPOLY MONEYBAGS SOUNDS11   MONEYBAGS S.SITE
@@ -27279,6 +27893,8 @@
 GAME( 200?, sc4popeya	,sc4popey,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Popeye (Mazooma) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4popeyb	,sc4popey,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Popeye (Mazooma) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4popeyc	,sc4popey,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Popeye (Mazooma) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4popeyd	,sc4popey,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Popeye (Mazooma) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4popeye	,sc4popey,	sc4, sc4, sc4mbus, ROT0, "Mazooma","Popeye (Mazooma) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 
 
 
@@ -27291,6 +27907,8 @@
 GAME( 200?, sc4poge		,sc4pog,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4pogf		,sc4pog,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4pogg		,sc4pog,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4pogh	    ,sc4pog,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4pogi	    ,sc4pog,	sc4, sc4, sc4mbus, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2272 POWER PLAY         PPLY SOUNDS
 GAME( 200?, sc4pwrpl	,0,			sc4, sc4, sc4, ROT0, "Mazooma","Power Play (Mazooma) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -27382,6 +28000,7 @@
 GAME( 200?, sc4showtc	,sc4showt,	sc4, sc4, sc4mbus, ROT0, "BFM","Showtime (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4showtd	,sc4showt,	sc4, sc4, sc4mbus, ROT0, "BFM","Showtime (Bellfruit) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4showte	,sc4showt,	sc4, sc4, sc4mbus, ROT0, "BFM","Showtime (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4showtf	,sc4showt,	sc4, sc4, sc4mbus, ROT0, "BFM","Showtime (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1411 AWP SNAKES AND LADDERS         PR1411 SNAKES A L SOUNDS11        SNAKES & LADDERS  S.SITE
 GAME( 200?, sc4slad		,0,			sc4, sc4, sc4, ROT0, "BFM","Snakes & Ladders (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -27923,6 +28542,10 @@
 GAME( 200?, sc4cckeyi	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4cckeyj	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4cckeyk	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 12)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cckeyl	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 13)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cckeym	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 14)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cckeyn	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 15)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4cckeyo	,sc4cckey,	sc4, sc4, sc4, ROT0, "BFM","Casino Crazy Fruits Gold (Bellfruit) (Scorpion 4) (set 16)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2062 CASINO ROYALE         CROY SOUNDS           CASINO ROYALE
 GAME( 200?, sc4casry	,0,			sc4, sc4, sc4, ROT0, "Mazooma","Casino Royale (PR2062) (Mazooma) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -27971,6 +28594,8 @@
 GAME( 200?, sc4crcpf	,sc4crcp,	sc4, sc4, sc4mbus, ROT0, "BFM","Cops 'n' Robbers Club Platinum (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crcpg	,sc4crcp,	sc4, sc4, sc4mbus, ROT0, "BFM","Cops 'n' Robbers Club Platinum (Bellfruit) (Scorpion 4) (set 7)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4crcph	,sc4crcp,	sc4, sc4, sc4mbus, ROT0, "BFM","Cops 'n' Robbers Club Platinum (Bellfruit) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crcpi	,sc4crcp,	sc4, sc4, sc4mbus, ROT0, "BFM","Cops 'n' Robbers Club Platinum (Bellfruit) (Scorpion 4) (set 9)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4crcpj	,sc4crcp,	sc4, sc4, sc4mbus, ROT0, "BFM","Cops 'n' Robbers Club Platinum (Bellfruit) (Scorpion 4) (set 10)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1348 CLUB COPS AND ROBBERS GOLD         PR1348 CCRG SOUNDS11         COPS AND ROBBERS
 GAME( 200?, sc4crgc		,0,			sc4, sc4, sc4, ROT0, "BFM","Cops 'n' Robbers Gold Club (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -28065,6 +28690,15 @@
 GAME( 200?, sc4easye	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak (Bellfruit) (Scorpion 4) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, sc4easyf	,sc4easy,	sc4, sc4, sc4, ROT0, "BFM","Easy Streak (Bellfruit) (Scorpion 4) (set 11)", GAME_IS_SKELETON_MECHANICAL )
 
+//PROJECT NUMBER PR1955 CLUB MONEYBAGS         MONEY BAGS  CLUB  PR1955 C M MONEYBAGS SOUNDS11       DEAL OR NO DEAL   5-10-20   10-20-30   20-30-50  30-50-100
+GAME( 200?, sc4clbmn	,0,	        sc4, sc4, sc4mbus, ROT0, "BFM","Club Moneybags (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4clbmna	,sc4clbmn,	sc4, sc4, sc4mbus, ROT0, "BFM","Club Moneybags (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4clbmnb	,sc4clbmn,	sc4, sc4, sc4mbus, ROT0, "BFM","Club Moneybags (Bellfruit) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4clbmnc	,sc4clbmn,	sc4, sc4, sc4mbus, ROT0, "BFM","Club Moneybags (Bellfruit) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+
+//PROJECT NUMBER PR3332 AWP MONOPOLY BOOM OR BUST S4         PR3307 MPOLY BOOM OR B SOUNDS11   BOOM OR BUST  S.SITE
+GAME( 200?, sc4boomb	,0, 	    sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Boom Or Bust (Bellfruit) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4boomba	,sc4boomb,	sc4, sc4, sc4mbus, ROT0, "BFM","Monopoly Boom Or Bust (Bellfruit) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 
 
 /* Scorpion 4 + Adder 4 */
diff -Nru src-old/mame/drivers/bfm_sc4h.c src/mame/drivers/bfm_sc4h.c
--- src-old/mame/drivers/bfm_sc4h.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/bfm_sc4h.c	2012-05-03 19:38:32.000000000 +0200
@@ -48,16 +48,65 @@
 
 	if (row<4)
 	{
-		value = (input_port_read_safe(machine, portnames[row], 0x00) & 0x1f) + ((input_port_read_safe(machine, portnames[row+8], 0x00) & 0x07) << 5);
+		value = (machine.root_device().ioport(portnames[row])->read_safe(0x00) & 0x1f) + ((machine.root_device().ioport(portnames[row+8])->read_safe(0x00) & 0x07) << 5);
 	}
 	else
 	{
-		value = (input_port_read_safe(machine, portnames[row], 0x00) & 0x1f) + ((input_port_read_safe(machine, portnames[row+4], 0x00) & 0x18) << 2);
+		value = (machine.root_device().ioport(portnames[row])->read_safe(0x00) & 0x1f) + ((machine.root_device().ioport(portnames[row+4])->read_safe(0x00) & 0x18) << 2);
 	}
 
 	return value;
 }
 
+READ16_MEMBER(sc4_state::sc4_cs1_r)
+{
+	int pc = cpu_get_pc(&space.device());
+
+	if (offset<0x100000/2)
+	{
+		// allow some sets to boot, should probably return this data on Mbus once we figure out what it is
+		if ((pc == m_chk41addr) && (offset == m_chk41addr>>1))
+		{
+			UINT32 r_A0 = cpu_get_reg(&space.device(), M68K_A0);
+			UINT32 r_A1 = cpu_get_reg(&space.device(), M68K_A1);
+			UINT32 r_D1 = cpu_get_reg(&space.device(), M68K_D1);
+
+			if (r_D1 == 0x7)
+			{
+				bool valid = true;
+				for (int i=0;i<8;i++)
+				{
+					UINT8 code = space.read_byte(r_A0+i);
+					if (code != 0xff) // assume our mbus code just returns 0xff for now..
+						valid = false;
+				}
+
+				if (valid && m_dochk41)
+				{
+					m_dochk41 = false;
+					// the value is actually random.. probably based on other reads
+					// making this a comparison?
+					printf("Ident code? ");
+					for (int i=0;i<8;i++)
+					{
+						UINT8 code = space.read_byte(r_A1+i);
+						printf("%02x",code);
+						space.write_byte(r_A0+i, code);
+					}
+					printf("\n");
+				}
+			}
+		}
+
+
+		return m_cpuregion[offset];
+	}
+	else
+		logerror("%08x maincpu read access offset %08x mem_mask %04x cs %d\n", pc, offset*2, mem_mask, 1);
+
+	return 0x0000;
+}
+
 READ16_MEMBER(sc4_state::sc4_mem_r)
 {
 	int pc = cpu_get_pc(&space.device());
@@ -70,49 +119,9 @@
 	switch ( cs )
 	{
 		case 1:
-			if (offset<0x100000/2)
-			{
-				// allow some sets to boot, should probably return this data on Mbus once we figure out what it is
-				if ((pc == m_chk41addr) && (offset == m_chk41addr>>1))
-				{
-					UINT32 r_A0 = cpu_get_reg(&space.device(), M68K_A0);
-					UINT32 r_A1 = cpu_get_reg(&space.device(), M68K_A1);
-					UINT32 r_D1 = cpu_get_reg(&space.device(), M68K_D1);
-
-					if (r_D1 == 0x7)
-					{
-						bool valid = true;
-						for (int i=0;i<8;i++)
-						{
-							UINT8 code = space.read_byte(r_A0+i);
-							if (code != 0xff) // assume our mbus code just returns 0xff for now..
-								valid = false;
-						}
-
-						if (valid && m_dochk41)
-						{
-							m_dochk41 = false;
-							// the value is actually random.. probably based on other reads
-							// making this a comparison?
-							printf("Ident code? ");
-							for (int i=0;i<8;i++)
-							{
-								UINT8 code = space.read_byte(r_A1+i);
-								printf("%02x",code);
-								space.write_byte(r_A0+i, code);
-							}
-							printf("\n");
-						}
-					}
-				}
+			return sc4_cs1_r(space,offset,mem_mask);
 
 
-				return m_cpuregion[offset];
-
-			}
-			else
-				logerror("%08x maincpu read access offset %08x mem_mask %04x cs %d\n", pc, offset*2, mem_mask, cs);
-			break;
 
 		case 2:
 			base = 0x800000/2;
@@ -378,11 +387,57 @@
 }
 
 static ADDRESS_MAP_START( sc4_map, AS_PROGRAM, 16, sc4_state )
+	AM_RANGE(0x0000000, 0x0fffff) AM_READ(sc4_cs1_r) // technically we should be going through the cs handler, but this is always set to ROM, and assuming that is a lot faster
 	AM_RANGE(0x0000000, 0xffffff) AM_READWRITE(sc4_mem_r, sc4_mem_w)
 ADDRESS_MAP_END
 
+
+
+
+READ32_MEMBER(sc4_adder4_state::adder4_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_adder4cpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 1:
+			return m_adder4cpuregion[offset];
+
+		case 2:
+			offset &=0x3fff;
+			return m_adder4ram[offset];
+
+		default:
+			logerror("%08x adder4cpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
+
+WRITE32_MEMBER(sc4_adder4_state::adder4_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_adder4cpu, offset * 4);
+
+	switch ( cs )
+	{
+		default:
+			logerror("%08x adder4cpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, offset*4, data, mem_mask, cs);
+
+		case 2:
+			offset &=0x3fff;
+			COMBINE_DATA(&m_adder4ram[offset]);
+			break;
+
+
+	}
+
+}
+
 static ADDRESS_MAP_START( sc4_adder4_map, AS_PROGRAM, 32, sc4_adder4_state )
-	AM_RANGE(0x000000, 0x2fffff) AM_ROM
+	AM_RANGE(0x00000000, 0xffffffff) AM_READWRITE(adder4_mem_r, adder4_mem_w)
 ADDRESS_MAP_END
 
 
@@ -584,10 +639,6 @@
 	{
 		 if (state->m_reel_setup[n]) stepper_config(machine, n, state->m_reel_setup[n]);
 	}
-	if (reels)
-	{
-		awp_reel_setup();
-	}
 }
 
 
@@ -722,9 +773,20 @@
 MACHINE_CONFIG_END
 
 
+
+static MACHINE_START( adder4 )
+{
+	sc4_adder4_state *state = machine.driver_data<sc4_adder4_state>();
+	state->m_adder4cpuregion = (UINT32*)state->memregion( "adder4" )->base();
+	state->m_adder4ram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+	MACHINE_START_CALL(sc4);
+}
+
 MACHINE_CONFIG_DERIVED_CLASS( sc4_adder4, sc4, sc4_adder4_state )
 	MCFG_CPU_ADD("adder4", M68340, 25175000)	 // 68340 (CPU32 core)
 	MCFG_CPU_PROGRAM_MAP(sc4_adder4_map)
+
+	MCFG_MACHINE_START( adder4 )
 MACHINE_CONFIG_END
 
 
diff -Nru src-old/mame/drivers/bfm_sc5.c src/mame/drivers/bfm_sc5.c
--- src-old/mame/drivers/bfm_sc5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bfm_sc5.c	2012-05-07 08:57:50.000000000 +0200
@@ -3888,6 +3888,7 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_REGION( 0x1000000, "adder5", ROMREGION_ERASEFF )
 	ROM_LOAD( "39211009.bin", 0x0000, 0x8ba10c, CRC(3883c4ea) SHA1(ac5876d252ef9900bbd86a43c73b2e3ba08f4e04) )
+	ROM_LOAD( "39212009.bin", 0x00000, 0x8ba10c, CRC(40328a9d) SHA1(0923f4dfffd4eca3aa9f67dbb972dd47b78aa0ab) )
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 )
 	ROM_LOAD( "95008434.bin", 0x0000, 0x100000, CRC(2d35e8ab) SHA1(a2e39beb891416bc5fae3d17125d146fe3ec3a12) )
 ROM_END
@@ -4080,6 +4081,11 @@
 	ROM_LOAD( "39211388.bin", 0x0000, 0x1000000, CRC(56fca244) SHA1(56890695c230a62b50c9dc2ecb4e8d6c123ed8dc) )
 	ROM_LOAD( "39212387.bin", 0x0000, 0x1000000, CRC(7affbe1b) SHA1(9fced7102afe267f426ada6e7840b877b185ca57) )
 	ROM_LOAD( "39212388.bin", 0x0000, 0x1000000, CRC(9ed7ae4f) SHA1(ff55640fd2538e9ed9b17b4387d1430401b22e69) )
+
+	ROM_LOAD( "39212612.bin", 0x0000, 0x1000000, CRC(dec693eb) SHA1(69256d4cc47715ea826eb0ca838c09a9d9e4d1e2) ) // hot spinner?
+
+
+
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 )
 	ROM_LOAD( "95008549.bin", 0x0000, 0x100000, CRC(dd7399cf) SHA1(1d4f475dde67048c6a425623a696a06e49231308) )
 ROM_END
@@ -4242,6 +4248,12 @@
 	ROM_LOAD( "39211605.bin", 0x0000, 0x1000000, CRC(b8fab0a2) SHA1(68ad9810549d9d01934182cb578e17af05ffa3c2) )
 	ROM_LOAD( "39211606.bin", 0x0000, 0x1000000, CRC(fa465b43) SHA1(8be39ffbee06a5b662a40b447276f95aa3b9bbe2) )
 	ROM_LOAD( "39212605.bin", 0x0000, 0x1000000, CRC(e5deb9fd) SHA1(9490d506080e729a43daf73710d4077c5d33d47b) )
+
+	ROM_LOAD( "39211630.bin", 0x0000, 0x1000000, CRC(2b246fc9) SHA1(ce1140c4f36a362f8c864ebc6aa3af00a173d913) )
+	ROM_LOAD( "39212630.bin", 0x0000, 0x1000000, CRC(b50bed01) SHA1(16a1e861baee8a54b1f7227744401351ed3355f7) )
+    ROM_LOAD( "39211615.bin", 0x00000, 0x1000000, CRC(d8308232) SHA1(11ddcb313b299a4704dbd24dd78c7303bf17a48a) )
+    ROM_LOAD( "39212615.bin", 0x00000, 0x1000000, CRC(b4299ca1) SHA1(d97e7f9d8a3729702d7f5076c10a4afc29333886) )
+
 ROM_END
 
 
@@ -5391,7 +5403,7 @@
 ROM_START( sc5frcrza )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95424546.lo", 0x00001, 0x080000, CRC(57d3e455) SHA1(f0ee335a9d56364aa5c64b2c20dcdef06aa0f5a5) )
-	ROM_LOAD16_BYTE( "95424547.hi", 0x00000, 0x080000, NO_DUMP )
+	ROM_LOAD16_BYTE( "95424547.hi", 0x00000, 0x080000, CRC(b9aa92e1) SHA1(3364253fd3e1c5b61a66080ce9a2e21047fb6d8b) )
 	sc_czfr_others
 ROM_END
 
@@ -5913,6 +5925,9 @@
 	ROM_LOAD( "39211171.bin", 0x0000, 0x1000000, CRC(a80f967a) SHA1(bc8dc5c2d30ec38a9119d577114f5e5813f38749) ) // PR3078 DOND
 	ROM_LOAD( "39212171.bin", 0x0000, 0x1000000, CRC(666fe2b4) SHA1(8baf5f8682f3937b4b49f8db93f3a21e8764c990) )
 
+	ROM_LOAD( "p1945p12.bin", 0x00000, 0x1000000, CRC(31ea70d9) SHA1(8e165132ecd48b5ea178e9b806944cc2fcd36f28) )
+    ROM_LOAD( "p1945s12.bin", 0x00000, 0x1000000, CRC(08235fa0) SHA1(b9482c6e65ad602f01f881156e83a5a475745642) )
+
 	ROM_REGION( 0x1000000, "ymz", ROMREGION_ERASE00 )
 	PR1945_CASINO_D_O_N_D_SOUNDS11
 	PR1945_CASINO_DOND_R_SOUNDS12
@@ -7309,6 +7324,8 @@
 	ROM_REGION( 0x1000000, "adder5", ROMREGION_ERASE00 )
 	ROM_LOAD( "39211613.bin", 0x0000, 0x1000000, CRC(98495946) SHA1(4c3d5d0731dfdaad37cee317a5d862ff46665ebd) )
 	ROM_LOAD( "39212613.bin", 0x0000, 0x1000000, CRC(1b0deb8f) SHA1(e27aafa91f5a9ca9064e6e89af5f86c305715efc) )
+    ROM_LOAD( "39211620.bin", 0x00000, 0x1000000, CRC(4b2fb445) SHA1(b50d57500d58199013f7ee4dee535578b63ddb7e) )
+	ROM_LOAD( "39212620.bin", 0x00000, 0x1000000, CRC(7f1f31a1) SHA1(9a8a826e73e91decce7b7315816b2c74bb37fcd9) )
 ROM_END
 
 
@@ -9706,7 +9723,10 @@
 	ROM_LOAD( "39212506.bin", 0x0000, 0x94ee0b, CRC(aef402bb) SHA1(4d0d58339a9c51ab5a33eebf9443ac43efced01d) )
 	ROM_LOAD( "39212510.bin", 0x0000, 0x94ee43, CRC(cec862b6) SHA1(b9b433218cef13d63e672f9e90649f44cf6aca72) )
 	ROM_LOAD( "39212511.bin", 0x0000, 0x94ef97, CRC(5a84f20f) SHA1(62d2ea8b462b53acf9b47cf3589cbdd455b5a5ad) )
-ROM_END
+    ROM_LOAD( "39211617.bin", 0x00000, 0x1000000, CRC(89d687e8) SHA1(7086f43fdaa417e9bb54feb859af22f501c6ca52) )
+	ROM_LOAD( "39212617.bin", 0x00000, 0x1000000, CRC(2191cc09) SHA1(593b6b16380821553adb377f3f4b5af28e73b2c0) )
+
+ ROM_END
 
 
 ROM_START( sc5mww )
@@ -10097,99 +10117,101 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95418746.lo", 0x00001, 0x080000, CRC(6ec2f94f) SHA1(6ea688cc7c69c0a50ba59cd1e3c55a67f4b8b980) )
 	ROM_LOAD16_BYTE( "95418747.hi", 0x00000, 0x080000, CRC(899d9f95) SHA1(170803aec2875223424a09326d74a335b2a1efa6) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc5poga )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95419746.lo", 0x00001, 0x080000, CRC(fde32cb2) SHA1(2627f19e787cd9f88d53e3dab6cfd5809912e39c) )
 	ROM_LOAD16_BYTE( "95419747.hi", 0x00000, 0x080000, CRC(2dd74466) SHA1(023af3659bbb31856364e33de1b3a03579248310) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc5pogb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95422096.lo", 0x00001, 0x080000, CRC(634b915f) SHA1(a64fa41d97d209774e403650e75f02039c714050) )
 	ROM_LOAD16_BYTE( "95422097.hi", 0x00000, 0x080000, CRC(393eeb18) SHA1(a73ddeaad545fc72e7bb970cc5884837df991412) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
 ROM_START( sc5pogc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95423096.lo", 0x00000, 0x080000, NO_DUMP )
 	ROM_LOAD16_BYTE( "95423097.hi", 0x00000, 0x080000, CRC(6c02b85d) SHA1(be8c898788cc826812a16eece855ce3f21cb1740) )
-	sc_pog_others
+	PR1918_POTS_OF_GOLD_SOUNDS11
+ROM_END
+
+ROM_START( sc5pogd )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "p1918p42.hi", 0x00000, 0x080000, CRC(9e0c7ebc) SHA1(e81fd6dbb13a25afde4849e54b0f71c0f6a83ad7) )
+	ROM_LOAD16_BYTE( "p1918p42.lo", 0x00001, 0x080000, CRC(330226ed) SHA1(001953a954c73d380d772a3779f104c1dd277505) )
+	PR1918_POTS_OF_GOLD_SOUNDS11
+ROM_END
+
+ROM_START( sc5poge )
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD16_BYTE( "p1918s42.hi", 0x00000, 0x080000, CRC(30780d72) SHA1(6731996c6f2addf70d9abae828853dde85df4585) )
+	ROM_LOAD16_BYTE( "p1918s42.lo", 0x00001, 0x080000, CRC(b9829456) SHA1(5c5f250857cc2f96f8e1761402bd46e05df0b549) )
+	PR1918_POTS_OF_GOLD_SOUNDS11
 ROM_END
 
+
 ROM_START( sc5potog )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95426442.lo", 0x00001, 0x080000, CRC(021dbcd3) SHA1(129c49001c9fb87277b1da0fe997822cd68d6833) )
 	ROM_LOAD16_BYTE( "95426443.hi", 0x00000, 0x080000, CRC(974f325d) SHA1(790efeff7b7a3f72a1cf1235771a7757cf844676) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potoga )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "95427442.lo", 0x00001, 0x080000, CRC(a461d588) SHA1(93fb5c6b145e5b4291ef3720fad5d527d27ebbda) )
 	ROM_LOAD16_BYTE( "95427443.hi", 0x00000, 0x080000, CRC(f3bcb341) SHA1(0bbfb2d661c99a9dbc5547e73c775b6e1a7cb8b5) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potogb )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95426376.lo", 0x00001, 0x080000, CRC(9f6b3222) SHA1(044065bfa7f68474351f08c9e1535bd4a590d258) )
 	ROM_LOAD16_BYTE( "g95426377.hi", 0x00000, 0x080000, CRC(02d55db3) SHA1(20e23360cebef9bc93ee2cc21d5851ffddf97e22) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potogc )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95426574.lo", 0x00001, 0x080000, CRC(2713029a) SHA1(255162dff74f9a68c91b5e3f08423d27b078ebcd) )
 	ROM_LOAD16_BYTE( "g95426575.hi", 0x00000, 0x080000, CRC(3e12bf73) SHA1(00419f72131e341a350056f06e12eddfa3a93dca) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potogd )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95426622.lo", 0x00001, 0x080000, CRC(fbc0286a) SHA1(0b9b1fef673fac90357799c54aa9b51a0bb97086) )
 	ROM_LOAD16_BYTE( "g95426623.hi", 0x00000, 0x080000, CRC(778fbd39) SHA1(b7087cba148d8b1f700a765f6556c48d08c00a4e) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potoge )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95427376.lo", 0x00001, 0x080000, CRC(932ba997) SHA1(07247a44c79e7afbe9de887c29051fbbf0a34ed3) )
 	ROM_LOAD16_BYTE( "g95427377.hi", 0x00000, 0x080000, CRC(154e6413) SHA1(2e3d73ffe1f080ce7e223ed31c11242cdb48c5a5) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potogf )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95427574.lo", 0x00001, 0x080000, CRC(8c1b9871) SHA1(2e2e02c911e45f71a363ffe85f05d76058cc7049) )
 	ROM_LOAD16_BYTE( "g95427575.hi", 0x00000, 0x080000, CRC(e0929b71) SHA1(85d0c52e53e5a414426da91b1d6496a750e519c1) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
 ROM_START( sc5potogg )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "g95427622.lo", 0x00001, 0x080000, CRC(c0629d24) SHA1(8077566d177a5b77d591fca916d7a860854e21f0) )
 	ROM_LOAD16_BYTE( "g95427623.hi", 0x00000, 0x080000, CRC(993cea6e) SHA1(94030b5062e31c32a08421ce0420af11227a9bd8) )
-	sc_pog_others
-ROM_END
-
-ROM_START( sc5pogd )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "p1918p42.hi", 0x00000, 0x080000, CRC(9e0c7ebc) SHA1(e81fd6dbb13a25afde4849e54b0f71c0f6a83ad7) )
-	ROM_LOAD16_BYTE( "p1918p42.lo", 0x00001, 0x080000, CRC(330226ed) SHA1(001953a954c73d380d772a3779f104c1dd277505) )
-	sc_pog_others
+	PR000050_POTOFGLD_1
 ROM_END
 
-ROM_START( sc5poge )
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
-	ROM_LOAD16_BYTE( "p1918s42.hi", 0x00000, 0x080000, CRC(30780d72) SHA1(6731996c6f2addf70d9abae828853dde85df4585) )
-	ROM_LOAD16_BYTE( "p1918s42.lo", 0x00001, 0x080000, CRC(b9829456) SHA1(5c5f250857cc2f96f8e1761402bd46e05df0b549) )
-	sc_pog_others
-ROM_END
 
 
 
@@ -10750,6 +10772,8 @@
 	ROM_LOAD( "p3084p12.bin", 0x0000, 0x1000000, CRC(f08e517d) SHA1(dc6f622d025fabad8302735188757a6f645ad2e3) )
 	ROM_LOAD( "p3084s11.bin", 0x0000, 0x1000000, CRC(d51a0816) SHA1(6ff1b486f29395d7f7fbe726c6c8bc185f145f93) )
 	ROM_LOAD( "p3084s12.bin", 0x0000, 0x1000000, CRC(7d33e52d) SHA1(6591834c60103f71211449355c592473180c33d9) )
+	ROM_LOAD( "39211386.bin", 0x00000, 0x1000000, CRC(05d2c75b) SHA1(7c82d48e74997b4fe2c12e56a96a7c7ca57628cb) )
+	ROM_LOAD( "39212386.bin", 0x00000, 0x1000000, CRC(4b47f4fc) SHA1(4a72df0c60968bdedac967f1989e3a4bcd7b974d) )
 
 	sc_sslam_others
 ROM_END
@@ -11051,14 +11075,14 @@
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p3010p41.hi", 0x00000, 0x080000, CRC(25ded37d) SHA1(3a24cae18d80e7f77975157d37483cecd3ed0e55) )
 	ROM_LOAD16_BYTE( "p3010p41.lo", 0x00001, 0x080000, CRC(4cfc8f4d) SHA1(ecc7bb4ce72de9f7cbdaaf4ff5182bc9d1325f45) )
-	sc_vivam_others
+	PR3010_VIVA_MEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc5vivama )
 	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD16_BYTE( "p3010s41.hi", 0x00000, 0x080000, CRC(1003cf54) SHA1(34e47911517a77dfd113af14bae4f335207f30be) )
 	ROM_LOAD16_BYTE( "p3010s41.lo", 0x00001, 0x080000, CRC(89c37841) SHA1(9b2d313c2498a1d05903490adbf9b0157a14e65f) )
-	sc_vivam_others
+	PR3010_VIVA_MEXICO_SOUNDS11
 ROM_END
 
 ROM_START( sc5wldjk )
@@ -11432,6 +11456,19 @@
 	ROM_LOAD( "p3206s11.bin", 0x0000, 0x1000000, CRC(944b7cb9) SHA1(7a7c6e5d14371ef2131a1bf40a5e4972a6518a0a) )
 	ROM_LOAD( "p3255p01.bin", 0x0000, 0x1000000, CRC(4855b7e3) SHA1(b69f9782c171a38f1f44f3eeab449d68d37ca996) )
 	ROM_LOAD( "p3255s01.bin", 0x0000, 0x1000000, CRC(e971e090) SHA1(df201580ee6189f5fabab0e6f955aac90d82f9a6) )
+
+	ROM_LOAD( "39211578.bin", 0x0000, 0x1000000, CRC(2d8a6d1b) SHA1(cc28c96d33468209192285e3b0d0690e189e4945) )
+	ROM_LOAD( "39211621.bin", 0x0000, 0x1000000, CRC(e0469d8d) SHA1(0a519c5721133f07e313d50b2199165b1f516027) )
+	ROM_LOAD( "39212578.bin", 0x0000, 0x1000000, CRC(15731e4b) SHA1(20ba14f87456a9610eb7f255fa1beae75800f3c6) )
+	ROM_LOAD( "39212621.bin", 0x0000, 0x1000000, CRC(f19c6714) SHA1(16d9c63f36be622a11036aefd39b55c6fbf162b4) )
+    ROM_LOAD( "39211622.bin", 0x00000, 0x1000000, CRC(6cd72899) SHA1(2f0d2af88276a8d45aac303a81a124ab7b743b6d) )
+    ROM_LOAD( "39211623.bin", 0x00000, 0x1000000, CRC(b65943f4) SHA1(8f281bd1b04709085254e3e352b47f187a7b5b47) )
+    ROM_LOAD( "39212622.bin", 0x00000, 0x1000000, CRC(055e639d) SHA1(b0a9427f0e8038d26b2a24425644dbda964cfa2c) )
+    ROM_LOAD( "39212623.bin", 0x00000, 0x1000000, CRC(13b1e404) SHA1(ee170ffbd8fcd552c374e550e58a455da76af5fe) )
+
+
+
+
 ROM_END
 
 
@@ -11739,6 +11776,12 @@
 	ROM_LOAD( "39212508.bin", 0x0000, 0x646fcd, CRC(811c9e4c) SHA1(34b59d319d80f45c238aca9f3ec536047427cfb3) )
 	ROM_LOAD( "39212509.bin", 0x0000, 0x646781, CRC(637a930a) SHA1(4ad90e242701b3beef5209e967795d632c5d39a4) )
 
+    ROM_LOAD( "39211172.bin", 0x00000, 0x1000000, CRC(8342c383) SHA1(cc92f7ebab0a55d2a6023ca194e81ef6154563a1) ) // video casino wow
+	ROM_LOAD( "39212172.bin", 0x00000, 0x1000000, CRC(3aed8e3a) SHA1(de5a3fc0d77bf4044a17f17f41ab5c953b500e81) ) // video casino wow
+
+	ROM_LOAD( "39211351.bin", 0x00000, 0x511189, CRC(8dd8fc7d) SHA1(54a5e2887e0df095d12beb7fbe7e5fe766c116a4) )
+    ROM_LOAD( "39212351.bin", 0x00000, 0x511189, CRC(38c7be05) SHA1(9d0057863fcd02b5d68717b3bbd5762131b15ed7) )
+
 	sc_mowow_others
 ROM_END
 
@@ -13555,8 +13598,8 @@
 GAME( 200?, sc5nmarec	,sc5nmare,	sc5, sc5, sc5, ROT0, "BFM","A Nightmare On Elm Street (Bellfruit) (Scorpion 5) (set 4)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR1612 PICK OF THE PACK         PR1612 PICK OF THE PACK SOUNDS11  PICK OF THE PACK  S.SITE
-GAME( 200?, sc5potp		,0,			sc5, sc5, sc5, ROT0, "BFM","Pick Of The Pack (Bellfruit) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potpa	,sc5potp,	sc5, sc5, sc5, ROT0, "BFM","Pick Of The Pack (Bellfruit) (Scorpion 5) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2005, sc5potp		,0,			sc5, sc5, sc5, ROT0, "BFM","Pick Of The Pack (Bellfruit) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 2005, sc5potpa	,sc5potp,	sc5, sc5, sc5, ROT0, "BFM","Pick Of The Pack (Bellfruit) (Scorpion 5) (set 2)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2562 PINK PANTHER         PINK SOUNDS         PINK PANTHER
 GAME( 200?, sc5pp		,0,			sc5, sc5, sc5, ROT0, "Mazooma","Pink Panther (Mazooma) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
@@ -13623,14 +13666,14 @@
 GAME( 200?, sc5poge		,sc5pog,	sc5, sc5, sc5, ROT0, "BFM","Pots Of Gold (Bellfruit) (Scorpion 5) (set 6)", GAME_IS_SKELETON_MECHANICAL )
 
 // Z050 POTOFGLD         PR000050 POTOFGLD 1         POTOFGLD  AWP
-GAME( 200?, sc5potog	,0,			sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potoga	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potogb	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potogc	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potogd	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potoge	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 6)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potogf	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 7)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc5potogg	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (Bellfruit) (Scorpion 5) (set 8)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potog	,0,			sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potoga	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potogb	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potogc	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potogd	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potoge	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 6)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potogf	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 7)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc5potogg	,sc5potog,	sc5, sc5, sc5, ROT0, "QPS","Pot Of Gold (QPS) (Scorpion 5) (set 8)", GAME_IS_SKELETON_MECHANICAL )
 
 // PR2272 POWER PLAY         PPLY SOUNDS
 GAME( 200?, sc5pwrpl	,0,			sc5, sc5, sc5, ROT0, "Mazooma","Power Play (Mazooma) (Scorpion 5) (set 1)", GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/bfm_swp.c src/mame/drivers/bfm_swp.c
--- src-old/mame/drivers/bfm_swp.c	2012-03-31 15:39:09.000000000 +0200
+++ src/mame/drivers/bfm_swp.c	2012-05-07 08:57:50.000000000 +0200
@@ -1,15 +1,5 @@
-/* Bellfruit SWP (Skill With Prizes) Video hardware */
-
-/*
-    This is 'Cobra 3' ?
-    is that an expansion board for Scorpion 4, or somehow related?
-    The CPU is the same (68340)
-
-    Radio Times is probably the only *COMPLETE* dump here, as it
-    includes the CD.  Other games probably have CDs or HDDs too.
-
-    Telly Addicts has a HDD dump (I'm assuming it's the same
-    platform) but no sound roms.
+/* Bellfruit SWP (Skill With Prizes) Video hardware
+    aka Cobra 3
 
 */
 
@@ -128,19 +118,80 @@
 {
 public:
 	bfm_swp_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_maincpu(*this, "maincpu")
+	{ }
+
+	UINT32* m_cpuregion;
+	UINT32* m_mainram;
+
+	DECLARE_READ32_MEMBER(bfm_swp_mem_r);
+	DECLARE_WRITE32_MEMBER(bfm_swp_mem_w);
+
 
 	UINT32 screen_update(screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect)
 	{
 		return 0;
 	}
+
+protected:
+
+	// devices
+	required_device<cpu_device> m_maincpu;
+
 };
 
 
 
+
+READ32_MEMBER(bfm_swp_state::bfm_swp_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 1:
+			if (offset<0x100000/4) return m_cpuregion[offset];
+
+		case 2:
+			offset&=0x3fff;
+			return m_mainram[offset];
+
+		default:
+			logerror("%08x maincpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
+
+WRITE32_MEMBER(bfm_swp_state::bfm_swp_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		default:
+			logerror("%08x maincpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, offset*4, data, mem_mask, cs);
+
+		case 2:
+			offset&=0x3fff;
+			COMBINE_DATA(&m_mainram[offset]);
+			break;
+
+
+	}
+
+}
+
+
+
+
 static ADDRESS_MAP_START( bfm_swp_map, AS_PROGRAM, 32, bfm_swp_state )
-	AM_RANGE(0x000000, 0x0fffff) AM_ROM
-	AM_RANGE(0xb00000, 0xb03fff) AM_RAM
+	AM_RANGE(0x00000000, 0x000fffff) AM_ROM
+	AM_RANGE(0x00000000, 0xffffffff) AM_READWRITE(bfm_swp_mem_r, bfm_swp_mem_w)
 ADDRESS_MAP_END
 
 
@@ -148,12 +199,23 @@
 INPUT_PORTS_END
 
 
+static MACHINE_START( bfm_swp )
+{
+	bfm_swp_state *state = machine.driver_data<bfm_swp_state>();
+	state->m_cpuregion = (UINT32*)state->memregion( "maincpu" )->base();
+	state->m_mainram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+
+}
+
+
 static MACHINE_CONFIG_START( bfm_swp, bfm_swp_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M68020,16000000) /* 68340 */
+	MCFG_CPU_ADD("maincpu", M68340, 16000000)
 	MCFG_CPU_PROGRAM_MAP(bfm_swp_map)
 
+	MCFG_MACHINE_START( bfm_swp )
+
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -232,8 +294,8 @@
 	ROM_LOAD( "totpsnd.lhs", 0x000000, 0x080000, CRC(56a73136) SHA1(10656ede18de9432a8a728cc59d000b5b1bf0150) )
 	ROM_LOAD( "totpsnd.rhs", 0x080000, 0x080000, CRC(28d156ab) SHA1(ebf5c4e008015b9b56b3aa5228c05b8e298daa80) )
 
-	DISK_REGION( "scsi" ) // CD or HDD
-	DISK_IMAGE_READONLY( "cd or hdd", 0, NO_DUMP )
+	DISK_REGION( "scsi" ) // uses a CD, only one we've seen has been damaged to a point where not all data could be read tho
+	DISK_IMAGE_READONLY( "cd", 0, NO_DUMP )
 ROM_END
 
 ROM_START( c3_ppays )
diff -Nru src-old/mame/drivers/bfmsys85.c src/mame/drivers/bfmsys85.c
--- src-old/mame/drivers/bfmsys85.c	2012-04-11 00:08:28.000000000 +0200
+++ src/mame/drivers/bfmsys85.c	2012-05-03 19:38:32.000000000 +0200
@@ -382,7 +382,6 @@
 
 	ROC10937_init(0,MSC1937,1);//?
 
-	awp_reel_setup();
 }
 
 // memory map for bellfruit system85 board ////////////////////////////////
diff -Nru src-old/mame/drivers/big10.c src/mame/drivers/big10.c
--- src-old/mame/drivers/big10.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/big10.c	2012-05-03 11:00:08.000000000 +0200
@@ -119,9 +119,9 @@
 {
 	switch(m_mux_data)
 	{
-		case 1: return input_port_read(machine(), "IN1");
-		case 2: return input_port_read(machine(), "IN2");
-		case 4: return input_port_read(machine(), "IN3");
+		case 1: return ioport("IN1")->read();
+		case 2: return ioport("IN2")->read();
+		case 4: return ioport("IN3")->read();
 	}
 
 	return m_mux_data;
diff -Nru src-old/mame/drivers/bigevglf.c src/mame/drivers/bigevglf.c
--- src-old/mame/drivers/bigevglf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bigevglf.c	2012-05-03 11:00:08.000000000 +0200
@@ -196,14 +196,14 @@
 {
 	static const char *const portx_name[2] = { "P1X", "P2X" };
 
-	return input_port_read(machine(), portx_name[m_port_select]);
+	return ioport(portx_name[m_port_select])->read();
 }
 
 READ8_MEMBER(bigevglf_state::beg_trackball_y_r)
 {
 	static const char *const porty_name[2] = { "P1Y", "P2Y" };
 
-	return input_port_read(machine(), porty_name[m_port_select]);
+	return ioport(porty_name[m_port_select])->read();
 }
 
 WRITE8_MEMBER(bigevglf_state::beg_port08_w)
@@ -336,7 +336,7 @@
 
     */
 	m_mcu_coin_bit5 ^= 0x20;
-	return bigevglf_mcu_status_r(space, 0) | (input_port_read(machine(), "PORT04") & 3) | m_mcu_coin_bit5;	/* bit 0 and bit 1 - coin inputs */
+	return bigevglf_mcu_status_r(space, 0) | (ioport("PORT04")->read() & 3) | m_mcu_coin_bit5;	/* bit 0 and bit 1 - coin inputs */
 }
 
 static ADDRESS_MAP_START( bigevglf_sub_portmap, AS_IO, 8, bigevglf_state )
diff -Nru src-old/mame/drivers/bionicc.c src/mame/drivers/bionicc.c
--- src-old/mame/drivers/bionicc.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bionicc.c	2012-05-03 11:00:08.000000000 +0200
@@ -87,13 +87,13 @@
 WRITE16_MEMBER(bionicc_state::bionicc_mpu_trigger_w)
 {
 
-	data = input_port_read(machine(), "SYSTEM") >> 12;
+	data = ioport("SYSTEM")->read() >> 12;
 	m_inp[0] = data ^ 0x0f;
 
-	data = input_port_read(machine(), "P2");
+	data = ioport("P2")->read();
 	m_inp[1] = data ^ 0xff;
 
-	data = input_port_read(machine(), "P1");
+	data = ioport("P1")->read();
 	m_inp[2] = data ^ 0xff;
 }
 
diff -Nru src-old/mame/drivers/bladestl.c src/mame/drivers/bladestl.c
--- src-old/mame/drivers/bladestl.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bladestl.c	2012-05-03 11:00:08.000000000 +0200
@@ -59,7 +59,7 @@
 	static const char *const port[] = { "TRACKBALL_P1_1", "TRACKBALL_P1_2", "TRACKBALL_P2_1", "TRACKBALL_P1_2" };
 	int curr, delta;
 
-	curr = input_port_read(machine(), port[offset]);
+	curr = ioport(port[offset])->read();
 	delta = (curr - m_last_track[offset]) & 0xff;
 	m_last_track[offset] = curr;
 
diff -Nru src-old/mame/drivers/blitz.c src/mame/drivers/blitz.c
--- src-old/mame/drivers/blitz.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/blitz.c	2012-05-03 11:00:08.000000000 +0200
@@ -422,10 +422,10 @@
 	blitz_state *state = device->machine().driver_data<blitz_state>();
 	switch( state->m_mux_data & 0xf0 )		/* bits 4-7 */
 	{
-		case 0x10: return input_port_read(device->machine(), "IN0-0");
-		case 0x20: return input_port_read(device->machine(), "IN0-1");
-		case 0x40: return input_port_read(device->machine(), "IN0-2");
-		case 0x80: return input_port_read(device->machine(), "IN0-3");
+		case 0x10: return state->ioport("IN0-0")->read();
+		case 0x20: return state->ioport("IN0-1")->read();
+		case 0x40: return state->ioport("IN0-2")->read();
+		case 0x80: return state->ioport("IN0-3")->read();
 	}
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/blitz68k.c src/mame/drivers/blitz68k.c
--- src-old/mame/drivers/blitz68k.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/blitz68k.c	2012-05-03 11:00:08.000000000 +0200
@@ -1156,12 +1156,12 @@
 READ16_MEMBER(blitz68k_state::hermit_track_r)
 {
 #ifdef MAME_DEBUG
-//  popmessage("track %02x %02x", input_port_read(machine(), "TRACK_X"), input_port_read(machine(), "TRACK_Y"));
+//  popmessage("track %02x %02x", ioport("TRACK_Y")->read());
 #endif
 
 	return
-		((0xf - ((input_port_read(machine(), "TRACK_Y") + 0x7) & 0xf)) << 12) |
-		((0xf - ((input_port_read(machine(), "TRACK_X") + 0x7) & 0xf)) << 8)  ;
+		((0xf - ((ioport("TRACK_Y")->read() + 0x7) & 0xf)) << 12) |
+		((0xf - ((ioport("TRACK_X")->read() + 0x7) & 0xf)) << 8)  ;
 }
 
 static ADDRESS_MAP_START( hermit_map, AS_PROGRAM, 16, blitz68k_state )
@@ -1737,14 +1737,14 @@
 //  for(i=0;i<8;i+=2)
 //      state->m_nvram[((0x8a0)+i)/2] = 0;
 	/*finally, read the inputs*/
-	state->m_nvram[0x89e/2] = input_port_read(timer.machine(), "MENU") & 0xffff;
-	state->m_nvram[0x8a0/2] = input_port_read(timer.machine(), "STAT") & 0xffff;
-	state->m_nvram[0x8a2/2] = input_port_read(timer.machine(), "BET_DEAL") & 0xffff;
-	state->m_nvram[0x8a4/2] = input_port_read(timer.machine(), "TAKE_DOUBLE") & 0xffff;
-	state->m_nvram[0x8a6/2] = input_port_read(timer.machine(), "SMALL_BIG") & 0xffff;
-	state->m_nvram[0x8a8/2] = input_port_read(timer.machine(), "CANCEL_HOLD1") & 0xffff;
-	state->m_nvram[0x8aa/2] = input_port_read(timer.machine(), "HOLD2_HOLD3") & 0xffff;
-	state->m_nvram[0x8ac/2] = input_port_read(timer.machine(), "HOLD4_HOLD5") & 0xffff;
+	state->m_nvram[0x89e/2] = timer.machine().root_device().ioport("MENU")->read() & 0xffff;
+	state->m_nvram[0x8a0/2] = timer.machine().root_device().ioport("STAT")->read() & 0xffff;
+	state->m_nvram[0x8a2/2] = timer.machine().root_device().ioport("BET_DEAL")->read() & 0xffff;
+	state->m_nvram[0x8a4/2] = timer.machine().root_device().ioport("TAKE_DOUBLE")->read() & 0xffff;
+	state->m_nvram[0x8a6/2] = timer.machine().root_device().ioport("SMALL_BIG")->read() & 0xffff;
+	state->m_nvram[0x8a8/2] = timer.machine().root_device().ioport("CANCEL_HOLD1")->read() & 0xffff;
+	state->m_nvram[0x8aa/2] = timer.machine().root_device().ioport("HOLD2_HOLD3")->read() & 0xffff;
+	state->m_nvram[0x8ac/2] = timer.machine().root_device().ioport("HOLD4_HOLD5")->read() & 0xffff;
 }
 
 
diff -Nru src-old/mame/drivers/blktiger.c src/mame/drivers/blktiger.c
--- src-old/mame/drivers/blktiger.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/blktiger.c	2012-05-03 11:00:08.000000000 +0200
@@ -59,7 +59,7 @@
 
 WRITE8_MEMBER(blktiger_state::blktiger_coinlockout_w)
 {
-	if (input_port_read(machine(), "COIN_LOCKOUT") & 0x01)
+	if (ioport("COIN_LOCKOUT")->read() & 0x01)
 	{
 		coin_lockout_w(machine(), 0,~data & 0x01);
 		coin_lockout_w(machine(), 1,~data & 0x02);
diff -Nru src-old/mame/drivers/blmbycar.c src/mame/drivers/blmbycar.c
--- src-old/mame/drivers/blmbycar.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/blmbycar.c	2012-05-03 11:00:08.000000000 +0200
@@ -62,7 +62,7 @@
 {
 
 	if (ACCESSING_BITS_0_7)
-		m_pot_wheel = ~input_port_read(machine(), "WHEEL") & 0xff;
+		m_pot_wheel = ~ioport("WHEEL")->read() & 0xff;
 }
 
 WRITE16_MEMBER(blmbycar_state::blmbycar_pot_wheel_shift_w)
@@ -86,7 +86,7 @@
 
 READ16_MEMBER(blmbycar_state::blmbycar_opt_wheel_r)
 {
-	return (~input_port_read(machine(), "WHEEL") & 0xff) << 8;
+	return (~ioport("WHEEL")->read() & 0xff) << 8;
 }
 
 
diff -Nru src-old/mame/drivers/blockade.c src/mame/drivers/blockade.c
--- src-old/mame/drivers/blockade.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/blockade.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 	blockade_state *state = device->machine().driver_data<blockade_state>();
 	device_resume(device, SUSPEND_ANY_REASON);
 
-	if ((input_port_read(device->machine(), "IN0") & 0x80) == 0)
+	if ((state->ioport("IN0")->read() & 0x80) == 0)
 	{
 		state->m_just_been_reset = 1;
 		device_set_input_line(device, INPUT_LINE_RESET, PULSE_LINE);
@@ -79,7 +79,7 @@
 READ8_MEMBER(blockade_state::blockade_input_port_0_r)
 {
 	/* coin latch is bit 7 */
-	UINT8 temp = (input_port_read(machine(), "IN0") & 0x7f);
+	UINT8 temp = (ioport("IN0")->read() & 0x7f);
 
 	return (m_coin_latch << 7) | temp;
 }
@@ -183,7 +183,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN3")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -226,7 +226,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( blasto )
@@ -271,7 +271,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( hustle )
@@ -315,7 +315,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( mineswpr )
@@ -357,7 +357,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( mineswpr4 )
@@ -399,7 +399,7 @@
 
 	PORT_START("IN3")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/bloodbro.c src/mame/drivers/bloodbro.c
--- src-old/mame/drivers/bloodbro.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bloodbro.c	2012-05-03 11:00:08.000000000 +0200
@@ -1,6 +1,6 @@
 /**************************************************************************
 
-Blood Bros, West Story [+Sky Smasher]
+Blood Bros, West Story & Sky Smasher
 TAD Corporation 1990
 68000 + Z80 + YM3931 + YM3812
 
@@ -14,11 +14,23 @@
 - runs too fast? (vblank flag somewhere?)
 
 
+Blood Bros  (c) 1990 Nihon System [Seibu hardware]
+-----------
+The manual states:
+
+ At Power On, if you touch the joystick, you will have DIP-SW setting on
+ the screen
+
+This works for all sets and the bootleg.
+
 Sky Smasher  (c) 1990 Nihon System [Seibu hardware]
 -----------
 
 Like some other Seibu hardware games, hold P1 right at boot to
-view DIP descriptions.
+view DIP descriptions. The manual states:
+
+ At Power On, if you touch the joystick or SHOOT or MISSILE button, you will
+ have DIP-SW setting on the screen
 
 Game does not appear to have cocktail mode. The screen hardware
 is undoubtedly capable of flipscreen and layer priority flipping
@@ -100,8 +112,8 @@
     Dip Switch as in 'toki' (same manufacturer and similar hardware).
 
 
-DIP locations verified for:
-    - bloodbro (manual)
+DIP locations verified for Blood Bros. & Sky Smasher via manual & DIP-SW setting
+    screens at power up.
 
 **************************************************************************/
 
@@ -162,7 +174,7 @@
 	PORT_DIPSETTING(      0x0001, "Mode 1" ) \
 	PORT_DIPSETTING(      0x0000, "Mode 2" ) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) )           PORT_DIPLOCATION("SW1:2,3,4,5") PORT_CONDITION("DSW",0x0001,PORTCOND_EQUALS,0x0001) \
+	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) )           PORT_DIPLOCATION("SW1:2,3,4,5") PORT_CONDITION("DSW",0x0001,EQUALS,0x0001) \
 	PORT_DIPSETTING(      0x0014, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(      0x0016, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(      0x0018, DEF_STR( 4C_1C ) ) \
@@ -180,12 +192,12 @@
 	PORT_DIPSETTING(      0x000a, DEF_STR( 1C_6C ) ) \
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) ) \
 	/* Coin Mode 2 */ \
-    PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) )            PORT_DIPLOCATION("SW1:2,3") PORT_CONDITION("DSW",0x0001,PORTCOND_EQUALS,0x0000) \
+    PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) )            PORT_DIPLOCATION("SW1:2,3") PORT_CONDITION("DSW",0x0001,EQUALS,0x0000) \
     PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) ) \
     PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) ) \
     PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) ) \
     PORT_DIPSETTING(      0x0006, DEF_STR( 1C_1C ) ) \
-    PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) )            PORT_DIPLOCATION("SW1:4,5") PORT_CONDITION("DSW",0x0001,PORTCOND_EQUALS,0x0000) \
+    PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) )            PORT_DIPLOCATION("SW1:4,5") PORT_CONDITION("DSW",0x0001,EQUALS,0x0000) \
     PORT_DIPSETTING(      0x0018, DEF_STR( 1C_2C ) ) \
     PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) ) \
     PORT_DIPSETTING(      0x0008, DEF_STR( 1C_5C ) ) \
@@ -474,89 +486,89 @@
 
 ROM_START( bloodbro )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "2j.u021",      0x00001, 0x20000, CRC(c0fdc3e4) SHA1(31968f693de2054a0c8ba50a8d44a371dd9c2848) )
-	ROM_LOAD16_BYTE( "1j.i022",      0x00000, 0x20000, CRC(2d7e0fdf) SHA1(8fe22d8a1ef7d562a475a5b6c98303b0cb1af561) )
-	ROM_LOAD16_BYTE( "bb_04.bin",    0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
-	ROM_LOAD16_BYTE( "bb_03.bin",    0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
+	ROM_LOAD16_BYTE( "2j.u021",   0x00001, 0x20000, CRC(c0fdc3e4) SHA1(31968f693de2054a0c8ba50a8d44a371dd9c2848) )
+	ROM_LOAD16_BYTE( "1j.i022",   0x00000, 0x20000, CRC(2d7e0fdf) SHA1(8fe22d8a1ef7d562a475a5b6c98303b0cb1af561) )
+	ROM_LOAD16_BYTE( "bb_04.bin", 0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
+	ROM_LOAD16_BYTE( "bb_03.bin", 0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 )
-	ROM_LOAD( "bb_07.bin",    0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "bb_07.bin",   0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "bb_05.bin",    0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
-	ROM_LOAD( "bb_06.bin",    0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
+	ROM_LOAD( "bb_05.bin", 0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
+	ROM_LOAD( "bb_06.bin", 0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
 
 	ROM_REGION( 0x100000, "gfx2", 0 )
-	ROM_LOAD( "bloodb.bk",   0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
+	ROM_LOAD( "bloodb.bk", 0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
 
 	ROM_REGION( 0x100000, "gfx3", 0 )
-	ROM_LOAD( "bloodb.obj",   0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
+	ROM_LOAD( "bloodb.obj", 0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
-	ROM_LOAD( "bb_08.bin",    0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
+	ROM_LOAD( "bb_08.bin",  0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
 ROM_END
 
 ROM_START( bloodbroa )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "2j.21",    0x00001, 0x20000, CRC(e8ca21b8) SHA1(65330368c29ec64ca03124d28a7f8b49d7a15566) )
-	ROM_LOAD16_BYTE( "1j.22",    0x00000, 0x20000, CRC(6b28cfc7) SHA1(dedd06cab61381f3e27dc14315f283d707d06bcb) )
-	ROM_LOAD16_BYTE( "bb_04.bin",    0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
-	ROM_LOAD16_BYTE( "bb_03.bin",    0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
+	ROM_LOAD16_BYTE( "2j.21",     0x00001, 0x20000, CRC(e8ca21b8) SHA1(65330368c29ec64ca03124d28a7f8b49d7a15566) )
+	ROM_LOAD16_BYTE( "1j.22",     0x00000, 0x20000, CRC(6b28cfc7) SHA1(dedd06cab61381f3e27dc14315f283d707d06bcb) )
+	ROM_LOAD16_BYTE( "bb_04.bin", 0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
+	ROM_LOAD16_BYTE( "bb_03.bin", 0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 )
-	ROM_LOAD( "bb_07.bin",    0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "bb_07.bin",   0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "bb_05.bin",    0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
-	ROM_LOAD( "bb_06.bin",    0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
+	ROM_LOAD( "bb_05.bin", 0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
+	ROM_LOAD( "bb_06.bin", 0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
 
 	ROM_REGION( 0x100000, "gfx2", 0 )
-	ROM_LOAD( "bloodb.bk",   0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
+	ROM_LOAD( "bloodb.bk", 0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
 
 	ROM_REGION( 0x100000, "gfx3", 0 )
-	ROM_LOAD( "bloodb.obj",   0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
+	ROM_LOAD( "bloodb.obj", 0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
-	ROM_LOAD( "bb_08.bin",    0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
+	ROM_LOAD( "bb_08.bin", 0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
 ROM_END
 
 ROM_START( bloodbrob )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "bloodbros02.bin",    0x00001, 0x20000, CRC(204dca6e) SHA1(f04cb2116d699ac2deec2d55597beb5d7b3dc793) )
-	ROM_LOAD16_BYTE( "bloodbros01.bin",    0x00000, 0x20000, CRC(ac6719e7) SHA1(bcefd61ed5d2f5eeb4424243f03037c7d123b9f6) )
-	ROM_LOAD16_BYTE( "bb_04.bin",    0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
-	ROM_LOAD16_BYTE( "bb_03.bin",    0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
+	ROM_LOAD16_BYTE( "bloodbros02.bin", 0x00001, 0x20000, CRC(204dca6e) SHA1(f04cb2116d699ac2deec2d55597beb5d7b3dc793) )
+	ROM_LOAD16_BYTE( "bloodbros01.bin", 0x00000, 0x20000, CRC(ac6719e7) SHA1(bcefd61ed5d2f5eeb4424243f03037c7d123b9f6) )
+	ROM_LOAD16_BYTE( "bb_04.bin",       0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
+	ROM_LOAD16_BYTE( "bb_03.bin",       0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 )
-	ROM_LOAD( "bb_07.bin",    0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
-	ROM_CONTINUE(             0x010000, 0x08000 )
+	ROM_LOAD( "bb_07.bin",   0x000000, 0x08000, CRC(411b94e8) SHA1(6968441f64212c0935afeca68f07deaadf86d614) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "bb_05.bin",    0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
-	ROM_LOAD( "bb_06.bin",    0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
+	ROM_LOAD( "bb_05.bin", 0x00000, 0x10000, CRC(04ba6d19) SHA1(7333075c3323756d51917418b5234d785a9bee00) )	/* characters */
+	ROM_LOAD( "bb_06.bin", 0x10000, 0x10000, CRC(7092e35b) SHA1(659d30b2e2fd9ffa34a47e98193c8f0a87ac1315) )
 
 	ROM_REGION( 0x100000, "gfx2", 0 )
-	ROM_LOAD( "bloodb.bk",   0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
+	ROM_LOAD( "bloodb.bk", 0x00000, 0x100000, CRC(1aa87ee6) SHA1(e7843c1e8a0f3a685f0b5d6e3a2eb3176c410847) )	/* Background+Foreground */
 
 	ROM_REGION( 0x100000, "gfx3", 0 )
-	ROM_LOAD( "bloodb.obj",   0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
+	ROM_LOAD( "bloodb.obj", 0x00000, 0x100000, CRC(d27c3952) SHA1(de7306432b682f238b911507ad7aa2fa8acbee80) )	/* sprites */
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
-	ROM_LOAD( "bb_08.bin",    0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
+	ROM_LOAD( "bb_08.bin", 0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
 ROM_END
 
 
 ROM_START( weststry )
 	ROM_REGION( 0x80000, "maincpu", 0 )	/* 64k for cpu code */
-	ROM_LOAD16_BYTE( "ws13.bin",    0x00001, 0x20000, CRC(158e302a) SHA1(52cc1bf526424ff025a6b79f3fc7bba4b9bbfcbb) )
-	ROM_LOAD16_BYTE( "ws15.bin",    0x00000, 0x20000, CRC(672e9027) SHA1(71cb9fcef04edb972ba88de45d605dcff539ea2d) )
-	ROM_LOAD16_BYTE( "bb_04.bin",   0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
-	ROM_LOAD16_BYTE( "bb_03.bin",   0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
+	ROM_LOAD16_BYTE( "ws13.bin",  0x00001, 0x20000, CRC(158e302a) SHA1(52cc1bf526424ff025a6b79f3fc7bba4b9bbfcbb) )
+	ROM_LOAD16_BYTE( "ws15.bin",  0x00000, 0x20000, CRC(672e9027) SHA1(71cb9fcef04edb972ba88de45d605dcff539ea2d) )
+	ROM_LOAD16_BYTE( "bb_04.bin", 0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
+	ROM_LOAD16_BYTE( "bb_03.bin", 0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 )	/* 64k for sound cpu code */
 	ROM_LOAD( "ws17.bin",    0x000000, 0x08000, CRC(e00a8f09) SHA1(e7247ce0ab99d0726f31dee5de5ba33f4ebd183e) )
@@ -564,70 +576,70 @@
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
 	ROM_REGION( 0x20000, "gfx1", 0 ) // first half of these is blank
-	ROM_LOAD( "ws09.bin",    0x00000, 0x08000, CRC(f05b2b3e) SHA1(6570d795d68655ace9668f32dc0bf5c2d2372411) )	/* characters */
-	ROM_CONTINUE(            0x00000, 0x08000 )
-	ROM_LOAD( "ws11.bin",    0x08000, 0x08000, CRC(2b10e3d2) SHA1(0f5045615b44e2300745fd3afac7f1441352cca5) )
-	ROM_CONTINUE(            0x08000, 0x08000 )
-	ROM_LOAD( "ws10.bin",    0x10000, 0x08000, CRC(efdf7c82) SHA1(65392697f56473cfe90d9733b9c49f2da6f9b7e6) )
-	ROM_CONTINUE(            0x10000, 0x08000 )
-	ROM_LOAD( "ws12.bin",    0x18000, 0x08000, CRC(af993578) SHA1(b250b562deeab3bb2c79002e5e1f0b6e17986848) )
-	ROM_CONTINUE(            0x18000, 0x08000 )
+	ROM_LOAD( "ws09.bin", 0x00000, 0x08000, CRC(f05b2b3e) SHA1(6570d795d68655ace9668f32dc0bf5c2d2372411) )	/* characters */
+	ROM_CONTINUE(         0x00000, 0x08000 )
+	ROM_LOAD( "ws11.bin", 0x08000, 0x08000, CRC(2b10e3d2) SHA1(0f5045615b44e2300745fd3afac7f1441352cca5) )
+	ROM_CONTINUE(         0x08000, 0x08000 )
+	ROM_LOAD( "ws10.bin", 0x10000, 0x08000, CRC(efdf7c82) SHA1(65392697f56473cfe90d9733b9c49f2da6f9b7e6) )
+	ROM_CONTINUE(         0x10000, 0x08000 )
+	ROM_LOAD( "ws12.bin", 0x18000, 0x08000, CRC(af993578) SHA1(b250b562deeab3bb2c79002e5e1f0b6e17986848) )
+	ROM_CONTINUE(         0x18000, 0x08000 )
 
 	ROM_REGION( 0x100000, "gfx2", 0 )
-	ROM_LOAD( "ws01.bin",    0x20000, 0x20000, CRC(32bda4bc) SHA1(ed0c0740c7af513b341b2b7ff3e0bf6045e930e9) )	/* Foreground */
-	ROM_LOAD( "ws03.bin",    0x60000, 0x20000, CRC(046b51f8) SHA1(25af752caebdec762582fc0130cf14546110bb54) )
-	ROM_LOAD( "ws02.bin",    0xa0000, 0x20000, CRC(ed9d682e) SHA1(0f79ea09a7af367d175081f72f2bc94f6caad463) )
-	ROM_LOAD( "ws04.bin",    0xe0000, 0x20000, CRC(75f082e5) SHA1(b29f09a3cc9a0ac3f982be3981f5e895050c49e8) )
-	ROM_LOAD( "ws05.bin",    0x00000, 0x20000, CRC(007c8dc0) SHA1(f44576da3b89d6a889fdb564825ac6ce3bb4cffe) )	/* Background */
-	ROM_LOAD( "ws07.bin",    0x40000, 0x20000, CRC(0f0c8d9a) SHA1(f5fe9b5ee4c8ffd7caf5313d13fb5f6e181ed9b6) )
-	ROM_LOAD( "ws06.bin",    0x80000, 0x20000, CRC(459d075e) SHA1(24cd0bffe7c5bbccf653ced0b73579059603d187) )
-	ROM_LOAD( "ws08.bin",    0xc0000, 0x20000, CRC(4d6783b3) SHA1(9870fe9570afeff179b6080581fd6bb187898ff0) )
+	ROM_LOAD( "ws01.bin", 0x20000, 0x20000, CRC(32bda4bc) SHA1(ed0c0740c7af513b341b2b7ff3e0bf6045e930e9) )	/* Foreground */
+	ROM_LOAD( "ws03.bin", 0x60000, 0x20000, CRC(046b51f8) SHA1(25af752caebdec762582fc0130cf14546110bb54) )
+	ROM_LOAD( "ws02.bin", 0xa0000, 0x20000, CRC(ed9d682e) SHA1(0f79ea09a7af367d175081f72f2bc94f6caad463) )
+	ROM_LOAD( "ws04.bin", 0xe0000, 0x20000, CRC(75f082e5) SHA1(b29f09a3cc9a0ac3f982be3981f5e895050c49e8) )
+	ROM_LOAD( "ws05.bin", 0x00000, 0x20000, CRC(007c8dc0) SHA1(f44576da3b89d6a889fdb564825ac6ce3bb4cffe) )	/* Background */
+	ROM_LOAD( "ws07.bin", 0x40000, 0x20000, CRC(0f0c8d9a) SHA1(f5fe9b5ee4c8ffd7caf5313d13fb5f6e181ed9b6) )
+	ROM_LOAD( "ws06.bin", 0x80000, 0x20000, CRC(459d075e) SHA1(24cd0bffe7c5bbccf653ced0b73579059603d187) )
+	ROM_LOAD( "ws08.bin", 0xc0000, 0x20000, CRC(4d6783b3) SHA1(9870fe9570afeff179b6080581fd6bb187898ff0) )
 
 	ROM_REGION( 0x100000, "gfx3", ROMREGION_INVERT )
-	ROM_LOAD( "ws25.bin",    0x00000, 0x20000, BAD_DUMP CRC(8092e8e9) SHA1(eabe58ac0f88234b0dddf361f56aad509a83012e) )	/* sprites */
-	ROM_LOAD( "ws26.bin",    0x20000, 0x20000, BAD_DUMP CRC(f6a1f42c) SHA1(6d5503e1a9b00104970292d22301ed28893c5223) )
-	ROM_LOAD( "ws23.bin",    0x40000, 0x20000, CRC(43d58e24) SHA1(99e255faa9716d9102a1223419084fc209ab4024) )
-	ROM_LOAD( "ws24.bin",    0x60000, 0x20000, CRC(20a867ea) SHA1(d3985002931fd4180fc541d61a94371871f3709d) )
-	ROM_LOAD( "ws21.bin",    0x80000, 0x20000, CRC(e23d7296) SHA1(33bbced960be22efc7d2681e06a27feba09e0fc0) )
-	ROM_LOAD( "ws22.bin",    0xa0000, 0x20000, CRC(7150a060) SHA1(73bdd7d6752f7fe9e23073d835dbc468d57865fa) )
-	ROM_LOAD( "ws19.bin",    0xc0000, 0x20000, CRC(c5dd0a96) SHA1(4696ab1b02d40c54a7dacf0bdf90b624b7d6812e) )
-	ROM_LOAD( "ws20.bin",    0xe0000, 0x20000, CRC(f1245c16) SHA1(f3941bf5830995f65a5378326fdb72687fbbddcf) )
+	ROM_LOAD( "ws25.bin", 0x00000, 0x20000, BAD_DUMP CRC(8092e8e9) SHA1(eabe58ac0f88234b0dddf361f56aad509a83012e) )	/* sprites */
+	ROM_LOAD( "ws26.bin", 0x20000, 0x20000, BAD_DUMP CRC(f6a1f42c) SHA1(6d5503e1a9b00104970292d22301ed28893c5223) )
+	ROM_LOAD( "ws23.bin", 0x40000, 0x20000, CRC(43d58e24) SHA1(99e255faa9716d9102a1223419084fc209ab4024) )
+	ROM_LOAD( "ws24.bin", 0x60000, 0x20000, CRC(20a867ea) SHA1(d3985002931fd4180fc541d61a94371871f3709d) )
+	ROM_LOAD( "ws21.bin", 0x80000, 0x20000, CRC(e23d7296) SHA1(33bbced960be22efc7d2681e06a27feba09e0fc0) )
+	ROM_LOAD( "ws22.bin", 0xa0000, 0x20000, CRC(7150a060) SHA1(73bdd7d6752f7fe9e23073d835dbc468d57865fa) )
+	ROM_LOAD( "ws19.bin", 0xc0000, 0x20000, CRC(c5dd0a96) SHA1(4696ab1b02d40c54a7dacf0bdf90b624b7d6812e) )
+	ROM_LOAD( "ws20.bin", 0xe0000, 0x20000, CRC(f1245c16) SHA1(f3941bf5830995f65a5378326fdb72687fbbddcf) )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
-	ROM_LOAD( "bb_08.bin",    0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
+	ROM_LOAD( "bb_08.bin", 0x00000, 0x20000, CRC(deb1b975) SHA1(08f2e9a0a23171201b71d381d091edcd3787c287) )
 ROM_END
 
 ROM_START( skysmash )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "rom5",    0x00000, 0x20000, CRC(867f9897) SHA1(7751f9d03d71bd5db0b82bda6e4d5231a30c1ad0) )
-	ROM_LOAD16_BYTE( "rom6",    0x00001, 0x20000, CRC(e9c1d308) SHA1(d7032345b91f87de64ad09ffea49e39b755cac44) )
-	ROM_LOAD16_BYTE( "rom7",    0x40000, 0x20000, CRC(d209db4d) SHA1(1cf85d39d12e92c1b97f7e5a148f3ad56cdca963) )
-	ROM_LOAD16_BYTE( "rom8",    0x40001, 0x20000, CRC(d3646728) SHA1(898606be662214d2ba99e9a3e3cc0c7e7609a719) )
+	ROM_LOAD16_BYTE( "rom5", 0x00000, 0x20000, CRC(867f9897) SHA1(7751f9d03d71bd5db0b82bda6e4d5231a30c1ad0) )
+	ROM_LOAD16_BYTE( "rom6", 0x00001, 0x20000, CRC(e9c1d308) SHA1(d7032345b91f87de64ad09ffea49e39b755cac44) )
+	ROM_LOAD16_BYTE( "rom7", 0x40000, 0x20000, CRC(d209db4d) SHA1(1cf85d39d12e92c1b97f7e5a148f3ad56cdca963) )
+	ROM_LOAD16_BYTE( "rom8", 0x40001, 0x20000, CRC(d3646728) SHA1(898606be662214d2ba99e9a3e3cc0c7e7609a719) )
 
 	ROM_REGION( 0x20000, "audiocpu", 0 )
-	ROM_LOAD( "rom2",    0x000000, 0x08000, CRC(75b194cf) SHA1(6aaf36cdab06c0aa5328f5176557387a5d3f7d26) )
-	ROM_CONTINUE(        0x010000, 0x08000 )
+	ROM_LOAD( "rom2",        0x000000, 0x08000, CRC(75b194cf) SHA1(6aaf36cdab06c0aa5328f5176557387a5d3f7d26) )
+	ROM_CONTINUE(            0x010000, 0x08000 )
 	ROM_COPY( "audiocpu", 0, 0x018000, 0x08000 )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "rom3",    0x00000, 0x10000, CRC(fbb241be) SHA1(cd94c328891538bbd8c062d90a47ddf3d7d05bb0) )	/* characters */
-	ROM_LOAD( "rom4",    0x10000, 0x10000, CRC(ad3cde81) SHA1(2bd0c707e5b67d3699a743d989cb5384cbe37ff7) )
+	ROM_LOAD( "rom3", 0x00000, 0x10000, CRC(fbb241be) SHA1(cd94c328891538bbd8c062d90a47ddf3d7d05bb0) )	/* characters */
+	ROM_LOAD( "rom4", 0x10000, 0x10000, CRC(ad3cde81) SHA1(2bd0c707e5b67d3699a743d989cb5384cbe37ff7) )
 
 	ROM_REGION( 0x100000, "gfx2", 0 )
-	ROM_LOAD( "rom9",    0x00000, 0x100000, CRC(b0a5eecf) SHA1(9e8191c7ae4a32dc16aebc37fa942afc531eddd4) )	/* Background + Foreground */
+	ROM_LOAD( "rom9", 0x00000, 0x100000, CRC(b0a5eecf) SHA1(9e8191c7ae4a32dc16aebc37fa942afc531eddd4) )	/* Background + Foreground */
 
 	ROM_REGION( 0x80000, "gfx3", 0 )
-	ROM_LOAD( "rom10",   0x00000, 0x080000, CRC(1bbcda5d) SHA1(63915221f70a7dfda6a4d8ac7f5c663c9316610a) )	/* sprites */
+	ROM_LOAD( "rom10", 0x00000, 0x080000, CRC(1bbcda5d) SHA1(63915221f70a7dfda6a4d8ac7f5c663c9316610a) )	/* sprites */
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* ADPCM samples */
-	ROM_LOAD( "rom1",    0x00000, 0x20000, CRC(e69986f6) SHA1(de38bf2d5638cb40740882e1abccf7928e43a5a6) )
+	ROM_LOAD( "rom1", 0x00000, 0x20000, CRC(e69986f6) SHA1(de38bf2d5638cb40740882e1abccf7928e43a5a6) )
 ROM_END
 
 
 /* Game Drivers */
 
-GAME( 1990, bloodbro, 0,        bloodbro, bloodbro, 0,        ROT0,   "TAD Corporation", "Blood Bros. (set 1)", GAME_NO_COCKTAIL )
-GAME( 1990, bloodbroa,bloodbro, bloodbro, bloodbro, 0,        ROT0,   "TAD Corporation", "Blood Bros. (set 2)", GAME_NO_COCKTAIL )
-GAME( 1990, bloodbrob,bloodbro, bloodbro, bloodbro, 0,        ROT0,   "TAD Corporation", "Blood Bros. (set 3)", GAME_NO_COCKTAIL )
-GAME( 1990, weststry, bloodbro, weststry, weststry, 0,        ROT0,   "bootleg (Datsu)", "West Story (bootleg of Blood Bros.)", GAME_NO_COCKTAIL | GAME_NO_SOUND )
-GAME( 1990, skysmash, 0,        skysmash, skysmash, 0,        ROT270, "Nihon System", "Sky Smasher", 0 )
+GAME( 1990, bloodbro, 0,        bloodbro, bloodbro, 0, ROT0,   "TAD Corporation", "Blood Bros. (set 1)", GAME_NO_COCKTAIL )
+GAME( 1990, bloodbroa,bloodbro, bloodbro, bloodbro, 0, ROT0,   "TAD Corporation", "Blood Bros. (set 2)", GAME_NO_COCKTAIL )
+GAME( 1990, bloodbrob,bloodbro, bloodbro, bloodbro, 0, ROT0,   "TAD Corporation", "Blood Bros. (set 3)", GAME_NO_COCKTAIL )
+GAME( 1990, weststry, bloodbro, weststry, weststry, 0, ROT0,   "bootleg (Datsu)", "West Story (bootleg of Blood Bros.)", GAME_NO_COCKTAIL | GAME_NO_SOUND )
+GAME( 1990, skysmash, 0,        skysmash, skysmash, 0, ROT270, "Nihon System",    "Sky Smasher", 0 )
diff -Nru src-old/mame/drivers/blstroid.c src/mame/drivers/blstroid.c
--- src-old/mame/drivers/blstroid.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/blstroid.c	2012-05-03 11:00:08.000000000 +0200
@@ -74,7 +74,7 @@
 READ16_MEMBER(blstroid_state::inputs_r)
 {
 	static const char *const iptnames[] = { "IN0", "IN1" };
-	int temp = input_port_read(machine(), iptnames[offset & 1]);
+	int temp = ioport(iptnames[offset & 1])->read();
 
 	if (m_cpu_to_sound_ready) temp ^= 0x0040;
 	if (atarigen_get_hblank(*machine().primary_screen)) temp ^= 0x0010;
@@ -135,7 +135,7 @@
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )
-	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -146,7 +146,7 @@
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )
-	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/bmcbowl.c src/mame/drivers/bmcbowl.c
--- src-old/mame/drivers/bmcbowl.c	2012-04-19 09:47:35.000000000 +0200
+++ src/mame/drivers/bmcbowl.c	2012-05-03 11:00:08.000000000 +0200
@@ -230,7 +230,7 @@
 
 static READ8_DEVICE_HANDLER(via_b_in)
 {
-	return input_port_read(device->machine(), "IN3");
+	return device->machine().root_device().ioport("IN3")->read();
 }
 
 
@@ -444,7 +444,7 @@
 	PORT_START("IN3")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(1)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 INPUT_PORTS_END
 
@@ -453,8 +453,8 @@
 	bmcbowl_state *state = device->machine().driver_data<bmcbowl_state>();
 	switch(state->m_bmc_input)
 	{
-			case 0x00:	return  input_port_read(device->machine(), "IN1");
-			case 0x40:	return  input_port_read(device->machine(), "IN2");
+			case 0x00:	return  state->ioport("IN1")->read();
+			case 0x40:	return  state->ioport("IN2")->read();
 	}
 	logerror("%s:unknown input - %X\n",device->machine().describe_context(),state->m_bmc_input);
 	return 0xff;
diff -Nru src-old/mame/drivers/bmcpokr.c src/mame/drivers/bmcpokr.c
--- src-old/mame/drivers/bmcpokr.c	2012-03-31 15:39:09.000000000 +0200
+++ src/mame/drivers/bmcpokr.c	2012-05-07 08:57:50.000000000 +0200
@@ -48,16 +48,30 @@
 public:
 	bmcpokr_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this,"maincpu"),
+		m_videoram(*this, "videoram")
 		{ }
 
+	DECLARE_READ16_MEMBER( bmcpokr_unk_r )
+	{
+		return space.machine().rand();
+	}
+
 	required_device<cpu_device> m_maincpu;
+	required_shared_ptr<UINT16> m_videoram;
 };
 
 
 
 static ADDRESS_MAP_START( bmcpokr_mem, AS_PROGRAM, 16, bmcpokr_state )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
+	AM_RANGE(0x210000, 0x21ffff) AM_RAM
+
+	AM_RANGE(0x2c0000, 0x2dffff) AM_RAM AM_SHARE("videoram")
+
+	AM_RANGE(0x2FF800, 0x2FFFFF) AM_RAM
+	AM_RANGE(0x34001A, 0x34001B) AM_READ(bmcpokr_unk_r)
+
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( bmcpokr )
@@ -185,6 +199,24 @@
 
 SCREEN_UPDATE_IND16( bmcpokr )
 {
+	bmcpokr_state *state = screen.machine().driver_data<bmcpokr_state>();
+	const gfx_element *gfx = screen.machine().gfx[0];
+
+	int count = 0;
+	for (int y=0;y<32;y++)
+	{
+		for (int x=0;x<64;x++)
+		{
+			UINT16 data = state->m_videoram[count];
+			count++;
+
+			drawgfx_opaque(bitmap,cliprect,gfx,data,0,0,0,x*8,y*8);
+
+		}
+	}
+
+
+
 	return 0;
 }
 
@@ -197,7 +229,7 @@
 static MACHINE_CONFIG_START( bmcpokr, bmcpokr_state )
 	MCFG_CPU_ADD("maincpu", M68000, XTAL_42MHz/4)
 	MCFG_CPU_PROGRAM_MAP(bmcpokr_mem)
-	//MCFG_CPU_VBLANK_INT("screen",irq3_line_hold)
+	MCFG_CPU_VBLANK_INT("screen",irq3_line_hold)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
diff -Nru src-old/mame/drivers/bnstars.c src/mame/drivers/bnstars.c
--- src-old/mame/drivers/bnstars.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bnstars.c	2012-05-03 11:00:08.000000000 +0200
@@ -1246,28 +1246,28 @@
 			return 0xffffffff;
 
 		case 0x0000:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 
 		case 0x0080:
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 
 		case 0x2000:
-			return input_port_read(machine(), "IN2");
+			return ioport("IN2")->read();
 
 		case 0x2080:
-			return input_port_read(machine(), "IN3");
+			return ioport("IN3")->read();
 
 	}
 }
 
 READ32_MEMBER(bnstars_state::bnstars2_r)
 {
-	return input_port_read(machine(), "IN4");
+	return ioport("IN4")->read();
 }
 
 READ32_MEMBER(bnstars_state::bnstars3_r)
 {
-	return input_port_read(machine(), "IN5");
+	return ioport("IN5")->read();
 }
 
 WRITE32_MEMBER(bnstars_state::bnstars1_mahjong_select_w)
diff -Nru src-old/mame/drivers/bogeyman.c src/mame/drivers/bogeyman.c
--- src-old/mame/drivers/bogeyman.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bogeyman.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,7 +81,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2")
diff -Nru src-old/mame/drivers/boogwing.c src/mame/drivers/boogwing.c
--- src-old/mame/drivers/boogwing.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/boogwing.c	2012-05-03 11:00:08.000000000 +0200
@@ -148,7 +148,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")
 	PORT_DIPNAME( 0x0007, 0x0007, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2,3")
diff -Nru src-old/mame/drivers/boxer.c src/mame/drivers/boxer.c
--- src-old/mame/drivers/boxer.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/boxer.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,12 +81,12 @@
 
 		memset(mask, 0, sizeof mask);
 
-		mask[input_port_read(machine, "STICK0_X")] |= 0x01;
-		mask[input_port_read(machine, "STICK0_Y")] |= 0x02;
-		mask[input_port_read(machine, "PADDLE0")]  |= 0x04;
-		mask[input_port_read(machine, "STICK1_X")] |= 0x08;
-		mask[input_port_read(machine, "STICK1_Y")] |= 0x10;
-		mask[input_port_read(machine, "PADDLE1")]  |= 0x20;
+		mask[state->ioport("STICK0_X")->read()] |= 0x01;
+		mask[state->ioport("STICK0_Y")->read()] |= 0x02;
+		mask[state->ioport("PADDLE0")->read()]  |= 0x04;
+		mask[state->ioport("STICK1_X")->read()] |= 0x08;
+		mask[state->ioport("STICK1_Y")->read()] |= 0x10;
+		mask[state->ioport("PADDLE1")->read()]  |= 0x20;
 
 		for (i = 1; i < 256; i++)
 			if (mask[i] != 0)
@@ -203,9 +203,9 @@
 
 READ8_MEMBER(boxer_state::boxer_input_r)
 {
-	UINT8 val = input_port_read(machine(), "IN0");
+	UINT8 val = ioport("IN0")->read();
 
-	if (input_port_read(machine(), "IN3") < machine().primary_screen->vpos())
+	if (ioport("IN3")->read() < machine().primary_screen->vpos())
 		val |= 0x02;
 
 	return (val << ((offset & 7) ^ 7)) & 0x80;
@@ -227,11 +227,11 @@
 		break;
 
 	case 2:
-		val = input_port_read(machine(), "IN1");
+		val = ioport("IN1")->read();
 		break;
 
 	case 3:
-		val = input_port_read(machine(), "IN2");
+		val = ioport("IN2")->read();
 		break;
 	}
 
diff -Nru src-old/mame/drivers/brkthru.c src/mame/drivers/brkthru.c
--- src-old/mame/drivers/brkthru.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/brkthru.c	2012-05-03 11:00:08.000000000 +0200
@@ -181,7 +181,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )	/* used only by the self test */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* used only by the self test */
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2")
diff -Nru src-old/mame/drivers/bsktball.c src/mame/drivers/bsktball.c
--- src-old/mame/drivers/bsktball.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/bsktball.c	2012-05-03 11:00:08.000000000 +0200
@@ -128,7 +128,7 @@
 	/* 0x80 - DR3 = PL1 V DIR */
 
 	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_TILT )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* SPARE */
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* TEST STEP */
diff -Nru src-old/mame/drivers/btime.c src/mame/drivers/btime.c
--- src-old/mame/drivers/btime.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/btime.c	2012-05-03 11:00:08.000000000 +0200
@@ -223,7 +223,7 @@
 	/* however if the previous instruction was JSR (which caused a write to */
 	/* the stack), fetch the address of the next instruction. */
 	addr1 = cpu_get_previouspc(&space->device());
-	src1 = (addr1 < 0x9000) ? state->m_rambase : space->machine().root_device().memregion("maincpu")->base();
+	src1 = (addr1 < 0x9000) ? state->m_rambase : state->memregion("maincpu")->base();
 	if (decrypted[addr1] == 0x20)	/* JSR $xxxx */
 		addr = src1[addr1 + 1] + 256 * src1[addr1 + 2];
 
@@ -550,7 +550,7 @@
 
 READ8_MEMBER(btime_state::zoar_dsw1_read)
 {
-	return (!machine().primary_screen->vblank() << 7) | (input_port_read(machine(), "DSW1") & 0x7f);
+	return (!machine().primary_screen->vblank() << 7) | (ioport("DSW1")->read() & 0x7f);
 }
 
 static INPUT_PORTS_START( btime )
@@ -611,7 +611,7 @@
 //  PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("15D:8")
 //  PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 //  PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) ) PORT_DIPLOCATION("14D:1")
@@ -684,7 +684,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
@@ -833,7 +833,7 @@
 //  PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("SW1:8")
 //  PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 //  PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) ) PORT_DIPLOCATION("SW2:1")
@@ -896,7 +896,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
@@ -972,7 +972,7 @@
 //  PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) )
 //  PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 //  PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
@@ -1050,7 +1050,7 @@
 //  PORT_DIPNAME( 0x80, 0x00, "Control Panel" ) PORT_DIPLOCATION("8D:8")
 //  PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 //  PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) ) PORT_DIPLOCATION("7D:1")
@@ -1141,7 +1141,7 @@
 
 	PORT_START("VBLANK")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( sdtennis )
@@ -1193,7 +1193,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
diff -Nru src-old/mame/drivers/bwidow.c src/mame/drivers/bwidow.c
--- src-old/mame/drivers/bwidow.c	2012-04-09 13:58:25.000000000 +0200
+++ src/mame/drivers/bwidow.c	2012-05-03 11:00:08.000000000 +0200
@@ -274,9 +274,9 @@
 	int res2;
 	int res3;
 
-	res1 = input_port_read(machine(), "IN3");
-	res2 = input_port_read(machine(), "IN4");
-	res3 = input_port_read_safe(machine(), "DSW2", 0);
+	res1 = ioport("IN3")->read();
+	res2 = ioport("IN4")->read();
+	res3 = ioport("DSW2")->read_safe(0);
 	res = 0x00;
 
 	switch (offset & 0x07)
diff -Nru src-old/mame/drivers/bwing.c src/mame/drivers/bwing.c
--- src-old/mame/drivers/bwing.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/bwing.c	2012-05-03 11:00:08.000000000 +0200
@@ -67,11 +67,11 @@
 READ8_MEMBER(bwing_state::bwp1_io_r)
 {
 
-	if (offset == 0) return(input_port_read(machine(), "DSW0"));
-	if (offset == 1) return(input_port_read(machine(), "DSW1"));
-	if (offset == 2) return(input_port_read(machine(), "IN0"));
-	if (offset == 3) return(input_port_read(machine(), "IN1"));
-	if (offset == 4) return(input_port_read(machine(), "IN2"));
+	if (offset == 0) return(ioport("DSW0")->read());
+	if (offset == 1) return(ioport("DSW1")->read());
+	if (offset == 2) return(ioport("IN0")->read());
+	if (offset == 3) return(ioport("IN1")->read());
+	if (offset == 4) return(ioport("IN2")->read());
 
 	return((m_bwp123_membase[0])[0x1b00 + offset]);
 }
@@ -279,13 +279,13 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN3")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_TILT ) PORT_CHANGED_MEMBER(DEVICE_SELF, bwing_state,tilt_pressed,0)
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("EXTRA") // a matter of taste
 	PORT_DIPNAME( 0x07, 0x00, "RGB" )
@@ -586,8 +586,8 @@
 {
 	bwing_state *state = machine.driver_data<bwing_state>();
 
-	state->m_bwp123_membase[0] = machine.root_device().memregion("maincpu")->base();
-	state->m_bwp123_membase[1] = machine.root_device().memregion("sub")->base();
+	state->m_bwp123_membase[0] = state->memregion("maincpu")->base();
+	state->m_bwp123_membase[1] = state->memregion("sub")->base();
 	state->m_bwp123_membase[2] = state->memregion("audiocpu")->base();
 
 	fix_bwp3(machine);
diff -Nru src-old/mame/drivers/byvid.c src/mame/drivers/byvid.c
--- src-old/mame/drivers/byvid.c	2012-04-19 09:47:35.000000000 +0200
+++ src/mame/drivers/byvid.c	2012-05-07 08:57:50.000000000 +0200
@@ -8,6 +8,7 @@
 #include "cpu/m6809/m6809.h"
 #include "video/tms9928a.h"
 #include "machine/6821pia.h"
+#include "sound/dac.h"
 
 class by133_state : public driver_device
 {
@@ -16,31 +17,27 @@
 		: driver_device(mconfig, type, tag),
 		  m_maincpu(*this, "maincpu"),
 		  m_videocpu(*this, "videocpu"),
-		  m_pia(*this, "pia")
+		  m_audiocpu(*this, "audiocpu"),
+		  m_videopia(*this, "videopia")
 	{ }
 
-
 	// devices
 	required_device<cpu_device> m_maincpu;
 	required_device<cpu_device> m_videocpu;
-	required_device<pia6821_device> m_pia;
+	required_device<cpu_device> m_audiocpu;
+	required_device<pia6821_device> m_videopia;
+
+	DECLARE_READ8_MEMBER(m6803_port2_r);
+	DECLARE_WRITE8_MEMBER(m6803_port2_w);
 
-	DECLARE_INPUT_CHANGED_MEMBER(test_switch_press);
-//  UINT32 screen_update(screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect);
-protected:
+	DECLARE_INPUT_CHANGED_MEMBER(video_test);
+	DECLARE_INPUT_CHANGED_MEMBER(sound_test);
 
-	// driver_device overrides
-	virtual void machine_reset();
+	UINT8 m_sound_port2;
 };
 
-#if 0
-UINT32 by133_state::screen_update( screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect )
-{
-	return 0;
-}
-#endif
 
-static ADDRESS_MAP_START( by133_map, AS_PROGRAM, 8, by133_state )
+static ADDRESS_MAP_START( main_map, AS_PROGRAM, 8, by133_state )
 	AM_RANGE(0x0000, 0xffff) AM_NOP
 	ADDRESS_MAP_GLOBAL_MASK(0x7fff)
 	AM_RANGE(0x1000, 0x7fff) AM_ROM
@@ -48,39 +45,60 @@
 
 
 
-static ADDRESS_MAP_START( by133_video_map, AS_PROGRAM, 8, by133_state )
+static ADDRESS_MAP_START( video_map, AS_PROGRAM, 8, by133_state )
 //  AM_RANGE(0x0000, 0x1fff) communication with main CPU
-	AM_RANGE(0x2000, 0x2003) AM_DEVREADWRITE("pia", pia6821_device, read, write)
-	AM_RANGE(0x4000, 0x4000) AM_DEVREADWRITE( "tms9928a", tms9928a_device, vram_read, vram_write )
-	AM_RANGE(0x4001, 0x4001) AM_DEVREADWRITE( "tms9928a", tms9928a_device, register_read, register_write )
+	AM_RANGE(0x2000, 0x2003) AM_DEVREADWRITE("videopia", pia6821_device, read, write)
+	AM_RANGE(0x4000, 0x4000) AM_DEVREADWRITE("tms9928a", tms9928a_device, vram_read, vram_write)
+	AM_RANGE(0x4001, 0x4001) AM_DEVREADWRITE("tms9928a", tms9928a_device, register_read, register_write)
 	AM_RANGE(0x6000, 0x63ff) AM_RAM
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-INPUT_CHANGED_MEMBER(by133_state::test_switch_press)
+
+
+READ8_MEMBER(by133_state::m6803_port2_r)
 {
+	machine().scheduler().synchronize();
+	return m_sound_port2;
+}
 
-	if(newval)
-		device_set_input_line(m_videocpu, INPUT_LINE_NMI, PULSE_LINE);
+WRITE8_MEMBER(by133_state::m6803_port2_w)
+{
 }
 
-static INPUT_PORTS_START( by133 )
-	/* service switch is directly hard-wired with the NMI signal */
-	PORT_START("TEST")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_IMPULSE(1) PORT_CHANGED_MEMBER(DEVICE_SELF, by133_state,test_switch_press, 0)
-INPUT_PORTS_END
+static ADDRESS_MAP_START( sound_map, AS_PROGRAM, 8, by133_state )
+	AM_RANGE(0xc000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( sound_portmap, AS_IO, 8, by133_state )
+	AM_RANGE(M6801_PORT1, M6801_PORT1) AM_DEVWRITE_LEGACY("dac", dac_w)
+	AM_RANGE(M6801_PORT2, M6801_PORT2) AM_READWRITE(m6803_port2_r, m6803_port2_w)
+ADDRESS_MAP_END
+
 
-void by133_state::machine_reset()
+INPUT_CHANGED_MEMBER(by133_state::video_test)
 {
+	if(newval)
+		device_set_input_line(m_videocpu, INPUT_LINE_NMI, PULSE_LINE);
 }
 
-static DRIVER_INIT( by133 )
+INPUT_CHANGED_MEMBER(by133_state::sound_test)
 {
+	if(newval)
+		device_set_input_line(m_audiocpu, INPUT_LINE_NMI, PULSE_LINE);
 }
 
+static INPUT_PORTS_START( by133 )
+	/* test switch is directly hard-wired to the NMI signal */
+	PORT_START("TEST")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Video Test") PORT_IMPULSE(1) PORT_CHANGED_MEMBER(DEVICE_SELF, by133_state, video_test, 0)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Sound Test") PORT_IMPULSE(1) PORT_CHANGED_MEMBER(DEVICE_SELF, by133_state, sound_test, 0)
+INPUT_PORTS_END
+
+
 static WRITE_LINE_DEVICE_HANDLER(vdp_interrupt)
 {
-	cputag_set_input_line(device->machine(), "videocpu", M6809_IRQ_LINE, (state ? ASSERT_LINE : CLEAR_LINE));
+	cputag_set_input_line(device->machine(), "videocpu", M6809_IRQ_LINE, state ? ASSERT_LINE : CLEAR_LINE);
 }
 
 static TMS9928A_INTERFACE(byvid_tms9928a_interface)
@@ -90,9 +108,17 @@
 	DEVCB_LINE(vdp_interrupt)
 };
 
-static WRITE_LINE_DEVICE_HANDLER( by133_firq )
+static WRITE_LINE_DEVICE_HANDLER(by133_firq)
+{
+	by133_state *drv_state = device->machine().driver_data<by133_state>();
+	device_set_input_line(drv_state->m_videocpu, M6809_FIRQ_LINE, (drv_state->m_videopia->irq_a_state() || drv_state->m_videopia->irq_b_state()) ? ASSERT_LINE : CLEAR_LINE);
+}
+
+static WRITE_LINE_DEVICE_HANDLER(by133_cb2)
 {
-	cputag_set_input_line(device->machine(), "videocpu", M6809_FIRQ_LINE, (state ? ASSERT_LINE : CLEAR_LINE));
+	// to M6803 port 2 d0?
+//  by133_state *drv_state = device->machine().driver_data<by133_state>();
+//  device_set_input_line(drv_state->m_audiocpu, M6801_TIN_LINE, state ? ASSERT_LINE : CLEAR_LINE);
 }
 
 static READ8_DEVICE_HANDLER(by133_portb_r)
@@ -100,7 +126,16 @@
 	return 0;
 }
 
-static const pia6821_interface pia_intf =
+static WRITE8_DEVICE_HANDLER(by133_portb_w)
+{
+	by133_state *state = device->machine().driver_data<by133_state>();
+	device->machine().scheduler().synchronize();
+
+	// d0-d3 to m6803 d1-d4
+	state->m_sound_port2 = data << 1 & 0x1f;
+}
+
+static const pia6821_interface videopia_intf =
 {
 	DEVCB_NULL,		/* port A in */
 	DEVCB_HANDLER(by133_portb_r),		/* port B in */
@@ -109,35 +144,47 @@
 	DEVCB_NULL,		/* line CA2 in */
 	DEVCB_NULL,		/* line CB2 in */
 	DEVCB_NULL,		/* port A out */
-	DEVCB_NULL,		/* port B out */
+	DEVCB_HANDLER(by133_portb_w),		/* port B out */
 	DEVCB_NULL,		/* line CA2 out */
-	DEVCB_NULL,		/* port CB2 out */
+	DEVCB_LINE(by133_cb2),		/* line CB2 out */
 	DEVCB_LINE(by133_firq),		/* IRQA */
 	DEVCB_LINE(by133_firq)		/* IRQB */
 };
 
 
+static MACHINE_RESET( by133 )
+{
+	by133_state *state = machine.driver_data<by133_state>();
+	state->m_sound_port2 = 2; // forced to 010 on /reset
+}
+
 static MACHINE_CONFIG_START( by133, by133_state )
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", M6800, 3580000/4)
 	MCFG_DEVICE_DISABLE()
-	MCFG_CPU_PROGRAM_MAP(by133_map)
+	MCFG_CPU_PROGRAM_MAP(main_map)
 
 	MCFG_CPU_ADD("videocpu", M6809, 3580000/4)
-	MCFG_CPU_PROGRAM_MAP(by133_video_map)
+	MCFG_CPU_PROGRAM_MAP(video_map)
+
+	MCFG_CPU_ADD("audiocpu", M6803, XTAL_3_579545MHz)
+	MCFG_CPU_PROGRAM_MAP(sound_map)
+	MCFG_CPU_IO_MAP(sound_portmap)
+
+	MCFG_PIA6821_ADD("videopia", videopia_intf)
 
-	MCFG_PIA6821_ADD("pia", pia_intf)
+	MCFG_MACHINE_RESET(by133)
 
 	/* video hardware */
 	MCFG_TMS9928A_ADD( "tms9928a", TMS9928A, byvid_tms9928a_interface )
 	MCFG_TMS9928A_SCREEN_ADD_NTSC( "screen" )
 	MCFG_SCREEN_UPDATE_DEVICE( "tms9928a", tms9928a_device, screen_update )
 
-
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-//  MCFG_SOUND_ADD("aysnd", AY8910, MAIN_CLOCK/4)
-//  MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
+
+	MCFG_SOUND_ADD("dac", DAC, 0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
 /*-----------------------------------------------------
@@ -149,14 +196,34 @@
 	ROM_CONTINUE( 0x5000, 0x0800)
 	ROM_LOAD( "891-u6.732", 0x1800, 0x0800, CRC(6136d636) SHA1(c01a0a2fcad3bdabd649128e012ab558b1c90cd3) )
 	ROM_CONTINUE( 0x5800, 0x0800)
-	ROM_RELOAD( 0x7000, 0x1000)
+	ROM_RELOAD(   0x7000, 0x1000)
+
 	ROM_REGION(0x10000, "videocpu", 0)
-	ROM_LOAD( "891-u9.764",  0x8000, 0x2000, CRC(7fa570f3) SHA1(423ad9266b1ded00fa52ce4180d518874142a203))
-	ROM_LOAD( "891-u10.764", 0xa000, 0x2000, CRC(28f4df8b) SHA1(bd6a3598c2c90b5a3a59327616d2f5b9940d98bc))
-	ROM_LOAD( "891-u11.764", 0xc000, 0x2000, CRC(0a5967a4) SHA1(26d56ddea3f39d41e382449007bf7ba113c0285f))
-	ROM_LOAD( "891-u12.764", 0xe000, 0x2000, CRC(58cfe542) SHA1(e024d14019866bd460d1da6b901f9b786a76a181))
-	ROM_REGION(0x10000, "soundcpu", 0)
-	ROM_LOAD( "891-u29.764", 0xe000, 0x2000, CRC(0b57fd5d) SHA1(43a03e6d16c87c3305adb04722484f992f23a1bd))
+	ROM_LOAD( "891-16-u09.764", 0x8000, 0x2000, CRC(781e90e9) SHA1(940047cc875ae531a825af069bb650d59c9495a6))
+	ROM_LOAD( "891-11-u10.764", 0xa000, 0x2000, CRC(28f4df8b) SHA1(bd6a3598c2c90b5a3a59327616d2f5b9940d98bc))
+	ROM_LOAD( "891-05-u11.764", 0xc000, 0x2000, CRC(0a5967a4) SHA1(26d56ddea3f39d41e382449007bf7ba113c0285f))
+	ROM_LOAD( "891-06-u12.764", 0xe000, 0x2000, CRC(58cfe542) SHA1(e024d14019866bd460d1da6b901f9b786a76a181))
+
+	ROM_REGION(0x10000, "audiocpu", 0)
+	ROM_LOAD( "891-12-u29.764", 0xe000, 0x2000, CRC(0b57fd5d) SHA1(43a03e6d16c87c3305adb04722484f992f23a1bd))
+ROM_END
+
+ROM_START(babypac2)
+	ROM_REGION(0x10000, "maincpu", 0)
+	ROM_LOAD( "891-u2.732", 0x1000, 0x0800, CRC(7f7242d1) SHA1(213a697bb7fc69f93ea04621f0fcfdd796f35196))
+	ROM_CONTINUE( 0x5000, 0x0800)
+	ROM_LOAD( "891-u6.732", 0x1800, 0x0800, CRC(6136d636) SHA1(c01a0a2fcad3bdabd649128e012ab558b1c90cd3) )
+	ROM_CONTINUE( 0x5800, 0x0800)
+	ROM_RELOAD(   0x7000, 0x1000)
+
+	ROM_REGION(0x10000, "videocpu", 0)
+	ROM_LOAD( "891-13-u09.764", 0x8000, 0x2000, CRC(7fa570f3) SHA1(423ad9266b1ded00fa52ce4180d518874142a203))
+	ROM_LOAD( "891-11-u10.764", 0xa000, 0x2000, CRC(28f4df8b) SHA1(bd6a3598c2c90b5a3a59327616d2f5b9940d98bc))
+	ROM_LOAD( "891-05-u11.764", 0xc000, 0x2000, CRC(0a5967a4) SHA1(26d56ddea3f39d41e382449007bf7ba113c0285f))
+	ROM_LOAD( "891-06-u12.764", 0xe000, 0x2000, CRC(58cfe542) SHA1(e024d14019866bd460d1da6b901f9b786a76a181))
+
+	ROM_REGION(0x10000, "audiocpu", 0)
+	ROM_LOAD( "891-12-u29.764", 0xe000, 0x2000, CRC(0b57fd5d) SHA1(43a03e6d16c87c3305adb04722484f992f23a1bd))
 ROM_END
 
 /*-----------------------------------------------------------------
@@ -168,7 +235,8 @@
 	ROM_CONTINUE( 0x5000, 0x0800)
 	ROM_LOAD( "cpu_u6.532", 0x1800, 0x0800, CRC(306aa673) SHA1(422c3d9decf9214a18edb536c2077bf52b272e7d) )
 	ROM_CONTINUE( 0x5800, 0x0800)
-	ROM_RELOAD( 0xf000, 0x1000)
+	ROM_RELOAD(   0xf000, 0x1000)
+
 	ROM_REGION(0x10000, "videocpu", 0)
 	ROM_LOAD( "vid_u4.764", 0x4000, 0x2000, CRC(3a3d4c6b) SHA1(a6c27eee178a4bde67004e11f6ddf3b6414571dd))
 	ROM_LOAD( "vid_u5.764", 0x6000, 0x2000, CRC(78bcb0fb) SHA1(d9dc1cc1bef063d5fbdbf2d1daf793234a9c55a0))
@@ -176,10 +244,12 @@
 	ROM_LOAD( "vid_u7.764", 0xa000, 0x2000, CRC(aa71cf29) SHA1(b69cd4060f5d4d2a7f85d901552cdc987013fde2))
 	ROM_LOAD( "vid_u8.764", 0xc000, 0x2000, CRC(a442bc01) SHA1(2c01123dc5799561ae9e7c5d6db588b82b5ae59c))
 	ROM_LOAD( "vid_u9.764", 0xe000, 0x2000, CRC(6b67a1f7) SHA1(251c2b941898363bbd6ee1a94710e2b2938ec851))
-	ROM_REGION(0x10000, "soundcpu", 0)
+
+	ROM_REGION(0x10000, "audiocpu", 0)
 	ROM_LOAD( "cs_u3.764", 0xe000, 0x2000, CRC(0a39a51d) SHA1(98342ba38e48578ce9870f2ee85b553d46c0e35f))
 ROM_END
 
 
-GAME(1982,  babypac,  0,  by133,  by133,  by133,  ROT90,  "Bally",    "Baby Pacman (Video/Pinball Combo)",              GAME_IS_SKELETON_MECHANICAL)
-GAME(1984,  granny,   0,  by133,  by133,  by133,  ROT0,  "Bally",    "Granny and the Gators (Video/Pinball Combo)",    GAME_IS_SKELETON_MECHANICAL)
+GAME( 1982, babypac,  0,        by133,  by133,  0,  ROT90, "Bally",    "Baby Pac-Man (set 1)",     GAME_IS_SKELETON_MECHANICAL)
+GAME( 1982, babypac2, babypac,  by133,  by133,  0,  ROT90, "Bally",    "Baby Pac-Man (set 2)",     GAME_IS_SKELETON_MECHANICAL)
+GAME( 1984, granny,   0,        by133,  by133,  0,  ROT0,  "Bally",    "Granny and the Gators",    GAME_IS_SKELETON_MECHANICAL)
diff -Nru src-old/mame/drivers/bzone.c src/mame/drivers/bzone.c
--- src-old/mame/drivers/bzone.c	2012-04-09 14:55:12.000000000 +0200
+++ src/mame/drivers/bzone.c	2012-05-03 11:00:08.000000000 +0200
@@ -244,7 +244,7 @@
 
 static INTERRUPT_GEN( bzone_interrupt )
 {
-	if (input_port_read(device->machine(), "IN0") & 0x10)
+	if (device->machine().root_device().ioport("IN0")->read() & 0x10)
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
@@ -278,7 +278,7 @@
 static READ8_DEVICE_HANDLER( redbaron_joy_r )
 {
 	bzone_state *state = device->machine().driver_data<bzone_state>();
-	return input_port_read(device->machine(), state->m_rb_input_select ? "FAKE1" : "FAKE2");
+	return state->ioport(state->m_rb_input_select ? "FAKE1" : "FAKE2")->read();
 }
 
 static WRITE8_DEVICE_HANDLER( redbaron_joysound_w )
@@ -789,7 +789,7 @@
 	static const char *const analog_port[] = { "AN0", "AN1", "AN2" };
 
 	if (offset <= 2)
-		m_analog_data = input_port_read(machine(), analog_port[offset]);
+		m_analog_data = ioport(analog_port[offset])->read();
 }
 
 
diff -Nru src-old/mame/drivers/cabal.c src/mame/drivers/cabal.c
--- src-old/mame/drivers/cabal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cabal.c	2012-05-03 11:00:08.000000000 +0200
@@ -84,7 +84,7 @@
 	static const char *const track_names[] = { "IN0", "IN1", "IN2", "IN3" };
 
 	for (i = 0; i < 4; i++)
-		m_last[i] = input_port_read(machine(), track_names[i]);
+		m_last[i] = ioport(track_names[i])->read();
 }
 
 READ16_MEMBER(cabal_state::track_r)
@@ -93,10 +93,10 @@
 	switch (offset)
 	{
 		default:
-		case 0:	return (( input_port_read(machine(), "IN0") - m_last[0]) & 0x00ff)		 | (((input_port_read(machine(), "IN2") - m_last[2]) & 0x00ff) << 8);	/* X lo */
-		case 1:	return (((input_port_read(machine(), "IN0") - m_last[0]) & 0xff00) >> 8) | (( input_port_read(machine(), "IN2") - m_last[2]) & 0xff00);			/* X hi */
-		case 2:	return (( input_port_read(machine(), "IN1") - m_last[1]) & 0x00ff)		 | (((input_port_read(machine(), "IN3") - m_last[3]) & 0x00ff) << 8);	/* Y lo */
-		case 3:	return (((input_port_read(machine(), "IN1") - m_last[1]) & 0xff00) >> 8) | (( input_port_read(machine(), "IN3") - m_last[3]) & 0xff00);			/* Y hi */
+		case 0: return (( ioport("IN0")->read() - m_last[0]) & 0x00ff)           | (((ioport("IN2")->read() - m_last[2]) & 0x00ff) << 8);       /* X lo */
+		case 1: return (((ioport("IN0")->read() - m_last[0]) & 0xff00) >> 8) | (( ioport("IN2")->read() - m_last[2]) & 0xff00);                 /* X hi */
+		case 2: return (( ioport("IN1")->read() - m_last[1]) & 0x00ff)           | (((ioport("IN3")->read() - m_last[3]) & 0x00ff) << 8);       /* Y lo */
+		case 3: return (((ioport("IN1")->read() - m_last[1]) & 0xff00) >> 8) | (( ioport("IN3")->read() - m_last[3]) & 0xff00);                 /* Y hi */
 	}
 }
 
@@ -246,7 +246,7 @@
 
 static INPUT_PORTS_START( common )
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x000f, 0x000f, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2,3,4") PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x00)
+	PORT_DIPNAME( 0x000f, 0x000f, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2,3,4") PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x00)
 	PORT_DIPSETTING(      0x000a, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(      0x000b, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0x000c, DEF_STR( 4C_1C ) )
@@ -263,12 +263,12 @@
 	PORT_DIPSETTING(      0x0006, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0005, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A )) PORT_DIPLOCATION("SW1:1,2") PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x00)
+	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A )) PORT_DIPLOCATION("SW1:1,2") PORT_CONDITION("DSW", 0x0010, EQUALS, 0x00)
 	PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B )) PORT_DIPLOCATION("SW1:3,4") PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x00)
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B )) PORT_DIPLOCATION("SW1:3,4") PORT_CONDITION("DSW", 0x0010, EQUALS, 0x00)
 	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_5C ) )
diff -Nru src-old/mame/drivers/calchase.c src/mame/drivers/calchase.c
--- src-old/mame/drivers/calchase.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/calchase.c	2012-05-03 11:00:08.000000000 +0200
@@ -493,28 +493,28 @@
 
 READ16_MEMBER(calchase_state::calchase_iocard1_r)
 {
-	return input_port_read(machine(), "IOCARD1");
+	return ioport("IOCARD1")->read();
 }
 
 READ16_MEMBER(calchase_state::calchase_iocard2_r)
 {
-	return input_port_read(machine(), "IOCARD2");
+	return ioport("IOCARD2")->read();
 }
 
 READ16_MEMBER(calchase_state::calchase_iocard3_r)
 {
-	return input_port_read(machine(), "IOCARD3");
+	return ioport("IOCARD3")->read();
 }
 
 /* These two controls wheel pot or whatever this game uses ... */
 READ16_MEMBER(calchase_state::calchase_iocard4_r)
 {
-	return input_port_read(machine(), "IOCARD4");
+	return ioport("IOCARD4")->read();
 }
 
 READ16_MEMBER(calchase_state::calchase_iocard5_r)
 {
-	return input_port_read(machine(), "IOCARD5");
+	return ioport("IOCARD5")->read();
 }
 
 
@@ -677,7 +677,7 @@
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN ) // returns back to MS-DOS (likely to be unmapped and actually used as a lame protection check)
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_START("IOCARD3")
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xdfff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IOCARD4")
diff -Nru src-old/mame/drivers/calomega.c src/mame/drivers/calomega.c
--- src-old/mame/drivers/calomega.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/calomega.c	2012-05-03 11:00:08.000000000 +0200
@@ -660,7 +660,7 @@
 static WRITE_LINE_DEVICE_HANDLER( tx_rx_clk )
 {
 	int trx_clk;
-	UINT8 dsw2 = input_port_read(device->machine(), "SW2");
+	UINT8 dsw2 = device->machine().root_device().ioport("SW2")->read();
 	trx_clk = UART_CLOCK * dsw2 / 128;
 	acia6850_device *acia = downcast<acia6850_device *>(device);
 	acia->set_rx_clock(trx_clk);
@@ -673,13 +673,13 @@
 	calomega_state *state = device->machine().driver_data<calomega_state>();
 	switch( state->m_s903_mux_data & 0xf0 )	/* bits 4-7 */
 	{
-		case 0x10: return input_port_read(device->machine(), "IN0-0");
-		case 0x20: return input_port_read(device->machine(), "IN0-1");
-		case 0x40: return input_port_read(device->machine(), "IN0-2");
-		case 0x80: return input_port_read(device->machine(), "IN0-3");
+		case 0x10: return state->ioport("IN0-0")->read();
+		case 0x20: return state->ioport("IN0-1")->read();
+		case 0x40: return state->ioport("IN0-2")->read();
+		case 0x80: return state->ioport("IN0-3")->read();
 	}
 
-	return input_port_read(device->machine(), "FRQ");	/* bit7 used for 50/60 Hz selector */
+	return device->machine().root_device().ioport("FRQ")->read();	/* bit7 used for 50/60 Hz selector */
 }
 
 static WRITE8_DEVICE_HANDLER( s903_mux_w )
@@ -695,13 +695,13 @@
 	calomega_state *state = device->machine().driver_data<calomega_state>();
 	switch( state->m_s905_mux_data & 0x0f )	/* bits 0-3 */
 	{
-		case 0x01: return input_port_read(device->machine(), "IN0-0");
-		case 0x02: return input_port_read(device->machine(), "IN0-1");
-		case 0x04: return input_port_read(device->machine(), "IN0-2");
-		case 0x08: return input_port_read(device->machine(), "IN0-3");
+		case 0x01: return state->ioport("IN0-0")->read();
+		case 0x02: return state->ioport("IN0-1")->read();
+		case 0x04: return state->ioport("IN0-2")->read();
+		case 0x08: return state->ioport("IN0-3")->read();
 	}
 
-	return input_port_read(device->machine(), "FRQ");	/* bit6 used for 50/60 Hz selector */
+	return device->machine().root_device().ioport("FRQ")->read();	/* bit6 used for 50/60 Hz selector */
 }
 
 static WRITE8_DEVICE_HANDLER( s905_mux_w )
@@ -717,7 +717,7 @@
 {
 	/* Valid input port. Each polled value is stored at $0538 */
 	logerror("PIA0: Port A in\n");
-	return input_port_read(device->machine(), "IN0");
+	return device->machine().root_device().ioport("IN0")->read();
 }
 
 static READ8_DEVICE_HANDLER( pia0_bin_r )
diff -Nru src-old/mame/drivers/canyon.c src/mame/drivers/canyon.c
--- src-old/mame/drivers/canyon.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/canyon.c	2012-05-03 11:00:08.000000000 +0200
@@ -67,10 +67,10 @@
 {
 	UINT8 val = 0;
 
-	if ((input_port_read(machine(), "IN2") >> (offset & 7)) & 1)
+	if ((ioport("IN2")->read() >> (offset & 7)) & 1)
 		val |= 0x80;
 
-	if ((input_port_read(machine(), "IN1") >> (offset & 3)) & 1)
+	if ((ioport("IN1")->read() >> (offset & 3)) & 1)
 		val |= 0x01;
 
 	return val;
@@ -79,7 +79,7 @@
 
 READ8_MEMBER(canyon_state::canyon_options_r)
 {
-	return (input_port_read(machine(), "DSW") >> (2 * (~offset & 3))) & 3;
+	return (ioport("DSW")->read() >> (2 * (~offset & 3))) & 3;
 }
 
 
@@ -160,7 +160,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_START1 )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_START2 )
 	PORT_SERVICE( 0x10, IP_ACTIVE_HIGH )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON7 ) PORT_NAME("Hiscore Reset") PORT_CODE(KEYCODE_H)
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_TILT ) /* SLAM */
 
diff -Nru src-old/mame/drivers/capbowl.c src/mame/drivers/capbowl.c
--- src-old/mame/drivers/capbowl.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/capbowl.c	2012-05-03 11:00:08.000000000 +0200
@@ -107,7 +107,7 @@
 
 static INTERRUPT_GEN( capbowl_interrupt )
 {
-	if (input_port_read(device->machine(), "SERVICE") & 1)						/* get status of the F2 key */
+	if (device->machine().root_device().ioport("SERVICE")->read() & 1)						/* get status of the F2 key */
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);	/* trigger self test */
 }
 
@@ -152,13 +152,13 @@
 
 READ8_MEMBER(capbowl_state::track_0_r)
 {
-	return (input_port_read(machine(), "IN0") & 0xf0) | ((input_port_read(machine(), "TRACKY") - m_last_trackball_val[0]) & 0x0f);
+	return (ioport("IN0")->read() & 0xf0) | ((ioport("TRACKY")->read() - m_last_trackball_val[0]) & 0x0f);
 }
 
 
 READ8_MEMBER(capbowl_state::track_1_r)
 {
-	return (input_port_read(machine(), "IN1") & 0xf0) | ((input_port_read(machine(), "TRACKX") - m_last_trackball_val[1]) & 0x0f);
+	return (ioport("IN1")->read() & 0xf0) | ((ioport("TRACKX")->read() - m_last_trackball_val[1]) & 0x0f);
 }
 
 
@@ -166,8 +166,8 @@
 {
 
 	/* reset the trackball counters */
-	m_last_trackball_val[0] = input_port_read(machine(), "TRACKY");
-	m_last_trackball_val[1] = input_port_read(machine(), "TRACKX");
+	m_last_trackball_val[0] = ioport("TRACKY")->read();
+	m_last_trackball_val[1] = ioport("TRACKX")->read();
 
 	watchdog_reset_w(space, offset, data);
 }
diff -Nru src-old/mame/drivers/cave.c src/mame/drivers/cave.c
--- src-old/mame/drivers/cave.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cave.c	2012-05-03 11:00:08.000000000 +0200
@@ -859,7 +859,7 @@
 READ16_MEMBER(cave_state::sailormn_input0_r)
 {
 //  watchdog_reset16_r(0, 0);    // written too rarely for mame.
-	return input_port_read(machine(), "IN0");
+	return ioport("IN0")->read();
 }
 
 static ADDRESS_MAP_START( sailormn_map, AS_PROGRAM, 16, cave_state )
@@ -1361,14 +1361,14 @@
 	PORT_DIPSETTING(      0x0200, "4" )
 	PORT_DIPNAME( 0x0400, 0x0400, DEF_STR( Bonus_Life ) )		PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0400, "150k/300k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0xc000)
-	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0xa000)
-	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0xe000)
-	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0x6000)
-	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0x8000)
-	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0x2000)
-	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0x4000)
-	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xe000, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0400, "150k/300k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0xc000)
+	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0xa000)
+	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0xe000)
+	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0x6000)
+	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0x8000)
+	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0x2000)
+	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0x4000)
+	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xe000, EQUALS, 0x0000)
 	PORT_DIPNAME( 0x1800, 0x1800, "Damage" )					PORT_DIPLOCATION("SW2:4,5")
 	PORT_DIPSETTING(      0x1800, "+0" )
 	PORT_DIPSETTING(      0x1000, "+1" )
@@ -1394,10 +1394,10 @@
 	PORT_DIPSETTING(      0x0004, DEF_STR( Chinese ) )
 	PORT_DIPNAME( 0x0400, 0x0400, DEF_STR( Bonus_Life ) )		PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0400, "150k/300k" ) PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x8000)
-	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0xc000)
-	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x4000)
-	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0400, "150k/300k" ) PORT_CONDITION("DSW", 0xc000, EQUALS, 0x8000)
+	PORT_DIPSETTING(      0x0400, "150k/350k" ) PORT_CONDITION("DSW", 0xc000, EQUALS, 0xc000)
+	PORT_DIPSETTING(      0x0400, "150k/400k" ) PORT_CONDITION("DSW", 0xc000, EQUALS, 0x4000)
+	PORT_DIPSETTING(      0x0400, "200k/500k" ) PORT_CONDITION("DSW", 0xc000, EQUALS, 0x0000)
 	PORT_DIPUNKNOWN_DIPLOC( 0x2000, 0x2000, "SW2:6" )
 	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Difficulty ) )		PORT_DIPLOCATION("SW2:7,8")
 	PORT_DIPSETTING(      0x8000, DEF_STR( Very_Easy ) )
@@ -4544,7 +4544,7 @@
 static DRIVER_INIT( hotdogst )
 {
 	cave_state *state = machine.driver_data<cave_state>();
-	UINT8 *ROM = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *ROM = state->memregion("audiocpu")->base();
 
 	init_cave(machine);
 
@@ -4563,10 +4563,10 @@
 static DRIVER_INIT( mazinger )
 {
 	cave_state *state = machine.driver_data<cave_state>();
-	UINT8 *ROM = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *ROM = state->memregion("audiocpu")->base();
 	UINT8 *buffer;
-	UINT8 *src = machine.root_device().memregion("sprites")->base();
-	int len = machine.root_device().memregion("sprites")->bytes();
+	UINT8 *src = state->memregion("sprites")->base();
+	int len = state->memregion("sprites")->bytes();
 
 	init_cave(machine);
 
@@ -4600,14 +4600,14 @@
 static DRIVER_INIT( metmqstr )
 {
 	cave_state *state = machine.driver_data<cave_state>();
-	UINT8 *ROM = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *ROM = state->memregion("audiocpu")->base();
 
 	init_cave(machine);
 
 	state->membank("bank1")->configure_entries(0, 0x2, &ROM[0x00000], 0x4000);
 	state->membank("bank1")->configure_entries(2, 0xe, &ROM[0x10000], 0x4000);
 
-	ROM = machine.root_device().memregion("oki1")->base();
+	ROM = state->memregion("oki1")->base();
 	state->membank("bank3")->configure_entries(0, 8, &ROM[0x00000], 0x20000);
 	state->membank("bank4")->configure_entries(0, 8, &ROM[0x00000], 0x20000);
 
@@ -4625,9 +4625,9 @@
 static DRIVER_INIT( pwrinst2j )
 {
 	cave_state *state = machine.driver_data<cave_state>();
-	UINT8 *ROM = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *ROM = state->memregion("audiocpu")->base();
 	UINT8 *buffer;
-	UINT8 *src = machine.root_device().memregion("sprites")->base();
+	UINT8 *src = state->memregion("sprites")->base();
 	int len = state->memregion("sprites")->bytes();
 	int i, j;
 
@@ -4674,17 +4674,17 @@
 static DRIVER_INIT( sailormn )
 {
 	cave_state *state = machine.driver_data<cave_state>();
-	UINT8 *ROM = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *ROM = state->memregion("audiocpu")->base();
 	UINT8 *buffer;
-	UINT8 *src = machine.root_device().memregion("sprites")->base();
-	int len = machine.root_device().memregion("sprites")->bytes();
+	UINT8 *src = state->memregion("sprites")->base();
+	int len = state->memregion("sprites")->bytes();
 
 	init_cave(machine);
 
 	state->membank("bank1")->configure_entries(0, 0x02, &ROM[0x00000], 0x4000);
 	state->membank("bank1")->configure_entries(2, 0x1e, &ROM[0x10000], 0x4000);
 
-	ROM = machine.root_device().memregion("oki1")->base();
+	ROM = state->memregion("oki1")->base();
 	state->membank("bank3")->configure_entries(0, 0x10, &ROM[0x00000], 0x20000);
 	state->membank("bank4")->configure_entries(0, 0x10, &ROM[0x00000], 0x20000);
 
diff -Nru src-old/mame/drivers/cb2001.c src/mame/drivers/cb2001.c
--- src-old/mame/drivers/cb2001.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cb2001.c	2012-05-03 11:00:08.000000000 +0200
@@ -656,28 +656,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
diff -Nru src-old/mame/drivers/cbasebal.c src/mame/drivers/cbasebal.c
--- src-old/mame/drivers/cbasebal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cbasebal.c	2012-05-03 11:00:08.000000000 +0200
@@ -168,7 +168,7 @@
 	PORT_SERVICE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )		/* ? */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")		/* ? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
 	PORT_START( "IO_01" )
diff -Nru src-old/mame/drivers/cbuster.c src/mame/drivers/cbuster.c
--- src-old/mame/drivers/cbuster.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cbuster.c	2012-05-03 11:00:08.000000000 +0200
@@ -84,17 +84,17 @@
 	switch (offset << 1)
 	{
 		case 0: /* Player 1 & Player 2 joysticks & fire buttons */
-			return input_port_read(machine(), "P1_P2");
+			return ioport("P1_P2")->read();
 
 		case 2: /* Dip Switches */
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 4: /* Protection */
 			logerror("%04x : protection control read at 30c000 %d\n", cpu_get_pc(&space.device()), offset);
 			return m_prot;
 
 		case 6: /* Credits, VBL in byte 7 */
-			return input_port_read(machine(), "COINS");
+			return ioport("COINS")->read();
 	}
 
 	return ~0;
@@ -164,7 +164,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/ccastles.c src/mame/drivers/ccastles.c
--- src-old/mame/drivers/ccastles.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ccastles.c	2012-05-03 11:00:08.000000000 +0200
@@ -191,7 +191,7 @@
 	rectangle visarea;
 
 	/* initialize globals */
-	state->m_syncprom = machine.root_device().memregion("proms")->base() + 0x000;
+	state->m_syncprom = state->memregion("proms")->base() + 0x000;
 
 	/* find the start of VBLANK in the SYNC PROM */
 	for (state->m_vblank_start = 0; state->m_vblank_start < 256; state->m_vblank_start++)
@@ -273,7 +273,7 @@
 {
 	static const char *const letanames[] = { "LETA0", "LETA1", "LETA2", "LETA3" };
 
-	return input_port_read(machine(), letanames[offset]);
+	return ioport(letanames[offset])->read();
 }
 
 
diff -Nru src-old/mame/drivers/cchance.c src/mame/drivers/cchance.c
--- src-old/mame/drivers/cchance.c	2012-04-06 17:03:29.000000000 +0200
+++ src/mame/drivers/cchance.c	2012-05-03 11:00:08.000000000 +0200
@@ -65,7 +65,7 @@
 READ8_MEMBER(cchance_state::input_1_r)
 {
 
-	return (m_hop_io) | (m_bell_io) | (input_port_read(machine(), "SP") & 0xff);
+	return (m_hop_io) | (m_bell_io) | (ioport("SP")->read() & 0xff);
 }
 
 WRITE8_MEMBER(cchance_state::output_1_w)
diff -Nru src-old/mame/drivers/cd32.c src/mame/drivers/cd32.c
--- src-old/mame/drivers/cd32.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cd32.c	2012-05-03 11:00:08.000000000 +0200
@@ -223,7 +223,7 @@
 		/* shift at 1 == return one, >1 = return button states */
 		if (state->m_cd32_shifter[i] == 0)
 			potgor &= ~p9dat; /* shift at zero == return zero */
-		if (state->m_cd32_shifter[i] >= 2 && (input_port_read(machine, player_portname[i]) & (1 << (state->m_cd32_shifter[i] - 2))))
+		if (state->m_cd32_shifter[i] >= 2 && (state->ioport(player_portname[i])->read() & (1 << (state->m_cd32_shifter[i] - 2))))
 			potgor &= ~p9dat;
 	}
 	return potgor;
@@ -1174,56 +1174,56 @@
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "cndypuzl", 0, SHA1(5f41ed3521b3e05d233ac1245b78cb0b118b2b90) )
+	DISK_IMAGE_READONLY( "cndypuzl", 0, BAD_DUMP SHA1(5f41ed3521b3e05d233ac1245b78cb0b118b2b90) )
 ROM_END
 
 ROM_START( haremchl )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "haremchl", 0, SHA1(abbab347c0d7c5eef0465d0eee770754a452e874) )
+	DISK_IMAGE_READONLY( "haremchl", 0, BAD_DUMP SHA1(abbab347c0d7c5eef0465d0eee770754a452e874) )
 ROM_END
 
 ROM_START( lsrquiz )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "lsrquiz", 0, SHA1(41fb6cd0c9d36bd77e9c3db69d36801edc791e96) )
+	DISK_IMAGE_READONLY( "lsrquiz", 0, BAD_DUMP SHA1(41fb6cd0c9d36bd77e9c3db69d36801edc791e96) )
 ROM_END
 
 ROM_START( lsrquiz2 )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "lsrquiz2", 0, SHA1(78e261df1c548fa492e6cf37a9469640bb8816bf) )
+	DISK_IMAGE_READONLY( "lsrquiz2", 0, BAD_DUMP SHA1(78e261df1c548fa492e6cf37a9469640bb8816bf) )
 ROM_END
 
 ROM_START( mgprem11 )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "mgprem11", 0, SHA1(7808db33d5949f6c86d12b32bc388c12377e7038) )
+	DISK_IMAGE_READONLY( "mgprem11", 0, BAD_DUMP SHA1(7808db33d5949f6c86d12b32bc388c12377e7038) )
 ROM_END
 
 ROM_START( lasstixx )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "lasstixx", 0, SHA1(b8f6138e1f1840c193e786c56dab03c512f3e21f) )
+	DISK_IMAGE_READONLY( "lasstixx", 0, BAD_DUMP SHA1(b8f6138e1f1840c193e786c56dab03c512f3e21f) )
 ROM_END
 
 ROM_START( mgnumber )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "magicnumber", 0, SHA1(60e1fadc42694742d19cc0ac2b6e99e9e33faa3d) )
+	DISK_IMAGE_READONLY( "magicnumber", 0, BAD_DUMP SHA1(60e1fadc42694742d19cc0ac2b6e99e9e33faa3d) )
 ROM_END
 
 ROM_START( odeontw2 )
 	CD32_BIOS
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE_READONLY( "odeontw2", 0, SHA1(f39e09f35b65a6ae9f1eba4a22f970626b7d3b71) )
+	DISK_IMAGE_READONLY( "odeontw2", 0, BAD_DUMP SHA1(f39e09f35b65a6ae9f1eba4a22f970626b7d3b71) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/cdi.c src/mame/drivers/cdi.c
--- src-old/mame/drivers/cdi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cdi.c	2012-05-03 11:00:08.000000000 +0200
@@ -87,35 +87,35 @@
 	switch((FPTR)param)
 	{
 		case 0x39:
-			if(input_port_read(machine(), "INPUT1") & 0x01) send = true;
+			if(ioport("INPUT1")->read() & 0x01) send = true;
 			break;
 		case 0x37:
-			if(input_port_read(machine(), "INPUT1") & 0x02) send = true;
+			if(ioport("INPUT1")->read() & 0x02) send = true;
 			break;
 		case 0x31:
-			if(input_port_read(machine(), "INPUT1") & 0x04) send = true;
+			if(ioport("INPUT1")->read() & 0x04) send = true;
 			break;
 		case 0x32:
-			if(input_port_read(machine(), "INPUT1") & 0x08) send = true;
+			if(ioport("INPUT1")->read() & 0x08) send = true;
 			break;
 		case 0x33:
-			if(input_port_read(machine(), "INPUT1") & 0x10) send = true;
+			if(ioport("INPUT1")->read() & 0x10) send = true;
 			break;
 
 		case 0x30:
-			if(input_port_read(machine(), "INPUT2") & 0x01) send = true;
+			if(ioport("INPUT2")->read() & 0x01) send = true;
 			break;
 		case 0x38:
-			if(input_port_read(machine(), "INPUT2") & 0x02) send = true;
+			if(ioport("INPUT2")->read() & 0x02) send = true;
 			break;
 		case 0x34:
-			if(input_port_read(machine(), "INPUT2") & 0x04) send = true;
+			if(ioport("INPUT2")->read() & 0x04) send = true;
 			break;
 		case 0x35:
-			if(input_port_read(machine(), "INPUT2") & 0x08) send = true;
+			if(ioport("INPUT2")->read() & 0x08) send = true;
 			break;
 		case 0x36:
-			if(input_port_read(machine(), "INPUT2") & 0x10) send = true;
+			if(ioport("INPUT2")->read() & 0x10) send = true;
 			break;
 	}
 
@@ -470,7 +470,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd32", 0, SHA1(31e9fa2169aa44d799c37170b238134ab738e1a1) )
+    DISK_IMAGE_READONLY( "quizrd32", 0, BAD_DUMP SHA1(31e9fa2169aa44d799c37170b238134ab738e1a1) )
 ROM_END
 
 ROM_START( quizrd22 )
@@ -484,7 +484,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd22", 0, SHA1(03c8fdcf27ead6e221691111e8c679b551099543) )
+    DISK_IMAGE_READONLY( "quizrd22", 0, BAD_DUMP SHA1(03c8fdcf27ead6e221691111e8c679b551099543) )
 ROM_END
 
 ROM_START( quizrd17 )
@@ -498,7 +498,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd17", 0, SHA1(4bd698f076505b4e17be978481bce027eb47123b) )
+    DISK_IMAGE_READONLY( "quizrd17", 0, BAD_DUMP SHA1(4bd698f076505b4e17be978481bce027eb47123b) )
 ROM_END
 
 ROM_START( quizrd12 ) /* CD-ROM printed 01/95 */
@@ -512,7 +512,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd12", 0, SHA1(6e41683b96b74e903040842aeb18437ad7813c82) )
+    DISK_IMAGE_READONLY( "quizrd12", 0, BAD_DUMP SHA1(6e41683b96b74e903040842aeb18437ad7813c82) )
 ROM_END
 
 ROM_START( quizrd18 ) /* CD-ROM printed ??/?? */
@@ -526,7 +526,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd18", 0, SHA1(ede873b22957f2a707bbd3039e962ef2ca5aedbd) )
+    DISK_IMAGE_READONLY( "quizrd18", 0, BAD_DUMP SHA1(ede873b22957f2a707bbd3039e962ef2ca5aedbd) )
 ROM_END
 
 ROM_START( quizrd23 ) /* CD-ROM printed ??/?? */
@@ -540,7 +540,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd23", 0, SHA1(cd909d9a54275d6f2d36e03e83eea996e781b4d3) )
+    DISK_IMAGE_READONLY( "quizrd23", 0, BAD_DUMP SHA1(cd909d9a54275d6f2d36e03e83eea996e781b4d3) )
 ROM_END
 
 ROM_START( quizrd34 ) /* CD-ROM printed ??/?? */
@@ -554,7 +554,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrd34", 0, SHA1(37ad49b72b5175afbb87141d57bc8604347fe032) )
+    DISK_IMAGE_READONLY( "quizrd34", 0, BAD_DUMP SHA1(37ad49b72b5175afbb87141d57bc8604347fe032) )
 ROM_END
 
 ROM_START( quizrr42 ) /* CD-ROM printed 09/98 */
@@ -568,7 +568,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrr42", 0, SHA1(a5d5c8950b4650b8753f9119dc7f1ccaa2aa5442) )
+    DISK_IMAGE_READONLY( "quizrr42", 0, BAD_DUMP SHA1(a5d5c8950b4650b8753f9119dc7f1ccaa2aa5442) )
 ROM_END
 
 ROM_START( quizrr41 )
@@ -582,7 +582,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrr41", 0, SHA1(2c0484c6545aac8e00b318328c6edce6f5dde43d) )
+    DISK_IMAGE_READONLY( "quizrr41", 0, BAD_DUMP SHA1(2c0484c6545aac8e00b318328c6edce6f5dde43d) )
 ROM_END
 
 ROM_START( quizrr40 ) /* CD-ROM printed 07/97 */
@@ -596,7 +596,7 @@
     ROM_LOAD( "slave.bin", 0x0000, 0x2000, NO_DUMP ) // Undumped 68HC05 microcontroller, might need decapping
 
     DISK_REGION( "cdrom" )
-    DISK_IMAGE_READONLY( "quizrr40", 0, SHA1(288cc37a994e4f1cbd47aa8c92342879c6fc0b87) )
+    DISK_IMAGE_READONLY( "quizrr40", 0, BAD_DUMP SHA1(288cc37a994e4f1cbd47aa8c92342879c6fc0b87) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/centiped.c src/mame/drivers/centiped.c
--- src-old/mame/drivers/centiped.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/centiped.c	2012-05-03 11:00:08.000000000 +0200
@@ -528,10 +528,10 @@
 
 	/* if we're to read the dipswitches behind the trackball data, do it now */
 	if (state->m_dsw_select)
-		return (input_port_read(machine, portnames[switch_port]) & 0x7f) | state->m_sign[idx];
+		return (machine.root_device().ioport(portnames[switch_port])->read() & 0x7f) | state->m_sign[idx];
 
 	/* get the new position and adjust the result */
-	newpos = input_port_read(machine, tracknames[idx]);
+	newpos = machine.root_device().ioport(tracknames[idx])->read();
 	if (newpos != state->m_oldpos[idx])
 	{
 		state->m_sign[idx] = (newpos - state->m_oldpos[idx]) & 0x80;
@@ -539,7 +539,7 @@
 	}
 
 	/* blend with the bits from the switch port */
-	return (input_port_read(machine, portnames[switch_port]) & 0x70) | (state->m_oldpos[idx] & 0x0f) | state->m_sign[idx];
+	return (machine.root_device().ioport(portnames[switch_port])->read() & 0x70) | (state->m_oldpos[idx] & 0x0f) | state->m_sign[idx];
 }
 
 
@@ -562,7 +562,7 @@
 
 READ8_MEMBER(centiped_state::milliped_IN2_r)
 {
-	UINT8 data = input_port_read(machine(), "IN2");
+	UINT8 data = ioport("IN2")->read();
 
 	/* MSH - 15 Feb, 2007
      * The P2 X Joystick inputs are not properly handled in
@@ -573,7 +573,7 @@
      */
 	if (0 != m_control_select) {
 		/* Bottom 4 bits is our joystick inputs */
-		UINT8 joy2data = input_port_read(machine(), "IN3") & 0x0f;
+		UINT8 joy2data = ioport("IN3")->read() & 0x0f;
 		data = data & 0xf0; /* Keep the top 4 bits */
 		data |= (joy2data & 0x0a) >> 1; /* flip left and up */
 		data |= (joy2data & 0x05) << 1; /* flip right and down */
@@ -599,7 +599,7 @@
 {
 	static const char *const sticknames[] = { "STICK0", "STICK1", "STICK2", "STICK3" };
 
-	return input_port_read(machine(), sticknames[m_control_select]);
+	return ioport(sticknames[m_control_select])->read();
 }
 
 
@@ -879,7 +879,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Cocktail ) )
 	PORT_SERVICE( 0x20, IP_ACTIVE_LOW )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* trackball sign bit */
 
 	PORT_START("IN1")
@@ -1115,7 +1115,7 @@
 	PORT_DIPSETTING(   0x0c, "0 1x 2x 3x" )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL )		/* trackball sign bit */
 
 	PORT_START("IN1")	/* $2001 */ /* see port 7 for y trackball */
@@ -1224,7 +1224,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
 	PORT_SERVICE( 0x20, IP_ACTIVE_LOW )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x80, "Upright (overlay)" )
 	PORT_DIPSETTING(    0x00, "Cocktail (no overlay)" )
@@ -1307,7 +1307,7 @@
 	PORT_DIPNAME( 0x40, 0x00, "Minimum credits" )		PORT_DIPLOCATION("SW0:!7")
 	PORT_DIPSETTING(    0x00, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1396,7 +1396,7 @@
 	PORT_START("IN0")
 	PORT_BIT( 0x0f, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* trackball data */
 	PORT_BIT( 0x30, IP_ACTIVE_LOW,  IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* trackball sign bit */
 
 	PORT_START("IN1")
diff -Nru src-old/mame/drivers/cesclass.c src/mame/drivers/cesclass.c
--- src-old/mame/drivers/cesclass.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/cesclass.c	2012-05-05 16:28:21.000000000 +0200
@@ -229,7 +229,7 @@
 	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("l_lcd")
 INPUT_PORTS_END
 
 static PALETTE_INIT( cesclassic )
diff -Nru src-old/mame/drivers/cham24.c src/mame/drivers/cham24.c
--- src-old/mame/drivers/cham24.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cham24.c	2012-05-03 11:00:08.000000000 +0200
@@ -173,8 +173,8 @@
 	m_in_0_shift = 0;
 	m_in_1_shift = 0;
 
-	m_in_0 = input_port_read(machine(), "P1");
-	m_in_1 = input_port_read(machine(), "P2");
+	m_in_0 = ioport("P1")->read();
+	m_in_1 = ioport("P2")->read();
 
 }
 
@@ -304,8 +304,8 @@
 {
 	cham24_state *state = machine.driver_data<cham24_state>();
 	/* switch PRG rom */
-	UINT8* dst = machine.root_device().memregion("maincpu")->base();
-	UINT8* src = machine.root_device().memregion("user1")->base();
+	UINT8* dst = state->memregion("maincpu")->base();
+	UINT8* src = state->memregion("user1")->base();
 
 	memcpy(&dst[0x8000], &src[0x0f8000], 0x4000);
 	memcpy(&dst[0xc000], &src[0x0f8000], 0x4000);
diff -Nru src-old/mame/drivers/champbwl.c src/mame/drivers/champbwl.c
--- src-old/mame/drivers/champbwl.c	2012-04-22 07:29:39.000000000 +0200
+++ src/mame/drivers/champbwl.c	2012-05-03 11:00:08.000000000 +0200
@@ -175,8 +175,8 @@
 READ8_MEMBER(champbwl_state::trackball_r)
 {
 	UINT8 ret;
-	UINT8 port4 = input_port_read(machine(), "FAKEX");
-	UINT8 port5 = input_port_read(machine(), "FAKEY");
+	UINT8 port4 = ioport("FAKEX")->read();
+	UINT8 port5 = ioport("FAKEY")->read();
 
 	ret = (((port4 - m_last_trackball_val[0]) & 0x0f)<<4) | ((port5 - m_last_trackball_val[1]) & 0x0f);
 
diff -Nru src-old/mame/drivers/chanbara.c src/mame/drivers/chanbara.c
--- src-old/mame/drivers/chanbara.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/chanbara.c	2012-05-03 11:00:08.000000000 +0200
@@ -265,7 +265,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 )           /* same coinage as COIN1 */
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START ("P1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN )
diff -Nru src-old/mame/drivers/chance32.c src/mame/drivers/chance32.c
--- src-old/mame/drivers/chance32.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/chance32.c	2012-05-07 08:57:50.000000000 +0200
@@ -0,0 +1,514 @@
+/*
+
+Chance 32 - Poker Game by PAL Company
+
+1x HD46505SP / HD6845SP
+1x Z84C0008PEC
+
+XTAL: 12.000 Mhz
+
+
+ todo, fix tilemaps, colours, inputs, hook up oki, add CRTC device
+
+*/
+
+#include "emu.h"
+#include "cpu/z80/z80.h"
+#include "sound/okim6295.h"
+#include "video/mc6845.h"
+
+
+
+class chance32_state : public driver_device
+{
+public:
+	chance32_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag),
+		m_fgram(*this, "fgram"),
+		m_bgram(*this, "bgram")
+
+	{ }
+
+	DECLARE_WRITE8_MEMBER(chance32_fgram_w)
+	{
+		m_fgram[offset] = data;
+		m_fg_tilemap->mark_tile_dirty(offset / 2);
+	}
+
+	DECLARE_WRITE8_MEMBER(chance32_bgram_w)
+	{
+		m_bgram[offset] = data;
+		m_bg_tilemap->mark_tile_dirty(offset / 2);
+	}
+
+	DECLARE_WRITE8_MEMBER(mux_w);
+	DECLARE_READ8_MEMBER(mux_r);
+
+	tilemap_t *m_fg_tilemap;
+	tilemap_t *m_bg_tilemap;
+
+	required_shared_ptr<UINT8> m_fgram;
+	required_shared_ptr<UINT8> m_bgram;
+
+	UINT8 mux_data;
+};
+
+static TILE_GET_INFO( get_fg_tile_info )
+{
+	chance32_state *state = machine.driver_data<chance32_state>();
+	int code = (state->m_fgram[tile_index * 2 + 1] << 8) | state->m_fgram[tile_index * 2];
+	int flip = (~code >> 12)&1;
+	SET_TILE_INFO(
+			1,
+			code & 0x0fff,
+			code >> 13,
+			TILE_FLIPYX(flip<<1)|flip);
+}
+
+static TILE_GET_INFO( get_bg_tile_info )
+{
+	chance32_state *state = machine.driver_data<chance32_state>();
+	int code = (state->m_bgram[tile_index * 2 +1] << 8) | state->m_bgram[tile_index * 2];
+	int flip = (~code >> 12)&1;
+	SET_TILE_INFO(
+			0,
+			code & 0x0fff,
+			code >> 13,
+			TILE_FLIPYX(flip<<1|flip));
+}
+
+
+VIDEO_START( chance32 )
+{
+	chance32_state *state = machine.driver_data<chance32_state>();
+
+	state->m_fg_tilemap = tilemap_create(machine, get_fg_tile_info, tilemap_scan_rows, 16, 8, 35, 29);
+	state->m_fg_tilemap->set_transparent_pen(0);
+
+	state->m_bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 16, 8, 35, 29);
+
+	state->m_fg_tilemap->set_flip(TILE_FLIPX|TILE_FLIPY);
+	state->m_bg_tilemap->set_flip(TILE_FLIPX|TILE_FLIPY);
+}
+
+SCREEN_UPDATE_IND16( chance32 )
+{
+	chance32_state *state = screen.machine().driver_data<chance32_state>();
+
+	/* TODO: wtf? */
+	state->m_bg_tilemap->set_scrollx(0, 352);
+	state->m_bg_tilemap->set_scrolly(0, 160);
+	state->m_fg_tilemap->set_scrollx(0, 352);
+	state->m_fg_tilemap->set_scrolly(0, 160);
+
+	state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
+	state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
+
+	return 0;
+}
+
+
+static ADDRESS_MAP_START( chance32_map, AS_PROGRAM, 8, chance32_state )
+	AM_RANGE(0x0000, 0xcfff) AM_ROM
+	AM_RANGE(0xd800, 0xdfff) AM_RAM
+
+	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(paletteram_xGGGGGRRRRRBBBBB_byte_le_w) AM_SHARE("paletteram")
+
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(chance32_fgram_w) AM_SHARE("fgram")
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(chance32_bgram_w) AM_SHARE("bgram")
+ADDRESS_MAP_END
+
+WRITE8_MEMBER(chance32_state::mux_w)
+{
+	mux_data = data;
+}
+
+READ8_MEMBER(chance32_state::mux_r)
+{
+	UINT8 res,i;
+	const char *const muxnames[4] = { "IN0", "IN1", "IN2", "IN3" };
+	res = 0;
+
+	for(i=0;i<4;i++)
+	{
+		if(mux_data & 1 << i)
+			res |= ioport(muxnames[i])->read();
+	}
+
+	return res;
+}
+
+static ADDRESS_MAP_START( chance32_portmap, AS_IO, 8, chance32_state )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+	//AM_RANGE(0x10, 0x10) AM_WRITENOP // ?
+	AM_RANGE(0x13, 0x13) AM_WRITE(mux_w)
+	AM_RANGE(0x20, 0x20) AM_READ_PORT("DSW0")
+	AM_RANGE(0x21, 0x21) AM_READ_PORT("DSW1")
+	AM_RANGE(0x22, 0x22) AM_READ_PORT("DSW2")
+	AM_RANGE(0x23, 0x23) AM_READ_PORT("DSW3")
+	AM_RANGE(0x24, 0x24) AM_READ_PORT("DSW4")
+	AM_RANGE(0x25, 0x25) AM_READ(mux_r)
+//  AM_RANGE(0x26, 0x26) AM_READ_PORT("UNK") // vblank?
+	AM_RANGE(0x30, 0x30) AM_DEVWRITE("crtc", mc6845_device, address_w)
+	AM_RANGE(0x31, 0x31) AM_DEVWRITE("crtc", mc6845_device, register_w)
+	AM_RANGE(0x50, 0x50) AM_DEVREADWRITE("oki", okim6295_device, read, write)
+//  AM_RANGE(0x60, 0x60) AM_WRITENOP // lamps
+
+ADDRESS_MAP_END
+
+
+
+static INPUT_PORTS_START( chance32 )
+	PORT_START("UNK")
+
+	PORT_START("DSW0")
+	PORT_DIPNAME( 0x01, 0x00, "DSW0" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x01, 0x00, "DSW1" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x01, 0x00, "DSW2" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x01, 0x00, "DSW3" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("DSW4")
+	PORT_DIPNAME( 0x01, 0x00, "DSW4" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("IN0")
+	PORT_DIPNAME( 0x01, 0x00, "0" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("IN1")
+	PORT_DIPNAME( 0x01, 0x00, "1" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("IN2")
+	PORT_DIPNAME( 0x01, 0x00, "2" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+
+	PORT_START("IN3")
+	PORT_DIPNAME( 0x01, 0x00, "3" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+INPUT_PORTS_END
+
+static const gfx_layout tiles8x8_layout =
+{
+	16,8,
+	RGN_FRAC(1,1),
+	8,
+	{ 0, 1, 2, 3,4,5,6,7 },
+	{ 15*8, 14*8, 13*8, 12*8, 11*8, 10*8, 9*8, 8*8, 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
+	{ 7*128, 6*128, 5*128, 4*128, 3*128, 2*128, 1*128, 0*128 },
+	128*8
+};
+
+static GFXDECODE_START( chance32 )
+	GFXDECODE_ENTRY( "gfx1", 0, tiles8x8_layout, 0, 8 )
+	GFXDECODE_ENTRY( "gfx2", 0, tiles8x8_layout, 0, 8 )
+GFXDECODE_END
+
+
+
+static MACHINE_START( chance32 )
+{
+
+}
+
+static MACHINE_RESET( chance32 )
+{
+
+}
+
+static const mc6845_interface mc6845_intf =
+{
+	"screen",	/* screen we are acting on */
+	16,			/* number of pixels per video memory address */
+	NULL,		/* before pixel update callback */
+	NULL,		/* row update callback */
+	NULL,		/* after pixel update callback */
+	DEVCB_NULL,	/* callback for display state changes */
+	DEVCB_NULL,	/* callback for cursor state changes */
+	DEVCB_NULL,	/* HSYNC callback */
+	DEVCB_NULL,	/* VSYNC callback */
+	NULL		/* update address callback */
+};
+
+
+static MACHINE_CONFIG_START( chance32, chance32_state )
+
+	/* basic machine hardware */
+	MCFG_CPU_ADD("maincpu", Z80,12000000/2)
+	MCFG_CPU_PROGRAM_MAP(chance32_map)
+	MCFG_CPU_IO_MAP(chance32_portmap)
+	MCFG_CPU_VBLANK_INT("screen", irq0_line_hold)
+
+	MCFG_MACHINE_START(chance32)
+	MCFG_MACHINE_RESET(chance32)
+
+	/* video hardware */
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MCFG_SCREEN_SIZE(40*16, 32*8)
+	MCFG_SCREEN_VISIBLE_AREA(0, 35*16-1, 0, 29*8-1)
+	MCFG_SCREEN_UPDATE_STATIC(chance32)
+
+	MCFG_MC6845_ADD("crtc", H46505, 12000000/14, mc6845_intf)	/* hand tuned to get ~60 fps */
+
+	MCFG_GFXDECODE(chance32)
+	MCFG_PALETTE_LENGTH(0x800)
+
+	MCFG_VIDEO_START(chance32)
+
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+
+	MCFG_OKIM6295_ADD("oki", 12000000/12, OKIM6295_PIN7_HIGH) // clock frequency & pin 7 not verified
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_CONFIG_END
+
+
+
+ROM_START( chance32 )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "0.u52", 0x00000, 0x10000, CRC(331048b2) SHA1(deb4da570b3efe6e15deefb6351f925b642b4614)  )
+
+	ROM_REGION( 0x80000, "gfx1", ROMREGION_INVERT )
+	ROM_LOAD16_BYTE( "4.u64", 0x00001, 0x20000, CRC(da80d9bd) SHA1(3b5235ab59fd55f0ec5584b3cf1aa5c8f36c76f6) )
+	ROM_LOAD16_BYTE( "5.u65", 0x00000, 0x20000, CRC(7528773b) SHA1(95c8e55cdec2c5c1dcdcc5a7edc6e590e3829f92) )
+	ROM_LOAD16_BYTE( "6.u66", 0x40001, 0x20000, CRC(cee2ffb0) SHA1(527c2072d39484317b0320afd975df1bbe244a01) )
+	ROM_LOAD16_BYTE( "7.u67", 0x40000, 0x20000, CRC(42dc4b69) SHA1(44c8f902db4c7ac235d5ea15d1b509f98663690a) )
+
+	ROM_REGION( 0x40000, "gfx2", ROMREGION_INVERT )
+	ROM_LOAD16_BYTE( "1.u71", 0x00001, 0x20000, CRC(f8e85873) SHA1(6ad24f7fcbc62a03180e168d70239df1ce662f0d) )
+	ROM_LOAD16_BYTE( "2.u72", 0x00000, 0x20000, CRC(860b534d) SHA1(44649ea93acdf173356bfcd7e81916253b52c378) )
+
+	ROM_REGION( 0x40000, "oki", 0 )
+	ROM_LOAD( "8.u21", 0x00000, 0x40000, CRC(161b35dd) SHA1(d20a75a4c4ed9cd9cfc12faee921122274840f06) )
+
+	ROM_REGION( 0x40000, "gals", 0 ) // no idea if these are any good
+	ROM_LOAD( "gal20v8a.u53.jed.bin", 0x0000, 0x157, CRC(9f680800) SHA1(2fa41ead85136e851d465432a7b9d3ec848c7a22) )
+	ROM_LOAD( "gal20v8a.u54.jed.bin", 0x0000, 0x157, CRC(9f680800) SHA1(2fa41ead85136e851d465432a7b9d3ec848c7a22) )
+	ROM_LOAD( "gal20v8a.u55.jed.bin", 0x0000, 0x157, CRC(9f680800) SHA1(2fa41ead85136e851d465432a7b9d3ec848c7a22) )
+	ROM_LOAD( "gal20v8a.u56.jed.bin", 0x0000, 0x157, CRC(6bab01ad) SHA1(c69e4be41a989a52788af8062f48bbe26bc3dab8) )
+	ROM_LOAD( "gal20v8a.u57.jed.bin", 0x0000, 0x157, CRC(787c4159) SHA1(f4a869b317c6be1024f1ca21bcc4af478c8227c8) )
+	ROM_LOAD( "gal20v8a.u58.jed.bin", 0x0000, 0x157, CRC(7b16053b) SHA1(cdb289d4f27c7a1a918393943bb8db9712e2f52e) )
+
+	ROM_LOAD( "gal16v8a.u47.jed.bin", 0x0000, 0x117, CRC(a733f0de) SHA1(6eec26043cedb3cae4efe93faa84a07327be468b) )
+	ROM_LOAD( "gal16v8a.u48.jed.bin", 0x0000, 0x117, CRC(5f1360ef) SHA1(56e4ee0dbae5602d810b2f7c744a71eb1a1e08a8) )
+
+	ROM_LOAD( "gal16v8a.u32.jed.bin", 0x0000, 0x117, CRC(c0784cd1) SHA1(0ae2ce482d379e29c2a9f130fc0d9ed928faef98) )
+
+	ROM_LOAD( "gal16v8a.u24.jed.bin", 0x0000, 0x117, CRC(a733f0de) SHA1(6eec26043cedb3cae4efe93faa84a07327be468b) )
+ROM_END
+
+
+
+
+
+GAME( 19??, chance32,  0,    chance32, chance32,  0, ROT0, "Pal Company", "Chance Thirty Two", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/changela.c src/mame/drivers/changela.c
--- src-old/mame/drivers/changela.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/changela.c	2012-05-03 11:00:08.000000000 +0200
@@ -52,7 +52,7 @@
 
 READ8_MEMBER(changela_state::changela_68705_port_b_r)
 {
-	return (m_port_b_out & m_ddr_b) | (input_port_read(machine(), "MCU") & ~m_ddr_b);
+	return (m_port_b_out & m_ddr_b) | (ioport("MCU")->read() & ~m_ddr_b);
 }
 
 WRITE8_MEMBER(changela_state::changela_68705_port_b_w)
@@ -122,7 +122,7 @@
 
 READ8_MEMBER(changela_state::changela_30_r)
 {
-	return input_port_read(machine(), "WHEEL") & 0x0f;	//wheel control (clocked input) signal on bits 3,2,1,0
+	return ioport("WHEEL")->read() & 0x0f;	//wheel control (clocked input) signal on bits 3,2,1,0
 }
 
 READ8_MEMBER(changela_state::changela_31_r)
@@ -130,7 +130,7 @@
 	/* If the new value is less than the old value, and it did not wrap around,
        or if the new value is greater than the old value, and it did wrap around,
        then we are moving LEFT. */
-	UINT8 curr_value = input_port_read(machine(), "WHEEL");
+	UINT8 curr_value = ioport("WHEEL")->read();
 
 	if ((curr_value < m_prev_value_31 && (m_prev_value_31 - curr_value) < 0x80)
 	||  (curr_value > m_prev_value_31 && (curr_value - m_prev_value_31) > 0x80))
@@ -147,7 +147,7 @@
 
 READ8_MEMBER(changela_state::changela_2c_r)
 {
-	int val = input_port_read(machine(), "IN0");
+	int val = ioport("IN0")->read();
 
 	val = (val & 0x30) | ((val & 1) << 7) | (((val & 1) ^ 1) << 6);
 
@@ -164,7 +164,7 @@
 		v8 = 1;
 
 	/* Gas pedal is made up of 2 switches, 1 active low, 1 active high */
-	switch (input_port_read(machine(), "IN1") & 0x03)
+	switch (ioport("IN1")->read() & 0x03)
 	{
 		case 0x02:
 			gas = 0x80;
@@ -177,7 +177,7 @@
 			break;
 	}
 
-	return (input_port_read(machine(), "IN1") & 0x20) | gas | (v8 << 4);
+	return (ioport("IN1")->read() & 0x20) | gas | (v8 << 4);
 }
 
 WRITE8_MEMBER(changela_state::mcu_pc_0_w)
diff -Nru src-old/mame/drivers/chinagat.c src/mame/drivers/chinagat.c
--- src-old/mame/drivers/chinagat.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/chinagat.c	2012-05-03 11:00:08.000000000 +0200
@@ -387,7 +387,7 @@
 
 static INPUT_PORTS_START( chinagat )
 	PORT_START("SYSTEM")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN3 )
@@ -912,7 +912,7 @@
 static DRIVER_INIT( chinagat )
 {
 	ddragon_state *state = machine.driver_data<ddragon_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
 	UINT8 *SUB = state->memregion("sub")->base();
 
 	state->m_technos_video_hw = 1;
diff -Nru src-old/mame/drivers/chinsan.c src/mame/drivers/chinsan.c
--- src-old/mame/drivers/chinsan.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/chinsan.c	2012-05-03 11:00:08.000000000 +0200
@@ -173,22 +173,22 @@
 		/* i doubt these are both really the same.. */
 		case 0x40:
 		case 0x4f:
-			return input_port_read(machine(), "MAHJONG_P2_1");
+			return ioport("MAHJONG_P2_1")->read();
 
 		case 0x53:
-			return input_port_read(machine(), "MAHJONG_P2_2");
+			return ioport("MAHJONG_P2_2")->read();
 
 		case 0x57:
-			return input_port_read(machine(), "MAHJONG_P2_3");
+			return ioport("MAHJONG_P2_3")->read();
 
 		case 0x5b:
-			return input_port_read(machine(), "MAHJONG_P2_4");
+			return ioport("MAHJONG_P2_4")->read();
 
 		case 0x5d:
-			return input_port_read(machine(), "MAHJONG_P2_5");
+			return ioport("MAHJONG_P2_5")->read();
 
 		case 0x5e:
-			return input_port_read(machine(), "MAHJONG_P2_6");
+			return ioport("MAHJONG_P2_6")->read();
 	}
 
 	printf("chinsan_input_port_0_r unk_r %02x\n", m_port_select);
@@ -203,22 +203,22 @@
 		/* i doubt these are both really the same.. */
 		case 0x40:
 		case 0x4f:
-			return input_port_read(machine(), "MAHJONG_P1_1");
+			return ioport("MAHJONG_P1_1")->read();
 
 		case 0x53:
-			return input_port_read(machine(), "MAHJONG_P1_2");
+			return ioport("MAHJONG_P1_2")->read();
 
 		case 0x57:
-			return input_port_read(machine(), "MAHJONG_P1_3");
+			return ioport("MAHJONG_P1_3")->read();
 
 		case 0x5b:
-			return input_port_read(machine(), "MAHJONG_P1_4");
+			return ioport("MAHJONG_P1_4")->read();
 
 		case 0x5d:
-			return input_port_read(machine(), "MAHJONG_P1_5");
+			return ioport("MAHJONG_P1_5")->read();
 
 		case 0x5e:
-			return input_port_read(machine(), "MAHJONG_P1_6");
+			return ioport("MAHJONG_P1_6")->read();
 	}
 
 	printf("chinsan_input_port_1_r unk_r %02x\n", m_port_select);
diff -Nru src-old/mame/drivers/chqflag.c src/mame/drivers/chqflag.c
--- src-old/mame/drivers/chqflag.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/chqflag.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,8 +120,8 @@
 {
 	switch (m_analog_ctrl & 0x03)
 	{
-		case 0x00: return (m_accel = input_port_read(machine(), "IN3"));	/* accelerator */
-		case 0x01: return (m_wheel = input_port_read(machine(), "IN4"));	/* steering */
+		case 0x00: return (m_accel = ioport("IN3")->read());	/* accelerator */
+		case 0x01: return (m_wheel = ioport("IN4")->read());	/* steering */
 		case 0x02: return m_accel;						/* accelerator (previous?) */
 		case 0x03: return m_wheel;						/* steering (previous?) */
 	}
diff -Nru src-old/mame/drivers/cinemat.c src/mame/drivers/cinemat.c
--- src-old/mame/drivers/cinemat.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/drivers/cinemat.c	2012-05-03 11:00:08.000000000 +0200
@@ -79,14 +79,14 @@
 
 READ8_MEMBER(cinemat_state::inputs_r)
 {
-	return (input_port_read(machine(), "INPUTS") >> offset) & 1;
+	return (ioport("INPUTS")->read() >> offset) & 1;
 }
 
 
 READ8_MEMBER(cinemat_state::switches_r)
 {
 	static const UINT8 switch_shuffle[8] = { 2,5,4,3,0,1,6,7 };
-	return (input_port_read(machine(), "SWITCHES") >> switch_shuffle[offset]) & 1;
+	return (ioport("SWITCHES")->read() >> switch_shuffle[offset]) & 1;
 }
 
 
@@ -149,7 +149,7 @@
 	else
 	{
 		int xval = (INT16)(cpu_get_reg(device, CCPU_X) << 4) >> 4;
-		return (input_port_read_safe(device->machine(), state->m_mux_select ? "ANALOGX" : "ANALOGY", 0) - xval) < 0x800;
+		return (state->ioport(state->m_mux_select ? "ANALOGX" : "ANALOGY")->read_safe(0) - xval) < 0x800;
 	}
 }
 
@@ -167,7 +167,7 @@
 	int delta_wheel;
 
     /* the shift register is cleared once per 'frame' */
-    delta_wheel = (INT8)input_port_read(machine(), "WHEEL") / 8;
+    delta_wheel = (INT8)ioport("WHEEL")->read() / 8;
     if (delta_wheel > 3)
         delta_wheel = 3;
     else if (delta_wheel < -3)
@@ -179,14 +179,14 @@
 
 READ8_MEMBER(cinemat_state::speedfrk_gear_r)
 {
-	int gearval = input_port_read(machine(), "GEAR");
+	int gearval = ioport("GEAR")->read();
 
 	/* check the fake gear input port and determine the bit settings for the gear */
 	if ((gearval & 0x0f) != 0x0f)
         m_gear = gearval & 0x0f;
 
 	/* add the start key into the mix -- note that it overlaps 4th gear */
-	if (!(input_port_read(machine(), "INPUTS") & 0x80))
+	if (!(ioport("INPUTS")->read() & 0x80))
         m_gear &= ~0x08;
 
 	return (m_gear >> offset) & 1;
@@ -232,9 +232,9 @@
 {
 	/* handle special keys first */
 	if (sundance_port_map[offset].portname)
-		return (input_port_read(machine(), sundance_port_map[offset].portname) & sundance_port_map[offset].bitmask) ? 0 : 1;
+		return (ioport(sundance_port_map[offset].portname)->read() & sundance_port_map[offset].bitmask) ? 0 : 1;
 	else
-		return (input_port_read(machine(), "INPUTS") >> offset) & 1;
+		return (ioport("INPUTS")->read() >> offset) & 1;
 }
 
 
@@ -247,7 +247,7 @@
 
 READ8_MEMBER(cinemat_state::boxingb_dial_r)
 {
-	int value = input_port_read(machine(), "DIAL");
+	int value = ioport("DIAL")->read();
 	if (!m_mux_select) offset += 4;
 	return (value >> offset) & 1;
 }
diff -Nru src-old/mame/drivers/circus.c src/mame/drivers/circus.c
--- src-old/mame/drivers/circus.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/circus.c	2012-05-03 11:00:08.000000000 +0200
@@ -54,7 +54,7 @@
 {
 	// also clears irq
 	cputag_set_input_line(machine(), "maincpu", 0, CLEAR_LINE);
-	return input_port_read(machine(), "PADDLE");
+	return ioport("PADDLE")->read();
 }
 
 static ADDRESS_MAP_START( circus_map, AS_PROGRAM, 8, circus_state )
@@ -96,7 +96,7 @@
 	PORT_DIPSETTING(	0x00, "Single Line" )
 	PORT_DIPSETTING(	0x20, "Super Bonus" )
 	PORT_DIPUNKNOWN_DIPLOC( 0x40, 0x00, "14A:1" ) /* Not mentioned in the manual */
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("PADDLE")
 	PORT_BIT( 0xff, 115, IPT_PADDLE ) PORT_MINMAX(64,167) PORT_SENSITIVITY(30) PORT_KEYDELTA(10) PORT_CENTERDELTA(0)
@@ -130,7 +130,7 @@
 	PORT_DIPSETTING(	0x20, "5 seconds" )
 	PORT_DIPSETTING(	0x40, "7 seconds" )
 	PORT_DIPSETTING(	0x60, "9 seconds" )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("PADDLE")
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_UNUSED)
@@ -164,7 +164,7 @@
 	PORT_DIPSETTING(	0x10, "Credit Awarded" )
 	PORT_DIPUNKNOWN_DIPLOC( 0x20, 0x00, "14A:2" ) /* Not mentioned in the manual */
 	PORT_DIPUNKNOWN_DIPLOC( 0x40, 0x00, "14A:1" ) /* Not mentioned in the manual */
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("PADDLE")
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_UNUSED)
@@ -204,7 +204,7 @@
 	PORT_DIPSETTING(	0x00, "No Award" )
 	PORT_DIPUNKNOWN_DIPLOC( 0x20, 0x00, "14A:2" ) /* Not mentioned in the manual */
 	PORT_DIPUNKNOWN_DIPLOC( 0x40, 0x00, "14A:1" ) /* Not mentioned in the manual */
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("PADDLE")
 	PORT_BIT( 0xff, 115, IPT_PADDLE ) PORT_MINMAX(64,167) PORT_SENSITIVITY(30) PORT_KEYDELTA(10) PORT_CENTERDELTA(0) PORT_REVERSE
@@ -457,7 +457,7 @@
 	ROM_LOAD( "9012.14d",	0x0000, 0x0200, CRC(2fde3930) SHA1(a21e2d342f16a39a07edf4bea8d698a52216ecba) )
 ROM_END
 
-ROM_START( circusse )
+ROM_START( springbd )
 	ROM_REGION( 0x10000, "maincpu", 0 ) // code
 	ROM_LOAD( "93448.1a",	0x1000, 0x0200, CRC(44d65ccd) SHA1(0eb2515444486a4656a4accec555501e75b39a74) )
 	ROM_LOAD( "93448.2a",	0x1200, 0x0200, CRC(b8acdbc5) SHA1(634bb11089f7a57a316b6829954cc4da4523f267) )
@@ -591,7 +591,7 @@
 
 
 GAMEL(1977, circus,   0,      circus,   circus,   circus,   ROT0, "Exidy / Taito", "Circus / Acrobat TV", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND, layout_circus )
-GAMEL(1977, circusse, circus, circus,   circus,   circus,   ROT0, "bootleg (Sub-Electro)", "Circus (Sub-Electro bootleg)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND, layout_circus ) // looks like a text hack, but we've seen 2 identical copies so it's worth supporting
+GAMEL(1977, springbd, circus, circus,   circus,   circus,   ROT0, "bootleg (Sub-Electro)", "Springboard (bootleg of Circus)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND, layout_circus ) // looks like a text hack, but we've seen 2 identical copies so it's worth supporting
 GAME( 1977, robotbwl, 0,      robotbwl, robotbwl, robotbwl, ROT0, "Exidy", "Robot Bowl", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAMEL(1979, crash,    0,      crash,    crash,    crash,    ROT0, "Exidy", "Crash", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND, layout_crash )
 GAMEL(1979, smash,    crash,  crash,    crash,    crash,    ROT0, "bootleg", "Smash (Crash bootleg)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND, layout_crash ) // looks like a text hack, but it also had a different bezel
diff -Nru src-old/mame/drivers/cischeat.c src/mame/drivers/cischeat.c
--- src-old/mame/drivers/cischeat.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cischeat.c	2012-05-03 11:00:08.000000000 +0200
@@ -429,7 +429,7 @@
 
 READ16_MEMBER(cischeat_state::scudhamm_analog_r)
 {
-	int i=input_port_read(machine(), "IN1"),j;
+	int i=ioport("IN1")->read(),j;
 
 	if ((i^m_prev)&0x4000) {
 		if (i<m_prev) m_prev-=0x8000;
@@ -527,17 +527,17 @@
 {
 	int armdelta;
 
-	armdelta = input_port_read(machine(), "IN1") - m_armold;
-	m_armold = input_port_read(machine(), "IN1");
+	armdelta = ioport("IN1")->read() - m_armold;
+	m_armold = ioport("IN1")->read();
 
 	return ~( m_scudhamm_motor_command + armdelta );	// + x : x<=0 and player loses, x>0 and player wins
 }
 
 READ16_MEMBER(cischeat_state::armchmp2_buttons_r)
 {
-	int arm_x = input_port_read(machine(), "IN1");
+	int arm_x = ioport("IN1")->read();
 
-	UINT16 ret = input_port_read(machine(), "IN0");
+	UINT16 ret = ioport("IN0")->read();
 
 	if (arm_x < 0x40)		ret &= ~1;
 	else if (arm_x > 0xc0)	ret &= ~2;
@@ -844,12 +844,12 @@
 	// DSW 3
 	PORT_DIPNAME( 0x0003, 0x0003, "Extra Setting For Coin B" ) PORT_DIPLOCATION("SW302:8,7")	/* 'Not used' (and must be OFF) according to the manual */
 	PORT_DIPSETTING(      0x0003, DEF_STR( Unused ) )
-	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_5C ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_6C ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_7C ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0001, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0002, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_5C ) )	PORT_CONDITION("IN4", 0x1c00, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_6C ) )	PORT_CONDITION("IN4", 0x1c00, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_7C ) )	PORT_CONDITION("IN4", 0x1c00, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0001, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0002, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( Unused ) )	PORT_CONDITION("IN4", 0x1c00, EQUALS, 0x0000)
 	PORT_DIPNAME( 0x0004, 0x0004, DEF_STR( Allow_Continue ) ) PORT_DIPLOCATION("SW302:6")
 	PORT_DIPSETTING(      0x0004, DEF_STR( No )  )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Yes ) )
@@ -875,7 +875,7 @@
 	PORT_DIPNAME( 0x0200, 0x0200, DEF_STR( Demo_Sounds ) ) PORT_DIPLOCATION("SW301:7")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( On ) )
-	PORT_DIPNAME( 0x1c00, 0x1c00, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW301:6,5,4") PORT_CONDITION("IN4", 0x0003, PORTCOND_EQUALS, 0x0003)
+	PORT_DIPNAME( 0x1c00, 0x1c00, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW301:6,5,4") PORT_CONDITION("IN4", 0x0003, EQUALS, 0x0003)
 	PORT_DIPSETTING(      0x1000, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(      0x0800, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x1800, DEF_STR( 2C_1C ) )
@@ -884,7 +884,7 @@
 	PORT_DIPSETTING(      0x1400, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x1c00, 0x1c00, "Set Coin B" ) PORT_DIPLOCATION("SW301:6,5,4") PORT_CONDITION("IN4", 0x0003, PORTCOND_NOTEQUALS, 0x0003)
+	PORT_DIPNAME( 0x1c00, 0x1c00, "Set Coin B" ) PORT_DIPLOCATION("SW301:6,5,4") PORT_CONDITION("IN4", 0x0003, NOTEQUALS, 0x0003)
 	PORT_DIPSETTING(      0x1c00, DEF_STR( Unused ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 	PORT_DIPNAME( 0xe000, 0xe000, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW301:3,2,1")
@@ -1051,7 +1051,7 @@
 	PORT_START("IN1")	// DSW 1 & 2 - $80000.w -> !f9012
 	// DSW 1
 	// Coinage Japan & USA (it changes with Country)
-	PORT_DIPNAME( 0x0007, 0x0007, "Coin A (JP US)" ) PORT_DIPLOCATION("SW01:1,2,3") PORT_CONDITION("IN1", 0x0300, PORTCOND_GREATERTHAN, 0x0100)
+	PORT_DIPNAME( 0x0007, 0x0007, "Coin A (JP US)" ) PORT_DIPLOCATION("SW01:1,2,3") PORT_CONDITION("IN1", 0x0300, GREATERTHAN, 0x0100)
 	PORT_DIPSETTING(      0x0001, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 2C_1C ) )
@@ -1060,7 +1060,7 @@
 	PORT_DIPSETTING(      0x0005, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x0038, 0x0038, "Coin B (JP US)" ) PORT_DIPLOCATION("SW01:4,5,6") PORT_CONDITION("IN1", 0x0300, PORTCOND_GREATERTHAN, 0x0100)
+	PORT_DIPNAME( 0x0038, 0x0038, "Coin B (JP US)" ) PORT_DIPLOCATION("SW01:4,5,6") PORT_CONDITION("IN1", 0x0300, GREATERTHAN, 0x0100)
 	PORT_DIPSETTING(      0x0008, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0018, DEF_STR( 2C_1C ) )
@@ -1068,11 +1068,11 @@
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0028, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_4C ) )
-	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW01:7") PORT_CONDITION("IN1", 0x0300, PORTCOND_GREATERTHAN, 0x0100)	// unused?
+	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW01:7") PORT_CONDITION("IN1", 0x0300, GREATERTHAN, 0x0100)	// unused?
 	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	// Coinage Europe & France (it changes with Country)
-	PORT_DIPNAME( 0x0007, 0x0007, "Coin A (EU FR)" ) PORT_DIPLOCATION("SW01:1,2,3") PORT_CONDITION("IN1", 0x0300, PORTCOND_NOTGREATERTHAN, 0x0100)
+	PORT_DIPNAME( 0x0007, 0x0007, "Coin A (EU FR)" ) PORT_DIPLOCATION("SW01:1,2,3") PORT_CONDITION("IN1", 0x0300, NOTGREATERTHAN, 0x0100)
 	PORT_DIPSETTING(      0x0007, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )
 	PORT_DIPSETTING(      0x0006, DEF_STR( 1C_2C ) )
@@ -1081,7 +1081,7 @@
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_7C ) )
-	PORT_DIPNAME( 0x0038, 0x0038, "Coin B (EU FR)" ) PORT_DIPLOCATION("SW01:4,5,6") PORT_CONDITION("IN1", 0x0300, PORTCOND_NOTGREATERTHAN, 0x0100)
+	PORT_DIPNAME( 0x0038, 0x0038, "Coin B (EU FR)" ) PORT_DIPLOCATION("SW01:4,5,6") PORT_CONDITION("IN1", 0x0300, NOTGREATERTHAN, 0x0100)
 	PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )
@@ -1090,7 +1090,7 @@
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0028, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_4C ) )
-	PORT_DIPNAME( 0x0040, 0x0040, "Free Play (EU & FR)" ) PORT_DIPLOCATION("SW01:7") PORT_CONDITION("IN1", 0x0300, PORTCOND_NOTGREATERTHAN, 0x0100)
+	PORT_DIPNAME( 0x0040, 0x0040, "Free Play (EU & FR)" ) PORT_DIPLOCATION("SW01:7") PORT_CONDITION("IN1", 0x0300, NOTGREATERTHAN, 0x0100)
 	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 
@@ -1113,10 +1113,10 @@
 	PORT_DIPNAME( 0x2000, 0x2000, DEF_STR( Demo_Sounds ) ) PORT_DIPLOCATION("SW02:6")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x2000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW02:7") PORT_CONDITION("IN1", 0x0300, PORTCOND_EQUALS, 0x0300)	// unused?
+	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW02:7") PORT_CONDITION("IN1", 0x0300, EQUALS, 0x0300)	// unused?
 	PORT_DIPSETTING(      0x4000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x4000, 0x4000, "Choose Race (US EU FR)" ) PORT_DIPLOCATION("SW02:7") PORT_CONDITION("IN1", 0x0300, PORTCOND_NOTEQUALS, 0x0300)	// -> f0020
+	PORT_DIPNAME( 0x4000, 0x4000, "Choose Race (US EU FR)" ) PORT_DIPLOCATION("SW02:7") PORT_CONDITION("IN1", 0x0300, NOTEQUALS, 0x0300)	// -> f0020
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x4000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x8000, 0x8000, "Vibrations" ) PORT_DIPLOCATION("SW02:8")
diff -Nru src-old/mame/drivers/citycon.c src/mame/drivers/citycon.c
--- src-old/mame/drivers/citycon.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/citycon.c	2012-05-03 11:00:08.000000000 +0200
@@ -16,7 +16,7 @@
 
 READ8_MEMBER(citycon_state::citycon_in_r)
 {
-	return input_port_read(machine(), flip_screen() ? "P2" : "P1");
+	return ioport(flip_screen() ? "P2" : "P1")->read();
 }
 
 READ8_MEMBER(citycon_state::citycon_irq_ack_r)
diff -Nru src-old/mame/drivers/clayshoo.c src/mame/drivers/clayshoo.c
--- src-old/mame/drivers/clayshoo.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/clayshoo.c	2012-05-03 11:00:08.000000000 +0200
@@ -54,7 +54,7 @@
 	UINT8 ret = 0;
 
 	/* read fake port and remap the buttons to 2 bits */
-	UINT8	raw = input_port_read(machine, "FAKE");
+	UINT8	raw = machine.root_device().ioport("FAKE")->read();
 
 	if (raw & (1 << (bit + 1)))
 		ret = 0x03;		/* expert */
@@ -74,11 +74,11 @@
 
 	switch (state->m_input_port_select)
 	{
-	case 0x01:	ret = input_port_read(device->machine(), "IN0"); break;
-	case 0x02:	ret = input_port_read(device->machine(), "IN1"); break;
-	case 0x04:	ret = (input_port_read(device->machine(), "IN2") & 0xf0) | difficulty_input_port_r(device->machine(), 0) |
+	case 0x01:	ret = state->ioport("IN0")->read(); break;
+	case 0x02:	ret = state->ioport("IN1")->read(); break;
+	case 0x04:	ret = (state->ioport("IN2")->read() & 0xf0) | difficulty_input_port_r(device->machine(), 0) |
 					  (difficulty_input_port_r(device->machine(), 3) << 2); break;
-	case 0x08:	ret = input_port_read(device->machine(), "IN3"); break;
+	case 0x08:	ret = state->ioport("IN3")->read(); break;
 	case 0x10:
 	case 0x20:	break;	/* these two are not really used */
 	default: logerror("Unexpected port read: %02X\n", state->m_input_port_select);
@@ -118,8 +118,8 @@
 
 	m_analog_port_val = 0xff;
 
-	m_analog_timer_1->adjust(compute_duration(&space.device(), input_port_read(machine(), "AN1")), 0x02);
-	m_analog_timer_2->adjust(compute_duration(&space.device(), input_port_read(machine(), "AN2")), 0x01);
+	m_analog_timer_1->adjust(compute_duration(&space.device(), ioport("AN1")->read()), 0x02);
+	m_analog_timer_2->adjust(compute_duration(&space.device(), ioport("AN2")->read()), 0x01);
 }
 
 
diff -Nru src-old/mame/drivers/cliffhgr.c src/mame/drivers/cliffhgr.c
--- src-old/mame/drivers/cliffhgr.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/cliffhgr.c	2012-05-03 11:00:08.000000000 +0200
@@ -134,7 +134,7 @@
 
 
 	if (m_port_bank < 7)
-		return input_port_read(machine(),  banknames[m_port_bank]);
+		return ioport(banknames[m_port_bank])->read();
 
 	/* output is pulled up for non-mapped ports */
 	return 0xff;
@@ -555,8 +555,8 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x02, 0x02, "Single Coin Continue" )	PORT_DIPLOCATION("E11:2")
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) ) PORT_CONDITION("BANK1",0x01,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) ) PORT_CONDITION("BANK1",0x01,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) ) PORT_CONDITION("BANK1",0x01,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) ) PORT_CONDITION("BANK1",0x01,EQUALS,0x00)
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Allow_Continue ) )	PORT_DIPLOCATION("E11:1")
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/cloak.c src/mame/drivers/cloak.c
--- src-old/mame/drivers/cloak.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/cloak.c	2012-05-03 11:00:08.000000000 +0200
@@ -228,7 +228,7 @@
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )		// player 2 controls, not used
 
 	PORT_START("SYSTEM")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN1 )
diff -Nru src-old/mame/drivers/cloud9.c src/mame/drivers/cloud9.c
--- src-old/mame/drivers/cloud9.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cloud9.c	2012-05-03 11:00:08.000000000 +0200
@@ -230,7 +230,7 @@
 
 READ8_MEMBER(cloud9_state::leta_r)
 {
-	return input_port_read(machine(), offset ? "TRACKX" : "TRACKY");
+	return ioport(offset ? "TRACKX" : "TRACKY")->read();
 }
 
 
diff -Nru src-old/mame/drivers/clshroad.c src/mame/drivers/clshroad.c
--- src-old/mame/drivers/clshroad.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/clshroad.c	2012-05-03 11:00:08.000000000 +0200
@@ -31,10 +31,10 @@
 
 READ8_MEMBER(clshroad_state::clshroad_input_r)
 {
-	return	((~input_port_read(machine(), "P1") & (1 << offset)) ? 1 : 0) |
-			((~input_port_read(machine(), "P2") & (1 << offset)) ? 2 : 0) |
-			((~input_port_read(machine(), "DSW1") & (1 << offset)) ? 4 : 0) |
-			((~input_port_read(machine(), "DSW2") & (1 << offset)) ? 8 : 0) ;
+	return	((~ioport("P1")->read() & (1 << offset)) ? 1 : 0) |
+			((~ioport("P2")->read() & (1 << offset)) ? 2 : 0) |
+			((~ioport("DSW1")->read() & (1 << offset)) ? 4 : 0) |
+			((~ioport("DSW2")->read() & (1 << offset)) ? 8 : 0) ;
 }
 
 
diff -Nru src-old/mame/drivers/cmmb.c src/mame/drivers/cmmb.c
--- src-old/mame/drivers/cmmb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cmmb.c	2012-05-03 11:00:08.000000000 +0200
@@ -125,10 +125,10 @@
 	//printf("%02x R\n",offset);
 	switch(offset)
 	{
-		case 0x00: return input_port_read(machine(), "IN2");
+		case 0x00: return ioport("IN2")->read();
 		case 0x03: return 4; //eeprom?
-		case 0x0e: return input_port_read(machine(), "IN0");
-		case 0x0f: return input_port_read(machine(), "IN1");
+		case 0x0e: return ioport("IN0")->read();
+		case 0x0f: return ioport("IN1")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/cninja.c src/mame/drivers/cninja.c
--- src-old/mame/drivers/cninja.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cninja.c	2012-05-03 11:00:08.000000000 +0200
@@ -131,11 +131,11 @@
 	switch (offset << 1)
 	{
 		case 0x41a: /* Player 1 & 2 input ports */
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 0x320: /* Coins */
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 		case 0x4e6: /* Dip switches */
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 0x504: /* PC: 6b6.  b4, 2c, 36 written before read */
 			logerror("Protection PC %06x: warning - read unmapped memory address %04x\n", cpu_get_pc(&space.device()), offset);
 			return 0x84;
@@ -386,7 +386,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")
 	DATAEAST_COINAGE
@@ -440,7 +440,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")	/* Dip switch bank 1 */
 
@@ -509,7 +509,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")	/* Dip switch bank 1 */
 
@@ -577,7 +577,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")	/* Dip switch bank 1 */
 
diff -Nru src-old/mame/drivers/cntsteer.c src/mame/drivers/cntsteer.c
--- src-old/mame/drivers/cntsteer.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cntsteer.c	2012-05-03 11:00:08.000000000 +0200
@@ -501,7 +501,7 @@
 READ8_MEMBER(cntsteer_state::cntsteer_adx_r)
 {
 	UINT8 res = 0, adx_val;
-	adx_val = input_port_read(machine(), "AN_STEERING");
+	adx_val = ioport("AN_STEERING")->read();
 
 	if (adx_val >= 0x70 && adx_val <= 0x90)
 		res = 0xff;
@@ -643,7 +643,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x60, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("P1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY
@@ -716,7 +716,7 @@
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2")
diff -Nru src-old/mame/drivers/combatsc.c src/mame/drivers/combatsc.c
--- src-old/mame/drivers/combatsc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/combatsc.c	2012-05-03 11:00:08.000000000 +0200
@@ -158,7 +158,7 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "DSW1", "DSW2" };
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 WRITE8_MEMBER(combatsc_state::combatscb_priority_w)
@@ -279,7 +279,7 @@
 		{
 			UINT8 curr;
 
-			curr = input_port_read_safe(machine(), tracknames[i], 0xff);
+			curr = ioport(tracknames[i])->read_safe(0xff);
 
 			dir[i] = curr - m_pos[i];
 			m_sign[i] = dir[i] & 0x80;
@@ -690,7 +690,7 @@
 static MACHINE_START( combatsc )
 {
 	combatsc_state *state = machine.driver_data<combatsc_state>();
-	UINT8 *MEM = machine.root_device().memregion("maincpu")->base() + 0x38000;
+	UINT8 *MEM = state->memregion("maincpu")->base() + 0x38000;
 
 	state->m_io_ram  = MEM + 0x0000;
 	state->m_page[0] = MEM + 0x4000;
diff -Nru src-old/mame/drivers/compgolf.c src/mame/drivers/compgolf.c
--- src-old/mame/drivers/compgolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/compgolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -99,7 +99,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2)
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03,   0x03, DEF_STR( Coin_A ) )
diff -Nru src-old/mame/drivers/coolpool.c src/mame/drivers/coolpool.c
--- src-old/mame/drivers/coolpool.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/coolpool.c	2012-05-03 11:00:08.000000000 +0200
@@ -406,10 +406,10 @@
 
 	m_result = (m_lastresult | 0x00ff);
 
-	m_newx[1] = input_port_read(machine(), "XAXIS1");	/* Trackball 1  Left - Right */
-	m_newy[1] = input_port_read(machine(), "YAXIS1");	/* Trackball 1   Up  - Down  */
-	m_newx[2] = input_port_read(machine(), "XAXIS2");	/* Trackball 2  Left - Right */
-	m_newy[2] = input_port_read(machine(), "YAXIS2");	/* Trackball 2   Up  - Down  */
+	m_newx[1] = ioport("XAXIS1")->read();	/* Trackball 1  Left - Right */
+	m_newy[1] = ioport("YAXIS1")->read();	/* Trackball 1   Up  - Down  */
+	m_newx[2] = ioport("XAXIS2")->read();	/* Trackball 2  Left - Right */
+	m_newy[2] = ioport("YAXIS2")->read();	/* Trackball 2   Up  - Down  */
 
 	m_dx[1] = (INT8)(m_newx[1] - m_oldx[1]);
 	m_dy[1] = (INT8)(m_newy[1] - m_oldy[1]);
@@ -572,9 +572,9 @@
 READ16_MEMBER(coolpool_state::coolpool_input_r)
 {
 
-	m_result = (input_port_read(machine(), "IN1") & 0x00ff) | (m_lastresult & 0xff00);
-	m_newx[1] = input_port_read(machine(), "XAXIS");
-	m_newy[1] = input_port_read(machine(), "YAXIS");
+	m_result = (ioport("IN1")->read() & 0x00ff) | (m_lastresult & 0xff00);
+	m_newx[1] = ioport("XAXIS")->read();
+	m_newy[1] = ioport("YAXIS")->read();
 	m_dx[1] = (INT8)(m_newx[1] - m_oldx[1]);
 	m_dy[1] = (INT8)(m_newy[1] - m_oldy[1]);
 
diff -Nru src-old/mame/drivers/cop01.c src/mame/drivers/cop01.c
--- src-old/mame/drivers/cop01.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cop01.c	2012-05-03 11:00:08.000000000 +0200
@@ -98,7 +98,7 @@
 CUSTOM_INPUT_MEMBER(cop01_state::mightguy_area_r)
 {
 	int bit_mask = (FPTR)param;
-	return (input_port_read(machine(), "FAKE") & bit_mask) ? 0x01 : 0x00;
+	return (ioport("FAKE")->read() & bit_mask) ? 0x01 : 0x00;
 }
 
 WRITE8_MEMBER(cop01_state::cop01_irq_ack_w)
diff -Nru src-old/mame/drivers/copsnrob.c src/mame/drivers/copsnrob.c
--- src-old/mame/drivers/copsnrob.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/copsnrob.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,7 +81,7 @@
 
 READ8_MEMBER(copsnrob_state::copsnrob_misc_r)
 {
-	return input_port_read(machine(), "IN0") & 0x80;
+	return ioport("IN0")->read() & 0x80;
 }
 
 WRITE8_MEMBER(copsnrob_state::copsnrob_misc2_w)
@@ -133,11 +133,11 @@
  *
  *************************************/
 
-static const input_port_value gun_table[] = {0x3f, 0x5f, 0x6f, 0x77, 0x7b, 0x7d, 0x7e};
+static const ioport_value gun_table[] = {0x3f, 0x5f, 0x6f, 0x77, 0x7b, 0x7d, 0x7e};
 
 static INPUT_PORTS_START( copsnrob )
 	PORT_START("IN0")
-	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
diff -Nru src-old/mame/drivers/corona.c src/mame/drivers/corona.c
--- src-old/mame/drivers/corona.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/corona.c	2012-05-03 11:00:08.000000000 +0200
@@ -515,12 +515,12 @@
 {
 	switch( m_input_selector )
 	{
-		case 0x01: return input_port_read(machine(), "IN0-1");
-		case 0x02: return input_port_read(machine(), "IN0-2");
-		case 0x04: return input_port_read(machine(), "IN0-3");
-		case 0x08: return input_port_read(machine(), "IN0-4");
-		case 0x10: return input_port_read(machine(), "IN0-5");
-		case 0x20: return input_port_read(machine(), "IN0-6");
+		case 0x01: return ioport("IN0-1")->read();
+		case 0x02: return ioport("IN0-2")->read();
+		case 0x04: return ioport("IN0-3")->read();
+		case 0x08: return ioport("IN0-4")->read();
+		case 0x10: return ioport("IN0-5")->read();
+		case 0x20: return ioport("IN0-6")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/cosmic.c src/mame/drivers/cosmic.c
--- src-old/mame/drivers/cosmic.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cosmic.c	2012-05-03 11:00:08.000000000 +0200
@@ -315,12 +315,12 @@
 READ8_MEMBER(cosmic_state::cosmicg_port_0_r)
 {
 	/* The top four address lines from the CRTC are bits 0-3 */
-	return (input_port_read(machine(), "IN0") & 0xf0) | ((machine().primary_screen->vpos() & 0xf0) >> 4);
+	return (ioport("IN0")->read() & 0xf0) | ((machine().primary_screen->vpos() & 0xf0) >> 4);
 }
 
 READ8_MEMBER(cosmic_state::magspot_coinage_dip_r)
 {
-	return (input_port_read_safe(machine(), "DSW", 0) & (1 << (7 - offset))) ? 0 : 1;
+	return (ioport("DSW")->read_safe(0) & (1 << (7 - offset))) ? 0 : 1;
 }
 
 
@@ -328,8 +328,8 @@
 
 READ8_MEMBER(cosmic_state::nomnlnd_port_0_1_r)
 {
-	int control = input_port_read(machine(), offset ? "IN1" : "IN0");
-	int fire = input_port_read(machine(), "IN3");
+	int control = ioport(offset ? "IN1" : "IN0")->read();
+	int fire = ioport("IN3")->read();
 
 	/* If firing - stop tank */
 	if ((fire & 0xc0) == 0) return 0xff;
@@ -630,7 +630,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
 
 	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x1e, IP_ACTIVE_LOW, IPT_UNUSED )		/* always HI */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SPECIAL )	/* reads what was written to 4808.  Probably not used?? */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
@@ -715,7 +715,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
 
 	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x3e, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )
@@ -811,7 +811,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
 
 	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x1e, IP_ACTIVE_LOW, IPT_UNUSED )		/* always HI */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SPECIAL )	/* reads what was written to 4808.  Probably not used?? */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
@@ -1512,7 +1512,7 @@
 	cosmic_state *state = machine.driver_data<cosmic_state>();
 	offs_t offs, len;
 	UINT8 *rom;
-	len = machine.root_device().memregion("maincpu")->bytes();
+	len = state->memregion("maincpu")->bytes();
 	rom = state->memregion("maincpu")->base();
 	for (offs = 0; offs < len; offs++)
 	{
diff -Nru src-old/mame/drivers/cps1.c src/mame/drivers/cps1.c
--- src-old/mame/drivers/cps1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cps1.c	2012-05-03 11:00:08.000000000 +0200
@@ -247,35 +247,35 @@
 READ16_MEMBER(cps_state::cps1_dsw_r)
 {
 	static const char *const dswname[] = { "IN0", "DSWA", "DSWB", "DSWC" };
-	int in = input_port_read(machine(), dswname[offset]);
+	int in = ioport(dswname[offset])->read();
 	return (in << 8) | 0xff;
 }
 
 READ16_MEMBER(cps_state::cps1_hack_dsw_r)
 {
 	static const char *const dswname[] = { "IN0", "DSWA", "DSWB", "DSWC" };
-	int in = input_port_read(machine(), dswname[offset]);
+	int in = ioport(dswname[offset])->read();
 	return (in << 8) | in;
 }
 
 READ16_MEMBER(cps_state::forgottn_dial_0_r)
 {
-	return ((input_port_read(machine(), "DIAL0") - m_dial[0]) >> (8 * offset)) & 0xff;
+	return ((ioport("DIAL0")->read() - m_dial[0]) >> (8 * offset)) & 0xff;
 }
 
 READ16_MEMBER(cps_state::forgottn_dial_1_r)
 {
-	return ((input_port_read(machine(), "DIAL1") - m_dial[1]) >> (8 * offset)) & 0xff;
+	return ((ioport("DIAL1")->read() - m_dial[1]) >> (8 * offset)) & 0xff;
 }
 
 WRITE16_MEMBER(cps_state::forgottn_dial_0_reset_w)
 {
-	m_dial[0] = input_port_read(machine(), "DIAL0");
+	m_dial[0] = ioport("DIAL0")->read();
 }
 
 WRITE16_MEMBER(cps_state::forgottn_dial_1_reset_w)
 {
-	m_dial[1] = input_port_read(machine(), "DIAL1");
+	m_dial[1] = ioport("DIAL1")->read();
 }
 
 
@@ -912,7 +912,7 @@
 
 	PORT_MODIFY("DSWB")
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Difficulty ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):1,2,3")
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Difficulty ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):1,2,3")
 	PORT_DIPSETTING(    0x04, "1 (Easiest)" )
 	PORT_DIPSETTING(    0x05, "2" )
 	PORT_DIPSETTING(    0x06, "3" )
@@ -921,16 +921,16 @@
 	PORT_DIPSETTING(    0x02, "6" )
 	PORT_DIPSETTING(    0x01, "7" )
 	PORT_DIPSETTING(    0x00, "8 (Hardest)" )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):4")
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):4")
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )  PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):5,6")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )  PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):5,6")
 	PORT_DIPSETTING(    0x20, "10K, 30K and every 30K" )
 	PORT_DIPSETTING(    0x10, "20K, 50K and every 70K" )
 	PORT_DIPSETTING(    0x30, "30K, 60K and every 70K" )
 	PORT_DIPSETTING(    0x00, "40K, 70K and every 80K" )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x07, 0x07, "Starting Weapon" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(B):1,2,3")
+	PORT_DIPNAME( 0x07, 0x07, "Starting Weapon" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(B):1,2,3")
 	PORT_DIPSETTING(    0x07, "Spear" )
 	PORT_DIPSETTING(    0x06, "Knife" )
 	PORT_DIPSETTING(    0x05, "Torch" )
@@ -939,7 +939,7 @@
 	PORT_DIPSETTING(    0x02, "Shield" )
 	PORT_DIPSETTING(    0x01, "Super Weapon" )
 //  PORT_DIPSETTING(    0x00, "INVALID !" )
-	PORT_DIPNAME( 0x38, 0x30, "Armor on New Life" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(B):4,5,6")
+	PORT_DIPNAME( 0x38, 0x30, "Armor on New Life" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(B):4,5,6")
 //  PORT_DIPSETTING(    0x38, "Silver Armor" )
 	PORT_DIPSETTING(    0x18, "Golden Armor" )
 	PORT_DIPSETTING(    0x30, "Silver Armor" )
@@ -956,7 +956,7 @@
 
 	PORT_MODIFY("DSWA")
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(A):1,2,3")
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(A):1,2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 2C_1C ) )
@@ -965,7 +965,7 @@
 	PORT_DIPSETTING(    0x05, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Coin_B ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(A):4,5,6")
+	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Coin_B ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(A):4,5,6")
 	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
@@ -975,7 +975,7 @@
 	PORT_DIPSETTING(    0x20, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_6C ) )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x0f, 0x0f, "Starting Level" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):1,2,3,4")
+	PORT_DIPNAME( 0x0f, 0x0f, "Starting Level" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):1,2,3,4")
 	PORT_DIPSETTING(    0x0f, "Level 1 (1st half)" )
 	PORT_DIPSETTING(    0x0e, "Level 1 (2nd half)" )
 	PORT_DIPSETTING(    0x0d, "Level 2 (1st half)" )
@@ -992,10 +992,10 @@
 //  PORT_DIPSETTING(    0x02, "INVALID !" )
 //  PORT_DIPSETTING(    0x01, "INVALID !" )
 //  PORT_DIPSETTING(    0x00, "INVALID !" )
-	PORT_DIPNAME( 0x10, 0x10, "Invulnerability" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):5")
+	PORT_DIPNAME( 0x10, 0x10, "Invulnerability" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):5")
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, "Slow Motion" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):6")
+	PORT_DIPNAME( 0x20, 0x20, "Slow Motion" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
@@ -1139,27 +1139,27 @@
 
 	PORT_START("DSWC")
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(C):1,2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(C):1,2")
 	PORT_DIPSETTING(    0x02, "1" )
 	PORT_DIPSETTING(    0x03, "2" )
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "4" )
-	PORT_DIPNAME( 0x0c, 0x0c, "Vitality" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(C):3,4")
+	PORT_DIPNAME( 0x0c, 0x0c, "Vitality" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(C):3,4")
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x0c, "3" )
 	PORT_DIPSETTING(    0x08, "4" )
 	PORT_DIPSETTING(    0x04, "5" )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x01, 0x01, "Turbo Mode" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(C):1")
+	PORT_DIPNAME( 0x01, 0x01, "Turbo Mode" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(C):1")
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, "Freeze" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(C):2")
+	PORT_DIPNAME( 0x02, 0x02, "Freeze" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(C):2")
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, "Slow Motion" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(C):3")
+	PORT_DIPNAME( 0x04, 0x04, "Slow Motion" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(C):3")
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, "Invulnerability" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(C):4")
+	PORT_DIPNAME( 0x08, 0x08, "Invulnerability" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(C):4")
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
@@ -1168,11 +1168,11 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(C):6")
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(C):6")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x20, 0x20, "Display Debug Infos" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(C):6")
+	PORT_DIPNAME( 0x20, 0x20, "Display Debug Infos" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(C):6")
 	PORT_DIPSETTING(    0x20, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
 
@@ -1185,7 +1185,7 @@
 
 	PORT_START("DSWB")
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Difficulty ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):1,2,3")
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Difficulty ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):1,2,3")
 	PORT_DIPSETTING(    0x04, "1 (Easiest)" )
 	PORT_DIPSETTING(    0x05, "2" )
 	PORT_DIPSETTING(    0x06, "3" )
@@ -1194,25 +1194,25 @@
 	PORT_DIPSETTING(    0x02, "6" )
 	PORT_DIPSETTING(    0x01, "7" )
 	PORT_DIPSETTING(    0x00, "8 (Hardest)" )
-	PORT_DIPNAME( 0x18, 0x18, "Nando Speed" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):4,5")
+	PORT_DIPNAME( 0x18, 0x18, "Nando Speed" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):4,5")
 	PORT_DIPSETTING(    0x10, "Slow" )
 	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x08, "Fast" )
 	PORT_DIPSETTING(    0x00, "Very Fast" )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):6")
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):7")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "Stage Magic Continue" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(B):8")
+	PORT_DIPNAME( 0x80, 0x80, "Stage Magic Continue" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(B):8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(B):1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unused ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(B):1")
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x1e, 0x1e, "Slow Motion Delay" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(B):2,3,4,5")
+	PORT_DIPNAME( 0x1e, 0x1e, "Slow Motion Delay" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(B):2,3,4,5")
 	PORT_DIPSETTING(    0x1e, "2 Frames" )
 	PORT_DIPSETTING(    0x1c, "3 Frames" )
 	PORT_DIPSETTING(    0x1a, "4 Frames" )
@@ -1229,7 +1229,7 @@
 	PORT_DIPSETTING(    0x04, "15 Frames" )
 	PORT_DIPSETTING(    0x02, "16 Frames" )
 	PORT_DIPSETTING(    0x00, "17 Frames" )
-	PORT_DIPNAME( 0xe0, 0xe0, "Starting Level" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(B):6,7,8")
+	PORT_DIPNAME( 0xe0, 0xe0, "Starting Level" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(B):6,7,8")
 	PORT_DIPSETTING(    0xe0, "Level 1" )
 	PORT_DIPSETTING(    0xc0, "Level 2" )
 	PORT_DIPSETTING(    0xa0, "Level 3" )
@@ -1241,7 +1241,7 @@
 
 	PORT_START("DSWA")
 	/* Standard Dip Switches */
-	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(A):1,2,3")
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(A):1,2,3")
 	PORT_DIPSETTING(    0x01, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_1C ) )
@@ -1250,7 +1250,7 @@
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x05, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_4C ) )
-	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Coin_B ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(A):4,5,6")
+	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Coin_B ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(A):4,5,6")
 	PORT_DIPSETTING(    0x08, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 2C_1C ) )
@@ -1259,20 +1259,20 @@
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x28, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( 1C_4C ) )
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Cabinet ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW(A):7,8")
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Cabinet ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW(A):7,8")
 	PORT_DIPSETTING(    0xc0, "Upright 1 Player" )
 	PORT_DIPSETTING(    0x80, "Upright 2 Players" )
 //  PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
 	/* Debug Dip Switches */
-	PORT_DIPNAME( 0x3f, 0x3f, DEF_STR( Free_Play ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):1,2,3,4,5,6")
+	PORT_DIPNAME( 0x3f, 0x3f, DEF_STR( Free_Play ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):1,2,3,4,5,6")
 	PORT_DIPSETTING(    0x3f, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x38, DEF_STR( On ) )
 	/* Other values don't give free play */
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Cabinet ) ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):7")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Cabinet ) ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):7")
 	PORT_DIPSETTING(    0x40, "Upright 1 Player" )
 	PORT_DIPSETTING(    0x00, "Upright 2 Players" )
-	PORT_DIPNAME( 0x80, 0x80, "Maximum magic/sword power" ) PORT_CONDITION("DSWC", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):8")
+	PORT_DIPNAME( 0x80, 0x80, "Maximum magic/sword power" ) PORT_CONDITION("DSWC", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
@@ -1818,10 +1818,10 @@
 
 	PORT_START("DSWA")
 	CPS1_COINAGE_1( "SW(A)" )
-	PORT_DIPNAME( 0x40, 0x40, "2 Coins to Start, 1 to Continue" ) PORT_CONDITION("DSWA", 0x3f,PORTCOND_NOTEQUALS,0x00) PORT_DIPLOCATION("SW(A):7")
+	PORT_DIPNAME( 0x40, 0x40, "2 Coins to Start, 1 to Continue" ) PORT_CONDITION("DSWA", 0x3f,NOTEQUALS,0x00) PORT_DIPLOCATION("SW(A):7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Free_Play ) ) PORT_CONDITION("DSWA", 0x3f, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW(A):7")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Free_Play ) ) PORT_CONDITION("DSWA", 0x3f, EQUALS, 0x00) PORT_DIPLOCATION("SW(A):7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	/* Free Play: ALL bits 0 to 7 must be ON ; 4C_1C, 4C_1C, 2 Coins to Start, 1 to Continue ON */
diff -Nru src-old/mame/drivers/cps2.c src/mame/drivers/cps2.c
--- src-old/mame/drivers/cps2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cps2.c	2012-05-03 11:00:08.000000000 +0200
@@ -706,7 +706,7 @@
 		/* bit 7 - */
 
 		/* EEPROM */
-		input_port_write(space->machine(), "EEPROMOUT", data, 0xffff);
+		state->ioport("EEPROMOUT")->write(data, 0xffff);
 	}
 
 	if (ACCESSING_BITS_0_7)
@@ -798,9 +798,9 @@
 	cps_state *state = space->machine().driver_data<cps_state>();
 
 	if (state->m_readpaddle != 0)
-		return (input_port_read(space->machine(), "IN0"));
+		return (state->ioport("IN0")->read());
 	else
-		return (input_port_read(space->machine(), "PADDLE1") & 0xff) | (input_port_read(space->machine(), "PADDLE2") << 8);
+		return (state->ioport("PADDLE1")->read() & 0xff) | (state->ioport("PADDLE2")->read() << 8);
 }
 
 
@@ -8181,7 +8181,7 @@
 {
 	cps_state *state = machine.driver_data<cps_state>();
 	address_space *space = machine.device("maincpu")->memory().space(AS_PROGRAM);
-	UINT16 *rom = (UINT16 *)machine.root_device().memregion("maincpu")->base();
+	UINT16 *rom = (UINT16 *)state->memregion("maincpu")->base();
 	int length = state->memregion("maincpu")->bytes();
 
 	gigaman2_gfx_reorder(machine);
@@ -9498,7 +9498,7 @@
 	ROM_LOAD16_WORD_SWAP( "vh2j_d.04a", 0x080000, 0x80000, CRC(ced9bba3) SHA1(ef7be9d39ae93ffde7d940736de9711a24585ef4) )
 	ROM_LOAD16_WORD_SWAP( "vh2j.05",    0x100000, 0x80000, CRC(de34f624) SHA1(60bbbd1765e76839b01c38765da2368c5188ec61) )
 	ROM_LOAD16_WORD_SWAP( "vh2j.06",    0x180000, 0x80000, CRC(6a3b9897) SHA1(4f3b37004db8a3d3dde709b51c94c392615134b5) )
-	ROM_LOAD16_WORD_SWAP( "vh2j_d.06",  0x200000, 0x80000, CRC(f320ea30) SHA1(c7853b83892a49917e7a0aa68bc66875a9263589) ) // fails rom test, bad? I don't see why this should change
+	ROM_LOAD16_WORD_SWAP( "vh2j.07",    0x200000, 0x80000, CRC(b021c029) SHA1(de4299197600608e83fe50775e3f352f5add844d) )
 	ROM_LOAD16_WORD_SWAP( "vh2j.08",    0x280000, 0x80000, CRC(ac873dff) SHA1(ad9a085b8403801035683b6f63eee33daf4e97ae) )
 	ROM_LOAD16_WORD_SWAP( "vh2j.09",    0x300000, 0x80000, CRC(eaefce9c) SHA1(d842a824f0d0adc13a86f780084164c1273c45a4) )
 	ROM_LOAD16_WORD_SWAP( "vh2j.10",    0x380000, 0x80000, CRC(11730952) SHA1(2966b80b99ab065614a6ddb546110f482b998e32) )
@@ -9524,14 +9524,14 @@
 ROM_END
 
 
-ROM_START( vsav2d ) // all modified roms fail rom check
+ROM_START( vsav2d )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_WORD_SWAP( "vs2j_d.03", 0x000000, 0x80000, CRC(5ee19aee) SHA1(da16d64c4de0b14a39c4a19a00c59f59579d0bd8) )
-	ROM_LOAD16_WORD_SWAP( "vs2j_d.04", 0x080000, 0x80000, CRC(80116c47) SHA1(e73c2d1fc006a74e3bb4c7a0e1b888b24b3f4c33) )
-	ROM_LOAD16_WORD_SWAP( "vs2j_d.05", 0x100000, 0x80000, CRC(dc74a062) SHA1(723e806f70a1cfcfcb37d59fae30bfd27a581f3a) )
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.03", 0x000000, 0x80000, CRC(50865f7b) SHA1(30914bde1caec55847f28167bfb48bc4473a376c) )
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.04", 0x080000, 0x80000, CRC(c3bff0e3) SHA1(5b81dfdc3bf4e78a9d023cd8c753ce0839c0e175) )
+	ROM_LOAD16_WORD_SWAP( "vs2j.05",   0x100000, 0x80000, CRC(61979638) SHA1(4d5625a9a06926c1a42c8f6e3a4c943f17750ec2) )
 	ROM_LOAD16_WORD_SWAP( "vs2j.06",   0x180000, 0x80000, CRC(f37c5bc2) SHA1(d8c1040a6ee6b9fc677a6a32b99bf02b6a707812) )
 	ROM_LOAD16_WORD_SWAP( "vs2j.07",   0x200000, 0x80000, CRC(8f885809) SHA1(69dac07e1f483b6478f792d20a137d6a081fbea3) )
-	ROM_LOAD16_WORD_SWAP( "vs2j_d.08", 0x280000, 0x80000, CRC(97554918) SHA1(da6a8f6ba160696b141117c7c0da6f459637a729) ) // should this really be different?
+	ROM_LOAD16_WORD_SWAP( "vs2j.08",   0x280000, 0x80000, CRC(2018c120) SHA1(de1184ab771c6f075cdefa744a28b09f78d91643) )
 	ROM_LOAD16_WORD_SWAP( "vs2j.09",   0x300000, 0x80000, CRC(fac3c217) SHA1(0e9dd54e401e6d7c4fe81107ffd27e42ca810fcb) )
 	ROM_LOAD16_WORD_SWAP( "vs2j.10",   0x380000, 0x80000, CRC(eb490213) SHA1(bf0416df66a33c7a4678ab4a047de334dfd3b31e) )
 
@@ -9788,7 +9788,7 @@
 GAME( 1997, sgemfd,   sgemf,    dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Super Gem Fighter Mini Mix (USA 970904 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2000, mmatrixd, mmatrix,  dead_cps2, cps2_2p1b, cps2,    ROT0,   "bootleg", "Mars Matrix: Hyper Solid Shooting (Japan 000412 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2000, dimahoud, dimahoo,  dead_cps2, cps2_2p3b, cps2,    ROT270, "bootleg", "Dimahoo (USA 000121 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
-GAME( 1997, vhunt2d,  vhunt2,   dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Hunter 2: Darkstalkers Revenge (Japan 970929 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1997, vhunt2d,  vhunt2,   dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Hunter 2: Darkstalkers Revenge (Japan 970913 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1997, vsav2d,   vsav2,    dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Savior 2: The Lord of Vampire (Japan 970913 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1997, csclub1d, csclub,   dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Capcom Sports Club (Euro 970722 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1995, cybotsud, cybots,   dead_cps2, cybots,    cps2,    ROT0,   "bootleg", "Cyberbots: Fullmetal Madness (USA 950424 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/cps3.c src/mame/drivers/cps3.c
--- src-old/mame/drivers/cps3.c	2012-04-20 18:34:05.000000000 +0200
+++ src/mame/drivers/cps3.c	2012-05-03 11:00:08.000000000 +0200
@@ -663,7 +663,7 @@
 {
 	cps3_state *state = machine.driver_data<cps3_state>();
 	int i;
-	UINT32 *coderegion = (UINT32*)machine.root_device().memregion("user1")->base();
+	UINT32 *coderegion = (UINT32*)state->memregion("user1")->base();
 
 	state->m_decrypted_bios = (UINT32*)state->memregion("user1")->base();
 
@@ -701,7 +701,7 @@
 	state->m_altEncryption = altEncryption;
 
 	// cache pointers to regions
-	state->m_user4region = machine.root_device().memregion("user4")->base();
+	state->m_user4region = state->memregion("user4")->base();
 	state->m_user5region = state->memregion("user5")->base();
 
 	if (!state->m_user4region) state->m_user4region = auto_alloc_array(machine, UINT8, USER4REGION_LENGTH);
@@ -2650,7 +2650,7 @@
 	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "redearth-simm5.1", 0x00000, 0x200000, CRC(9b8cb56b) SHA1(2ff1081dc99bb7c2f1e036f4c112137c96b83d23) ) \
 
 #define REDEARTH_961121_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-wzd-5", 0, SHA1(e5676752b08283dc4a98c3d7b759e8aa6dcd0679) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-wzd-5", 0, BAD_DUMP SHA1(e5676752b08283dc4a98c3d7b759e8aa6dcd0679) ) \
 
 #define REDEARTH_961023_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "redearth(__961023)-simm1.0", 0x00000, 0x200000, CRC(65bac346) SHA1(6f4ba0c2cae91a37fc97bea5fc8a50aaf6ca6513) ) \
@@ -2704,7 +2704,7 @@
 	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "sfiii-simm5.1", 0x00000, 0x200000, CRC(c6f1c066) SHA1(00de492dd1ef7aef05027a8c501c296b6602e917) ) \
 
 #define SFIII_970204_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-sf3-3", 0, SHA1(606e62cc5f46275e366e7dbb412dbaeb7e54cd0c) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-sf3-3", 0, BAD_DUMP SHA1(606e62cc5f46275e366e7dbb412dbaeb7e54cd0c) ) \
 
 #define SFIII2_970930_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii2-simm1.0", 0x00000, 0x200000, CRC(2d666f0b) SHA1(68de034b3a3aeaf4b26122a84ad48b0b763e4122) ) \
@@ -2741,7 +2741,7 @@
 	ROM_REGION( 0x200000, "simm5.7", 0 ) ROM_LOAD( "sfiii2-simm5.7", 0x00000, 0x200000, CRC(93ffa199) SHA1(33ec2379f30c6fdf47ba72c1d0cad8bdd02f17df) ) \
 
 #define SFIII2_970930_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-3ga000", 0, SHA1(4e162885b0b3265a56e0265037bcf247e820f027) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-3ga000", 0, BAD_DUMP SHA1(4e162885b0b3265a56e0265037bcf247e820f027) ) \
 
 #define JOJO_990128_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo(__990128)-simm1.0", 0x00000, 0x200000, CRC(9516948b) SHA1(4d7e6c1eb7d1bebff2a5069bcd186070a9105474) ) \
@@ -2803,7 +2803,7 @@
 	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "jojo-simm5.1", 0x00000, 0x200000, CRC(734fd162) SHA1(16cdfac74d18a6c2216afb1ce6afbd7f15297c32) ) \
 
 #define JOJO_990108_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk-2", 0, SHA1(0f5c09171409213e191a607ee89ca3a91fe9c96a) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk-2", 0, BAD_DUMP SHA1(0f5c09171409213e191a607ee89ca3a91fe9c96a) ) \
 
 #define JOJO_981202_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo(__981202)-simm1.0", 0x00000, 0x200000, CRC(e06ba886) SHA1(4defd5e8e1e6d0c439fed8a6454e89a59e24ea4c) ) \
@@ -2834,7 +2834,7 @@
 	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "jojo-simm5.1",  0x00000, 0x200000, CRC(734fd162) SHA1(16cdfac74d18a6c2216afb1ce6afbd7f15297c32) ) \
 
 #define JOJO_981202_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk000", 0, SHA1(09869f6d8c032b527e02d815749dc8fab1289e86) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk000", 0, BAD_DUMP SHA1(09869f6d8c032b527e02d815749dc8fab1289e86) ) \
 
 #define SFIII3_990608_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3(__990608)-simm1.0", 0x00000, 0x200000, CRC(11dfd3cd) SHA1(dba1f77c46e80317e3279298411154dfb6db2309) ) \
@@ -2879,7 +2879,7 @@
 	ROM_REGION( 0x200000, "simm6.7", 0 ) ROM_LOAD( "sfiii3-simm6.7", 0x00000, 0x200000, CRC(cc5f4187) SHA1(248ddace21ed4736a56e92f77cc6ad219d7fef0b) ) \
 
 #define SFIII3_990608_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-2", 0, SHA1(41b0e246db91cbfc3f8f0f62d981734feb4b4ab5) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-2", 0, BAD_DUMP SHA1(41b0e246db91cbfc3f8f0f62d981734feb4b4ab5) ) \
 
 #define SFIII3_990512_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3(__990512)-simm1.0", 0x00000, 0x200000, CRC(66e66235) SHA1(0a98038721d176458d4f85dbd76c5edb93a65322) ) \
@@ -2924,7 +2924,7 @@
 	ROM_REGION( 0x200000, "simm6.7", 0 ) ROM_LOAD( "sfiii3-simm6.7",  0x00000, 0x200000, CRC(cc5f4187) SHA1(248ddace21ed4736a56e92f77cc6ad219d7fef0b) ) \
 
 #define SFIII3_990512_CDROM \
-	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-1", 0, SHA1(2f4a9006a31903114f9f9dc09465ae253e565c51) ) \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-1", 0, BAD_DUMP SHA1(2f4a9006a31903114f9f9dc09465ae253e565c51) ) \
 
 #define JOJOBA_990927_FLASH \
 	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba(__990927)-simm1.0", 0x00000, 0x200000, CRC(adcd8377) SHA1(f1aacbe061e3bcade5cca34435c3f86aec5f1499) ) \
diff -Nru src-old/mame/drivers/crbaloon.c src/mame/drivers/crbaloon.c
--- src-old/mame/drivers/crbaloon.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/crbaloon.c	2012-05-03 11:00:08.000000000 +0200
@@ -73,7 +73,7 @@
 
 	/* enable coin & start input? Wild guess!!! */
 	if (m_pc3092_data[1] & 0x02)
-		ret = input_port_read(machine(), "PC3092");
+		ret = ioport("PC3092")->read();
 	else
 		ret = 0x00;
 
@@ -143,7 +143,7 @@
 
 	if (LOG_PC3259) logerror("%04X:  read PC3259 #%d = 0x%02x\n", cpu_get_pc(&space.device()), reg, ret);
 
-	return ret | (input_port_read(machine(), "DSW1") & 0xf0);
+	return ret | (ioport("DSW1")->read() & 0xf0);
 }
 
 
diff -Nru src-old/mame/drivers/crgolf.c src/mame/drivers/crgolf.c
--- src-old/mame/drivers/crgolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/crgolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -90,13 +90,13 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "P1", "P2", "DSW", "UNUSED0", "UNUSED1" };
 
-	return input_port_read(machine(), portnames[m_port_select]);
+	return ioport(portnames[m_port_select])->read();
 }
 
 
 READ8_MEMBER(crgolf_state::analog_input_r)
 {
-	return ((input_port_read(machine(), "STICK0") >> 4) | (input_port_read(machine(), "STICK1") & 0xf0)) ^ 0x88;
+	return ((ioport("STICK1")->read() & 0xf0)) ^ 0x88;
 }
 
 
diff -Nru src-old/mame/drivers/crimfght.c src/mame/drivers/crimfght.c
--- src-old/mame/drivers/crimfght.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/crimfght.c	2012-05-07 08:57:50.000000000 +0200
@@ -24,6 +24,17 @@
 static KONAMI_SETLINES_CALLBACK( crimfght_banking );
 
 
+static TIMER_DEVICE_CALLBACK( crimfght_scanline )
+{
+	crimfght_state *state = timer.machine().driver_data<crimfght_state>();
+	int scanline = param;
+
+	if(scanline == 240 && k051960_is_irq_enabled(state->m_k051960)) // vblank irq
+		cputag_set_input_line(timer.machine(), "maincpu", KONAMI_IRQ_LINE, HOLD_LINE);
+	else if(((scanline % 32) == 0) && (k051960_is_nmi_enabled(state->m_k051960))) // timer irq
+		cputag_set_input_line(timer.machine(), "maincpu", INPUT_LINE_NMI, PULSE_LINE);
+}
+
 WRITE8_MEMBER(crimfght_state::crimfght_coin_w)
 {
 	coin_counter_w(machine(), 0, data & 1);
@@ -33,7 +44,7 @@
 WRITE8_MEMBER(crimfght_state::crimfght_sh_irqtrigger_w)
 {
 	soundlatch_byte_w(space, offset, data);
-	device_set_input_line_and_vector(m_audiocpu, 0, HOLD_LINE, 0xff);
+	device_set_input_line(m_audiocpu, 0, HOLD_LINE);
 }
 
 static WRITE8_DEVICE_HANDLER( crimfght_snd_bankswitch_w )
@@ -78,8 +89,8 @@
 /********************************************/
 
 static ADDRESS_MAP_START( crimfght_map, AS_PROGRAM, 8, crimfght_state )
-	AM_RANGE(0x0000, 0x03ff) AM_RAMBANK("bank1")					/* banked RAM */
-	AM_RANGE(0x0400, 0x1fff) AM_RAM												/* RAM */
+	AM_RANGE(0x0000, 0x03ff) AM_RAMBANK("bank1")						/* banked RAM */
+	AM_RANGE(0x0400, 0x1fff) AM_RAM								/* RAM */
 	AM_RANGE(0x3f80, 0x3f80) AM_READ_PORT("SYSTEM")
 	AM_RANGE(0x3f81, 0x3f81) AM_READ_PORT("P1")
 	AM_RANGE(0x3f82, 0x3f82) AM_READ_PORT("P2")
@@ -89,17 +100,17 @@
 	AM_RANGE(0x3f86, 0x3f86) AM_READ_PORT("P4")
 	AM_RANGE(0x3f87, 0x3f87) AM_READ_PORT("DSW1")
 	AM_RANGE(0x3f88, 0x3f88) AM_READ(watchdog_reset_r) AM_WRITE(crimfght_coin_w)	/* watchdog reset */
-	AM_RANGE(0x3f8c, 0x3f8c) AM_WRITE(crimfght_sh_irqtrigger_w)	/* cause interrupt on audio CPU? */
+	AM_RANGE(0x3f8c, 0x3f8c) AM_WRITE(crimfght_sh_irqtrigger_w)				/* cause interrupt on audio CPU? */
 	AM_RANGE(0x2000, 0x5fff) AM_READWRITE(k052109_051960_r, k052109_051960_w)	/* video RAM + sprite RAM */
 	AM_RANGE(0x6000, 0x7fff) AM_ROMBANK("bank2")						/* banked ROM */
-	AM_RANGE(0x8000, 0xffff) AM_ROM												/* ROM */
+	AM_RANGE(0x8000, 0xffff) AM_ROM								/* ROM */
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( crimfght_sound_map, AS_PROGRAM, 8, crimfght_state )
-	AM_RANGE(0x0000, 0x7fff) AM_ROM												/* ROM 821l01.h4 */
-	AM_RANGE(0x8000, 0x87ff) AM_RAM												/* RAM */
-	AM_RANGE(0xa000, 0xa001) AM_DEVREADWRITE_LEGACY("ymsnd", ym2151_r, ym2151_w)			/* YM2151 */
-	AM_RANGE(0xc000, 0xc000) AM_READ(soundlatch_byte_r)								/* soundlatch_byte_r */
+	AM_RANGE(0x0000, 0x7fff) AM_ROM									/* ROM 821l01.h4 */
+	AM_RANGE(0x8000, 0x87ff) AM_RAM									/* RAM */
+	AM_RANGE(0xa000, 0xa001) AM_DEVREADWRITE_LEGACY("ymsnd", ym2151_r, ym2151_w)		/* YM2151 */
+	AM_RANGE(0xc000, 0xc000) AM_READ(soundlatch_byte_r)						/* soundlatch_byte_r */
 	AM_RANGE(0xe000, 0xe00d) AM_DEVREADWRITE_LEGACY("k007232", k007232_r, k007232_w)	/* 007232 registers */
 ADDRESS_MAP_END
 
@@ -275,13 +286,15 @@
 static MACHINE_CONFIG_START( crimfght, crimfght_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", KONAMI, 3000000)		/* ? */
+	MCFG_CPU_ADD("maincpu", KONAMI,XTAL_24MHz/8)		/* 052001 (verified on pcb) */
 	MCFG_CPU_PROGRAM_MAP(crimfght_map)
-	MCFG_CPU_VBLANK_INT("screen", irq0_line_hold)
+	MCFG_TIMER_ADD_SCANLINE("scantimer", crimfght_scanline, "screen", 0, 1)
 
-	MCFG_CPU_ADD("audiocpu", Z80, 3579545)	/* verified with PCB */
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_3_579545MHz) 	/* verified on pcb */
 	MCFG_CPU_PROGRAM_MAP(crimfght_sound_map)
 
+	MCFG_QUANTUM_TIME(attotime::from_hz(600))
+
 	MCFG_MACHINE_START(crimfght)
 	MCFG_MACHINE_RESET(crimfght)
 
@@ -289,7 +302,7 @@
 	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_REFRESH_RATE(54)	/* adjusted - compared with PCB speed */
+	MCFG_SCREEN_REFRESH_RATE(59.17)				/* verified on pcb */
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(13*8, (64-13)*8-1, 2*8, 30*8-1 )
@@ -305,12 +318,12 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("ymsnd", YM2151, 3579545)	/* verified with PCB */
+	MCFG_SOUND_ADD("ymsnd", YM2151, XTAL_3_579545MHz)	/* verified on pcb */
 	MCFG_SOUND_CONFIG(ym2151_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 
-	MCFG_SOUND_ADD("k007232", K007232, 3579545)
+	MCFG_SOUND_ADD("k007232", K007232, XTAL_3_579545MHz)	/* verified on pcb */
 	MCFG_SOUND_CONFIG(k007232_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.20)
 	MCFG_SOUND_ROUTE(0, "rspeaker", 0.20)
diff -Nru src-old/mame/drivers/crshrace.c src/mame/drivers/crshrace.c
--- src-old/mame/drivers/crshrace.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/crshrace.c	2012-05-03 11:00:08.000000000 +0200
@@ -271,7 +271,7 @@
 	PORT_DIPNAME( 0x0100, 0x0100, "Coin Slot" ) PORT_DIPLOCATION("SW1:1")
 	PORT_DIPSETTING(      0x0100, "Same" )
 	PORT_DIPSETTING(      0x0000, "Individual" )
-	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:2,3,4") PORT_CONDITION("DSW0", 0x0100, PORTCOND_EQUALS, 0x0100)
+	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:2,3,4") PORT_CONDITION("DSW0", 0x0100, EQUALS, 0x0100)
 	PORT_DIPSETTING(      0x0a00, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0c00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0e00, DEF_STR( 1C_1C ) )
@@ -280,7 +280,7 @@
 	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x7000, 0x7000, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:5,6,7") PORT_CONDITION("DSW0", 0x0100, PORTCOND_EQUALS, 0x0100)
+	PORT_DIPNAME( 0x7000, 0x7000, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:5,6,7") PORT_CONDITION("DSW0", 0x0100, EQUALS, 0x0100)
 	PORT_DIPSETTING(      0x5000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x6000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x7000, DEF_STR( 1C_1C ) )
@@ -289,7 +289,7 @@
 	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:2,3,4") PORT_CONDITION("DSW0", 0x0100, PORTCOND_NOTEQUALS, 0x0100)
+	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:2,3,4") PORT_CONDITION("DSW0", 0x0100, NOTEQUALS, 0x0100)
 	PORT_DIPSETTING(      0x0a00, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0c00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0e00, DEF_STR( 1C_1C ) )
@@ -298,7 +298,7 @@
 	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPUNUSED_DIPLOC( 0x7000, 0x7000, "SW1:5,6,7") PORT_CONDITION("DSW0", 0x0100, PORTCOND_NOTEQUALS, 0x0100)
+	PORT_DIPUNUSED_DIPLOC( 0x7000, 0x7000, "SW1:5,6,7") PORT_CONDITION("DSW0", 0x0100, NOTEQUALS, 0x0100)
 	PORT_DIPNAME( 0x8000, 0x8000, "2 to Start, 1 to Cont." ) PORT_DIPLOCATION("SW1:8")	// Other desc. was too long !
 	PORT_DIPSETTING(      0x8000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/crystal.c src/mame/drivers/crystal.c
--- src-old/mame/drivers/crystal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/crystal.c	2012-05-03 11:00:08.000000000 +0200
@@ -161,7 +161,7 @@
 	UINT8     m_OldPort4;
 
 	device_t *m_maincpu;
-	device_t *m_ds1302;
+	ds1302_device *m_ds1302;
 	device_t *m_vr0video;
 	DECLARE_READ32_MEMBER(FlipCount_r);
 	DECLARE_WRITE32_MEMBER(FlipCount_w);
@@ -233,18 +233,18 @@
 {
 
 	if (offset == 0)
-		return input_port_read(machine(), "P1_P2");
+		return ioport("P1_P2")->read();
 	else if (offset == 1)
-		return input_port_read(machine(), "P3_P4");
+		return ioport("P3_P4")->read();
 	else if( offset == 2)
 	{
-		UINT8 Port4 = input_port_read(machine(), "SYSTEM");
+		UINT8 Port4 = ioport("SYSTEM")->read();
 		if (!(Port4 & 0x10) && ((m_OldPort4 ^ Port4) & 0x10))	//coin buttons trigger IRQs
 			IntReq(machine(), 12);
 		if (!(Port4 & 0x20) && ((m_OldPort4 ^ Port4) & 0x20))
 			IntReq(machine(), 19);
 		m_OldPort4 = Port4;
-		return /*dips*/input_port_read(machine(), "DSW") | (Port4 << 16);
+		return /*dips*/ioport("DSW")->read() | (Port4 << 16);
 	}
 	return 0;
 }
@@ -400,13 +400,11 @@
 	UINT32 CLK = data & 0x02000000;
 	UINT32 DAT = data & 0x10000000;
 
-	if (!RST)
-		m_ds1302->reset();
+	m_ds1302->ce_w(RST ? 1 : 0);
+	m_ds1302->io_w(DAT ? 1 : 0);
+	m_ds1302->sclk_w(CLK ? 1 : 0);
 
-	ds1302_dat_w(m_ds1302, 0, DAT ? 1 : 0);
-	ds1302_clk_w(m_ds1302, 0, CLK ? 1 : 0);
-
-	if (ds1302_read(m_ds1302, 0))
+	if (m_ds1302->io_r())
 		space.write_dword(0x01802008, space.read_dword(0x01802008) | 0x10000000);
 	else
 		space.write_dword(0x01802008, space.read_dword(0x01802008) & (~0x10000000));
@@ -567,7 +565,7 @@
 	crystal_state *state = machine.driver_data<crystal_state>();
 
 	if (state->m_Bank <= 2)
-		state->membank("bank1")->set_base(machine.root_device().memregion("user1")->base() + state->m_Bank * 0x1000000);
+		state->membank("bank1")->set_base(state->memregion("user1")->base() + state->m_Bank * 0x1000000);
 	else
 		state->membank("bank1")->set_base(state->memregion("user2")->base());
 }
@@ -578,7 +576,7 @@
 	int i;
 
 	state->m_maincpu = machine.device("maincpu");
-	state->m_ds1302 = machine.device("rtc");
+	state->m_ds1302 = machine.device<ds1302_device>("rtc");
 	state->m_vr0video = machine.device("vr0");
 
 	device_set_irq_callback(machine.device("maincpu"), icallback);
@@ -859,7 +857,7 @@
 	MCFG_PALETTE_INIT(RRRRR_GGGGGG_BBBBB)
 	MCFG_PALETTE_LENGTH(65536)
 
-	MCFG_DS1302_ADD("rtc")
+	MCFG_DS1302_ADD("rtc", XTAL_32_768kHz)
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
diff -Nru src-old/mame/drivers/cshooter.c src/mame/drivers/cshooter.c
--- src-old/mame/drivers/cshooter.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cshooter.c	2012-05-03 11:00:08.000000000 +0200
@@ -226,7 +226,7 @@
 	/* Even reads must return 0xff - Odd reads must return the contents of input port 5.
        Code at 0x5061 is executed once during P.O.S.T. where there is one read.
        Code at 0x50b4 is then executed each frame (not sure) where there are 2 reads. */
-	return ( (m_counter++ & 1) ? 0xff : input_port_read(machine(), "COIN") );
+	return ( (m_counter++ & 1) ? 0xff : ioport("COIN")->read() );
 }
 
 WRITE8_MEMBER(cshooter_state::cshooter_c500_w)
diff -Nru src-old/mame/drivers/csplayh5.c src/mame/drivers/csplayh5.c
--- src-old/mame/drivers/csplayh5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/csplayh5.c	2012-05-05 12:08:57.000000000 +0200
@@ -9,6 +9,7 @@
     - fix h8 CPU core bugs, it trips various unhandled opcodes
     - Implement DVD routing and YUV decoding;
     - game timings seem busted, could be due of missing DVD hook-up
+    - csplayh8: inputs doesn't work at all, slower than the others too
 
 ***************************************************************************/
 
@@ -92,11 +93,11 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(), "KEY0");
-		case 0x02: return input_port_read(machine(), "KEY1");
-		case 0x04: return input_port_read(machine(), "KEY2");
-		case 0x08: return input_port_read(machine(), "KEY3");
-		case 0x10: return input_port_read(machine(), "KEY4");
+		case 0x01: return ioport("KEY0")->read();
+		case 0x02: return ioport("KEY1")->read();
+		case 0x04: return ioport("KEY2")->read();
+		case 0x08: return ioport("KEY3")->read();
+		case 0x10: return ioport("KEY4")->read();
 	}
 
 	return 0xffff;
@@ -668,7 +669,7 @@
 
 ***************************************************************************/
 
-void general_init(running_machine &machine, int patchaddress)
+void general_init(running_machine &machine, int patchaddress, int patchvalue)
 {
 	UINT16 *MAINROM = (UINT16 *)machine.root_device().memregion("maincpu")->base();
 	UINT8 *SNDROM = machine.root_device().memregion("audiocpu")->base();
@@ -677,21 +678,46 @@
 	csplayh5_soundbank_w(machine, 0);
 
 	/* patch DVD comms check */
-	MAINROM[patchaddress] = 0x6018;
+	MAINROM[patchaddress] = patchvalue;
 
 	/* patch sound program */
 	SNDROM[0x0213] = 0x00;			// DI -> NOP
 
 }
 
-static DRIVER_INIT( junai )    { general_init(machine, 0x679c/2); }
-static DRIVER_INIT( mjmania )  { general_init(machine, 0x6b96/2); }
-static DRIVER_INIT( junai2 )   { general_init(machine, 0x6588/2); }
-static DRIVER_INIT( csplayh5 ) { general_init(machine, 0x4cb4/2); }
-static DRIVER_INIT( bikiniko ) { general_init(machine, 0x585c/2); }
-static DRIVER_INIT( thenanpa ) { general_init(machine, 0x69ec/2); }
-static DRIVER_INIT( csplayh7 ) { general_init(machine, 0x7a20/2); }
-static DRIVER_INIT( fuudol )   { general_init(machine, 0x9166/2); }
+static DRIVER_INIT( csplayh1 ) { general_init(machine, 0x6880/2,0x6020); }
+
+static DRIVER_INIT( junai )    { general_init(machine, 0x679c/2,0x6018); }
+static DRIVER_INIT( mjmania )  { general_init(machine, 0x6b96/2,0x6018); }
+static DRIVER_INIT( junai2 )   { general_init(machine, 0x6588/2,0x6018); }
+static DRIVER_INIT( csplayh5 ) { general_init(machine, 0x4cb4/2,0x6018); }
+static DRIVER_INIT( bikiniko ) { general_init(machine, 0x585c/2,0x6018); }
+static DRIVER_INIT( thenanpa ) { general_init(machine, 0x69ec/2,0x6018); }
+static DRIVER_INIT( csplayh7 ) { general_init(machine, 0x7a20/2,0x6018); }
+static DRIVER_INIT( fuudol )   { general_init(machine, 0x9166/2,0x6018); }
+
+/* TODO: correct rom labels*/
+ROM_START( csplayh1 )
+	ROM_REGION( 0x40000, "maincpu", 0 ) // tmp68301 prg
+	ROM_LOAD16_BYTE( "3.bin", 0x000000, 0x020000, CRC(86ac0289) SHA1(7ae3047fc7ea22705cc5b04d0ec6c792c429e8ee) )
+	ROM_LOAD16_BYTE( "2.bin", 0x000001, 0x020000, CRC(1f056e64) SHA1(7c5fb318abcd87313ef739dec191af9bcf284f24) )
+
+	ROM_REGION( 0x20000, "subcpu", 0 ) // h8, dvd player
+	ROM_LOAD16_WORD_SWAP( "u2",   0x00000, 0x20000, NO_DUMP )
+
+	ROM_REGION( 0x20000, "audiocpu", 0 ) // z80
+	ROM_LOAD( "1.bin", 0x000000, 0x020000, CRC(8296d67f) SHA1(20eb944a2bd27980e1aaf60ca544059e84129760) )
+
+	ROM_REGION( 0x400000, "blit_gfx", ROMREGION_ERASEFF ) // blitter based gfxs
+    ROM_LOAD16_BYTE( "4.bin", 0x000000, 0x080000, CRC(2e63ee15) SHA1(78fefbc277234458212cded997d393bd8b82cf76) )
+    ROM_LOAD16_BYTE( "8.bin", 0x000001, 0x080000, CRC(a8567f1b) SHA1(2a854ef8b1988ad097bbcbeddc4b275ad738e1e1) )
+
+	DISK_REGION( "dvd" )
+	DISK_IMAGE( "csplayh8", 0, SHA1(d6514882c2626e62c5079df9ac68ecb70fc33209) )
+
+	ROM_REGION( 0x1000, "gal", ROMREGION_ERASE00 )
+	ROM_LOAD( "gal16v8b.ic8", 0x000000, 0x0008c1, NO_DUMP )
+ROM_END
 
 ROM_START( junai )
 	ROM_REGION( 0x40000, "maincpu", 0 ) // tmp68301 prg
@@ -865,6 +891,9 @@
 	ROM_LOAD( "gal16v8b.ic8", 0x000000, 0x0008c1, CRC(30719630) SHA1(a8c7b6d0304c38691775c5af6c32fbeeefd9f9fa) )
 ROM_END
 
+// 1995
+GAME( 1995, csplayh1,   0,   csplayh5,  csplayh5,  csplayh1,                ROT0, "Sphinx/AV Japan/Astro System Japan",   "Super CD Dai8dan Mahjong Hanafuda Cosplay Tengoku (Japan)", GAME_NOT_WORKING )
+
 // 1998
 // 01 : Mahjong Gal-pri - World Gal-con Grandprix : Nichibutsu/Just&Just
 // 02 : Sengoku Mahjong Kurenai Otome-tai : Nichibutsu/Just&Just
@@ -876,7 +905,7 @@
 
 // 1999
 /* 07 */ GAME( 1999, mjmania,   0,   csplayh5,  csplayh5,  mjmania,     	ROT0, "Sphinx/Just&Just", "Mahjong Mania - Kairakukan e Youkoso (Japan)", GAME_NOT_WORKING )
-// 08 : Renai Mahjong Idol Gakuen : Nichibutsu/eic
+///* 08 */ GAME( 1995, renaimj,   0,   csplayh5,  csplayh5,  renaimj,         ROT0, "Nichibutsu/eic",   "Renai Mahjong Idol Gakuen (Japan)", GAME_NOT_WORKING )
 /* 09 */ GAME( 1999, bikiniko,  0,   csplayh5,  csplayh5,  bikiniko,		ROT0, "Nichibutsu/eic",   "BiKiNikko - Okinawa de Ippai Shichaimashita (Japan)", GAME_NOT_WORKING )
 // 10 : Mahjong Hanafuda Cosplay Tengoku 6 - Junai hen : Nichibutsu/eic
 /* 11 */ GAME( 1999, thenanpa,  0,   csplayh5,  csplayh5,  thenanpa,        ROT0, "Nichibutsu/Love Factory/eic", "The Nanpa (Japan)", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/cubeqst.c src/mame/drivers/cubeqst.c
--- src-old/mame/drivers/cubeqst.c	2012-04-05 09:44:51.000000000 +0200
+++ src/mame/drivers/cubeqst.c	2012-05-03 11:00:08.000000000 +0200
@@ -329,7 +329,7 @@
 
 READ16_MEMBER(cubeqst_state::io_r)
 {
-	UINT16 port_data = input_port_read(machine(), "IO");
+	UINT16 port_data = ioport("IO")->read();
 
 	/*
          Certain bits depend on Q7 of the IO latch:
@@ -350,7 +350,7 @@
 /* Trackball ('CHOP') */
 READ16_MEMBER(cubeqst_state::chop_r)
 {
-	return (input_port_read(machine(), "TRACK_X") << 8) | input_port_read(machine(), "TRACK_Y");
+	return (ioport("TRACK_X")->read() << 8) | ioport("TRACK_Y")->read();
 }
 
 
@@ -535,8 +535,8 @@
 	MCFG_LASERDISC_SIMUTREK_ADD("laserdisc")
 	MCFG_LASERDISC_OVERLAY_STATIC(CUBEQST_HBLANK, CUBEQST_VCOUNT, cubeqst)
 	MCFG_LASERDISC_OVERLAY_CLIP(0, 320-1, 0, 256-8)
-	MCFG_LASERDISC_OVERLAY_POSITION(0.002, -0.018)
-	MCFG_LASERDISC_OVERLAY_SCALE(1.0, 1.030)
+	MCFG_LASERDISC_OVERLAY_POSITION(0.002f, -0.018f)
+	MCFG_LASERDISC_OVERLAY_SCALE(1.0f, 1.030f)
 
 	MCFG_LASERDISC_SCREEN_ADD_NTSC("screen", "laserdisc")
 
diff -Nru src-old/mame/drivers/cvs.c src/mame/drivers/cvs.c
--- src-old/mame/drivers/cvs.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cvs.c	2012-05-03 11:00:08.000000000 +0200
@@ -261,12 +261,12 @@
 	/* the lower 4 (or 3?) bits select the port to read */
 	switch (offset & 0x0f)	/* might be 0x07 */
 	{
-	case 0x00:  ret = input_port_read(machine(), "IN0"); break;
-	case 0x02:  ret = input_port_read(machine(), "IN1"); break;
-	case 0x03:  ret = input_port_read(machine(), "IN2"); break;
-	case 0x04:  ret = input_port_read(machine(), "IN3"); break;
-	case 0x06:  ret = input_port_read(machine(), "DSW3"); break;
-	case 0x07:  ret = input_port_read(machine(), "DSW2"); break;
+	case 0x00:  ret = ioport("IN0")->read(); break;
+	case 0x02:  ret = ioport("IN1")->read(); break;
+	case 0x03:  ret = ioport("IN2")->read(); break;
+	case 0x04:  ret = ioport("IN3")->read(); break;
+	case 0x06:  ret = ioport("DSW3")->read(); break;
+	case 0x07:  ret = ioport("DSW2")->read(); break;
 	default:    logerror("%04x : CVS: Reading unmapped input port 0x%02x\n", cpu_get_pc(&space.device()), offset & 0x0f); break;
 	}
 
@@ -425,8 +425,7 @@
 static int speech_rom_read_bit( device_t *device )
 {
 	cvs_state *state = device->machine().driver_data<cvs_state>();
-	running_machine &machine = device->machine();
-	UINT8 *ROM = machine.root_device().memregion("speechdata")->base();
+	UINT8 *ROM = state->memregion("speechdata")->base();
 	int bit;
 
 	/* before reading the bit, clamp the address to the region length */
@@ -612,7 +611,7 @@
 	PORT_DIPUNUSED( 0x20, IP_ACTIVE_HIGH )                  /* can't tell if it's ACTIVE_HIGH or ACTIVE_LOW */
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( cvs_registration )
diff -Nru src-old/mame/drivers/cyberbal.c src/mame/drivers/cyberbal.c
--- src-old/mame/drivers/cyberbal.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/cyberbal.c	2012-05-05 16:28:21.000000000 +0200
@@ -103,7 +103,7 @@
 
 READ16_MEMBER(cyberbal_state::special_port0_r)
 {
-	int temp = input_port_read(machine(), "IN0");
+	int temp = ioport("IN0")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0080;
 	return temp;
 }
@@ -111,7 +111,7 @@
 
 READ16_MEMBER(cyberbal_state::special_port2_r)
 {
-	int temp = input_port_read(machine(), "IN2");
+	int temp = ioport("IN2")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x2000;
 	return temp;
 }
@@ -306,7 +306,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("lscreen")
 
 	PORT_START("IN2")		/* fake port for screen switching */
 	PORT_BIT( 0xffff, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -346,7 +346,7 @@
 	PORT_START("IN2")		/* fc4000 */
 	PORT_BIT( 0x1fff, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x4000, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x4000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x8000, IP_ACTIVE_LOW )
 
 	PORT_INCLUDE( atarijsa_ii )		/* audio board port */
diff -Nru src-old/mame/drivers/cybertnk.c src/mame/drivers/cybertnk.c
--- src-old/mame/drivers/cybertnk.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/cybertnk.c	2012-05-03 11:00:08.000000000 +0200
@@ -531,7 +531,7 @@
 	switch( offset )
 	{
 		case 2/2:
-			return input_port_read(machine(), "DSW1");
+			return ioport("DSW1")->read();
 
 		// 0x00110007 is controller device select
 		// 0x001100D5 is controller data
@@ -540,15 +540,15 @@
 			switch( (m_io_ram[6/2]) & 0xff )
 			{
 				case 0:
-					m_io_ram[0xd4/2] = input_port_read(machine(), "TRAVERSE");
+					m_io_ram[0xd4/2] = ioport("TRAVERSE")->read();
 					break;
 
 				case 0x20:
-					m_io_ram[0xd4/2] = input_port_read(machine(), "ELEVATE");
+					m_io_ram[0xd4/2] = ioport("ELEVATE")->read();
 					break;
 
 				case 0x40:
-					m_io_ram[0xd4/2] = input_port_read(machine(), "ACCEL");
+					m_io_ram[0xd4/2] = ioport("ACCEL")->read();
 					break;
 
 				case 0x42:
@@ -560,7 +560,7 @@
 					break;
 
 				case 0x60:
-					m_io_ram[0xd4/2] = input_port_read(machine(), "HANDLE");
+					m_io_ram[0xd4/2] = ioport("HANDLE")->read();
 					break;
 
 				//default:
@@ -569,13 +569,13 @@
 			return 0;
 
 		case 6/2:
-			return input_port_read(machine(), "IN0"); // high half
+			return ioport("IN0")->read(); // high half
 
 		case 8/2:
-			return input_port_read(machine(), "IN0"); // low half
+			return ioport("IN0")->read(); // low half
 
 		case 0xa/2:
-			return input_port_read(machine(), "DSW2");
+			return ioport("DSW2")->read();
 
 		case 0xd4/2:
 			return m_io_ram[offset]; // controller data
diff -Nru src-old/mame/drivers/dai3wksi.c src/mame/drivers/dai3wksi.c
--- src-old/mame/drivers/dai3wksi.c	2012-04-12 01:29:02.000000000 +0200
+++ src/mame/drivers/dai3wksi.c	2012-05-03 11:00:08.000000000 +0200
@@ -150,7 +150,7 @@
 		}
 		else
 		{
-			if (input_port_read(screen.machine(), "IN2") & 0x03)
+			if (state->ioport("IN2")->read() & 0x03)
 				color = vr_prom2[value];
 			else
 				color = vr_prom1[value];
diff -Nru src-old/mame/drivers/dambustr.c src/mame/drivers/dambustr.c
--- src-old/mame/drivers/dambustr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dambustr.c	2012-05-03 11:00:08.000000000 +0200
@@ -136,10 +136,10 @@
 	PORT_DIPSETTING(    0x00, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW:!2")
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_1C ) )   PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )   PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, "A 1/1  B 1/2" )     PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_DIPSETTING(    0x00, "A 1/2  B 1/6" )     PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x40)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_1C ) )   PORT_CONDITION("IN1", 0x40, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )   PORT_CONDITION("IN1", 0x40, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, "A 1/1  B 1/2" )     PORT_CONDITION("IN1", 0x40, EQUALS, 0x40)
+	PORT_DIPSETTING(    0x00, "A 1/2  B 1/6" )     PORT_CONDITION("IN1", 0x40, EQUALS, 0x40)
 
 	PORT_START("DSW")
 	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Lives ) ) PORT_DIPLOCATION("SW:!3,!4")
@@ -162,10 +162,10 @@
 
 	PORT_MODIFY("IN1")
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW:!2")
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_1C ) )   PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )   PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, "A 1/1  B 1/6" )     PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_DIPSETTING(    0x00, "A 1/2  B 1/12" )    PORT_CONDITION("IN1", 0x40, PORTCOND_EQUALS, 0x40)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_1C ) )   PORT_CONDITION("IN1", 0x40, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )   PORT_CONDITION("IN1", 0x40, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, "A 1/1  B 1/6" )     PORT_CONDITION("IN1", 0x40, EQUALS, 0x40)
+	PORT_DIPSETTING(    0x00, "A 1/2  B 1/12" )    PORT_CONDITION("IN1", 0x40, EQUALS, 0x40)
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/darius.c src/mame/drivers/darius.c
--- src-old/mame/drivers/darius.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/darius.c	2012-05-03 11:00:08.000000000 +0200
@@ -180,19 +180,19 @@
 			return (tc0140syt_comm_r(m_tc0140syt, 0) & 0xff);	/* sound interface read */
 
 		case 0x04:
-			return input_port_read(machine(), "P1");
+			return ioport("P1")->read();
 
 		case 0x05:
-			return input_port_read(machine(), "P2");
+			return ioport("P2")->read();
 
 		case 0x06:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 
 		case 0x07:
 			return m_coin_word;	/* bits 3&4 coin lockouts, must return zero */
 
 		case 0x08:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 	}
 
 logerror("CPU #0 PC %06x: warning - read unmapped ioc offset %06x\n",cpu_get_pc(&space.device()),offset);
@@ -842,7 +842,7 @@
 {
 	darius_state *state = machine.driver_data<darius_state>();
 
-	state->membank("bank1")->configure_entries(0, 4, machine.root_device().memregion("audiocpu")->base() + 0x10000, 0x8000);
+	state->membank("bank1")->configure_entries(0, 4, state->memregion("audiocpu")->base() + 0x10000, 0x8000);
 	state->membank("bank1")->configure_entry(4, state->memregion("audiocpu")->base());
 	state->membank("bank1")->set_entry(4);
 
diff -Nru src-old/mame/drivers/darkhors.c src/mame/drivers/darkhors.c
--- src-old/mame/drivers/darkhors.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/darkhors.c	2012-05-03 11:00:08.000000000 +0200
@@ -313,8 +313,8 @@
 	int bit_p2 = mask_to_bit((m_input_sel & 0xff000000) >> 24);
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3", "IN4", "IN5", "IN6", "IN7" };
 
-	return	(input_port_read(machine(), portnames[bit_p1]) & 0x00ffffff) |
-			(input_port_read(machine(), portnames[bit_p2]) & 0xff000000) ;
+	return	(ioport(portnames[bit_p1])->read() & 0x00ffffff) |
+			(ioport(portnames[bit_p2])->read() & 0xff000000) ;
 }
 
 WRITE32_MEMBER(darkhors_state::darkhors_unk1_w)
diff -Nru src-old/mame/drivers/darkseal.c src/mame/drivers/darkseal.c
--- src-old/mame/drivers/darkseal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/darkseal.c	2012-05-03 11:00:08.000000000 +0200
@@ -45,13 +45,13 @@
 	switch (offset<<1)
 	{
 		case 0:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 2:
-			return input_port_read(machine(), "P1_P2");
+			return ioport("P1_P2")->read();
 
 		case 4:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 	}
 
 	return ~0;
@@ -120,7 +120,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/dassault.c src/mame/drivers/dassault.c
--- src-old/mame/drivers/dassault.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dassault.c	2012-05-03 11:00:08.000000000 +0200
@@ -134,19 +134,19 @@
 	switch (offset << 1)
 	{
 		case 0: /* Player 1 & Player 2 joysticks & fire buttons */
-			return input_port_read(machine(), "P1_P2");
+			return ioport("P1_P2")->read();
 
 		case 2: /* Player 3 & Player 4 joysticks & fire buttons */
-			return input_port_read(machine(), "P3_P4");
+			return ioport("P3_P4")->read();
 
 		case 4: /* Dip 1 (stored at 0x3f8035) */
-			return input_port_read(machine(), "DSW1");
+			return ioport("DSW1")->read();
 
 		case 6: /* Dip 2 (stored at 0x3f8034) */
-			return input_port_read(machine(), "DSW2");
+			return ioport("DSW2")->read();
 
 		case 8: /* VBL, Credits */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 	}
 
 	return 0xffff;
@@ -161,7 +161,7 @@
 
 READ16_MEMBER(dassault_state::dassault_sub_control_r)
 {
-	return input_port_read(machine(), "VBLANK1");
+	return ioport("VBLANK1")->read();
 }
 
 WRITE16_MEMBER(dassault_state::dassault_sound_w)
@@ -302,7 +302,7 @@
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_COIN4 )
 
 	PORT_START("VBLANK1") /* Cpu 1 vblank */
-	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( thndzone )
@@ -312,7 +312,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )			// Adds 4 credits/coins !
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -369,7 +369,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2,3")
@@ -427,7 +427,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2,3")
diff -Nru src-old/mame/drivers/dblewing.c src/mame/drivers/dblewing.c
--- src-old/mame/drivers/dblewing.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/dblewing.c	2012-05-03 11:00:08.000000000 +0200
@@ -145,11 +145,11 @@
 		case 0x330: return 0; // controls bonuses such as shoot type,bombs etc.
 		case 0x1d4: return m_70c_data;  //controls restart points
 
-		case 0x0ac: return (input_port_read(machine(), "DSW") & 0x40) << 4;//flip screen
+		case 0x0ac: return (ioport("DSW")->read() & 0x40) << 4;//flip screen
 		case 0x4b0: return m_608_data;//coinage
 		case 0x068:
 		{
-			switch (input_port_read(machine(), "DSW") & 0x0300) //I don't know how to relationate this...
+			switch (ioport("DSW")->read() & 0x0300) //I don't know how to relationate this...
 			{
 				case 0x0000: return 0x000;//0
 				case 0x0100: return 0x060;//3
@@ -159,12 +159,12 @@
 		}
 		case 0x094: return m_104_data;// p1 inputs select screen  OK
 		case 0x24c: return m_008_data;//read DSW (mirror for coinage/territory)
-		case 0x298: return input_port_read(machine(), "SYSTEM");//vblank
-		case 0x476: return input_port_read(machine(), "SYSTEM");//mirror for coins
-		case 0x506: return input_port_read(machine(), "DSW");
+		case 0x298: return ioport("SYSTEM")->read();//vblank
+		case 0x476: return ioport("SYSTEM")->read();//mirror for coins
+		case 0x506: return ioport("DSW")->read();
 		case 0x5d8: return m_406_data;
-		case 0x2b4: return input_port_read(machine(), "P1_P2");
-		case 0x1a8: return (input_port_read(machine(), "DSW") & 0x4000) >> 12;//allow continue
+		case 0x2b4: return ioport("P1_P2")->read();
+		case 0x1a8: return (ioport("DSW")->read() & 0x4000) >> 12;//allow continue
 		case 0x3ec: return m_70c_data; //score entry
 		case 0x246: return m_580_data; // these three controls "perfect bonus" I suppose...
 		case 0x52e: return m_580_data;
@@ -424,7 +424,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")
 	 /* 16bit - These values are for Dip Switch #1 */
diff -Nru src-old/mame/drivers/dcheese.c src/mame/drivers/dcheese.c
--- src-old/mame/drivers/dcheese.c	2012-04-10 07:38:11.000000000 +0200
+++ src/mame/drivers/dcheese.c	2012-05-03 11:00:08.000000000 +0200
@@ -129,7 +129,7 @@
 	/* bits $0080-$0010 are probably lamps */
 	if (ACCESSING_BITS_0_7)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 		machine().device<ticket_dispenser_device>("ticket")->write(space, 0, (data & 1) << 7);
 	}
 }
diff -Nru src-old/mame/drivers/dday.c src/mame/drivers/dday.c
--- src-old/mame/drivers/dday.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/dday.c	2012-05-03 11:00:08.000000000 +0200
@@ -86,14 +86,14 @@
                                                   /* accessed */
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW3:1,2")
-	PORT_DIPSETTING(    0x00, "2" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x80)
-	PORT_DIPSETTING(    0x01, "3" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x80)
-	PORT_DIPSETTING(    0x02, "4" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x80)
-	PORT_DIPSETTING(    0x03, "5" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x80)
-	PORT_DIPSETTING(    0x00, "5" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, "6" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, "7" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x03, "8" ) PORT_CONDITION("DSW0", 0x80, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "2" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x80)
+	PORT_DIPSETTING(    0x01, "3" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x80)
+	PORT_DIPSETTING(    0x02, "4" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x80)
+	PORT_DIPSETTING(    0x03, "5" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x80)
+	PORT_DIPSETTING(    0x00, "5" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, "6" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, "7" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, "8" ) PORT_CONDITION("DSW0", 0x80, EQUALS, 0x00)
 
 	PORT_DIPNAME( 0x0c, 0x00, "Extended Play At" )		PORT_DIPLOCATION("SW3:3,4")
 	PORT_DIPSETTING(    0x00, "10000" )
diff -Nru src-old/mame/drivers/ddealer.c src/mame/drivers/ddealer.c
--- src-old/mame/drivers/ddealer.c	2012-04-12 01:29:02.000000000 +0200
+++ src/mame/drivers/ddealer.c	2012-05-03 11:00:08.000000000 +0200
@@ -309,7 +309,7 @@
 
 	/*coin/credit simulation*/
 	/*$fe002 is used,might be for multiple coins for one credit settings.*/
-	state->m_coin_input = (~(input_port_read(timer.machine(), "IN0")));
+	state->m_coin_input = (~(timer.machine().root_device().ioport("IN0")->read()));
 
 	if (state->m_coin_input & 0x01)//coin 1
 	{
diff -Nru src-old/mame/drivers/ddenlovr.c src/mame/drivers/ddenlovr.c
--- src-old/mame/drivers/ddenlovr.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/ddenlovr.c	2012-05-03 11:00:08.000000000 +0200
@@ -430,7 +430,7 @@
 static int blit_draw( running_machine &machine, int src, int sx )
 {
 	dynax_state *state = machine.driver_data<dynax_state>();
-	UINT8 *src_data = machine.root_device().memregion("blitter")->base();
+	UINT8 *src_data = state->memregion("blitter")->base();
 	int src_len = state->memregion("blitter")->bytes();
 	int bit_addr = (src & 0xffffff) * state->m_ddenlovr_blit_rom_bits;	/* convert to bit address */
 	int pen_size, arg_size, cmd;
@@ -1597,9 +1597,9 @@
 	/* 0 and 1 are read from offset 1, 2 from offset 0... */
 	switch (m_input_sel)
 	{
-		case 0x00:	return input_port_read(machine(), "P1");
-		case 0x01:	return input_port_read(machine(), "P2");
-		case 0x02:	return input_port_read(machine(), "SYSTEM");
+		case 0x00:	return ioport("P1")->read();
+		case 0x01:	return ioport("P2")->read();
+		case 0x02:	return ioport("SYSTEM")->read();
 	}
 	return 0xff;
 }
@@ -1609,9 +1609,9 @@
 {
 	dynax_state *state = device->machine().driver_data<dynax_state>();
 
-	if (!BIT(state->m_dsw_sel, 0))	return input_port_read(device->machine(), "DSW1");
-	if (!BIT(state->m_dsw_sel, 1))	return input_port_read(device->machine(), "DSW2");
-	if (!BIT(state->m_dsw_sel, 2))	return input_port_read(device->machine(), "DSW3");
+	if (!BIT(state->m_dsw_sel, 0))	return state->ioport("DSW1")->read();
+	if (!BIT(state->m_dsw_sel, 1))	return state->ioport("DSW2")->read();
+	if (!BIT(state->m_dsw_sel, 2))	return state->ioport("DSW3")->read();
 	if (!BIT(state->m_dsw_sel, 3))	return 0xff;//device->machine().rand();
 	if (!BIT(state->m_dsw_sel, 4))	return 0xff;//device->machine().rand();
 	return 0xff;
@@ -1624,9 +1624,9 @@
 	/* 0 and 1 are read from offset 1, 2 from offset 0... */
 	switch (m_input_sel)
 	{
-		case 0x10:	return input_port_read(machine(), "P1");
-		case 0x11:	return input_port_read(machine(), "P2");
-		case 0x12:	return input_port_read(machine(), "SYSTEM");
+		case 0x10:	return ioport("P1")->read();
+		case 0x11:	return ioport("P2")->read();
+		case 0x12:	return ioport("SYSTEM")->read();
 	}
 	return 0xff;
 }
@@ -1728,9 +1728,9 @@
 READ16_MEMBER(dynax_state::ddenlovj_dsw_r)
 {
 	UINT16 dsw = 0;
-	if ((~*m_dsw_sel16) & 0x01)	dsw |= input_port_read(machine(), "DSW1");
-	if ((~*m_dsw_sel16) & 0x02)	dsw |= input_port_read(machine(), "DSW2");
-	if ((~*m_dsw_sel16) & 0x04)	dsw |= input_port_read(machine(), "DSW3");
+	if ((~*m_dsw_sel16) & 0x01)	dsw |= ioport("DSW1")->read();
+	if ((~*m_dsw_sel16) & 0x02)	dsw |= ioport("DSW2")->read();
+	if ((~*m_dsw_sel16) & 0x04)	dsw |= ioport("DSW3")->read();
 	return dsw;
 }
 
@@ -1888,9 +1888,9 @@
 READ16_MEMBER(dynax_state::nettoqc_input_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))	return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 1))	return input_port_read(machine(), "DSW2");
-	if (!BIT(m_dsw_sel, 2))	return input_port_read(machine(), "DSW3");
+	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
+	if (!BIT(m_dsw_sel, 2))	return ioport("DSW3")->read();
 	return 0xffff;
 }
 
@@ -1971,11 +1971,11 @@
 READ8_MEMBER(dynax_state::rongrong_input_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))	return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 1))	return input_port_read(machine(), "DSW2");
+	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))	return 0xff;//machine().rand();
 	if (!BIT(m_dsw_sel, 3))	return 0xff;//machine().rand();
-	if (!BIT(m_dsw_sel, 4))	return input_port_read(machine(), "DSW3");
+	if (!BIT(m_dsw_sel, 4))	return ioport("DSW3")->read();
 	return 0xff;
 }
 
@@ -2252,9 +2252,9 @@
 READ8_MEMBER(dynax_state::funkyfig_dsw_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))  return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 1))  return input_port_read(machine(), "DSW2");
-	if (!BIT(m_dsw_sel, 2))  return input_port_read(machine(), "DSW3");
+	if (!BIT(m_dsw_sel, 0))  return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 1))  return ioport("DSW2")->read();
+	if (!BIT(m_dsw_sel, 2))  return ioport("DSW3")->read();
 	logerror("%06x: warning, unknown bits read, ddenlovr_select = %02x\n", cpu_get_pc(&space.device()), m_dsw_sel);
 	return 0xff;
 }
@@ -2264,7 +2264,7 @@
 
 	switch (m_input_sel)
 	{
-		case 0x22:	return input_port_read(machine(), "IN2");
+		case 0x22:	return ioport("IN2")->read();
 		case 0x23:	return m_funkyfig_lockout;
 	}
 	logerror("%06x: warning, unknown bits read, ddenlovr_select2 = %02x\n", cpu_get_pc(&space.device()), m_input_sel);
@@ -2276,8 +2276,8 @@
 
 	switch (m_input_sel)
 	{
-		case 0x20:	return input_port_read(machine(), "IN0");
-		case 0x21:	return input_port_read(machine(), "IN1");
+		case 0x20:	return ioport("IN0")->read();
+		case 0x21:	return ioport("IN1")->read();
 	}
 	logerror("%06x: warning, unknown bits read, ddenlovr_select2 = %02x\n", cpu_get_pc(&space.device()), m_input_sel);
 	return 0xff;
@@ -2379,24 +2379,24 @@
 
 	UINT8 val = 0xff;
 
-	if      (!BIT(m_keyb, 0))   val = input_port_read(machine(), offset ? "KEY5" : "KEY0");
-	else if (!BIT(m_keyb, 1))   val = input_port_read(machine(), offset ? "KEY6" : "KEY1");
-	else if (!BIT(m_keyb, 2))   val = input_port_read(machine(), offset ? "KEY7" : "KEY2");
-	else if (!BIT(m_keyb, 3))   val = input_port_read(machine(), offset ? "KEY8" : "KEY3");
-	else if (!BIT(m_keyb, 4))   val = input_port_read(machine(), offset ? "KEY9" : "KEY4");
+	if      (!BIT(m_keyb, 0))   val = ioport(offset ? "KEY5" : "KEY0")->read();
+	else if (!BIT(m_keyb, 1))   val = ioport(offset ? "KEY6" : "KEY1")->read();
+	else if (!BIT(m_keyb, 2))   val = ioport(offset ? "KEY7" : "KEY2")->read();
+	else if (!BIT(m_keyb, 3))   val = ioport(offset ? "KEY8" : "KEY3")->read();
+	else if (!BIT(m_keyb, 4))   val = ioport(offset ? "KEY9" : "KEY4")->read();
 
-	val |= input_port_read(machine(), offset ? "HOPPER" : "BET");
+	val |= ioport(offset ? "HOPPER" : "BET")->read();
 	return val;
 }
 
 READ8_MEMBER(dynax_state::hanakanz_dsw_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))   return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 1))   return input_port_read(machine(), "DSW2");
-	if (!BIT(m_dsw_sel, 2))   return input_port_read(machine(), "DSW3");
-	if (!BIT(m_dsw_sel, 3))   return input_port_read(machine(), "DSW4");
-	if (!BIT(m_dsw_sel, 4))   return input_port_read(machine(), "DSW5");
+	if (!BIT(m_dsw_sel, 0))   return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 1))   return ioport("DSW2")->read();
+	if (!BIT(m_dsw_sel, 2))   return ioport("DSW3")->read();
+	if (!BIT(m_dsw_sel, 3))   return ioport("DSW4")->read();
+	if (!BIT(m_dsw_sel, 4))   return ioport("DSW5")->read();
 	return 0xff;
 }
 
@@ -2562,13 +2562,13 @@
 {
 	UINT8 val = 0xff;
 
-	if      (!BIT(m_keyb, 0))   val = input_port_read(machine(), offset ? "KEY5" : "KEY0");
-	else if (!BIT(m_keyb, 1))   val = input_port_read(machine(), offset ? "KEY6" : "KEY1");
-	else if (!BIT(m_keyb, 2))   val = input_port_read(machine(), offset ? "KEY7" : "KEY2");
-	else if (!BIT(m_keyb, 3))   val = input_port_read(machine(), offset ? "KEY8" : "KEY3");
-	else if (!BIT(m_keyb, 4))   val = input_port_read(machine(), offset ? "KEY9" : "KEY4");
+	if      (!BIT(m_keyb, 0))   val = ioport(offset ? "KEY5" : "KEY0")->read();
+	else if (!BIT(m_keyb, 1))   val = ioport(offset ? "KEY6" : "KEY1")->read();
+	else if (!BIT(m_keyb, 2))   val = ioport(offset ? "KEY7" : "KEY2")->read();
+	else if (!BIT(m_keyb, 3))   val = ioport(offset ? "KEY8" : "KEY3")->read();
+	else if (!BIT(m_keyb, 4))   val = ioport(offset ? "KEY9" : "KEY4")->read();
 
-	val |= input_port_read(machine(), offset ? "HOPPER" : "BET");
+	val |= ioport(offset ? "HOPPER" : "BET")->read();
 
 	if (offset)
 		val |= 0x80;	// blitter busy
@@ -2585,7 +2585,7 @@
 static void mjchuuka_get_romdata(running_machine &machine)
 {
 	dynax_state *state = machine.driver_data<dynax_state>();
-	UINT8 *rom = machine.root_device().memregion("blitter")->base();
+	UINT8 *rom = state->memregion("blitter")->base();
 	size_t size = state->memregion("blitter")->bytes();
 	int address = (state->m_ddenlovr_blit_address & 0xffffff) * 2;
 
@@ -2716,7 +2716,7 @@
 
 	switch (m_input_sel)
 	{
-		case 0x00:	return input_port_read(machine(), "SYSTEM");
+		case 0x00:	return ioport("SYSTEM")->read();
 		case 0x01:	return 0xff;
 		case 0x02:	return 0xff;	// bit 7 = 0 -> blitter busy, + hopper switch
 		case 0x03:	return 0xff;
@@ -2731,11 +2731,11 @@
 {
 	UINT8 ret = 0xff;
 
-	if      (BIT(m_keyb, 0))   ret = input_port_read(machine(), "KEY0");
-	else if (BIT(m_keyb, 1))   ret = input_port_read(machine(), "KEY1");
-	else if (BIT(m_keyb, 2))   ret = input_port_read(machine(), "KEY2");
-	else if (BIT(m_keyb, 3))   ret = input_port_read(machine(), "KEY3");
-	else if (BIT(m_keyb, 4))   ret = input_port_read(machine(), "KEY4");
+	if      (BIT(m_keyb, 0))   ret = ioport("KEY0")->read();
+	else if (BIT(m_keyb, 1))   ret = ioport("KEY1")->read();
+	else if (BIT(m_keyb, 2))   ret = ioport("KEY2")->read();
+	else if (BIT(m_keyb, 3))   ret = ioport("KEY3")->read();
+	else if (BIT(m_keyb, 4))   ret = ioport("KEY4")->read();
 	else	logerror("%06x: warning, unknown bits read, keyb = %02x\n", cpu_get_pc(&space.device()), m_keyb);
 
 	m_keyb <<= 1;
@@ -2746,11 +2746,11 @@
 READ8_MEMBER(dynax_state::mjmyster_dsw_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))   return input_port_read(machine(), "DSW4");
-	if (!BIT(m_dsw_sel, 1))   return input_port_read(machine(), "DSW3");
-	if (!BIT(m_dsw_sel, 2))   return input_port_read(machine(), "DSW2");
-	if (!BIT(m_dsw_sel, 3))   return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 4))   return input_port_read(machine(), "DSW5");
+	if (!BIT(m_dsw_sel, 0))   return ioport("DSW4")->read();
+	if (!BIT(m_dsw_sel, 1))   return ioport("DSW3")->read();
+	if (!BIT(m_dsw_sel, 2))   return ioport("DSW2")->read();
+	if (!BIT(m_dsw_sel, 3))   return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 4))   return ioport("DSW5")->read();
 	logerror("%06x: warning, unknown bits read, ddenlovr_select = %02x\n", cpu_get_pc(&space.device()), m_dsw_sel);
 	return 0xff;
 }
@@ -2841,11 +2841,11 @@
 {
 	dynax_state *state = device->machine().driver_data<dynax_state>();
 
-	if (!BIT(state->m_dsw_sel, 0))   return input_port_read(device->machine(), "DSW4");
-	if (!BIT(state->m_dsw_sel, 1))   return input_port_read(device->machine(), "DSW3");
-	if (!BIT(state->m_dsw_sel, 2))   return input_port_read(device->machine(), "DSW2");
-	if (!BIT(state->m_dsw_sel, 3))   return input_port_read(device->machine(), "DSW1");
-	if (!BIT(state->m_dsw_sel, 4))   return input_port_read(device->machine(), "DSW5");
+	if (!BIT(state->m_dsw_sel, 0))   return state->ioport("DSW4")->read();
+	if (!BIT(state->m_dsw_sel, 1))   return state->ioport("DSW3")->read();
+	if (!BIT(state->m_dsw_sel, 2))   return state->ioport("DSW2")->read();
+	if (!BIT(state->m_dsw_sel, 3))   return state->ioport("DSW1")->read();
+	if (!BIT(state->m_dsw_sel, 4))   return state->ioport("DSW5")->read();
 
 	logerror("%s: warning, unknown bits read, ddenlovr_select = %02x\n", device->machine().describe_context(), state->m_dsw_sel);
 	return 0xff;
@@ -2862,8 +2862,8 @@
 
 	switch (m_input_sel)
 	{
-		case 0x20:	return input_port_read(machine(), "SYSTEM");
-		case 0x21:	return input_port_read(machine(), "BET");
+		case 0x20:	return ioport("SYSTEM")->read();
+		case 0x21:	return ioport("BET")->read();
 		case 0x22:	return 0x7f;	// bit 7 = blitter busy, bit 6 = hopper
 		case 0x23:	return m_coins;
 	}
@@ -2912,11 +2912,11 @@
 
 		// player 1
 		case 0xa1:
-			return input_port_read(machine(), keynames0[m_keyb++]);
+			return ioport(keynames0[m_keyb++])->read();
 
 		// player 2
 		case 0xa2:
-			return input_port_read(machine(), keynames1[m_keyb++]);
+			return ioport(keynames1[m_keyb++])->read();
 	}
 	logerror("%04x: input_r with select = %02x\n", cpu_get_pc(&space.device()), m_input_sel);
 	return 0xff;
@@ -2988,11 +2988,11 @@
 	dynax_state *state = space->machine().driver_data<dynax_state>();
 	UINT8 hopper_bit = ((state->m_hopper && !(space->machine().primary_screen->frame_number() % 10)) ? 0 : (1 << 6));
 
-	if (!BIT(state->m_input_sel, 0))   return input_port_read(space->machine(), player ? "KEY5" : "KEY0") | hopper_bit;
-	if (!BIT(state->m_input_sel, 1))   return input_port_read(space->machine(), player ? "KEY6" : "KEY1") | hopper_bit;
-	if (!BIT(state->m_input_sel, 2))   return input_port_read(space->machine(), player ? "KEY7" : "KEY2") | hopper_bit;
-	if (!BIT(state->m_input_sel, 3))   return input_port_read(space->machine(), player ? "KEY8" : "KEY3") | hopper_bit;
-	if (!BIT(state->m_input_sel, 4))   return input_port_read(space->machine(), player ? "KEY9" : "KEY4") | hopper_bit;
+	if (!BIT(state->m_input_sel, 0))   return state->ioport(player ? "KEY5" : "KEY0")->read() | hopper_bit;
+	if (!BIT(state->m_input_sel, 1))   return state->ioport(player ? "KEY6" : "KEY1")->read() | hopper_bit;
+	if (!BIT(state->m_input_sel, 2))   return state->ioport(player ? "KEY7" : "KEY2")->read() | hopper_bit;
+	if (!BIT(state->m_input_sel, 3))   return state->ioport(player ? "KEY8" : "KEY3")->read() | hopper_bit;
+	if (!BIT(state->m_input_sel, 4))   return state->ioport(player ? "KEY9" : "KEY4")->read() | hopper_bit;
 
 	return 0x7f;	// bit 7 = blitter busy, bit 6 = hopper
 }
@@ -3007,7 +3007,7 @@
 
 	switch (m_dsw_sel)
 	{
-		case 0x20:	return input_port_read(machine(), "SYSTEM");
+		case 0x20:	return ioport("SYSTEM")->read();
 		case 0x21:	return hgokou_player_r(&space, 1);
 		case 0x22:	return hgokou_player_r(&space, 0);
 		case 0x23:	return m_coins;
@@ -3170,12 +3170,12 @@
 
 	switch (m_input_sel)
 	{
-		case 0x00:	return input_port_read(machine(), "P1");
-		case 0x01:	return input_port_read(machine(), "P2");
-		case 0x02:	return input_port_read(machine(), "SYSTEM");
+		case 0x00:	return ioport("P1")->read();
+		case 0x01:	return ioport("P2")->read();
+		case 0x02:	return ioport("SYSTEM")->read();
 		case 0x0d:	return 0x00;
-		case 0x80:	return input_port_read(machine(), keynames0[m_keyb++]);	// P1 (Keys)
-		case 0x81:	return input_port_read(machine(), keynames1[m_keyb++]);	// P2 (Keys)
+		case 0x80:	return ioport(keynames0[m_keyb++])->read();	// P1 (Keys)
+		case 0x81:	return ioport(keynames1[m_keyb++])->read();	// P2 (Keys)
 	}
 	logerror("%06x: warning, unknown bits read, input_sel = %02x\n", cpu_get_pc(&space.device()), m_input_sel);
 	return 0xff;
@@ -3184,11 +3184,11 @@
 READ8_MEMBER(dynax_state::hparadis_dsw_r)
 {
 
-	if (!BIT(m_dsw_sel, 0))	return input_port_read(machine(), "DSW1");
-	if (!BIT(m_dsw_sel, 1))	return input_port_read(machine(), "DSW2");
+	if (!BIT(m_dsw_sel, 0))	return ioport("DSW1")->read();
+	if (!BIT(m_dsw_sel, 1))	return ioport("DSW2")->read();
 	if (!BIT(m_dsw_sel, 2))	return 0xff;
 	if (!BIT(m_dsw_sel, 3))	return 0xff;
-	if (!BIT(m_dsw_sel, 4))	return input_port_read(machine(), "DSW3");
+	if (!BIT(m_dsw_sel, 4))	return ioport("DSW3")->read();
 	return 0xff;
 }
 
@@ -3246,7 +3246,7 @@
 
 	switch (m_input_sel)
 	{
-		case 0x80:	return input_port_read(machine(), "SYSTEM");
+		case 0x80:	return ioport("SYSTEM")->read();
 		case 0x81:	return 0x00;
 		case 0x82:	return 0xff;	// bit 7 = 0 -> blitter busy, + hopper switch
 		case 0x83:	return 0x00;
@@ -3316,8 +3316,8 @@
 {
 	UINT16 dsw = 0;
 
-	if (m_dsw_sel16[1] == 0xff)	dsw |= input_port_read(machine(), "DSW1");
-	if (m_dsw_sel16[0] == 0xff)	dsw |= input_port_read(machine(), "DSW2");
+	if (m_dsw_sel16[1] == 0xff)	dsw |= ioport("DSW1")->read();
+	if (m_dsw_sel16[0] == 0xff)	dsw |= ioport("DSW2")->read();
 	return dsw;
 }
 
@@ -3402,11 +3402,11 @@
 {
 	UINT8 val = 0xff;
 
-	if      (!BIT(m_keyb, 0))   val = input_port_read(machine(), offset ? "KEY5" : "KEY0");
-	else if (!BIT(m_keyb, 1))   val = input_port_read(machine(), offset ? "KEY6" : "KEY1");
-	else if (!BIT(m_keyb, 2))   val = input_port_read(machine(), offset ? "KEY7" : "KEY2");
-	else if (!BIT(m_keyb, 3))   val = input_port_read(machine(), offset ? "KEY8" : "KEY3");
-	else if (!BIT(m_keyb, 4))   val = input_port_read(machine(), offset ? "KEY9" : "KEY4");
+	if      (!BIT(m_keyb, 0))   val = ioport(offset ? "KEY5" : "KEY0")->read();
+	else if (!BIT(m_keyb, 1))   val = ioport(offset ? "KEY6" : "KEY1")->read();
+	else if (!BIT(m_keyb, 2))   val = ioport(offset ? "KEY7" : "KEY2")->read();
+	else if (!BIT(m_keyb, 3))   val = ioport(offset ? "KEY8" : "KEY3")->read();
+	else if (!BIT(m_keyb, 4))   val = ioport(offset ? "KEY9" : "KEY4")->read();
 
 	return val;
 }
@@ -3524,13 +3524,13 @@
 {
 	UINT8 val = 0x3f;
 
-	if      (!BIT(m_keyb, 0))   val = input_port_read(machine(), offset ? "KEY5" : "KEY0");
-	else if (!BIT(m_keyb, 1))   val = input_port_read(machine(), offset ? "KEY6" : "KEY1");
-	else if (!BIT(m_keyb, 2))   val = input_port_read(machine(), offset ? "KEY7" : "KEY2");
-	else if (!BIT(m_keyb, 3))   val = input_port_read(machine(), offset ? "KEY8" : "KEY3");
-	else if (!BIT(m_keyb, 4))   val = input_port_read(machine(), offset ? "KEY9" : "KEY4");
+	if      (!BIT(m_keyb, 0))   val = ioport(offset ? "KEY5" : "KEY0")->read();
+	else if (!BIT(m_keyb, 1))   val = ioport(offset ? "KEY6" : "KEY1")->read();
+	else if (!BIT(m_keyb, 2))   val = ioport(offset ? "KEY7" : "KEY2")->read();
+	else if (!BIT(m_keyb, 3))   val = ioport(offset ? "KEY8" : "KEY3")->read();
+	else if (!BIT(m_keyb, 4))   val = ioport(offset ? "KEY9" : "KEY4")->read();
 
-	val |= input_port_read(machine(), offset ? "HOPPER" : "BET");
+	val |= ioport(offset ? "HOPPER" : "BET")->read();
 	if (offset)
 		val &= 0x7f;	// bit 7 = blitter busy
 	return val;
@@ -3600,13 +3600,13 @@
 {
 	UINT8 val = 0x3f;
 
-	if      (!BIT(m_keyb, 0))  val = input_port_read(machine(), "KEY0");
-	else if (!BIT(m_keyb, 1))  val = input_port_read(machine(), "KEY1");
-	else if (!BIT(m_keyb, 2))  val = input_port_read(machine(), "KEY2");
-	else if (!BIT(m_keyb, 3))  val = input_port_read(machine(), "KEY3");
-	else if (!BIT(m_keyb, 4))  val = input_port_read(machine(), "KEY4");
+	if      (!BIT(m_keyb, 0))  val = ioport("KEY0")->read();
+	else if (!BIT(m_keyb, 1))  val = ioport("KEY1")->read();
+	else if (!BIT(m_keyb, 2))  val = ioport("KEY2")->read();
+	else if (!BIT(m_keyb, 3))  val = ioport("KEY3")->read();
+	else if (!BIT(m_keyb, 4))  val = ioport("KEY4")->read();
 
-	val |= input_port_read(machine(), "BET");
+	val |= ioport("BET")->read();
 	return val;
 }
 
@@ -3614,13 +3614,13 @@
 {
 	UINT8 val = 0x3f;
 
-	if      (!BIT(m_keyb, 0))  val = input_port_read(machine(), "KEY5");
-	else if (!BIT(m_keyb, 1))  val = input_port_read(machine(), "KEY6");
-	else if (!BIT(m_keyb, 2))  val = input_port_read(machine(), "KEY7");
-	else if (!BIT(m_keyb, 3))  val = input_port_read(machine(), "KEY8");
-	else if (!BIT(m_keyb, 4))  val = input_port_read(machine(), "KEY9");
+	if      (!BIT(m_keyb, 0))  val = ioport("KEY5")->read();
+	else if (!BIT(m_keyb, 1))  val = ioport("KEY6")->read();
+	else if (!BIT(m_keyb, 2))  val = ioport("KEY7")->read();
+	else if (!BIT(m_keyb, 3))  val = ioport("KEY8")->read();
+	else if (!BIT(m_keyb, 4))  val = ioport("KEY9")->read();
 
-	val |= input_port_read(machine(), "HOPPER");
+	val |= ioport("HOPPER")->read();
 	return val;
 }
 
diff -Nru src-old/mame/drivers/ddragon.c src/mame/drivers/ddragon.c
--- src-old/mame/drivers/ddragon.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/ddragon.c	2012-05-03 11:00:08.000000000 +0200
@@ -690,7 +690,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON3 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, ddragon_state,sub_cpu_busy, NULL)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -2023,25 +2023,25 @@
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_write_handler(0x3808, 0x3808, write8_delegate(FUNC(ddragon_state::toffy_bankswitch_w),state));
 
 	/* the program rom has a simple bitswap encryption */
-	rom = machine.root_device().memregion("maincpu")->base();
-	length = machine.root_device().memregion("maincpu")->bytes();
+	rom = state->memregion("maincpu")->base();
+	length = state->memregion("maincpu")->bytes();
 	for (i = 0; i < length; i++)
 		rom[i] = BITSWAP8(rom[i], 6,7,5,4,3,2,1,0);
 
 	/* and the fg gfx ... */
-	rom = machine.root_device().memregion("gfx1")->base();
-	length = machine.root_device().memregion("gfx1")->bytes();
+	rom = state->memregion("gfx1")->base();
+	length = state->memregion("gfx1")->bytes();
 	for (i = 0; i < length; i++)
 		rom[i] = BITSWAP8(rom[i], 7,6,5,3,4,2,1,0);
 
 	/* and the sprites gfx */
-	rom = machine.root_device().memregion("gfx2")->base();
-	length = machine.root_device().memregion("gfx2")->bytes();
+	rom = state->memregion("gfx2")->base();
+	length = state->memregion("gfx2")->bytes();
 	for (i = 0; i < length; i++)
 		rom[i] = BITSWAP8(rom[i], 7,6,5,4,3,2,0,1);
 
 	/* and the bg gfx */
-	rom = machine.root_device().memregion("gfx3")->base();
+	rom = state->memregion("gfx3")->base();
 	length = state->memregion("gfx3")->bytes();
 	for (i = 0; i < length / 2; i++)
 	{
@@ -2058,7 +2058,7 @@
 	int i;
 	UINT8 *dst,*src;
 
-	src = machine.root_device().memregion("chars")->base();
+	src = state->memregion("chars")->base();
 	dst = state->memregion("gfx1")->base();
 
 	for (i = 0; i < 0x8000; i++)
diff -Nru src-old/mame/drivers/ddragon3.c src/mame/drivers/ddragon3.c
--- src-old/mame/drivers/ddragon3.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/ddragon3.c	2012-05-03 11:00:08.000000000 +0200
@@ -365,7 +365,7 @@
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Flip_Screen ) )	PORT_DIPLOCATION("SW1:7")
 	PORT_DIPSETTING(	  0x1000, DEF_STR( Off ) )
 	PORT_DIPSETTING(	  0x0000, DEF_STR( On ) )
@@ -420,10 +420,10 @@
 	PORT_DIPSETTING(	  0x0800, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x1000, IP_ACTIVE_LOW, "SW2:5" )
 	PORT_DIPNAME( 0x2000, 0x2000, "Stage Clear Energy" ) PORT_DIPLOCATION("SW2:6")
-	PORT_DIPSETTING(	  0x2000, "0" )			PORT_CONDITION("IN3", 0x0100, PORTCOND_EQUALS, 0x0100)
-	PORT_DIPSETTING(	  0x0000, "50" )		PORT_CONDITION("IN3", 0x0100, PORTCOND_EQUALS, 0x0100)
-	PORT_DIPSETTING(	  0x2000, "100" )		PORT_CONDITION("IN3", 0x0100, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(	  0x0000, "150" )		PORT_CONDITION("IN3", 0x0100, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(	  0x2000, "0" )			PORT_CONDITION("IN3", 0x0100, EQUALS, 0x0100)
+	PORT_DIPSETTING(	  0x0000, "50" )		PORT_CONDITION("IN3", 0x0100, EQUALS, 0x0100)
+	PORT_DIPSETTING(	  0x2000, "100" )		PORT_CONDITION("IN3", 0x0100, EQUALS, 0x0000)
+	PORT_DIPSETTING(	  0x0000, "150" )		PORT_CONDITION("IN3", 0x0100, EQUALS, 0x0000)
 	PORT_BIT( 0xc000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN3")
diff -Nru src-old/mame/drivers/deadang.c src/mame/drivers/deadang.c
--- src-old/mame/drivers/deadang.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/deadang.c	2012-05-03 11:00:08.000000000 +0200
@@ -47,11 +47,11 @@
 
 READ16_MEMBER(deadang_state::ghunter_trackball_low_r)
 {
-	return (input_port_read(machine(), "TRACKX") & 0xff) | ((input_port_read(machine(), "TRACKY") & 0xff) << 8);
+	return (ioport("TRACKX")->read() & 0xff) | ((ioport("TRACKY")->read() & 0xff) << 8);
 }
 READ16_MEMBER(deadang_state::ghunter_trackball_high_r)
 {
-	return ((input_port_read(machine(), "TRACKX") & 0x0f00) >> 4) | (input_port_read(machine(), "TRACKY") & 0x0f00);
+	return ((ioport("TRACKX")->read() & 0x0f00) >> 4) | (ioport("TRACKY")->read() & 0x0f00);
 }
 
 /* Memory Maps */
diff -Nru src-old/mame/drivers/dec0.c src/mame/drivers/dec0.c
--- src-old/mame/drivers/dec0.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dec0.c	2012-05-03 11:00:08.000000000 +0200
@@ -337,13 +337,13 @@
 	switch (offset<<1)
 	{
 		case 0: /* Dip Switches */
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 2: /* Player 1 & Player 2 joysticks & fire buttons */
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 
 		case 4: /* Credits */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 	}
 
 	logerror("Unknown control read at 30c000 %d\n", offset);
@@ -693,7 +693,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( dec1 )
@@ -719,7 +719,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -977,7 +977,7 @@
 	PORT_DIPUNUSED_DIPLOC( 0x8000, IP_ACTIVE_LOW, "SW2:8" )	// Always OFF
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( ffantasy )
@@ -1121,7 +1121,7 @@
 	PORT_INCLUDE( dec1 )
 
 	PORT_MODIFY("SYSTEM")
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )		/* extremely slow palette fades with ACTIVE_HIGH */
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")		/* extremely slow palette fades with ACTIVE_HIGH */
 
 	PORT_START("DSW")
 	/* Different Coinage. Just a few combinations from manual, the rest was figured out */
diff -Nru src-old/mame/drivers/dec8.c src/mame/drivers/dec8.c
--- src-old/mame/drivers/dec8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dec8.c	2012-05-03 11:00:08.000000000 +0200
@@ -96,28 +96,28 @@
 
 READ8_MEMBER(dec8_state::gondo_player_1_r)
 {
-	int val = 1 << input_port_read(machine(), "AN0");
+	int val = 1 << ioport("AN0")->read();
 
 	switch (offset)
 	{
 		case 0: /* Rotary low byte */
 			return ~(val & 0xff);
 		case 1: /* Joystick = bottom 4 bits, rotary = top 4 */
-			return ((~val >> 4) & 0xf0) | (input_port_read(machine(), "IN0") & 0xf);
+			return ((~val >> 4) & 0xf0) | (ioport("IN0")->read() & 0xf);
 	}
 	return 0xff;
 }
 
 READ8_MEMBER(dec8_state::gondo_player_2_r)
 {
-	int val = 1 << input_port_read(machine(), "AN1");
+	int val = 1 << ioport("AN1")->read();
 
 	switch (offset)
 	{
 		case 0: /* Rotary low byte */
 			return ~(val & 0xff);
 		case 1: /* Joystick = bottom 4 bits, rotary = top 4 */
-			return ((~val >> 4) & 0xf0) | (input_port_read(machine(), "IN1") & 0xf);
+			return ((~val >> 4) & 0xf0) | (ioport("IN1")->read() & 0xf);
 	}
 	return 0xff;
 }
@@ -183,8 +183,8 @@
 	}
 
 	/* Coins are controlled by the i8751 */
-	if ((input_port_read(machine(), "IN2") & 3) == 3) m_latch = 1;
-	if ((input_port_read(machine(), "IN2") & 1) != 1 && m_latch)
+	if ((ioport("IN2")->read() & 3) == 3) m_latch = 1;
+	if ((ioport("IN2")->read() & 1) != 1 && m_latch)
 	{
 		m_coin1++;
 		m_latch = 0;
@@ -196,7 +196,7 @@
 			m_credits+=m_cred1;
 		}
 	}
-	if ((input_port_read(machine(), "IN2") & 2) != 2 && m_latch)
+	if ((ioport("IN2")->read() & 2) != 2 && m_latch)
 	{
 		m_coin2++;
 		m_latch = 0;
@@ -246,9 +246,9 @@
 	}
 
 	/* Coins are controlled by the i8751 */
-	if (/*(input_port_read(machine(), "IN2") & 3) == 3*/!m_latch) { m_latch = 1; m_coin1 = m_coin2 = 0; }
-	if ((input_port_read(machine(), "IN2") & 1) != 1 && m_latch)  { m_coin1 = 1; m_latch = 0; }
-	if ((input_port_read(machine(), "IN2") & 2) != 2 && m_latch)  { m_coin2 = 1; m_latch = 0; }
+	if (/*(ioport("IN2")->read() & 3) == 3*/!m_latch) { m_latch = 1; m_coin1 = m_coin2 = 0; }
+	if ((ioport("IN2")->read() & 1) != 1 && m_latch)  { m_coin1 = 1; m_latch = 0; }
+	if ((ioport("IN2")->read() & 2) != 2 && m_latch)  { m_coin2 = 1; m_latch = 0; }
 
 	if (m_i8751_value == 0x0102) m_i8751_return = 0;    /* ??? */
 	if (m_i8751_value == 0x0101) m_i8751_return = 0;    /* ??? */
@@ -284,8 +284,8 @@
 	}
 
 	/* Coins are controlled by the i8751 */
-	if ((input_port_read(machine(), "IN2") & 3) == 3) m_latch = 1;
-	if ((input_port_read(machine(), "IN2") & 1) != 1 && m_latch)
+	if ((ioport("IN2")->read() & 3) == 3) m_latch = 1;
+	if ((ioport("IN2")->read() & 1) != 1 && m_latch)
 	{
 		m_coin1++;
 		m_latch = 0;
@@ -297,7 +297,7 @@
 			m_credits+=m_cred1;
 		}
 	}
-	if ((input_port_read(machine(), "IN2") & 2) != 2 && m_latch)
+	if ((ioport("IN2")->read() & 2) != 2 && m_latch)
 	{
 		m_coin2++;
 		m_latch = 0;
@@ -351,8 +351,8 @@
 	}
 
 	/* Coins are controlled by the i8751 */
-	if ((input_port_read(machine(), "I8751") & 3) == 3) m_latch = 1;
-	if ((input_port_read(machine(), "I8751") & 1) != 1 && m_latch)
+	if ((ioport("I8751")->read() & 3) == 3) m_latch = 1;
+	if ((ioport("I8751")->read() & 1) != 1 && m_latch)
 	{
 		m_coin1++;
 		m_latch = 0;
@@ -362,7 +362,7 @@
 			m_credits+=m_cred1;
 		}
 	}
-	if ((input_port_read(machine(), "I8751") & 2) != 2 && m_latch)
+	if ((ioport("I8751")->read() & 2) != 2 && m_latch)
 	{
 		m_coin2++;
 		m_latch = 0;
@@ -934,7 +934,7 @@
 		case 2:
 			return 0xff;
 		case 3:
-			return input_port_read(machine(), "I8751");
+			return ioport("I8751")->read();
 	}
 
 	return 0xff; //compile safe.
@@ -1005,7 +1005,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
@@ -1095,7 +1095,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) )
@@ -1189,7 +1189,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("I8751")	/* hooked up on the i8751 */
 	/* Low 4 bits not connected on schematics */
@@ -1260,7 +1260,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)  /* shoot */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)  /* bomb */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("I8751")	/* hooked up on the (fake) i8751 */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
@@ -1344,7 +1344,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
@@ -1473,7 +1473,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
@@ -1560,7 +1560,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* table at 0xf8e3 (4 * 2 bytes : coins then credits) */
@@ -1649,7 +1649,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("I8751") /* Fake port for i8751 */
@@ -1743,7 +1743,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* code at 0x88b7 in 'cobracom', 0x890e in 'cobracomj' */
@@ -1966,8 +1966,8 @@
 static INTERRUPT_GEN( oscar_interrupt )
 {
 	dec8_state *state = device->machine().driver_data<dec8_state>();
-	if ((input_port_read(device->machine(), "IN2") & 0x7) == 0x7) state->m_latch = 1;
-	if (state->m_latch && (input_port_read(device->machine(), "IN2") & 0x7) != 0x7)
+	if ((state->ioport("IN2")->read() & 0x7) == 0x7) state->m_latch = 1;
+	if (state->m_latch && (state->ioport("IN2")->read() & 0x7) != 0x7)
 	{
 		state->m_latch = 0;
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
diff -Nru src-old/mame/drivers/deco156.c src/mame/drivers/deco156.c
--- src-old/mame/drivers/deco156.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/deco156.c	2012-05-03 11:00:08.000000000 +0200
@@ -89,7 +89,7 @@
 	if (ACCESSING_BITS_0_7)
 	{
 		m_oki2->set_bank_base(0x40000 * (data & 0x7));
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
@@ -189,7 +189,7 @@
 	PORT_BIT( 0x00020000, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x00080000, IP_ACTIVE_LOW )
-	PORT_BIT( 0x00100000, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x00100000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x00200000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x00400000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x00800000, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -231,7 +231,7 @@
 	PORT_BIT( 0x00020000, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x00080000, IP_ACTIVE_LOW )
-	PORT_BIT( 0x00100000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x00100000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x00200000, IP_ACTIVE_LOW, IPT_UNUSED ) /* 'soundmask' */
 	PORT_BIT( 0x00400000, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x00800000, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/deco32.c src/mame/drivers/deco32.c
--- src-old/mame/drivers/deco32.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/deco32.c	2012-05-03 11:00:08.000000000 +0200
@@ -358,9 +358,9 @@
 {
 	/* Protection/IO chip 75, same as Lemmings & Robocop 2 */
 	switch (offset<<2) {
-	case 0x0a0: return input_port_read(machine(), "IN0"); /* Player 1 & 2 controls */
-	case 0x158: return input_port_read(machine(), "IN1"); /* Player 3 & 4 controls */
-	case 0xed4: return input_port_read(machine(), "IN2"); /* Misc */
+	case 0x0a0: return ioport("IN0")->read(); /* Player 1 & 2 controls */
+	case 0x158: return ioport("IN1")->read(); /* Player 3 & 4 controls */
+	case 0xed4: return ioport("IN2")->read(); /* Misc */
 	}
 
 	logerror("%08x: Unmapped protection read %04x\n",cpu_get_pc(&space.device()),offset<<2);
@@ -370,14 +370,14 @@
 READ32_MEMBER(deco32_state::captaven_soundcpu_r)
 {
 	/* Top byte - top bit low == sound cpu busy, bottom word is dips */
-	return 0xffff0000 | input_port_read(machine(), "DSW");
+	return 0xffff0000 | ioport("DSW")->read();
 }
 
 READ32_MEMBER(deco32_state::fghthist_control_r)
 {
 	switch (offset) {
-	case 0: return 0xffff0000 | input_port_read(machine(), "IN0");
-	case 1: return 0xffff0000 | input_port_read(machine(), "IN1"); //check top bits??
+	case 0: return 0xffff0000 | ioport("IN0")->read();
+	case 1: return 0xffff0000 | ioport("IN1")->read(); //check top bits??
 	case 2: return 0xfffffffe | machine().device<eeprom_device>("eeprom")->read_bit();
 	}
 
@@ -405,7 +405,7 @@
 READ32_MEMBER(deco32_state::dragngun_service_r)
 {
 //  logerror("%08x:Read service\n",cpu_get_pc(&space.device()));
-	return input_port_read(machine(), "IN2");
+	return ioport("IN2")->read();
 }
 
 READ32_MEMBER(deco32_state::lockload_gun_mirror_r)
@@ -413,8 +413,8 @@
 //logerror("%08x:Read gun %d\n",cpu_get_pc(&space.device()),offset);
 //return ((machine().rand()%0xffff)<<16) | machine().rand()%0xffff;
 	if (offset) /* Mirror of player 1 and player 2 fire buttons */
-		return input_port_read(machine(), "IN4") | ((machine().rand()%0xff)<<16);
-	return input_port_read(machine(), "IN3") | input_port_read(machine(), "LIGHT0_X") | (input_port_read(machine(), "LIGHT0_X")<<16) | (input_port_read(machine(), "LIGHT0_X")<<24); //((machine().rand()%0xff)<<16);
+		return ioport("IN4")->read() | ((machine().rand()%0xff)<<16);
+	return ioport("IN3")->read() | ioport("LIGHT0_X")->read() | (ioport("LIGHT0_X")->read()<<16) | (ioport("LIGHT0_X")->read()<<24); //((machine().rand()%0xff)<<16);
 }
 
 READ32_MEMBER(deco32_state::dragngun_prot_r)
@@ -427,9 +427,9 @@
 //definitely vblank in locked load
 
 	switch (offset<<1) {
-	case 0x140/2: return 0xffff0000 | input_port_read(machine(), "IN0"); /* IN0 */
-	case 0xadc/2: return 0xffff0000 | input_port_read(machine(), "IN1") | m_strobe; /* IN1 */
-	case 0x6a0/2: return 0xffff0000 | input_port_read(machine(), "DSW"); /* IN2 (Dip switch) */
+	case 0x140/2: return 0xffff0000 | ioport("IN0")->read(); /* IN0 */
+	case 0xadc/2: return 0xffff0000 | ioport("IN1")->read() | m_strobe; /* IN1 */
+	case 0x6a0/2: return 0xffff0000 | ioport("DSW")->read(); /* IN2 (Dip switch) */
 	}
 	return 0xffffffff;
 }
@@ -439,10 +439,10 @@
 {
 	/* Ports 0-3 are read, but seem unused */
 	switch (m_dragngun_lightgun_port) {
-	case 4: return input_port_read(machine(), "LIGHT0_X");
-	case 5: return input_port_read(machine(), "LIGHT1_X");
-	case 6: return input_port_read(machine(), "LIGHT0_Y");
-	case 7: return input_port_read(machine(), "LIGHT1_Y");
+	case 4: return ioport("LIGHT0_X")->read();
+	case 5: return ioport("LIGHT1_X")->read();
+	case 6: return ioport("LIGHT0_Y")->read();
+	case 7: return ioport("LIGHT1_Y")->read();
 	}
 
 //  logerror("Illegal lightgun port %d read \n",m_dragngun_lightgun_port);
@@ -479,8 +479,8 @@
 READ32_MEMBER(deco32_state::tattass_prot_r)
 {
 	switch (offset<<1) {
-	case 0x280: return input_port_read(machine(), "IN0") << 16;
-	case 0x4c4: return input_port_read(machine(), "IN1") << 16;
+	case 0x280: return ioport("IN0")->read() << 16;
+	case 0x4c4: return ioport("IN1")->read() << 16;
 	case 0x35a: return m_tattass_eprom_bit << 16;
 	}
 
@@ -637,8 +637,8 @@
 {
 
 	switch (offset<<1) {
-	case 0x280: return input_port_read(machine(), "IN0") << 16| 0xffff; /* IN0 */
-	case 0x4c4: return input_port_read(machine(), "IN1") << 16| 0xffff; /* IN1 */
+	case 0x280: return ioport("IN0")->read() << 16| 0xffff; /* IN0 */
+	case 0x4c4: return ioport("IN1")->read() << 16| 0xffff; /* IN1 */
 	case 0x35a: return (machine().device<eeprom_device>("eeprom")->read_bit()<< 16) | 0xffff; // Debug switch in low word??
 	}
 
@@ -1208,7 +1208,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1287,7 +1287,7 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_SERVICE( 0x0004, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNKNOWN ) //check  //test BUTTON F2
@@ -1363,7 +1363,7 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK ) //IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") //IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x0004, IP_ACTIVE_LOW )
 	PORT_BIT( 0x00f8, IP_ACTIVE_LOW, IPT_UNUSED ) //check  //test BUTTON F2
@@ -1413,7 +1413,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED ) /* 'soundmask' */
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -1451,7 +1451,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED ) /* 'soundmask' */
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/deco_ld.c src/mame/drivers/deco_ld.c
--- src-old/mame/drivers/deco_ld.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/deco_ld.c	2012-05-03 11:00:08.000000000 +0200
@@ -286,7 +286,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_DIPNAME( 0x01, 0x00, "SYS1" )
@@ -442,7 +442,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_DIPNAME( 0x01, 0x00, "SYS1" )
diff -Nru src-old/mame/drivers/deco_mlc.c src/mame/drivers/deco_mlc.c
--- src-old/mame/drivers/deco_mlc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/deco_mlc.c	2012-05-03 11:00:08.000000000 +0200
@@ -110,7 +110,7 @@
 READ32_MEMBER(deco_mlc_state::test2_r)
 {
 //  if (offset==0)
-//      return input_port_read(machine(), "IN0"); //0xffffffff;
+//      return ioport("IN0")->read(); //0xffffffff;
 //   logerror("%08x:  Test2_r %d\n",cpu_get_pc(&space.device()),offset);
 	return machine().rand(); //0xffffffff;
 }
diff -Nru src-old/mame/drivers/decocass.c src/mame/drivers/decocass.c
--- src-old/mame/drivers/decocass.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/decocass.c	2012-05-03 11:00:08.000000000 +0200
@@ -239,7 +239,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )						PORT_DIPLOCATION("SW1:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM) PORT_VBLANK("screen")
 
 	PORT_START("DSW2") /* Start with all Unknown as each can change per game, except for Country Code */
 	PORT_DIPUNKNOWN_DIPLOC( 0x01, 0x01, "SW2:1")		/* Most Dipswitch Settings sheets show this as "Number of Players" (Lives) */
@@ -1475,8 +1475,8 @@
 static DRIVER_INIT( decocrom )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
-	int romlength = machine.root_device().memregion("user3")->bytes();
-	UINT8 *rom = machine.root_device().memregion("user3")->base();
+	int romlength = state->memregion("user3")->bytes();
+	UINT8 *rom = state->memregion("user3")->base();
 	int i;
 
 	state->m_decrypted2 = auto_alloc_array(machine, UINT8, romlength);
diff -Nru src-old/mame/drivers/deshoros.c src/mame/drivers/deshoros.c
--- src-old/mame/drivers/deshoros.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/deshoros.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,9 +81,9 @@
 	switch(offset)
 	{
 		case 0x00: return 0xff; //printer read
-		case 0x03: return input_port_read(machine(), "KEY0" );
-		case 0x04: return input_port_read(machine(), "KEY1" );
-		case 0x05: return input_port_read(machine(), "SYSTEM" );
+		case 0x03: return ioport("KEY0" )->read();
+		case 0x04: return ioport("KEY1" )->read();
+		case 0x05: return ioport("SYSTEM" )->read();
 		case 0x0a: return m_io_ram[offset]; //"buzzer" 0 read
 		case 0x0b: return m_io_ram[offset]; //"buzzer" 1 read
 	}
diff -Nru src-old/mame/drivers/destroyr.c src/mame/drivers/destroyr.c
--- src-old/mame/drivers/destroyr.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/destroyr.c	2012-05-03 11:00:08.000000000 +0200
@@ -146,7 +146,7 @@
 	state->m_potsense[1] = 0;
 
 	/* PCB supports two dials, but cab has only got one */
-	machine.scheduler().timer_set(machine.primary_screen->time_until_pos(input_port_read(machine, "PADDLE")), FUNC(destroyr_dial_callback));
+	machine.scheduler().timer_set(machine.primary_screen->time_until_pos(state->ioport("PADDLE")->read()), FUNC(destroyr_dial_callback));
 	machine.scheduler().timer_set(machine.primary_screen->time_until_pos(0), FUNC(destroyr_frame_callback));
 }
 
@@ -237,12 +237,12 @@
 
 	if (offset & 1)
 	{
-		return input_port_read(machine(), "IN1");
+		return ioport("IN1")->read();
 	}
 
 	else
 	{
-		UINT8 ret = input_port_read(machine(), "IN0");
+		UINT8 ret = ioport("IN0")->read();
 
 		if (m_potsense[0] && m_potmask[0])
 			ret |= 4;
@@ -297,7 +297,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_DIPNAME( 0x03, 0x02, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW:4,3")
diff -Nru src-old/mame/drivers/dgpix.c src/mame/drivers/dgpix.c
--- src-old/mame/drivers/dgpix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dgpix.c	2012-05-03 11:00:08.000000000 +0200
@@ -195,7 +195,7 @@
 {
 	/* burn a bunch of cycles because this is polled frequently during busy loops */
 	device_eat_cycles(&space.device(), 100);
-	return input_port_read(machine(), "VBLANK");
+	return ioport("VBLANK")->read();
 }
 
 static ADDRESS_MAP_START( cpu_map, AS_PROGRAM, 32, dgpix_state )
@@ -250,7 +250,7 @@
 
 static INPUT_PORTS_START( dgpix )
 	PORT_START("VBLANK")
-	PORT_BIT( 0x00000003, IP_ACTIVE_LOW, IPT_VBLANK ) //value 2 is used by fmaniac3
+	PORT_BIT( 0x00000003, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") //value 2 is used by fmaniac3
 	PORT_BIT( 0xfffffffc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("INPUTS")
diff -Nru src-old/mame/drivers/dietgo.c src/mame/drivers/dietgo.c
--- src-old/mame/drivers/dietgo.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/dietgo.c	2012-05-03 11:00:08.000000000 +0200
@@ -50,7 +50,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(1)
diff -Nru src-old/mame/drivers/discoboy.c src/mame/drivers/discoboy.c
--- src-old/mame/drivers/discoboy.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/discoboy.c	2012-05-03 11:00:08.000000000 +0200
@@ -560,7 +560,7 @@
 static DRIVER_INIT( discoboy )
 {
 	discoboy_state *state = machine.driver_data<discoboy_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	UINT8 *AUDIO = state->memregion("audiocpu")->base();
 
 	memset(state->m_ram_1, 0, sizeof(state->m_ram_1));
diff -Nru src-old/mame/drivers/djboy.c src/mame/drivers/djboy.c
--- src-old/mame/drivers/djboy.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/djboy.c	2012-05-03 11:00:08.000000000 +0200
@@ -347,9 +347,9 @@
 
 	switch ((m_beast_p0 >> 2) & 3)
 	{
-		case 0: return input_port_read(machine(), "IN1");
-		case 1: return input_port_read(machine(), "IN2");
-		case 2: return input_port_read(machine(), "IN0");
+		case 0: return ioport("IN1")->read();
+		case 1: return ioport("IN2")->read();
+		case 2: return ioport("IN0")->read();
 		default: return 0xff;
 	}
 }
@@ -363,8 +363,8 @@
 {
 
 	UINT8 dsw = 0;
-	UINT8 dsw1 = ~input_port_read(machine(), "DSW1");
-	UINT8 dsw2 = ~input_port_read(machine(), "DSW2");
+	UINT8 dsw1 = ~ioport("DSW1")->read();
+	UINT8 dsw2 = ~ioport("DSW2")->read();
 
 	switch ((m_beast_p0 >> 5) & 3)
 	{
@@ -522,8 +522,8 @@
 static MACHINE_START( djboy )
 {
 	djboy_state *state = machine.driver_data<djboy_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
-	UINT8 *CPU1 = machine.root_device().memregion("cpu1")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
+	UINT8 *CPU1 = state->memregion("cpu1")->base();
 	UINT8 *CPU2 = state->memregion("cpu2")->base();
 
 	state->membank("bank1")->configure_entries(0, 4,  &MAIN[0x00000], 0x2000);
diff -Nru src-old/mame/drivers/djmain.c src/mame/drivers/djmain.c
--- src-old/mame/drivers/djmain.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/djmain.c	2012-05-03 11:00:08.000000000 +0200
@@ -229,13 +229,13 @@
 READ8_MEMBER(djmain_state::inp1_r)
 {
 	static const char *const portnames[] = { "DSW3", "BTN3", "BTN2", "BTN1" };
-	return input_port_read(machine(), portnames[ offset & 0x03 ]);
+	return ioport(portnames[ offset & 0x03 ])->read();
 }
 
 READ8_MEMBER(djmain_state::inp2_r)
 {
 	static const char *const portnames[] = { "DSW1", "DSW2", "UNK2", "UNK1" };
-	return input_port_read(machine(), portnames[ offset & 0x03 ]);
+	return ioport(portnames[ offset & 0x03 ])->read();
 }
 
 READ32_MEMBER(djmain_state::turntable_r)
@@ -248,7 +248,7 @@
 		UINT8 pos;
 		int delta;
 
-		pos = input_port_read_safe(machine(), ttnames[m_turntable_select], 0);
+		pos = ioport(ttnames[m_turntable_select])->read_safe(0);
 		delta = pos - m_turntable_last_pos[m_turntable_select];
 		if (delta < -128)
 			delta += 256;
@@ -660,11 +660,11 @@
 
 #ifdef PRIORITY_EASINESS_TO_PLAY
 	#define BEATMANIA_DSW3_STAGES_OLD \
-		PORT_DIPNAME( 0x1c, 0x1c, "Normal Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Normal Mode Stages" ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
 		PORT_DIPSETTING(    0x00, "4 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -672,7 +672,7 @@
 		PORT_DIPSETTING(    0x08, "5 Stages" )
 #else
 	#define BEATMANIA_DSW3_STAGES_OLD \
-		PORT_DIPNAME( 0x1c, 0x1c, "Normal Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Normal Mode Stages" ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
 		  PORT_DIPSETTING(  0x1c, "4 Stages" ) /* duplicated setting */ \
 		  PORT_DIPSETTING(  0x0c, "4 Stages" ) /* duplicated setting */ \
@@ -681,7 +681,7 @@
 		  PORT_DIPSETTING(  0x18, "4 Stages" ) /* duplicated setting */ \
 		PORT_DIPSETTING(    0x00, "4 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -694,11 +694,11 @@
 
 #ifdef PRIORITY_EASINESS_TO_PLAY
 	#define BEATMANIA_DSW3_STAGES_MIDDLE( str ) \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 / 3 Stages" ) \
 		PORT_DIPSETTING(    0x00, "4 / 4 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 / 5 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -706,7 +706,7 @@
 		PORT_DIPSETTING(    0x08, "5 Stages" )
 #else
 	#define BEATMANIA_DSW3_STAGES_MIDDLE( str ) \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 / 3 Stages" ) \
 		  PORT_DIPSETTING(  0x1c, "4 / 4 Stages" ) /* duplicated setting */ \
 		  PORT_DIPSETTING(  0x0c, "4 / 4 Stages" ) /* duplicated setting */ \
@@ -715,7 +715,7 @@
 		  PORT_DIPSETTING(  0x18, "4 / 4 Stages" ) /* duplicated setting */ \
 		PORT_DIPSETTING(    0x00, "4 / 4 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 / 5 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -728,11 +728,11 @@
 
 #ifdef PRIORITY_EASINESS_TO_PLAY
 	#define BEATMANIA_DSW3_STAGES_NEW( str ) \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 / 2 Stages" ) \
 		PORT_DIPSETTING(    0x00, "4 / 3 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 / 3 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -740,7 +740,7 @@
 		PORT_DIPSETTING(    0x08, "5 Stages" )
 #else
 	#define BEATMANIA_DSW3_STAGES_NEW( str ) \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x10, "3 / 2 Stages" ) \
 		  PORT_DIPSETTING(  0x1c, "4 / 3 Stages" ) /* duplicated setting */ \
 		  PORT_DIPSETTING(  0x0c, "4 / 3 Stages" ) /* duplicated setting */ \
@@ -749,7 +749,7 @@
 		  PORT_DIPSETTING(  0x18, "4 / 3 Stages" ) /* duplicated setting */ \
 		PORT_DIPSETTING(    0x00, "4 / 3 Stages" ) \
 		PORT_DIPSETTING(    0x08, "5 / 3 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -853,10 +853,10 @@
 		PORT_START("DSW3") \
 		PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED ) /* bit 7,6 don't exist */ \
 		BEATMANIA_DSW3_EVENTMODE /* SW3:1 */ \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x1c, "3 / 3 Stages" ) \
 		PORT_DIPSETTING(    0x10, "4 / 4 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -869,7 +869,7 @@
 		PORT_START("DSW3") \
 		PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED ) /* bit 7,6 don't exist */ \
 		BEATMANIA_DSW3_EVENTMODE /* SW3:1 */ \
-		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, str ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x1c, "3 / 3 Stages" ) \
 		  PORT_DIPSETTING(  0x0c, "3 / 3 Stages" ) /* duplicated setting */ \
 		  PORT_DIPSETTING(  0x14, "3 / 3 Stages" ) /* duplicated setting */ \
@@ -878,7 +878,7 @@
 		  PORT_DIPSETTING(  0x08, "3 / 3 Stages" ) /* duplicated setting */ \
 		  PORT_DIPSETTING(  0x00, "3 / 3 Stages" ) /* duplicated setting */ \
 		PORT_DIPSETTING(    0x10, "4 / 4 Stages" ) \
-		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
+		PORT_DIPNAME( 0x1c, 0x1c, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:4,3,2") \
 		PORT_DIPSETTING(    0x0c, "1 Stage" ) \
 		PORT_DIPSETTING(    0x14, "2 Stages" ) \
 		PORT_DIPSETTING(    0x10, "3 Stages" ) \
@@ -914,21 +914,21 @@
 	/* "Free Hidden Songs" 3-3=On 3-6=On */
 	PORT_MODIFY("DSW3")
 	BEATMANIA_DSW3_EVENTMODE /* SW3:1 */
-	PORT_DIPNAME( 0x10, 0x10, "Unused (Used if Event Mode)" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:2")
+	PORT_DIPNAME( 0x10, 0x10, "Unused (Used if Event Mode)" ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:2")
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, "Free Hidden Songs (step1of2)" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:3")
+	PORT_DIPNAME( 0x08, 0x08, "Free Hidden Songs (step1of2)" ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:3")
 	PORT_DIPSETTING(    0x08, "No (Off)" )
 	PORT_DIPSETTING(    0x00, "Yes (On)" )
-	PORT_DIPNAME( 0x18, 0x18, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:3,2")
+	PORT_DIPNAME( 0x18, 0x18, "Event Mode Stages" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:3,2")
 	PORT_DIPSETTING(    0x18, "1 Stage" )
 	PORT_DIPSETTING(    0x08, "2 Stages" )
 	PORT_DIPSETTING(    0x10, "3 Stages" )
 	PORT_DIPSETTING(    0x00, "4 Stages" )
-	PORT_DIPNAME( 0x01, 0x01, "Free Hidden Songs (step2of2)" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW3:6")
+	PORT_DIPNAME( 0x01, 0x01, "Free Hidden Songs (step2of2)" ) PORT_CONDITION("DSW3", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW3:6")
 	PORT_DIPSETTING(    0x01, "No (Off)" )
 	PORT_DIPSETTING(    0x00, "Yes (On)" )
-	PORT_DIPNAME( 0x01, 0x01, "Unused (Used if not Event Mode)" ) PORT_CONDITION("DSW3", 0x20, PORTCOND_NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:6")
+	PORT_DIPNAME( 0x01, 0x01, "Unused (Used if not Event Mode)" ) PORT_CONDITION("DSW3", 0x20, NOTEQUALS, 0x20) PORT_DIPLOCATION("SW3:6")
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	/* "Free Hidden Songs" 3-3=On 3-6=On */
diff -Nru src-old/mame/drivers/dkong.c src/mame/drivers/dkong.c
--- src-old/mame/drivers/dkong.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dkong.c	2012-05-03 11:00:08.000000000 +0200
@@ -579,7 +579,7 @@
 	UINT8 mcustatus = latch8_bit4_q_r(m_dev_vp2, 0);
 	UINT8 r;
 
-	r = (input_port_read(machine(), "IN2") & 0xBF) | (mcustatus << 6);
+	r = (ioport("IN2")->read() & 0xBF) | (mcustatus << 6);
 	coin_counter_w(machine(), offset, r >> 7);
 	if (r & 0x10)
 		r = (r & ~0x10) | 0x80; /* service ==> coin */
@@ -592,7 +592,7 @@
 
     UINT8 r;
 
-    r = (input_port_read(machine(), "IN2") & 0xBF) | 0x40;
+    r = (ioport("IN2")->read() & 0xBF) | 0x40;
     coin_counter_w(machine(), offset, r >> 7);
     if (r & 0x10)
         r = (r & ~0x10) | 0x80; /* service ==> coin */
@@ -724,30 +724,30 @@
 
 READ8_MEMBER(dkong_state::strtheat_inputport_0_r)
 {
-    if(input_port_read(machine(), "DSW0") & 0x40)
+    if(ioport("DSW0")->read() & 0x40)
     {
         /* Joystick inputs */
-        return input_port_read(machine(), "IN0");
+        return ioport("IN0")->read();
     }
     else
     {
         /* Steering Wheel inputs */
-        return (input_port_read(machine(), "IN0") & ~3) | (input_port_read(machine(), "IN4") & 3);
+        return (ioport("IN4")->read() & 3);
     }
 }
 
 
 READ8_MEMBER(dkong_state::strtheat_inputport_1_r)
 {
-    if(input_port_read(machine(), "DSW0") & 0x40)
+    if(ioport("DSW0")->read() & 0x40)
     {
         /* Joystick inputs */
-        return input_port_read(machine(), "IN1");
+        return ioport("IN1")->read();
     }
     else
     {
         /* Steering Wheel inputs */
-        return (input_port_read(machine(), "IN1") & ~3) | (input_port_read(machine(), "IN5") & 3);
+        return (ioport("IN5")->read() & 3);
     }
 }
 
@@ -1196,7 +1196,7 @@
     PORT_DIPSETTING(    0x0c, "80000" )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1240,7 +1240,7 @@
     PORT_SERVICE( 0x80, IP_ACTIVE_HIGH )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1273,7 +1273,7 @@
     PORT_DIPUNKNOWN_DIPLOC( 0x08, 0x00, "SW1:!4" )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1292,7 +1292,7 @@
     PORT_DIPUNKNOWN_DIPLOC( 0x08, 0x00, "SW1:!4" )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1326,7 +1326,7 @@
     PORT_DIPSETTING(    0x0c, "3" )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1424,7 +1424,7 @@
     PORT_DIPSETTING(    0xc0, DEF_STR( 1C_4C ) )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
@@ -1457,7 +1457,7 @@
     PORT_DIPUNUSED_DIPLOC( 0x80, 0x80, "SW1:!8" )
 
     PORT_START("SENSE") /* Sense */
-    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+    PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
     PORT_INCLUDE( dkong_config )
 INPUT_PORTS_END
diff -Nru src-old/mame/drivers/dlair.c src/mame/drivers/dlair.c
--- src-old/mame/drivers/dlair.c	2012-04-19 09:47:35.000000000 +0200
+++ src/mame/drivers/dlair.c	2012-05-03 11:00:08.000000000 +0200
@@ -260,7 +260,7 @@
 	/* determine the laserdisc player from the DIP switches */
 	if (state->m_laserdisc_type == LASERDISC_TYPE_VARIABLE)
 	{
-		int newtype = (input_port_read(machine, "DSW2") & 0x08) ? LASERDISC_TYPE_PIONEER_LDV1000 : LASERDISC_TYPE_PIONEER_PR7820;
+		int newtype = (state->ioport("DSW2")->read() & 0x08) ? LASERDISC_TYPE_PIONEER_LDV1000 : LASERDISC_TYPE_PIONEER_PR7820;
 		laserdisc_set_type(state->m_laserdisc, newtype);
 	}
 #endif
@@ -555,14 +555,14 @@
 	PORT_DIPSETTING(    0x40, "PAYG3" )
 	PORT_DIPSETTING(    0x60, "PAYG4" )
 	PORT_DIPNAME( 0x90, 0x10, DEF_STR( Difficulty ) ) PORT_DIPLOCATION("B:8,5")
-	PORT_DIPSETTING(	0x00, "Increase after 5" ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x10, "Increase after 9" ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x00, DEF_STR( Hard ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x10, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
+	PORT_DIPSETTING(	0x00, "Increase after 5" ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x10, "Increase after 9" ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x00, DEF_STR( Hard ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x10, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
 
 	PORT_START("CONTROLS")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )
@@ -657,14 +657,14 @@
 	PORT_DIPSETTING(    0x40, "PAYG3" )
 	PORT_DIPSETTING(    0x60, "PAYG4" )
 	PORT_DIPNAME( 0x90, 0x10, DEF_STR( Difficulty ) ) PORT_DIPLOCATION("B:8,5s")
-	PORT_DIPSETTING(	0x00, "Increase after 5" ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x10, "Increase after 9" ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x00, DEF_STR( Hard ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x10, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
-	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x04)
+	PORT_DIPSETTING(	0x00, "Increase after 5" ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x10, "Increase after 9" ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x00, DEF_STR( Hard ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x10, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x80, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
+	PORT_DIPSETTING(	0x90, DEF_STR( Easy ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x04)
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/dmndrby.c src/mame/drivers/dmndrby.c
--- src-old/mame/drivers/dmndrby.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dmndrby.c	2012-05-03 11:00:08.000000000 +0200
@@ -91,14 +91,14 @@
 {
 	switch(offset & 7)
 	{
-		case 0: return input_port_read(machine(), "IN0");
-		case 1: return input_port_read(machine(), "IN1");
-		case 2: return input_port_read(machine(), "IN2");
-		case 3: return input_port_read(machine(), "IN3");
-		case 4: return input_port_read(machine(), "IN4");
-		case 5: return input_port_read(machine(), "IN5");
-		case 6: return input_port_read(machine(), "IN6");
-		case 7: return input_port_read(machine(), "IN7");
+		case 0: return ioport("IN0")->read();
+		case 1: return ioport("IN1")->read();
+		case 2: return ioport("IN2")->read();
+		case 3: return ioport("IN3")->read();
+		case 4: return ioport("IN4")->read();
+		case 5: return ioport("IN5")->read();
+		case 6: return ioport("IN6")->read();
+		case 7: return ioport("IN7")->read();
 	}
 
 	return 0xff;
@@ -209,14 +209,14 @@
 	PORT_DIPSETTING(    0x04, "480p (cash + tokens)" )
 	PORT_DIPSETTING(    0x00, "600p (cash + tokens)" )
 	PORT_DIPNAME( 0x30, 0x00, "Percentage Payout" )
-	PORT_DIPSETTING(    0x00, "76%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_LESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x10, "80%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_LESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x20, "86%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_LESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x30, "88%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_LESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x00, "78%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_NOTLESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x10, "82%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_NOTLESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x20, "86%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_NOTLESSTHAN, 0x80)
-	PORT_DIPSETTING(    0x30, "90%" )	PORT_CONDITION("DSW1", 0xc0, PORTCOND_NOTLESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x00, "76%" )	PORT_CONDITION("DSW1", 0xc0, LESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x10, "80%" )	PORT_CONDITION("DSW1", 0xc0, LESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x20, "86%" )	PORT_CONDITION("DSW1", 0xc0, LESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x30, "88%" )	PORT_CONDITION("DSW1", 0xc0, LESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x00, "78%" )	PORT_CONDITION("DSW1", 0xc0, NOTLESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x10, "82%" )	PORT_CONDITION("DSW1", 0xc0, NOTLESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x20, "86%" )	PORT_CONDITION("DSW1", 0xc0, NOTLESSTHAN, 0x80)
+	PORT_DIPSETTING(    0x30, "90%" )	PORT_CONDITION("DSW1", 0xc0, NOTLESSTHAN, 0x80)
 	PORT_DIPNAME( 0xc0, 0x80, "Price Per Game" )
 	PORT_DIPSETTING(    0x00, "2p" )
 	PORT_DIPSETTING(    0x40, "5p" )
diff -Nru src-old/mame/drivers/dogfgt.c src/mame/drivers/dogfgt.c
--- src-old/mame/drivers/dogfgt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/dogfgt.c	2012-05-03 11:00:08.000000000 +0200
@@ -160,7 +160,7 @@
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 /*  Manual shows:
 
diff -Nru src-old/mame/drivers/dooyong.c src/mame/drivers/dooyong.c
--- src-old/mame/drivers/dooyong.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dooyong.c	2012-05-03 11:00:08.000000000 +0200
@@ -327,23 +327,23 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SWA:5,6")
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SWA:7,8")
-	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSWA", 0x02, PORTCOND_NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSWA", 0x02, NOTEQUALS, 0x02)
 
 	PORT_START("DSWB")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )		PORT_DIPLOCATION("SWB:1,2")
@@ -413,23 +413,23 @@
 	PORT_DIPSETTING(      0x0008, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SWA:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SWA:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
 	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) )		PORT_DIPLOCATION("SWB:1,2")
 	PORT_DIPSETTING(      0x0000, "1" )
 	PORT_DIPSETTING(      0x0200, "2" )
@@ -536,7 +536,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_VBLANK )	/* ??? */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ??? */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -605,14 +605,14 @@
 
 	PORT_MODIFY("DSW")
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SWA:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW", 0x0002, NOTEQUALS, 0x0002)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( superx )
@@ -1282,9 +1282,46 @@
 	ROM_LOAD16_BYTE( "11.n9",        0x00001, 0x10000, CRC(7dfe4a9c) SHA1(40982b5b266e4a928544ab5ec330080935588c57) )
 ROM_END
 
+ROM_START( gulfstrma )
+	ROM_REGION( 0x30000, "maincpu", 0 )	/* 64k for code + 128k for banks */
+	ROM_LOAD( "1.bin",       0x00000, 0x20000, CRC(d04fb06b) SHA1(bdf09ab692f90e3dea815605998f75b6478c8047) )
+	ROM_RELOAD(              0x10000, 0x20000 )				/* banked at 0x8000-0xbfff */
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )	/* sound */
+	ROM_LOAD( "3.c5",         0x00000, 0x10000, CRC(c029b015) SHA1(86f8d4f6560cb99e25e8e8baf72dde743a7b9c4c) )
+
+	ROM_REGION( 0x8000, "gfx1", 0 )	/* chars */
+	ROM_LOAD( "2.s4",         0x0000, 0x8000, CRC(c2d65a25) SHA1(a198b42c0737b253aca5bab6fb58ab561ccc1d5c) )	/* empty */
+	ROM_CONTINUE(             0x0000, 0x8000 )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )	/* sprites */
+	ROM_LOAD16_BYTE( "14.b1",        0x00000, 0x20000, CRC(67bdf73d) SHA1(3e357448b6f255fdec731f143afa3d3149523ed2) )
+	ROM_LOAD16_BYTE( "16.c1",        0x00001, 0x20000, CRC(7770a76f) SHA1(4f9f5245f59008b26ed60e636285ea85271744e7) )
+	ROM_LOAD16_BYTE( "15.b1",        0x40000, 0x20000, CRC(84803f7e) SHA1(74b694c0d20c5b016b9d7258b0296229972151d5) )
+	ROM_LOAD16_BYTE( "17.e1",        0x40001, 0x20000, CRC(94706500) SHA1(8f4a6f7ce20b1b50577271601c2c2632b5a2292c) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )	/* tiles */
+	ROM_LOAD16_BYTE( "4.d8",         0x00000, 0x20000, CRC(858fdbb6) SHA1(4c317ab6069a8509287d3df88cf4272f512a40a3) )
+	ROM_LOAD16_BYTE( "5.b9",         0x00001, 0x20000, CRC(c0a552e8) SHA1(31dcb14eb8815c609b0bf4d5f1ea17b26ab18aec) )
+	ROM_LOAD16_BYTE( "6.d8",         0x40000, 0x20000, CRC(20eedda3) SHA1(8c8b1284e07f5380037f8431f2649aa99fd47542) )
+	ROM_LOAD16_BYTE( "7.d9",         0x40001, 0x20000, CRC(294f8c40) SHA1(b7afb87510ab52682151ff2b13029427487589ec) )
+
+	ROM_REGION( 0x40000, "gfx4", 0 )	/* tiles */
+	ROM_LOAD16_BYTE( "12.bin",       0x00000, 0x20000, CRC(3e3d3b57) SHA1(398a6cac7144ba7bacaa36c593bcb4b3c051eb0f) )
+	ROM_LOAD16_BYTE( "13.bin",       0x00001, 0x20000, CRC(66fcce80) SHA1(6ab2b7cd49447d374cde40b98db0a6209dcad461) )
+
+	ROM_REGION( 0x20000, "gfx5", 0 )	/* background tilemaps */
+	ROM_LOAD16_BYTE( "8.e8",         0x00000, 0x10000, CRC(8d7f4693) SHA1(a7c8573d9e54c8230decc3e88f76ae729d77b096) )
+	ROM_LOAD16_BYTE( "9.e9",         0x00001, 0x10000, CRC(34d440c4) SHA1(74b0e15e75f62106177234b6ea54a5d312628802) )
+
+	ROM_REGION( 0x20000, "gfx6", 0 )	/* fg tilemaps */
+	ROM_LOAD16_BYTE( "10.bin",       0x00000, 0x10000, CRC(08149140) SHA1(ff0094883ca0fc81bae991d6ea62d0064d6f7c47) )
+	ROM_LOAD16_BYTE( "11.bin",       0x00001, 0x10000, CRC(2ed7545b) SHA1(6a70743bbb03ef694310f2b5531f384209db62a1) )
+ROM_END
+
 ROM_START( gulfstrmm )
 	ROM_REGION( 0x30000, "maincpu", 0 )	/* 64k for code + 128k for banks */
-	ROM_LOAD( "18.1",         0x00000, 0x20000, CRC(d38e2667) SHA1(3690d708c7be85871d6bb32a774d711a30782126) )
+	ROM_LOAD( "18.l4",        0x00000, 0x20000, CRC(d38e2667) SHA1(3690d708c7be85871d6bb32a774d711a30782126) )
 	ROM_RELOAD(               0x10000, 0x20000 )				/* banked at 0x8000-0xbfff */
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* sound */
@@ -1902,7 +1939,8 @@
 
 GAME( 1990, lastday,  0,        lastday,  lastday,  0, ROT270, "Dooyong",  "The Last Day (set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1990, lastdaya, lastday,  lastday,  lastday,  0, ROT270, "Dooyong",  "The Last Day (set 2)", GAME_SUPPORTS_SAVE )
-GAME( 1991, gulfstrm, 0,        gulfstrm, gulfstrm, 0, ROT270, "Dooyong",  "Gulf Storm",            GAME_SUPPORTS_SAVE )
+GAME( 1991, gulfstrm, 0,        gulfstrm, gulfstrm, 0, ROT270, "Dooyong",  "Gulf Storm (set 1)",   GAME_SUPPORTS_SAVE )
+GAME( 1991, gulfstrma,gulfstrm, gulfstrm, gulfstrm, 0, ROT270, "Dooyong",  "Gulf Storm (set 2)",   GAME_SUPPORTS_SAVE )
 GAME( 1991, gulfstrmm,gulfstrm, gulfstrm, gulfstrm, 0, ROT270, "Dooyong (Media Shoji license)", "Gulf Storm (Media Shoji)",  GAME_SUPPORTS_SAVE )
 GAME( 1991, pollux,   0,        pollux,   pollux,   0, ROT270, "Dooyong",  "Pollux (set 1)",       GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
 GAME( 1991, polluxa,  pollux,   pollux,   pollux,   0, ROT270, "Dooyong",  "Pollux (set 2)",       GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/dragrace.c src/mame/drivers/dragrace.c
--- src-old/mame/drivers/dragrace.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/dragrace.c	2012-05-03 11:00:08.000000000 +0200
@@ -18,7 +18,7 @@
 
 	for (i = 0; i < 2; i++)
 	{
-		switch (input_port_read(timer.machine(), portnames[i]))
+		switch (timer.machine().root_device().ioport(portnames[i])->read())
 		{
 		case 0x01: state->m_gear[i] = 1; break;
 		case 0x02: state->m_gear[i] = 2; break;
@@ -29,7 +29,7 @@
 	}
 
 	/* watchdog is disabled during service mode */
-	timer.machine().watchdog_enable(input_port_read(timer.machine(), "IN0") & 0x20);
+	timer.machine().watchdog_enable(timer.machine().root_device().ioport("IN0")->read() & 0x20);
 }
 
 
@@ -112,7 +112,7 @@
 
 READ8_MEMBER(dragrace_state::dragrace_input_r)
 {
-	int val = input_port_read(machine(), "IN2");
+	int val = ioport("IN2")->read();
 	static const char *const portnames[] = { "IN0", "IN1" };
 
 	UINT8 maskA = 1 << (offset % 8);
@@ -122,7 +122,7 @@
 
 	for (i = 0; i < 2; i++)
 	{
-		int in = input_port_read(machine(), portnames[i]);
+		int in = ioport(portnames[i])->read();
 
 		if (m_gear[i] != 0)
 			in &= ~(1 << m_gear[i]);
@@ -145,7 +145,7 @@
 
 	for (i = 0; i < 2; i++)
 	{
-		int dial = input_port_read(machine(), dialnames[i]);
+		int dial = ioport(dialnames[i])->read();
 
 		bitA[i] = ((dial + 1) / 2) & 1;
 		bitB[i] = ((dial + 0) / 2) & 1;
diff -Nru src-old/mame/drivers/dribling.c src/mame/drivers/dribling.c
--- src-old/mame/drivers/dribling.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/dribling.c	2012-05-03 11:00:08.000000000 +0200
@@ -68,11 +68,11 @@
 
 	/* low value in the given bit selects */
 	if (!(state->m_input_mux & 0x01))
-		return input_port_read(device->machine(), "MUX0");
+		return state->ioport("MUX0")->read();
 	else if (!(state->m_input_mux & 0x02))
-		return input_port_read(device->machine(), "MUX1");
+		return state->ioport("MUX1")->read();
 	else if (!(state->m_input_mux & 0x04))
-		return input_port_read(device->machine(), "MUX2");
+		return state->ioport("MUX2")->read();
 	return 0xff;
 }
 
diff -Nru src-old/mame/drivers/drw80pkr.c src/mame/drivers/drw80pkr.c
--- src-old/mame/drivers/drw80pkr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/drw80pkr.c	2012-05-03 11:00:08.000000000 +0200
@@ -284,7 +284,7 @@
 		{
 
 			// TODO: Get Input Port Values
-			kbdin = ((input_port_read(machine(), "IN1") & 0xaf ) << 8) + input_port_read(machine(), "IN0");
+			kbdin = ((ioport("IN1")->read() & 0xaf ) << 8) + ioport("IN0")->read();
 
 			switch (kbdin)
 			{
diff -Nru src-old/mame/drivers/dunhuang.c src/mame/drivers/dunhuang.c
--- src-old/mame/drivers/dunhuang.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dunhuang.c	2012-05-03 11:00:08.000000000 +0200
@@ -432,7 +432,7 @@
 
 READ8_MEMBER(dunhuang_state::dunhuang_service_r)
 {
-	return input_port_read(machine(), "SERVICE")
+	return ioport("SERVICE")->read()
 	 | ((m_hopper && !(machine().primary_screen->frame_number() % 10)) ? 0x00 : 0x08)	// bit 3: hopper sensor
 	 | 0x80																// bit 7 low -> tiles block transferrer busy
 	;
@@ -441,21 +441,21 @@
 static READ8_DEVICE_HANDLER( dunhuang_dsw_r )
 {
 	dunhuang_state *state = device->machine().driver_data<dunhuang_state>();
-	if (!(state->m_input & 0x01))	return input_port_read(device->machine(), "DSW1");
-	if (!(state->m_input & 0x02))	return input_port_read(device->machine(), "DSW2");
-	if (!(state->m_input & 0x04))	return input_port_read(device->machine(), "DSW3");
-	if (!(state->m_input & 0x08))	return input_port_read(device->machine(), "DSW4");
-	if (!(state->m_input & 0x10))	return input_port_read(device->machine(), "DSW5");
+	if (!(state->m_input & 0x01))	return state->ioport("DSW1")->read();
+	if (!(state->m_input & 0x02))	return state->ioport("DSW2")->read();
+	if (!(state->m_input & 0x04))	return state->ioport("DSW3")->read();
+	if (!(state->m_input & 0x08))	return state->ioport("DSW4")->read();
+	if (!(state->m_input & 0x10))	return state->ioport("DSW5")->read();
 	logerror("%s: warning, unknown dsw bits read, input = %02x\n", device->machine().describe_context(), state->m_input);
 	return 0xff;
 }
 READ8_MEMBER(dunhuang_state::dunhuang_input_r)
 {
-	if (!(m_input & 0x01))	return input_port_read(machine(), "IN0");
-	if (!(m_input & 0x02))	return input_port_read(machine(), "IN1");
-	if (!(m_input & 0x04))	return input_port_read(machine(), "IN2");
-	if (!(m_input & 0x08))	return input_port_read(machine(), "IN3");
-	if (!(m_input & 0x10))	return input_port_read(machine(), "IN4");
+	if (!(m_input & 0x01))	return ioport("IN0")->read();
+	if (!(m_input & 0x02))	return ioport("IN1")->read();
+	if (!(m_input & 0x04))	return ioport("IN2")->read();
+	if (!(m_input & 0x08))	return ioport("IN3")->read();
+	if (!(m_input & 0x10))	return ioport("IN4")->read();
 	logerror("%s: warning, unknown input bits read, input = %02x\n", machine().describe_context(), m_input);
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/dwarfd.c src/mame/drivers/dwarfd.c
--- src-old/mame/drivers/dwarfd.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dwarfd.c	2012-05-03 11:00:08.000000000 +0200
@@ -1290,7 +1290,7 @@
 	UINT8 *src, *dst;
 
 	/* expand gfx roms */
-	src = machine.root_device().memregion("gfx1")->base();
+	src = state->memregion("gfx1")->base();
 	dst = state->memregion("gfx2")->base();
 
 	for (i = 0; i < 0x4000; i++)
diff -Nru src-old/mame/drivers/dynax.c src/mame/drivers/dynax.c
--- src-old/mame/drivers/dynax.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/dynax.c	2012-05-03 11:00:08.000000000 +0200
@@ -235,11 +235,11 @@
 	int res = 0x3f;
 
 	/* the game reads all rows at once (keyb = 0) to check if a key is pressed */
-	if (!BIT(m_keyb, 0)) res &= input_port_read(machine(), "KEY0");
-	if (!BIT(m_keyb, 1)) res &= input_port_read(machine(), "KEY1");
-	if (!BIT(m_keyb, 2)) res &= input_port_read(machine(), "KEY2");
-	if (!BIT(m_keyb, 3)) res &= input_port_read(machine(), "KEY3");
-	if (!BIT(m_keyb, 4)) res &= input_port_read(machine(), "KEY4");
+	if (!BIT(m_keyb, 0)) res &= ioport("KEY0")->read();
+	if (!BIT(m_keyb, 1)) res &= ioport("KEY1")->read();
+	if (!BIT(m_keyb, 2)) res &= ioport("KEY2")->read();
+	if (!BIT(m_keyb, 3)) res &= ioport("KEY3")->read();
+	if (!BIT(m_keyb, 4)) res &= ioport("KEY4")->read();
 
 	return res;
 }
@@ -249,11 +249,11 @@
 	int res = 0x3f;
 
 	/* the game reads all rows at once (keyb = 0) to check if a key is pressed */
-	if (!BIT(m_keyb, 0)) res &= input_port_read(machine(), "KEY5");
-	if (!BIT(m_keyb, 1)) res &= input_port_read(machine(), "KEY6");
-	if (!BIT(m_keyb, 2)) res &= input_port_read(machine(), "KEY7");
-	if (!BIT(m_keyb, 3)) res &= input_port_read(machine(), "KEY8");
-	if (!BIT(m_keyb, 4)) res &= input_port_read(machine(), "KEY9");
+	if (!BIT(m_keyb, 0)) res &= ioport("KEY5")->read();
+	if (!BIT(m_keyb, 1)) res &= ioport("KEY6")->read();
+	if (!BIT(m_keyb, 2)) res &= ioport("KEY7")->read();
+	if (!BIT(m_keyb, 3)) res &= ioport("KEY8")->read();
+	if (!BIT(m_keyb, 4)) res &= ioport("KEY9")->read();
 
 	return res;
 }
@@ -621,7 +621,7 @@
 
 READ8_MEMBER(dynax_state::hjingi_keyboard_1_r)
 {
-	return hanamai_keyboard_1_r(space, 0) | input_port_read(machine(), "BET");
+	return hanamai_keyboard_1_r(space, 0) | ioport("BET")->read();
 }
 
 static ADDRESS_MAP_START( hjingi_mem_map, AS_PROGRAM, 8, dynax_state )
@@ -715,7 +715,7 @@
 			switch (m_input_sel)
 			{
 			case 0x00:
-				return input_port_read(machine(), "COINS");	// coins
+				return ioport("COINS")->read();	// coins
 
 			case 0x02:
 				return 0xff;	// bit 7 must be 1. Bit 2?
@@ -732,12 +732,12 @@
 			// player 2
 			case 0x01:	//quiztvqq
 			case 0x81:
-				return input_port_read(machine(), keynames1[m_keyb++]);
+				return ioport(keynames1[m_keyb++])->read();
 
 			// player 1
 			case 0x02:	//quiztvqq
 			case 0x82:
-				return input_port_read(machine(), keynames0[m_keyb++]);
+				return ioport(keynames0[m_keyb++])->read();
 
 			default:
 				return 0xff;
@@ -1050,7 +1050,7 @@
 
 READ8_MEMBER(dynax_state::mjelctrn_keyboard_1_r)
 {
-	return (hanamai_keyboard_1_r(space, 0) & 0x3f) | (input_port_read(machine(), "FAKE") ? 0x40 : 0);
+	return (hanamai_keyboard_1_r(space, 0) & 0x3f) | (ioport("FAKE")->read() ? 0x40 : 0);
 }
 
 READ8_MEMBER(dynax_state::mjelctrn_dsw_r)
@@ -1058,7 +1058,7 @@
 	int dsw = (m_keyb & 0xc0) >> 6;
 	static const char *const dswnames[] = { "DSW0", "DSW1", "DSW3", "DSW4" };
 
-	return input_port_read(machine(), dswnames[dsw]);
+	return ioport(dswnames[dsw])->read();
 }
 
 WRITE8_MEMBER(dynax_state::mjelctrn_blitter_ack_w)
@@ -1124,11 +1124,11 @@
 static READ8_DEVICE_HANDLER( htengoku_dsw_r )
 {
 	dynax_state *state = device->machine().driver_data<dynax_state>();
-	if (!BIT(state->m_dsw_sel, 0))	return input_port_read(device->machine(), "DSW0");
-	if (!BIT(state->m_dsw_sel, 1))	return input_port_read(device->machine(), "DSW1");
-	if (!BIT(state->m_dsw_sel, 2))	return input_port_read(device->machine(), "DSW2");
-	if (!BIT(state->m_dsw_sel, 3))	return input_port_read(device->machine(), "DSW3");
-	if (!BIT(state->m_dsw_sel, 4))	return input_port_read(device->machine(), "DSW4");
+	if (!BIT(state->m_dsw_sel, 0))	return state->ioport("DSW0")->read();
+	if (!BIT(state->m_dsw_sel, 1))	return state->ioport("DSW1")->read();
+	if (!BIT(state->m_dsw_sel, 2))	return state->ioport("DSW2")->read();
+	if (!BIT(state->m_dsw_sel, 3))	return state->ioport("DSW3")->read();
+	if (!BIT(state->m_dsw_sel, 4))	return state->ioport("DSW4")->read();
 	logerror("%s: warning, unknown bits read, dsw_sel = %02x\n", device->machine().describe_context(), state->m_dsw_sel);
 
 	return 0xff;
@@ -1165,8 +1165,8 @@
 
 	switch (m_input_sel)
 	{
-		case 0x81:	return input_port_read(machine(), keynames1[m_keyb++]);
-		case 0x82:	return input_port_read(machine(), keynames0[m_keyb++]);
+		case 0x81:	return ioport(keynames1[m_keyb++])->read();
+		case 0x82:	return ioport(keynames0[m_keyb++])->read();
 		case 0x0d:	return 0xff;	// unused
 	}
 	logerror("%04x: input_r with select = %02x\n", cpu_get_pc(&space.device()), m_input_sel);
@@ -1178,7 +1178,7 @@
 
 	switch (m_input_sel)
 	{
-		case 0x00:	return input_port_read(machine(), "COINS");
+		case 0x00:	return ioport("COINS")->read();
 		case 0x01:	return 0xff;	//?
 		case 0x02:	return 0xbf | ((m_hopper && !(machine().primary_screen->frame_number() % 10)) ? 0 : (1 << 6));	// bit 7 = blitter busy, bit 6 = hopper
 		case 0x03:	return m_coins;
@@ -1290,7 +1290,7 @@
 			switch (m_input_sel)
 			{
 				case 0x00:
-					return input_port_read(machine(), "COINS");	// coins
+					return ioport("COINS")->read();	// coins
 
 				default:
 					logerror("%04x: unmapped ip_sel=%02x read from offs %x\n", cpu_get_pc(&space.device()), m_input_sel, offset);
@@ -1309,13 +1309,13 @@
 				case 0x81:
 					if (m_keyb >= 5)
 						logerror("%04x: unmapped keyb=%02x read\n", cpu_get_pc(&space.device()), m_keyb);
-					return 0xff;//input_port_read(machine(), keynames1[m_keyb++]);
+					return 0xff;//ioport(keynames1[m_keyb++])->read();
 
 				// player 1
 				case 0x82:
 					if (m_keyb >= 5)
 						logerror("%04x: unmapped keyb=%02x read\n", cpu_get_pc(&space.device()), m_keyb);
-					return input_port_read(machine(), keynames0[m_keyb++]);
+					return ioport(keynames0[m_keyb++])->read();
 
 				default:
 					logerror("%04x: unmapped ip_sel=%02x read from offs %x\n", cpu_get_pc(&space.device()), m_input_sel, offset);
@@ -1337,11 +1337,11 @@
 {
 	dynax_state *state = device->machine().driver_data<dynax_state>();
 
-	if (!BIT(state->m_dsw_sel, 0)) return input_port_read(device->machine(), "DSW0");
-	if (!BIT(state->m_dsw_sel, 1)) return input_port_read(device->machine(), "DSW1");
-	if (!BIT(state->m_dsw_sel, 2)) return input_port_read(device->machine(), "DSW2");
-	if (!BIT(state->m_dsw_sel, 3)) return input_port_read(device->machine(), "DSW3");
-	if (!BIT(state->m_dsw_sel, 4)) return input_port_read(device->machine(), "DSW4");
+	if (!BIT(state->m_dsw_sel, 0)) return state->ioport("DSW0")->read();
+	if (!BIT(state->m_dsw_sel, 1)) return state->ioport("DSW1")->read();
+	if (!BIT(state->m_dsw_sel, 2)) return state->ioport("DSW2")->read();
+	if (!BIT(state->m_dsw_sel, 3)) return state->ioport("DSW3")->read();
+	if (!BIT(state->m_dsw_sel, 4)) return state->ioport("DSW4")->read();
 	logerror("%s: unmapped dsw %02x read\n", device->machine().describe_context(), state->m_dsw_sel);
 
 	return 0xff;
@@ -1533,11 +1533,11 @@
 {
 	int res = 0x3f;
 
-	if (!BIT(m_keyb, 0)) res &= input_port_read(machine(), "KEY0");
-	if (!BIT(m_keyb, 1)) res &= input_port_read(machine(), "KEY1");
-	if (!BIT(m_keyb, 2)) res &= input_port_read(machine(), "KEY2");
-	if (!BIT(m_keyb, 3)) res &= input_port_read(machine(), "KEY3");
-	if (!BIT(m_keyb, 4)) res &= input_port_read(machine(), "KEY4");
+	if (!BIT(m_keyb, 0)) res &= ioport("KEY0")->read();
+	if (!BIT(m_keyb, 1)) res &= ioport("KEY1")->read();
+	if (!BIT(m_keyb, 2)) res &= ioport("KEY2")->read();
+	if (!BIT(m_keyb, 3)) res &= ioport("KEY3")->read();
+	if (!BIT(m_keyb, 4)) res &= ioport("KEY4")->read();
 
 	return res;
 }
@@ -1545,14 +1545,14 @@
 {
 	int res = 0x3f;
 
-	if (!BIT(m_keyb, 0)) res &= input_port_read(machine(), "KEY5");
-	if (!BIT(m_keyb, 1)) res &= input_port_read(machine(), "KEY6");
-	if (!BIT(m_keyb, 2)) res &= input_port_read(machine(), "KEY7");
-	if (!BIT(m_keyb, 3)) res &= input_port_read(machine(), "KEY8");
-	if (!BIT(m_keyb, 4)) res &= input_port_read(machine(), "KEY9");
+	if (!BIT(m_keyb, 0)) res &= ioport("KEY5")->read();
+	if (!BIT(m_keyb, 1)) res &= ioport("KEY6")->read();
+	if (!BIT(m_keyb, 2)) res &= ioport("KEY7")->read();
+	if (!BIT(m_keyb, 3)) res &= ioport("KEY8")->read();
+	if (!BIT(m_keyb, 4)) res &= ioport("KEY9")->read();
 
 	// bit 6
-	res |= input_port_read(machine(), "BET");
+	res |= ioport("BET")->read();
 
 	// bit 7 = blitter busy
 
@@ -1586,13 +1586,13 @@
 
 	switch (offset + 0x8000)
 	{
-		case 0x8061:	return input_port_read(machine(), "COINS");
+		case 0x8061:	return ioport("COINS")->read();
 		case 0x8062:	return gekisha_keyboard_1_r(space, 0);
 		case 0x8063:	return gekisha_keyboard_0_r(space, 0);
-		case 0x8064:	return input_port_read(machine(), "DSW1");
-		case 0x8065:	return input_port_read(machine(), "DSW3");
-		case 0x8066:	return input_port_read(machine(), "DSW4");
-		case 0x8067:	return input_port_read(machine(), "DSW2");
+		case 0x8064:	return ioport("DSW1")->read();
+		case 0x8065:	return ioport("DSW3")->read();
+		case 0x8066:	return ioport("DSW4")->read();
+		case 0x8067:	return ioport("DSW2")->read();
 	}
 
 	logerror("%04x: unmapped offset %04X read with rombank=%02X\n",cpu_get_pc(&space.device()), offset, m_rombank);
@@ -4630,7 +4630,7 @@
 static MACHINE_START( jantouki )
 {
 	dynax_state *state = machine.driver_data<dynax_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
 	UINT8 *SOUND = state->memregion("soundcpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 0x10, &MAIN[0x8000],  0x8000);
diff -Nru src-old/mame/drivers/dynduke.c src/mame/drivers/dynduke.c
--- src-old/mame/drivers/dynduke.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/dynduke.c	2012-05-03 11:00:08.000000000 +0200
@@ -139,18 +139,18 @@
 	PORT_DIPNAME( 0x0001, 0x0001, "Coin Mode" ) PORT_DIPLOCATION("SW1:1")
 	PORT_DIPSETTING(      0x0001, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
-	PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:2,3") PORT_CONDITION("DSW", 0x0001, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:2,3") PORT_CONDITION("DSW", 0x0001, EQUALS, 0x0000)
 	PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0006, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x0018, 0x0008, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:4,5") PORT_CONDITION("DSW", 0x0001, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPNAME( 0x0018, 0x0008, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:4,5") PORT_CONDITION("DSW", 0x0001, EQUALS, 0x0000)
 	PORT_DIPSETTING(      0x0018, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:2,3,4,5") PORT_CONDITION("DSW", 0x0001, PORTCOND_EQUALS, 0x0001)
+	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:2,3,4,5") PORT_CONDITION("DSW", 0x0001, EQUALS, 0x0001)
 	PORT_DIPSETTING(      0x0018, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(      0x001a, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x001c, DEF_STR( 2C_1C ) )
diff -Nru src-old/mame/drivers/embargo.c src/mame/drivers/embargo.c
--- src-old/mame/drivers/embargo.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/embargo.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,7 +72,7 @@
 
 READ8_MEMBER(embargo_state::input_port_bit_r)
 {
-	return (input_port_read(machine(), "IN1") << (7 - m_input_select)) & 0x80;
+	return (ioport("IN1")->read() << (7 - m_input_select)) & 0x80;
 }
 
 
@@ -97,14 +97,14 @@
 
 	if (m_dial_enable_1 && !m_dial_enable_2)
 	{
-		lo = input_port_read(machine(), "DIAL0");
-		hi = input_port_read(machine(), "DIAL1");
+		lo = ioport("DIAL0")->read();
+		hi = ioport("DIAL1")->read();
 	}
 
 	if (m_dial_enable_2 && !m_dial_enable_1)
 	{
-		lo = input_port_read(machine(), "DIAL2");
-		hi = input_port_read(machine(), "DIAL3");
+		lo = ioport("DIAL2")->read();
+		hi = ioport("DIAL3")->read();
 	}
 
 	lo = 12 * lo / 256;
diff -Nru src-old/mame/drivers/enigma2.c src/mame/drivers/enigma2.c
--- src-old/mame/drivers/enigma2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/enigma2.c	2012-05-03 11:00:08.000000000 +0200
@@ -365,7 +365,7 @@
 		if (m_protection_data != 0xff)
 			ret = m_protection_data ^ 0x88;
 		else
-			ret = input_port_read(machine(), "DSW");
+			ret = ioport("DSW")->read();
 		break;
 
 	case 0x02:
@@ -413,22 +413,22 @@
 
 WRITE8_MEMBER(enigma2_state::enigma2_flip_screen_w)
 {
-	m_flip_screen = ((data >> 5) & 0x01) && ((input_port_read(machine(), "DSW") & 0x20) == 0x20);
+	m_flip_screen = ((data >> 5) & 0x01) && ((ioport("DSW")->read() & 0x20) == 0x20);
 }
 
 
 CUSTOM_INPUT_MEMBER(enigma2_state::p1_controls_r)
 {
-	return input_port_read(machine(), "P1CONTROLS");
+	return ioport("P1CONTROLS")->read();
 }
 
 
 CUSTOM_INPUT_MEMBER(enigma2_state::p2_controls_r)
 {
 	if (m_flip_screen)
-		return input_port_read(machine(), "P2CONTROLS");
+		return ioport("P2CONTROLS")->read();
 	else
-		return input_port_read(machine(), "P1CONTROLS");
+		return ioport("P1CONTROLS")->read();
 }
 
 
diff -Nru src-old/mame/drivers/eolith.c src/mame/drivers/eolith.c
--- src-old/mame/drivers/eolith.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/eolith.c	2012-05-03 11:00:08.000000000 +0200
@@ -112,7 +112,7 @@
     */
 	eolith_speedup_read(&space);
 
-	return (input_port_read(machine(), "IN0") & ~0x300) | (machine().rand() & 0x300);
+	return (ioport("IN0")->read() & ~0x300) | (machine().rand() & 0x300);
 }
 
 WRITE32_MEMBER(eolith_state::systemcontrol_w)
@@ -121,7 +121,7 @@
 	coin_counter_w(machine(), 0, data & m_coin_counter_bit);
 	set_led_status(machine(), 0, data & 1);
 
-	input_port_write(machine(), "EEPROMOUT", data, 0xff);
+	ioport("EEPROMOUT")->write(data, 0xff);
 
 	// bit 0x100 and 0x040 ?
 }
@@ -129,8 +129,8 @@
 READ32_MEMBER(eolith_state::hidctch3_pen1_r)
 {
 	//320 x 240
-	int xpos = input_port_read(machine(), "PEN_X_P1");
-	int ypos = input_port_read(machine(), "PEN_Y_P1");
+	int xpos = ioport("PEN_X_P1")->read();
+	int ypos = ioport("PEN_Y_P1")->read();
 
 	return xpos + (ypos*168*2);
 }
@@ -138,8 +138,8 @@
 READ32_MEMBER(eolith_state::hidctch3_pen2_r)
 {
 	//320 x 240
-	int xpos = input_port_read(machine(), "PEN_X_P2");
-	int ypos = input_port_read(machine(), "PEN_Y_P2");
+	int xpos = ioport("PEN_X_P2")->read();
+	int ypos = ioport("PEN_Y_P2")->read();
 
 	return xpos + (ypos*168*2);
 }
diff -Nru src-old/mame/drivers/eolith16.c src/mame/drivers/eolith16.c
--- src-old/mame/drivers/eolith16.c	2012-04-09 15:23:05.000000000 +0200
+++ src/mame/drivers/eolith16.c	2012-05-03 11:00:08.000000000 +0200
@@ -51,7 +51,7 @@
 	m_vbuffer = (data & 0x80) >> 7;
 	coin_counter_w(machine(), 0, data & 1);
 
-	input_port_write(machine(), "EEPROMOUT", data, 0xff);
+	ioport("EEPROMOUT")->write(data, 0xff);
 
 	//data & 0x100 and data & 0x004 always set
 }
@@ -59,7 +59,7 @@
 READ16_MEMBER(eolith16_state::eolith16_custom_r)
 {
 	eolith_speedup_read(&space);
-	return input_port_read(machine(), "SPECIAL");
+	return ioport("SPECIAL")->read();
 }
 
 
diff -Nru src-old/mame/drivers/epos.c src/mame/drivers/epos.c
--- src-old/mame/drivers/epos.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/epos.c	2012-04-29 22:57:38.000000000 +0200
@@ -89,8 +89,10 @@
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_RANGE(0x10, 0x13) AM_DEVREADWRITE_LEGACY("ppi8255", ppi8255_r, ppi8255_w)
 	AM_RANGE(0x20, 0x24) AM_WRITE(dealer_decrypt_rom)
+	AM_RANGE(0x34, 0x34) AM_DEVWRITE_LEGACY("aysnd", ay8910_data_w)
 	AM_RANGE(0x38, 0x38) AM_READ_PORT("DSW")
-//  AM_RANGE(0x40, 0x40) AM_WRITE(watchdog_reset_w)
+	AM_RANGE(0x3C, 0x3C) AM_DEVWRITE_LEGACY("aysnd", ay8910_address_w)
+	AM_RANGE(0x40, 0x40) AM_WRITE(watchdog_reset_w)
 ADDRESS_MAP_END
 
 
diff -Nru src-old/mame/drivers/eprom.c src/mame/drivers/eprom.c
--- src-old/mame/drivers/eprom.c	2012-04-16 00:44:14.000000000 +0200
+++ src/mame/drivers/eprom.c	2012-05-03 11:00:08.000000000 +0200
@@ -76,7 +76,7 @@
 
 READ16_MEMBER(eprom_state::special_port1_r)
 {
-	int result = input_port_read(machine(), "260010");
+	int result = ioport("260010")->read();
 
 	if (m_sound_to_cpu_ready) result ^= 0x0004;
 	if (m_cpu_to_sound_ready) result ^= 0x0008;
@@ -89,7 +89,7 @@
 READ16_MEMBER(eprom_state::adc_r)
 {
 	static const char *const adcnames[] = { "ADC0", "ADC1", "ADC2", "ADC3" };
-	int result = input_port_read(machine(), adcnames[m_last_offset & 3]);
+	int result = ioport(adcnames[m_last_offset & 3])->read();
 
 	m_last_offset = offset;
 	return result;
@@ -245,7 +245,7 @@
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("260010")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0002, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )	/* Input buffer full (@260030) */
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED ) /* Output buffer full (@360030) */
@@ -290,7 +290,7 @@
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1)
 
 	PORT_START("260010")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0002, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )	/* Input buffer full (@260030) */
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED ) /* Output buffer full (@360030) */
@@ -319,7 +319,7 @@
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("260010")		/* 260010 */
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0002, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )	/* Input buffer full (@260030) */
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED ) /* Output buffer full (@360030) */
diff -Nru src-old/mame/drivers/equites.c src/mame/drivers/equites.c
--- src-old/mame/drivers/equites.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/equites.c	2012-05-03 11:00:08.000000000 +0200
@@ -404,7 +404,7 @@
 static TIMER_CALLBACK( equites_frq_adjuster_callback )
 {
 	equites_state *state = machine.driver_data<equites_state>();
-	UINT8 frq = input_port_read(machine, FRQ_ADJUSTER_TAG);
+	UINT8 frq = state->ioport(FRQ_ADJUSTER_TAG)->read();
 
 	msm5232_set_clock(state->m_msm, MSM5232_MIN_CLOCK + frq * (MSM5232_MAX_CLOCK - MSM5232_MIN_CLOCK) / 100);
 //popmessage("8155: C %02x A %02x  AY: A %02x B %02x Unk:%x", state->m_eq8155_port_c, state->m_eq8155_port_a, state->m_ay_port_a, state->m_ay_port_b, state->m_eq_cymbal_ctrl & 15);
@@ -647,7 +647,7 @@
 #if HVOLTAGE_DEBUG
 READ16_MEMBER(equites_state::hvoltage_debug_r)
 {
-	return(input_port_read(machine(), "FAKE"));
+	return(ioport("FAKE")->read());
 }
 #endif
 
diff -Nru src-old/mame/drivers/ertictac.c src/mame/drivers/ertictac.c
--- src-old/mame/drivers/ertictac.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/ertictac.c	2012-05-03 11:00:08.000000000 +0200
@@ -18,6 +18,8 @@
     - Need PCB for identify the exact model of AA, available RAM, what kind of i/o "podule"
       it has etc.
 
+PCB has a single OSC at 24MHz
+
 *******************************************************************************************/
 #include "emu.h"
 #include "cpu/arm/arm.h"
@@ -42,11 +44,11 @@
 
 	switch(offset)
 	{
-		case 0x04/4: return input_port_read(machine(), "DSW1") & 0xff;
-		case 0x08/4: return input_port_read(machine(), "DSW2") & 0xff;
-		case 0x10/4: return input_port_read(machine(), "SYSTEM") & 0xff;
-		case 0x14/4: return input_port_read(machine(), "P2") & 0xff;
-		case 0x18/4: return input_port_read(machine(), "P1") & 0xff;
+		case 0x04/4: return ioport("DSW1")->read() & 0xff;
+		case 0x08/4: return ioport("DSW2")->read() & 0xff;
+		case 0x10/4: return ioport("SYSTEM")->read() & 0xff;
+		case 0x14/4: return ioport("P2")->read() & 0xff;
+		case 0x18/4: return ioport("P1")->read() & 0xff;
 	}
 
 	return 0;
@@ -165,22 +167,22 @@
 	PORT_DIPSETTING(    0x01, "Manual" )
 	PORT_DIPSETTING(    0x00, "Automatic" )
 	PORT_DIPNAME( 0x1A, 0x00, "Setting 2" )  PORT_DIPLOCATION("DSW2:3,4,5")
-	PORT_DIPSETTING(    0x00, "Extremely Easy - 2:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, "Very Easy - 1:30")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x08, "Easy - 2:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x0A, "Normal 1 - 1:30")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, "Normal 2 - 1:45")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x12, "Difficult - 2:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x18, "Very Difficult - 2:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x1A, "Extremely Difficult - 1:30")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "Clear 20% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x02, "Clear 30% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x08, "Clear 40% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x0A, "Clear 50% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x10, "Clear 60% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x12, "Clear 70% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x18, "Clear 80% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x1A, "Clear 90% - 1:00")	PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPSETTING(    0x00, "Extremely Easy - 2:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, "Very Easy - 1:30")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x08, "Easy - 2:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x0A, "Normal 1 - 1:30")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, "Normal 2 - 1:45")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x12, "Difficult - 2:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x18, "Very Difficult - 2:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x1A, "Extremely Difficult - 1:30")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "Clear 20% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x02, "Clear 30% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x08, "Clear 40% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x0A, "Clear 50% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x10, "Clear 60% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x12, "Clear 70% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x18, "Clear 80% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x1A, "Clear 90% - 1:00")	PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPUNKNOWN_DIPLOC( 0x04, 0x04, "DSW2:1" )
 	PORT_DIPUNKNOWN_DIPLOC( 0x20, 0x20, "DSW2:6" )
 INPUT_PORTS_END
@@ -219,7 +221,7 @@
 
 static MACHINE_CONFIG_START( ertictac, ertictac_state )
 
-	MCFG_CPU_ADD("maincpu", ARM, 8000000) /* guess */
+	MCFG_CPU_ADD("maincpu", ARM, XTAL_24MHz/3) /* guess, 12MHz 8MHz or 6MHz, what's the correct devider 2, 3 or 4? */
 	MCFG_CPU_PROGRAM_MAP(ertictac_map)
 	MCFG_CPU_PERIODIC_INT(ertictac_podule_irq,60) // FIXME: timing of this
 
@@ -267,22 +269,45 @@
 
 ROM_START( ertictac )
 	ROM_REGION(0x800000, "maincpu", 0 )
-	ROM_LOAD32_BYTE( "01", 0x00000, 0x10000, CRC(8dce677c) SHA1(9f12b1febe796038caa1ecad1d17864dc546cfd8) )
-	ROM_LOAD32_BYTE( "02", 0x00001, 0x10000, CRC(7c5c916c) SHA1(d4ed5fc3a7b27253551e7d9176ed9e6513092e60) )
-	ROM_LOAD32_BYTE( "03", 0x00002, 0x10000, CRC(edca5ac6) SHA1(f6c4b8030f3c1c93922c5f7232f2159e0471b93a) )
-	ROM_LOAD32_BYTE( "04", 0x00003, 0x10000, CRC(959be81c) SHA1(3e8eaacf8809863fd712ad605d23fdda4e904aee) )
-	ROM_LOAD32_BYTE( "05", 0x40000, 0x10000, CRC(d08a6c89) SHA1(17b0f5fb2094126146b09d69c91bf413737b0c9e) )
-	ROM_LOAD32_BYTE( "06", 0x40001, 0x10000, CRC(d727bcd8) SHA1(4627f8d4d6e6f323445b3ffcfc0d9c699a9a4f89) )
-	ROM_LOAD32_BYTE( "07", 0x40002, 0x10000, CRC(23b75de2) SHA1(e18f5339ca2dd362298784ff3e5479d780d823f8) )
-	ROM_LOAD32_BYTE( "08", 0x40003, 0x10000, CRC(9448ccdf) SHA1(75fe3c31625f8ba1eedd806b52993e92b1f585b6) )
-	ROM_LOAD32_BYTE( "09", 0x80000, 0x10000, CRC(2bfb312e) SHA1(af7a4a1926c9c3d0b3ad41a4729a17383581c070) )
-	ROM_LOAD32_BYTE( "10", 0x80001, 0x10000, CRC(e7a05477) SHA1(0ec6f94a35b87e1e4529dea194fce1fde9a5b0ad) )
-	ROM_LOAD32_BYTE( "11", 0x80002, 0x10000, CRC(3722591c) SHA1(e0c4075bc4b1c90a6decba3005a1f8298bd61bd1) )
-	ROM_LOAD32_BYTE( "12", 0x80003, 0x10000, CRC(fe022b7e) SHA1(056f7283bc54eff555fd1db91410c020fd905063) )
-	ROM_LOAD32_BYTE( "13", 0xc0000, 0x10000, CRC(83550842) SHA1(0fee78dbf13ba970e0544c48f8939550f9347822) )
-	ROM_LOAD32_BYTE( "14", 0xc0001, 0x10000, CRC(3029567c) SHA1(6d49bea3a3f6f11f4182a602d37b53f1f896c154) )
-	ROM_LOAD32_BYTE( "15", 0xc0002, 0x10000, CRC(500997ab) SHA1(028c7b3ca03141e5b596ab1e2ab98d0ccd9bf93a) )
-	ROM_LOAD32_BYTE( "16", 0xc0003, 0x10000, CRC(70a8d136) SHA1(50b11f5701ed5b79a5d59c9a3c7d5b7528e66a4d) )
+	ROM_LOAD32_BYTE( "01", 0x00000, 0x10000, CRC(8dce677c) SHA1(9f12b1febe796038caa1ecad1d17864dc546cfd8) ) /* Unknown version / revision */
+	ROM_LOAD32_BYTE( "02", 0x00001, 0x10000, CRC(7c5c916c) SHA1(d4ed5fc3a7b27253551e7d9176ed9e6513092e60) ) /* Unknown version / revision */
+	ROM_LOAD32_BYTE( "03", 0x00002, 0x10000, CRC(edca5ac6) SHA1(f6c4b8030f3c1c93922c5f7232f2159e0471b93a) ) /* Unknown version / revision */
+	ROM_LOAD32_BYTE( "04", 0x00003, 0x10000, CRC(959be81c) SHA1(3e8eaacf8809863fd712ad605d23fdda4e904aee) ) /* Unknown version / revision */
+	ROM_LOAD32_BYTE( "eroti_ver01_-05-", 0x40000, 0x10000, CRC(d08a6c89) SHA1(17b0f5fb2094126146b09d69c91bf413737b0c9e) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-06-", 0x40001, 0x10000, CRC(d727bcd8) SHA1(4627f8d4d6e6f323445b3ffcfc0d9c699a9a4f89) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-07-", 0x40002, 0x10000, CRC(23b75de2) SHA1(e18f5339ca2dd362298784ff3e5479d780d823f8) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-08-", 0x40003, 0x10000, CRC(9448ccdf) SHA1(75fe3c31625f8ba1eedd806b52993e92b1f585b6) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-09-", 0x80000, 0x10000, CRC(2bfb312e) SHA1(af7a4a1926c9c3d0b3ad41a4729a17383581c070) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-10-", 0x80001, 0x10000, CRC(e7a05477) SHA1(0ec6f94a35b87e1e4529dea194fce1fde9a5b0ad) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-11-", 0x80002, 0x10000, CRC(3722591c) SHA1(e0c4075bc4b1c90a6decba3005a1f8298bd61bd1) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-12-", 0x80003, 0x10000, CRC(fe022b7e) SHA1(056f7283bc54eff555fd1db91410c020fd905063) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-13-", 0xc0000, 0x10000, CRC(83550842) SHA1(0fee78dbf13ba970e0544c48f8939550f9347822) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-14-", 0xc0001, 0x10000, CRC(3029567c) SHA1(6d49bea3a3f6f11f4182a602d37b53f1f896c154) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-15-", 0xc0002, 0x10000, CRC(500997ab) SHA1(028c7b3ca03141e5b596ab1e2ab98d0ccd9bf93a) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-16-", 0xc0003, 0x10000, CRC(70a8d136) SHA1(50b11f5701ed5b79a5d59c9a3c7d5b7528e66a4d) )
+
+	ROM_REGION(0x200000, "vram", ROMREGION_ERASE00)
+ROM_END
+
+
+ROM_START( ertictaca ) /* PCB had sticker printed "092121 EROTICTAC" */
+	ROM_REGION(0x800000, "maincpu", 0 )
+	ROM_LOAD32_BYTE( "eroti_ver01_-01-", 0x00000, 0x10000, CRC(7e5b5b0b) SHA1(a9a814ca99a4cb5ee1372c0258a5b93ec90fde5c) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-02-", 0x00001, 0x10000, CRC(e4116f89) SHA1(79bab10f7c49e47e6692b4211c0445886b005275) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-03-", 0x00002, 0x10000, CRC(2d14a239) SHA1(980926ea188f96d0453571fe1afbdb3492d4cf7a) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-04-", 0x00003, 0x10000, CRC(e862b0d2) SHA1(fd66e55ea8fe6d65db6e61b90af690a81efee6dd) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-05-", 0x40000, 0x10000, CRC(d08a6c89) SHA1(17b0f5fb2094126146b09d69c91bf413737b0c9e) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-06-", 0x40001, 0x10000, CRC(d727bcd8) SHA1(4627f8d4d6e6f323445b3ffcfc0d9c699a9a4f89) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-07-", 0x40002, 0x10000, CRC(23b75de2) SHA1(e18f5339ca2dd362298784ff3e5479d780d823f8) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-08-", 0x40003, 0x10000, CRC(9448ccdf) SHA1(75fe3c31625f8ba1eedd806b52993e92b1f585b6) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-09-", 0x80000, 0x10000, CRC(2bfb312e) SHA1(af7a4a1926c9c3d0b3ad41a4729a17383581c070) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-10-", 0x80001, 0x10000, CRC(e7a05477) SHA1(0ec6f94a35b87e1e4529dea194fce1fde9a5b0ad) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-11-", 0x80002, 0x10000, CRC(3722591c) SHA1(e0c4075bc4b1c90a6decba3005a1f8298bd61bd1) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-12-", 0x80003, 0x10000, CRC(fe022b7e) SHA1(056f7283bc54eff555fd1db91410c020fd905063) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-13-", 0xc0000, 0x10000, CRC(83550842) SHA1(0fee78dbf13ba970e0544c48f8939550f9347822) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-14-", 0xc0001, 0x10000, CRC(3029567c) SHA1(6d49bea3a3f6f11f4182a602d37b53f1f896c154) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-15-", 0xc0002, 0x10000, CRC(500997ab) SHA1(028c7b3ca03141e5b596ab1e2ab98d0ccd9bf93a) )
+	ROM_LOAD32_BYTE( "eroti_ver01_-16-", 0xc0003, 0x10000, CRC(70a8d136) SHA1(50b11f5701ed5b79a5d59c9a3c7d5b7528e66a4d) )
 
 	ROM_REGION(0x200000, "vram", ROMREGION_ERASE00)
 ROM_END
@@ -310,6 +335,7 @@
 	ROM_REGION(0x200000, "vram", ROMREGION_ERASE00)
 ROM_END
 
-GAME( 1990, ertictac, 0, ertictac, ertictac, ertictac, ROT0, "Sisteme", "Erotictac/Tactic" ,GAME_IMPERFECT_SOUND)
-GAME( 1991, poizone,  0, ertictac, poizone, ertictac,  ROT0, "Eterna" ,"Poizone" ,GAME_IMPERFECT_SOUND|GAME_IMPERFECT_GRAPHICS)
+GAME( 1990, ertictac,         0, ertictac, ertictac, ertictac, ROT0, "Sisteme", "Erotictac/Tactic" ,GAME_IMPERFECT_SOUND)
+GAME( 1990, ertictaca, ertictac, ertictac, ertictac, ertictac, ROT0, "Sisteme", "Erotictac/Tactic (ver 01)" ,GAME_IMPERFECT_SOUND)
+GAME( 1991, poizone,          0, ertictac, poizone, ertictac,  ROT0, "Eterna" ,"Poizone" ,GAME_IMPERFECT_SOUND|GAME_IMPERFECT_GRAPHICS)
 
diff -Nru src-old/mame/drivers/esd16.c src/mame/drivers/esd16.c
--- src-old/mame/drivers/esd16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/esd16.c	2012-05-03 11:00:08.000000000 +0200
@@ -125,7 +125,7 @@
 WRITE16_MEMBER(esd16_state::esd_eeprom_w)
 {
 	if (ACCESSING_BITS_8_15)
-		input_port_write(machine(), "EEPROMOUT", data, 0xffff);
+		ioport("EEPROMOUT")->write(data, 0xffff);
 
 //  logerror("(0x%06x) Unk EEPROM write: %04x %04x\n", cpu_get_pc(&space.device()), data, mem_mask);
 }
@@ -305,21 +305,21 @@
 	PORT_DIPSETTING(      0x0008, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
 	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0002)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW", 0x0002, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW", 0x0002, EQUALS, 0x0000)
 
 	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Difficulty ) )		PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0200, DEF_STR( Easy ) )
diff -Nru src-old/mame/drivers/esripsys.c src/mame/drivers/esripsys.c
--- src-old/mame/drivers/esripsys.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/esripsys.c	2012-05-03 11:00:08.000000000 +0200
@@ -276,32 +276,32 @@
 			return m_cmos_ram[(m_cmos_ram_a10_3 << 3) | (m_cmos_ram_a2_0 & 3)];
 		case 8:
 		{
-			int keypad = input_port_read(machine(), "KEYPAD_B") | m_keypad_status;
+			int keypad = ioport("KEYPAD_B")->read() | m_keypad_status;
 			m_keypad_status = 0;
 			m_io_firq_status = 0;
 			return keypad;
 		}
 		case 9:
 		{
-			return input_port_read(machine(), "KEYPAD_A");
+			return ioport("KEYPAD_A")->read();
 		}
 		case 0xa:
 		{
-			int coins =  m_coin_latch | (input_port_read(machine(), "COINS") & 0x30);
+			int coins =  m_coin_latch | (ioport("COINS")->read() & 0x30);
 			m_coin_latch = 0;
 			m_io_firq_status = 0;
 			return coins;
 		}
 		case 0x10:
-			return input_port_read(machine(), "IO_1");
+			return ioport("IO_1")->read();
 		case 0x11:
-			return input_port_read(machine(), "JOYSTICK_X");
+			return ioport("JOYSTICK_X")->read();
 		case 0x12:
-			return input_port_read(machine(), "JOYSTICK_Y");
+			return ioport("JOYSTICK_Y")->read();
 		case 0x16:
 			return m_io_firq_status;
 		case 0x18:
-			return input_port_read(machine(), "IO_2");
+			return ioport("IO_2")->read();
 			/* Unused I/O */
 		case 0x19:
 		case 0x1a:
@@ -417,7 +417,7 @@
 	if (newval == 1)
 	{
 		m_io_firq_status |= 2;
-		m_coin_latch = input_port_read(machine(), "COINS") << 2;
+		m_coin_latch = ioport("COINS")->read() << 2;
 		cputag_set_input_line(machine(), "game_cpu", M6809_FIRQ_LINE, HOLD_LINE);
 	}
 }
diff -Nru src-old/mame/drivers/ettrivia.c src/mame/drivers/ettrivia.c
--- src-old/mame/drivers/ettrivia.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ettrivia.c	2012-05-03 11:00:08.000000000 +0200
@@ -290,7 +290,7 @@
 
 static INTERRUPT_GEN( ettrivia_interrupt )
 {
-	if( input_port_read(device->machine(), "COIN") & 0x01 )
+	if( device->machine().root_device().ioport("COIN")->read() & 0x01 )
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 	else
 		device_set_input_line(device, 0, HOLD_LINE);
diff -Nru src-old/mame/drivers/exerion.c src/mame/drivers/exerion.c
--- src-old/mame/drivers/exerion.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/exerion.c	2012-05-03 11:00:08.000000000 +0200
@@ -133,7 +133,7 @@
 CUSTOM_INPUT_MEMBER(exerion_state::exerion_controls_r)
 {
 	static const char *const inname[2] = { "P1", "P2" };
-	return input_port_read(machine(), inname[m_cocktail_flip]) & 0x3f;
+	return ioport(inname[m_cocktail_flip])->read() & 0x3f;
 }
 
 
@@ -261,7 +261,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
 
 	PORT_START("DSW1")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x0e, 0x00, DEF_STR( Coinage ) )          /* see notes */
 	PORT_DIPSETTING(    0x0e, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 4C_1C ) )
diff -Nru src-old/mame/drivers/exidy.c src/mame/drivers/exidy.c
--- src-old/mame/drivers/exidy.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/exidy.c	2012-05-03 11:00:08.000000000 +0200
@@ -157,7 +157,7 @@
 
 CUSTOM_INPUT_MEMBER(exidy_state::teetert_input_r)
 {
-	UINT8 dial = input_port_read(machine(), "DIAL");
+	UINT8 dial = ioport("DIAL")->read();
 	int result = 0;
 
 	result = (dial != m_last_dial) << 4;
@@ -379,7 +379,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_SPECIAL )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -404,14 +404,14 @@
 
 	PORT_MODIFY("DSW")
 	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2")
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "2C/1P, 50P Coin/3P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, "1C/1P, 50P Coin/6P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, "1C/2P, 50P Coin/12P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x03, "1C/3P, 50P Coin/18P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "2C/1P, 50P Coin/3P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, "1C/1P, 50P Coin/6P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, "1C/2P, 50P Coin/12P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, "1C/3P, 50P Coin/18P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
 	PORT_DIPNAME( 0x04, 0x00, "Top Score Award" ) PORT_DIPLOCATION("SW1:3")
 	PORT_DIPSETTING(    0x00, "Credit" )
 	PORT_DIPSETTING(    0x04, "Extended Play" )
@@ -445,14 +445,14 @@
 
 	PORT_MODIFY("DSW")
 	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2")
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x80, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "2F/1P, 5F Coin/3P" )		PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, "1F/1P, 5F Coin/6P" )		PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, "1F/2P, 5F Coin/12P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x03, "1F/3P, 5F Coin/18P" )	PORT_CONDITION("DSW", 0x80, PORTCOND_NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x80, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "2F/1P, 5F Coin/3P" )		PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, "1F/1P, 5F Coin/6P" )		PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, "1F/2P, 5F Coin/12P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, "1F/3P, 5F Coin/18P" )	PORT_CONDITION("DSW", 0x80, NOTEQUALS, 0x00)
 INPUT_PORTS_END
 
 
@@ -507,7 +507,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_SPECIAL )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Yellow Button")
@@ -569,7 +569,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_SPECIAL )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -625,7 +625,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -685,7 +685,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_SPECIAL )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -737,7 +737,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_HIGH, IPT_SPECIAL )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/exidy440.c src/mame/drivers/exidy440.c
--- src-old/mame/drivers/exidy440.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/exidy440.c	2012-05-03 11:00:08.000000000 +0200
@@ -282,7 +282,7 @@
 CUSTOM_INPUT_MEMBER(exidy440_state::hitnmiss_button1_r)
 {
 	/* button 1 shows up in two bits */
-	UINT32 button1 = input_port_read(machine(), "HITNMISS_BUTTON1");
+	UINT32 button1 = ioport("HITNMISS_BUTTON1")->read();
 	return (button1 << 1) | button1;
 }
 
@@ -336,7 +336,7 @@
 {
 	/* I/O1 accesses clear the CIRQ flip/flop */
 	cputag_set_input_line(machine(), "maincpu", 0, CLEAR_LINE);
-	return input_port_read(machine(), "IN3");
+	return ioport("IN3")->read();
 }
 
 
@@ -424,7 +424,7 @@
 
 READ8_MEMBER(exidy440_state::topsecex_input_port_5_r)
 {
-	return (input_port_read(machine(), "AN1") & 1) ? 0x01 : 0x02;
+	return (ioport("AN1")->read() & 1) ? 0x01 : 0x02;
 }
 
 
diff -Nru src-old/mame/drivers/exprraid.c src/mame/drivers/exprraid.c
--- src-old/mame/drivers/exprraid.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/exprraid.c	2012-05-03 11:00:08.000000000 +0200
@@ -238,7 +238,7 @@
 
 READ8_MEMBER(exprraid_state::vblank_r)
 {
-	return input_port_read(machine(), "IN0");
+	return ioport("IN0")->read();
 }
 
 static ADDRESS_MAP_START( master_map, AS_PROGRAM, 8, exprraid_state )
@@ -288,27 +288,27 @@
 
 static INPUT_PORTS_START( exprraid )
 	PORT_START("IN0")	/* 0x3800 */
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")	/* 0x1800 */
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           PORT_DIPLOCATION("SW1:1,2")
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )           PORT_DIPLOCATION("SW1:3,4")
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x04, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x08, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,PORTCOND_EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x04, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x08, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW0",0x10,EQUALS,0x10)
 	PORT_DIPNAME( 0x10, 0x10, "Coin Mode" )                 PORT_DIPLOCATION("SW1:5")     /* see notes */
 	PORT_DIPSETTING(    0x10, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
@@ -451,7 +451,7 @@
 {
 	exprraid_state *state = device->machine().driver_data<exprraid_state>();
 
-	if ((~input_port_read(device->machine(), "IN2")) & 0xc0)
+	if ((~state->ioport("IN2")->read()) & 0xc0)
 	{
 		if (state->m_coin == 0)
 		{
diff -Nru src-old/mame/drivers/exterm.c src/mame/drivers/exterm.c
--- src-old/mame/drivers/exterm.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/exterm.c	2012-05-03 11:00:08.000000000 +0200
@@ -101,7 +101,7 @@
 	UINT16 port;
 
 	/* Read the fake input port */
-	UINT8 trackball_pos = input_port_read(space->machine(), which ? "DIAL1" : "DIAL0");
+	UINT8 trackball_pos = state->ioport(which ? "DIAL1" : "DIAL0")->read();
 
 	/* Calculate the change from the last position. */
 	UINT8 trackball_diff = state->m_trackball_old[which] - trackball_pos;
@@ -117,7 +117,7 @@
 	state->m_aimpos[which] = (state->m_aimpos[which] + trackball_diff) & 0x3f;
 
 	/* Combine it with the standard input bits */
-	port = which ? input_port_read(space->machine(), "P2") : input_port_read(space->machine(), "P1");
+	port = state->ioport(which ? "P2" : "P1")->read();
 
 	return (port & 0xc0ff) | (state->m_aimpos[which] << 8);
 }
diff -Nru src-old/mame/drivers/f-32.c src/mame/drivers/f-32.c
--- src-old/mame/drivers/f-32.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/f-32.c	2012-05-03 11:00:08.000000000 +0200
@@ -69,7 +69,7 @@
 	if ((pc == 0x000379de) || (pc == 0x000379cc) )
 		m_maincpu->eat_cycles(100);
 	//else printf("PC %08x\n", pc );
-	return input_port_read(machine(), "SYSTEM_P2");
+	return ioport("SYSTEM_P2")->read();
 }
 
 
@@ -107,7 +107,7 @@
 	PORT_BIT( 0x00000200, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_SERVICE_NO_TOGGLE( 0x00000400, IP_ACTIVE_LOW )
 	PORT_BIT( 0x00007800, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x00008000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x00008000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x00010000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2)
 	PORT_BIT( 0x00020000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2)
 	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2)
diff -Nru src-old/mame/drivers/f1gp.c src/mame/drivers/f1gp.c
--- src-old/mame/drivers/f1gp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/f1gp.c	2012-05-03 11:00:08.000000000 +0200
@@ -241,7 +241,7 @@
 
 	PORT_START("DSW1")
 	PORT_DIPUNUSED_DIPLOC( 0x0100, 0x0100, "SW1:1" )		/* Listed as "Unused" */
-	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coin_A ) )		PORT_CONDITION("DSW1",0x8000,PORTCOND_EQUALS,0x8000) PORT_DIPLOCATION("SW1:2,3,4")
+	PORT_DIPNAME( 0x0e00, 0x0e00, DEF_STR( Coin_A ) )		PORT_CONDITION("DSW1",0x8000,EQUALS,0x8000) PORT_DIPLOCATION("SW1:2,3,4")
 	PORT_DIPSETTING(      0x0a00, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0c00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0e00, DEF_STR( 1C_1C ) )
@@ -250,7 +250,7 @@
 	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x7000, 0x7000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW1",0x8000,PORTCOND_EQUALS,0x8000) PORT_DIPLOCATION("SW1:5,6,7")
+	PORT_DIPNAME( 0x7000, 0x7000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW1",0x8000,EQUALS,0x8000) PORT_DIPLOCATION("SW1:5,6,7")
 	PORT_DIPSETTING(      0x5000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x6000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x7000, DEF_STR( 1C_1C ) )
@@ -259,7 +259,7 @@
 	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x7e00, 0x7e00, DEF_STR( Coinage ) )		PORT_CONDITION("DSW1",0x8000,PORTCOND_NOTEQUALS,0x8000) PORT_DIPLOCATION("SW1:2,3,4,5,6,7")
+	PORT_DIPNAME( 0x7e00, 0x7e00, DEF_STR( Coinage ) )		PORT_CONDITION("DSW1",0x8000,NOTEQUALS,0x8000) PORT_DIPLOCATION("SW1:2,3,4,5,6,7")
 	PORT_DIPSETTING(      0x7e00, "2 to Start, 1 to Continue" )
 	PORT_DIPNAME( 0x8000, 0x8000, "Continue Coin" )			PORT_DIPLOCATION("SW1:8")
 	PORT_DIPSETTING(      0x8000, "Normal Coinage" )
@@ -273,10 +273,10 @@
 	PORT_DIPSETTING(      0x0004, DEF_STR( Single ) )
 	PORT_DIPSETTING(      0x0000, "Multiple" )
 	PORT_DIPNAME( 0x0008, 0x0008, "Multi Player Mode" )		PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(      0x0008, "Single or Multi Player" )		PORT_CONDITION("DSW1",0x0004,PORTCOND_EQUALS,0x0000)
-	PORT_DIPSETTING(      0x0000, "Multi Player Game Only" )		PORT_CONDITION("DSW1",0x0004,PORTCOND_EQUALS,0x0000)
-	PORT_DIPSETTING(      0x0008, "Multi Player Off" )			PORT_CONDITION("DSW1",0x0004,PORTCOND_NOTEQUALS,0x0000)
-	PORT_DIPSETTING(      0x0000, "Multi Player Off" )			PORT_CONDITION("DSW1",0x0004,PORTCOND_NOTEQUALS,0x0000)
+	PORT_DIPSETTING(      0x0008, "Single or Multi Player" )		PORT_CONDITION("DSW1",0x0004,EQUALS,0x0000)
+	PORT_DIPSETTING(      0x0000, "Multi Player Game Only" )		PORT_CONDITION("DSW1",0x0004,EQUALS,0x0000)
+	PORT_DIPSETTING(      0x0008, "Multi Player Off" )			PORT_CONDITION("DSW1",0x0004,NOTEQUALS,0x0000)
+	PORT_DIPSETTING(      0x0000, "Multi Player Off" )			PORT_CONDITION("DSW1",0x0004,NOTEQUALS,0x0000)
 	PORT_DIPUNUSED_DIPLOC( 0x0010, 0x0010, "SW2:5" )		/* Listed as "Unused" */
 	PORT_DIPUNUSED_DIPLOC( 0x0020, 0x0020, "SW2:6" )		/* Listed as "Unused" */
 	PORT_DIPUNUSED_DIPLOC( 0x0040, 0x0040, "SW2:7" )		/* Listed as "Unused" */
diff -Nru src-old/mame/drivers/famibox.c src/mame/drivers/famibox.c
--- src-old/mame/drivers/famibox.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/famibox.c	2012-05-03 11:00:08.000000000 +0200
@@ -207,8 +207,8 @@
 	m_in_0_shift = 0;
 	m_in_1_shift = 0;
 
-	m_in_0 = input_port_read(machine(), "P1");
-	m_in_1 = input_port_read(machine(), "P2");
+	m_in_0 = ioport("P1")->read();
+	m_in_1 = ioport("P2")->read();
 }
 
 READ8_MEMBER(famibox_state::famibox_IN1_r)
@@ -312,9 +312,9 @@
 				return ret;
 			}
 		case 2:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 3:
-			return input_port_read(machine(), "KEYSWITCH");
+			return ioport("KEYSWITCH")->read();
 		case 7:
 			return 0x02;
 		default:
diff -Nru src-old/mame/drivers/fantland.c src/mame/drivers/fantland.c
--- src-old/mame/drivers/fantland.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fantland.c	2012-05-03 11:00:08.000000000 +0200
@@ -179,20 +179,20 @@
 {
 	int x, y, f;
 
-	switch (input_port_read(machine(), "Controls") & 0x03)
+	switch (ioport("Controls")->read() & 0x03)
 	{
 		case 3:
-		case 1:	return input_port_read(machine(), offset ? "P2_GUN" : "P1_GUN");	// Lightgun buttons
-		case 2:	return input_port_read(machine(), offset ? "P2_JOY" : "P1_JOY");	// Joystick
+		case 1:	return ioport(offset ? "P2_GUN" : "P1_GUN")->read();	// Lightgun buttons
+		case 2:	return ioport(offset ? "P2_JOY" : "P1_JOY")->read();	// Joystick
 	}
 
 	// Trackball
 
-	x = input_port_read(machine(), offset ? "P2 Trackball X" : "P1 Trackball X");
-	y = input_port_read(machine(), offset ? "P2 Trackball Y" : "P1 Trackball Y");
+	x = ioport(offset ? "P2 Trackball X" : "P1 Trackball X")->read();
+	y = ioport(offset ? "P2 Trackball Y" : "P1 Trackball Y")->read();
 	f = machine().primary_screen->frame_number();
 
-	m_input_ret[offset] = (m_input_ret[offset] & 0x14) | (input_port_read(machine(), offset ? "P2_TRACK" : "P1_TRACK") & 0xc3);
+	m_input_ret[offset] = (m_input_ret[offset] & 0x14) | (ioport(offset ? "P2_TRACK" : "P1_TRACK")->read() & 0xc3);
 
 	x = (x & 0x7f) - (x & 0x80);
 	y = (y & 0x7f) - (y & 0x80);
@@ -368,7 +368,7 @@
 	if (!state->m_adpcm_playing[voice])
 		return;
 
-	rom = device->machine().root_device().memregion("adpcm")->base();
+	rom = state->memregion("adpcm")->base();
 	len = state->memregion("adpcm")->bytes() * 2;
 
 	start = state->m_adpcm_addr[0][voice] + state->m_adpcm_nibble[voice];
@@ -585,64 +585,64 @@
 
 static INPUT_PORTS_START( borntofi )
 	PORT_START("P1_GUN")	/* 53000 (Lightgun) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
 
 	PORT_START("P2_GUN")	/* 53001 (Lightgun) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03) PORT_PLAYER(2)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03) PORT_PLAYER(2)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x03)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03) PORT_PLAYER(2)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03) PORT_PLAYER(2)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x03)
 
 	PORT_START("P1_TRACK")	/* 53000 (Trackball) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_START1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball x
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball x
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball y
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball y
-	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW,  IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_START1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball x
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball x
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball y
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball y
+	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW,  IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
 
 	PORT_START("P2_TRACK")	/* 53001 (Trackball) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_START2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball x
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball x
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball y
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) // trackball y
-	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) PORT_PLAYER(2)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW,  IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x00) PORT_PLAYER(2)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW,  IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_START2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball x
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball x
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball y
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SPECIAL )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) // trackball y
+	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) PORT_PLAYER(2)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW,  IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x00) PORT_PLAYER(2)
 
 	PORT_START("P1_JOY")	/* 53000 (Joystick) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
 
 	PORT_START("P2_JOY")	/* 53001 (Joystick) */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, PORTCOND_EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )	PORT_CONDITION("Controls", 0x03, EQUALS, 0x02) PORT_PLAYER(2)
 
 	PORT_START("DSW")	/* 53002 */
 	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coinage ) )		PORT_DIPLOCATION("DSW1:1,2,3")
@@ -721,7 +721,7 @@
 CUSTOM_INPUT_MEMBER(fantland_state::wheelrun_wheel_r)
 {
 	int player = (FPTR)param;
-	int delta = input_port_read(machine(), player ? "WHEEL1" : "WHEEL0");
+	int delta = ioport(player ? "WHEEL1" : "WHEEL0")->read();
 	delta = (delta & 0x7f) - (delta & 0x80) + 4;
 
 	if		(delta > 7)	delta = 7;
diff -Nru src-old/mame/drivers/fcombat.c src/mame/drivers/fcombat.c
--- src-old/mame/drivers/fcombat.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fcombat.c	2012-05-03 11:00:08.000000000 +0200
@@ -61,7 +61,7 @@
 READ8_MEMBER(fcombat_state::fcombat_port01_r)
 {
 	/* the cocktail flip bit muxes between ports 0 and 1 */
-	return m_cocktail_flip ? input_port_read(machine(), "IN1") : input_port_read(machine(), "IN0");
+	return ioport(m_cocktail_flip ? "IN1" : "IN0")->read();
 }
 
 
@@ -194,7 +194,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
 
 	PORT_START("DSW1")      /* dip switches/VBLANK (0xe200) */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unknown ) )		// related to vblank
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/feversoc.c src/mame/drivers/feversoc.c
--- src-old/mame/drivers/feversoc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/feversoc.c	2012-05-03 11:00:08.000000000 +0200
@@ -138,7 +138,7 @@
 {
 
 	m_x^=0x40; //vblank? eeprom read bit?
-	return (input_port_read(machine(), "IN0") | m_x) | (input_port_read(machine(), "IN1")<<16);
+	return (ioport("IN1")->read()<<16);
 }
 
 WRITE32_MEMBER(feversoc_state::output_w)
diff -Nru src-old/mame/drivers/fgoal.c src/mame/drivers/fgoal.c
--- src-old/mame/drivers/fgoal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fgoal.c	2012-05-03 11:00:08.000000000 +0200
@@ -73,7 +73,7 @@
 {
 	fgoal_state *state = machine.driver_data<fgoal_state>();
 	int scanline;
-	int coin = (input_port_read(machine, "IN1") & 2);
+	int coin = (state->ioport("IN1")->read() & 2);
 
 	device_set_input_line(state->m_maincpu, 0, ASSERT_LINE);
 
@@ -100,7 +100,7 @@
 
 READ8_MEMBER(fgoal_state::fgoal_analog_r)
 {
-	return input_port_read(machine(), m_fgoal_player ? "PADDLE1" : "PADDLE0"); /* PCB can be jumpered to use a single dial */
+	return ioport(m_fgoal_player ? "PADDLE1" : "PADDLE0")->read(); /* PCB can be jumpered to use a single dial */
 }
 
 
diff -Nru src-old/mame/drivers/finalizr.c src/mame/drivers/finalizr.c
--- src-old/mame/drivers/finalizr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/finalizr.c	2012-05-03 11:00:08.000000000 +0200
@@ -139,7 +139,7 @@
 	KONAMI8_SYSTEM_10
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("P1")
 	KONAMI8_MONO_B12_UNK
diff -Nru src-old/mame/drivers/firebeat.c src/mame/drivers/firebeat.c
--- src-old/mame/drivers/firebeat.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/firebeat.c	2012-05-03 11:00:08.000000000 +0200
@@ -727,15 +727,15 @@
 
 	if (ACCESSING_BITS_24_31)
 	{
-		r |= (input_port_read(space->machine(), "IN0") & 0xff) << 24;
+		r |= (space->machine().root_device().ioport("IN0")->read() & 0xff) << 24;
 	}
 	if (ACCESSING_BITS_8_15)
 	{
-		r |= (input_port_read(space->machine(), "IN1") & 0xff) << 8;
+		r |= (space->machine().root_device().ioport("IN1")->read() & 0xff) << 8;
 	}
 	if (ACCESSING_BITS_0_7)
 	{
-		r |= (input_port_read(space->machine(), "IN2") & 0xff);
+		r |= (space->machine().root_device().ioport("IN2")->read() & 0xff);
 	}
 
 	return r;
@@ -745,11 +745,11 @@
 {
 	if (offset == 0)
 	{
-		return input_port_read(space->machine(), "SENSOR1") | 0x01000100;
+		return space->machine().root_device().ioport("SENSOR1")->read() | 0x01000100;
 	}
 	else
 	{
-		return input_port_read(space->machine(), "SENSOR2") | 0x01000100;
+		return space->machine().root_device().ioport("SENSOR2")->read() | 0x01000100;
 	}
 }
 
@@ -1365,11 +1365,11 @@
 {
 	if (offset == 0)		// Keyboard Wheel (P1)
 	{
-		return input_port_read(space->machine(), "WHEEL_P1") << 24;
+		return space->machine().root_device().ioport("WHEEL_P1")->read() << 24;
 	}
 	else if (offset == 2)	// Keyboard Wheel (P2)
 	{
-		return input_port_read(space->machine(), "WHEEL_P2") << 24;
+		return space->machine().root_device().ioport("WHEEL_P2")->read() << 24;
 	}
 
 	return 0;
@@ -1459,7 +1459,7 @@
 
 	for (keyboard=0; keyboard < 2; keyboard++)
 	{
-		UINT32 kbstate = input_port_read(machine, keynames[keyboard]);
+		UINT32 kbstate = machine.root_device().ioport(keynames[keyboard])->read();
 		int uart_channel = kb_uart_channel[keyboard];
 
 		if (kbstate != state->m_keyboard_state[keyboard])
@@ -2291,7 +2291,7 @@
 	ROM_LOAD("gq977-ja", 0x00, 0xc0, BAD_DUMP CRC(55b5abdb) SHA1(d8da5bac005235480a1815bd0a79c3e8a63ebad1))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "977jaa01", 0, SHA1(59c03d8eb366167feef741d42d9d8b54bfeb3c1e) )
+	DISK_IMAGE_READONLY( "977jaa01", 0, BAD_DUMP SHA1(59c03d8eb366167feef741d42d9d8b54bfeb3c1e) )
 
 	// TODO: the audio CD is not dumped
 ROM_END
@@ -2306,10 +2306,10 @@
 	ROM_LOAD("gq974-ja", 0x00, 0xc0, BAD_DUMP CRC(4578f29b) SHA1(faaeaf6357c1e86e898e7017566cfd2fc7ee3d6f))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "974jac01", 0, SHA1(c6145d7090e44c87f71ba626620d2ae2596a75ca) )
+	DISK_IMAGE_READONLY( "974jac01", 0, BAD_DUMP SHA1(c6145d7090e44c87f71ba626620d2ae2596a75ca) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "974jaa02", 1, SHA1(3b9946083239eb5687f66a49df24568bffa4fbbd) )
+	DISK_IMAGE_READONLY( "974jaa02", 1, BAD_DUMP SHA1(3b9946083239eb5687f66a49df24568bffa4fbbd) )
 ROM_END
 
 ROM_START( kbm2nd )
@@ -2322,10 +2322,10 @@
 	ROM_LOAD("gca01-ja", 0x00, 0xc0, BAD_DUMP CRC(2bda339d) SHA1(031cb3f44e7a89cd62a9ba948f3d19d53a325abd))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "a01jaa01", 0, SHA1(37bc3879719b3d3c6bc8a5691abd7aa4aec87d45) )
+	DISK_IMAGE_READONLY( "a01jaa01", 0, BAD_DUMP SHA1(37bc3879719b3d3c6bc8a5691abd7aa4aec87d45) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "a01jaa02", 1, SHA1(a3fdeee0f85a7a9718c0fb1cc642ac22d3eff8db) )
+	DISK_IMAGE_READONLY( "a01jaa02", 1, BAD_DUMP SHA1(a3fdeee0f85a7a9718c0fb1cc642ac22d3eff8db) )
 ROM_END
 
 ROM_START( kbm3rd )
@@ -2338,10 +2338,10 @@
 	ROM_LOAD("gca12-ja", 0x00, 0xc0, BAD_DUMP CRC(cf01dc15) SHA1(da8d208233487ebe65a0a9826fc72f1f459baa26))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "a12jaa01", 0, SHA1(10f2284248e51b1adf0fde173df72ad97fe0e5c8) )
+	DISK_IMAGE_READONLY( "a12jaa01", 0, BAD_DUMP SHA1(10f2284248e51b1adf0fde173df72ad97fe0e5c8) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "a12jaa02", 1, SHA1(1256ce9d71350d355a256f83c7b319f0e6e84525) )
+	DISK_IMAGE_READONLY( "a12jaa02", 1, BAD_DUMP SHA1(1256ce9d71350d355a256f83c7b319f0e6e84525) )
 ROM_END
 
 ROM_START( popn5 )
@@ -2375,10 +2375,10 @@
 	ROM_LOAD16_WORD_SWAP("a02jaa04.3q", 0x00000, 0x80000, CRC(8c6000dd) SHA1(94ab2a66879839411eac6c673b25143d15836683))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "b00jab01", 0, SHA1(604fd460befcb5c53ae230155b83dec3a0b668d7) )
+	DISK_IMAGE_READONLY( "b00jab01", 0, BAD_DUMP SHA1(604fd460befcb5c53ae230155b83dec3a0b668d7) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "b00jaa02", 1, SHA1(9e226f6b377ea72514d58dd350578b7dad12a70a) )
+	DISK_IMAGE_READONLY( "b00jaa02", 1, BAD_DUMP SHA1(9e226f6b377ea72514d58dd350578b7dad12a70a) )
 ROM_END
 
 ROM_START( ppd )
@@ -2391,10 +2391,10 @@
 	ROM_LOAD("gq977-ko", 0x00, 0xc0, BAD_DUMP CRC(ee743323) SHA1(2042e45879795557ad3cc21b37962f6bf54da60d))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "977kaa01", 0, SHA1(7af9f4949ffa10ea5fc18b6c88c2abc710df3cf9) )
+	DISK_IMAGE_READONLY( "977kaa01", 0, BAD_DUMP SHA1(7af9f4949ffa10ea5fc18b6c88c2abc710df3cf9) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "977kaa02", 1, SHA1(cfca3cbc41c6203c3f3b482a6be5f63d33a8a966) )
+	DISK_IMAGE_READONLY( "977kaa02", 1, BAD_DUMP SHA1(cfca3cbc41c6203c3f3b482a6be5f63d33a8a966) )
 ROM_END
 
 ROM_START( ppp11 )
@@ -2407,10 +2407,10 @@
 	ROM_LOAD("gq977-ja", 0x00, 0xc0, BAD_DUMP CRC(55b5abdb) SHA1(d8da5bac005235480a1815bd0a79c3e8a63ebad1))
 
 	DISK_REGION( "scsi0" )
-	DISK_IMAGE_READONLY( "gc977jaa01", 0, SHA1(6b93dd38029ea68f9572126e48d618edce68fbce) )
+	DISK_IMAGE_READONLY( "gc977jaa01", 0, BAD_DUMP SHA1(6b93dd38029ea68f9572126e48d618edce68fbce) )
 
 	DISK_REGION( "scsi1" )
-	DISK_IMAGE_READONLY( "gc977jaa02", 1, SHA1(b853a6f4edcaceb609fe2a3d6a18d4ac62bd3822) )
+	DISK_IMAGE_READONLY( "gc977jaa02", 1, BAD_DUMP SHA1(b853a6f4edcaceb609fe2a3d6a18d4ac62bd3822) )
 ROM_END
 
 /*****************************************************************************/
diff -Nru src-old/mame/drivers/firefox.c src/mame/drivers/firefox.c
--- src-old/mame/drivers/firefox.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/firefox.c	2012-05-03 11:00:08.000000000 +0200
@@ -381,10 +381,10 @@
 {
 	if( m_control_num == 0 )
 	{
-		return input_port_read( machine(), "PITCH" );
+		return ioport( "PITCH" )->read();
 	}
 
-	return input_port_read( machine(), "YAW" );
+	return ioport( "YAW" )->read();
 }
 
 WRITE8_MEMBER(firefox_state::adc_select_w)
@@ -579,7 +579,7 @@
 	PORT_START("rdin1")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, firefox_state,mainflag_r, NULL)
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, firefox_state,soundflag_r, NULL)
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
diff -Nru src-old/mame/drivers/firetrap.c src/mame/drivers/firetrap.c
--- src-old/mame/drivers/firetrap.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/firetrap.c	2012-05-03 11:00:08.000000000 +0200
@@ -192,7 +192,7 @@
 	/* the following only works in the bootleg version, which doesn't have an */
 	/* 8751 - the real thing is much more complicated than that. */
 	UINT8 coin = 0;
-	UINT8 port = input_port_read(machine(), "IN2") & 0x70;
+	UINT8 port = ioport("IN2")->read() & 0x70;
 
 	if (cpu_get_pc(&space.device()) == 0x1188)
 		return ~m_coin_command_pending;
@@ -454,7 +454,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW0")	/* DSW0 */
 	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:1,2,3")
@@ -593,7 +593,7 @@
 static MACHINE_START( firetrap )
 {
 	firetrap_state *state = machine.driver_data<firetrap_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
 	UINT8 *SOUND = state->memregion("audiocpu")->base();
 
 	state->m_maincpu = machine.device("maincpu");
diff -Nru src-old/mame/drivers/firetrk.c src/mame/drivers/firetrk.c
--- src-old/mame/drivers/firetrk.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/firetrk.c	2012-05-03 11:00:08.000000000 +0200
@@ -172,8 +172,8 @@
 
 READ8_MEMBER(firetrk_state::firetrk_dip_r)
 {
-	UINT8 val0 = input_port_read(machine(), "DIP_0");
-	UINT8 val1 = input_port_read(machine(), "DIP_1");
+	UINT8 val0 = ioport("DIP_0")->read();
+	UINT8 val1 = ioport("DIP_1")->read();
 
 	if (val1 & (1 << (2 * offset + 0))) val0 |= 1;
 	if (val1 & (1 << (2 * offset + 1))) val0 |= 2;
@@ -184,8 +184,8 @@
 
 READ8_MEMBER(firetrk_state::montecar_dip_r)
 {
-	UINT8 val0 = input_port_read(machine(), "DIP_0");
-	UINT8 val1 = input_port_read(machine(), "DIP_1");
+	UINT8 val0 = ioport("DIP_0")->read();
+	UINT8 val1 = ioport("DIP_1")->read();
 
 	if (val1 & (1 << (3 - offset))) val0 |= 1;
 	if (val1 & (1 << (7 - offset))) val0 |= 2;
@@ -247,7 +247,7 @@
 	/* update steering wheels */
 	for (i = 0; i < 2; i++)
 	{
-		UINT32 new_dial = input_port_read_safe(machine(), (i ? "STEER_2" : "STEER_1"), 0);
+		UINT32 new_dial = ioport((i ? "STEER_2" : "STEER_1"))->read_safe(0);
 		INT32 delta = new_dial - m_dial[i];
 
 		if (delta != 0)
@@ -259,9 +259,9 @@
 		}
 	}
 
-	return ((input_port_read_safe(machine(), "BIT_0", 0) & (1 << offset)) ? 0x01 : 0) |
-		   ((input_port_read_safe(machine(), "BIT_6", 0) & (1 << offset)) ? 0x40 : 0) |
-		   ((input_port_read_safe(machine(), "BIT_7", 0) & (1 << offset)) ? 0x80 : 0);
+	return ((ioport("BIT_0")->read_safe(0) & (1 << offset)) ? 0x01 : 0) |
+		   ((ioport("BIT_6")->read_safe(0) & (1 << offset)) ? 0x40 : 0) |
+		   ((ioport("BIT_7")->read_safe(0) & (1 << offset)) ? 0x80 : 0);
 }
 
 
@@ -447,7 +447,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_START3 ) PORT_NAME("Both Players Start")
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("Track Select") PORT_CODE(KEYCODE_SPACE) PORT_PLAYER(1)
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW,  IPT_VBLANK )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW,  IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Cabinet ))
 	PORT_DIPSETTING(    0x00, "Smokey Joe (1 Player)" )
 	PORT_DIPSETTING(    0x40, "Fire Truck (2 Players)" )
@@ -579,7 +579,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, firetrk_state,gear_r, (void *)2)
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON6 ) PORT_NAME("Track Select") PORT_CODE(KEYCODE_SPACE)
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("Gas")
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, firetrk_state,steer_dir_r, (void *)0)
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, firetrk_state,skid_r, (void *)1)
 
diff -Nru src-old/mame/drivers/flkatck.c src/mame/drivers/flkatck.c
--- src-old/mame/drivers/flkatck.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/flkatck.c	2012-05-03 11:00:08.000000000 +0200
@@ -47,13 +47,13 @@
 	{
 		case 0x00:
 			if (offset & 0x02)
-				data = input_port_read(machine(), (offset & 0x01) ? "COIN" : "DSW3");
+				data = ioport((offset & 0x01) ? "COIN" : "DSW3")->read();
 			else
-				data = input_port_read(machine(), (offset & 0x01) ? "P2" : "P1");
+				data = ioport((offset & 0x01) ? "P2" : "P1")->read();
 			break;
 		case 0x01:
 			if (offset & 0x02)
-				data = input_port_read(machine(), (offset & 0x01) ? "DSW1" : "DSW2");
+				data = ioport((offset & 0x01) ? "DSW1" : "DSW2")->read();
 			break;
 	}
 
diff -Nru src-old/mame/drivers/flower.c src/mame/drivers/flower.c
--- src-old/mame/drivers/flower.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/flower.c	2012-04-23 01:12:50.000000000 +0200
@@ -121,13 +121,13 @@
 	AM_RANGE(0xa102, 0xa102) AM_READ_PORT("IN0CPU0")
 	AM_RANGE(0xa103, 0xa103) AM_READ_PORT("IN1CPU0")
 	AM_RANGE(0xa400, 0xa400) AM_WRITE(sound_command_w)
-	AM_RANGE(0xc000, 0xddff) AM_RAM
+	AM_RANGE(0xc000, 0xddff) AM_RAM AM_SHARE("mainram1")
 	AM_RANGE(0xde00, 0xdfff) AM_RAM AM_SHARE("spriteram")
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(flower_textram_w)  AM_SHARE("textram")
-	AM_RANGE(0xe000, 0xefff) AM_RAM // only cleared?
-	AM_RANGE(0xf000, 0xf1ff) AM_RAM_WRITE(flower_bg0ram_w)   AM_SHARE("bg0ram")
-	AM_RANGE(0xf200, 0xf200) AM_RAM  AM_SHARE("bg0_scroll")
-	AM_RANGE(0xf800, 0xf9ff) AM_RAM_WRITE(flower_bg1ram_w)  AM_SHARE("bg1ram")
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(flower_textram_w) AM_SHARE("textram")
+	AM_RANGE(0xe000, 0xefff) AM_RAM AM_SHARE("mainram2") // only cleared?
+	AM_RANGE(0xf000, 0xf1ff) AM_RAM_WRITE(flower_bg0ram_w) AM_SHARE("bg0ram")
+	AM_RANGE(0xf200, 0xf200) AM_RAM AM_SHARE("bg0_scroll")
+	AM_RANGE(0xf800, 0xf9ff) AM_RAM_WRITE(flower_bg1ram_w) AM_SHARE("bg1ram")
 	AM_RANGE(0xfa00, 0xfa00) AM_RAM AM_SHARE("bg1_scroll")
 ADDRESS_MAP_END
 
diff -Nru src-old/mame/drivers/flyball.c src/mame/drivers/flyball.c
--- src-old/mame/drivers/flyball.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/flyball.c	2012-05-03 11:00:08.000000000 +0200
@@ -145,10 +145,10 @@
 
 	memset(potsense, 0, sizeof potsense);
 
-	potsense[input_port_read(machine, "STICK1_Y")] |= 1;
-	potsense[input_port_read(machine, "STICK1_X")] |= 2;
-	potsense[input_port_read(machine, "STICK0_Y")] |= 4;
-	potsense[input_port_read(machine, "STICK0_X")] |= 8;
+	potsense[state->ioport("STICK1_Y")->read()] |= 1;
+	potsense[state->ioport("STICK1_X")->read()] |= 2;
+	potsense[state->ioport("STICK0_Y")->read()] |= 4;
+	potsense[state->ioport("STICK0_X")->read()] |= 8;
 
 	for (i = 0; i < 64; i++)
 		if (potsense[i] != 0)
@@ -173,7 +173,7 @@
 /* two physical buttons (start game and stop runner) share the same port bit */
 READ8_MEMBER(flyball_state::flyball_input_r)
 {
-	return input_port_read(machine(), "IN0") & input_port_read(machine(), "IN1");
+	return ioport("IN1")->read();
 }
 
 READ8_MEMBER(flyball_state::flyball_scanline_r)
diff -Nru src-old/mame/drivers/foodf.c src/mame/drivers/foodf.c
--- src-old/mame/drivers/foodf.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/foodf.c	2012-05-03 11:00:08.000000000 +0200
@@ -189,7 +189,7 @@
 {
 	static const char *const portnames[] = { "STICK0_X", "STICK1_X", "STICK0_Y", "STICK1_Y" };
 
-	return input_port_read(machine(), portnames[m_whichport]);
+	return ioport(portnames[m_whichport])->read();
 }
 
 
@@ -326,7 +326,7 @@
 
 static READ8_DEVICE_HANDLER( pot_r )
 {
-	return (input_port_read(device->machine(), "DSW") >> offset) << 7;
+	return (device->machine().root_device().ioport("DSW")->read() >> offset) << 7;
 }
 
 static const pokey_interface pokey_config =
diff -Nru src-old/mame/drivers/forte2.c src/mame/drivers/forte2.c
--- src-old/mame/drivers/forte2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/forte2.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,7 +72,7 @@
 static READ8_DEVICE_HANDLER(forte2_ay8910_read_input)
 {
 	forte2_state *state = device->machine().driver_data<forte2_state>();
-	return input_port_read(device->machine(), "IN0") | (state->m_input_mask&0x3f);
+	return state->ioport("IN0")->read() | (state->m_input_mask&0x3f);
 }
 
 static WRITE8_DEVICE_HANDLER( forte2_ay8910_set_input_mask )
diff -Nru src-old/mame/drivers/freekick.c src/mame/drivers/freekick.c
--- src-old/mame/drivers/freekick.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/freekick.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 
 READ8_MEMBER(freekick_state::spinner_r)
 {
-	return input_port_read(machine(), m_spinner ? "IN3" : "IN2");
+	return ioport(m_spinner ? "IN3" : "IN2")->read();
 }
 
 WRITE8_MEMBER(freekick_state::pbillrd_bankswitch_w)
diff -Nru src-old/mame/drivers/fromanc2.c src/mame/drivers/fromanc2.c
--- src-old/mame/drivers/fromanc2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fromanc2.c	2012-05-03 11:00:08.000000000 +0200
@@ -58,10 +58,10 @@
 
 	switch (m_portselect)
 	{
-	case 0x01:	ret = input_port_read(machine(), "KEY0"); break;
-	case 0x02:	ret = input_port_read(machine(), "KEY1"); break;
-	case 0x04:	ret = input_port_read(machine(), "KEY2"); break;
-	case 0x08:	ret = input_port_read(machine(), "KEY3"); break;
+	case 0x01:	ret = ioport("KEY0")->read(); break;
+	case 0x02:	ret = ioport("KEY1")->read(); break;
+	case 0x04:	ret = ioport("KEY2")->read(); break;
+	case 0x08:	ret = ioport("KEY3")->read(); break;
 	default:	ret = 0xffff;
 			logerror("PC:%08X unknown %02X\n", cpu_get_pc(&space.device()), m_portselect);
 			break;
@@ -88,7 +88,7 @@
 WRITE16_MEMBER(fromanc2_state::fromanc2_eeprom_w)
 {
 	if (ACCESSING_BITS_8_15)
-		input_port_write(machine(), "EEPROMOUT", data, 0xffff);
+		ioport("EEPROMOUT")->write(data, 0xffff);
 }
 
 WRITE16_MEMBER(fromanc2_state::fromancr_eeprom_w)
@@ -96,14 +96,14 @@
 	if (ACCESSING_BITS_0_7)
 	{
 		fromancr_gfxbank_w(machine(), data & 0xfff8);
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
 WRITE16_MEMBER(fromanc2_state::fromanc4_eeprom_w)
 {
 	if (ACCESSING_BITS_0_7)
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 }
 
 WRITE16_MEMBER(fromanc2_state::fromanc2_subcpu_w)
@@ -524,8 +524,8 @@
 {
 	fromanc2_state *state = machine.driver_data<fromanc2_state>();
 
-	state->membank("bank1")->configure_entries(0, 4, machine.root_device().memregion("sub")->base(), 0x4000);
-	state->membank("bank2")->configure_entry(0, machine.root_device().memregion("sub")->base() + 0x08000);
+	state->membank("bank1")->configure_entries(0, 4, state->memregion("sub")->base(), 0x4000);
+	state->membank("bank2")->configure_entry(0, state->memregion("sub")->base() + 0x08000);
 	state->membank("bank2")->configure_entries(1, 3, state->memregion("sub")->base() + 0x14000, 0x4000);
 
 	MACHINE_START_CALL(fromanc4);
diff -Nru src-old/mame/drivers/fromance.c src/mame/drivers/fromance.c
--- src-old/mame/drivers/fromance.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fromance.c	2012-05-03 11:00:08.000000000 +0200
@@ -180,15 +180,15 @@
 	int ret = 0xff;
 
 	if (m_portselect & 0x01)
-		ret &= input_port_read(machine(), "KEY1");
+		ret &= ioport("KEY1")->read();
 	if (m_portselect & 0x02)
-		ret &= input_port_read(machine(), "KEY2");
+		ret &= ioport("KEY2")->read();
 	if (m_portselect & 0x04)
-		ret &= input_port_read(machine(), "KEY3");
+		ret &= ioport("KEY3")->read();
 	if (m_portselect & 0x08)
-		ret &= input_port_read(machine(), "KEY4");
+		ret &= ioport("KEY4")->read();
 	if (m_portselect & 0x10)
-		ret &= input_port_read(machine(), "KEY5");
+		ret &= ioport("KEY5")->read();
 
 	return ret;
 }
diff -Nru src-old/mame/drivers/funkball.c src/mame/drivers/funkball.c
--- src-old/mame/drivers/funkball.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/funkball.c	2012-05-03 11:00:08.000000000 +0200
@@ -555,7 +555,7 @@
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3", "IN4", "IN5", "IN6", "IN7",
 	                                         "IN8", "IN9", "INA", "INB", "INC", "IND", "INE", "INF",};
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 static ADDRESS_MAP_START(funkball_map, AS_PROGRAM, 32, funkball_state)
@@ -1118,13 +1118,13 @@
 static MACHINE_RESET( funkball )
 {
 	funkball_state *state = machine.driver_data<funkball_state>();
-	state->membank("bios_ext1")->set_base(machine.root_device().memregion("bios")->base() + 0x00000);
-	state->membank("bios_ext2")->set_base(machine.root_device().memregion("bios")->base() + 0x04000);
-	state->membank("bios_ext3")->set_base(machine.root_device().memregion("bios")->base() + 0x08000);
-	state->membank("bios_ext4")->set_base(machine.root_device().memregion("bios")->base() + 0x0c000);
-	state->membank("bios_bank1")->set_base(machine.root_device().memregion("bios")->base() + 0x10000);
-	state->membank("bios_bank2")->set_base(machine.root_device().memregion("bios")->base() + 0x14000);
-	state->membank("bios_bank3")->set_base(machine.root_device().memregion("bios")->base() + 0x18000);
+	state->membank("bios_ext1")->set_base(state->memregion("bios")->base() + 0x00000);
+	state->membank("bios_ext2")->set_base(state->memregion("bios")->base() + 0x04000);
+	state->membank("bios_ext3")->set_base(state->memregion("bios")->base() + 0x08000);
+	state->membank("bios_ext4")->set_base(state->memregion("bios")->base() + 0x0c000);
+	state->membank("bios_bank1")->set_base(state->memregion("bios")->base() + 0x10000);
+	state->membank("bios_bank2")->set_base(state->memregion("bios")->base() + 0x14000);
+	state->membank("bios_bank3")->set_base(state->memregion("bios")->base() + 0x18000);
 	state->membank("bios_bank4")->set_base(state->memregion("bios")->base() + 0x1c000);
 	state->m_voodoo_pci_regs.base_addr = 0xff000000;
 }
diff -Nru src-old/mame/drivers/funkybee.c src/mame/drivers/funkybee.c
--- src-old/mame/drivers/funkybee.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/funkybee.c	2012-05-03 11:00:08.000000000 +0200
@@ -80,7 +80,7 @@
 READ8_MEMBER(funkybee_state::funkybee_input_port_0_r)
 {
 	watchdog_reset_r(space, 0);
-	return input_port_read(machine(), "IN0");
+	return ioport("IN0")->read();
 }
 
 WRITE8_MEMBER(funkybee_state::funkybee_coin_counter_w)
diff -Nru src-old/mame/drivers/funkyjet.c src/mame/drivers/funkyjet.c
--- src-old/mame/drivers/funkyjet.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/funkyjet.c	2012-05-03 11:00:08.000000000 +0200
@@ -155,7 +155,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	/* Dips seem inverted with respect to other Deco games */
 	PORT_START("DSW")
diff -Nru src-old/mame/drivers/fuukifg3.c src/mame/drivers/fuukifg3.c
--- src-old/mame/drivers/fuukifg3.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/fuukifg3.c	2012-05-03 11:00:08.000000000 +0200
@@ -425,8 +425,8 @@
 	PORT_DIPSETTING(      0x2000, "2C Start / 1C Continue" )
 //  PORT_DIPSETTING(      0x7000, "Error!!" )               // Causes graphics issues - Service Mode shows "Error"
 //  PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )        // Duplicate 2C_1C
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW2",0x0f00,PORTCOND_NOTEQUALS,0x0000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )		PORT_CONDITION("DSW2",0x0f00,PORTCOND_EQUALS,0x0000)	// Set both for Free Play
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW2",0x0f00,NOTEQUALS,0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )		PORT_CONDITION("DSW2",0x0f00,EQUALS,0x0000)	// Set both for Free Play
 	PORT_DIPNAME( 0x0f00, 0x0f00, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW4:5,6,7,8") /* Service Mode Shows Player 1 */
 	PORT_DIPSETTING(      0x0800, DEF_STR( 8C_1C ) )
 	PORT_DIPSETTING(      0x0900, DEF_STR( 7C_1C ) )
@@ -443,8 +443,8 @@
 	PORT_DIPSETTING(      0x0200, "2C Start / 1C Continue" )
 //  PORT_DIPSETTING(      0x0700, "Error!!" )               // Causes graphics issues - Service Mode shows "Error"
 //  PORT_DIPSETTING(      0x0100, DEF_STR( 2C_1C ) )        // Duplicate 2C_1C
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW2",0xf000,PORTCOND_NOTEQUALS,0x0000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )		PORT_CONDITION("DSW2",0xf000,PORTCOND_EQUALS,0x0000)	// Set both for Free Play
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW2",0xf000,NOTEQUALS,0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )		PORT_CONDITION("DSW2",0xf000,EQUALS,0x0000)	// Set both for Free Play
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( asurabus )
diff -Nru src-old/mame/drivers/gaelco2.c src/mame/drivers/gaelco2.c
--- src-old/mame/drivers/gaelco2.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gaelco2.c	2012-05-03 11:00:08.000000000 +0200
@@ -206,10 +206,10 @@
                                 BANG
   ============================================================================*/
 
-READ16_MEMBER(gaelco2_state::p1_gun_x){return (input_port_read(machine(), "LIGHT0_X") * 320 / 0x100) + 1;}
-READ16_MEMBER(gaelco2_state::p1_gun_y){return (input_port_read(machine(), "LIGHT0_Y") * 240 / 0x100) - 4;}
-READ16_MEMBER(gaelco2_state::p2_gun_x){return (input_port_read(machine(), "LIGHT1_X") * 320 / 0x100) + 1;}
-READ16_MEMBER(gaelco2_state::p2_gun_y){return (input_port_read(machine(), "LIGHT1_Y") * 240 / 0x100) - 4;}
+READ16_MEMBER(gaelco2_state::p1_gun_x){return (ioport("LIGHT0_X")->read() * 320 / 0x100) + 1;}
+READ16_MEMBER(gaelco2_state::p1_gun_y){return (ioport("LIGHT0_Y")->read() * 240 / 0x100) - 4;}
+READ16_MEMBER(gaelco2_state::p2_gun_x){return (ioport("LIGHT1_X")->read() * 320 / 0x100) + 1;}
+READ16_MEMBER(gaelco2_state::p2_gun_y){return (ioport("LIGHT1_Y")->read() * 240 / 0x100) - 4;}
 
 static ADDRESS_MAP_START( bang_map, AS_PROGRAM, 16, gaelco2_state )
     AM_RANGE(0x000000, 0x0fffff) AM_ROM																			/* ROM */
diff -Nru src-old/mame/drivers/gaelco3d.c src/mame/drivers/gaelco3d.c
--- src-old/mame/drivers/gaelco3d.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gaelco3d.c	2012-05-03 11:00:08.000000000 +0200
@@ -449,10 +449,10 @@
 	{
 		if (!(data & 0xff))
 		{
-			m_analog_ports[0] = input_port_read_safe(machine(), "ANALOG0", 0);
-			m_analog_ports[1] = input_port_read_safe(machine(), "ANALOG1", 0);
-			m_analog_ports[2] = input_port_read_safe(machine(), "ANALOG2", 0);
-			m_analog_ports[3] = input_port_read_safe(machine(), "ANALOG3", 0);
+			m_analog_ports[0] = ioport("ANALOG0")->read_safe(0);
+			m_analog_ports[1] = ioport("ANALOG1")->read_safe(0);
+			m_analog_ports[2] = ioport("ANALOG2")->read_safe(0);
+			m_analog_ports[3] = ioport("ANALOG3")->read_safe(0);
 		}
 	}
 	else
diff -Nru src-old/mame/drivers/galaga.c src/mame/drivers/galaga.c
--- src-old/mame/drivers/galaga.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/galaga.c	2012-05-03 11:00:08.000000000 +0200
@@ -717,8 +717,8 @@
 {
 	int bit0,bit1;
 
-	bit0 = (input_port_read(machine(), "DSWB") >> offset) & 1;
-	bit1 = (input_port_read(machine(), "DSWA") >> offset) & 1;
+	bit0 = (ioport("DSWB")->read() >> offset) & 1;
+	bit1 = (ioport("DSWA")->read() >> offset) & 1;
 
 	return bit0 | (bit1 << 1);
 }
@@ -777,7 +777,7 @@
 	}
 }
 
-CUSTOM_INPUT_MEMBER(digdug_state::shifted_port_r){ return input_port_read(machine(), (const char *)param) >> 4; }
+CUSTOM_INPUT_MEMBER(digdug_state::shifted_port_r){ return ioport((const char *)param)->read() >> 4; }
 
 static WRITE8_DEVICE_HANDLER( out_0 )
 {
@@ -1077,22 +1077,22 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
 	/* bonus scores are different for 5 lives */
 	PORT_DIPNAME( 0x38, 0x20, "Bonus Fighter" )         PORT_DIPLOCATION("SWA:4,5,6")
-	PORT_DIPSETTING(    0x30, "15K and 50K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0) /* Began with 1, 2 or 3 fighters */
-	PORT_DIPSETTING(    0x38, "20K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x10, "15K, 50K, Every 50K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x18, "15K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x20, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0) // factory default = "20K, 70K, Every70K"
-	PORT_DIPSETTING(    0x28, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x30, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0) /* Began with 5 fighters */
-	PORT_DIPSETTING(    0x38, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "15K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x10, "20K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x18, "20K and 100K Only" )     PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x20, "30K and 120K Only" )     PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x28, "30K, 80K, Every 80K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
+	PORT_DIPSETTING(    0x30, "15K and 50K Only" )      PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0) /* Began with 1, 2 or 3 fighters */
+	PORT_DIPSETTING(    0x38, "20K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x10, "15K, 50K, Every 50K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x18, "15K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0) // factory default = "20K, 70K, Every70K"
+	PORT_DIPSETTING(    0x28, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x30, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0) /* Began with 5 fighters */
+	PORT_DIPSETTING(    0x38, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "15K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x10, "20K and 70K Only" )      PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x18, "20K and 100K Only" )     PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "30K and 120K Only" )     PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x28, "30K, 80K, Every 80K" )   PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
 	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Lives ) )        PORT_DIPLOCATION("SWA:7,8")
 	PORT_DIPSETTING(    0x00, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
@@ -1181,22 +1181,22 @@
 	PORT_DIPSETTING(    0x05, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
 	PORT_DIPNAME( 0x38, 0x10, DEF_STR( Bonus_Life ) )   PORT_DIPLOCATION("SWA:4,5,6")
-	PORT_DIPSETTING(    0x20, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0) /* Began with 2, 3 or 4 fighters */
-	PORT_DIPSETTING(    0x18, "20K and 60K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x10, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0) // factory default = "20K, 70K, Every70K"
-	PORT_DIPSETTING(    0x30, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x38, "30K and 80K Only" )      PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x28, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x20, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0) /* Began with 5 fighters */
-	PORT_DIPSETTING(    0x18, "30K and 150K Only" )     PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x10, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x30, "30K, 150K, Every 150K" ) PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x38, "30K Only" )              PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "30K and 100K Only" )     PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x28, "30K and 120K Only" )     PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,PORTCOND_EQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0) /* Began with 2, 3 or 4 fighters */
+	PORT_DIPSETTING(    0x18, "20K and 60K Only" )      PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x10, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0) // factory default = "20K, 70K, Every70K"
+	PORT_DIPSETTING(    0x30, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x38, "30K and 80K Only" )      PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x28, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0) /* Began with 5 fighters */
+	PORT_DIPSETTING(    0x18, "30K and 150K Only" )     PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x10, "30K, 120K, Every 120K" ) PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x30, "30K, 150K, Every 150K" ) PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x38, "30K Only" )              PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "30K and 100K Only" )     PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x28, "30K and 120K Only" )     PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWB",0xc0,EQUALS,0xc0)
 	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Lives ) )        PORT_DIPLOCATION("SWA:7,8")
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x80, "3" ) // factory default = "3"
@@ -1268,22 +1268,22 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
 	PORT_DIPNAME( 0x1c, 0x1c, DEF_STR( Bonus_Life ) )   PORT_DIPLOCATION("SWA:3,4,5")
-	PORT_DIPSETTING(    0x18, "10K, 40K, Every 40K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x14, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "20K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x1c, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00) // factory default = "20K, 60K, Every60K"
-	PORT_DIPSETTING(    0x0c, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x04, "20K and 60K Only" )      PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0x60,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x14, "20K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x1c, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x0c, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x04, "20K and 80K Only" )      PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0x60,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "10K, 40K, Every 40K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x14, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "20K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x1c, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00) // factory default = "20K, 60K, Every60K"
+	PORT_DIPSETTING(    0x0c, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x04, "20K and 60K Only" )      PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0x60,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x14, "20K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x1c, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x0c, "20K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "30K, 100K, Every 100K" ) PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x04, "20K and 80K Only" )      PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0x60,EQUALS,0x00)
 	PORT_DIPNAME( 0x60, 0x60, DEF_STR( Lives ) )        PORT_DIPLOCATION("SWA:6,7")
 	PORT_DIPSETTING(    0x40, "1" )
 	PORT_DIPSETTING(    0x20, "2" )
@@ -1393,22 +1393,22 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_7C ) )
 	PORT_DIPNAME( 0x38, 0x18, DEF_STR( Bonus_Life ) )   PORT_DIPLOCATION("SWA:4,5,6")
-	PORT_DIPSETTING(    0x20, "10K, 40K, Every 40K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0) // Atari factory default = "10K, 40K, Every40K"
-	PORT_DIPSETTING(    0x10, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x30, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x28, "10K and 40K Only" )      PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x18, "20K and 60K Only" )      PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0) // Namco factory default = "20K, 60K"
-	PORT_DIPSETTING(    0x38, "10K Only" )              PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0xc0,PORTCOND_NOTEQUALS,0xc0)
-	PORT_DIPSETTING(    0x20, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x10, "30K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x30, "20K and 50K Only" )      PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x08, "20K and 60K Only" )      PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x28, "30K and 70K Only" )      PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x18, "20K Only" )              PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x38, "30K Only" )              PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0xc0,PORTCOND_EQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "10K, 40K, Every 40K" )   PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0) // Atari factory default = "10K, 40K, Every40K"
+	PORT_DIPSETTING(    0x10, "10K, 50K, Every 50K" )   PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x30, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "20K, 70K, Every 70K" )   PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x28, "10K and 40K Only" )      PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x18, "20K and 60K Only" )      PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0) // Namco factory default = "20K, 60K"
+	PORT_DIPSETTING(    0x38, "10K Only" )              PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0xc0,NOTEQUALS,0xc0)
+	PORT_DIPSETTING(    0x20, "20K, 60K, Every 60K" )   PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x10, "30K, 80K, Every 80K" )   PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x30, "20K and 50K Only" )      PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x08, "20K and 60K Only" )      PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x28, "30K and 70K Only" )      PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x18, "20K Only" )              PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x38, "30K Only" )              PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )         PORT_CONDITION("DSWA",0xc0,EQUALS,0xc0)
 	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Lives ) )        PORT_DIPLOCATION("SWA:7,8")
 	PORT_DIPSETTING(    0x00, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
diff -Nru src-old/mame/drivers/galastrm.c src/mame/drivers/galastrm.c
--- src-old/mame/drivers/galastrm.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/galastrm.c	2012-05-03 11:00:08.000000000 +0200
@@ -150,9 +150,9 @@
 	if (offset == 0x00)
 	{
 		if (ACCESSING_BITS_24_31)
-			return input_port_read(machine(), "STICKX") << 24;
+			return ioport("STICKX")->read() << 24;
 		if (ACCESSING_BITS_16_23)
-			return input_port_read(machine(), "STICKY") << 16;
+			return ioport("STICKY")->read() << 16;
 	}
 	return 0;
 }
diff -Nru src-old/mame/drivers/galaxia.c src/mame/drivers/galaxia.c
--- src-old/mame/drivers/galaxia.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/galaxia.c	2012-05-03 11:00:08.000000000 +0200
@@ -234,7 +234,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/galaxian.c src/mame/drivers/galaxian.c
--- src-old/mame/drivers/galaxian.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/galaxian.c	2012-05-03 11:00:08.000000000 +0200
@@ -452,7 +452,7 @@
 	galaxian_state *state = device->machine().driver_data<galaxian_state>();
 	interrupt_gen(device);
 
-	if (input_port_read_safe(device->machine(), "FAKE_SELECT", 0x00))
+	if (state->ioport("FAKE_SELECT")->read_safe(0x00))
 	{
 		state->m_tenspot_current_game++;
 		state->m_tenspot_current_game%=10;
@@ -1103,7 +1103,7 @@
 	const char *portname = (const char *)param;
 	if (m_gmgalax_selected_game != 0)
 		portname += strlen(portname) + 1;
-	return input_port_read(machine(), portname);
+	return ioport(portname)->read();
 }
 
 
@@ -1154,7 +1154,7 @@
 
 CUSTOM_INPUT_MEMBER(galaxian_state::azurian_port_r)
 {
-	return (input_port_read(machine(), "FAKE") >> (FPTR)param) & 1;
+	return (ioport("FAKE")->read() >> (FPTR)param) & 1;
 }
 
 
@@ -1168,7 +1168,7 @@
 CUSTOM_INPUT_MEMBER(galaxian_state::kingball_muxbit_r)
 {
 	/* multiplex the service mode switch with a speech DIP switch */
-	return (input_port_read(machine(), "FAKE") >> m_kingball_speech_dip) & 1;
+	return (ioport("FAKE")->read() >> m_kingball_speech_dip) & 1;
 }
 
 
@@ -2810,10 +2810,10 @@
 
 	/* ROM is banked */
 	space->install_read_bank(0x0000, 0x3fff, "bank1");
-	machine.root_device().membank("bank1")->configure_entries(0, 2, state->memregion("maincpu")->base() + 0x10000, 0x4000);
+	state->membank("bank1")->configure_entries(0, 2, state->memregion("maincpu")->base() + 0x10000, 0x4000);
 
 	/* callback when the game select is toggled */
-	state->gmgalax_game_changed(*machine.ioport().first_port()->fieldlist().first(), NULL, 0, 0);
+	state->gmgalax_game_changed(*machine.ioport().first_port()->first_field(), NULL, 0, 0);
 	state_save_register_global(machine, state->m_gmgalax_selected_game);
 }
 
@@ -2927,7 +2927,7 @@
 {
 	char tmp[64];
 	sprintf(tmp,"IN2_GAME%d", m_tenspot_current_game);
-	return input_port_read_safe(machine(), tmp, 0x00);
+	return ioport(tmp)->read_safe(0x00);
 }
 
 
@@ -3026,8 +3026,8 @@
 	/* make ROMs 2 & 3 swappable */
 	space->install_read_bank(0x2000, 0x2fff, "bank1");
 	space->install_read_bank(0x3000, 0x3fff, "bank2");
-	state->membank("bank1")->configure_entries(0, 2, machine.root_device().memregion("maincpu")->base() + 0x2000, 0x1000);
-	state->membank("bank2")->configure_entries(0, 2, machine.root_device().memregion("maincpu")->base() + 0x2000, 0x1000);
+	state->membank("bank1")->configure_entries(0, 2, state->memregion("maincpu")->base() + 0x2000, 0x1000);
+	state->membank("bank2")->configure_entries(0, 2, state->memregion("maincpu")->base() + 0x2000, 0x1000);
 
 	/* also re-install the fixed ROM area as a bank in order to inform the memory system that
        the fixed area only extends to 0x1fff */
@@ -3502,7 +3502,7 @@
 
 	/* extra ROM */
 	space->install_read_bank(0x5800, 0x67ff, "bank1");
-	state->membank("bank1")->set_base(machine.root_device().memregion("maincpu")->base() + 0x5800);
+	state->membank("bank1")->set_base(state->memregion("maincpu")->base() + 0x5800);
 
 	/* no background related */
 //  space->nop_write(0x6803, 0x6803);
diff -Nru src-old/mame/drivers/galaxold.c src/mame/drivers/galaxold.c
--- src-old/mame/drivers/galaxold.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/galaxold.c	2012-05-03 11:00:08.000000000 +0200
@@ -580,9 +580,9 @@
 ADDRESS_MAP_END
 
 READ8_MEMBER(galaxold_state::scramb2_protection_r){ return 0x25; }
-READ8_MEMBER(galaxold_state::scramb2_port0_r){ return (input_port_read(machine(), "IN0") >> offset) & 0x1; }
-READ8_MEMBER(galaxold_state::scramb2_port1_r){ return (input_port_read(machine(), "IN1") >> offset) & 0x1; }
-READ8_MEMBER(galaxold_state::scramb2_port2_r){ return (input_port_read(machine(), "IN2") >> offset) & 0x1; }
+READ8_MEMBER(galaxold_state::scramb2_port0_r){ return (ioport("IN0")->read() >> offset) & 0x1; }
+READ8_MEMBER(galaxold_state::scramb2_port1_r){ return (ioport("IN1")->read() >> offset) & 0x1; }
+READ8_MEMBER(galaxold_state::scramb2_port2_r){ return (ioport("IN2")->read() >> offset) & 0x1; }
 
 static ADDRESS_MAP_START( scramb2_map, AS_PROGRAM, 8, galaxold_state )
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
@@ -923,9 +923,9 @@
 	switch (bit_mask)
 	{
 		case 0x40:  /* vpool : IN1 (0xa800) bit 6 */
-			return ((input_port_read(machine(), "LIVES") & bit_mask) >> 6);
+			return ((ioport("LIVES")->read() & bit_mask) >> 6);
 		case 0x01:  /* vpool : DSW (0xb000) bit 0 */
-			return ((input_port_read(machine(), "LIVES") & bit_mask) >> 0);
+			return ((ioport("LIVES")->read() & bit_mask) >> 0);
 
 		default:
 			logerror("vpool_lives_r : invalid %02X bit_mask\n",bit_mask);
@@ -1070,14 +1070,14 @@
 	switch (bit_mask)
 	{
 		case 0x0c:  /* ckongg  : DSW (0xc800) bits 2 and 3 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 2);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 2);
 		case 0x40:  /* ckongg  : IN1 (0xc400) bit 6 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 6);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 6);
 
 		case 0xc0:  /* ckongmc : IN1 (0xa800) bits 6 and 7 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 6);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 6);
 		case 0x01:  /* ckongmc : DSW (0xb000) bit 0 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 0);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 0);
 
 		default:
 			logerror("ckongg_coinage_r : invalid %02X bit_mask\n",bit_mask);
@@ -1438,9 +1438,9 @@
 	switch (bit_mask)
 	{
 		case 0xc0:  /* dkongjrm : IN1 (0xa8??) bits 6 and 7 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 6);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 6);
 		case 0x01:  /* dkongjrm : DSW (0xb0??) bit 0 */
-			return ((input_port_read(machine(), "COINAGE") & bit_mask) >> 0);
+			return ((ioport("COINAGE")->read() & bit_mask) >> 0);
 
 		default:
 			logerror("dkongjrm_coinage_r : invalid %02X bit_mask\n",bit_mask);
@@ -1869,7 +1869,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -1933,7 +1933,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -1997,7 +1997,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -3000,6 +3000,42 @@
 	ROM_LOAD( "bot.clr",      0x0020, 0x0020, CRC(0f0782af) SHA1(32c0dd09ead5c70cee2657e9cb8cb9fcf54c5a6a) )
 ROM_END
 
+ROM_START( drivfrct )
+	ROM_REGION( 0x8000, "maincpu", 0 )
+	ROM_LOAD( "03.bin",       0x2800, 0x0400, CRC(9ab604cb) SHA1(772a5c0d93377f5bd7fc1f5e4050d44321a1bb8d) )
+	ROM_CONTINUE(			  0x2c00, 0x0400 )
+	ROM_CONTINUE(			  0x0000, 0x0400 )
+	ROM_CONTINUE(			  0x0400, 0x0400 )
+	ROM_CONTINUE(			  0x0800, 0x0400 )
+	ROM_CONTINUE(			  0x0c00, 0x0400 )
+	ROM_CONTINUE(			  0x2000, 0x0400 )
+	ROM_CONTINUE(			  0x2400, 0x0400 )
+	ROM_CONTINUE(			  0x6800, 0x0400 )
+	ROM_CONTINUE(			  0x6c00, 0x0400 )
+	ROM_CONTINUE(			  0x4000, 0x0400 )
+	ROM_CONTINUE(			  0x4400, 0x0400 )
+	ROM_CONTINUE(			  0x4800, 0x0400 )
+	ROM_CONTINUE(			  0x4c00, 0x0400 )
+	ROM_CONTINUE(			  0x6000, 0x0400 )
+	ROM_CONTINUE(			  0x6400, 0x0400 )
+
+	ROM_REGION( 0x4000, "gfx1", 0 )
+	ROM_LOAD( "01.bin",       0x1000, 0x1000, CRC(300a6750) SHA1(0760eb852706ef72c61e889309ee94edc49a13dc) )
+	ROM_CONTINUE(			  0x0000, 0x1000 )
+	ROM_LOAD( "02.bin",       0x3000, 0x1000, CRC(f04e14c4) SHA1(f628da48ad19c86000c56345fd96d415992bf9a9) )
+	ROM_CONTINUE(			  0x2000, 0x1000 )
+
+	/* piggy-backed colour proms */
+	ROM_REGION( 0x0040, "proms", 0 )
+	ROM_LOAD( "tbp18s030.02", 0x0000, 0x0020, CRC(3110ddae) SHA1(53b2e1cc07915592f6c868131ec296c63a407f04) )
+	ROM_LOAD( "tbp18s030.01", 0x0020, 0x0020, CRC(0f0782af) SHA1(32c0dd09ead5c70cee2657e9cb8cb9fcf54c5a6a) )
+
+	/* proms inside epoxy block with cpu */
+	ROM_REGION( 0x0300, "user1", 0 )
+	ROM_LOAD( "tbp24s10.bin", 0x0000, 0x0100, CRC(8c0d886d) SHA1(03bb942861a639f30797fcb22f048f7908404955) )
+	ROM_LOAD( "tbp28s42.bin", 0x0100, 0x0200, CRC(9b8f310a) SHA1(8e17cc1adf441aec56d98d0809e1359d5175e8ed) )
+ROM_END
+
 ROM_START( racknrol )
 	ROM_REGION( 0x8000, "maincpu", 0 )
 	ROM_LOAD( "horz_p.bin",   0x0000, 0x1000, CRC(32ca5b43) SHA1(f3e7662f947dcdd80f6eae4f002d2fe64a825aff) )
@@ -3096,7 +3132,8 @@
 /* S2650 games */
 GAME( 1983, hunchbkg, hunchbak,	hunchbkg, hunchbkg, 0,        ROT90,  "Century Electronics", "Hunchback (Galaxian hardware)", GAME_SUPPORTS_SAVE )
 GAME( 1984, drivfrcg, drivfrcp, drivfrcg, drivfrcg, 0,        ROT90,  "Shinkai Inc. (Magic Eletronics USA license)", "Driving Force (Galaxian conversion)", GAME_SUPPORTS_SAVE )
-GAME( 1985, drivfrcb, drivfrcp, drivfrcg, drivfrcg, 0,        ROT90,  "bootleg", "Driving Force (Galaxian conversion bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1984, drivfrct, drivfrcp, drivfrcg, drivfrcg, 0,        ROT90,  "bootleg (EMT Germany)", "Top Racer (bootleg of Driving Force)", GAME_SUPPORTS_SAVE ) // Video Klein PCB
+GAME( 1985, drivfrcb, drivfrcp, drivfrcg, drivfrcg, 0,        ROT90,  "bootleg (Elsys Software)", "Driving Force (Galaxian conversion bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1986, racknrol, 0,        racknrol, racknrol, 0,	      ROT0,   "Senko Industries (Status license from Shinkai Inc.)", "Rack + Roll", GAME_SUPPORTS_SAVE )
 GAME( 1986, hexpool,  racknrol, racknrol, racknrol, 0,	      ROT90,  "Senko Industries (Shinkai Inc. license)", "Hex Pool (Shinkai)", GAME_SUPPORTS_SAVE ) // still has Senko logo in gfx rom
 GAME( 1985, hexpoola, racknrol, hexpoola, racknrol, 0,	      ROT90,  "Senko Industries", "Hex Pool (Senko)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/galdrvr.c src/mame/drivers/galdrvr.c
--- src-old/mame/drivers/galdrvr.c	2012-04-12 11:28:12.000000000 +0200
+++ src/mame/drivers/galdrvr.c	2012-05-07 08:57:50.000000000 +0200
@@ -898,37 +898,37 @@
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_SPECIAL) PORT_CUSTOM_MEMBER(DEVICE_SELF, galaxian_state, gmgalax_port_r, "GMIN2\0GLIN2")
 
 	PORT_START("GMIN0")      /* Ghost Muncher - IN0 */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )	                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP) PORT_4WAY PORT_COCKTAIL     PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY                PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY               PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNUSED )                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPNAME( 0x20, 0x00, "Ghost Muncher - Cabinet" )                        PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )	                                 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP) PORT_4WAY PORT_COCKTAIL     PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY                PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY               PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNUSED )                                 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_DIPNAME( 0x20, 0x00, "Ghost Muncher - Cabinet" )                        PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY                PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_4WAY                  PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY                PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_4WAY                  PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
 
 	PORT_START("GMIN1")      /* Ghost Muncher - IN1 */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNUSED )	                             PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPNAME( 0xc0, 0x40, "Ghost Muncher - Bonus Life" )                     PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )                                 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )                                 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNUSED )	                             PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
+	PORT_DIPNAME( 0xc0, 0x40, "Ghost Muncher - Bonus Life" )                     PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
 	PORT_DIPSETTING(    0x40, "10000" )
 	PORT_DIPSETTING(    0x80, "15000" )
 	PORT_DIPSETTING(    0xc0, "20000" )
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
 
 	PORT_START("GMIN2")      /* Ghost Muncher - IN2 */
-	PORT_DIPNAME( 0x03, 0x02, "Ghost Muncher - Coinage" )	                     PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_DIPNAME( 0x03, 0x02, "Ghost Muncher - Coinage" )	                     PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x0c, 0x04, "Ghost Muncher - Lives" )	                         PORT_CONDITION("GAMESEL",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_DIPNAME( 0x0c, 0x04, "Ghost Muncher - Lives" )	                         PORT_CONDITION("GAMESEL",0x01,NOTEQUALS,0x01)
 	PORT_DIPSETTING(    0x0c, "1" )
 	PORT_DIPSETTING(    0x08, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
@@ -936,37 +936,37 @@
 	PORT_BIT( 0xf0, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("GLIN0")      /* Galaxian - IN0 */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )                                  PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 )                                  PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY                PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY               PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )                                PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPNAME( 0x20, 0x00, "Galaxian - Cabinet" )                             PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )                                  PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 )                                  PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY                PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY               PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )                                PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_DIPNAME( 0x20, 0x00, "Galaxian - Cabinet" )                             PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
-	PORT_SERVICE( 0x40, IP_ACTIVE_HIGH )                                         PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SERVICE1 )                               PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
+	PORT_SERVICE( 0x40, IP_ACTIVE_HIGH )                                         PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SERVICE1 )                               PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
 
 	PORT_START("GLIN1")      /* Galaxian - IN1 */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )                                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL	                 PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNUSED )	                             PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPNAME( 0xc0, 0x00, "Galaxian - Coinage" )	                         PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )                                 PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )                                 PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_COCKTAIL	 PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL	                 PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNUSED )	                             PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
+	PORT_DIPNAME( 0xc0, 0x00, "Galaxian - Coinage" )	                         PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
 	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0xc0, DEF_STR( Free_Play ) )
 
 	PORT_START("GLIN2")      /* Galaxian - IN2 */
-	PORT_DIPNAME( 0x03, 0x01, "Galaxian - Bonus Life" )                          PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
+	PORT_DIPNAME( 0x03, 0x01, "Galaxian - Bonus Life" )                          PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
 	PORT_DIPSETTING(    0x01, "4000" )
 	PORT_DIPSETTING(    0x02, "5000" )
 	PORT_DIPSETTING(    0x03, "7000" )
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
-	PORT_DIPNAME( 0x04, 0x00, "Galaxian - Lives" )                               PORT_CONDITION("GAMESEL",0x01,PORTCOND_EQUALS,0x01)
+	PORT_DIPNAME( 0x04, 0x00, "Galaxian - Lives" )                               PORT_CONDITION("GAMESEL",0x01,EQUALS,0x01)
 	PORT_DIPSETTING(    0x00, "3" )
 	PORT_DIPSETTING(    0x04, "5" )
 	PORT_DIPUNUSED( 0x08, 0x00 )
@@ -2489,7 +2489,7 @@
 	// see http://www.cityofberwyn.com/schematics/stern/MoonWar_opto.tiff for schematic
 	// I.e. a 74ls161 counts from 0 to 15 which is the absolute number of bars passed on the quadrature
 
-	signed char dialread = input_port_read(machine(), dialname[p]);
+	signed char dialread = ioport(dialname[p])->read();
 
 	UINT8 ret;
 
@@ -2521,8 +2521,8 @@
 	PORT_DIPSETTING(    0x03, DEF_STR( Free_Play ) )                  /* see notes */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL PORT_CONDITION("IN2", 0x08, PORTCOND_EQUALS, 0x08) // cocktail: p2 thrust
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_CONDITION("IN2", 0x08, PORTCOND_EQUALS, 0x00) // upright: p1&p2 hyperflip
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL PORT_CONDITION("IN2", 0x08, EQUALS, 0x08) // cocktail: p2 thrust
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_CONDITION("IN2", 0x08, EQUALS, 0x00) // upright: p1&p2 hyperflip
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON3 ) // both: p1(upright: &p2) shield
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2 ) // both: p1(upright: &p2) thrust
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) // both: p1(upright: &p2) fire
@@ -2543,8 +2543,8 @@
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("P1_DIAL")
-	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(4) PORT_REVERSE PORT_RESET PORT_CONDITION("IN2", 0x08, PORTCOND_EQUALS, 0x08) // cocktail: dial is reversed
-	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(4) PORT_RESET PORT_CONDITION("IN2", 0x08, PORTCOND_EQUALS, 0x00) // upright: dial works normally
+	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(4) PORT_REVERSE PORT_RESET PORT_CONDITION("IN2", 0x08, EQUALS, 0x08) // cocktail: dial is reversed
+	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(4) PORT_RESET PORT_CONDITION("IN2", 0x08, EQUALS, 0x00) // upright: dial works normally
 
 	PORT_START("P2_DIAL")
 	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(25) PORT_KEYDELTA(4) PORT_RESET PORT_COCKTAIL PORT_REVERSE // cocktail: dial is reversed
@@ -4203,6 +4203,27 @@
 	ROM_LOAD( "mmi6331.6l", 0x0000, 0x0020, CRC(6a0c7d87) SHA1(140335d85c67c75b65689d4e76d29863c209cf32) ) /* Compatible with 82s123 prom */
 ROM_END
 
+ROM_START( mooncrstuku )
+	ROM_REGION( 0x8000, "maincpu", 0 )
+	ROM_LOAD( "smc1f",        0x0000, 0x0800, CRC(389ca0d6) SHA1(51cf6d190a0ebf23b70c2bcf1ccaa4705e29cd09) )
+	ROM_LOAD( "smc2f",        0x0800, 0x0800, CRC(410ab430) SHA1(d89abff6ac4afbf69377a1d63043d629a634aab7) )
+	ROM_LOAD( "smc3f",        0x1000, 0x0800, CRC(a6b4144b) SHA1(2b27ad54d716286c0dc9476d47df182ae01bcfd7) )
+	ROM_LOAD( "smc4f",        0x1800, 0x0800, CRC(4cc046fe) SHA1(465eaacd50967d768babadd09ab9cad35380f6bf) )
+	ROM_LOAD( "smc5f",  	  0x2000, 0x0800, CRC(06d378a6) SHA1(99dbe9fc7f95f8fdce86eb5c32bd1ca1bea0ca3c) )
+	ROM_LOAD( "smc6f",        0x2800, 0x0800, CRC(6e84a927) SHA1(82e8e825d157c3c947a3a222bca059a735169c7d) )
+	ROM_LOAD( "smc7f",        0x3000, 0x0800, CRC(b45af1e8) SHA1(d7020774707234acdaef5c655f667d5ee9e54a13) )
+	ROM_LOAD( "smc8f_uk",     0x3800, 0x0800, CRC(b968b2ff) SHA1(40105423f48d2260e85597c3c1e4d8fe947db793) )
+
+	ROM_REGION( 0x2000, "gfx1", 0 )
+	ROM_LOAD( "mcs_b",        0x0000, 0x0800, CRC(fb0f1f81) SHA1(38a6679a8b69bc1870a0e67e692131c42f9535c8) )
+	ROM_LOAD( "mcs_d",        0x0800, 0x0800, CRC(13932a15) SHA1(b8885c555c6ad7021be55c6925a0a0872c1b6abd) )
+	ROM_LOAD( "mcs_a",        0x1000, 0x0800, CRC(631ebb5a) SHA1(5bc9493afa76c55858b8c8849524cbc77dc838fc) )
+	ROM_LOAD( "mcs_c",        0x1800, 0x0800, CRC(24cfd145) SHA1(08c6599db170dd6ee364c44f70a0f5c0f881b6ef) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "mmi6331.6l", 0x0000, 0x0020, CRC(6a0c7d87) SHA1(140335d85c67c75b65689d4e76d29863c209cf32) ) /* Compatible with 82s123 prom */
+ROM_END
+
 ROM_START( mooncrstu )
 	ROM_REGION( 0x8000, "maincpu", 0 )
 	ROM_LOAD( "smc1f",        0x0000, 0x0800, CRC(389ca0d6) SHA1(51cf6d190a0ebf23b70c2bcf1ccaa4705e29cd09) )
@@ -6421,11 +6442,12 @@
  *************************************/
 
 /* based on Galaxian, but with altered address map for more ROM */
-GAME( 1980, mooncrst,  0,        mooncrst, mooncrst, mooncrst, ROT90,  "Nichibutsu", "Moon Cresta (Nichibutsu)", GAME_SUPPORTS_SAVE )
-GAME( 1980, mooncrstuk,mooncrst, mooncrst, mooncrst, mooncrst, ROT90,  "Nichibutsu UK", "Moon Cresta (Nichibutsu UK)", GAME_SUPPORTS_SAVE )
-GAME( 1980, mooncrstu, mooncrst, mooncrst, mooncrst, mooncrsu, ROT90,  "Nichibutsu USA", "Moon Cresta (Nichibutsu USA, unencrypted)", GAME_SUPPORTS_SAVE )
-GAME( 1980, mooncrsto, mooncrst, mooncrst, mooncrsa, mooncrst, ROT90,  "Nichibutsu", "Moon Cresta (Nichibutsu, old rev)", GAME_SUPPORTS_SAVE )
-GAME( 1980, mooncrstg, mooncrst, mooncrst, mooncrsg, mooncrsu, ROT90,  "Nichibutsu (Gremlin license)", "Moon Cresta (Gremlin)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrst,   0,        mooncrst, mooncrst, mooncrst, ROT90,  "Nichibutsu", "Moon Cresta (Nichibutsu)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrstuk, mooncrst, mooncrst, mooncrst, mooncrst, ROT90,  "Nichibutsu UK", "Moon Cresta (Nichibutsu UK)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrstuku,mooncrst, mooncrst, mooncrst, mooncrsu, ROT90,  "Nichibutsu UK", "Moon Cresta (Nichibutsu UK, unencrypted)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrstu,  mooncrst, mooncrst, mooncrst, mooncrsu, ROT90,  "Nichibutsu USA", "Moon Cresta (Nichibutsu USA, unencrypted)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrsto,  mooncrst, mooncrst, mooncrsa, mooncrst, ROT90,  "Nichibutsu", "Moon Cresta (Nichibutsu, old rev)", GAME_SUPPORTS_SAVE )
+GAME( 1980, mooncrstg,  mooncrst, mooncrst, mooncrsg, mooncrsu, ROT90,  "Nichibutsu (Gremlin license)", "Moon Cresta (Gremlin)", GAME_SUPPORTS_SAVE )
 
 /* straight Moon Cresta ripoffs on basic mooncrst hardware */
 GAME( 1980, mooncrsb, mooncrst, mooncrst, mooncrsa, mooncrsu, ROT90,  "bootleg", "Moon Cresta (bootleg set 1)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/galivan.c src/mame/drivers/galivan.c
--- src-old/mame/drivers/galivan.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/galivan.c	2012-05-03 11:00:08.000000000 +0200
@@ -1085,7 +1085,7 @@
 	galivan_state *state = machine.driver_data<galivan_state>();
 	machine.device("maincpu")->memory().space(AS_IO)->install_write_handler(0x82, 0x82, write8_delegate(FUNC(galivan_state::youmab_extra_bank_w),state)); // banks rom at 0x8000? writes 0xff and 0x00 before executing code there
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_bank(0x0000, 0x7fff, "bank3");
-	state->membank("bank3")->set_base(machine.root_device().memregion("maincpu")->base());
+	state->membank("bank3")->set_base(state->memregion("maincpu")->base());
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_bank(0x8000, 0xbfff, "bank2");
 	state->membank("bank2")->configure_entries(0, 2, state->memregion("user2")->base(), 0x4000);
diff -Nru src-old/mame/drivers/galpani3.c src/mame/drivers/galpani3.c
--- src-old/mame/drivers/galpani3.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/galpani3.c	2012-05-03 11:00:08.000000000 +0200
@@ -529,7 +529,7 @@
 	{
 		case 0x03:	// DSW
 		{
-			state->m_mcu_ram[mcu_offset] = input_port_read(machine, "DSW");
+			state->m_mcu_ram[mcu_offset] = state->ioport("DSW")->read();
 			logerror("%s : MCU executed command: %04X %04X (read DSW)\n", machine.describe_context(), mcu_command, mcu_offset*2);
 		}
 		break;
diff -Nru src-old/mame/drivers/gameplan.c src/mame/drivers/gameplan.c
--- src-old/mame/drivers/gameplan.c	2012-04-09 22:23:26.000000000 +0200
+++ src/mame/drivers/gameplan.c	2012-05-03 11:00:08.000000000 +0200
@@ -110,7 +110,7 @@
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3", "DSW0", "DSW1" };
 	gameplan_state *state = device->machine().driver_data<gameplan_state>();
 
-	return input_port_read(device->machine(), portnames[state->m_current_port]);
+	return state->ioport(portnames[state->m_current_port])->read();
 }
 
 
diff -Nru src-old/mame/drivers/gauntlet.c src/mame/drivers/gauntlet.c
--- src-old/mame/drivers/gauntlet.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gauntlet.c	2012-05-03 11:00:08.000000000 +0200
@@ -187,7 +187,7 @@
 
 READ16_MEMBER(gauntlet_state::port4_r)
 {
-	int temp = input_port_read(machine(), "803008");
+	int temp = ioport("803008")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0020;
 	if (m_sound_to_cpu_ready) temp ^= 0x0010;
 	return temp;
@@ -240,7 +240,7 @@
 	if (m_cpu_to_sound_ready) temp ^= 0x80;
 	if (m_sound_to_cpu_ready) temp ^= 0x40;
 	if (!tms5220_readyq_r(machine().device("tms"))) temp ^= 0x20;
-	if (!(input_port_read(machine(), "803008") & 0x0008)) temp ^= 0x10;
+	if (!(ioport("803008")->read() & 0x0008)) temp ^= 0x10;
 
 	return temp;
 }
@@ -408,7 +408,7 @@
 	PORT_BIT( 0x0007, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_SERVICE( 0x0008, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0030, IP_ACTIVE_HIGH, IPT_SPECIAL )
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW,  IPT_VBLANK )
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW,  IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff80, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("COIN")	/* 1020 (sound) */
@@ -455,7 +455,7 @@
 	PORT_BIT( 0x0007, IP_ACTIVE_HIGH, IPT_UNUSED )
 	PORT_SERVICE( 0x0008, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0030, IP_ACTIVE_HIGH, IPT_SPECIAL )
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW,  IPT_VBLANK )
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW,  IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff80, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("COIN")	/* 1020 (sound) */
diff -Nru src-old/mame/drivers/gcpinbal.c src/mame/drivers/gcpinbal.c
--- src-old/mame/drivers/gcpinbal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gcpinbal.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,13 +82,13 @@
 	switch (offset)
 	{
 		case 0x80/2:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 0x84/2:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 
 		case 0x86/2:
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 
 		case 0x50:
 		case 0x51:
diff -Nru src-old/mame/drivers/gei.c src/mame/drivers/gei.c
--- src-old/mame/drivers/gei.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gei.c	2012-05-07 08:57:50.000000000 +0200
@@ -719,10 +719,10 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x00) PORT_NAME ("Start in no coins mode")
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN ) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x40)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x00) PORT_NAME ("Start in no coins mode")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x40)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN ) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x00)
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("ticket", ticket_dispenser_device, line_r)		/* ticket status */
 	PORT_SERVICE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -896,10 +896,10 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x00) PORT_NAME ("Start in no coins mode")
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x40)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN ) PORT_CONDITION("DSWA", 0x40, PORTCOND_EQUALS, 0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x40)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x00) PORT_NAME ("Start in no coins mode")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(2) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x40)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN ) PORT_CONDITION("DSWA", 0x40, EQUALS, 0x00)
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("ticket", ticket_dispenser_device, line_r)		/* ticket status */
 	PORT_SERVICE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1695,49 +1695,51 @@
 	/* Missing "General Facts" */
 ROM_END
 
-ROM_START( gt103a1 )
+ROM_START( gtsers12 )
 	ROM_REGION( 0x38000, "maincpu", 0 )
-	ROM_LOAD( "prog1_versiona",  0x00000, 0x4000, CRC(537d6566) SHA1(282a33e4a9fc54d34094393c00026bf31ccd6ab5) )
-	ROM_LOAD( "new_science_2",   0x10000, 0x8000, CRC(3bd80fb8) SHA1(9a196595bc5dc6ed5ee5853786839ed4847fa436) ) /* Questions from an unknown set, will be corrected when verified */
-	ROM_LOAD( "nfl_football",    0x18000, 0x8000, CRC(d676b7cd) SHA1(d652d2441adb500f7af526d110d0335ea453d75b) ) /* These questions are likely mix-n-match do to opperator swaps   */
-	ROM_LOAD( "rock_music",      0x20000, 0x8000, CRC(7f11733a) SHA1(d4d0dee75518edf986cb1241ade45ccb4840f088) ) /* Currently unverified are Series 12, 13 & 14 */
-	ROM_LOAD( "war_and_peace",   0x28000, 0x8000, CRC(bc709383) SHA1(2fba4c80773abea7bbd826c39378b821cddaa255) )
-	ROM_LOAD( "entertainment",   0x30000, 0x8000, CRC(07068c9f) SHA1(1aedc78d071281ec8b08488cd82655d41a77cf6b) )
+	ROM_LOAD( "prog1_versionc",  0x00000, 0x4000, CRC(340246a4) SHA1(d655e1cf2b1e87a05e87ff6af4b794e6d54a2a52) )
+	ROM_LOAD( "new_science_2",   0x10000, 0x8000, CRC(3bd80fb8) SHA1(9a196595bc5dc6ed5ee5853786839ed4847fa436) )
+	ROM_LOAD( "adult_sex_4",     0x18000, 0x8000, CRC(36a75071) SHA1(f08d31f241e1dc9b94b940cd2872a692f6f8475b) )
+	ROM_LOAD( "cops_&_robbers",  0x20000, 0x8000, CRC(8b367c33) SHA1(013468157bf469c9cf138809fdc45b3ba60a423b) )
+	ROM_LOAD( "famous_quotes",   0x28000, 0x8000, CRC(0a27d8ae) SHA1(427e6ae25e47da7f7f7c3e92a37e330d711da90c) )
+	ROM_LOAD( "vices",           0x30000, 0x8000, CRC(e6069955) SHA1(68f7453f21a4ce1be912141bbe947fbd81d918a3) )
 ROM_END
 
-ROM_START( gt103a2 )
+ROM_START( gtsers14 )
 	ROM_REGION( 0x38000, "maincpu", 0 )
 	ROM_LOAD( "prog1_versionc",  0x00000, 0x4000, CRC(340246a4) SHA1(d655e1cf2b1e87a05e87ff6af4b794e6d54a2a52) )
-	ROM_LOAD( "vices",           0x10000, 0x8000, CRC(e6069955) SHA1(68f7453f21a4ce1be912141bbe947fbd81d918a3) ) /* Questions from an unknown set, will be corrected when verified */
-	ROM_LOAD( "cops_&_robbers",  0x18000, 0x8000, CRC(8b367c33) SHA1(013468157bf469c9cf138809fdc45b3ba60a423b) ) /* These questions are likely mix-n-match do to opperator swaps   */
-	ROM_LOAD( "famous_couples",  0x20000, 0x8000, CRC(e0618218) SHA1(ff64fcd6dec83a2271b63c3ae64dc932a3954ec5) ) /* Currently unverified are Series 12, 13 & 14 */
-	ROM_LOAD( "famous_quotes",   0x28000, 0x8000, CRC(0a27d8ae) SHA1(427e6ae25e47da7f7f7c3e92a37e330d711da90c) )
+	ROM_LOAD( "famous_couples",  0x10000, 0x8000, CRC(e0618218) SHA1(ff64fcd6dec83a2271b63c3ae64dc932a3954ec5) )
+	ROM_LOAD( "war_and_peace",   0x18000, 0x8000, CRC(bc709383) SHA1(2fba4c80773abea7bbd826c39378b821cddaa255) )
+	ROM_LOAD( "tv_comedies",     0x20000, 0x8000, CRC(992ae38e) SHA1(312780d651a85a1c433f587ff2ede579456d3fd9) )
+	ROM_LOAD( "the_sixties",     0x28000, 0x8000, CRC(8cfa854e) SHA1(81428c12f99841db1c61b471ac8d00f0c411883b) )
+	/* Missing "New Sports" */
 ROM_END
 
-ROM_START( gt103a3 )
+ROM_START( gt103a1 ) /* Need to verify these are actually Series 13 */
 	ROM_REGION( 0x38000, "maincpu", 0 )
-	ROM_LOAD( "t_3a-8_1.bin",    0x00000, 0x4000, CRC(02aef306) SHA1(1ffc10c79a55d41ea36bcaab13cb3f02cb3f9712) )
-	ROM_LOAD( "rock-n-roll_alt", 0x10000, 0x8000, CRC(8eb83052) SHA1(93e3c1ae6c2048fb44ecafe1013b6a96da38fa84) ) /* Questions from an unknown set, will be corrected when verified */
-	ROM_LOAD( "history-geog",    0x18000, 0x8000, CRC(c9a70fc3) SHA1(4021e5d702844416e8c798ed0a57c9ecd20b1d4b) ) /* These questions are likely mix-n-match do to opperator swaps   */
-	ROM_LOAD( "the_sixties",     0x20000, 0x8000, CRC(8cfa854e) SHA1(81428c12f99841db1c61b471ac8d00f0c411883b) ) /* Currently unverified are Series 12, 13 & 14 */
-	ROM_LOAD( "tv_comedies",     0x28000, 0x8000, CRC(992ae38e) SHA1(312780d651a85a1c433f587ff2ede579456d3fd9) )
+	ROM_LOAD( "prog1_versiona",  0x00000, 0x4000, CRC(537d6566) SHA1(282a33e4a9fc54d34094393c00026bf31ccd6ab5) ) /* Currently unverified Series 13 */
+	ROM_LOAD( "history-geog",    0x10000, 0x8000, CRC(c9a70fc3) SHA1(4021e5d702844416e8c798ed0a57c9ecd20b1d4b) )
+	ROM_LOAD( "nfl_football",    0x18000, 0x8000, CRC(d676b7cd) SHA1(d652d2441adb500f7af526d110d0335ea453d75b) )
+	ROM_LOAD( "rock_music",      0x20000, 0x8000, CRC(7f11733a) SHA1(d4d0dee75518edf986cb1241ade45ccb4840f088) )
+	ROM_LOAD( "rock-n-roll_alt", 0x28000, 0x8000, CRC(8eb83052) SHA1(93e3c1ae6c2048fb44ecafe1013b6a96da38fa84) )
+	ROM_LOAD( "entertainment",   0x30000, 0x8000, CRC(07068c9f) SHA1(1aedc78d071281ec8b08488cd82655d41a77cf6b) )
 ROM_END
 
 ROM_START( gt103aa )
 	ROM_REGION( 0x38000, "maincpu", 0 )
 	ROM_LOAD( "t_3a-8_1.bin",      0x00000, 0x4000, CRC(02aef306) SHA1(1ffc10c79a55d41ea36bcaab13cb3f02cb3f9712) )
-	ROM_LOAD( "entertainment_alt", 0x10000, 0x8000, CRC(9a6628b9) SHA1(c0cb7e974329d4d5b91f107296d21a674e35a51b) ) /* Questions from an unknown set, will be corrected when verified */
-	ROM_LOAD( "general_alt",       0x18000, 0x8000, CRC(df34f7f9) SHA1(329d123eea711d5135dc02dd7b89b220ce8ddd28) ) /* These questions are likely mix-n-match do to opperator swaps   */
-	ROM_LOAD( "science_alt",       0x20000, 0x8000, CRC(9eaebd18) SHA1(3a4d787cb006dbb23ce346577cb1bb5e543ba52c) ) /* Currently unverified are Series 12, 13 & 14 */
+	ROM_LOAD( "entertainment_alt", 0x10000, 0x8000, CRC(9a6628b9) SHA1(c0cb7e974329d4d5b91f107296d21a674e35a51b) )
+	ROM_LOAD( "general_alt",       0x18000, 0x8000, CRC(df34f7f9) SHA1(329d123eea711d5135dc02dd7b89b220ce8ddd28) )
+	ROM_LOAD( "science_alt",       0x20000, 0x8000, CRC(9eaebd18) SHA1(3a4d787cb006dbb23ce346577cb1bb5e543ba52c) )
 	ROM_LOAD( "science_alt2",      0x28000, 0x8000, CRC(ac93d348) SHA1(55550ba6b5daffdf9653854075ad4f8398a5e621) )
 	ROM_LOAD( "sports_alt2",       0x30000, 0x8000, CRC(40207845) SHA1(2dddb9685dcefabfde07057a639aa9d08da2329e) )
 ROM_END
 
 ROM_START( gt103asx )
 	ROM_REGION( 0x38000, "maincpu", 0 )
-	ROM_LOAD( "t_3a-8_1.bin",    0x00000, 0x4000, CRC(02aef306) SHA1(1ffc10c79a55d41ea36bcaab13cb3f02cb3f9712) )
-	ROM_LOAD( "adult_sex_2",     0x10000, 0x8000, CRC(0d683f21) SHA1(f47ce3c31c4c5ed02247fa280303e6ae760315df) )
-	ROM_LOAD( "adult_sex_2_alt", 0x18000, 0x8000, CRC(8c0eacc8) SHA1(ddaa25548d161394b41c65a2db57a9fcf793062b) )
+	ROM_LOAD( "t_3a-8_1.bin",    0x00000, 0x4000, CRC(02aef306) SHA1(1ffc10c79a55d41ea36bcaab13cb3f02cb3f9712) ) /* Not sure there was ever a specific Adult set  */
+	ROM_LOAD( "adult_sex_2",     0x10000, 0x8000, CRC(0d683f21) SHA1(f47ce3c31c4c5ed02247fa280303e6ae760315df) ) /* These are likely just the collection of adult */
+	ROM_LOAD( "adult_sex_2_alt", 0x18000, 0x8000, CRC(8c0eacc8) SHA1(ddaa25548d161394b41c65a2db57a9fcf793062b) ) /* from all the series combined here. */
 	ROM_LOAD( "adult_sex_3_alt", 0x20000, 0x8000, CRC(63cbd1d6) SHA1(8dcd5546dc8688d6b8404d5cf63d8a59acc9bf4c) )
 	ROM_LOAD( "adult_sex_4",     0x28000, 0x8000, CRC(36a75071) SHA1(f08d31f241e1dc9b94b940cd2872a692f6f8475b) )
 	ROM_LOAD( "adult_sex_5",     0x30000, 0x8000, CRC(fdbc3729) SHA1(7cb7cec4439ddc39de2f7f62c25623cfb869f493) )
@@ -1909,9 +1911,9 @@
 GAME( 1984, gtsers9,  gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Questions Series 9)",             GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1984, gtsers10, gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Questions Series 10)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1984, gtsers11, gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Questions Series 11)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
+GAME( 1984, gtsers12, gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Questions Series 12)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
+GAME( 1984, gtsers14, gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Questions Series 14)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1984, gt103a1,  gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Version 1.03a) (alt 1)",          GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
-GAME( 1984, gt103a2,  gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Version 1.03a) (alt 2)",          GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
-GAME( 1984, gt103a3,  gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Version 1.03a) (alt 3)",          GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1984, gt103aa,  gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Version 1.03a Alt questions)",    GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1984, gt103asx, gtsers8,  findout,  gt103a,   0,       ROT0, "Greyhound Electronics", "Trivia (Version 1.03a Sex questions)",    GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 
diff -Nru src-old/mame/drivers/gijoe.c src/mame/drivers/gijoe.c
--- src-old/mame/drivers/gijoe.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gijoe.c	2012-05-03 11:00:08.000000000 +0200
@@ -74,7 +74,7 @@
 		/* bit 3  (unknown: coin) */
 		/* bit 5  is enable irq 6 */
 		/* bit 7  (unknown: enable irq 5?) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 
 		m_cur_control2 = data;
 
diff -Nru src-old/mame/drivers/gladiatr.c src/mame/drivers/gladiatr.c
--- src-old/mame/drivers/gladiatr.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/gladiatr.c	2012-05-03 11:00:08.000000000 +0200
@@ -202,14 +202,14 @@
 
 static READ8_HANDLER( gladiator_dsw1_r )
 {
-	int orig = input_port_read(space->machine(), "DSW1")^0xff;
+	int orig = space->machine().root_device().ioport("DSW1")->read()^0xff;
 
 	return BITSWAP8(orig, 0,1,2,3,4,5,6,7);
 }
 
 static READ8_HANDLER( gladiator_dsw2_r )
 {
-	int orig = input_port_read(space->machine(), "DSW2")^0xff;
+	int orig = space->machine().root_device().ioport("DSW2")->read()^0xff;
 
 	return BITSWAP8(orig, 2,3,4,5,6,7,1,0);
 }
@@ -218,15 +218,15 @@
 {
 	int coins = 0;
 
-	if( input_port_read(space->machine(), "COINS") & 0xc0 ) coins = 0x80;
+	if( space->machine().root_device().ioport("COINS")->read() & 0xc0 ) coins = 0x80;
 	switch(offset)
 	{
 	case 0x01: /* start button , coins */
-		return input_port_read(space->machine(), "IN0") | coins;
+		return space->machine().root_device().ioport("IN0")->read() | coins;
 	case 0x02: /* Player 1 Controller , coins */
-		return input_port_read(space->machine(), "IN1") | coins;
+		return space->machine().root_device().ioport("IN1")->read() | coins;
 	case 0x04: /* Player 2 Controller , coins */
-		return input_port_read(space->machine(), "IN2") | coins;
+		return space->machine().root_device().ioport("IN2")->read() | coins;
 	}
 	/* unknown */
 	return 0;
@@ -237,7 +237,7 @@
 	switch(offset)
 	{
 	case 0x01: /* button 3 */
-		return input_port_read(space->machine(), "IN3");
+		return space->machine().root_device().ioport("IN3")->read();
 	}
 	/* unknown */
 	return 0;
diff -Nru src-old/mame/drivers/globalfr.c src/mame/drivers/globalfr.c
--- src-old/mame/drivers/globalfr.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/globalfr.c	2012-04-24 13:58:27.000000000 +0200
@@ -38,7 +38,7 @@
 {
 	globalfr_state *state = space->machine().driver_data<globalfr_state>();
 
-	int clock = (data & 0x40);
+	bool clock = (data & 0x40) != 0;
 	int datline = (data & 0x80);
 
 	//Unlike MPU4, this uses positive transitions on both lines, so this may be a similar, but not identical component
diff -Nru src-old/mame/drivers/go2000.c src/mame/drivers/go2000.c
--- src-old/mame/drivers/go2000.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/go2000.c	2012-05-03 11:00:08.000000000 +0200
@@ -136,14 +136,14 @@
 	PORT_DIPSETTING(      0x0100, "7" )
 	PORT_DIPSETTING(      0x0000, "8" )
 	PORT_DIPNAME( 0x1800, 0x1800, "M1 value" ) PORT_DIPLOCATION("SW-2:4,5")
-	PORT_DIPSETTING(      0x0800, "3000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, "3500" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1800, "4000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1000, "4500" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0800, "6000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, "7000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1800, "8000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1000, "9000" ) PORT_CONDITION("DSW", 0x0003, PORTCOND_NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0800, "3000" ) PORT_CONDITION("DSW", 0x0003, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, "3500" ) PORT_CONDITION("DSW", 0x0003, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1800, "4000" ) PORT_CONDITION("DSW", 0x0003, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1000, "4500" ) PORT_CONDITION("DSW", 0x0003, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0800, "6000" ) PORT_CONDITION("DSW", 0x0003, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, "7000" ) PORT_CONDITION("DSW", 0x0003, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1800, "8000" ) PORT_CONDITION("DSW", 0x0003, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1000, "9000" ) PORT_CONDITION("DSW", 0x0003, NOTEQUALS, 0x0000)
 	PORT_DIPUNKNOWN_DIPLOC( 0x2000, IP_ACTIVE_LOW, "SW-2:6" )
 	PORT_DIPNAME( 0xc000, 0xc000, "Difficult-2" ) PORT_DIPLOCATION("SW-2:7,8")
 	PORT_DIPSETTING(      0xc000, "1" )
diff -Nru src-old/mame/drivers/goal92.c src/mame/drivers/goal92.c
--- src-old/mame/drivers/goal92.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/goal92.c	2012-05-03 11:00:08.000000000 +0200
@@ -29,15 +29,15 @@
 	switch(offset)
 	{
 		case 0:
-			return input_port_read(machine(), "DSW1");
+			return ioport("DSW1")->read();
 		case 1:
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 		case 2:
-			return input_port_read(machine(), "IN2");
+			return ioport("IN2")->read();
 		case 3:
-			return input_port_read(machine(), "IN3");
+			return ioport("IN3")->read();
 		case 7:
-			return input_port_read(machine(), "DSW2");
+			return ioport("DSW2")->read();
 
 		default:
 			logerror("reading unhandled goal92 inputs %04X %04X @ PC = %04X\n", offset, mem_mask,cpu_get_pc(&space.device()));
diff -Nru src-old/mame/drivers/goldnpkr.c src/mame/drivers/goldnpkr.c
--- src-old/mame/drivers/goldnpkr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/goldnpkr.c	2012-05-03 11:00:08.000000000 +0200
@@ -1199,10 +1199,10 @@
 	goldnpkr_state *state = device->machine().driver_data<goldnpkr_state>();
 	switch( state->m_mux_data & 0xf0 )		/* bits 4-7 */
 	{
-		case 0x10: return input_port_read(device->machine(), "IN0-0");
-		case 0x20: return input_port_read(device->machine(), "IN0-1");
-		case 0x40: return input_port_read(device->machine(), "IN0-2");
-		case 0x80: return input_port_read(device->machine(), "IN0-3");
+		case 0x10: return state->ioport("IN0-0")->read();
+		case 0x20: return state->ioport("IN0-1")->read();
+		case 0x40: return state->ioport("IN0-2")->read();
+		case 0x80: return state->ioport("IN0-3")->read();
 	}
 	return 0xff;
 }
@@ -1214,10 +1214,10 @@
 
 	switch( state->m_mux_data & 0xf0 )		/* bits 4-7 */
 	{
-		case 0x10: return input_port_read(device->machine(), "IN0-0");
-		case 0x20: return input_port_read(device->machine(), "IN0-1");
-		case 0x40: return input_port_read(device->machine(), "IN0-2");
-		case 0x80: return input_port_read(device->machine(), "IN0-3");
+		case 0x10: return state->ioport("IN0-0")->read();
+		case 0x20: return state->ioport("IN0-1")->read();
+		case 0x40: return state->ioport("IN0-2")->read();
+		case 0x80: return state->ioport("IN0-3")->read();
 	}
 
 	pa_7 = (state->m_pia0_PA_data >> 7) & 1;	/* To do: bit PA5 to pin CB1 */
diff -Nru src-old/mame/drivers/goldstar.c src/mame/drivers/goldstar.c
--- src-old/mame/drivers/goldstar.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/goldstar.c	2012-05-03 11:00:08.000000000 +0200
@@ -680,28 +680,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -842,28 +842,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1004,28 +1004,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1166,28 +1166,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1328,28 +1328,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1490,28 +1490,28 @@
 
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) /* A-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) /* B-Type */
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40) /* A-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )     PORT_CONDITION("DSW2",0x40,EQUALS,0x00) /* B-Type */
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) /* C-Type */
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) /* D-Type */
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10) /* C-Type */
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )    PORT_CONDITION("DSW4",0x10,EQUALS,0x00) /* D-Type */
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Coin/25 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Coin/50 Credits" ) PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1789,28 +1789,28 @@
 
 	PORT_START("DSW3")	/* some of these could be wrong */
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) // A-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) // B-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00) // A-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40) // B-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")
 	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
 	PORT_DIPSETTING(    0x04, "1 Coin/20 Credits" )
 	PORT_DIPSETTING(    0x08, "1 Coin/50 Credits" )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) // C-Type
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) // D-Type
-	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10) // C-Type
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00) // D-Type
+	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -1961,28 +1961,28 @@
 
 	PORT_START("DSW3")	/* seems ok */
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")	/* OK */
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) // A-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) // B-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00) // A-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40) // B-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
 	PORT_DIPSETTING(    0x04, "1 Coin/20 Credits" )
 	PORT_DIPSETTING(    0x08, "1 Coin/50 Credits" )
 	PORT_DIPSETTING(    0x0c, "1 Coin/100 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")	/* OK */
-	PORT_DIPSETTING(    0x30, "5 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) // C-Type
-	PORT_DIPSETTING(    0x20, "2 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, "1 Coin/20 Credits" )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 50 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 200 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 500 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) // D-Type
+	PORT_DIPSETTING(    0x30, "5 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10) // C-Type
+	PORT_DIPSETTING(    0x20, "2 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, "1 Coin/10 Credits" )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, "1 Coin/20 Credits" )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 50 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 200 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 500 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00) // D-Type
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")	/* OK */
 	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )
 	PORT_DIPSETTING(    0x40, "1 Coin/20 Credits" )
@@ -2133,28 +2133,28 @@
 
 	PORT_START("DSW3")	/* some of these are wrong */
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) // A-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) // B-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00) // A-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40) // B-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) // C-Type
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) // D-Type
-	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10) // C-Type
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00) // D-Type
+	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -2305,28 +2305,28 @@
 
 	PORT_START("DSW3")	/* some of these are wrong */
 	PORT_DIPNAME( 0x03, 0x03, "Key In Rate" ) PORT_DIPLOCATION("DSW3:1,2")
-	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00) // A-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40) // B-Type
-	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x00, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00) // A-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/20 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "1 Coin/100 Credits" )	PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_5C ) )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40) // B-Type
+	PORT_DIPSETTING(    0x01, "1 Coin/10 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, "1 Coin/25 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_DIPSETTING(    0x03, "1 Coin/50 Credits" )		PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x0c, 0x0c, "Coin A Rate" ) PORT_DIPLOCATION("DSW3:3,4")
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0c, "1 Coin/10 Credits" )
 	PORT_DIPNAME( 0x30, 0x30, "Coin D Rate" ) PORT_DIPLOCATION("DSW3:5,6")
-	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10) // C-Type
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00) // D-Type
-	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 5C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10) // C-Type
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )				PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x30, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00) // D-Type
+	PORT_DIPSETTING(    0x20, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "1 Ticket/Coin / 100 Credits" )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, "Coin C Rate" ) PORT_DIPLOCATION("DSW3:7,8")
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) )
@@ -3759,25 +3759,25 @@
 	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
 	/* DIP switches 2 to 5 work only for version 3.51 */
 	PORT_DIPNAME( 0x02, 0x00, "Limit Score of Each Game to Max 10x Bet or $5.00" )	PORT_DIPLOCATION("DSW5:2")	/* OK */
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x04, 0x00, "Play Remaining Score when No Credit" )				PORT_DIPLOCATION("DSW5:3")	/* OK */
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x04, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x04, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x04, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x04, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x08, 0x00, "Reset Remaining Score to Zero" )						PORT_DIPLOCATION("DSW5:4")	/* OK */
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x08, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x08, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x10, 0x00, "Ticket Dispense from Score" )						PORT_DIPLOCATION("DSW5:5")	/* OK */
-	PORT_DIPSETTING(    0x00, "Use TDDD" )			PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, "Use Interface" )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "Use TDDD" )			PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, "Use Interface" )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x20, 0x20, "Reel Speed (ver 2.3)" )								PORT_DIPLOCATION("DSW5:6")	/* OK (turn the machine off/on after change) */
 	PORT_DIPSETTING(    0x20, "Slow" )
 	PORT_DIPSETTING(    0x00, "Fast" )
@@ -3831,27 +3831,27 @@
 	PORT_DIPSETTING(    0x01, "Level 7" )
 	PORT_DIPSETTING(    0x00, "Level 8" )
 	PORT_DIPNAME( 0x38, 0x38, "Maximum Play" )				PORT_DIPLOCATION("DSW1:4,5,6")	/* OK */
-	PORT_DIPSETTING(    0x00, "10" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "20" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "30" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "40" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "8" )		PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x08, "16" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x10, "24" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x18, "32" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, "10" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "20" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "30" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "40" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "8" )		PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x08, "16" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x10, "24" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x18, "32" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
 	PORT_DIPSETTING(    0x20, "40" )
 	PORT_DIPSETTING(    0x28, "48" )
 	PORT_DIPSETTING(    0x30, "64" )
 	PORT_DIPSETTING(    0x38, "80" )
 	PORT_DIPNAME( 0xc0, 0x80, "Minimum Play for Bonus" )	PORT_DIPLOCATION("DSW1:7,8")	/* OK */
-	PORT_DIPSETTING(    0x00, "10" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x40, "20" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x80, "30" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0xc0, "40" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "8" )		PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x40, "16" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x80, "24" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0xc0, "32" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, "10" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, "20" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x80, "30" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0xc0, "40" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "8" )		PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x40, "16" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x80, "24" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0xc0, "32" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, "Double-Up Game" )			PORT_DIPLOCATION("DSW2:1")	/* OK */
@@ -3881,12 +3881,12 @@
 	PORT_START("DSW3")
 	PORT_DIPNAME( 0x03, 0x02, "Minimum Play to Start" )			PORT_DIPLOCATION("DSW3:1,2")	/* OK */
 	PORT_DIPSETTING(    0x00, "1" )
-	PORT_DIPSETTING(    0x01, "10" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "20" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x03, "30" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x01, "8" )		PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, "16" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x03, "24" )	PORT_CONDITION("DSW5",0x10,PORTCOND_EQUALS,0x10)
+	PORT_DIPSETTING(    0x01, "10" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "20" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x03, "30" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x01, "8" )		PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, "16" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x03, "24" )	PORT_CONDITION("DSW5",0x10,EQUALS,0x10)
 	PORT_DIPNAME( 0x0c, 0x08, "Max Coin In & Note In Point" )	PORT_DIPLOCATION("DSW3:3,4")	/* OK */
 	PORT_DIPSETTING(    0x00, "1000" )
 	PORT_DIPSETTING(    0x04, "5000" )
@@ -3941,10 +3941,10 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
 	PORT_DIPNAME( 0x02, 0x00, "Limit Score of Each Game to Max 10x Bet or $5.00" )	PORT_DIPLOCATION("DSW5:2")	/* OK */
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x04, 0x00, "Use Printer" )										PORT_DIPLOCATION("DSW5:3")	/* OK */
 	PORT_DIPSETTING(    0x00, "No (Use TDDD)" )
 	PORT_DIPSETTING(    0x04, DEF_STR( Yes ) )
@@ -3955,15 +3955,15 @@
 	PORT_DIPSETTING(    0x10, "Base 8" )
 	PORT_DIPSETTING(    0x00, "Base 10" )
 	PORT_DIPNAME( 0x20, 0x20, "Play Score when no point left" )						PORT_DIPLOCATION("DSW5:6")	/* OK (turn the machine off/on after change) */
-	PORT_DIPSETTING(    0x20, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x20, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x20, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x40, 0x00, "Reset Remaining Score when Game Over" )				PORT_DIPLOCATION("DSW5:7")	/* OK (turn the machine off/on after change) */
-	PORT_DIPSETTING(    0x40, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x40, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x40, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x80, 0x00, "Advanced Count Game" )								PORT_DIPLOCATION("DSW5:8")	/* OK (turn the machine off/on after change) */
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Yes ) )
@@ -4111,10 +4111,10 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
 	PORT_DIPNAME( 0x02, 0x00, "Limit Score of Each Game to Max 10x Bet or $5.00" )	PORT_DIPLOCATION("DSW5:2")	/* OK */
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x02, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x04, 0x00, "Use Printer" )										PORT_DIPLOCATION("DSW5:3")	/* OK */
 	PORT_DIPSETTING(    0x00, "Interfase" )
 	PORT_DIPSETTING(    0x04, "Direct Driver" )
@@ -4125,15 +4125,15 @@
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x20, 0x20, "Play Score when no point left" )						PORT_DIPLOCATION("DSW5:6")	/* OK (turn the machine off/on after change) */
-	PORT_DIPSETTING(    0x20, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x20, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x20, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x40, 0x00, "Reset Remaining Score when Game Over" )				PORT_DIPLOCATION("DSW5:7")	/* OK (turn the machine off/on after change) */
-	PORT_DIPSETTING(    0x40, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x10)
-	PORT_DIPSETTING(    0x40, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( No ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )		PORT_CONDITION("DSW4",0x10,EQUALS,0x10)
+	PORT_DIPSETTING(    0x40, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Unused ) )	PORT_CONDITION("DSW4",0x10,EQUALS,0x00)
 	PORT_DIPNAME( 0x80, 0x00, "Advanced Count Game" )								PORT_DIPLOCATION("DSW5:8")	/* OK (turn the machine off/on after change) */
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Yes ) )
diff -Nru src-old/mame/drivers/gomoku.c src/mame/drivers/gomoku.c
--- src-old/mame/drivers/gomoku.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gomoku.c	2012-05-03 11:00:08.000000000 +0200
@@ -32,7 +32,7 @@
 
 	res = 0;
 	for (i = 0; i < 8; i++)
-		res |= ((input_port_read_safe(machine(), portnames[i], 0xff) >> offset) & 1) << i;
+		res |= ((ioport(portnames[i])->read_safe(0xff) >> offset) & 1) << i;
 
 	return res;
 }
diff -Nru src-old/mame/drivers/goodejan.c src/mame/drivers/goodejan.c
--- src-old/mame/drivers/goodejan.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/drivers/goodejan.c	2012-05-03 11:00:08.000000000 +0200
@@ -88,11 +88,11 @@
 
 	switch(m_mux_data)
 	{
-		case 1:    ret = input_port_read(machine(), "KEY0"); break;
-		case 2:    ret = input_port_read(machine(), "KEY1"); break;
-		case 4:    ret = input_port_read(machine(), "KEY2"); break;
-		case 8:    ret = input_port_read(machine(), "KEY3"); break;
-		case 0x10: ret = input_port_read(machine(), "KEY4"); break;
+		case 1:    ret = ioport("KEY0")->read(); break;
+		case 2:    ret = ioport("KEY1")->read(); break;
+		case 4:    ret = ioport("KEY2")->read(); break;
+		case 8:    ret = ioport("KEY3")->read(); break;
+		case 0x10: ret = ioport("KEY4")->read(); break;
 	}
 
 	return ret;
diff -Nru src-old/mame/drivers/gottlieb.c src/mame/drivers/gottlieb.c
--- src-old/mame/drivers/gottlieb.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gottlieb.c	2012-05-03 11:00:08.000000000 +0200
@@ -295,22 +295,22 @@
 	const char *string = (const char *)param;
 	int which = string[0] - '0';
 
-	return input_port_read(machine(), &string[1]) - m_track[which];
+	return ioport(&string[1])->read() - m_track[which];
 }
 
 
 WRITE8_MEMBER(gottlieb_state::gottlieb_analog_reset_w)
 {
 	/* reset the trackball counters */
-	m_track[0] = input_port_read_safe(machine(), "TRACKX", 0);
-	m_track[1] = input_port_read_safe(machine(), "TRACKY", 0);
+	m_track[0] = ioport("TRACKX")->read_safe(0);
+	m_track[1] = ioport("TRACKY")->read_safe(0);
 }
 
 
 CUSTOM_INPUT_MEMBER(gottlieb_state::stooges_joystick_r)
 {
 	static const char *const joyport[] = { "P2JOY", "P3JOY", "P1JOY", NULL };
-	return (joyport[m_joystick_select & 3] != NULL) ? input_port_read(machine(), joyport[m_joystick_select & 3]) : 0xff;
+	return (joyport[m_joystick_select & 3] != NULL) ? ioport(joyport[m_joystick_select & 3])->read() : 0xff;
 }
 
 
@@ -1235,17 +1235,17 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( French ) )
 	PORT_DIPNAME( 0xc2, 0x00, DEF_STR( Coinage ) )			PORT_DIPLOCATION("DSW:!6,!7,!8")
-	PORT_DIPSETTING(    0x42, "A 3/1 B 1/2" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x20)
-	PORT_DIPSETTING(    0x42, "A 4/1 B 1/1" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x82, "A 1/5 B 1/2" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x20)
-	PORT_DIPSETTING(    0x82, "A 3/1 B 1/1" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, "A 2/1 B 2/3" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x20)
-	PORT_DIPSETTING(    0x02, "A 2/1 B 1/1" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x42, "A 3/1 B 1/2" )	PORT_CONDITION("DSW",0x20,EQUALS,0x20)
+	PORT_DIPSETTING(    0x42, "A 4/1 B 1/1" )	PORT_CONDITION("DSW",0x20,EQUALS,0x00)
+	PORT_DIPSETTING(    0x82, "A 1/5 B 1/2" )	PORT_CONDITION("DSW",0x20,EQUALS,0x20)
+	PORT_DIPSETTING(    0x82, "A 3/1 B 1/1" )	PORT_CONDITION("DSW",0x20,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, "A 2/1 B 2/3" )	PORT_CONDITION("DSW",0x20,EQUALS,0x20)
+	PORT_DIPSETTING(    0x02, "A 2/1 B 1/1" )	PORT_CONDITION("DSW",0x20,EQUALS,0x00)
 	PORT_DIPSETTING(    0xc0, "A 2/1 B 2/1" )
-	PORT_DIPSETTING(    0x80, "A 1/1 B 1/2" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x20)
-	PORT_DIPSETTING(    0x80, "A 2/1 B 1/2" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x40, "A 1/1 B 1/3" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x20)
-	PORT_DIPSETTING(    0x40, "A 2/1 B 1/3" )	PORT_CONDITION("DSW",0x20,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x80, "A 1/1 B 1/2" )	PORT_CONDITION("DSW",0x20,EQUALS,0x20)
+	PORT_DIPSETTING(    0x80, "A 2/1 B 1/2" )	PORT_CONDITION("DSW",0x20,EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, "A 1/1 B 1/3" )	PORT_CONDITION("DSW",0x20,EQUALS,0x20)
+	PORT_DIPSETTING(    0x40, "A 2/1 B 1/3" )	PORT_CONDITION("DSW",0x20,EQUALS,0x00)
 	PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" )
 	PORT_DIPSETTING(    0xc2, DEF_STR( Free_Play ) )
 
diff -Nru src-old/mame/drivers/gpworld.c src/mame/drivers/gpworld.c
--- src-old/mame/drivers/gpworld.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gpworld.c	2012-05-03 11:00:08.000000000 +0200
@@ -247,9 +247,9 @@
 READ8_MEMBER(gpworld_state::pedal_in)
 {
 	if (m_brake_gas)
-		return	input_port_read(machine(), "INACCEL");
+		return	ioport("INACCEL")->read();
 
-	return	input_port_read(machine(), "INBRAKE");
+	return	ioport("INBRAKE")->read();
 
 }
 
diff -Nru src-old/mame/drivers/grchamp.c src/mame/drivers/grchamp.c
--- src-old/mame/drivers/grchamp.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/grchamp.c	2012-05-03 11:00:08.000000000 +0200
@@ -79,7 +79,7 @@
 static MACHINE_RESET( grchamp )
 {
 	/* if the coin system is 1 way, lock Coin B (Page 40) */
-	coin_lockout_w(machine, 1, (input_port_read(machine, "DSWB") & 0x10) ? 1 : 0);
+	coin_lockout_w(machine, 1, (machine.root_device().ioport("DSWB")->read() & 0x10) ? 1 : 0);
 }
 
 
diff -Nru src-old/mame/drivers/gridlee.c src/mame/drivers/gridlee.c
--- src-old/mame/drivers/gridlee.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gridlee.c	2012-05-03 11:00:08.000000000 +0200
@@ -180,7 +180,7 @@
 	static const char *const portnames[] = { "TRACK0_Y", "TRACK0_X", "TRACK1_Y", "TRACK1_X" };
 
 	/* first read the new trackball value and compute the signed delta */
-	newval = input_port_read(machine(), portnames[offset + 2 * m_cocktail_flip]);
+	newval = ioport(portnames[offset + 2 * m_cocktail_flip])->read();
 	delta = (int)newval - (int)m_last_analog_input[offset];
 
 	/* handle the case where we wrap around from 0x00 to 0xff, or vice versa */
@@ -390,7 +390,7 @@
 	PORT_BIT( 0x1f, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_SERVICE( 0x20, IP_ACTIVE_LOW )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/groundfx.c src/mame/drivers/groundfx.c
--- src-old/mame/drivers/groundfx.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/groundfx.c	2012-05-03 11:00:08.000000000 +0200
@@ -146,7 +146,7 @@
 
 			if (ACCESSING_BITS_0_7)
 			{
-				input_port_write(machine(), "EEPROMOUT", data, 0xff);
+				ioport("EEPROMOUT")->write(data, 0xff);
 			}
 
 			break;
@@ -166,7 +166,7 @@
 
 READ32_MEMBER(groundfx_state::groundfx_adc_r)
 {
-	return (input_port_read(machine(), "AN0") << 8) | input_port_read(machine(), "AN1");
+	return (ioport("AN0")->read() << 8) | ioport("AN1")->read();
 }
 
 WRITE32_MEMBER(groundfx_state::groundfx_adc_w)
diff -Nru src-old/mame/drivers/gstream.c src/mame/drivers/gstream.c
--- src-old/mame/drivers/gstream.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/gstream.c	2012-05-03 11:00:08.000000000 +0200
@@ -185,7 +185,7 @@
 	int result;
 
 	/* PORT_SERVICE_NO_TOGGLE */
-	result = (input_port_read(machine(), "IN0") & 0x8000) >> 15;
+	result = (ioport("IN0")->read() & 0x8000) >> 15;
 
 	return ~result;
 }
@@ -195,15 +195,15 @@
 	int result;
 
 	/* IPT_COIN1 */
-	result  = ((input_port_read(machine(), "IN0") & 0x200) >>  9) << 0;
+	result  = ((ioport("IN0")->read() & 0x200) >>  9) << 0;
 	/* IPT_COIN2 */
-	result |= ((input_port_read(machine(), "IN1") & 0x200) >>  9) << 1;
+	result |= ((ioport("IN1")->read() & 0x200) >>  9) << 1;
 	/* IPT_START1 */
-	result |= ((input_port_read(machine(), "IN0") & 0x400) >> 10) << 2;
+	result |= ((ioport("IN0")->read() & 0x400) >> 10) << 2;
 	/* IPT_START2 */
-	result |= ((input_port_read(machine(), "IN1") & 0x400) >> 10) << 3;
+	result |= ((ioport("IN1")->read() & 0x400) >> 10) << 3;
 	/* PORT_SERVICE_NO_TOGGLE */
-	result |= ((input_port_read(machine(), "IN0") & 0x8000) >> 15) << 6;
+	result |= ((ioport("IN0")->read() & 0x8000) >> 15) << 6;
 
 	return ~result;
 }
diff -Nru src-old/mame/drivers/gsword.c src/mame/drivers/gsword.c
--- src-old/mame/drivers/gsword.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/gsword.c	2012-05-03 11:00:08.000000000 +0200
@@ -153,7 +153,7 @@
 static int gsword_coins_in(void)
 {
 	/* emulate 8741 coin slot */
-	if (input_port_read(machine, "IN4") & 0xc0)
+	if (machine.root_device().ioport("IN4")->read() & 0xc0)
 	{
 		logerror("Coin In\n");
 		return 0x80;
@@ -191,11 +191,11 @@
 	switch (offset)
 	{
 	case 0x01: /* start button , coins */
-		return input_port_read(space->machine(), "IN0");
+		return space->machine().root_device().ioport("IN0")->read();
 	case 0x02: /* Player 1 Controller */
-		return input_port_read(space->machine(), "IN1");
+		return space->machine().root_device().ioport("IN1")->read();
 	case 0x04: /* Player 2 Controller */
-		return input_port_read(space->machine(), "IN3");
+		return space->machine().root_device().ioport("IN3")->read();
 //  default:
 //      logerror("8741-2 unknown read %d PC=%04x\n",offset,cpu_get_pc(&space->device()));
 	}
@@ -208,11 +208,11 @@
 	switch (offset)
 	{
 	case 0x01: /* start button  */
-		return input_port_read(space->machine(), "IN2");
+		return space->machine().root_device().ioport("IN2")->read();
 	case 0x02: /* Player 1 Controller? */
-		return input_port_read(space->machine(), "IN1");
+		return space->machine().root_device().ioport("IN1")->read();
 	case 0x04: /* Player 2 Controller? */
-		return input_port_read(space->machine(), "IN3");
+		return space->machine().root_device().ioport("IN3")->read();
 	}
 	/* unknown */
 //  logerror("8741-3 unknown read %d PC=%04x\n",offset,cpu_get_pc(&space->device()));
diff -Nru src-old/mame/drivers/gticlub.c src/mame/drivers/gticlub.c
--- src-old/mame/drivers/gticlub.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gticlub.c	2012-05-03 11:00:08.000000000 +0200
@@ -343,7 +343,7 @@
 		case 0:
 		case 1:
 		case 3:
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 
 		case 2:
 			return adc1038_sars_read(adc1038) << 7;
@@ -727,10 +727,10 @@
 	int value = 0;
 	switch (input)
 	{
-	case 0: value = input_port_read(device->machine(), "AN0"); break;
-	case 1: value = input_port_read(device->machine(), "AN1"); break;
-	case 2: value = input_port_read(device->machine(), "AN2"); break;
-	case 3: value = input_port_read(device->machine(), "AN3"); break;
+	case 0: value = device->machine().root_device().ioport("AN0")->read(); break;
+	case 1: value = device->machine().root_device().ioport("AN1")->read(); break;
+	case 2: value = device->machine().root_device().ioport("AN2")->read(); break;
+	case 3: value = device->machine().root_device().ioport("AN3")->read(); break;
 	case 4: value = 0x000; break;
 	case 5: value = 0x000; break;
 	case 6: value = 0x000; break;
@@ -1165,7 +1165,7 @@
 
 	state->m_sharc_dataram_0 = auto_alloc_array(machine, UINT32, 0x100000/4);
 
-	K001005_preprocess_texture_data(machine.root_device().memregion("gfx1")->base(), state->memregion("gfx1")->bytes(), 1);
+	K001005_preprocess_texture_data(state->memregion("gfx1")->base(), state->memregion("gfx1")->bytes(), 1);
 }
 
 static DRIVER_INIT(hangplt)
@@ -1173,7 +1173,7 @@
 	gticlub_state *state = machine.driver_data<gticlub_state>();
 
 	init_konami_cgboard(machine, 2, CGBOARD_TYPE_HANGPLT);
-	set_cgboard_texture_bank(machine, 0, "bank5", machine.root_device().memregion("user5")->base());
+	set_cgboard_texture_bank(machine, 0, "bank5", state->memregion("user5")->base());
 	set_cgboard_texture_bank(machine, 1, "bank6", state->memregion("user5")->base());
 
 	state->m_sharc_dataram_0 = auto_alloc_array(machine, UINT32, 0x100000/4);
diff -Nru src-old/mame/drivers/guab.c src/mame/drivers/guab.c
--- src-old/mame/drivers/guab.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/guab.c	2012-05-03 11:00:08.000000000 +0200
@@ -579,7 +579,7 @@
 		case 0x01:
 		case 0x02:
 		{
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 		}
 		case 0x30:
 		{
diff -Nru src-old/mame/drivers/gunbustr.c src/mame/drivers/gunbustr.c
--- src-old/mame/drivers/gunbustr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/gunbustr.c	2012-05-03 11:00:08.000000000 +0200
@@ -174,8 +174,8 @@
 
 READ32_MEMBER(gunbustr_state::gunbustr_gun_r)
 {
-	return ( input_port_read(machine(), "LIGHT0_X") << 24) | (input_port_read(machine(), "LIGHT0_Y") << 16) |
-		 ( input_port_read(machine(), "LIGHT1_X") << 8)  |  input_port_read(machine(), "LIGHT1_Y");
+	return ( ioport("LIGHT0_X")->read() << 24) | (ioport("LIGHT0_Y")->read() << 16) |
+			( ioport("LIGHT1_X")->read() << 8)  |  ioport("LIGHT1_Y")->read();
 }
 
 WRITE32_MEMBER(gunbustr_state::gunbustr_gun_w)
diff -Nru src-old/mame/drivers/gundealr.c src/mame/drivers/gundealr.c
--- src-old/mame/drivers/gundealr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gundealr.c	2012-05-03 11:00:08.000000000 +0200
@@ -498,9 +498,9 @@
 			break;
 	}
 
-	state->m_rambase[0x004] = input_port_read(timer.machine(), "IN2");
-	state->m_rambase[0x005] = input_port_read(timer.machine(), "IN1");
-	state->m_rambase[0x006] = input_port_read(timer.machine(), "IN0");
+	state->m_rambase[0x004] = timer.machine().root_device().ioport("IN2")->read();
+	state->m_rambase[0x005] = timer.machine().root_device().ioport("IN1")->read();
+	state->m_rambase[0x006] = timer.machine().root_device().ioport("IN0")->read();
 }
 
 static MACHINE_CONFIG_DERIVED( yamyam, gundealr )
diff -Nru src-old/mame/drivers/gunpey.c src/mame/drivers/gunpey.c
--- src-old/mame/drivers/gunpey.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/gunpey.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,11 +120,11 @@
 {
 	switch(offset+0x7f40)
 	{
-		case 0x7f40: return input_port_read(machine(), "DSW1");
-		case 0x7f41: return input_port_read(machine(), "DSW2");
-		case 0x7f42: return input_port_read(machine(), "P1");
-		case 0x7f43: return input_port_read(machine(), "P2");
-		case 0x7f44: return input_port_read(machine(), "SYSTEM");
+		case 0x7f40: return ioport("DSW1")->read();
+		case 0x7f41: return ioport("DSW2")->read();
+		case 0x7f42: return ioport("P1")->read();
+		case 0x7f43: return ioport("P2")->read();
+		case 0x7f44: return ioport("SYSTEM")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/halleys.c src/mame/drivers/halleys.c
--- src-old/mame/drivers/halleys.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/halleys.c	2012-05-03 11:00:08.000000000 +0200
@@ -1488,7 +1488,7 @@
 		bitmap.fill(state->m_bgcolor, cliprect);
 
 #ifdef MAME_DEBUG
-	if (input_port_read(screen.machine(), "DEBUG")) copy_scroll_xp(bitmap, state->m_render_layer[3], *state->m_scrollx0, *state->m_scrolly0); // not used???
+	if (screen.machine().root_device().ioport("DEBUG")->read()) copy_scroll_xp(bitmap, state->m_render_layer[3], *state->m_scrollx0, *state->m_scrolly0); // not used???
 #endif
 
 	copy_scroll_xp(bitmap, state->m_render_layer[2], *state->m_scrollx1, *state->m_scrolly1);
@@ -1628,8 +1628,8 @@
 	//   0x8599 : 'benberob'
 	//   0x83e2 : 'halleys', 'halleysc', 'halleycj'
 	//   0x83df : 'halley87'
-	int inp = input_port_read(machine(), "IN0");
-	int result = ((input_port_read(machine(), "DSW4")) & 0x20) >> 5;
+	int inp = ioport("IN0")->read();
+	int result = ((ioport("DSW4")->read()) & 0x20) >> 5;
 
 	if (inp & 0x80) result |= 0x02;
 	if (inp & 0x40) result |= 0x04;
@@ -1642,7 +1642,7 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3" };
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 
diff -Nru src-old/mame/drivers/hanaawas.c src/mame/drivers/hanaawas.c
--- src-old/mame/drivers/hanaawas.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/hanaawas.c	2012-05-03 11:00:08.000000000 +0200
@@ -38,13 +38,13 @@
 	switch (m_mux)
 	{
 	case 1: /* start buttons */
-		buttons = input_port_read(machine(), "START");
+		buttons = ioport("START")->read();
 		break;
 	case 2: /* player 1 buttons */
-		buttons = input_port_read(machine(), "P1");
+		buttons = ioport("P1")->read();
 		break;
 	case 4: /* player 2 buttons */
-		buttons = input_port_read(machine(), "P2");
+		buttons = ioport("P2")->read();
 		break;
 	}
 
@@ -60,7 +60,7 @@
 		}
 	}
 
-	return (input_port_read(machine(), "IN0") & 0xf0) | ordinal;
+	return (ioport("IN0")->read() & 0xf0) | ordinal;
 }
 
 WRITE8_MEMBER(hanaawas_state::hanaawas_inputs_mux_w)
diff -Nru src-old/mame/drivers/harddriv.c src/mame/drivers/harddriv.c
--- src-old/mame/drivers/harddriv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/harddriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -686,7 +686,7 @@
 	PORT_START("IN0")		/* 600000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )	/* diagnostic switch */
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -742,7 +742,7 @@
 	PORT_START("IN0")		/* 600000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )	/* diagnostic switch */
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -798,7 +798,7 @@
 	PORT_START("IN0")		/* 60c000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )	/* diagnostic switch */
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -860,7 +860,7 @@
 	PORT_START("IN0")		/* 60c000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -922,7 +922,7 @@
 	PORT_START("IN0")		/* 60c000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -985,7 +985,7 @@
 	PORT_START("IN0")		/* 60c000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
@@ -1048,7 +1048,7 @@
 	PORT_START("IN0")		/* 60c000 */
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SPECIAL )	/* HBLANK */
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 12-bit EOC */
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* 8-bit EOC */
 	PORT_SERVICE( 0x0020, IP_ACTIVE_LOW )
diff -Nru src-old/mame/drivers/highvdeo.c src/mame/drivers/highvdeo.c
--- src-old/mame/drivers/highvdeo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/highvdeo.c	2012-05-03 11:00:08.000000000 +0200
@@ -194,17 +194,17 @@
 
 READ16_MEMBER(highvdeo_state::read1_r)
 {
-	return input_port_read(machine(), "IN0");
+	return ioport("IN0")->read();
 }
 
 READ16_MEMBER(highvdeo_state::read2_r)
 {
-	return input_port_read(machine(), "IN1");
+	return ioport("IN1")->read();
 }
 
 READ16_MEMBER(highvdeo_state::read3_r)
 {
-	return input_port_read(machine(), "IN2");
+	return ioport("IN2")->read();
 }
 
 WRITE16_MEMBER(highvdeo_state::tv_vcf_paletteram_w)
@@ -322,7 +322,7 @@
 	// machine resets itself.
 	resetpulse ^= 0x40;
 
-	return (input_port_read(machine(), "IN1") & 0xbf) | resetpulse;
+	return (ioport("IN1")->read() & 0xbf) | resetpulse;
 }
 
 static WRITE16_DEVICE_HANDLER( tv_ncf_oki6376_w )
diff -Nru src-old/mame/drivers/hikaru.c src/mame/drivers/hikaru.c
--- src-old/mame/drivers/hikaru.c	2012-03-31 15:39:09.000000000 +0200
+++ src/mame/drivers/hikaru.c	2012-05-07 08:57:50.000000000 +0200
@@ -319,6 +319,67 @@
 
 */
 
+/*
+    New hardware notes from Stefano Teso:
+
+  - The master SH-4 port A: the bit layout for this thing is (MSB left)
+
+    xxxx xxii iiee eexM
+
+    x = unused
+    i = IRQ causes (active low)
+    e = Mainboard EEPROM (active low)
+    M = connected to the slave SH-4 NMI pin; writing a specific bit
+    pattern here (3 ones, 3 zeros, 7 ones) sends an NMI to the slave
+
+    Bit 1 of the slave port A is used for master-slave communication as
+    well, but I have yet to figure out how. It doesn't seem to be needed
+    for emulation at this point though. Master-slave communication seems
+    to work okay after emulating the M bit here.
+
+  - There's an additional indirect-DMA-like device on the GPU at
+    150000(0C,10,14). The table indicating where the data is, how long it
+    is, and how to operate on it, is located at the bottom of GPU command
+    RAM (14xxxxxx), defaulting at 143FC000 (whose bus address, specified
+    by 1500000C is 483FC000.) It is used for (my guess) on-the-fly texture
+    format conversion. Upon termination, it raises a GPU IRQ. It looks
+    like airtrix first uploads the data to be converted somewhere using
+    the memory controller's DMA, then instructs the GPU indirect DMA thing
+    to read it and perform the conversion.
+
+  - GPU IRQs: it looks like the GPU IRQs are as follows:
+
+    15000088:
+
+    bit 0: the GPU indirect-DMA-like device is done
+    bit 1: vblank (or hblank)
+    bit 2: the GPU at 15xxxxxx is done and needs feeding (means that
+    commands are uploaded to CMDRAM and registers fiddled with, see bit 2
+    below.)
+    bit 8: any bit of 1A000018 is set
+
+    1A000018:
+
+    bit 1: vblank (or hblank)
+    bit 2: GPU at 1Axxxxxx is done and needs feeding (same as bit 2
+    above; note that both IRQs must be raised -- not necessarily at the
+    same time -- for the whole "let's upload data to the GPU" routine to
+    be performed.)
+
+    My gut feeling tells me that there are two different GPUs: one
+    processes the command stream and does the rendering on even frames,
+    the other does the same for odd frames. Registers 1500007x may specify
+    where the command stream start is (the initial GPU PC) and possibly
+    the location of two distinct stack pointers (the GPU supports
+    subroutines, after all.)
+
+  - the serial device at 0080000(A|C) is not an EEPROM; it's likely some
+    weird device that is used to query the heirarchy of the attached
+    input/output devices. Probably the naomi has something similar, I
+    haven't looked into it yet.
+
+*/
+
 #include "emu.h"
 #include "cpu/sh4/sh4.h"
 
diff -Nru src-old/mame/drivers/hitme.c src/mame/drivers/hitme.c
--- src-old/mame/drivers/hitme.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/hitme.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,7 +72,7 @@
 {
 	hitme_state *state = screen.machine().driver_data<hitme_state>();
 	/* the card width resistor comes from an input port, scaled to the range 0-25 kOhms */
-	double width_resist = input_port_read(screen.machine(), "WIDTH") * 25000 / 100;
+	double width_resist = screen.machine().root_device().ioport("WIDTH")->read() * 25000 / 100;
 	/* this triggers a oneshot for the following length of time */
 	double width_duration = 0.45 * 1000e-12 * width_resist;
 	/* the dot clock runs at the standard horizontal frequency * 320+16 clocks per scanline */
@@ -136,7 +136,7 @@
 	hitme_state *state = machine.driver_data<hitme_state>();
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3" };
 
-	UINT8 val = input_port_read(machine, portnames[port]);
+	UINT8 val = machine.root_device().ioport(portnames[port])->read();
 	if (machine.time() > state->m_timeout_time)
 		val ^= 0x80;
 	return val;
@@ -192,7 +192,7 @@
         system's equivalent computation, or else we will hang notes.
     */
 	hitme_state *state = device->machine().driver_data<hitme_state>();
-	UINT8 raw_game_speed = input_port_read(device->machine(), "R3");
+	UINT8 raw_game_speed = state->ioport("R3")->read();
 	double resistance = raw_game_speed * 25000 / 100;
 	attotime duration = attotime(0, ATTOSECONDS_PER_SECOND * 0.45 * 6.8e-6 * resistance * (data + 1));
 	state->m_timeout_time = device->machine().time() + duration;
diff -Nru src-old/mame/drivers/hitpoker.c src/mame/drivers/hitpoker.c
--- src-old/mame/drivers/hitpoker.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hitpoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -289,7 +289,7 @@
 	PORT_DIPNAME( 0x40, 0x40, "Monitor" ) //a JP probably
 	PORT_DIPSETTING(    0x40, "15KHz" )
 	PORT_DIPSETTING(    0x00, "24KHz" )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN0")
 	PORT_DIPNAME( 0x01, 0x01, "IN0" )
diff -Nru src-old/mame/drivers/hnayayoi.c src/mame/drivers/hnayayoi.c
--- src-old/mame/drivers/hnayayoi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hnayayoi.c	2012-05-03 11:00:08.000000000 +0200
@@ -49,7 +49,7 @@
 	for (i = 0; i < 5; i++)
 	{
 		if (~m_keyb & (1 << i))
-			res &= input_port_read(machine(), keynames[i]);
+			res &= ioport(keynames[i])->read();
 	}
 
 	return res;
diff -Nru src-old/mame/drivers/hng64.c src/mame/drivers/hng64.c
--- src-old/mame/drivers/hng64.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hng64.c	2012-05-03 11:00:08.000000000 +0200
@@ -639,8 +639,8 @@
 	switch (offset*4)
 	{
 		case 0x000: return 0x00000400;
-		case 0x004: return input_port_read(machine(), "SYSTEM");
-		case 0x008: return input_port_read(machine(), "P1_P2");
+		case 0x004: return ioport("SYSTEM")->read();
+		case 0x008: return ioport("P1_P2")->read();
 		case 0x600: return m_no_machine_error_code;
 	}
 
@@ -668,8 +668,8 @@
 			else
 				return 0x000;
 		}
-		case 0x004: return input_port_read(machine(), "SYSTEM");
-		case 0x008: return input_port_read(machine(), "P1_P2");
+		case 0x004: return ioport("SYSTEM")->read();
+		case 0x008: return ioport("P1_P2")->read();
 		case 0x600: return m_no_machine_error_code;
 	}
 
@@ -696,26 +696,26 @@
 		case 0x010:
 		{
 			/* Quick kludge for use the input test items */
-			if(input_port_read(machine(), "D_IN") & 0x01000000)
+			if(ioport("D_IN")->read() & 0x01000000)
 				m_p1_trig = machine().rand() & 0x01000000;
 
-			return (input_port_read(machine(), "D_IN") & ~0x01000000) | (m_p1_trig);
+			return (ioport("D_IN")->read() & ~0x01000000) | (m_p1_trig);
 		}
 		case 0x018:
 		{
 			UINT8 p1_x, p1_y, p2_x, p2_y;
-			p1_x = input_port_read(machine(), "LIGHT_P1_X") & 0xff;
-			p1_y = input_port_read(machine(), "LIGHT_P1_Y") & 0xff;
-			p2_x = input_port_read(machine(), "LIGHT_P2_X") & 0xff;
-			p2_y = input_port_read(machine(), "LIGHT_P2_Y") & 0xff;
+			p1_x = ioport("LIGHT_P1_X")->read() & 0xff;
+			p1_y = ioport("LIGHT_P1_Y")->read() & 0xff;
+			p2_x = ioport("LIGHT_P2_X")->read() & 0xff;
+			p2_y = ioport("LIGHT_P2_Y")->read() & 0xff;
 
 			return p1_x<<24 | p1_y<<16 | p2_x<<8 | p2_y;
 		}
 		case 0x01c:
 		{
 			UINT8 p3_x, p3_y;
-			p3_x = input_port_read(machine(), "LIGHT_P3_X") & 0xff;
-			p3_y = input_port_read(machine(), "LIGHT_P3_Y") & 0xff;
+			p3_x = ioport("LIGHT_P3_X")->read() & 0xff;
+			p3_y = ioport("LIGHT_P3_Y")->read() & 0xff;
 
 			return p3_x<<24 | p3_y<<16 | p3_x<<8 | p3_y; //FIXME: see what's the right bank here when the trigger works
 		}
@@ -741,8 +741,8 @@
 			else
 				return 0x000;
 		}
-		case 0x004: return input_port_read(machine(), "SYSTEM");
-		case 0x008: return input_port_read(machine(), "P1_P2");
+		case 0x004: return ioport("SYSTEM")->read();
+		case 0x008: return ioport("P1_P2")->read();
 		case 0x600: return m_no_machine_error_code;
 	}
 
@@ -929,7 +929,7 @@
 
 	//printf("Q1 R : %.8x %.8x\n", offset, hng64_tcram[offset]);
 	if(offset == 0x12)
-		return input_port_read(machine(), "VBLANK");
+		return ioport("VBLANK")->read();
 
 	return m_tcram[offset];
 }
@@ -1269,7 +1269,7 @@
 
 static INPUT_PORTS_START( hng64 )
 	PORT_START("VBLANK")
-	PORT_BIT( 0xffffffff, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0xffffffff, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IPT_TEST")
 	PORT_BIT( 0x0001, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -1345,7 +1345,7 @@
 
 static INPUT_PORTS_START( bbust2 )
 	PORT_START("VBLANK")
-	PORT_BIT( 0xffffffff, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0xffffffff, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("D_IN")
 	PORT_BIT( 0x000000ff, IP_ACTIVE_HIGH, IPT_UNUSED )
diff -Nru src-old/mame/drivers/homedata.c src/mame/drivers/homedata.c
--- src-old/mame/drivers/homedata.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/homedata.c	2012-05-03 11:00:08.000000000 +0200
@@ -257,7 +257,7 @@
 		{
 			if (m_keyb & (1 << i))
 			{
-				res = input_port_read(machine(), keynames[i]) & 0x3f;
+				res = ioport(keynames[i])->read() & 0x3f;
 				break;
 			}
 		}
@@ -370,7 +370,7 @@
 
 READ8_MEMBER(homedata_state::reikaids_io_r)
 {
-	int res = input_port_read(machine(), "IN2");	// bit 4 = coin, bit 5 = service
+	int res = ioport("IN2")->read();	// bit 4 = coin, bit 5 = service
 
 	res |= BIT(m_upd7807_portc, 2) * 0x01;		// bit 0 = upd7807 status
 	res |= BIT(m_upd7807_portc, 6) * 0x02;		// bit 1 = upd7807 data
@@ -438,7 +438,7 @@
 READ8_MEMBER(homedata_state::pteacher_keyboard_r)
 {
 	static const char *const keynames[] = { "KEY0", "KEY1", "KEY2", "KEY3", "KEY4", "KEY5" };
-	int dips = input_port_read(machine(), "DSW");
+	int dips = ioport("DSW")->read();
 
 	//  logerror("%04x: keyboard_r with port A = %02x\n",cpu_get_pc(&space.device()),upd7807_porta);
 
@@ -446,7 +446,7 @@
 	{
 		/* player 1 + dip switches */
 		int row = (m_upd7807_porta & 0x07);
-		return input_port_read(machine(), keynames[row]) | (((dips >> row) & 1) << 5);	// 0-5
+		return ioport(keynames[row])->read() | (((dips >> row) & 1) << 5);	// 0-5
 	}
 	if (m_upd7807_porta & 0x08)
 	{
@@ -1149,7 +1149,7 @@
 static MACHINE_START( reikaids )
 {
 	homedata_state *state = machine.driver_data<homedata_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 8, &ROM[0xc000], 0x4000);
 	state->membank("bank2")->configure_entries(0, 4, state->memregion("audiocpu")->base(), 0x10000);
@@ -1166,7 +1166,7 @@
 static MACHINE_START( pteacher )
 {
 	homedata_state *state = machine.driver_data<homedata_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 4, &ROM[0xc000], 0x4000);
 	state->membank("bank2")->configure_entries(0, 4, state->memregion("audiocpu")->base(), 0x10000);
diff -Nru src-old/mame/drivers/hornet.c src/mame/drivers/hornet.c
--- src-old/mame/drivers/hornet.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hornet.c	2012-05-03 11:00:08.000000000 +0200
@@ -471,7 +471,7 @@
 		case 0:	/* I/O port 0 */
 		case 1:	/* I/O port 1 */
 		case 2:	/* I/O port 2 */
-			r = input_port_read(machine(), portnames[offset]);
+			r = ioport(portnames[offset])->read();
 			break;
 
 		case 3:	/* I/O port 3 */
@@ -489,7 +489,7 @@
 			break;
 
 		case 4:	/* I/O port 4 - DIP switches */
-			r = input_port_read(machine(), "DSW");
+			r = ioport("DSW")->read();
 			break;
 	}
 	return r;
@@ -524,7 +524,7 @@
                 0x02 = LAMP1
                 0x01 = LAMP0
             */
-			input_port_write(machine(), "EEPROMOUT", data, 0xff);
+			ioport("EEPROMOUT")->write(data, 0xff);
 			mame_printf_debug("System register 0 = %02X\n", data);
 			break;
 
@@ -1255,7 +1255,7 @@
 {
 	hornet_state *state = machine.driver_data<hornet_state>();
 	init_konami_cgboard(machine, 2, CGBOARD_TYPE_HORNET);
-	set_cgboard_texture_bank(machine, 0, "bank5", machine.root_device().memregion("user5")->base());
+	set_cgboard_texture_bank(machine, 0, "bank5", state->memregion("user5")->base());
 	set_cgboard_texture_bank(machine, 1, "bank6", state->memregion("user5")->base());
 
 	state->m_led_reg0 = state->m_led_reg1 = 0x7f;
diff -Nru src-old/mame/drivers/hvyunit.c src/mame/drivers/hvyunit.c
--- src-old/mame/drivers/hvyunit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hvyunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -369,9 +369,9 @@
 
 	switch ((m_mermaid_p[0] >> 2) & 3)
 	{
-		case 0: return input_port_read(machine(), "IN1");
-		case 1: return input_port_read(machine(), "IN2");
-		case 2: return input_port_read(machine(), "IN0");
+		case 0: return ioport("IN1")->read();
+		case 1: return ioport("IN2")->read();
+		case 2: return ioport("IN0")->read();
 		default: return 0xff;
 	}
 }
@@ -386,8 +386,8 @@
 {
 
 	UINT8 dsw = 0;
-	UINT8 dsw1 = input_port_read(machine(), "DSW1");
-	UINT8 dsw2 = input_port_read(machine(), "DSW2");
+	UINT8 dsw1 = ioport("DSW1")->read();
+	UINT8 dsw2 = ioport("DSW2")->read();
 
 	switch ((m_mermaid_p[0] >> 5) & 3)
 	{
@@ -529,23 +529,23 @@
 	PORT_DIPSETTING(    0x08, ( "Mode 1" ) )
 	PORT_DIPSETTING(    0x00, ( "Mode 2" ) )
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )			PORT_DIPLOCATION("DSW1:5,6")
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )			PORT_DIPLOCATION("DSW1:7,8")
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1", 0x08, EQUALS, 0x00)
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )		PORT_DIPLOCATION("DSW2:1,2")
diff -Nru src-old/mame/drivers/hyhoo.c src/mame/drivers/hyhoo.c
--- src-old/mame/drivers/hyhoo.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/hyhoo.c	2012-05-01 00:02:17.000000000 +0200
@@ -29,13 +29,6 @@
 #include "includes/hyhoo.h"
 #include "machine/nvram.h"
 
-#define	SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
 
 static DRIVER_INIT( hyhoo )
 {
@@ -64,7 +57,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r, nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r, nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xcf) AM_WRITEONLY AM_SHARE("clut")
-	AM_RANGE(0xd0, 0xd0) AM_READNOP AM_DEVWRITE_LEGACY("dac", DAC_WRITE)		// unknown read
+	AM_RANGE(0xd0, 0xd0) AM_READNOP AM_DEVWRITE_LEGACY("dac", dac_w)		// unknown read
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(hyhoo_romsel_w)
 	AM_RANGE(0xe0, 0xe1) AM_READ_LEGACY(nb1413m3_gfxrom_r)
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
@@ -321,6 +314,5 @@
 ROM_END
 
 
-GAME( 1987, hyhoo,  0, hyhoo,  hyhoo,  hyhoo,  ROT90, "Nichibutsu", "Taisen Quiz HYHOO (Japan)", 0 )
-GAME( 1987, hyhoo2, 0, hyhoo,  hyhoo2, hyhoo2, ROT90, "Nichibutsu", "Taisen Quiz HYHOO 2 (Japan)", 0 )
-
+GAME( 1987, hyhoo,  0, hyhoo,  hyhoo,  hyhoo,  ROT90, "Nichibutsu", "Hayaoshi Taisen Quiz Hyhoo (Japan)", 0 )
+GAME( 1987, hyhoo2, 0, hyhoo,  hyhoo2, hyhoo2, ROT90, "Nichibutsu", "Hayaoshi Taisen Quiz Hyhoo 2 (Japan)", 0 )
diff -Nru src-old/mame/drivers/hyprduel.c src/mame/drivers/hyprduel.c
--- src-old/mame/drivers/hyprduel.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/hyprduel.c	2012-04-27 14:38:14.000000000 +0200
@@ -441,7 +441,7 @@
 	AM_RANGE(0xe00002, 0xe00003) AM_READ_PORT("DSW")
 	AM_RANGE(0xe00004, 0xe00005) AM_READ_PORT("P1_P2")
 	AM_RANGE(0xe00006, 0xe00007) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("sharedram2")
 	AM_RANGE(0xfe4000, 0xffffff) AM_RAM AM_SHARE("sharedram3")
 ADDRESS_MAP_END
 
@@ -452,7 +452,7 @@
 	AM_RANGE(0x400004, 0x400005) AM_DEVREADWRITE8("oki", okim6295_device, read, write, 0x00ff)
 	AM_RANGE(0x800000, 0x800001) AM_NOP
 	AM_RANGE(0xc00000, 0xc07fff) AM_RAM AM_SHARE("sharedram1")
-	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("sharedram2")
 	AM_RANGE(0xfe4000, 0xffffff) AM_RAM AM_SHARE("sharedram3")
 ADDRESS_MAP_END
 
@@ -487,19 +487,19 @@
 	AM_RANGE(0xe00002, 0xe00003) AM_READ_PORT("DSW")
 	AM_RANGE(0xe00004, 0xe00005) AM_READ_PORT("P1_P2")
 	AM_RANGE(0xe00006, 0xe00007) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("sharedram2")
 	AM_RANGE(0xfe4000, 0xffffff) AM_RAM AM_SHARE("sharedram3")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( magerror_map2, AS_PROGRAM, 16, hyprduel_state )
-	AM_RANGE(0x000000, 0x003fff) AM_RAM AM_SHARE("share1")						/* shadow ($c00000 - $c03fff : vector) */
-	AM_RANGE(0x004000, 0x007fff) AM_READONLY AM_WRITENOP AM_SHARE("share3")			/* shadow ($fe4000 - $fe7fff : read only) */
+	AM_RANGE(0x000000, 0x003fff) AM_RAM AM_SHARE("sharedram1")						/* shadow ($c00000 - $c03fff : vector) */
+	AM_RANGE(0x004000, 0x007fff) AM_READONLY AM_WRITENOP AM_SHARE("sharedram3")		/* shadow ($fe4000 - $fe7fff : read only) */
 	AM_RANGE(0x400000, 0x400003) AM_NOP
 	AM_RANGE(0x800000, 0x800003) AM_READNOP AM_DEVWRITE8_LEGACY("ymsnd", ym2413_w, 0x00ff)
 	AM_RANGE(0x800004, 0x800005) AM_DEVREADWRITE8("oki", okim6295_device, read, write, 0x00ff)
-	AM_RANGE(0xc00000, 0xc1ffff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0xfe4000, 0xffffff) AM_RAM AM_SHARE("share3")
+	AM_RANGE(0xc00000, 0xc1ffff) AM_RAM AM_SHARE("sharedram1")
+	AM_RANGE(0xfe0000, 0xfe3fff) AM_RAM AM_SHARE("sharedram2")
+	AM_RANGE(0xfe4000, 0xffffff) AM_RAM AM_SHARE("sharedram3")
 ADDRESS_MAP_END
 
 /***************************************************************************
diff -Nru src-old/mame/drivers/icecold.c src/mame/drivers/icecold.c
--- src-old/mame/drivers/icecold.c	2012-04-15 02:50:27.000000000 +0200
+++ src/mame/drivers/icecold.c	2012-05-03 11:00:08.000000000 +0200
@@ -207,11 +207,11 @@
 	{
 		case 0:
 			// override the ball gate switch
-			return input_port_read(machine(), "X0") & ~(m_ball_gate_sw<<2);
+			return ioport("X0")->read() & ~(m_ball_gate_sw<<2);
 		case 1:
-			return input_port_read(machine(), "X1");
+			return ioport("X1")->read();
 		case 2:
-			return input_port_read(machine(), "X2");
+			return ioport("X2")->read();
 		default:
 			return 0xff;
 	}
diff -Nru src-old/mame/drivers/igs009.c src/mame/drivers/igs009.c
--- src-old/mame/drivers/igs009.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/igs009.c	2012-05-03 11:00:08.000000000 +0200
@@ -434,11 +434,11 @@
 	switch(m_igs_magic[0])
 	{
 		case 0x00:
-			if ( !(m_igs_magic[1] & 0x01) )	return input_port_read(machine(), "DSW1");
-			if ( !(m_igs_magic[1] & 0x02) )	return input_port_read(machine(), "DSW2");
-			if ( !(m_igs_magic[1] & 0x04) )	return input_port_read(machine(), "DSW3");
-			if ( !(m_igs_magic[1] & 0x08) )	return input_port_read(machine(), "DSW4");
-			if ( !(m_igs_magic[1] & 0x10) )	return input_port_read(machine(), "DSW5");
+			if ( !(m_igs_magic[1] & 0x01) )	return ioport("DSW1")->read();
+			if ( !(m_igs_magic[1] & 0x02) )	return ioport("DSW2")->read();
+			if ( !(m_igs_magic[1] & 0x04) )	return ioport("DSW3")->read();
+			if ( !(m_igs_magic[1] & 0x08) )	return ioport("DSW4")->read();
+			if ( !(m_igs_magic[1] & 0x10) )	return ioport("DSW5")->read();
 			logerror("%06x: warning, reading dsw with igs_magic[1] = %02x\n", cpu_get_pc(&space.device()), m_igs_magic[1]);
 			break;
 
diff -Nru src-old/mame/drivers/igs011.c src/mame/drivers/igs011.c
--- src-old/mame/drivers/igs011.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/igs011.c	2012-05-03 11:00:08.000000000 +0200
@@ -540,7 +540,7 @@
 
 	for (i = 0; i < NUM; i++)
 		if ((~m_igs_dips_sel) & (1 << i) )
-			ret = input_port_read(machine(), dipnames[i]);
+			ret = ioport(dipnames[i])->read();
 	/* 0x0100 is blitter busy */
 	return	(ret & 0xff) | 0x0000;
 }
@@ -1373,9 +1373,9 @@
 {
 	switch(m_igs003_reg[0])
 	{
-		case 0x00:	return input_port_read(machine(), "IN0");
-		case 0x01:	return input_port_read(machine(), "IN1");
-		case 0x02:	return input_port_read(machine(), "IN2");
+		case 0x00:	return ioport("IN0")->read();
+		case 0x01:	return ioport("IN1")->read();
+		case 0x02:	return ioport("IN2")->read();
 
 		case 0x20:	return 0x49;
 		case 0x21:	return 0x47;
@@ -1431,11 +1431,11 @@
 		case 0:		return m_igs_input_sel;
 
 		case 1:
-			if (~m_igs_input_sel & 0x01)	return input_port_read(machine(), "KEY0");
-			if (~m_igs_input_sel & 0x02)	return input_port_read(machine(), "KEY1");
-			if (~m_igs_input_sel & 0x04)	return input_port_read(machine(), "KEY2");
-			if (~m_igs_input_sel & 0x08)	return input_port_read(machine(), "KEY3");
-			if (~m_igs_input_sel & 0x10)	return input_port_read(machine(), "KEY4");
+			if (~m_igs_input_sel & 0x01)	return ioport("KEY0")->read();
+			if (~m_igs_input_sel & 0x02)	return ioport("KEY1")->read();
+			if (~m_igs_input_sel & 0x04)	return ioport("KEY2")->read();
+			if (~m_igs_input_sel & 0x08)	return ioport("KEY3")->read();
+			if (~m_igs_input_sel & 0x10)	return ioport("KEY4")->read();
 
 			logerror("%06x: warning, reading with igs_input_sel = %02x\n", cpu_get_pc(&space.device()), m_igs_input_sel);
 			break;
@@ -1494,11 +1494,11 @@
 	switch(m_igs003_reg[0])
 	{
 		case 0x01:
-			if (~m_igs_input_sel & 0x01)	return input_port_read(machine(), "KEY0");
-			if (~m_igs_input_sel & 0x02)	return input_port_read(machine(), "KEY1");
-			if (~m_igs_input_sel & 0x04)	return input_port_read(machine(), "KEY2");
-			if (~m_igs_input_sel & 0x08)	return input_port_read(machine(), "KEY3");
-			if (~m_igs_input_sel & 0x10)	return input_port_read(machine(), "KEY4");
+			if (~m_igs_input_sel & 0x01)	return ioport("KEY0")->read();
+			if (~m_igs_input_sel & 0x02)	return ioport("KEY1")->read();
+			if (~m_igs_input_sel & 0x04)	return ioport("KEY2")->read();
+			if (~m_igs_input_sel & 0x08)	return ioport("KEY3")->read();
+			if (~m_igs_input_sel & 0x10)	return ioport("KEY4")->read();
 			/* fall through */
 		default:
 			logerror("%06x: warning, reading with igs003_reg = %02x\n", cpu_get_pc(&space.device()), m_igs003_reg[0]);
@@ -1573,7 +1573,7 @@
 {
 	switch(m_igs003_reg[0])
 	{
-		case 0x00:	return input_port_read(machine(), "IN0");
+		case 0x00:	return ioport("IN0")->read();
 
 		case 0x20:	return 0x49;
 		case 0x21:	return 0x47;
@@ -1639,14 +1639,14 @@
 {
 	switch(m_igs003_reg[0])
 	{
-		case 0x00:	return input_port_read(machine(), "COIN");
+		case 0x00:	return ioport("COIN")->read();
 
 		case 0x02:
-			if (~m_igs_input_sel & 0x01)	return input_port_read(machine(), "KEY0");
-			if (~m_igs_input_sel & 0x02)	return input_port_read(machine(), "KEY1");
-			if (~m_igs_input_sel & 0x04)	return input_port_read(machine(), "KEY2");
-			if (~m_igs_input_sel & 0x08)	return input_port_read(machine(), "KEY3");
-			if (~m_igs_input_sel & 0x10)	return input_port_read(machine(), "KEY4");
+			if (~m_igs_input_sel & 0x01)	return ioport("KEY0")->read();
+			if (~m_igs_input_sel & 0x02)	return ioport("KEY1")->read();
+			if (~m_igs_input_sel & 0x04)	return ioport("KEY2")->read();
+			if (~m_igs_input_sel & 0x08)	return ioport("KEY3")->read();
+			if (~m_igs_input_sel & 0x10)	return ioport("KEY4")->read();
 			/* fall through */
 
 		case 0x20:	return 0x49;
@@ -1711,8 +1711,8 @@
 {
 	switch(m_igs003_reg[0])
 	{
-		case 0x00:	return input_port_read(machine(), "IN0");
-		case 0x01:	return input_port_read(machine(), "IN1");
+		case 0x00:	return ioport("IN0")->read();
+		case 0x01:	return ioport("IN1")->read();
 
 //      case 0x03:
 //          return 0xff;    // parametric bitswaps?
@@ -2408,7 +2408,7 @@
 	{
 		igs011_state *state = screen.machine().driver_data<igs011_state>();
 		state->m_vbowl_trackball[0] = state->m_vbowl_trackball[1];
-		state->m_vbowl_trackball[1] = (input_port_read(screen.machine(), "AN1") << 8) | input_port_read(screen.machine(), "AN0");
+		state->m_vbowl_trackball[1] = (state->ioport("AN1")->read() << 8) | state->ioport("AN0")->read();
 	}
 }
 
diff -Nru src-old/mame/drivers/igs017.c src/mame/drivers/igs017.c
--- src-old/mame/drivers/igs017.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/igs017.c	2012-05-03 11:00:08.000000000 +0200
@@ -219,7 +219,7 @@
 static void expand_sprites(running_machine &machine)
 {
 	igs017_state *state = machine.driver_data<igs017_state>();
-	UINT8 *rom	=	machine.root_device().memregion("sprites")->base();
+	UINT8 *rom	=	state->memregion("sprites")->base();
 	int size	=	state->memregion("sprites")->bytes();
 	int i;
 
@@ -1259,9 +1259,9 @@
 {
 	switch (m_input_select)
 	{
-		case 0x00:	return input_port_read(machine(), "PLAYER1");
-		case 0x01:	return input_port_read(machine(), "PLAYER2");
-		case 0x02:	return input_port_read(machine(), "COINS");
+		case 0x00:	return ioport("PLAYER1")->read();
+		case 0x01:	return ioport("PLAYER2")->read();
+		case 0x02:	return ioport("COINS")->read();
 
 		case 0x03:	return 01;
 
@@ -1377,11 +1377,11 @@
 static READ8_DEVICE_HANDLER( mgcs_keys_r )
 {
 	igs017_state *state = device->machine().driver_data<igs017_state>();
-	if (~state->m_input_select & 0x08)	return input_port_read(device->machine(), "KEY0");
-	if (~state->m_input_select & 0x10)	return input_port_read(device->machine(), "KEY1");
-	if (~state->m_input_select & 0x20)	return input_port_read(device->machine(), "KEY2");
-	if (~state->m_input_select & 0x40)	return input_port_read(device->machine(), "KEY3");
-	if (~state->m_input_select & 0x80)	return input_port_read(device->machine(), "KEY4");
+	if (~state->m_input_select & 0x08)	return state->ioport("KEY0")->read();
+	if (~state->m_input_select & 0x10)	return state->ioport("KEY1")->read();
+	if (~state->m_input_select & 0x20)	return state->ioport("KEY2")->read();
+	if (~state->m_input_select & 0x40)	return state->ioport("KEY3")->read();
+	if (~state->m_input_select & 0x80)	return state->ioport("KEY4")->read();
 
 	logerror("%s: warning, reading key with input_select = %02x\n", device->machine().describe_context(), state->m_input_select);
 	return 0xff;
@@ -1449,13 +1449,13 @@
 
 READ8_MEMBER(igs017_state::sdmg2_keys_r)
 {
-	if (~m_input_select & 0x01)	return input_port_read(machine(), "KEY0");
-	if (~m_input_select & 0x02)	return input_port_read(machine(), "KEY1");
-	if (~m_input_select & 0x04)	return input_port_read(machine(), "KEY2");
-	if (~m_input_select & 0x08)	return input_port_read(machine(), "KEY3");
-	if (~m_input_select & 0x10)	return input_port_read(machine(), "KEY4");
+	if (~m_input_select & 0x01)	return ioport("KEY0")->read();
+	if (~m_input_select & 0x02)	return ioport("KEY1")->read();
+	if (~m_input_select & 0x04)	return ioport("KEY2")->read();
+	if (~m_input_select & 0x08)	return ioport("KEY3")->read();
+	if (~m_input_select & 0x10)	return ioport("KEY4")->read();
 
-	if (m_input_select == 0x1f)	return input_port_read(machine(), "KEY0");	// in joystick mode
+	if (m_input_select == 0x1f)	return ioport("KEY0")->read();	// in joystick mode
 
 	logerror("%s: warning, reading key with input_select = %02x\n", machine().describe_context(), m_input_select);
 	return 0xff;
@@ -1502,7 +1502,7 @@
 		case 0x00:
 		{
 			UINT16 hopper_bit = (m_hopper && ((machine().primary_screen->frame_number()/10)&1)) ? 0x0000 : 0x0001;
-			return input_port_read(machine(), "COINS") | hopper_bit;
+			return ioport("COINS")->read() | hopper_bit;
 		}
 
 		case 0x02:
@@ -1538,13 +1538,13 @@
 
 READ8_MEMBER(igs017_state::mgdh_keys_r)
 {
-	if (~m_input_select & 0x04)	return input_port_read(machine(), "KEY0");
-	if (~m_input_select & 0x08)	return input_port_read(machine(), "KEY1");
-	if (~m_input_select & 0x10)	return input_port_read(machine(), "KEY2");
-	if (~m_input_select & 0x20)	return input_port_read(machine(), "KEY3");
-	if (~m_input_select & 0x40)	return input_port_read(machine(), "KEY4");
+	if (~m_input_select & 0x04)	return ioport("KEY0")->read();
+	if (~m_input_select & 0x08)	return ioport("KEY1")->read();
+	if (~m_input_select & 0x10)	return ioport("KEY2")->read();
+	if (~m_input_select & 0x20)	return ioport("KEY3")->read();
+	if (~m_input_select & 0x40)	return ioport("KEY4")->read();
 
-	if ((m_input_select & 0xfc) == 0xfc)	return input_port_read(machine(), "DSW1");
+	if ((m_input_select & 0xfc) == 0xfc)	return ioport("DSW1")->read();
 
 	logerror("%s: warning, reading key with input_select = %02x\n", machine().describe_context(), m_input_select);
 	return 0xff;
@@ -1616,15 +1616,15 @@
 			return mgdh_keys_r(space, 0);
 
 		case 0x01:
-			return input_port_read(machine(), "BUTTONS");
+			return ioport("BUTTONS")->read();
 
 		case 0x02:
-			return BITSWAP8(input_port_read(machine(), "DSW2"), 0,1,2,3,4,5,6,7);
+			return BITSWAP8(ioport("DSW2")->read(), 0,1,2,3,4,5,6,7);
 
 		case 0x03:
 		{
 			UINT16 hopper_bit = (m_hopper && ((machine().primary_screen->frame_number()/10)&1)) ? 0x0000 : 0x0001;
-			return input_port_read(machine(), "COINS") | hopper_bit;
+			return ioport("COINS")->read() | hopper_bit;
 		}
 
 		default:
@@ -1702,13 +1702,13 @@
 {
 	switch (m_input_select)
 	{
-		case 0x00:	return input_port_read(machine(), "PLAYER1");
-		case 0x01:	return input_port_read(machine(), "PLAYER2");
-		case 0x02:	return input_port_read(machine(), "COINS");
+		case 0x00:	return ioport("PLAYER1")->read();
+		case 0x01:	return ioport("PLAYER2")->read();
+		case 0x02:	return ioport("COINS")->read();
 		case 0x03:
 		{
 			UINT8 hopper_bit = (m_hopper && ((machine().primary_screen->frame_number()/10)&1)) ? 0x00 : 0x20;
-			return input_port_read(machine(), "HOPPER") | hopper_bit;
+			return ioport("HOPPER")->read() | hopper_bit;
 		}
 
 		default:
@@ -1794,11 +1794,11 @@
 	{
 		case 0x01:
 		{
-			if (~m_input_select & 0x01)	return input_port_read(machine(), "KEY0");
-			if (~m_input_select & 0x02)	return input_port_read(machine(), "KEY1");
-			if (~m_input_select & 0x04)	return input_port_read(machine(), "KEY2");
-			if (~m_input_select & 0x08)	return input_port_read(machine(), "KEY3");
-			if (~m_input_select & 0x10)	return input_port_read(machine(), "KEY4");
+			if (~m_input_select & 0x01)	return ioport("KEY0")->read();
+			if (~m_input_select & 0x02)	return ioport("KEY1")->read();
+			if (~m_input_select & 0x04)	return ioport("KEY2")->read();
+			if (~m_input_select & 0x08)	return ioport("KEY3")->read();
+			if (~m_input_select & 0x10)	return ioport("KEY4")->read();
 
 			logerror("%s: warning, reading key with input_select = %02x\n", machine().describe_context(), m_input_select);
 			return 0xffff;
@@ -1854,8 +1854,8 @@
 	{
 		case 0x03:
 		{
-			UINT8 a = BITSWAP8(m_prot[0], 9,9,1,9,2,5,4,7);	// 9 means 0 value
-			UINT8 b = BITSWAP8(m_prot[1], 5,2,9,7,9,9,9,9);
+			UINT8 a = BITSWAP8((UINT16)m_prot[0], 9,9,1,9,2,5,4,7);	// 9 means 0 value
+			UINT8 b = BITSWAP8((UINT16)m_prot[1], 5,2,9,7,9,9,9,9);
 			return a | b;
 		}
 
@@ -1885,11 +1885,11 @@
 	{
 		case 0x00:	// Keys
 		{
-			if (~m_input_select & 0x01)	return input_port_read(machine(), "KEY0") << 8;
-			if (~m_input_select & 0x02)	return input_port_read(machine(), "KEY1") << 8;
-			if (~m_input_select & 0x04)	return input_port_read(machine(), "KEY2") << 8;
-			if (~m_input_select & 0x08)	return input_port_read(machine(), "KEY3") << 8;
-			if (~m_input_select & 0x10)	return input_port_read(machine(), "KEY4") << 8;
+			if (~m_input_select & 0x01)	return ioport("KEY0")->read() << 8;
+			if (~m_input_select & 0x02)	return ioport("KEY1")->read() << 8;
+			if (~m_input_select & 0x04)	return ioport("KEY2")->read() << 8;
+			if (~m_input_select & 0x08)	return ioport("KEY3")->read() << 8;
+			if (~m_input_select & 0x10)	return ioport("KEY4")->read() << 8;
 
 			logerror("%s: warning, reading key with input_select = %02x\n", machine().describe_context(), m_input_select);
 			return 0xffff;
@@ -1898,11 +1898,11 @@
 		case 0x02:
 		{
 			UINT16 hopper_bit = (m_hopper && ((machine().primary_screen->frame_number()/10)&1)) ? 0x0000 : 0x0002;
-			return (input_port_read(machine(), "DSW1") << 8) | input_port_read(machine(), "COINS") | hopper_bit;
+			return (ioport("DSW1")->read() << 8) | ioport("COINS")->read() | hopper_bit;
 		}
 
 		case 0x04:
-			return input_port_read(machine(), "DSW2");
+			return ioport("DSW2")->read();
 	}
 
 	return 0xffff;
@@ -2011,11 +2011,11 @@
 	switch(m_igs_magic[0])
 	{
 		case 0x00:
-			return input_port_read(machine(), "PLAYER2");
+			return ioport("PLAYER2")->read();
 		case 0x01:
-			return input_port_read(machine(), "PLAYER1");
+			return ioport("PLAYER1")->read();
 		case 0x02:
-			return input_port_read(machine(), "BUTTONS");
+			return ioport("BUTTONS")->read();
 
 		default:
 			logerror("%s: warning, reading with igs_magic = %02x\n", machine().describe_context(), m_igs_magic[0]);
@@ -2559,31 +2559,31 @@
 	PORT_BIT( 0x20, IP_ACTIVE_LOW,  IPT_OTHER     ) PORT_NAME("Pay Out") PORT_CODE(KEYCODE_O)
 
 	// Keyboard mode:
-	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_SERVICE3  )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)	// shown in test mode
+	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_SERVICE3  )	PORT_CONDITION("DSW2",0x40,EQUALS,0x40)	// shown in test mode
 	// Joystick mode:
-	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON3   )	PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW,  IPT_BUTTON3   )	PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 
 	PORT_BIT( 0x80, IP_ACTIVE_LOW,  IPT_UNKNOWN   )
 
 	PORT_START("KEY0")
 	// Keyboard mode:
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A         ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E         ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I         ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M         ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN       ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A         ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E         ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I         ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M         ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN       ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	// Joystick mode:
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_UP       ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN     ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT     ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT    ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON1           ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2           ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_UP       ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN     ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT     ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT    ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON1           ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON2           ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
 
 	PORT_START("KEY1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )
@@ -2690,23 +2690,23 @@
 
 	PORT_START("KEY0")
 	// Keyboard mode:
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A         ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E         ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I         ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M         ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN       ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x02)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_A         ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_E         ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_MAHJONG_I         ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_MAHJONG_M         ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_KAN       ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,EQUALS,0x02)
 	// Joystick mode:
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_UP       ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN     ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT     ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT    ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON1           ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1            ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_UP       ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN     ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT     ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT    ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON1           ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN           ) PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
 
 	PORT_START("KEY1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_B )
diff -Nru src-old/mame/drivers/igspoker.c src/mame/drivers/igspoker.c
--- src-old/mame/drivers/igspoker.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/igspoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -298,7 +298,7 @@
 
 	switch (data)
 	{
-		case 0x00: m_protection_res = input_port_read(machine(), "BUTTONS1"); break;
+		case 0x00: m_protection_res = ioport("BUTTONS1")->read(); break;
 		// CSK227
 		case 0x20: m_protection_res = 0x49; break;
 		case 0x21: m_protection_res = 0x47; break;
diff -Nru src-old/mame/drivers/imolagp.c src/mame/drivers/imolagp.c
--- src-old/mame/drivers/imolagp.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/imolagp.c	2012-05-03 11:00:08.000000000 +0200
@@ -472,7 +472,7 @@
 	imolagp_state *state = timer.machine().driver_data<imolagp_state>();
 
 	{
-		int newsteer = input_port_read(timer.machine(), "2802") & 0xf;
+		int newsteer = timer.machine().root_device().ioport("2802")->read() & 0xf;
 		if (newsteer != state->m_oldsteer)
 		{
 			if (state->m_steerlatch == 0)
diff -Nru src-old/mame/drivers/irobot.c src/mame/drivers/irobot.c
--- src-old/mame/drivers/irobot.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/irobot.c	2012-05-03 11:00:08.000000000 +0200
@@ -185,7 +185,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN ) /* MB DONE */
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN ) /* EXT DONE */
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2") /* DSW2 - 5E*/
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Language ) )  PORT_DIPLOCATION("SW5E:1")
diff -Nru src-old/mame/drivers/itech32.c src/mame/drivers/itech32.c
--- src-old/mame/drivers/itech32.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/itech32.c	2012-05-03 11:00:08.000000000 +0200
@@ -474,8 +474,8 @@
 
 READ16_MEMBER(itech32_state::trackball_r)
 {
-	int lower = input_port_read(machine(), "TRACKX1");
-	int upper = input_port_read(machine(), "TRACKY1");
+	int lower = ioport("TRACKX1")->read();
+	int upper = ioport("TRACKY1")->read();
 
 	return (lower & 15) | ((upper & 15) << 4);
 }
@@ -483,8 +483,8 @@
 
 READ32_MEMBER(itech32_state::trackball32_8bit_r)
 {
-	int lower = input_port_read(machine(), "TRACKX1");
-	int upper = input_port_read(machine(), "TRACKY1");
+	int lower = ioport("TRACKX1")->read();
+	int upper = ioport("TRACKY1")->read();
 
 	return (lower & 255) | ((upper & 255) << 8);
 }
@@ -499,8 +499,8 @@
 		int upper, lower;
 		int dx, dy;
 
-		int curx = input_port_read(machine(), "TRACKX1");
-		int cury = input_port_read(machine(), "TRACKY1");
+		int curx = ioport("TRACKX1")->read();
+		int cury = ioport("TRACKY1")->read();
 
 		dx = curx - m_p1_effx;
 		if (dx < -0x80) dx += 0x100;
@@ -535,8 +535,8 @@
 		int upper, lower;
 		int dx, dy;
 
-		int curx = input_port_read(machine(), "TRACKX2");
-		int cury = input_port_read(machine(), "TRACKY2");
+		int curx = ioport("TRACKX2")->read();
+		int cury = ioport("TRACKY2")->read();
 
 		dx = curx - m_p2_effx;
 		if (dx < -0x80) dx += 0x100;
@@ -571,7 +571,7 @@
 
 READ32_MEMBER(itech32_state::drivedge_steering_r)
 {
-	int val = input_port_read(machine(), "STEER") * 2 - 0x100;
+	int val = ioport("STEER")->read() * 2 - 0x100;
 	if (val < 0) val = 0x100 | (-val);
 	return val << 16;
 }
@@ -579,7 +579,7 @@
 
 READ32_MEMBER(itech32_state::drivedge_gas_r)
 {
-	int val = input_port_read(machine(), "GAS");
+	int val = ioport("GAS")->read();
 	return val << 16;
 }
 
@@ -1115,7 +1115,7 @@
 	PORT_START("DIPS")		/* 58000 */
 	PORT_SERVICE_NO_TOGGLE( 0x0001, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, itech32_state,special_port_r, NULL)
 	PORT_DIPNAME( 0x0010, 0x0000, "Video Sync" )	 PORT_DIPLOCATION("SW1:1")
 	PORT_DIPSETTING(      0x0000, "-" )
@@ -1160,7 +1160,7 @@
 	PORT_START("DIPS")	/* 280000 */
 	PORT_SERVICE_NO_TOGGLE( 0x0001, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, itech32_state,special_port_r, NULL)
 	PORT_DIPNAME( 0x0010, 0x0000, "Video Sync" )	 PORT_DIPLOCATION("SW1:4")
 	PORT_DIPSETTING(      0x0000, "-" )
@@ -1278,7 +1278,7 @@
 	PORT_BIT( 0x0000ffff, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x01000000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x02000000, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x04000000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x04000000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x08000000, IP_ACTIVE_LOW, IPT_SPECIAL )
 	PORT_DIPNAME( 0x70000000, 0x00000000, "Network Number" ) PORT_DIPLOCATION("SW1:4,3,2")
 	PORT_DIPSETTING(          0x00000000, "1" )
@@ -1363,7 +1363,7 @@
 	PORT_BIT( 0x0000ffff, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_SERVICE_NO_TOGGLE( 0x00010000, IP_ACTIVE_LOW )
 	PORT_BIT( 0x00020000, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x00080000, IP_ACTIVE_LOW, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, itech32_state,special_port_r, NULL)
 	PORT_DIPNAME( 0x00100000, 0x00000000, "Video Sync" )	 PORT_DIPLOCATION("SW1:4")
 	PORT_DIPSETTING(          0x00000000, "-" )
diff -Nru src-old/mame/drivers/itech8.c src/mame/drivers/itech8.c
--- src-old/mame/drivers/itech8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/itech8.c	2012-05-03 11:00:08.000000000 +0200
@@ -1104,7 +1104,7 @@
 {
 	const char *tag1 = (const char *)param;
 	const char *tag2 = tag1 + strlen(tag1) + 1;
-	return input_port_read(machine(), tag1) & input_port_read(machine(), tag2);
+	return ioport(tag2)->read();
 }
 
 static INPUT_PORTS_START( gtg )
diff -Nru src-old/mame/drivers/jack.c src/mame/drivers/jack.c
--- src-old/mame/drivers/jack.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jack.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,7 +82,7 @@
 {
 	UINT8 ret = 0;
 
-	if ((input_port_read(machine(), "IN2") & 0x80) && !m_joinem_snd_bit)
+	if ((ioport("IN2")->read() & 0x80) && !m_joinem_snd_bit)
 		ret = 1;
 
 	return ret;
@@ -682,14 +682,14 @@
 	PORT_DIPSETTING(    0x02, "Horizontal" )
 	PORT_DIPSETTING(    0x00, "Vertical" )
 	PORT_DIPNAME( 0x05, 0x05, "Gaming Option Number" )	PORT_DIPLOCATION("SW1:!1,!3")
-	PORT_DIPSETTING(    0x01, "2" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x05, "3" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "4" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x04, "5" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x01, "4" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x05, "5" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "6" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x04, "7" ) PORT_CONDITION("DSW1", 0x20, PORTCOND_NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x01, "2" ) PORT_CONDITION("DSW1", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x05, "3" ) PORT_CONDITION("DSW1", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "4" ) PORT_CONDITION("DSW1", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x04, "5" ) PORT_CONDITION("DSW1", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x01, "4" ) PORT_CONDITION("DSW1", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x05, "5" ) PORT_CONDITION("DSW1", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "6" ) PORT_CONDITION("DSW1", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x04, "7" ) PORT_CONDITION("DSW1", 0x20, NOTEQUALS, 0x20)
 	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Cabinet ) )		PORT_DIPLOCATION("SW1:!4")
 	PORT_DIPSETTING(    0x08, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
@@ -857,7 +857,7 @@
 static INTERRUPT_GEN( joinem_vblank_irq )
 {
 	 /* TODO: looks hackish to me ... */
-	if (!(input_port_read(device->machine(), "IN2") & 0x80))
+	if (!(device->machine().root_device().ioport("IN2")->read() & 0x80))
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
diff -Nru src-old/mame/drivers/jackal.c src/mame/drivers/jackal.c
--- src-old/mame/drivers/jackal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jackal.c	2012-05-03 11:00:08.000000000 +0200
@@ -85,7 +85,7 @@
 
 READ8_MEMBER(jackal_state::topgunbl_rotary_r)
 {
-	return (1 << input_port_read_safe(machine(), offset ? "DIAL1" : "DIAL0", 0x00)) ^ 0xff;
+	return (1 << ioport(offset ? "DIAL1" : "DIAL0")->read_safe(0x00)) ^ 0xff;
 }
 
 WRITE8_MEMBER(jackal_state::jackal_flipscreen_w)
diff -Nru src-old/mame/drivers/jackpool.c src/mame/drivers/jackpool.c
--- src-old/mame/drivers/jackpool.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jackpool.c	2012-05-03 11:00:08.000000000 +0200
@@ -97,20 +97,20 @@
 {
 	switch(offset*2)
 	{
-		case 0x00: return input_port_read(machine(),"COIN1");
-		case 0x04: return input_port_read(machine(),"UNK1");
-		case 0x06: return input_port_read(machine(),"UNK2");
-		case 0x08: return input_port_read(machine(),"SERVICE1");
-		case 0x0a: return input_port_read(machine(),"SERVICE2");//probably not a button, remote?
-		case 0x0c: return input_port_read(machine(),"PAYOUT");
-		case 0x0e: return input_port_read(machine(),"START2");
-		case 0x10: return input_port_read(machine(),"HOLD3");
-		case 0x12: return input_port_read(machine(),"HOLD4");
-		case 0x14: return input_port_read(machine(),"HOLD2");
-		case 0x16: return input_port_read(machine(),"HOLD1");
-		case 0x18: return input_port_read(machine(),"HOLD5");
-		case 0x1a: return input_port_read(machine(),"START1");
-		case 0x1c: return input_port_read(machine(),"BET");
+		case 0x00: return ioport("COIN1")->read();
+		case 0x04: return ioport("UNK1")->read();
+		case 0x06: return ioport("UNK2")->read();
+		case 0x08: return ioport("SERVICE1")->read();
+		case 0x0a: return ioport("SERVICE2")->read();//probably not a button, remote?
+		case 0x0c: return ioport("PAYOUT")->read();
+		case 0x0e: return ioport("START2")->read();
+		case 0x10: return ioport("HOLD3")->read();
+		case 0x12: return ioport("HOLD4")->read();
+		case 0x14: return ioport("HOLD2")->read();
+		case 0x16: return ioport("HOLD1")->read();
+		case 0x18: return ioport("HOLD5")->read();
+		case 0x1a: return ioport("START1")->read();
+		case 0x1c: return ioport("BET")->read();
 		case 0x1e: return 0xff; //ticket motor
 		case 0x20: return 0xff; //hopper motor
     	case 0x2c: return machine().device<eeprom_device>("eeprom")->read_bit();
diff -Nru src-old/mame/drivers/jaguar.c src/mame/drivers/jaguar.c
--- src-old/mame/drivers/jaguar.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jaguar.c	2012-05-03 11:00:08.000000000 +0200
@@ -555,7 +555,7 @@
 	joystick_data = 0xffffffff;
 	eeprom_bit_count = 0;
 	blitter_status = 1;
-	if ((using_cart) && (input_port_read(machine, "CONFIG") & 2))
+	if ((using_cart) && (machine.root_device().ioport("CONFIG")->read() & 2))
 	{
 		cart_base[0x102] = 1;
 		using_cart = 0;
@@ -825,13 +825,13 @@
 	{
 		if ((joystick_data & (0x10000 << i)) == 0)
 		{
-			joystick_result &= input_port_read(machine(), keynames[0][i]);
-			joybuts_result &= input_port_read(machine(), keynames[1][i]);
+			joystick_result &= ioport(keynames[0][i])->read();
+			joybuts_result &= ioport(keynames[1][i])->read();
 		}
 	}
 
 	joystick_result |= machine().device<eeprom_device>("eeprom")->read_bit();
-	joybuts_result |= (input_port_read(machine(), "CONFIG") & 0x10);
+	joybuts_result |= (ioport("CONFIG")->read() & 0x10);
 
 	return (joystick_result << 16) | joybuts_result;
 }
diff -Nru src-old/mame/drivers/jalmah.c src/mame/drivers/jalmah.c
--- src-old/mame/drivers/jalmah.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jalmah.c	2012-05-03 11:00:08.000000000 +0200
@@ -698,7 +698,7 @@
 
 
 #define MCU_READ(tag, _bit_, _offset_, _retval_) \
-if((0xffff - input_port_read(machine, tag)) & _bit_) { jm_shared_ram[_offset_] = _retval_; }
+if((0xffff - machine.root_device().ioport(tag)->read()) & _bit_) { jm_shared_ram[_offset_] = _retval_; }
 
 /*Funky "DMA" / protection thing*/
 /*---- -x-- "DMA" execute.*/
@@ -749,12 +749,12 @@
 
 	if(state->m_test_mode)	//service_mode
 	{
-		jm_shared_ram[0x000/2] = input_port_read(machine, "KEY0");
-		jm_shared_ram[0x002/2] = input_port_read(machine, "KEY1");
-		jm_shared_ram[0x004/2] = input_port_read(machine, "KEY2");
-		jm_shared_ram[0x006/2] = input_port_read(machine, "KEY3");
-		jm_shared_ram[0x008/2] = input_port_read(machine, "KEY4");
-		jm_shared_ram[0x00a/2] = input_port_read(machine, "KEY5");
+		jm_shared_ram[0x000/2] = machine.root_device().ioport("KEY0")->read();
+		jm_shared_ram[0x002/2] = machine.root_device().ioport("KEY1")->read();
+		jm_shared_ram[0x004/2] = machine.root_device().ioport("KEY2")->read();
+		jm_shared_ram[0x006/2] = machine.root_device().ioport("KEY3")->read();
+		jm_shared_ram[0x008/2] = machine.root_device().ioport("KEY4")->read();
+		jm_shared_ram[0x00a/2] = machine.root_device().ioport("KEY5")->read();
 	}
 	else
 	{
@@ -793,12 +793,12 @@
 
 	if(state->m_test_mode)	//service_mode
 	{
-		jm_shared_ram[0x000/2] = input_port_read(machine, "KEY0");
-		jm_shared_ram[0x002/2] = input_port_read(machine, "KEY1");
-		jm_shared_ram[0x004/2] = input_port_read(machine, "KEY2");
-		jm_shared_ram[0x006/2] = input_port_read(machine, "KEY3");
-		jm_shared_ram[0x008/2] = input_port_read(machine, "KEY4");
-		jm_shared_ram[0x00a/2] = input_port_read(machine, "KEY5");
+		jm_shared_ram[0x000/2] = state->ioport("KEY0")->read();
+		jm_shared_ram[0x002/2] = state->ioport("KEY1")->read();
+		jm_shared_ram[0x004/2] = state->ioport("KEY2")->read();
+		jm_shared_ram[0x006/2] = state->ioport("KEY3")->read();
+		jm_shared_ram[0x008/2] = state->ioport("KEY4")->read();
+		jm_shared_ram[0x00a/2] = state->ioport("KEY5")->read();
 	}
 	else
 	{
@@ -838,12 +838,12 @@
 
 	if(state->m_test_mode)	//service_mode
 	{
-		jm_shared_ram[0x300/2] = input_port_read(machine, "KEY0");
-		jm_shared_ram[0x302/2] = input_port_read(machine, "KEY1");
-		jm_shared_ram[0x304/2] = input_port_read(machine, "KEY2");
-		jm_shared_ram[0x306/2] = input_port_read(machine, "KEY3");
-		jm_shared_ram[0x308/2] = input_port_read(machine, "KEY4");
-		jm_shared_ram[0x30a/2] = input_port_read(machine, "KEY5");
+		jm_shared_ram[0x300/2] = state->ioport("KEY0")->read();
+		jm_shared_ram[0x302/2] = state->ioport("KEY1")->read();
+		jm_shared_ram[0x304/2] = state->ioport("KEY2")->read();
+		jm_shared_ram[0x306/2] = state->ioport("KEY3")->read();
+		jm_shared_ram[0x308/2] = state->ioport("KEY4")->read();
+		jm_shared_ram[0x30a/2] = state->ioport("KEY5")->read();
 	}
 	else
 	{
@@ -882,9 +882,9 @@
 	UINT16 *jm_shared_ram = state->m_jm_shared_ram;
 	if(state->m_test_mode)	//service_mode
 	{
-		jm_shared_ram[0x200/2] = input_port_read(machine, "KEY0");
-		jm_shared_ram[0x202/2] = input_port_read(machine, "KEY1");
-		jm_shared_ram[0x204/2] = input_port_read(machine, "KEY2");
+		jm_shared_ram[0x200/2] = state->ioport("KEY0")->read();
+		jm_shared_ram[0x202/2] = state->ioport("KEY1")->read();
+		jm_shared_ram[0x204/2] = state->ioport("KEY2")->read();
 	}
 	else
 	{
@@ -1378,15 +1378,15 @@
 	{
 		case MJZOOMIN_MCU:
 		case DAIREIKA_MCU:
-			state->m_test_mode = (~(input_port_read(machine, "SYSTEM")) & 0x0008) ? (1) : (0);
+			state->m_test_mode = (~(state->ioport("SYSTEM")->read()) & 0x0008) ? (1) : (0);
 			break;
 		case URASHIMA_MCU:
-			state->m_test_mode = ((~(input_port_read(machine, "SYSTEM")) & 0x0008) || (~(input_port_read(machine, "DSW")) & 0x8000)) ? (1) : (0);
+			state->m_test_mode = ((~(state->ioport("SYSTEM")->read()) & 0x0008) || (~(state->ioport("DSW")->read()) & 0x8000)) ? (1) : (0);
 			break;
 		case KAKUMEI_MCU:
 		case KAKUMEI2_MCU:
 		case SUCHIPI_MCU:
-			state->m_test_mode = (~(input_port_read(machine, "DSW")) & 0x0004) ? (1) : (0);
+			state->m_test_mode = (~(state->ioport("DSW")->read()) & 0x0004) ? (1) : (0);
 			break;
 	}
 }
diff -Nru src-old/mame/drivers/jangou.c src/mame/drivers/jangou.c
--- src-old/mame/drivers/jangou.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jangou.c	2012-05-03 11:00:08.000000000 +0200
@@ -277,20 +277,20 @@
 	jangou_state *state = device->machine().driver_data<jangou_state>();
 	switch(state->m_mux_data)
 	{
-		case 0x01: return input_port_read(device->machine(), "PL1_1");
-		case 0x02: return input_port_read(device->machine(), "PL1_2");
-		case 0x04: return input_port_read(device->machine(), "PL2_1");
-		case 0x08: return input_port_read(device->machine(), "PL2_2");
-		case 0x10: return input_port_read(device->machine(), "PL1_3");
-		case 0x20: return input_port_read(device->machine(), "PL2_3");
+		case 0x01: return state->ioport("PL1_1")->read();
+		case 0x02: return state->ioport("PL1_2")->read();
+		case 0x04: return state->ioport("PL2_1")->read();
+		case 0x08: return state->ioport("PL2_2")->read();
+		case 0x10: return state->ioport("PL1_3")->read();
+		case 0x20: return state->ioport("PL2_3")->read();
 	}
 
-	return input_port_read(device->machine(), "IN_NOMUX");
+	return device->machine().root_device().ioport("IN_NOMUX")->read();
 }
 
 static READ8_DEVICE_HANDLER( input_system_r )
 {
-	return input_port_read(device->machine(), "SYSTEM");
+	return device->machine().root_device().ioport("SYSTEM")->read();
 }
 
 
@@ -595,7 +595,7 @@
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK ) // guess
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") // guess
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN ) // blitter busy flag
 INPUT_PORTS_END
 
@@ -656,7 +656,7 @@
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK ) // guess
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") // guess
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN ) // blitter busy flag
 INPUT_PORTS_END
 
@@ -782,7 +782,7 @@
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) ) PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN ) //blitter busy flag
 INPUT_PORTS_END
 
diff -Nru src-old/mame/drivers/jantotsu.c src/mame/drivers/jantotsu.c
--- src-old/mame/drivers/jantotsu.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jantotsu.c	2012-05-03 11:00:08.000000000 +0200
@@ -238,12 +238,12 @@
 	UINT8 i,res;
 
 	//  printf("%02x\n", m_mux_data);
-	res = input_port_read(machine(), "COINS");
+	res = ioport("COINS")->read();
 
 	for(i=0;i<8;i++)
 	{
 		if((~m_mux_data) & (1 << i))
-			res |= input_port_read(machine(), portnames[i]);
+			res |= ioport(portnames[i])->read();
 	}
 
 	return res;
@@ -260,7 +260,7 @@
   a side-by-side test (to know if the background colors really works) to be sure. */
 READ8_MEMBER(jantotsu_state::jantotsu_dsw2_r)
 {
-	return (input_port_read(machine(), "DSW2") & 0x3f) | 0x80;
+	return (ioport("DSW2")->read() & 0x3f) | 0x80;
 }
 
 static WRITE8_DEVICE_HANDLER( jan_adpcm_w )
@@ -490,7 +490,7 @@
 	jantotsu_state *state = machine.driver_data<jantotsu_state>();
 
 	/*Load hard-wired background color.*/
-	state->m_col_bank = (input_port_read(machine, "DSW2") & 0xc0) >> 3;
+	state->m_col_bank = (state->ioport("DSW2")->read() & 0xc0) >> 3;
 
 	state->m_vram_bank = 0;
 	state->m_mux_data = 0;
diff -Nru src-old/mame/drivers/jchan.c src/mame/drivers/jchan.c
--- src-old/mame/drivers/jchan.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jchan.c	2012-05-03 11:00:08.000000000 +0200
@@ -260,7 +260,7 @@
 
 		case 0x03:	// DSW
 		{
-			state->m_mcu_ram[mcu_offset] = input_port_read(machine, "DSW");
+			state->m_mcu_ram[mcu_offset] = machine.root_device().ioport("DSW")->read();
 			logerror("%s : MCU executed command: %04X %04X (read DSW)\n",machine.describe_context(),mcu_command,mcu_offset*2);
 		}
 		break;
@@ -447,10 +447,10 @@
 
 	switch(offset)
 	{
-		case 0/2: return input_port_read(machine(), "P1");
-		case 2/2: return input_port_read(machine(), "P2");
-		case 4/2: return input_port_read(machine(), "SYSTEM");
-		case 6/2: return input_port_read(machine(), "EXTRA");
+		case 0/2: return ioport("P1")->read();
+		case 2/2: return ioport("P2")->read();
+		case 4/2: return ioport("SYSTEM")->read();
+		case 6/2: return ioport("EXTRA")->read();
 		default: logerror("jchan_ctrl_r unknown!"); break;
 	}
 	return m_ctrl[offset];
@@ -590,8 +590,8 @@
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT	) PORT_8WAY PORT_PLAYER(1)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("P2")		/* $f00002.w (-> $2000b5.b) */
@@ -601,8 +601,8 @@
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT	) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("SYSTEM")	/* $f00004.b */
@@ -616,14 +616,14 @@
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("EXTRA")		/* $f00006.b */
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x0000)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNKNOWN )                PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1) PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2) PORT_CONDITION("DSW",0x8000,EQUALS,0x0000)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )               /* duplicated Player 1 Button 4 (whatever the layout is) */
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNKNOWN )               /* duplicated Player 2 Button 4 (whatever the layout is) */
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/jedi.c src/mame/drivers/jedi.c
--- src-old/mame/drivers/jedi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jedi.c	2012-05-03 11:00:08.000000000 +0200
@@ -214,8 +214,8 @@
 
 	switch (m_a2d_select)
 	{
-		case 0: ret = input_port_read(machine(), "STICKY"); break;
-		case 2: ret = input_port_read(machine(), "STICKX"); break;
+		case 0: ret = ioport("STICKY")->read(); break;
+		case 2: ret = ioport("STICKX")->read(); break;
 	}
 
 	return ret;
@@ -321,7 +321,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_TILT )
 	PORT_BIT( 0x18, IP_ACTIVE_LOW,  IPT_UNUSED )
 	PORT_BIT( 0x60, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF,jedi_state,jedi_audio_comm_stat_r, NULL)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("STICKY")	/* analog Y */
 	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_SENSITIVITY(100) PORT_KEYDELTA(10)
diff -Nru src-old/mame/drivers/jongkyo.c src/mame/drivers/jongkyo.c
--- src-old/mame/drivers/jongkyo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jongkyo.c	2012-05-03 11:00:08.000000000 +0200
@@ -144,41 +144,41 @@
 static READ8_DEVICE_HANDLER( input_1p_r )
 {
 	jongkyo_state *state = device->machine().driver_data<jongkyo_state>();
-	UINT8 cr_clear = input_port_read(device->machine(), "CR_CLEAR");
+	UINT8 cr_clear = state->ioport("CR_CLEAR")->read();
 
 	switch (state->m_mux_data)
 	{
-		case 0x01: return input_port_read(device->machine(), "PL1_1") | cr_clear;
-		case 0x02: return input_port_read(device->machine(), "PL1_2") | cr_clear;
-		case 0x04: return input_port_read(device->machine(), "PL1_3") | cr_clear;
-		case 0x08: return input_port_read(device->machine(), "PL1_4") | cr_clear;
-		case 0x10: return input_port_read(device->machine(), "PL1_5") | cr_clear;
-		case 0x20: return input_port_read(device->machine(), "PL1_6") | cr_clear;
+		case 0x01: return state->ioport("PL1_1")->read() | cr_clear;
+		case 0x02: return state->ioport("PL1_2")->read() | cr_clear;
+		case 0x04: return state->ioport("PL1_3")->read() | cr_clear;
+		case 0x08: return state->ioport("PL1_4")->read() | cr_clear;
+		case 0x10: return state->ioport("PL1_5")->read() | cr_clear;
+		case 0x20: return state->ioport("PL1_6")->read() | cr_clear;
 	}
 	//  printf("%04x\n", state->m_mux_data);
 
-	return (input_port_read(device->machine(), "PL1_1") & input_port_read(device->machine(), "PL1_2") & input_port_read(device->machine(), "PL1_3") &
-	       input_port_read(device->machine(), "PL1_4") & input_port_read(device->machine(), "PL1_5") & input_port_read(device->machine(), "PL1_6")) | cr_clear;
+	return (state->ioport("PL1_1")->read() & state->ioport("PL1_2")->read() & state->ioport("PL1_3")->read() &
+	       state->ioport("PL1_4")->read() & state->ioport("PL1_5")->read() & state->ioport("PL1_6")->read()) | cr_clear;
 }
 
 static READ8_DEVICE_HANDLER( input_2p_r )
 {
 	jongkyo_state *state = device->machine().driver_data<jongkyo_state>();
-	UINT8 coin_port = input_port_read(device->machine(), "COINS");
+	UINT8 coin_port = state->ioport("COINS")->read();
 
 	switch (state->m_mux_data)
 	{
-		case 0x01: return input_port_read(device->machine(), "PL2_1") | coin_port;
-		case 0x02: return input_port_read(device->machine(), "PL2_2") | coin_port;
-		case 0x04: return input_port_read(device->machine(), "PL2_3") | coin_port;
-		case 0x08: return input_port_read(device->machine(), "PL2_4") | coin_port;
-		case 0x10: return input_port_read(device->machine(), "PL2_5") | coin_port;
-		case 0x20: return input_port_read(device->machine(), "PL2_6") | coin_port;
+		case 0x01: return state->ioport("PL2_1")->read() | coin_port;
+		case 0x02: return state->ioport("PL2_2")->read() | coin_port;
+		case 0x04: return state->ioport("PL2_3")->read() | coin_port;
+		case 0x08: return state->ioport("PL2_4")->read() | coin_port;
+		case 0x10: return state->ioport("PL2_5")->read() | coin_port;
+		case 0x20: return state->ioport("PL2_6")->read() | coin_port;
 	}
 	//  printf("%04x\n", state->m_mux_data);
 
-	return (input_port_read(device->machine(), "PL2_1") & input_port_read(device->machine(), "PL2_2") & input_port_read(device->machine(), "PL2_3") &
-	       input_port_read(device->machine(), "PL2_4") & input_port_read(device->machine(), "PL2_5") & input_port_read(device->machine(), "PL2_6")) | coin_port;
+	return (state->ioport("PL2_1")->read() & state->ioport("PL2_2")->read() & state->ioport("PL2_3")->read() &
+	       state->ioport("PL2_4")->read() & state->ioport("PL2_5")->read() & state->ioport("PL2_6")->read()) | coin_port;
 }
 
 WRITE8_MEMBER(jongkyo_state::videoram2_w)
diff -Nru src-old/mame/drivers/jpmimpct.c src/mame/drivers/jpmimpct.c
--- src-old/mame/drivers/jpmimpct.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jpmimpct.c	2012-05-03 11:00:08.000000000 +0200
@@ -250,7 +250,7 @@
 		}
 		case 0xd:
 		{
-			val = input_port_read(machine(), "TEST/DEMO");
+			val = ioport("TEST/DEMO")->read();
 			break;
 		}
 		case 0xe:
@@ -366,11 +366,11 @@
 		{
 			if (m_touch_cnt == 0)
 			{
-				if ( input_port_read(machine(), "TOUCH") & 0x1 )
+				if ( ioport("TOUCH")->read() & 0x1 )
 				{
 					m_touch_data[0] = 0x2a;
-					m_touch_data[1] = 0x7 - (input_port_read(machine(), "TOUCH_Y") >> 5) + 0x30;
-					m_touch_data[2] = (input_port_read(machine(), "TOUCH_X") >> 5) + 0x30;
+					m_touch_data[1] = 0x7 - (ioport("TOUCH_Y")->read() >> 5) + 0x30;
+					m_touch_data[2] = (ioport("TOUCH_X")->read() >> 5) + 0x30;
 
 					/* Return RXRDY */
 					return 0x1;
@@ -434,22 +434,22 @@
 	{
 		case 0:
 		{
-			val = input_port_read(machine(), "DSW");
+			val = ioport("DSW")->read();
 			break;
 		}
 		case 2:
 		{
-			val = input_port_read(machine(), "SW2");
+			val = ioport("SW2")->read();
 			break;
 		}
 		case 4:
 		{
-			val = input_port_read(machine(), "SW1");
+			val = ioport("SW1")->read();
 			break;
 		}
 		case 9:
 		{
-			val = input_port_read(machine(), "COINS");
+			val = ioport("COINS")->read();
 			break;
 		}
 	}
@@ -1038,47 +1038,47 @@
 		{
 			case 0:
 			{
-				val = input_port_read(machine(), "DSW");
+				val = ioport("DSW")->read();
 				break;
 			}
 			case 1:
 			{
-				val = input_port_read(machine(), "PERCENT");
+				val = ioport("PERCENT")->read();
 				break;
 			}
 			case 2:
 			{
-				val = input_port_read(machine(), "KEYS");
+				val = ioport("KEYS")->read();
 				break;
 			}
 			case 3:
 			{
-				val = input_port_read(machine(), "SW2");
+				val = ioport("SW2")->read();
 				break;
 			}
 			case 4:
 			{
-				val = input_port_read(machine(), "SW1");
+				val = ioport("SW1")->read();
 				break;
 			}
 			case 5:
 			{
-				val = (input_port_read(machine(), "SW3") );
+				val = (ioport("SW3")->read() );
 				break;
 			}
 			case 6:
 			{
-				val = (input_port_read(machine(), "SW4") );
+				val = (ioport("SW4")->read() );
 				break;
 			}
 			case 7://5
 			{
-				val = (input_port_read(machine(), "SW5") );
+				val = (ioport("SW5")->read() );
 				break;
 			}
 			case 9:
 			{
-				val = input_port_read(machine(), "COINS");
+				val = ioport("COINS")->read();
 				break;
 			}
 		}
diff -Nru src-old/mame/drivers/jpmsys5.c src/mame/drivers/jpmsys5.c
--- src-old/mame/drivers/jpmsys5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/jpmsys5.c	2012-05-03 11:00:08.000000000 +0200
@@ -257,7 +257,7 @@
 READ16_MEMBER(jpmsys5_state::coins_r)
 {
 	if (offset == 2)
-		return input_port_read(machine(), "COINS") << 8;
+		return ioport("COINS")->read() << 8;
 	else
 		return 0xffff;
 }
@@ -280,7 +280,7 @@
 READ16_MEMBER(jpmsys5_state::mux_r)
 {
 	if (offset == 0x81/2)
-		return input_port_read(machine(), "DSW");
+		return ioport("DSW")->read();
 
 	return 0xffff;
 }
@@ -410,8 +410,8 @@
 
 		/* Each touch screen packet is 3 bytes */
 		m_touch_data[0] = 0x2a;
-		m_touch_data[1] = 0x7 - (input_port_read(machine(), "TOUCH_Y") >> 5) + 0x30;
-		m_touch_data[2] = (input_port_read(machine(), "TOUCH_X") >> 5) + 0x30;
+		m_touch_data[1] = 0x7 - (ioport("TOUCH_Y")->read() >> 5) + 0x30;
+		m_touch_data[2] = (ioport("TOUCH_X")->read() >> 5) + 0x30;
 
 		/* Start sending the data to the 68000 serially */
 		m_touch_data_count = 0;
diff -Nru src-old/mame/drivers/kaneko16.c src/mame/drivers/kaneko16.c
--- src-old/mame/drivers/kaneko16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/kaneko16.c	2012-05-03 11:00:08.000000000 +0200
@@ -343,7 +343,7 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 
 	if (ACCESSING_BITS_8_15)
@@ -612,12 +612,12 @@
 READ16_MEMBER(kaneko16_state::gtmr_wheel_r)
 {
 	// check 'Controls' dip switch
-	switch (input_port_read(machine(), "DSW1") & 0x1000)
+	switch (ioport("DSW1")->read() & 0x1000)
 	{
 		case 0x0000:	// 'Both Sides' = 270deg Wheel
-			return	(input_port_read(machine(), "WHEEL0"));
+			return	(ioport("WHEEL0")->read());
 		case 0x1000:	// '1P Side' = 360' Wheel
-			return	(input_port_read(machine(), "WHEEL1"));
+			return	(ioport("WHEEL1")->read());
 		default:
 			return	(0);
 	}
@@ -700,14 +700,14 @@
 
 READ16_MEMBER(kaneko16_state::gtmr2_wheel_r)
 {
-	switch (input_port_read(machine(), "DSW1") & 0x1800)
+	switch (ioport("DSW1")->read() & 0x1800)
 	{
 		case 0x0000:	// 270' A. Wheel
-			return	(input_port_read(machine(), "WHEEL0"));
+			return	(ioport("WHEEL0")->read());
 		case 0x1000:	// 270' D. Wheel
-			return	(input_port_read(machine(), "WHEEL1") << 8);
+			return	(ioport("WHEEL1")->read() << 8);
 		case 0x0800:	// 360' Wheel
-			return	(input_port_read(machine(), "WHEEL2") << 8);
+			return	(ioport("WHEEL2")->read() << 8);
 		default:
 			logerror("gtmr2_wheel_r : read at %06x with joystick\n", cpu_get_pc(&space.device()));
 			return	(~0);
@@ -716,7 +716,7 @@
 
 READ16_MEMBER(kaneko16_state::gtmr2_IN1_r)
 {
-	return	(input_port_read(machine(), "P2") & (input_port_read(machine(), "FAKE") | ~0x7100));
+	return  (ioport("P2")->read() & (ioport("FAKE")->read() | ~0x7100));
 }
 
 static ADDRESS_MAP_START( gtmr2_map, AS_PROGRAM, 16, kaneko16_state )
@@ -1362,10 +1362,10 @@
 	PORT_DIPSETTING(      0x0800, DEF_STR( Joystick ) )
 	PORT_DIPSETTING(      0x0000, "Wheel" )
 	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Controls ) ) PORT_DIPLOCATION("SW1:5")
-	PORT_DIPSETTING(      0x1000, "1P Side" )			PORT_CONDITION("DSW1",0x0800,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, "Both Sides" )		PORT_CONDITION("DSW1",0x0800,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x1000, "360 degree wheel" )	PORT_CONDITION("DSW1",0x0800,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, "270 degree wheel" )	PORT_CONDITION("DSW1",0x0800,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(      0x1000, "1P Side" )			PORT_CONDITION("DSW1",0x0800,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, "Both Sides" )		PORT_CONDITION("DSW1",0x0800,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x1000, "360 degree wheel" )	PORT_CONDITION("DSW1",0x0800,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, "270 degree wheel" )	PORT_CONDITION("DSW1",0x0800,EQUALS,0x00)
 	PORT_DIPNAME( 0x2000, 0x2000, "Use Brake" ) PORT_DIPLOCATION("SW1:6") /* Valid only when joystick is used */
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x2000, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/karnov.c src/mame/drivers/karnov.c
--- src-old/mame/drivers/karnov.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/karnov.c	2012-05-03 11:00:08.000000000 +0200
@@ -407,11 +407,11 @@
 	switch (offset << 1)
 	{
 		case 0:
-			return input_port_read(machine(), "P1_P2");
+			return ioport("P1_P2")->read();
 		case 2: /* Start buttons & VBL */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 4:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 6: /* i8751 return values */
 			return m_i8751_return;
 	}
@@ -481,7 +481,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -728,7 +728,7 @@
 static INTERRUPT_GEN( karnov_interrupt )
 {
 	karnov_state *state = device->machine().driver_data<karnov_state>();
-	UINT8 port = input_port_read(device->machine(), "FAKE");
+	UINT8 port = state->ioport("FAKE")->read();
 
 	/* Coin input to the i8751 generates an interrupt to the main cpu */
 	if (port == state->m_coin_mask)
diff -Nru src-old/mame/drivers/kas89.c src/mame/drivers/kas89.c
--- src-old/mame/drivers/kas89.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/kas89.c	2012-05-03 11:00:08.000000000 +0200
@@ -290,19 +290,19 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(), "PL1");
-		case 0x02: return input_port_read(machine(), "PL2");
-		case 0x04: return input_port_read(machine(), "PL3");
-		case 0x08: return input_port_read(machine(), "PL4");
-		case 0x10: return input_port_read(machine(), "PL5");
-		case 0x20: return input_port_read(machine(), "PL6");
+		case 0x01: return ioport("PL1")->read();
+		case 0x02: return ioport("PL2")->read();
+		case 0x04: return ioport("PL3")->read();
+		case 0x08: return ioport("PL4")->read();
+		case 0x10: return ioport("PL5")->read();
+		case 0x20: return ioport("PL6")->read();
 		case 0x40:
 		{
-			output_set_lamp_value(37, 1 - ((input_port_read(machine(), "SVC") >> 5) & 1));	/* Operator Key LAMP */
-			return input_port_read(machine(), "SVC");
+			output_set_lamp_value(37, 1 - ((ioport("SVC")->read() >> 5) & 1));	/* Operator Key LAMP */
+			return ioport("SVC")->read();
 		}
-		case 0x80: return input_port_read(machine(), "DSW");	/* Polled at $162a through NMI routine */
-		case 0x3f: return input_port_read(machine(), "UNK");
+		case 0x80: return ioport("DSW")->read();	/* Polled at $162a through NMI routine */
+		case 0x3f: return ioport("UNK")->read();
 	}
 
 	logerror("Mux_data %02X\n", m_mux_data);
diff -Nru src-old/mame/drivers/kingdrby.c src/mame/drivers/kingdrby.c
--- src-old/mame/drivers/kingdrby.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/kingdrby.c	2012-05-03 11:00:08.000000000 +0200
@@ -267,7 +267,7 @@
 static READ8_DEVICE_HANDLER( hopper_io_r )
 {
 	kingdrby_state *state = device->machine().driver_data<kingdrby_state>();
-	return (input_port_read(device->machine(),"HPIO") & 0x3f) | state->m_p1_hopper | state->m_p2_hopper;
+	return (state->ioport("HPIO")->read() & 0x3f) | state->m_p1_hopper | state->m_p2_hopper;
 }
 
 static WRITE8_DEVICE_HANDLER( hopper_io_w )
@@ -300,9 +300,9 @@
 {
 	kingdrby_state *state = device->machine().driver_data<kingdrby_state>();
 	if(state->m_mux_data & 0x80)
-		return input_port_read(device->machine(),"MUX0");
+		return state->ioport("MUX0")->read();
 	else
-		return input_port_read(device->machine(),"MUX1");
+		return state->ioport("MUX1")->read();
 }
 
 static READ8_DEVICE_HANDLER( key_matrix_r )
@@ -310,8 +310,8 @@
 	UINT16 p1_val,p2_val;
 	UINT8 p1_res,p2_res;
 
-	p1_val = input_port_read(device->machine(),"KEY_1P");
-	p2_val = input_port_read(device->machine(),"KEY_2P");
+	p1_val = device->machine().root_device().ioport("KEY_1P")->read();
+	p2_val = device->machine().root_device().ioport("KEY_2P")->read();
 
 	p1_res = 0;
 	p2_res = 0;
@@ -556,7 +556,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SPECIAL ) //2p hopper i/o
 
 	PORT_START("IN1")	// ppi0 (5001)
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK ) //?
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") //?
 	PORT_DIPNAME( 0x02, 0x02, "IN1" )
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -739,7 +739,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("IN1")	// ppi0 (5001)
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK ) //?
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") //?
 	PORT_DIPNAME( 0x02, 0x02, "IN1" )
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/kingobox.c src/mame/drivers/kingobox.c
--- src-old/mame/drivers/kingobox.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/kingobox.c	2012-05-03 11:00:08.000000000 +0200
@@ -301,7 +301,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* Sound busy??? */
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
 
diff -Nru src-old/mame/drivers/kinst.c src/mame/drivers/kinst.c
--- src-old/mame/drivers/kinst.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/kinst.c	2012-05-03 11:00:08.000000000 +0200
@@ -338,7 +338,7 @@
 	switch (offset)
 	{
 		case 2:		/* $90 -- sound return */
-			result = input_port_read(machine(), portnames[offset]);
+			result = ioport(portnames[offset])->read();
 			result &= ~0x0002;
 			if (dcs_control_r(machine()) & 0x800)
 				result |= 0x0002;
@@ -347,11 +347,11 @@
 		case 0:		/* $80 */
 		case 1:		/* $88 */
 		case 3:		/* $98 */
-			result = input_port_read(machine(), portnames[offset]);
+			result = ioport(portnames[offset])->read();
 			break;
 
 		case 4:		/* $a0 */
-			result = input_port_read(machine(), portnames[offset]);
+			result = ioport(portnames[offset])->read();
 			if (cpu_get_pc(&space.device()) == 0x802d428)
 				device_spin_until_interrupt(&space.device());
 			break;
diff -Nru src-old/mame/drivers/klax.c src/mame/drivers/klax.c
--- src-old/mame/drivers/klax.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/klax.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 static void scanline_update(screen_device &screen, int scanline)
 {
 	/* generate 32V signals */
-	if ((scanline & 32) == 0 && !(input_port_read(screen.machine(), "P1") & 0x800))
+	if ((scanline & 32) == 0 && !(screen.machine().root_device().ioport("P1")->read() & 0x800))
 		atarigen_scanline_int_gen(screen.machine().device("maincpu"));
 }
 
@@ -115,7 +115,7 @@
 	PORT_BIT( 0x00fc, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0600, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1)
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1)
diff -Nru src-old/mame/drivers/koikoi.c src/mame/drivers/koikoi.c
--- src-old/mame/drivers/koikoi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/koikoi.c	2012-05-03 11:00:08.000000000 +0200
@@ -165,7 +165,7 @@
 
 	if (!state->m_inputcnt)
 	{
-		int key = input_port_read(device->machine(), "IN1");
+		int key = state->ioport("IN1")->read();
 		int keyval = 0; //we must return 0 (0x2 in 2nd read) to clear 4 bit at $6600 and allow next read
 
 		if (key)
@@ -202,7 +202,7 @@
 READ8_MEMBER(koikoi_state::io_r)
 {
 	if (!offset)
-		return input_port_read(machine(), "IN0") ^ m_ioram[4]; //coin
+		return ioport("IN0")->read() ^ m_ioram[4]; //coin
 
 	return 0;
 }
diff -Nru src-old/mame/drivers/konamigq.c src/mame/drivers/konamigq.c
--- src-old/mame/drivers/konamigq.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/konamigq.c	2012-05-03 11:00:08.000000000 +0200
@@ -144,7 +144,7 @@
 
 WRITE32_MEMBER(konamigq_state::eeprom_w)
 {
-	input_port_write(machine(), "EEPROMOUT", data & 0x07, 0xff);
+	ioport("EEPROMOUT")->write(data & 0x07, 0xff);
 	cputag_set_input_line(machine(), "soundcpu", INPUT_LINE_RESET, ( data & 0x40 ) ? CLEAR_LINE : ASSERT_LINE );
 }
 
diff -Nru src-old/mame/drivers/konamigv.c src/mame/drivers/konamigv.c
--- src-old/mame/drivers/konamigv.c	2012-04-10 16:06:51.000000000 +0200
+++ src/mame/drivers/konamigv.c	2012-05-03 11:00:08.000000000 +0200
@@ -503,7 +503,7 @@
 
 		for( axis = 0; axis < 2; axis++ )
 		{
-			value = input_port_read(machine(), axisnames[axis]);
+			value = ioport(axisnames[axis])->read();
 			diff = value - m_trackball_prev[ axis ];
 			m_trackball_prev[ axis ] = value;
 			m_trackball_data[ axis ] = ( ( diff & 0xf00 ) << 16 ) | ( ( diff & 0xff ) << 8 );
@@ -595,7 +595,7 @@
 
 		for( axis = 0; axis < 4; axis++ )
 		{
-			value = input_port_read(machine(), axisnames[axis]);
+			value = ioport(axisnames[axis])->read();
 			diff = value - m_btc_trackball_prev[ axis ];
 			m_btc_trackball_prev[ axis ] = value;
 			m_btc_trackball_data[ axis ] = ( ( diff & 0xf00 ) << 16 ) | ( ( diff & 0xff ) << 8 );
diff -Nru src-old/mame/drivers/konamigx.c src/mame/drivers/konamigx.c
--- src-old/mame/drivers/konamigx.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/konamigx.c	2012-05-03 11:00:08.000000000 +0200
@@ -463,7 +463,7 @@
           bit 0: eeprom data
         */
 
-		input_port_write(machine(), "EEPROMOUT", odata, 0xff);
+		ioport("EEPROMOUT")->write(odata, 0xff);
 
 		konamigx_wrport1_0 = odata;
 	}
@@ -874,9 +874,9 @@
 	switch (input)
 	{
 	case ADC083X_CH0:
-		return (double)(5 * input_port_read(device->machine(), "AN0")) / 255.0; // steer
+		return (double)(5 * device->machine().root_device().ioport("AN0")->read()) / 255.0; // steer
 	case ADC083X_CH1:
-		return (double)(5 * input_port_read(device->machine(), "AN1")) / 255.0; // gas
+		return (double)(5 * device->machine().root_device().ioport("AN1")->read()) / 255.0; // gas
 	case ADC083X_VREF:
 		return 5;
 	}
@@ -890,16 +890,16 @@
 
 READ32_MEMBER(konamigx_state::le2_gun_H_r)
 {
-	int p1x = input_port_read(machine(), "LIGHT0_X")*290/0xff+20;
-	int p2x = input_port_read(machine(), "LIGHT1_X")*290/0xff+20;
+	int p1x = ioport("LIGHT0_X")->read()*290/0xff+20;
+	int p2x = ioport("LIGHT1_X")->read()*290/0xff+20;
 
 	return (p1x<<16)|p2x;
 }
 
 READ32_MEMBER(konamigx_state::le2_gun_V_r)
 {
-	int p1y = input_port_read(machine(), "LIGHT0_Y")*224/0xff;
-	int p2y = input_port_read(machine(), "LIGHT1_Y")*224/0xff;
+	int p1y = ioport("LIGHT0_Y")->read()*224/0xff;
+	int p2y = ioport("LIGHT1_Y")->read()*224/0xff;
 
 	// make "off the bottom" reload too
 	if (p1y >= 0xdf) p1y = 0;
diff -Nru src-old/mame/drivers/konamim2.c src/mame/drivers/konamim2.c
--- src-old/mame/drivers/konamim2.c	2012-04-12 08:01:56.000000000 +0200
+++ src/mame/drivers/konamim2.c	2012-04-25 05:09:41.000000000 +0200
@@ -1208,7 +1208,7 @@
 	ROM_LOAD16_WORD( "636a01.8q", 0x000000, 0x200000, CRC(7b1dc738) SHA1(32ae8e7ddd38fcc70b4410275a2cc5e9a0d7d33b) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "btltryst", 0, SHA1(c76326b0a0fcfe696a2ca019170d3abde40e773e) )
+	DISK_IMAGE( "btltryst", 0, BAD_DUMP SHA1(c76326b0a0fcfe696a2ca019170d3abde40e773e) )
 ROM_END
 
 ROM_START( heatof11 )
@@ -1219,7 +1219,7 @@
 	ROM_LOAD( "dallas.5e",  0x000000, 0x002000, CRC(8611ff09) SHA1(6410236947d99c552c4a1f7dd5fd8c7a5ae4cba1) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "heatof11", 0, SHA1(5a0a2782cd8676d3f6dfad4e0f805b309e230d8b) )
+	DISK_IMAGE( "heatof11", 0, BAD_DUMP SHA1(5a0a2782cd8676d3f6dfad4e0f805b309e230d8b) )
 ROM_END
 
 ROM_START( evilngt )
@@ -1236,7 +1236,7 @@
 	ROM_LOAD( "93c46.7k",    0x000000, 0x000080, CRC(d7ba2e5e) SHA1(d729557555c6fc1cd433b14017952cc63ec73573) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "810uba02", 0, SHA1(ca3b957e3e33435391fbf630f9ed89aa08a70c8f) )
+	DISK_IMAGE( "810uba02", 0, BAD_DUMP SHA1(ca3b957e3e33435391fbf630f9ed89aa08a70c8f) )
 ROM_END
 
 ROM_START( evilngte )
@@ -1274,7 +1274,7 @@
 	ROM_LOAD( "639jaa02.bin",  0x000000, 0x100000, CRC(c6163818) SHA1(b6f8f2d808b98610becc0a5be5443ece3908df0b) )
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "639uac01", 0, SHA1(88431b8a0ce83c156c8b19efbba1af901b859404) )
+	DISK_IMAGE( "639uac01", 0, BAD_DUMP SHA1(88431b8a0ce83c156c8b19efbba1af901b859404) )
 ROM_END
 
 ROM_START( totlvicj )
diff -Nru src-old/mame/drivers/kongambl.c src/mame/drivers/kongambl.c
--- src-old/mame/drivers/kongambl.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/drivers/kongambl.c	2012-05-03 11:00:08.000000000 +0200
@@ -59,7 +59,7 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		UINT32 rv = input_port_read(machine(), "SYSTEM") & ~0x1;
+		UINT32 rv = ioport("SYSTEM")->read() & ~0x1;
 
 		return rv;	// bit 0 freezes the game if 1
 	}
@@ -71,7 +71,7 @@
 {
 	if (ACCESSING_BITS_8_15)
 	{
-		input_port_write(machine(), "EEPROMOUT", (data>>8)&0xf, 0xff);
+		ioport("EEPROMOUT")->write((data>>8)&0xf, 0xff);
 	}
 }
 
diff -Nru src-old/mame/drivers/kopunch.c src/mame/drivers/kopunch.c
--- src-old/mame/drivers/kopunch.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/kopunch.c	2012-05-03 11:00:08.000000000 +0200
@@ -20,7 +20,7 @@
 	if (offset == 0)
 		return machine().rand();
 	else
-		return (machine().rand() & 0x07) | input_port_read(machine(), "SYSTEM");
+		return (machine().rand() & 0x07) | ioport("SYSTEM")->read();
 }
 
 WRITE8_MEMBER(kopunch_state::kopunch_lamp_w)
diff -Nru src-old/mame/drivers/ksys573.c src/mame/drivers/ksys573.c
--- src-old/mame/drivers/ksys573.c	2012-04-10 16:06:51.000000000 +0200
+++ src/mame/drivers/ksys573.c	2012-05-07 08:57:50.000000000 +0200
@@ -349,6 +349,79 @@
   HYC24855    - ?
   RCA-L/R     - RCA connectors for left/right audio output
 
+  Drummania 10th Mix Multisession
+  -------------------------------
+
+  This box is used with multi-session System 573 games.
+
+  Main board is standard GX700 PCB with CDROM (Drummania 10th Mix Multisession)
+  and Digital I/O Board GX894-PWB(B)A
+  BIOS is on a small plug-in daughterboard.
+  Daughterboard contains one EPROM, one PAL22V10, 2 logic chips and a PIC16F84.
+  The dumps provided are the EPROM dumped separately and a dump of the 'board'
+  with it plugged in (reading may be affected by the PIC)
+
+
+  PCB Layout of External Multisession Box
+  ---------------------------------------
+
+  GXA25-PWB(A)(C)2000 KONAMI
+  |--------------------------------------------------------------------------|
+  |CN9  ADM232  LS273        PC16552          PC16552         XC9536(1)  CN13|
+  |DSW(8)  LS245   LS273            18.432MHz                        DS2401  |
+  |         |-------|      |-------|       |-------|      |-------|          |
+  | MB3793  |TOSHIBA|      |TOSHIBA|       |TOSHIBA|      |TOSHIBA|M48T58Y.6T|
+  |         |TC9446F|      |TC9446F|       |TC9446F|      |TC9446F|          |
+  |         |-016   |      |-016   |       |-016   |      |-016   |      CN12|
+  |         |-------|      |-------|       |-------|      |-------|          |
+  |       LV14                    XC9572XL                                   |
+  | CN16                 CN17                 CN18             CN19 XC9536(2)|
+  |PQ30RV21        LCX245   LCX245                                       CN11|
+  |                                  33.8688MHz              PQ30RV21        |
+  |    8.25MHz   HY57V641620                                                 |
+  |  |------------|     HY57V641620   XC2S200                                |
+  |  |TOSHIBA     |                                          FLASH.20T       |
+  |  |TMPR3927AF  |                                                      CN10|
+  |  |            |                                                          |
+  |  |            |                                     LS245   F245  F245   |
+  |  |            |HY57V641620  LCX245     DIP40                             |
+  |  |------------|     HY57V641620  LCX245                   ATAPI44        |
+  |                             LCX245              LED(HDD)  ATAPI40        |
+  |    CN7                      LCX245      CN14    LED(CD)           CN5    |
+  |--------------------------------------------------------------------------|
+  Notes: (all IC's shown)
+          TMPR3927     - Toshiba TMPR3927AF Risc Microprocessor (QFP240)
+          FLASH.20T    - Fujitsu 29F400TC Flash ROM (TSOP48)
+          ATAPI44      - IDE44 44-pin laptop type HDD connector (not used)
+          ATAPI40      - IDE40 40-pin flat cable HDD connector used for connection of CDROM drive
+          XC9572XL     - XILINX XC9572XL In-system Programmable CPLD stamped 'XA25A1' (TQFP100)
+          XC9536(1)    - XILINX CPLD stamped 'XA25A3' (PLCC44)
+          XC9536(2)    - XILINX CPLD stamped 'XA25A2' (PLCC44)
+          XC2S200      - XILINX XC2S200 SPARTAN FPGA (QFP208)
+          DS2401       - MAXIM Dallas DS2401 Silicon Serial Number (SOIC6)
+          M48T58Y      - ST M48T58Y Timekeeper NVRAM 8k bytes x8-bit (DIP28). Chip appears empty (0x04 fill) or unused
+          MB3793       - Fujitsu MB3793 Power-Voltage Monitoring IC with Watchdog Timer (SOIC8)
+          DIP40        - Empty DIP40 socket
+          HY57V641620  - Hyundai/Hynix HY57V641620 4 Banks x 1M x 16Bit Synchronous DRAM
+          PC16552D     - National PC16552D Dual Universal Asynchronous Receiver/Transmitter with FIFO's
+          TC9446F      - Toshiba TC9446F-016 Audio Digital Processor for Decode of Dolby Digital (AC-3) MPEG2 Audio
+          CN16-CN19    - Connector for sub board (3 of them are present). One board connects via a thin cable from
+                         CN1 to the main board to a connector on the security board labelled 'AMP BOX'.
+
+  Sub Board Layout
+  ----------------
+
+  GXA25-PWB(B) (C) 2000 KONAMI
+  |---------------------------------|
+  | TLP2630  LV14          ADM232   |
+  |CN2                           CN1|
+  |A2430         AK5330             |
+  |                                 |
+  |                          RCA L/R|
+  |ZUS1R50505        6379A          |
+  |                          LM358  |
+  |---------------------------------|
+
   */
 
 #include "emu.h"
@@ -524,7 +597,7 @@
 READ32_MEMBER(ksys573_state::jamma_r)
 {
 	int security_cart_number = m_security_cart_number;
-	UINT32 data = input_port_read(machine(), "IN1");
+	UINT32 data = ioport("IN1")->read();
 	data |= 0x000000c0;
 
 	ds2401_device *ds2401 = machine().device<ds2401_device>(security_cart_number ? "game_id" : "install_id");
@@ -1160,7 +1233,7 @@
 		}
 	}
 
-	input_port_write_safe( machine(), "OUT1", data, mem_mask );
+	machine().root_device().ioport("OUT1")->write_safe( data, mem_mask );
 }
 
 READ32_MEMBER(ksys573_state::security_r)
@@ -1293,8 +1366,8 @@
 static void update_mode( running_machine &machine )
 {
 	ksys573_state *state = machine.driver_data<ksys573_state>();
-	int cart = input_port_read(machine, "CART");
-	int cd = input_port_read( machine, "CD" );
+	int cart = state->ioport("CART")->read();
+	int cd = state->ioport( "CD" )->read();
 	SCSIInstance *new_cdrom;
 
 	if( state->machine().device<device_secure_serial_flash>("game_eeprom") )
@@ -1416,8 +1489,8 @@
 	switch (offset)
 	{
 	case 0x26:
-		upd4701_y_add(upd4701, 0, input_port_read_safe(machine(), "uPD4701_y", 0), 0xffff);
-		upd4701_switches_set(upd4701, 0, input_port_read_safe(machine(), "uPD4701_switches", 0));
+		upd4701_y_add(upd4701, 0, ioport("uPD4701_y")->read_safe(0), 0xffff);
+		upd4701_switches_set(upd4701, 0, ioport("uPD4701_switches")->read_safe(0));
 
 		upd4701_cs_w(upd4701, 0, 0);
 		upd4701_xy_w(upd4701, 0, 1);
@@ -1685,7 +1758,7 @@
 CUSTOM_INPUT_MEMBER(ksys573_state::gn845pwbb_read)
 {
 
-	return input_port_read(machine(), "STAGE") & m_stage_mask;
+	return ioport("STAGE")->read() & m_stage_mask;
 }
 
 static void gn845pwbb_output_callback( running_machine &machine, int offset, int data )
@@ -2644,7 +2717,7 @@
 {
 	ksys573_state *state = device->machine().driver_data<ksys573_state>();
 	double *pad_position = state->m_pad_position;
-	int pads = input_port_read(device->machine(), "PADS");
+	int pads = state->ioport("PADS")->read();
 	for( int i = 0; i < 6; i++ )
 	{
 		if( ( pads & ( 1 << i ) ) != 0 )
@@ -2931,15 +3004,15 @@
 	switch( offset )
 	{
 	case 0x20:
-		data = input_port_read( machine(), "GUNX" ) | ds2401->read() << 7;
+		data = ioport( "GUNX" )->read() | ds2401->read() << 7;
 		break;
 
 	case 0x22:
-		data = input_port_read( machine(), "GUNY" ) | input_port_read( machine(), "SENSOR" );
+		data = ioport( "SENSOR" )->read();
 		break;
 
 	case 0x34:
-		data = input_port_read( machine(), "ENCODER" );
+		data = ioport( "ENCODER" )->read();
 		popmessage( "encoder %04x", data );
 		break;
 	}
@@ -2962,13 +3035,13 @@
 	switch (input)
 	{
 	case ADC083X_CH0:
-		return (double)( 5 * input_port_read_safe( device->machine(), "analog0", 0 ) ) / 255.0;
+		return (double)( 5 * device->machine().root_device().ioport( "analog0" )->read_safe( 0 ) ) / 255.0;
 	case ADC083X_CH1:
-		return (double)( 5 * input_port_read_safe( device->machine(), "analog1", 0 ) ) / 255.0;
+		return (double)( 5 * device->machine().root_device().ioport( "analog1" )->read_safe( 0 ) ) / 255.0;
 	case ADC083X_CH2:
-		return (double)( 5 * input_port_read_safe( device->machine(), "analog2", 0 ) ) / 255.0;
+		return (double)( 5 * device->machine().root_device().ioport( "analog2" )->read_safe( 0 ) ) / 255.0;
 	case ADC083X_CH3:
-		return (double)( 5 * input_port_read_safe( device->machine(), "analog3", 0 ) ) / 255.0;
+		return (double)( 5 * device->machine().root_device().ioport( "analog3" )->read_safe( 0 ) ) / 255.0;
 	case ADC083X_AGND:
 		return 0;
 	case ADC083X_VREF:
@@ -3634,7 +3707,7 @@
 	ROM_LOAD( "ge765ja.u1", 0x000000, 0x000224, BAD_DUMP CRC(ee1b32a7) SHA1(c0f6b14b054f5a95ce474e794a3e0ca78faac681) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "765jaa02", 0, SHA1(4291711b1025733cb97f6da5dc3b03c189fcc37c) )
+	DISK_IMAGE_READONLY( "765jaa02", 0, BAD_DUMP SHA1(4291711b1025733cb97f6da5dc3b03c189fcc37c) )
 ROM_END
 
 ROM_START( bassang2 )
@@ -3644,21 +3717,21 @@
 	ROM_LOAD( "gc865ja.u1", 0x000000, 0x000224, BAD_DUMP CRC(095cbfb5) SHA1(529ce0a7b0986cf7e64c37f466d6c2dac95cea7f) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "865jaa02", 0, SHA1(b98d9aa54f13aa73bea580d6494cb6a7f3217be3) )
+	DISK_IMAGE_READONLY( "865jaa02", 0, BAD_DUMP SHA1(b98d9aa54f13aa73bea580d6494cb6a7f3217be3) )
 ROM_END
 
 ROM_START( cr589fw )
 	SYS573_BIOS_A
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "700b04", 0, SHA1(2f65f62eb7ae202153a8544989675989ed33316f) )
+	DISK_IMAGE_READONLY( "700b04", 0, BAD_DUMP SHA1(2f65f62eb7ae202153a8544989675989ed33316f) )
 ROM_END
 
 ROM_START( cr589fwa )
 	SYS573_BIOS_A
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "700a04", 0, SHA1(554481f48eeb5daf8b4e7be2d66840d6c8454a52) )
+	DISK_IMAGE_READONLY( "700a04", 0, BAD_DUMP SHA1(554481f48eeb5daf8b4e7be2d66840d6c8454a52) )
 ROM_END
 
 ROM_START( darkhleg )
@@ -3668,7 +3741,7 @@
 	ROM_LOAD( "gx706ja.u1", 0x000000, 0x000224, BAD_DUMP CRC(72b42574) SHA1(79dc959f0ce95ccb9ac0dbf0a72aec973e91bc56) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "706jaa02", 0, SHA1(58bd06855988250028086cba6b3670372b9d96a0) )
+	DISK_IMAGE_READONLY( "706jaa02", 0, BAD_DUMP SHA1(58bd06855988250028086cba6b3670372b9d96a0) )
 ROM_END
 
 ROM_START( ddrextrm )
@@ -3682,7 +3755,7 @@
 	ROM_LOAD( "gcc36ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c36jaa02", 0, SHA1(edeb45fff0e66151b1ba2fd67542064ccddb031e) )
+	DISK_IMAGE_READONLY( "c36jaa02", 0, BAD_DUMP SHA1(edeb45fff0e66151b1ba2fd67542064ccddb031e) )
 ROM_END
 
 ROM_START( ddru )
@@ -3702,7 +3775,7 @@
 	ROM_LOAD( "gc845jb.u1",   0x000000, 0x000224, BAD_DUMP CRC(a16f42b8) SHA1(da4f1eb3eb2b28cb3a0bc74bb9b9945970f56ac2) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "845jba02", 0, SHA1(2d10378c89fe85682f262f0987f8366b9ea72f11) )
+	DISK_IMAGE_READONLY( "845jba02", 0, BAD_DUMP SHA1(2d10378c89fe85682f262f0987f8366b9ea72f11) )
 ROM_END
 
 ROM_START( ddrja )
@@ -3729,7 +3802,7 @@
 	ROM_LOAD( "gc845jaa.27h",  0x000000, 0x200000, NO_DUMP )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "845jaa02", 0, SHA1(37ca16be25bee39a5692dee2fa5f0fa0addfaaca) )
+	DISK_IMAGE_READONLY( "845jaa02", 0, BAD_DUMP SHA1(37ca16be25bee39a5692dee2fa5f0fa0addfaaca) )
 
 	DISK_REGION( "cdrom1" )
 	DISK_IMAGE_READONLY( "845jaa01", 1, NO_DUMP ) // if this even exists
@@ -3759,7 +3832,7 @@
 	ROM_LOAD( "gc845jab.27h",  0x000000, 0x200000, NO_DUMP )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "845jab02", 0, SHA1(7bdcef37bf376c23153dfd1580de5666cc681335) )
+	DISK_IMAGE_READONLY( "845jab02", 0, BAD_DUMP SHA1(7bdcef37bf376c23153dfd1580de5666cc681335) )
 
 	DISK_REGION( "cdrom1" )
 	DISK_IMAGE_READONLY( "845jab01", 1, NO_DUMP ) // if this even exists
@@ -3772,7 +3845,7 @@
 	ROM_LOAD( "gn845aa.u1",   0x000000, 0x000224, BAD_DUMP CRC(327c4851) SHA1(f0939224af706fd103a67aae9c96518c1db90ac9) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "845aaa02", 0, SHA1(839e2f8698a1561ac364998b8b3158ef0dee6998) )
+	DISK_IMAGE_READONLY( "845aaa02", 0, BAD_DUMP SHA1(839e2f8698a1561ac364998b8b3158ef0dee6998) )
 ROM_END
 
 ROM_START( ddr2m )
@@ -3782,7 +3855,7 @@
 	ROM_LOAD( "gn895jaa.u1",  0x000000, 0x000224, BAD_DUMP CRC(363f427e) SHA1(adec886a07b9bd91f142f286b04fc6582205f037) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "895jaa02", 0, SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
+	DISK_IMAGE_READONLY( "895jaa02", 0, BAD_DUMP SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
 ROM_END
 
 ROM_START( ddr2mc )
@@ -3792,10 +3865,10 @@
 	ROM_LOAD( "gn896ja.u1",  0x000000, 0x000224, BAD_DUMP CRC(cbc984c5) SHA1(6c0cd78a41000999b4ffbd9fb3707738b50a9b50) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "896jaa01", 0, SHA1(f802a0e2ba0147eb71c54d92af409c3010a5715f) )
+	DISK_IMAGE_READONLY( "896jaa01", 0, BAD_DUMP SHA1(f802a0e2ba0147eb71c54d92af409c3010a5715f) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "895jaa02", 1, SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
+	DISK_IMAGE_READONLY( "895jaa02", 1, BAD_DUMP SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
 ROM_END
 
 ROM_START( ddr2mc2 )
@@ -3805,10 +3878,10 @@
 	ROM_LOAD( "ge984ja.u1",  0x000000, 0x000224, BAD_DUMP CRC(cbc984c5) SHA1(6c0cd78a41000999b4ffbd9fb3707738b50a9b50) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "984jaa01", 0, SHA1(5505c28be27bfa9648060fd799bcf0c2c5f608ed) )
+	DISK_IMAGE_READONLY( "984jaa01", 0, BAD_DUMP SHA1(5505c28be27bfa9648060fd799bcf0c2c5f608ed) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "895jaa02", 1, SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
+	DISK_IMAGE_READONLY( "895jaa02", 1, BAD_DUMP SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
 ROM_END
 
 ROM_START( ddr2ml )
@@ -3824,7 +3897,7 @@
 	DISK_IMAGE_READONLY( "885jab01", 0, SHA1(c2bbb9e2e6f34e07f57e7076726af81df39f55c9) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "885jaa02", 0, SHA1(5d187aea247eefc5c065566ab277acd8c942ba27) )
+	DISK_IMAGE_READONLY( "885jaa02", 0, BAD_DUMP SHA1(5d187aea247eefc5c065566ab277acd8c942ba27) )
 ROM_END
 
 ROM_START( ddr2mla )
@@ -3837,7 +3910,7 @@
 	ROM_LOAD( "ge885jaa.u1",  0x000000, 0x000224, BAD_DUMP CRC(cbc984c5) SHA1(6c0cd78a41000999b4ffbd9fb3707738b50a9b50) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "885jaa02", 0, SHA1(5d187aea247eefc5c065566ab277acd8c942ba27) )
+	DISK_IMAGE_READONLY( "885jaa02", 0, BAD_DUMP SHA1(5d187aea247eefc5c065566ab277acd8c942ba27) )
 ROM_END
 
 ROM_START( ddr3ma )
@@ -3857,7 +3930,7 @@
 	ROM_LOAD( "gn887aa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "887aaa02", 0, SHA1(c4136305b97123f5dfe3ecd34a10ddda0180da3d) )
+	DISK_IMAGE_READONLY( "887aaa02", 0, BAD_DUMP SHA1(c4136305b97123f5dfe3ecd34a10ddda0180da3d) )
 ROM_END
 
 ROM_START( ddr3mj )
@@ -3877,7 +3950,7 @@
 	ROM_LOAD( "gn887ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "887jaa02", 0, SHA1(2d1bf2a1566292dc869afaa6486f5ecd3973ff62) )
+	DISK_IMAGE_READONLY( "887jaa02", 0, BAD_DUMP SHA1(2d1bf2a1566292dc869afaa6486f5ecd3973ff62) )
 ROM_END
 
 ROM_START( ddr3mk )
@@ -3897,7 +3970,7 @@
 	ROM_LOAD( "gn887kb.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "887kba02", 0, SHA1(92a3844fab24f46c16dd96f9474d95fd001df603) )
+	DISK_IMAGE_READONLY( "887kba02", 0, BAD_DUMP SHA1(92a3844fab24f46c16dd96f9474d95fd001df603) )
 ROM_END
 
 ROM_START( ddr3mka )
@@ -3917,7 +3990,7 @@
 	ROM_LOAD( "gn887ka.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "887kaa02", 0, SHA1(a80930dd66c2e2326e8792f2e7cf9116d9cd752c) )
+	DISK_IMAGE_READONLY( "887kaa02", 0, BAD_DUMP SHA1(a80930dd66c2e2326e8792f2e7cf9116d9cd752c) )
 ROM_END
 
 ROM_START( ddr3mp )
@@ -3937,7 +4010,7 @@
 	ROM_LOAD( "gca22ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a22jaa02", 0, SHA1(2bf07d08f6acee562024b418b453d654fc40f8dd) )
+	DISK_IMAGE_READONLY( "a22jaa02", 0, BAD_DUMP SHA1(2bf07d08f6acee562024b418b453d654fc40f8dd) )
 ROM_END
 
 ROM_START( ddr4m )
@@ -3977,7 +4050,7 @@
 	ROM_LOAD( "gca33ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a33jaa02", 0, SHA1(9d9fb5e65f1532f358e9c273c56d11389d11fd79) )
+	DISK_IMAGE_READONLY( "a33jaa02", 0, BAD_DUMP SHA1(9d9fb5e65f1532f358e9c273c56d11389d11fd79) )
 ROM_END
 
 ROM_START( ddr4ms )
@@ -3997,7 +4070,7 @@
 	ROM_LOAD( "gca33ab.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a33aba02", 0, SHA1(cc7349cbee37bfb101480497e99f1f52acb4ffa1) )
+	DISK_IMAGE_READONLY( "a33aba02", 0, BAD_DUMP SHA1(cc7349cbee37bfb101480497e99f1f52acb4ffa1) )
 ROM_END
 
 ROM_START( ddr4msj )
@@ -4040,7 +4113,7 @@
 	ROM_LOAD( "gca34ja.22h",  0x000000, 0x002000, CRC(80575c1f) SHA1(a0594ca0f75bc7d49b645e835e9fa48a73c3c9c7) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a34jaa02", 0, SHA1(1d5f9eb633f054ddbf9fba55d53e4ee263ba91dd) )
+	DISK_IMAGE_READONLY( "a34jaa02", 0, BAD_DUMP SHA1(1d5f9eb633f054ddbf9fba55d53e4ee263ba91dd) )
 ROM_END
 
 ROM_START( ddr4mps )
@@ -4077,7 +4150,7 @@
 	ROM_LOAD( "gca27ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a27jaa02", 0, SHA1(0324973c98b82b72b22d2f0cd43e1924b83be667) )
+	DISK_IMAGE_READONLY( "a27jaa02", 0, BAD_DUMP SHA1(0324973c98b82b72b22d2f0cd43e1924b83be667) )
 ROM_END
 
 ROM_START( ddrbocd )
@@ -4087,10 +4160,10 @@
 	ROM_LOAD( "gn895jaa.u1",  0x000000, 0x000224, BAD_DUMP CRC(363f427e) SHA1(adec886a07b9bd91f142f286b04fc6582205f037) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "892jaa01", 0, SHA1(46ace0feef48a2a6643c3cb4ac9164ba0beeea94) )
+	DISK_IMAGE_READONLY( "892jaa01", 0, BAD_DUMP SHA1(46ace0feef48a2a6643c3cb4ac9164ba0beeea94) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "895jaa02", 1, SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
+	DISK_IMAGE_READONLY( "895jaa02", 1, BAD_DUMP SHA1(cfe3a6f3ed62ba388b07045e29e22472d17dcfe4) )
 ROM_END
 
 ROM_START( ddrs2k )
@@ -4110,7 +4183,7 @@
 	ROM_LOAD( "gc905aa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "905aaa02", 0, SHA1(1fc0f3fcc7d5d23711967023ff02c1fc76479024) )
+	DISK_IMAGE_READONLY( "905aaa02", 0, BAD_DUMP SHA1(1fc0f3fcc7d5d23711967023ff02c1fc76479024) )
 ROM_END
 
 ROM_START( ddrs2kj )
@@ -4130,7 +4203,7 @@
 	ROM_LOAD( "gc905aa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "905jaa02", 0, SHA1(84931345611574afd53976a0807f4163348e3c15) )
+	DISK_IMAGE_READONLY( "905jaa02", 0, BAD_DUMP SHA1(84931345611574afd53976a0807f4163348e3c15) )
 ROM_END
 
 ROM_START( ddrmax )
@@ -4144,7 +4217,7 @@
 	ROM_LOAD( "gcb19ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b19jaa02", 0, SHA1(a156ebdef395747c64e1829237e4e7932ae251a8) )
+	DISK_IMAGE_READONLY( "b19jaa02", 0, BAD_DUMP SHA1(a156ebdef395747c64e1829237e4e7932ae251a8) )
 ROM_END
 
 ROM_START( ddrmax2 )
@@ -4158,7 +4231,7 @@
 	ROM_LOAD( "gcb20ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b20jaa02", 0, SHA1(3f378e922e3182f980d07d6b2b524e33c5a00549) )
+	DISK_IMAGE_READONLY( "b20jaa02", 0, BAD_DUMP SHA1(3f378e922e3182f980d07d6b2b524e33c5a00549) )
 ROM_END
 
 ROM_START( ddrsbm )
@@ -4172,7 +4245,7 @@
 	ROM_LOAD( "gq894ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "894jaa02", 0, SHA1(3b2e061996d12f0e7367a579208eb746d849e070) )
+	DISK_IMAGE_READONLY( "894jaa02", 0, BAD_DUMP SHA1(3b2e061996d12f0e7367a579208eb746d849e070) )
 ROM_END
 
 ROM_START( ddrusa )
@@ -4186,7 +4259,7 @@
 	ROM_LOAD( "gka44ua.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a44uaa02", 0, SHA1(2cdbe1c62d16a2be65adb7e11331fce5c8e45504) )
+	DISK_IMAGE_READONLY( "a44uaa02", 0, BAD_DUMP SHA1(2cdbe1c62d16a2be65adb7e11331fce5c8e45504) )
 ROM_END
 
 ROM_START( drmn )
@@ -4204,7 +4277,7 @@
 	ROM_LOAD( "gq881ja.22h",  0x000000, 0x002000, CRC(e834d5ec) SHA1(1c845811e43d7dfec657da288b5a38b8bc9c8366) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "881jad01", 0, SHA1(7d9d47bef636dbaa8d578f34ea9489e349d3d6df) ) // upgrade or bootleg?
+	DISK_IMAGE_READONLY( "881jad01", 0, BAD_DUMP SHA1(7d9d47bef636dbaa8d578f34ea9489e349d3d6df) ) // upgrade or bootleg?
 
 	DISK_REGION( "cdrom1" )
 	DISK_IMAGE_READONLY( "881jaa02", 1, NO_DUMP )
@@ -4227,7 +4300,7 @@
 	ROM_LOAD( "gn912ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "912jab02", 0, SHA1(19dfae94b63468d3e16d3cc4a3eeae60d5dff1d7) )
+	DISK_IMAGE_READONLY( "912jab02", 0, BAD_DUMP SHA1(19dfae94b63468d3e16d3cc4a3eeae60d5dff1d7) )
 ROM_END
 
 ROM_START( drmn2mpu )
@@ -4247,10 +4320,10 @@
 	ROM_LOAD( "gn912ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "912jab02", 0, SHA1(19dfae94b63468d3e16d3cc4a3eeae60d5dff1d7) )
+	DISK_IMAGE_READONLY( "912jab02", 0, BAD_DUMP SHA1(19dfae94b63468d3e16d3cc4a3eeae60d5dff1d7) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "912za01",  1, SHA1(033a310006efe164cc6a8276de42a5d555f9fea9) )
+	DISK_IMAGE_READONLY( "912za01",  1, BAD_DUMP SHA1(033a310006efe164cc6a8276de42a5d555f9fea9) )
 ROM_END
 
 ROM_START( drmn3m )
@@ -4270,7 +4343,7 @@
 	ROM_LOAD( "gca23ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a23jaa02", 0, SHA1(89e365f61a4db889621d7d9d9917bcfa2c09704e) )
+	DISK_IMAGE_READONLY( "a23jaa02", 0, BAD_DUMP SHA1(89e365f61a4db889621d7d9d9917bcfa2c09704e) )
 ROM_END
 
 ROM_START( drmn4m )
@@ -4289,10 +4362,10 @@
 	ROM_LOAD( "gea25jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a25jaa02", 0, SHA1(8a0b761d1c282d927e2daf92519654a1c91ee1ab) )
+	DISK_IMAGE_READONLY( "a25jaa02", 0, BAD_DUMP SHA1(8a0b761d1c282d927e2daf92519654a1c91ee1ab) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "a25jba02", 0, SHA1(5f4aae359da610352c1004cfa1a32064d8f55d0e) )
+	DISK_IMAGE_READONLY( "a25jba02", 0, BAD_DUMP SHA1(5f4aae359da610352c1004cfa1a32064d8f55d0e) )
 ROM_END
 
 ROM_START( drmn5m )
@@ -4306,10 +4379,10 @@
 	ROM_LOAD( "gcb05jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b05jaa02", 0, SHA1(7a6e7940d1441cff1d9be1bc3affc029fe6dc9e4) )
+	DISK_IMAGE_READONLY( "b05jaa02", 0, BAD_DUMP SHA1(7a6e7940d1441cff1d9be1bc3affc029fe6dc9e4) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "b05jba02", 0, SHA1(822149db553ca78ad8174719a657dbbd2776b922) )
+	DISK_IMAGE_READONLY( "b05jba02", 0, BAD_DUMP SHA1(822149db553ca78ad8174719a657dbbd2776b922) )
 ROM_END
 
 ROM_START( drmn6m )
@@ -4328,10 +4401,10 @@
 	ROM_LOAD( "gcb16jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b16jaa02", 0, SHA1(fa0862a9bd3a48d4f6e7b44b11ad387acc05037e) )
+	DISK_IMAGE_READONLY( "b16jaa02", 0, BAD_DUMP SHA1(fa0862a9bd3a48d4f6e7b44b11ad387acc05037e) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "b16jba02", 0, SHA1(07de74a3ca384407d99c433110085208a458653e) )
+	DISK_IMAGE_READONLY( "b16jba02", 0, BAD_DUMP SHA1(07de74a3ca384407d99c433110085208a458653e) )
 ROM_END
 
 ROM_START( drmn7m )
@@ -4350,10 +4423,10 @@
 	ROM_LOAD( "gcc07jba.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c07jca02", 0, SHA1(1f27e0a22c7f4f37ec3a09984ce197e390340d27) )
+	DISK_IMAGE_READONLY( "c07jca02", 0, BAD_DUMP SHA1(1f27e0a22c7f4f37ec3a09984ce197e390340d27) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "c07jda02", 0, SHA1(7c22ebbda11bdaf85c3441d7a6f3497994cd957f) )
+	DISK_IMAGE_READONLY( "c07jda02", 0, BAD_DUMP SHA1(7c22ebbda11bdaf85c3441d7a6f3497994cd957f) )
 ROM_END
 
 ROM_START( drmn7ma )
@@ -4372,10 +4445,10 @@
 	ROM_LOAD( "gcc07jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c07jaa02", 0, SHA1(96c410745d1fd14059bf11987655ed998a9b79dd) )
+	DISK_IMAGE_READONLY( "c07jaa02", 0, BAD_DUMP SHA1(96c410745d1fd14059bf11987655ed998a9b79dd) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "c07jba02", 0, SHA1(25e1a3ff7886c409d16e40ca1798b01b11546755) )
+	DISK_IMAGE_READONLY( "c07jba02", 0, BAD_DUMP SHA1(25e1a3ff7886c409d16e40ca1798b01b11546755) )
 ROM_END
 
 ROM_START( drmn8m )
@@ -4389,10 +4462,10 @@
 	ROM_LOAD( "gcc38jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c38jaa02", 0, SHA1(d19ae541557405a4484145f4237f3c868375c72e) )
+	DISK_IMAGE_READONLY( "c38jaa02", 0, BAD_DUMP SHA1(d19ae541557405a4484145f4237f3c868375c72e) )
 
 	DISK_REGION( "multisession" )
-	DISK_IMAGE_READONLY( "c38jba02", 0, SHA1(d963064678978d489474d1ca22c1f249c6f60232) )
+	DISK_IMAGE_READONLY( "c38jba02", 0, BAD_DUMP SHA1(d963064678978d489474d1ca22c1f249c6f60232) )
 ROM_END
 
 ROM_START( drmn9m )
@@ -4406,7 +4479,7 @@
 	ROM_LOAD( "gcd09jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d09jaa02", 0, SHA1(33f3e48ed5a8becd8c4714413e454328d8d5baae) )
+	DISK_IMAGE_READONLY( "d09jaa02", 0, BAD_DUMP SHA1(33f3e48ed5a8becd8c4714413e454328d8d5baae) )
 
 	DISK_REGION( "multisession" )
 	DISK_IMAGE_READONLY( "d09jba02", 0, NO_DUMP )
@@ -4423,7 +4496,7 @@
 	ROM_LOAD( "gcd40jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d40jaa02", 0, SHA1(68b2038f0cd2d461f608945d1e243f2b6979efaa) )
+	DISK_IMAGE_READONLY( "d40jaa02", 0, BAD_DUMP SHA1(68b2038f0cd2d461f608945d1e243f2b6979efaa) )
 
 	DISK_REGION( "multisession" )
 	DISK_IMAGE_READONLY( "d40jba02", 0, BAD_DUMP SHA1(0ded9e0a6c77b181e7b6beb1dbdfa17dee4acd90) )
@@ -4454,7 +4527,7 @@
 	ROM_LOAD( "gca39ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a39jaa02", 0, SHA1(3d021448df857c12f6d46a20e14ae0fc6d342dcc) )
+	DISK_IMAGE_READONLY( "a39jaa02", 0, BAD_DUMP SHA1(3d021448df857c12f6d46a20e14ae0fc6d342dcc) )
 ROM_END
 
 ROM_START( dmx2majp )
@@ -4473,7 +4546,7 @@
 	ROM_LOAD( "gca38ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a38jaa02", 0, SHA1(d26c481ef8a70bba75bcdf41f9ceb3a49c245986) )
+	DISK_IMAGE_READONLY( "a38jaa02", 0, BAD_DUMP SHA1(d26c481ef8a70bba75bcdf41f9ceb3a49c245986) )
 ROM_END
 
 ROM_START( dncfrks )
@@ -4515,7 +4588,7 @@
 	ROM_LOAD( "gkc23ea.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c23eaa02", 0, SHA1(46868c97530db5be1b43ffa32744e3e12495c243) )
+	DISK_IMAGE_READONLY( "c23eaa02", 0, BAD_DUMP SHA1(46868c97530db5be1b43ffa32744e3e12495c243) )
 ROM_END
 
 ROM_START( dsfdct )
@@ -4535,7 +4608,7 @@
 	ROM_LOAD( "gc910jc.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "910jca02", 0, SHA1(0c868f3c9f696d291e8f27687e3ad83e453a4894) )
+	DISK_IMAGE_READONLY( "910jca02", 0, BAD_DUMP SHA1(0c868f3c9f696d291e8f27687e3ad83e453a4894) )
 ROM_END
 
 ROM_START( dsfdcta )
@@ -4554,7 +4627,7 @@
 	ROM_LOAD( "gc910ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "910jaa02", 0, SHA1(70851c383e3876c4a697a99706fbaae2dafcb0e0) )
+	DISK_IMAGE_READONLY( "910jaa02", 0, BAD_DUMP SHA1(70851c383e3876c4a697a99706fbaae2dafcb0e0) )
 ROM_END
 
 ROM_START( dsfdr )
@@ -4574,7 +4647,7 @@
 	ROM_LOAD( "gca37ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a37jaa02", 0, SHA1(c6a23b910e884aa0d4afc388dbc8379e0d09611a) )
+	DISK_IMAGE_READONLY( "a37jaa02", 0, BAD_DUMP SHA1(c6a23b910e884aa0d4afc388dbc8379e0d09611a) )
 ROM_END
 
 ROM_START( dsftkd )
@@ -4587,7 +4660,7 @@
 	ROM_LOAD( "gn884ja.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "884jaa02", 0, SHA1(80f02fcb7ea5b6394a2a58f12b73d87a1826d7f4) )
+	DISK_IMAGE_READONLY( "884jaa02", 0, BAD_DUMP SHA1(80f02fcb7ea5b6394a2a58f12b73d87a1826d7f4) )
 ROM_END
 
 ROM_START( dstage )
@@ -4607,7 +4680,7 @@
 	ROM_LOAD( "gc865ua.u1", 0x000000, 0x000224, BAD_DUMP CRC(ea8f0b4b) SHA1(363b1ea1a520b239ba8bca867366bbe8a9977a43) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "865uab02", 0, SHA1(d14dc066d4c16fba1e9b31d5f042ad249c4b5137) )
+	DISK_IMAGE_READONLY( "865uab02", 0, BAD_DUMP SHA1(d14dc066d4c16fba1e9b31d5f042ad249c4b5137) )
 ROM_END
 
 ROM_START( fbaitbc )
@@ -4617,7 +4690,7 @@
 	ROM_LOAD( "ge765ua.u1", 0x000000, 0x000224, BAD_DUMP CRC(588748c6) SHA1(ea1ead61e0dcb324ef7b6106cae00bcf6702d6c4) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "765uab02", 0, SHA1(07b09e763e4b90108aa924b518221b16667a7133) )
+	DISK_IMAGE_READONLY( "765uab02", 0, BAD_DUMP SHA1(07b09e763e4b90108aa924b518221b16667a7133) )
 ROM_END
 
 ROM_START( fbaitmc )
@@ -4675,7 +4748,7 @@
 	ROM_LOAD( "gq918eaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "918xxb02", 0, SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
+	DISK_IMAGE_READONLY( "918xxb02", 0, BAD_DUMP SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
 ROM_END
 
 ROM_START( fghtmna )
@@ -4693,7 +4766,7 @@
 	ROM_LOAD( "gq918aaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "918xxb02", 0, SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
+	DISK_IMAGE_READONLY( "918xxb02", 0, BAD_DUMP SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
 ROM_END
 
 ROM_START( fghtmnk )
@@ -4711,7 +4784,7 @@
 	ROM_LOAD( "gq918kaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "918xxb02", 0, SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
+	DISK_IMAGE_READONLY( "918xxb02", 0, BAD_DUMP SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
 ROM_END
 
 ROM_START( fghtmnu )
@@ -4729,7 +4802,7 @@
 	ROM_LOAD( "gq918uaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "918xxb02", 0, SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
+	DISK_IMAGE_READONLY( "918xxb02", 0, BAD_DUMP SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
 ROM_END
 
 ROM_START( gtrfrks )
@@ -4739,7 +4812,7 @@
 	ROM_LOAD( "gq886eac.u1",  0x000000, 0x000224, BAD_DUMP CRC(06bd6c4f) SHA1(61930e467ad135e2f31393ff5af981ed52f3bef9) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "886__c02", 0, SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
+	DISK_IMAGE_READONLY( "886__c02", 0, BAD_DUMP SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
 ROM_END
 
 ROM_START( gtrfrksu )
@@ -4749,7 +4822,7 @@
 	ROM_LOAD( "gq886uac.u1",  0x000000, 0x000224, BAD_DUMP CRC(143eaa55) SHA1(51a4fa3693f1cb1646a8986003f9b6cc1ae8b630) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "886__c02", 0, SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
+	DISK_IMAGE_READONLY( "886__c02", 0, BAD_DUMP SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
 ROM_END
 
 ROM_START( gtrfrksj )
@@ -4759,7 +4832,7 @@
 	ROM_LOAD( "gq886jac.u1",  0x000000, 0x000224, BAD_DUMP CRC(11ffd43d) SHA1(27f4f4d782604379254fb98c3c57e547aa4b321f) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "886__c02", 0, SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
+	DISK_IMAGE_READONLY( "886__c02", 0, BAD_DUMP SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
 ROM_END
 
 ROM_START( gtrfrksa )
@@ -4769,7 +4842,7 @@
 	ROM_LOAD( "gq886aac.u1",  0x000000, 0x000224, BAD_DUMP CRC(efa51ee9) SHA1(3374d936de69c287e0161bc526546441c2943555) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "886__c02", 0, SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
+	DISK_IMAGE_READONLY( "886__c02", 0, BAD_DUMP SHA1(80293512c4b914ef98acb1bbc7e3a2ed944a0dad) )
 ROM_END
 
 ROM_START( gtrfrk2m )
@@ -4802,10 +4875,10 @@
 	ROM_LOAD( "ge949jab.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "949jac01", 0, SHA1(ff017dd5c0ecbdb8935d0d4656a45e9fab10ef82) )
+	DISK_IMAGE_READONLY( "949jac01", 0, BAD_DUMP SHA1(ff017dd5c0ecbdb8935d0d4656a45e9fab10ef82) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "949jab02", 1, SHA1(ad629c9bafbdc4bf6c679918a5fae2bcfdb39332) )
+	DISK_IMAGE_READONLY( "949jab02", 1, BAD_DUMP SHA1(ad629c9bafbdc4bf6c679918a5fae2bcfdb39332) )
 ROM_END
 
 ROM_START( gtfrk3ma )
@@ -4825,7 +4898,7 @@
 	ROM_LOAD( "ge949jab.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "949jab02", 0, SHA1(ad629c9bafbdc4bf6c679918a5fae2bcfdb39332) )
+	DISK_IMAGE_READONLY( "949jab02", 0, BAD_DUMP SHA1(ad629c9bafbdc4bf6c679918a5fae2bcfdb39332) )
 ROM_END
 
 ROM_START( gtfrk3mb )
@@ -4839,7 +4912,7 @@
 	ROM_LOAD( "ge949jaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "949jaz02", 0, SHA1(b0c786ba420a34fcbd16bc36a137f6ae87b7dfa8) )
+	DISK_IMAGE_READONLY( "949jaz02", 0, BAD_DUMP SHA1(b0c786ba420a34fcbd16bc36a137f6ae87b7dfa8) )
 ROM_END
 
 ROM_START( gtrfrk4m )
@@ -4859,7 +4932,7 @@
 	ROM_LOAD( "gea24ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a24jaa02", 0, SHA1(bc0303f5a6a19484cd35890cc9934ee0bcabb2ad) )
+	DISK_IMAGE_READONLY( "a24jaa02", 0, BAD_DUMP SHA1(bc0303f5a6a19484cd35890cc9934ee0bcabb2ad) )
 ROM_END
 
 ROM_START( gtrfrk5m )
@@ -4878,7 +4951,7 @@
 	ROM_LOAD( "gea26jaa.u6",    0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a26jaa02", 0, SHA1(9909e08abff780db6fd7a5fbcc57ffbe14ae08ce) )
+	DISK_IMAGE_READONLY( "a26jaa02", 0, BAD_DUMP SHA1(9909e08abff780db6fd7a5fbcc57ffbe14ae08ce) )
 ROM_END
 
 ROM_START( gtrfrk6m )
@@ -4892,7 +4965,7 @@
 	ROM_LOAD( "gcb06ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b06jaa02", 0, SHA1(2ea53ef492da63183a28c54afde07fce323fe42e) )
+	DISK_IMAGE_READONLY( "b06jaa02", 0, BAD_DUMP SHA1(2ea53ef492da63183a28c54afde07fce323fe42e) )
 ROM_END
 
 ROM_START( gtrfrk7m )
@@ -4911,7 +4984,7 @@
 	ROM_LOAD( "gcb17jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "b17jaa02", 0, SHA1(d38dc22011b71b0e4167f1728a8794ea4b9c5396) )
+	DISK_IMAGE_READONLY( "b17jaa02", 0, BAD_DUMP SHA1(d38dc22011b71b0e4167f1728a8794ea4b9c5396) )
 ROM_END
 
 ROM_START( gtrfrk8m )
@@ -4930,7 +5003,7 @@
 	ROM_LOAD( "gcc08jba.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c08jba02", 0, SHA1(8e352ed8ade581b7c9bb579fc56003ea1831202c) )
+	DISK_IMAGE_READONLY( "c08jba02", 0, BAD_DUMP SHA1(8e352ed8ade581b7c9bb579fc56003ea1831202c) )
 ROM_END
 
 ROM_START( gtrfrk8ma )
@@ -4949,7 +5022,7 @@
 	ROM_LOAD( "gcc08jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c08jaa02", 0, SHA1(7a1d97f74ec4d643ff7d3981d66b551cbf9e57f0) )
+	DISK_IMAGE_READONLY( "c08jaa02", 0, BAD_DUMP SHA1(7a1d97f74ec4d643ff7d3981d66b551cbf9e57f0) )
 ROM_END
 
 ROM_START( gtrfrk9m )
@@ -4963,7 +5036,7 @@
 	ROM_LOAD( "gcc39jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "c39jaa02", 0, SHA1(d0696b29976a6bc01c3a1fefe09dbee721ff3ffb) )
+	DISK_IMAGE_READONLY( "c39jaa02", 0, BAD_DUMP SHA1(d0696b29976a6bc01c3a1fefe09dbee721ff3ffb) )
 ROM_END
 
 ROM_START( gtfrk10m )
@@ -4977,10 +5050,10 @@
 	ROM_LOAD( "gcd10jab.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d10jab01", 0, SHA1(c84858b412f0798a65cf3059c743501f32ad7280) )
+	DISK_IMAGE_READONLY( "d10jab01", 0, BAD_DUMP SHA1(c84858b412f0798a65cf3059c743501f32ad7280) )
 
 	DISK_REGION( "cdrom1" )
-	DISK_IMAGE_READONLY( "d10jaa02", 1, SHA1(d4e4460ca3edc1b365af593757557c6cf5b7b3ec) )
+	DISK_IMAGE_READONLY( "d10jaa02", 1, BAD_DUMP SHA1(d4e4460ca3edc1b365af593757557c6cf5b7b3ec) )
 ROM_END
 
 ROM_START( gtfrk10ma )
@@ -4994,7 +5067,7 @@
 	ROM_LOAD( "gcd10jaa.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d10jaa02", 0, SHA1(d4e4460ca3edc1b365af593757557c6cf5b7b3ec) )
+	DISK_IMAGE_READONLY( "d10jaa02", 0, BAD_DUMP SHA1(d4e4460ca3edc1b365af593757557c6cf5b7b3ec) )
 ROM_END
 
 ROM_START( gtfrk10mb )
@@ -5008,7 +5081,7 @@
 	ROM_LOAD( "gcd10jab.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d10jba02", 0, SHA1(80893da422268cc1f89688289cdec981c4f9feb2) )
+	DISK_IMAGE_READONLY( "d10jba02", 0, BAD_DUMP SHA1(80893da422268cc1f89688289cdec981c4f9feb2) )
 ROM_END
 
 ROM_START( gtfrk11m )
@@ -5022,7 +5095,7 @@
 	ROM_LOAD( "gcd39ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "d39jaa02", 0, SHA1(7a87ee331ba0301bb8724c398e6c77cfb9c172a7) )
+	DISK_IMAGE_READONLY( "d39jaa02", 0, BAD_DUMP SHA1(7a87ee331ba0301bb8724c398e6c77cfb9c172a7) )
 ROM_END
 
 ROM_START( gunmania )
@@ -5099,7 +5172,7 @@
 	ROM_LOAD( "gx908ka.u1",  0x000000, 0x000084, BAD_DUMP CRC(f4f37fe1) SHA1(30f90cdb2d092e4f8d6c14cfd4ca4945e6d352cb) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "908a02", 0, SHA1(573194ca9938c30415fc88dcc0c0152dd3024d71) )
+	DISK_IMAGE_READONLY( "908a02", 0, BAD_DUMP SHA1(573194ca9938c30415fc88dcc0c0152dd3024d71) )
 ROM_END
 
 ROM_START( konam80a )
@@ -5186,7 +5259,7 @@
 	ROM_LOAD( "gx802ja.u1", 0x000000, 0x000224, BAD_DUMP CRC(ea8bdda3) SHA1(780034ab08871631ef0e3e9b779ca89e016c26a8) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "802jab02", 0, SHA1(bcc2b6c3515e2420eef9fdf8b28115368a428a92) )
+	DISK_IMAGE_READONLY( "802jab02", 0, BAD_DUMP SHA1(bcc2b6c3515e2420eef9fdf8b28115368a428a92) )
 ROM_END
 
 ROM_START( pcnfrk3m )
@@ -5206,7 +5279,7 @@
 	ROM_LOAD( "gca23ka.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a23kaa02", 0, SHA1(5b853cc25eb583ed36d8cd402235b4f5c9ce065a) )
+	DISK_IMAGE_READONLY( "a23kaa02", 0, BAD_DUMP SHA1(5b853cc25eb583ed36d8cd402235b4f5c9ce065a) )
 ROM_END
 
 ROM_START( pnchmn )
@@ -5224,7 +5297,7 @@
 	ROM_LOAD( "gq918jaa.u6",  0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "918xxb02", 0, SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
+	DISK_IMAGE_READONLY( "918xxb02", 0, BAD_DUMP SHA1(8ced8952fff3e70ce0621a491f0973af5a6ccd82) )
 ROM_END
 
 ROM_START( pnchmna )
@@ -5260,7 +5333,7 @@
 	ROM_LOAD( "gqa09ja.u6",   0x000000, 0x000008, BAD_DUMP CRC(ce84419e) SHA1(839e8ee080ecfc79021a06417d930e8b32dfc6a1) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "a09jaa02", 0, SHA1(b085fbe76d5ef87578744b45b874b5f79147e586) )
+	DISK_IMAGE_READONLY( "a09jaa02", 0, BAD_DUMP SHA1(b085fbe76d5ef87578744b45b874b5f79147e586) )
 ROM_END
 
 ROM_START( salarymc )
diff -Nru src-old/mame/drivers/ladybug.c src/mame/drivers/ladybug.c
--- src-old/mame/drivers/ladybug.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ladybug.c	2012-05-03 11:00:08.000000000 +0200
@@ -203,7 +203,7 @@
 
 CUSTOM_INPUT_MEMBER(ladybug_state::ladybug_p1_control_r)
 {
-	return input_port_read(machine(), LADYBUG_P1_CONTROL_PORT_TAG);
+	return ioport(LADYBUG_P1_CONTROL_PORT_TAG)->read();
 }
 
 CUSTOM_INPUT_MEMBER(ladybug_state::ladybug_p2_control_r)
@@ -211,10 +211,10 @@
 	UINT32 ret;
 
 	/* upright cabinet only uses a single set of controls */
-	if (input_port_read(machine(), "DSW0") & 0x20)
-		ret = input_port_read(machine(), LADYBUG_P2_CONTROL_PORT_TAG);
+	if (ioport("DSW0")->read() & 0x20)
+		ret = ioport(LADYBUG_P2_CONTROL_PORT_TAG)->read();
 	else
-		ret = input_port_read(machine(), LADYBUG_P1_CONTROL_PORT_TAG);
+		ret = ioport(LADYBUG_P1_CONTROL_PORT_TAG)->read();
 
 	return ret;
 }
@@ -234,7 +234,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -331,7 +331,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -416,7 +416,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2 )
@@ -499,7 +499,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/laserbat.c src/mame/drivers/laserbat.c
--- src-old/mame/drivers/laserbat.c	2012-04-11 09:56:42.000000000 +0200
+++ src/mame/drivers/laserbat.c	2012-05-03 11:00:08.000000000 +0200
@@ -77,7 +77,7 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3" };
 
-	return input_port_read(machine(), portnames[m_input_mux]);
+	return ioport(portnames[m_input_mux])->read();
 }
 
 WRITE8_MEMBER(laserbat_state::laserbat_cnteff_w)
@@ -283,7 +283,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( lazarian )
@@ -361,7 +361,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( catnmous )
@@ -444,7 +444,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static const gfx_layout charlayout =
diff -Nru src-old/mame/drivers/lastfght.c src/mame/drivers/lastfght.c
--- src-old/mame/drivers/lastfght.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/lastfght.c	2012-05-03 11:00:08.000000000 +0200
@@ -382,12 +382,12 @@
 {
 	// high byte:
 	// mask 0x1c: from sound?
-	return (machine().rand() & 0x1c00) | input_port_read(machine(), "IN0");
+	return (machine().rand() & 0x1c00) | ioport("IN0")->read();
 }
 
 READ16_MEMBER(lastfght_state::lastfght_c00004_r)
 {
-	return input_port_read(machine(), "IN1");
+	return ioport("IN1")->read();
 }
 
 READ16_MEMBER(lastfght_state::lastfght_c00006_r)
@@ -395,7 +395,7 @@
 	// low byte:
 	// bit 7 = protection?
 	// bit 5 = blitter?
-	return input_port_read(machine(), "IN2");
+	return ioport("IN2")->read();
 }
 
 WRITE16_MEMBER(lastfght_state::lastfght_c00006_w)
diff -Nru src-old/mame/drivers/lazercmd.c src/mame/drivers/lazercmd.c
--- src-old/mame/drivers/lazercmd.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/lazercmd.c	2012-05-03 11:00:08.000000000 +0200
@@ -290,7 +290,7 @@
 /* triggered by REDD,r opcode */
 READ8_MEMBER(lazercmd_state::lazercmd_data_port_r)
 {
-	UINT8 data = input_port_read(machine(), "DSW") & 0x0f;
+	UINT8 data = ioport("DSW")->read() & 0x0f;
 	return data;
 }
 
@@ -370,16 +370,16 @@
 	switch (offset)
 	{
 		case 0: 			   /* player 1 joysticks */
-			data = input_port_read(machine(), "IN0");
+			data = ioport("IN0")->read();
 			break;
 		case 1: 			   /* player 2 joysticks */
-			data = input_port_read(machine(), "IN1");
+			data = ioport("IN1")->read();
 			break;
 		case 2: 			   /* player 1 + 2 buttons */
-			data = input_port_read(machine(), "IN3");
+			data = ioport("IN3")->read();
 			break;
 		case 3: 			   /* coin slot + start buttons */
-			data = input_port_read(machine(), "IN2");
+			data = ioport("IN2")->read();
 			break;
 		case 4: 			   /* vertical scan counter */
 			data = ((m_timer_count & 0x10) >> 1) | ((m_timer_count & 0x20) >> 3)
diff -Nru src-old/mame/drivers/leland.c src/mame/drivers/leland.c
--- src-old/mame/drivers/leland.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/leland.c	2012-05-03 11:00:08.000000000 +0200
@@ -146,7 +146,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -192,7 +192,7 @@
 
 	PORT_START("IN3")	/* 0xD1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -225,7 +225,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -264,7 +264,7 @@
 
 	PORT_START("IN3")	/* 0xD1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -300,7 +300,7 @@
 
 	PORT_START("IN3")	/* 0xD1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -335,7 +335,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -370,7 +370,7 @@
 
 	PORT_START("IN3")	/* 0x51/D1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -407,7 +407,7 @@
 
 	PORT_START("IN3")	/* 0xD1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -445,7 +445,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -487,7 +487,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -545,7 +545,7 @@
 
 	PORT_START("IN3")	/* 0x91 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -600,7 +600,7 @@
 
 	PORT_START("IN3")	/* 0xD1 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE_NO_TOGGLE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -660,7 +660,7 @@
 
 	PORT_START("IN3")	/* 0x51 */
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE_NO_TOGGLE( 0x04, IP_ACTIVE_LOW )
 	PORT_BIT( 0xf8, IP_ACTIVE_LOW, IPT_UNUSED )
 
diff -Nru src-old/mame/drivers/lemmings.c src/mame/drivers/lemmings.c
--- src-old/mame/drivers/lemmings.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/lemmings.c	2012-05-03 11:00:08.000000000 +0200
@@ -36,10 +36,10 @@
 {
 	switch (offset)
 	{
-	case 0: return input_port_read(machine(), "AN0");
-	case 1: return input_port_read(machine(), "AN1");
-	case 4: return input_port_read(machine(), "AN2");
-	case 5: return input_port_read(machine(), "AN3");
+	case 0: return ioport("AN0")->read();
+	case 1: return ioport("AN1")->read();
+	case 4: return ioport("AN2")->read();
+	case 5: return ioport("AN3")->read();
 	}
 	return 0;
 }
@@ -50,13 +50,13 @@
 	switch (offset << 1)
 	{
 		case 0x41a:
-			return input_port_read(machine(), "BUTTONS");
+			return ioport("BUTTONS")->read();
 
 		case 0x320:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 
 		case 0x4e6:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 	}
 
 	return 0;
@@ -143,7 +143,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_SERVICE_NO_TOGGLE(0x0004, IP_ACTIVE_LOW)
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/lethal.c src/mame/drivers/lethal.c
--- src-old/mame/drivers/lethal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/lethal.c	2012-05-03 11:00:08.000000000 +0200
@@ -174,8 +174,8 @@
 static const char *const gunnames[] = { "LIGHT0_X", "LIGHT0_Y", "LIGHT1_X", "LIGHT1_Y" };
 
 /* a = 1, 2 = player # */
-#define GUNX( a ) (( ( input_port_read(machine(), gunnames[2 * (a - 1)]) * 287 ) / 0xff ) + 16)
-#define GUNY( a ) (( ( input_port_read(machine(), gunnames[2 * (a - 1) + 1]) * 223 ) / 0xff ) + 10)
+#define GUNX( a ) (( ( ioport(gunnames[2 * (a - 1)])->read() * 287 ) / 0xff ) + 16)
+#define GUNY( a ) (( ( ioport(gunnames[2 * (a - 1) + 1])->read() * 223 ) / 0xff ) + 10)
 
 static const eeprom_interface eeprom_intf =
 {
@@ -200,7 +200,7 @@
 
 	m_cur_control2 = data;
 
-	input_port_write(machine(), "EEPROMOUT", m_cur_control2, 0xff);
+	ioport("EEPROMOUT")->write(m_cur_control2, 0xff);
 }
 
 static INTERRUPT_GEN(lethalen_interrupt)
diff -Nru src-old/mame/drivers/lethalj.c src/mame/drivers/lethalj.c
--- src-old/mame/drivers/lethalj.c	2012-04-10 07:38:11.000000000 +0200
+++ src/mame/drivers/lethalj.c	2012-05-03 11:00:08.000000000 +0200
@@ -161,7 +161,7 @@
 
 CUSTOM_INPUT_MEMBER(lethalj_state::cclownz_paddle)
 {
-	int value = input_port_read(machine(), "PADDLE");
+	int value = ioport("PADDLE")->read();
 	return ((value << 4) & 0xf00) | (value & 0x00f);
 }
 
diff -Nru src-old/mame/drivers/liberate.c src/mame/drivers/liberate.c
--- src-old/mame/drivers/liberate.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/liberate.c	2012-05-03 11:00:08.000000000 +0200
@@ -54,11 +54,11 @@
 
 READ8_MEMBER(liberate_state::deco16_io_r)
 {
-	if (offset == 0) return input_port_read(machine(), "IN1"); /* Player 1 controls */
-	if (offset == 1) return input_port_read(machine(), "IN2"); /* Player 2 controls */
-	if (offset == 2) return input_port_read(machine(), "IN3"); /* Vblank, coins */
-	if (offset == 3) return input_port_read(machine(), "DSW1"); /* Dip 1 */
-	if (offset == 4) return input_port_read(machine(), "DSW2"); /* Dip 2 */
+	if (offset == 0) return ioport("IN1")->read(); /* Player 1 controls */
+	if (offset == 1) return ioport("IN2")->read(); /* Player 2 controls */
+	if (offset == 2) return ioport("IN3")->read(); /* Vblank, coins */
+	if (offset == 3) return ioport("DSW1")->read(); /* Dip 1 */
+	if (offset == 4) return ioport("DSW2")->read(); /* Dip 2 */
 
 	logerror("%04x:  Read input %d\n", cpu_get_pc(&space.device()), offset);
 	return 0xff;
@@ -338,7 +338,7 @@
 
 static INPUT_PORTS_START( generic_input )
 	PORT_START("IN0")
-	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
@@ -358,7 +358,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN3")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
@@ -489,7 +489,7 @@
 	PORT_INCLUDE( kamikcab )
 
 	PORT_MODIFY("IN0")
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfb, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -575,7 +575,7 @@
 
 	PORT_MODIFY("IN0")
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_TILT )
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xf9, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 
 	PORT_MODIFY("DSW1")
@@ -763,7 +763,7 @@
 static INTERRUPT_GEN( deco16_interrupt )
 {
 	liberate_state *state = device->machine().driver_data<liberate_state>();
-	int p = ~input_port_read(device->machine(), "IN3");
+	int p = ~state->ioport("IN3")->read();
 	if ((p & 0x43) && !state->m_latch)
 	{
 		device_set_input_line(device, DECO16_IRQ_LINE, ASSERT_LINE);
diff -Nru src-old/mame/drivers/liberatr.c src/mame/drivers/liberatr.c
--- src-old/mame/drivers/liberatr.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/liberatr.c	2012-05-03 11:00:08.000000000 +0200
@@ -182,8 +182,8 @@
 	/* input becomes the starting point for the trackball counters */
 	if (((data ^ m_ctrld) & 0x10) && (data & 0x10))
 	{
-		UINT8 trackball = input_port_read(machine(), "FAKE");
-		UINT8 switches = input_port_read(machine(), "IN0");
+		UINT8 trackball = ioport("FAKE")->read();
+		UINT8 switches = ioport("IN0")->read();
 		m_trackball_offset = ((trackball & 0xf0) - (switches & 0xf0)) | ((trackball - switches) & 0x0f);
 	}
 	m_ctrld = data & 0x10;
@@ -195,13 +195,13 @@
 	/* if ctrld is high, the /ld signal on the LS191 is NOT set, meaning that the trackball is counting */
 	if (m_ctrld)
 	{
-		UINT8 trackball = input_port_read(machine(), "FAKE");
+		UINT8 trackball = ioport("FAKE")->read();
 		return ((trackball & 0xf0) - (m_trackball_offset & 0xf0)) | ((trackball - m_trackball_offset) & 0x0f);
 	}
 
 	/* otherwise, the LS191 is simply passing through the raw switch inputs */
 	else
-		return input_port_read(machine(), "IN0");
+		return ioport("IN0")->read();
 }
 
 
@@ -300,7 +300,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH,IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH,IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")			/* IN2  -  Game Option switches DSW @ D4 on PCB */
 	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Lives ) )
diff -Nru src-old/mame/drivers/limenko.c src/mame/drivers/limenko.c
--- src-old/mame/drivers/limenko.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/limenko.c	2012-05-03 11:00:08.000000000 +0200
@@ -371,7 +371,7 @@
 	limenko_state *state = machine.driver_data<limenko_state>();
 	int i;
 
-	UINT8 *base_gfx	= machine.root_device().memregion("gfx1")->base();
+	UINT8 *base_gfx	= state->memregion("gfx1")->base();
 	UINT8 *gfx_max	= base_gfx + state->memregion("gfx1")->bytes();
 
 	UINT8 *gfxdata;
@@ -1066,7 +1066,7 @@
 static DRIVER_INIT( spotty )
 {
 	limenko_state *state = machine.driver_data<limenko_state>();
-	UINT8 *dst    = machine.root_device().memregion("gfx1")->base();
+	UINT8 *dst    = state->memregion("gfx1")->base();
 	UINT8 *src    = state->memregion("user2")->base();
 	int x;
 
diff -Nru src-old/mame/drivers/lockon.c src/mame/drivers/lockon.c
--- src-old/mame/drivers/lockon.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/lockon.c	2012-05-03 11:00:08.000000000 +0200
@@ -332,10 +332,10 @@
 {
 	switch (offset)
 	{
-		case 0:  return input_port_read(machine(), "ADC_BANK");
-		case 1:  return input_port_read(machine(), "ADC_PITCH");
-		case 2:  return input_port_read(machine(), "ADC_MISSILE");
-		case 3:  return input_port_read(machine(), "ADC_HOVER");
+		case 0:  return ioport("ADC_BANK")->read();
+		case 1:  return ioport("ADC_PITCH")->read();
+		case 2:  return ioport("ADC_MISSILE")->read();
+		case 3:  return ioport("ADC_HOVER")->read();
 		default: return 0;
 	}
 }
diff -Nru src-old/mame/drivers/looping.c src/mame/drivers/looping.c
--- src-old/mame/drivers/looping.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/looping.c	2012-05-03 11:00:08.000000000 +0200
@@ -900,7 +900,7 @@
 static DRIVER_INIT( looping )
 {
 	looping_state *state = machine.driver_data<looping_state>();
-	int length = machine.root_device().memregion("maincpu")->bytes();
+	int length = state->memregion("maincpu")->bytes();
 	UINT8 *rom = state->memregion("maincpu")->base();
 	int i;
 
diff -Nru src-old/mame/drivers/lordgun.c src/mame/drivers/lordgun.c
--- src-old/mame/drivers/lordgun.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/lordgun.c	2012-05-03 11:00:08.000000000 +0200
@@ -208,9 +208,9 @@
 	lordgun_state *state = device->machine().driver_data<lordgun_state>();
 	switch (state->m_aliencha_dip_sel & 0x70)
 	{
-		case 0x30:	return input_port_read(device->machine(), "DIP1");
-		case 0x60:	return input_port_read(device->machine(), "DIP2");
-		case 0x50:	return input_port_read(device->machine(), "DIP3");
+		case 0x30:	return state->ioport("DIP1")->read();
+		case 0x60:	return state->ioport("DIP2")->read();
+		case 0x50:	return state->ioport("DIP3")->read();
 
 		default:
 			logerror("%s: dip_r with unknown dip_sel = %02X\n",device->machine().describe_context(),state->m_aliencha_dip_sel);
diff -Nru src-old/mame/drivers/lvcards.c src/mame/drivers/lvcards.c
--- src-old/mame/drivers/lvcards.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/lvcards.c	2012-05-03 11:00:08.000000000 +0200
@@ -130,7 +130,7 @@
 
 READ8_MEMBER(lvcards_state::payout_r)
 {
-	m_result = input_port_read(machine(), "IN2");
+	m_result = ioport("IN2")->read();
 
 	if (m_payout)
 	{
diff -Nru src-old/mame/drivers/m10.c src/mame/drivers/m10.c
--- src-old/mame/drivers/m10.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/m10.c	2012-05-03 11:00:08.000000000 +0200
@@ -251,10 +251,10 @@
 	/* I have NO IDEA if this is correct or not */
 	m_bottomline = ~data & 0x20;
 
-	if (input_port_read(machine(), "CAB") & 0x01)
+	if (ioport("CAB")->read() & 0x01)
 		m_flip = ~data & 0x10;
 
-	if (!(input_port_read(machine(), "CAB") & 0x02))
+	if (!(ioport("CAB")->read() & 0x02))
 		machine().sound().system_mute(data & 0x80);
 
 	/* sound command in lower 4 bytes */
@@ -326,10 +326,10 @@
 
 	m_bottomline = ~data & 0x20;
 
-	if (input_port_read(machine(), "CAB") & 0x01)
+	if (ioport("CAB")->read() & 0x01)
 		m_flip = ~data & 0x10;
 
-	if (!(input_port_read(machine(), "CAB") & 0x02))
+	if (!(ioport("CAB")->read() & 0x02))
 		machine().sound().system_mute(data & 0x80);
 }
 
@@ -355,9 +355,9 @@
 	if (data & 0xf0)
 		popmessage("M15 ctrl: %02x",data);
 #endif
-	if (input_port_read(machine(), "CAB") & 0x01)
+	if (ioport("CAB")->read() & 0x01)
 		m_flip = ~data & 0x04;
-	if (!(input_port_read(machine(), "CAB") & 0x02))
+	if (!(ioport("CAB")->read() & 0x02))
 		machine().sound().system_mute(data & 0x08);
 }
 
diff -Nru src-old/mame/drivers/m107.c src/mame/drivers/m107.c
--- src-old/mame/drivers/m107.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/m107.c	2012-05-03 11:00:08.000000000 +0200
@@ -202,7 +202,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_SERVICE )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK ) //this is sprite flag on Irem M92, if this is active low then Dream Soccer '94 is unplayably slow
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") //this is sprite flag on Irem M92, if this is active low then Dream Soccer '94 is unplayably slow
 
 	/* DIP switch bank 3 */
 	PORT_DIPUNKNOWN_DIPLOC( 0x0100, 0x0100, "SW3:1" )
@@ -369,7 +369,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_SERVICE )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_VBLANK ) //this is sprite flag on Irem M92, if this is active low then Dream Soccer '94 is unplayably slow
+	PORT_BIT( 0x0080, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") //this is sprite flag on Irem M92, if this is active low then Dream Soccer '94 is unplayably slow
 	PORT_DIPNAME( 0x0100, 0x0000, "DSW3" )
 	PORT_DIPSETTING(    0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x0100, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/m14.c src/mame/drivers/m14.c
--- src-old/mame/drivers/m14.c	2012-04-12 11:28:12.000000000 +0200
+++ src/mame/drivers/m14.c	2012-05-03 11:00:08.000000000 +0200
@@ -162,7 +162,7 @@
 READ8_MEMBER(m14_state::m14_rng_r)
 {
 	/* graphic artifacts happens if this doesn't return random values. */
-	return (machine().rand() & 0x0f) | 0xf0; /* | (input_port_read(machine(), "IN1") & 0x80)*/;
+	return (machine().rand() & 0x0f) | 0xf0; /* | (ioport("IN1")->read() & 0x80)*/;
 }
 
 /* Here routes the hopper & the inputs */
@@ -175,7 +175,7 @@
 		return 0; //0x43 status bits
 	}
 	else
-		return input_port_read(machine(), "IN0");
+		return ioport("IN0")->read();
 }
 
 #if 0
diff -Nru src-old/mame/drivers/m63.c src/mame/drivers/m63.c
--- src-old/mame/drivers/m63.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/m63.c	2012-05-03 11:00:08.000000000 +0200
@@ -544,17 +544,17 @@
 	PORT_DIPSETTING(    0x04, "x1.2" )
 	PORT_DIPSETTING(    0x08, "x1.4" )
 	PORT_DIPSETTING(    0x0c, "x1.6" )
-	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:!5,!6") PORT_CONDITION("DSW1",0x04,PORTCOND_EQUALS,0x04) /* coin mode 2 */
+	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:!5,!6") PORT_CONDITION("DSW1",0x04,EQUALS,0x04) /* coin mode 2 */
 	PORT_DIPSETTING(    0x20, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x30, DEF_STR( Free_Play ) )	/* Not documented */
-	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:!7,!8") PORT_CONDITION("DSW1",0x04,PORTCOND_EQUALS,0x04) /* coin mode 2 */
+	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:!7,!8") PORT_CONDITION("DSW1",0x04,EQUALS,0x04) /* coin mode 2 */
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0xf0, 0x00, DEF_STR( Coinage ) )		PORT_DIPLOCATION("SW1:!5,!6,!7,!8") PORT_CONDITION("DSW1",0x04,PORTCOND_EQUALS,0x00) /* coin mode 1 */
+	PORT_DIPNAME( 0xf0, 0x00, DEF_STR( Coinage ) )		PORT_DIPLOCATION("SW1:!5,!6,!7,!8") PORT_CONDITION("DSW1",0x04,EQUALS,0x00) /* coin mode 1 */
 	PORT_DIPSETTING(    0x60, DEF_STR( 7C_1C ) )
 	PORT_DIPSETTING(    0x50, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 5C_1C ) )
@@ -696,7 +696,7 @@
 {
 	running_machine &machine = device.machine();
 	m63_state *state = machine.driver_data<m63_state>();
-	int i, len = machine.root_device().memregion("samples")->bytes();
+	int i, len = state->memregion("samples")->bytes();
 	UINT8 *ROM = state->memregion("samples")->base();
 
 	state->m_samplebuf = auto_alloc_array(machine, INT16, len);
diff -Nru src-old/mame/drivers/m72.c src/mame/drivers/m72.c
--- src-old/mame/drivers/m72.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/m72.c	2012-05-03 11:00:08.000000000 +0200
@@ -845,7 +845,7 @@
 
 		for (i = 0;i < 4;i++)
 		{
-			curr = input_port_read(machine(), axisnames[i]);
+			curr = ioport(axisnames[i])->read();
 			m_diff[i] = (curr - m_prev[i]);
 			m_prev[i] = curr;
 		}
@@ -857,7 +857,7 @@
 		case 0:
 			return (m_diff[0] & 0xff) | ((m_diff[2] & 0xff) << 8);
 		case 1:
-			return ((m_diff[0] >> 8) & 0x1f) | (m_diff[2] & 0x1f00) | (input_port_read(machine(), "IN0") & 0xe0e0);
+			return ((m_diff[0] >> 8) & 0x1f) | (m_diff[2] & 0x1f00) | (ioport("IN0")->read() & 0xe0e0);
 		case 2:
 			return (m_diff[1] & 0xff) | ((m_diff[3] & 0xff) << 8);
 		case 3:
@@ -1122,7 +1122,7 @@
 ADDRESS_MAP_END
 
 #define COIN_MODE_1 \
-	PORT_DIPNAME( 0x00f0, 0x00f0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0400, PORTCOND_NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW1:5,6,7,8") \
+	PORT_DIPNAME( 0x00f0, 0x00f0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0400, NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW1:5,6,7,8") \
 	PORT_DIPSETTING(      0x00a0, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(      0x00b0, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(      0x00c0, DEF_STR( 4C_1C ) ) \
@@ -1141,12 +1141,12 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 
 #define COIN_MODE_2_A \
-	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0400, PORTCOND_EQUALS, 0x0000) PORT_DIPLOCATION("SW1:5,6") \
+	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0400, EQUALS, 0x0000) PORT_DIPLOCATION("SW1:5,6") \
 	PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) ) \
 	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) ) \
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) ) \
-	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0400, PORTCOND_EQUALS, 0x0000) PORT_DIPLOCATION("SW1:7,8") \
+	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0400, EQUALS, 0x0000) PORT_DIPLOCATION("SW1:7,8") \
 	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) ) \
 	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) ) \
 	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_5C ) ) \
@@ -1426,10 +1426,10 @@
 	PORT_DIPSETTING(      0x0100, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0200, 0x0000, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("SW2:2")
-	PORT_DIPSETTING(      0x0000, "Upright (single)" )		PORT_CONDITION("DSW", 0x1000, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0200, DEF_STR( Cocktail ) )		PORT_CONDITION("DSW", 0x1000, PORTCOND_NOTEQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0000, "Upright (double) On" )	PORT_CONDITION("DSW", 0x1000, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x0200, "Upright (double) Off" )	PORT_CONDITION("DSW", 0x1000, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, "Upright (single)" )		PORT_CONDITION("DSW", 0x1000, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0200, DEF_STR( Cocktail ) )		PORT_CONDITION("DSW", 0x1000, NOTEQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, "Upright (double) On" )	PORT_CONDITION("DSW", 0x1000, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0200, "Upright (double) Off" )	PORT_CONDITION("DSW", 0x1000, EQUALS, 0x0000)
 	PORT_DIPNAME( 0x0400, 0x0400, "Coin Mode" ) PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x0400, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
@@ -1621,7 +1621,7 @@
 	PORT_DIPSETTING(      0x0800, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
 	/* Coin Mode 1 */
-	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, PORTCOND_NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6,7,8")
+	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6,7,8")
 	PORT_DIPSETTING(      0xa000, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(      0xb000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0xc000, DEF_STR( 4C_1C ) )
@@ -1683,7 +1683,7 @@
 	PORT_DIPSETTING(      0x0800, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
 	/* Coin Mode 1 */
-	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, PORTCOND_NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6,7,8")
+	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, NOTEQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6,7,8")
 	PORT_DIPSETTING(      0xa000, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(      0xb000, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0xc000, DEF_STR( 4C_1C ) )
diff -Nru src-old/mame/drivers/m79amb.c src/mame/drivers/m79amb.c
--- src-old/mame/drivers/m79amb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/m79amb.c	2012-05-03 11:00:08.000000000 +0200
@@ -114,16 +114,16 @@
 
 READ8_MEMBER(m79amb_state::gray5bit_controller0_r)
 {
-	UINT8 port_data = input_port_read(machine(), "8004");
-	UINT8 gun_pos = input_port_read(machine(), "GUN1");
+	UINT8 port_data = ioport("8004")->read();
+	UINT8 gun_pos = ioport("GUN1")->read();
 
 	return (port_data & 0xe0) | m_lut_gun1[gun_pos];
 }
 
 READ8_MEMBER(m79amb_state::gray5bit_controller1_r)
 {
-	UINT8 port_data = input_port_read(machine(), "8005");
-	UINT8 gun_pos = input_port_read(machine(), "GUN2");
+	UINT8 port_data = ioport("8005")->read();
+	UINT8 gun_pos = ioport("GUN2")->read();
 
 	return (port_data & 0xe0) | m_lut_gun2[gun_pos];
 }
@@ -171,7 +171,7 @@
 	PORT_DIPSETTING(    0xc0, DEF_STR( Free_Play ))
 
 	PORT_START("8002")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_TILT )
diff -Nru src-old/mame/drivers/macs.c src/mame/drivers/macs.c
--- src-old/mame/drivers/macs.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/macs.c	2012-05-03 11:00:08.000000000 +0200
@@ -110,23 +110,23 @@
 			/*It's bit-wise*/
 			switch(m_mux_data&0x0f)
 			{
-				case 0x00: return input_port_read(machine(), "IN0");
-				case 0x01: return input_port_read(machine(), "IN1");
-				case 0x02: return input_port_read(machine(), "IN2");
-				case 0x04: return input_port_read(machine(), "IN3");
-				case 0x08: return input_port_read(machine(), "IN4");
+				case 0x00: return ioport("IN0")->read();
+				case 0x01: return ioport("IN1")->read();
+				case 0x02: return ioport("IN2")->read();
+				case 0x04: return ioport("IN3")->read();
+				case 0x08: return ioport("IN4")->read();
 				default:
 				logerror("Unmapped mahjong panel mux data %02x\n",m_mux_data);
 				return 0xff;
 			}
 		}
-		case 1: return input_port_read(machine(), "SYS0");
-		case 2: return input_port_read(machine(), "DSW0");
-		case 3: return input_port_read(machine(), "DSW1");
-		case 4: return input_port_read(machine(), "DSW2");
-		case 5: return input_port_read(machine(), "DSW3");
-		case 6: return input_port_read(machine(), "DSW4");
-		case 7: return input_port_read(machine(), "SYS1");
+		case 1: return ioport("SYS0")->read();
+		case 2: return ioport("DSW0")->read();
+		case 3: return ioport("DSW1")->read();
+		case 4: return ioport("DSW2")->read();
+		case 5: return ioport("DSW3")->read();
+		case 6: return ioport("DSW4")->read();
+		case 7: return ioport("SYS1")->read();
 		default:	popmessage("Unmapped I/O read at PC = %06x offset = %02x",cpu_get_pc(&space.device()),offset+0xc0);
 	}
 
@@ -676,10 +676,10 @@
         730E: ED B0         ldir
         ...
 */
-		memcpy(macs_ram1 + 0x0e9f, machine.root_device().memregion("user1")->base()+0x7327, 0xc7);
-		memcpy(macs_ram1 + 0x1e9f, machine.root_device().memregion("user1")->base()+0x7327, 0xc7);
+		memcpy(macs_ram1 + 0x0e9f, state->memregion("user1")->base()+0x7327, 0xc7);
+		memcpy(macs_ram1 + 0x1e9f, state->memregion("user1")->base()+0x7327, 0xc7);
 
-		memcpy(macs_ram1 + 0x0800, machine.root_device().memregion("user1")->base()+0x73fa, 0x507);
+		memcpy(macs_ram1 + 0x0800, state->memregion("user1")->base()+0x73fa, 0x507);
 		memcpy(macs_ram1 + 0x1800, state->memregion("user1")->base()+0x73fa, 0x507);
 
 #define MAKEJMP(n,m)	macs_ram2[(n) - 0xe800 + 0]=0xc3;\
diff -Nru src-old/mame/drivers/madalien.c src/mame/drivers/madalien.c
--- src-old/mame/drivers/madalien.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/madalien.c	2012-05-03 11:00:08.000000000 +0200
@@ -143,7 +143,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet )) PORT_DIPLOCATION("SW:8")
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ))
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ))
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("PLAYER2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2)
diff -Nru src-old/mame/drivers/madmotor.c src/mame/drivers/madmotor.c
--- src-old/mame/drivers/madmotor.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/madmotor.c	2012-05-03 11:00:08.000000000 +0200
@@ -151,7 +151,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/magic10.c src/mame/drivers/magic10.c
--- src-old/mame/drivers/magic10.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/magic10.c	2012-05-03 11:00:08.000000000 +0200
@@ -427,23 +427,23 @@
 	PORT_DIPSETTING(      0x0800, "Note A: 20 - Note B: 40 - Note C: 100 - Note D: 200" )
 	PORT_DIPSETTING(      0x0400, "Note A: 50 - Note B: 100 - Note C: 500 - Note D: 1000" )
 	PORT_DIPSETTING(      0x0c00, "Note A: 100 - Note B: 200 - Note C: 1000 - Note D: 2000" )
-	PORT_DIPNAME( 0x3000, 0x3000, "Lots At" )			PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0xc000)
+	PORT_DIPNAME( 0x3000, 0x3000, "Lots At" )			PORT_CONDITION("DSW", 0xc000, EQUALS, 0xc000)
 	PORT_DIPSETTING(      0x0000, "50 200 500 1000 2000" )
 	PORT_DIPSETTING(      0x1000, "100 300 1000 3000 5000" )
 	PORT_DIPSETTING(      0x2000, "200 500 2000 3000 5000" )
 	PORT_DIPSETTING(      0x3000, "500 1000 2000 4000 8000" )
-	PORT_DIPNAME( 0x3000, 0x3000, "1 Ticket Won" )		PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x8000)
+	PORT_DIPNAME( 0x3000, 0x3000, "1 Ticket Won" )		PORT_CONDITION("DSW", 0xc000, EQUALS, 0x8000)
 //  PORT_DIPSETTING(      0x0000, "Every 100 Score" )
 //  PORT_DIPSETTING(      0x1000, "Every 100 Score" )
 //  PORT_DIPSETTING(      0x2000, "Every 100 Score" )
 	PORT_DIPSETTING(      0x3000, "Every 100 Score" )
-	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Unused ) )	PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x4000)
+	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Unused ) )	PORT_CONDITION("DSW", 0xc000, EQUALS, 0x4000)
 	PORT_DIPSETTING(      0x1000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x2000, 0x2000, DEF_STR( Unused ) )	PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x4000)
+	PORT_DIPNAME( 0x2000, 0x2000, DEF_STR( Unused ) )	PORT_CONDITION("DSW", 0xc000, EQUALS, 0x4000)
 	PORT_DIPSETTING(      0x2000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x3000, 0x3000, "1 Play Won" )		PORT_CONDITION("DSW", 0xc000, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPNAME( 0x3000, 0x3000, "1 Play Won" )		PORT_CONDITION("DSW", 0xc000, EQUALS, 0x0000)
 //  PORT_DIPSETTING(      0x0000, "Every 10 Score" )
 //  PORT_DIPSETTING(      0x1000, "Every 10 Score" )
 //  PORT_DIPSETTING(      0x2000, "Every 10 Score" )
diff -Nru src-old/mame/drivers/magicfly.c src/mame/drivers/magicfly.c
--- src-old/mame/drivers/magicfly.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/magicfly.c	2012-05-03 11:00:08.000000000 +0200
@@ -561,11 +561,11 @@
 {
 	switch( m_input_selector )
 	{
-		case 0x01: return input_port_read(machine(), "IN0-0");
-		case 0x02: return input_port_read(machine(), "IN0-1");
-		case 0x04: return input_port_read(machine(), "IN0-2");
-		case 0x08: return input_port_read(machine(), "IN0-3");
-		case 0x00: return input_port_read(machine(), "DSW0");
+		case 0x01: return ioport("IN0-0")->read();
+		case 0x02: return ioport("IN0-1")->read();
+		case 0x04: return ioport("IN0-2")->read();
+		case 0x08: return ioport("IN0-3")->read();
+		case 0x00: return ioport("DSW0")->read();
 	}
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/magtouch.c src/mame/drivers/magtouch.c
--- src-old/mame/drivers/magtouch.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/magtouch.c	2012-05-03 11:00:08.000000000 +0200
@@ -147,7 +147,7 @@
 	switch(offset)
 	{
 		case 1:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		default:
 			return 0;
 	}
diff -Nru src-old/mame/drivers/majorpkr.c src/mame/drivers/majorpkr.c
--- src-old/mame/drivers/majorpkr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/majorpkr.c	2012-05-03 11:00:08.000000000 +0200
@@ -655,10 +655,10 @@
 
 	switch( (m_mux_data & 0xf0) )		/* 00-10-20-30-0F-1F-2F-3F */
 	{
-		case 0x00: return input_port_read(machine(), "DSW1");	/* confirmed */
-		case 0x10: return input_port_read(machine(), "DSW2");	/* confirmed */
-		case 0x20: return input_port_read(machine(), "DSW3");	/* confirmed */
-		case 0x30: return input_port_read(machine(), "DSW4");	/* confirmed */
+		case 0x00: return ioport("DSW1")->read();	/* confirmed */
+		case 0x10: return ioport("DSW2")->read();	/* confirmed */
+		case 0x20: return ioport("DSW3")->read();	/* confirmed */
+		case 0x30: return ioport("DSW4")->read();	/* confirmed */
 	}
 
 	return 0xff;
@@ -669,11 +669,11 @@
 
 	if ((m_mux_data & 0x0f) == 4)
 	{
-		return input_port_read(machine(), "IN0-1");
+		return ioport("IN0-1")->read();
 	}
 	else
 	{
-		return input_port_read(machine(), "IN0-0");
+		return ioport("IN0-0")->read();
 	}
 }
 
diff -Nru src-old/mame/drivers/malzak.c src/mame/drivers/malzak.c
--- src-old/mame/drivers/malzak.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/malzak.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,7 +82,7 @@
 	// POT switch position, read from port A of the first S2636
 	// Not sure of the correct values to return, but these should
 	// do based on the game code.
-	switch (input_port_read(machine(), "POT"))
+	switch (ioport("POT")->read())
 	{
 		case 0:  // Normal play
 			return 0xf0;
@@ -210,7 +210,7 @@
 	/* No POT switch on Malzak as far as I know */
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 INPUT_PORTS_END
 
@@ -237,7 +237,7 @@
 	PORT_DIPSETTING( 0x03, "4" )  // Change settings
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 INPUT_PORTS_END
 
diff -Nru src-old/mame/drivers/mappy.c src/mame/drivers/mappy.c
--- src-old/mame/drivers/mappy.c	2012-04-16 00:44:14.000000000 +0200
+++ src/mame/drivers/mappy.c	2012-05-03 11:00:08.000000000 +0200
@@ -1050,21 +1050,21 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_7C ) )
 	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:4,5,6")
-	PORT_DIPSETTING(    0x08, "30k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "30k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "30k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x38, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x28, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "30k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "30k Only" )			PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "30k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "30k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x38, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x28, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "30k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x00)
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
-	PORT_DIPSETTING(    0x10, "30k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00) /* Manual shows 100k only, Test Mode shows 30k which is what we use */
-	PORT_DIPSETTING(    0x38, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "40k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x28, "40k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "40k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "30k Only" )			PORT_CONDITION("DSW2",0xc0,EQUALS,0x00) /* Manual shows 100k only, Test Mode shows 30k which is what we use */
+	PORT_DIPSETTING(    0x38, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "40k Only" )			PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x28, "40k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "40k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,EQUALS,0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:7,8")
 	PORT_DIPSETTING(    0x80, "1" )
 	PORT_DIPSETTING(    0x40, "2" )
@@ -1089,20 +1089,20 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_7C ) )
 	PORT_DIPNAME( 0x38, 0x30, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW1:4,5,6")
-	PORT_DIPSETTING(    0x20, "20k & 70k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "20k, 70k & Every 70k" )	PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "30k Only" )			PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "30k & 70k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "30k & 80k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x28, "30k, 100k & Every 80k" )	PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "30k & 100k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "30k Only" )			PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, "40k Only" )			PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x20, "30k & 80k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, "30k, 80k & Every 80k" )	PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "30k & 100k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "40k & 120k Only" )		PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x28, "40k, 100k & Every 100k" )	PORT_CONDITION("DSW1",0xc0,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "20k & 70k Only" )		PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "20k, 70k & Every 70k" )	PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "30k Only" )			PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "30k & 70k Only" )		PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "30k & 80k Only" )		PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x28, "30k, 100k & Every 80k" )	PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "30k & 100k Only" )		PORT_CONDITION("DSW1",0xc0,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "30k Only" )			PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, "40k Only" )			PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x20, "30k & 80k Only" )		PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, "30k, 80k & Every 80k" )	PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "30k & 100k Only" )		PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "40k & 120k Only" )		PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
+	PORT_DIPSETTING(    0x28, "40k, 100k & Every 100k" )	PORT_CONDITION("DSW1",0xc0,EQUALS,0x00)
 	PORT_DIPSETTING(    0x38, DEF_STR( None ) )
 	PORT_DIPNAME( 0xc0, 0x40, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW1:7,8")
 	PORT_DIPSETTING(    0xc0, "1" )
@@ -1228,20 +1228,20 @@
 	PORT_DIPSETTING(    0x01, "4" )
 	PORT_DIPSETTING(    0x00, "5" )
 	PORT_DIPNAME( 0x1c, 0x1c, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:3,4,5")
-	PORT_DIPSETTING(    0x08, "20k & 80k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "20k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x04, "30k Only" )			PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "30k & 60k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x1c, "30k & 100k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-//  PORT_DIPSETTING(    0x14, "30k 100k" )  // repeated         PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x0c, "30k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0x02,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(    0x0c, "20k & 80k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, "30k" )			PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x1c, "30k & 100k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-//  PORT_DIPSETTING(    0x14, "30k 100k" )  // repeated     PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x18, "40k & 80k Only" )		PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x04, "100k Only" )			PORT_CONDITION("DSW2",0x02,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "20k & 80k Only" )		PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "20k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x04, "30k Only" )			PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "30k & 60k Only" )		PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x1c, "30k & 100k Only" )		PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+//  PORT_DIPSETTING(    0x14, "30k 100k" )  // repeated         PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x0c, "30k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0x02,NOTEQUALS,0x00)
+	PORT_DIPSETTING(    0x0c, "20k & 80k Only" )		PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, "30k" )			PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_DIPSETTING(    0x1c, "30k & 100k Only" )		PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+//  PORT_DIPSETTING(    0x14, "30k 100k" )  // repeated     PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_DIPSETTING(    0x18, "40k & 80k Only" )		PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
+	PORT_DIPSETTING(    0x04, "100k Only" )			PORT_CONDITION("DSW2",0x02,EQUALS,0x00)
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
 	PORT_DIPNAME( 0xe0, 0xe0, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW2:6,7,8")
 	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
@@ -1308,20 +1308,20 @@
 	PORT_DIPSETTING(    0x05, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )
 	PORT_DIPNAME( 0x38, 0x38, DEF_STR( Bonus_Life ) )		PORT_DIPLOCATION("SW2:4,5,6")
-	PORT_DIPSETTING(    0x18, "20k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x30, "20k & 60k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x38, "20k & 70k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x10, "20k, 70k & Every 70k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x28, "20k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x08, "20k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x20, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_NOTEQUALS,0x80)
-	PORT_DIPSETTING(    0x20, "30k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x38, "30k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x30, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x10, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x28, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x18, "40k Only" )			PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x08, "40k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,PORTCOND_EQUALS,0x80)
+	PORT_DIPSETTING(    0x18, "20k Only" )			PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x30, "20k & 60k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x38, "20k & 70k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x10, "20k, 70k & Every 70k" )	PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x28, "20k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x08, "20k, 80k & Every 80k" )	PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x20, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,NOTEQUALS,0x80)
+	PORT_DIPSETTING(    0x20, "30k Only" )			PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x38, "30k & 80k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x30, "30k & 100k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x10, "30k, 100k & Every 100k" )	PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x28, "30k & 120k Only" )		PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x18, "40k Only" )			PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
+	PORT_DIPSETTING(    0x08, "40k, 120k & Every 120k" )	PORT_CONDITION("DSW2",0xc0,EQUALS,0x80)
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Lives ) )			PORT_DIPLOCATION("SW2:7,8")
 	PORT_DIPSETTING(    0x40, "1" )
@@ -1560,14 +1560,14 @@
 
 ***************************************************************************/
 
-static READ8_DEVICE_HANDLER( dipA_l )	{ return input_port_read(device->machine(), "DSW1"); }		// dips A
-static READ8_DEVICE_HANDLER( dipA_h )	{ return input_port_read(device->machine(), "DSW1") >> 4; }	// dips A
+static READ8_DEVICE_HANDLER( dipA_l )	{ return device->machine().root_device().ioport("DSW1")->read(); }		// dips A
+static READ8_DEVICE_HANDLER( dipA_h )	{ return device->machine().root_device().ioport("DSW1")->read() >> 4; }	// dips A
 
 static READ8_DEVICE_HANDLER( dipB_mux )	// dips B
 {
 	mappy_state *state = device->machine().driver_data<mappy_state>();
 
-	return input_port_read(device->machine(), "DSW2") >> (4 * state->m_mux);
+	return state->ioport("DSW2")->read() >> (4 * state->m_mux);
 }
 
 static READ8_DEVICE_HANDLER( dipB_muxi )	// dips B
@@ -1575,7 +1575,7 @@
 	mappy_state *state = device->machine().driver_data<mappy_state>();
 
 	// bits are interleaved in Phozon
-	return BITSWAP8(input_port_read(device->machine(), "DSW2"),6,4,2,0,7,5,3,1) >> (4 * state->m_mux);
+	return BITSWAP8(state->ioport("DSW2")->read(),6,4,2,0,7,5,3,1) >> (4 * state->m_mux);
 }
 
 static WRITE8_DEVICE_HANDLER( out_mux )
diff -Nru src-old/mame/drivers/marinedt.c src/mame/drivers/marinedt.c
--- src-old/mame/drivers/marinedt.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/marinedt.c	2012-05-03 11:00:08.000000000 +0200
@@ -163,7 +163,7 @@
 	//might need to be reversed for cocktail stuff
 
 	/* x/y multiplexed */
-	return input_port_read(machine(), ((m_pf & 0x08) >> 3) ? "TRACKY" : "TRACKX");
+	return ioport(((m_pf & 0x08) >> 3) ? "TRACKY" : "TRACKX")->read();
 }
 
 READ8_MEMBER(marinedt_state::marinedt_coll_r)
diff -Nru src-old/mame/drivers/matmania.c src/mame/drivers/matmania.c
--- src-old/mame/drivers/matmania.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/matmania.c	2012-05-03 11:00:08.000000000 +0200
@@ -176,7 +176,7 @@
 	PORT_DIPSETTING(   0x00, DEF_STR( Upright ) )		/* The default setting should be cocktail. */
 	PORT_DIPSETTING(   0x20, DEF_STR( Cocktail ) )
 	PORT_SERVICE_DIPLOC( 0x40, IP_ACTIVE_LOW, "SW1:7" )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )		/* Listed as always ON among DIPs in the manual */
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")		/* Listed as always ON among DIPs in the manual */
 
 	PORT_START("DSW2")
 	PORT_DIPNAME(0x03, 0x02, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
diff -Nru src-old/mame/drivers/maxaflex.c src/mame/drivers/maxaflex.c
--- src-old/mame/drivers/maxaflex.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/maxaflex.c	2012-05-03 11:00:08.000000000 +0200
@@ -75,7 +75,7 @@
 
 READ8_MEMBER(maxaflex_state::mcu_portA_r)
 {
-	m_portA_in = input_port_read(machine(), "dsw") | (input_port_read(machine(), "coin") << 4) | (input_port_read(machine(), "console") << 5);
+	m_portA_in = ioport("dsw")->read() | (ioport("coin")->read() << 4) | (ioport("console")->read() << 5);
 	return (m_portA_in & ~m_ddrA) | (m_portA_out & m_ddrA);
 }
 
@@ -371,12 +371,12 @@
 
 READ8_DEVICE_HANDLER(maxaflex_atari_pia_pa_r)
 {
-	return atari_input_disabled(device->machine()) ? 0xFF : input_port_read_safe(device->machine(), "djoy_0_1", 0);
+	return atari_input_disabled(device->machine()) ? 0xFF : device->machine().root_device().ioport("djoy_0_1")->read_safe(0);
 }
 
 READ8_DEVICE_HANDLER(maxaflex_atari_pia_pb_r)
 {
-	return atari_input_disabled(device->machine()) ? 0xFF : input_port_read_safe(device->machine(), "djoy_2_3", 0);
+	return atari_input_disabled(device->machine()) ? 0xFF : device->machine().root_device().ioport("djoy_2_3")->read_safe(0);
 }
 
 
diff -Nru src-old/mame/drivers/maygay1b.c src/mame/drivers/maygay1b.c
--- src-old/mame/drivers/maygay1b.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/maygay1b.c	2012-05-03 11:00:08.000000000 +0200
@@ -202,7 +202,7 @@
 			/* read sensor RAM */
 			case 0x40:
 				addr = chip->command & 0x07;
-				result = input_port_read(machine(),"SW1");
+				result = ioport("SW1")->read();
 				/* handle autoincrement */
 				if (chip->command & 0x10)
 					chip->command = (chip->command & 0xf0) | ((addr + 1) & 0x0f);
@@ -229,7 +229,7 @@
 	{
 		if ( chip->read_sensor )
 		{
-			result = input_port_read(machine(),portnames[chip->sense_address]);
+			result = ioport(portnames[chip->sense_address])->read();
 //          break
 		}
 		if ( chip->sense_auto_inc )
@@ -377,7 +377,7 @@
 		{
 			/* read sensor RAM */
 			case 0x40:
-				//result = ~input_port_read(machine,"DSW1");  /* DSW 1 - inverted! */
+				//result = ~ioport("DSW1")->read();  /* DSW 1 - inverted! */
 				break;
 
 			/* read display RAM */
diff -Nru src-old/mame/drivers/maygayv1.c src/mame/drivers/maygayv1.c
--- src-old/mame/drivers/maygayv1.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/maygayv1.c	2012-05-03 11:00:08.000000000 +0200
@@ -532,7 +532,7 @@
 			case 0x40:
 				addr = i8279.command & 0x07;
 
-				result = input_port_read(machine(), portnames[addr]);
+				result = ioport(portnames[addr])->read();
 
 				/* handle autoincrement */
 				if (i8279.command & 0x10)
@@ -730,7 +730,7 @@
 		case 1:
 		{
 			if ( !BIT(m_p3, 4) )
-				return (input_port_read(machine(), "REEL"));	// Reels???
+				return (ioport("REEL")->read());	// Reels???
 			else
 				return 0;
 		}
diff -Nru src-old/mame/drivers/mayumi.c src/mame/drivers/mayumi.c
--- src-old/mame/drivers/mayumi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mayumi.c	2012-05-03 11:00:08.000000000 +0200
@@ -124,7 +124,7 @@
 	for (i = 0; i < 5; i++)
 	{
 		if (BIT(p, i))
-			ret &= input_port_read(machine(), keynames[offset][i]);
+			ret &= ioport(keynames[offset][i])->read();
 	}
 
 	return ret;
diff -Nru src-old/mame/drivers/mazerbla.c src/mame/drivers/mazerbla.c
--- src-old/mame/drivers/mazerbla.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mazerbla.c	2012-05-03 11:00:08.000000000 +0200
@@ -889,7 +889,7 @@
 
 	UINT8 ret = 0;
 
-	ret = input_port_read(machine(), strobenames[m_bcd_7445]);
+	ret = ioport(strobenames[m_bcd_7445])->read();
 
 	return ret;
 }
diff -Nru src-old/mame/drivers/mcatadv.c src/mame/drivers/mcatadv.c
--- src-old/mame/drivers/mcatadv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mcatadv.c	2012-05-03 11:00:08.000000000 +0200
@@ -279,21 +279,21 @@
 	PORT_DIPSETTING(      0x0800, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
 	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
 	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
 	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x4000, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
-	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
 	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0800)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x0800, PORTCOND_EQUALS, 0x0000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0800)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x0800, EQUALS, 0x0000)
 
 	PORT_START("DSW2")
 	PORT_BIT( 0x00ff, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/mcr.c src/mame/drivers/mcr.c
--- src-old/mame/drivers/mcr.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/mcr.c	2012-05-03 11:00:08.000000000 +0200
@@ -337,9 +337,9 @@
 	/* game in cocktail mode, they don't work at all. So we fake-mux   */
 	/* the controls through player 1's ports */
 	if (mcr_cocktail_flip)
-		return input_port_read(machine(), "ssio:IP0") | 0x08;
+		return ioport("ssio:IP0")->read() | 0x08;
 	else
-		return ((input_port_read(machine(), "ssio:IP0") & ~0x14) | 0x08) | ((input_port_read(machine(), "ssio:IP0") & 0x08) >> 1) | ((input_port_read(machine(), "ssio:IP2") & 0x01) << 4);
+		return ((ioport("ssio:IP2")->read() & 0x01) << 4);
 }
 
 
@@ -347,9 +347,9 @@
 {
 	/*  same deal as above */
 	if (mcr_cocktail_flip)
-		return input_port_read(machine(), "ssio:IP1") | 0xf0;
+		return ioport("ssio:IP1")->read() | 0xf0;
 	else
-		return (input_port_read(machine(), "ssio:IP1") >> 4) | 0xf0;
+		return (ioport("ssio:IP1")->read() >> 4) | 0xf0;
 }
 
 
@@ -362,7 +362,7 @@
 
 READ8_MEMBER(mcr_state::kick_ip1_r)
 {
-	return (input_port_read(machine(), "DIAL2") << 4) & 0xf0;
+	return (ioport("DIAL2")->read() << 4) & 0xf0;
 }
 
 
@@ -382,18 +382,18 @@
 READ8_MEMBER(mcr_state::wacko_ip1_r)
 {
 	if (!input_mux)
-		return input_port_read(machine(), "ssio:IP1");
+		return ioport("ssio:IP1")->read();
 	else
-		return input_port_read(machine(), "ssio:IP1.ALT");
+		return ioport("ssio:IP1.ALT")->read();
 }
 
 
 READ8_MEMBER(mcr_state::wacko_ip2_r)
 {
 	if (!input_mux)
-		return input_port_read(machine(), "ssio:IP2");
+		return ioport("ssio:IP2")->read();
 	else
-		return input_port_read(machine(), "ssio:IP2.ALT");
+		return ioport("ssio:IP2.ALT")->read();
 }
 
 
@@ -406,7 +406,7 @@
 
 READ8_MEMBER(mcr_state::kroozr_ip1_r)
 {
-	int dial = input_port_read(machine(), "DIAL");
+	int dial = ioport("DIAL")->read();
 	return ((dial & 0x80) >> 1) | ((dial & 0x70) >> 4);
 }
 
@@ -629,15 +629,15 @@
 
 READ8_MEMBER(mcr_state::demoderb_ip1_r)
 {
-	return input_port_read(machine(), "ssio:IP1") |
-		(input_port_read(machine(), input_mux ? "ssio:IP1.ALT2" : "ssio:IP1.ALT1") << 2);
+	return ioport("ssio:IP1")->read() |
+		(ioport(input_mux ? "ssio:IP1.ALT2" : "ssio:IP1.ALT1")->read() << 2);
 }
 
 
 READ8_MEMBER(mcr_state::demoderb_ip2_r)
 {
-	return input_port_read(machine(), "ssio:IP2") |
-		(input_port_read(machine(), input_mux ? "ssio:IP2.ALT2" : "ssio:IP2.ALT1") << 2);
+	return ioport("ssio:IP2")->read() |
+		(ioport(input_mux ? "ssio:IP2.ALT2" : "ssio:IP2.ALT1")->read() << 2);
 }
 
 
diff -Nru src-old/mame/drivers/mcr3.c src/mame/drivers/mcr3.c
--- src-old/mame/drivers/mcr3.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/mcr3.c	2012-05-03 11:00:08.000000000 +0200
@@ -143,15 +143,15 @@
 
 READ8_MEMBER(mcr3_state::demoderm_ip1_r)
 {
-	return input_port_read(machine(), "MONO.IP1") |
-		(input_port_read(machine(), m_input_mux ? "MONO.IP1.ALT2" : "MONO.IP1.ALT1") << 2);
+	return ioport("MONO.IP1")->read() |
+		(ioport(m_input_mux ? "MONO.IP1.ALT2" : "MONO.IP1.ALT1")->read() << 2);
 }
 
 
 READ8_MEMBER(mcr3_state::demoderm_ip2_r)
 {
-	return input_port_read(machine(), "MONO.IP2") |
-		(input_port_read(machine(), m_input_mux ? "MONO.IP2.ALT2" : "MONO.IP2.ALT1") << 2);
+	return ioport("MONO.IP2")->read() |
+		(ioport(m_input_mux ? "MONO.IP2.ALT2" : "MONO.IP2.ALT1")->read() << 2);
 }
 
 
@@ -182,8 +182,8 @@
 READ8_MEMBER(mcr3_state::maxrpm_ip2_r)
 {
 	static const UINT8 shift_bits[5] = { 0x00, 0x05, 0x06, 0x01, 0x02 };
-	UINT8 start = input_port_read(machine(), "MONO.IP0");
-	UINT8 shift = input_port_read(machine(), "SHIFT");
+	UINT8 start = ioport("MONO.IP0")->read();
+	UINT8 shift = ioport("SHIFT")->read();
 
 	/* reset on a start */
 	if (!(start & 0x08))
@@ -256,7 +256,7 @@
 
 	/* when the read is toggled is when the ADC value is latched */
 	if (!(data & 0x80))
-		m_latched_input = input_port_read(machine(), inputs[m_maxrpm_adc_select]);
+		m_latched_input = ioport(inputs[m_maxrpm_adc_select])->read();
 
 	/* when both the write and the enable are low, it's a write to the ADC0844 */
 	/* unfortunately the behavior below doesn't match up with the inputs on the */
@@ -278,7 +278,7 @@
 
 READ8_MEMBER(mcr3_state::rampage_ip4_r)
 {
-	return input_port_read(machine(), "MONO.IP4") | (m_sounds_good->read(space,0) << 7);
+	return ioport("MONO.IP4")->read() | (m_sounds_good->read(space,0) << 7);
 }
 
 
@@ -301,7 +301,7 @@
 
 READ8_MEMBER(mcr3_state::powerdrv_ip2_r)
 {
-	return input_port_read(machine(), "MONO.IP2") | (m_sounds_good->read(space, 0) << 7);
+	return ioport("MONO.IP2")->read() | (m_sounds_good->read(space, 0) << 7);
 }
 
 
@@ -345,9 +345,9 @@
 
 READ8_MEMBER(mcr3_state::stargrds_ip0_r)
 {
-	UINT8 result = input_port_read(machine(), "MONO.IP0");
+	UINT8 result = ioport("MONO.IP0")->read();
 	if (m_input_mux)
-		result = (result & ~0x0a) | (input_port_read(machine(), "MONO.IP0.ALT") & 0x0a);
+		result = (result & ~0x0a) | (ioport("MONO.IP0.ALT")->read() & 0x0a);
 	return (result & ~0x10) | ((m_sounds_good->read(space, 0) << 4) & 0x10);
 }
 
@@ -388,14 +388,14 @@
 
 READ8_MEMBER(mcr3_state::spyhunt_ip1_r)
 {
-	return input_port_read(machine(), "ssio:IP1") | (m_chip_squeak_deluxe->read(space, 0) << 5);
+	return ioport("ssio:IP1")->read() | (m_chip_squeak_deluxe->read(space, 0) << 5);
 }
 
 
 READ8_MEMBER(mcr3_state::spyhunt_ip2_r)
 {
 	/* multiplexed steering wheel/gas pedal */
-	return input_port_read(machine(), m_input_mux ? "ssio:IP2.ALT" : "ssio:IP2");
+	return ioport(m_input_mux ? "ssio:IP2.ALT" : "ssio:IP2")->read();
 }
 
 
@@ -447,9 +447,9 @@
 {
 	/* multiplexed steering wheel/gas pedal */
 	if (m_input_mux)
-		return input_port_read(machine(), "ssio:IP2.ALT");
+		return ioport("ssio:IP2.ALT")->read();
 
-	return input_port_read(machine(), "ssio:IP2") + 5 * (machine().primary_screen->frame_number() & 1);
+	return ioport("ssio:IP2")->read() + 5 * (machine().primary_screen->frame_number() & 1);
 }
 
 
diff -Nru src-old/mame/drivers/mcr68.c src/mame/drivers/mcr68.c
--- src-old/mame/drivers/mcr68.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/mcr68.c	2012-05-03 11:00:08.000000000 +0200
@@ -69,8 +69,8 @@
 
 READ8_DEVICE_HANDLER( zwackery_port_2_r )
 {
-	int result = input_port_read(device->machine(), "IN2");
-	int wheel = input_port_read(device->machine(), "IN5");
+	int result = device->machine().root_device().ioport("IN2")->read();
+	int wheel = device->machine().root_device().ioport("IN5")->read();
 
 	return result | ((wheel >> 2) & 0x3e);
 }
@@ -131,9 +131,9 @@
 READ16_MEMBER(mcr68_state::spyhunt2_port_0_r)
 {
 	static const char *const portnames[] = { "AN1", "AN2", "AN3", "AN4" };
-	int result = input_port_read(machine(), "IN0");
+	int result = ioport("IN0")->read();
 	int which = (m_control_word >> 3) & 3;
-	int analog = input_port_read(machine(), portnames[which]);
+	int analog = ioport(portnames[which])->read();
 
 	return result | ((m_sounds_good->read(space, 0) & 1) << 5) | (analog << 8);
 }
@@ -141,7 +141,7 @@
 
 READ16_MEMBER(mcr68_state::spyhunt2_port_1_r)
 {
-	int result = input_port_read(machine(), "IN1");
+	int result = ioport("IN1")->read();
 	return result | ((m_turbo_chip_squeak->read(space, 0) & 1) << 7);
 }
 
@@ -194,10 +194,10 @@
 
 READ16_MEMBER(mcr68_state::archrivl_port_1_r)
 {
-	return (translate49[input_port_read(machine(), "49WAYY2") >> 4] << 12) |
-			(translate49[input_port_read(machine(), "49WAYX2") >> 4] << 8) |
-			(translate49[input_port_read(machine(), "49WAYY1") >> 4] << 4) |
-			(translate49[input_port_read(machine(), "49WAYX1") >> 4] << 0);
+	return (translate49[ioport("49WAYY2")->read() >> 4] << 12) |
+			(translate49[ioport("49WAYX2")->read() >> 4] << 8) |
+			(translate49[ioport("49WAYY1")->read() >> 4] << 4) |
+			(translate49[ioport("49WAYX1")->read() >> 4] << 0);
 }
 
 
@@ -256,18 +256,18 @@
 READ16_MEMBER(mcr68_state::pigskin_port_1_r)
 {
 	/* see archrivl_port_1_r for 49-way joystick description */
-	return input_port_read(machine(), "IN1") |
-			(translate49[input_port_read(machine(), "49WAYX1") >> 4] << 12) |
-			(translate49[input_port_read(machine(), "49WAYY1") >> 4] << 8);
+	return ioport("IN1")->read() |
+			(translate49[ioport("49WAYX1")->read() >> 4] << 12) |
+			(translate49[ioport("49WAYY1")->read() >> 4] << 8);
 }
 
 
 READ16_MEMBER(mcr68_state::pigskin_port_2_r)
 {
 	/* see archrivl_port_1_r for 49-way joystick description */
-	return input_port_read(machine(), "DSW") |
-			(translate49[input_port_read(machine(), "49WAYX2") >> 4] << 12) |
-			(translate49[input_port_read(machine(), "49WAYY2") >> 4] << 8);
+	return ioport("DSW")->read() |
+			(translate49[ioport("49WAYX2")->read() >> 4] << 12) |
+			(translate49[ioport("49WAYY2")->read() >> 4] << 8);
 }
 
 
@@ -280,9 +280,9 @@
 
 READ16_MEMBER(mcr68_state::trisport_port_1_r)
 {
-	int xaxis = (INT8)input_port_read(machine(), "AN1");
-	int yaxis = (INT8)input_port_read(machine(), "AN2");
-	int result = input_port_read(machine(), "IN1");
+	int xaxis = (INT8)ioport("AN1")->read();
+	int yaxis = (INT8)ioport("AN2")->read();
+	int result = ioport("IN1")->read();
 
 	result |= (xaxis & 0x3c) << 6;
 	result |= (yaxis & 0x3c) << 10;
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/mediagx.c	2012-05-03 11:00:08.000000000 +0200
@@ -572,21 +572,21 @@
 
 	if (ACCESSING_BITS_8_15)
 	{
-		UINT8 nibble = m_parallel_latched;//(input_port_read_safe(machine(), m_portnames[m_parallel_pointer / 3], 0) >> (4 * (m_parallel_pointer % 3))) & 15;
+		UINT8 nibble = m_parallel_latched;//(ioport(m_portnames[m_parallel_pointer / 3])->read_safe(0) >> (4 * (m_parallel_pointer % 3))) & 15;
 		r |= ((~nibble & 0x08) << 12) | ((nibble & 0x07) << 11);
 		logerror("%08X:parallel_port_r()\n", cpu_get_pc(&space.device()));
 #if 0
 		if (m_controls_data == 0x18)
 		{
-			r |= input_port_read(machine(), "IN0") << 8;
+			r |= ioport("IN0")->read() << 8;
 		}
 		else if (m_controls_data == 0x60)
 		{
-			r |= input_port_read(machine(), "IN1") << 8;
+			r |= ioport("IN1")->read() << 8;
 		}
 		else if (m_controls_data == 0xff || m_controls_data == 0x50)
 		{
-			r |= input_port_read(machine(), "IN2") << 8;
+			r |= ioport("IN2")->read() << 8;
 		}
 
 		//r |= m_control_read << 8;
@@ -625,7 +625,7 @@
 
 		logerror("%08X:", cpu_get_pc(&space.device()));
 
-		m_parallel_latched = (input_port_read_safe(machine(), portnames[m_parallel_pointer / 3], 0) >> (4 * (m_parallel_pointer % 3))) & 15;
+		m_parallel_latched = (ioport(portnames[m_parallel_pointer / 3])->read_safe(0) >> (4 * (m_parallel_pointer % 3))) & 15;
 		//parallel_pointer++;
 		//logerror("[%02X] Advance pointer to %d\n", data, parallel_pointer);
 		switch (data & 0xfc)
diff -Nru src-old/mame/drivers/megadrvb.c src/mame/drivers/megadrvb.c
--- src-old/mame/drivers/megadrvb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/megadrvb.c	2012-05-03 11:00:08.000000000 +0200
@@ -281,7 +281,7 @@
 	md_boot_state *state = space->machine().driver_data<md_boot_state>();
 	if (cpu_get_pc(&space->device())==0x1b2a56)
 	{
-		state->m_aladmdb_mcu_port = input_port_read(space->machine(), "MCU");
+		state->m_aladmdb_mcu_port = state->ioport("MCU")->read();
 
 		if (state->m_aladmdb_mcu_port & 0x100)
 			return ((state->m_aladmdb_mcu_port & 0x0f) | 0x100); // coin inserted, calculate the number of coins
@@ -289,7 +289,7 @@
 			return (0x100); //MCU status, needed if you fall into a pitfall
 	}
 	if (cpu_get_pc(&space->device())==0x1b2a72) return 0x0000;
-	if (cpu_get_pc(&space->device())==0x1b2d24) return (input_port_read(space->machine(), "MCU") & 0x00f0) | 0x1200;    // difficulty
+	if (cpu_get_pc(&space->device())==0x1b2d24) return (space->machine().root_device().ioport("MCU")->read() & 0x00f0) | 0x1200;    // difficulty
 	if (cpu_get_pc(&space->device())==0x1b2d4e) return 0x0000;
 
 	logerror("aladbl_r : %06x\n",cpu_get_pc(&space->device()));
@@ -300,19 +300,19 @@
 static READ16_HANDLER( mk3mdb_dsw_r )
 {
 	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
-	return input_port_read(space->machine(), dswname[offset]);
+	return space->machine().root_device().ioport(dswname[offset])->read();
 }
 
 static READ16_HANDLER( ssf2mdb_dsw_r )
 {
 	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
-	return input_port_read(space->machine(), dswname[offset]);
+	return space->machine().root_device().ioport(dswname[offset])->read();
 }
 
 static READ16_HANDLER( srmdb_dsw_r )
 {
 	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
-	return input_port_read(space->machine(), dswname[offset]);
+	return space->machine().root_device().ioport(dswname[offset])->read();
 }
 
 static READ16_HANDLER( topshoot_200051_r )
diff -Nru src-old/mame/drivers/megasys1.c src/mame/drivers/megasys1.c
--- src-old/mame/drivers/megasys1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/megasys1.c	2012-05-03 11:00:08.000000000 +0200
@@ -237,11 +237,11 @@
 
 	switch (i)
 	{
-			case 0 :	return input_port_read(machine(), "SYSTEM");
-			case 1 :	return input_port_read(machine(), "P1");
-			case 2 :	return input_port_read(machine(), "P2");
-			case 3 :	return input_port_read(machine(), "DSW1");
-			case 4 :	return input_port_read(machine(), "DSW2");
+			case 0 :	return ioport("SYSTEM")->read();
+			case 1 :	return ioport("P1")->read();
+			case 2 :	return ioport("P2")->read();
+			case 3 :	return ioport("DSW1")->read();
+			case 4 :	return ioport("DSW2")->read();
 			default	 :	return 0x0006;
 	}
 }
@@ -1367,8 +1367,8 @@
 	switch (m_protection_val)
 	{
 		case 0x02:	return 0x03;
-		case 0x51:	return input_port_read(machine(), "P1");
-		case 0x52:	return input_port_read(machine(), "P2");
+		case 0x51:	return ioport("P1")->read();
+		case 0x52:	return ioport("P2")->read();
 		default:	return m_protection_val;
 	}
 }
@@ -3801,7 +3801,7 @@
 		case 0x04/2:
 		case 0x06/2:
 		case 0x08/2:
-		case 0x0a/2: res = input_port_read(machine(), in_names[offset-1]); break;
+		case 0x0a/2: res = ioport(in_names[offset-1])->read(); break;
 	}
 
 	return res;
@@ -4017,7 +4017,7 @@
 		case 0x04/2:
 		case 0x06/2:
 		case 0x08/2:
-		case 0x0a/2: res = input_port_read(machine(), in_names[offset-1]); break;
+		case 0x0a/2: res = ioport(in_names[offset-1])->read(); break;
 	}
 
 	return res;
diff -Nru src-old/mame/drivers/megatech.c src/mame/drivers/megatech.c
--- src-old/mame/drivers/megatech.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/megatech.c	2012-05-03 11:00:08.000000000 +0200
@@ -222,7 +222,7 @@
 	UINT8* game_region;
 
 	sprintf(tempname, "game%d", param);
-	game_region = machine.root_device().memregion(tempname)->base();
+	game_region = state->memregion(tempname)->base();
 
 	memcpy(state->memregion("maincpu")->base(), game_region, 0x400000);
 
diff -Nru src-old/mame/drivers/meijinsn.c src/mame/drivers/meijinsn.c
--- src-old/mame/drivers/meijinsn.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/meijinsn.c	2012-05-03 11:00:08.000000000 +0200
@@ -112,7 +112,7 @@
 	switch (offset)
 	{
 		case 0: /* Dipswitch 2 */
-			m_shared_ram[0] = (source & 0xff00) | input_port_read(machine(), "DSW");
+			m_shared_ram[0] = (source & 0xff00) | ioport("DSW")->read();
 			return 0;
 
 		case 0x22: /* Coin value */
@@ -123,16 +123,16 @@
 
 			m_credits = 0;
 
-			if ((input_port_read(machine(), "COINS") & 0x3) == 3)
+			if ((ioport("COINS")->read() & 0x3) == 3)
 				m_mcu_latch = 0;
 
-			if ((input_port_read(machine(), "COINS") & 0x1) == 0 && !m_mcu_latch)
+			if ((ioport("COINS")->read() & 0x1) == 0 && !m_mcu_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | 0x22;	// coinA
 				m_shared_ram[0x22] = (source & 0xff00) | 0x00;
 				m_mcu_latch = 1;
 
-				m_coinvalue = (~input_port_read(machine(), "DSW")>>3) & 1;
+				m_coinvalue = (~ioport("DSW")->read()>>3) & 1;
 
 				m_deposits1++;
 				if (m_deposits1 == coinage1[m_coinvalue][0])
@@ -143,13 +143,13 @@
 				else
 					m_credits = 0;
 			}
-			else if ((input_port_read(machine(), "COINS") & 0x2) == 0 && !m_mcu_latch)
+			else if ((ioport("COINS")->read() & 0x2) == 0 && !m_mcu_latch)
 			{
 				m_shared_ram[0x29] = (source & 0xff00) | 0x22;	// coinA
 				m_shared_ram[0x22] = (source & 0xff00) | 0x00;
 				m_mcu_latch = 1;
 
-				m_coinvalue = (~input_port_read(machine(), "DSW") >> 3) & 1;
+				m_coinvalue = (~ioport("DSW")->read() >> 3) & 1;
 
 				m_deposits2++;
 				if (m_deposits2 == coinage2[m_coinvalue][0])
diff -Nru src-old/mame/drivers/merit.c src/mame/drivers/merit.c
--- src-old/mame/drivers/merit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/merit.c	2012-05-03 11:00:08.000000000 +0200
@@ -220,8 +220,8 @@
 	UINT16 x = 0;
 	int rlen;
 
-	gfx[0] = device->machine().root_device().memregion("gfx1")->base();
-	gfx[1] = device->machine().root_device().memregion("gfx2")->base();
+	gfx[0] = state->memregion("gfx1")->base();
+	gfx[1] = state->memregion("gfx2")->base();
 	rlen = state->memregion("gfx2")->bytes();
 
 	//ma = ma ^ 0x7ff;
diff -Nru src-old/mame/drivers/meritm.c src/mame/drivers/meritm.c
--- src-old/mame/drivers/meritm.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/meritm.c	2012-05-03 11:00:08.000000000 +0200
@@ -1016,7 +1016,7 @@
 	state->m_ram = auto_alloc_array(machine, UINT8,  0x8000 );
 	machine.device<nvram_device>("nvram")->set_base(state->m_ram, 0x8000);
 	memset(state->m_ram, 0x00, 0x8000);
-	state->membank("bank1")->configure_entries(0, 128, machine.root_device().memregion("maincpu")->base(), 0x8000);
+	state->membank("bank1")->configure_entries(0, 128, state->memregion("maincpu")->base(), 0x8000);
 	state->membank("bank2")->configure_entries(0, 128, state->memregion("maincpu")->base(), 0x8000);
 	state->membank("bank3")->configure_entries(0, 4, state->m_ram, 0x2000);
 	state->m_bank = 0xff;
diff -Nru src-old/mame/drivers/metlclsh.c src/mame/drivers/metlclsh.c
--- src-old/mame/drivers/metlclsh.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/metlclsh.c	2012-05-03 11:00:08.000000000 +0200
@@ -198,7 +198,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )	// cpu2 will clr c040 on startup forever
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_IMPULSE(1) PORT_CHANGED_MEMBER(DEVICE_SELF, metlclsh_state,coin_inserted, 0)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/metro.c src/mame/drivers/metro.c
--- src-old/mame/drivers/metro.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/metro.c	2012-05-03 11:00:08.000000000 +0200
@@ -839,9 +839,9 @@
 /* Really weird way of mapping 3 DSWs */
 READ16_MEMBER(metro_state::balcube_dsw_r)
 {
-	UINT16 dsw1 = input_port_read(machine(), "DSW0") >> 0;
-	UINT16 dsw2 = input_port_read(machine(), "DSW0") >> 8;
-	UINT16 dsw3 = input_port_read(machine(), "IN2");
+	UINT16 dsw1 = ioport("DSW0")->read() >> 0;
+	UINT16 dsw2 = ioport("DSW0")->read() >> 8;
+	UINT16 dsw3 = ioport("IN2")->read();
 
 	switch (offset * 2)
 	{
@@ -1293,11 +1293,11 @@
 {
 	UINT16 input_sel = (*m_input_sel) ^ 0x3e;
 	// Bit 0 ??
-	if (input_sel & 0x0002)	return input_port_read(machine(), "KEY0");
-	if (input_sel & 0x0004)	return input_port_read(machine(), "KEY1");
-	if (input_sel & 0x0008)	return input_port_read(machine(), "KEY2");
-	if (input_sel & 0x0010)	return input_port_read(machine(), "KEY3");
-	if (input_sel & 0x0020)	return input_port_read(machine(), "KEY4");
+	if (input_sel & 0x0002)	return ioport("KEY0")->read();
+	if (input_sel & 0x0004)	return ioport("KEY1")->read();
+	if (input_sel & 0x0008)	return ioport("KEY2")->read();
+	if (input_sel & 0x0010)	return ioport("KEY3")->read();
+	if (input_sel & 0x0020)	return ioport("KEY4")->read();
 	return 0xffff;
 }
 
@@ -5995,7 +5995,7 @@
 {
 	metro_state *state = machine.driver_data<metro_state>();
 
-	const size_t len = machine.root_device().memregion("gfx1")->bytes();
+	const size_t len = state->memregion("gfx1")->bytes();
 	UINT8 *src       = state->memregion("gfx1")->base();
 	UINT8 *end       = src + len;
 
diff -Nru src-old/mame/drivers/mexico86.c src/mame/drivers/mexico86.c
--- src-old/mame/drivers/mexico86.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mexico86.c	2012-05-03 11:00:08.000000000 +0200
@@ -452,7 +452,7 @@
 
 	/*TODO: check the PCB and see how the halt / reset lines are connected. */
 	if (machine.device("sub") != NULL)
-		cputag_set_input_line(machine, "sub", INPUT_LINE_RESET, (input_port_read(machine, "DSW1") & 0x80) ? ASSERT_LINE : CLEAR_LINE);
+		cputag_set_input_line(machine, "sub", INPUT_LINE_RESET, (state->ioport("DSW1")->read() & 0x80) ? ASSERT_LINE : CLEAR_LINE);
 
 	state->m_port_a_in = 0;
 	state->m_port_a_out = 0;
diff -Nru src-old/mame/drivers/meyc8080.c src/mame/drivers/meyc8080.c
--- src-old/mame/drivers/meyc8080.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/meyc8080.c	2012-05-03 11:00:08.000000000 +0200
@@ -44,8 +44,8 @@
 
 ***********************************************************
 
-  To initialize battery RAM, go into testmode (F1 -> F2),
-  and then press the Reset Counters button.
+  To initialize battery RAM, go into Meter Read mode (F1 -> 9),
+  and then press the Meter Read + Reset buttons (9 + 0).
 
   If a game is not turned off properly, eg. exiting MAME
   in mid-game, it may run faulty on the next boot.
@@ -83,34 +83,17 @@
 };
 
 
-#define NUM_PENS	(8)
-
-
 /*************************************
  *
  *  Video system
  *
  *************************************/
 
-static void get_pens(pen_t *pens)
-{
-	offs_t i;
-
-	for (i = 0; i < NUM_PENS; i++)
-	{
-		pens[i] = MAKE_RGB(pal1bit(i >> 2), pal1bit(i >> 1), pal1bit(i >> 0));
-	}
-}
-
-
 static SCREEN_UPDATE_RGB32( meyc8080 )
 {
 	meyc8080_state *state = screen.machine().driver_data<meyc8080_state>();
-	pen_t pens[NUM_PENS];
 	offs_t offs;
 
-	get_pens(pens);
-
 	for (offs = 0; offs < state->m_videoram_0.bytes(); offs++)
 	{
 		int i;
@@ -130,11 +113,7 @@
 
 		for (i = 0; i < 8; i++)
 		{
-			UINT8 color = ((data_r >> 5) & 0x04) |
-						  ((data_g >> 6) & 0x02) |
-						  ((data_b >> 7) & 0x01);
-
-			bitmap.pix32(y, x) = pens[color];
+			bitmap.pix32(y, x) = MAKE_RGB(pal1bit(data_r >> 7), pal1bit(data_g >> 7), pal1bit(data_b >> 7));
 
 			data_r = data_r << 1;
 			data_g = data_g << 1;
@@ -344,7 +323,7 @@
 
 static INPUT_PORTS_START( wldarrow )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
 	PORT_DIPNAME( 0x04, 0x00, "Monitor" )
 	PORT_DIPSETTING(    0x00, "Color" )
@@ -377,18 +356,16 @@
 	PORT_DIPNAME( 0x40, 0x00, "Bit Switch 7" )		PORT_DIPLOCATION("BSW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "Bit Switch 8" )		PORT_DIPLOCATION("BSW:8")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "BSW:8" )
 
 	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_CODE(KEYCODE_C) PORT_NAME("Stop Reel 3")	/* Skill Stop only? */
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_CODE(KEYCODE_X) PORT_NAME("Stop Reel 2")	/* Skill Stop only? */
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_CODE(KEYCODE_Z) PORT_NAME("Stop Reel 1")	/* Skill Stop only? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_CODE(KEYCODE_M) PORT_NAME("Start")
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_CODE(KEYCODE_N) PORT_NAME("Bet")
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Reset Counters")
-	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SLOT_STOP3 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SLOT_STOP2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SLOT_STOP1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_BET )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Meter Reset")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Meter Read")
 	PORT_DIPNAME( 0x80, 0x80, "Night Switch" ) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -407,7 +384,7 @@
 
 static INPUT_PORTS_START( mdrawpkr )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -429,7 +406,7 @@
 	PORT_DIPNAME( 0x08, 0x00, "Bit Switch 4" )		PORT_DIPLOCATION("BSW:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, "Bit Switch 5" )		PORT_DIPLOCATION("BSW:5")
+	PORT_DIPNAME( 0x10, 0x00, "Bit Switch 5" )		PORT_DIPLOCATION("BSW:5") // no coinage sw
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
 	PORT_DIPNAME( 0x20, 0x00, "Bit Switch 6" )		PORT_DIPLOCATION("BSW:6")
@@ -438,9 +415,7 @@
 	PORT_DIPNAME( 0x40, 0x00, "Bit Switch 7" )		PORT_DIPLOCATION("BSW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "Bit Switch 8" )		PORT_DIPLOCATION("BSW:8")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "BSW:8" )
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_POKER_CANCEL )
@@ -448,8 +423,8 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_BET )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_DEAL )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 )	PORT_NAME("Reset Counters")
-	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Meter Reset")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Meter Read")
 	PORT_DIPNAME( 0x80, 0x80, "Night Switch" ) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -468,7 +443,7 @@
 
 static INPUT_PORTS_START( mdrawpkra )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -490,18 +465,16 @@
 	PORT_DIPNAME( 0x08, 0x00, "Bit Switch 4" )		PORT_DIPLOCATION("BSW:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, "Bit Switch 5" )		PORT_DIPLOCATION("BSW:5")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) )	PORT_DIPLOCATION("BSW:5")
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_5C ) )
 	PORT_DIPNAME( 0x20, 0x00, "Bit Switch 6" )		PORT_DIPLOCATION("BSW:6")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_DIPNAME( 0x40, 0x00, "Bit Switch 7" )		PORT_DIPLOCATION("BSW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "Bit Switch 8" )		PORT_DIPLOCATION("BSW:8")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "BSW:8" )
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_POKER_CANCEL )
@@ -509,8 +482,8 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_BET )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_DEAL )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 )	PORT_NAME("Reset Counters")
-	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Meter Reset")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Meter Read")
 	PORT_DIPNAME( 0x80, 0x80, "Night Switch" ) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -529,7 +502,7 @@
 
 static INPUT_PORTS_START( casbjack )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -551,18 +524,16 @@
 	PORT_DIPNAME( 0x08, 0x00, "Bit Switch 4" )		PORT_DIPLOCATION("BSW:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, "Bit Switch 5" )		PORT_DIPLOCATION("BSW:5")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) )	PORT_DIPLOCATION("BSW:5")
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_5C ) )
 	PORT_DIPNAME( 0x20, 0x00, "Bit Switch 6" )		PORT_DIPLOCATION("BSW:6")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_DIPNAME( 0x40, 0x00, "Bit Switch 7" )		PORT_DIPLOCATION("BSW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "Bit Switch 8" )		PORT_DIPLOCATION("BSW:8")
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
+	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "BSW:8" )
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_CODE(KEYCODE_B) PORT_NAME("Split")
@@ -570,8 +541,8 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_CODE(KEYCODE_Z) PORT_NAME("Bet")
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_CODE(KEYCODE_X) PORT_NAME("Hit")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Reset Counters")
-	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Meter Reset")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Meter Read")
 	PORT_DIPNAME( 0x80, 0x80, "Night Switch" ) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -637,11 +608,7 @@
 
 /*
 
-  Meyco Games, unknown PCB, 1981
-
-  NOTE TO WHOEVER IS MAME DEVELOPER FOR THIS DRIVER:  This is obviously part of a multiple board set.
-  The other PCB board(s) were unfound.  If/when the game is identified,
-  could you please let me know what it is?
+  Meyco Games, 1981
 
   Dumper notes:
 
@@ -675,7 +642,7 @@
     |------------------------------------------------------------------------------|
 
   * = 8 pin connector
-  & = 50 pin connector (assuming to other half of PCB)
+  & = 50 pin connector (meant for edge connector or to another pcb?)
 
 */
 
@@ -689,6 +656,7 @@
 	ROM_LOAD( "tms2516.k3", 0x2800, 0x0800, CRC(30904dc8) SHA1(c82276aa0eb8f48d136ad8c15dd309c9b880c294) )
 ROM_END
 
+
 /*
 
   Board silkscreened:
@@ -750,8 +718,8 @@
  *
  *************************************/
 
-/*     YEAR  NAME       PARENT    MACHINE   INPUT      INIT  ROT    COMPANY              FULLNAME                                    FLAGS                                      LAYOUT  */
-GAMEL( 1982, wldarrow,  0,        meyc8080, wldarrow,  0,    ROT0, "Meyco Games, Inc.", "Wild Arrow (color, Standard V4.8)",         GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_wldarrow  ) // B&W version not dumped yet
-GAMEL( 1984, mdrawpkr,  0,        meyc8080, mdrawpkr,  0,    ROT0, "Meyco Games, Inc.", "Draw Poker - Joker's Wild (Standard)",      GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_mdrawpkr  ) // year not shown, but it is in mdrawpkra
-GAMEL( 1984, mdrawpkra, mdrawpkr, meyc8080, mdrawpkra, 0,    ROT0, "Meyco Games, Inc.", "Draw Poker - Joker's Wild (02-11)",         GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_mdrawpkr  )
-GAMEL( 1983, casbjack,  0,        meyc8080, casbjack,  0,    ROT0, "Meyco Games, Inc.", "Casino Black Jack (color, Standard 00-05)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_meybjack  ) // B&W version not dumped yet
+/*    YEAR  NAME       PARENT    MACHINE   INPUT      INIT  ROT    COMPANY              FULLNAME                                    FLAGS                                      LAYOUT  */
+GAMEL(1982, wldarrow,  0,        meyc8080, wldarrow,  0,    ROT0, "Meyco Games, Inc.", "Wild Arrow (color, Standard V4.8)",         GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_wldarrow ) // B&W version not dumped yet
+GAMEL(1984, mdrawpkr,  0,        meyc8080, mdrawpkr,  0,    ROT0, "Meyco Games, Inc.", "Draw Poker - Joker's Wild (Standard)",      GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_mdrawpkr ) // year not shown, but it is in mdrawpkra
+GAMEL(1984, mdrawpkra, mdrawpkr, meyc8080, mdrawpkra, 0,    ROT0, "Meyco Games, Inc.", "Draw Poker - Joker's Wild (02-11)",         GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_mdrawpkr )
+GAMEL(1983, casbjack,  0,        meyc8080, casbjack,  0,    ROT0, "Meyco Games, Inc.", "Casino Black Jack (color, Standard 00-05)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE, layout_meybjack ) // B&W version not dumped yet
diff -Nru src-old/mame/drivers/meyc8088.c src/mame/drivers/meyc8088.c
--- src-old/mame/drivers/meyc8088.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/meyc8088.c	2012-05-03 11:00:08.000000000 +0200
@@ -10,12 +10,28 @@
   also thanks to Darrell Hal Smith, Kevin Mullins
 
 
+  To initialize battery RAM, go into Meter Read mode (F1 -> 9),
+  and then press the Meter Read + Reset buttons (9 + 0).
+
+  If a game is not turned off properly, eg. exiting MAME
+  in mid-game, it may run faulty on the next boot.
+  Enable the Night Switch to prevent this.
+
+
+  TODO:
+  - coincounters/hopper
+
 ****************************************************************/
 
 #include "emu.h"
 #include "cpu/i86/i86.h"
 #include "machine/i8155.h"
+#include "machine/nvram.h"
 #include "sound/dac.h"
+#include "video/resnet.h"
+
+#include "gldarrow.lh"
+
 
 class meyc8088_state : public driver_device
 {
@@ -23,11 +39,13 @@
 	meyc8088_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag) ,
 		m_maincpu(*this,"maincpu"),
-		m_vram(*this, "vram")
+		m_vram(*this, "vram"),
+		m_heartbeat(*this, "heartbeat")
 	{ }
 
 	required_device<cpu_device> m_maincpu;
 	required_shared_ptr<UINT8> m_vram;
+	required_device<timer_device> m_heartbeat;
 
 	UINT8 m_status;
 	UINT8 m_common;
@@ -46,26 +64,94 @@
 
 ***************************************************************************/
 
+/***************************************************************************
+
+  Convert the color PROMs into a more useable format.
+
+  The palette PROM is connected to the RGB output this way:
+  (even and uneven pins were switched around in the schematics)
+
+  bit 7 -- N/C
+        -- 820 ohm resistor  -- GREEN
+        --                   -- GREEN
+        -- 820 ohm resistor  -- BLUE
+        --                   -- BLUE
+        -- 820 ohm resistor  -- RED
+        --                   -- RED
+  bit 0 -- N/C
+
+  plus 330 ohm pullup resistors on all lines
+
+***************************************************************************/
+
+static const res_net_decode_info meyc8088_decode_info =
+{
+	1,		// there may be two proms needed to construct color
+	0, 31,	// start/end
+	//  R,   G,   B,
+	{   0,   0,   0, },		// offsets
+	{   1,   5,   3, },		// shifts
+	{0x03,0x03,0x03, }	    // masks
+};
+
+static const res_net_info meyc8088_net_info =
+{
+	RES_NET_VCC_5V | RES_NET_VBIAS_5V | RES_NET_VIN_OPEN_COL,
+	{
+		{ RES_NET_AMP_NONE, 330, 0, 2, { 1, 820 } },
+		{ RES_NET_AMP_NONE, 330, 0, 2, { 1, 820 } },
+		{ RES_NET_AMP_NONE, 330, 0, 2, { 1, 820 } }
+	}
+};
+
+PALETTE_INIT( meyc8088 )
+{
+	const UINT8 *color_prom = machine.root_device().memregion("proms")->base();
+	rgb_t *rgb;
+
+	rgb = compute_res_net_all(machine, color_prom, &meyc8088_decode_info, &meyc8088_net_info);
+	palette_set_colors(machine, 0, rgb, 32);
+	auto_free(machine, rgb);
+}
+
 static SCREEN_UPDATE_IND16( meyc8088 )
 {
 	meyc8088_state *state = screen.machine().driver_data<meyc8088_state>();
+	UINT8 v[5];
+	v[4] = state->m_status << 2 & 0x10; // video5: color prom d4
 
-	for (int y = 0; y < 512; y++)
+	if (~state->m_status & 2)
 	{
-		for (int x = 0; x < 64; x++)
-		{
-			UINT8 data = state->m_vram[y*64+x];
-			for (int i = 0; i < 8; i++)
-			{
-				bitmap.pix16(y, x << 3 | i) = (data << i & 0x80) ? 1 : 0;
-			}
+		// screen off
+		bitmap.fill(v[4]);
+		return 0;
+	}
+
+	for (offs_t offs = 0x800; offs < 0x4000; offs+=2)
+	{
+		UINT8 y = (offs-0x800) >> 6;
+		UINT8 x = (offs-0x800) << 2;
+
+		v[0] = state->m_vram[offs|0x0000]; // video1: color prom d0
+		v[1] = state->m_vram[offs|0x0001]; // video2: color prom d1
+		v[2] = state->m_vram[offs|0x4000]; // video3: color prom d2
+		v[3] = state->m_vram[offs|0x4001]; // video4: color prom d3
 
-		}
+		for (int i = 0; i < 8; i++)
+			bitmap.pix16(y, x | i) = ((v[0] << i) >> 7 & 1) | ((v[1] << i) >> 6 & 2) | ((v[2] << i) >> 5 & 4) | ((v[3] << i) >> 4 & 8) | v[4];
 	}
 
 	return 0;
 }
 
+static SCREEN_VBLANK( meyc8088 )
+{
+	meyc8088_state *state = screen.machine().driver_data<meyc8088_state>();
+
+	// INTR on LC255 (pulses at start and end of vblank), INTA hardwired to $20
+	generic_pulse_irq_line_and_vector(state->m_maincpu, 0, 0x20, 1);
+}
+
 
 /***************************************************************************
 
@@ -73,9 +159,17 @@
 
 ***************************************************************************/
 
+TIMER_DEVICE_CALLBACK( heartbeat_callback )
+{
+	meyc8088_state *state = timer.machine().driver_data<meyc8088_state>();
+	state->m_status |= 0x20;
+}
+
 WRITE8_MEMBER(meyc8088_state::drive_w)
 {
+	// drivers go into high-impedance state ~100ms after write (LS374 /OC)
 	m_status &= ~0x20;
+	m_heartbeat->adjust(attotime::from_msec(100));
 
 	// d0-d3: DC counter drivers
 	// d4-d7: AC motor drivers
@@ -107,33 +201,61 @@
 
 
 static ADDRESS_MAP_START( meyc8088_map, AS_PROGRAM, 8, meyc8088_state )
-	AM_RANGE(0x00000, 0x007ff) AM_RAM
+	AM_RANGE(0x00000, 0x007ff) AM_RAM AM_SHARE("nvram")
 	AM_RANGE(0x70000, 0x77fff) AM_RAM AM_SHARE("vram")
 	AM_RANGE(0xb0000, 0xb00ff) AM_DEVREADWRITE("i8155_2", i8155_device, memory_r, memory_w)
 	AM_RANGE(0xb0800, 0xb0807) AM_DEVREADWRITE("i8155_2", i8155_device, io_r, io_w)
 	AM_RANGE(0xb1000, 0xb10ff) AM_DEVREADWRITE("i8155_1", i8155_device, memory_r, memory_w)
 	AM_RANGE(0xb1800, 0xb1807) AM_DEVREADWRITE("i8155_1", i8155_device, io_r, io_w)
 	AM_RANGE(0xb2000, 0xb2000) AM_WRITE(drive_w)
-//  AM_RANGE(0xb3000, 0xb3000) AM_NOP // 8251A, debug related
-//  AM_RANGE(0xb3800, 0xb3800) AM_NOP // "
+	AM_RANGE(0xb3000, 0xb3000) AM_NOP // i8251A data (debug related, unpopulated on sold boards)
+	AM_RANGE(0xb3800, 0xb3800) AM_NOP // "
 	AM_RANGE(0xb4000, 0xb4000) AM_READWRITE(screen_flip_r, screen_flip_w)
 	AM_RANGE(0xb5000, 0xb5000) AM_READWRITE(video5_flip_r, video5_flip_w)
 	AM_RANGE(0xf8000, 0xfffff) AM_ROM
 ADDRESS_MAP_END
 
 
+static READ8_DEVICE_HANDLER(meyc8088_input_r)
+{
+	meyc8088_state *state = device->machine().driver_data<meyc8088_state>();
+	UINT8 ret = 0xff;
+
+	// multiplexed switch inputs
+	if (~state->m_common & 1) ret &= state->ioport("C0")->read_safe(0); // bit switches
+	if (~state->m_common & 2) ret &= state->ioport("C1")->read_safe(0); // control switches
+	if (~state->m_common & 4) ret &= state->ioport("C2")->read_safe(0); // light switches
+	if (~state->m_common & 8) ret &= state->ioport("C3")->read_safe(0); // light switches
+
+	return ret;
+}
+
+static READ8_DEVICE_HANDLER(meyc8088_status_r)
+{
+	meyc8088_state *state = device->machine().driver_data<meyc8088_state>();
+
+	// d0: /CR2
+	// d1: screen on
+	// d2: video5
+	// d3: N/C
+	// d4: battery ok
+	// d5: /drive on
+	return (state->m_status & 0x27) | 0x18;
+}
+
+
 static WRITE8_DEVICE_HANDLER(meyc8088_lights1_w)
 {
 	// lite 1-8
 	for (int i = 0; i < 8; i++)
-		output_set_lamp_value(i, data >> i & 1);
+		output_set_lamp_value(i, ~data >> i & 1);
 }
 
 static WRITE8_DEVICE_HANDLER(meyc8088_lights2_w)
 {
 	// lite 9-16
 	for (int i = 0; i < 8; i++)
-		output_set_lamp_value(i + 8, data >> i & 1);
+		output_set_lamp_value(i + 8, ~data >> i & 1);
 }
 
 static WRITE8_DEVICE_HANDLER(meyc8088_common_w)
@@ -148,47 +270,25 @@
 
 	// d2-d5: /common
 	state->m_common = data >> 2 & 0xf;
-
-	logerror("i8155 Port C: %02X\n", data);
 }
 
-static WRITE_LINE_DEVICE_HANDLER(meyc8088_i8155_1_timer_out)
+static WRITE_LINE_DEVICE_HANDLER(meyc8088_sound_out)
 {
-	// clock 8251A
-	//logerror("Timer 1 out %d\n", state);
+	dac_signed_w(device->machine().device("dac"), 0, state ? 0x7f : 0);
 }
 
-static WRITE_LINE_DEVICE_HANDLER(meyc8088_i8155_2_timer_out)
-{
-	// sound dac
-	//logerror("Timer 2 out %d\n", state);
-}
-
-
-static READ8_DEVICE_HANDLER(meyc8088_status_r)
-{
-	meyc8088_state *state = device->machine().driver_data<meyc8088_state>();
-
-	// d0: /CR2
-	// d1: screen on
-	// d2: video5
-	// d3: N/C
-	// d4: battery ok
-	// d5: /drive on
-	return (state->m_status & 7) | 0x18;
-}
 
 static const i8155_interface i8155_intf[2] =
 {
 	{
 		// all ports set to input
-		DEVCB_INPUT_PORT("IN0"),
+		DEVCB_HANDLER(meyc8088_input_r),
 		DEVCB_NULL,
-		DEVCB_INPUT_PORT("IN1"),
+		DEVCB_INPUT_PORT("SW"), // filtered switch inputs
 		DEVCB_NULL,
 		DEVCB_HANDLER(meyc8088_status_r),
 		DEVCB_NULL,
-		DEVCB_LINE(meyc8088_i8155_1_timer_out)
+		DEVCB_NULL // i8251A trigger txc/rxc (debug related, unpopulated on sold boards)
 	},
 	{
 		// all ports set to output
@@ -198,7 +298,7 @@
 		DEVCB_HANDLER(meyc8088_lights1_w),
 		DEVCB_NULL,
 		DEVCB_HANDLER(meyc8088_common_w),
-		DEVCB_LINE(meyc8088_i8155_2_timer_out)
+		DEVCB_LINE(meyc8088_sound_out)
 	}
 };
 
@@ -210,81 +310,54 @@
 ***************************************************************************/
 
 static INPUT_PORTS_START( gldarrow )
-	PORT_START("IN0")
-	PORT_DIPNAME( 0x01, 0x01, "IN0 1" )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, "IN0 2" )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, "IN0 3" )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, "IN0 4" )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, "IN0 5" )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, "IN0 6" )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, "IN0 7" )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "IN0 8" )
+	PORT_START("SW")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(1) // coin4
+	PORT_BIT( 0x78, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN ) // hopper coin switch?
+
+	PORT_START("C0")
+	PORT_DIPNAME( 0x03, 0x00, "Payout Percentage" )		PORT_DIPLOCATION("BSW:1,2")
+	PORT_DIPSETTING(    0x03, "85%")
+	PORT_DIPSETTING(    0x02, "88%")
+	PORT_DIPSETTING(    0x01, "90%")
+	PORT_DIPSETTING(    0x00, "93%")
+	PORT_DIPNAME( 0x04, 0x00, "Bit Switch 3" )			PORT_DIPLOCATION("BSW:3")
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x00, "Bonus Award" )			PORT_DIPLOCATION("BSW:4")
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) )		PORT_DIPLOCATION("BSW:5")
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_5C ) )
+	PORT_DIPNAME( 0x20, 0x00, "Bit Switch 6" )			PORT_DIPLOCATION("BSW:6")
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, "Bit Switch 7" )			PORT_DIPLOCATION("BSW:7")
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "BSW:8" )
+
+	PORT_START("C1")
+	PORT_BIT( 0x1f, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE2 ) PORT_NAME("Meter Reset")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Meter Read")
+	PORT_DIPNAME( 0x80, 0x80, "Night Switch" ) PORT_CODE(KEYCODE_F1) PORT_TOGGLE
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
-	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
-	PORT_DIPNAME( 0x02, 0x02, "IN1 2" )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, "IN1 3" )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, "IN1 4" )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, "IN1 5" )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, "IN1 6" )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, "IN1 7" )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "IN1 8" )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_START("C2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_GAMBLE_BET )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SLOT_STOP3 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SLOT_STOP2 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SLOT_STOP1 )
+	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
 
-	PORT_START("IN2")
-	PORT_DIPNAME( 0x01, 0x01, "IN2 1" )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, "IN2 2" )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, "IN2 3" )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, "IN2 4" )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, "IN2 5" )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, "IN2 6" )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, "IN2 7" )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "IN2 8" )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_START("C3")
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
 
@@ -294,32 +367,33 @@
 
 ***************************************************************************/
 
-static INTERRUPT_GEN( meyc8088_irq )
-{
-	// INTR on LC255, INTA hardwired to $20
-	device_set_input_line_and_vector(device, 0, HOLD_LINE, 0x20);
-}
-
 static MACHINE_CONFIG_START( meyc8088, meyc8088_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", I8088, XTAL_15MHz / 3)
+	MCFG_CPU_ADD("maincpu", I8088, (XTAL_15MHz / 3) * 0.95) // NOTE: underclocked to prevent errors on diagnostics, MAME i8088 cycle timing is probably inaccurate
 	MCFG_CPU_PROGRAM_MAP(meyc8088_map)
-	MCFG_CPU_VBLANK_INT("screen", meyc8088_irq)
 
-	MCFG_I8155_ADD("i8155_1", XTAL_15MHz / 3, i8155_intf[0])
-	MCFG_I8155_ADD("i8155_2", XTAL_15MHz / 3, i8155_intf[1])
+	MCFG_I8155_ADD("i8155_1", XTAL_15MHz / (3*1), i8155_intf[0])
+	MCFG_I8155_ADD("i8155_2", XTAL_15MHz / (3*32), i8155_intf[1])
+
+	MCFG_NVRAM_ADD_0FILL("nvram")
+
+	MCFG_TIMER_ADD("heartbeat", heartbeat_callback)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_REFRESH_RATE(60)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500))
-	MCFG_SCREEN_SIZE(512,512)
-	MCFG_SCREEN_VISIBLE_AREA(0, 512-1, 0, 512-1)
+	MCFG_SCREEN_RAW_PARAMS(XTAL_15MHz/3, 320, 0, 256, 261, 0, 224)
 	MCFG_SCREEN_UPDATE_STATIC(meyc8088)
+	MCFG_SCREEN_VBLANK_STATIC(meyc8088)
+
+	MCFG_PALETTE_LENGTH(32)
+	MCFG_PALETTE_INIT(meyc8088)
 
-	MCFG_PALETTE_LENGTH(8)
+	/* sound hardware */
+	MCFG_SPEAKER_STANDARD_MONO("mono")
 
+	MCFG_SOUND_ADD("dac", DAC, 0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
 
@@ -330,8 +404,8 @@
 	ROM_LOAD( "1.12h",   0x0fe000, 0x002000, CRC(71bd0e39) SHA1(15345f5726cd33ecb1b2da05f2852b6cc3ac7747) )
 
 	ROM_REGION( 0x20, "proms", 0 )
-	ROM_LOAD( "prom.2c", 0x00, 0x20, NO_DUMP ) // M3-7602-5 color prom
+	ROM_LOAD( "prom.2c", 0x00, 0x20, CRC(2839bb14) SHA1(c9acdb3ae00c2f9344aedaf77c0f4e860a3184fc) ) // M3-7602-5 color prom
 ROM_END
 
 
-GAME( 1984, gldarrow, 0,        meyc8088, gldarrow, 0, ROT0,  "Meyco Games, Inc.", "Golden Arrow", GAME_NOT_WORKING | GAME_NO_SOUND )
+GAMEL(1984, gldarrow, 0,        meyc8088, gldarrow, 0, ROT0,  "Meyco Games, Inc.", "Golden Arrow (Standard G8-03)", 0, layout_gldarrow )
diff -Nru src-old/mame/drivers/mgolf.c src/mame/drivers/mgolf.c
--- src-old/mame/drivers/mgolf.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/mgolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -91,7 +91,7 @@
 static void update_plunger( running_machine &machine )
 {
 	mgolf_state *state = machine.driver_data<mgolf_state>();
-	UINT8 val = input_port_read(machine, "BUTTON");
+	UINT8 val = state->ioport("BUTTON")->read();
 
 	if (state->m_prev != val)
 	{
@@ -143,13 +143,13 @@
 
 READ8_MEMBER(mgolf_state::mgolf_dial_r)
 {
-	UINT8 val = input_port_read(machine(), "41");
+	UINT8 val = ioport("41")->read();
 
-	if ((input_port_read(machine(), "DIAL") + 0x00) & 0x20)
+	if ((ioport("DIAL")->read() + 0x00) & 0x20)
 	{
 		val |= 0x01;
 	}
-	if ((input_port_read(machine(), "DIAL") + 0x10) & 0x20)
+	if ((ioport("DIAL")->read() + 0x10) & 0x20)
 	{
 		val |= 0x02;
 	}
@@ -162,7 +162,7 @@
 {
 	double plunger = calc_plunger_pos(machine()); /* see Video Pinball */
 
-	UINT8 val = input_port_read(machine(), "61");
+	UINT8 val = ioport("61")->read();
 
 	if (plunger >= 0.000 && plunger <= 0.001)
 	{
@@ -232,7 +232,7 @@
 	PORT_BIT ( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) /* DIAL A */
 	PORT_BIT ( 0x02, IP_ACTIVE_HIGH, IPT_SPECIAL ) /* DIAL B */
 	PORT_BIT ( 0x04, IP_ACTIVE_HIGH, IPT_UNUSED )
-	PORT_BIT ( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT ( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("60")
 	PORT_SERVICE( 0x10, IP_ACTIVE_LOW )
diff -Nru src-old/mame/drivers/midas.c src/mame/drivers/midas.c
--- src-old/mame/drivers/midas.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/midas.c	2012-05-03 11:00:08.000000000 +0200
@@ -299,10 +299,10 @@
 
 READ16_MEMBER(midas_state::hammer_sensor_r)
 {
-	if (input_port_read(machine(), "HAMMER") & 0x80)
+	if (ioport("HAMMER")->read() & 0x80)
 		return 0xffff;
 
-	return (input_port_read(machine(), "SENSORY") << 8) | input_port_read(machine(), "SENSORX");
+	return (ioport("SENSORY")->read() << 8) | ioport("SENSORX")->read();
 }
 
 WRITE16_MEMBER(midas_state::hammer_coin_w)
diff -Nru src-old/mame/drivers/midvunit.c src/mame/drivers/midvunit.c
--- src-old/mame/drivers/midvunit.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/midvunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -89,7 +89,7 @@
 
 READ32_MEMBER(midvunit_state::port0_r)
 {
-	UINT16 val = input_port_read(machine(), "IN0");
+	UINT16 val = ioport("IN0")->read();
 	UINT16 diff = val ^ m_last_port0;
 
 	/* make sure the shift controls are mutually exclusive */
@@ -143,7 +143,7 @@
 		int which = (data >> m_adc_shift) - 4;
 		if (which < 0 || which > 2)
 			logerror("adc_w: unexpected which = %02X\n", which + 4);
-		m_adc_data = input_port_read_safe(machine(), adcnames[which], 0);
+		m_adc_data = ioport(adcnames[which])->read_safe(0);
 		machine().scheduler().timer_set(attotime::from_msec(1), FUNC(adc_ready));
 	}
 	else
@@ -296,7 +296,7 @@
 READ32_MEMBER(midvunit_state::crusnwld_serial_status_r)
 {
 	int status = midway_serial_pic_status_r();
-	return (input_port_read(machine(), "991030") & 0x7fff7fff) | (status << 31) | (status << 15);
+	return (ioport("991030")->read() & 0x7fff7fff) | (status << 31) | (status << 15);
 }
 
 
@@ -359,7 +359,7 @@
 READ32_MEMBER(midvunit_state::offroadc_serial_status_r)
 {
 	int status = midway_serial_pic2_status_r(&space);
-	return (input_port_read(machine(), "991030")  & 0x7fff7fff) | (status << 31) | (status << 15);
+	return (ioport("991030")->read()  & 0x7fff7fff) | (status << 31) | (status << 15);
 }
 
 
diff -Nru src-old/mame/drivers/midzeus.c src/mame/drivers/midzeus.c
--- src-old/mame/drivers/midzeus.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/midzeus.c	2012-05-03 11:00:08.000000000 +0200
@@ -425,7 +425,7 @@
 	static const UINT8 translate49[7] = { 0x8, 0xc, 0xe, 0xf, 0x3, 0x1, 0x0 };
 	const char *namex = (const char *)param;
 	const char *namey = namex + strlen(namex) + 1;
-	return (translate49[input_port_read(machine(), namey) >> 4] << 4) | translate49[input_port_read(machine(), namex) >> 4];
+	return (translate49[ioport(namey)->read() >> 4] << 4) | translate49[ioport(namex)->read() >> 4];
 }
 
 
@@ -438,7 +438,7 @@
 
 CUSTOM_INPUT_MEMBER(midzeus_state::keypad_r)
 {
-	UINT32 bits = input_port_read(machine(), (const char *)param);
+	UINT32 bits = ioport((const char *)param)->read();
 	UINT8 select = keypad_select;
 	while ((select & 1) != 0)
 	{
@@ -461,7 +461,7 @@
 	static const char * const tags[] = { "ANALOG0", "ANALOG1", "ANALOG2", "ANALOG3" };
 	if (offset < 8 || offset > 11)
 		logerror("%06X:analog_r(%X)\n", cpu_get_pc(&space.device()), offset);
-	return input_port_read(machine(), tags[offset & 3]);
+	return ioport(tags[offset & 3])->read();
 }
 
 
@@ -527,8 +527,8 @@
 				{ "GUNX1", "GUNY1" },
 				{ "GUNX2", "GUNY2" }
 			};
-			gun_x[player] = input_port_read(machine(), names[player][0]) * visarea.width() / 255 + visarea.min_x + BEAM_XOFFS;
-			gun_y[player] = input_port_read(machine(), names[player][1]) * visarea.height() / 255 + visarea.min_y;
+			gun_x[player] = ioport(names[player][0])->read() * visarea.width() / 255 + visarea.min_x + BEAM_XOFFS;
+			gun_y[player] = ioport(names[player][1])->read() * visarea.height() / 255 + visarea.min_y;
 			gun_timer[player]->adjust(machine().primary_screen->time_until_pos(MAX(0, gun_y[player] - BEAM_DY), MAX(0, gun_x[player] - BEAM_DX)), player);
 		}
 	}
diff -Nru src-old/mame/drivers/mirage.c src/mame/drivers/mirage.c
--- src-old/mame/drivers/mirage.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/mirage.c	2012-05-03 11:00:08.000000000 +0200
@@ -111,11 +111,11 @@
 {
 	switch (m_mux_data & 0x1f)
 	{
-		case 0x01: return input_port_read(machine(), "KEY0");
-		case 0x02: return input_port_read(machine(), "KEY1");
-		case 0x04: return input_port_read(machine(), "KEY2");
-		case 0x08: return input_port_read(machine(), "KEY3");
-		case 0x10: return input_port_read(machine(), "KEY4");
+		case 0x01: return ioport("KEY0")->read();
+		case 0x02: return ioport("KEY1")->read();
+		case 0x04: return ioport("KEY2")->read();
+		case 0x08: return ioport("KEY3")->read();
+		case 0x10: return ioport("KEY4")->read();
 	}
 
 	return 0xffff;
@@ -166,7 +166,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_SERVICE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(      0x0020, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/mirax.c src/mame/drivers/mirax.c
--- src-old/mame/drivers/mirax.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mirax.c	2012-05-03 11:00:08.000000000 +0200
@@ -535,7 +535,7 @@
 static DRIVER_INIT( mirax )
 {
 	mirax_state *state = machine.driver_data<mirax_state>();
-	UINT8 *DATA = machine.root_device().memregion("data_code")->base();
+	UINT8 *DATA = state->memregion("data_code")->base();
 	UINT8 *ROM = state->memregion("maincpu")->base();
 	int i;
 
diff -Nru src-old/mame/drivers/missile.c src/mame/drivers/missile.c
--- src-old/mame/drivers/missile.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/missile.c	2012-05-03 11:00:08.000000000 +0200
@@ -798,21 +798,21 @@
 		if (m_ctrld)	/* trackball */
 		{
 			if (!m_flipscreen)
-			    result = ((input_port_read(machine(), "TRACK0_Y") << 4) & 0xf0) | (input_port_read(machine(), "TRACK0_X") & 0x0f);
+				result = ((ioport("TRACK0_Y")->read() << 4) & 0xf0) | (ioport("TRACK0_X")->read() & 0x0f);
 			else
-			    result = ((input_port_read(machine(), "TRACK1_Y") << 4) & 0xf0) | (input_port_read(machine(), "TRACK1_X") & 0x0f);
+				result = ((ioport("TRACK1_Y")->read() << 4) & 0xf0) | (ioport("TRACK1_X")->read() & 0x0f);
 		}
 		else	/* buttons */
-			result = input_port_read(machine(), "IN0");
+			result = ioport("IN0")->read();
 	}
 
 	/* IN1 */
 	else if (offset < 0x4a00)
-		result = input_port_read(machine(), "IN1");
+		result = ioport("IN1")->read();
 
 	/* IN2 */
 	else if (offset < 0x4b00)
-		result = input_port_read(machine(), "R10");
+		result = ioport("R10")->read();
 
 	/* anything else */
 	else
diff -Nru src-old/mame/drivers/mitchell.c src/mame/drivers/mitchell.c
--- src-old/mame/drivers/mitchell.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mitchell.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,7 +120,7 @@
         otherwise music doesn't work.
     */
 
-	return (input_port_read(machine(), "SYS0") & 0xfe) | (m_irq_source & 1);
+	return (ioport("SYS0")->read() & 0xfe) | (m_irq_source & 1);
 }
 
 static WRITE8_DEVICE_HANDLER( eeprom_cs_w )
@@ -166,7 +166,7 @@
 
 	if (m_dial_selected)
 	{
-		int delta = (input_port_read(machine(), dialnames[offset]) - m_dial[offset]) & 0xff;
+		int delta = (ioport(dialnames[offset])->read() - m_dial[offset]) & 0xff;
 
 		if (delta & 0x80)
 		{
@@ -194,7 +194,7 @@
 	}
 	else
 	{
-		int res = input_port_read(machine(), portnames[offset]) & 0xf7;
+		int res = ioport(portnames[offset])->read() & 0xf7;
 
 		if (m_dir[offset])
 			res |= 0x08;
@@ -209,8 +209,8 @@
 	if (data == 0x08)
 	{
 		/* reset the dial counters */
-		m_dial[0] = input_port_read(machine(), "DIAL1");
-		m_dial[1] = input_port_read(machine(), "DIAL2");
+		m_dial[0] = ioport("DIAL1")->read();
+		m_dial[1] = ioport("DIAL2")->read();
 	}
 	else if (data == 0x80)
 		m_dial_selected = 0;
@@ -231,7 +231,7 @@
 	for (i = 0; i < 5; i++)
 	{
 		if (m_keymatrix & (0x80 >> i))
-			return input_port_read(machine(), keynames[offset][i]);
+			return ioport(keynames[offset][i])->read();
 	}
 
 	return 0xff;
@@ -251,21 +251,21 @@
 	{
 		case 0:
 		default:
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 		case 1:		/* Mahjong games */
 			if (offset)
 				return mahjong_input_r(space, offset - 1);
 			else
-				return input_port_read(machine(), "IN0");
+				return ioport("IN0")->read();
 			break;
 		case 2:		/* Block Block - dial control */
 			if (offset)
 				return block_input_r(space, offset - 1);
 			else
-				return input_port_read(machine(), "IN0");
+				return ioport("IN0")->read();
 			break;
 		case 3:		/* Super Pang - simulate START 1 press to initialize EEPROM */
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 	}
 }
 
@@ -420,7 +420,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* USED - handled in port5_r */
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
@@ -670,7 +670,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* USED - handled in port5_r */
 	PORT_SERVICE_NO_TOGGLE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
@@ -721,7 +721,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_SERVICE_NO_TOGGLE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 
@@ -837,7 +837,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* USED - handled in port5_r */
 	PORT_SERVICE_NO_TOGGLE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
@@ -877,7 +877,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* USED - handled in port5_r */
 	PORT_SERVICE_NO_TOGGLE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
@@ -919,7 +919,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* USED - handled in port5_r */
 	PORT_SERVICE_NO_TOGGLE( 0x02, IP_ACTIVE_LOW )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x70, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 
diff -Nru src-old/mame/drivers/mjkjidai.c src/mame/drivers/mjkjidai.c
--- src-old/mame/drivers/mjkjidai.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mjkjidai.c	2012-05-03 11:00:08.000000000 +0200
@@ -124,12 +124,12 @@
 	{
 		if (~m_keyb & (1 << i))
 		{
-			res = input_port_read(machine(), keynames[i]) & 0x3f;
+			res = ioport(keynames[i])->read() & 0x3f;
 			break;
 		}
 	}
 
-	res |= (input_port_read(machine(), "IN3") & 0xc0);
+	res |= (ioport("IN3")->read() & 0xc0);
 
 	if (m_nvram_init_count)
 	{
diff -Nru src-old/mame/drivers/mjsister.c src/mame/drivers/mjsister.c
--- src-old/mame/drivers/mjsister.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mjsister.c	2012-05-03 11:00:08.000000000 +0200
@@ -266,7 +266,7 @@
 	for (i = 0; i < 6; i++)
 	{
 		if (BIT(p, i))
-			ret |= input_port_read(machine(), keynames[i]);
+			ret |= ioport(keynames[i])->read();
 	}
 
 	return ret;
@@ -449,7 +449,7 @@
 static MACHINE_START( mjsister )
 {
 	mjsister_state *state = machine.driver_data<mjsister_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 4, &ROM[0x10000], 0x8000);
 
diff -Nru src-old/mame/drivers/mlanding.c src/mame/drivers/mlanding.c
--- src-old/mame/drivers/mlanding.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mlanding.c	2012-05-03 11:00:08.000000000 +0200
@@ -250,7 +250,7 @@
     */
 // multiplexed? or just overriden?
 
-	int retval = (m_dma_active << 15) | (input_port_read(machine(), "DSW") & 0x7fff);
+	int retval = (m_dma_active << 15) | (ioport("DSW")->read() & 0x7fff);
 	return retval;
 }
 
@@ -365,17 +365,17 @@
 
 READ16_MEMBER(mlanding_state::ml_analog1_lsb_r)
 {
-	return input_port_read(machine(), "STICKX") & 0xff;
+	return ioport("STICKX")->read() & 0xff;
 }
 
 READ16_MEMBER(mlanding_state::ml_analog2_lsb_r)
 {
-	return input_port_read(machine(), "STICKY") & 0xff;
+	return ioport("STICKY")->read() & 0xff;
 }
 
 READ16_MEMBER(mlanding_state::ml_analog3_lsb_r)
 {
-	return (input_port_read(machine(), "STICKZ") & 0xff);
+	return (ioport("STICKZ")->read() & 0xff);
 }
 
 /*
@@ -401,7 +401,7 @@
 /* high bits of analog inputs + "limiters"/ADC converters. */
 READ16_MEMBER(mlanding_state::ml_analog1_msb_r)
 {
-	return ((input_port_read(machine(), "STICKY") & 0xf00)>>8) | (input_port_read(machine(), "IN2") & 0xf0);
+	return ((ioport("STICKY")->read() & 0xf00)>>8) | (ioport("IN2")->read() & 0xf0);
 }
 
 READ16_MEMBER(mlanding_state::ml_analog2_msb_r)
@@ -409,8 +409,8 @@
 	UINT8 res;
 	UINT16 y_adc,x_adc;
 
-	y_adc = input_port_read(machine(), "STICKY");
-	x_adc = input_port_read(machine(), "STICKZ");
+	y_adc = ioport("STICKY")->read();
+	x_adc = ioport("STICKZ")->read();
 
 	res = 0;
 
@@ -426,7 +426,7 @@
 
 //  popmessage("%04x %04x",x_adc,y_adc);
 
-	return ((input_port_read(machine(), "STICKZ") & 0xf00)>>8) | res;
+	return ((ioport("STICKZ")->read() & 0xf00)>>8) | res;
 }
 
 READ16_MEMBER(mlanding_state::ml_analog3_msb_r)
@@ -434,8 +434,8 @@
 	UINT8 z_adc,res;
 	UINT16 x_adc;
 
-	z_adc = input_port_read(machine(), "STICKX");
-	x_adc = input_port_read(machine(), "STICKZ");
+	z_adc = ioport("STICKX")->read();
+	x_adc = ioport("STICKZ")->read();
 
 	res = 0;
 
@@ -449,7 +449,7 @@
 	if(x_adc & 0x800 || x_adc == 0)
 		res|= 0x10;
 
-	return ((input_port_read(machine(), "STICKX") & 0xf00)>>8) | res;
+	return ((ioport("STICKX")->read() & 0xf00)>>8) | res;
 }
 
 WRITE16_MEMBER(mlanding_state::ml_nmi_to_sound_w)
diff -Nru src-old/mame/drivers/model1.c src/mame/drivers/model1.c
--- src-old/mame/drivers/model1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/model1.c	2012-05-03 11:00:08.000000000 +0200
@@ -640,13 +640,13 @@
 	static const char *const inputnames[] = { "IN0", "IN1", "IN2" };
 
 	if(offset < 0x8)
-		return input_port_read_safe(machine(), analognames[offset], 0x00);
+		return ioport(analognames[offset])->read_safe(0x00);
 
 	if(offset < 0x10)
 	{
 		offset -= 0x8;
 		if(offset < 3)
-			return input_port_read(machine(), inputnames[offset]);
+			return ioport(inputnames[offset])->read();
 		return 0xff;
 	}
 
diff -Nru src-old/mame/drivers/model2.c src/mame/drivers/model2.c
--- src-old/mame/drivers/model2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/model2.c	2012-05-03 11:00:08.000000000 +0200
@@ -356,8 +356,8 @@
 static MACHINE_RESET(model2_scsp)
 {
 	model2_state *state = machine.driver_data<model2_state>();
-	state->membank("bank4")->set_base(machine.root_device().memregion("scsp")->base() + 0x200000);
-	state->membank("bank5")->set_base(machine.root_device().memregion("scsp")->base() + 0x600000);
+	state->membank("bank4")->set_base(state->memregion("scsp")->base() + 0x200000);
+	state->membank("bank5")->set_base(state->memregion("scsp")->base() + 0x600000);
 
 	// copy the 68k vector table into RAM
 	memcpy(state->m_soundram, state->memregion("audiocpu")->base() + 0x80000, 16);
@@ -454,7 +454,7 @@
 
 CUSTOM_INPUT_MEMBER(model2_state::_1c00000_r)
 {
-	UINT32 ret = input_port_read(machine(), "IN0");
+	UINT32 ret = ioport("IN0")->read();
 
 	if(m_ctrlmode == 0)
 	{
@@ -473,7 +473,7 @@
 	if(m_analog_channel < 4)
 	{
 		static const char *const ports[] = { "ANA0", "ANA1", "ANA2", "ANA3" };
-		iptval = input_port_read_safe(machine(), ports[m_analog_channel], 0);
+		iptval = ioport(ports[m_analog_channel])->read_safe(0);
 		++m_analog_channel;
 	}
 	return iptval;
diff -Nru src-old/mame/drivers/model3.c src/mame/drivers/model3.c
--- src-old/mame/drivers/model3.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/model3.c	2012-05-03 11:00:08.000000000 +0200
@@ -1277,10 +1277,10 @@
 	state->m_sound_irq_enable = 0;
 	state->m_sound_timer->adjust(attotime::never);
 
-	state->membank("bank1")->set_base(machine.root_device().memregion( "user1" )->base() + 0x800000 ); /* banked CROM */
+	state->membank("bank1")->set_base(state->memregion( "user1" )->base() + 0x800000 ); /* banked CROM */
 
-	state->membank("bank4")->set_base(machine.root_device().memregion("samples")->base() + 0x200000);
-	state->membank("bank5")->set_base(machine.root_device().memregion("samples")->base() + 0x600000);
+	state->membank("bank4")->set_base(state->memregion("samples")->base() + 0x200000);
+	state->membank("bank5")->set_base(state->memregion("samples")->base() + 0x600000);
 
 	// copy the 68k vector table into RAM
 	memcpy(state->m_soundram, state->memregion("audiocpu")->base()+0x80000, 16);
@@ -1337,11 +1337,11 @@
 			{
 				if(m_controls_bank & 0x1)
 				{
-					return (input_port_read(machine(), "IN1")) << 24;
+					return (ioport("IN1")->read()) << 24;
 				}
 				else
 				{
-					return (input_port_read(machine(), "IN0")) << 24;
+					return (ioport("IN0")->read()) << 24;
 				}
 			}
 			break;
@@ -1349,11 +1349,11 @@
 		case 1:
 			if (ACCESSING_BITS_56_63)
 			{
-				return (UINT64)input_port_read(machine(), "IN2") << 56;
+				return (UINT64)ioport("IN2")->read() << 56;
 			}
 			else if (ACCESSING_BITS_24_31)
 			{
-				return input_port_read(machine(), "IN3") << 24;
+				return ioport("IN3")->read() << 24;
 			}
 			break;
 
@@ -1388,7 +1388,7 @@
 			if (ACCESSING_BITS_24_31)		/* ADC Data read */
 			{
 				static const char *const adcnames[] = { "AN0", "AN1", "AN2", "AN3", "AN4", "AN5", "AN6", "AN7" };
-				UINT8 adc_data = input_port_read_safe(machine(), adcnames[m_adc_channel], 0);
+				UINT8 adc_data = ioport(adcnames[m_adc_channel])->read_safe(0);
 				m_adc_channel++;
 				m_adc_channel &= 0x7;
 				return (UINT64)adc_data << 24;
@@ -1441,32 +1441,32 @@
 						switch(m_lightgun_reg_sel)		/* read lightrun register */
 						{
 							case 0:		/* player 1 gun X-position, lower 8-bits */
-								m_serial_fifo2 = input_port_read(machine(), "LIGHT0_Y") & 0xff;
+								m_serial_fifo2 = ioport("LIGHT0_Y")->read() & 0xff;
 								break;
 							case 1:		/* player 1 gun X-position, upper 2-bits */
-								m_serial_fifo2 = (input_port_read(machine(), "LIGHT0_Y") >> 8) & 0x3;
+								m_serial_fifo2 = (ioport("LIGHT0_Y")->read() >> 8) & 0x3;
 								break;
 							case 2:		/* player 1 gun Y-position, lower 8-bits */
-								m_serial_fifo2 = input_port_read(machine(), "LIGHT0_X") & 0xff;
+								m_serial_fifo2 = ioport("LIGHT0_X")->read() & 0xff;
 								break;
 							case 3:		/* player 1 gun Y-position, upper 2-bits */
-								m_serial_fifo2 = (input_port_read(machine(), "LIGHT0_X") >> 8) & 0x3;
+								m_serial_fifo2 = (ioport("LIGHT0_X")->read() >> 8) & 0x3;
 								break;
 							case 4:		/* player 2 gun X-position, lower 8-bits */
-								m_serial_fifo2 = input_port_read(machine(), "LIGHT1_Y") & 0xff;
+								m_serial_fifo2 = ioport("LIGHT1_Y")->read() & 0xff;
 								break;
 							case 5:		/* player 2 gun X-position, upper 2-bits */
-								m_serial_fifo2 = (input_port_read(machine(), "LIGHT1_Y") >> 8) & 0x3;
+								m_serial_fifo2 = (ioport("LIGHT1_Y")->read() >> 8) & 0x3;
 								break;
 							case 6:		/* player 2 gun Y-position, lower 8-bits */
-								m_serial_fifo2 = input_port_read(machine(), "LIGHT1_X") & 0xff;
+								m_serial_fifo2 = ioport("LIGHT1_X")->read() & 0xff;
 								break;
 							case 7:		/* player 2 gun Y-position, upper 2-bits */
-								m_serial_fifo2 = (input_port_read(machine(), "LIGHT1_X") >> 8) & 0x3;
+								m_serial_fifo2 = (ioport("LIGHT1_X")->read() >> 8) & 0x3;
 								break;
 							case 8:		/* gun offscreen (bit set = gun offscreen, bit clear = gun on screen) */
 								m_serial_fifo2 = 0;	/* bit 0 = player 1, bit 1 = player 2 */
-								if(input_port_read(machine(), "OFFSCREEN") & 0x1) {
+								if(ioport("OFFSCREEN")->read() & 0x1) {
 									m_serial_fifo2 |= 0x01;
 								}
 								break;
@@ -5302,8 +5302,8 @@
 	model3_state *state = machine.driver_data<model3_state>();
 	int start;
 	int i,j,x;
-	UINT16 *vrom1 = (UINT16*)machine.root_device().memregion("user3")->base();
-	UINT16 *vrom2 = (UINT16*)machine.root_device().memregion("user4")->base();
+	UINT16 *vrom1 = (UINT16*)state->memregion("user3")->base();
+	UINT16 *vrom2 = (UINT16*)state->memregion("user4")->base();
 	int vrom_length = state->memregion("user3")->bytes();
 	UINT16 *vrom;
 
diff -Nru src-old/mame/drivers/moo.c src/mame/drivers/moo.c
--- src-old/mame/drivers/moo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/moo.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,7 +82,7 @@
 
 	COMBINE_DATA(&m_cur_control2);
 
-	input_port_write(machine(), "EEPROMOUT", m_cur_control2, 0xff);
+	ioport("EEPROMOUT")->write(m_cur_control2, 0xff);
 
 	if (data & 0x100)
 		k053246_set_objcha_line(m_k053246, ASSERT_LINE);
diff -Nru src-old/mame/drivers/mpoker.c src/mame/drivers/mpoker.c
--- src-old/mame/drivers/mpoker.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/mpoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -258,7 +258,7 @@
     If you change the status *every* read, the HW stucks.
 */
 
-	m_mixdata = (input_port_read(machine(), "SW2") & 0xfd) | (machine().rand() & 0x02);
+	m_mixdata = (ioport("SW2")->read() & 0xfd) | (machine().rand() & 0x02);
 
 	return m_mixdata;
 }
diff -Nru src-old/mame/drivers/mpu3.c src/mame/drivers/mpu3.c
--- src-old/mame/drivers/mpu3.c	2012-04-03 11:51:27.000000000 +0200
+++ src/mame/drivers/mpu3.c	2012-05-03 11:00:08.000000000 +0200
@@ -346,13 +346,13 @@
 		case 2:
 		case 3:
 		{
-			data = (input_port_read(device->machine(), portnames[state->m_input_strobe])<<2);
+			data = (device->machine().root_device().ioport(portnames[state->m_input_strobe])->read()<<2);
 			break;
 		}
 		case 4://DIL1
 		case 6://DIL2
 		{
-			swizzle = (input_port_read(device->machine(), portnames[state->m_input_strobe]));
+			swizzle = (device->machine().root_device().ioport(portnames[state->m_input_strobe])->read());
 			data = (((swizzle & 0x01) << 7) + ((swizzle & 0x02) << 5) + ((swizzle & 0x04) << 3)
 					+ ((swizzle & 0x08) << 1) +((swizzle & 0x10) >> 1) + ((swizzle & 0x20) >> 3));
 			break;
@@ -360,7 +360,7 @@
 		case 5://DIL1
 		case 7://DIL2
 		{
-			swizzle = (input_port_read(device->machine(), portnames[state->m_input_strobe]));
+			swizzle = (device->machine().root_device().ioport(portnames[state->m_input_strobe])->read());
 			data = (((swizzle & 0x80) >> 1) + ((swizzle & 0x40) << 1));
 			break;
 		}
@@ -600,14 +600,14 @@
 static READ8_DEVICE_HANDLER( pia_ic6_porta_r )
 {
 	mpu3_state *state = device->machine().driver_data<mpu3_state>();
-	return (input_port_read(device->machine(), "AUX1"))|state->m_aux1_input;
+	return (state->ioport("AUX1")->read())|state->m_aux1_input;
 }
 
 
 static READ8_DEVICE_HANDLER( pia_ic6_portb_r )
 {
 	mpu3_state *state = device->machine().driver_data<mpu3_state>();
-	return (input_port_read(device->machine(), "AUX2"))|state->m_aux2_input;
+	return (state->ioport("AUX2")->read())|state->m_aux2_input;
 }
 
 static WRITE8_DEVICE_HANDLER( pia_ic6_porta_w )
diff -Nru src-old/mame/drivers/mpu4.c src/mame/drivers/mpu4.c
--- src-old/mame/drivers/mpu4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mpu4.c	2012-05-03 19:38:32.000000000 +0200
@@ -910,7 +910,7 @@
 	}
 	LOG(("%s: IC5 PIA Read of Port A (AUX1)\n",device->machine().describe_context()));
 
-	return input_port_read(device->machine(), "AUX1")|state->m_aux1_input;
+	return device->machine().root_device().ioport("AUX1")->read()|state->m_aux1_input;
 }
 
 static WRITE8_DEVICE_HANDLER( pia_ic5_porta_w )
@@ -1099,7 +1099,7 @@
 	coin_lockout_w(device->machine(), 1, (pia_ic5->b_output() & 0x02) );
 	coin_lockout_w(device->machine(), 2, (pia_ic5->b_output() & 0x04) );
 	coin_lockout_w(device->machine(), 3, (pia_ic5->b_output() & 0x08) );
-	return input_port_read(device->machine(), "AUX2") | state->m_aux2_input;
+	return device->machine().root_device().ioport("AUX2")->read() | state->m_aux2_input;
 }
 
 
@@ -1415,8 +1415,8 @@
 /* The orange inputs are polled twice as often as the black ones, for reasons of efficiency.
    This is achieved via connecting every input line to an AND gate, thus allowing two strobes
    to represent each orange input bank (strobes are active low). */
-	pia_ic5->cb1_w(input_port_read(device->machine(), "AUX2") & 0x80);
-	return input_port_read(device->machine(), portnames[state->m_input_strobe]);
+	pia_ic5->cb1_w(device->machine().root_device().ioport("AUX2")->read() & 0x80);
+	return device->machine().root_device().ioport(portnames[state->m_input_strobe])->read();
 }
 
 
@@ -2635,7 +2635,6 @@
 	{
 		stepper_config(machine, n, &barcrest_reel_interface);
 	}
-	awp_reel_setup();
 }
 
 MACHINE_START( mod2     )
@@ -2775,7 +2774,6 @@
 	stepper_config(machine, 4, &barcrest_opto1_interface);
 	stepper_config(machine, 5, &barcrest_opto1_interface);
 
-	awp_reel_setup();
 	state->m_current_chr_table = oldtmr_data;
 }
 
diff -Nru src-old/mame/drivers/mpu4vid.c src/mame/drivers/mpu4vid.c
--- src-old/mame/drivers/mpu4vid.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mpu4vid.c	2012-05-03 11:00:08.000000000 +0200
@@ -1182,10 +1182,10 @@
 	LOG(("%s: IC5 PIA Read of Port A (AUX1)\n",device->machine().describe_context()));
 
 
-	UINT8 data = input_port_read(device->machine(), "AUX1");
+	UINT8 data = state->ioport("AUX1")->read();
 
-	INT8 dx = input_port_read(device->machine(), "TRACKX");
-	INT8 dy = input_port_read(device->machine(), "TRACKY");
+	INT8 dx = state->ioport("TRACKX")->read();
+	INT8 dy = state->ioport("TRACKY")->read();
 
 	state->m_cur[0] = dy + dx;
 	state->m_cur[1] = dy - dx;
@@ -1468,12 +1468,12 @@
 
 	PORT_START("ORANGE2")
 	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_COIN5) PORT_NAME("20p Token")PORT_IMPULSE(5)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x04)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x05)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x06)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x07)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x08)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x09)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x04)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x05)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x06)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x07)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x08)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p") PORT_CONDITION("DIL1",0x0f,EQUALS,0x09)
 	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_UNUSED)
 	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_UNUSED)
 	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_UNUSED)
@@ -1484,22 +1484,22 @@
 	PORT_START("BLACK1")
 	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON5) PORT_NAME("Gamble")
 	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_START2) PORT_NAME("Pontoon")
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x01)
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x09)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x03)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x04)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x05)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x06)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x07)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x08)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x01)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x09)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x03)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x04)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x05)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x06)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x07)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x08)
 	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_UNUSED)
 	PORT_BIT(0x20, IP_ACTIVE_HIGH, IPT_SERVICE) PORT_NAME("Test Button") PORT_CODE(KEYCODE_W)
 	PORT_BIT(0x40, IP_ACTIVE_HIGH, IPT_SERVICE) PORT_NAME("Refill Key") PORT_CODE(KEYCODE_R) PORT_TOGGLE
 	PORT_BIT(0x80, IP_ACTIVE_HIGH, IPT_INTERLOCK) PORT_NAME("Rear Door")  PORT_CODE(KEYCODE_Q) PORT_TOGGLE
 
 	PORT_START("BLACK2")
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x00)
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x02)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x00)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_START1) PORT_NAME("Hi-Lo") PORT_CONDITION("DIL1",0x0f,EQUALS,0x02)
 	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_UNUSED)
 	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON6) PORT_NAME("Twist")
 	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_BUTTON3) PORT_NAME("Lo")
@@ -1574,10 +1574,10 @@
 	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_SPECIAL)
 	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_SPECIAL)
 	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_SPECIAL)
-	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x00)
-	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x01)
-	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x02)
-	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,PORTCOND_EQUALS,0x03)
+	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,EQUALS,0x00)
+	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,EQUALS,0x01)
+	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,EQUALS,0x02)
+	PORT_BIT(0x10, IP_ACTIVE_HIGH, IPT_COIN1) PORT_NAME("10p")PORT_IMPULSE(5) PORT_CONDITION("DIL1",0x0f,EQUALS,0x03)
 	PORT_BIT(0x20, IP_ACTIVE_HIGH, IPT_COIN2) PORT_NAME("20p")PORT_IMPULSE(5)
 	PORT_BIT(0x40, IP_ACTIVE_HIGH, IPT_COIN3) PORT_NAME("50p")PORT_IMPULSE(5)
 	PORT_BIT(0x80, IP_ACTIVE_HIGH, IPT_COIN4) PORT_NAME("100p")PORT_IMPULSE(5)
diff -Nru src-old/mame/drivers/mpu5.c src/mame/drivers/mpu5.c
--- src-old/mame/drivers/mpu5.c	2012-04-01 15:12:40.000000000 +0200
+++ src/mame/drivers/mpu5.c	2012-04-30 19:19:12.000000000 +0200
@@ -45,6 +45,11 @@
 		: driver_device(mconfig, type, tag),
 		  m_maincpu(*this, "maincpu")
 	{ }
+	UINT32* m_cpuregion;
+	UINT32* m_mainram;
+
+	DECLARE_READ32_MEMBER(mpu5_mem_r);
+	DECLARE_WRITE32_MEMBER(mpu5_mem_w);
 
 protected:
 
@@ -53,17 +58,72 @@
 };
 
 
+READ32_MEMBER(mpu5_state::mpu5_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 1:
+			return m_cpuregion[offset];
+
+		case 4:
+			offset &=0x3fff;
+			return (m_mainram[offset]);
+
+		default:
+			logerror("%08x maincpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
+
+WRITE32_MEMBER(mpu5_state::mpu5_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 4:
+			offset &=0x3fff;
+			COMBINE_DATA(&m_mainram[offset]);
+			break;
+
+
+
+		default:
+			logerror("%08x maincpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, offset*4, data, mem_mask, cs);
+
+	}
+
+}
+
 static ADDRESS_MAP_START( mpu5_map, AS_PROGRAM, 32, mpu5_state )
-	AM_RANGE(0x000000, 0x2fffff) AM_ROM
+	AM_RANGE(0x00000000, 0xffffffff) AM_READWRITE(mpu5_mem_r, mpu5_mem_w)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START(  mpu5 )
 INPUT_PORTS_END
 
+
+static MACHINE_START( mpu5 )
+{
+	mpu5_state *state = machine.driver_data<mpu5_state>();
+	state->m_cpuregion = (UINT32*)state->memregion( "maincpu" )->base();
+	state->m_mainram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+
+}
+
+
 static MACHINE_CONFIG_START( mpu5, mpu5_state )
 	MCFG_CPU_ADD("maincpu", M68340, 16000000)	 // ?
 	MCFG_CPU_PROGRAM_MAP(mpu5_map)
 
+	MCFG_MACHINE_START( mpu5 )
+
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 	/* unknown sound */
 MACHINE_CONFIG_END
@@ -6102,7 +6162,7 @@
 GAME( 199?, m5cos		,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Costa Del Cash Casino (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5cosclb	,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Costa Del Cash Club (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5crzkni	,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Crazy Crazy Knights (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, m5doshpk	,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Do$h & Pecks (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, m5doshpk	,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Do$h 'n' Pecks (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5draclb	,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Ooh Aah Dracula Club (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5ewn		,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Each Way Nudge (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, m5elim		,0,			mpu5, mpu5, 0, ROT0, "Barcrest","Eliminator (Barcrest) (MPU5)", GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/mquake.c src/mame/drivers/mquake.c
--- src-old/mame/drivers/mquake.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mquake.c	2012-05-03 11:00:08.000000000 +0200
@@ -107,7 +107,7 @@
 static READ16_HANDLER( coin_chip_r )
 {
 	if (offset == 1)
-		return input_port_read(space->machine(), "COINCHIP");
+		return space->machine().root_device().ioport("COINCHIP")->read();
 	logerror("%06x:coin_chip_r(%02x) & %04x\n", cpu_get_pc(&space->device()), offset, mem_mask);
 	return 0xffff;
 }
diff -Nru src-old/mame/drivers/ms32.c src/mame/drivers/ms32.c
--- src-old/mame/drivers/ms32.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ms32.c	2012-05-03 11:00:08.000000000 +0200
@@ -183,19 +183,19 @@
 	switch (m_mahjong_input_select[0])
 	{
 		case 0x01:
-			mj_input = input_port_read(machine(), "MJ0");
+			mj_input = ioport("MJ0")->read();
 			break;
 		case 0x02:
-			mj_input = input_port_read(machine(), "MJ1");
+			mj_input = ioport("MJ1")->read();
 			break;
 		case 0x04:
-			mj_input = input_port_read(machine(), "MJ2");
+			mj_input = ioport("MJ2")->read();
 			break;
 		case 0x08:
-			mj_input = input_port_read(machine(), "MJ3");
+			mj_input = ioport("MJ3")->read();
 			break;
 		case 0x10:
-			mj_input = input_port_read(machine(), "MJ4");
+			mj_input = ioport("MJ4")->read();
 			break;
 		default:
 			mj_input = 0;
@@ -209,10 +209,10 @@
 READ32_MEMBER(ms32_state::ms32_read_inputs3)
 {
 	int a,b,c,d;
-	a = input_port_read(machine(), "AN2?"); // unused?
-	b = input_port_read(machine(), "AN2?"); // unused?
-	c = input_port_read(machine(), "AN1");
-	d = (input_port_read(machine(), "AN0") - 0xb0) & 0xff;
+	a = ioport("AN2?")->read(); // unused?
+	b = ioport("AN2?")->read(); // unused?
+	c = ioport("AN1")->read();
+	d = (ioport("AN0")->read() - 0xb0) & 0xff;
 	return a << 24 | b << 16 | c << 8 | d << 0;
 }
 
@@ -2202,7 +2202,7 @@
 {
 	ms32_state *state = machine.driver_data<ms32_state>();
 	state_save_register_global(machine, state->m_to_main);
-	state->membank("bank4")->configure_entries(0, 16, machine.root_device().memregion("audiocpu")->base() + 0x14000, 0x4000);
+	state->membank("bank4")->configure_entries(0, 16, state->memregion("audiocpu")->base() + 0x14000, 0x4000);
 	state->membank("bank5")->configure_entries(0, 16, state->memregion("audiocpu")->base() + 0x14000, 0x4000);
 }
 
diff -Nru src-old/mame/drivers/msisaac.c src/mame/drivers/msisaac.c
--- src-old/mame/drivers/msisaac.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/msisaac.c	2012-05-03 11:00:08.000000000 +0200
@@ -116,7 +116,7 @@
 			//6-down
 			//7-leftdwn
 
-			UINT8 val= (input_port_read(machine(), "IN1") >> 2) & 0x0f;
+			UINT8 val= (ioport("IN1")->read() >> 2) & 0x0f;
 			/* bit0 = left
                bit1 = right
                bit2 = down
diff -Nru src-old/mame/drivers/mugsmash.c src/mame/drivers/mugsmash.c
--- src-old/mame/drivers/mugsmash.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/mugsmash.c	2012-05-03 11:00:08.000000000 +0200
@@ -154,16 +154,16 @@
 	switch (offset)
 	{
 		case 0 :
-			data = (input_port_read(machine(), "P1") & 0xff) | ((input_port_read(machine(), "DSW1") & 0xc0) << 6) | ((input_port_read(machine(), "IN0") & 0x03) << 8);
+			data = (ioport("P1")->read() & 0xff) | ((ioport("DSW1")->read() & 0xc0) << 6) | ((ioport("IN0")->read() & 0x03) << 8);
 			break;
 		case 1 :
-			data = (input_port_read(machine(), "P2") & 0xff) | ((input_port_read(machine(), "DSW1") & 0x3f) << 8);
+			data = (ioport("P2")->read() & 0xff) | ((ioport("DSW1")->read() & 0x3f) << 8);
 			break;
 		case 2 :
-			data = ((input_port_read(machine(), "DSW2") & 0x3f) << 8);
+			data = ((ioport("DSW2")->read() & 0x3f) << 8);
 			break;
 		case 3 :
-			data = ((input_port_read(machine(), "DSW2") & 0xc0) << 2);
+			data = ((ioport("DSW2")->read() & 0xc0) << 2);
 			break;
 	}
 
diff -Nru src-old/mame/drivers/multigam.c src/mame/drivers/multigam.c
--- src-old/mame/drivers/multigam.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/multigam.c	2012-05-03 11:00:08.000000000 +0200
@@ -263,11 +263,11 @@
 	m_in_0_shift = 0;
 	m_in_1_shift = 0;
 
-	m_in_0 = input_port_read(machine(), "P1");
-	m_in_1 = input_port_read(machine(), "P2");
+	m_in_0 = ioport("P1")->read();
+	m_in_1 = ioport("P2")->read();
 
 	m_in_dsw_shift = 0;
-	m_in_dsw = input_port_read_safe(machine(), "DSW", 0);
+	m_in_dsw = ioport("DSW")->read_safe(0);
 }
 
 READ8_MEMBER(multigam_state::multigam_IN1_r)
diff -Nru src-old/mame/drivers/mw18w.c src/mame/drivers/mw18w.c
--- src-old/mame/drivers/mw18w.c	2012-04-09 13:58:25.000000000 +0200
+++ src/mame/drivers/mw18w.c	2012-05-05 22:08:22.000000000 +0200
@@ -94,7 +94,7 @@
 	AM_RANGE(0x07, 0x07) AM_WRITE(mw18w_irq0_clear_w)
 ADDRESS_MAP_END
 
-static const UINT32 mw18w_controller_table[] =
+static const ioport_value mw18w_controller_table[] =
 {
 	// same encoder as sspeedr
 	0x3f, 0x3e, 0x3c, 0x3d, 0x39, 0x38, 0x3a, 0x3b,
@@ -141,22 +141,22 @@
 	PORT_DIPSETTING(    0x30, "90 seconds" )
 
 	PORT_DIPNAME( 0x0c, 0x00, "Extended Time" ) PORT_DIPLOCATION("SW:3,4")
-	PORT_DIPSETTING(    0x00, "20 seconds at 4000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x00) // @ 60 seconds
-	PORT_DIPSETTING(    0x04, "30 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x08, "15 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x0c, "30 seconds at 10000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "20 seconds at 6000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x10) // @ 70 seconds
-	PORT_DIPSETTING(    0x04, "30 seconds at 9000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x10)
-	PORT_DIPSETTING(    0x08, "20 seconds at 9000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x10)
-	PORT_DIPSETTING(    0x0c, "30 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x10)
-	PORT_DIPSETTING(    0x00, "20 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x20) // @ 80 seconds
-	PORT_DIPSETTING(    0x04, "30 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x08, "20 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x0c, "30 seconds at 16000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "20 seconds at 10000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x30) // @ 90 seconds
-	PORT_DIPSETTING(    0x04, "30 seconds at 15000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x30)
-	PORT_DIPSETTING(    0x08, "20 seconds at 15000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x30)
-	PORT_DIPSETTING(    0x0c, "30 seconds at 20000" ) PORT_CONDITION("DSW", 0x30, PORTCOND_EQUALS, 0x30)
+	PORT_DIPSETTING(    0x00, "20 seconds at 4000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x00) // @ 60 seconds
+	PORT_DIPSETTING(    0x04, "30 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x08, "15 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x0c, "30 seconds at 10000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "20 seconds at 6000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x10) // @ 70 seconds
+	PORT_DIPSETTING(    0x04, "30 seconds at 9000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x10)
+	PORT_DIPSETTING(    0x08, "20 seconds at 9000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x10)
+	PORT_DIPSETTING(    0x0c, "30 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x10)
+	PORT_DIPSETTING(    0x00, "20 seconds at 8000" )  PORT_CONDITION("DSW", 0x30, EQUALS, 0x20) // @ 80 seconds
+	PORT_DIPSETTING(    0x04, "30 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x08, "20 seconds at 12000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x0c, "30 seconds at 16000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "20 seconds at 10000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x30) // @ 90 seconds
+	PORT_DIPSETTING(    0x04, "30 seconds at 15000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x30)
+	PORT_DIPSETTING(    0x08, "20 seconds at 15000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x30)
+	PORT_DIPSETTING(    0x0c, "30 seconds at 20000" ) PORT_CONDITION("DSW", 0x30, EQUALS, 0x30)
 
 	PORT_DIPNAME( 0x40, 0x40, "I/O Test" ) PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
diff -Nru src-old/mame/drivers/mw8080bw.c src/mame/drivers/mw8080bw.c
--- src-old/mame/drivers/mw8080bw.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/mw8080bw.c	2012-05-05 22:08:22.000000000 +0200
@@ -315,8 +315,8 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::seawolf_erase_input_r)
 {
-	return input_port_read(machine(), SEAWOLF_ERASE_SW_PORT_TAG) &
-		   input_port_read(machine(), SEAWOLF_ERASE_DIP_PORT_TAG);
+	return ioport(SEAWOLF_ERASE_SW_PORT_TAG)->read() &
+		   ioport(SEAWOLF_ERASE_DIP_PORT_TAG)->read();
 }
 
 
@@ -336,7 +336,7 @@
 
 
 /* the 30 position encoder is verified */
-static const UINT32 seawolf_controller_table[30] =
+static const ioport_value seawolf_controller_table[30] =
 {
 	0x1e, 0x1c, 0x1d, 0x19, 0x18, 0x1a, 0x1b, 0x13,
 	0x12, 0x10, 0x11, 0x15, 0x14, 0x16, 0x17, 0x07,
@@ -353,20 +353,20 @@
 	/* The actual commutator pcb (encoder) has 30 positions and works like the table says. */
 	PORT_BIT( 0x1f, 0x0f, IPT_POSITIONAL ) PORT_POSITIONS(30) PORT_REMAP_TABLE(seawolf_controller_table) PORT_INVERT PORT_SENSITIVITY(20) PORT_KEYDELTA(8) PORT_CENTERDELTA(0) PORT_NAME("Periscope axis") PORT_CROSSHAIR(X, ((float)MW8080BW_HPIXCOUNT - 28) / MW8080BW_HPIXCOUNT, 16.0 / MW8080BW_HPIXCOUNT, 32.0 / MW8080BW_VBSTART)
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_PLAYER(1)
-	PORT_DIPNAME( 0xc0, 0x40, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0xe0) PORT_DIPLOCATION("G4:1,2")
-	PORT_DIPSETTING(    0x00, "60 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, "70 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, "80 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, "90 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "60 seconds" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, "70 seconds" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, "80 seconds" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, "90 seconds" ) PORT_CONDITION("IN1", 0xe0, PORTCOND_EQUALS, 0x00)
+	PORT_DIPNAME( 0xc0, 0x40, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0xe0) PORT_DIPLOCATION("G4:1,2")
+	PORT_DIPSETTING(    0x00, "60 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, "70 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, "80 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, "90 seconds + 20 extended" ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "60 seconds" ) PORT_CONDITION("IN1", 0xe0, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, "70 seconds" ) PORT_CONDITION("IN1", 0xe0, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, "80 seconds" ) PORT_CONDITION("IN1", 0xe0, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, "90 seconds" ) PORT_CONDITION("IN1", 0xe0, EQUALS, 0x00)
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START1 )
-	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0xe0, PORTCOND_NOTEQUALS, 0xe0) PORT_DIPLOCATION("G4:3,4")
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0xe0, NOTEQUALS, 0xe0) PORT_DIPLOCATION("G4:3,4")
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 2C_3C ) )
@@ -444,7 +444,7 @@
 ADDRESS_MAP_END
 
 
-static const UINT32 gunfight_controller_table[7] =
+static const ioport_value gunfight_controller_table[7] =
 {
 	0x06, 0x02, 0x00, 0x04, 0x05, 0x01, 0x03
 };
@@ -548,13 +548,13 @@
 
 UINT8 tornbase_get_cabinet_type(running_machine &machine)
 {
-	return input_port_read(machine, TORNBASE_CAB_TYPE_PORT_TAG);
+	return machine.root_device().ioport(TORNBASE_CAB_TYPE_PORT_TAG)->read();
 }
 
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::tornbase_hit_left_input_r)
 {
-	return input_port_read(machine(), TORNBASE_L_HIT_PORT_TAG);
+	return ioport(TORNBASE_L_HIT_PORT_TAG)->read();
 }
 
 
@@ -565,13 +565,13 @@
 	switch (tornbase_get_cabinet_type(machine()))
 	{
 	case TORNBASE_CAB_TYPE_UPRIGHT_OLD:
-		ret = input_port_read(machine(), TORNBASE_L_HIT_PORT_TAG);
+		ret = ioport(TORNBASE_L_HIT_PORT_TAG)->read();
 		break;
 
 	case TORNBASE_CAB_TYPE_UPRIGHT_NEW:
 	case TORNBASE_CAB_TYPE_COCKTAIL:
 	default:
-		ret = input_port_read(machine(), TORNBASE_R_HIT_PORT_TAG);
+		ret = ioport(TORNBASE_R_HIT_PORT_TAG)->read();
 		break;
 	}
 
@@ -587,12 +587,12 @@
 	{
 	case TORNBASE_CAB_TYPE_UPRIGHT_OLD:
 	case TORNBASE_CAB_TYPE_UPRIGHT_NEW:
-		ret = input_port_read(machine(), TORNBASE_L_PITCH_PORT_TAG);
+		ret = ioport(TORNBASE_L_PITCH_PORT_TAG)->read();
 		break;
 
 	case TORNBASE_CAB_TYPE_COCKTAIL:
 	default:
-		ret = input_port_read(machine(), TORNBASE_R_PITCH_PORT_TAG);
+		ret = ioport(TORNBASE_R_PITCH_PORT_TAG)->read();
 		break;
 	}
 
@@ -602,14 +602,14 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::tornbase_pitch_right_input_r)
 {
-	return input_port_read(machine(), TORNBASE_L_PITCH_PORT_TAG);
+	return ioport(TORNBASE_L_PITCH_PORT_TAG)->read();
 }
 
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::tornbase_score_input_r)
 {
-	return input_port_read(machine(), TORNBASE_SCORE_SW_PORT_TAG) &
-		   input_port_read(machine(), TORNBASE_SCORE_DIP_PORT_TAG);
+	return ioport(TORNBASE_SCORE_SW_PORT_TAG)->read() &
+		   ioport(TORNBASE_SCORE_DIP_PORT_TAG)->read();
 }
 
 
@@ -643,7 +643,7 @@
 	PORT_START("IN0")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,tornbase_hit_left_input_r, NULL)
 	PORT_BIT( 0x7e, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,tornbase_pitch_left_input_r, NULL)
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B1:7")
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B1:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
@@ -656,7 +656,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_UNKNOWN )  /* schematics shows it as "START", but not used by the software */
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,tornbase_score_input_r, NULL)
-	PORT_DIPNAME( 0x78, 0x40, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B1:2,3,4,5")
+	PORT_DIPNAME( 0x78, 0x40, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B1:2,3,4,5")
 	PORT_DIPSETTING(    0x18, "4 Coins/1 Inning" )
 	PORT_DIPSETTING(    0x10, "3 Coins/1 Inning" )
 	PORT_DIPSETTING(    0x38, "4 Coins/2 Innings" )
@@ -774,25 +774,25 @@
 	PORT_BIT( 0xff, 0x7f, IPT_PADDLE ) PORT_MINMAX(0x01,0xfe) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_REVERSE PORT_PLAYER(1)
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x0c, PORTCOND_NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x0c, NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:1,2")
 	PORT_DIPSETTING(    0x02, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_3C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
 	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Game_Time ) ) PORT_DIPLOCATION("E3:3,4")
-	PORT_DIPSETTING(    0x0c, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "80 seconds + 40 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x08, "99 seconds + 50 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x0c, "60 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "80 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x08, "99 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x20)
+	PORT_DIPSETTING(    0x0c, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "80 seconds + 40 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x08, "99 seconds + 50 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x0c, "60 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "80 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x08, "99 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x20)
 	PORT_DIPSETTING(    0x04, "Test Mode" )
-	PORT_DIPNAME( 0x30, 0x00, "Extended Time At" ) PORT_CONDITION("IN2", 0x0c, PORTCOND_NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:5,6")
+	PORT_DIPNAME( 0x30, 0x00, "Extended Time At" ) PORT_CONDITION("IN2", 0x0c, NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:5,6")
 	PORT_DIPSETTING(    0x10, "2.00" )
 	PORT_DIPSETTING(    0x00, "2.50" )
 	PORT_DIPSETTING(    0x20, DEF_STR( None ) )
 	/* PORT_DIPSETTING( 0x30, DEF_STR( None ) ) */
-	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Language )) PORT_CONDITION("IN2", 0x0c, PORTCOND_NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:7,8")
+	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Language )) PORT_CONDITION("IN2", 0x0c, NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:7,8")
 	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( German ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( French ) )
@@ -817,16 +817,16 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_3C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:3,4")
-	PORT_DIPSETTING(    0x00, "45 seconds + 22 extended" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0xc0)
-	PORT_DIPSETTING(    0x04, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0xc0)
-	PORT_DIPSETTING(    0x08, "75 seconds + 37 extended" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0xc0)
-	PORT_DIPSETTING(    0x0c, "90 seconds + 45 extended" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0xc0)
-	PORT_DIPSETTING(    0x00, "45 seconds" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_EQUALS, 0xc0)
-	PORT_DIPSETTING(    0x04, "60 seconds" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_EQUALS, 0xc0)
-	PORT_DIPSETTING(    0x08, "75 seconds" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_EQUALS, 0xc0)
-	PORT_DIPSETTING(    0x0c, "90 seconds" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_EQUALS, 0xc0)
-	PORT_DIPNAME( 0x30, 0x20, "Extended Time At" ) PORT_CONDITION("IN2", 0xc0, PORTCOND_NOTEQUALS, 0xc0) PORT_DIPLOCATION("E3:5,6")
+	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0x04) PORT_DIPLOCATION("E3:3,4")
+	PORT_DIPSETTING(    0x00, "45 seconds + 22 extended" ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0xc0)
+	PORT_DIPSETTING(    0x04, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0xc0)
+	PORT_DIPSETTING(    0x08, "75 seconds + 37 extended" ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0xc0)
+	PORT_DIPSETTING(    0x0c, "90 seconds + 45 extended" ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0xc0)
+	PORT_DIPSETTING(    0x00, "45 seconds" ) PORT_CONDITION("IN2", 0xc0, EQUALS, 0xc0)
+	PORT_DIPSETTING(    0x04, "60 seconds" ) PORT_CONDITION("IN2", 0xc0, EQUALS, 0xc0)
+	PORT_DIPSETTING(    0x08, "75 seconds" ) PORT_CONDITION("IN2", 0xc0, EQUALS, 0xc0)
+	PORT_DIPSETTING(    0x0c, "90 seconds" ) PORT_CONDITION("IN2", 0xc0, EQUALS, 0xc0)
+	PORT_DIPNAME( 0x30, 0x20, "Extended Time At" ) PORT_CONDITION("IN2", 0xc0, NOTEQUALS, 0xc0) PORT_DIPLOCATION("E3:5,6")
 	PORT_DIPSETTING(    0x00, "350" )
 	PORT_DIPSETTING(    0x10, "400" )
 	PORT_DIPSETTING(    0x20, "450" )
@@ -940,12 +940,12 @@
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_UNUSED )	/* labeled 'Not Used' */
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1  )
-	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
+	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
 	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x30, DEF_STR( 2C_3C ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x40, 0x40, "2 Player Game Time" ) PORT_CONDITION("IN1", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:3")
+	PORT_DIPNAME( 0x40, 0x40, "2 Player Game Time" ) PORT_CONDITION("IN1", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:3")
 	PORT_DIPSETTING(    0x40, "4 minutes" )
 	PORT_DIPSETTING(    0x00, "6 minutes" )
 	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "SW:4" )
@@ -1000,7 +1000,7 @@
 ADDRESS_MAP_END
 
 
-static const UINT32 boothill_controller_table[7] =
+static const ioport_value boothill_controller_table[7] =
 {
 	0x00, 0x04, 0x06, 0x07, 0x03, 0x01, 0x05
 };
@@ -1024,12 +1024,12 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x10, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x10, EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
 	PORT_DIPSETTING(    0x02, "2 Coins per Player" )
 	PORT_DIPSETTING(    0x03, "2 Coins/1 or 2 Players" )
 	PORT_DIPSETTING(    0x00, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x01, "1 Coin/1 or 2 Players" )
-	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x10, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
+	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x10, EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
 	PORT_DIPSETTING(    0x00, "60 seconds" )
 	PORT_DIPSETTING(    0x04, "70 seconds" )
 	PORT_DIPSETTING(    0x08, "80 seconds" )
@@ -1111,21 +1111,21 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(4)
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("A4:1")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("A4:1")
 	PORT_DIPSETTING(    0x00, "1 Coin/1 or 2 Players" )
 	PORT_DIPSETTING(    0x01, "1 Coin/1 or 2 Players, 2 Coins/3 or 4 Players" )
-	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("A4:2")
+	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("A4:2")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0c, 0x04, "Rounds" ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("A4:3,4")
+	PORT_DIPNAME( 0x0c, 0x04, "Rounds" ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("A4:3,4")
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
 	PORT_DIPSETTING(    0x08, "4" )
 	PORT_DIPSETTING(    0x0c, "5" )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("A4:5")
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("A4:5")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
-	PORT_DIPNAME( 0x60, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("A4:6,7")
+	PORT_DIPNAME( 0x60, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("A4:6,7")
 	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
 	PORT_DIPSETTING(    0x20, "Language 2" )
 	PORT_DIPSETTING(    0x40, "Language 3" )
@@ -1190,9 +1190,9 @@
 	UINT32 ret;
 
 	if (m_desertgun_controller_select)
-		ret = input_port_read(machine(), DESERTGU_GUN_X_PORT_TAG);
+		ret = ioport(DESERTGU_GUN_X_PORT_TAG)->read();
 	else
-		ret = input_port_read(machine(), DESERTGU_GUN_Y_PORT_TAG);
+		ret = ioport(DESERTGU_GUN_Y_PORT_TAG)->read();
 
 	return ret;
 }
@@ -1203,9 +1203,9 @@
 	UINT32 ret;
 
 	if (m_desertgun_controller_select)
-		ret = input_port_read(machine(), DESERTGU_DIP_SW_0_1_SET_2_TAG);
+		ret = ioport(DESERTGU_DIP_SW_0_1_SET_2_TAG)->read();
 	else
-		ret = input_port_read(machine(), DESERTGU_DIP_SW_0_1_SET_1_TAG);
+		ret = ioport(DESERTGU_DIP_SW_0_1_SET_1_TAG)->read();
 
 	return ret;
 }
@@ -1234,7 +1234,7 @@
 
 	PORT_START("IN1")
 	PORT_BIT( 0x03, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,desertgu_dip_sw_0_1_r, NULL)
-	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN1", 0x30, PORTCOND_NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:5,6")
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN1", 0x30, NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:5,6")
 	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( German ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( French ) )
@@ -1257,7 +1257,7 @@
 	/* D0 and D1 in the DIP SW input port can reflect two sets of switches depending on the controller
        select bit.  These two ports are fakes to handle this case */
 	PORT_START(DESERTGU_DIP_SW_0_1_SET_1_TAG)
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x30, PORTCOND_NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x30, NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:1,2")
 	PORT_DIPSETTING(    0x02, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_3C ) )
@@ -1265,7 +1265,7 @@
 	PORT_BIT( 0xfc, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START(DESERTGU_DIP_SW_0_1_SET_2_TAG)
-	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0x30, PORTCOND_NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:3,4")
+	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0x30, NOTEQUALS, 0x30) PORT_DIPLOCATION("C2:3,4")
 	PORT_DIPSETTING(    0x00, "40 seconds + 30 extended" )
 	PORT_DIPSETTING(    0x01, "50 seconds + 30 extended" )
 	PORT_DIPSETTING(    0x02, "60 seconds + 30 extended" )
@@ -1318,10 +1318,10 @@
 {
 	UINT32 ret;
 
-	if (input_port_read(machine(), DPLAY_CAB_TYPE_PORT_TAG) == DPLAY_CAB_TYPE_UPRIGHT)
-		ret = input_port_read(machine(), DPLAY_L_PITCH_PORT_TAG);
+	if (ioport(DPLAY_CAB_TYPE_PORT_TAG)->read() == DPLAY_CAB_TYPE_UPRIGHT)
+		ret = ioport(DPLAY_L_PITCH_PORT_TAG)->read();
 	else
-		ret = input_port_read(machine(), DPLAY_R_PITCH_PORT_TAG);
+		ret = ioport(DPLAY_R_PITCH_PORT_TAG)->read();
 
 	return ret;
 }
@@ -1329,7 +1329,7 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::dplay_pitch_right_input_r)
 {
-	return input_port_read(machine(), DPLAY_L_PITCH_PORT_TAG);
+	return ioport(DPLAY_L_PITCH_PORT_TAG)->read();
 }
 
 
@@ -1361,7 +1361,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x07, 0x00, DEF_STR( Coinage )) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:1,2,3")
+	PORT_DIPNAME( 0x07, 0x00, DEF_STR( Coinage )) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:1,2,3")
 	PORT_DIPSETTING(    0x05, "2 Coins/1 Inning/1 Player, 4 Coins/1 Inning/2 Players, 8 Coins/3 Innings/2 Players" )
 	PORT_DIPSETTING(    0x04, "1 Coin/1 Inning/1 Player, 2 Coins/1 Inning/2 Players, 4 Coins/3 Innings/2 Players" )
 	PORT_DIPSETTING(    0x02, "2 Coins per Inning" )
@@ -1370,13 +1370,13 @@
 	/* PORT_DIPSETTING( 0x06, "1 Coin per Inning" ) */
 	/* PORT_DIPSETTING( 0x07, "1 Coin per Inning" ) */
 	PORT_DIPSETTING(    0x01, "1 Coin/1 Inning, 2 Coins/3 Innings" )
-	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:4")
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:5")
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:5")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:6")
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:6")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x40, IP_ACTIVE_LOW, "C1:7" )
@@ -1425,7 +1425,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x07, 0x00, DEF_STR( Coinage )) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:1,2,3")
+	PORT_DIPNAME( 0x07, 0x00, DEF_STR( Coinage )) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:1,2,3")
 	PORT_DIPSETTING(    0x05, "2 Coins/1 Inning/1 Player, 4 Coins/1 Inning/2 Players, 8 Coins/3 Innings/2 Players" )
 	PORT_DIPSETTING(    0x04, "1 Coin/1 Inning/1 Player, 2 Coins/1 Inning/2 Players, 4 Coins/3 Innings/2 Players" )
 	PORT_DIPSETTING(    0x02, "2 Coins per Inning" )
@@ -1434,13 +1434,13 @@
 	/* PORT_DIPSETTING( 0x06, "1 Coin per Inning" ) */
 	/* PORT_DIPSETTING( 0x07, "1 Coin per Inning" ) */
 	PORT_DIPSETTING(    0x01, "1 Coin/1 Inning, 2 Coins/3 Innings" )
-	PORT_DIPNAME( 0x08, 0x00, "Wall Knock Out Behavior" ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:4")
+	PORT_DIPNAME( 0x08, 0x00, "Wall Knock Out Behavior" ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:4")
 	PORT_DIPSETTING(    0x00, "Individually" )
 	PORT_DIPSETTING(    0x08, "In Pairs" )
-	PORT_DIPNAME( 0x10, 0x00, "Double Score when Special Lit" ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:5")
+	PORT_DIPNAME( 0x10, 0x00, "Double Score when Special Lit" ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:5")
 	PORT_DIPSETTING(    0x00, "Home Run Only" )
 	PORT_DIPSETTING(    0x10, "Any Hit" )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, PORTCOND_EQUALS, 0x40) PORT_DIPLOCATION("C1:6")
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x40, EQUALS, 0x40) PORT_DIPLOCATION("C1:6")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x40, IP_ACTIVE_LOW, "C1:7" )
@@ -1550,22 +1550,22 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("D1:1,2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("D1:1,2")
 	PORT_DIPSETTING(    0x01, "2 Coins per Player" )
 	PORT_DIPSETTING(    0x00, "2 Coins/1 or 2 Players" )
 	PORT_DIPSETTING(    0x03, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x02, "1 Coin/1 or 2 Players" )
-	PORT_DIPNAME( 0x0c, 0x08, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("D1:3,4")
+	PORT_DIPNAME( 0x0c, 0x08, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("D1:3,4")
 	PORT_DIPSETTING(    0x00, "60 seconds + 30 extended" )
 	PORT_DIPSETTING(    0x08, "70 seconds + 35 extended" )
 	PORT_DIPSETTING(    0x04, "80 seconds + 40 extended" )
 	PORT_DIPSETTING(    0x0c, "90 seconds + 45 extended" )
-	PORT_DIPNAME( 0x30, 0x10, "Extended Time At" ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("D1:5,6")
+	PORT_DIPNAME( 0x30, 0x10, "Extended Time At" ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("D1:5,6")
 	PORT_DIPSETTING(    0x00, "500" )
 	PORT_DIPSETTING(    0x20, "700" )
 	PORT_DIPSETTING(    0x10, "1000" )
 	PORT_DIPSETTING(    0x30, "1300" )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("D1:7")
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("D1:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_LOW, "D1:8" )
@@ -1644,12 +1644,12 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )  /* not connected */
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x10, PORTCOND_EQUALS, 0x10) PORT_DIPLOCATION("C1:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x10, EQUALS, 0x10) PORT_DIPLOCATION("C1:1,2")
 	PORT_DIPSETTING(    0x02, "2 Coins per Player" )
 	PORT_DIPSETTING(    0x03, "2 Coins/1 or 2 Players" )
 	PORT_DIPSETTING(    0x00, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x01, "1 Coin/1 or 2 Players" )
-	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x10, PORTCOND_EQUALS, 0x10) PORT_DIPLOCATION("C1:3,4")
+	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Game_Time ) ) PORT_CONDITION("IN2", 0x10, EQUALS, 0x10) PORT_DIPLOCATION("C1:3,4")
 	PORT_DIPSETTING(    0x00, "60 seconds" )
 	PORT_DIPSETTING(    0x04, "70 seconds" )
 	PORT_DIPSETTING(    0x08, "80 seconds" )
@@ -1711,11 +1711,11 @@
 
 	if (m_clowns_controller_select)
 	{
-		ret = input_port_read(machine(), CLOWNS_CONTROLLER_P2_TAG);
+		ret = ioport(CLOWNS_CONTROLLER_P2_TAG)->read();
 	}
 	else
 	{
-		ret = input_port_read(machine(), CLOWNS_CONTROLLER_P1_TAG);
+		ret = ioport(CLOWNS_CONTROLLER_P1_TAG)->read();
 	}
 
 	return ret;
@@ -1754,23 +1754,23 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )  /* not connected */
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 2C_2C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x00, "Bonus Game" ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
+	PORT_DIPNAME( 0x0c, 0x00, "Bonus Game" ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
 	PORT_DIPSETTING(    0x00, "No Bonus" )
 	PORT_DIPSETTING(    0x04, "9000" )
 	PORT_DIPSETTING(    0x08, "11000" )
 	PORT_DIPSETTING(    0x0c, "13000" )
-	PORT_DIPNAME( 0x10, 0x00, "Balloon Resets" ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:5")
+	PORT_DIPNAME( 0x10, 0x00, "Balloon Resets" ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x00, "Each Row" )
 	PORT_DIPSETTING(    0x10, "All Rows" )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:6")
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:6")
 	PORT_DIPSETTING(    0x00, "3000" )
 	PORT_DIPSETTING(    0x20, "4000" )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Lives ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:7")
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Lives ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, "3" )
 	PORT_DIPSETTING(    0x40, "4" )
 	/* test mode - press coin button for input test */
@@ -1803,20 +1803,20 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:1,2")
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 2C_2C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Lives ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
+	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Lives ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:3,4")
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x04, "3" )
 	PORT_DIPSETTING(    0x08, "4" )
 	PORT_DIPSETTING(    0x0c, "5" )
-	PORT_DIPNAME( 0x10, 0x00, "Balloon Resets" ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:5")
+	PORT_DIPNAME( 0x10, 0x00, "Balloon Resets" ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x00, "Each Row" )
 	PORT_DIPSETTING(    0x10, "All Rows" )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW:6")
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("SW:6")
 	PORT_DIPSETTING(    0x00, "3000" )
 	PORT_DIPSETTING(    0x20, "4000" )
 	PORT_DIPNAME( 0x40, 0x00, "Input Test"  ) PORT_DIPLOCATION("SW:7")
@@ -1895,14 +1895,14 @@
     but ROM contents suggests it's not connected (no different languages or unmapped reads) */
 	PORT_START("IN2")
 	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Game_Time ) ) PORT_DIPLOCATION("C2:1,2")
-	PORT_DIPSETTING(    0x03, "40 seconds + 20 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x00) // 45 + 20 for 2 players
-	PORT_DIPSETTING(    0x02, "50 seconds + 25 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x00) // 60 + 30 for 2 players
-	PORT_DIPSETTING(    0x01, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x00) // 75 + 35 for 2 players
-	PORT_DIPSETTING(    0x00, "70 seconds + 35 extended" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x00) // 90 + 45 for 2 players
-	PORT_DIPSETTING(    0x03, "40 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x02, "50 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x01, "60 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "70 seconds" ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x03, "40 seconds + 20 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x00) // 45 + 20 for 2 players
+	PORT_DIPSETTING(    0x02, "50 seconds + 25 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x00) // 60 + 30 for 2 players
+	PORT_DIPSETTING(    0x01, "60 seconds + 30 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x00) // 75 + 35 for 2 players
+	PORT_DIPSETTING(    0x00, "70 seconds + 35 extended" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x00) // 90 + 45 for 2 players
+	PORT_DIPSETTING(    0x03, "40 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x02, "50 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x01, "60 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "70 seconds" ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x00)
 	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_DIPLOCATION("C2:3,4")
 	PORT_DIPSETTING(    0x00, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x04, "1 Coin/1 or 2 Players" )
@@ -1972,22 +1972,22 @@
 
 static INPUT_PORTS_START( shuffle )
 	PORT_START("IN0")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("B3:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("B3:1,2")
 	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( French ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( German ) )
 	/* PORT_DIPSETTING( 0x03, DEF_STR( German ) ) */
-	PORT_DIPNAME( 0x0c, 0x04, "Points to Win" ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("B3:3,4")
+	PORT_DIPNAME( 0x0c, 0x04, "Points to Win" ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("B3:3,4")
 	PORT_DIPSETTING(    0x00, "Game 1 = 25, Game 2 = 11" )
 	PORT_DIPSETTING(    0x04, "Game 1 = 35, Game 2 = 15" )
 	PORT_DIPSETTING(    0x08, "Game 1 = 40, Game 2 = 18" )
 	PORT_DIPSETTING(    0x0c, "Game 1 = 50, Game 2 = 21" )
-	PORT_DIPNAME( 0x30, 0x10, DEF_STR( Coinage ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("B3:5,6")
+	PORT_DIPNAME( 0x30, 0x10, DEF_STR( Coinage ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("B3:5,6")
 	PORT_DIPSETTING(    0x30, "2 Coins per Player" )
 	PORT_DIPSETTING(    0x20, "2 Coins/1 or 2 Players" )
 	PORT_DIPSETTING(    0x10, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x00, "1 Coin/1 or 2 Players" )
-	PORT_DIPNAME( 0x40, 0x40, "Time Limit" ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("B3:7")
+	PORT_DIPNAME( 0x40, 0x40, "Time Limit" ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("B3:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_LOW, "B3:8" )
@@ -2049,7 +2049,7 @@
 ADDRESS_MAP_END
 
 
-static const UINT32 dogpatch_controller_table[7] =
+static const ioport_value dogpatch_controller_table[7] =
 {
 	0x07, 0x06, 0x04, 0x05, 0x01, 0x00, 0x02
 };
@@ -2073,21 +2073,21 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x02, "Number of Cans" ) PORT_CONDITION("IN2", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:1,2")
+	PORT_DIPNAME( 0x03, 0x02, "Number of Cans" ) PORT_CONDITION("IN2", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:1,2")
 	PORT_DIPSETTING(    0x03, "10" )
 	PORT_DIPSETTING(    0x02, "15" )
 	PORT_DIPSETTING(    0x01, "20" )
 	PORT_DIPSETTING(    0x00, "25" )
-	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:3,4")
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:3,4")
 	PORT_DIPSETTING(    0x08, "2 Coins per Player" )
 	PORT_DIPSETTING(    0x0c, "2 Coins/1 or 2 Players" )
 	PORT_DIPSETTING(    0x00, "1 Coin per Player" )
 	PORT_DIPSETTING(    0x04, "1 Coin/1 or 2 Players" )
-	PORT_DIPNAME( 0x10, 0x10, "Extended Time Reward" ) PORT_CONDITION("IN2", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:5")
+	PORT_DIPNAME( 0x10, 0x10, "Extended Time Reward" ) PORT_CONDITION("IN2", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x10, "3 extra cans" )
 	PORT_DIPSETTING(    0x00, "5 extra cans" )
 	PORT_SERVICE_DIPLOC( 0x20, IP_ACTIVE_LOW, "SW:6" )
-	PORT_DIPNAME( 0xc0, 0x40, "Extended Time At" ) PORT_CONDITION("IN2", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:7,8")
+	PORT_DIPNAME( 0xc0, 0x40, "Extended Time At" ) PORT_CONDITION("IN2", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:7,8")
 	PORT_DIPSETTING(    0xc0, "150" )
 	PORT_DIPSETTING(    0x80, "175" )
 	PORT_DIPSETTING(    0x40, "225" )
@@ -2207,7 +2207,7 @@
 ADDRESS_MAP_END
 
 
-static const UINT32 spcenctr_controller_table[] =
+static const ioport_value spcenctr_controller_table[] =
 {
 	0x3f, 0x3e, 0x3c, 0x3d, 0x39, 0x38, 0x3a, 0x3b,
 	0x33, 0x32, 0x30, 0x31, 0x35, 0x34, 0x36, 0x37,
@@ -2234,12 +2234,12 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )  /* marked as COIN #2, but the software never reads it */
 
 	PORT_START("IN2")
-	PORT_DIPNAME( 0x03, 0x02, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x30, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("F3:1,2")
+	PORT_DIPNAME( 0x03, 0x02, DEF_STR( Bonus_Life ) ) PORT_CONDITION("IN2", 0x30, EQUALS, 0x00) PORT_DIPLOCATION("F3:1,2")
 	PORT_DIPSETTING(    0x00, "2000 4000 8000" )
 	PORT_DIPSETTING(    0x01, "3000 6000 12000" )
 	PORT_DIPSETTING(    0x02, "4000 8000 16000" )
 	PORT_DIPSETTING(    0x03, "5000 10000 20000" )
-	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x10) PORT_DIPLOCATION("F3:3,4")
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x10) PORT_DIPLOCATION("F3:3,4")
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 2C_3C ) )
@@ -2249,7 +2249,7 @@
 	PORT_DIPSETTING(    0x30, "Bonus Off" )
 	PORT_DIPSETTING(    0x20, "Cross Hatch" )
 	PORT_DIPSETTING(    0x10, "Test Mode" )
-	PORT_DIPNAME( 0xc0, 0x40, "Time" ) PORT_CONDITION("IN2", 0x30, PORTCOND_NOTEQUALS, 0x10) PORT_DIPLOCATION("F3:7,8")
+	PORT_DIPNAME( 0xc0, 0x40, "Time" ) PORT_CONDITION("IN2", 0x30, NOTEQUALS, 0x10) PORT_DIPLOCATION("F3:7,8")
 	PORT_DIPSETTING(    0x00, "45" )
 	PORT_DIPSETTING(    0x40, "60" )
 	PORT_DIPSETTING(    0x80, "75" )
@@ -2329,25 +2329,25 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )  /* not connected */
 
 	PORT_START("IN1")
-	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:1")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:1")
 	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Game_Time ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:2,3")
 	PORT_DIPSETTING(    0x00, "45 seconds + 20 extended (at 20 points)" )
 	PORT_DIPSETTING(    0x02, "60 seconds + 25 extended (at 25 points)" )
 	PORT_DIPSETTING(    0x04, "75 seconds + 30 extended (at 30 points)" )
 	PORT_DIPSETTING(    0x06, "90 seconds + 35 extended (at 35 points)" )
-	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:4")
+	PORT_DIPNAME( 0x08, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:5")
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
 	PORT_SERVICE_DIPLOC( 0x20, IP_ACTIVE_LOW, "SW:6" )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:7")
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, PORTCOND_EQUALS, 0x20) PORT_DIPLOCATION("SW:8")
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x20, EQUALS, 0x20) PORT_DIPLOCATION("SW:8")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 INPUT_PORTS_END
@@ -2452,24 +2452,24 @@
 
 static INPUT_PORTS_START( bowler )
 	PORT_START("IN0")
-	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:1,2")
+	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Language ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:1,2")
 	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( French ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( German ) )
 	/*PORT_DIPSETTING(  0x03, DEF_STR( German ) ) */
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Demo_Sounds ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:3")
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Demo_Sounds ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:3")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( On ) )  /* every 17 minutes */
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Game_Time ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:4")
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Game_Time ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:4")
 	PORT_DIPSETTING(    0x00, "No Limit" )
 	PORT_DIPSETTING(    0x08, "5 Minutes" )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:5")
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:5")
 	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Difficulty ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:6")
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Difficulty ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:6")
 	PORT_DIPSETTING(    0x20, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hard ) )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) ) PORT_CONDITION("IN0", 0x80, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("B3:7")
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) ) PORT_CONDITION("IN0", 0x80, EQUALS, 0x00) PORT_DIPLOCATION("B3:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, "Cocktail (not functional)" )
 	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_HIGH, "B3:8" )
@@ -2534,7 +2534,7 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::invaders_coin_input_r)
 {
-	UINT32 ret = input_port_read(machine(), INVADERS_COIN_INPUT_PORT_TAG);
+	UINT32 ret = ioport(INVADERS_COIN_INPUT_PORT_TAG)->read();
 
 	coin_counter_w(machine(), 0, !ret);
 
@@ -2552,7 +2552,7 @@
 	if (invaders_is_cabinet_cocktail(machine()))
 		ret = 0x03;
 	else
-		ret = input_port_read(machine(), INVADERS_SW6_SW7_PORT_TAG);
+		ret = ioport(INVADERS_SW6_SW7_PORT_TAG)->read();
 
 	return ret;
 }
@@ -2568,7 +2568,7 @@
 	if (invaders_is_cabinet_cocktail(machine()))
 		ret = 0x01;
 	else
-		ret = input_port_read(machine(), INVADERS_SW5_PORT_TAG);
+		ret = ioport(INVADERS_SW5_PORT_TAG)->read();
 
 	return ret;
 }
@@ -2584,7 +2584,7 @@
 	if (invaders_is_cabinet_cocktail(machine()))
 		ret = 0x07;
 	else
-		ret = input_port_read(machine(), INVADERS_P1_CONTROL_PORT_TAG);
+		ret = ioport(INVADERS_P1_CONTROL_PORT_TAG)->read();
 
 	return ret;
 }
@@ -2592,7 +2592,7 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::invaders_in1_control_r)
 {
-	return input_port_read(machine(), INVADERS_P1_CONTROL_PORT_TAG);
+	return ioport(INVADERS_P1_CONTROL_PORT_TAG)->read();
 }
 
 
@@ -2604,9 +2604,9 @@
        cocktail PCB: P2 controls */
 
 	if (invaders_is_cabinet_cocktail(machine()))
-		ret = input_port_read(machine(), INVADERS_P2_CONTROL_PORT_TAG);
+		ret = ioport(INVADERS_P2_CONTROL_PORT_TAG)->read();
 	else
-		ret = input_port_read(machine(), INVADERS_P1_CONTROL_PORT_TAG);
+		ret = ioport(INVADERS_P1_CONTROL_PORT_TAG)->read();
 
 	return ret;
 }
@@ -2614,7 +2614,7 @@
 
 int invaders_is_cabinet_cocktail(running_machine &machine)
 {
-	return input_port_read(machine, INVADERS_CAB_TYPE_PORT_TAG);
+	return machine.root_device().ioport(INVADERS_CAB_TYPE_PORT_TAG)->read();
 }
 
 
@@ -2741,7 +2741,7 @@
 
 CUSTOM_INPUT_MEMBER(mw8080bw_state::blueshrk_coin_input_r)
 {
-	UINT32 ret = input_port_read(machine(), BLUESHRK_COIN_INPUT_PORT_TAG);
+	UINT32 ret = ioport(BLUESHRK_COIN_INPUT_PORT_TAG)->read();
 
 	coin_counter_w(machine(), 0, !ret);
 
@@ -2770,14 +2770,14 @@
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, mw8080bw_state,blueshrk_coin_input_r, NULL)
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW:3")
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW:3")
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_TILT )  /* not shown on the schematics, instead DIP SW4 is connected here */
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW:5")
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) ) PORT_CONDITION("IN1", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW:5")
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x60, 0x40, "Replay" ) PORT_CONDITION("IN1", 0x80, PORTCOND_EQUALS, 0x80) PORT_DIPLOCATION("SW:6,7")
+	PORT_DIPNAME( 0x60, 0x40, "Replay" ) PORT_CONDITION("IN1", 0x80, EQUALS, 0x80) PORT_DIPLOCATION("SW:6,7")
 	PORT_DIPSETTING(    0x20, "14000" )
 	PORT_DIPSETTING(    0x40, "18000" )
 	PORT_DIPSETTING(    0x60, "22000" )
@@ -2820,7 +2820,7 @@
 #ifdef UNUSED_FUNCTION
 static UINT32 invad2ct_coin_input_r(void *param)
 {
-	UINT32 ret = input_port_read(machine, INVAD2CT_COIN_INPUT_PORT_TAG);
+	UINT32 ret = machine.root_device().ioport(INVAD2CT_COIN_INPUT_PORT_TAG)->read();
 
 	coin_counter_w(machine, 0, !ret);
 
diff -Nru src-old/mame/drivers/mwarr.c src/mame/drivers/mwarr.c
--- src-old/mame/drivers/mwarr.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/mwarr.c	2012-05-03 11:00:08.000000000 +0200
@@ -243,7 +243,7 @@
 	PORT_START("SYSTEM")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_SPECIAL ) // otherwise it doesn't boot
 	PORT_BIT( 0xfff0, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
diff -Nru src-old/mame/drivers/mystston.c src/mame/drivers/mystston.c
--- src-old/mame/drivers/mystston.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/mystston.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,7 +177,7 @@
 	PORT_DIPNAME(0x40, 0x00, DEF_STR( Cabinet ) )		PORT_DIPLOCATION("SW1:7")
 	PORT_DIPSETTING(   0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(   0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/mystwarr.c src/mame/drivers/mystwarr.c
--- src-old/mame/drivers/mystwarr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/mystwarr.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		return input_port_read(machine(), "IN1");
+		return ioport("IN1")->read();
 	}
 
 //  logerror("msb access to eeprom port\n");
@@ -75,7 +75,7 @@
 {
 	if (ACCESSING_BITS_8_15)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xffff);
+		ioport("EEPROMOUT")->write(data, 0xffff);
 	}
 
 //  logerror("unknown LSB write %x to eeprom\n", data);
@@ -86,17 +86,17 @@
 {
 	if (ACCESSING_BITS_8_15)
 	{
-		return input_port_read(machine(), "IN1") << 8;
+		return ioport("IN1")->read() << 8;
 	}
 
-	return input_port_read(machine(), "P2");
+	return ioport("P2")->read();
 }
 
 WRITE16_MEMBER(mystwarr_state::mmeeprom_w)
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
diff -Nru src-old/mame/drivers/namcofl.c src/mame/drivers/namcofl.c
--- src-old/mame/drivers/namcofl.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcofl.c	2012-05-03 11:00:08.000000000 +0200
@@ -282,16 +282,16 @@
 	switch (m_mcu_port6 & 0xf0)
 	{
 		case 0x00:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 
 		case 0x20:
-			return input_port_read(machine(), "MISC");
+			return ioport("MISC")->read();
 
 		case 0x40:
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 
 		case 0x60:
-			return input_port_read(machine(), "IN2");
+			return ioport("IN2")->read();
 
 		default:
 			break;
@@ -302,17 +302,17 @@
 
 READ8_MEMBER(namcofl_state::dac7_r)
 {
-	return input_port_read_safe(machine(), "ACCEL", 0xff);
+	return ioport("ACCEL")->read_safe(0xff);
 }
 
 READ8_MEMBER(namcofl_state::dac6_r)
 {
-	return input_port_read_safe(machine(), "BRAKE", 0xff);
+	return ioport("BRAKE")->read_safe(0xff);
 }
 
 READ8_MEMBER(namcofl_state::dac5_r)
 {
-	return input_port_read_safe(machine(), "WHEEL", 0xff);
+	return ioport("WHEEL")->read_safe(0xff);
 }
 
 READ8_MEMBER(namcofl_state::dac4_r){ return 0xff; }
diff -Nru src-old/mame/drivers/namcona1.c src/mame/drivers/namcona1.c
--- src-old/mame/drivers/namcona1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcona1.c	2012-05-03 11:00:08.000000000 +0200
@@ -881,16 +881,16 @@
 	switch (m_mcu_port6 & 0xe0)
 	{
 		case 0x40:
-			return input_port_read(machine(), "P1");
+			return ioport("P1")->read();
 
 		case 0x60:
-			return input_port_read(machine(), "P2");
+			return ioport("P2")->read();
 
 		case 0x20:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 0x00:
-			return input_port_read(machine(), "P4");
+			return ioport("P4")->read();
 	}
 
 	return 0xff;
@@ -940,7 +940,7 @@
 READ8_MEMBER(namcona1_state::portana_r)
 {
 	static const UINT8 bitnum[8] = { 0x40, 0x20, 0x10, 0x01, 0x02, 0x04, 0x08, 0x80 };
-	UINT8 port = input_port_read(machine(), "P3");
+	UINT8 port = ioport("P3")->read();
 
 	return (port & bitnum[offset>>1]) ? 0xff : 0x00;
 }
diff -Nru src-old/mame/drivers/namconb1.c src/mame/drivers/namconb1.c
--- src-old/mame/drivers/namconb1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namconb1.c	2012-05-03 11:00:08.000000000 +0200
@@ -813,10 +813,10 @@
 
 	switch( offset )
 	{
-	case 0: case 1: result = (UINT8)(0x0f + input_port_read(machine(), "LIGHT1_Y") * 224/255); break; /* Y (p2) */
-	case 2: case 3: result = (UINT8)(0x26 + input_port_read(machine(), "LIGHT1_X") * 288/314); break; /* X (p2) */
-	case 4: case 5: result = (UINT8)(0x0f + input_port_read(machine(), "LIGHT0_Y") * 224/255); break; /* Y (p1) */
-	case 6: case 7: result = (UINT8)(0x26 + input_port_read(machine(), "LIGHT0_X") * 288/314); break; /* X (p1) */
+	case 0: case 1: result = (UINT8)(0x0f + ioport("LIGHT1_Y")->read() * 224/255); break; /* Y (p2) */
+	case 2: case 3: result = (UINT8)(0x26 + ioport("LIGHT1_X")->read() * 288/314); break; /* X (p2) */
+	case 4: case 5: result = (UINT8)(0x0f + ioport("LIGHT0_Y")->read() * 224/255); break; /* Y (p1) */
+	case 6: case 7: result = (UINT8)(0x26 + ioport("LIGHT0_X")->read() * 288/314); break; /* X (p1) */
 	}
 	return result<<24;
 } /* gunbulet_gun_r */
@@ -932,16 +932,16 @@
 	switch (m_nbx_port6 & 0xf0)
 	{
 		case 0x00:
-			return input_port_read_safe(machine(), "P4", 0xff);
+			return ioport("P4")->read_safe(0xff);
 
 		case 0x20:
-			return input_port_read(machine(), "MISC");
+			return ioport("MISC")->read();
 
 		case 0x40:
-			return input_port_read(machine(), "P1");
+			return ioport("P1")->read();
 
 		case 0x60:
-			return input_port_read(machine(), "P2");
+			return ioport("P2")->read();
 
 		default:
 			break;
@@ -955,42 +955,42 @@
 // register full scale, so it works...
 READ8_MEMBER(namconb1_state::dac7_r)// bit 7
 {
-	return input_port_read_safe(machine(), "P3", 0xff)&0x80;
+	return ioport("P3")->read_safe(0xff)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac6_r)// bit 3
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<1)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<1)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac5_r)// bit 2
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<2)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<2)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac4_r)// bit 1
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<3)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<3)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac3_r)// bit 0
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<4)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<4)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac2_r)// bit 4
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<5)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<5)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac1_r)// bit 5
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<6)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<6)&0x80;
 }
 
 READ8_MEMBER(namconb1_state::dac0_r)// bit 6
 {
-	return (input_port_read_safe(machine(), "P3", 0xff)<<7)&0x80;
+	return (ioport("P3")->read_safe(0xff)<<7)&0x80;
 }
 
 static ADDRESS_MAP_START( namcoc75_io, AS_IO, 8, namconb1_state )
diff -Nru src-old/mame/drivers/namcos1.c src/mame/drivers/namcos1.c
--- src-old/mame/drivers/namcos1.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/namcos1.c	2012-05-03 11:00:08.000000000 +0200
@@ -369,7 +369,7 @@
 
 READ8_MEMBER(namcos1_state::dsw_r)
 {
-	int ret = input_port_read(machine(), "DIPSW");
+	int ret = ioport("DIPSW")->read();
 	if (!(offset & 2)) ret >>= 4;
 	return 0xf0 | ret;
 }
diff -Nru src-old/mame/drivers/namcos10.c src/mame/drivers/namcos10.c
--- src-old/mame/drivers/namcos10.c	2012-04-21 13:46:16.000000000 +0200
+++ src/mame/drivers/namcos10.c	2012-05-07 08:57:50.000000000 +0200
@@ -353,8 +353,11 @@
 
 	UINT16 dd16 = d16 ^ key;
 
+	key = d16;
+
 	key =
-		((    BIT(d16,  3) ^ (BIT(cnt, 0) & !BIT(cnt, 2))) << 15) |
+		//((    BIT(d16,  3) ^ (BIT(cnt, 0) & !BIT(cnt, 2))) << 15) |
+		((1 ^ BIT(key,  3) ^  BIT(d16, 0))                 << 15) |
 		((1 ^ BIT(key, 13) ^  BIT(cnt, 0))                 << 14) |
 		((1 ^ BIT(key, 11) ^  BIT(d16, 5) ^  BIT(d16, 2))  << 13) |
 		((    BIT(key,  9) ^  BIT(cnt, 3))                 << 12) |
@@ -369,7 +372,8 @@
 		((1 ^ BIT(key,  8) ^ (BIT(cnt, 7) |  BIT(d16, 3))) <<  3) |
 		((    BIT(key, 14) ^ (BIT(cnt, 1) |  BIT(d16, 7))) <<  2) |
 		((1 ^ BIT(key, 12) ^ (BIT(cnt, 7) &  BIT(d16, 7))) <<  1) |
-		((                   (BIT(cnt, 0) |  BIT(cnt, 2))) <<  0);
+		//((                   (BIT(cnt, 0) |  BIT(cnt, 2))) <<  0);
+		((1 ^ BIT(key,  0) ^ BIT(cnt, 2))                  <<  0);
 
 	cnt++;
 
@@ -491,7 +495,7 @@
 static void memn_driver_init( running_machine &machine )
 {
 	namcos10_state *state = machine.driver_data<namcos10_state>();
-	UINT8 *BIOS = (UINT8 *)machine.root_device().memregion( "user1" )->base();
+	UINT8 *BIOS = (UINT8 *)state->memregion( "user1" )->base();
 	state->nand_base = (UINT8 *)state->memregion( "user2" )->base();
 
 	state->nand_copy( (UINT32 *)( BIOS + 0x0000000 ), 0x08000, 0x001c000 );
diff -Nru src-old/mame/drivers/namcos11.c src/mame/drivers/namcos11.c
--- src-old/mame/drivers/namcos11.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcos11.c	2012-05-03 11:00:08.000000000 +0200
@@ -696,16 +696,16 @@
 	switch( offset )
 	{
 	case 0:
-		data = input_port_read( machine(), "GUN1X" );
+		data = ioport( "GUN1X" )->read();
 		break;
 	case 1:
-		data = ( input_port_read( machine(), "GUN1Y" ) ) | ( ( input_port_read( machine(), "GUN1Y" ) + 1 ) << 16 );
+		data = ( ioport( "GUN1Y" )->read() ) | ( ( ioport( "GUN1Y" )->read() + 1 ) << 16 );
 		break;
 	case 2:
-		data = input_port_read( machine(), "GUN2X" );
+		data = ioport( "GUN2X" )->read();
 		break;
 	case 3:
-		data = ( input_port_read( machine(), "GUN2Y" ) ) | ( ( input_port_read( machine(), "GUN2Y" ) + 1 ) << 16 );
+		data = ( ioport( "GUN2Y" )->read() ) | ( ( ioport( "GUN2Y" )->read() + 1 ) << 16 );
 		break;
 	}
 	verboselog( machine(), 2, "lightgun_r( %08x, %08x ) %08x\n", offset, mem_mask, data );
@@ -750,16 +750,16 @@
 	switch (offset)
 	{
 		case 0:
-			return input_port_read(machine(), "PLAYER4");
+			return ioport("PLAYER4")->read();
 
 		case 1:
-			return input_port_read(machine(), "SWITCH");
+			return ioport("SWITCH")->read();
 
 		case 2:
-			return input_port_read(machine(), "PLAYER1");
+			return ioport("PLAYER1")->read();
 
 		case 3:
-			return input_port_read(machine(), "PLAYER2");
+			return ioport("PLAYER2")->read();
 	}
 
 	return 0xff;
@@ -779,52 +779,52 @@
 
 READ8_MEMBER(namcos11_state::dac7_r)// bit 7
 {
-	return input_port_read_safe(machine(), "PLAYER3", 0xff)&0x80;
+	return ioport("PLAYER3")->read_safe(0xff)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac6_r)// bit 3
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<4)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<4)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac5_r)// bit 2
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<5)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<5)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac4_r)// bit 1
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<6)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<6)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac3_r)// bit 0
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<7)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<7)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac2_r)// bit 4
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<3)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<3)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac1_r)// bit 5
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<2)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<2)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::dac0_r)// bit 6
 {
-	return (input_port_read_safe(machine(), "PLAYER3", 0xff)<<1)&0x80;
+	return (ioport("PLAYER3")->read_safe(0xff)<<1)&0x80;
 }
 
 READ8_MEMBER(namcos11_state::pocketrc_gas_r)
 {
-	return input_port_read(machine(), "GAS");
+	return ioport("GAS")->read();
 }
 
 READ8_MEMBER(namcos11_state::pocketrc_steer_r)
 {
-	return input_port_read(machine(), "STEERING");
+	return ioport("STEERING")->read();
 }
 
 ADDRESS_MAP_START( c76_io_map, AS_IO, 8, namcos11_state )
diff -Nru src-old/mame/drivers/namcos12.c src/mame/drivers/namcos12.c
--- src-old/mame/drivers/namcos12.c	2012-04-22 07:07:46.000000000 +0200
+++ src/mame/drivers/namcos12.c	2012-05-03 11:00:08.000000000 +0200
@@ -1296,16 +1296,16 @@
 	switch( offset )
 	{
 	case 0:
-		data = input_port_read(machine(), "LIGHT0_X");
+		data = ioport("LIGHT0_X")->read();
 		break;
 	case 1:
-		data = ( input_port_read(machine(), "LIGHT0_Y") ) | ( ( input_port_read(machine(), "LIGHT0_Y") + 1 ) << 16 );
+		data = ( ioport("LIGHT0_Y")->read() ) | ( ( ioport("LIGHT0_Y")->read() + 1 ) << 16 );
 		break;
 	case 2:
-		data = input_port_read(machine(), "LIGHT1_X");
+		data = ioport("LIGHT1_X")->read();
 		break;
 	case 3:
-		data = ( input_port_read(machine(), "LIGHT1_Y") ) | ( ( input_port_read(machine(), "LIGHT1_Y") + 1 ) << 16 );
+		data = ( ioport("LIGHT1_Y")->read() ) | ( ( ioport("LIGHT1_Y")->read() + 1 ) << 16 );
 		break;
 	}
 	verboselog( machine(), 2, "system11gun_r( %08x, %08x ) %08x\n", offset, mem_mask, data );
@@ -1573,10 +1573,10 @@
 
 READ8_MEMBER(namcos12_state::s12_mcu_gun_h_r)
 {
-	const input_port_config *port = ioport("LIGHT0_X");
+	ioport_port *port = ioport("LIGHT0_X");
 	if( port != NULL )
 	{
-		int rv = input_port_read_direct( port ) << 6;
+		int rv = port->read() << 6;
 
 		if( ( offset & 1 ) != 0 )
 		{
@@ -1592,10 +1592,10 @@
 
 READ8_MEMBER(namcos12_state::s12_mcu_gun_v_r)
 {
-	const input_port_config *port = ioport("LIGHT0_Y");
+	ioport_port *port = ioport("LIGHT0_Y");
 	if( port != NULL )
 	{
-		int rv = input_port_read_direct( port ) << 6;
+		int rv = port->read() << 6;
 
 		if( ( offset & 1 ) != 0 )
 		{
@@ -1627,7 +1627,7 @@
 
 	psx_driver_init(machine);
 
-	state->membank("bank1")->configure_entries(0, machine.root_device().memregion( "user2" )->bytes() / 0x200000, state->memregion( "user2" )->base(), 0x200000 );
+	state->membank("bank1")->configure_entries(0, state->memregion( "user2" )->bytes() / 0x200000, state->memregion( "user2" )->base(), 0x200000 );
 
 	state->m_s12_porta = 0;
 	state->m_s12_rtcstate = 0;
diff -Nru src-old/mame/drivers/namcos21.c src/mame/drivers/namcos21.c
--- src-old/mame/drivers/namcos21.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcos21.c	2012-05-03 11:00:08.000000000 +0200
@@ -2257,7 +2257,7 @@
 static DRIVER_INIT( winrun )
 {
 	namcos21_state *state = machine.driver_data<namcos21_state>();
-	UINT16 *pMem = (UINT16 *)machine.root_device().memregion("dsp")->base();
+	UINT16 *pMem = (UINT16 *)state->memregion("dsp")->base();
 	int pc = 0;
 	pMem[pc++] = 0xff80; /* b */
 	pMem[pc++] = 0;
@@ -2301,7 +2301,7 @@
 static DRIVER_INIT( driveyes )
 {
 	namcos21_state *state = machine.driver_data<namcos21_state>();
-	UINT16 *pMem = (UINT16 *)machine.root_device().memregion("dsp")->base();
+	UINT16 *pMem = (UINT16 *)state->memregion("dsp")->base();
 	int pc = 0;
 	pMem[pc++] = 0xff80; /* b */
 	pMem[pc++] = 0;
diff -Nru src-old/mame/drivers/namcos22.c src/mame/drivers/namcos22.c
--- src-old/mame/drivers/namcos22.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcos22.c	2012-05-03 11:00:08.000000000 +0200
@@ -1183,9 +1183,9 @@
 static void
 ReadAnalogDrivingPorts( running_machine &machine, UINT16 *gas, UINT16 *brake, UINT16 *steer )
 {
-	*gas   = input_port_read(machine, "GAS");
-	*brake = input_port_read(machine, "BRAKE");
-	*steer = input_port_read(machine, "STEER");
+	*gas   = machine.root_device().ioport("GAS")->read();
+	*brake = machine.root_device().ioport("BRAKE")->read();
+	*steer = machine.root_device().ioport("STEER")->read();
 }
 
 /* TODO: REMOVE (THIS IS HANDLED BY "SUBCPU") */
@@ -1193,9 +1193,9 @@
 AnalogAsDigital( running_machine &machine )
 {
 	namcos22_state *state = machine.driver_data<namcos22_state>();
-	UINT16 inputs = input_port_read_safe(machine, "INPUTS", 0);
-	UINT16 gas    = input_port_read_safe(machine, "GAS", 0);
-	UINT16 steer  = input_port_read_safe(machine, "STEER", 0);
+	UINT16 inputs = state->ioport("INPUTS")->read_safe(0);
+	UINT16 gas    = state->ioport("GAS")->read_safe(0);
+	UINT16 steer  = state->ioport("STEER")->read_safe(0);
 	UINT16 result = 0xffff;
 
 	switch( state->m_gametype )
@@ -1248,7 +1248,7 @@
 	UINT16 *share16 = (UINT16 *)state->m_shareram.target();
 	UINT32 coin_state;
 
-	coin_state = input_port_read(machine, "INPUTS") & 0x1200;
+	coin_state = state->ioport("INPUTS")->read() & 0x1200;
 
 	if (!(coin_state & 0x1000) && (state->m_old_coin_state & 0x1000))
 	{
@@ -1277,7 +1277,7 @@
 	namcos22_state *state = machine.driver_data<namcos22_state>();
 	if( nthbyte(state->m_system_controller, 0x18) != 0 )
 	{
-		UINT16 flags = input_port_read(machine, "INPUTS");
+		UINT16 flags = state->ioport("INPUTS")->read();
 		UINT16 gas, brake, steer, coinram_address_is_odd = 0;
 		ReadAnalogDrivingPorts( machine, &gas, &brake, &steer );
 
@@ -1335,12 +1335,12 @@
 	namcos22_state *state = machine.driver_data<namcos22_state>();
 	if( nthbyte(state->m_system_controller, 0x18) != 0 )
 	{
-		UINT16 flags = input_port_read(machine, "INPUTS");
+		UINT16 flags = state->ioport("INPUTS")->read();
 
-		UINT16 volume0 = input_port_read(machine, "STICKY1") * 0x10;
-		UINT16 volume1 = input_port_read(machine, "STICKY2") * 0x10;
-		UINT16 volume2 = input_port_read(machine, "STICKX1") * 0x10;
-		UINT16 volume3 = input_port_read(machine, "STICKX2") * 0x10;
+		UINT16 volume0 = state->ioport("STICKY1")->read() * 0x10;
+		UINT16 volume1 = state->ioport("STICKY2")->read() * 0x10;
+		UINT16 volume2 = state->ioport("STICKX1")->read() * 0x10;
+		UINT16 volume3 = state->ioport("STICKX2")->read() * 0x10;
 
 		state->m_shareram[0x030/4] = (flags<<16) | volume0;
 		state->m_shareram[0x034/4] = (volume1<<16) | volume2;
@@ -2421,7 +2421,7 @@
 
 READ32_MEMBER(namcos22_state::namcos22_dipswitch_r)
 {
-	return input_port_read(machine(), "DSW0")<<16;
+	return ioport("DSW0")->read()<<16;
 }
 
 READ32_MEMBER(namcos22_state::namcos22_mcuram_r)
@@ -2436,8 +2436,8 @@
 
 READ32_MEMBER(namcos22_state::namcos22_gun_r)
 {
-	int xpos = input_port_read_safe(machine(), "LIGHTX", 0) * 640 / 0xff;
-	int ypos = input_port_read_safe(machine(), "LIGHTY", 0) * 240 / 0xff + 0x10;
+	int xpos = ioport("LIGHTX")->read_safe(0) * 640 / 0xff;
+	int ypos = ioport("LIGHTY")->read_safe(0) * 240 / 0xff + 0x10;
 	switch( offset )
 	{
 	case 0: /* 430000 */
@@ -2626,9 +2626,9 @@
 {
 
 	if (m_p4 & 8)
-		return input_port_read_safe(machine(), "MCUP5A", 0xff);
+		return ioport("MCUP5A")->read_safe(0xff);
 	else
-		return input_port_read_safe(machine(), "MCUP5B", 0xff);
+		return ioport("MCUP5B")->read_safe(0xff);
 }
 
 WRITE8_MEMBER(namcos22_state::mcu_port6_w)
@@ -2666,9 +2666,9 @@
 	// H+L = horizontal, 1 H+L = vertical
 	UINT16 ddx, ddy;
 
-	ddx = input_port_read(machine(), "STICKX");
+	ddx = ioport("STICKX")->read();
 	if (ddx > 0) ddx -= 1;
-	ddy = input_port_read(machine(), "STICKY");
+	ddy = ioport("STICKY")->read();
 	if (ddy > 0) ddy -= 1;
 
 	ddx <<= 2;
@@ -2685,7 +2685,7 @@
 			// and timer A3 is configured by the MCU program to cause an interrupt each time
 			// it's clocked.  by counting the number of interrupts in a frame, we can determine
 			// how fast the user is pedaling.
-			if( input_port_read(machine(), "JOY") & 0x10 )
+			if( ioport("JOY")->read() & 0x10 )
 			{
 				int i;
 				for (i = 0; i < 16; i++)
@@ -2739,8 +2739,8 @@
 READ8_MEMBER(namcos22_state::alpineracer_mcu_adc_r)
 {
 	// 0 H+L = swing, 1 H+L = edge
-	UINT16 swing = input_port_read(machine(), "SWING")<<2;
-	UINT16 edge  = input_port_read(machine(), "EDGE" )<<2;
+	UINT16 swing = ioport("SWING")->read()<<2;
+	UINT16 edge  = ioport("EDGE" )->read()<<2;
 
 	switch (offset)
 	{
@@ -2833,9 +2833,9 @@
 {
 	UINT16 gas, steer, ddy;
 
-	gas   = input_port_read(machine(), "GAS") ^ 0x7f;
-	steer = input_port_read(machine(), "STEER") ^ 0xff;
-	ddy = input_port_read(machine(), "STICKY");
+	gas   = ioport("GAS")->read() ^ 0x7f;
+	steer = ioport("STEER")->read() ^ 0xff;
+	ddy = ioport("STICKY")->read();
 	if (ddy > 0) ddy -= 1;
 
 	gas <<= 2;
@@ -2877,9 +2877,9 @@
 {
 	UINT16 pedal, x, y;
 
-	pedal = input_port_read(machine(), "PEDAL")<<2;
-	x = input_port_read(machine(), "STICKX")<<2;
-	y = input_port_read(machine(), "STICKY")<<2;
+	pedal = ioport("PEDAL")->read()<<2;
+	x = ioport("STICKX")->read()<<2;
+	y = ioport("STICKY")->read()<<2;
 
 
 	switch (offset)
diff -Nru src-old/mame/drivers/namcos23.c src/mame/drivers/namcos23.c
--- src-old/mame/drivers/namcos23.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcos23.c	2012-05-03 11:00:08.000000000 +0200
@@ -1705,7 +1705,7 @@
 
 	case 2: case 3:
 		// These may be coming from another CPU, in particular the I/O one
-		m_ctl_inp_buffer[offset-2] = input_port_read(machine(), offset == 2 ? "P1" : "P2");
+		m_ctl_inp_buffer[offset-2] = ioport(offset == 2 ? "P1" : "P2")->read();
 		break;
 	case 5:
 		if(m_ctl_vbl_active) {
@@ -1728,7 +1728,7 @@
 {
 	switch(offset) {
 		// 0100 set freezes gorgon (polygon fifo flag)
-	case 1: return 0x0000 | input_port_read(machine(), "DSW");
+	case 1: return 0x0000 | ioport("DSW")->read();
 	case 2: case 3: {
 		UINT16 res = m_ctl_inp_buffer[offset-2] & 0x800 ? 0xffff : 0x0000;
 		m_ctl_inp_buffer[offset-2] = (m_ctl_inp_buffer[offset-2] << 1) | 1;
@@ -2992,8 +2992,8 @@
 
 READ8_MEMBER(namcos23_state::s23_gun_r)
 {
-	UINT16 xpos = input_port_read_safe(machine(), "LIGHTX", 0) * 640 / 0xff + 0x80;
-	UINT16 ypos = input_port_read_safe(machine(), "LIGHTY", 0) * 240 / 0xff + 0x20;
+	UINT16 xpos = ioport("LIGHTX")->read_safe(0) * 640 / 0xff + 0x80;
+	UINT16 ypos = ioport("LIGHTY")->read_safe(0) * 240 / 0xff + 0x20;
 
 	// note: will need angle adjustments for accurate aiming at screen sides
 	switch(offset)
@@ -3070,13 +3070,13 @@
 {
 	namcos23_state *state = machine.driver_data<namcos23_state>();
 	render_t &render = state->m_render;
-	state->m_ptrom  = (const UINT32 *)machine.root_device().memregion("pointrom")->base();
-	state->m_tmlrom = (const UINT16 *)machine.root_device().memregion("textilemapl")->base();
-	state->m_tmhrom = machine.root_device().memregion("textilemaph")->base();
-	state->m_texrom = machine.root_device().memregion("textile")->base();
+	state->m_ptrom  = (const UINT32 *)state->memregion("pointrom")->base();
+	state->m_tmlrom = (const UINT16 *)state->memregion("textilemapl")->base();
+	state->m_tmhrom = state->memregion("textilemaph")->base();
+	state->m_texrom = state->memregion("textile")->base();
 
-	state->m_tileid_mask = (machine.root_device().memregion("textilemapl")->bytes()/2 - 1) & ~0xff; // Used for y masking
-	state->m_tile_mask = machine.root_device().memregion("textile")->bytes()/256 - 1;
+	state->m_tileid_mask = (state->memregion("textilemapl")->bytes()/2 - 1) & ~0xff; // Used for y masking
+	state->m_tile_mask = state->memregion("textile")->bytes()/256 - 1;
 	state->m_ptrom_limit = state->memregion("pointrom")->bytes()/4;
 
 	state->m_mi_rd = state->m_mi_wr = state->m_im_rd = state->m_im_wr = 0;
diff -Nru src-old/mame/drivers/namcos86.c src/mame/drivers/namcos86.c
--- src-old/mame/drivers/namcos86.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/namcos86.c	2012-05-03 11:00:08.000000000 +0200
@@ -214,15 +214,15 @@
 {
 	int rhi, rlo;
 
-	rhi  = ( input_port_read(machine(), "DSWA") & 0x01 ) << 4;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x04 ) << 3;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x10 ) << 2;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x40 ) << 1;
-
-	rlo  = ( input_port_read(machine(), "DSWB") & 0x01 );
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x04 ) >> 1;
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x10 ) >> 2;
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x40 ) >> 3;
+	rhi  = ( ioport("DSWA")->read() & 0x01 ) << 4;
+	rhi |= ( ioport("DSWA")->read() & 0x04 ) << 3;
+	rhi |= ( ioport("DSWA")->read() & 0x10 ) << 2;
+	rhi |= ( ioport("DSWA")->read() & 0x40 ) << 1;
+
+	rlo  = ( ioport("DSWB")->read() & 0x01 );
+	rlo |= ( ioport("DSWB")->read() & 0x04 ) >> 1;
+	rlo |= ( ioport("DSWB")->read() & 0x10 ) >> 2;
+	rlo |= ( ioport("DSWB")->read() & 0x40 ) >> 3;
 
 	return rhi | rlo;
 }
@@ -231,15 +231,15 @@
 {
 	int rhi, rlo;
 
-	rhi  = ( input_port_read(machine(), "DSWA") & 0x02 ) << 3;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x08 ) << 2;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x20 ) << 1;
-	rhi |= ( input_port_read(machine(), "DSWA") & 0x80 );
-
-	rlo  = ( input_port_read(machine(), "DSWB") & 0x02 ) >> 1;
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x08 ) >> 2;
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x20 ) >> 3;
-	rlo |= ( input_port_read(machine(), "DSWB") & 0x80 ) >> 4;
+	rhi  = ( ioport("DSWA")->read() & 0x02 ) << 3;
+	rhi |= ( ioport("DSWA")->read() & 0x08 ) << 2;
+	rhi |= ( ioport("DSWA")->read() & 0x20 ) << 1;
+	rhi |= ( ioport("DSWA")->read() & 0x80 );
+
+	rlo  = ( ioport("DSWB")->read() & 0x02 ) >> 1;
+	rlo |= ( ioport("DSWB")->read() & 0x08 ) >> 2;
+	rlo |= ( ioport("DSWB")->read() & 0x20 ) >> 3;
+	rlo |= ( ioport("DSWB")->read() & 0x80 ) >> 4;
 
 	return rhi | rlo;
 }
diff -Nru src-old/mame/drivers/naomi.c src/mame/drivers/naomi.c
--- src-old/mame/drivers/naomi.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/naomi.c	2012-05-06 00:21:39.000000000 +0200
@@ -1726,7 +1726,7 @@
 
 	if (reg == 0x280/4)
 	{
-		UINT32 coins = input_port_read(space->machine(), "COINS");
+		UINT32 coins = space->machine().root_device().ioport("COINS")->read();
 
 		if (coins & 0x01)
 		{
@@ -2664,6 +2664,7 @@
 EPR-21576b - NAOMI BOOT ROM 1999 02/15  1.20 (Japan)
 EPR-21576a - NAOMI BOOT ROM 1999 01/14  1.10 (Japan)
 EPR-21576  - NAOMI BOOT ROM 1998 12/18  1.00 (Japan)
+EPR-21577h - NAOMI BOOT ROM 2002 07/08  1.8- (USA)
 EPR-21577g - NAOMI BOOT ROM 2001 09/10  1.70 (USA)
 EPR-21577e - NAOMI BOOT ROM 2000 08/25  1.50 (USA)
 EPR-21577d - NAOMI BOOT ROM 1999 06/04  1.40 (USA)
@@ -2672,7 +2673,7 @@
 EPR-21578g - NAOMI BOOT ROM 2001 09/10  1.70 (Export)
 EPR-21578e - NAOMI BOOT ROM 2000 08/25  1.50 (Export)
 EPR-21578d - NAOMI BOOT ROM 1999 06/04  1.40 (Export)
-EPR-21578b - NAOMI BOOT ROM 1999 02/15  1.20 (Export) <-- Also found as EPR-21578A
+EPR-21578a - NAOMI BOOT ROM 1999 02/15  1.20 (Export) <-- Also found as EPR-21578A
 EPR-21579d - NAOMI BOOT ROM 1999 06/04  1.40 (Korea)
 EPR-21579  - NAOMI BOOT ROM 1999 01/14  1.10 (Korea)
 EPR-21580  - No known dump (Australia)
@@ -2733,41 +2734,43 @@
 #define NAOMI_BIOS \
 	ROM_REGION( 0x200000, "maincpu", 0) \
 	ROM_SYSTEM_BIOS( 0, "bios0", "epr-21576h (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 0, "epr-21576h.ic27",  0x000000, 0x200000, CRC(d4895685) SHA1(91424d481ff99a8d3f4c45cea6d3f0eada049a6d) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 0, "epr-21576h.ic27", 0x000000, 0x200000, CRC(d4895685) SHA1(91424d481ff99a8d3f4c45cea6d3f0eada049a6d) ) \
 	ROM_SYSTEM_BIOS( 1, "bios1", "epr-21576g (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 1, "epr-21576g.ic27",  0x000000, 0x200000, CRC(d2a1c6bf) SHA1(6d27d71aec4dfba98f66316ae74a1426d567698a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 1, "epr-21576g.ic27", 0x000000, 0x200000, CRC(d2a1c6bf) SHA1(6d27d71aec4dfba98f66316ae74a1426d567698a) ) \
 	ROM_SYSTEM_BIOS( 2, "bios2", "epr-21576e (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 2, "epr-21576e.ic27",  0x000000, 0x200000, CRC(08c0add7) SHA1(e7c1a7673cb2ccb21748ef44105e46d1bad7266d) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 2, "epr-21576e.ic27", 0x000000, 0x200000, CRC(08c0add7) SHA1(e7c1a7673cb2ccb21748ef44105e46d1bad7266d) ) \
 	ROM_SYSTEM_BIOS( 3, "bios3", "epr-21576d (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 3, "epr-21576d.ic27",  0x000000, 0x200000, CRC(3b2afa7b) SHA1(d007e1d321c198a38c5baff86eb2ab84385d150a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 3, "epr-21576d.ic27", 0x000000, 0x200000, CRC(3b2afa7b) SHA1(d007e1d321c198a38c5baff86eb2ab84385d150a) ) \
 	ROM_SYSTEM_BIOS( 4, "bios4", "epr-21576b (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 4, "epr-21576b.ic27",  0x000000, 0x200000, CRC(755a6e07) SHA1(7e8b8ccfc063144d89668e7224dcd8a36c54f3b3) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 4, "epr-21576b.ic27", 0x000000, 0x200000, CRC(755a6e07) SHA1(7e8b8ccfc063144d89668e7224dcd8a36c54f3b3) ) \
 	ROM_SYSTEM_BIOS( 5, "bios5", "epr-21576a (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 5, "epr-21576a.ic27",  0x000000, 0x200000, CRC(cedfe439) SHA1(f27798bf3d890863ef0c1d9dcb4e7782249dca27) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 5, "epr-21576a.ic27", 0x000000, 0x200000, CRC(cedfe439) SHA1(f27798bf3d890863ef0c1d9dcb4e7782249dca27) ) \
 	ROM_SYSTEM_BIOS( 6, "bios6", "epr-21576 (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 6, "epr-21576.ic27", 0x000000, 0x200000, CRC(9dad3495) SHA1(5fb66f9a2b68d120f059c72758e65d34f461044a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 6, "epr-21576.ic27",  0x000000, 0x200000, CRC(9dad3495) SHA1(5fb66f9a2b68d120f059c72758e65d34f461044a) ) \
 	ROM_SYSTEM_BIOS( 7, "bios7", "epr-21578h (Export)" ) \
 	ROM_LOAD16_WORD_SWAP_BIOS( 7, "epr-21578h.ic27", 0x000000, 0x200000, CRC(7b452946) SHA1(8e9f153bbada24b37066dc45b64a7bf0d4f26a9b) ) \
 	ROM_SYSTEM_BIOS( 8, "bios8", "epr-21578g (Export)" ) \
 	ROM_LOAD16_WORD_SWAP_BIOS( 8, "epr-21578g.ic27", 0x000000, 0x200000, CRC(55413214) SHA1(bd2748365a9fc1821c9369aa7155d7c41c4df43e) ) \
 	ROM_SYSTEM_BIOS( 9, "bios9", "epr-21578e (Export)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 9, "epr-21578e.ic27",  0x000000, 0x200000, CRC(087f09a3) SHA1(0418eb2cf9766f0b1b874a4e92528779e22c0a4a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 9, "epr-21578e.ic27", 0x000000, 0x200000, CRC(087f09a3) SHA1(0418eb2cf9766f0b1b874a4e92528779e22c0a4a) ) \
 	ROM_SYSTEM_BIOS( 10, "bios10", "epr-21578d (Export)" ) \
 	ROM_LOAD16_WORD_SWAP_BIOS( 10, "epr-21578d.ic27",  0x000000, 0x200000, CRC(dfd5f42a) SHA1(614a0db4743a5e5a206190d6786ade24325afbfd) ) \
 	ROM_SYSTEM_BIOS( 11, "bios11", "epr-21578b (Export)" ) \
 	ROM_LOAD16_WORD_SWAP_BIOS( 11, "epr-21578b.ic27",  0x000000, 0x200000, CRC(6c9aad83) SHA1(555918de76d8dbee2a97d8a95297ef694b3e803f) ) \
-	ROM_SYSTEM_BIOS( 12, "bios12", "epr-21577g (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 12, "epr-21577g.ic27",  0x000000, 0x200000, CRC(25f64af7) SHA1(99f9e6cc0642319bd2da492611220540add573e8) ) \
-	ROM_SYSTEM_BIOS( 13, "bios13", "epr-21577e (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 13, "epr-21577e.ic27",  0x000000, 0x200000, CRC(cf36e97b) SHA1(b085305982e7572e58b03a9d35f17ae319c3bbc6) ) \
-	ROM_SYSTEM_BIOS( 14, "bios14", "epr-21577d (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 14, "epr-21577d.ic27",  0x000000, 0x200000, CRC(60ddcbbe) SHA1(58b15096d269d6df617ca1810b66b47deb184958) ) \
-	ROM_SYSTEM_BIOS( 15, "bios15", "epr-21579d (Korea)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 15, "epr-21579d.ic27",  0x000000, 0x200000, CRC(33513691) SHA1(b1d8c7c516e1471a788fcf7a02a794ad2f05aeeb) ) \
-	ROM_SYSTEM_BIOS( 16, "bios16", "epr-21579 (Korea)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 16, "epr-21579.ic27",  0x000000, 0x200000, CRC(71f9c918) SHA1(d15af8b947f41eea7c203b565cd403e3f37a2017) ) \
-	ROM_SYSTEM_BIOS( 17, "bios17", "Naomi Dev BIOS" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 17,  "dcnaodev.bios", 0x000000, 0x080000, CRC(7a50fab9) SHA1(ef79f448e0bf735d1264ad4f051d24178822110f) ) /* This one comes from a dev / beta board. The eprom was a 27C4096 */
+	ROM_SYSTEM_BIOS( 12, "bios12", "epr-21577h (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 12, "epr-21577h.ic27",  0x000000, 0x200000, CRC(fdf17452) SHA1(5f3e4b677f0046ce690a4f096b0481e5dd8bb6e6) ) \
+	ROM_SYSTEM_BIOS( 13, "bios13", "epr-21577g (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 13, "epr-21577g.ic27",  0x000000, 0x200000, CRC(25f64af7) SHA1(99f9e6cc0642319bd2da492611220540add573e8) ) \
+	ROM_SYSTEM_BIOS( 14, "bios14", "epr-21577e (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 14, "epr-21577e.ic27",  0x000000, 0x200000, CRC(cf36e97b) SHA1(b085305982e7572e58b03a9d35f17ae319c3bbc6) ) \
+	ROM_SYSTEM_BIOS( 15, "bios15", "epr-21577d (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 15, "epr-21577d.ic27",  0x000000, 0x200000, CRC(60ddcbbe) SHA1(58b15096d269d6df617ca1810b66b47deb184958) ) \
+	ROM_SYSTEM_BIOS( 16, "bios16", "epr-21579d (Korea)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 16, "epr-21579d.ic27",  0x000000, 0x200000, CRC(33513691) SHA1(b1d8c7c516e1471a788fcf7a02a794ad2f05aeeb) ) \
+	ROM_SYSTEM_BIOS( 17, "bios17", "epr-21579 (Korea)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 17, "epr-21579.ic27",  0x000000, 0x200000, CRC(71f9c918) SHA1(d15af8b947f41eea7c203b565cd403e3f37a2017) ) \
+	ROM_SYSTEM_BIOS( 18, "bios18", "Naomi Dev BIOS" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 18,  "dcnaodev.bios", 0x000000, 0x080000, CRC(7a50fab9) SHA1(ef79f448e0bf735d1264ad4f051d24178822110f) ) /* This one comes from a dev / beta board. The eprom was a 27C4096 */
 
 
 // bios for House of the Dead 2
@@ -2798,29 +2801,31 @@
 #define NAOMIGD_BIOS \
 	ROM_REGION( 0x200000, "maincpu", 0) \
 	ROM_SYSTEM_BIOS( 0, "bios0", "epr-21576e (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 0, "epr-21576e.bin",  0x000000, 0x200000, CRC(08c0add7) SHA1(e7c1a7673cb2ccb21748ef44105e46d1bad7266d) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 0, "epr-21576e.ic27",  0x000000, 0x200000, CRC(08c0add7) SHA1(e7c1a7673cb2ccb21748ef44105e46d1bad7266d) ) \
 	ROM_SYSTEM_BIOS( 1, "bios1", "epr-21576g (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 1, "epr-21576g.bin",  0x000000, 0x200000, CRC(d2a1c6bf) SHA1(6d27d71aec4dfba98f66316ae74a1426d567698a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 1, "epr-21576g.ic27",  0x000000, 0x200000, CRC(d2a1c6bf) SHA1(6d27d71aec4dfba98f66316ae74a1426d567698a) ) \
 	ROM_SYSTEM_BIOS( 2, "bios2", "epr-21576h (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 2, "epr-21576h.bin",  0x000000, 0x200000, CRC(d4895685) SHA1(91424d481ff99a8d3f4c45cea6d3f0eada049a6d) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 2, "epr-21576h.ic27",  0x000000, 0x200000, CRC(d4895685) SHA1(91424d481ff99a8d3f4c45cea6d3f0eada049a6d) ) \
 	ROM_SYSTEM_BIOS( 3, "bios3", "epr-21576d (Japan)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 3, "epr-21576d.bin",  0x000000, 0x200000, CRC(3b2afa7b) SHA1(d007e1d321c198a38c5baff86eb2ab84385d150a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 3, "epr-21576d.ic27",  0x000000, 0x200000, CRC(3b2afa7b) SHA1(d007e1d321c198a38c5baff86eb2ab84385d150a) ) \
 	ROM_SYSTEM_BIOS( 4, "bios4", "epr-21578h (Export)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 4, "epr-21578h.ic27", 0x000000, 0x200000, CRC(7b452946) SHA1(8e9f153bbada24b37066dc45b64a7bf0d4f26a9b) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 4, "epr-21578h.ic27",  0x000000, 0x200000, CRC(7b452946) SHA1(8e9f153bbada24b37066dc45b64a7bf0d4f26a9b) ) \
 	ROM_SYSTEM_BIOS( 5, "bios5", "epr-21578g (Export)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 5, "epr-21578g.ic27", 0x000000, 0x200000, CRC(55413214) SHA1(bd2748365a9fc1821c9369aa7155d7c41c4df43e) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 5, "epr-21578g.ic27",  0x000000, 0x200000, CRC(55413214) SHA1(bd2748365a9fc1821c9369aa7155d7c41c4df43e) ) \
 	ROM_SYSTEM_BIOS( 6, "bios6", "epr-21578e (Export)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 6, "epr-21578e.bin",  0x000000, 0x200000, CRC(087f09a3) SHA1(0418eb2cf9766f0b1b874a4e92528779e22c0a4a) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 6, "epr-21578e.ic27",  0x000000, 0x200000, CRC(087f09a3) SHA1(0418eb2cf9766f0b1b874a4e92528779e22c0a4a) ) \
 	ROM_SYSTEM_BIOS( 7, "bios7", "epr-21578d (Export)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 7, "epr-21578d.bin",  0x000000, 0x200000, CRC(dfd5f42a) SHA1(614a0db4743a5e5a206190d6786ade24325afbfd) ) \
-	ROM_SYSTEM_BIOS( 8, "bios8", "epr-21577g (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 8, "epr-21577g.bin",  0x000000, 0x200000, CRC(25f64af7) SHA1(99f9e6cc0642319bd2da492611220540add573e8) ) \
-	ROM_SYSTEM_BIOS( 9, "bios9", "epr-21577e (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 9, "epr-21577e.bin",  0x000000, 0x200000, CRC(cf36e97b) SHA1(b085305982e7572e58b03a9d35f17ae319c3bbc6) ) \
-	ROM_SYSTEM_BIOS( 10, "bios10", "epr-21577d (USA)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 10, "epr-21577d.bin",  0x000000, 0x200000, CRC(60ddcbbe) SHA1(58b15096d269d6df617ca1810b66b47deb184958) ) \
-	ROM_SYSTEM_BIOS( 11, "bios11", "epr-21579d (Korea)" ) \
-	ROM_LOAD16_WORD_SWAP_BIOS( 11, "epr-21579d.ic27",  0x000000, 0x200000, CRC(33513691) SHA1(b1d8c7c516e1471a788fcf7a02a794ad2f05aeeb) ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 7, "epr-21578d.ic27",  0x000000, 0x200000, CRC(dfd5f42a) SHA1(614a0db4743a5e5a206190d6786ade24325afbfd) ) \
+	ROM_SYSTEM_BIOS( 8, "bios8", "epr-21577h (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 8, "epr-21577h.ic27",  0x000000, 0x200000, CRC(fdf17452) SHA1(5f3e4b677f0046ce690a4f096b0481e5dd8bb6e6) ) \
+	ROM_SYSTEM_BIOS( 9, "bios9", "epr-21577g (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 9, "epr-21577g.ic27",  0x000000, 0x200000, CRC(25f64af7) SHA1(99f9e6cc0642319bd2da492611220540add573e8) ) \
+	ROM_SYSTEM_BIOS( 10, "bios10", "epr-21577e (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 10, "epr-21577e.ic27",  0x000000, 0x200000, CRC(cf36e97b) SHA1(b085305982e7572e58b03a9d35f17ae319c3bbc6) ) \
+	ROM_SYSTEM_BIOS( 11, "bios11", "epr-21577d (USA)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 11, "epr-21577d.ic27",  0x000000, 0x200000, CRC(60ddcbbe) SHA1(58b15096d269d6df617ca1810b66b47deb184958) ) \
+	ROM_SYSTEM_BIOS( 12, "bios12", "epr-21579d (Korea)" ) \
+	ROM_LOAD16_WORD_SWAP_BIOS( 12, "epr-21579d.ic27",  0x000000, 0x200000, CRC(33513691) SHA1(b1d8c7c516e1471a788fcf7a02a794ad2f05aeeb) ) \
 	ROM_REGION( 0x200000, "user2", 0) \
 	ROM_LOAD16_WORD_SWAP( "fpr-23489c.ic14", 0x000000, 0x200000, CRC(bc38bea1) SHA1(b36fcc6902f397d9749e9d02de1bbb7a5e29d468) )
 
@@ -6110,7 +6115,7 @@
 	NAOMI_DEFAULT_EEPROM
 
 	DISK_REGION( "gdrom" )
-	DISK_IMAGE_READONLY( "gdl-0018", 0, BAD_DUMP SHA1(3e40ca7d43173fe7048d199fdc127b9411e10360) )
+	DISK_IMAGE_READONLY( "gdl-0018", 0, SHA1(857d405b733c1de3534275a91afb939aec4e1279) )
 
 	ROM_REGION( 0x50, "pic", ROMREGION_ERASE)
 	//PIC16C622A (317-5091-JPN)
diff -Nru src-old/mame/drivers/naughtyb.c src/mame/drivers/naughtyb.c
--- src-old/mame/drivers/naughtyb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/naughtyb.c	2012-05-03 11:00:08.000000000 +0200
@@ -112,14 +112,14 @@
 
 READ8_MEMBER(naughtyb_state::in0_port_r)
 {
-	int in0 = input_port_read(machine(), "IN0");
+	int in0 = ioport("IN0")->read();
 
 	if ( m_cocktail )
 	{
 		// cabinet == cocktail -AND- handling player 2
 
 		in0 = ( in0 & 0x03 ) |				// start buttons
-			  ( input_port_read(machine(), "IN0_COCKTAIL") & 0xFC );	// cocktail inputs
+			  ( ioport("IN0_COCKTAIL")->read() & 0xFC );	// cocktail inputs
 	}
 
 	return in0;
@@ -129,8 +129,8 @@
 {
 	// vblank replaces the cabinet dip
 
-	return ( ( input_port_read(machine(), "DSW0") & 0x7F ) |		// dsw0
-			 ( input_port_read(machine(), "FAKE") & 0x80 ) );		// vblank
+	return ( ( ioport("DSW0")->read() & 0x7F ) |		// dsw0
+			 ( ioport("FAKE")->read() & 0x80 ) );		// vblank
 }
 
 /* Pop Flamer
@@ -331,7 +331,7 @@
 	PORT_START( "FAKE" )
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 ) PORT_CHANGED_MEMBER(DEVICE_SELF, naughtyb_state,coin_inserted, 0)
 	// when reading DSW0, bit 7 doesn't read cabinet, but vblank
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( trvmstr )
@@ -379,7 +379,7 @@
 	PORT_START( "FAKE" )
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 ) PORT_CHANGED_MEMBER(DEVICE_SELF, naughtyb_state,coin_inserted, 0)
 	// when reading DSW0, bit 7 doesn't read cabinet, but vblank
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/nbmj8688.c src/mame/drivers/nbmj8688.c
--- src-old/mame/drivers/nbmj8688.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nbmj8688.c	2012-05-01 00:02:17.000000000 +0200
@@ -42,14 +42,6 @@
 #include "machine/nvram.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
 static DRIVER_INIT( mjsikaku )
 {
 	nb1413m3_type = NB1413M3_MJSIKAKU;
@@ -316,7 +308,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xcf) AM_WRITE(nbmj8688_clut_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(secolove_romsel_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -341,7 +333,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READ_LEGACY(nb1413m3_inputport2_r) AM_WRITE(barline_output_w)
 	AM_RANGE(0xc0, 0xcf) AM_WRITE(nbmj8688_clut_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-//  AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE) //not used
+//  AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w) //not used
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(secolove_romsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) AM_WRITE(mjsikaku_scrolly_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -359,7 +351,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xcf) AM_WRITE(nbmj8688_clut_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(crystalg_romsel_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf0, 0xf0) AM_WRITENOP
@@ -379,7 +371,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) AM_WRITE(mjsikaku_scrolly_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -399,7 +391,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
     AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) AM_WRITE(mjsikaku_scrolly_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -420,7 +412,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -442,7 +434,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -462,7 +454,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -487,7 +479,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xcf) AM_WRITE(nbmj8688_clut_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(secolove_romsel_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -508,7 +500,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -530,7 +522,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xd0, 0xd0) AM_READ(ff_r)	// irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(mjsikaku_gfxflag2_w)
 //  AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 //  AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -1345,7 +1337,6 @@
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
-
 static INPUT_PORTS_START( citylove )
 	PORT_START("DSWA")
 	PORT_DIPNAME( 0x0f, 0x0f, DEF_STR( Difficulty ) )
@@ -2915,7 +2906,6 @@
 };
 
 
-
 static MACHINE_CONFIG_START( NBMJDRV_4096, nbmj8688_state )
 
 	/* basic machine hardware */
@@ -2946,10 +2936,9 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.00)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( NBMJDRV_256, NBMJDRV_4096 )
 
 	/* basic machine hardware */
@@ -2961,7 +2950,6 @@
 	MCFG_VIDEO_START(mbmj8688_8bit)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( NBMJDRV_65536, NBMJDRV_4096 )
 
 	/* basic machine hardware */
@@ -2974,7 +2962,6 @@
 	MCFG_VIDEO_START(mbmj8688_hybrid_16bit)
 MACHINE_CONFIG_END
 
-
 // --------------------------------------------------------------------------------
 
 static MACHINE_CONFIG_DERIVED( crystalg, NBMJDRV_256 )
@@ -2985,7 +2972,6 @@
 	MCFG_CPU_IO_MAP(crystalg_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( apparel, NBMJDRV_256 )
 
 	/* basic machine hardware */
@@ -2994,7 +2980,6 @@
 	MCFG_CPU_IO_MAP(secolove_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( mbmj_h12bit, NBMJDRV_4096 )
 
 	/* basic machine hardware */
@@ -3014,7 +2999,7 @@
 	MCFG_CPU_IO_MAP(barline_io_map)
 
 	MCFG_SOUND_REPLACE("psg", YM3812, 20000000/8)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
 
 	MCFG_DEVICE_REMOVE("dac")
 MACHINE_CONFIG_END
@@ -3030,7 +3015,6 @@
 	MCFG_VIDEO_START(mbmj8688_pure_16bit)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_START( mbmj_p16bit_LCD, nbmj8688_state )
 
 	/* basic machine hardware */
@@ -3079,10 +3063,9 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.00)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( seiha, NBMJDRV_65536 )
 
 	/* basic machine hardware */
@@ -3108,7 +3091,6 @@
 	MCFG_CPU_IO_MAP(iemoto_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( ojousan, NBMJDRV_65536 )
 
 	/* basic machine hardware */
@@ -3125,7 +3107,6 @@
 	MCFG_CPU_IO_MAP(kaguya_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( mjsikaku, NBMJDRV_4096 )
 
 	/* basic machine hardware */
@@ -3138,7 +3119,6 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( mmsikaku, NBMJDRV_4096 )
 
 	/* basic machine hardware */
@@ -3147,7 +3127,6 @@
 	MCFG_CPU_IO_MAP(mmsikaku_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( otonano, mjsikaku )
 
 	/* basic machine hardware */
@@ -3156,8 +3135,6 @@
 MACHINE_CONFIG_END
 
 
-
-
 ROM_START( crystalg )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* program */
 	ROM_LOAD( "mbs1.3c",  0x00000, 0x04000, CRC(1cacdbbd) SHA1(672e67b761ef1723ec2445f13881a435dbbdf53f) )
@@ -3454,14 +3431,14 @@
 
 	/*TODO: check if the w labeled roms are correctly mapped.*/
     ROM_REGION( 0x400000, "gfx1", 0 ) /* gfx */
-    ROM_LOAD( "se1507.6a",0x000000, 0x80000, CRC(f1e9555e) SHA1(a34ffcff2b2d6ba40a8a453b89970d636515a8ad) ) // seiha/se1507.6a
+    ROM_LOAD( "se1507.6a",0x000000, 0x80000, CRC(f1e9555e) SHA1(a34ffcff2b2d6ba40a8a453b89970d636515a8ad) )	// seiha/se1507.6a
     ROM_LOAD( "w19.1a",   0x080000, 0x40000, CRC(788cd3ca) SHA1(955a520e122aaee30e080d0a784556b69ba3de36) )
     ROM_LOAD( "w20.2a",   0x0c0000, 0x40000, CRC(a3175a8f) SHA1(8214fdefa1186dd96bc55a30b64a24a486750f05) )
     ROM_LOAD( "w21.3a",   0x100000, 0x40000, CRC(da46163e) SHA1(c6e5f59fe813915f94d81ff28526614c943b7082) )
-    ROM_LOAD( "6.2a",     0x180000, 0x10000, CRC(9fefe2ca) SHA1(7b638a739640e9d311ee15c0e7b4f3f2dfdd3589) ) // seiha/seiha06.8a
-    ROM_LOAD( "7.3a",     0x190000, 0x10000, CRC(a7d438ec) SHA1(5d145bab0ffc76fd77582ea5495ca4496210d41a) )            // seiha/seiha07.9a
+    ROM_LOAD( "6.2a",     0x180000, 0x10000, CRC(9fefe2ca) SHA1(7b638a739640e9d311ee15c0e7b4f3f2dfdd3589) )	// seiha/seiha06.8a
+    ROM_LOAD( "7.3a",     0x190000, 0x10000, CRC(a7d438ec) SHA1(5d145bab0ffc76fd77582ea5495ca4496210d41a) )	// seiha/seiha07.9a
     ROM_LOAD( "8.4a",     0x1a0000, 0x10000, CRC(e8e61e48) SHA1(e1d0e64b39bad3e294b061fb6f02ece2f2ee4bca) )
-    ROM_LOAD( "9.2b",     0x1b0000, 0x10000, CRC(541f6e9f) SHA1(946a9c9cc8e6985098af4dd035f80ecc50e800ec) )            // seiha/seiha05.1i
+    ROM_LOAD( "9.2b",     0x1b0000, 0x10000, CRC(541f6e9f) SHA1(946a9c9cc8e6985098af4dd035f80ecc50e800ec) )	// seiha/seiha05.1i
     ROM_LOAD( "10.3b",    0x1c0000, 0x10000, CRC(a4144f78) SHA1(316ebe91aa604f1d4a0f1942df9d87de487c977a) )
     ROM_LOAD( "w22.4a",   0x200000, 0x40000, CRC(ea2b78b3) SHA1(38ec10a29f32cbb6b270fa10ade815cf3e0a54c2) )
     ROM_LOAD( "w23.5a",   0x240000, 0x40000, CRC(0263ff75) SHA1(16a18dfaf732ab94dec70fd8e955d6179525115c) )
@@ -4035,6 +4012,7 @@
 	ROM_LOAD( "16061.k7", 0x000, 0x104, CRC(d25ccac8) SHA1(cfad5a4cd9609ac2461314d77a5e0cecd326c63b) )
 ROM_END
 
+
 /* 8-bit palette */
 GAME( 1986, crystalg, 0,        crystalg,        crystalg, crystalg, ROT0, "Nichibutsu", "Crystal Gal (Japan 860512)", 0 )
 GAME( 1986, crystal2, 0,        crystalg,        crystal2, crystal2, ROT0, "Nichibutsu", "Crystal Gal 2 (Japan 860620)", 0 )
@@ -4085,12 +4063,3 @@
 GAME( 1988, mmsikaku, mjsikaku, mmsikaku,        mmsikaku, mmsikaku, ROT0, "Nichibutsu", "Mahjong Shikaku [BET] (Japan 880929)", 0 )
 GAME( 1988, otonano,  0,        otonano,         otonano,  otonano,  ROT0, "Apple", "Otona no Mahjong (Japan 880628)", 0 )
 GAME( 1988, mjcamera, 0,        otonano,         mjcamera, mjcamera, ROT0, "Miki Syouji", "Mahjong Camera Kozou (set 1) (Japan 881109)", 0 )
-
-
-/*
-
-iemotom     outcoin check
-ojousanm    outcoin check
-ryuuha      outcoin check
-
-*/
diff -Nru src-old/mame/drivers/nbmj8891.c src/mame/drivers/nbmj8891.c
--- src-old/mame/drivers/nbmj8891.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nbmj8891.c	2012-05-01 00:02:17.000000000 +0200
@@ -51,14 +51,6 @@
 #include "machine/nvram.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
 static DRIVER_INIT( gionbana )
 {
 	UINT8 *prot = machine.root_device().memregion("protection")->base();
@@ -451,7 +443,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r) //AM_WRITENOP
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(nbmj8891_vramsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -470,7 +462,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r) //AM_WRITENOP
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(nbmj8891_vramsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -493,7 +485,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r) AM_WRITENOP
 	AM_RANGE(0xd0, 0xdf) AM_READ(nbmj8891_clut_r)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
 ADDRESS_MAP_END
@@ -511,7 +503,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r) //AM_WRITENOP
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) //AM_WRITENOP
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -530,7 +522,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r) //AM_WRITENOP
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) //AM_WRITENOP
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -549,7 +541,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READWRITE_LEGACY(nb1413m3_inputport3_r,nb1413m3_nmi_clock_w)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r) //AM_WRITENOP
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -569,7 +561,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READWRITE_LEGACY(nb1413m3_inputport3_r,nb1413m3_nmi_clock_w)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -589,7 +581,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READWRITE_LEGACY(nb1413m3_inputport3_r,nb1413m3_nmi_clock_w)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -608,7 +600,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_PORT("PORT0-2")
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(nbmj8891_vramsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -627,7 +619,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_PORT("PORT0-2") //AM_WRITENOP
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(nbmj8891_vramsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -643,7 +635,7 @@
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 //  AM_RANGE(0xc0, 0xc0) AM_WRITENOP                    // ?
 //  AM_RANGE(0xd0, 0xd0) AM_READ_LEGACY(ff_r)  // irq ack? watchdog?
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_READ_LEGACY(nb1413m3_dipsw3_h_r) AM_WRITE(nbmj8891_taiwanmb_gfxdraw_w)	// blitter draw start
 	AM_RANGE(0xe1, 0xe1) AM_READ_LEGACY(nb1413m3_dipsw3_l_r)
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw2_r,nb1413m3_outcoin_w)
@@ -2604,8 +2596,6 @@
 };
 
 
-
-
 static MACHINE_CONFIG_START( gionbana, nbmj8891_state )
 
 	/* basic machine hardware */
@@ -2638,7 +2628,6 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( mgion, gionbana )
 
 	/* basic machine hardware */
@@ -2649,7 +2638,6 @@
 	MCFG_NVRAM_ADD_0FILL("nvram")
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( omotesnd, gionbana )
 
 	/* basic machine hardware */
@@ -2665,7 +2653,6 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
 MACHINE_CONFIG_END
 
-
 /* NBMJDRV2 */
 static MACHINE_CONFIG_DERIVED( mjcamerb, gionbana )
 
@@ -2708,7 +2695,6 @@
 	MCFG_VIDEO_START(nbmj8891_1layer)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( msjiken, hanamomo )
 
 	/* basic machine hardware */
@@ -2717,8 +2703,6 @@
 	MCFG_CPU_IO_MAP(msjiken_io_map)
 MACHINE_CONFIG_END
 
-
-
 /* NBMJDRV3 */
 static MACHINE_CONFIG_DERIVED( telmahjn, gionbana )
 
@@ -2735,7 +2719,6 @@
 	MCFG_VIDEO_START(nbmj8891_1layer)
 MACHINE_CONFIG_END
 
-
 /* NBMJDRV5 */
 static MACHINE_CONFIG_DERIVED( mjnanpas, gionbana )
 
@@ -2744,7 +2727,6 @@
 	MCFG_CPU_PROGRAM_MAP(club90s_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( maiko, mjnanpas )
 
 	/* basic machine hardware */
@@ -2753,7 +2735,6 @@
 	MCFG_CPU_IO_MAP(maiko_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( mmaiko, maiko )
 
 	/* basic machine hardware */
@@ -2763,7 +2744,6 @@
 	MCFG_NVRAM_ADD_0FILL("nvram")
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( lovehous, mjnanpas )
 
 	/* basic machine hardware */
@@ -2774,7 +2754,6 @@
 	MCFG_NVRAM_ADD_0FILL("nvram")
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( hanaoji, maiko )
 
 	/* basic machine hardware */
@@ -2808,7 +2787,6 @@
 	MCFG_CPU_IO_MAP(scandal_io_map)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( bananadr, mjnanpas )
 
 	/* basic machine hardware */
@@ -2819,7 +2797,6 @@
 	MCFG_NVRAM_ADD_0FILL("nvram")
 MACHINE_CONFIG_END
 
-
 /* NBMJDRV6 */
 static MACHINE_CONFIG_DERIVED( mjfocusm, gionbana )
 
@@ -2838,10 +2815,9 @@
 	/* sound hardware */
 	MCFG_SOUND_REPLACE("fmsnd", AY8910, 1250000)
 	MCFG_SOUND_CONFIG(ay8910_config)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( taiwanmb, gionbana )
 
 	/* basic machine hardware */
@@ -2860,11 +2836,10 @@
 	/* sound hardware */
 	MCFG_SOUND_REPLACE("fmsnd", AY8910, 1250000)
 	MCFG_SOUND_CONFIG(ay8910_config)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
 
-
 ROM_START( gionbana )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* program */
 	ROM_LOAD( "gion_03.bin", 0x00000, 0x10000, CRC(615e993b) SHA1(6efda8d1f0d5be6418a73dd86b898bb518de3f8b) )
@@ -3835,6 +3810,7 @@
 	DISK_IMAGE_READONLY( "hnageman", 0, NO_DUMP )
 ROM_END
 
+
 //     YEAR,     NAME,   PARENT,  MACHINE,    INPUT,     INIT, MONITOR,COMPANY,FULLNAME,FLAGS)
 GAME( 1988, msjiken,   0,        msjiken,  msjiken,  msjiken,  ROT270, "Nichibutsu", "Mahjong Satsujin Jiken (Japan 881017)", 0 )
 GAME( 1988, hanamomo,  0,        hanamomo, hanamomo, hanamomo, ROT0,   "Nichibutsu", "Mahjong Hana no Momoko gumi (Japan 881201)", 0 )
diff -Nru src-old/mame/drivers/nbmj8900.c src/mame/drivers/nbmj8900.c
--- src-old/mame/drivers/nbmj8900.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nbmj8900.c	2012-05-01 00:02:17.000000000 +0200
@@ -32,16 +32,6 @@
 #include "includes/nbmj8900.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
-
-
 static DRIVER_INIT( ohpaipee )
 {
 #if 0
@@ -71,8 +61,6 @@
 #endif
 
 	nb1413m3_type = NB1413M3_OHPAIPEE;
-
-//  init_nb1413m3(machine);
 }
 
 static DRIVER_INIT( togenkyo )
@@ -103,8 +91,6 @@
 #endif
 
 	nb1413m3_type = NB1413M3_TOGENKYO;
-
-//S init_nb1413m3(machine);
 }
 
 
@@ -139,7 +125,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READ_LEGACY(nb1413m3_inputport3_r)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 	AM_RANGE(0xe0, 0xe0) AM_WRITE(nbmj8900_vramsel_w)
 	AM_RANGE(0xf0, 0xf0) AM_READ_LEGACY(nb1413m3_dipsw1_r)
 	AM_RANGE(0xf1, 0xf1) AM_READWRITE_LEGACY(nb1413m3_dipsw2_r, nb1413m3_outcoin_w)
@@ -341,13 +327,12 @@
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 	MCFG_SOUND_ADD("ymsnd", YM3812, 2500000)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.85)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( togenkyo, ohpaipee )
 
 	/* basic machine hardware */
@@ -356,7 +341,6 @@
 MACHINE_CONFIG_END
 
 
-
 ROM_START( ohpaipee )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* program */
 	ROM_LOAD( "02.3h",  0x00000, 0x10000, CRC(2b6c9afc) SHA1(591a7016ebd99d4a2bfdef5e99da3a1ac9d30d75) )
diff -Nru src-old/mame/drivers/nbmj8991.c src/mame/drivers/nbmj8991.c
--- src-old/mame/drivers/nbmj8991.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nbmj8991.c	2012-05-01 00:02:17.000000000 +0200
@@ -38,14 +38,6 @@
 #include "machine/nvram.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
 WRITE8_MEMBER(nbmj8991_state::nbmj8991_soundbank_w)
 {
 	if (!(data & 0x80)) soundlatch_clear_byte_w(space, 0, 0);
@@ -261,7 +253,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READWRITE_LEGACY(nb1413m3_inputport3_r,nb1413m3_nmi_clock_w)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -276,7 +268,7 @@
 	AM_RANGE(0xa0, 0xa0) AM_READWRITE_LEGACY(nb1413m3_inputport1_r,nb1413m3_inputportsel_w)
 	AM_RANGE(0xb0, 0xb0) AM_READWRITE_LEGACY(nb1413m3_inputport2_r,nb1413m3_sndrombank1_w)
 	AM_RANGE(0xc0, 0xc0) AM_READWRITE_LEGACY(nb1413m3_inputport3_r,nb1413m3_nmi_clock_w)
-	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", DAC_WRITE)
+	AM_RANGE(0xd0, 0xd0) AM_DEVWRITE_LEGACY("dac", dac_w)
 //  AM_RANGE(0xe0, 0xe0) AM_WRITENOP
 	AM_RANGE(0xf0, 0xf0) AM_READWRITE_LEGACY(nb1413m3_dipsw1_r,nb1413m3_outcoin_w)
 	AM_RANGE(0xf1, 0xf1) AM_READ_LEGACY(nb1413m3_dipsw2_r)
@@ -318,8 +310,8 @@
 
 static ADDRESS_MAP_START( nbmj8991_sound_io_map, AS_IO, 8, nbmj8991_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
-	AM_RANGE(0x00, 0x00) AM_READ(nbmj8991_sound_r) AM_DEVWRITE_LEGACY("dac1", DAC_WRITE)
-	AM_RANGE(0x02, 0x02) AM_DEVWRITE_LEGACY("dac2", DAC_WRITE)
+	AM_RANGE(0x00, 0x00) AM_READ(nbmj8991_sound_r) AM_DEVWRITE_LEGACY("dac1", dac_w)
+	AM_RANGE(0x02, 0x02) AM_DEVWRITE_LEGACY("dac2", dac_w)
 	AM_RANGE(0x04, 0x04) AM_WRITE(nbmj8991_soundbank_w)
 	AM_RANGE(0x06, 0x06) AM_WRITENOP
 	AM_RANGE(0x80, 0x81) AM_DEVWRITE_LEGACY("fmsnd", ym3812_w)
diff -Nru src-old/mame/drivers/nbmj9195.c src/mame/drivers/nbmj9195.c
--- src-old/mame/drivers/nbmj9195.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nbmj9195.c	2012-05-03 11:00:08.000000000 +0200
@@ -30,14 +30,6 @@
 #include "includes/nbmj9195.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
 WRITE8_MEMBER(nbmj9195_state::nbmj9195_soundbank_w)
 {
 	UINT8 *SNDROM = memregion("audiocpu")->base();
@@ -80,7 +72,7 @@
 static int nbmj9195_dipsw_r(running_machine &machine)
 {
 	nbmj9195_state *state = machine.driver_data<nbmj9195_state>();
-	return ((((input_port_read(machine, "DSWA") & 0xff) | ((input_port_read(machine, "DSWB") & 0xff) << 8)) >> state->m_dipswbitsel) & 0x01);
+	return (((state->ioport("DSWA")->read() & 0xff) | ((state->ioport("DSWB")->read() & 0xff) << 8)) >> state->m_dipswbitsel) & 0x01;
 }
 
 static void nbmj9195_dipswbitsel_w(address_space *space, int data)
@@ -112,19 +104,19 @@
 READ8_MEMBER(nbmj9195_state::mscoutm_dipsw_0_r)
 {
 	// DIPSW A
-	return (((input_port_read(machine(), "DSWA") & 0x01) << 7) | ((input_port_read(machine(), "DSWA") & 0x02) << 5) |
-	        ((input_port_read(machine(), "DSWA") & 0x04) << 3) | ((input_port_read(machine(), "DSWA") & 0x08) << 1) |
-	        ((input_port_read(machine(), "DSWA") & 0x10) >> 1) | ((input_port_read(machine(), "DSWA") & 0x20) >> 3) |
-	        ((input_port_read(machine(), "DSWA") & 0x40) >> 5) | ((input_port_read(machine(), "DSWA") & 0x80) >> 7));
+	return (((ioport("DSWA")->read() & 0x01) << 7) | ((ioport("DSWA")->read() & 0x02) << 5) |
+	        ((ioport("DSWA")->read() & 0x04) << 3) | ((ioport("DSWA")->read() & 0x08) << 1) |
+	        ((ioport("DSWA")->read() & 0x10) >> 1) | ((ioport("DSWA")->read() & 0x20) >> 3) |
+	        ((ioport("DSWA")->read() & 0x40) >> 5) | ((ioport("DSWA")->read() & 0x80) >> 7));
 }
 
 READ8_MEMBER(nbmj9195_state::mscoutm_dipsw_1_r)
 {
 	// DIPSW B
-	return (((input_port_read(machine(), "DSWB") & 0x01) << 7) | ((input_port_read(machine(), "DSWB") & 0x02) << 5) |
-	        ((input_port_read(machine(), "DSWB") & 0x04) << 3) | ((input_port_read(machine(), "DSWB") & 0x08) << 1) |
-	        ((input_port_read(machine(), "DSWB") & 0x10) >> 1) | ((input_port_read(machine(), "DSWB") & 0x20) >> 3) |
-	        ((input_port_read(machine(), "DSWB") & 0x40) >> 5) | ((input_port_read(machine(), "DSWB") & 0x80) >> 7));
+	return (((ioport("DSWB")->read() & 0x01) << 7) | ((ioport("DSWB")->read() & 0x02) << 5) |
+	        ((ioport("DSWB")->read() & 0x04) << 3) | ((ioport("DSWB")->read() & 0x08) << 1) |
+	        ((ioport("DSWB")->read() & 0x10) >> 1) | ((ioport("DSWB")->read() & 0x20) >> 3) |
+	        ((ioport("DSWB")->read() & 0x40) >> 5) | ((ioport("DSWB")->read() & 0x80) >> 7));
 }
 
 
@@ -144,30 +136,30 @@
 		{
 			case 0:			/* PA_0 */
 				// COIN IN, ETC...
-				portdata = input_port_read(machine(), "SYSTEM");
+				portdata = ioport("SYSTEM")->read();
 				break;
 			case 1:			/* PB_0 */
 				// PLAYER1 KEY, DIPSW A/B
 				switch (m_mscoutm_inputport)
 				{
 					case 0x01:
-						portdata = input_port_read(machine(), "KEY0");
+						portdata = ioport("KEY0")->read();
 						break;
 					case 0x02:
-						portdata = input_port_read(machine(), "KEY1");
+						portdata = ioport("KEY1")->read();
 						break;
 					case 0x04:
-						portdata = input_port_read(machine(), "KEY2");
+						portdata = ioport("KEY2")->read();
 						break;
 					case 0x08:
-						portdata = input_port_read(machine(), "KEY3");
+						portdata = ioport("KEY3")->read();
 						break;
 					case 0x10:
-						portdata = input_port_read(machine(), "KEY4");
+						portdata = ioport("KEY4")->read();
 						break;
 					default:
-						portdata = (input_port_read(machine(), "KEY0") & input_port_read(machine(), "KEY1") & input_port_read(machine(), "KEY2")
-									& input_port_read(machine(), "KEY3") & input_port_read(machine(), "KEY4"));
+						portdata = (ioport("KEY0")->read() & ioport("KEY1")->read() & ioport("KEY2")->read()
+									& ioport("KEY3")->read() & ioport("KEY4")->read());
 						break;
 				}
 				break;
@@ -176,23 +168,23 @@
 				switch (m_mscoutm_inputport)
 				{
 					case 0x01:
-						portdata = input_port_read(machine(), "KEY5");
+						portdata = ioport("KEY5")->read();
 						break;
 					case 0x02:
-						portdata = input_port_read(machine(), "KEY6");
+						portdata = ioport("KEY6")->read();
 						break;
 					case 0x04:
-						portdata = input_port_read(machine(), "KEY7");
+						portdata = ioport("KEY7")->read();
 						break;
 					case 0x08:
-						portdata = input_port_read(machine(), "KEY8");
+						portdata = ioport("KEY8")->read();
 						break;
 					case 0x10:
-						portdata = input_port_read(machine(), "KEY9");
+						portdata = ioport("KEY9")->read();
 						break;
 					default:
-						portdata = (input_port_read(machine(), "KEY5") & input_port_read(machine(), "KEY6") & input_port_read(machine(), "KEY7")
-									& input_port_read(machine(), "KEY8") & input_port_read(machine(), "KEY9"));
+						portdata = (ioport("KEY5")->read() & ioport("KEY6")->read() & ioport("KEY7")->read()
+									& ioport("KEY8")->read() & ioport("KEY9")->read());
 						break;
 				}
 				break;
@@ -231,29 +223,29 @@
 		{
 			case 0:			/* PA_0 */
 				// COIN IN, ETC...
-				portdata = ((input_port_read(machine(), "SYSTEM") & 0xfe) | m_outcoin_flag);
+				portdata = ((ioport("SYSTEM")->read() & 0xfe) | m_outcoin_flag);
 				break;
 			case 1:			/* PB_0 */
 				// PLAYER1 KEY, DIPSW A/B
 				switch (m_inputport)
 				{
 					case 0x01:
-						portdata = input_port_read(machine(), "KEY0");
+						portdata = ioport("KEY0")->read();
 						break;
 					case 0x02:
-						portdata = input_port_read(machine(), "KEY1");
+						portdata = ioport("KEY1")->read();
 						break;
 					case 0x04:
-						portdata = input_port_read(machine(), "KEY2");
+						portdata = ioport("KEY2")->read();
 						break;
 					case 0x08:
-						portdata = input_port_read(machine(), "KEY3");
+						portdata = ioport("KEY3")->read();
 						break;
 					case 0x10:
-						portdata = ((input_port_read(machine(), "KEY4") & 0x7f) | (nbmj9195_dipsw_r(machine()) << 7));
+						portdata = ((ioport("KEY4")->read() & 0x7f) | (nbmj9195_dipsw_r(machine()) << 7));
 						break;
 					default:
-						portdata = (input_port_read(machine(), "KEY0") & input_port_read(machine(), "KEY1") & input_port_read(machine(), "KEY2") & input_port_read(machine(), "KEY3") & (input_port_read(machine(), "KEY4") & 0x7f));
+						portdata = (ioport("KEY0")->read() & ioport("KEY1")->read() & ioport("KEY2")->read() & ioport("KEY3")->read() & (ioport("KEY4")->read() & 0x7f));
 						break;
 				}
 				break;
@@ -262,22 +254,22 @@
 				switch (m_inputport)
 				{
 					case 0x01:
-						portdata = input_port_read(machine(), "KEY5");
+						portdata = ioport("KEY5")->read();
 						break;
 					case 0x02:
-						portdata = input_port_read(machine(), "KEY6");
+						portdata = ioport("KEY6")->read();
 						break;
 					case 0x04:
-						portdata = input_port_read(machine(), "KEY7");
+						portdata = ioport("KEY7")->read();
 						break;
 					case 0x08:
-						portdata = input_port_read(machine(), "KEY8");
+						portdata = ioport("KEY8")->read();
 						break;
 					case 0x10:
-						portdata = input_port_read(machine(), "KEY9") & 0x7f;
+						portdata = ioport("KEY9")->read() & 0x7f;
 						break;
 					default:
-						portdata = (input_port_read(machine(), "KEY5") & input_port_read(machine(), "KEY6") & input_port_read(machine(), "KEY7") & input_port_read(machine(), "KEY8") & (input_port_read(machine(), "KEY9") & 0x7f));
+						portdata = (ioport("KEY5")->read() & ioport("KEY6")->read() & ioport("KEY7")->read() & ioport("KEY8")->read() & (ioport("KEY9")->read() & 0x7f));
 						break;
 				}
 				break;
@@ -341,10 +333,10 @@
 				nbmj9195_soundbank_w(space, 0, data);
 				break;
 			case 6:			/* PB_1 */
-				DAC_WRITE(machine().device("dac2"), 0, data);
+				dac_w(machine().device("dac2"), 0, data);
 				break;
 			case 7:			/* PC_1 */
-				DAC_WRITE(machine().device("dac1"), 0, data);
+				dac_w(machine().device("dac1"), 0, data);
 				break;
 			case 8:			/* PD_1 */
 				break;
@@ -379,10 +371,10 @@
 				nbmj9195_soundbank_w(space, 0, data);
 				break;
 			case 6:			/* PB_1 */
-				DAC_WRITE(machine().device("dac2"), 0, data);
+				dac_w(machine().device("dac1"), 0, data);
 				break;
 			case 7:			/* PC_1 */
-				DAC_WRITE(machine().device("dac1"), 0, data);
+				dac_w(machine().device("dac2"), 0, data);
 				break;
 			case 8:			/* PD_1 */
 				break;
@@ -669,6 +661,7 @@
 
 	// initialize sound rom bank
 	state->nbmj9195_soundbank_w(*space, 0, 0);
+	logerror("DRIVER_INIT( nbmj9195 )\n");
 }
 
 static ADDRESS_MAP_START( tmpz84c011_regs, AS_IO, 8, nbmj9195_state )
@@ -739,7 +732,6 @@
 	AM_RANGE(0xb6, 0xb6) AM_WRITE(nbmj9195_inputportsel_w)
 ADDRESS_MAP_END
 
-
 static ADDRESS_MAP_START( koinomp_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -759,7 +751,6 @@
 	AM_RANGE(0xcf, 0xcf) AM_WRITENOP
 ADDRESS_MAP_END
 
-
 static ADDRESS_MAP_START( patimono_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -846,7 +837,6 @@
 	AM_RANGE(0xf0, 0xff) AM_WRITE(nbmj9195_clut_1_w)
 ADDRESS_MAP_END
 
-
 static ADDRESS_MAP_START( mkeibaou_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -865,7 +855,6 @@
 	AM_RANGE(0xde, 0xde) AM_WRITE(nbmj9195_inputportsel_w)
 ADDRESS_MAP_END
 
-
 static ADDRESS_MAP_START( pachiten_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -920,7 +909,6 @@
 	AM_RANGE(0xfe, 0xfe) AM_WRITE(nbmj9195_inputportsel_w)
 ADDRESS_MAP_END
 
-
 static ADDRESS_MAP_START( psailor1_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -993,6 +981,24 @@
 	AM_RANGE(0xd0, 0xdf) AM_WRITE(nbmj9195_clut_1_w)
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( yosimotm_io_map, AS_IO, 8, nbmj9195_state )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+	AM_IMPORT_FROM( tmpz84c011_regs )
+
+	AM_RANGE(0x60, 0x61) AM_READ(nbmj9195_blitter_0_r)
+	AM_RANGE(0x60, 0x6f) AM_WRITE(nbmj9195_blitter_0_w)
+	AM_RANGE(0x70, 0x7f) AM_WRITE(nbmj9195_clut_0_w)
+
+	AM_RANGE(0x80, 0x81) AM_READ(nbmj9195_blitter_1_r)
+	AM_RANGE(0x80, 0x8f) AM_WRITE(nbmj9195_blitter_1_w)
+	AM_RANGE(0x90, 0x9f) AM_WRITE(nbmj9195_clut_1_w)
+
+	AM_RANGE(0xf0, 0xf0) AM_WRITE(nbmj9195_inputportsel_w)
+	AM_RANGE(0xfc, 0xfc) AM_WRITE(nbmj9195_sound_w)
+	AM_RANGE(0xf4, 0xf4) AM_NOP
+	AM_RANGE(0xf8, 0xf8) AM_NOP
+ADDRESS_MAP_END
+
 static ADDRESS_MAP_START( jituroku_io_map, AS_IO, 8, nbmj9195_state )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	AM_IMPORT_FROM( tmpz84c011_regs )
@@ -2415,7 +2421,7 @@
 	PORT_DIPNAME( 0x40, 0x00, "Voices" )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Flip_Screen ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
@@ -2457,6 +2463,75 @@
 	PORT_INCLUDE( nbmjcontrols )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( yosimotm )
+
+	// I don't have manual for this game.
+
+	PORT_START("DSWA")
+	PORT_DIPNAME( 0x01, 0x01, "DIPSW 1-1" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "DIPSW 1-2" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, "DIPSW 1-3" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, "DIPSW 1-4" )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, "DIPSW 1-5" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "DIPSW 1-6" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "Character Display Test" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Graphic ROM Test" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSWB")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "Character Display Test" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, "Score Pool" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, "DIPSW 2-4" )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, "DIPSW 2-5" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "DIPSW 2-6" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "DIPSW 2-7" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "DIPSW 2-8" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNUSED )			// COIN OUT
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE3 )		// MEMORY RESET
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE2 )		// ANALYZER
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Credit Clear") PORT_CODE(KEYCODE_4) // CREDIT CLEAR
+	PORT_SERVICE( 0x10, IP_ACTIVE_LOW )					// TEST
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )			// COIN1
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )			// COIN2
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SERVICE1 )		// SERVICE
+
+	PORT_INCLUDE( nbmjcontrols )
+INPUT_PORTS_END
+
 static INPUT_PORTS_START( jituroku )
 
 	// I don't have manual for this game.
@@ -2474,7 +2549,7 @@
 	PORT_DIPNAME( 0x08, 0x08, "DIPSW 1-4" )
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Flip_Screen ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x20, 0x20, "DIPSW 1-6" )
@@ -3102,10 +3177,10 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 
 	MCFG_SOUND_ADD("dac1", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
 	MCFG_SOUND_ADD("dac2", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
 
@@ -3281,6 +3356,16 @@
 MACHINE_CONFIG_END
 
 
+static MACHINE_CONFIG_DERIVED( yosimotm, NBMJDRV1 )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_IO_MAP(yosimotm_io_map)
+
+	MCFG_NVRAM_ADD_0FILL("nvram")
+MACHINE_CONFIG_END
+
+
 static MACHINE_CONFIG_DERIVED( jituroku, NBMJDRV1 )
 
 	/* basic machine hardware */
@@ -3706,6 +3791,22 @@
 	ROM_LOAD( "8.9h",  0x280000, 0x80000, CRC(dbad97fc) SHA1(ead04086ffec53ede90e3ebcf150018a91bb8457) )
 ROM_END
 
+ROM_START( yosimotm )
+	ROM_REGION( 0x10000, "maincpu", 0 ) /* main program */
+	ROM_LOAD( "1.7c",  0x00000,  0x10000, CRC(d156b07d) SHA1(8dcf2d8ac60920dc7ea286d4b91399ed2db05a3b) )
+
+	ROM_REGION( 0x20000, "audiocpu", 0 ) /* sound program */
+	ROM_LOAD( "2.12e", 0x00000,  0x20000, CRC(e2d84085) SHA1(890b4d4a02030253837b67e8232293dce30d7ca2) )
+
+	ROM_REGION( 0x300000, "gfx1", 0 ) /* gfx */
+	ROM_LOAD( "3.3h",  0x000000, 0x80000, CRC(f421c6c8) SHA1(f9d68f542cbf379a7c41b47704b19e1aec69f237) )
+	ROM_LOAD( "4.5h",  0x080000, 0x80000, CRC(a9b17359) SHA1(84cb71ab32e069c8ff8cffff7badb3a823d3abfd) )
+	ROM_LOAD( "5.5h",  0x100000, 0x80000, CRC(927517b7) SHA1(de4fcc4e87bc1a31834ffb2312b8cee167ec16b5) )
+	ROM_LOAD( "6.6h",  0x180000, 0x80000, CRC(31b0b9de) SHA1(b68c2028859b6804fe66a500f6afc375c1634bcd) )
+	ROM_LOAD( "7.7h",  0x200000, 0x80000, CRC(a7249937) SHA1(81d4adfb4bebe1e94fbbe70b7346c97f582f07a8) )
+	ROM_LOAD( "8.8h",  0x280000, 0x80000, CRC(a3cd2458) SHA1(a82b011a880f0d47362d2e70b9d77db85d83e6ed) )
+ROM_END
+
 ROM_START( ngpgal )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* main program */
 	ROM_LOAD( "ngpg_01.bin", 0x00000,  0x10000, CRC(c766378b) SHA1(b221908eb14ebf5c87ae896c3c27d261b26b5146) )
@@ -3943,8 +4044,9 @@
 GAME( 1993, sailorwa, sailorws, sailorws, sailorws, nbmj9195, ROT0,   "Nichibutsu", "Mahjong Sailor Wars (Japan set 2)", 0 )
 GAME( 1993, sailorwr, sailorws, sailorwr, sailorwr, nbmj9195, ROT0,   "Nichibutsu", "Mahjong Sailor Wars-R [BET] (Japan)", 0 )
 GAME( 1993, wcatcher, 0,        otatidai, wcatcher, nbmj9195, ROT0,   "Nichibutsu", "Mahjong Wakuwaku Catcher (Japan)", 0 )
-GAME( 1993, jituroku, 0,        jituroku, jituroku, nbmj9195, ROT180, "Windom", "Jitsuroku Maru-chi Mahjong (Japan)", 0 )
-GAME( 1994, yosimoto, 0,        yosimoto, yosimoto, nbmj9195, ROT180, "Nichibutsu / Yoshimoto Kougyou", "Mahjong Yoshimoto Gekijou (Japan)", 0 )
+GAME( 1993, jituroku, 0,        jituroku, jituroku, nbmj9195, ROT0,   "Windom", "Jitsuroku Maru-chi Mahjong (Japan)", 0 )
+GAME( 1994, yosimoto, 0,        yosimoto, yosimoto, nbmj9195, ROT0,   "Nichibutsu / Yoshimoto Kougyou", "Mahjong Yoshimoto Gekijou (Japan)", 0 )
+GAME( 1994, yosimotm, yosimoto, yosimotm, yosimotm, nbmj9195, ROT0,   "Nichibutsu / Yoshimoto Kougyou", "Mahjong Yoshimoto Gekijou [BET] (Japan)", 0 )
 GAME( 1994, psailor1, 0,        psailor1, psailor1, nbmj9195, ROT0,   "Sphinx", "Bishoujo Janshi Pretty Sailor 18-kin (Japan)", 0 )
 GAME( 1994, psailor2, 0,        psailor2, psailor2, nbmj9195, ROT0,   "Sphinx", "Bishoujo Janshi Pretty Sailor 2 (Japan)", 0 )
 GAME( 1995, otatidai, 0,        otatidai, otatidai, nbmj9195, ROT0,   "Sphinx", "Disco Mahjong Otachidai no Okite (Japan)", 0 )
diff -Nru src-old/mame/drivers/nemesis.c src/mame/drivers/nemesis.c
--- src-old/mame/drivers/nemesis.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/nemesis.c	2012-05-03 11:00:08.000000000 +0200
@@ -198,8 +198,8 @@
     bit 12-15: accel
 */
 
-	int data = input_port_read(machine(), "IN3");
-	int data2 = input_port_read(machine(), "PADDLE");
+	int data = ioport("IN3")->read();
+	int data2 = ioport("PADDLE")->read();
 
 	int ret=0x0000;
 
@@ -228,10 +228,10 @@
 
 	switch (m_selected_ip & 0xf)
 	{												// From WEC Le Mans Schems:
-		case 0xc:  return input_port_read(machine(), "ACCEL");	// Accel - Schems: Accelevr
-		case 0:    return input_port_read(machine(), "ACCEL");
-		case 0xd:  return input_port_read(machine(), "WHEEL");	// Wheel - Schems: Handlevr
-		case 1:    return input_port_read(machine(), "WHEEL");
+		case 0xc:  return ioport("ACCEL")->read();	// Accel - Schems: Accelevr
+		case 0:    return ioport("ACCEL")->read();
+		case 0xd:  return ioport("WHEEL")->read();	// Wheel - Schems: Handlevr
+		case 1:    return ioport("WHEEL")->read();
 
 		default: return ~0;
 	}
@@ -1281,8 +1281,8 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x02)		// only in WEC Le Mans 24 cabinets
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x02)	// player 2?
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_CONDITION("DSW1", 0x03, EQUALS, 0x02)		// only in WEC Le Mans 24 cabinets
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x02)	// player 2?
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON3 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SPECIAL )	// must be 0 otherwise game freezes when using WEC Le Mans 24 cabinet
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -1329,8 +1329,8 @@
 	PORT_BIT( 0x7f, 0x40, IPT_PADDLE ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)
 
 	PORT_START("IN3")
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)		// only in Konami GT cabinet with brake
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)		// only in Konami GT cabinet with brake
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 //  PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_BUTTON4 )
 
diff -Nru src-old/mame/drivers/neodrvr.c src/mame/drivers/neodrvr.c
--- src-old/mame/drivers/neodrvr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/neodrvr.c	2012-05-03 11:00:08.000000000 +0200
@@ -9559,7 +9559,7 @@
 
 static TIMER_CALLBACK( ms5pcb_bios_timer_callback )
 {
-	int harddip3 = input_port_read(machine, "HARDDIP") & 1;
+	int harddip3 = machine.root_device().ioport("HARDDIP")->read() & 1;
 	machine.root_device().membank(NEOGEO_BANK_BIOS)->set_base(machine.root_device().memregion("mainbios")->base() + 0x20000 + harddip3 * 0x20000);
 }
 
@@ -9596,7 +9596,7 @@
 
 static TIMER_CALLBACK( svcpcb_bios_timer_callback )
 {
-	int harddip3 = input_port_read(machine, "HARDDIP") & 1;
+	int harddip3 = machine.root_device().ioport("HARDDIP")->read() & 1;
 	machine.root_device().membank(NEOGEO_BANK_BIOS)->set_base(machine.root_device().memregion("mainbios")->base() + 0x20000 + harddip3 * 0x20000);
 }
 
diff -Nru src-old/mame/drivers/neogeo.c src/mame/drivers/neogeo.c
--- src-old/mame/drivers/neogeo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/neogeo.c	2012-05-03 11:00:08.000000000 +0200
@@ -169,6 +169,11 @@
 static UINT8 *memcard_data;
 static UINT16 *save_ram;
 
+static const char *audio_banks[4] =
+{
+    NEOGEO_BANK_AUDIO_CPU_CART_BANK0, NEOGEO_BANK_AUDIO_CPU_CART_BANK1, NEOGEO_BANK_AUDIO_CPU_CART_BANK2, NEOGEO_BANK_AUDIO_CPU_CART_BANK3
+};
+
 
 /*************************************
  *
@@ -386,7 +391,7 @@
 			{ "IN0-0", "IN0-1" }, { "IN1-0", "IN1-1" }
 		};
 
-	return input_port_read_safe(machine(), cntrl[port][m_controller_select & 0x01], 0x00);
+	return ioport(cntrl[port][m_controller_select & 0x01])->read_safe(0x00);
 }
 
 #if 1 // this needs to be added dynamically somehow
@@ -405,10 +410,10 @@
 	{
 	default:
 	case 0x00: ret = 0x0000; break; /* nothing? */
-	case 0x09: ret = input_port_read(machine(), "MAHJONG1"); break;
-	case 0x12: ret = input_port_read(machine(), "MAHJONG2"); break;
-	case 0x1b: ret = input_port_read(machine(), "MAHJONG3"); break; /* player 1 normal inputs? */
-	case 0x24: ret = input_port_read(machine(), "MAHJONG4"); break;
+	case 0x09: ret = ioport("MAHJONG1")->read(); break;
+	case 0x12: ret = ioport("MAHJONG2")->read(); break;
+	case 0x1b: ret = ioport("MAHJONG3")->read(); break; /* player 1 normal inputs? */
+	case 0x24: ret = ioport("MAHJONG4")->read(); break;
 	}
 
 	return ret;
@@ -708,7 +713,7 @@
 	int region;
 
 	for (region = 0; region < 4; region++)
-		state->membank(NEOGEO_BANK_AUDIO_CPU_CART_BANK + region)->set_entry(state->m_audio_cpu_banks[region]);
+		state->membank(audio_banks[region])->set_entry(state->m_audio_cpu_banks[region]);
 }
 
 
@@ -795,12 +800,12 @@
 	UINT32 address_mask;
 
 	/* audio bios/cartridge selection */
-	if (machine.root_device().memregion("audiobios")->base())
-		state->membank(NEOGEO_BANK_AUDIO_CPU_MAIN_BANK)->configure_entry(0, machine.root_device().memregion("audiobios")->base());
-	state->membank(NEOGEO_BANK_AUDIO_CPU_MAIN_BANK)->configure_entry(1, machine.root_device().memregion("audiocpu")->base());
+	if (state->memregion("audiobios")->base())
+		state->membank(NEOGEO_BANK_AUDIO_CPU_MAIN_BANK)->configure_entry(0, state->memregion("audiobios")->base());
+	state->membank(NEOGEO_BANK_AUDIO_CPU_MAIN_BANK)->configure_entry(1, state->memregion("audiocpu")->base());
 
 	/* audio banking */
-	address_mask = machine.root_device().memregion("audiocpu")->bytes() - 0x10000 - 1;
+	address_mask = state->memregion("audiocpu")->bytes() - 0x10000 - 1;
 
 	rgn = state->memregion("audiocpu")->base();
 	for (region = 0; region < 4; region++)
@@ -808,7 +813,7 @@
 		for (bank = 0; bank < 0x100; bank++)
 		{
 			UINT32 bank_address = 0x10000 + (((bank << (11 + region)) & 0x3ffff) & address_mask);
-			state->membank(NEOGEO_BANK_AUDIO_CPU_CART_BANK + region)->configure_entry(bank, &rgn[bank_address]);
+			state->membank(audio_banks[region])->configure_entry(bank, &rgn[bank_address]);
 		}
 	}
 
@@ -1114,10 +1119,10 @@
 
 static ADDRESS_MAP_START( audio_map, AS_PROGRAM, 8, neogeo_state )
 	AM_RANGE(0x0000, 0x7fff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_MAIN_BANK)
-	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK + 3)
-	AM_RANGE(0xc000, 0xdfff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK + 2)
-	AM_RANGE(0xe000, 0xefff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK + 1)
-	AM_RANGE(0xf000, 0xf7ff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK + 0)
+	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK3)
+	AM_RANGE(0xc000, 0xdfff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK2)
+	AM_RANGE(0xe000, 0xefff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK1)
+	AM_RANGE(0xf000, 0xf7ff) AM_ROMBANK(NEOGEO_BANK_AUDIO_CPU_CART_BANK0)
 	AM_RANGE(0xf800, 0xffff) AM_RAM
 ADDRESS_MAP_END
 
diff -Nru src-old/mame/drivers/nexus3d.c src/mame/drivers/nexus3d.c
--- src-old/mame/drivers/nexus3d.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nexus3d.c	2012-05-03 11:00:08.000000000 +0200
@@ -263,7 +263,7 @@
 {
 	nexus3d_state *state = machine.driver_data<nexus3d_state>();
 	// the first part of the flash ROM automatically gets copied to RAM
-	memcpy( state->m_mainram, machine.root_device().memregion("user1")->base(), 4 * 1024);
+	memcpy( state->m_mainram, state->memregion("user1")->base(), 4 * 1024);
 	state->m_flash_region = state->memregion("user1")->base();
 }
 
diff -Nru src-old/mame/drivers/nightgal.c src/mame/drivers/nightgal.c
--- src-old/mame/drivers/nightgal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nightgal.c	2012-05-03 11:00:08.000000000 +0200
@@ -420,41 +420,41 @@
 static READ8_DEVICE_HANDLER( input_1p_r )
 {
 	nightgal_state *state = device->machine().driver_data<nightgal_state>();
-	UINT8 cr_clear = input_port_read(device->machine(), "CR_CLEAR");
+	UINT8 cr_clear = state->ioport("CR_CLEAR")->read();
 
 	switch (state->m_mux_data)
 	{
-		case 0x01: return input_port_read(device->machine(), "PL1_1") | cr_clear;
-		case 0x02: return input_port_read(device->machine(), "PL1_2") | cr_clear;
-		case 0x04: return input_port_read(device->machine(), "PL1_3") | cr_clear;
-		case 0x08: return input_port_read(device->machine(), "PL1_4") | cr_clear;
-		case 0x10: return input_port_read(device->machine(), "PL1_5") | cr_clear;
-		case 0x20: return input_port_read(device->machine(), "PL1_6") | cr_clear;
+		case 0x01: return state->ioport("PL1_1")->read() | cr_clear;
+		case 0x02: return state->ioport("PL1_2")->read() | cr_clear;
+		case 0x04: return state->ioport("PL1_3")->read() | cr_clear;
+		case 0x08: return state->ioport("PL1_4")->read() | cr_clear;
+		case 0x10: return state->ioport("PL1_5")->read() | cr_clear;
+		case 0x20: return state->ioport("PL1_6")->read() | cr_clear;
 	}
 	//printf("%04x\n", state->m_mux_data);
 
-	return (input_port_read(device->machine(), "PL1_1") & input_port_read(device->machine(), "PL1_2") & input_port_read(device->machine(), "PL1_3") &
-	       input_port_read(device->machine(), "PL1_4") & input_port_read(device->machine(), "PL1_5") & input_port_read(device->machine(), "PL1_6")) | cr_clear;
+	return (state->ioport("PL1_1")->read() & state->ioport("PL1_2")->read() & state->ioport("PL1_3")->read() &
+	       state->ioport("PL1_4")->read() & state->ioport("PL1_5")->read() & state->ioport("PL1_6")->read()) | cr_clear;
 }
 
 static READ8_DEVICE_HANDLER( input_2p_r )
 {
 	nightgal_state *state = device->machine().driver_data<nightgal_state>();
-	UINT8 coin_port = input_port_read(device->machine(), "COINS");
+	UINT8 coin_port = state->ioport("COINS")->read();
 
 	switch (state->m_mux_data)
 	{
-		case 0x01: return input_port_read(device->machine(), "PL2_1") | coin_port;
-		case 0x02: return input_port_read(device->machine(), "PL2_2") | coin_port;
-		case 0x04: return input_port_read(device->machine(), "PL2_3") | coin_port;
-		case 0x08: return input_port_read(device->machine(), "PL2_4") | coin_port;
-		case 0x10: return input_port_read(device->machine(), "PL2_5") | coin_port;
-		case 0x20: return input_port_read(device->machine(), "PL2_6") | coin_port;
+		case 0x01: return state->ioport("PL2_1")->read() | coin_port;
+		case 0x02: return state->ioport("PL2_2")->read() | coin_port;
+		case 0x04: return state->ioport("PL2_3")->read() | coin_port;
+		case 0x08: return state->ioport("PL2_4")->read() | coin_port;
+		case 0x10: return state->ioport("PL2_5")->read() | coin_port;
+		case 0x20: return state->ioport("PL2_6")->read() | coin_port;
 	}
 	//printf("%04x\n", state->m_mux_data);
 
-	return (input_port_read(device->machine(), "PL2_1") & input_port_read(device->machine(), "PL2_2") & input_port_read(device->machine(), "PL2_3") &
-	       input_port_read(device->machine(), "PL2_4") & input_port_read(device->machine(), "PL2_5") & input_port_read(device->machine(), "PL2_6")) | coin_port;
+	return (state->ioport("PL2_1")->read() & state->ioport("PL2_2")->read() & state->ioport("PL2_3")->read() &
+	       state->ioport("PL2_4")->read() & state->ioport("PL2_5")->read() & state->ioport("PL2_6")->read()) | coin_port;
 }
 
 /********************************************
diff -Nru src-old/mame/drivers/ninjakd2.c src/mame/drivers/ninjakd2.c
--- src-old/mame/drivers/ninjakd2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ninjakd2.c	2012-05-03 11:00:08.000000000 +0200
@@ -228,7 +228,7 @@
 {
 	ninjakd2_state *state = device.machine().driver_data<ninjakd2_state>();
 	running_machine &machine = device.machine();
-	const UINT8* const rom = machine.root_device().memregion("pcm")->base();
+	const UINT8* const rom = state->memregion("pcm")->base();
 	const int length = state->memregion("pcm")->bytes();
 	INT16* sampledata = auto_alloc_array(machine, INT16, length);
 
@@ -350,8 +350,8 @@
 		case 1:	// dip switches
 			switch (offset)
 			{
-				case 0: result = input_port_read(machine(), "DIPSW1"); break;
-				case 1: result = input_port_read(machine(), "DIPSW2"); break;
+				case 0: result = ioport("DIPSW1")->read(); break;
+				case 1: result = ioport("DIPSW2")->read(); break;
 				case 2: result = 0x02;                         break;
 			}
 			break;
@@ -359,8 +359,8 @@
 		case 2:	// player inputs
 			switch (offset)
 			{
-				case 0: result = input_port_read(machine(), "PAD1"); break;
-				case 1: result = input_port_read(machine(), "PAD2"); break;
+				case 0: result = ioport("PAD1")->read(); break;
+				case 1: result = ioport("PAD2")->read(); break;
 				case 2: result = 0x01;                       break;
 			}
 			break;
@@ -615,31 +615,31 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
 	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW2:5,4")
-	PORT_DIPSETTING(    0x00, "2 Coins/1 Credit, 6/4" )       PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x18, "1 Coin/1 Credit, 3/4" )        PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, "1 Coin/2 Credits, 2/6, 3/10" ) PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x08, "1 Coin/3 Credits, 3/12" )      PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x18, DEF_STR( 1C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "2 Coins/1 Credit, 6/4" )       PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x18, "1 Coin/1 Credit, 3/4" )        PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, "1 Coin/2 Credits, 2/6, 3/10" ) PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x08, "1 Coin/3 Credits, 3/12" )      PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x18, DEF_STR( 1C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
 	PORT_DIPNAME( 0xe0, 0xe0, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW2:3,2,1")
-	PORT_DIPSETTING(    0x00, "5 Coins/1 Credit, 15/4" )      PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, "4 Coins/1 Credit, 12/4" )      PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, "3 Coins/1 Credit, 9/4" )       PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x60, "2 Coins/1 Credit, 6/4" )       PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0xe0, "1 Coin/1 Credit, 3/4" )        PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, "1 Coin/2 Credits, 2/6, 3/10" ) PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0xa0, "1 Coin/3 Credits, 3/12" )      PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_NOTEQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, DEF_STR( 4C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 3C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x60, DEF_STR( 2C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xe0, DEF_STR( 1C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xa0, DEF_STR( 1C_3C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) )              PORT_CONDITION("DIPSW2", 0x04, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "5 Coins/1 Credit, 15/4" )      PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, "4 Coins/1 Credit, 12/4" )      PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, "3 Coins/1 Credit, 9/4" )       PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x60, "2 Coins/1 Credit, 6/4" )       PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0xe0, "1 Coin/1 Credit, 3/4" )        PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, "1 Coin/2 Credits, 2/6, 3/10" ) PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0xa0, "1 Coin/3 Credits, 3/12" )      PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) )              PORT_CONDITION("DIPSW2", 0x04, NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 4C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 3C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x60, DEF_STR( 2C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xe0, DEF_STR( 1C_1C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xa0, DEF_STR( 1C_3C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) )              PORT_CONDITION("DIPSW2", 0x04, EQUALS, 0x00)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( rdaction )
diff -Nru src-old/mame/drivers/nitedrvr.c src/mame/drivers/nitedrvr.c
--- src-old/mame/drivers/nitedrvr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/nitedrvr.c	2012-05-03 11:00:08.000000000 +0200
@@ -78,7 +78,7 @@
 	PORT_DIPNAME( 0x20, 0x20, "Bonus Time" )
 	PORT_DIPSETTING(	0x00, DEF_STR ( No ) )
 	PORT_DIPSETTING(	0x20, "Score = 350" )
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x80, IP_ACTIVE_LOW )
 
 	PORT_START("GEARS")	// fake
diff -Nru src-old/mame/drivers/niyanpai.c src/mame/drivers/niyanpai.c
--- src-old/mame/drivers/niyanpai.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/niyanpai.c	2012-05-03 11:00:08.000000000 +0200
@@ -14,6 +14,9 @@
     Mahjong Housoukyoku Honbanchuu
     (c)199? Nihon Bussan Co.,Ltd.
 
+    Zoku Mahjong Housoukyoku Honbanchuu
+    (c)199? Nihon Bussan Co.,Ltd.
+
     Driver by Takahiro Nogi <nogi@kt.rim.or.jp> 2000/12/23 -
 
 ******************************************************************************/
@@ -45,14 +48,6 @@
 #include "includes/niyanpai.h"
 
 
-#define SIGNED_DAC	0		// 0:unsigned DAC, 1:signed DAC
-#if SIGNED_DAC
-#define DAC_WRITE	dac_signed_w
-#else
-#define DAC_WRITE	dac_w
-#endif
-
-
 static void niyanpai_soundbank_w(running_machine &machine, int data)
 {
 	UINT8 *SNDROM = machine.root_device().memregion("audiocpu")->base();
@@ -117,10 +112,10 @@
 			niyanpai_soundbank_w(machine(), data & 0x03);
 			break;
 		case 1:			/* PB_0 */
-			DAC_WRITE(machine().device("dac2"), 0, data);
+			dac_w(machine().device("dac1"), 0, data);
 			break;
 		case 2:			/* PC_0 */
-			DAC_WRITE(machine().device("dac1"), 0, data);
+			dac_w(machine().device("dac2"), 0, data);
 			break;
 		case 3:			/* PD_0 */
 			break;
@@ -283,15 +278,15 @@
 {
 	UINT8 dipsw_a, dipsw_b;
 
-	dipsw_a = (((input_port_read(machine(), "DSWA") & 0x01) << 7) | ((input_port_read(machine(), "DSWA") & 0x02) << 5) |
-			   ((input_port_read(machine(), "DSWA") & 0x04) << 3) | ((input_port_read(machine(), "DSWA") & 0x08) << 1) |
-			   ((input_port_read(machine(), "DSWA") & 0x10) >> 1) | ((input_port_read(machine(), "DSWA") & 0x20) >> 3) |
-			   ((input_port_read(machine(), "DSWA") & 0x40) >> 5) | ((input_port_read(machine(), "DSWA") & 0x80) >> 7));
-
-	dipsw_b = (((input_port_read(machine(), "DSWB") & 0x01) << 7) | ((input_port_read(machine(), "DSWB") & 0x02) << 5) |
-			   ((input_port_read(machine(), "DSWB") & 0x04) << 3) | ((input_port_read(machine(), "DSWB") & 0x08) << 1) |
-			   ((input_port_read(machine(), "DSWB") & 0x10) >> 1) | ((input_port_read(machine(), "DSWB") & 0x20) >> 3) |
-			   ((input_port_read(machine(), "DSWB") & 0x40) >> 5) | ((input_port_read(machine(), "DSWB") & 0x80) >> 7));
+	dipsw_a = (((ioport("DSWA")->read() & 0x01) << 7) | ((ioport("DSWA")->read() & 0x02) << 5) |
+			   ((ioport("DSWA")->read() & 0x04) << 3) | ((ioport("DSWA")->read() & 0x08) << 1) |
+			   ((ioport("DSWA")->read() & 0x10) >> 1) | ((ioport("DSWA")->read() & 0x20) >> 3) |
+			   ((ioport("DSWA")->read() & 0x40) >> 5) | ((ioport("DSWA")->read() & 0x80) >> 7));
+
+	dipsw_b = (((ioport("DSWB")->read() & 0x01) << 7) | ((ioport("DSWB")->read() & 0x02) << 5) |
+			   ((ioport("DSWB")->read() & 0x04) << 3) | ((ioport("DSWB")->read() & 0x08) << 1) |
+			   ((ioport("DSWB")->read() & 0x10) >> 1) | ((ioport("DSWB")->read() & 0x20) >> 3) |
+			   ((ioport("DSWB")->read() & 0x40) >> 5) | ((ioport("DSWB")->read() & 0x80) >> 7));
 
 	return ((dipsw_a << 8) | dipsw_b);
 }
@@ -302,13 +297,13 @@
 
 	switch ((m_musobana_inputport ^ 0xff00) >> 8)
 	{
-		case 0x01:	portdata = input_port_read(machine(), "KEY0"); break;
-		case 0x02:	portdata = input_port_read(machine(), "KEY1"); break;
-		case 0x04:	portdata = input_port_read(machine(), "KEY2"); break;
-		case 0x08:	portdata = input_port_read(machine(), "KEY3"); break;
-		case 0x10:	portdata = input_port_read(machine(), "KEY4"); break;
-		default:	portdata = input_port_read(machine(), "KEY0") & input_port_read(machine(), "KEY1") & input_port_read(machine(), "KEY2")
-								& input_port_read(machine(), "KEY3") & input_port_read(machine(), "KEY4"); break;
+		case 0x01:	portdata = ioport("KEY0")->read(); break;
+		case 0x02:	portdata = ioport("KEY1")->read(); break;
+		case 0x04:	portdata = ioport("KEY2")->read(); break;
+		case 0x08:	portdata = ioport("KEY3")->read(); break;
+		case 0x10:	portdata = ioport("KEY4")->read(); break;
+		default:	portdata = ioport("KEY0")->read() & ioport("KEY1")->read() & ioport("KEY2")->read()
+								& ioport("KEY3")->read() & ioport("KEY4")->read(); break;
 	}
 
 	return (portdata);
@@ -454,6 +449,45 @@
 	AM_IMPORT_FROM( tmp68301_regs )
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( zokumahj_map, AS_PROGRAM, 16, niyanpai_state )
+	AM_RANGE(0x000000, 0x03ffff) AM_ROM
+	AM_RANGE(0x0ff000, 0x0fffff) AM_RAM
+
+	AM_RANGE(0x0e0000, 0x0e08ff) AM_READWRITE(niyanpai_palette_r,niyanpai_palette_w)
+	AM_RANGE(0x0e0900, 0x0e11ff) AM_RAM				// palette work ram?
+
+	AM_RANGE(0x0a8000, 0x0a87ff) AM_RAM AM_SHARE("nvram")
+	AM_RANGE(0x0c0000, 0x0cffff) AM_RAM
+
+	AM_RANGE(0x200000, 0x200001) AM_WRITE(niyanpai_sound_w)
+
+	AM_RANGE(0x200200, 0x200201) AM_WRITE(musobana_inputport_w)	// inputport select
+	AM_RANGE(0x240000, 0x240009) AM_WRITENOP			// unknown
+	AM_RANGE(0x240200, 0x2403ff) AM_WRITENOP			// unknown
+
+	AM_RANGE(0x240400, 0x240403) AM_READ(niyanpai_blitter_0_r)
+	AM_RANGE(0x240400, 0x24041f) AM_WRITE(niyanpai_blitter_0_w)
+	AM_RANGE(0x240420, 0x24043f) AM_WRITE(niyanpai_clut_0_w)
+
+	AM_RANGE(0x240600, 0x240603) AM_READ(niyanpai_blitter_1_r)
+	AM_RANGE(0x240600, 0x24061f) AM_WRITE(niyanpai_blitter_1_w)
+	AM_RANGE(0x240620, 0x24063f) AM_WRITE(niyanpai_clut_1_w)
+
+	AM_RANGE(0x240800, 0x240803) AM_READ(niyanpai_blitter_2_r)
+	AM_RANGE(0x240800, 0x24081f) AM_WRITE(niyanpai_blitter_2_w)
+	AM_RANGE(0x240820, 0x24083f) AM_WRITE(niyanpai_clut_2_w)
+
+	AM_RANGE(0x240a00, 0x240a01) AM_WRITE(niyanpai_clutsel_0_w)
+	AM_RANGE(0x240c00, 0x240c01) AM_WRITE(niyanpai_clutsel_1_w)
+	AM_RANGE(0x240e00, 0x240e01) AM_WRITE(niyanpai_clutsel_2_w)
+
+	AM_RANGE(0x280000, 0x280001) AM_READ(niyanpai_dipsw_r)
+	AM_RANGE(0x280200, 0x280201) AM_READ(musobana_inputport_0_r)
+	AM_RANGE(0x280400, 0x280401) AM_READ_PORT("SYSTEM")
+
+	AM_IMPORT_FROM( tmp68301_regs )
+ADDRESS_MAP_END
+
 
 static ADDRESS_MAP_START( niyanpai_sound_map, AS_PROGRAM, 8, niyanpai_state )
 	AM_RANGE(0x0000, 0x77ff) AM_ROM
@@ -774,8 +808,8 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Coinage ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )
 	PORT_DIPNAME( 0x10, 0x00, "DIPSW 1-5" )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -828,6 +862,72 @@
 	PORT_INCLUDE( nbmjctrl_16 )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( zokumahj )	// I don't have manual for this game.
+	PORT_START("DSWA")
+	PORT_DIPNAME( 0x01, 0x01, "DIPSW 1-1" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "DIPSW 1-2" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, "DIPSW 1-3" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Coinage ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) )
+	PORT_DIPNAME( 0x10, 0x10, "DIPSW 1-5" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "DIPSW 1-7" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "DIPSW 1-8" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSWB")
+	PORT_DIPNAME( 0x01, 0x01, "DIPSW 2-1" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "DIPSW 2-2" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, "DIPSW 2-3" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, "DIPSW 2-4" )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, "DIPSW 2-5" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "DIPSW 2-6" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "DIPSW 2-7" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Option Test" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_COIN1 )			// COIN1
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_COIN2 )			// COIN2
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_START3 )			// CREDIT CLEAR
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_SERVICE3 )			// MEMORY RESET
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_SERVICE2 )			// ANALYZER
+	PORT_BIT( 0x2000, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, niyanpai_state,musobana_outcoin_flag_r, NULL)	// OUT COIN
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_SERVICE( 0x8000, IP_ACTIVE_LOW )					// TEST
+
+	PORT_INCLUDE( nbmjctrl_16 )
+INPUT_PORTS_END
+
 
 static INTERRUPT_GEN( niyanpai_interrupt )
 {
@@ -866,7 +966,7 @@
 	MCFG_SCREEN_VISIBLE_AREA(0, 640-1, 0, 240-1)
 	MCFG_SCREEN_UPDATE_STATIC(niyanpai)
 
-	MCFG_PALETTE_LENGTH(768)
+	MCFG_PALETTE_LENGTH(256*3)
 
 	MCFG_VIDEO_START(niyanpai)
 
@@ -874,10 +974,10 @@
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 	MCFG_SOUND_ADD("ymsnd", YM3812, 4000000)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.00)
 
 	MCFG_SOUND_ADD("dac1", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.75)
 
 	MCFG_SOUND_ADD("dac2", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.75)
@@ -897,6 +997,13 @@
 	MCFG_CPU_PROGRAM_MAP(mhhonban_map)
 MACHINE_CONFIG_END
 
+static MACHINE_CONFIG_DERIVED( zokumahj, niyanpai )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(zokumahj_map)
+MACHINE_CONFIG_END
+
 
 ROM_START( niyanpai )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* TMP68301 main program */
@@ -974,8 +1081,26 @@
 	ROM_LOAD( "u107.bin",  0x280000, 0x80000, CRC(efc85912) SHA1(b9d523fd5f9ce879e2ed6916c89940be1d738a1c) )
 ROM_END
 
+ROM_START( zokumahj )
+	ROM_REGION( 0x40000, "maincpu", 0 ) /* TMP68301 main program */
+	ROM_LOAD16_BYTE( "1.bin", 0x00000, 0x20000, CRC(53ca34a9) SHA1(5a1e2660442665efd529ec6c98ffc994c6103419) )
+	ROM_LOAD16_BYTE( "2.bin", 0x00001, 0x20000, CRC(474f9303) SHA1(4b03e3b6b6ee864dfcce3978f19bf329e39b3fe7) )
+
+	ROM_REGION( 0x20000, "audiocpu", 0 ) /* TMPZ84C011 sound program */
+	ROM_LOAD( "3.bin",  0x000000, 0x20000, CRC(48407507) SHA1(afd24d16d487fd2b6548d967e2f1ae122e2633a2) )
+
+	ROM_REGION( 0x300000, "gfx1", 0 ) /* gfx */
+	ROM_LOAD( "4.bin",  0x000000, 0x80000, CRC(2b3e88b4) SHA1(d49a81f1bc6ac5b56df36caf7ee7188a917d947f) )
+	ROM_LOAD( "5.bin",  0x080000, 0x80000, CRC(cfe9477a) SHA1(9d08f5b1d638cef7d8dc97bdd9d98627f9af1ef9) )
+	ROM_LOAD( "6.bin",  0x100000, 0x80000, CRC(2d62df76) SHA1(83fe8e0a853c0137e7c77ecde762617c082774e5) )
+	ROM_LOAD( "7.bin",  0x180000, 0x80000, CRC(75922e76) SHA1(4ad23e241a1a223e0fcd4fd26bd695b1a68c258a) )
+	ROM_LOAD( "8.bin",  0x200000, 0x80000, CRC(22b3befa) SHA1(e44635e021962ce29b4e129ae394c794038aef39) )
+	ROM_LOAD( "9.bin",  0x280000, 0x80000, CRC(f72d83af) SHA1(4b897b40765084fd9483065fd0eb0e29cbcfa5ac) )
+ROM_END
+
 
-GAME( 1996, niyanpai, 0, niyanpai, niyanpai, niyanpai, ROT0, "Nichibutsu", "Niyanpai (Japan)", 0 )
-GAME( 1995, musobana, 0, musobana, musobana, niyanpai, ROT0, "Nichibutsu / Yubis", "Musoubana (Japan)", 0 )
-GAME( 1994, 4psimasy, 0, musobana, 4psimasy, niyanpai, ROT0, "Sphinx / AV Japan", "Mahjong 4P Simasyo (Japan)", 0 )
-GAME( 199?, mhhonban, 0, mhhonban, mhhonban, niyanpai, ROT0, "Nichibutsu?", "Mahjong Housoukyoku Honbanchuu (Japan)", 0 )
+GAME( 1996, niyanpai, 0,        niyanpai, niyanpai, niyanpai, ROT0, "Nichibutsu", "Niyanpai (Japan)", 0 )
+GAME( 1995, musobana, 0,        musobana, musobana, niyanpai, ROT0, "Nichibutsu / Yubis", "Musoubana (Japan)", 0 )
+GAME( 1994, 4psimasy, 0,        musobana, 4psimasy, niyanpai, ROT0, "Sphinx / AV Japan", "Mahjong 4P Simasyo (Japan)", 0 )
+GAME( 199?, mhhonban, 0,        mhhonban, mhhonban, niyanpai, ROT0, "Nichibutsu?", "Mahjong Housoukyoku Honbanchuu (Japan)", 0 )
+GAME( 199?, zokumahj, mhhonban, zokumahj, zokumahj, niyanpai, ROT0, "Nichibutsu?", "Zoku Mahjong Housoukyoku (Japan)", 0 )
diff -Nru src-old/mame/drivers/nmg5.c src/mame/drivers/nmg5.c
--- src-old/mame/drivers/nmg5.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/nmg5.c	2012-05-03 11:00:08.000000000 +0200
@@ -418,23 +418,23 @@
 	PORT_DIPSETTING(      0x0080, DEF_STR( Hard ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
 	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Coin_B ) )       PORT_DIPLOCATION("SW2:8,7")
-	PORT_DIPSETTING(      0x0200, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0300, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0100, DEF_STR( 1C_2C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0300, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0100, DEF_STR( 1C_3C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0200, DEF_STR( 1C_4C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(      0x0200, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0300, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0100, DEF_STR( 1C_2C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0300, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0100, DEF_STR( 1C_3C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0200, DEF_STR( 1C_4C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
 	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Coin_A ) )       PORT_DIPLOCATION("SW2:6,5")
-	PORT_DIPSETTING(      0x0800, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0c00, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_2C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x00)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0800, DEF_STR( 3C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0400, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(      0x0c00, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(      0x0800, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0c00, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0400, DEF_STR( 1C_2C ) )        PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x00)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0800, DEF_STR( 3C_1C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0400, DEF_STR( 2C_1C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
+	PORT_DIPSETTING(      0x0c00, DEF_STR( 1C_1C ) )        PORT_CONDITION("DSW",0x4000,EQUALS,0x00)
 	PORT_DIPUNUSED_DIPLOC( 0x1000, IP_ACTIVE_LOW, "SW2:4" )                               // See notes
 	PORT_DIPNAME( 0x2000, 0x0000, DEF_STR( Demo_Sounds ) )  PORT_DIPLOCATION("SW2:3")
 	PORT_DIPSETTING(      0x2000, DEF_STR( Off ) )
diff -Nru src-old/mame/drivers/nmk16.c src/mame/drivers/nmk16.c
--- src-old/mame/drivers/nmk16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nmk16.c	2012-05-04 05:16:35.000000000 +0200
@@ -257,7 +257,7 @@
 		return res << 8;
 	}
 	else
-		return ~input_port_read(machine(), "IN1");
+		return ~ioport("IN1")->read();
 }
 
 WRITE16_MEMBER(nmk16_state::macross2_sound_reset_w)
@@ -750,8 +750,8 @@
 	/*needed because of the uncompatibility of the dsw settings.*/
 	if(dsw_setting) // Thunder Dragon
 	{
-		dsw[0] = (input_port_read(machine, "DSW2") & 0x7);
-		dsw[1] = (input_port_read(machine, "DSW2") & 0x38) >> 3;
+		dsw[0] = (machine.root_device().ioport("DSW2")->read() & 0x7);
+		dsw[1] = (machine.root_device().ioport("DSW2")->read() & 0x38) >> 3;
 		for(i=0;i<2;i++)
 		{
 			switch(dsw[i] & 7)
@@ -769,8 +769,8 @@
 	}
 	else // Hacha Mecha Fighter
 	{
-		dsw[0] = (input_port_read(machine, "DSW1") & 0x0700) >> 8;
-		dsw[1] = (input_port_read(machine, "DSW1") & 0x3800) >> 11;
+		dsw[0] = (machine.root_device().ioport("DSW1")->read() & 0x0700) >> 8;
+		dsw[1] = (machine.root_device().ioport("DSW1")->read() & 0x3800) >> 11;
 		for(i=0;i<2;i++)
 		{
 			switch(dsw[i] & 7)
@@ -788,7 +788,7 @@
 	}
 
 	/*read the coin port*/
-	coin_input = (~(input_port_read(machine, "IN0")));
+	coin_input = (~(machine.root_device().ioport("IN0")->read()));
 
 	if(coin_input & 0x01)//coin 1
 	{
@@ -4874,16 +4874,17 @@
 	MCFG_SCREEN_UPDATE_STATIC(firehawk)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_DERIVED( grdnstrmk, stagger1 )
+static MACHINE_CONFIG_DERIVED( grdnstrmk, stagger1 ) /* Side by side with PCB, the music seems too fast as well */
 
 	/* basic machine hardware */
 
 	/* video hardware */
+	MCFG_SCREEN_MODIFY("screen")
+	MCFG_SCREEN_REFRESH_RATE(57) /* Side by side with PCB, MAME is too fast at 56 */
 	MCFG_GFXDECODE(grdnstrm)
 	MCFG_VIDEO_START(grdnstrm)
 MACHINE_CONFIG_END
 
-
 static MACHINE_CONFIG_DERIVED( popspops, grdnstrm )
 
 	/* basic machine hardware */
@@ -6665,6 +6666,28 @@
 	ROM_LOAD( "afega1.u95", 0x00000, 0x40000, CRC(e911ce33) SHA1(a29c4dea98a22235122303325c63c15fadd3431d) )
 ROM_END
 
+ROM_START( redfoxwp2 )
+	ROM_REGION( 0x80000, "maincpu", 0 )		/* 68000 Code */
+	ROM_LOAD16_BYTE( "u112", 0x000000, 0x040000, CRC(3f31600b) SHA1(6c56e36178effb60ec27dfcd205393e2cfac4ed6) ) /* No label */
+	ROM_LOAD16_BYTE( "u107", 0x000001, 0x040000, CRC(daa44ab4) SHA1(7edaf8c7383dd31250478aeebc3247c525c75fef) ) /* No label */
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )		/* Z80 Code */
+	ROM_LOAD( "u92", 0x00000, 0x10000, CRC(864b55c2) SHA1(43475b05e35549ad301c3d4a25d4f4f0bcbe3f2c) ) /* Winbond W27E512-12 with no label */
+
+	ROM_REGION( 0x200000, "gfx1", 0 )	/* Sprites, 16x16x4 */
+	ROM_LOAD( "afega_af1-sp.uc13", 0x000000, 0x200000, CRC(7d4d4985) SHA1(15c6c1aecd3f12050c1db2376f929f1a26a1d1cf) ) /* MASK ROM (read as 27C160) */
+
+	ROM_REGION( 0x400000, "gfx2", 0 )	/* Layer 0, 16x16x8 */
+	ROM_LOAD( "afega_af1-b2.uc8", 0x000000, 0x200000, CRC(d68588c2) SHA1(c5f397d74a6ecfd2e375082f82e37c5a330fba62) ) /* MASK ROM (read as 27C160) */
+	ROM_LOAD( "afega_af1-b1.uc3", 0x200000, 0x200000, CRC(f8b200a8) SHA1(a6c43dd57b752d87138d7125b47dc0df83df8987) ) /* MASK ROM (read as 27C160) */
+
+	ROM_REGION( 0x10000, "gfx3", 0 )	/* Layer 1, 8x8x4 */
+	ROM_LOAD( "u4",  0x00000, 0x10000, CRC(19239401) SHA1(7876335dd97418bd9130dc894a517f3ceca20135) ) /* Winbond W27E512-12 with no label */
+
+	ROM_REGION( 0x40000, "oki1", 0 )	/* Samples */
+	ROM_LOAD( "afega1.u95", 0x00000, 0x40000, CRC(e911ce33) SHA1(a29c4dea98a22235122303325c63c15fadd3431d) )
+ROM_END
+
 /***************************************************************************
 
 Pop's Pop's by Afega (1999)
@@ -7186,6 +7209,7 @@
 GAME( 1997, redhawkb, stagger1, redhawkb, redhawkb, 0,        ROT0,   "bootleg",                           "Red Hawk (bootleg)", 0 )
 GAME( 1998, grdnstrm, 0,        grdnstrm, grdnstrm, 0,        ORIENTATION_FLIP_Y, "Afega (Apples Industries license)", "Guardian Storm", 0 )
 GAME( 1998, grdnstrmk,grdnstrm, grdnstrmk,grdnstrk, grdnstrm, ROT270, "Afega",                             "Sen Jin - Guardian Storm (Korea)", 0 )
+GAME( 1998, redfoxwp2,grdnstrm, grdnstrmk,grdnstrk, grdnstrm, ROT270, "Afega",                             "Red Fox War Planes II (China)", 0 )
 GAME( 1998, bubl2000, 0,        popspops, bubl2000, bubl2000, ROT0,   "Tuning",                            "Bubble 2000", 0 ) // on a tuning board (bootleg?)
 GAME( 1998, hotbubl,  bubl2000, popspops, bubl2000, bubl2000, ROT0,   "Pandora",                           "Hot Bubble" , 0 ) // on an afega board ..
 GAME( 1999, popspops, 0,        popspops, popspops, grdnstrm, ROT0,   "Afega",                             "Pop's Pop's", 0 )
diff -Nru src-old/mame/drivers/nova2001.c src/mame/drivers/nova2001.c
--- src-old/mame/drivers/nova2001.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nova2001.c	2012-05-03 11:00:08.000000000 +0200
@@ -222,7 +222,7 @@
 	AM_RANGE(0xa003, 0xa003) AM_WRITE(nova2001_flipscreen_w)
 	AM_RANGE(0xc000, 0xc7ff) AM_RAM_WRITE(nova2001_fg_videoram_w) AM_SHARE("fg_videoram")
 	AM_RANGE(0xc800, 0xcfff) AM_READWRITE(ninjakun_bg_videoram_r, ninjakun_bg_videoram_w) AM_SHARE("bg_videoram")
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM AM_SHARE("share3")
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xd800, 0xd9ff) AM_RAM_WRITE(ninjakun_paletteram_w) AM_SHARE("paletteram")
 	AM_RANGE(0xe000, 0xe3ff) AM_RAM AM_SHARE("share6") /* swapped wrt CPU1 */
 	AM_RANGE(0xe400, 0xe7ff) AM_RAM AM_SHARE("share5") /* swapped wrt CPU1 */
@@ -315,7 +315,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x78, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("SW1:1")
@@ -381,7 +381,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_COIN1 )
 
 	PORT_START("IN2")	/* 0xa002 */
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0c, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, nova2001_state,ninjakun_io_A002_ctrl_r, NULL)
 
 	PORT_START("DSW1") // printed "SW 2"
@@ -442,7 +442,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_COCKTAIL
@@ -491,7 +491,7 @@
 
 static INPUT_PORTS_START( raiders5 )
 	PORT_START("IN0")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
diff -Nru src-old/mame/drivers/nwk-tr.c src/mame/drivers/nwk-tr.c
--- src-old/mame/drivers/nwk-tr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nwk-tr.c	2012-05-03 11:00:08.000000000 +0200
@@ -296,15 +296,15 @@
 	{
 		if (ACCESSING_BITS_24_31)
 		{
-			r |= input_port_read(machine(), "IN0") << 24;
+			r |= ioport("IN0")->read() << 24;
 		}
 		if (ACCESSING_BITS_16_23)
 		{
-			r |= input_port_read(machine(), "IN1") << 16;
+			r |= ioport("IN1")->read() << 16;
 		}
 		if (ACCESSING_BITS_8_15)
 		{
-			r |= input_port_read(machine(), "IN2") << 8;
+			r |= ioport("IN2")->read() << 8;
 		}
 		if (ACCESSING_BITS_0_7)
 		{
@@ -315,7 +315,7 @@
 	{
 		if (ACCESSING_BITS_24_31)
 		{
-			r |= input_port_read(machine(), "DSW") << 24;
+			r |= ioport("DSW")->read() << 24;
 		}
 	}
 	return r;
@@ -625,11 +625,11 @@
 	int value = 0;
 	switch (input)
 	{
-		case 0:		value = input_port_read(device->machine(), "ANALOG1") - 0x800; break;
-		case 1:		value = input_port_read(device->machine(), "ANALOG2"); break;
-		case 2:		value = input_port_read(device->machine(), "ANALOG3"); break;
-		case 3:		value = input_port_read(device->machine(), "ANALOG4"); break;
-		case 4:		value = input_port_read(device->machine(), "ANALOG5"); break;
+		case 0:		value = device->machine().root_device().ioport("ANALOG1")->read() - 0x800; break;
+		case 1:		value = device->machine().root_device().ioport("ANALOG2")->read(); break;
+		case 2:		value = device->machine().root_device().ioport("ANALOG3")->read(); break;
+		case 3:		value = device->machine().root_device().ioport("ANALOG4")->read(); break;
+		case 4:		value = device->machine().root_device().ioport("ANALOG5")->read(); break;
 	}
 
 	return (double)(value) / 2047.0;
diff -Nru src-old/mame/drivers/nycaptor.c src/mame/drivers/nycaptor.c
--- src-old/mame/drivers/nycaptor.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/nycaptor.c	2012-05-03 11:00:08.000000000 +0200
@@ -233,7 +233,7 @@
 
 READ8_MEMBER(nycaptor_state::nycaptor_by_r)
 {
-	int port = input_port_read(machine(), "LIGHTY");
+	int port = ioport("LIGHTY")->read();
 
 	if (m_gametype == 1)
 		port = 255 - port;
@@ -243,7 +243,7 @@
 
 READ8_MEMBER(nycaptor_state::nycaptor_bx_r)
 {
-	return (input_port_read(machine(), "LIGHTX") + 0x27) | 1;
+	return (ioport("LIGHTX")->read() + 0x27) | 1;
 }
 
 
diff -Nru src-old/mame/drivers/nyny.c src/mame/drivers/nyny.c
--- src-old/mame/drivers/nyny.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/nyny.c	2012-05-03 11:00:08.000000000 +0200
@@ -169,13 +169,13 @@
 	/* update the different PIA pins from the input ports */
 
 	/* CA1 - copy of PA0 (COIN1) */
-	state->m_pia1->ca1_w(input_port_read(device->machine(), "IN0") & 0x01);
+	state->m_pia1->ca1_w(state->ioport("IN0")->read() & 0x01);
 
 	/* CA2 - copy of PA1 (SERVICE1) */
-	state->m_pia1->ca2_w(input_port_read(device->machine(), "IN0") & 0x02);
+	state->m_pia1->ca2_w(state->ioport("IN0")->read() & 0x02);
 
 	/* CB1 - (crosshatch) */
-	state->m_pia1->cb1_w(input_port_read(device->machine(), "CROSS"));
+	state->m_pia1->cb1_w(state->ioport("CROSS")->read());
 
 	/* CB2 - NOT CONNECTED */
 }
diff -Nru src-old/mame/drivers/offtwall.c src/mame/drivers/offtwall.c
--- src-old/mame/drivers/offtwall.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/offtwall.c	2012-05-03 11:00:08.000000000 +0200
@@ -91,7 +91,7 @@
 
 READ16_MEMBER(offtwall_state::special_port3_r)
 {
-	int result = input_port_read(machine(), "260010");
+	int result = ioport("260010")->read();
 	if (m_cpu_to_sound_ready) result ^= 0x0020;
 	return result;
 }
@@ -346,7 +346,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )	/* tested before writing to 260040 */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("260012")
diff -Nru src-old/mame/drivers/ojankohs.c src/mame/drivers/ojankohs.c
--- src-old/mame/drivers/ojankohs.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ojankohs.c	2012-05-03 11:00:08.000000000 +0200
@@ -113,18 +113,18 @@
 
 	switch (m_portselect)
 	{
-		case 0x01:	ret = input_port_read(machine(), "KEY0");	break;
-		case 0x02:	ret = input_port_read(machine(), "KEY1"); break;
-		case 0x04:	ret = input_port_read(machine(), "KEY2"); break;
-		case 0x08:	ret = input_port_read(machine(), "KEY3"); break;
-		case 0x10:	ret = input_port_read(machine(), "KEY4"); break;
+		case 0x01:	ret = ioport("KEY0")->read();	break;
+		case 0x02:	ret = ioport("KEY1")->read(); break;
+		case 0x04:	ret = ioport("KEY2")->read(); break;
+		case 0x08:	ret = ioport("KEY3")->read(); break;
+		case 0x10:	ret = ioport("KEY4")->read(); break;
 		case 0x20:	ret = 0xff; break;
 		case 0x3f:	ret = 0xff;
-					ret &= input_port_read(machine(), "KEY0");
-					ret &= input_port_read(machine(), "KEY1");
-					ret &= input_port_read(machine(), "KEY2");
-					ret &= input_port_read(machine(), "KEY3");
-					ret &= input_port_read(machine(), "KEY4");
+					ret &= ioport("KEY0")->read();
+					ret &= ioport("KEY1")->read();
+					ret &= ioport("KEY2")->read();
+					ret &= ioport("KEY3")->read();
+					ret &= ioport("KEY4")->read();
 					break;
 		default:	ret = 0xff;
 					logerror("PC:%04X unknown %02X\n", cpu_get_pc(&space.device()), m_portselect);
@@ -147,38 +147,40 @@
 	for (i = 0; i < 5; i++)
 	{
 		if (!BIT(m_portselect, i))
-			ret |= input_port_read(machine(), keynames[offset][i]);
+			ret |= ioport(keynames[offset][i])->read();
 	}
 
-	return (ret & 0x3f) | (input_port_read(machine(), offset ? "IN1" : "IN0") & 0xc0);
+	return (ret & 0x3f) | (ioport(offset ? "IN1" : "IN0")->read() & 0xc0);
 }
 
 static READ8_DEVICE_HANDLER( ojankohs_ay8910_0_r )
 {
 	// DIPSW 1
-	return (((input_port_read(device->machine(), "DSW1") & 0x01) << 7) | ((input_port_read(device->machine(), "DSW1") & 0x02) << 5) |
-	        ((input_port_read(device->machine(), "DSW1") & 0x04) << 3) | ((input_port_read(device->machine(), "DSW1") & 0x08) << 1) |
-	        ((input_port_read(device->machine(), "DSW1") & 0x10) >> 1) | ((input_port_read(device->machine(), "DSW1") & 0x20) >> 3) |
-	        ((input_port_read(device->machine(), "DSW1") & 0x40) >> 5) | ((input_port_read(device->machine(), "DSW1") & 0x80) >> 7));
+	device_t &root = device->machine().root_device();
+	return (((root.ioport("DSW1")->read() & 0x01) << 7) | ((root.ioport("DSW1")->read() & 0x02) << 5) |
+	        ((root.ioport("DSW1")->read() & 0x04) << 3) | ((root.ioport("DSW1")->read() & 0x08) << 1) |
+	        ((root.ioport("DSW1")->read() & 0x10) >> 1) | ((root.ioport("DSW1")->read() & 0x20) >> 3) |
+	        ((root.ioport("DSW1")->read() & 0x40) >> 5) | ((root.ioport("DSW1")->read() & 0x80) >> 7));
 }
 
 static READ8_DEVICE_HANDLER( ojankohs_ay8910_1_r )
 {
 	// DIPSW 1
-	return (((input_port_read(device->machine(), "DSW2") & 0x01) << 7) | ((input_port_read(device->machine(), "DSW2") & 0x02) << 5) |
-	        ((input_port_read(device->machine(), "DSW2") & 0x04) << 3) | ((input_port_read(device->machine(), "DSW2") & 0x08) << 1) |
-	        ((input_port_read(device->machine(), "DSW2") & 0x10) >> 1) | ((input_port_read(device->machine(), "DSW2") & 0x20) >> 3) |
-	        ((input_port_read(device->machine(), "DSW2") & 0x40) >> 5) | ((input_port_read(device->machine(), "DSW2") & 0x80) >> 7));
+	device_t &root = device->machine().root_device();
+	return (((root.ioport("DSW2")->read() & 0x01) << 7) | ((root.ioport("DSW2")->read() & 0x02) << 5) |
+	        ((root.ioport("DSW2")->read() & 0x04) << 3) | ((root.ioport("DSW2")->read() & 0x08) << 1) |
+	        ((root.ioport("DSW2")->read() & 0x10) >> 1) | ((root.ioport("DSW2")->read() & 0x20) >> 3) |
+	        ((root.ioport("DSW2")->read() & 0x40) >> 5) | ((root.ioport("DSW2")->read() & 0x80) >> 7));
 }
 
 READ8_MEMBER(ojankohs_state::ccasino_dipsw3_r)
 {
-	return (input_port_read(machine(), "DSW3") ^ 0xff);		// DIPSW 3
+	return (ioport("DSW3")->read() ^ 0xff);		// DIPSW 3
 }
 
 READ8_MEMBER(ojankohs_state::ccasino_dipsw4_r)
 {
-	return (input_port_read(machine(), "DSW4") ^ 0xff);		// DIPSW 4
+	return (ioport("DSW4")->read() ^ 0xff);		// DIPSW 4
 }
 
 WRITE8_MEMBER(ojankohs_state::ojankoy_coinctr_w)
diff -Nru src-old/mame/drivers/omegrace.c src/mame/drivers/omegrace.c
--- src-old/mame/drivers/omegrace.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/omegrace.c	2012-05-03 11:00:08.000000000 +0200
@@ -297,7 +297,7 @@
 
 READ8_MEMBER(omegrace_state::omegrace_spinner1_r)
 {
-	return (spinnerTable[input_port_read(machine(), "SPIN0") & 0x3f]);
+	return (spinnerTable[ioport("SPIN0")->read() & 0x3f]);
 }
 
 
diff -Nru src-old/mame/drivers/oneshot.c src/mame/drivers/oneshot.c
--- src-old/mame/drivers/oneshot.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/oneshot.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 
 READ16_MEMBER(oneshot_state::oneshot_in0_word_r)
 {
-	int data = input_port_read(machine(), "DSW1");
+	int data = ioport("DSW1")->read();
 
 	switch (data & 0x0c)
 	{
diff -Nru src-old/mame/drivers/onetwo.c src/mame/drivers/onetwo.c
--- src-old/mame/drivers/onetwo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/onetwo.c	2012-05-03 11:00:08.000000000 +0200
@@ -215,7 +215,7 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_EQUALS,0x04) PORT_DIPLOCATION("SW1:5,6,7,8")
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2",0x04,EQUALS,0x04) PORT_DIPLOCATION("SW1:5,6,7,8")
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0xb0, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0xc0, DEF_STR( 4C_1C ) )
@@ -232,12 +232,12 @@
 	PORT_DIPSETTING(    0x60, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x50, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:5,6")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2",0x04,NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:5,6")
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:7,8")
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2",0x04,NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:7,8")
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_5C ) )
diff -Nru src-old/mame/drivers/opwolf.c src/mame/drivers/opwolf.c
--- src-old/mame/drivers/opwolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/opwolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -304,13 +304,13 @@
 READ16_MEMBER(opwolf_state::opwolf_in_r)
 {
 	static const char *const inname[2] = { "IN0", "IN1" };
-	return input_port_read(machine(), inname[offset]);
+	return ioport(inname[offset])->read();
 }
 
 READ16_MEMBER(opwolf_state::opwolf_dsw_r)
 {
 	static const char *const dswname[2] = { "DSWA", "DSWB" };
-	return input_port_read(machine(), dswname[offset]);
+	return ioport(dswname[offset])->read();
 }
 
 READ16_MEMBER(opwolf_state::opwolf_lightgun_r)
@@ -320,10 +320,10 @@
 	switch (offset)
 	{
 		case 0x00:	/* P1X - Have to remap 8 bit input value, into 0-319 visible range */
-			scaled = (input_port_read(machine(), P1X_PORT_TAG) * 320 ) / 256;
+			scaled = (ioport(P1X_PORT_TAG)->read() * 320 ) / 256;
 			return (scaled + 0x15 + m_opwolf_gun_xoffs);
 		case 0x01:	/* P1Y */
-			return (input_port_read(machine(), P1Y_PORT_TAG) - 0x24 + m_opwolf_gun_yoffs);
+			return (ioport(P1Y_PORT_TAG)->read() - 0x24 + m_opwolf_gun_yoffs);
 	}
 
 	return 0xff;
@@ -331,12 +331,12 @@
 
 READ8_MEMBER(opwolf_state::z80_input1_r)
 {
-	return input_port_read(machine(), "IN0");	/* irrelevant mirror ? */
+	return ioport("IN0")->read();	/* irrelevant mirror ? */
 }
 
 READ8_MEMBER(opwolf_state::z80_input2_r)
 {
-	return input_port_read(machine(), "IN0");	/* needed for coins */
+	return ioport("IN0")->read();	/* needed for coins */
 }
 
 
@@ -979,7 +979,7 @@
 static DRIVER_INIT( opwolf )
 {
 	opwolf_state *state = machine.driver_data<opwolf_state>();
-	UINT16* rom = (UINT16*)machine.root_device().memregion("maincpu")->base();
+	UINT16* rom = (UINT16*)state->memregion("maincpu")->base();
 
 	state->m_opwolf_region = rom[0x03fffe / 2] & 0xff;
 
@@ -996,7 +996,7 @@
 static DRIVER_INIT( opwolfb )
 {
 	opwolf_state *state = machine.driver_data<opwolf_state>();
-	UINT16* rom = (UINT16*)machine.root_device().memregion("maincpu")->base();
+	UINT16* rom = (UINT16*)state->memregion("maincpu")->base();
 
 	state->m_opwolf_region = rom[0x03fffe / 2] & 0xff;
 
diff -Nru src-old/mame/drivers/orbit.c src/mame/drivers/orbit.c
--- src-old/mame/drivers/orbit.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/orbit.c	2012-05-03 11:00:08.000000000 +0200
@@ -187,7 +187,7 @@
 	PORT_DIPNAME( 0x40, 0x40, "DIAG TEST" ) /* should be off */
 	PORT_DIPSETTING( 0x40, DEF_STR( Off ))
 	PORT_DIPSETTING( 0x00, DEF_STR( On ))
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("BUTTONS")	/* 2800 */
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("Game 7 / Strong Gravity") PORT_CODE(KEYCODE_7_PAD)
diff -Nru src-old/mame/drivers/othldrby.c src/mame/drivers/othldrby.c
--- src-old/mame/drivers/othldrby.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/drivers/othldrby.c	2012-05-03 11:00:08.000000000 +0200
@@ -104,7 +104,7 @@
 
 static INPUT_PORTS_START( othldrby )
 	PORT_START("VBLANK")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Demo_Sounds ) )
diff -Nru src-old/mame/drivers/othunder.c src/mame/drivers/othunder.c
--- src-old/mame/drivers/othunder.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/othunder.c	2012-05-03 11:00:08.000000000 +0200
@@ -372,7 +372,7 @@
 READ16_MEMBER(othunder_state::othunder_lightgun_r)
 {
 	static const char *const portname[4] = { P1X_PORT_TAG, P1Y_PORT_TAG, P2X_PORT_TAG, P2Y_PORT_TAG };
-	return input_port_read(machine(), portname[offset]);
+	return ioport(portname[offset])->read();
 }
 
 WRITE16_MEMBER(othunder_state::othunder_lightgun_w)
diff -Nru src-old/mame/drivers/overdriv.c src/mame/drivers/overdriv.c
--- src-old/mame/drivers/overdriv.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/drivers/overdriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -70,7 +70,7 @@
 		/* bit 0 is data */
 		/* bit 1 is clock (active high) */
 		/* bit 2 is cs (active low) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
diff -Nru src-old/mame/drivers/pachifev.c src/mame/drivers/pachifev.c
--- src-old/mame/drivers/pachifev.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pachifev.c	2012-05-03 11:00:08.000000000 +0200
@@ -311,10 +311,10 @@
 		address_space *ramspace = device->memory().space(AS_PROGRAM);
 		UINT8 player = 0;
 
-		if ((ramspace->read_byte(0xe00f) == 0x01) && ((input_port_read(device->machine(), "DSW1") & 0x08) == 0x00))
+		if ((ramspace->read_byte(0xe00f) == 0x01) && ((state->ioport("DSW1")->read() & 0x08) == 0x00))
 			player = 1;
 
-        int current_power=input_port_read(device->machine(), inname[player]) & 0x3f;
+        int current_power=state->ioport(inname[player])->read() & 0x3f;
         if(current_power != state->m_previous_power)
         {
             popmessage    ("%d%%", (current_power * 100) / 0x3f);
diff -Nru src-old/mame/drivers/pacland.c src/mame/drivers/pacland.c
--- src-old/mame/drivers/pacland.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/pacland.c	2012-05-03 11:00:08.000000000 +0200
@@ -198,8 +198,8 @@
 	int shift = 4 * (offset & 1);
 	int port = offset & 2;
 	static const char *const portnames[] = { "DSWA", "DSWB", "IN0", "IN1" };
-	int r = (input_port_read(machine(), portnames[port]) << shift) & 0xf0;
-	r |= (input_port_read(machine(), portnames[port+1]) >> (4 - shift)) & 0x0f;
+	int r = (ioport(portnames[port])->read() << shift) & 0xf0;
+	r |= (ioport(portnames[port+1])->read() >> (4 - shift)) & 0x0f;
 
 	return r;
 }
diff -Nru src-old/mame/drivers/pacman.c src/mame/drivers/pacman.c
--- src-old/mame/drivers/pacman.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pacman.c	2012-05-03 11:00:08.000000000 +0200
@@ -374,7 +374,7 @@
 static MACHINE_RESET( mschamp )
 {
 	UINT8 *rom = machine.root_device().memregion("maincpu")->base() + 0x10000;
-	int whichbank = input_port_read(machine, "GAME") & 1;
+	int whichbank = machine.root_device().ioport("GAME")->read() & 1;
 
 	machine.root_device().membank("bank1")->configure_entries(0, 2, &rom[0x0000], 0x8000);
 	machine.root_device().membank("bank2")->configure_entries(0, 2, &rom[0x4000], 0x8000);
@@ -541,7 +541,7 @@
 
 READ8_MEMBER(pacman_state::maketrax_special_port2_r)
 {
-	int data = input_port_read(machine(), "DSW1");
+	int data = ioport("DSW1")->read();
 	int pc = cpu_get_previouspc(&space.device());
 
 	if ((pc == 0x1973) || (pc == 0x2389)) return data | 0x40;
@@ -584,7 +584,7 @@
 
 READ8_MEMBER(pacman_state::korosuke_special_port2_r)
 {
-	int data = input_port_read(machine(), "DSW1");
+	int data = ioport("DSW1")->read();
 	int pc = cpu_get_previouspc(&space.device());
 
 	if ((pc == 0x196e) || (pc == 0x2387)) return data | 0x40;
@@ -2806,7 +2806,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("Sense")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -2858,7 +2858,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("Sense")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -2910,7 +2910,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
 	PORT_START("Sense")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/paradise.c src/mame/drivers/paradise.c
--- src-old/mame/drivers/paradise.c	2012-04-22 01:42:20.000000000 +0200
+++ src/mame/drivers/paradise.c	2012-05-03 11:00:08.000000000 +0200
@@ -260,7 +260,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -345,7 +345,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(5)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(5)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -424,7 +424,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -506,7 +506,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -588,7 +588,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -672,7 +672,7 @@
 static MACHINE_START( paradise )
 {
 	paradise_state *state = machine.driver_data<paradise_state>();
-	int bank_n = machine.root_device().memregion("maincpu")->bytes() / 0x4000 - 1;
+	int bank_n = state->memregion("maincpu")->bytes() / 0x4000 - 1;
 	UINT8 *ROM = state->memregion("maincpu")->base();
 
 	state->membank("bank1")->configure_entries(0, 3, &ROM[0x00000], 0x4000);
diff -Nru src-old/mame/drivers/pastelg.c src/mame/drivers/pastelg.c
--- src-old/mame/drivers/pastelg.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pastelg.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,11 +82,11 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(),"KEY0_PL1");
-		case 0x02: return input_port_read(machine(),"KEY1_PL1");
-		case 0x04: return input_port_read(machine(),"KEY2_PL1");
-		case 0x08: return input_port_read(machine(),"KEY3_PL1");
-		case 0x10: return input_port_read(machine(),"KEY4_PL1");
+		case 0x01: return ioport("KEY0_PL1")->read();
+		case 0x02: return ioport("KEY1_PL1")->read();
+		case 0x04: return ioport("KEY2_PL1")->read();
+		case 0x08: return ioport("KEY3_PL1")->read();
+		case 0x10: return ioport("KEY4_PL1")->read();
 	}
 
 	return 0xff;
@@ -96,11 +96,11 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(),"KEY0_PL2");
-		case 0x02: return input_port_read(machine(),"KEY1_PL2");
-		case 0x04: return input_port_read(machine(),"KEY2_PL2");
-		case 0x08: return input_port_read(machine(),"KEY3_PL2");
-		case 0x10: return input_port_read(machine(),"KEY4_PL2");
+		case 0x01: return ioport("KEY0_PL2")->read();
+		case 0x02: return ioport("KEY1_PL2")->read();
+		case 0x04: return ioport("KEY2_PL2")->read();
+		case 0x08: return ioport("KEY3_PL2")->read();
+		case 0x10: return ioport("KEY4_PL2")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/pcat_nit.c src/mame/drivers/pcat_nit.c
--- src-old/mame/drivers/pcat_nit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pcat_nit.c	2012-05-03 11:00:08.000000000 +0200
@@ -195,7 +195,7 @@
 		case 0: /* 278 */
 			return 0xff;
 		case 1: /* 279 */
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 7: /* 27f dips */
 			return 0xff;
 		default:
diff -Nru src-old/mame/drivers/pcxt.c src/mame/drivers/pcxt.c
--- src-old/mame/drivers/pcxt.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pcxt.c	2012-05-03 11:00:08.000000000 +0200
@@ -146,8 +146,8 @@
 READ8_MEMBER(pcxt_state::disk_iobank_r)
 {
 	//printf("Read Prototyping card [%02x] @ PC=%05x\n",offset,cpu_get_pc(&space.device()));
-	//if(offset == 0) return input_port_read(machine(), "DSW");
-	if(offset == 1) return input_port_read(machine(), "IN1");
+	//if(offset == 0) return ioport("DSW")->read();
+	if(offset == 1) return ioport("IN1")->read();
 
 	return m_disk_data[offset];
 }
diff -Nru src-old/mame/drivers/pengadvb.c src/mame/drivers/pengadvb.c
--- src-old/mame/drivers/pengadvb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pengadvb.c	2012-05-03 11:00:08.000000000 +0200
@@ -178,7 +178,7 @@
 
 static READ8_DEVICE_HANDLER( pengadvb_psg_port_a_r )
 {
-	return input_port_read(device->machine(), "IN0");
+	return device->machine().root_device().ioport("IN0")->read();
 }
 
 static const ay8910_interface pengadvb_ay8910_interface =
@@ -212,7 +212,7 @@
 	i8255_device *ppi = device->machine().device<i8255_device>("ppi8255");
 	address_space *space = device->machine().firstcpu->memory().space(AS_PROGRAM);
 	if ((ppi->read(*space, 2) & 0x0f) == 0)
-		return input_port_read(device->machine(), "IN1");
+		return device->machine().root_device().ioport("IN1")->read();
 
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/peplus.c src/mame/drivers/peplus.c
--- src-old/mame/drivers/peplus.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/peplus.c	2012-05-03 11:00:08.000000000 +0200
@@ -352,8 +352,8 @@
 
 static void handle_lightpen( device_t *device )
 {
-    int x_val = input_port_read_safe(device->machine(), "TOUCH_X",0x00);
-    int y_val = input_port_read_safe(device->machine(), "TOUCH_Y",0x00);
+    int x_val = device->machine().root_device().ioport("TOUCH_X")->read_safe(0x00);
+    int y_val = device->machine().root_device().ioport("TOUCH_Y")->read_safe(0x00);
     const rectangle &vis_area = device->machine().primary_screen->visible_area();
     int xt, yt;
 
@@ -576,7 +576,7 @@
 		sda = i2cmem_sda_read(device);
 	}
 
-	if ((input_port_read_safe(device->machine(), "SENSOR",0x00) & 0x01) == 0x01 && state->m_coin_state == 0) {
+	if ((state->ioport("SENSOR")->read_safe(0x00) & 0x01) == 0x01 && state->m_coin_state == 0) {
 		state->m_coin_state = 1; // Start Coin Cycle
 		state->m_last_cycles = device->machine().firstcpu->total_cycles();
 	} else {
@@ -615,7 +615,7 @@
 		door_wait = 12345;
 
 	if (curr_cycles - state->m_last_door > door_wait) {
-		if ((input_port_read_safe(device->machine(), "DOOR",0xff) & 0x01) == 0x01) {
+		if ((state->ioport("DOOR")->read_safe(0xff) & 0x01) == 0x01) {
 			state->m_door_open = (!state->m_door_open & 0x01);
 		} else {
 			state->m_door_open = 1;
@@ -818,7 +818,7 @@
 CUSTOM_INPUT_MEMBER(peplus_state::peplus_input_r)
 {
 	UINT8 inp_ret = 0x00;
-	UINT8 inp_read = input_port_read(machine(), (const char *)param);
+	UINT8 inp_read = ioport((const char *)param)->read();
 
 	if (inp_read & 0x01) inp_ret = 0x01;
 	if (inp_read & 0x02) inp_ret = 0x02;
@@ -1035,7 +1035,7 @@
 	state->m_autohold_addr = 0x5e7e; // AutoHold Address
 
 	if (state->m_autohold_addr)
-		state->m_program_ram[state->m_autohold_addr] = input_port_read_safe(machine, "AUTOHOLD",0x00) & 0x01;
+		state->m_program_ram[state->m_autohold_addr] = state->ioport("AUTOHOLD")->read_safe(0x00) & 0x01;
 #endif
 }
 
diff -Nru src-old/mame/drivers/peyper.c src/mame/drivers/peyper.c
--- src-old/mame/drivers/peyper.c	2012-04-09 13:58:25.000000000 +0200
+++ src/mame/drivers/peyper.c	2012-05-03 11:00:08.000000000 +0200
@@ -174,9 +174,9 @@
 	switch (bit_mask)
 	{
 		case 0x03:
-			return ((input_port_read(machine(), "REPLAY") & bit_mask) >> 0);
+			return ((ioport("REPLAY")->read() & bit_mask) >> 0);
 		case 0x40:
-			return ((input_port_read(machine(), "REPLAY") & bit_mask) >> 6);
+			return ((ioport("REPLAY")->read() & bit_mask) >> 6);
 		default:
 			logerror("wolfman_replay_hs_r : invalid %02X bit_mask\n",bit_mask);
 			return 0;
diff -Nru src-old/mame/drivers/pgm.c src/mame/drivers/pgm.c
--- src-old/mame/drivers/pgm.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pgm.c	2012-05-03 11:00:08.000000000 +0200
@@ -3613,7 +3613,7 @@
 static void expand_colourdata( running_machine &machine )
 {
 	pgm_state *state = machine.driver_data<pgm_state>();
-	UINT8 *src = machine.root_device().memregion( "sprcol" )->base();
+	UINT8 *src = state->memregion( "sprcol" )->base();
 	size_t srcsize = state->memregion( "sprcol" )->bytes();
 	int cnt;
 	size_t needed = srcsize / 2 * 3;
diff -Nru src-old/mame/drivers/phoenix.c src/mame/drivers/phoenix.c
--- src-old/mame/drivers/phoenix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/phoenix.c	2012-05-03 11:00:08.000000000 +0200
@@ -101,7 +101,7 @@
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )          PORT_DIPLOCATION( "SW1:7" )
 	PORT_DIPSETTING(	0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")		/* fake port for non-memory mapped dip switch */
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION( "SW1:!8" )
@@ -113,10 +113,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( phoenixa )
@@ -184,7 +184,7 @@
 	PORT_DIPSETTING(	0x50, "Fast" )
 	PORT_DIPSETTING(	0x60, "Faster" )
 	PORT_DIPSETTING(	0x70, "Fastest" )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x0f, 0x00, DEF_STR( Coin_B ) )           PORT_DIPLOCATION( "SW2:1,2,3,4" )
@@ -232,10 +232,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_2WAY
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON2 )
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( falconz )
@@ -305,10 +305,10 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL					PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL	PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )									PORT_CONDITION("CAB",0x01,PORTCOND_EQUALS,0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL					PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL	PORT_CONDITION("CAB",0x01,EQUALS,0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )									PORT_CONDITION("CAB",0x01,EQUALS,0x01)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( pleiadbl )
@@ -381,7 +381,7 @@
 	PORT_DIPSETTING(	0x20, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(	0x40, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(	0x60, DEF_STR( 1C_1C ) )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CAB")		/* fake port for non-memory mapped dip switch */
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )
diff -Nru src-old/mame/drivers/pingpong.c src/mame/drivers/pingpong.c
--- src-old/mame/drivers/pingpong.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pingpong.c	2012-05-03 11:00:08.000000000 +0200
@@ -598,13 +598,13 @@
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_bank(0x5700, 0x57ff, "bank8");
 
 	// setup default banks
-	state->membank("bank1")->set_base(machine.root_device().memregion("user1")->base() + 0x100*0 );
-	state->membank("bank2")->set_base(machine.root_device().memregion("user1")->base() + 0x100*1 );
-	state->membank("bank3")->set_base(machine.root_device().memregion("user1")->base() + 0x100*2 );
-	state->membank("bank4")->set_base(machine.root_device().memregion("user1")->base() + 0x100*3 );
-	state->membank("bank5")->set_base(machine.root_device().memregion("user1")->base() + 0x100*4 );
-	state->membank("bank6")->set_base(machine.root_device().memregion("user1")->base() + 0x100*5 );
-	state->membank("bank7")->set_base(machine.root_device().memregion("user1")->base() + 0x100*6 );
+	state->membank("bank1")->set_base(state->memregion("user1")->base() + 0x100*0 );
+	state->membank("bank2")->set_base(state->memregion("user1")->base() + 0x100*1 );
+	state->membank("bank3")->set_base(state->memregion("user1")->base() + 0x100*2 );
+	state->membank("bank4")->set_base(state->memregion("user1")->base() + 0x100*3 );
+	state->membank("bank5")->set_base(state->memregion("user1")->base() + 0x100*4 );
+	state->membank("bank6")->set_base(state->memregion("user1")->base() + 0x100*5 );
+	state->membank("bank7")->set_base(state->memregion("user1")->base() + 0x100*6 );
 	state->membank("bank8")->set_base(state->memregion("user1")->base() + 0x100*7 );
 }
 
diff -Nru src-old/mame/drivers/pinkiri8.c src/mame/drivers/pinkiri8.c
--- src-old/mame/drivers/pinkiri8.c	2012-04-12 01:29:02.000000000 +0200
+++ src/mame/drivers/pinkiri8.c	2012-05-03 11:00:08.000000000 +0200
@@ -450,11 +450,11 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(), "PL2_01");
-		case 0x02: return input_port_read(machine(), "PL2_02");
-		case 0x04: return input_port_read(machine(), "PL2_03");
-		case 0x08: return input_port_read(machine(), "PL2_04");
-		case 0x10: return input_port_read(machine(), "PL2_05");
+		case 0x01: return ioport("PL2_01")->read();
+		case 0x02: return ioport("PL2_02")->read();
+		case 0x04: return ioport("PL2_03")->read();
+		case 0x08: return ioport("PL2_04")->read();
+		case 0x10: return ioport("PL2_05")->read();
 	}
 
 	return 0xff;
@@ -464,11 +464,11 @@
 {
 	switch(m_mux_data)
 	{
-		case 0x01: return input_port_read(machine(), "PL1_01");
-		case 0x02: return input_port_read(machine(), "PL1_02");
-		case 0x04: return input_port_read(machine(), "PL1_03");
-		case 0x08: return input_port_read(machine(), "PL1_04");
-		case 0x10: return input_port_read(machine(), "PL1_05");
+		case 0x01: return ioport("PL1_01")->read();
+		case 0x02: return ioport("PL1_02")->read();
+		case 0x04: return ioport("PL1_03")->read();
+		case 0x08: return ioport("PL1_04")->read();
+		case 0x10: return ioport("PL1_05")->read();
 	}
 
 	return 0xff;
diff -Nru src-old/mame/drivers/pipedrm.c src/mame/drivers/pipedrm.c
--- src-old/mame/drivers/pipedrm.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pipedrm.c	2012-05-03 11:00:08.000000000 +0200
@@ -595,7 +595,7 @@
 	state->m_subcpu = machine.device("sub");
 
 	/* initialize main Z80 bank */
-	state->membank("bank1")->configure_entries(0, 8, machine.root_device().memregion("maincpu")->base() + 0x10000, 0x2000);
+	state->membank("bank1")->configure_entries(0, 8, state->memregion("maincpu")->base() + 0x10000, 0x2000);
 	state->membank("bank1")->set_entry(0);
 
 	/* initialize sound bank */
diff -Nru src-old/mame/drivers/pktgaldx.c src/mame/drivers/pktgaldx.c
--- src-old/mame/drivers/pktgaldx.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/pktgaldx.c	2012-05-03 11:00:08.000000000 +0200
@@ -162,7 +162,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/playch10.c src/mame/drivers/playch10.c
--- src-old/mame/drivers/playch10.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/playch10.c	2012-05-03 11:00:08.000000000 +0200
@@ -426,33 +426,33 @@
     PORT_START("SW1")
     PORT_DIPNAME( 0x3f, 0x09, "Prime Time Bonus" )
     // STANDARD TIME (no bonus)
-    PORT_DIPSETTING(    0x00, "0%" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x00, "0%" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
     // PRIME TIME (bonus) for 2 COINS
-    PORT_DIPSETTING(    0x07, "8%" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x08, "17%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x09, "25%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x10, "33%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x11, "42%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x12, "50%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x13, "58%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x14, "67%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x15, "75%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x16, "83%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x17, "92%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x18, "100%" )  PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x07, "8%" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x08, "17%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x09, "25%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x10, "33%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x11, "42%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x12, "50%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x13, "58%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x14, "67%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x15, "75%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x16, "83%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x17, "92%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x18, "100%" )  PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
     // PRIME TIME (bonus) for 4 COINS
-    PORT_DIPSETTING(    0x04, "8%" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x05, "17%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x06, "25%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x07, "33%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x08, "42%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x09, "50%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x10, "58%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x11, "67%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x12, "75%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x13, "83%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x14, "92%" )   PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x15, "100%" )  PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x04, "8%" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x05, "17%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x06, "25%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x07, "33%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x08, "42%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x09, "50%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x10, "58%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x11, "67%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x12, "75%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x13, "83%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x14, "92%" )   PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x15, "100%" )  PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
 
     PORT_DIPNAME( 0x40, 0x40, DEF_STR( Demo_Sounds ) )
     PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
@@ -462,53 +462,53 @@
     PORT_START("SW2")
     PORT_DIPNAME( 0x3f, 0x28, "Play Time/Coin" )
     // STANDARD TIME (no bonus)
-    PORT_DIPSETTING(    0x3f, DEF_STR( Free_Play ) )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x23, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x21, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x1f, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x1d, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x1b, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x19, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x17, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x15, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x13, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x11, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x0f, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x0d, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x0b, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x09, "4:10 (250)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x07, "4:20 (260)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x05, "4:30 (270)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x03, "4:40 (280)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
-    PORT_DIPSETTING(    0x01, "4:50 (290)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x3f, DEF_STR( Free_Play ) )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x23, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x21, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x1f, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x1d, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x1b, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x19, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x17, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x15, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x13, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x11, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x0f, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x0d, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x0b, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x09, "4:10 (250)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x07, "4:20 (260)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x05, "4:30 (270)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x03, "4:40 (280)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
+    PORT_DIPSETTING(    0x01, "4:50 (290)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0xc0 )
     // PRIME TIME (bonus) for 2 COINS
-    PORT_DIPSETTING(    0x1c, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x1e, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x20, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x22, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x24, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x26, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x28, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x2a, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x2c, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x2e, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x30, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x32, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
-    PORT_DIPSETTING(    0x34, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x1c, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x1e, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x20, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x22, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x24, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x26, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x28, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x2a, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x2c, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x2e, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x30, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x32, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
+    PORT_DIPSETTING(    0x34, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x80 )
     // PRIME TIME (bonus) for 4 COINS
-    PORT_DIPSETTING(    0x1c, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x1e, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x20, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x22, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x24, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x26, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x28, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x2a, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x2c, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x2e, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x30, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x32, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
-    PORT_DIPSETTING(    0x34, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, PORTCOND_EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x1c, "2:00 (120)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x1e, "2:10 (130)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x20, "2:20 (140)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x22, "2:30 (150)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x24, "2:40 (160)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x26, "2:50 (170)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x28, "3:00 (180)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x2a, "3:10 (190)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x2c, "3:20 (200)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x2e, "3:30 (210)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x30, "3:40 (220)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x32, "3:50 (230)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
+    PORT_DIPSETTING(    0x34, "4:00 (240)" )    PORT_CONDITION("SW2", 0xc0, EQUALS, 0x00 )
 
     PORT_DIPNAME( 0xc0, 0x80, "Bonus" )
     PORT_DIPSETTING(    0xc0, "Standard Time" )
diff -Nru src-old/mame/drivers/playmark.c src/mame/drivers/playmark.c
--- src-old/mame/drivers/playmark.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/playmark.c	2012-05-03 11:00:08.000000000 +0200
@@ -414,7 +414,7 @@
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) )
@@ -431,12 +431,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
@@ -513,7 +513,7 @@
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) )
@@ -530,12 +530,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
@@ -661,7 +661,7 @@
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) )
@@ -678,12 +678,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
@@ -725,7 +725,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)	/* EEPROM data */
 
 	PORT_START("DSW1")
@@ -756,7 +756,7 @@
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) )
@@ -773,12 +773,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
@@ -852,7 +852,7 @@
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW2", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) )
@@ -869,12 +869,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW2", 0x01, NOTEQUALS, 0x01)
 	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) )
@@ -1678,7 +1678,7 @@
 static DRIVER_INIT( bigtwin )
 {
 	playmark_state *state = machine.driver_data<playmark_state>();
-	UINT8 *playmark_PICROM_HEX = machine.root_device().memregion("user1")->base();
+	UINT8 *playmark_PICROM_HEX = state->memregion("user1")->base();
 	UINT16 *playmark_PICROM = (UINT16 *)state->memregion("audiocpu")->base();
 	INT32 offs, data;
 	UINT16 src_pos = 0;
diff -Nru src-old/mame/drivers/pluto5.c src/mame/drivers/pluto5.c
--- src-old/mame/drivers/pluto5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pluto5.c	2012-04-30 19:19:12.000000000 +0200
@@ -28,6 +28,8 @@
   ---------------------------------------------------------------------
 
   Pluto 5 Technical Notes....
+   (why is this information here? it seems to be c+p straight from a tech manual
+    and is completely unneccessary)
 
 
   * Clocks...
@@ -180,22 +182,78 @@
 {
 public:
 	pluto5_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_maincpu(*this, "maincpu")
+	{ }
+
+	UINT32* m_cpuregion;
+	UINT32* m_mainram;
+
+	DECLARE_READ32_MEMBER(pluto5_mem_r);
+	DECLARE_WRITE32_MEMBER(pluto5_mem_w);
+
+protected:
+
+	// devices
+	required_device<cpu_device> m_maincpu;
 
 };
 
+READ32_MEMBER(pluto5_state::pluto5_mem_r)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		case 1:
+			return m_cpuregion[offset];
+
+		default:
+			logerror("%08x maincpu read access offset %08x mem_mask %08x cs %d\n", pc, offset*4, mem_mask, cs);
+
+	}
+
+	return 0x0000;
+}
+
+WRITE32_MEMBER(pluto5_state::pluto5_mem_w)
+{
+	int pc = cpu_get_pc(&space.device());
+	int cs = m68340_get_cs(m_maincpu, offset * 4);
+
+	switch ( cs )
+	{
+		default:
+			logerror("%08x maincpu write access offset %08x data %08x mem_mask %08x cs %d\n", pc, offset*4, data, mem_mask, cs);
+
+	}
+
+}
+
 
 static ADDRESS_MAP_START( pluto5_map, AS_PROGRAM, 32, pluto5_state )
-	AM_RANGE(0x000000, 0x2fffff) AM_ROM
+	AM_RANGE(0x00000000, 0xffffffff) AM_READWRITE(pluto5_mem_r, pluto5_mem_w)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START(  pluto5 )
 INPUT_PORTS_END
 
+static MACHINE_START( pluto5 )
+{
+	pluto5_state *state = machine.driver_data<pluto5_state>();
+	state->m_cpuregion = (UINT32*)state->memregion( "maincpu" )->base();
+	state->m_mainram = (UINT32*)auto_alloc_array_clear(machine, UINT32, 0x10000);
+
+}
+
 static MACHINE_CONFIG_START( pluto5, pluto5_state )
 	MCFG_CPU_ADD("maincpu", M68340, 16000000)
 	MCFG_CPU_PROGRAM_MAP(pluto5_map)
 
+	MCFG_MACHINE_START( pluto5 )
+
+
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 	/* unknown sound */
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/plygonet.c src/mame/drivers/plygonet.c
--- src-old/mame/drivers/plygonet.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/plygonet.c	2012-05-03 11:00:08.000000000 +0200
@@ -110,8 +110,8 @@
 	}
 	else
 	{
-		UINT8 lowInputBits = input_port_read(device->machine(), "IN1");
-		UINT8 highInputBits = input_port_read(device->machine(), "IN0");
+		UINT8 lowInputBits = device->machine().root_device().ioport("IN1")->read();
+		UINT8 highInputBits = device->machine().root_device().ioport("IN0")->read();
 		return ((highInputBits << 24) | (lowInputBits << 16));
 	}
 
@@ -124,7 +124,7 @@
 {
 	if (ACCESSING_BITS_24_31)
 	{
-		input_port_write(machine(), "EEPROMOUT", data, 0xffffffff);
+		ioport("EEPROMOUT")->write(data, 0xffffffff);
 		return;
 	}
 
diff -Nru src-old/mame/drivers/pntnpuzl.c src/mame/drivers/pntnpuzl.c
--- src-old/mame/drivers/pntnpuzl.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/pntnpuzl.c	2012-05-03 11:00:08.000000000 +0200
@@ -170,7 +170,7 @@
 	pntnpuzl_state *state = device->machine().driver_data<pntnpuzl_state>();
 	/* bit 11 is EEPROM data */
 	eeprom_device *eeprom = downcast<eeprom_device *>(device);
-	return (state->m_eeprom & 0xf4ff) | (eeprom->read_bit()<<11) | (input_port_read(device->machine(), "IN1") & 0x0300);
+	return (state->m_eeprom & 0xf4ff) | (eeprom->read_bit()<<11) | (state->ioport("IN1")->read() & 0x0300);
 }
 
 static WRITE16_DEVICE_HANDLER( pntnpuzl_eeprom_w )
@@ -241,11 +241,11 @@
 
 	if (m_serial_out == 0x11)
 	{
-		if (input_port_read(machine(), "IN0") & 0x10)
+		if (ioport("IN0")->read() & 0x10)
 		{
 			m_touchscr[0] = 0x1b;
-			m_touchscr[2] = BITSWAP8(input_port_read(machine(), "TOUCHX"),0,1,2,3,4,5,6,7);
-			m_touchscr[4] = BITSWAP8(input_port_read(machine(), "TOUCHY"),0,1,2,3,4,5,6,7);
+			m_touchscr[2] = BITSWAP8(ioport("TOUCHX")->read(),0,1,2,3,4,5,6,7);
+			m_touchscr[4] = BITSWAP8(ioport("TOUCHY")->read(),0,1,2,3,4,5,6,7);
 		}
 		else
 			m_touchscr[0] = 0;
@@ -325,7 +325,7 @@
 
 static INPUT_PORTS_START( pntnpuzl )
 	PORT_START("IN0")	/* fake inputs */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN1 ) PORT_CHANGED_MEMBER(DEVICE_SELF, pntnpuzl_state,coin_inserted, 1) PORT_IMPULSE(1)
 	PORT_SERVICE_NO_TOGGLE( 0x04, IP_ACTIVE_HIGH )PORT_CHANGED_MEMBER(DEVICE_SELF, pntnpuzl_state,coin_inserted, 2) PORT_IMPULSE(1)
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 ) PORT_CHANGED_MEMBER(DEVICE_SELF, pntnpuzl_state,coin_inserted, 4) PORT_IMPULSE(1)
diff -Nru src-old/mame/drivers/polepos.c src/mame/drivers/polepos.c
--- src-old/mame/drivers/polepos.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/polepos.c	2012-05-03 11:00:08.000000000 +0200
@@ -267,7 +267,7 @@
 
 READ8_MEMBER(polepos_state::polepos_adc_r)
 {
-	return input_port_read(machine(), m_adc_input ? "ACCEL" : "BRAKE");
+	return ioport(m_adc_input ? "ACCEL" : "BRAKE")->read();
 }
 
 READ8_MEMBER(polepos_state::polepos_ready_r)
@@ -340,8 +340,8 @@
 }
 
 
-CUSTOM_INPUT_MEMBER(polepos_state::high_port_r){ return input_port_read(field.machine(), (const char *)param) >> 4; }
-CUSTOM_INPUT_MEMBER(polepos_state::low_port_r){ return input_port_read(field.machine(), (const char *)param) & 0x0f; }
+CUSTOM_INPUT_MEMBER(polepos_state::high_port_r){ return field.machine().root_device().ioport((const char *)param)->read() >> 4; }
+CUSTOM_INPUT_MEMBER(polepos_state::low_port_r){ return field.machine().root_device().ioport((const char *)param)->read() & 0x0f; }
 CUSTOM_INPUT_MEMBER(polepos_state::auto_start_r)
 {
 	return m_auto_start_mask;
@@ -409,7 +409,7 @@
 {
 	polepos_state *state = device->machine().driver_data<polepos_state>();
 	/* read the current steering value and update our delta */
-	UINT8 steer_new = input_port_read(device->machine(), "STEER");
+	UINT8 steer_new = state->ioport("STEER")->read();
 	state->m_steer_accum += (INT8)(steer_new - state->m_steer_last) * 2;
 	state->m_steer_last = steer_new;
 
diff -Nru src-old/mame/drivers/policetr.c src/mame/drivers/policetr.c
--- src-old/mame/drivers/policetr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/policetr.c	2012-05-05 00:10:42.000000000 +0200
@@ -25,6 +25,7 @@
   Sound Roms:  S12     - Sound rom v1.2
 
 Noted differences in versions of SharpShooter:
+ Added a "Welcome to Sharpshooter" start-up screen showing rom versions for v1.9
  Initial High Score names are changed between v1.1 and v1.2
   Circus of Mystery:
     The ballon challenge has been rewritten for v1.7
@@ -588,7 +589,32 @@
 ROM_END
 
 
-ROM_START( sshooter ) /* Rev 0.5B PCB , unknown program rom date */
+ROM_START( sshooter ) /* Rev 0.5B PCB , Added a "Welcome" start-up screen which shows "This is Version C191012" */
+	ROM_REGION( 0x800000, "gfx1", ROMREGION_ERASE00 ) /* Graphics v1.0 */
+	ROM_LOAD16_BYTE( "ss-u121.bin", 0x000000, 0x100000, CRC(22e27dd6) SHA1(cb9e8c450352bb116a9c0407cc8ce6d8ae9d9881) ) // 1:1
+	ROM_LOAD16_BYTE( "ss-u120.bin", 0x000001, 0x100000, CRC(30173b1b) SHA1(366464444ce208391ca350f1639403f0c2217330) ) // 1:2
+	ROM_LOAD16_BYTE( "ss-u125.bin", 0x200000, 0x100000, CRC(79e8520a) SHA1(682e5c7954f96db65a137f05cde67c310b85b526) ) // 2:1
+	ROM_LOAD16_BYTE( "ss-u124.bin", 0x200001, 0x100000, CRC(8e805970) SHA1(bfc9940ed6425f136d768170275279c590da7003) ) // 2:2
+	ROM_LOAD16_BYTE( "ss-u123.bin", 0x400000, 0x100000, CRC(d045bb62) SHA1(839209ff6a8e5db63a51a3494a6c973e0068a3c6) ) // 3:1
+	ROM_LOAD16_BYTE( "ss-u122.bin", 0x400001, 0x100000, CRC(163cc133) SHA1(a5e84b5060fd32362aa097d0194ce72e8a90357c) ) // 3:2
+	ROM_LOAD16_BYTE( "ss-u127.bin", 0x600000, 0x100000, CRC(76a7a591) SHA1(9fd7cce21b01f388966a3e8388ba95820ac10bfd) ) // 4:1
+	ROM_LOAD16_BYTE( "ss-u126.bin", 0x600001, 0x100000, CRC(ab1b9d60) SHA1(ff51a71443f7774d3abf96c2eb8ef6a54d73dd8e) ) // 4:2
+
+	ROM_REGION32_BE( 0x100000, "user1", 0 )
+	ROM_LOAD32_BYTE( "ss-u113.v19", 0x00000, 0x40000, CRC(de536a90) SHA1(76f0e0e2457d91b3c1bd2b3501591646a18db348) ) // 1:1
+	ROM_LOAD32_BYTE( "ss-u112.v19", 0x00001, 0x40000, CRC(2e4e1837) SHA1(b4088269e1e7a3913d2841eb24f53b1c413cd0cc) ) // 1:2
+	ROM_LOAD32_BYTE( "ss-u111.v19", 0x00002, 0x40000, CRC(485d03e8) SHA1(ebdf166b2354b318e6bfb68e0fb5647381b9c405) ) // 1:3
+	ROM_LOAD32_BYTE( "ss-u110.v19", 0x00003, 0x40000, CRC(df6a0a45) SHA1(a73a9dcdc669c6e61a5983f3b2a2721fe1b35f34) ) // 1:4
+
+	ROM_REGION( 0x1000000, "bsmt", 0 ) /* Sound v1.2 */
+	ROM_LOAD( "ss-u160.bin", 0x000000, 0x100000, CRC(1c603d42) SHA1(880992871be52129684052d542946de0cc32ba9a) ) // 1:1
+	ROM_RELOAD(              0x3f8000, 0x100000 )
+	ROM_LOAD( "ss-u162.bin", 0x100000, 0x100000, CRC(40ef448a) SHA1(c96f7b169be2576e9f3783af84c07259efefb812) ) // 2:1
+	ROM_RELOAD(              0x4f8000, 0x100000 )
+ROM_END
+
+
+ROM_START( sshooter17 ) /* Rev 0.5B PCB , unknown program rom date */
 	ROM_REGION( 0x800000, "gfx1", ROMREGION_ERASE00 ) /* Graphics v1.0 */
 	ROM_LOAD16_BYTE( "ss-u121.bin", 0x000000, 0x100000, CRC(22e27dd6) SHA1(cb9e8c450352bb116a9c0407cc8ce6d8ae9d9881) ) // 1:1
 	ROM_LOAD16_BYTE( "ss-u120.bin", 0x000001, 0x100000, CRC(30173b1b) SHA1(366464444ce208391ca350f1639403f0c2217330) ) // 1:2
@@ -714,6 +740,7 @@
 GAME( 1996, policetr13a, policetr, sshooter, policetr, plctr13b, ROT0, "P&P Marketing", "Police Trainer (Rev 1.3B Newer)", 0 )
 GAME( 1996, policetr13b, policetr, sshooter, policetr, plctr13b, ROT0, "P&P Marketing", "Police Trainer (Rev 1.3B)", 0 )
 
-GAME( 1998, sshooter,    0,        sshooter, policetr, sshooter, ROT0, "P&P Marketing", "Sharpshooter (Rev 1.7)", 0 )
+GAME( 1998, sshooter,    0,        sshooter, policetr, sshooter, ROT0, "P&P Marketing", "Sharpshooter (Rev 1.9)", 0 )
+GAME( 1998, sshooter17,  sshooter, sshooter, policetr, sshooter, ROT0, "P&P Marketing", "Sharpshooter (Rev 1.7)", 0 )
 GAME( 1998, sshooter12,  sshooter, sshooter, sshoot11, sshoot12, ROT0, "P&P Marketing", "Sharpshooter (Rev 1.2)", 0 )
 GAME( 1998, sshooter11,  sshooter, sshooter, sshoot11, sshoot12, ROT0, "P&P Marketing", "Sharpshooter (Rev 1.1)", 0 )
diff -Nru src-old/mame/drivers/polyplay.c src/mame/drivers/polyplay.c
--- src-old/mame/drivers/polyplay.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/polyplay.c	2012-05-03 11:00:08.000000000 +0200
@@ -129,7 +129,7 @@
 {
 	polyplay_state *state = device->machine().driver_data<polyplay_state>();
 
-	if (input_port_read(device->machine(), "INPUT") & 0x80)
+	if (state->ioport("INPUT")->read() & 0x80)
 		state->m_last = 0;
 	else
 	{
diff -Nru src-old/mame/drivers/poolshrk.c src/mame/drivers/poolshrk.c
--- src-old/mame/drivers/poolshrk.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/poolshrk.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,10 +72,10 @@
 READ8_MEMBER(poolshrk_state::poolshrk_input_r)
 {
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "IN3" };
-	UINT8 val = input_port_read(machine(), portnames[offset & 3]);
+	UINT8 val = ioport(portnames[offset & 3])->read();
 
-	int x = input_port_read(machine(), (offset & 1) ? "AN1" : "AN0");
-	int y = input_port_read(machine(), (offset & 1) ? "AN3" : "AN2");
+	int x = ioport((offset & 1) ? "AN1" : "AN0")->read();
+	int y = ioport((offset & 1) ? "AN3" : "AN2")->read();
 
 	if (x >= m_da_latch) val |= 8;
 	if (y >= m_da_latch) val |= 4;
diff -Nru src-old/mame/drivers/popeye.c src/mame/drivers/popeye.c
--- src-old/mame/drivers/popeye.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/popeye.c	2012-05-03 11:00:08.000000000 +0200
@@ -407,8 +407,8 @@
 	int res;
 
 
-	res = input_port_read(device->machine(), "DSW0");
-	res |= (input_port_read(device->machine(), "DSW1") << (7-state->m_dswbit)) & 0x80;
+	res = state->ioport("DSW0")->read();
+	res |= (state->ioport("DSW1")->read() << (7-state->m_dswbit)) & 0x80;
 
 	return res;
 }
diff -Nru src-old/mame/drivers/popper.c src/mame/drivers/popper.c
--- src-old/mame/drivers/popper.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/popper.c	2012-05-03 11:00:08.000000000 +0200
@@ -126,14 +126,14 @@
 	switch (offset)
 	{
 		//           player inputs        dsw1                           dsw2
-		case 0: data = input_port_read(machine(), "IN0") | ((input_port_read(machine(), "DSW1") & 0x02) << 5) | ((input_port_read(machine(), "DSW2") & 0x01) << 4); break;
-		case 1: data = input_port_read(machine(), "IN1") | ((input_port_read(machine(), "DSW1") & 0x01) << 6) | ((input_port_read(machine(), "DSW2") & 0x02) << 3); break;
-		case 2: data = input_port_read(machine(), "IN2") | ((input_port_read(machine(), "DSW1") & 0x08) << 3) | ((input_port_read(machine(), "DSW2") & 0x04) << 2); break;
-		case 3: data = input_port_read(machine(), "IN3") | ((input_port_read(machine(), "DSW1") & 0x04) << 4) | ((input_port_read(machine(), "DSW2") & 0x08) << 1); break;
-		case 4: data = ((input_port_read(machine(), "DSW1") & 0x20) << 2) | ((input_port_read(machine(), "DSW2") & 0x10) << 1); break;
-		case 5: data = ((input_port_read(machine(), "DSW1") & 0x10) << 3) | ((input_port_read(machine(), "DSW2") & 0x20) << 0); break;
-		case 6: data = ((input_port_read(machine(), "DSW1") & 0x80) << 0) | ((input_port_read(machine(), "DSW2") & 0x40) >> 1); break;
-		case 7: data = ((input_port_read(machine(), "DSW1") & 0x40) << 1) | ((input_port_read(machine(), "DSW2") & 0x80) >> 2); break;
+		case 0: data = ioport("IN0")->read() | ((ioport("DSW1")->read() & 0x02) << 5) | ((ioport("DSW2")->read() & 0x01) << 4); break;
+		case 1: data = ioport("IN1")->read() | ((ioport("DSW1")->read() & 0x01) << 6) | ((ioport("DSW2")->read() & 0x02) << 3); break;
+		case 2: data = ioport("IN2")->read() | ((ioport("DSW1")->read() & 0x08) << 3) | ((ioport("DSW2")->read() & 0x04) << 2); break;
+		case 3: data = ioport("IN3")->read() | ((ioport("DSW1")->read() & 0x04) << 4) | ((ioport("DSW2")->read() & 0x08) << 1); break;
+		case 4: data = ((ioport("DSW1")->read() & 0x20) << 2) | ((ioport("DSW2")->read() & 0x10) << 1); break;
+		case 5: data = ((ioport("DSW1")->read() & 0x10) << 3) | ((ioport("DSW2")->read() & 0x20) << 0); break;
+		case 6: data = ((ioport("DSW1")->read() & 0x80) << 0) | ((ioport("DSW2")->read() & 0x40) >> 1); break;
+		case 7: data = ((ioport("DSW1")->read() & 0x40) << 1) | ((ioport("DSW2")->read() & 0x80) >> 2); break;
 	}
 	return data;
 }
diff -Nru src-old/mame/drivers/powerbal.c src/mame/drivers/powerbal.c
--- src-old/mame/drivers/powerbal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/powerbal.c	2012-05-03 11:00:08.000000000 +0200
@@ -227,40 +227,40 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x01, 0x01, "Coin Mode" )
 	PORT_DIPSETTING(    0x01, "Mode 1" )
 	PORT_DIPSETTING(    0x00, "Mode 2" )
-	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x1a, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x02, DEF_STR( 8C_3C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x1c, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x04, DEF_STR( 5C_3C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x06, DEF_STR( 3C_2C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x1e, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x08, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x12, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x0e, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1",0x01,PORTCOND_NOTEQUALS,0x01)
+	PORT_DIPNAME( 0x1e, 0x1e, "Coinage Mode 1" ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x14, DEF_STR( 6C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x16, DEF_STR( 5C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x18, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x1a, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x02, DEF_STR( 8C_3C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x1c, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x04, DEF_STR( 5C_3C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x06, DEF_STR( 3C_2C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x1e, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x08, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x12, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x0e, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_5C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) ) PORT_CONDITION("DSW1",0x01,EQUALS,0x01)
+	PORT_DIPNAME( 0x06, 0x06, "Coin A Mode 2" ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x02, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x06, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPNAME( 0x18, 0x18, "Coin B Mode 2" ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x18, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_5C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSW1",0x01,NOTEQUALS,0x01)
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
@@ -324,7 +324,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("DSW1")
diff -Nru src-old/mame/drivers/prehisle.c src/mame/drivers/prehisle.c
--- src-old/mame/drivers/prehisle.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/prehisle.c	2012-05-03 11:00:08.000000000 +0200
@@ -140,7 +140,7 @@
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Allow_Continue ) )	PORT_DIPLOCATION("SW2:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Yes ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 /******************************************************************************/
diff -Nru src-old/mame/drivers/progolf.c src/mame/drivers/progolf.c
--- src-old/mame/drivers/progolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/progolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -279,7 +279,7 @@
 static INPUT_PORTS_START( progolf )
 	PORT_START("IN0")
 	PORT_BIT( 0x7f, IP_ACTIVE_HIGH, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("P1")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT )
@@ -311,14 +311,14 @@
 	PORT_DIPSETTING(    0x03, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_6C ) )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_6C ) )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_6C ) )  PORT_CONDITION("DSW2",0x40,PORTCOND_EQUALS,0x40)
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_3C ) )  PORT_CONDITION("DSW2",0x40,EQUALS,0x00)
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_6C ) )  PORT_CONDITION("DSW2",0x40,EQUALS,0x40)
 	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
diff -Nru src-old/mame/drivers/psikyo.c src/mame/drivers/psikyo.c
--- src-old/mame/drivers/psikyo.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/psikyo.c	2012-05-03 11:00:08.000000000 +0200
@@ -124,9 +124,9 @@
 {
 	switch (offset)
 	{
-		case 0x0:	return input_port_read(machine(), "P1_P2");
-		case 0x1:	return input_port_read(machine(), "DSW");
-		case 0x2:	return input_port_read(machine(), "COIN");
+		case 0x0:	return ioport("P1_P2")->read();
+		case 0x1:	return ioport("DSW")->read();
+		case 0x2:	return ioport("COIN")->read();
 		default:	logerror("PC %06X - Read input %02X !\n", cpu_get_pc(&space.device()), offset * 2);
 				return 0;
 	}
@@ -136,8 +136,8 @@
 {
 	switch (offset)
 	{
-		case 0x0:	return input_port_read(machine(), "P1_P2");
-		case 0x1:	return input_port_read(machine(), "DSW");
+		case 0x0:	return ioport("P1_P2")->read();
+		case 0x1:	return ioport("DSW")->read();
 		default:	logerror("PC %06X - Read input %02X !\n", cpu_get_pc(&space.device()), offset * 2);
 				return 0;
 	}
@@ -288,8 +288,8 @@
 {
 	switch (offset)
 	{
-		case 0x0:	return input_port_read(machine(), "P1_P2");
-		case 0x1:	return (input_port_read(machine(), "DSW") & 0xffff000f) | s1945_mcu_r(space, offset - 1, mem_mask);
+		case 0x0:	return ioport("P1_P2")->read();
+		case 0x1:	return (ioport("DSW")->read() & 0xffff000f) | s1945_mcu_r(space, offset - 1, mem_mask);
 		case 0x2:	return s1945_mcu_r(space, offset - 1, mem_mask);
 		default:	logerror("PC %06X - Read input %02X !\n", cpu_get_pc(&space.device()), offset * 2);
 					return 0;
@@ -543,7 +543,7 @@
 	PORT_INCLUDE(psikyo_common)
 
 	PORT_START("COIN")
-	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_VBLANK  )	// vblank
+	PORT_BIT( 0x00000001, IP_ACTIVE_LOW, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank
 	PORT_BIT( 0x00000002, IP_ACTIVE_LOW, IPT_UNKNOWN )	// unused?
 	PORT_BIT( 0x00000004, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000008, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -670,7 +670,7 @@
 	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x00000080, IP_ACTIVE_HIGH, IPT_VBLANK  )	// vblank   ACTIVE_HIGH fixes slowdowns, but is it right?
+	PORT_BIT( 0x00000080, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank   ACTIVE_HIGH fixes slowdowns, but is it right?
 	// This DSW is used for debugging the game
 	PORT_DIPNAME( 0x00000100, 0x00000100, "Unknown 3-0" )	// tested!
 	PORT_DIPSETTING(          0x00000100, DEF_STR( Off ) )
@@ -756,7 +756,7 @@
 	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_VBLANK  )	// vblank
+	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank
 	PORT_BIT( 0x00000100, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000200, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000400, IP_ACTIVE_LOW, IPT_UNKNOWN )	// tested!
@@ -826,7 +826,7 @@
 	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_VBLANK  )	// vblank
+	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank
 	PORT_BIT( 0x00000100, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000200, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000400, IP_ACTIVE_LOW, IPT_UNKNOWN )	// tested!
@@ -898,7 +898,7 @@
 
 	// I need to invert the Vblank on this to avoid excessive slowdown
 	PORT_MODIFY("DSW")		/* c00004 -> c00007 */
-	PORT_BIT( 0x00000080, IP_ACTIVE_HIGH, IPT_VBLANK  )	// vblank
+	PORT_BIT( 0x00000080, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank
 INPUT_PORTS_END
 
 
@@ -942,7 +942,7 @@
 	PORT_BIT( 0x00000010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_VBLANK  )	// vblank
+	PORT_BIT( 0x00000080, IP_ACTIVE_LOW, IPT_CUSTOM  ) PORT_VBLANK("screen")	// vblank
 	PORT_BIT( 0x00000100, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000200, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x00000400, IP_ACTIVE_LOW, IPT_UNKNOWN )	// tested!
@@ -1811,7 +1811,7 @@
 	psikyo_state *state = machine.driver_data<psikyo_state>();
 
 	{
-		UINT8 *RAM = machine.root_device().memregion("ymsnd")->base();
+		UINT8 *RAM = state->memregion("ymsnd")->base();
 		int len = state->memregion("ymsnd")->bytes();
 		int i;
 
diff -Nru src-old/mame/drivers/psikyo4.c src/mame/drivers/psikyo4.c
--- src-old/mame/drivers/psikyo4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/psikyo4.c	2012-05-03 11:00:08.000000000 +0200
@@ -182,7 +182,7 @@
 {
 	if (ACCESSING_BITS_16_31)
 	{
-		return input_port_read(device->machine(), "JP4");
+		return device->machine().root_device().ioport("JP4")->read();
 	}
 
 //  logerror("Unk EEPROM read mask %x\n", mem_mask);
@@ -197,7 +197,7 @@
 
 CUSTOM_INPUT_MEMBER(psikyo4_state::system_port_r)
 {
-	return input_port_read(machine(), "SYSTEM");
+	return ioport("SYSTEM")->read();
 }
 
 CUSTOM_INPUT_MEMBER(psikyo4_state::mahjong_ctrl_r)/* used by hotgmck/hgkairak */
@@ -206,10 +206,10 @@
 	int sel = (m_io_select[0] & 0x0000ff00) >> 8;
 	int ret = 0xff;
 
-	if (sel & 1) ret &= input_port_read(machine(), player ? "KEY4" : "KEY0" );
-	if (sel & 2) ret &= input_port_read(machine(), player ? "KEY5" : "KEY1" );
-	if (sel & 4) ret &= input_port_read(machine(), player ? "KEY6" : "KEY2" );
-	if (sel & 8) ret &= input_port_read(machine(), player ? "KEY7" : "KEY3" );
+	if (sel & 1) ret &= ioport(player ? "KEY4" : "KEY0" )->read();
+	if (sel & 2) ret &= ioport(player ? "KEY5" : "KEY1" )->read();
+	if (sel & 4) ret &= ioport(player ? "KEY6" : "KEY2" )->read();
+	if (sel & 8) ret &= ioport(player ? "KEY7" : "KEY3" )->read();
 
 	return ret;
 }
@@ -328,7 +328,7 @@
 static void set_hotgmck_pcm_bank( running_machine &machine, int n )
 {
 	psikyo4_state *state = machine.driver_data<psikyo4_state>();
-	UINT8 *ymf_pcmbank = machine.root_device().memregion("ymf")->base() + 0x200000;
+	UINT8 *ymf_pcmbank = state->memregion("ymf")->base() + 0x200000;
 	UINT8 *pcm_rom = state->memregion("ymfsource")->base();
 
 	memcpy(ymf_pcmbank + n * 0x100000, pcm_rom + PCM_BANK_NO_LEGACY(n) * 0x100000, 0x100000);
@@ -955,7 +955,7 @@
 static void install_hotgmck_pcm_bank(running_machine &machine)
 {
 	psikyo4_state *state = machine.driver_data<psikyo4_state>();
-	UINT8 *ymf_pcm = machine.root_device().memregion("ymf")->base();
+	UINT8 *ymf_pcm = state->memregion("ymf")->base();
 	UINT8 *pcm_rom = state->memregion("ymfsource")->base();
 
 	memcpy(ymf_pcm, pcm_rom, 0x200000);
diff -Nru src-old/mame/drivers/psikyosh.c src/mame/drivers/psikyosh.c
--- src-old/mame/drivers/psikyosh.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/psikyosh.c	2012-05-03 11:00:08.000000000 +0200
@@ -338,7 +338,7 @@
 {
 	if (ACCESSING_BITS_24_31)
 	{
-		return input_port_read(device->machine(), "JP4");
+		return device->machine().root_device().ioport("JP4")->read();
 	}
 
 	logerror("Unk EEPROM read mask %x\n", mem_mask);
@@ -437,8 +437,8 @@
     GND  55|56  GND
 */
 
-	UINT32 controls = input_port_read(machine(), "CONTROLLER");
-	UINT32 value = input_port_read(machine(), "INPUTS");
+	UINT32 controls = ioport("CONTROLLER")->read();
+	UINT32 value = ioport("INPUTS")->read();
 
 	if(controls) {
 		// Clearly has ghosting, game will only recognise one key depressed at once, and keyboard can only represent keys with distinct rows and columns
@@ -483,7 +483,7 @@
 			KEY11 | KEY6, // Ron
 			KEY1 | KEY3   // Start
 		}; // generic Mahjong keyboard encoder, corresponds to ordering in input port
-		UINT32 keys = input_port_read(machine(), "MAHJONG");
+		UINT32 keys = ioport("MAHJONG")->read();
 		UINT32 which_key = 0x1;
 		int count = 0;
 
diff -Nru src-old/mame/drivers/puckpkmn.c src/mame/drivers/puckpkmn.c
--- src-old/mame/drivers/puckpkmn.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/puckpkmn.c	2012-05-07 08:57:50.000000000 +0200
@@ -126,8 +126,93 @@
 INPUT_PORTS_END
 
 
+
+
+static INPUT_PORTS_START( jzth )
+	PORT_START("P2")	/* $700011.b */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
+
+	PORT_START("P1")	/* $700013.b */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(10)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)
+
+	PORT_START("UNK")	/* $700015.b */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+
+	PORT_START("DSW1")	/* $700017.b */
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coinage ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 5C_1C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 4C_1C ) )
+	PORT_DIPSETTING(    0x05, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(    0x06, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x07, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )
+	PORT_DIPNAME( 0x38, 0x28, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x38, "1" )
+	PORT_DIPSETTING(    0x30, "2" )
+	PORT_DIPSETTING(    0x28, "3" )
+	PORT_DIPSETTING(    0x20, "4" )
+	PORT_DIPSETTING(    0x18, "5" )
+	PORT_DIPSETTING(    0x10, "6" )
+	PORT_DIPSETTING(    0x08, "7" )
+	PORT_DIPSETTING(    0x00, "8" )
+	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0xc0, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
+
+	PORT_START("DSW2")	/* $700019.b */
+	PORT_SERVICE( 0x01, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
+
+
 static ADDRESS_MAP_START( puckpkmn_map, AS_PROGRAM, 16, md_boot_state )
-	AM_RANGE(0x000000, 0x1fffff) AM_ROM								/* Main 68k Program Roms */
+	AM_RANGE(0x000000, 0x3fffff) AM_ROM								/* Main 68k Program Roms */
 	AM_RANGE(0x700010, 0x700011) AM_READ_PORT("P2")
 	AM_RANGE(0x700012, 0x700013) AM_READ_PORT("P1")
 	AM_RANGE(0x700014, 0x700015) AM_READ_PORT("UNK")
@@ -136,6 +221,8 @@
 	AM_RANGE(0x700022, 0x700023) AM_DEVREADWRITE8("oki", okim6295_device, read, write, 0x00ff)
 	AM_RANGE(0xa04000, 0xa04003) AM_DEVREADWRITE8_LEGACY("ymsnd", megadriv_68k_YM2612_read, megadriv_68k_YM2612_write, 0xffff)
 	AM_RANGE(0xc00000, 0xc0001f) AM_READWRITE_LEGACY(megadriv_vdp_r, megadriv_vdp_w)
+	AM_RANGE(0x000000, 0x00001f) AM_WRITE_LEGACY(megadriv_vdp_w)
+
 	AM_RANGE(0xe00000, 0xe0ffff) AM_RAM AM_MIRROR(0x1f0000) AM_BASE_LEGACY(&megadrive_ram)
 
 	/* Unknown reads/writes: */
@@ -148,6 +235,32 @@
 	AM_RANGE(0xa11200, 0xa11201) AM_WRITENOP							/* ? */
 ADDRESS_MAP_END
 
+
+static ADDRESS_MAP_START( jzth_map, AS_PROGRAM, 16, md_boot_state )
+	AM_RANGE(0x000000, 0x3fffff) AM_ROM
+	AM_RANGE(0x700010, 0x700011) AM_READ_PORT("P2")
+	AM_RANGE(0x700012, 0x700013) AM_READ_PORT("P1")
+	AM_RANGE(0x700014, 0x700015) AM_READ_PORT("UNK")
+	AM_RANGE(0x700016, 0x700017) AM_READ_PORT("DSW1")
+	AM_RANGE(0x700018, 0x700019) AM_READ_PORT("DSW2")
+	AM_RANGE(0x700022, 0x700023) AM_DEVREADWRITE8("oki", okim6295_device, read, write, 0x00ff)
+	AM_RANGE(0xa04000, 0xa04003) AM_DEVREADWRITE8_LEGACY("ymsnd", megadriv_68k_YM2612_read, megadriv_68k_YM2612_write, 0xffff)
+	AM_RANGE(0xc00000, 0xc0001f) AM_READWRITE_LEGACY(megadriv_vdp_r, megadriv_vdp_w)
+
+
+	AM_RANGE(0xe00000, 0xe0ffff) AM_RAM AM_MIRROR(0x1f0000) AM_BASE_LEGACY(&megadrive_ram)
+
+	AM_RANGE(0xa00000, 0xa00551) AM_NOP
+
+	AM_RANGE(0xA11100, 0xA11101) AM_NOP
+
+	AM_RANGE(0x710000, 0x710001) AM_READWRITE(bl_710000_r,bl_710000_w) // protection, will erase the VDP address causing writes to 0 unless this returns 0xe
+
+
+
+
+ADDRESS_MAP_END
+
 static READ16_HANDLER(puckpkmna_70001c_r)
 {
 	return 0x0e;
@@ -172,7 +285,7 @@
 
 	MCFG_DEVICE_REMOVE("genesis_snd_z80")
 
-	MCFG_OKIM6295_ADD("oki", 1056000, OKIM6295_PIN7_HIGH) // clock frequency & pin 7 not verified
+	MCFG_OKIM6295_ADD("oki", XTAL_4MHz / 4, OKIM6295_PIN7_HIGH)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.25)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker",0.25)
 MACHINE_CONFIG_END
@@ -184,6 +297,13 @@
 
 MACHINE_CONFIG_END
 
+static MACHINE_CONFIG_DERIVED( jzth, puckpkmn )
+
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(jzth_map)
+
+MACHINE_CONFIG_END
+
 /* Genie's Hardware (contains no real sega parts) */
 
 /***************************************************************************
@@ -271,7 +391,7 @@
 }
 
 ROM_START( puckpkmn ) /* Puckman Pockimon  (c)2000 Genie */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x400000, "maincpu", 0 )
 	ROM_LOAD16_BYTE( "puckpoke.u5", 0x000000, 0x080000, CRC(fd334b91) SHA1(cf8bf6645a4082ea4392937e169b1686c9c7e246) )
 	ROM_LOAD16_BYTE( "puckpoke.u4", 0x000001, 0x080000, CRC(839cc76b) SHA1(e15662a7175db7a8e222dda176a8ed92e0d56e9d) )
 	ROM_LOAD16_BYTE( "puckpoke.u8", 0x100000, 0x080000, CRC(7936bec8) SHA1(4b350105abe514fbfeabae1c6f3aeee695c3d07a) )
@@ -323,7 +443,7 @@
 */
 
 ROM_START( puckpkmna ) /* Puckman Pockimon  (c)2000 IBS Co. Ltd */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x400000, "maincpu", 0 )
 	ROM_LOAD16_BYTE( "b2.u59", 0x000000, 0x080000, CRC(3fbea2c7) SHA1(89f3770ae92c62714f0795ddd2f311a9532eb25a) ) // FIRST AND SECOND HALF IDENTICAL
 	ROM_IGNORE(0x080000)
 	ROM_LOAD16_BYTE( "b1.u59", 0x000001, 0x080000, CRC(dc7b4254) SHA1(8ba5c5e8123e62e9af091971d0d0401d2df49350) ) // FIRST AND SECOND HALF IDENTICAL
@@ -337,6 +457,27 @@
 	ROM_LOAD( "a.u3", 0x00000, 0x80000, CRC(77891c9b) SHA1(66f28b418a480a89ddb3fae3a7c2fe702c62364c) )
 ROM_END
 
+
+
+
+
+ROM_START( jzth )
+	ROM_REGION( 0x400000, "maincpu", 0 )
+	ROM_LOAD16_BYTE( "s.y.u5", 0x000000, 0x080000, CRC(a4a526b5) SHA1(85d0299caf91ff50b6870f845b9aacbd358ed81f) )
+	ROM_LOAD16_BYTE( "s.y.u4", 0x000001, 0x080000, CRC(c16654eb) SHA1(dca4b772a3b9caa7be3fa01511c401b591c2e6f3) )
+	ROM_LOAD16_BYTE( "s.y.u8", 0x100000, 0x080000, CRC(b62e1068) SHA1(2484ae49a4a2a2c551b3b84bbc0b4e40e5d281e7) )
+	ROM_LOAD16_BYTE( "s.y.u7", 0x100001, 0x080000, CRC(27fe424c) SHA1(14bee8c16aac3d5b04123c994167531f817634fd) )
+	ROM_LOAD16_BYTE( "s.y.u64", 0x200000, 0x080000, CRC(62f52886) SHA1(07fc9765274c03eff4a09f48a0b1b2b2afc6078e) )
+	ROM_LOAD16_BYTE( "s.y.u63", 0x200001, 0x080000, CRC(a6a32c8c) SHA1(d0c779751e4af459e9bf63e55c5e2b19a243b70d) )
+	ROM_LOAD16_BYTE( "s.y.u66", 0x300000, 0x080000, CRC(fa4a09f5) SHA1(67d77c91a994ecb8b29e7661c3a12e84a64eb837))
+	ROM_LOAD16_BYTE( "s.y.u65", 0x300001, 0x080000, CRC(de64e526) SHA1(e3b3e5c95b8ae36c0c57f8c9a6f55084464c4c05) )
+
+	ROM_REGION( 0x80000, "oki", 0 ) // there are 2 banks in here, so find bank switch
+	ROM_LOAD( "s.y.u3", 0x00000, 0x40000, CRC(38eef2f2) SHA1(2f750dbf71fea0622e8493f0a8be7c43555ed5cf) )
+	ROM_CONTINUE(0x40000,0x40000)
+ROM_END
+
 /* Genie Hardware (uses Genesis VDP) also has 'Sun Mixing Co' put into tile ram */
 GAME( 2000, puckpkmn, 0,        puckpkmn,  puckpkmn, puckpkmn, ROT0, "Genie",                  "Puckman Pockimon (set 1)", 0 )
 GAME( 2000, puckpkmna,puckpkmn, puckpkmna, puckpkmn, puckpkmn, ROT0, "IBS",                    "Puckman Pockimon (set 2)", 0 )
+GAME( 2000, jzth,     0,        jzth,      jzth,     puckpkmn, ROT0, "<unknown>",              "Jue Zhan Tian Huang", GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/pushman.c src/mame/drivers/pushman.c
--- src-old/mame/drivers/pushman.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/pushman.c	2012-05-03 11:00:08.000000000 +0200
@@ -215,7 +215,7 @@
 	PORT_BIT( 0x00ff, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_VBLANK ) /* not sure, probably wrong */
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") /* not sure, probably wrong */
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_SERVICE1 )
@@ -282,7 +282,7 @@
 	PORT_BIT( 0x00ff, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_VBLANK ) /* not sure, probably wrong */
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") /* not sure, probably wrong */
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_SERVICE1 )
diff -Nru src-old/mame/drivers/pzletime.c src/mame/drivers/pzletime.c
--- src-old/mame/drivers/pzletime.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/pzletime.c	2012-05-03 11:00:08.000000000 +0200
@@ -235,7 +235,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_SERVICE_NO_TOGGLE( 0x0004, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit) /* eeprom */
diff -Nru src-old/mame/drivers/qdrmfgp.c src/mame/drivers/qdrmfgp.c
--- src-old/mame/drivers/qdrmfgp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/qdrmfgp.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 {
 	const char *tag1 = (const char *)param;
 	const char *tag2 = tag1 + strlen(tag1) + 1;
-	return input_port_read(machine(), (m_control & 0x0080) ? tag1 : tag2);
+	return ioport((m_control & 0x0080) ? tag1 : tag2)->read();
 }
 
 CUSTOM_INPUT_MEMBER(qdrmfgp_state::battery_sensor_r)
diff -Nru src-old/mame/drivers/quantum.c src/mame/drivers/quantum.c
--- src-old/mame/drivers/quantum.c	2012-04-10 19:02:54.000000000 +0200
+++ src/mame/drivers/quantum.c	2012-05-03 11:00:08.000000000 +0200
@@ -74,19 +74,19 @@
 
 READ16_MEMBER(quantum_state::trackball_r)
 {
-	return (input_port_read(machine(), "TRACKY") << 4) | input_port_read(machine(), "TRACKX");
+	return (ioport("TRACKY")->read() << 4) | ioport("TRACKX")->read();
 }
 
 
 static READ8_DEVICE_HANDLER( input_1_r )
 {
-	return (input_port_read(device->machine(), "DSW0") << (7 - (offset - POT0_C))) & 0x80;
+	return (device->machine().root_device().ioport("DSW0")->read() << (7 - (offset - POT0_C))) & 0x80;
 }
 
 
 static READ8_DEVICE_HANDLER( input_2_r )
 {
-	return (input_port_read(device->machine(), "DSW1") << (7 - (offset - POT0_C))) & 0x80;
+	return (device->machine().root_device().ioport("DSW1")->read() << (7 - (offset - POT0_C))) & 0x80;
 }
 
 
diff -Nru src-old/mame/drivers/quasar.c src/mame/drivers/quasar.c
--- src-old/mame/drivers/quasar.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/quasar.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,10 +72,10 @@
 
 	switch (m_io_page)
 	{
-	case 0:  ans = input_port_read(machine(), "IN0"); break;
-	case 1:  ans = input_port_read(machine(), "IN1"); break;
-	case 2:  ans = input_port_read(machine(), "DSW0"); break;
-	case 3:  ans = input_port_read(machine(), "DSW1"); break;
+	case 0:  ans = ioport("IN0")->read(); break;
+	case 1:  ans = ioport("IN1")->read(); break;
+	case 2:  ans = ioport("DSW0")->read(); break;
+	case 3:  ans = ioport("DSW1")->read(); break;
 	}
 
 	return ans;
@@ -99,7 +99,7 @@
 
 READ8_MEMBER(quasar_state::quasar_sh_command_r)
 {
-	return soundlatch_byte_r(space, 0) + (input_port_read(machine(), "DSW2") & 0x30);
+	return soundlatch_byte_r(space, 0) + (ioport("DSW2")->read() & 0x30);
 }
 
 READ8_MEMBER(quasar_state::audio_t1_r)
@@ -220,7 +220,7 @@
 	PORT_DIPSETTING(    0x00, "Wrap Around" )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 #if 0
diff -Nru src-old/mame/drivers/quizpani.c src/mame/drivers/quizpani.c
--- src-old/mame/drivers/quizpani.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/quizpani.c	2012-05-03 11:00:08.000000000 +0200
@@ -88,39 +88,39 @@
 
 	PORT_START("P1_P2")
 	/* "Standard" buttons layout */
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0002)
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0002)
 	/* "Alternate" buttons layout */
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,PORTCOND_EQUALS,0x0000)
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P1 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_UNKNOWN ) /* dup. B1 P2 */   PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)     PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNKNOWN )                    PORT_CONDITION("DSW1",0x0002,EQUALS,0x0000)
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x0001, 0x0001, DEF_STR( Flip_Screen ) )  /* guess, but check code at 0x004d9c and write to 0x100014 */
diff -Nru src-old/mame/drivers/raiden.c src/mame/drivers/raiden.c
--- src-old/mame/drivers/raiden.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/raiden.c	2012-05-03 11:00:08.000000000 +0200
@@ -138,7 +138,7 @@
 	PORT_DIPSETTING(      0x0001, "A" )
 	PORT_DIPSETTING(      0x0000, "B" )
 	/* Coin Mode A */
-	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0001, PORTCOND_EQUALS, 0x0001) PORT_DIPLOCATION("SW1:2,3,4,5")
+	PORT_DIPNAME( 0x001e, 0x001e, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0001, EQUALS, 0x0001) PORT_DIPLOCATION("SW1:2,3,4,5")
 	PORT_DIPSETTING(      0x0014, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(      0x0016, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(      0x0018, DEF_STR( 4C_1C ) )
@@ -156,12 +156,12 @@
 	PORT_DIPSETTING(      0x000a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 	/* Coin Mode B */
-	PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0001, PORTCOND_NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:2,3")
+	PORT_DIPNAME( 0x0006, 0x0006, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0001, NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:2,3")
     PORT_DIPSETTING(      0x0000, "5C/1C or Free if Coin B too" )
     PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )
     PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
     PORT_DIPSETTING(      0x0006, DEF_STR( 1C_1C ) )
-    PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0001, PORTCOND_NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:4,5")
+    PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0001, NOTEQUALS, 0x0001) PORT_DIPLOCATION("SW1:4,5")
     PORT_DIPSETTING(      0x0018, DEF_STR( 1C_2C ) )
     PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )
     PORT_DIPSETTING(      0x0008, DEF_STR( 1C_5C ) )
diff -Nru src-old/mame/drivers/raiden2.c src/mame/drivers/raiden2.c
--- src-old/mame/drivers/raiden2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/raiden2.c	2012-04-26 21:54:06.000000000 +0200
@@ -478,7 +478,8 @@
 	switch(data) {
 	case 0x0205:   // 0205 0006 ffeb 0000 - 0188 0282 0082 0b8e 098e 0000 0000 0000
 		space.write_dword(cop_regs[0] + 4 + offset*4, space.read_dword(cop_regs[0] + 4 + offset*4) + space.read_dword(cop_regs[0] + 16 + offset*4));
-		space.write_word(cop_regs[0] + 0x1c + offset*4, space.read_word(cop_regs[0] + 0x1c + offset*4) + space.read_word(cop_regs[0] + 16 + offset*4));
+		/* TODO: check the following, makes Zero Team to crash as soon as this command is triggered. */
+		//space.write_word(cop_regs[0] + 0x1c + offset*4, space.read_word(cop_regs[0] + 0x1c + offset*4) + space.read_word(cop_regs[0] + 16 + offset*4));
 		break;
 
 	case 0x0904: { /* X Se Dae and Zero Team uses this variant */
diff -Nru src-old/mame/drivers/rainbow.c src/mame/drivers/rainbow.c
--- src-old/mame/drivers/rainbow.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rainbow.c	2012-05-03 11:00:08.000000000 +0200
@@ -435,23 +435,23 @@
 	PORT_START("DSWA")
 	TAITO_MACHINE_COCKTAIL
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) ) PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
 
 	PORT_START("DSWB")
 	TAITO_DIFFICULTY
diff -Nru src-old/mame/drivers/rallyx.c src/mame/drivers/rallyx.c
--- src-old/mame/drivers/rallyx.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/rallyx.c	2012-05-03 11:00:08.000000000 +0200
@@ -397,37 +397,37 @@
 	PORT_DIPSETTING(	0x20, "3 Cars, Medium" )
 	PORT_DIPSETTING(	0x38, "3 Cars, Hard" )
 	PORT_DIPNAME( 0x06, 0x02, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x00)
-
-	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x08)
-
-	PORT_DIPSETTING(	0x02, "10000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x10)
-	PORT_DIPSETTING(	0x04, "20000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x10)
-	PORT_DIPSETTING(	0x06, "30000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x10)
-
-	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x18)
-	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x18)
-	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x18)
-
-	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x20)
-
-	PORT_DIPSETTING(	0x02, "10000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x28)
-	PORT_DIPSETTING(	0x04, "20000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x28)
-	PORT_DIPSETTING(	0x06, "30000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x28)
-
-	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x30)
-	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x30)
-	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x30)
-
-	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x38)
-	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x38)
-	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, PORTCOND_EQUALS, 0x38)
+	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x00)
+	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x00)
+
+	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x08)
+	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x08)
+	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x08)
+
+	PORT_DIPSETTING(	0x02, "10000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x10)
+	PORT_DIPSETTING(	0x04, "20000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x10)
+	PORT_DIPSETTING(	0x06, "30000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x10)
+
+	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x18)
+	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x18)
+	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x18)
+
+	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x20)
+	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x20)
+	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x20)
+
+	PORT_DIPSETTING(	0x02, "10000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x28)
+	PORT_DIPSETTING(	0x04, "20000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x28)
+	PORT_DIPSETTING(	0x06, "30000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x28)
+
+	PORT_DIPSETTING(	0x02, "15000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x30)
+	PORT_DIPSETTING(	0x04, "30000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x30)
+	PORT_DIPSETTING(	0x06, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x30)
+
+	PORT_DIPSETTING(	0x02, "20000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x38)
+	PORT_DIPSETTING(	0x04, "40000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x38)
+	PORT_DIPSETTING(	0x06, "60000" )		PORT_CONDITION("DSW", 0x38, EQUALS, 0x38)
 	PORT_DIPSETTING(	0x00, DEF_STR( None ) )
 	PORT_SERVICE( 0x01, IP_ACTIVE_LOW )
 INPUT_PORTS_END
diff -Nru src-old/mame/drivers/rampart.c src/mame/drivers/rampart.c
--- src-old/mame/drivers/rampart.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rampart.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,7 +177,7 @@
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(3)
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN1")
@@ -221,7 +221,7 @@
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(3)
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN1")
@@ -271,7 +271,7 @@
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN1")
diff -Nru src-old/mame/drivers/re900.c src/mame/drivers/re900.c
--- src-old/mame/drivers/re900.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/re900.c	2012-05-03 11:00:08.000000000 +0200
@@ -108,7 +108,7 @@
 
 static READ8_DEVICE_HANDLER (re_psg_portA_r)
 {
-	if ((input_port_read(device->machine(), "IN0") & 0x01) == 0)
+	if ((device->machine().root_device().ioport("IN0")->read() & 0x01) == 0)
 	{
 		output_set_lamp_value(0,1);		// Operator Key ON
 	}
@@ -118,7 +118,7 @@
 		output_set_lamp_value(0,0);		// Operator Key OFF
 	}
 
-	return input_port_read(device->machine(), "IN0");
+	return device->machine().root_device().ioport("IN0")->read();
 }
 
 static READ8_DEVICE_HANDLER (re_psg_portB_r)
@@ -130,7 +130,7 @@
 
 	output_set_lamp_value(state->m_player,1);
 
-	if (input_port_read(device->machine(), "IN_S"))
+	if (state->ioport("IN_S")->read())
 	{
 		if (!state->m_stat_a)
 		{
@@ -161,12 +161,12 @@
 	/* "INA": Unified port to share the player Keys among all players - Key In & Key Out have their own buttons on keyboard. */
 	switch( state->m_mux_data )
 	{
-		case 0x01: retval = (input_port_read(device->machine(), "IN6") | 0x80 ) - (( state->m_player == 6 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 6 */
-		case 0x02: retval = (input_port_read(device->machine(), "IN5") | 0x80 ) - (( state->m_player == 5 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 5 */
-		case 0x04: retval = (input_port_read(device->machine(), "IN4") | 0x80 ) - (( state->m_player == 4 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 4 */
-		case 0x08: retval = (input_port_read(device->machine(), "IN3") | 0x80 ) - (( state->m_player == 3 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 3 */
-		case 0x10: retval = (input_port_read(device->machine(), "IN2") | 0x80 ) - (( state->m_player == 2 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 2 */
-		case 0x20: retval = (input_port_read(device->machine(), "IN1") | 0x80 ) - (( state->m_player == 1 ) ? (input_port_read(device->machine(), "INA") | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 1 */
+		case 0x01: retval = (state->ioport("IN6")->read() | 0x80 ) - (( state->m_player == 6 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 6 */
+		case 0x02: retval = (state->ioport("IN5")->read() | 0x80 ) - (( state->m_player == 5 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 5 */
+		case 0x04: retval = (state->ioport("IN4")->read() | 0x80 ) - (( state->m_player == 4 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 4 */
+		case 0x08: retval = (state->ioport("IN3")->read() | 0x80 ) - (( state->m_player == 3 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 3 */
+		case 0x10: retval = (state->ioport("IN2")->read() | 0x80 ) - (( state->m_player == 2 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 2 */
+		case 0x20: retval = (state->ioport("IN1")->read() | 0x80 ) - (( state->m_player == 1 ) ? (state->ioport("INA")->read() | 0x80 ) ^ 0xff: 0x00 ); break; /* Player 1 */
 	}
 
 	return retval;
diff -Nru src-old/mame/drivers/realbrk.c src/mame/drivers/realbrk.c
--- src-old/mame/drivers/realbrk.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/realbrk.c	2012-05-03 11:00:08.000000000 +0200
@@ -53,15 +53,15 @@
 READ16_MEMBER(realbrk_state::realbrk_dsw_r)
 {
 	UINT16 sel = ~m_dsw_select[0];
-	if (sel & 0x01)	return	(input_port_read(machine(), "SW1") & 0x00ff) << 8;		// DSW1 low bits
-	if (sel & 0x02)	return	(input_port_read(machine(), "SW2") & 0x00ff) << 8;		// DSW2 low bits
-	if (sel & 0x04)	return	(input_port_read(machine(), "SW3") & 0x00ff) << 8;		// DSW3 low bits
-	if (sel & 0x08)	return	(input_port_read(machine(), "SW4") & 0x00ff) << 8;		// DSW4 low bits
-
-	if (sel & 0x10)	return	((input_port_read(machine(), "SW1") & 0x0300) << 0) |	// DSWs high 2 bits
-							((input_port_read(machine(), "SW2") & 0x0300) << 2) |
-							((input_port_read(machine(), "SW3") & 0x0300) << 4) |
-							((input_port_read(machine(), "SW4") & 0x0300) << 6) ;
+	if (sel & 0x01)	return	(ioport("SW1")->read() & 0x00ff) << 8;		// DSW1 low bits
+	if (sel & 0x02)	return	(ioport("SW2")->read() & 0x00ff) << 8;		// DSW2 low bits
+	if (sel & 0x04)	return	(ioport("SW3")->read() & 0x00ff) << 8;		// DSW3 low bits
+	if (sel & 0x08)	return	(ioport("SW4")->read() & 0x00ff) << 8;		// DSW4 low bits
+
+	if (sel & 0x10)	return	((ioport("SW1")->read() & 0x0300) << 0) |	// DSWs high 2 bits
+							((ioport("SW2")->read() & 0x0300) << 2) |
+							((ioport("SW3")->read() & 0x0300) << 4) |
+							((ioport("SW4")->read() & 0x0300) << 6) ;
 
 	logerror("CPU #0 PC %06X: read with unknown dsw_select = %02x\n",cpu_get_pc(&space.device()),m_dsw_select[0]);
 	return 0xffff;
@@ -73,14 +73,14 @@
 	{
 		case 0x00/2: return 0xffff;
 		case 0x02/2: return 0xffff;
-		case 0x04/2: return input_port_read(machine(), "IN0");		/*Service buttons*/
-		case 0x06/2: return input_port_read(machine(), "SW1");		/*DIP 2*/
-		case 0x08/2: return input_port_read(machine(), "SW2");		/*DIP 1*/
-		case 0x0a/2: return input_port_read(machine(), "SW3");		/*DIP 1+2 Hi-Bits*/
-		case 0x0c/2: return input_port_read(machine(), "PADDLE1");	/*Handle 1p*/
-		case 0x0e/2: return input_port_read(machine(), "P1");			/*Buttons 1p*/
-		case 0x10/2: return input_port_read(machine(), "PADDLE2");	/*Handle 2p*/
-		case 0x12/2: return input_port_read(machine(), "P2");			/*Buttons 2p*/
+		case 0x04/2: return ioport("IN0")->read();		/*Service buttons*/
+		case 0x06/2: return ioport("SW1")->read();		/*DIP 2*/
+		case 0x08/2: return ioport("SW2")->read();		/*DIP 1*/
+		case 0x0a/2: return ioport("SW3")->read();		/*DIP 1+2 Hi-Bits*/
+		case 0x0c/2: return ioport("PADDLE1")->read();	/*Handle 1p*/
+		case 0x0e/2: return ioport("P1")->read();			/*Buttons 1p*/
+		case 0x10/2: return ioport("PADDLE2")->read();	/*Handle 2p*/
+		case 0x12/2: return ioport("P2")->read();			/*Buttons 2p*/
 	}
 	return 0xffff;
 }
@@ -92,22 +92,22 @@
 	switch(offset)
 	{
 		case 0x00/2: return 0xffff;
-		case 0x02/2: return input_port_read(machine(), "IN0");	/*Service buttons*/
+		case 0x02/2: return ioport("IN0")->read();	/*Service buttons*/
 		/*DSW,same handling as realbrk*/
 		case 0x04/2:
-			if (sel & 0x01)	return	(input_port_read(machine(), "SW1") & 0x00ff) << 8;		// DSW1 low bits
-			if (sel & 0x02)	return	(input_port_read(machine(), "SW2") & 0x00ff) << 8;		// DSW2 low bits
-			if (sel & 0x04)	return	(input_port_read(machine(), "SW3") & 0x00ff) << 8;		// DSW3 low bits
-			if (sel & 0x08)	return	(input_port_read(machine(), "SW4") & 0x00ff) << 8;		// DSW4 low bits
-
-			if (sel & 0x10)	return	((input_port_read(machine(), "SW1") & 0x0300) << 0) |	// DSWs high 2 bits
-									((input_port_read(machine(), "SW2") & 0x0300) << 2) |
-									((input_port_read(machine(), "SW3") & 0x0300) << 4) |
-									((input_port_read(machine(), "SW4") & 0x0300) << 6) ;
+			if (sel & 0x01)	return	(ioport("SW1")->read() & 0x00ff) << 8;		// DSW1 low bits
+			if (sel & 0x02)	return	(ioport("SW2")->read() & 0x00ff) << 8;		// DSW2 low bits
+			if (sel & 0x04)	return	(ioport("SW3")->read() & 0x00ff) << 8;		// DSW3 low bits
+			if (sel & 0x08)	return	(ioport("SW4")->read() & 0x00ff) << 8;		// DSW4 low bits
+
+			if (sel & 0x10)	return	((ioport("SW1")->read() & 0x0300) << 0) |	// DSWs high 2 bits
+									((ioport("SW2")->read() & 0x0300) << 2) |
+									((ioport("SW3")->read() & 0x0300) << 4) |
+									((ioport("SW4")->read() & 0x0300) << 6) ;
 
 			return 0xffff;
-		case 0x06/2: return input_port_read(machine(), "P2");/*Buttons+Handle 2p*/
-		case 0x08/2: return input_port_read(machine(), "P1");/*Buttons+Handle 1p*/
+		case 0x06/2: return ioport("P2")->read();/*Buttons+Handle 2p*/
+		case 0x08/2: return ioport("P1")->read();/*Buttons+Handle 1p*/
 		case 0x0a/2: return 0xffff;
 		case 0x0c/2: return 0xffff;
 		case 0x0e/2: return 0xffff;
diff -Nru src-old/mame/drivers/redalert.c src/mame/drivers/redalert.c
--- src-old/mame/drivers/redalert.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/redalert.c	2012-05-03 11:00:08.000000000 +0200
@@ -109,7 +109,7 @@
 
 static INTERRUPT_GEN( redalert_vblank_interrupt )
 {
-	if( input_port_read(device->machine(), "COIN") )
+	if( device->machine().root_device().ioport("COIN")->read() )
 		/* the service coin as conntected to the CPU's RDY pin as well */
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 
@@ -136,12 +136,12 @@
 {
 	cputag_set_input_line(machine(), "maincpu", M6502_IRQ_LINE, CLEAR_LINE);
 
-	return input_port_read(machine(), "STICK0");
+	return ioport("STICK0")->read();
 }
 
 READ8_MEMBER(redalert_state::panther_unk_r)
 {
-	return ((machine().rand() & 0x01) | (input_port_read(machine(), "C020") & 0xfe));
+	return ((machine().rand() & 0x01) | (ioport("C020")->read() & 0xfe));
 }
 
 /*************************************
diff -Nru src-old/mame/drivers/redclash.c src/mame/drivers/redclash.c
--- src-old/mame/drivers/redclash.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/redclash.c	2012-05-03 11:00:08.000000000 +0200
@@ -109,7 +109,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, "Difficulty?" )
@@ -202,7 +202,7 @@
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
 	/* high. There are probably other differencies in the hardware, but emulating */
 	/* them this way is enough to get the game running. */
-	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
+	PORT_BIT( 0xc0, 0x40, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPUNUSED_DIPLOC( 0x01, 0x01, "SW1:8" )	/* Switches 6-8 are not used */
diff -Nru src-old/mame/drivers/relief.c src/mame/drivers/relief.c
--- src-old/mame/drivers/relief.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/relief.c	2012-05-03 11:00:08.000000000 +0200
@@ -95,7 +95,7 @@
 
 READ16_MEMBER(relief_state::special_port2_r)
 {
-	int result = input_port_read(machine(), "260010");
+	int result = ioport("260010")->read();
 	if (m_cpu_to_sound_ready) result ^= 0x0020;
 	if (!(result & 0x0080) || atarigen_get_hblank(*machine().primary_screen)) result ^= 0x0001;
 	return result;
@@ -235,7 +235,7 @@
 	PORT_BIT( 0x001f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )	/* tested before writing to 260040 */
 	PORT_SERVICE( 0x0040, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("260012")	/* 260012 */
diff -Nru src-old/mame/drivers/renegade.c src/mame/drivers/renegade.c
--- src-old/mame/drivers/renegade.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/renegade.c	2012-05-03 11:00:08.000000000 +0200
@@ -717,7 +717,7 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)	/* attack right */
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)	/* attack right */
 	PORT_BIT( 0x30, IP_ACTIVE_HIGH, IPT_SPECIAL) PORT_CUSTOM_MEMBER(DEVICE_SELF, renegade_state,mcu_status_r, NULL)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SERVICE1 )
 
 	PORT_START("DSW1")	/* DIP1 */
diff -Nru src-old/mame/drivers/rltennis.c src/mame/drivers/rltennis.c
--- src-old/mame/drivers/rltennis.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rltennis.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,7 +72,7 @@
 READ16_MEMBER(rltennis_state::rlt_io_r)
 {
 
-	return (input_port_read(machine(), "P1" )&0x1fff) | (m_unk_counter<<13); /* top 3 bits controls smaple address update */
+	return (ioport("P1" )->read()&0x1fff) | (m_unk_counter<<13); /* top 3 bits controls smaple address update */
 }
 
 WRITE16_MEMBER(rltennis_state::rlt_snd1_w)
@@ -162,8 +162,8 @@
 	state->m_screen = machine.device(  "screen");
 	state->m_dac_1 = machine.device("dac1");
 	state->m_dac_2 = machine.device("dac2");
-	state->m_samples_1 = machine.root_device().memregion("samples1")->base();
-	state->m_samples_2 = machine.root_device().memregion("samples2")->base();
+	state->m_samples_1 = state->memregion("samples1")->base();
+	state->m_samples_2 = state->memregion("samples2")->base();
 	state->m_gfx =  state->memregion("gfx1")->base();
 	state->m_timer = machine.scheduler().timer_alloc(FUNC(sample_player));
 }
diff -Nru src-old/mame/drivers/rmhaihai.c src/mame/drivers/rmhaihai.c
--- src-old/mame/drivers/rmhaihai.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rmhaihai.c	2012-05-03 11:00:08.000000000 +0200
@@ -114,9 +114,9 @@
 
 			for (i = 0; i < 31; i++)
 			{
-				if (input_port_read(machine(), keynames[i/16]) & (1 << (i & 15))) return i+1;
+				if (ioport(keynames[i/16])->read() & (1 << (i & 15))) return i+1;
 			}
-			if (input_port_read(machine(), "KEY1") & 0x8000) return 0x80;	// coin
+			if (ioport("KEY1")->read() & 0x8000) return 0x80;	// coin
 			return 0;
 		}
 		case 0x5c7b:	// rmhaihai, rmhaisei, rmhaijin
diff -Nru src-old/mame/drivers/rohga.c src/mame/drivers/rohga.c
--- src-old/mame/drivers/rohga.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rohga.c	2012-05-03 11:00:08.000000000 +0200
@@ -298,7 +298,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1_2")
 	PORT_DIPNAME( 0x0007, 0x0007, DEF_STR( Coin_A ) )
@@ -396,7 +396,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1_2")
 	PORT_DIPNAME( 0x0007, 0x0007, DEF_STR( Coin_A ) )
@@ -469,7 +469,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1_2")
 	PORT_DIPNAME( 0x0007, 0x0007, DEF_STR( Coin_A ) )
@@ -553,7 +553,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1_2")
 	PORT_DIPNAME( 0x0007, 0x0007, DEF_STR( Coin_A ) )
diff -Nru src-old/mame/drivers/rollrace.c src/mame/drivers/rollrace.c
--- src-old/mame/drivers/rollrace.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/rollrace.c	2012-05-03 11:00:08.000000000 +0200
@@ -127,7 +127,7 @@
 	PORT_DIPSETTING(	0x10, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(	0x18, DEF_STR( 1C_6C ) )
 
-/*  PORT_BIT( 0x40, IP_ACTIVE_HIGH , IPT_VBLANK )  freezes frame, could be vblank ?*/
+/*  PORT_BIT( 0x40, IP_ACTIVE_HIGH , IPT_CUSTOM ) PORT_VBLANK("screen")  freezes frame, could be vblank ?*/
 	PORT_DIPNAME( 0x40, 0x00, "Freeze" )
 	PORT_DIPSETTING(	0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x40, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/route16.c src/mame/drivers/route16.c
--- src-old/mame/drivers/route16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/route16.c	2012-05-03 11:00:08.000000000 +0200
@@ -163,10 +163,10 @@
 
 	switch (m_ttmahjng_port_select)
 	{
-	case 1:  ret = input_port_read(machine(), "KEY0"); break;
-	case 2:  ret = input_port_read(machine(), "KEY1"); break;
-	case 4:  ret = input_port_read(machine(), "KEY2"); break;
-	case 8:  ret = input_port_read(machine(), "KEY3"); break;
+	case 1:  ret = ioport("KEY0")->read(); break;
+	case 2:  ret = ioport("KEY1")->read(); break;
+	case 4:  ret = ioport("KEY2")->read(); break;
+	case 8:  ret = ioport("KEY3")->read(); break;
 	default: break;
 	}
 
diff -Nru src-old/mame/drivers/royalmah.c src/mame/drivers/royalmah.c
--- src-old/mame/drivers/royalmah.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/royalmah.c	2012-05-03 11:00:08.000000000 +0200
@@ -326,13 +326,13 @@
 static READ8_DEVICE_HANDLER( royalmah_player_1_port_r )
 {
 	royalmah_state *state = device->machine().driver_data<royalmah_state>();
-	int ret = (input_port_read(device->machine(), "KEY0") & 0xc0) | 0x3f;
+	int ret = (state->ioport("KEY0")->read() & 0xc0) | 0x3f;
 
-	if ((state->m_input_port_select & 0x01) == 0)  ret &= input_port_read(device->machine(), "KEY0");
-	if ((state->m_input_port_select & 0x02) == 0)  ret &= input_port_read(device->machine(), "KEY1");
-	if ((state->m_input_port_select & 0x04) == 0)  ret &= input_port_read(device->machine(), "KEY2");
-	if ((state->m_input_port_select & 0x08) == 0)  ret &= input_port_read(device->machine(), "KEY3");
-	if ((state->m_input_port_select & 0x10) == 0)  ret &= input_port_read(device->machine(), "KEY4");
+	if ((state->m_input_port_select & 0x01) == 0)  ret &= state->ioport("KEY0")->read();
+	if ((state->m_input_port_select & 0x02) == 0)  ret &= state->ioport("KEY1")->read();
+	if ((state->m_input_port_select & 0x04) == 0)  ret &= state->ioport("KEY2")->read();
+	if ((state->m_input_port_select & 0x08) == 0)  ret &= state->ioport("KEY3")->read();
+	if ((state->m_input_port_select & 0x10) == 0)  ret &= state->ioport("KEY4")->read();
 
 	return ret;
 }
@@ -340,13 +340,13 @@
 static READ8_DEVICE_HANDLER( royalmah_player_2_port_r )
 {
 	royalmah_state *state = device->machine().driver_data<royalmah_state>();
-	int ret = (input_port_read(device->machine(), "KEY5") & 0xc0) | 0x3f;
+	int ret = (state->ioport("KEY5")->read() & 0xc0) | 0x3f;
 
-	if ((state->m_input_port_select & 0x01) == 0)  ret &= input_port_read(device->machine(), "KEY5");
-	if ((state->m_input_port_select & 0x02) == 0)  ret &= input_port_read(device->machine(), "KEY6");
-	if ((state->m_input_port_select & 0x04) == 0)  ret &= input_port_read(device->machine(), "KEY7");
-	if ((state->m_input_port_select & 0x08) == 0)  ret &= input_port_read(device->machine(), "KEY8");
-	if ((state->m_input_port_select & 0x10) == 0)  ret &= input_port_read(device->machine(), "KEY9");
+	if ((state->m_input_port_select & 0x01) == 0)  ret &= state->ioport("KEY5")->read();
+	if ((state->m_input_port_select & 0x02) == 0)  ret &= state->ioport("KEY6")->read();
+	if ((state->m_input_port_select & 0x04) == 0)  ret &= state->ioport("KEY7")->read();
+	if ((state->m_input_port_select & 0x08) == 0)  ret &= state->ioport("KEY8")->read();
+	if ((state->m_input_port_select & 0x10) == 0)  ret &= state->ioport("KEY9")->read();
 
 	return ret;
 }
@@ -357,9 +357,9 @@
 {
 	switch (m_dsw_select)
 	{
-		case 0x00: return input_port_read(machine(), "DSW3");	/* DSW3 */
-		case 0x20: return input_port_read(machine(), "DSW4");	/* DSW4 */
-		case 0x40: return input_port_read(machine(), "DSW2");	/* DSW2 */
+		case 0x00: return ioport("DSW3")->read();	/* DSW3 */
+		case 0x20: return ioport("DSW4")->read();	/* DSW4 */
+		case 0x40: return ioport("DSW2")->read();	/* DSW2 */
 	}
 	return 0;
 }
@@ -376,9 +376,9 @@
 	{
 		switch (m_suzume_bank)
 		{
-			case 0x08: return input_port_read(machine(), "DSW4");	/* DSW4 */
-			case 0x10: return input_port_read(machine(), "DSW3");	/* DSW3 */
-			case 0x18: return input_port_read(machine(), "DSW2");	/* DSW2 */
+			case 0x08: return ioport("DSW4")->read();	/* DSW4 */
+			case 0x10: return ioport("DSW3")->read();	/* DSW3 */
+			case 0x18: return ioport("DSW2")->read();	/* DSW2 */
 		}
 		return 0;
 	}
@@ -417,7 +417,7 @@
 
 READ8_MEMBER(royalmah_state::mjapinky_dsw_r)
 {
-	if (m_rombank == 0x0e)	return input_port_read(machine(), "DSW3");
+	if (m_rombank == 0x0e)	return ioport("DSW3")->read();
 	else					return *(machine().root_device().memregion("maincpu")->base() + 0x10000 + 0x8000 * m_rombank);
 }
 
@@ -459,10 +459,10 @@
 {
 	switch (m_dsw_select)
 	{
-		case 0x00: return input_port_read(machine(), "DSW4");
-		case 0x04: return input_port_read(machine(), "DSW1");
-		case 0x08: return input_port_read(machine(), "DSW2");
-		case 0x0c: return input_port_read(machine(), "DSW3");
+		case 0x00: return ioport("DSW4")->read();
+		case 0x04: return ioport("DSW1")->read();
+		case 0x08: return ioport("DSW2")->read();
+		case 0x0c: return ioport("DSW3")->read();
 	}
 
 	return 0;
@@ -487,10 +487,10 @@
 {
 	switch (m_dsw_select)
 	{
-//      case 0x00: return input_port_read(machine(), "DSW4");
-		case 0x40: return input_port_read(machine(), "DSW2");
-		case 0x80: return input_port_read(machine(), "DSW3");
-		case 0xc0: return input_port_read(machine(), "DSW4");
+//      case 0x00: return ioport("DSW4")->read();
+		case 0x40: return ioport("DSW2")->read();
+		case 0x80: return ioport("DSW3")->read();
+		case 0xc0: return ioport("DSW4")->read();
 	}
 
 	return 0;
@@ -694,9 +694,9 @@
 {
 	switch (m_dsw_select & 7)
 	{
-		case 1: return input_port_read(machine(), "DSW1");
-		case 2: return input_port_read(machine(), "DSW2");
-		case 4: return input_port_read(machine(), "DSW3");
+		case 1: return ioport("DSW1")->read();
+		case 2: return ioport("DSW2")->read();
+		case 4: return ioport("DSW3")->read();
 	}
 
 	return 0xff;
@@ -818,11 +818,11 @@
 
 READ8_MEMBER(royalmah_state::janptr96_dsw_r)
 {
-	if (~m_dsw_select & 0x01) return input_port_read(machine(), "DSW4");
-	if (~m_dsw_select & 0x02) return input_port_read(machine(), "DSW3");
-	if (~m_dsw_select & 0x04) return input_port_read(machine(), "DSW2");
-	if (~m_dsw_select & 0x08) return input_port_read(machine(), "DSW1");
-	if (~m_dsw_select & 0x10) return input_port_read(machine(), "DSWTOP");
+	if (~m_dsw_select & 0x01) return ioport("DSW4")->read();
+	if (~m_dsw_select & 0x02) return ioport("DSW3")->read();
+	if (~m_dsw_select & 0x04) return ioport("DSW2")->read();
+	if (~m_dsw_select & 0x08) return ioport("DSW1")->read();
+	if (~m_dsw_select & 0x10) return ioport("DSWTOP")->read();
 	return 0xff;
 }
 
@@ -886,10 +886,10 @@
 
 	switch(offset)
 	{
-		case 0x8000:	return input_port_read(machine(), "DSW4");		// dsw 4
-		case 0x8200:	return input_port_read(machine(), "DSW3");		// dsw 3
+		case 0x8000:	return ioport("DSW4")->read();		// dsw 4
+		case 0x8200:	return ioport("DSW3")->read();		// dsw 3
 		case 0x9001:	return ay8910_r(machine().device("aysnd"), 0);	// inputs
-		case 0x9011:	return input_port_read(machine(), "SYSTEM");
+		case 0x9011:	return ioport("SYSTEM")->read();
 	}
 
 	logerror("%04X: unmapped input read at %04X\n", cpu_get_pc(&space.device()), offset);
@@ -940,19 +940,19 @@
 
 READ8_MEMBER(royalmah_state::mjifb_p3_r)
 {
-	return input_port_read(machine(), "PORT3_5") >> 6;
+	return ioport("PORT3_5")->read() >> 6;
 }
 READ8_MEMBER(royalmah_state::mjifb_p5_r)
 {
-	return input_port_read(machine(), "PORT3_5");
+	return ioport("PORT3_5")->read();
 }
 READ8_MEMBER(royalmah_state::mjifb_p6_r)
 {
-	return input_port_read(machine(), "PORT6_7");
+	return ioport("PORT6_7")->read();
 }
 READ8_MEMBER(royalmah_state::mjifb_p7_r)
 {
-	return input_port_read(machine(), "PORT6_7") >> 4;
+	return ioport("PORT6_7")->read() >> 4;
 }
 READ8_MEMBER(royalmah_state::mjifb_p8_r)
 {
@@ -995,10 +995,10 @@
 
 	switch(offset)
 	{
-		case 0x8000:	return input_port_read(machine(), "DSW2");		// dsw 2
-		case 0x8001:	return input_port_read(machine(), "DSW1");		// dsw 1
+		case 0x8000:	return ioport("DSW2")->read();		// dsw 2
+		case 0x8001:	return ioport("DSW1")->read();		// dsw 1
 		case 0x9001:	return ay8910_r(machine().device("aysnd"), 0);	// inputs
-		case 0x9011:	return input_port_read(machine(), "SYSTEM");
+		case 0x9011:	return ioport("SYSTEM")->read();
 	}
 
 	logerror("%04X: unmapped input read at %04X\n", cpu_get_pc(&space.device()), offset);
@@ -1113,11 +1113,11 @@
 {
 	switch( m_dsw_select )
 	{
-		case 0x00: return input_port_read(machine(), "DSW1");
-		case 0x01: return input_port_read(machine(), "DSW2");
-		case 0x02: return input_port_read(machine(), "DSW3");
-		case 0x03: return input_port_read(machine(), "DSW4");
-		case 0x04: return input_port_read(machine(), "DSWTOP");
+		case 0x00: return ioport("DSW1")->read();
+		case 0x01: return ioport("DSW2")->read();
+		case 0x02: return ioport("DSW3")->read();
+		case 0x03: return ioport("DSW4")->read();
+		case 0x04: return ioport("DSWTOP")->read();
 	}
 	logerror("%04X: unmapped dsw read %02X\n", cpu_get_pc(&space.device()), m_dsw_select);
 	return 0xff;
@@ -1891,14 +1891,14 @@
 	PORT_DIPSETTING(    0x02, "B" )
 	PORT_DIPSETTING(    0x01, "C" )
 	PORT_DIPSETTING(    0x03, "D" )
-	PORT_DIPUNUSED_DIPLOC( 0x0c, 0x08, "SW2:3,4" ) PORT_CONDITION("DSW3", 0x03, PORTCOND_EQUALS, 0x00)
-	PORT_DIPUNUSED_DIPLOC( 0x0c, 0x08, "SW2:3,4" ) PORT_CONDITION("DSW3", 0x03, PORTCOND_EQUALS, 0x02)
-	PORT_DIPNAME( 0x0c, 0x08, "Bonus Rate (3renchan bonus)" )	PORT_DIPLOCATION("SW2:3,4")	PORT_CONDITION("DSW3", 0x03, PORTCOND_EQUALS, 0x01)
+	PORT_DIPUNUSED_DIPLOC( 0x0c, 0x08, "SW2:3,4" ) PORT_CONDITION("DSW3", 0x03, EQUALS, 0x00)
+	PORT_DIPUNUSED_DIPLOC( 0x0c, 0x08, "SW2:3,4" ) PORT_CONDITION("DSW3", 0x03, EQUALS, 0x02)
+	PORT_DIPNAME( 0x0c, 0x08, "Bonus Rate (3renchan bonus)" )	PORT_DIPLOCATION("SW2:3,4")	PORT_CONDITION("DSW3", 0x03, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x00, "A (1 2 2 3 pts.)" )
 	PORT_DIPSETTING(    0x04, "B (1 2 2 5 pts.)" )
 	PORT_DIPSETTING(    0x08, "C (1 2 3 6 pts.)" )
 	PORT_DIPSETTING(    0x0c, "D (1 2 6 10 pts.)" )
-	PORT_DIPNAME( 0x0c, 0x08, "Bonus Rate (5renchan bonus)" )	PORT_DIPLOCATION("SW2:3,4")	PORT_CONDITION("DSW3", 0x03, PORTCOND_EQUALS, 0x03)
+	PORT_DIPNAME( 0x0c, 0x08, "Bonus Rate (5renchan bonus)" )	PORT_DIPLOCATION("SW2:3,4")	PORT_CONDITION("DSW3", 0x03, EQUALS, 0x03)
 	PORT_DIPSETTING(    0x00, "A (5 pts.)" )
 	PORT_DIPSETTING(    0x04, "B (10 pts.)" )
 	PORT_DIPSETTING(    0x08, "C (15 pts.)" )
diff -Nru src-old/mame/drivers/rpunch.c src/mame/drivers/rpunch.c
--- src-old/mame/drivers/rpunch.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rpunch.c	2012-05-03 11:00:08.000000000 +0200
@@ -146,7 +146,7 @@
 
 CUSTOM_INPUT_MEMBER(rpunch_state::hi_bits_r)
 {
-	return input_port_read(machine(), "SERVICE");
+	return ioport("SERVICE")->read();
 }
 
 
diff -Nru src-old/mame/drivers/runaway.c src/mame/drivers/runaway.c
--- src-old/mame/drivers/runaway.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/runaway.c	2012-05-03 11:00:08.000000000 +0200
@@ -50,11 +50,11 @@
 {
 	UINT8 val = 0;
 
-	if (input_port_read(machine(), "3000D7") & (1 << offset))
+	if (ioport("3000D7")->read() & (1 << offset))
 	{
 		val |= 0x80;
 	}
-	if (input_port_read(machine(), "3000D6") & (1 << offset))
+	if (ioport("3000D6")->read() & (1 << offset))
 	{
 		val |= 0x40;
 	}
@@ -65,7 +65,7 @@
 
 static READ8_DEVICE_HANDLER( runaway_pot_r )
 {
-	return (input_port_read(device->machine(), "7000") << (7 - offset)) & 0x80;
+	return (device->machine().root_device().ioport("7000")->read() << (7 - offset)) & 0x80;
 }
 
 
@@ -107,7 +107,7 @@
 static INPUT_PORTS_START( qwak )
 	PORT_START("3000D7")	/* 3000 D7 */
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -159,7 +159,7 @@
 static INPUT_PORTS_START( runaway )
 	PORT_START("3000D7") /* 3000 D7 */
 	PORT_BIT ( 0x01, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT ( 0x02, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT ( 0x02, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT ( 0x04, IP_ACTIVE_LOW, IPT_TILT )
 	PORT_BIT ( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x10, IP_ACTIVE_LOW )
diff -Nru src-old/mame/drivers/rungun.c src/mame/drivers/rungun.c
--- src-old/mame/drivers/rungun.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/rungun.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,20 +72,20 @@
 	switch (offset)
 	{
 		case 0x00/2:
-			if (input_port_read(machine(), "DSW") & 0x20)
-				return (input_port_read(machine(), "P1") | input_port_read(machine(), "P3") << 8);
+			if (ioport("DSW")->read() & 0x20)
+				return (ioport("P1")->read() | ioport("P3")->read() << 8);
 			else
 			{
-				data = input_port_read(machine(), "P1") & input_port_read(machine(), "P3");
+				data = ioport("P1")->read() & ioport("P3")->read();
 				return (data << 8 | data);
 			}
 
 		case 0x02/2:
-			if (input_port_read(machine(), "DSW") & 0x20)
-				return (input_port_read(machine(), "P2") | input_port_read(machine(), "P4") << 8);
+			if (ioport("DSW")->read() & 0x20)
+				return (ioport("P2")->read() | ioport("P4")->read() << 8);
 			else
 			{
-				data = input_port_read(machine(), "P2") & input_port_read(machine(), "P4");
+				data = ioport("P2")->read() & ioport("P4")->read();
 				return (data << 8 | data);
 			}
 
@@ -95,12 +95,12 @@
                 bit8 : freeze
                 bit9 : joysticks layout(auto detect???)
             */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 
 		case 0x06/2:
 			if (ACCESSING_BITS_0_7)
 			{
-				data = input_port_read(machine(), "DSW");
+				data = ioport("DSW")->read();
 			}
 			return ((m_sysreg[0x06 / 2] & 0xff00) | data);
 	}
@@ -125,7 +125,7 @@
                 bit10 : IRQ5 ACK
             */
 			if (ACCESSING_BITS_0_7)
-				input_port_write(machine(), "EEPROMOUT", data, 0xff);
+				ioport("EEPROMOUT")->write(data, 0xff);
 
 			if (!(data & 0x40))
 				device_set_input_line(m_maincpu, M68K_IRQ_5, CLEAR_LINE);
diff -Nru src-old/mame/drivers/safarir.c src/mame/drivers/safarir.c
--- src-old/mame/drivers/safarir.c	2012-04-12 01:14:33.000000000 +0200
+++ src/mame/drivers/safarir.c	2012-05-03 11:00:08.000000000 +0200
@@ -388,7 +388,7 @@
 	PORT_DIPSETTING(    0x20, "5000" )
 	PORT_DIPSETTING(    0x40, "7000" )
 	PORT_DIPSETTING(    0x60, "9000" )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/saturn.c src/mame/drivers/saturn.c
--- src-old/mame/drivers/saturn.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/saturn.c	2012-05-03 11:00:08.000000000 +0200
@@ -830,68 +830,68 @@
 }
 
 #define SATURN_PAD_P1(_mask_, _val_) \
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P1 A") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P1 C") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P1 B") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P1 R") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P1 X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P1 Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P1 Z") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON7 ) PORT_NAME("P1 L") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0007, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) //read '1' when direct mode is polled
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P1 A") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P1 C") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P1 B") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P1 R") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P1 X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P1 Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P1 Z") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON7 ) PORT_NAME("P1 L") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0007, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) //read '1' when direct mode is polled
 
 #define SATURN_PAD_P2(_mask_, _val_) \
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P2 A") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P2 C") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P2 B") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P2 R") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P2 X") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P2 Y") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P2 Z") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON7 ) PORT_NAME("P2 L") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0007, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) //read '1' when direct mode is polled
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P2 A") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P2 C") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P2 B") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P2 R") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P2 X") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P2 Y") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P2 Z") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_BUTTON7 ) PORT_NAME("P2 L") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0007, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) //read '1' when direct mode is polled
 
 #define MD_PAD_P1(_mask_, _val_) \
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P1 A") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P1 C") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P1 B") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P1 Mode") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P1 X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P1 Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P1 Z") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) //read '1' when direct mode is polled
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P1 A") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P1 C") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P1 B") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P1 Mode") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P1 X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P1 Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P1 Z") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) //read '1' when direct mode is polled
 
 #define MD_PAD_P2(_mask_, _val_) \
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P2 A") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P2 C") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P2 B") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P2 Mode") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P2 X") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P2 Y") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P2 Z") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) \
-	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, PORTCOND_EQUALS, _val_) //read '1' when direct mode is polled
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("P2 A") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("P2 C") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("P2 B") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_BUTTON8 ) PORT_NAME("P2 Mode") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("P2 X") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("P2 Y") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON6 ) PORT_NAME("P2 Z") PORT_PLAYER(2)	PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) \
+	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("INPUT_TYPE", _mask_, EQUALS, _val_) //read '1' when direct mode is polled
 
-#define SATURN_KEYBOARD	PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x05)
+#define SATURN_KEYBOARD	PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x05)
 
 INPUT_CHANGED_MEMBER(saturn_state::nmi_reset)
 {
@@ -1098,40 +1098,40 @@
 	PORT_BIT(0x08,IP_ACTIVE_HIGH,IPT_KEYBOARD) PORT_NAME("RIGHT") PORT_CODE(KEYCODE_RIGHT) /*PORT_CHAR('3')*/ PORT_CHANGED_MEMBER(DEVICE_SELF, saturn_state, key_stroke, 0x7b) PORT_PLAYER(1) SATURN_KEYBOARD
 
 	PORT_START("MOUSEB1")
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P1 Pointer Left Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P1 Pointer Right Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P1 Pointer Middle Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P1 Pointer Start Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P1 Mouse Left Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P1 Mouse Right Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P1 Mouse Middle Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P1 Mouse Start Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P1 Pointer Left Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P1 Pointer Right Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P1 Pointer Middle Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P1 Pointer Start Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P1 Mouse Left Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P1 Mouse Right Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P1 Mouse Middle Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P1 Mouse Start Button") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
 
 	PORT_START("MOUSEX1")
-    PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P1 Pointer X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P1 Mouse X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
+    PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P1 Pointer X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P1 Mouse X") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
 
 	PORT_START("MOUSEY1")
-    PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P1 Pointer Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x04)
-	PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P1 Mouse Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x08)
+    PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P1 Pointer Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x04)
+	PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P1 Mouse Y") PORT_PLAYER(1) PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x08)
 
 	PORT_START("MOUSEB2")
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P2 Pointer Left Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P2 Pointer Right Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P2 Pointer Middle Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P2 Pointer Start Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P2 Mouse Left Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
-	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P2 Mouse Right Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
-	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P2 Mouse Middle Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
-	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P2 Mouse Start Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P2 Pointer Left Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P2 Pointer Right Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P2 Pointer Middle Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P2 Pointer Start Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0x01, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("P2 Mouse Left Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
+	PORT_BIT(0x02, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("P2 Mouse Right Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
+	PORT_BIT(0x04, IP_ACTIVE_HIGH, IPT_BUTTON3 ) PORT_NAME("P2 Mouse Middle Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
+	PORT_BIT(0x08, IP_ACTIVE_HIGH, IPT_START ) PORT_NAME("P2 Mouse Start Button") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
 
 	PORT_START("MOUSEX2")
-    PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P2 Pointer X") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P2 Mouse X") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
+    PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P2 Pointer X") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0xffff, 0x00, IPT_MOUSE_X) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_NAME("P2 Mouse X") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
 
 	PORT_START("MOUSEY2")
-    PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P2 Pointer Y") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x40)
-	PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P2 Mouse Y") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x80)
+    PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P2 Pointer Y") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x40)
+	PORT_BIT(0xffff, 0x00, IPT_MOUSE_Y) PORT_SENSITIVITY(100) PORT_MINMAX(0x000, 0xffff) PORT_KEYDELTA(2) PORT_RESET PORT_REVERSE PORT_NAME("P2 Mouse Y") PORT_PLAYER(2) PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x80)
 
 	PORT_START("AN_JOY1")
 	SATURN_PAD_P1(0x0f, 0x01)	// racing device
@@ -1142,28 +1142,28 @@
 	SATURN_PAD_P2(0xf0, 0x20)	// analog controller
 
 	PORT_START("AN_X1")
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick X") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick X") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x02)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick X") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x01)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick X") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x02)
 
 	PORT_START("AN_Y1")
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick Y") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick Y") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x02)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick Y") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x01)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick Y") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x02)
 
 	PORT_START("AN_Z1")
-	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick Z") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick Z") PORT_CONDITION("INPUT_TYPE", 0x0f, PORTCOND_EQUALS, 0x02)
+	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 Racing Stick Z") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x01)
+	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(1) PORT_NAME("P1 AD Stick Z") PORT_CONDITION("INPUT_TYPE", 0x0f, EQUALS, 0x02)
 
 	PORT_START("AN_X2")
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick X") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x10)
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick X") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x20)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick X") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x10)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick X") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x20)
 
 	PORT_START("AN_Y2")
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick Y") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x10)
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick Y") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x20)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick Y") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x10)
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick Y") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x20)
 
 	PORT_START("AN_Z2")
-	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick Z") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x10)
-	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick Z") PORT_CONDITION("INPUT_TYPE", 0xf0, PORTCOND_EQUALS, 0x20)
+	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 Racing Stick Z") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x10)
+	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Z ) PORT_MINMAX(0x00, 0xff) PORT_SENSITIVITY(25) PORT_KEYDELTA(200) PORT_PLAYER(2) PORT_NAME("P2 AD Stick Z") PORT_CONDITION("INPUT_TYPE", 0xf0, EQUALS, 0x20)
 
 	PORT_START("MD_JOY1")
 	MD_PAD_P1(0x0f, 0x06)	// MD 3 buttons pad
@@ -1468,8 +1468,8 @@
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_MODIFY("PORTC")
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_MODIFY("PORTE")
@@ -1479,55 +1479,55 @@
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("P1_KEY0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_E )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_A )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_M )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_I )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_KAN )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_E )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_A )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_M )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_I )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
 
 	PORT_START("P1_KEY1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_BET )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_F )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_B )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_N )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_J )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_REACH )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_MAHJONG_BET )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_F )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_B )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_N )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_J )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
 
 	PORT_START("P1_KEY2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_RON )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_G )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_C )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_K )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_MAHJONG_RON )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_G )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_C )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_CHI )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_K )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )  PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
 
 	PORT_START("P1_KEY3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_H ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_D ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_PON ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_L ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_MAHJONG_H ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_MAHJONG_D ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_MAHJONG_PON ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_MAHJONG_L ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_PLAYER(1) PORT_CONDITION("IO_TYPE", 0x01, EQUALS, 0x01)
 
 	PORT_START("P1_KEY4")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED ) /* F/F is there, but these two games are single player so it isn't connected */
@@ -2055,7 +2055,7 @@
 
 	stvcd_reset( machine );
 
-	state->m_cart_type = input_port_read(machine,"CART_AREA") & 7;
+	state->m_cart_type = state->ioport("CART_AREA")->read() & 7;
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_legacy_readwrite_handler(0x02400000, 0x027fffff, FUNC(saturn_null_ram_r), FUNC(saturn_null_ram_w));
 	machine.device("slave")->memory().space(AS_PROGRAM)->install_legacy_readwrite_handler(0x02400000, 0x027fffff, FUNC(saturn_null_ram_r), FUNC(saturn_null_ram_w));
diff -Nru src-old/mame/drivers/sbowling.c src/mame/drivers/sbowling.c
--- src-old/mame/drivers/sbowling.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sbowling.c	2012-05-03 11:00:08.000000000 +0200
@@ -216,9 +216,9 @@
 {
 
 	if (m_sbw_system & 2)
-		return input_port_read(machine(), "TRACKY");
+		return ioport("TRACKY")->read();
 	else
-		return input_port_read(machine(), "TRACKX");
+		return ioport("TRACKX")->read();
 }
 
 static ADDRESS_MAP_START( main_map, AS_PROGRAM, 8, sbowling_state )
diff -Nru src-old/mame/drivers/sbrkout.c src/mame/drivers/sbrkout.c
--- src-old/mame/drivers/sbrkout.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/drivers/sbrkout.c	2012-05-03 11:00:08.000000000 +0200
@@ -142,7 +142,7 @@
 	/* on the VBLANK, read the pot and schedule an interrupt time for it */
 	if (scanline == machine.primary_screen->visible_area().max_y + 1)
 	{
-		UINT8 potvalue = input_port_read(machine, "PADDLE");
+		UINT8 potvalue = state->ioport("PADDLE")->read();
 		state->m_pot_timer->adjust(machine.primary_screen->time_until_pos(56 + (potvalue / 2), (potvalue % 2) * 128));
 	}
 
@@ -173,25 +173,25 @@
 
 	/* DIP switches are selected by ADR0+ADR1 if ADR3 == 0 */
 	if ((offset & 0x0b) == 0x00)
-		result &= (input_port_read(machine(), "DIPS") << 6) | 0x3f;
+		result &= (ioport("DIPS")->read() << 6) | 0x3f;
 	if ((offset & 0x0b) == 0x01)
-		result &= (input_port_read(machine(), "DIPS") << 4) | 0x3f;
+		result &= (ioport("DIPS")->read() << 4) | 0x3f;
 	if ((offset & 0x0b) == 0x02)
-		result &= (input_port_read(machine(), "DIPS") << 0) | 0x3f;
+		result &= (ioport("DIPS")->read() << 0) | 0x3f;
 	if ((offset & 0x0b) == 0x03)
-		result &= (input_port_read(machine(), "DIPS") << 2) | 0x3f;
+		result &= (ioport("DIPS")->read() << 2) | 0x3f;
 
 	/* other switches are selected by ADR0+ADR1+ADR2 if ADR4 == 0 */
 	if ((offset & 0x17) == 0x00)
-		result &= (input_port_read(machine(), "SELECT") << 7) | 0x7f;
+		result &= (ioport("SELECT")->read() << 7) | 0x7f;
 	if ((offset & 0x17) == 0x04)
 		result &= ((m_pot_trigger[0] & ~m_pot_mask[0]) << 7) | 0x7f;
 	if ((offset & 0x17) == 0x05)
 		result &= ((m_pot_trigger[1] & ~m_pot_mask[1]) << 7) | 0x7f;
 	if ((offset & 0x17) == 0x06)
-		result &= input_port_read(machine(), "SERVE");
+		result &= ioport("SERVE")->read();
 	if ((offset & 0x17) == 0x07)
-		result &= (input_port_read(machine(), "SELECT") << 6) | 0x7f;
+		result &= (ioport("SELECT")->read() << 6) | 0x7f;
 
 	return result;
 }
@@ -398,29 +398,29 @@
 	PORT_DIPSETTING(	0x00, DEF_STR( Free_Play ) )
 	PORT_DIPNAME( 0x70, 0x00, "Extended Play" )
 	/* Progressive */
-	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x20, "400" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x30, "600" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x40, "900" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x50, "1200" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x60, "1600" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
-	PORT_DIPSETTING(	0x70, "2000" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x00)
+	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x20, "400" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x30, "600" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x40, "900" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x50, "1200" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x60, "1600" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
+	PORT_DIPSETTING(	0x70, "2000" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x00)
 	/* Double */
-	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x20, "400" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x30, "600" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x40, "800" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x50, "1000" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x60, "1200" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
-	PORT_DIPSETTING(	0x70, "1500" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x02)
+	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x20, "400" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x30, "600" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x40, "800" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x50, "1000" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x60, "1200" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
+	PORT_DIPSETTING(	0x70, "1500" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x02)
 	/* Cavity */
-	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x20, "300" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x30, "400" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x40, "700" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x50, "900" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x60, "1100" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(	0x70, "1400" )	PORT_CONDITION("SELECT",0x03,PORTCOND_EQUALS,0x01)
+	PORT_DIPSETTING(	0x10, "200" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x20, "300" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x30, "400" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x40, "700" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x50, "900" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x60, "1100" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
+	PORT_DIPSETTING(	0x70, "1400" )	PORT_CONDITION("SELECT",0x03,EQUALS,0x01)
 	PORT_DIPSETTING(	0x00, DEF_STR( None ) )
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Lives ) )
 	PORT_DIPSETTING(	0x80, "3" )
diff -Nru src-old/mame/drivers/scobra.c src/mame/drivers/scobra.c
--- src-old/mame/drivers/scobra.c	2012-04-16 10:28:56.000000000 +0200
+++ src/mame/drivers/scobra.c	2012-05-03 11:00:08.000000000 +0200
@@ -268,7 +268,7 @@
 CUSTOM_INPUT_MEMBER(scobra_state::stratgyx_coinage_r)
 {
 	int bit_mask = (FPTR)param;
-	return (input_port_read(machine(), "IN4") & bit_mask) ? 0x01 : 0x00;
+	return (ioport("IN4")->read() & bit_mask) ? 0x01 : 0x00;
 }
 
 
diff -Nru src-old/mame/drivers/scramble.c src/mame/drivers/scramble.c
--- src-old/mame/drivers/scramble.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/scramble.c	2012-05-03 11:00:08.000000000 +0200
@@ -475,7 +475,7 @@
 CUSTOM_INPUT_MEMBER(scramble_state::ckongs_coinage_r)
 {
 	int bit_mask = (FPTR)param;
-	return (input_port_read(machine(), "FAKE") & bit_mask) ? 0x01 : 0x00;
+	return (ioport("FAKE")->read() & bit_mask) ? 0x01 : 0x00;
 }
 
 
@@ -816,7 +816,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* protection check? */
 
     PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( hncholms )
@@ -860,7 +860,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* protection check? */
 
     PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( cavelon )
diff -Nru src-old/mame/drivers/scregg.c src/mame/drivers/scregg.c
--- src-old/mame/drivers/scregg.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/scregg.c	2012-05-03 11:00:08.000000000 +0200
@@ -142,7 +142,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
diff -Nru src-old/mame/drivers/sderby.c src/mame/drivers/sderby.c
--- src-old/mame/drivers/sderby.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/sderby.c	2012-05-03 11:00:08.000000000 +0200
@@ -77,7 +77,7 @@
 	switch (offset)
 	{
 		case 0x00 >> 1:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 0x02 >> 1:
 			return 0xffff;			// to avoid game to reset (needs more work)
 	}
@@ -92,11 +92,11 @@
 	switch (offset)
 	{
 		case 0x00 >> 1:
-			return input_port_read(machine(), "IN0");
+			return ioport("IN0")->read();
 		case 0x02 >> 1:
-			return input_port_read(machine(), "IN1");
+			return ioport("IN1")->read();
 		case 0x04 >> 1:
-			return input_port_read(machine(), "IN2");
+			return ioport("IN2")->read();
 	}
 
 	return 0xffff;
@@ -421,7 +421,7 @@
 static INPUT_PORTS_START( pmroulet )
 	PORT_START("IN0")
 	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK ) /* it must be toggled to boot anyway */
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen") /* it must be toggled to boot anyway */
 	PORT_SERVICE_NO_TOGGLE(0x0020, IP_ACTIVE_LOW)
 	PORT_BIT( 0x00c0, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0f00, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/seattle.c src/mame/drivers/seattle.c
--- src-old/mame/drivers/seattle.c	2012-04-12 01:29:02.000000000 +0200
+++ src/mame/drivers/seattle.c	2012-05-03 11:00:08.000000000 +0200
@@ -1435,7 +1435,7 @@
 
 	if (data < 8 || data > 15)
 		logerror("%08X:Unexpected analog port select = %08X\n", cpu_get_pc(&space.device()), data);
-	m_pending_analog_read = input_port_read(machine(), portnames[data & 7]);
+	m_pending_analog_read = ioport(portnames[data & 7])->read();
 }
 
 
@@ -1453,39 +1453,39 @@
 	switch (offset)
 	{
 		case 0:		/* low 8 bits of X */
-			result = (input_port_read(machine(), "LIGHT0_X") << 4) & 0xff;
+			result = (ioport("LIGHT0_X")->read() << 4) & 0xff;
 			break;
 
 		case 1:		/* upper 4 bits of X */
-			result = (input_port_read(machine(), "LIGHT0_X") >> 4) & 0x0f;
-			result |= (input_port_read(machine(), "FAKE") & 0x03) << 4;
+			result = (ioport("LIGHT0_X")->read() >> 4) & 0x0f;
+			result |= (ioport("FAKE")->read() & 0x03) << 4;
 			result |= 0x40;
 			break;
 
 		case 2:		/* low 8 bits of Y */
-			result = (input_port_read(machine(), "LIGHT0_Y") << 2) & 0xff;
+			result = (ioport("LIGHT0_Y")->read() << 2) & 0xff;
 			break;
 
 		case 3:		/* upper 4 bits of Y */
-			result = (input_port_read(machine(), "LIGHT0_Y") >> 6) & 0x03;
+			result = (ioport("LIGHT0_Y")->read() >> 6) & 0x03;
 			break;
 
 		case 4:		/* low 8 bits of X */
-			result = (input_port_read(machine(), "LIGHT1_X") << 4) & 0xff;
+			result = (ioport("LIGHT1_X")->read() << 4) & 0xff;
 			break;
 
 		case 5:		/* upper 4 bits of X */
-			result = (input_port_read(machine(), "LIGHT1_X") >> 4) & 0x0f;
-			result |= (input_port_read(machine(), "FAKE") & 0x30);
+			result = (ioport("LIGHT1_X")->read() >> 4) & 0x0f;
+			result |= (ioport("FAKE")->read() & 0x30);
 			result |= 0x40;
 			break;
 
 		case 6:		/* low 8 bits of Y */
-			result = (input_port_read(machine(), "LIGHT1_Y") << 2) & 0xff;
+			result = (ioport("LIGHT1_Y")->read() << 2) & 0xff;
 			break;
 
 		case 7:		/* upper 4 bits of Y */
-			result = (input_port_read(machine(), "LIGHT1_Y") >> 6) & 0x03;
+			result = (ioport("LIGHT1_Y")->read() >> 6) & 0x03;
 			break;
 	}
 	return result;
diff -Nru src-old/mame/drivers/segac2.c src/mame/drivers/segac2.c
--- src-old/mame/drivers/segac2.c	2012-04-20 21:57:41.000000000 +0200
+++ src/mame/drivers/segac2.c	2012-05-03 11:00:08.000000000 +0200
@@ -118,7 +118,7 @@
 
 	/* determine how many sound banks */
 	state->m_sound_banks = 0;
-	if (machine.root_device().memregion("upd")->base())
+	if (state->memregion("upd")->base())
 		state->m_sound_banks = state->memregion("upd")->bytes() / 0x20000;
 
 	/* reset the protection */
@@ -326,8 +326,8 @@
 
 			/* otherwise, return an input port */
 			if (offset == 0x04/2 && state->m_sound_banks)
-				return (input_port_read(space->machine(), portnames[offset]) & 0xbf) | (upd7759_busy_r(space->machine().device("upd")) << 6);
-			return input_port_read(space->machine(), portnames[offset]);
+				return (space->machine().root_device().ioport(portnames[offset])->read() & 0xbf) | (upd7759_busy_r(space->machine().device("upd")) << 6);
+			return space->machine().root_device().ioport(portnames[offset])->read();
 
 		/* 'SEGA' protection */
 		case 0x10/2:
diff -Nru src-old/mame/drivers/segae.c src/mame/drivers/segae.c
--- src-old/mame/drivers/segae.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segae.c	2012-05-03 11:00:08.000000000 +0200
@@ -487,10 +487,10 @@
 	temp = 0;
 
 	if (m_port_fa_last == 0x08)  /* 0000 1000 */ /* Angle */
-		temp = input_port_read(machine(), "IN2");
+		temp = ioport("IN2")->read();
 
 	if (m_port_fa_last == 0x09)  /* 0000 1001 */ /* Accel */
-		temp = input_port_read(machine(), "IN3");
+		temp = ioport("IN3")->read();
 
 	return temp;
 }
@@ -524,13 +524,13 @@
 
 	if (data & 1)
 	{
-		int curr = input_port_read(machine(), "IN2");
+		int curr = ioport("IN2")->read();
 		m_diff1 = ((curr - m_last1) & 0x0fff) | (curr & 0xf000);
 		m_last1 = curr;
 	}
 	if (data & 2)
 	{
-		int curr = input_port_read(machine(), "IN3") & 0x0fff;
+		int curr = ioport("IN3")->read() & 0x0fff;
 		m_diff2 = ((curr - m_last2) & 0x0fff) | (curr & 0xf000);
 		m_last2 = curr;
 	}
diff -Nru src-old/mame/drivers/segag80r.c src/mame/drivers/segag80r.c
--- src-old/mame/drivers/segag80r.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segag80r.c	2012-05-03 11:00:08.000000000 +0200
@@ -214,10 +214,10 @@
 	/* read as two bits from each of 4 ports. For this reason, the input   */
 	/* ports have been organized logically, and are demangled at runtime.  */
 	/* 4 input ports each provide 8 bits of information. */
-	UINT8 d7d6 = input_port_read(machine(), "D7D6");
-	UINT8 d5d4 = input_port_read(machine(), "D5D4");
-	UINT8 d3d2 = input_port_read(machine(), "D3D2");
-	UINT8 d1d0 = input_port_read(machine(), "D1D0");
+	UINT8 d7d6 = ioport("D7D6")->read();
+	UINT8 d5d4 = ioport("D5D4")->read();
+	UINT8 d3d2 = ioport("D3D2")->read();
+	UINT8 d1d0 = ioport("D1D0")->read();
 	int shift = offset & 3;
 	return demangle(d7d6 >> shift, d5d4 >> shift, d3d2 >> shift, d1d0 >> shift);
 }
@@ -229,17 +229,17 @@
 	/* versus cocktail cabinets; we fix this here. The input ports are */
 	/* coded for cocktail mode; for upright mode, we manually shuffle the */
 	/* bits around. */
-	UINT8 d7d6 = input_port_read(machine(), "D7D6");
-	UINT8 d5d4 = input_port_read(machine(), "D5D4");
-	UINT8 d3d2 = input_port_read(machine(), "D3D2");
-	UINT8 d1d0 = input_port_read(machine(), "D1D0");
+	UINT8 d7d6 = ioport("D7D6")->read();
+	UINT8 d5d4 = ioport("D5D4")->read();
+	UINT8 d3d2 = ioport("D3D2")->read();
+	UINT8 d1d0 = ioport("D1D0")->read();
 	int shift = offset & 3;
 
 	/* tweak bits for the upright case */
 	UINT8 upright = d3d2 & 0x04;
 	if (upright)
 	{
-		UINT8 fc = input_port_read(machine(), "FC");
+		UINT8 fc = ioport("FC")->read();
 		d7d6 |= 0x60;
 		d5d4 = (d5d4 & ~0x1c) |
 				((~fc & 0x20) >> 3) | /* IPT_BUTTON2 */
@@ -253,8 +253,8 @@
 
 READ8_MEMBER(segag80r_state::spaceod_port_fc_r)
 {
-	UINT8 upright = input_port_read(machine(), "D3D2") & 0x04;
-	UINT8 fc = input_port_read(machine(), "FC");
+	UINT8 upright = ioport("D3D2")->read() & 0x04;
+	UINT8 fc = ioport("FC")->read();
 
 	/* tweak bits for the upright case */
 	if (upright)
diff -Nru src-old/mame/drivers/segag80v.c src/mame/drivers/segag80v.c
--- src-old/mame/drivers/segag80v.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/segag80v.c	2012-05-03 11:00:08.000000000 +0200
@@ -233,10 +233,10 @@
 	/* read as two bits from each of 4 ports. For this reason, the input   */
 	/* ports have been organized logically, and are demangled at runtime.  */
 	/* 4 input ports each provide 8 bits of information. */
-	UINT8 d7d6 = input_port_read(machine(), "D7D6");
-	UINT8 d5d4 = input_port_read(machine(), "D5D4");
-	UINT8 d3d2 = input_port_read(machine(), "D3D2");
-	UINT8 d1d0 = input_port_read(machine(), "D1D0");
+	UINT8 d7d6 = ioport("D7D6")->read();
+	UINT8 d5d4 = ioport("D5D4")->read();
+	UINT8 d3d2 = ioport("D3D2")->read();
+	UINT8 d1d0 = ioport("D1D0")->read();
 	int shift = offset & 3;
 	return demangle(d7d6 >> shift, d5d4 >> shift, d3d2 >> shift, d1d0 >> shift);
 }
@@ -260,7 +260,7 @@
 	INT8 delta;
 
 	if (m_spinner_select & 1)
-		return input_port_read(machine(), "FC");
+		return ioport("FC")->read();
 
 /*
  * The values returned are always increasing.  That is, regardless of whether
@@ -270,7 +270,7 @@
  */
 
 	/* I'm sure this can be further simplified ;-) BW */
-	delta = input_port_read(machine(), "SPINNER");
+	delta = ioport("SPINNER")->read();
 	if (delta != 0)
 	{
 		m_spinner_sign = (delta >> 7) & 1;
@@ -289,7 +289,7 @@
 
 CUSTOM_INPUT_MEMBER(segag80v_state::elim4_joint_coin_r)
 {
-	return (input_port_read(machine(), "COINS") & 0xf) != 0xf;
+	return (ioport("COINS")->read() & 0xf) != 0xf;
 }
 
 
@@ -305,11 +305,11 @@
 		{
 			case 6:
 				/* player 3 & 4 controls */
-				result = input_port_read(machine(), "FC");
+				result = ioport("FC")->read();
 				break;
 			case 7:
 				/* the 4 coin inputs */
-				result = input_port_read(machine(), "COINS");
+				result = ioport("COINS")->read();
 				break;
 		}
 	}
diff -Nru src-old/mame/drivers/segahang.c src/mame/drivers/segahang.c
--- src-old/mame/drivers/segahang.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segahang.c	2012-05-03 11:00:08.000000000 +0200
@@ -180,7 +180,7 @@
 		case 0x1000/2: /* Input ports and DIP switches */
 		{
 			static const char *const sysports[] = { "SERVICE", "COINAGE", "DSW", "UNKNOWN" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return space->machine().root_device().ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x3000/2: /* PPI @ 4C */
@@ -189,7 +189,7 @@
 		case 0x3020/2: /* ADC0804 data output */
 		{
 			static const char *const adcports[] = { "ADC0", "ADC1", "ADC2", "ADC3" };
-			return input_port_read_safe(space->machine(), adcports[state->m_adc_select], 0);
+			return state->ioport(adcports[state->m_adc_select])->read_safe(0);
 		}
 	}
 
@@ -235,7 +235,7 @@
 		case 0x0010/2: /* Input ports and DIP switches */
 		{
 			static const char *const sysports[] = { "SERVICE", "UNKNOWN", "COINAGE", "DSW" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return space->machine().root_device().ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x0020/2: /* PPI @ 4C */
@@ -245,7 +245,7 @@
 		case 0x0030/2: /* ADC0804 data output */
 		{
 			static const char *const adcports[] = { "ADC0", "ADC1", "ADC2", "ADC3" };
-			return input_port_read_safe(space->machine(), adcports[state->m_adc_select], 0);
+			return state->ioport(adcports[state->m_adc_select])->read_safe(0);
 		}
 	}
 
@@ -393,7 +393,7 @@
 
 static void sharrier_i8751_sim(running_machine &machine)
 {
-	workram[0x492/2] = (input_port_read(machine, "ADC0") << 8) | input_port_read(machine, "ADC1");
+	workram[0x492/2] = (machine.root_device().ioport("ADC0")->read() << 8) | machine.root_device().ioport("ADC1")->read();
 }
 
 
diff -Nru src-old/mame/drivers/segaorun.c src/mame/drivers/segaorun.c
--- src-old/mame/drivers/segaorun.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segaorun.c	2012-05-03 11:00:08.000000000 +0200
@@ -663,13 +663,13 @@
 		case 0x10/2:
 		{
 			static const char *const sysports[] = { "SERVICE", "UNKNOWN", "COINAGE", "DSW" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return space->machine().root_device().ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x30/2:
 		{
 			static const char *const ports[] = { "ADC0", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6", "ADC7" };
-			return input_port_read_safe(space->machine(), ports[state->m_adc_select], 0x0010);
+			return state->ioport(ports[state->m_adc_select])->read_safe(0x0010);
 		}
 
 		case 0x60/2:
@@ -733,13 +733,13 @@
 		case 0x1006/2:
 		{
 			static const char *const sysports[] = { "SERVICE", "UNKNOWN", "COINAGE", "DSW" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return space->machine().root_device().ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x3020/2:
 		{
 			static const char *const ports[] = { "ADC0", "ADC1", "ADC2", "ADC3" };
-			return input_port_read_safe(space->machine(), ports[state->m_adc_select], 0x0010);
+			return state->ioport(ports[state->m_adc_select])->read_safe(0x0010);
 		}
 	}
 	logerror("%06X:misc_io_r - unknown read access to address %04X\n", cpu_get_pc(&space->device()), offset * 2);
diff -Nru src-old/mame/drivers/segas16a.c src/mame/drivers/segas16a.c
--- src-old/mame/drivers/segas16a.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segas16a.c	2012-05-03 11:00:08.000000000 +0200
@@ -298,11 +298,11 @@
 		case 0x1000/2:
 		{
 			static const char *const sysports[] = { "SERVICE", "P1", "UNUSED", "P2" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return state->ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x2000/2:
-			return input_port_read(space->machine(), (offset & 1) ? "DSW2" : "DSW1");
+			return state->ioport((offset & 1) ? "DSW2" : "DSW1")->read();
 	}
 	logerror("%06X:standard_io_r - unknown read access to address %04X\n", cpu_get_pc(&space->device()), offset * 2);
 	return 0xffff;
@@ -634,16 +634,16 @@
 				{
 					switch (state->m_video_control & 0xf)
 					{
-						case 0x00: return input_port_read(space->machine(), "P1"); // "HANDX1"
-						case 0x04: return input_port_read(space->machine(), "TRACKX1");
-						case 0x08: return input_port_read(space->machine(), "TRACKY1");
-						case 0x0c: return input_port_read(space->machine(), "HANDY1");
+						case 0x00: return state->ioport("P1")->read(); // "HANDX1"
+						case 0x04: return state->ioport("TRACKX1")->read();
+						case 0x08: return state->ioport("TRACKY1")->read();
+						case 0x0c: return state->ioport("HANDY1")->read();
 					}
 					break;
 				}
 
 				case 0x02:
-					return input_port_read(space->machine(), "DIAL1") | (input_port_read(space->machine(), "DIAL2") << 4);
+					return state->ioport("DIAL1")->read() | (state->ioport("DIAL2")->read() << 4);
 					// low nibble: Sega 56pin Edge "16"-"19" // rotary switch 10positions 4bit-binary-pinout
 					// high nibble: Sega 56pin Edge "T"-"W"  // ditto
 
@@ -651,10 +651,10 @@
 				{
 					switch (state->m_video_control & 0xf)
 					{
-						case 0x00: return input_port_read(space->machine(), "P2"); // "HANDX2"
-						case 0x04: return input_port_read(space->machine(), "TRACKX2");
-						case 0x08: return input_port_read(space->machine(), "TRACKY2");
-						case 0x0c: return input_port_read(space->machine(), "HANDY2");
+						case 0x00: return state->ioport("P2")->read(); // "HANDX2"
+						case 0x04: return state->ioport("TRACKX2")->read();
+						case 0x08: return state->ioport("TRACKY2")->read();
+						case 0x0c: return state->ioport("HANDY2")->read();
 					}
 					break;
 				}
@@ -686,9 +686,9 @@
 				/* upper bit of the trackball controls */
 				case 0:
 				{
-					UINT8 buttons = input_port_read(space->machine(), "SERVICE");
-					UINT8 analog1 = input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1");
-					UINT8 analog2 = input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2");
+					UINT8 buttons = state->ioport("SERVICE")->read();
+					UINT8 analog1 = state->ioport((state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1")->read();
+					UINT8 analog2 = state->ioport((state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2")->read();
 					buttons |= (analog1 & 0x80) >> 1;
 					buttons |= (analog2 & 0x80);
 					return buttons;
@@ -698,8 +698,8 @@
 				/* player 1 select switch mapped to bit 7 */
 				case 1:
 				{
-					UINT8 buttons = input_port_read(space->machine(), "BUTTONS1");
-					UINT8 analog = input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1");
+					UINT8 buttons = state->ioport("BUTTONS1")->read();
+					UINT8 analog = state->ioport((state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1")->read();
 					return (buttons & 0x80) | (analog & 0x7f);
 				}
 
@@ -707,11 +707,11 @@
 				case 2:
 				{
 					if (state->m_video_control & 4)
-						return (input_port_read(space->machine(), "ANALOGZ1") >> 4) | (input_port_read(space->machine(), "ANALOGZ2") & 0xf0);
+						return (state->ioport("ANALOGZ1")->read() >> 4) | (state->ioport("ANALOGZ2")->read() & 0xf0);
 					else
 					{
-						UINT8 buttons1 = input_port_read(space->machine(), "BUTTONS1");
-						UINT8 buttons2 = input_port_read(space->machine(), "BUTTONS2");
+						UINT8 buttons1 = state->ioport("BUTTONS1")->read();
+						UINT8 buttons2 = state->ioport("BUTTONS2")->read();
 
 						if (!(buttons1 & 0x01))
 							state->m_last_buttons1 = 0;
@@ -739,8 +739,8 @@
 				/* player 2 select switch mapped to bit 7 */
 				case 3:
 				{
-					UINT8 buttons = input_port_read(space->machine(), "BUTTONS2");
-					UINT8 analog = input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2");
+					UINT8 buttons = state->ioport("BUTTONS2")->read();
+					UINT8 analog = state->ioport((state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2")->read();
 					return (buttons & 0x80) | (analog & 0x7f);
 				}
 			}
@@ -773,10 +773,10 @@
 				case 1:
 					switch ((state->m_read_port++) & 3)
 					{
-						case 0: return input_port_read(space->machine(), "P1");
-						case 1: return input_port_read(space->machine(), "P2");
-						case 2: return input_port_read(space->machine(), "P3");
-						case 3: return input_port_read(space->machine(), "P4");
+						case 0: return state->ioport("P1")->read();
+						case 1: return state->ioport("P2")->read();
+						case 2: return state->ioport("P3")->read();
+						case 3: return state->ioport("P4")->read();
 					}
 
 					break;
@@ -803,8 +803,8 @@
 		case 0x1000/2:
 			switch (offset & 3)
 			{
-				case 1:	return input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1");
-				case 3:	return input_port_read(space->machine(), (state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2");
+				case 1:	return state->ioport((state->m_video_control & 4) ? "ANALOGY1" : "ANALOGX1")->read();
+				case 3:	return state->ioport((state->m_video_control & 4) ? "ANALOGY2" : "ANALOGX2")->read();
 			}
 			break;
 	}
@@ -830,12 +830,12 @@
 			switch (offset & 3)
 			{
 				case 1:
-					if (input_port_read_safe(space->machine(), portname[state->m_mj_input_num], 0xff) != 0xff)
+					if (state->ioport(portname[state->m_mj_input_num])->read_safe(0xff) != 0xff)
 						return 0xff & ~(1 << state->m_mj_input_num);
 					return 0xff;
 
 				case 2:
-					return input_port_read_safe(space->machine(), portname[state->m_mj_input_num], 0xff);
+					return state->ioport(portname[state->m_mj_input_num])->read_safe(0xff);
 			}
 			break;
 	}
@@ -973,9 +973,9 @@
 			return maincpu_byte_r(space->machine(), 0x840001 ^ offset);
 
 		case 5:
-			return space->machine().root_device().memregion("maincpu")->base()[0x00000 + offset];
+			return state->memregion("maincpu")->base()[0x00000 + offset];
 		case 6:
-			return space->machine().root_device().memregion("maincpu")->base()[0x10000 + offset];
+			return state->memregion("maincpu")->base()[0x10000 + offset];
 		case 7:
 			return state->memregion("maincpu")->base()[0x20000 + offset];
 
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segas16b.c	2012-05-03 11:00:08.000000000 +0200
@@ -1168,11 +1168,11 @@
 		case 0x1000/2:
 		{
 			static const char *const sysports[] = { "SERVICE", "P1", "UNUSED", "P2" };
-			return input_port_read(space->machine(), sysports[offset & 3]);
+			return space->machine().root_device().ioport(sysports[offset & 3])->read();
 		}
 
 		case 0x2000/2:
-			return input_port_read(space->machine(), (offset & 1) ? "DSW1" : "DSW2");
+			return space->machine().root_device().ioport((offset & 1) ? "DSW1" : "DSW2")->read();
 	}
 	logerror("%06X:standard_io_r - unknown read access to address %04X\n", cpu_get_pc(&space->device()), offset * 2);
 	return segaic16_open_bus_r(space, 0, mem_mask);
@@ -1450,7 +1450,7 @@
 	}
 
 	/* read inputs */
-	workram[inputoffs] = ~input_port_read(machine, "SERVICE") << 8;
+	workram[inputoffs] = ~machine.root_device().ioport("SERVICE")->read() << 8;
 }
 
 static void altbeasj_i8751_sim(running_machine &machine)
@@ -1534,8 +1534,8 @@
 	}
 
 	/* read inputs */
-	workram[0x2cd0/2] = (input_port_read(machine, "P1") << 8) | input_port_read(machine, "P2");
-	workram[0x2c96/2] = input_port_read(machine, "SERVICE") << 8;
+	workram[0x2cd0/2] = (state->ioport("P1")->read() << 8) | state->ioport("P2")->read();
+	workram[0x2c96/2] = machine.root_device().ioport("SERVICE")->read() << 8;
 }
 
 
@@ -1557,9 +1557,9 @@
 	}
 
 	/* read inputs */
-	workram[0x01e6/2] = input_port_read(machine, "SERVICE") << 8;
-	workram[0x01e8/2] = input_port_read(machine, "P1") << 8;
-	workram[0x01ea/2] = input_port_read(machine, "P2") << 8;
+	workram[0x01e6/2] = machine.root_device().ioport("SERVICE")->read() << 8;
+	workram[0x01e8/2] = machine.root_device().ioport("P1")->read() << 8;
+	workram[0x01ea/2] = machine.root_device().ioport("P2")->read() << 8;
 }
 
 
@@ -1591,34 +1591,35 @@
 
 static READ16_HANDLER( aceattac_custom_io_r )
 {
+	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	switch (offset & (0x3000/2))
 	{
 		case 0x1000/2:
 			switch (offset & 3)
 			{
 				case 0x01:
-					return input_port_read(space->machine(), "P1");
+					return state->ioport("P1")->read();
 
 				case 0x02:
-					return input_port_read(space->machine(), "DIAL1") | (input_port_read(space->machine(), "DIAL2") << 4);
+					return state->ioport("DIAL1")->read() | (state->ioport("DIAL2")->read() << 4);
 					// low nibble: Sega 56pin Edge "16"-"19" // rotary switch 10positions 4bit-binary-pinout
 					// high nibble: Sega 56pin Edge "T"-"W"  // ditto
 
 				case 0x03:
-					return input_port_read(space->machine(), "P2");
+					return state->ioport("P2")->read();
 			}
 			break;
 		case 0x3000/2:
 			switch (offset & 3)
 			{
-				case 0:	return input_port_read(space->machine(), "HANDX1");
-				case 1:	return input_port_read(space->machine(), "TRACKX1");
-				case 2:	return input_port_read(space->machine(), "TRACKY1");
-				case 3:	return input_port_read(space->machine(), "HANDY1");
-				case 4:	return input_port_read(space->machine(), "HANDX2");
-				case 5:	return input_port_read(space->machine(), "TRACKX2");
-				case 6:	return input_port_read(space->machine(), "TRACKY2");
-				case 7:	return input_port_read(space->machine(), "HANDY2");
+				case 0:	return state->ioport("HANDX1")->read();
+				case 1:	return state->ioport("TRACKX1")->read();
+				case 2:	return state->ioport("TRACKY1")->read();
+				case 3:	return state->ioport("HANDY1")->read();
+				case 4:	return state->ioport("HANDX2")->read();
+				case 5:	return state->ioport("TRACKX2")->read();
+				case 6:	return state->ioport("TRACKY2")->read();
+				case 7:	return state->ioport("HANDY2")->read();
 			}
 			break;
 	}
@@ -1656,19 +1657,20 @@
 
 static READ16_HANDLER( dunkshot_custom_io_r )
 {
+	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	switch (offset & (0x3000/2))
 	{
 		case 0x3000/2:
 			switch ((offset/2) & 7)
 			{
-				case 0:	return (input_port_read(space->machine(), "ANALOGX1") << 4) >> (8 * (offset & 1));
-				case 1:	return (input_port_read(space->machine(), "ANALOGY1") << 4) >> (8 * (offset & 1));
-				case 2:	return (input_port_read(space->machine(), "ANALOGX2") << 4) >> (8 * (offset & 1));
-				case 3:	return (input_port_read(space->machine(), "ANALOGY2") << 4) >> (8 * (offset & 1));
-				case 4:	return (input_port_read(space->machine(), "ANALOGX3") << 4) >> (8 * (offset & 1));
-				case 5:	return (input_port_read(space->machine(), "ANALOGY3") << 4) >> (8 * (offset & 1));
-				case 6:	return (input_port_read(space->machine(), "ANALOGX4") << 4) >> (8 * (offset & 1));
-				case 7:	return (input_port_read(space->machine(), "ANALOGY4") << 4) >> (8 * (offset & 1));
+				case 0:	return (state->ioport("ANALOGX1")->read() << 4) >> (8 * (offset & 1));
+				case 1:	return (state->ioport("ANALOGY1")->read() << 4) >> (8 * (offset & 1));
+				case 2:	return (state->ioport("ANALOGX2")->read() << 4) >> (8 * (offset & 1));
+				case 3:	return (state->ioport("ANALOGY2")->read() << 4) >> (8 * (offset & 1));
+				case 4:	return (state->ioport("ANALOGX3")->read() << 4) >> (8 * (offset & 1));
+				case 5:	return (state->ioport("ANALOGY3")->read() << 4) >> (8 * (offset & 1));
+				case 6:	return (state->ioport("ANALOGX4")->read() << 4) >> (8 * (offset & 1));
+				case 7:	return (state->ioport("ANALOGY4")->read() << 4) >> (8 * (offset & 1));
 			}
 			break;
 	}
@@ -1714,7 +1716,7 @@
 			switch (offset & 0x30/2)
 			{
 				case 0x20/2:
-					state->m_hwc_input_value = input_port_read_safe(space->machine(), portname[offset & 3], 0xff);
+					state->m_hwc_input_value = state->ioport(portname[offset & 3])->read_safe(0xff);
 					break;
 
 				case 0x30/2:
@@ -1741,15 +1743,16 @@
 
 static READ16_HANDLER( passshtj_custom_io_r )
 {
+	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	switch (offset & (0x3000/2))
 	{
 		case 0x3000/2:
 			switch (offset & 3)
 			{
-				case 0:	return input_port_read(space->machine(), "P1");
-				case 1:	return input_port_read(space->machine(), "P2");
-				case 2:	return input_port_read(space->machine(), "P3");
-				case 3:	return input_port_read(space->machine(), "P4");
+				case 0:	return state->ioport("P1")->read();
+				case 1:	return state->ioport("P2")->read();
+				case 2:	return state->ioport("P3")->read();
+				case 3:	return state->ioport("P4")->read();
 			}
 			break;
 	}
@@ -1766,15 +1769,16 @@
 
 static READ16_HANDLER( sdi_custom_io_r )
 {
+	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	switch (offset & (0x3000/2))
 	{
 		case 0x3000/2:
 			switch ((offset/2) & 3)
 			{
-				case 0:	return input_port_read(space->machine(), "ANALOGX1");
-				case 1:	return input_port_read(space->machine(), "ANALOGY1");
-				case 2:	return input_port_read(space->machine(), "ANALOGX2");
-				case 3:	return input_port_read(space->machine(), "ANALOGY2");
+				case 0:	return state->ioport("ANALOGX1")->read();
+				case 1:	return state->ioport("ANALOGY1")->read();
+				case 2:	return state->ioport("ANALOGX2")->read();
+				case 3:	return state->ioport("ANALOGY2")->read();
 			}
 			break;
 	}
@@ -1800,12 +1804,12 @@
 			switch (offset & 3)
 			{
 				case 1:
-					if (input_port_read_safe(space->machine(), portname[state->m_mj_input_num], 0xff) != 0xff)
+					if (state->ioport(portname[state->m_mj_input_num])->read_safe(0xff) != 0xff)
 						return 0xff & ~(1 << state->m_mj_input_num);
 					return 0xff;
 
 				case 2:
-					return input_port_read_safe(space->machine(), portname[state->m_mj_input_num], 0xff);
+					return state->ioport(portname[state->m_mj_input_num])->read_safe(0xff);
 			}
 			break;
 	}
diff -Nru src-old/mame/drivers/segas18.c src/mame/drivers/segas18.c
--- src-old/mame/drivers/segas18.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segas18.c	2012-05-03 11:00:08.000000000 +0200
@@ -252,7 +252,7 @@
 				return state->m_misc_io_data[offset];
 
 			/* otherwise, return an input port */
-			return input_port_read(space->machine(), portnames[offset]);
+			return space->machine().root_device().ioport(portnames[offset])->read();
 
 		/* 'SEGA' protection */
 		case 0x10/2:
@@ -359,7 +359,7 @@
 
 		/* video control latch */
 		case 0x2000/2:
-			return input_port_read(space->machine(), portnames[offset & 1]);
+			return space->machine().root_device().ioport(portnames[offset & 1])->read();
 	}
 	if (state->m_custom_io_r)
 		return state->m_custom_io_r(space, offset, mem_mask);
@@ -450,13 +450,13 @@
 	switch (offset)
 	{
 		case 0x3020/2:
-			return input_port_read(space->machine(), "P3");
+			return space->machine().root_device().ioport("P3")->read();
 
 		case 0x3022/2:
-			return input_port_read(space->machine(), "P4");
+			return space->machine().root_device().ioport("P4")->read();
 
 		case 0x3024/2:
-			return input_port_read(space->machine(), "P34START");
+			return space->machine().root_device().ioport("P34START")->read();
 	}
 	return segaic16_open_bus_r(space, 0, mem_mask);
 }
@@ -494,19 +494,19 @@
 	switch (offset)
 	{
 		case 0x3010/2:
-			state->m_lghost_value = 255 - input_port_read(space->machine(), "GUNY1");
+			state->m_lghost_value = 255 - state->ioport("GUNY1")->read();
 			break;
 
 		case 0x3012/2:
-			state->m_lghost_value = input_port_read(space->machine(), "GUNX1");
+			state->m_lghost_value = state->ioport("GUNX1")->read();
 			break;
 
 		case 0x3014/2:
-			state->m_lghost_value = 255 - input_port_read(space->machine(), state->m_lghost_select ? "GUNY3" : "GUNY2");
+			state->m_lghost_value = 255 - state->ioport(state->m_lghost_select ? "GUNY3" : "GUNY2")->read();
 			break;
 
 		case 0x3016/2:
-			state->m_lghost_value = input_port_read(space->machine(), state->m_lghost_select ? "GUNX3" : "GUNX2");
+			state->m_lghost_value = state->ioport(state->m_lghost_select ? "GUNX3" : "GUNX2")->read();
 			break;
 
 		case 0x3020/2:
@@ -530,22 +530,22 @@
 	switch (offset)
 	{
 		case 0x3000/2:
-			return (input_port_read(space->machine(), "TRACKX1") - state->m_wwally_last_x[0]) & 0xff;
+			return (state->ioport("TRACKX1")->read() - state->m_wwally_last_x[0]) & 0xff;
 
 		case 0x3004/2:
-			return (input_port_read(space->machine(), "TRACKY1") - state->m_wwally_last_y[0]) & 0xff;
+			return (state->ioport("TRACKY1")->read() - state->m_wwally_last_y[0]) & 0xff;
 
 		case 0x3008/2:
-			return (input_port_read(space->machine(), "TRACKX2") - state->m_wwally_last_x[1]) & 0xff;
+			return (state->ioport("TRACKX2")->read() - state->m_wwally_last_x[1]) & 0xff;
 
 		case 0x300c/2:
-			return (input_port_read(space->machine(), "TRACKY2") - state->m_wwally_last_y[1]) & 0xff;
+			return (state->ioport("TRACKY2")->read() - state->m_wwally_last_y[1]) & 0xff;
 
 		case 0x3010/2:
-			return (input_port_read(space->machine(), "TRACKX3") - state->m_wwally_last_x[2]) & 0xff;
+			return (state->ioport("TRACKX3")->read() - state->m_wwally_last_x[2]) & 0xff;
 
 		case 0x3014/2:
-			return (input_port_read(space->machine(), "TRACKY3") - state->m_wwally_last_y[2]) & 0xff;
+			return (state->ioport("TRACKY3")->read() - state->m_wwally_last_y[2]) & 0xff;
 	}
 	return segaic16_open_bus_r(space, 0, mem_mask);
 }
@@ -559,20 +559,20 @@
 	{
 		case 0x3000/2:
 		case 0x3004/2:
-			state->m_wwally_last_x[0] = input_port_read(space->machine(), "TRACKX1");
-			state->m_wwally_last_y[0] = input_port_read(space->machine(), "TRACKY1");
+			state->m_wwally_last_x[0] = state->ioport("TRACKX1")->read();
+			state->m_wwally_last_y[0] = state->ioport("TRACKY1")->read();
 			break;
 
 		case 0x3008/2:
 		case 0x300c/2:
-			state->m_wwally_last_x[1] = input_port_read(space->machine(), "TRACKX2");
-			state->m_wwally_last_y[1] = input_port_read(space->machine(), "TRACKY2");
+			state->m_wwally_last_x[1] = state->ioport("TRACKX2")->read();
+			state->m_wwally_last_y[1] = state->ioport("TRACKY2")->read();
 			break;
 
 		case 0x3010/2:
 		case 0x3014/2:
-			state->m_wwally_last_x[2] = input_port_read(space->machine(), "TRACKX3");
-			state->m_wwally_last_y[2] = input_port_read(space->machine(), "TRACKY3");
+			state->m_wwally_last_x[2] = state->ioport("TRACKX3")->read();
+			state->m_wwally_last_y[2] = state->ioport("TRACKY3")->read();
 			break;
 	}
 }
diff -Nru src-old/mame/drivers/segas24.c src/mame/drivers/segas24.c
--- src-old/mame/drivers/segas24.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/segas24.c	2012-05-03 11:00:08.000000000 +0200
@@ -515,19 +515,19 @@
 	switch(port)
 	{
 	case 0:
-		return input_port_read(machine(), "P1");
+		return ioport("P1")->read();
 	case 1:
-		return input_port_read(machine(), "P2");
+		return ioport("P2")->read();
 	case 2:
-		return input_port_read_safe(machine(), "P3", 0xff);
+		return ioport("P3")->read_safe(0xff);
 	case 3:
 		return 0xff;
 	case 4:
-		return input_port_read(machine(), "SERVICE");
+		return ioport("SERVICE")->read();
 	case 5: // Dip switches
-		return input_port_read(machine(), "COINAGE");
+		return ioport("COINAGE")->read();
 	case 6:
-		return input_port_read(machine(), "DSW");
+		return ioport("DSW")->read();
 	case 7: // DAC
 		return 0xff;
 	}
@@ -541,20 +541,20 @@
 	case 0:
 	{
 		static const UINT8 pos[16] = { 0, 1, 3, 2, 6, 4, 12, 8, 9 };
-		return (input_port_read(machine(), "P1") & 0xf) | ((~pos[input_port_read(machine(), "PADDLE")>>4]<<4) & 0xf0);
+		return (ioport("P1")->read() & 0xf) | ((~pos[ioport("PADDLE")->read()>>4]<<4) & 0xf0);
 	}
 	case 1:
-		return input_port_read(machine(), "P2");
+		return ioport("P2")->read();
 	case 2:
 		return 0xff;
 	case 3:
 		return 0xff;
 	case 4:
-		return input_port_read(machine(), "SERVICE");
+		return ioport("SERVICE")->read();
 	case 5: // Dip switches
-		return input_port_read(machine(), "COINAGE");
+		return ioport("COINAGE")->read();
 	case 6:
-		return input_port_read(machine(), "DSW");
+		return ioport("DSW")->read();
 	case 7: // DAC
 		return 0xff;
 	}
@@ -573,15 +573,15 @@
 	case 1:
 		return 0xff;
 	case 2:
-		return input_port_read(machine(), keynames[cur_input_line]);
+		return ioport(keynames[cur_input_line])->read();
 	case 3:
 		return 0xff;
 	case 4:
-		return input_port_read(machine(), "SERVICE");
+		return ioport("SERVICE")->read();
 	case 5: // Dip switches
-		return input_port_read(machine(), "COINAGE");
+		return ioport("COINAGE")->read();
 	case 6:
-		return input_port_read(machine(), "DSW");
+		return ioport("DSW")->read();
 	case 7: // DAC
 		return 0xff;
 	}
@@ -626,7 +626,7 @@
 	if(ACCESSING_BITS_0_7)
 	{
 		data &= 3;
-		hotrod_ctrl_cur = input_port_read_safe(machine(), portnames[data], 0);
+		hotrod_ctrl_cur = ioport(portnames[data])->read_safe(0);
 	}
 }
 
@@ -638,21 +638,21 @@
 		{
 			// Steering dials
 			case 0:
-				return input_port_read_safe(machine(), "DIAL1", 0) & 0xff;
+				return ioport("DIAL1")->read_safe(0) & 0xff;
 			case 1:
-				return input_port_read_safe(machine(), "DIAL1", 0) >> 8;
+				return ioport("DIAL1")->read_safe(0) >> 8;
 			case 2:
-				return input_port_read_safe(machine(), "DIAL2", 0) & 0xff;
+				return ioport("DIAL2")->read_safe(0) & 0xff;
 			case 3:
-				return input_port_read_safe(machine(), "DIAL2", 0) >> 8;
+				return ioport("DIAL2")->read_safe(0) >> 8;
 			case 4:
-				return input_port_read_safe(machine(), "DIAL3", 0) & 0xff;
+				return ioport("DIAL3")->read_safe(0) & 0xff;
 			case 5:
-				return input_port_read_safe(machine(), "DIAL3", 0) >> 8;
+				return ioport("DIAL3")->read_safe(0) >> 8;
 			case 6:
-				return input_port_read_safe(machine(), "DIAL4", 0) & 0xff;
+				return ioport("DIAL4")->read_safe(0) & 0xff;
 			case 7:
-				return input_port_read_safe(machine(), "DIAL4", 0) >> 8;
+				return ioport("DIAL4")->read_safe(0) >> 8;
 
 			case 8:
 			{
@@ -1262,7 +1262,7 @@
 {
 	segas24_state *state = machine.driver_data<segas24_state>();
 	if (state->track_size)
-		machine.device<nvram_device>("floppy_nvram")->set_base(machine.root_device().memregion("floppy")->base(), 2*state->track_size);
+		machine.device<nvram_device>("floppy_nvram")->set_base(state->memregion("floppy")->base(), 2*state->track_size);
 
 	UINT8 *usr1 = state->memregion("romboard")->base();
 	if (usr1)
@@ -1771,19 +1771,19 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(3)
 
 	PORT_START("SERVICE")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN4 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN3 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN4 ) PORT_CONDITION("DSW",0x08,EQUALS,0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN3 ) PORT_CONDITION("DSW",0x08,EQUALS,0x00)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CONDITION("DSW",0x08,EQUALS,0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CONDITION("DSW",0x08,EQUALS,0x00)
 	/* alt coin mode */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x08)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x08)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x08)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW",0x08,PORTCOND_EQUALS,0x08)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CONDITION("DSW",0x08,EQUALS,0x08)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CONDITION("DSW",0x08,EQUALS,0x08)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW",0x08,EQUALS,0x08)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED ) PORT_CONDITION("DSW",0x08,EQUALS,0x08)
 
 
 	PORT_INCLUDE( system24_DSW )
diff -Nru src-old/mame/drivers/segas32.c src/mame/drivers/segas32.c
--- src-old/mame/drivers/segas32.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/segas32.c	2012-05-03 11:00:08.000000000 +0200
@@ -613,7 +613,7 @@
 				return state->m_misc_io_data[which][offset];
 
 			/* otherwise, return an input port */
-			return input_port_read_safe(space->machine(), portnames[which][offset], 0xffff);
+			return state->ioport(portnames[which][offset])->read_safe(0xffff);
 
 		/* 'SEGA' protection */
 		case 0x10/2:
@@ -885,7 +885,7 @@
 		case 0x12/2:
 		case 0x14/2:
 		case 0x16/2:
-			m_analog_value[offset & 3] = input_port_read_safe(machine(), names[offset & 3], 0);
+			m_analog_value[offset & 3] = ioport(names[offset & 3])->read_safe(0);
 			return;
 	}
 	logerror("%06X:unknown analog_custom_io_w(%X) = %04X & %04X\n", cpu_get_pc(&space.device()), offset*2, data, mem_mask);
@@ -901,7 +901,7 @@
 		case 0x22/2:
 		case 0x24/2:
 		case 0x26/2:
-			return input_port_read_safe(machine(), names[offset & 3], 0xffff);
+			return ioport(names[offset & 3])->read_safe(0xffff);
 	}
 
 	logerror("%06X:unknown extra_custom_io_r(%X) & %04X\n", cpu_get_pc(&space.device()), offset*2, mem_mask);
@@ -918,7 +918,7 @@
 		case 0x12/2:
 		case 0x14/2:
 		case 0x16/2:
-			m_analog_value[offset & 3] = input_port_read_safe(machine(), names[m_analog_bank * 4 + (offset & 3)], 0);
+			m_analog_value[offset & 3] = ioport(names[m_analog_bank * 4 + (offset & 3)])->read_safe(0);
 			return;
 
 		case 0x20/2:
@@ -941,7 +941,7 @@
 		case 0x0c/2:
 		case 0x10/2:
 		case 0x14/2:
-			return (UINT8)(input_port_read(machine(), names[offset/2]) - m_sonic_last[offset/2]);
+			return (UINT8)(ioport(names[offset/2])->read() - m_sonic_last[offset/2]);
 	}
 
 	logerror("%06X:unknown sonic_custom_io_r(%X) & %04X\n", cpu_get_pc(&space.device()), offset*2, mem_mask);
@@ -958,8 +958,8 @@
 		case 0x00/2:
 		case 0x08/2:
 		case 0x10/2:
-			m_sonic_last[offset/2 + 0] = input_port_read(machine(), names[offset/2 + 0]);
-			m_sonic_last[offset/2 + 1] = input_port_read(machine(), names[offset/2 + 1]);
+			m_sonic_last[offset/2 + 0] = ioport(names[offset/2 + 0])->read();
+			m_sonic_last[offset/2 + 1] = ioport(names[offset/2 + 1])->read();
 			return;
 	}
 
diff -Nru src-old/mame/drivers/segaxbd.c src/mame/drivers/segaxbd.c
--- src-old/mame/drivers/segaxbd.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/segaxbd.c	2012-05-03 11:00:08.000000000 +0200
@@ -451,7 +451,7 @@
 	int which = (state->m_iochip_regs[0][2] >> 2) & 7;
 
 	/* on the write, latch the selected input port and stash the value */
-	int value = input_port_read_safe(space->machine(), ports[which], 0x0010);
+	int value = state->ioport(ports[which])->read_safe(0x0010);
 
 	/* reverse some port values */
 	if (state->m_adc_reverse[which])
@@ -512,11 +512,11 @@
                 D6: /INTR of ADC0804
                 D5-D0: CN C pin 24-19 (switch state 0= open, 1= closed)
             */
-			return iochip_r(space->machine(), 0, 0, input_port_read(space->machine(), "IO0PORTA"));
+			return iochip_r(space->machine(), 0, 0, space->machine().root_device().ioport("IO0PORTA")->read());
 
 		case 1:
 			/* I/O port: CN C pins 17,15,13,11,9,7,5,3 */
-			return iochip_r(space->machine(), 0, 1, input_port_read(space->machine(), "IO0PORTB"));
+			return iochip_r(space->machine(), 0, 1, space->machine().root_device().ioport("IO0PORTB")->read());
 
 		case 2:
 			/* Output port */
@@ -588,19 +588,19 @@
 	{
 		case 0:
 			/* Input port: switches, CN D pin A1-8 (switch state 1= open, 0= closed) */
-			return iochip_r(space->machine(), 1, 0, input_port_read(space->machine(), "IO1PORTA"));
+			return iochip_r(space->machine(), 1, 0, space->machine().root_device().ioport("IO1PORTA")->read());
 
 		case 1:
 			/* Input port: switches, CN D pin A9-16 (switch state 1= open, 0= closed) */
-			return iochip_r(space->machine(), 1, 1, input_port_read(space->machine(), "IO1PORTB"));
+			return iochip_r(space->machine(), 1, 1, space->machine().root_device().ioport("IO1PORTB")->read());
 
 		case 2:
 			/* Input port: DIP switches (1= off, 0= on) */
-			return iochip_r(space->machine(), 1, 2, input_port_read(space->machine(), "IO1PORTC"));
+			return iochip_r(space->machine(), 1, 2, space->machine().root_device().ioport("IO1PORTC")->read());
 
 		case 3:
 			/* Input port: DIP switches (1= off, 0= on) */
-			return iochip_r(space->machine(), 1, 3, input_port_read(space->machine(), "IO1PORTD"));
+			return iochip_r(space->machine(), 1, 3, space->machine().root_device().ioport("IO1PORTD")->read());
 
 		case 4:
 			/* Unused */
diff -Nru src-old/mame/drivers/segaybd.c src/mame/drivers/segaybd.c
--- src-old/mame/drivers/segaybd.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/segaybd.c	2012-05-03 11:00:08.000000000 +0200
@@ -287,7 +287,7 @@
 				return state->m_misc_io_data[offset];
 
 			/* otherwise, return an input port */
-			return input_port_read(space->machine(), portnames[offset]);
+			return space->machine().root_device().ioport(portnames[offset])->read();
 
 		/* 'SEGA' protection */
 		case 0x10/2:
@@ -403,7 +403,7 @@
 	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	static const char *const ports[] = { "ADC0", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6" };
 	int selected = ((offset & 3) == 3) ? (3 + (state->m_misc_io_data[0x08/2] & 3)) : (offset & 3);
-	int value = input_port_read_safe(space->machine(), ports[selected], 0xff);
+	int value = state->ioport(ports[selected])->read_safe(0xff);
 
 	state->m_analog_data[offset & 3] = value;
 }
diff -Nru src-old/mame/drivers/seibuspi.c src/mame/drivers/seibuspi.c
--- src-old/mame/drivers/seibuspi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/seibuspi.c	2012-05-03 11:00:08.000000000 +0200
@@ -917,7 +917,7 @@
 {
 	if( ACCESSING_BITS_0_7 )
 	{
-		return input_port_read(machine(), "INPUTS");
+		return ioport("INPUTS")->read();
 	}
 	return 0xffffffff;
 }
@@ -926,7 +926,7 @@
 {
 	if( ACCESSING_BITS_0_7 )
 	{
-		return input_port_read(machine(), "SYSTEM");
+		return ioport("SYSTEM")->read();
 	}
 	return 0xffffffff;
 }
@@ -936,17 +936,17 @@
 	switch(m_ejsakura_input_port)
 	{
 		case 0x01:
-			return input_port_read(machine(), "INPUT01");
+			return ioport("INPUT01")->read();
 		case 0x02:
-			return input_port_read(machine(), "INPUT02");
+			return ioport("INPUT02")->read();
 		case 0x04:
-			return input_port_read(machine(), "INPUT04");
+			return ioport("INPUT04")->read();
 		case 0x08:
-			return input_port_read(machine(), "INPUT08");
+			return ioport("INPUT08")->read();
 		case 0x10:
-			return input_port_read(machine(), "INPUT10");
+			return ioport("INPUT10")->read();
 		default:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 	}
 	return 0xffffffff;
 }
@@ -985,12 +985,12 @@
 
 READ8_MEMBER(seibuspi_state::z80_jp1_r)
 {
-	return input_port_read(machine(), "JP1");
+	return ioport("JP1")->read();
 }
 
 READ8_MEMBER(seibuspi_state::z80_coin_r)
 {
-	return input_port_read(machine(), "COIN");
+	return ioport("COIN")->read();
 }
 
 READ32_MEMBER(seibuspi_state::soundrom_r)
@@ -1289,7 +1289,7 @@
 CUSTOM_INPUT_MEMBER(seibuspi_state::ejanhs_encode)
 {
 	static const UINT8 encoding[] = { 0x02, 0x10, 0x03, 0x18, 0x04, 0x20, 0x05, 0x28, 0x06, 0x30, 0x07 };
-	input_port_value state = input_port_read(machine(), (const char *)param);
+	ioport_value state = ioport((const char *)param)->read();
 	int bit;
 
 	for (bit = 0; bit < ARRAY_LENGTH(encoding); bit++)
@@ -1812,7 +1812,7 @@
 {
 	seibuspi_state *state = machine.driver_data<seibuspi_state>();
 	int i;
-	UINT8 *sound = machine.root_device().memregion("ymf")->base();
+	UINT8 *sound = state->memregion("ymf")->base();
 
 	UINT8 *rombase = state->memregion("user1")->base();
 	UINT8 flash_data = rombase[0x1ffffc];
@@ -2057,7 +2057,7 @@
 		device_spin_until_interrupt(&space.device()); // idle
 		// Hack to enter test mode
 		r = m_spimainram[(0x002894c-0x800)/4] & (~0x400);
-		return r | (((input_port_read(machine(), "SYSTEM") ^ 0xff)<<8) & 0x400);
+		return r | (((ioport("SYSTEM")->read() ^ 0xff)<<8) & 0x400);
 	}
 
 	/* rfjetj */
@@ -2075,8 +2075,8 @@
 	state->m_flash[0] = machine.device<intel_e28f008sa_device>("flash0");
 	state->m_flash[1] = machine.device<intel_e28f008sa_device>("flash1");
 
-	seibuspi_text_decrypt(machine.root_device().memregion("gfx1")->base());
-	seibuspi_bg_decrypt(machine.root_device().memregion("gfx2")->base(), machine.root_device().memregion("gfx2")->bytes());
+	seibuspi_text_decrypt(state->memregion("gfx1")->base());
+	seibuspi_bg_decrypt(state->memregion("gfx2")->base(), state->memregion("gfx2")->bytes());
 	seibuspi_sprite_decrypt(state->memregion("gfx3")->base(), 0x400000);
 }
 
@@ -2146,8 +2146,8 @@
 	state->m_flash[1] = machine.device<intel_e28f008sa_device>("flash1");
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x0282AC, 0x0282AF, read32_delegate(FUNC(seibuspi_state::rf2_speedup_r),state));
-	seibuspi_rise10_text_decrypt(machine.root_device().memregion("gfx1")->base());
-	seibuspi_rise10_bg_decrypt(machine.root_device().memregion("gfx2")->base(), machine.root_device().memregion("gfx2")->bytes());
+	seibuspi_rise10_text_decrypt(state->memregion("gfx1")->base());
+	seibuspi_rise10_bg_decrypt(state->memregion("gfx2")->base(), state->memregion("gfx2")->bytes());
 	seibuspi_rise10_sprite_decrypt(state->memregion("gfx3")->base(), 0x600000);
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_write_handler(0x560, 0x563, write32_delegate(FUNC(seibuspi_state::sprite_dma_start_w),state));
@@ -2171,8 +2171,8 @@
 	state->m_flash[1] = machine.device<intel_e28f008sa_device>("flash1");
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_read_handler(0x002894c, 0x002894f, read32_delegate(FUNC(seibuspi_state::rfjet_speedup_r),state));
-	seibuspi_rise11_text_decrypt(machine.root_device().memregion("gfx1")->base());
-	seibuspi_rise11_bg_decrypt(machine.root_device().memregion("gfx2")->base(), machine.root_device().memregion("gfx2")->bytes());
+	seibuspi_rise11_text_decrypt(state->memregion("gfx1")->base());
+	seibuspi_rise11_bg_decrypt(state->memregion("gfx2")->base(), state->memregion("gfx2")->bytes());
 	seibuspi_rise11_sprite_decrypt_rfjet(state->memregion("gfx3")->base(), 0x800000);
 
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_write_handler(0x560, 0x563, write32_delegate(FUNC(seibuspi_state::sprite_dma_start_w),state));
diff -Nru src-old/mame/drivers/seicross.c src/mame/drivers/seicross.c
--- src-old/mame/drivers/seicross.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/seicross.c	2012-05-03 11:00:08.000000000 +0200
@@ -85,7 +85,7 @@
 {
 	seicross_state *state = device->machine().driver_data<seicross_state>();
 
-	return (state->m_portb & 0x9f) | (input_port_read_safe(device->machine(), "DEBUG", 0) & 0x60);
+	return (state->m_portb & 0x9f) | (state->ioport("DEBUG")->read_safe(0) & 0x60);
 }
 
 static WRITE8_DEVICE_HANDLER( friskyt_portB_w )
diff -Nru src-old/mame/drivers/sengokmj.c src/mame/drivers/sengokmj.c
--- src-old/mame/drivers/sengokmj.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/drivers/sengokmj.c	2012-05-03 11:00:08.000000000 +0200
@@ -80,12 +80,12 @@
 {
 	switch(m_sengokumj_mux_data)
 	{
-		case 0x0100: return input_port_read(machine(), "KEY0");
-		case 0x0200: return input_port_read(machine(), "KEY1");
-		case 0x0400: return input_port_read(machine(), "KEY2");
-		case 0x0800: return input_port_read(machine(), "KEY3");
-		case 0x1000: return input_port_read(machine(), "KEY4");
-		case 0x2000: return input_port_read(machine(), "UNUSED");
+		case 0x0100: return ioport("KEY0")->read();
+		case 0x0200: return ioport("KEY1")->read();
+		case 0x0400: return ioport("KEY2")->read();
+		case 0x0800: return ioport("KEY3")->read();
+		case 0x1000: return ioport("KEY4")->read();
+		case 0x2000: return ioport("UNUSED")->read();
 	}
 
 	return 0xffff;
@@ -111,7 +111,7 @@
 
 READ16_MEMBER(sengokmj_state::sengokmj_system_r)
 {
-	return (input_port_read(machine(), "SYSTEM") & 0xffbf) | m_hopper_io;
+	return (ioport("SYSTEM")->read() & 0xffbf) | m_hopper_io;
 }
 
 static ADDRESS_MAP_START( sengokmj_map, AS_PROGRAM, 16, sengokmj_state )
diff -Nru src-old/mame/drivers/senjyo.c src/mame/drivers/senjyo.c
--- src-old/mame/drivers/senjyo.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/senjyo.c	2012-05-03 04:25:41.000000000 +0200
@@ -667,39 +667,39 @@
 
 ROM_START( starforc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "starforc.3",   0x0000, 0x4000, CRC(8ba27691) SHA1(2b8b1e634ef5bed5c61a078e64a6dda77f84cdf5) )
-	ROM_LOAD( "starforc.2",   0x4000, 0x4000, CRC(0fc4d2d6) SHA1(0743e3928d5cc0e3f1bcdaf4b0cc83aeb7a2f7a8) )
+	ROM_LOAD( "3.3p",    0x0000, 0x4000, CRC(8ba27691) SHA1(2b8b1e634ef5bed5c61a078e64a6dda77f84cdf5) )
+	ROM_LOAD( "2.3mn",   0x4000, 0x4000, CRC(0fc4d2d6) SHA1(0743e3928d5cc0e3f1bcdaf4b0cc83aeb7a2f7a8) )
 
 	ROM_REGION( 0x10000, "sub", 0 )     /* 64k for sound board */
-	ROM_LOAD( "starforc.1",   0x0000, 0x2000, CRC(2735bb22) SHA1(1bd0558e05b41aebab3911991969512df904fea5) )
+	ROM_LOAD( "1.3hj",   0x0000, 0x2000, CRC(2735bb22) SHA1(1bd0558e05b41aebab3911991969512df904fea5) )
 
 	ROM_REGION( 0x03000, "gfx1", 0 )
-	ROM_LOAD( "starforc.7",   0x00000, 0x1000, CRC(f4803339) SHA1(a119d68c2dd1c0e191231ce77353b31f30f7aa76) )	/* fg */
-	ROM_LOAD( "starforc.8",   0x01000, 0x1000, CRC(96979684) SHA1(bb4f7d3afc8dfaa723dfb5374996cc4bfd76fa3c) )
-	ROM_LOAD( "starforc.9",   0x02000, 0x1000, CRC(eead1d5c) SHA1(7c9165ed227c5228122b494a265cbfd6e843ba61) )
+	ROM_LOAD( "7.2fh",   0x00000, 0x1000, CRC(f4803339) SHA1(a119d68c2dd1c0e191231ce77353b31f30f7aa76) )	/* fg */
+	ROM_LOAD( "8.3fh",   0x01000, 0x1000, CRC(96979684) SHA1(bb4f7d3afc8dfaa723dfb5374996cc4bfd76fa3c) )
+	ROM_LOAD( "9.3fh",   0x02000, 0x1000, CRC(eead1d5c) SHA1(7c9165ed227c5228122b494a265cbfd6e843ba61) )
 
 	ROM_REGION( 0x06000, "gfx2", 0 )
-	ROM_LOAD( "starforc.15",  0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
-	ROM_LOAD( "starforc.14",  0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
-	ROM_LOAD( "starforc.13",  0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
+	ROM_LOAD( "15.10jk", 0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
+	ROM_LOAD( "14.9jk",  0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
+	ROM_LOAD( "13.8jk",  0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
 
 	ROM_REGION( 0x06000, "gfx3", 0 )
-	ROM_LOAD( "starforc.12",  0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
-	ROM_LOAD( "starforc.11",  0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
-	ROM_LOAD( "starforc.10",  0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
+	ROM_LOAD( "12.10de", 0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
+	ROM_LOAD( "11.9de",  0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
+	ROM_LOAD( "10.8de",  0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
 
 	ROM_REGION( 0x03000, "gfx4", 0 )
-	ROM_LOAD( "starforc.18",  0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
-	ROM_LOAD( "starforc.17",  0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
-	ROM_LOAD( "starforc.16",  0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
+	ROM_LOAD( "18.10pq", 0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
+	ROM_LOAD( "17.9pq",  0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
+	ROM_LOAD( "16.8pq",  0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
 
 	ROM_REGION( 0x0c000, "gfx5", 0 )
-	ROM_LOAD( "starforc.6",   0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
-	ROM_LOAD( "starforc.5",   0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
-	ROM_LOAD( "starforc.4",   0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
+	ROM_LOAD( "6.10lm",  0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
+	ROM_LOAD( "5.9lm",   0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
+	ROM_LOAD( "4.8lm",   0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
 
 	ROM_REGION( 0x0020, "proms", 0 )	/* PROMs */
-	ROM_LOAD( "07b.bin",    0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
+	ROM_LOAD( "07b.bin", 0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
 ROM_END
 
 ROM_START( starforcb )
@@ -744,7 +744,6 @@
 	ROM_LOAD( "a18s030.7b",    0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
 ROM_END
 
-
 ROM_START( starforca )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "5.bin",   0x0000, 0x2000, CRC(7691bbd4) SHA1(efcab11ea0ed58b6a47c9d7a994c921dfaa1b47e) )
@@ -787,7 +786,6 @@
 	ROM_LOAD( "prom.bin",    0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
 ROM_END
 
-
 ROM_START( starforce )
 	ROM_REGION( 2*0x10000, "maincpu", 0 )     /* 64k for code + 64k for decrypted opcodes */
 	ROM_LOAD( "starfore.005", 0x0000, 0x2000, CRC(825f7ebe) SHA1(d63fd516e075bcc28d42189216b95bbf491a4cd1) )
@@ -799,69 +797,69 @@
 	ROM_LOAD( "starfore.000", 0x0000, 0x2000, CRC(a277c268) SHA1(99ed8439119fa4b850ad8aadb7ff3e54d4cd40be) )
 
 	ROM_REGION( 0x03000, "gfx1", 0 )
-	ROM_LOAD( "starforc.7",   0x00000, 0x1000, CRC(f4803339) SHA1(a119d68c2dd1c0e191231ce77353b31f30f7aa76) )	/* fg */
-	ROM_LOAD( "starforc.8",   0x01000, 0x1000, CRC(96979684) SHA1(bb4f7d3afc8dfaa723dfb5374996cc4bfd76fa3c) )
-	ROM_LOAD( "starforc.9",   0x02000, 0x1000, CRC(eead1d5c) SHA1(7c9165ed227c5228122b494a265cbfd6e843ba61) )
+	ROM_LOAD( "7.2fh",   0x00000, 0x1000, CRC(f4803339) SHA1(a119d68c2dd1c0e191231ce77353b31f30f7aa76) )	/* fg */
+	ROM_LOAD( "8.3fh",   0x01000, 0x1000, CRC(96979684) SHA1(bb4f7d3afc8dfaa723dfb5374996cc4bfd76fa3c) )
+	ROM_LOAD( "9.3fh",   0x02000, 0x1000, CRC(eead1d5c) SHA1(7c9165ed227c5228122b494a265cbfd6e843ba61) )
 
 	ROM_REGION( 0x06000, "gfx2", 0 )
-	ROM_LOAD( "starforc.15",  0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
-	ROM_LOAD( "starforc.14",  0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
-	ROM_LOAD( "starforc.13",  0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
+	ROM_LOAD( "15.10jk", 0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
+	ROM_LOAD( "14.9jk",  0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
+	ROM_LOAD( "13.8jk",  0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
 
 	ROM_REGION( 0x06000, "gfx3", 0 )
-	ROM_LOAD( "starforc.12",  0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
-	ROM_LOAD( "starforc.11",  0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
-	ROM_LOAD( "starforc.10",  0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
+	ROM_LOAD( "12.10de", 0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
+	ROM_LOAD( "11.9de",  0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
+	ROM_LOAD( "10.8de",  0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
 
 	ROM_REGION( 0x03000, "gfx4", 0 )
-	ROM_LOAD( "starforc.18",  0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
-	ROM_LOAD( "starforc.17",  0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
-	ROM_LOAD( "starforc.16",  0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
+	ROM_LOAD( "18.10pq", 0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
+	ROM_LOAD( "17.9pq",  0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
+	ROM_LOAD( "16.8pq",  0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
 
 	ROM_REGION( 0x0c000, "gfx5", 0 )
-	ROM_LOAD( "starforc.6",   0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
-	ROM_LOAD( "starforc.5",   0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
-	ROM_LOAD( "starforc.4",   0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
+	ROM_LOAD( "6.10lm",  0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
+	ROM_LOAD( "5.9lm",   0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
+	ROM_LOAD( "4.8lm",   0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
 
 	ROM_REGION( 0x0020, "proms", 0 )	/* PROMs */
-	ROM_LOAD( "07b.bin",    0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
+	ROM_LOAD( "07b.bin", 0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
 ROM_END
 
 ROM_START( megaforc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "mf3.bin",      0x0000, 0x4000, CRC(d3ea82ec) SHA1(e15fda65ba24517cc04abc55b5d079a33327553c) )
-	ROM_LOAD( "mf2.bin",      0x4000, 0x4000, CRC(aa320718) SHA1(cbbf8e4d06a1ecf77d776058d965afdaa7f5b47f) )
+	ROM_LOAD( "mf3.bin",  0x0000, 0x4000, CRC(d3ea82ec) SHA1(e15fda65ba24517cc04abc55b5d079a33327553c) )
+	ROM_LOAD( "mf2.bin",  0x4000, 0x4000, CRC(aa320718) SHA1(cbbf8e4d06a1ecf77d776058d965afdaa7f5b47f) )
 
 	ROM_REGION( 0x10000, "sub", 0 )     /* 64k for sound board */
-	ROM_LOAD( "starforc.1",   0x0000, 0x2000, CRC(2735bb22) SHA1(1bd0558e05b41aebab3911991969512df904fea5) )
+	ROM_LOAD( "1.3hj",    0x0000, 0x2000, CRC(2735bb22) SHA1(1bd0558e05b41aebab3911991969512df904fea5) )
 
 	ROM_REGION( 0x03000, "gfx1", 0 )
-	ROM_LOAD( "mf7.bin",      0x00000, 0x1000, CRC(43ef8d20) SHA1(07ebe3e10fa56b671788a122cdc02e661b624f40) )	/* fg */
-	ROM_LOAD( "mf8.bin",      0x01000, 0x1000, CRC(c36fb746) SHA1(01960e068046bcc0e3e9370fdfe73f9fd64491ae) )
-	ROM_LOAD( "mf9.bin",      0x02000, 0x1000, CRC(62e7c9ec) SHA1(24dd1de3e268865c36c732714dc257c58cb88d67) )
+	ROM_LOAD( "mf7.bin",  0x00000, 0x1000, CRC(43ef8d20) SHA1(07ebe3e10fa56b671788a122cdc02e661b624f40) )	/* fg */
+	ROM_LOAD( "mf8.bin",  0x01000, 0x1000, CRC(c36fb746) SHA1(01960e068046bcc0e3e9370fdfe73f9fd64491ae) )
+	ROM_LOAD( "mf9.bin",  0x02000, 0x1000, CRC(62e7c9ec) SHA1(24dd1de3e268865c36c732714dc257c58cb88d67) )
 
 	ROM_REGION( 0x06000, "gfx2", 0 )
-	ROM_LOAD( "starforc.15",  0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
-	ROM_LOAD( "starforc.14",  0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
-	ROM_LOAD( "starforc.13",  0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
+	ROM_LOAD( "15.10jk",  0x00000, 0x2000, CRC(c3bda12f) SHA1(3748ea8e34222a31a365a02ec77430f268b0b397) )	/* bg1 */
+	ROM_LOAD( "14.9jk",   0x02000, 0x2000, CRC(9e9384fe) SHA1(3aaa9cc64ef3775325f64733da4f6c328abf6514) )
+	ROM_LOAD( "13.8jk",   0x04000, 0x2000, CRC(84603285) SHA1(f4d6dfa3968fbd8ebf1a6451d5ea1821d65d9b49) )
 
 	ROM_REGION( 0x06000, "gfx3", 0 )
-	ROM_LOAD( "starforc.12",  0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
-	ROM_LOAD( "starforc.11",  0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
-	ROM_LOAD( "starforc.10",  0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
+	ROM_LOAD( "12.10de",  0x00000, 0x2000, CRC(fdd9e38b) SHA1(3766835d9e9fc7e5dd99521e7303562029b78a65) )	/* bg2 */
+	ROM_LOAD( "11.9de",   0x02000, 0x2000, CRC(668aea14) SHA1(62eb0df48f2f0c5778bb230cc3bf0b8eb3b4e3f8) )
+	ROM_LOAD( "10.8de",   0x04000, 0x2000, CRC(c62a19c1) SHA1(9ce0e29630d3c8cba4db4cff333b250481348968) )
 
 	ROM_REGION( 0x03000, "gfx4", 0 )
-	ROM_LOAD( "starforc.18",  0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
-	ROM_LOAD( "starforc.17",  0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
-	ROM_LOAD( "starforc.16",  0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
+	ROM_LOAD( "18.10pq",  0x00000, 0x1000, CRC(6455c3ad) SHA1(b163ccd3dc26ccfa8be1d16d52e17bc660ff84e3) )	/* bg3 */
+	ROM_LOAD( "17.9pq",   0x01000, 0x1000, CRC(68c60d0f) SHA1(1152ba0c274ecadb534133a860bbc8a93577dcf2) )
+	ROM_LOAD( "16.8pq",   0x02000, 0x1000, CRC(ce20b469) SHA1(60177a669d9c8cbeedd03ca5e2edf3f589c1c815) )
 
 	ROM_REGION( 0x0c000, "gfx5", 0 )
-	ROM_LOAD( "starforc.6",   0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
-	ROM_LOAD( "starforc.5",   0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
-	ROM_LOAD( "starforc.4",   0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
+	ROM_LOAD( "6.10lm",   0x00000, 0x4000, CRC(5468a21d) SHA1(4a1196d4cfb99616efdac9b3927609a85c6f1758) )	/* sprites */
+	ROM_LOAD( "5.9lm",    0x04000, 0x4000, CRC(f71717f8) SHA1(bf673571f772d8e0eddae89c00f31390c49a25d2) )
+	ROM_LOAD( "4.8lm",    0x08000, 0x4000, CRC(dd9d68a4) SHA1(34c60d2b34c7980bf65a5ebadb9c73f89128141f) )
 
 	ROM_REGION( 0x0020, "proms", 0 )	/* PROMs */
-	ROM_LOAD( "07b.bin",    0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
+	ROM_LOAD( "07b.bin",  0x0000, 0x0020, CRC(68db8300) SHA1(33cd6b5ed92d7b73a708f2e4b12b6e7f6496d0c6) )	/* unknown - timing? */
 ROM_END
 
 ROM_START( baluba )
@@ -947,4 +945,3 @@
 GAME( 1984, starforca,starforc, senjyo,  starforc, starfora, ROT90, "Tehkan", "Star Force (encrypted, set 2)", 0 )
 GAME( 1985, megaforc, starforc, senjyo,  starforc, starforc, ROT90, "Tehkan (Video Ware license)", "Mega Force", 0 )
 GAME( 1986, baluba,   0,        senjyo,  baluba,   starforc, ROT90, "Able Corp, Ltd.", "Baluba-louk no Densetsu (Japan)", 0 )
-
diff -Nru src-old/mame/drivers/seta.c src/mame/drivers/seta.c
--- src-old/mame/drivers/seta.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/seta.c	2012-05-03 11:00:08.000000000 +0200
@@ -1517,7 +1517,7 @@
 /* DSW reading for 16 bit CPUs */
 READ16_MEMBER(seta_state::seta_dsw_r)
 {
-	UINT16 dsw = input_port_read(machine(), "DSW");
+	UINT16 dsw = ioport("DSW")->read();
 	if (offset == 0)	return (dsw >> 8) & 0xff;
 	else				return (dsw >> 0) & 0xff;
 }
@@ -1527,12 +1527,12 @@
 
 static READ8_DEVICE_HANDLER( dsw1_r )
 {
-	return (input_port_read(device->machine(), "DSW") >> 8) & 0xff;
+	return (device->machine().root_device().ioport("DSW")->read() >> 8) & 0xff;
 }
 
 static READ8_DEVICE_HANDLER( dsw2_r )
 {
-	return (input_port_read(device->machine(), "DSW") >> 0) & 0xff;
+	return (device->machine().root_device().ioport("DSW")->read() >> 0) & 0xff;
 }
 
 
@@ -1628,15 +1628,15 @@
 
 READ16_MEMBER(seta_state::calibr50_ip_r)
 {
-	int dir1 = input_port_read(machine(), "ROT1");	// analog port
-	int dir2 = input_port_read(machine(), "ROT2");	// analog port
+	int dir1 = ioport("ROT1")->read();	// analog port
+	int dir2 = ioport("ROT2")->read();	// analog port
 
 	switch (offset)
 	{
-		case 0x00/2:	return input_port_read(machine(), "P1");	// p1
-		case 0x02/2:	return input_port_read(machine(), "P2");	// p2
+		case 0x00/2:	return ioport("P1")->read();	// p1
+		case 0x02/2:	return ioport("P2")->read();	// p2
 
-		case 0x08/2:	return input_port_read(machine(), "COINS");	// Coins
+		case 0x08/2:	return ioport("COINS")->read();	// Coins
 
 		case 0x10/2:	return (dir1 & 0xff);		// lower 8 bits of p1 rotation
 		case 0x12/2:	return (dir1 >> 8);			// upper 4 bits of p1 rotation
@@ -1691,10 +1691,10 @@
 {
 	switch (offset)
 	{
-		case 0/2:	return (input_port_read(machine(), "DSW") >>  8) & 0xf;
-		case 2/2:	return (input_port_read(machine(), "DSW") >> 12) & 0xf;
-		case 4/2:	return (input_port_read(machine(), "DSW") >>  0) & 0xf;
-		case 6/2:	return (input_port_read(machine(), "DSW") >>  4) & 0xf;
+		case 0/2:	return (ioport("DSW")->read() >>  8) & 0xf;
+		case 2/2:	return (ioport("DSW")->read() >> 12) & 0xf;
+		case 4/2:	return (ioport("DSW")->read() >>  0) & 0xf;
+		case 6/2:	return (ioport("DSW")->read() >>  4) & 0xf;
 	}
 	return 0;
 }
@@ -1705,8 +1705,8 @@
 
 	switch (offset)
 	{
-		case 0/2:	return (input_port_read(machine(), portx_name[m_usclssic_port_select]) >> 0) & 0xff;
-		case 2/2:	return (input_port_read(machine(), portx_name[m_usclssic_port_select]) >> 8) & 0xff;
+		case 0/2:	return (ioport(portx_name[m_usclssic_port_select])->read() >> 0) & 0xff;
+		case 2/2:	return (ioport(portx_name[m_usclssic_port_select])->read() >> 8) & 0xff;
 	}
 	return 0;
 }
@@ -1717,8 +1717,8 @@
 
 	switch (offset)
 	{
-		case 0/2:	return (input_port_read(machine(), porty_name[m_usclssic_port_select]) >> 0) & 0xff;
-		case 2/2:	return (input_port_read(machine(), porty_name[m_usclssic_port_select]) >> 8) & 0xff;
+		case 0/2:	return (ioport(porty_name[m_usclssic_port_select])->read() >> 0) & 0xff;
+		case 2/2:	return (ioport(porty_name[m_usclssic_port_select])->read() >> 8) & 0xff;
 	}
 	return 0;
 }
@@ -1866,7 +1866,7 @@
 {
 	static const char *const portnames[] = { "GUNX1", "GUNY1", "GUNX2", "GUNY2" };
 
-	int data = input_port_read(machine(), portnames[m_gun_input_src]);	// Input Ports 5-8
+	int data = ioport(portnames[m_gun_input_src])->read();	// Input Ports 5-8
 	return (data >> m_gun_input_bit) & 1;
 }
 
@@ -2076,7 +2076,7 @@
 
 READ16_MEMBER(seta_state::keroppi_coin_r)
 {
-	UINT16 result = input_port_read(machine(), "COINS");
+	UINT16 result = ioport("COINS")->read();
 
 	if (m_keroppi_prize_hop == 2)
 	{
@@ -2393,10 +2393,10 @@
 READ16_MEMBER(seta_state::krzybowl_input_r)
 {
 	// analog ports
-	int dir1x = input_port_read(machine(), "TRACK1_X") & 0xfff;
-	int dir1y = input_port_read(machine(), "TRACK1_Y") & 0xfff;
-	int dir2x = input_port_read(machine(), "TRACK2_X") & 0xfff;
-	int dir2y = input_port_read(machine(), "TRACK2_Y") & 0xfff;
+	int dir1x = ioport("TRACK1_X")->read() & 0xfff;
+	int dir1y = ioport("TRACK1_Y")->read() & 0xfff;
+	int dir2x = ioport("TRACK2_X")->read() & 0xfff;
+	int dir2y = ioport("TRACK2_Y")->read() & 0xfff;
 
 	switch (offset)
 	{
@@ -2567,9 +2567,9 @@
 
 	switch( offset )
 	{
-		case 0x00/2:	return input_port_read(machine(), keynames[i]);
+		case 0x00/2:	return ioport(keynames[i])->read();
 		case 0x02/2:	return 0xffff;
-		case 0x04/2:	return input_port_read(machine(), "COINS");
+		case 0x04/2:	return ioport("COINS")->read();
 //      case 0x06/2:
 		case 0x08/2:	return 0xffff;
 
@@ -2838,9 +2838,9 @@
 READ16_MEMBER(seta_state::inttoote_dsw_r)
 {
 	int shift = offset * 4;
-	return	((((input_port_read(machine(), "DSW1") >> shift)       & 0xf)) << 0) |
-			((((input_port_read(machine(), "DSW2_3") >> shift)     & 0xf)) << 4) |
-			((((input_port_read(machine(), "DSW2_3") >> (shift+8)) & 0xf)) << 8) ;
+	return	((((ioport("DSW1")->read() >> shift)       & 0xf)) << 0) |
+			((((ioport("DSW2_3")->read() >> shift)     & 0xf)) << 4) |
+			((((ioport("DSW2_3")->read() >> (shift+8)) & 0xf)) << 8) ;
 }
 
 READ16_MEMBER(seta_state::inttoote_key_r)
@@ -2848,11 +2848,11 @@
 
 	switch( *m_inttoote_key_select )
 	{
-		case 0x08:	return input_port_read(machine(), "BET0");
-		case 0x10:	return input_port_read(machine(), "BET1");
-		case 0x20:	return input_port_read(machine(), "BET2");
-		case 0x40:	return input_port_read(machine(), "BET3");
-		case 0x80:	return input_port_read(machine(), "BET4");
+		case 0x08:	return ioport("BET0")->read();
+		case 0x10:	return ioport("BET1")->read();
+		case 0x20:	return ioport("BET2")->read();
+		case 0x40:	return ioport("BET3")->read();
+		case 0x80:	return ioport("BET4")->read();
 	}
 
 	logerror("%06X: unknown read, select = %04x\n",cpu_get_pc(&space.device()), *m_inttoote_key_select);
@@ -2905,11 +2905,11 @@
 
 	switch( m_jockeyc_key_select )
 	{
-		case 0x08:	return input_port_read(machine(), "BET0");
-		case 0x10:	return input_port_read(machine(), "BET1");
-		case 0x20:	return input_port_read(machine(), "BET2");
-		case 0x40:	return input_port_read(machine(), "BET3");
-		case 0x80:	return input_port_read(machine(), "BET4");
+		case 0x08:	return ioport("BET0")->read();
+		case 0x10:	return ioport("BET1")->read();
+		case 0x20:	return ioport("BET2")->read();
+		case 0x40:	return ioport("BET3")->read();
+		case 0x80:	return ioport("BET4")->read();
 	}
 
 	return 0xffff;
@@ -3037,21 +3037,21 @@
 
 READ8_MEMBER(seta_state::downtown_ip_r)
 {
-	int dir1 = input_port_read(machine(), "ROT1");	// analog port
-	int dir2 = input_port_read(machine(), "ROT2");	// analog port
+	int dir1 = ioport("ROT1")->read();	// analog port
+	int dir2 = ioport("ROT2")->read();	// analog port
 
 	dir1 = (~ (0x800 >> dir1)) & 0xfff;
 	dir2 = (~ (0x800 >> dir2)) & 0xfff;
 
 	switch (offset)
 	{
-		case 0:	return (input_port_read(machine(), "COINS") & 0xf0) + (dir1 >> 8);	// upper 4 bits of p1 rotation + coins
+		case 0:	return (ioport("COINS")->read() & 0xf0) + (dir1 >> 8);	// upper 4 bits of p1 rotation + coins
 		case 1:	return (dir1 & 0xff);					// lower 8 bits of p1 rotation
-		case 2:	return input_port_read(machine(), "P1");	// p1
+		case 2:	return ioport("P1")->read();	// p1
 		case 3:	return 0xff;							// ?
 		case 4:	return (dir2 >> 8);						// upper 4 bits of p2 rotation + ?
 		case 5:	return (dir2 & 0xff);					// lower 8 bits of p2 rotation
-		case 6:	return input_port_read(machine(), "P2");	// p2
+		case 6:	return ioport("P2")->read();	// p2
 		case 7:	return 0xff;							// ?
 	}
 
@@ -3234,10 +3234,10 @@
 
 	PORT_START("DSW")	// 2 DSWs - $600001 & 3.b
 	PORT_DIPNAME( 0x0001, 0x0001, "Licensed To" )		PORT_DIPLOCATION("SW1:1") /* Manual states "Don't Touch" */
-	PORT_DIPSETTING(      0x0000, "Taito" )				PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Jordan" )			PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0000, "Taito" )				PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Romstar" )			PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000) /* Manual shows DSW1-1=Off & DSW2-7=Off */
+	PORT_DIPSETTING(      0x0000, "Taito" )				PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Jordan" )			PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0000, "Taito" )				PORT_CONDITION("DSW",0x4000,EQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Romstar" )			PORT_CONDITION("DSW",0x4000,EQUALS,0x4000) /* Manual shows DSW1-1=Off & DSW2-7=Off */
 	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Flip_Screen ) )	PORT_DIPLOCATION("SW1:2")
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
@@ -3246,23 +3246,23 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0300, DEF_STR( Easy ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( Hard ) )
@@ -3406,20 +3406,20 @@
 	PORT_DIPSETTING(      0x0014, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 	PORT_DIPNAME( 0x00e0, 0x00e0, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW2:6,7,8")
-	PORT_DIPSETTING(      0x0080, DEF_STR( 5C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x0060, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x00e0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_EQUALS,0x0002)
-	PORT_DIPSETTING(      0x00e0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
-	PORT_DIPSETTING(      0x0060, DEF_STR( 2C_4C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
-	PORT_DIPSETTING(      0x0080, "3 Coins/7 Credits" )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002) /* Manuals states "2 Coin 7 Credit" */
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_5C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_6C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
-	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x0002,PORTCOND_NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 5C_1C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x0060, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x00e0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x0002,EQUALS,0x0002)
+	PORT_DIPSETTING(      0x00e0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x0060, DEF_STR( 2C_4C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x0080, "3 Coins/7 Credits" )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002) /* Manuals states "2 Coin 7 Credit" */
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_5C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_6C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
+	PORT_DIPSETTING(      0x00a0, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x0002,NOTEQUALS,0x0002)
 	PORT_DIPSETTING(      0x0000, DEF_STR( Free_Play ) )
 
 
@@ -3535,10 +3535,10 @@
 
 	PORT_START("DSW")	//2 DSWs - $600001 & 3.b
 	PORT_DIPNAME( 0x0001, 0x0001, "Copyright / License" )		PORT_DIPLOCATION("SW1:1") /* Romstar's Manual states "Don't Touch" */
-	PORT_DIPSETTING(      0x0000, "Seta (Japan only)" )		PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Seta USA / Romstar" )		PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0000, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Seta USA / Taito America" )	PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000) /* Romstar's Manual shows DSW1-1=Off & DSW2-7=Off */
+	PORT_DIPSETTING(      0x0000, "Seta (Japan only)" )		PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Seta USA / Romstar" )		PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0000, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,EQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Seta USA / Taito America" )	PORT_CONDITION("DSW",0x4000,EQUALS,0x4000) /* Romstar's Manual shows DSW1-1=Off & DSW2-7=Off */
 	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Flip_Screen ) )	PORT_DIPLOCATION("SW1:2")
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
@@ -3547,23 +3547,23 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x0300, 0x0100, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0300, DEF_STR( Easiest ) )
 	PORT_DIPSETTING(      0x0200, DEF_STR( Easy ) )
@@ -3740,23 +3740,23 @@
 	PORT_DIPSETTING(      0x0000, "1 of 8 Scenes" )
 	PORT_SERVICE_DIPLOC(  0x0800, IP_ACTIVE_LOW, "SW2:4" )
 	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW2:5,6")
-	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
 	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW2:7,8")
-	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_EQUALS,0x0010)
-	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_3C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x4000, DEF_STR( 1C_4C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )			PORT_CONDITION("COINS",0x0010,PORTCOND_NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_1C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,EQUALS,0x0010)
+	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_2C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_3C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 1C_4C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )			PORT_CONDITION("COINS",0x0010,NOTEQUALS,0x0010)
 
 INPUT_PORTS_END
 
@@ -4140,23 +4140,23 @@
 	PORT_DIPSETTING(      0x0008, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x0300, 0x0100, DEF_STR( Difficulty ) ) PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0200, DEF_STR( Easy ) )
 	PORT_DIPSETTING(      0x0300, DEF_STR( Normal ) )
@@ -4853,10 +4853,10 @@
 
 	PORT_START("DSW") //$600001 & 3.b
 	PORT_DIPNAME( 0x0001, 0x0001, "Copyright / License" )	PORT_DIPLOCATION("SW1:1") /* Romstar's Manual states "Don't Touch" */
-	PORT_DIPSETTING(      0x0000, "Seta USA / Taito America" )	PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Seta / Jordan I.S." )		PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0000, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Seta USA / Romstar" )		PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000) /* Romstar's Manual shows DSW1-1=Off & DSW2-7=Off */
+	PORT_DIPSETTING(      0x0000, "Seta USA / Taito America" )	PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Seta / Jordan I.S." )		PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0000, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,EQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Seta USA / Romstar" )		PORT_CONDITION("DSW",0x4000,EQUALS,0x4000) /* Romstar's Manual shows DSW1-1=Off & DSW2-7=Off */
 	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Flip_Screen ) )	PORT_DIPLOCATION("SW1:2")
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
@@ -4865,23 +4865,23 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( On ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x0300, 0x0100, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0300, DEF_STR( Normal )  )
 	PORT_DIPSETTING(      0x0200, DEF_STR( Easy )    )
@@ -5702,23 +5702,23 @@
 	PORT_DIPSETTING(      0x0800, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
 	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
 	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_EQUALS,0x0080)
-	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_3C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x4000, DEF_STR( 1C_4C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )			PORT_CONDITION("DSW",0x0080,PORTCOND_NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 2C_1C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_1C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,EQUALS,0x0080)
+	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_2C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_3C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x4000, DEF_STR( 1C_4C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )			PORT_CONDITION("DSW",0x0080,NOTEQUALS,0x0080)
 INPUT_PORTS_END
 
 
@@ -5775,10 +5775,10 @@
 
 	PORT_START("DSW") //2 DSWs - $600001 & 3.b
 	PORT_DIPNAME( 0x0001, 0x0001, "Copyright / License" )	PORT_DIPLOCATION("SW1:1") /* Always "Seta" if sim. players = 1 */
-	PORT_DIPSETTING(      0x0000, "Taito America / Romstar" )	PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Taito Corp Japan" )		PORT_CONDITION("DSW",0x4000,PORTCOND_NOTEQUALS,0x4000)	/* "World" Copyright */
-	PORT_DIPSETTING(      0x0000, "Taito America" )			PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000)
-	PORT_DIPSETTING(      0x0001, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,PORTCOND_EQUALS,0x4000)	/* Japan Only Notice */
+	PORT_DIPSETTING(      0x0000, "Taito America / Romstar" )	PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Taito Corp Japan" )		PORT_CONDITION("DSW",0x4000,NOTEQUALS,0x4000)	/* "World" Copyright */
+	PORT_DIPSETTING(      0x0000, "Taito America" )			PORT_CONDITION("DSW",0x4000,EQUALS,0x4000)
+	PORT_DIPSETTING(      0x0001, "Seta / Taito" )			PORT_CONDITION("DSW",0x4000,EQUALS,0x4000)	/* Japan Only Notice */
 	PORT_DIPNAME( 0x0002, 0x0002, DEF_STR( Flip_Screen ) )	PORT_DIPLOCATION("SW1:2")
 	PORT_DIPSETTING(      0x0002, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
@@ -5787,23 +5787,23 @@
 	PORT_DIPSETTING(      0x0000, DEF_STR( Upright ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( Cocktail ) )
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0010, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_EQUALS,0x8000)
-	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,PORTCOND_NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,EQUALS,0x8000)
+	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0080, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )		PORT_CONDITION("DSW",0x8000,NOTEQUALS,0x8000)
 	PORT_DIPNAME( 0x0300, 0x0100, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0300, DEF_STR( Normal )  )
 	PORT_DIPSETTING(      0x0200, DEF_STR( Easy )    )
@@ -10646,14 +10646,13 @@
 
 static DRIVER_INIT( crazyfgt )
 {
-	//seta_state *state = machine.driver_data<seta_state>();
-	UINT16 *RAM = (UINT16 *) machine.root_device().memregion("maincpu")->base();
+	seta_state *state = machine.driver_data<seta_state>();
+	UINT16 *RAM = (UINT16 *) state->memregion("maincpu")->base();
 
 	// protection check at boot
 	RAM[0x1078/2] = 0x4e71;
 
 	// fixed priorities?
-	seta_state *state = machine.driver_data<seta_state>();
 	state->m_vregs.allocate(3);
 
 	DRIVER_INIT_CALL(blandia);
@@ -10665,11 +10664,10 @@
 
 static DRIVER_INIT( inttoote )
 {
-	//seta_state *state = machine.driver_data<seta_state>();
-	UINT16 *ROM = (UINT16 *)machine.root_device().memregion( "maincpu" )->base();
+	seta_state *state = machine.driver_data<seta_state>();
+	UINT16 *ROM = (UINT16 *)state->memregion( "maincpu" )->base();
 
 	// missing / unused video regs
-	seta_state *state = machine.driver_data<seta_state>();
 	state->m_vregs.allocate(3);
 
 	// code patches (to be removed...)
diff -Nru src-old/mame/drivers/seta2.c src/mame/drivers/seta2.c
--- src-old/mame/drivers/seta2.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/seta2.c	2012-05-07 08:57:50.000000000 +0200
@@ -220,11 +220,11 @@
 
 	switch (m_keyboard_row)
 	{
-		case 0x01: return input_port_read(machine(), "P1_KEY0");
-		case 0x02: return input_port_read(machine(), "P1_KEY1");
-		case 0x04: return input_port_read(machine(), "P1_KEY2");
-		case 0x08: return input_port_read(machine(), "P1_KEY3");
-		case 0x10: return input_port_read(machine(), "P1_KEY4");
+		case 0x01: return ioport("P1_KEY0")->read();
+		case 0x02: return ioport("P1_KEY1")->read();
+		case 0x04: return ioport("P1_KEY2")->read();
+		case 0x08: return ioport("P1_KEY3")->read();
+		case 0x10: return ioport("P1_KEY4")->read();
 		default:   logerror("p1_r with keyboard_row = %02x\n", m_keyboard_row); return 0xffff;
 	}
 }
@@ -234,11 +234,11 @@
 
 	switch (m_keyboard_row)
 	{
-		case 0x01: return input_port_read(machine(), "P2_KEY0");
-		case 0x02: return input_port_read(machine(), "P2_KEY1");
-		case 0x04: return input_port_read(machine(), "P2_KEY2");
-		case 0x08: return input_port_read(machine(), "P2_KEY3");
-		case 0x10: return input_port_read(machine(), "P2_KEY4");
+		case 0x01: return ioport("P2_KEY0")->read();
+		case 0x02: return ioport("P2_KEY1")->read();
+		case 0x04: return ioport("P2_KEY2")->read();
+		case 0x08: return ioport("P2_KEY3")->read();
+		case 0x10: return ioport("P2_KEY4")->read();
 		default:   logerror("p2_r with keyboard_row = %02x\n", m_keyboard_row); return 0xffff;
 	}
 }
@@ -330,7 +330,7 @@
 
 READ16_MEMBER(seta2_state::pzlbowl_coins_r)
 {
-	return input_port_read(machine(), "SYSTEM") | (machine().rand() & 0x80 );
+	return ioport("SYSTEM")->read() | (machine().rand() & 0x80 );
 }
 
 WRITE16_MEMBER(seta2_state::pzlbowl_coin_counter_w)
@@ -567,7 +567,7 @@
 			return machine().rand();
 
 		case CF_PPDAT:
-			return input_port_read(machine(), "BATTERY") << 16;
+			return ioport("BATTERY")->read() << 16;
 	}
 
 	return m_coldfire_regs[offset];
@@ -575,7 +575,7 @@
 
 READ32_MEMBER(seta2_state::funcube_debug_r)
 {
-	UINT32 ret = input_port_read(machine(),"DEBUG");
+	UINT32 ret = ioport("DEBUG")->read();
 
 	// This bits let you move the crosshair in the inputs / touch panel test with a joystick
 	if (!(machine().primary_screen->frame_number() % 3))
@@ -638,7 +638,7 @@
 
 READ8_MEMBER(seta2_state::funcube_coins_r)
 {
-	UINT8 ret = input_port_read(machine(),"SWITCH");
+	UINT8 ret = ioport("SWITCH")->read();
 	UINT8 coin_bit0 = 1;	// active low
 	UINT8 coin_bit1 = 1;
 
@@ -684,10 +684,11 @@
 	return ret;
 }
 
-static void funcube_debug_outputs(void)
+static void funcube_debug_outputs(running_machine &machine)
 {
 #ifdef MAME_DEBUG
-//  popmessage("LED: %02x OUT: %02x", (int)*funcube_leds, (int)*funcube_outputs);
+//  seta2_state *state = machine.driver_data<seta2_state>();
+//  popmessage("LED: %02x OUT: %02x", (int)*state->m_funcube_leds, (int)*state->m_funcube_outputs);
 #endif
 }
 
@@ -705,7 +706,7 @@
 	set_led_status( machine(), 4, (~data) & 0x40 );
 	set_led_status( machine(), 5, (~data) & 0x80 );
 
-	funcube_debug_outputs();
+	funcube_debug_outputs(space.machine());
 }
 
 READ8_MEMBER(seta2_state::funcube_outputs_r)
@@ -730,7 +731,7 @@
 	// Bit 3: low after coining up, blinks on pay out
 	set_led_status( machine(), 6, (~data) & 0x08 );
 
-	funcube_debug_outputs();
+	funcube_debug_outputs(space.machine());
 }
 
 
@@ -2152,14 +2153,14 @@
 	}
 	else
 	{
-		UINT8 press   = input_port_read(device->machine(),"TOUCH_PRESS");
+		UINT8 press   = device->machine().root_device().ioport("TOUCH_PRESS")->read();
 		UINT8 release = state->m_funcube_press && !press;
 
 		if ( press || release )
 		{
 			state->m_funcube_serial_fifo[0] = press ? 0xfe : 0xfd;
-			state->m_funcube_serial_fifo[1] = input_port_read(device->machine(),"TOUCH_X");
-			state->m_funcube_serial_fifo[2] = input_port_read(device->machine(),"TOUCH_Y");
+			state->m_funcube_serial_fifo[1] = device->machine().root_device().ioport("TOUCH_X")->read();
+			state->m_funcube_serial_fifo[2] = device->machine().root_device().ioport("TOUCH_Y")->read();
 			state->m_funcube_serial_fifo[3] = 0xff;
 			state->m_funcube_serial_count = 4;
 		}
@@ -2406,6 +2407,24 @@
 	ROM_LOAD( "fc41_snd0.u47", 0x000000, 0x200000, CRC(e6f7d2bc) SHA1(638c73d439eaaff8097cb0aa2684f9f7111bcade) )
 ROM_END
 
+ROM_START( funcube5 )
+	ROM_REGION( 0x80000, "maincpu", 0 ) // XCF5206 Code
+	ROM_LOAD( "fc51_prg-0.u4", 0x00000, 0x80000, CRC(4e34c2d8) SHA1(1ace4f6edab291e69e5c36b15193fba62f4a6773) )
+
+	ROM_REGION( 0x20000, "sub", 0 )		// H8/3007 Code
+	ROM_LOAD( "fc21_iopr-0.u49", 0x00000, 0x20000, CRC(314555ef) SHA1(b17e3926c8ef7f599856c198c330d2051aae13ad) )
+
+	ROM_REGION( 0x300, "pic", 0 )		// PIC12C508? Code
+	ROM_LOAD( "fc51a.u57", 0x000, 0x300, NO_DUMP )
+
+	ROM_REGION( 0x800000, "sprites", 0 )
+	ROM_LOAD32_WORD( "fc51_obj-0.u43", 0x000000, 0x400000, CRC(116624b3) SHA1(c0b3dbe0ea4a0808222616c3ef77b2d1194a970a) )
+	ROM_LOAD32_WORD( "fc51_obj-1.u42", 0x000002, 0x400000, CRC(35c6ec61) SHA1(424c9b66a2cdd5217d8a577d0179d1228112ee5b) )
+
+	ROM_REGION( 0x1000000, "oki", ROMREGION_ERASE00 )
+	ROM_LOAD( "fc51_snd-0.u47", 0x000000, 0x200000, CRC(2a504fe1) SHA1(911ad650bf48aa78d9cb3c64284aa526ceb519ba) )
+ROM_END
+
 static DRIVER_INIT( funcube2 )
 {
 	UINT32 *main_cpu = (UINT32 *) machine.root_device().memregion("maincpu")->base();
@@ -3271,4 +3290,5 @@
 GAME( 2001, funcube2, 0,        funcube,  funcube,  funcube2, ROT0, "Namco",                 "Funcube 2 (v1.1)",                             GAME_NO_COCKTAIL )
 GAME( 2001, funcube3, 0,        funcube3, funcube,  funcube3, ROT0, "Namco",                 "Funcube 3 (v1.1)",                             GAME_NO_COCKTAIL )
 GAME( 2001, funcube4, 0,        funcube,  funcube,  funcube2, ROT0, "Namco",                 "Funcube 4 (v1.0)",                             GAME_NO_COCKTAIL )
+GAME( 2002, funcube5, 0,        funcube,  funcube,  funcube2, ROT0, "Namco",                 "Funcube 5 (v1.0)",                             GAME_NO_COCKTAIL )
 GAME( ????, reelquak, 0,        reelquak, reelquak, 0,        ROT0, "<unknown>",             "Reel'N Quake! (Ver. 1.05)",                    GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/sf.c src/mame/drivers/sf.c
--- src-old/mame/drivers/sf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sf.c	2012-05-03 11:00:08.000000000 +0200
@@ -162,12 +162,12 @@
 
 READ16_MEMBER(sf_state::button1_r)
 {
-	return (scale[input_port_read(machine(), "IN3")] << 8) | scale[input_port_read(machine(), "IN1")];
+	return (scale[ioport("IN3")->read()] << 8) | scale[ioport("IN1")->read()];
 }
 
 READ16_MEMBER(sf_state::button2_r)
 {
-	return (scale[input_port_read(machine(), "IN4")] << 8) | scale[input_port_read(machine(), "IN2")];
+	return (scale[ioport("IN4")->read()] << 8) | scale[ioport("IN2")->read()];
 }
 
 
diff -Nru src-old/mame/drivers/sfbonus.c src/mame/drivers/sfbonus.c
--- src-old/mame/drivers/sfbonus.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sfbonus.c	2012-05-03 11:00:08.000000000 +0200
@@ -5733,8 +5733,8 @@
 
 	// dummy.rom helper
 	{
-		UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
-		int length = machine.root_device().memregion("maincpu")->bytes();
+		UINT8 *ROM = state->memregion("maincpu")->base();
+		int length = state->memregion("maincpu")->bytes();
 		UINT8* ROM2 = state->memregion("user1")->base();
 
 		if (ROM2)
diff -Nru src-old/mame/drivers/sfkick.c src/mame/drivers/sfkick.c
--- src-old/mame/drivers/sfkick.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sfkick.c	2012-05-03 11:00:08.000000000 +0200
@@ -91,11 +91,11 @@
 	sfkick_state *state = device->machine().driver_data<sfkick_state>();
 	switch(state->m_input_mux&0x0f)
 	{
-		case 0: return input_port_read(device->machine(), "IN0");
-		case 1: return input_port_read(device->machine(), "IN1");
-		case 2: return BITSWAP8(input_port_read(device->machine(), "DIAL"),4,5,6,7,3,2,1,0);
-		case 3: return input_port_read(device->machine(), "DSW2");
-		case 4: return input_port_read(device->machine(), "DSW1");
+		case 0: return state->ioport("IN0")->read();
+		case 1: return state->ioport("IN1")->read();
+		case 2: return BITSWAP8(state->ioport("DIAL")->read(),4,5,6,7,3,2,1,0);
+		case 3: return state->ioport("DSW2")->read();
+		case 4: return state->ioport("DSW1")->read();
 	}
 	return 0xff;
 }
diff -Nru src-old/mame/drivers/shadfrce.c src/mame/drivers/shadfrce.c
--- src-old/mame/drivers/shadfrce.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/shadfrce.c	2012-05-03 11:00:08.000000000 +0200
@@ -241,16 +241,16 @@
 	switch (offset)
 	{
 		case 0 :
-			data = (input_port_read(machine(), "P1") & 0xff) | ((input_port_read(machine(), "DSW2") & 0xc0) << 6) | ((input_port_read(machine(), "SYSTEM") & 0x0f) << 8);
+			data = (ioport("P1")->read() & 0xff) | ((ioport("DSW2")->read() & 0xc0) << 6) | ((ioport("SYSTEM")->read() & 0x0f) << 8);
 			break;
 		case 1 :
-			data = (input_port_read(machine(), "P2") & 0xff) | ((input_port_read(machine(), "DSW2") & 0x3f) << 8);
+			data = (ioport("P2")->read() & 0xff) | ((ioport("DSW2")->read() & 0x3f) << 8);
 			break;
 		case 2 :
-			data = (input_port_read(machine(), "EXTRA") & 0xff) | ((input_port_read(machine(), "DSW1") & 0x3f) << 8);
+			data = (ioport("EXTRA")->read() & 0xff) | ((ioport("DSW1")->read() & 0x3f) << 8);
 			break;
 		case 3 :
-			data = (input_port_read(machine(), "OTHER") & 0xff) | ((input_port_read(machine(), "DSW1") & 0xc0) << 2) | ((input_port_read(machine(), "MISC") & 0x38) << 8) | (m_vblank << 8);
+			data = (ioport("OTHER")->read() & 0xff) | ((ioport("DSW1")->read() & 0xc0) << 2) | ((ioport("MISC")->read() & 0x38) << 8) | (m_vblank << 8);
 			break;
 	}
 
diff -Nru src-old/mame/drivers/shangha3.c src/mame/drivers/shangha3.c
--- src-old/mame/drivers/shangha3.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/shangha3.c	2012-05-03 11:00:08.000000000 +0200
@@ -207,7 +207,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_SERVICE_NO_TOGGLE(0x0020, IP_ACTIVE_LOW)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
@@ -268,7 +268,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )	/* vblank?? has to toggle */
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* vblank?? has to toggle */
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(2)
@@ -276,7 +276,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_VBLANK )	/* vblank?? has to toggle */
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* vblank?? has to toggle */
 
 	PORT_START("SYSTEM")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
@@ -347,7 +347,7 @@
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)
-	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_VBLANK )	/* vblank?? has to toggle */
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* vblank?? has to toggle */
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(2)
@@ -355,7 +355,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
-	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_VBLANK )	/* vblank?? has to toggle */
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* vblank?? has to toggle */
 
 	PORT_START("SYSTEM")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
diff -Nru src-old/mame/drivers/shangkid.c src/mame/drivers/shangkid.c
--- src-old/mame/drivers/shangkid.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/shangkid.c	2012-05-03 11:00:08.000000000 +0200
@@ -134,7 +134,7 @@
 	state->m_gfx_type = 1;
 
 	/* set up banking */
-	state->membank("bank1")->configure_entries(0, 2, machine.root_device().memregion("maincpu")->base() + 0x8000, 0x8000);
+	state->membank("bank1")->configure_entries(0, 2, state->memregion("maincpu")->base() + 0x8000, 0x8000);
 	state->membank("bank2")->configure_entries(0, 2, state->memregion("audiocpu")->base() + 0x0000, 0x10000);
 }
 
diff -Nru src-old/mame/drivers/shisen.c src/mame/drivers/shisen.c
--- src-old/mame/drivers/shisen.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/shisen.c	2012-05-03 11:00:08.000000000 +0200
@@ -15,18 +15,18 @@
 
 READ8_MEMBER(shisen_state::sichuan2_dsw1_r)
 {
-	int ret = input_port_read(machine(), "DSW1");
+	int ret = ioport("DSW1")->read();
 
 	/* Based on the coin mode fill in the upper bits */
-	if (input_port_read(machine(), "DSW2") & 0x04)
+	if (ioport("DSW2")->read() & 0x04)
 	{
 		/* Mode 1 */
-		ret	|= (input_port_read(machine(), "DSW1") << 4);
+		ret	|= (ioport("DSW1")->read() << 4);
 	}
 	else
 	{
 		/* Mode 2 */
-		ret	|= (input_port_read(machine(), "DSW1") & 0xf0);
+		ret	|= (ioport("DSW1")->read() & 0xf0);
 	}
 
 	return ret;
@@ -117,7 +117,7 @@
 	PORT_DIPSETTING(    0x08, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_EQUALS,0x04) PORT_DIPLOCATION("SW1:5,6,7,8")
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2",0x04,EQUALS,0x04) PORT_DIPLOCATION("SW1:5,6,7,8")
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) )
 	PORT_DIPSETTING(    0xb0, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0xc0, DEF_STR( 4C_1C ) )
@@ -134,12 +134,12 @@
 	PORT_DIPSETTING(    0x60, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x50, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:5,6")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2",0x04,NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:5,6")
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2",0x04,PORTCOND_NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:7,8")
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2",0x04,NOTEQUALS,0x04) PORT_DIPLOCATION("SW1:7,8")
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_5C ) )
diff -Nru src-old/mame/drivers/shootout.c src/mame/drivers/shootout.c
--- src-old/mame/drivers/shootout.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/shootout.c	2012-05-03 11:00:08.000000000 +0200
@@ -171,7 +171,7 @@
 	PORT_DIPSETTING(	0x10, DEF_STR( Hard ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( Very_Hard ) )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SPECIAL ) /* this is set when either coin is inserted */
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( shootouj )
diff -Nru src-old/mame/drivers/shuuz.c src/mame/drivers/shuuz.c
--- src-old/mame/drivers/shuuz.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/shuuz.c	2012-05-03 11:00:08.000000000 +0200
@@ -100,8 +100,8 @@
 	/* when reading the even ports, do a real analog port update */
 	if (which == 0)
 	{
-		int dx = (INT8)input_port_read(machine(), "TRACKX");
-		int dy = (INT8)input_port_read(machine(), "TRACKY");
+		int dx = (INT8)ioport("TRACKX")->read();
+		int dy = (INT8)ioport("TRACKY")->read();
 
 		m_cur[0] = dx + dy;
 		m_cur[1] = dx - dy;
@@ -121,7 +121,7 @@
 
 READ16_MEMBER(shuuz_state::special_port0_r)
 {
-	int result = input_port_read(machine(), "SYSTEM");
+	int result = ioport("SYSTEM")->read();
 
 	if ((result & 0x0800) && atarigen_get_hblank(*machine().primary_screen))
 		result &= ~0x0800;
@@ -171,7 +171,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x07fc, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("BUTTONS")
@@ -198,7 +198,7 @@
 	PORT_BIT( 0x00fc, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Step Debug SW") PORT_CODE(KEYCODE_S)
 	PORT_BIT( 0x0600, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Playfield Debug SW") PORT_CODE(KEYCODE_Y)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Reset Debug SW") PORT_CODE(KEYCODE_E)
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Crosshair Debug SW") PORT_CODE(KEYCODE_C)
diff -Nru src-old/mame/drivers/sidearms.c src/mame/drivers/sidearms.c
--- src-old/mame/drivers/sidearms.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sidearms.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 
 	res = 0;
 	for (i = 0;i < 8;i++)
-		res |= ((input_port_read_safe(machine(), portnames[i], 0) >> offset) & 1) << i;
+		res |= ((ioport(portnames[i])->read_safe(0) >> offset) & 1) << i;
 
 	return res;
 }
@@ -260,7 +260,7 @@
 
 	PORT_START("DSW2")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )     /* not sure, but likely */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")     /* not sure, but likely */
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( turtship )
@@ -534,7 +534,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH,IPT_VBLANK )
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH,IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/sigmab98.c src/mame/drivers/sigmab98.c
--- src-old/mame/drivers/sigmab98.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sigmab98.c	2012-05-03 11:00:08.000000000 +0200
@@ -721,7 +721,7 @@
 
 READ8_MEMBER(sigmab98_state::sammymdl_coin_hopper_r)
 {
-	UINT8 ret = input_port_read(machine(), "COIN");
+	UINT8 ret = ioport("COIN")->read();
 
 //  if ( !machine().device<ticket_dispenser_device>("hopper")->read(0) )
 //      ret &= ~0x01;
@@ -1499,7 +1499,7 @@
 
 	PORT_START("EEPROM")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL )	// protection? checks. Must be 0
-	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_VBLANK  )	// protection? checks. Must be 0
+	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_CUSTOM  ) PORT_VBLANK("screen")	// protection? checks. Must be 0
 	PORT_BIT( 0x04, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW,  IPT_UNKNOWN )
@@ -1537,7 +1537,7 @@
 
 	PORT_START("EEPROM")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL )	// protection? checks. Must be 0
-	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_VBLANK  )	// protection? checks. Must be 0
+	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_CUSTOM  ) PORT_VBLANK("screen")	// protection? checks. Must be 0
 	PORT_BIT( 0x04, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW,  IPT_UNKNOWN )
@@ -1575,7 +1575,7 @@
 
 	PORT_START("EEPROM")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL )	// protection? checks. Must be 0
-	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_VBLANK  )	// protection? checks. Must be 0
+	PORT_BIT( 0x02, IP_ACTIVE_LOW,  IPT_CUSTOM  ) PORT_VBLANK("screen")	// protection? checks. Must be 0
 	PORT_BIT( 0x04, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW,  IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/simpl156.c src/mame/drivers/simpl156.c
--- src-old/mame/drivers/simpl156.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/simpl156.c	2012-05-03 11:00:08.000000000 +0200
@@ -103,7 +103,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x00f0, IP_ACTIVE_HIGH, IPT_VBLANK ) // all bits? check..
+	PORT_BIT( 0x00f0, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") // all bits? check..
 	PORT_BIT( 0x0100, IP_ACTIVE_HIGH, IPT_SPECIAL ) // eeprom?..
 
 
@@ -130,7 +130,7 @@
 READ32_MEMBER(simpl156_state::simpl156_inputs_read)
 {
 	int eep = m_eeprom->read_bit();
-	UINT32 returndata = input_port_read(machine(), "IN0") ^ 0xffff0000;
+	UINT32 returndata = ioport("IN0")->read() ^ 0xffff0000;
 
 	returndata ^= ((eep << 8));
 	return returndata;
@@ -161,7 +161,7 @@
 {
 	UINT32 returndata;
 
-	returndata = input_port_read(machine(), "IN1");
+	returndata = ioport("IN1")->read();
 
 	return returndata;
 }
diff -Nru src-old/mame/drivers/skimaxx.c src/mame/drivers/skimaxx.c
--- src-old/mame/drivers/skimaxx.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/skimaxx.c	2012-05-03 11:00:08.000000000 +0200
@@ -138,7 +138,7 @@
 static VIDEO_START( skimaxx )
 {
 	skimaxx_state *state = machine.driver_data<skimaxx_state>();
-	state->m_blitter_gfx = (UINT16 *) machine.root_device().memregion( "blitter" )->base();
+	state->m_blitter_gfx = (UINT16 *) state->memregion( "blitter" )->base();
 	state->m_blitter_gfx_len = state->memregion( "blitter" )->bytes() / 2;
 
 	state->m_bg_buffer = auto_alloc_array(machine, UINT32, 0x400 * 0x100 * sizeof(UINT16) / sizeof(UINT32) * 2);	// 2 buffers
@@ -150,7 +150,7 @@
 
 static SCREEN_UPDATE_IND16( skimaxx )
 {
-//  popmessage("%02x %02x", input_port_read(screen.machine(), "X"), input_port_read(screen.machine(), "Y") );
+//  popmessage("%02x %02x", state->ioport("X")->read(), state->ioport("Y")->read() );
 
 	SCREEN_UPDATE16_CALL(tms340x0_ind16);
 
@@ -308,7 +308,7 @@
 */
 READ32_MEMBER(skimaxx_state::skimaxx_analog_r)
 {
-	return BITSWAP8(input_port_read(machine(), offset ? "Y" : "X"), 0,1,2,3,4,5,6,7);
+	return BITSWAP8(ioport(offset ? "Y" : "X")->read(), 0,1,2,3,4,5,6,7);
 }
 
 /*************************************
diff -Nru src-old/mame/drivers/skullxbo.c src/mame/drivers/skullxbo.c
--- src-old/mame/drivers/skullxbo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/skullxbo.c	2012-05-03 11:00:08.000000000 +0200
@@ -97,7 +97,7 @@
 
 READ16_MEMBER(skullxbo_state::special_port1_r)
 {
-	int temp = input_port_read(machine(), "FF5802");
+	int temp = ioport("FF5802")->read();
 	if (m_cpu_to_sound_ready) temp ^= 0x0040;
 	if (atarigen_get_hblank(*machine().primary_screen)) temp ^= 0x0010;
 	return temp;
@@ -179,7 +179,7 @@
 	PORT_START("FF5802")
 	PORT_BIT( 0x000f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0010, IP_ACTIVE_HIGH, IPT_UNUSED )	/* HBLANK */
-	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0020, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )	/* /AUDBUSY */
 	PORT_SERVICE( 0x0080, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
diff -Nru src-old/mame/drivers/skydiver.c src/mame/drivers/skydiver.c
--- src-old/mame/drivers/skydiver.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/skydiver.c	2012-05-03 11:00:08.000000000 +0200
@@ -309,7 +309,7 @@
 	PORT_START("IN12")
 	PORT_BIT (0x3f, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT (0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT (0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN13")
 	PORT_BIT (0x3f, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/skyfox.c src/mame/drivers/skyfox.c
--- src-old/mame/drivers/skyfox.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/skyfox.c	2012-05-03 11:00:08.000000000 +0200
@@ -124,7 +124,7 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
 
 	PORT_START("DSW1")	// Coins, DSW + Vblank
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_VBLANK  )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_CUSTOM  ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x0e, 0x00, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW2:1,2,3")
 	PORT_DIPSETTING(    0x0e, DEF_STR( 5C_1C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 4C_1C ) )
diff -Nru src-old/mame/drivers/skykid.c src/mame/drivers/skykid.c
--- src-old/mame/drivers/skykid.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/skykid.c	2012-05-03 11:00:08.000000000 +0200
@@ -37,19 +37,19 @@
 	switch (m_inputport_selected)
 	{
 		case 0x00:	/* DSW B (bits 0-4) */
-			return (input_port_read(machine(), "DSWB") & 0xf8) >> 3;
+			return (ioport("DSWB")->read() & 0xf8) >> 3;
 		case 0x01:	/* DSW B (bits 5-7), DSW A (bits 0-1) */
-			return ((input_port_read(machine(), "DSWB") & 0x07) << 2) | ((input_port_read(machine(), "DSWA") & 0xc0) >> 6);
+			return ((ioport("DSWB")->read() & 0x07) << 2) | ((ioport("DSWA")->read() & 0xc0) >> 6);
 		case 0x02:	/* DSW A (bits 2-6) */
-			return (input_port_read(machine(), "DSWA") & 0x3e) >> 1;
+			return (ioport("DSWA")->read() & 0x3e) >> 1;
 		case 0x03:	/* DSW A (bit 7), DSW C (bits 0-3) */
-			return ((input_port_read(machine(), "DSWA") & 0x01) << 4) | (input_port_read(machine(), "BUTTON2") & 0x0f);
+			return ((ioport("DSWA")->read() & 0x01) << 4) | (ioport("BUTTON2")->read() & 0x0f);
 		case 0x04:	/* coins, start */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 0x05:	/* 2P controls */
-			return input_port_read(machine(), "P2");
+			return ioport("P2")->read();
 		case 0x06:	/* 1P controls */
-			return input_port_read(machine(), "P1");
+			return ioport("P1")->read();
 		default:
 			return 0xff;
 	}
diff -Nru src-old/mame/drivers/skyraid.c src/mame/drivers/skyraid.c
--- src-old/mame/drivers/skyraid.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/skyraid.c	2012-05-03 11:00:08.000000000 +0200
@@ -36,11 +36,11 @@
 
 READ8_MEMBER(skyraid_state::skyraid_port_0_r)
 {
-	UINT8 val = input_port_read(machine(), "LANGUAGE");
+	UINT8 val = ioport("LANGUAGE")->read();
 
-	if (input_port_read(machine(), "STICKY") > m_analog_range)
+	if (ioport("STICKY")->read() > m_analog_range)
 		val |= 0x40;
-	if (input_port_read(machine(), "STICKX") > m_analog_range)
+	if (ioport("STICKX")->read() > m_analog_range)
 		val |= 0x80;
 
 	return val;
diff -Nru src-old/mame/drivers/slapshot.c src/mame/drivers/slapshot.c
--- src-old/mame/drivers/slapshot.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/slapshot.c	2012-05-03 11:00:08.000000000 +0200
@@ -194,8 +194,8 @@
 	switch (offset)
 	{
 		case 0x03:
-			return ((input_port_read(machine(), "SYSTEM") & 0xef) |
-				  (input_port_read(machine(), "SERVICE") & 0x10))  << 8;	/* IN3 + service switch */
+			return ((ioport("SYSTEM")->read() & 0xef) |
+				  (ioport("SERVICE")->read() & 0x10))  << 8;	/* IN3 + service switch */
 
 		default:
 			return tc0640fio_r(m_tc0640fio, offset) << 8;
@@ -207,7 +207,7 @@
 {
 	static const char *const adcnames[] = { "GUN1X", "GUN1Y", "GUN2X", "GUN2Y" };
 
-	return input_port_read(machine(), adcnames[offset]) << 8;
+	return ioport(adcnames[offset])->read() << 8;
 }
 
 WRITE16_MEMBER(slapshot_state::opwolf3_adc_req_w)
diff -Nru src-old/mame/drivers/slotcarn.c src/mame/drivers/slotcarn.c
--- src-old/mame/drivers/slotcarn.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/slotcarn.c	2012-05-03 11:00:08.000000000 +0200
@@ -112,8 +112,8 @@
 	UINT16 x = 0;
 	int rlen;
 
-	gfx[0] = device->machine().root_device().memregion("gfx1")->base();
-	gfx[1] = device->machine().root_device().memregion("gfx2")->base();
+	gfx[0] = state->memregion("gfx1")->base();
+	gfx[1] = state->memregion("gfx2")->base();
 	rlen = state->memregion("gfx2")->bytes();
 
 	//ma = ma ^ 0x7ff;
diff -Nru src-old/mame/drivers/snesb.c src/mame/drivers/snesb.c
--- src-old/mame/drivers/snesb.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/snesb.c	2012-05-03 11:00:08.000000000 +0200
@@ -212,17 +212,17 @@
 /* Generic read handlers for Dip Switches and coins inputs */
 READ8_MEMBER(snesb_state::snesb_dsw1_r)
 {
-	return input_port_read(machine(), "DSW1");
+	return ioport("DSW1")->read();
 }
 
 READ8_MEMBER(snesb_state::snesb_dsw2_r)
 {
-	return input_port_read(machine(), "DSW2");
+	return ioport("DSW2")->read();
 }
 
 READ8_MEMBER(snesb_state::snesb_coin_r)
 {
-	return input_port_read(machine(), "COIN");
+	return ioport("COIN")->read();
 }
 
 
diff -Nru src-old/mame/drivers/snk.c src/mame/drivers/snk.c
--- src-old/mame/drivers/snk.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/snk.c	2012-05-03 11:00:08.000000000 +0200
@@ -741,7 +741,7 @@
 {
 	static const char *const ports[] = { "P1ROT", "P2ROT" };
 	int which = (int)(FPTR)param;
-	int value = input_port_read(machine(), ports[which]);
+	int value = ioport(ports[which])->read();
 
 	if ((m_last_value[which] == 0x5 && value == 0x6) || (m_last_value[which] == 0x6 && value == 0x5))
 	{
@@ -756,7 +756,7 @@
 
 CUSTOM_INPUT_MEMBER(snk_state::gwarb_rotary)
 {
-	if (input_port_read(machine(), "JOYSTICK_MODE") == 1)
+	if (ioport("JOYSTICK_MODE")->read() == 1)
 	{
 		return gwar_rotary(field, param);
 	}
@@ -805,13 +805,13 @@
 CUSTOM_INPUT_MEMBER(snk_state::countryc_trackball_x)
 {
 
-	return input_port_read(machine(), m_countryc_trackball ? "TRACKBALLX2" : "TRACKBALLX1");
+	return ioport(m_countryc_trackball ? "TRACKBALLX2" : "TRACKBALLX1")->read();
 }
 
 CUSTOM_INPUT_MEMBER(snk_state::countryc_trackball_y)
 {
 
-	return input_port_read(machine(), m_countryc_trackball ? "TRACKBALLY2" : "TRACKBALLY1");
+	return ioport(m_countryc_trackball ? "TRACKBALLY2" : "TRACKBALLY1")->read();
 }
 
 
@@ -824,14 +824,14 @@
 	switch (bit_mask)
 	{
 		case 0x01:  /* older games : "Occurrence" Dip Switch (DSW2:1) */
-			return ((input_port_read(machine(), "BONUS") & bit_mask) >> 0);
+			return ((ioport("BONUS")->read() & bit_mask) >> 0);
 		case 0xc0:  /* older games : "Bonus Life" Dip Switches (DSW1:7,8) */
-			return ((input_port_read(machine(), "BONUS") & bit_mask) >> 6);
+			return ((ioport("BONUS")->read() & bit_mask) >> 6);
 
 		case 0x04:  /* later games : "Occurrence" Dip Switch (DSW1:3) */
-			return ((input_port_read(machine(), "BONUS") & bit_mask) >> 2);
+			return ((ioport("BONUS")->read() & bit_mask) >> 2);
 		case 0x30:  /* later games : "Bonus Life" Dip Switches (DSW2:5,6) */
-			return ((input_port_read(machine(), "BONUS") & bit_mask) >> 4);
+			return ((ioport("BONUS")->read() & bit_mask) >> 4);
 
 		default:
 			logerror("snk_bonus_r : invalid %02X bit_mask\n",bit_mask);
@@ -2388,12 +2388,12 @@
 	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("DSW1:3")
 	PORT_DIPSETTING(    0x04, DEF_STR( Upright ) )          /* Dual Controls */
 	PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
-	PORT_DIPNAME( 0x08, 0x00, "Gameplay" )        PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01) PORT_DIPLOCATION("DSW1:4")    /* code at 0x011e */
-	PORT_DIPSETTING(    0x00, "Basic Player" )    PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x08, "Avid Golfer" )     PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) ) PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("DSW1:4")
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )    PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )     PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
+	PORT_DIPNAME( 0x08, 0x00, "Gameplay" )        PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01) PORT_DIPLOCATION("DSW1:4")    /* code at 0x011e */
+	PORT_DIPSETTING(    0x00, "Basic Player" )    PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x08, "Avid Golfer" )     PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) ) PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00) PORT_DIPLOCATION("DSW1:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )    PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )     PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )           PORT_DIPLOCATION("DSW1:5,6")
 	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )
diff -Nru src-old/mame/drivers/snk68.c src/mame/drivers/snk68.c
--- src-old/mame/drivers/snk68.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/snk68.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,35 +63,35 @@
 
 READ16_MEMBER(snk68_state::control_1_r)
 {
-	return (input_port_read(machine(), "P1") + (input_port_read(machine(), "P2") << 8));
+	return (ioport("P1")->read() + (ioport("P2")->read() << 8));
 }
 
 READ16_MEMBER(snk68_state::control_2_r)
 {
-	return input_port_read(machine(), "SYSTEM");
+	return ioport("SYSTEM")->read();
 }
 
 READ16_MEMBER(snk68_state::rotary_1_r)
 {
-	return (( ~(1 << input_port_read(machine(), "ROT1")) )<<8)&0xff00;
+	return (( ~(1 << ioport("ROT1")->read()) )<<8)&0xff00;
 }
 
 READ16_MEMBER(snk68_state::rotary_2_r)
 {
-	return (( ~(1 << input_port_read(machine(), "ROT2")) )<<8)&0xff00;
+	return (( ~(1 << ioport("ROT2")->read()) )<<8)&0xff00;
 }
 
 READ16_MEMBER(snk68_state::rotary_lsb_r)
 {
-	return ((( ~(1 << input_port_read(machine(), "ROT2"))  ) <<4)&0xf000)
-		 + ((( ~(1 << input_port_read(machine(), "ROT1"))  )    )&0x0f00);
+	return ((( ~(1 << ioport("ROT2")->read())  ) <<4)&0xf000)
+		 + ((( ~(1 << ioport("ROT1")->read())  )    )&0x0f00);
 }
 
 READ16_MEMBER(snk68_state::protcontrols_r)
 {
 	static const char *const portnames[] = { "P1", "P2", "SYSTEM" };
 
-	return input_port_read(machine(), portnames[offset]) ^ m_invert_controls;
+	return ioport(portnames[offset])->read() ^ m_invert_controls;
 }
 
 WRITE16_MEMBER(snk68_state::protection_w)
diff -Nru src-old/mame/drivers/snookr10.c src/mame/drivers/snookr10.c
--- src-old/mame/drivers/snookr10.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/snookr10.c	2012-05-03 11:00:08.000000000 +0200
@@ -390,7 +390,7 @@
     BIT 7 = Complement of DS1, bit 7
    ---------------------------------
 */
-return input_port_read(machine(), "SW1");
+return ioport("SW1")->read();
 }
 
 
diff -Nru src-old/mame/drivers/snowbros.c src/mame/drivers/snowbros.c
--- src-old/mame/drivers/snowbros.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/snowbros.c	2012-05-03 11:00:08.000000000 +0200
@@ -418,13 +418,13 @@
 	{
 		case 0x23:
 		case 0x26:
-		snd = machine.root_device().memregion("oki")->base();
+		snd = state->memregion("oki")->base();
 		memcpy(snd+0x20000, snd+0x80000+0x00000, 0x20000);
 		state->m_sb3_music_is_playing = 1;
 		break;
 
 		case 0x24:
-		snd = machine.root_device().memregion("oki")->base();
+		snd = state->memregion("oki")->base();
 		memcpy(snd+0x20000, snd+0x80000+0x20000, 0x20000);
 		state->m_sb3_music_is_playing = 1;
 		break;
@@ -558,22 +558,22 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x01, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x01)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1", 0x01, EQUALS, 0x00)
 	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY
 	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY
@@ -667,7 +667,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 )
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 )
-	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_VBLANK )	/* Must be low or game stops! */
+	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* Must be low or game stops! */
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Difficulty ) )
@@ -743,7 +743,7 @@
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 )
 	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 )
-	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_VBLANK )	/* Must be low or game stops! */
+	PORT_BIT( 0x8000, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* Must be low or game stops! */
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Difficulty ) )
@@ -2352,7 +2352,7 @@
 static DRIVER_INIT( cookbib2 )
 {
 	//snowbros_state *state = machine.driver_data<snowbros_state>();
-//  UINT16 *HCROM = (UINT16*)machine.root_device().memregion("maincpu")->base();
+//  UINT16 *HCROM = (UINT16*)state->memregion("maincpu")->base();
 //  UINT16 *PROTDATA = (UINT16*)state->memregion("user1")->base();
 //  int i;
 //  state->m_hyperpac_ram[0xf000/2] = 0x46fc;
diff -Nru src-old/mame/drivers/spacefb.c src/mame/drivers/spacefb.c
--- src-old/mame/drivers/spacefb.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/spacefb.c	2012-04-30 17:21:04.000000000 +0200
@@ -371,9 +371,36 @@
  *
  *************************************/
 
+// pcb is revision 04 and has roms with suffix 'u'
 ROM_START( spacefb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "5e.cpu",      0x0000, 0x0800, CRC(2d406678) SHA1(9dff1980fc5267313f99f9f67d2d83eda8aae00e) )
+	ROM_LOAD( "tst-c-u.5e",      0x0000, 0x0800, CRC(79c3527e) SHA1(5f2d9f3a8b573333e40e78222996f556ed6686ea) )
+	ROM_LOAD( "tst-c-u.5f",      0x0800, 0x0800, CRC(c0973965) SHA1(f0dcd820c0e0766368ef5d58c29ef090fc5cfdef) )
+	ROM_LOAD( "tst-c-u.5h",      0x1000, 0x0800, CRC(02c60ec5) SHA1(43b8553076c7c0e22e0708797c8f3d30fccf82ec) )
+	ROM_LOAD( "tst-c-u.5i",      0x1800, 0x0800, CRC(76fd18c7) SHA1(2db271269b8f810eb93e5e86d59251fe1f43769a) )
+	ROM_LOAD( "tst-c-u.5j",      0x2000, 0x0800, CRC(df52c97c) SHA1(54032c1ed694911079ffa45545b1e63ec8107fc4) )
+	ROM_LOAD( "tst-c-u.5k",      0x2800, 0x0800, CRC(1713300c) SHA1(9a7b6cc0d79cccadd4988e0e791c1598813b6552) )
+	ROM_LOAD( "tst-c-u.5m",      0x3000, 0x0800, CRC(6286f534) SHA1(c47d0df85a52c774a4bc26351fdae18795062b6e) )
+	ROM_LOAD( "tst-c-u.5n",      0x3800, 0x0800, CRC(1c9f91ee) SHA1(481a309fe9aa9ce6fd18d7d908c18790f594057d) )
+
+	ROM_REGION( 0x1000, "audiocpu", 0 )
+    ROM_LOAD( "ic20.snd",    0x0000, 0x0400, CRC(1c8670b3) SHA1(609124caa11498fc6a6bdf6cdbb8003bbc249dd8) )
+
+	ROM_REGION( 0x1000, "gfx1", 0 )  /* sprites */
+	ROM_LOAD( "tst-v-a.5k",      0x0000, 0x0800, CRC(236e1ff7) SHA1(575b8ed9ab054a864207e0fde3ae93cdcafbebf2) )
+	ROM_LOAD( "tst-v-a.6k",      0x0800, 0x0800, CRC(bf901a4e) SHA1(71207ad1ca60aa617dbbc3cd2e4e42520b7c8513) )
+
+	ROM_REGION( 0x0100, "gfx2", 0 )  /* bullets */
+	ROM_LOAD( "4i.vid",      0x0000, 0x0100, CRC(528e8533) SHA1(8e41eee1016c98a4f08acbd902daf8e32aa9d9ab) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "mb7051.3n",   0x0000, 0x0020, CRC(465d07af) SHA1(25e246f7674c25d05e5f6e68db88c15aaa10cee1) )
+ROM_END
+
+// pcb is revision 03 and has roms with suffix 'e'
+ROM_START( spacefbe )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "tst-c-e.5e",      0x0000, 0x0800, CRC(77dda05b) SHA1(b8a42632587260509ba023c7e05d252972f90363) )
 	ROM_LOAD( "tst-c-e.5f",      0x0800, 0x0800, CRC(89f0c34a) SHA1(4d8652fb7c4f22ddbac8c2d7ca7df675eaa2a447) )
 	ROM_LOAD( "tst-c-e.5h",      0x1000, 0x0800, CRC(c4bcac3e) SHA1(5364d6fc9d3402b2def163dee7c39fe3fe57eea3) )
 	ROM_LOAD( "tst-c-e.5i",      0x1800, 0x0800, CRC(61c00a65) SHA1(afc93e320478c70b3ddca8375fd648c9f2572dab) )
@@ -396,11 +423,9 @@
 	ROM_LOAD( "mb7051.3n",   0x0000, 0x0020, CRC(465d07af) SHA1(25e246f7674c25d05e5f6e68db88c15aaa10cee1) )
 ROM_END
 
-
-// pcb is revision 03 and has roms with suffix 'e'
-ROM_START( spacefbe )
+ROM_START( spacefbe2 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "tst-c-e.5e",      0x0000, 0x0800, CRC(77dda05b) SHA1(b8a42632587260509ba023c7e05d252972f90363) ) // only 5e differs to above set, by 2 bytes.
+	ROM_LOAD( "5e.cpu",      0x0000, 0x0800, CRC(2d406678) SHA1(9dff1980fc5267313f99f9f67d2d83eda8aae00e) ) // only 5e differs to above set, by 2 bytes.
 	ROM_LOAD( "tst-c-e.5f",      0x0800, 0x0800, CRC(89f0c34a) SHA1(4d8652fb7c4f22ddbac8c2d7ca7df675eaa2a447) )
 	ROM_LOAD( "tst-c-e.5h",      0x1000, 0x0800, CRC(c4bcac3e) SHA1(5364d6fc9d3402b2def163dee7c39fe3fe57eea3) )
 	ROM_LOAD( "tst-c-e.5i",      0x1800, 0x0800, CRC(61c00a65) SHA1(afc93e320478c70b3ddca8375fd648c9f2572dab) )
@@ -423,30 +448,30 @@
 	ROM_LOAD( "mb7051.3n",   0x0000, 0x0020, CRC(465d07af) SHA1(25e246f7674c25d05e5f6e68db88c15aaa10cee1) )
 ROM_END
 
-// pcb is revision 04 and has roms with suffix 'u'
-ROM_START( spacefbu )
+// cpu pcb is revision 02, video pcb is revision 03. roms with handwritten suffix 'a'
+ROM_START( spacefba )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "tst-c-u.5e",      0x0000, 0x0800, CRC(79c3527e) SHA1(5f2d9f3a8b573333e40e78222996f556ed6686ea) )
-	ROM_LOAD( "tst-c-u.5f",      0x0800, 0x0800, CRC(c0973965) SHA1(f0dcd820c0e0766368ef5d58c29ef090fc5cfdef) )
-	ROM_LOAD( "tst-c-u.5h",      0x1000, 0x0800, CRC(02c60ec5) SHA1(43b8553076c7c0e22e0708797c8f3d30fccf82ec) )
-	ROM_LOAD( "tst-c-u.5i",      0x1800, 0x0800, CRC(76fd18c7) SHA1(2db271269b8f810eb93e5e86d59251fe1f43769a) )
-	ROM_LOAD( "tst-c-u.5j",      0x2000, 0x0800, CRC(df52c97c) SHA1(54032c1ed694911079ffa45545b1e63ec8107fc4) )
-	ROM_LOAD( "tst-c-u.5k",      0x2800, 0x0800, CRC(1713300c) SHA1(9a7b6cc0d79cccadd4988e0e791c1598813b6552) )
-	ROM_LOAD( "tst-c-u.5m",      0x3000, 0x0800, CRC(6286f534) SHA1(c47d0df85a52c774a4bc26351fdae18795062b6e) )
-	ROM_LOAD( "tst-c-u.5n",      0x3800, 0x0800, CRC(1c9f91ee) SHA1(481a309fe9aa9ce6fd18d7d908c18790f594057d) )
+	ROM_LOAD( "tst-c-a.5e",      0x0000, 0x0800, CRC(5657bd2f) SHA1(0e615a7dd5efbbf6f543480bc150f45089c41d32) )
+	ROM_LOAD( "tst-c-a.5f",      0x0800, 0x0800, CRC(303b0294) SHA1(a2f5637e201739b440e7ea0868d2d5745fbb4f5b) )
+	ROM_LOAD( "tst-c-a.5h",      0x1000, 0x0800, CRC(49a26fe5) SHA1(851f62df651aa180b6fa236f4c54ed7791d92a21) )
+	ROM_LOAD( "tst-c-a.5i",      0x1800, 0x0800, CRC(c23025da) SHA1(ccc73ca9754b04e49733661cbd9e788b13163100) )
+	ROM_LOAD( "tst-c-a.5j",      0x2000, 0x0800, CRC(946bee5d) SHA1(6e668cec5986af3d319bf9aa8962a3d9008d0156) )
+	ROM_LOAD( "tst-c-a.5k",      0x2800, 0x0800, CRC(1713300c) SHA1(9a7b6cc0d79cccadd4988e0e791c1598813b6552) )
+	ROM_LOAD( "tst-c-a.5m",      0x3000, 0x0800, CRC(4cbe92fc) SHA1(903b617e42f740e94a6edb6a973dc0d57ac0abee) )
+	ROM_LOAD( "tst-c-a.5n",      0x3800, 0x0800, CRC(1a798fbf) SHA1(65ff2fe91c2037378314c4a68b2bd21fd167c64a) )
 
 	ROM_REGION( 0x1000, "audiocpu", 0 )
-    ROM_LOAD( "ic20.snd",    0x0000, 0x0400, CRC(1c8670b3) SHA1(609124caa11498fc6a6bdf6cdbb8003bbc249dd8) )
+    ROM_LOAD( "tst-e-20.bin",    0x0000, 0x0400, CRC(f7a59492) SHA1(22bdc02c72086c38acd9d9675da54ce6ba3f80a3) )
 
 	ROM_REGION( 0x1000, "gfx1", 0 )  /* sprites */
 	ROM_LOAD( "tst-v-a.5k",      0x0000, 0x0800, CRC(236e1ff7) SHA1(575b8ed9ab054a864207e0fde3ae93cdcafbebf2) )
 	ROM_LOAD( "tst-v-a.6k",      0x0800, 0x0800, CRC(bf901a4e) SHA1(71207ad1ca60aa617dbbc3cd2e4e42520b7c8513) )
 
 	ROM_REGION( 0x0100, "gfx2", 0 )  /* bullets */
-	ROM_LOAD( "4i.vid",      0x0000, 0x0100, CRC(528e8533) SHA1(8e41eee1016c98a4f08acbd902daf8e32aa9d9ab) )
+	ROM_LOAD( "mb7052-a.4i",     0x0000, 0x0100, CRC(528e8533) SHA1(8e41eee1016c98a4f08acbd902daf8e32aa9d9ab) )
 
 	ROM_REGION( 0x0020, "proms", 0 )
-	ROM_LOAD( "mb7051.3n",   0x0000, 0x0020, CRC(465d07af) SHA1(25e246f7674c25d05e5f6e68db88c15aaa10cee1) )
+	ROM_LOAD( "mb7051-a.3n",     0x0000, 0x0020, CRC(465d07af) SHA1(25e246f7674c25d05e5f6e68db88c15aaa10cee1) )
 ROM_END
 
 
@@ -559,9 +584,10 @@
  *
  *************************************/
 
-GAME( 1980, spacefb,  0,       spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (Nintendo, set 1)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
-GAME( 1980, spacefbu, spacefb, spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (Nintendo, set 2)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
-GAME( 1980, spacefbe, spacefb, spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (Nintendo, set 3)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
+GAME( 1980, spacefb,  0,       spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (rev. 04-u)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
+GAME( 1980, spacefbe, spacefb, spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (rev. 03-e set 1)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
+GAME( 1980, spacefbe2,spacefb, spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (rev. 03-e set 2)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
+GAME( 1980, spacefba, spacefb, spacefb, spacefb,  0, ROT270, "Nintendo", "Space Firebird (rev. 02-a)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
 GAME( 1980, spacefbg, spacefb, spacefb, spacefb,  0, ROT270, "Nintendo (Gremlin license)", "Space Firebird (Gremlin)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
 GAME( 1980, spacebrd, spacefb, spacefb, spacefb,  0, ROT270, "bootleg (Karateco)", "Space Bird (bootleg)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
 GAME( 1980, spacefbb, spacefb, spacefb, spacefb,  0, ROT270, "bootleg", "Space Firebird (bootleg)", GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/spcforce.c src/mame/drivers/spcforce.c
--- src-old/mame/drivers/spcforce.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/spcforce.c	2012-05-03 11:00:08.000000000 +0200
@@ -152,7 +152,7 @@
 	PORT_SERVICE_NO_TOGGLE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT ( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
 	PORT_BIT ( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT ( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_2WAY PORT_COCKTAIL
 INPUT_PORTS_END
 
@@ -194,7 +194,7 @@
 
 	PORT_START("P2")
 	PORT_SERVICE_NO_TOGGLE( 0x08, IP_ACTIVE_LOW )
-	PORT_BIT ( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/spdodgeb.c src/mame/drivers/spdodgeb.c
--- src-old/mame/drivers/spdodgeb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/spdodgeb.c	2012-05-03 11:00:08.000000000 +0200
@@ -98,8 +98,8 @@
 	{
 		int curr[2][2];
 
-		curr[p][0] = input_port_read(machine, p ? "P2" : "P1") & 0x01;
-		curr[p][1] = input_port_read(machine, p ? "P2" : "P1") & 0x02;
+		curr[p][0] = state->ioport(p ? "P2" : "P1")->read() & 0x01;
+		curr[p][1] = state->ioport(p ? "P2" : "P1")->read() & 0x02;
 
 		for (j = 0;j <= 1;j++)
 		{
@@ -133,7 +133,7 @@
 	{
 		int curr[2];
 
-		curr[p] = input_port_read(machine, p ? "P2" : "P1") & 0x30;
+		curr[p] = machine.root_device().ioport(p ? "P2" : "P1")->read() & 0x30;
 
 		if (state->m_jumped[p]) buttons[p] = 0;	/* jump only momentarily flips the buttons */
 		else buttons[p] = curr[p];
@@ -144,8 +144,8 @@
 		state->m_prev[p] = curr[p];
 	}
 
-	state->m_inputs[0] = input_port_read(machine, "P1") & 0xcf;
-	state->m_inputs[1] = input_port_read(machine, "P2") & 0x0f;
+	state->m_inputs[0] = machine.root_device().ioport("P1")->read() & 0xcf;
+	state->m_inputs[1] = machine.root_device().ioport("P2")->read() & 0x0f;
 	state->m_inputs[2] = state->m_running[0] | buttons[0];
 	state->m_inputs[3] = state->m_running[1] | buttons[1];
 }
@@ -166,7 +166,7 @@
 
 	for (p=0; p<=1; p++)
 	{
-		curr_port[p] = input_port_read(machine, p ? "P2" : "P1");
+		curr_port[p] = state->ioport(p ? "P2" : "P1")->read();
 		curr_dash[p] = 0;
 
 		if (curr_port[p] & R)
@@ -221,7 +221,7 @@
 		case 1: return m_inputs[1];
 		case 2: return m_inputs[2];
 		case 3: return m_inputs[3];
-		case 4: return input_port_read(machine(), "IN1");
+		case 4: return ioport("IN1")->read();
 	}
 }
 
@@ -235,7 +235,7 @@
 
 READ8_MEMBER(spdodgeb_state::port_0_r)
 {
-	int port = input_port_read(machine(), "IN0");
+	int port = ioport("IN0")->read();
 
 	m_toggle^=0x02;	/* mcu63701_busy flag */
 
@@ -272,7 +272,7 @@
 
 static INPUT_PORTS_START( spdodgeb )
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_SPECIAL )	/* mcu63701_busy flag */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN1 )
diff -Nru src-old/mame/drivers/speedatk.c src/mame/drivers/speedatk.c
--- src-old/mame/drivers/speedatk.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/speedatk.c	2012-05-03 11:00:08.000000000 +0200
@@ -94,7 +94,7 @@
 
 		for (t = 0 ; t < 8 ; t ++)
 		{
-			if (!(input_port_read(machine, keynames[j+p_side]) & ( 1 << t )))
+			if (!(machine.root_device().ioport(keynames[j+p_side])->read() & ( 1 << t )))
 			{
 				return (i + t) | (p_side ? 0x20 : 0x00);
 			}
@@ -113,7 +113,7 @@
 		return 0x80;
 	}
 
-	if((input_port_read(machine(),"COINS") & 1) || (input_port_read(machine(),"COINS") & 2))
+	if((ioport("COINS")->read() & 1) || (ioport("COINS")->read() & 2))
 	{
 		m_coin_impulse = m_coin_settings;
 		m_coin_impulse--;
diff -Nru src-old/mame/drivers/spiders.c src/mame/drivers/spiders.c
--- src-old/mame/drivers/spiders.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/spiders.c	2012-05-03 11:00:08.000000000 +0200
@@ -275,13 +275,13 @@
 	/* update the different PIA pins from the input ports */
 
 	/* CA1 - copy of PA1 (COIN1) */
-	pia1->ca1_w(input_port_read(device->machine(), "IN0") & 0x02);
+	pia1->ca1_w(device->machine().root_device().ioport("IN0")->read() & 0x02);
 
 	/* CA2 - copy of PA0 (SERVICE1) */
-	pia1->ca2_w(input_port_read(device->machine(), "IN0") & 0x01);
+	pia1->ca2_w(device->machine().root_device().ioport("IN0")->read() & 0x01);
 
 	/* CB1 - (crosshatch) */
-	pia1->cb1_w(input_port_read(device->machine(), "XHATCH"));
+	pia1->cb1_w(device->machine().root_device().ioport("XHATCH")->read());
 
 	/* CB2 - NOT CONNECTED */
 }
diff -Nru src-old/mame/drivers/splash.c src/mame/drivers/splash.c
--- src-old/mame/drivers/splash.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/splash.c	2012-05-03 11:00:08.000000000 +0200
@@ -1056,7 +1056,7 @@
 static DRIVER_INIT( funystrp )
 {
 	splash_state *state = machine.driver_data<splash_state>();
-	UINT16 *ROM = (UINT16 *)machine.root_device().memregion("maincpu")->base();
+	UINT16 *ROM = (UINT16 *)state->memregion("maincpu")->base();
 
 	state->m_bitmap_type = 0;
 	state->m_sprite_attr2_shift = 0;
diff -Nru src-old/mame/drivers/splus.c src/mame/drivers/splus.c
--- src-old/mame/drivers/splus.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/splus.c	2012-05-03 11:00:08.000000000 +0200
@@ -395,7 +395,7 @@
 			break;
 		case 0x01: // Bank 10
             // Test for Coin-In
-	        if ((input_port_read_safe(machine(),"SENSOR",0x00) & 0x01) == 0x01 && m_coin_state == 0) {
+	        if ((ioport("SENSOR")->read_safe(0x00) & 0x01) == 0x01 && m_coin_state == 0) {
 		        m_coin_state = 1; // Start Coin Cycle
 		        m_last_cycles = machine().firstcpu->total_cycles();
 #if DEBUG_OUTPUT
@@ -438,7 +438,7 @@
 	        }
 
             // Determine Door Optics
-            if ((input_port_read_safe(machine(),"I10",0x08) & 0x08) == 0x08)
+            if ((ioport("I10")->read_safe(0x08) & 0x08) == 0x08)
                 door_optics = 0x08;
             else
                 door_optics = (((m_bank20 >> 4) & 1) << 3); // Use Door Optics Transmitter
@@ -483,22 +483,22 @@
             val = val | door_optics; // Door Optics Receiver
             val = val | coin_out; // Hopper Coin OutR
             val = val | 0x00; // Hopper Full
-            val = val | (input_port_read_safe(machine(),"I10",0x40) & 0x40); // Handle/Spin Button
-            val = val | (input_port_read_safe(machine(),"I10",0x80) & 0x80); // Jackpot Reset Key
+            val = val | (ioport("I10")->read_safe(0x40) & 0x40); // Handle/Spin Button
+            val = val | (ioport("I10")->read_safe(0x80) & 0x80); // Jackpot Reset Key
 			break;
 		case 0x02: // Bank 20
-            val = val | (input_port_read_safe(machine(),"I20",0x01) & 0x01); // Bet One Credit
-            val = val | (input_port_read_safe(machine(),"I20",0x02) & 0x02); // Play Max Credits
-            val = val | (input_port_read_safe(machine(),"I20",0x04) & 0x04); // Cash Out
-            val = val | (input_port_read_safe(machine(),"I20",0x08) & 0x08); // Change Request
+            val = val | (ioport("I20")->read_safe(0x01) & 0x01); // Bet One Credit
+            val = val | (ioport("I20")->read_safe(0x02) & 0x02); // Play Max Credits
+            val = val | (ioport("I20")->read_safe(0x04) & 0x04); // Cash Out
+            val = val | (ioport("I20")->read_safe(0x08) & 0x08); // Change Request
             val = val | 0x00; // Reel Mechanism
-            val = val | (input_port_read_safe(machine(),"I20",0x20) & 0x20); // Self Test Button
+            val = val | (ioport("I20")->read_safe(0x20) & 0x20); // Self Test Button
             val = val | 0x40; // Card Cage
             val = val | 0x80; // Bill Acceptor
 			break;
 		case 0x04: // Bank 30
             // Reserved
-            val = val | (input_port_read_safe(machine(),"I30",0x02) & 0x02); // Drop Door
+            val = val | (ioport("I30")->read_safe(0x02) & 0x02); // Drop Door
             // Jackpot to Credit Key
             // Reserved
             // Reserved
diff -Nru src-old/mame/drivers/spoker.c src/mame/drivers/spoker.c
--- src-old/mame/drivers/spoker.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/spoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -201,11 +201,11 @@
 	switch(m_igs_magic[0])
 	{
 		case 0x00:
-			if ( !(m_igs_magic[1] & 0x01) )	return input_port_read(machine(), "DSW1");
-			if ( !(m_igs_magic[1] & 0x02) )	return input_port_read(machine(), "DSW2");
-			if ( !(m_igs_magic[1] & 0x04) )	return input_port_read(machine(), "DSW3");
-			if ( !(m_igs_magic[1] & 0x08) )	return input_port_read(machine(), "DSW4");
-			if ( !(m_igs_magic[1] & 0x10) )	return input_port_read(machine(), "DSW5");
+			if ( !(m_igs_magic[1] & 0x01) )	return ioport("DSW1")->read();
+			if ( !(m_igs_magic[1] & 0x02) )	return ioport("DSW2")->read();
+			if ( !(m_igs_magic[1] & 0x04) )	return ioport("DSW3")->read();
+			if ( !(m_igs_magic[1] & 0x08) )	return ioport("DSW4")->read();
+			if ( !(m_igs_magic[1] & 0x10) )	return ioport("DSW5")->read();
 			logerror("%06x: warning, reading dsw with igs_magic[1] = %02x\n", cpu_get_pc(&space.device()), m_igs_magic[1]);
 			break;
 
diff -Nru src-old/mame/drivers/spool99.c src/mame/drivers/spool99.c
--- src-old/mame/drivers/spool99.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/spool99.c	2012-05-03 11:00:08.000000000 +0200
@@ -165,19 +165,19 @@
 	{
 		switch(offset+0xaf00)
 		{
-			case 0xafd8: return input_port_read(machine(),"COIN1");
+			case 0xafd8: return ioport("COIN1")->read();
 //          case 0xafd9: return 1;
-			case 0xafda: return input_port_read(machine(),"COIN2");
+			case 0xafda: return ioport("COIN2")->read();
 			case 0xafdb: return 1;
-			case 0xafdc: return input_port_read(machine(),"SERVICE1");//attract mode
-			case 0xafdd: return input_port_read(machine(),"HOLD3");
-			case 0xafde: return input_port_read(machine(),"HOLD4");
-			case 0xafdf: return input_port_read(machine(),"HOLD2");
-			case 0xafe0: return input_port_read(machine(),"HOLD1");
-			case 0xafe1: return input_port_read(machine(),"HOLD5");
-			case 0xafe2: return input_port_read(machine(),"START");
-			case 0xafe3: return input_port_read(machine(),"BET");//system 2
-			case 0xafe4: return input_port_read(machine(),"SERVICE2");//attract mode
+			case 0xafdc: return ioport("SERVICE1")->read();//attract mode
+			case 0xafdd: return ioport("HOLD3")->read();
+			case 0xafde: return ioport("HOLD4")->read();
+			case 0xafdf: return ioport("HOLD2")->read();
+			case 0xafe0: return ioport("HOLD1")->read();
+			case 0xafe1: return ioport("HOLD5")->read();
+			case 0xafe2: return ioport("START")->read();
+			case 0xafe3: return ioport("BET")->read();//system 2
+			case 0xafe4: return ioport("SERVICE2")->read();//attract mode
 //          case 0xafe5: return 1;
 //          case 0xafe6: return 1;
 			case 0xafe7: return machine().device<eeprom_device>("eeprom")->read_bit();
@@ -235,18 +235,18 @@
 	{
 		switch(offset+0xa700)
 		{
-			case 0xa720: return input_port_read(machine(),"SERVICE1");//attract mode
-			case 0xa722: return input_port_read(machine(),"COIN1");
-			case 0xa723: return input_port_read(machine(),"COIN2");
-			case 0xa724: return input_port_read(machine(),"SERVICE2");//attract mode
-			case 0xa725: return input_port_read(machine(),"HOLD3");
-			case 0xa726: return input_port_read(machine(),"HOLD4");
-			case 0xa727: return input_port_read(machine(),"HOLD2");
+			case 0xa720: return ioport("SERVICE1")->read();//attract mode
+			case 0xa722: return ioport("COIN1")->read();
+			case 0xa723: return ioport("COIN2")->read();
+			case 0xa724: return ioport("SERVICE2")->read();//attract mode
+			case 0xa725: return ioport("HOLD3")->read();
+			case 0xa726: return ioport("HOLD4")->read();
+			case 0xa727: return ioport("HOLD2")->read();
 			case 0xa780: return machine().device<okim6295_device>("oki")->read(space,0);
-			case 0xa7a0: return input_port_read(machine(),"HOLD1");
-			case 0xa7a1: return input_port_read(machine(),"HOLD5");
-			case 0xa7a2: return input_port_read(machine(),"START");
-			case 0xa7a3: return input_port_read(machine(),"BET");//system 2
+			case 0xa7a0: return ioport("HOLD1")->read();
+			case 0xa7a1: return ioport("HOLD5")->read();
+			case 0xa7a2: return ioport("START")->read();
+			case 0xa7a3: return ioport("BET")->read();//system 2
 
 			case 0xa7a7: return machine().device<eeprom_device>("eeprom")->read_bit();
 
diff -Nru src-old/mame/drivers/sprint2.c src/mame/drivers/sprint2.c
--- src-old/mame/drivers/sprint2.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/sprint2.c	2012-05-03 11:00:08.000000000 +0200
@@ -50,7 +50,7 @@
 static int service_mode(running_machine &machine)
 {
 	sprint2_state *state = machine.driver_data<sprint2_state>();
-	UINT8 v = input_port_read(machine, "INB");
+	UINT8 v = state->ioport("INB")->read();
 
 	if (GAME_IS_SPRINT1)
 	{
@@ -82,7 +82,7 @@
 
 		for (i = 0; i < 2; i++)
 		{
-			signed char delta = input_port_read(device->machine(), i ? "DIAL_P2" : "DIAL_P1") - state->m_dial[i];
+			signed char delta = state->ioport(i ? "DIAL_P2" : "DIAL_P1")->read() - state->m_dial[i];
 
 			if (delta < 0)
 			{
@@ -95,7 +95,7 @@
 
 			state->m_dial[i] += delta;
 
-			switch (input_port_read(device->machine(), i ? "GEAR_P2" : "GEAR_P1") & 15)
+			switch (device->machine().root_device().ioport(i ? "GEAR_P2" : "GEAR_P1")->read() & 15)
 			{
 			case 1: state->m_gear[i] = 1; break;
 			case 2: state->m_gear[i] = 2; break;
@@ -126,13 +126,13 @@
 
 READ8_MEMBER(sprint2_state::sprint2_dip_r)
 {
-	return (input_port_read(machine(), "DSW") << (2 * ((offset & 3) ^ 3))) & 0xc0;
+	return (ioport("DSW")->read() << (2 * ((offset & 3) ^ 3))) & 0xc0;
 }
 
 
 READ8_MEMBER(sprint2_state::sprint2_input_A_r)
 {
-	UINT8 val = input_port_read(machine(), "INA");
+	UINT8 val = ioport("INA")->read();
 
 	if (m_game == 2)// (GAME_IS_SPRINT2)
 	{
@@ -150,7 +150,7 @@
 
 READ8_MEMBER(sprint2_state::sprint2_input_B_r)
 {
-	UINT8 val = input_port_read(machine(), "INB");
+	UINT8 val = ioport("INB")->read();
 
 	if (m_game == 1) // (GAME_IS_SPRINT1)
 	{
diff -Nru src-old/mame/drivers/sprint4.c src/mame/drivers/sprint4.c
--- src-old/mame/drivers/sprint4.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/sprint4.c	2012-05-03 11:00:08.000000000 +0200
@@ -50,17 +50,17 @@
 
 	UINT8 wheel[4] =
 	{
-		input_port_read(machine, "WHEEL1"),
-		input_port_read(machine, "WHEEL2"),
-		input_port_read(machine, "WHEEL3"),
-		input_port_read(machine, "WHEEL4")
+		state->ioport("WHEEL1")->read(),
+		state->ioport("WHEEL2")->read(),
+		state->ioport("WHEEL3")->read(),
+		state->ioport("WHEEL4")->read()
 	};
 	UINT8 lever[4] =
 	{
-		input_port_read(machine, "LEVER1"),
-		input_port_read(machine, "LEVER2"),
-		input_port_read(machine, "LEVER3"),
-		input_port_read(machine, "LEVER4")
+		machine.root_device().ioport("LEVER1")->read(),
+		machine.root_device().ioport("LEVER2")->read(),
+		machine.root_device().ioport("LEVER3")->read(),
+		machine.root_device().ioport("LEVER4")->read()
 	};
 
 	int i;
@@ -99,9 +99,9 @@
 
 	/* NMI and watchdog are disabled during service mode */
 
-	machine.watchdog_enable(input_port_read(machine, "IN0") & 0x40);
+	machine.watchdog_enable(machine.root_device().ioport("IN0")->read() & 0x40);
 
-	if (input_port_read(machine, "IN0") & 0x40)
+	if (machine.root_device().ioport("IN0")->read() & 0x40)
 		cputag_set_input_line(machine, "maincpu", INPUT_LINE_NMI, PULSE_LINE);
 
 	machine.scheduler().timer_set(machine.primary_screen->time_until_pos(scanline), FUNC(nmi_callback), scanline);
@@ -134,21 +134,21 @@
 
 READ8_MEMBER(sprint4_state::sprint4_analog_r)
 {
-	return (input_port_read(machine(), "ANALOG") << (~offset & 7)) & 0x80;
+	return (ioport("ANALOG")->read() << (~offset & 7)) & 0x80;
 }
 READ8_MEMBER(sprint4_state::sprint4_coin_r)
 {
-	return (input_port_read(machine(), "COIN") << (~offset & 7)) & 0x80;
+	return (ioport("COIN")->read() << (~offset & 7)) & 0x80;
 }
 READ8_MEMBER(sprint4_state::sprint4_collision_r)
 {
-	return (input_port_read(machine(), "COLLISION") << (~offset & 7)) & 0x80;
+	return (ioport("COLLISION")->read() << (~offset & 7)) & 0x80;
 }
 
 
 READ8_MEMBER(sprint4_state::sprint4_options_r)
 {
-	return (input_port_read(machine(), "DIP") >> (2 * (offset & 3))) & 3;
+	return (ioport("DIP")->read() >> (2 * (offset & 3))) & 3;
 }
 
 
@@ -259,7 +259,7 @@
 
 	PORT_START("IN0")
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Track Select") PORT_CODE(KEYCODE_SPACE)
diff -Nru src-old/mame/drivers/sprint8.c src/mame/drivers/sprint8.c
--- src-old/mame/drivers/sprint8.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/sprint8.c	2012-05-03 11:00:08.000000000 +0200
@@ -32,7 +32,7 @@
 
 	for (i = 0; i < 8; i++)
 	{
-		UINT8 val = input_port_read(timer.machine(), dialnames[i]) >> 4;
+		UINT8 val = timer.machine().root_device().ioport(dialnames[i])->read() >> 4;
 
 		signed char delta = (val - state->m_dial[i]) & 15;
 
@@ -69,7 +69,7 @@
 READ8_MEMBER(sprint8_state::sprint8_input_r)
 {
 	static const char *const portnames[] = { "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8" };
-	UINT8 val = input_port_read(machine(), portnames[offset]);
+	UINT8 val = ioport(portnames[offset])->read();
 
 	if (m_steer_dir[offset])
 	{
@@ -255,7 +255,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Track Select") PORT_CODE(KEYCODE_SPACE)
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	/* this is actually a variable resistor */
 	PORT_START("R132")
@@ -383,7 +383,7 @@
 	PORT_DIPSETTING(    0x01, "Tag" )
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	/* this is actually a variable resistor */
 	PORT_START("R132")
diff -Nru src-old/mame/drivers/srmp2.c src/mame/drivers/srmp2.c
--- src-old/mame/drivers/srmp2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/srmp2.c	2012-05-03 11:00:08.000000000 +0200
@@ -261,7 +261,7 @@
 
 		for (t = 0 ; t < 8 ; t ++)
 		{
-			if (!(input_port_read(machine, keynames[j+p_side]) & ( 1 << t )))
+			if (!(machine.root_device().ioport(keynames[j+p_side])->read() & ( 1 << t )))
 			{
 				return (i + t) | (p_side ? 0x20 : 0x00);
 			}
@@ -313,7 +313,7 @@
 		return iox_key_matrix_calc(machine(),(iox.mux == 2) ? 0 : 4);
 	}
 
-	return input_port_read(machine(),"SERVICE") & 0xff;
+	return ioport("SERVICE")->read() & 0xff;
 }
 
 READ8_MEMBER(srmp2_state::iox_status_r)
diff -Nru src-old/mame/drivers/srmp5.c src/mame/drivers/srmp5.c
--- src-old/mame/drivers/srmp5.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/srmp5.c	2012-05-03 11:00:08.000000000 +0200
@@ -288,17 +288,17 @@
 	switch (m_input_select)
 	{
 	case 0x01:
-		ret = input_port_read(machine(), "IN0");
+		ret = ioport("IN0")->read();
 		break;
 	case 0x02:
-		ret = input_port_read(machine(), "IN1");
+		ret = ioport("IN1")->read();
 		break;
 	case 0x04:
-		ret = input_port_read(machine(), "IN2");
+		ret = ioport("IN2")->read();
 		break;
 	case 0x00:
 	case 0x08:
-		ret = input_port_read(machine(), "IN3");
+		ret = ioport("IN3")->read();
 		break;
 	}
 	return ret;
diff -Nru src-old/mame/drivers/srmp6.c src/mame/drivers/srmp6.c
--- src-old/mame/drivers/srmp6.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/srmp6.c	2012-05-03 11:00:08.000000000 +0200
@@ -311,14 +311,14 @@
 {
 
 	if (offset == 0)			// DSW
-		return input_port_read(machine(), "DSW");
+		return ioport("DSW")->read();
 
 	switch (m_input_select)	// inputs
 	{
-		case 1<<0: return input_port_read(machine(), "KEY0");
-		case 1<<1: return input_port_read(machine(), "KEY1");
-		case 1<<2: return input_port_read(machine(), "KEY2");
-		case 1<<3: return input_port_read(machine(), "KEY3");
+		case 1<<0: return ioport("KEY0")->read();
+		case 1<<1: return ioport("KEY1")->read();
+		case 1<<2: return ioport("KEY2")->read();
+		case 1<<3: return ioport("KEY3")->read();
 	}
 
 	return 0;
diff -Nru src-old/mame/drivers/ssfindo.c src/mame/drivers/ssfindo.c
--- src-old/mame/drivers/ssfindo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ssfindo.c	2012-05-03 11:00:08.000000000 +0200
@@ -393,10 +393,10 @@
 
 			if( m_iocr_hack)
 			{
-				return (input_port_read(machine(), "PS7500") & 0x80) | 0x34 | (machine().rand()&3); //eeprom read ?
+				return (ioport("PS7500")->read() & 0x80) | 0x34 | (machine().rand()&3); //eeprom read ?
 			}
 
-			return (input_port_read(machine(), "PS7500") & 0x80) | 0x37;
+			return (ioport("PS7500")->read() & 0x80) | 0x37;
 
 		case VIDCR:
 			return (m_PS7500_IO[offset] | 0x50) & 0xfffffff0;
@@ -613,7 +613,7 @@
 
 static INPUT_PORTS_START( ssfindo )
 	PORT_START("PS7500")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN0")
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_UNUSED	)				// IPT_START2 ??
@@ -663,7 +663,7 @@
 
 static INPUT_PORTS_START( ppcar )
 	PORT_START("PS7500")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN0")
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN1	)
@@ -680,7 +680,7 @@
 
 static INPUT_PORTS_START( tetfight )
 	PORT_START("PS7500")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")
 	PORT_DIPNAME( 0x01, 0x01, "DSW 0" )
diff -Nru src-old/mame/drivers/sshangha.c src/mame/drivers/sshangha.c
--- src-old/mame/drivers/sshangha.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sshangha.c	2012-05-03 11:00:08.000000000 +0200
@@ -73,11 +73,11 @@
 	switch (offset)
 	{
 		case 0x050 >> 1:
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 		case 0x76a >> 1:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 0x0ac >> 1:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		// Protection TODO
 	}
@@ -91,11 +91,11 @@
 	switch (offset)
 	{
 		case 0x050 >> 1:
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 		case 0x76a >> 1:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 0x0ac >> 1:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 	}
 
 	return m_prot_data[offset];
@@ -259,7 +259,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -278,23 +278,23 @@
 	PORT_DIPSETTING(      0x0010, "Mode 1" )
 	PORT_DIPSETTING(      0x0000, "Mode 2" )
 	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(      0x0008, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x0008, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0008, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0008, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
 	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(      0x0002, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_EQUALS, 0x0010) //Mode 1
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
-	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0010, PORTCOND_NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0002, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_3C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x0010, EQUALS, 0x0010) //Mode 1
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0002, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
+	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x0010, NOTEQUALS, 0x0010) //Mode 2
 	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x4000, DEF_STR( Easy ) )
 	PORT_DIPSETTING(      0xc000, DEF_STR( Normal ) )
diff -Nru src-old/mame/drivers/ssingles.c src/mame/drivers/ssingles.c
--- src-old/mame/drivers/ssingles.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ssingles.c	2012-05-03 11:00:08.000000000 +0200
@@ -342,7 +342,7 @@
 CUSTOM_INPUT_MEMBER(ssingles_state::controls_r)
 {
 	int data = 7;
-	switch(input_port_read(machine(), "EXTRA"))		//multiplexed
+	switch(ioport("EXTRA")->read())		//multiplexed
 	{
 		case 0x01: data = 1; break;
 		case 0x02: data = 2; break;
diff -Nru src-old/mame/drivers/ssozumo.c src/mame/drivers/ssozumo.c
--- src-old/mame/drivers/ssozumo.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/ssozumo.c	2012-05-03 11:00:08.000000000 +0200
@@ -129,7 +129,7 @@
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Controls ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Single ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Dual ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/sspeedr.c src/mame/drivers/sspeedr.c
--- src-old/mame/drivers/sspeedr.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/drivers/sspeedr.c	2012-05-05 22:08:22.000000000 +0200
@@ -108,7 +108,7 @@
 ADDRESS_MAP_END
 
 
-static const UINT32 sspeedr_controller_table[] =
+static const ioport_value sspeedr_controller_table[] =
 {
 	0x3f, 0x3e, 0x3c, 0x3d, 0x39, 0x38, 0x3a, 0x3b,
 	0x33, 0x32, 0x30, 0x31, 0x35, 0x34, 0x36, 0x37,
diff -Nru src-old/mame/drivers/ssrj.c src/mame/drivers/ssrj.c
--- src-old/mame/drivers/ssrj.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/ssrj.c	2012-05-03 11:00:08.000000000 +0200
@@ -45,7 +45,7 @@
 
 READ8_MEMBER(ssrj_state::ssrj_wheel_r)
 {
-	int port = input_port_read(machine(), "IN1") - 0x80;
+	int port = ioport("IN1")->read() - 0x80;
 	int retval = port - m_oldport;
 
 	m_oldport = port;
diff -Nru src-old/mame/drivers/sstrangr.c src/mame/drivers/sstrangr.c
--- src-old/mame/drivers/sstrangr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/sstrangr.c	2012-05-03 11:00:08.000000000 +0200
@@ -186,7 +186,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY
 
 	PORT_START("EXT")      /* External switches */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -253,7 +253,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_PLAYER(1)
 
 	PORT_START("EXT")      /* External switches */
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_DIPNAME( 0x02, 0x00, "Player's Bullet Speed (Cheat)" )
 	PORT_DIPSETTING(    0x00, "Slow" )
 	PORT_DIPSETTING(    0x02, "Fast" )
diff -Nru src-old/mame/drivers/ssv.c src/mame/drivers/ssv.c
--- src-old/mame/drivers/ssv.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/ssv.c	2012-05-03 11:00:08.000000000 +0200
@@ -459,7 +459,7 @@
 	static const char *const gunnames[] = { "GUNX1", "GUNY1", "GUNX2", "GUNY2" };
 
 	eeprom_device *eeprom = downcast<eeprom_device *>(device);
-	return (((state->m_gdfs_lightgun_select & 1) ? 0 : 0xff) ^ input_port_read(device->machine(), gunnames[state->m_gdfs_lightgun_select])) | (eeprom->read_bit() << 8);
+	return (((state->m_gdfs_lightgun_select & 1) ? 0 : 0xff) ^ device->machine().root_device().ioport(gunnames[state->m_gdfs_lightgun_select])->read()) | (eeprom->read_bit() << 8);
 }
 
 static WRITE16_DEVICE_HANDLER( gdfs_eeprom_w )
@@ -608,10 +608,10 @@
 {
 	UINT16 input_sel = *m_input_sel;
 
-	if (input_sel & 0x0001)	return input_port_read(machine(), "KEY0");
-	if (input_sel & 0x0002)	return input_port_read(machine(), "KEY1");
-	if (input_sel & 0x0004)	return input_port_read(machine(), "KEY2");
-	if (input_sel & 0x0008)	return input_port_read(machine(), "KEY3");
+	if (input_sel & 0x0001)	return ioport("KEY0")->read();
+	if (input_sel & 0x0002)	return ioport("KEY1")->read();
+	if (input_sel & 0x0004)	return ioport("KEY2")->read();
+	if (input_sel & 0x0008)	return ioport("KEY3")->read();
 	logerror("CPU #0 PC %06X: unknown input read: %04X\n",cpu_get_pc(&space.device()),input_sel);
 	return 0xffff;
 }
@@ -733,10 +733,10 @@
 {
 	UINT16 input_sel = *m_input_sel;
 
-	if (input_sel & 0x0002)	return input_port_read(machine(), "KEY0");
-	if (input_sel & 0x0004)	return input_port_read(machine(), "KEY1");
-	if (input_sel & 0x0008)	return input_port_read(machine(), "KEY2");
-	if (input_sel & 0x0010)	return input_port_read(machine(), "KEY3");
+	if (input_sel & 0x0002)	return ioport("KEY0")->read();
+	if (input_sel & 0x0004)	return ioport("KEY1")->read();
+	if (input_sel & 0x0008)	return ioport("KEY2")->read();
+	if (input_sel & 0x0010)	return ioport("KEY3")->read();
 	logerror("CPU #0 PC %06X: unknown input read: %04X\n",cpu_get_pc(&space.device()),input_sel);
 	return 0xffff;
 }
@@ -781,10 +781,10 @@
 {
 	UINT16 input_sel = *m_input_sel;
 
-	if (input_sel & 0x0002)	return input_port_read(machine(), "KEY0");
-	if (input_sel & 0x0004)	return input_port_read(machine(), "KEY1");
-	if (input_sel & 0x0008)	return input_port_read(machine(), "KEY2");
-	if (input_sel & 0x0010)	return input_port_read(machine(), "KEY3");
+	if (input_sel & 0x0002)	return ioport("KEY0")->read();
+	if (input_sel & 0x0004)	return ioport("KEY1")->read();
+	if (input_sel & 0x0008)	return ioport("KEY2")->read();
+	if (input_sel & 0x0010)	return ioport("KEY3")->read();
 	logerror("CPU #0 PC %06X: unknown input read: %04X\n",cpu_get_pc(&space.device()),input_sel);
 	return 0xffff;
 }
@@ -827,7 +827,7 @@
 
 READ16_MEMBER(ssv_state::sxyreact_ballswitch_r)
 {
-	return input_port_read_safe(machine(), "SERVICE", 0);
+	return ioport("SERVICE")->read_safe(0);
 }
 
 READ16_MEMBER(ssv_state::sxyreact_dial_r)
@@ -843,7 +843,7 @@
 	{
 
 		if (data & 0x20)
-			m_sxyreact_serial = input_port_read_safe(machine(), "PADDLE", 0) & 0xff;
+			m_sxyreact_serial = ioport("PADDLE")->read_safe(0) & 0xff;
 
 		if ( (m_sxyreact_dial & 0x40) && !(data & 0x40) )	// $40 -> $00
 			m_sxyreact_serial <<= 1;						// shift 1 bit
@@ -986,11 +986,11 @@
 
 	switch(m_trackball_select)
 	{
-		case 0x60:	return (input_port_read(machine(), "TRACKX") >> 8) & 0xff;
-		case 0x40:	return (input_port_read(machine(), "TRACKX") >> 0) & 0xff;
+		case 0x60:	return (ioport("TRACKX")->read() >> 8) & 0xff;
+		case 0x40:	return (ioport("TRACKX")->read() >> 0) & 0xff;
 
-		case 0x70:	return (input_port_read(machine(), "TRACKY") >> 8) & 0xff;
-		case 0x50:	return (input_port_read(machine(), "TRACKY") >> 0) & 0xff;
+		case 0x70:	return (ioport("TRACKY")->read() >> 8) & 0xff;
+		case 0x50:	return (ioport("TRACKY")->read() >> 0) & 0xff;
 	}
 	return 0;
 }
diff -Nru src-old/mame/drivers/st0016.c src/mame/drivers/st0016.c
--- src-old/mame/drivers/st0016.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/st0016.c	2012-05-03 11:00:08.000000000 +0200
@@ -45,18 +45,18 @@
         xxxx - input port #2
     xxxx     - dip switches (2x8 bits) (multiplexed)
 */
-	int retval = input_port_read(machine(), "SYSTEM") & 0x0f;
+	int retval = ioport("SYSTEM")->read() & 0x0f;
 
 	switch(mux_port & 0x30)
 	{
-		case 0x00: retval |= ((input_port_read(machine(), "DSW1") & 1) << 4) | ((input_port_read(machine(), "DSW1") & 0x10) << 1)
-								| ((input_port_read(machine(), "DSW2") & 1) << 6) | ((input_port_read(machine(), "DSW2") & 0x10) <<3); break;
-		case 0x10: retval |= ((input_port_read(machine(), "DSW1") & 2) << 3) | ((input_port_read(machine(), "DSW1") & 0x20)   )
-								| ((input_port_read(machine(), "DSW2") & 2) << 5) | ((input_port_read(machine(), "DSW2") & 0x20) <<2); break;
-		case 0x20: retval |= ((input_port_read(machine(), "DSW1") & 4) << 2) | ((input_port_read(machine(), "DSW1") & 0x40) >> 1)
-								| ((input_port_read(machine(), "DSW2") & 4) << 4) | ((input_port_read(machine(), "DSW2") & 0x40) <<1); break;
-		case 0x30: retval |= ((input_port_read(machine(), "DSW1") & 8) << 1) | ((input_port_read(machine(), "DSW1") & 0x80) >> 2)
-								| ((input_port_read(machine(), "DSW2") & 8) << 3) | ((input_port_read(machine(), "DSW2") & 0x80)    ); break;
+		case 0x00: retval |= ((ioport("DSW1")->read() & 1) << 4) | ((ioport("DSW1")->read() & 0x10) << 1)
+								| ((ioport("DSW2")->read() & 1) << 6) | ((ioport("DSW2")->read() & 0x10) <<3); break;
+		case 0x10: retval |= ((ioport("DSW1")->read() & 2) << 3) | ((ioport("DSW1")->read() & 0x20)   )
+								| ((ioport("DSW2")->read() & 2) << 5) | ((ioport("DSW2")->read() & 0x20) <<2); break;
+		case 0x20: retval |= ((ioport("DSW1")->read() & 4) << 2) | ((ioport("DSW1")->read() & 0x40) >> 1)
+								| ((ioport("DSW2")->read() & 4) << 4) | ((ioport("DSW2")->read() & 0x40) <<1); break;
+		case 0x30: retval |= ((ioport("DSW1")->read() & 8) << 1) | ((ioport("DSW1")->read() & 0x80) >> 2)
+								| ((ioport("DSW2")->read() & 8) << 3) | ((ioport("DSW2")->read() & 0x80)    ); break;
 	}
 
 	return retval;
diff -Nru src-old/mame/drivers/stactics.c src/mame/drivers/stactics.c
--- src-old/mame/drivers/stactics.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/stactics.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,8 +81,8 @@
 	 /* monitor motor under joystick control */
     if (*state->m_motor_on & 0x01)
     {
-		int ip3 = input_port_read(machine, "IN3");
-		int ip4 = input_port_read(machine, "FAKE");
+		int ip3 = machine.root_device().ioport("IN3")->read();
+		int ip4 = machine.root_device().ioport("FAKE")->read();
 
 		/* up */
 		if (((ip4 & 0x01) == 0) && (state->m_vert_pos > -128))
diff -Nru src-old/mame/drivers/stadhero.c src/mame/drivers/stadhero.c
--- src-old/mame/drivers/stadhero.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/stadhero.c	2012-05-03 11:00:08.000000000 +0200
@@ -25,13 +25,13 @@
 	switch (offset<<1)
 	{
 		case 0:
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 
 		case 2:
-			return input_port_read(machine(), "COIN");
+			return ioport("COIN")->read();
 
 		case 4:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 	}
 
 	logerror("CPU #0 PC %06x: warning - read unmapped memory address %06x\n",cpu_get_pc(&space.device()),0x30c000+offset);
@@ -150,7 +150,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 /******************************************************************************/
diff -Nru src-old/mame/drivers/starfire.c src/mame/drivers/starfire.c
--- src-old/mame/drivers/starfire.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/starfire.c	2012-05-03 11:00:08.000000000 +0200
@@ -102,11 +102,11 @@
 {
 	switch (offset & 15)
 	{
-		case 0:	return input_port_read(machine(), "DSW");
-		case 1:	return input_port_read(machine(), "SYSTEM");	/* Note: need to loopback sounds lengths on that one */
-		case 5: return input_port_read(machine(), "STICKZ");
-		case 6:	return input_port_read(machine(), "STICKX");
-		case 7:	return input_port_read(machine(), "STICKY");
+		case 0:	return ioport("DSW")->read();
+		case 1:	return ioport("SYSTEM")->read();	/* Note: need to loopback sounds lengths on that one */
+		case 5: return ioport("STICKZ")->read();
+		case 6:	return ioport("STICKX")->read();
+		case 7:	return ioport("STICKY")->read();
 		default: return 0xff;
 	}
 }
@@ -130,10 +130,10 @@
 
 	switch (offset & 15)
 	{
-		case 0:	return input_port_read(machine(), "DSW");
-		case 1:	return input_port_read(machine(), "SYSTEM");
+		case 0:	return ioport("DSW")->read();
+		case 1:	return ioport("SYSTEM")->read();
 		case 2:
-			temp = m_fireone_select ? input_port_read(machine(), "P1") : input_port_read(machine(), "P2");
+			temp = m_fireone_select ? ioport("P1")->read() : ioport("P2")->read();
 			temp = (temp & 0xc0) | fireone_paddle_map[temp & 0x3f];
 			return temp;
 		default: return 0xff;
diff -Nru src-old/mame/drivers/starshp1.c src/mame/drivers/starshp1.c
--- src-old/mame/drivers/starshp1.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/starshp1.c	2012-05-03 11:00:08.000000000 +0200
@@ -16,7 +16,7 @@
 
 static INTERRUPT_GEN( starshp1_interrupt )
 {
-	if ((input_port_read(device->machine(), "SYSTEM") & 0x90) != 0x90)
+	if ((device->machine().root_device().ioport("SYSTEM")->read() & 0x90) != 0x90)
 		generic_pulse_irq_line(device, 0, 1);
 }
 
@@ -71,16 +71,16 @@
 	switch (m_analog_in_select)
 	{
 	case 0:
-		val = input_port_read(machine(), "STICKY");
+		val = ioport("STICKY")->read();
 		break;
 	case 1:
-		val = input_port_read(machine(), "STICKX");
+		val = ioport("STICKX")->read();
 		break;
 	case 2:
 		val = 0x20; /* DAC feedback, not used */
 		break;
 	case 3:
-		val = input_port_read(machine(), "PLAYTIME");
+		val = ioport("PLAYTIME")->read();
 		break;
 	}
 
@@ -202,7 +202,7 @@
 	PORT_START("VBLANK")
 	PORT_BIT( 0x3f, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, starshp1_state,starshp1_analog_r, NULL)	/* analog in */
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("COINAGE")
 	PORT_BIT( 0x0f, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, starshp1_state,collision_latch_r, NULL)	/* collision latch */
diff -Nru src-old/mame/drivers/statriv2.c src/mame/drivers/statriv2.c
--- src-old/mame/drivers/statriv2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/statriv2.c	2012-05-03 11:00:08.000000000 +0200
@@ -204,7 +204,7 @@
 static INTERRUPT_GEN( statriv2_interrupt )
 {
 	statriv2_state *state = device->machine().driver_data<statriv2_state>();
-	UINT8 new_coin = input_port_read(device->machine(), "COIN");
+	UINT8 new_coin = state->ioport("COIN")->read();
 
 	/* check the coin inputs once per frame */
 	state->m_latched_coin |= new_coin & (new_coin ^ state->m_last_coin);
diff -Nru src-old/mame/drivers/stlforce.c src/mame/drivers/stlforce.c
--- src-old/mame/drivers/stlforce.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/stlforce.c	2012-05-03 11:00:08.000000000 +0200
@@ -137,7 +137,7 @@
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE_NO_TOGGLE( 0x0008, IP_ACTIVE_LOW )
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0040, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit) /* eeprom */
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/stv.c src/mame/drivers/stv.c
--- src-old/mame/drivers/stv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/stv.c	2012-05-03 11:00:08.000000000 +0200
@@ -58,12 +58,12 @@
 
 	switch(offset)
 	{
-		case 0x01: res = input_port_read(machine(), "PORTA"); break; // P1
-		case 0x03: res = input_port_read(machine(), "PORTB"); break; // P2
-		case 0x05: res = input_port_read(machine(), "PORTC"); break; // SYSTEM
+		case 0x01: res = ioport("PORTA")->read(); break; // P1
+		case 0x03: res = ioport("PORTB")->read(); break; // P2
+		case 0x05: res = ioport("PORTC")->read(); break; // SYSTEM
 		case 0x07: res = m_system_output | 0xf0; break; // port D, read-backs value written
-		case 0x09: res = input_port_read(machine(), "PORTE"); break; // P3
-		case 0x0b: res = input_port_read(machine(), "PORTF"); break; // P4
+		case 0x09: res = ioport("PORTE")->read(); break; // P3
+		case 0x0b: res = ioport("PORTF")->read(); break; // P4
 		case 0x1b: res = 0; break; // Serial COM READ status
 	}
 
@@ -101,9 +101,9 @@
 	{
 		case 0x01:
 		case 0x03:
-			res = input_port_read(machine(), lgnames[offset >> 1]);
+			res = ioport(lgnames[offset >> 1])->read();
 			res = BITSWAP8(res, 2, 3, 0, 1, 6, 7, 5, 4) & 0xf3;
-			res |= (input_port_read(machine(), "PORTC") & 0x10) ? 0x0 : 0x4; // x/y hit latch actually
+			res |= (ioport("PORTC")->read() & 0x10) ? 0x0 : 0x4; // x/y hit latch actually
 			break;
 		default: res = stv_ioga_r(space,offset); break;
 	}
@@ -169,7 +169,7 @@
 				for(i=0;i<5;i++)
 				{
 					if(m_mux_data & 1 << i)
-						res = input_port_read(machine(), mpnames[offset >> 1][i]);
+						res = ioport(mpnames[offset >> 1][i])->read();
 				}
 			}
 			break;
@@ -1993,7 +1993,7 @@
 	ROM_LOAD16_WORD_SWAP( "mpr-18275.ic4",    0x0c00000, 0x0200000, CRC(7691deca) SHA1(aabb6b098963caf51f66aefa0a97aed7eb86c308) ) // good
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "sfish2", 0, SHA1(a10073d83bbbe16e16f69ad48565821576557d61) )
+	DISK_IMAGE( "sfish2", 0, BAD_DUMP SHA1(a10073d83bbbe16e16f69ad48565821576557d61) )
 
 	ROM_REGION32_BE( 0x3000000, "abus", ROMREGION_ERASE00 ) /* SH2 code */ \
 ROM_END
@@ -2014,7 +2014,7 @@
 	ROM_LOAD16_WORD_SWAP( "mpr-18274.ic3",    0x0800000, 0x0400000, CRC(a6d76d23) SHA1(eee8c824eff4485d1b3af93a4fd5b21262eec803) ) // good
 
 	DISK_REGION( "cdrom" )
-	DISK_IMAGE( "sfish2", 0, SHA1(a10073d83bbbe16e16f69ad48565821576557d61) )
+	DISK_IMAGE( "sfish2", 0, BAD_DUMP SHA1(a10073d83bbbe16e16f69ad48565821576557d61) )
 
 	ROM_REGION32_BE( 0x3000000, "abus", ROMREGION_ERASE00 ) /* SH2 code */
 ROM_END
diff -Nru src-old/mame/drivers/subs.c src/mame/drivers/subs.c
--- src-old/mame/drivers/subs.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/subs.c	2012-05-05 16:28:21.000000000 +0200
@@ -114,7 +114,7 @@
 	PORT_BIT ( 0x02, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT ( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT ( 0x08, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT ( 0x10, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x10, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("lscreen")
 	PORT_BIT ( 0x20, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_SERVICE_NO_TOGGLE( 0x40, IP_ACTIVE_LOW )
 	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )
diff -Nru src-old/mame/drivers/subsino2.c src/mame/drivers/subsino2.c
--- src-old/mame/drivers/subsino2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/subsino2.c	2012-05-03 11:00:08.000000000 +0200
@@ -96,7 +96,7 @@
 	UINT8 m_dsw_mask;
 	optional_shared_ptr<UINT16> m_outputs16;
 	optional_shared_ptr<UINT8> m_outputs;
-	required_shared_ptr<UINT8> m_am188em_regs;
+	optional_shared_ptr<UINT8> m_am188em_regs;
 	UINT16 m_bishjan_sel;
 	UINT16 m_bishjan_input;
 	DECLARE_WRITE8_MEMBER(ss9601_byte_lo_w);
@@ -786,10 +786,10 @@
 
 READ8_MEMBER(subsino2_state::dsw_r)
 {
-	return	( (input_port_read(machine(), "DSW1") & m_dsw_mask) ? 0x01 : 0 ) |
-			( (input_port_read(machine(), "DSW2") & m_dsw_mask) ? 0x02 : 0 ) |
-			( (input_port_read(machine(), "DSW3") & m_dsw_mask) ? 0x04 : 0 ) |
-			( (input_port_read(machine(), "DSW4") & m_dsw_mask) ? 0x08 : 0 ) ;
+	return	( (ioport("DSW1")->read() & m_dsw_mask) ? 0x01 : 0 ) |
+			( (ioport("DSW2")->read() & m_dsw_mask) ? 0x02 : 0 ) |
+			( (ioport("DSW3")->read() & m_dsw_mask) ? 0x04 : 0 ) |
+			( (ioport("DSW4")->read() & m_dsw_mask) ? 0x08 : 0 ) ;
 }
 
 
@@ -915,10 +915,10 @@
 
 	for (i = 0; i < 5; i++)
 		if (m_bishjan_input & (1 << i))
-			res = input_port_read(machine(), port[i]);
+			res = ioport(port[i])->read();
 
 	return	(res << 8) |									// high byte
-			input_port_read(machine(), "SYSTEM") |		// low byte
+			ioport("SYSTEM")->read() |		// low byte
 			(machine().device<ticket_dispenser_device>("hopper")->read(space, 0) ? 0x00 : 0x04)	// bit 2: hopper sensor
 	;
 }
diff -Nru src-old/mame/drivers/suna8.c src/mame/drivers/suna8.c
--- src-old/mame/drivers/suna8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/suna8.c	2012-05-03 11:00:08.000000000 +0200
@@ -470,10 +470,10 @@
 
 	switch (*m_hardhead_ip)
 	{
-		case 0:	return input_port_read(machine(), "P1");
-		case 1:	return input_port_read(machine(), "P2");
-		case 2:	return input_port_read(machine(), "DSW1");
-		case 3:	return input_port_read(machine(), "DSW2");
+		case 0:	return ioport("P1")->read();
+		case 1:	return ioport("P2")->read();
+		case 2:	return ioport("DSW1")->read();
+		case 3:	return ioport("DSW2")->read();
 		default:
 			logerror("CPU #0 - PC %04X: Unknown IP read: %02X\n", cpu_get_pc(&space.device()), *m_hardhead_ip);
 			return 0xff;
@@ -1329,7 +1329,7 @@
 	PORT_BIT(  0x08, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT(  0x10, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 	PORT_BIT(  0x20, IP_ACTIVE_LOW,  IPT_UNKNOWN )
-	PORT_BIT(  0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT(  0x40, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT(  0x80, IP_ACTIVE_LOW,  IPT_UNKNOWN )
 
 INPUT_PORTS_END
diff -Nru src-old/mame/drivers/supbtime.c src/mame/drivers/supbtime.c
--- src-old/mame/drivers/supbtime.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/supbtime.c	2012-05-03 11:00:08.000000000 +0200
@@ -36,11 +36,11 @@
 	switch (offset << 1)
 	{
 		case 0:
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 		case 2:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 8:
-			return input_port_read(machine(), "COIN");
+			return ioport("COIN")->read();
 		case 10: /* ?  Not used for anything */
 		case 12:
 			return 0;
@@ -131,7 +131,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -209,7 +209,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/superchs.c src/mame/drivers/superchs.c
--- src-old/mame/drivers/superchs.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/superchs.c	2012-05-03 11:00:08.000000000 +0200
@@ -109,7 +109,7 @@
 	switch (offset)
 	{
 		case 0x00:
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 
 		case 0x01:
 			return m_coin_word<<16;
@@ -169,12 +169,12 @@
 
 READ32_MEMBER(superchs_state::superchs_stick_r)
 {
-	int fake = input_port_read(machine(), "FAKE");
+	int fake = ioport("FAKE")->read();
 	int accel;
 
 	if (!(fake &0x10))	/* Analogue steer (the real control method) */
 	{
-		m_steer = input_port_read(machine(), "WHEEL");
+		m_steer = ioport("WHEEL")->read();
 	}
 	else	/* Digital steer, with smoothing - speed depends on how often stick_r is called */
 	{
@@ -199,13 +199,13 @@
 	}
 
 	/* Accelerator is an analogue input but the game treats it as digital (on/off) */
-	if (input_port_read(machine(),  "FAKE") & 0x1)	/* pressing B1 */
+	if (ioport("FAKE")->read() & 0x1)	/* pressing B1 */
 		accel = 0x0;
 	else
 		accel = 0xff;
 
 	/* Todo: Verify brake - and figure out other input */
-	return (m_steer << 24) | (accel << 16) | (input_port_read(machine(), "SOUND") << 8) | input_port_read(machine(), "UNKNOWN");
+	return (m_steer << 24) | (accel << 16) | (ioport("SOUND")->read() << 8) | ioport("UNKNOWN")->read();
 }
 
 WRITE32_MEMBER(superchs_state::superchs_stick_w)
diff -Nru src-old/mame/drivers/superqix.c src/mame/drivers/superqix.c
--- src-old/mame/drivers/superqix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/superqix.c	2012-05-03 11:00:08.000000000 +0200
@@ -112,7 +112,7 @@
 {
 	superqix_state *state = device.machine().driver_data<superqix_state>();
 	running_machine &machine = device.machine();
-	UINT8 *src = machine.root_device().memregion("samples")->base();
+	UINT8 *src = state->memregion("samples")->base();
 	int i, len = state->memregion("samples")->bytes();
 
 	/* convert 8-bit unsigned samples to 8-bit signed */
@@ -174,7 +174,7 @@
 {
 	superqix_state *state = device->machine().driver_data<superqix_state>();
 //  logerror("%04x: in4_mcu_r\n",cpu_get_pc(&space->device()));
-	return input_port_read(device->machine(), "P2") | (state->m_from_mcu_pending << 6) | (state->m_from_z80_pending << 7);
+	return state->ioport("P2")->read() | (state->m_from_mcu_pending << 6) | (state->m_from_z80_pending << 7);
 }
 
 static READ8_DEVICE_HANDLER( sqix_from_mcu_r )
@@ -255,11 +255,11 @@
 {
 	if ((m_port1 & 0x10) == 0)
 	{
-		return input_port_read(machine(), "DSW1");
+		return ioport("DSW1")->read();
 	}
 	else if ((m_port1 & 0x20) == 0)
 	{
-		return input_port_read(machine(), "SYSTEM") | (m_from_mcu_pending << 6) | (m_from_z80_pending << 7);
+		return ioport("SYSTEM")->read() | (m_from_mcu_pending << 6) | (m_from_z80_pending << 7);
 	}
 	else if ((m_port1 & 0x40) == 0)
 	{
@@ -272,7 +272,7 @@
 
 READ8_MEMBER(superqix_state::sqixu_mcu_p0_r)
 {
-	return input_port_read(machine(), "SYSTEM") | (m_from_mcu_pending << 6) | (m_from_z80_pending << 7);
+	return ioport("SYSTEM")->read() | (m_from_mcu_pending << 6) | (m_from_z80_pending << 7);
 }
 
 WRITE8_MEMBER(superqix_state::sqixu_mcu_p2_w)
@@ -325,7 +325,7 @@
 
 static READ8_DEVICE_HANDLER( bootleg_in0_r )
 {
-	return BITSWAP8(input_port_read(device->machine(), "DSW1"), 0,1,2,3,4,5,6,7);
+	return BITSWAP8(device->machine().root_device().ioport("DSW1")->read(), 0,1,2,3,4,5,6,7);
 }
 
 WRITE8_MEMBER(superqix_state::bootleg_flipscreen_w)
@@ -352,7 +352,7 @@
 	int newpos;
 
 	/* get the new position and adjust the result */
-	newpos = input_port_read(machine, player ? "DIAL2" : "DIAL1");
+	newpos = state->ioport(player ? "DIAL2" : "DIAL1")->read();
 	if (newpos != state->m_oldpos[player])
 	{
 		state->m_sign[player] = ((newpos - state->m_oldpos[player]) & 0x80) >> 7;
@@ -429,11 +429,11 @@
 		switch (data & 0x07)
 		{
 			case 0x0:	// dsw A
-				m_portA_in = input_port_read(machine(), "DSW1");
+				m_portA_in = ioport("DSW1")->read();
 				break;
 
 			case 0x1:	// dsw B
-				m_portA_in = input_port_read(machine(), "DSW2");
+				m_portA_in = ioport("DSW2")->read();
 				break;
 
 			case 0x2:
@@ -478,7 +478,7 @@
 {
 	superqix_state *state = device->machine().driver_data<superqix_state>();
 //  logerror("%04x: ay_port_a_r and mcu_pending is %d\n",cpu_get_pc(&space->device()),state->m_from_mcu_pending);
-	return input_port_read(device->machine(), "SYSTEM") | ((state->m_from_mcu_pending^1) << 7);
+	return state->ioport("SYSTEM")->read() | ((state->m_from_mcu_pending^1) << 7);
 }
 
 /**************************************************************************
@@ -499,15 +499,15 @@
 	{
 		case 0x01:
 		{
-			UINT8 p = input_port_read(machine(), m_curr_player ? "PLUNGER2" : "PLUNGER1") & 0xbf;
+			UINT8 p = ioport(m_curr_player ? "PLUNGER2" : "PLUNGER1")->read() & 0xbf;
 			if ((p & 0x3f) == 0) p |= 0x40;
 			return p;
 		}
 
-		case 0x02: return input_port_read(machine(), m_curr_player ? "DIAL2" : "DIAL1");
+		case 0x02: return ioport(m_curr_player ? "DIAL2" : "DIAL1")->read();
 
-		case 0x04: return input_port_read(machine(), "DSW1");
-		case 0x08: return input_port_read(machine(), "DSW2");
+		case 0x04: return ioport("DSW1")->read();
+		case 0x08: return ioport("DSW2")->read();
 
 		case 0x80: m_curr_player = 0; return 0;
 		case 0x81: m_curr_player = 1; return 0;
@@ -521,7 +521,7 @@
 {
 //  logerror("%04x: ay_port_a_r\n",cpu_get_pc(&space->device()));
 	/* bits 76------  MCU status bits */
-	return (device->machine().rand() & 0xc0) | input_port_read(device->machine(), "BUTTONS");
+	return (device->machine().rand() & 0xc0) | device->machine().root_device().ioport("BUTTONS")->read();
 }
 
 
@@ -867,7 +867,7 @@
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_VBLANK )	/* ??? */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ??? */
 	PORT_SERVICE( 0x80, IP_ACTIVE_LOW )
 
 	PORT_START("P2")
diff -Nru src-old/mame/drivers/suprgolf.c src/mame/drivers/suprgolf.c
--- src-old/mame/drivers/suprgolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/suprgolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -285,20 +285,20 @@
 {
 	UINT8 p1_sht_sw,p2_sht_sw;
 
-	p1_sht_sw = (input_port_read(device->machine(), "P1_RELEASE") & 0x80)>>7;
-	p2_sht_sw = (input_port_read(device->machine(), "P2_RELEASE") & 0x80)>>6;
+	p1_sht_sw = (device->machine().root_device().ioport("P1_RELEASE")->read() & 0x80)>>7;
+	p2_sht_sw = (device->machine().root_device().ioport("P2_RELEASE")->read() & 0x80)>>6;
 
 	return p1_sht_sw | p2_sht_sw;
 }
 
 static READ8_DEVICE_HANDLER( p1_r )
 {
-	return (input_port_read(device->machine(), "P1") & 0xf0) | ((input_port_read(device->machine(), "P1_ANALOG") & 0xf));
+	return (device->machine().root_device().ioport("P1")->read() & 0xf0) | ((device->machine().root_device().ioport("P1_ANALOG")->read() & 0xf));
 }
 
 static READ8_DEVICE_HANDLER( p2_r )
 {
-	return (input_port_read(device->machine(), "P2") & 0xf0) | ((input_port_read(device->machine(), "P2_ANALOG") & 0xf));
+	return (device->machine().root_device().ioport("P2")->read() & 0xf0) | ((device->machine().root_device().ioport("P2_ANALOG")->read() & 0xf));
 }
 
 static ADDRESS_MAP_START( suprgolf_map, AS_PROGRAM, 8, suprgolf_state )
diff -Nru src-old/mame/drivers/suprnova.c src/mame/drivers/suprnova.c
--- src-old/mame/drivers/suprnova.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/suprnova.c	2012-05-03 11:00:08.000000000 +0200
@@ -458,7 +458,7 @@
 CUSTOM_INPUT_MEMBER(skns_state::paddle_r)
 {
 	const char *tag = (const char *)param;
-	return input_port_read(machine(), tag);
+	return ioport(tag)->read();
 }
 
 static INPUT_PORTS_START( skns )		/* 3 buttons, 2 players */
diff -Nru src-old/mame/drivers/suprridr.c src/mame/drivers/suprridr.c
--- src-old/mame/drivers/suprridr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/suprridr.c	2012-05-03 11:00:08.000000000 +0200
@@ -230,9 +230,9 @@
 
 	/* screen flip multiplexes controls */
 	if (suprridr_is_screen_flipped(machine()))
-		ret = input_port_read(machine(), SUPRRIDR_P2_CONTROL_PORT_TAG);
+		ret = ioport(SUPRRIDR_P2_CONTROL_PORT_TAG)->read();
 	else
-		ret = input_port_read(machine(), SUPRRIDR_P1_CONTROL_PORT_TAG);
+		ret = ioport(SUPRRIDR_P1_CONTROL_PORT_TAG)->read();
 
 	return ret;
 }
diff -Nru src-old/mame/drivers/system1.c src/mame/drivers/system1.c
--- src-old/mame/drivers/system1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/system1.c	2012-05-03 11:00:08.000000000 +0200
@@ -356,10 +356,10 @@
 static MACHINE_START( system1 )
 {
 	system1_state *state = machine.driver_data<system1_state>();
-	UINT32 numbanks = (machine.root_device().memregion("maincpu")->bytes() - 0x10000) / 0x4000;
+	UINT32 numbanks = (state->memregion("maincpu")->bytes() - 0x10000) / 0x4000;
 
 	if (numbanks > 0)
-		state->membank("bank1")->configure_entries(0, numbanks, machine.root_device().memregion("maincpu")->base() + 0x10000, 0x4000);
+		state->membank("bank1")->configure_entries(0, numbanks, state->memregion("maincpu")->base() + 0x10000, 0x4000);
 	else
 		state->membank("bank1")->configure_entry(0, state->memregion("maincpu")->base() + 0x8000);
 	state->membank("bank1")->set_entry(0);
@@ -442,7 +442,7 @@
 CUSTOM_INPUT_MEMBER(system1_state::dakkochn_mux_data_r)
 {
 	static const char *const ports[] = { "KEY0", "KEY1", "KEY2", "KEY3", "KEY4", "KEY5", "KEY6" };
-	return input_port_read(machine(), ports[m_dakkochn_mux_data]);
+	return ioport(ports[m_dakkochn_mux_data])->read();
 }
 
 
diff -Nru src-old/mame/drivers/system16.c src/mame/drivers/system16.c
--- src-old/mame/drivers/system16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/system16.c	2012-05-03 11:00:08.000000000 +0200
@@ -203,37 +203,37 @@
 
 READ16_MEMBER(segas1x_bootleg_state::passht4b_service_r)
 {
-	UINT16 val = input_port_read(machine(), "SERVICE");
+	UINT16 val = ioport("SERVICE")->read();
 
-	if(!(input_port_read(machine(), "P1") & 0x40)) val &= 0xef;
-	if(!(input_port_read(machine(), "P2") & 0x40)) val &= 0xdf;
-	if(!(input_port_read(machine(), "P3") & 0x40)) val &= 0xbf;
-	if(!(input_port_read(machine(), "P4") & 0x40)) val &= 0x7f;
+	if(!(ioport("P1")->read() & 0x40)) val &= 0xef;
+	if(!(ioport("P2")->read() & 0x40)) val &= 0xdf;
+	if(!(ioport("P3")->read() & 0x40)) val &= 0xbf;
+	if(!(ioport("P4")->read() & 0x40)) val &= 0x7f;
 
-	m_passht4b_io3_val = (input_port_read(machine(), "P1") << 4) | (input_port_read(machine(), "P3") & 0xf);
-	m_passht4b_io2_val = (input_port_read(machine(), "P2") << 4) | (input_port_read(machine(), "P4") & 0xf);
+	m_passht4b_io3_val = (ioport("P1")->read() << 4) | (ioport("P3")->read() & 0xf);
+	m_passht4b_io2_val = (ioport("P2")->read() << 4) | (ioport("P4")->read() & 0xf);
 
 	m_passht4b_io1_val = 0xff;
 
 	// player 1 buttons
-	if(!(input_port_read(machine(), "P1") & 0x10)) m_passht4b_io1_val &= 0xfe;
-	if(!(input_port_read(machine(), "P1") & 0x20)) m_passht4b_io1_val &= 0xfd;
-	if(!(input_port_read(machine(), "P1") & 0x80)) m_passht4b_io1_val &= 0xfc;
+	if(!(ioport("P1")->read() & 0x10)) m_passht4b_io1_val &= 0xfe;
+	if(!(ioport("P1")->read() & 0x20)) m_passht4b_io1_val &= 0xfd;
+	if(!(ioport("P1")->read() & 0x80)) m_passht4b_io1_val &= 0xfc;
 
 	// player 2 buttons
-	if(!(input_port_read(machine(), "P2") & 0x10)) m_passht4b_io1_val &= 0xfb;
-	if(!(input_port_read(machine(), "P2") & 0x20)) m_passht4b_io1_val &= 0xf7;
-	if(!(input_port_read(machine(), "P2") & 0x80)) m_passht4b_io1_val &= 0xf3;
+	if(!(ioport("P2")->read() & 0x10)) m_passht4b_io1_val &= 0xfb;
+	if(!(ioport("P2")->read() & 0x20)) m_passht4b_io1_val &= 0xf7;
+	if(!(ioport("P2")->read() & 0x80)) m_passht4b_io1_val &= 0xf3;
 
 	// player 3 buttons
-	if(!(input_port_read(machine(), "P3") & 0x10)) m_passht4b_io1_val &= 0xef;
-	if(!(input_port_read(machine(), "P3") & 0x20)) m_passht4b_io1_val &= 0xdf;
-	if(!(input_port_read(machine(), "P3") & 0x80)) m_passht4b_io1_val &= 0xcf;
+	if(!(ioport("P3")->read() & 0x10)) m_passht4b_io1_val &= 0xef;
+	if(!(ioport("P3")->read() & 0x20)) m_passht4b_io1_val &= 0xdf;
+	if(!(ioport("P3")->read() & 0x80)) m_passht4b_io1_val &= 0xcf;
 
 	// player 4 buttons
-	if(!(input_port_read(machine(), "P4") & 0x10)) m_passht4b_io1_val &= 0xbf;
-	if(!(input_port_read(machine(), "P4") & 0x20)) m_passht4b_io1_val &= 0x7f;
-	if(!(input_port_read(machine(), "P4") & 0x80)) m_passht4b_io1_val &= 0x3f;
+	if(!(ioport("P4")->read() & 0x10)) m_passht4b_io1_val &= 0xbf;
+	if(!(ioport("P4")->read() & 0x20)) m_passht4b_io1_val &= 0x7f;
+	if(!(ioport("P4")->read() & 0x80)) m_passht4b_io1_val &= 0x3f;
 
 	return val;
 }
@@ -1892,7 +1892,7 @@
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SERVICE4 )
 
 	PORT_MODIFY("COINAGE")
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:5,6,7,8") PORT_CONDITION("DSW1",0x20,PORTCOND_EQUALS,0x20)
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:5,6,7,8") PORT_CONDITION("DSW1",0x20,EQUALS,0x20)
 	PORT_DIPSETTING(    0x70, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x90, DEF_STR( 2C_1C ) )
@@ -3349,7 +3349,7 @@
 {
 	segas1x_bootleg_state *state = machine.driver_data<segas1x_bootleg_state>();
 	int i;
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	UINT8 *KEY = state->memregion("decryption")->base();
 	address_space *space = machine.device("maincpu")->memory().space(AS_PROGRAM);
 	UINT8 data[0x1000];
diff -Nru src-old/mame/drivers/tagteam.c src/mame/drivers/tagteam.c
--- src-old/mame/drivers/tagteam.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/tagteam.c	2012-05-03 11:00:08.000000000 +0200
@@ -118,7 +118,7 @@
 	PORT_DIPSETTING(    0x40, "Upright, Dual Controls" )
 //  PORT_DIPSETTING(    0x20, "Cocktail, Single Controls" ) // IMPOSSIBLE !
 	PORT_DIPSETTING(    0x60, DEF_STR( Cocktail ) )		// "Cocktail, Dual Controls"
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK  )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM  ) PORT_VBLANK("screen")
 
 	PORT_START("DSW2")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:1")
@@ -144,14 +144,14 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW2", 0xe0, PORTCOND_NOTEQUALS, 0x80)	//Mode 1
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW2", 0xe0, PORTCOND_EQUALS, 0x80)	//Mode 2
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW2", 0xe0, NOTEQUALS, 0x80)	//Mode 1
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW2", 0xe0, EQUALS, 0x80)	//Mode 2
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:3,4")
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW2", 0xe0, PORTCOND_NOTEQUALS, 0x80)	//Mode 1
-	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW2", 0xe0, PORTCOND_EQUALS, 0x80)	//Mode 2
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW2", 0xe0, NOTEQUALS, 0x80)	//Mode 1
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW2", 0xe0, EQUALS, 0x80)	//Mode 2
 
 	PORT_MODIFY("DSW2")
 	PORT_DIPNAME( 0xe0, 0x00, "Coin Mode" )			PORT_DIPLOCATION("SW2:6,7,8")
diff -Nru src-old/mame/drivers/tail2nos.c src/mame/drivers/tail2nos.c
--- src-old/mame/drivers/tail2nos.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tail2nos.c	2012-05-03 11:00:08.000000000 +0200
@@ -227,7 +227,7 @@
 	tail2nos_state *state = machine.driver_data<tail2nos_state>();
 
 	/* point to the extra ROMs */
-	state->membank("bank1")->set_base(machine.root_device().memregion("user1")->base());
+	state->membank("bank1")->set_base(state->memregion("user1")->base());
 	state->membank("bank2")->set_base(state->memregion("user2")->base());
 
 	state->m_charbank = 0;
diff -Nru src-old/mame/drivers/taito_b.c src/mame/drivers/taito_b.c
--- src-old/mame/drivers/taito_b.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_b.c	2012-05-03 11:00:08.000000000 +0200
@@ -336,42 +336,42 @@
 
 READ16_MEMBER(taitob_state::tracky1_hi_r)
 {
-	return input_port_read(machine(), "TRACKX1");
+	return ioport("TRACKX1")->read();
 }
 
 READ16_MEMBER(taitob_state::tracky1_lo_r)
 {
-	return (input_port_read(machine(), "TRACKX1") & 0xff) << 8;
+	return (ioport("TRACKX1")->read() & 0xff) << 8;
 }
 
 READ16_MEMBER(taitob_state::trackx1_hi_r)
 {
-	return input_port_read(machine(), "TRACKY1");
+	return ioport("TRACKY1")->read();
 }
 
 READ16_MEMBER(taitob_state::trackx1_lo_r)
 {
-	return (input_port_read(machine(), "TRACKY1") & 0xff) << 8;
+	return (ioport("TRACKY1")->read() & 0xff) << 8;
 }
 
 READ16_MEMBER(taitob_state::tracky2_hi_r)
 {
-	return input_port_read(machine(), "TRACKX2");
+	return ioport("TRACKX2")->read();
 }
 
 READ16_MEMBER(taitob_state::tracky2_lo_r)
 {
-	return (input_port_read(machine(), "TRACKX2") & 0xff) << 8;
+	return (ioport("TRACKX2")->read() & 0xff) << 8;
 }
 
 READ16_MEMBER(taitob_state::trackx2_hi_r)
 {
-	return input_port_read(machine(), "TRACKY2");
+	return ioport("TRACKY2")->read();
 }
 
 READ16_MEMBER(taitob_state::trackx2_lo_r)
 {
-	return (input_port_read(machine(), "TRACKY2") & 0xff) << 8;
+	return (ioport("TRACKY2")->read() & 0xff) << 8;
 }
 
 
@@ -438,7 +438,7 @@
 		/* bit 7 - set all the time (Chip Select?) */
 
 		/* EEPROM */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
@@ -475,7 +475,7 @@
 	switch (offset)
 	{
 		case 0x01:
-			return input_port_read(machine(), "COIN") << 8;
+			return ioport("COIN")->read() << 8;
 
 		default:
 			return tc0640fio_r(m_tc0640fio, offset) << 8;
diff -Nru src-old/mame/drivers/taito_f2.c src/mame/drivers/taito_f2.c
--- src-old/mame/drivers/taito_f2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_f2.c	2012-05-03 11:00:08.000000000 +0200
@@ -324,25 +324,25 @@
 	switch (offset)
 	{
 		case 0x00:
-			return (input_port_read(machine(), "DSWA") << 8);
+			return (ioport("DSWA")->read() << 8);
 
 		case 0x01:
-			return (input_port_read(machine(), "DSWB") << 8);
+			return (ioport("DSWB")->read() << 8);
 
 		case 0x02:
-			return (input_port_read(machine(), "IN0") << 8);
+			return (ioport("IN0")->read() << 8);
 
 		case 0x03:
-			return (input_port_read(machine(), "IN1") << 8);
+			return (ioport("IN1")->read() << 8);
 
 		case 0x04:
-			return (input_port_read(machine(), "IN3") << 8);
+			return (ioport("IN3")->read() << 8);
 
 		case 0x05:
-			return (input_port_read(machine(), "IN4") << 8);
+			return (ioport("IN4")->read() << 8);
 
 		case 0x06:
-			return (input_port_read(machine(), "IN2") << 8);
+			return (ioport("IN2")->read() << 8);
 
 //      case 0x07:
 //          return (coin_word & mem_mask);
@@ -360,13 +360,13 @@
 	switch (offset)
 	{
 		case 0x00:
-			curr = input_port_read(machine(), "PADDLE1");
+			curr = ioport("PADDLE1")->read();
 			res = curr - m_last[0];
 			m_last[0] = curr;
 			return res;
 
 		case 0x02:
-			curr = input_port_read(machine(), "PADDLE2");
+			curr = ioport("PADDLE2")->read();
 			res = curr - m_last[1];
 			m_last[1] = curr;
 			return res;
@@ -383,12 +383,12 @@
 	{
 		case 0x00:
 		{
-			return (input_port_read(machine(), "IN5") << 8) + input_port_read(machine(), "DSWA");	/* DSW A + coin */
+			return (ioport("IN5")->read() << 8) + ioport("DSWA")->read();	/* DSW A + coin */
 		}
 
 		case 0x01:
 		{
-			return (input_port_read(machine(), "IN6") << 8) + input_port_read(machine(), "DSWB");	/* DSW B + coin */
+			return (ioport("IN6")->read() << 8) + ioport("DSWB")->read();	/* DSW B + coin */
 		}
 	}
 
@@ -402,19 +402,19 @@
 	switch (m_mjnquest_input)
 	{
 		case 0x01:
-			  return input_port_read(machine(), "IN0");
+			  return ioport("IN0")->read();
 
 		 case 0x02:
-			  return input_port_read(machine(), "IN1");
+			  return ioport("IN1")->read();
 
 		 case 0x04:
-			  return input_port_read(machine(), "IN2");
+			  return ioport("IN2")->read();
 
 		 case 0x08:
-			  return input_port_read(machine(), "IN3");
+			  return ioport("IN3")->read();
 
 		 case 0x10:
-			  return input_port_read(machine(), "IN4");
+			  return ioport("IN4")->read();
 
 	}
 
@@ -2461,43 +2461,43 @@
 
 	PORT_START("IN0")
 	/* Joystick Control */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )                                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(1) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )                                  PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
 	/* 4 Buttons Control */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START1 )                                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START1 )                                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
 
 	PORT_START("IN1")
 	/* Joystick Control */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )                                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x80)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2) PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )                                  PORT_CONDITION("DSWB",0x80,EQUALS,0x80)
 	/* 4 Buttons Control */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START2 )                                  PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,PORTCOND_EQUALS,0x00)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START2 )                                  PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )                                 PORT_CONDITION("DSWB",0x80,EQUALS,0x00)
 
 	PORT_START("IN2")
 	TAITO_F2_SYSTEM_INPUT
@@ -5310,7 +5310,7 @@
 static DRIVER_INIT( mjnquest )
 {
 	taitof2_state *state = machine.driver_data<taitof2_state>();
-	int i, len = machine.root_device().memregion("gfx2")->bytes();
+	int i, len = state->memregion("gfx2")->bytes();
 	UINT8 *gfx = state->memregion("gfx2")->base();
 
 	/* the bytes in each longword are in reversed order, put them in the
diff -Nru src-old/mame/drivers/taito_f3.c src/mame/drivers/taito_f3.c
--- src-old/mame/drivers/taito_f3.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_f3.c	2012-05-03 11:00:08.000000000 +0200
@@ -46,7 +46,7 @@
 	const char *tag = (const char *)param;
 	UINT32 ipt = 0;
 
-	ipt = ((input_port_read(machine(), tag) & 0xf)<<12) | ((input_port_read(machine(), tag) & 0xff0)>>4);
+	ipt = ((ioport(tag)->read() & 0xf)<<12) | ((ioport(tag)->read() & 0xff0)>>4);
 
 	return ipt;
 }
@@ -62,7 +62,7 @@
 	static const char *const iptnames[] = { "IN0", "IN1", "AN0", "AN1", "IN2", "IN3" };
 
 	if (offset < 6)
-		return input_port_read(machine(), iptnames[offset]);
+		return ioport(iptnames[offset])->read();
 
 	logerror("CPU #0 PC %06x: warning - read unmapped control address %06x\n", cpu_get_pc(&space.device()), offset);
 	return 0xffffffff;
@@ -90,7 +90,7 @@
 		case 0x04: /* Eeprom */
 			if (ACCESSING_BITS_0_7)
 			{
-				input_port_write(machine(), "EEPROMOUT", data, 0xff);
+				ioport("EEPROMOUT")->write(data, 0xff);
 			}
 			return;
 
diff -Nru src-old/mame/drivers/taito_h.c src/mame/drivers/taito_h.c
--- src-old/mame/drivers/taito_h.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_h.c	2012-05-03 11:00:08.000000000 +0200
@@ -188,37 +188,37 @@
 	switch( port )
 	{
 		case 0x08:				/* trackball y coords bottom 8 bits for 2nd player */
-			return input_port_read(machine(), P2TRACKY_PORT_TAG);
+			return ioport(P2TRACKY_PORT_TAG)->read();
 
 		case 0x09:				/* trackball y coords top 8 bits for 2nd player */
-			if (input_port_read(machine(), P2TRACKY_PORT_TAG) & 0x80)	/* y- direction (negative value) */
+			if (ioport(P2TRACKY_PORT_TAG)->read() & 0x80)	/* y- direction (negative value) */
 				return 0xff;
 			else												/* y+ direction (positive value) */
 				return 0x00;
 
 		case 0x0a:				/* trackball x coords bottom 8 bits for 2nd player */
-			return input_port_read(machine(), P2TRACKX_PORT_TAG);
+			return ioport(P2TRACKX_PORT_TAG)->read();
 
 		case 0x0b:				/* trackball x coords top 8 bits for 2nd player */
-			if (input_port_read(machine(), P2TRACKX_PORT_TAG) & 0x80)	/* x- direction (negative value) */
+			if (ioport(P2TRACKX_PORT_TAG)->read() & 0x80)	/* x- direction (negative value) */
 				return 0xff;
 			else												/* x+ direction (positive value) */
 				return 0x00;
 
 		case 0x0c:				/* trackball y coords bottom 8 bits for 1st player */
-			return input_port_read(machine(), P1TRACKY_PORT_TAG);
+			return ioport(P1TRACKY_PORT_TAG)->read();
 
 		case 0x0d:				/* trackball y coords top 8 bits for 1st player */
-			if (input_port_read(machine(), P1TRACKY_PORT_TAG) & 0x80)	/* y- direction (negative value) */
+			if (ioport(P1TRACKY_PORT_TAG)->read() & 0x80)	/* y- direction (negative value) */
 				return 0xff;
 			else												/* y+ direction (positive value) */
 				return 0x00;
 
 		case 0x0e:				/* trackball x coords bottom 8 bits for 1st player */
-			return input_port_read(machine(), P1TRACKX_PORT_TAG);
+			return ioport(P1TRACKX_PORT_TAG)->read();
 
 		case 0x0f:				/* trackball x coords top 8 bits for 1st player */
-			if (input_port_read(machine(), P1TRACKX_PORT_TAG) & 0x80)	/* x- direction (negative value) */
+			if (ioport(P1TRACKX_PORT_TAG)->read() & 0x80)	/* x- direction (negative value) */
 				return 0xff;
 			else												/* x+ direction (positive value) */
 				return 0x00;
diff -Nru src-old/mame/drivers/taito_l.c src/mame/drivers/taito_l.c
--- src-old/mame/drivers/taito_l.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_l.c	2012-05-03 11:00:08.000000000 +0200
@@ -487,13 +487,13 @@
 static READ8_DEVICE_HANDLER( portA_r )
 {
 	taitol_state *state = device->machine().driver_data<taitol_state>();
-	return input_port_read(device->machine(), (state->m_extport == 0) ? state->m_porte0_tag : state->m_porte1_tag);
+	return state->ioport((state->m_extport == 0) ? state->m_porte0_tag : state->m_porte1_tag)->read();
 }
 
 static READ8_DEVICE_HANDLER( portB_r )
 {
 	taitol_state *state = device->machine().driver_data<taitol_state>();
-	return input_port_read(device->machine(), (state->m_extport == 0) ? state->m_portf0_tag : state->m_portf1_tag);
+	return state->ioport((state->m_extport == 0) ? state->m_portf0_tag : state->m_portf1_tag)->read();
 }
 
 static READ8_DEVICE_HANDLER( extport_select_and_ym2203_r )
@@ -551,15 +551,15 @@
 	switch (m_mux_ctrl)
 	{
 	case 0:
-		return input_port_read(machine(), "DSWA");
+		return ioport("DSWA")->read();
 	case 1:
-		return input_port_read(machine(), "DSWB");
+		return ioport("DSWB")->read();
 	case 2:
-		return input_port_read(machine(), "IN0");
+		return ioport("IN0")->read();
 	case 3:
-		return input_port_read(machine(), "IN1");
+		return ioport("IN1")->read();
 	case 7:
-		return input_port_read(machine(), "IN2");
+		return ioport("IN2")->read();
 	default:
 		logerror("Mux read from unknown port %d (%04x)\n", m_mux_ctrl, cpu_get_pc(&space.device()));
 		return 0xff;
@@ -636,7 +636,7 @@
 {
 
 	/* reset the trackball counter */
-	m_tracky = input_port_read(machine(), "AN0");
+	m_tracky = ioport("AN0")->read();
 	return 0;
 }
 
@@ -644,28 +644,28 @@
 {
 
 	/* reset the trackball counter */
-	m_trackx = input_port_read(machine(), "AN1");
+	m_trackx = ioport("AN1")->read();
 	return 0;
 }
 
 READ8_MEMBER(taitol_state::horshoes_tracky_lo_r)
 {
-	return (input_port_read(machine(), "AN0") - m_tracky) & 0xff;
+	return (ioport("AN0")->read() - m_tracky) & 0xff;
 }
 
 READ8_MEMBER(taitol_state::horshoes_tracky_hi_r)
 {
-	return (input_port_read(machine(), "AN0") - m_tracky) >> 8;
+	return (ioport("AN0")->read() - m_tracky) >> 8;
 }
 
 READ8_MEMBER(taitol_state::horshoes_trackx_lo_r)
 {
-	return (input_port_read(machine(), "AN1") - m_trackx) & 0xff;
+	return (ioport("AN1")->read() - m_trackx) & 0xff;
 }
 
 READ8_MEMBER(taitol_state::horshoes_trackx_hi_r)
 {
-	return (input_port_read(machine(), "AN1") - m_trackx) >> 8;
+	return (ioport("AN1")->read() - m_trackx) >> 8;
 }
 
 
@@ -1532,23 +1532,23 @@
 	PORT_DIPSETTING(    0x08, "Mode A" )
 	PORT_DIPSETTING(    0x00, "Mode B" )
 	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:5,6")
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
 	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:7,8")
-	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x08)
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x40, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWA", 0x08, PORTCOND_EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_3C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x08)
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x40, DEF_STR( 3C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION("DSWA", 0x08, EQUALS, 0x00)
 
 	PORT_START("DSWB")
 	TAITO_DIFFICULTY_LOC(SW2)				/* Difficulty controls the number of hits requiered to destroy enemies */
diff -Nru src-old/mame/drivers/taito_o.c src/mame/drivers/taito_o.c
--- src-old/mame/drivers/taito_o.c	2012-04-12 10:33:20.000000000 +0200
+++ src/mame/drivers/taito_o.c	2012-05-03 11:00:08.000000000 +0200
@@ -53,8 +53,8 @@
 
 	switch(offset)
 	{
-		case 0: retval = input_port_read(machine(), "IN0") & (clear_hack ? 0xf7ff : 0xffff); break;
-		case 1: retval = input_port_read(machine(), "IN1") & (clear_hack ? 0xfff7 : 0xffff); break;
+		case 0: retval = ioport("IN0")->read() & (clear_hack ? 0xf7ff : 0xffff); break;
+		case 1: retval = ioport("IN1")->read() & (clear_hack ? 0xfff7 : 0xffff); break;
 		default: logerror("IO R %x %x = %x @ %x\n", offset, mem_mask, retval, cpu_get_pc(&space.device()));
 	}
 	return retval;
diff -Nru src-old/mame/drivers/taito_x.c src/mame/drivers/taito_x.c
--- src-old/mame/drivers/taito_x.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_x.c	2012-05-03 11:00:08.000000000 +0200
@@ -340,13 +340,13 @@
 	switch (offset)
 	{
 		case 0x00:
-			return  input_port_read(machine(), "DSWA") & 0x0f;
+			return  ioport("DSWA")->read() & 0x0f;
 		case 0x01:
-			return (input_port_read(machine(), "DSWA") & 0xf0) >> 4;
+			return (ioport("DSWA")->read() & 0xf0) >> 4;
 		case 0x02:
-			return  input_port_read(machine(), "DSWB") & 0x0f;
+			return  ioport("DSWB")->read() & 0x0f;
 		case 0x03:
-			return (input_port_read(machine(), "DSWB") & 0xf0) >> 4;
+			return (ioport("DSWB")->read() & 0xf0) >> 4;
 		default:
 			logerror("taitox unknown dsw read offset: %04x\n", offset);
 			return 0x00;
@@ -358,11 +358,11 @@
 	switch (offset)
 	{
 		case 0x00:
-			return input_port_read(machine(), "IN0");    /* Player 1 controls + START1 */
+			return ioport("IN0")->read();    /* Player 1 controls + START1 */
 		case 0x01:
-			return input_port_read(machine(), "IN1");    /* Player 2 controls + START2 */
+			return ioport("IN1")->read();    /* Player 2 controls + START2 */
 		case 0x02:
-			return input_port_read(machine(), "IN2");    /* COINn + SERVICE1 + TILT */
+			return ioport("IN2")->read();    /* COINn + SERVICE1 + TILT */
 
 		default:
 			logerror("taitox unknown input read offset: %04x\n", offset);
diff -Nru src-old/mame/drivers/taito_z.c src/mame/drivers/taito_z.c
--- src-old/mame/drivers/taito_z.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taito_z.c	2012-05-03 11:00:08.000000000 +0200
@@ -1046,7 +1046,7 @@
             x0000000    (unused)                  */
 
 			COMBINE_DATA(&m_eep_latch);
-			input_port_write(machine(), "EEPROMOUT", data, 0xff);
+			ioport("EEPROMOUT")->write(data, 0xff);
 			break;
 
 		default:
@@ -1065,12 +1065,12 @@
 
 	UINT8 port = tc0220ioc_port_r(m_tc0220ioc, 0);	/* read port number */
 	int steer = 0;
-	int fake = input_port_read(machine(), "FAKE");
+	int fake = ioport("FAKE")->read();
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
 		/* center around zero and reduce span to 0xc0 */
-		steer = ((input_port_read(machine(), "STEER") - 0x80) * 0xc0) / 0x100;
+		steer = ((ioport("STEER")->read() - 0x80) * 0xc0) / 0x100;
 
 	}
 	else	/* Digital steer */
@@ -1105,12 +1105,12 @@
 
 	UINT8 port = tc0220ioc_port_r(m_tc0220ioc, 0);	/* read port number */
 	int steer = 0;
-	int fake = input_port_read(machine(), "FAKE");
+	int fake = ioport("FAKE")->read();
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
 		/* center around zero */
-		steer = input_port_read(machine(), "STEER") - 0x80;
+		steer = ioport("STEER")->read() - 0x80;
 	}
 	else	/* Digital steer */
 	{
@@ -1127,16 +1127,16 @@
 	switch (port)
 	{
 		case 0x08:
-			return input_port_read(machine(), "UNK1");
+			return ioport("UNK1")->read();
 
 		case 0x09:
-			return input_port_read(machine(), "UNK2");
+			return ioport("UNK2")->read();
 
 		case 0x0a:
-			return input_port_read(machine(), "UNK3");
+			return ioport("UNK3")->read();
 
 		case 0x0b:
-			return input_port_read(machine(), "UNK4");
+			return ioport("UNK4")->read();
 
 		case 0x0c:
 			return steer & 0xff;
@@ -1155,16 +1155,16 @@
 	switch (offset)
 	{
 		case 0x00:
-			return input_port_read(machine(), "STICKX");
+			return ioport("STICKX")->read();
 
 		case 0x01:
-			return input_port_read(machine(), "X_ADJUST");
+			return ioport("X_ADJUST")->read();
 
 		case 0x02:
-			return input_port_read(machine(), "STICKY");
+			return ioport("STICKY")->read();
 
 		case 0x03:
-			return input_port_read(machine(), "Y_ADJUST");
+			return ioport("Y_ADJUST")->read();
 	}
 
 	logerror("CPU #0 PC %06x: warning - read unmapped stick offset %06x\n", cpu_get_pc(&space.device()), offset);
@@ -1178,16 +1178,16 @@
 	switch (offset)
 	{
 		case 0x00:
-			return input_port_read(machine(), "STICKX");
+			return ioport("STICKX")->read();
 
 		case 0x01:
-			return input_port_read(machine(), "STICKY");
+			return ioport("STICKY")->read();
 
 		case 0x02:
-			return input_port_read(machine(), "X_ADJUST");
+			return ioport("X_ADJUST")->read();
 
 		case 0x03:
-			return input_port_read(machine(), "Y_ADJUST");
+			return ioport("Y_ADJUST")->read();
 	}
 
 	logerror("CPU #0 PC %06x: warning - read unmapped stick offset %06x\n", cpu_get_pc(&space.device()), offset);
@@ -1210,12 +1210,12 @@
 READ16_MEMBER(taitoz_state::sci_steer_input_r)
 {
 	int steer = 0;
-	int fake = input_port_read(machine(), "FAKE");
+	int fake = ioport("FAKE")->read();
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
 		/* center around zero and reduce span to 0xc0 */
-		steer = ((input_port_read(machine(), "STEER") - 0x80) * 0xc0) / 0x100;
+		steer = ((ioport("STEER")->read() - 0x80) * 0xc0) / 0x100;
 	}
 	else	/* Digital steer */
 	{
@@ -1262,16 +1262,16 @@
 	switch (offset)
 	{
 		case 0x00:
-			return input_port_read(machine(), "STICKX1");
+			return ioport("STICKX1")->read();
 
 		case 0x01:
-			return input_port_read(machine(), "STICKY1");
+			return ioport("STICKY1")->read();
 
 		case 0x02:
-			return input_port_read(machine(), "STICKX2");
+			return ioport("STICKX2")->read();
 
 		case 0x03:
-			return input_port_read(machine(), "STICKY2");
+			return ioport("STICKY2")->read();
 	}
 
 	return 0x00;
@@ -1300,12 +1300,12 @@
 READ16_MEMBER(taitoz_state::dblaxle_steer_input_r)
 {
 	int steer = 0;
-	int fake = input_port_read(machine(), "FAKE");
+	int fake = ioport("FAKE")->read();
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
 		/* center around zero and reduce span to 0x80 */
-		steer = ((input_port_read(machine(), "STEER") - 0x80) * 0x80) / 0x100;
+		steer = ((ioport("STEER")->read() - 0x80) * 0x80) / 0x100;
 	}
 	else	/* Digital steer */
 	{
diff -Nru src-old/mame/drivers/taitoair.c src/mame/drivers/taitoair.c
--- src-old/mame/drivers/taitoair.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/taitoair.c	2012-05-03 11:00:08.000000000 +0200
@@ -341,19 +341,19 @@
 	switch( offset )
 	{
 		case 0x00:	/* "counter 1" lo */
-			return input_port_read(machine(), STICK1_PORT_TAG);
+			return ioport(STICK1_PORT_TAG)->read();
 
 		case 0x01:	/* "counter 2" lo */
-			return input_port_read(machine(), STICK2_PORT_TAG);
+			return ioport(STICK2_PORT_TAG)->read();
 
 		case 0x02:	/* "counter 1" hi */
-			if(input_port_read(machine(), STICK1_PORT_TAG) & 0x80)
+			if(ioport(STICK1_PORT_TAG)->read() & 0x80)
 				return 0xff;
 
 			return 0;
 
 		case 0x03:	/* "counter 2" hi */
-			return (input_port_read(machine(), STICK2_PORT_TAG) & 0xff00) >> 8;
+			return (ioport(STICK2_PORT_TAG)->read() & 0xff00) >> 8;
 	}
 
 	return 0;
@@ -364,10 +364,10 @@
 	switch( offset )
 	{
 		case 0x00:	/* "counter 3" lo */
-			return input_port_read(machine(), STICK3_PORT_TAG);
+			return ioport(STICK3_PORT_TAG)->read();
 
 		case 0x02:	/* "counter 3" hi */
-			return (input_port_read(machine(), STICK3_PORT_TAG) & 0xff00) >> 8;
+			return (ioport(STICK3_PORT_TAG)->read() & 0xff00) >> 8;
 	}
 
 	return 0;
diff -Nru src-old/mame/drivers/taitogn.c src/mame/drivers/taitogn.c
--- src-old/mame/drivers/taitogn.c	2012-04-10 16:06:51.000000000 +0200
+++ src/mame/drivers/taitogn.c	2012-05-03 11:00:08.000000000 +0200
@@ -754,7 +754,7 @@
 	{
 		if( state->m_b_lastclock )
 		{
-			int bit = ( ( input_port_read(machine, "DSW") >> state->m_n_dip_bit ) & 1 );
+			int bit = ( ( state->ioport("DSW")->read() >> state->m_n_dip_bit ) & 1 );
 			psx_sio_input( machine, 0, PSX_SIO_IN_DATA, bit * PSX_SIO_IN_DATA );
 			state->m_n_dip_bit++;
 			state->m_n_dip_bit &= 7;
@@ -866,14 +866,14 @@
 
 	switch(m_mux_data)
 	{
-		case 0x04: return input_port_read(machine(), "KEY0");
-		case 0x08: return input_port_read(machine(), "KEY1");
-		case 0x40: return input_port_read(machine(), "KEY2");
-		case 0x80: return input_port_read(machine(), "KEY3");
+		case 0x04: return ioport("KEY0")->read();
+		case 0x08: return ioport("KEY1")->read();
+		case 0x40: return ioport("KEY2")->read();
+		case 0x80: return ioport("KEY3")->read();
 	}
 
 	/* mux disabled */
-	return input_port_read(machine(), "P4");
+	return ioport("P4")->read();
 }
 
 // Init and reset
diff -Nru src-old/mame/drivers/taitojc.c src/mame/drivers/taitojc.c
--- src-old/mame/drivers/taitojc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/taitojc.c	2012-05-03 11:00:08.000000000 +0200
@@ -397,7 +397,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				r |= ((input_port_read(machine(), "COINS") & 0x2) << 2) << 24;
+				r |= ((ioport("COINS")->read() & 0x2) << 2) << 24;
 			}
 			return r;
 		}
@@ -405,7 +405,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				r |= input_port_read(machine(), "COINS") << 24;
+				r |= ioport("COINS")->read() << 24;
 			}
 			return r;
 		}
@@ -413,7 +413,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				r |= input_port_read(machine(), "START") << 24;
+				r |= ioport("START")->read() << 24;
 			}
 			return r;
 		}
@@ -421,7 +421,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				r |= input_port_read(machine(), "UNUSED") << 24;
+				r |= ioport("UNUSED")->read() << 24;
 			}
 			return r;
 		}
@@ -437,7 +437,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				r |= input_port_read(machine(), "BUTTONS") << 24;
+				r |= ioport("BUTTONS")->read() << 24;
 			}
 			return r;
 		}
@@ -471,7 +471,7 @@
 		{
 			if (ACCESSING_BITS_24_31)
 			{
-				input_port_write(machine(), "EEPROMOUT", data >> 24, 0xff);
+				ioport("EEPROMOUT")->write(data >> 24, 0xff);
 			}
 			else
 				popmessage("jc_control_w: %08X, %08X, %08X\n", data, offset, mem_mask);
@@ -828,9 +828,9 @@
 	else if(offset == 1 && ACCESSING_BITS_16_31)
 		m_brake_meter = taitojc_brake_table[(data >> 16) & 0xff];
 
-	if(input_port_read_safe(machine(), "METER", 0))
+	if(ioport("METER")->read_safe(0))
 	{
-		UINT8 mascon_lv = (input_port_read(machine(), "MASCON") & 0x70) >> 4;
+		UINT8 mascon_lv = (ioport("MASCON")->read() & 0x70) >> 4;
 
 		popmessage("%d %.02f km/h %.02f MPa",mascon_lv,m_speed_meter,m_brake_meter/10);
 	}
@@ -898,7 +898,7 @@
 	static const char *const portnames[] = { "ANALOG1", "ANALOG2", "ANALOG3", "ANALOG4",
 										"ANALOG5", "ANALOG6", "ANALOG7", "ANALOG8" };
 
-	return input_port_read_safe(machine(), portnames[offset], 0);
+	return ioport(portnames[offset])->read_safe(0);
 }
 
 
@@ -1166,7 +1166,7 @@
 CUSTOM_INPUT_MEMBER(taitojc_state::mascon_state_r)
 {
 	static const UINT8 mascon_table[6] = { 0x01, 0x10, 0x02, 0x20, 0x04, 0x40 };
-	UINT8 res = input_port_read(machine(), "MASCON");
+	UINT8 res = ioport("MASCON")->read();
 	int i;
 
 	//popmessage("%02x",res);
diff -Nru src-old/mame/drivers/taitosj.c src/mame/drivers/taitosj.c
--- src-old/mame/drivers/taitosj.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/taitosj.c	2012-05-03 11:00:08.000000000 +0200
@@ -290,9 +290,9 @@
 		port_tag = "GEARP2";
 
 	/* gear MUST be 1, 2 or 3 */
-	if (input_port_read(machine(), port_tag) & 0x01) m_kikstart_gears[player] = 0x02;
-	if (input_port_read(machine(), port_tag) & 0x02) m_kikstart_gears[player] = 0x03;
-	if (input_port_read(machine(), port_tag) & 0x04) m_kikstart_gears[player] = 0x01;
+	if (ioport(port_tag)->read() & 0x01) m_kikstart_gears[player] = 0x02;
+	if (ioport(port_tag)->read() & 0x02) m_kikstart_gears[player] = 0x03;
+	if (ioport(port_tag)->read() & 0x04) m_kikstart_gears[player] = 0x01;
 
 	return m_kikstart_gears[player];
 }
diff -Nru src-old/mame/drivers/tank8.c src/mame/drivers/tank8.c
--- src-old/mame/drivers/tank8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tank8.c	2012-05-03 11:00:08.000000000 +0200
@@ -257,7 +257,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME( "RC 8" )
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("CRASH")
 	PORT_ADJUSTER( 50, "Crash, Explosion Volume" )
diff -Nru src-old/mame/drivers/tankbatt.c src/mame/drivers/tankbatt.c
--- src-old/mame/drivers/tankbatt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/tankbatt.c	2012-05-03 11:00:08.000000000 +0200
@@ -71,7 +71,7 @@
 {
 	int val;
 
-	val = input_port_read(machine(), "P1");
+	val = ioport("P1")->read();
 	return ((val << (7 - offset)) & 0x80);
 }
 
@@ -79,7 +79,7 @@
 {
 	int val;
 
-	val = input_port_read(machine(), "P2");
+	val = ioport("P2")->read();
 	return ((val << (7 - offset)) & 0x80);
 }
 
@@ -87,7 +87,7 @@
 {
 	int val;
 
-	val = input_port_read(machine(), "DSW");
+	val = ioport("DSW")->read();
 	return ((val << (7 - offset)) & 0x80);
 }
 
diff -Nru src-old/mame/drivers/tapatune.c src/mame/drivers/tapatune.c
--- src-old/mame/drivers/tapatune.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/tapatune.c	2012-05-03 11:00:08.000000000 +0200
@@ -157,9 +157,9 @@
 {
 	switch( m_controls_mux )
 	{
-		case 0x07: return input_port_read(machine(), "DSW1");
-		case 0x08: return input_port_read(machine(), "DSW2");
-		case 0x09: return input_port_read(machine(), "IN0");
+		case 0x07: return ioport("DSW1")->read();
+		case 0x08: return ioport("DSW2")->read();
+		case 0x09: return ioport("IN0")->read();
 		default: return 0xff;
 	}
 }
diff -Nru src-old/mame/drivers/tatsumi.c src/mame/drivers/tatsumi.c
--- src-old/mame/drivers/tatsumi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tatsumi.c	2012-05-03 11:00:08.000000000 +0200
@@ -188,13 +188,13 @@
 READ16_MEMBER(tatsumi_state::cyclwarr_input_r)
 {
 	static const char *const port[] = { "SERVICE", "P1", "P2", "DSW3" };
-	return input_port_read(machine(), port[offset]);
+	return ioport(port[offset])->read();
 }
 
 READ16_MEMBER(tatsumi_state::cyclwarr_input2_r)
 {
 	static const char *const port2[] = { "DSW1", "DSW2", "P3", "P4" };
-	return input_port_read(machine(), port2[offset]);
+	return ioport(port2[offset])->read();
 }
 
 WRITE16_MEMBER(tatsumi_state::cyclwarr_sound_w)
@@ -1284,8 +1284,8 @@
 static DRIVER_INIT( apache3 )
 {
 	tatsumi_state *state = machine.driver_data<tatsumi_state>();
-	UINT8 *dst = machine.root_device().memregion("gfx1")->base();
-	UINT8 *src1 = machine.root_device().memregion("gfx2")->base();
+	UINT8 *dst = state->memregion("gfx1")->base();
+	UINT8 *src1 = state->memregion("gfx2")->base();
 	UINT8 *src2 = state->memregion("gfx3")->base();
 	int i;
 
@@ -1312,8 +1312,8 @@
 static DRIVER_INIT( roundup5 )
 {
 	tatsumi_state *state = machine.driver_data<tatsumi_state>();
-	UINT8 *dst = machine.root_device().memregion("gfx1")->base();
-	UINT8 *src1 = machine.root_device().memregion("gfx2")->base();
+	UINT8 *dst = state->memregion("gfx1")->base();
+	UINT8 *src1 = state->memregion("gfx2")->base();
 	UINT8 *src2 = state->memregion("gfx3")->base();
 	int i;
 
@@ -1338,10 +1338,10 @@
 static DRIVER_INIT( cyclwarr )
 {
 	tatsumi_state *state = machine.driver_data<tatsumi_state>();
-	UINT8 *dst = machine.root_device().memregion("gfx1")->base();
-	UINT8 *src1 = machine.root_device().memregion("gfx2")->base();
-	int len1 = machine.root_device().memregion("gfx2")->bytes();
-	UINT8 *src2 = machine.root_device().memregion("gfx3")->base();
+	UINT8 *dst = state->memregion("gfx1")->base();
+	UINT8 *src1 = state->memregion("gfx2")->base();
+	int len1 = state->memregion("gfx2")->bytes();
+	UINT8 *src2 = state->memregion("gfx3")->base();
 	int len2 = state->memregion("gfx3")->bytes();
 	int i;
 	for (i=0; i<len1; i+=32) {
diff -Nru src-old/mame/drivers/taxidriv.c src/mame/drivers/taxidriv.c
--- src-old/mame/drivers/taxidriv.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/taxidriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -69,7 +69,7 @@
 static READ8_DEVICE_HANDLER( p1c_r )
 {
 	taxidriv_state *state = device->machine().driver_data<taxidriv_state>();
-	return (state->m_s2 << 7) | (state->m_s4 << 6) | ((input_port_read(device->machine(), "SERVCOIN") & 1) << 4);
+	return (state->m_s2 << 7) | (state->m_s4 << 6) | ((state->ioport("SERVCOIN")->read() & 1) << 4);
 }
 
 static WRITE8_DEVICE_HANDLER( p1a_w )
diff -Nru src-old/mame/drivers/tceptor.c src/mame/drivers/tceptor.c
--- src-old/mame/drivers/tceptor.c	2012-04-16 00:44:14.000000000 +0200
+++ src/mame/drivers/tceptor.c	2012-05-03 11:00:08.000000000 +0200
@@ -131,22 +131,22 @@
 
 READ8_MEMBER(tceptor_state::dsw0_r)
 {
-	return fix_input0(input_port_read(machine(), "DSW1"), input_port_read(machine(), "DSW2"));
+	return fix_input0(ioport("DSW1")->read(), ioport("DSW2")->read());
 }
 
 READ8_MEMBER(tceptor_state::dsw1_r)
 {
-	return fix_input1(input_port_read(machine(), "DSW1"), input_port_read(machine(), "DSW2"));
+	return fix_input1(ioport("DSW1")->read(), ioport("DSW2")->read());
 }
 
 READ8_MEMBER(tceptor_state::input0_r)
 {
-	return fix_input0(input_port_read(machine(), "BUTTONS"), input_port_read(machine(), "SERVICE"));
+	return fix_input0(ioport("BUTTONS")->read(), ioport("SERVICE")->read());
 }
 
 READ8_MEMBER(tceptor_state::input1_r)
 {
-	return fix_input1(input_port_read(machine(), "BUTTONS"), input_port_read(machine(), "SERVICE"));
+	return fix_input1(ioport("BUTTONS")->read(), ioport("SERVICE")->read());
 }
 
 READ8_MEMBER(tceptor_state::readFF)
diff -Nru src-old/mame/drivers/tecmo.c src/mame/drivers/tecmo.c
--- src-old/mame/drivers/tecmo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tecmo.c	2012-05-03 11:00:08.000000000 +0200
@@ -105,28 +105,28 @@
 /* the 8-bit dipswitches are split across addresses */
 READ8_MEMBER(tecmo_state::tecmo_dswa_l_r)
 {
-	UINT8 port = input_port_read(machine(), "DSWA");
+	UINT8 port = ioport("DSWA")->read();
 	port &= 0x0f;
 	return port;
 }
 
 READ8_MEMBER(tecmo_state::tecmo_dswa_h_r)
 {
-	UINT8 port = input_port_read(machine(), "DSWA");
+	UINT8 port = ioport("DSWA")->read();
 	port &= 0xf0;
 	return port>>4;
 }
 
 READ8_MEMBER(tecmo_state::tecmo_dswb_l_r)
 {
-	UINT8 port = input_port_read(machine(), "DSWB");
+	UINT8 port = ioport("DSWB")->read();
 	port &= 0x0f;
 	return port;
 }
 
 READ8_MEMBER(tecmo_state::tecmo_dswb_h_r)
 {
-	UINT8 port = input_port_read(machine(), "DSWB");
+	UINT8 port = ioport("DSWB")->read();
 	port &= 0xf0;
 	return port>>4;
 }
diff -Nru src-old/mame/drivers/tecmosys.c src/mame/drivers/tecmosys.c
--- src-old/mame/drivers/tecmosys.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tecmosys.c	2012-05-03 11:00:08.000000000 +0200
@@ -447,8 +447,8 @@
 
 static MACHINE_START( tecmosys )
 {
-//  tecmosys_state *state = machine.driver_data<tecmosys_state>();
-	machine.root_device().membank("bank1")->configure_entries(0, 16, machine.root_device().memregion("audiocpu")->base(), 0x4000);
+	tecmosys_state *state = machine.driver_data<tecmosys_state>();
+	state->membank("bank1")->configure_entries(0, 16, state->memregion("audiocpu")->base(), 0x4000);
 }
 
 static MACHINE_CONFIG_START( deroon, tecmosys_state )
diff -Nru src-old/mame/drivers/tehkanwc.c src/mame/drivers/tehkanwc.c
--- src-old/mame/drivers/tehkanwc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tehkanwc.c	2012-05-03 11:00:08.000000000 +0200
@@ -108,32 +108,32 @@
 {
 	int joy;
 
-	joy = input_port_read(machine(), "FAKE") >> (2 * offset);
+	joy = ioport("FAKE")->read() >> (2 * offset);
 	if (joy & 1) return -63;
 	if (joy & 2) return 63;
-	return input_port_read(machine(), offset ? "P1Y" : "P1X") - m_track0[offset];
+	return ioport(offset ? "P1Y" : "P1X")->read() - m_track0[offset];
 }
 
 READ8_MEMBER(tehkanwc_state::tehkanwc_track_1_r)
 {
 	int joy;
 
-	joy = input_port_read(machine(), "FAKE") >> (4 + 2 * offset);
+	joy = ioport("FAKE")->read() >> (4 + 2 * offset);
 	if (joy & 1) return -63;
 	if (joy & 2) return 63;
-	return input_port_read(machine(), offset ? "P2Y" : "P2X") - m_track1[offset];
+	return ioport(offset ? "P2Y" : "P2X")->read() - m_track1[offset];
 }
 
 WRITE8_MEMBER(tehkanwc_state::tehkanwc_track_0_reset_w)
 {
 	/* reset the trackball counters */
-	m_track0[offset] = input_port_read(machine(), offset ? "P1Y" : "P1X") + data;
+	m_track0[offset] = ioport(offset ? "P1Y" : "P1X")->read() + data;
 }
 
 WRITE8_MEMBER(tehkanwc_state::tehkanwc_track_1_reset_w)
 {
 	/* reset the trackball counters */
-	m_track1[offset] = input_port_read(machine(), offset ? "P2Y" : "P2X") + data;
+	m_track1[offset] = ioport(offset ? "P2Y" : "P2X")->read() + data;
 }
 
 
diff -Nru src-old/mame/drivers/tempest.c src/mame/drivers/tempest.c
--- src-old/mame/drivers/tempest.c	2012-04-12 10:33:20.000000000 +0200
+++ src/mame/drivers/tempest.c	2012-05-03 11:00:08.000000000 +0200
@@ -334,14 +334,12 @@
 
 CUSTOM_INPUT_MEMBER(tempest_state::tempest_knob_r)
 {
-	return input_port_read(machine(), (m_player_select == 0) ?
-										TEMPEST_KNOB_P1_TAG : TEMPEST_KNOB_P2_TAG);
+	return ioport((m_player_select == 0) ? TEMPEST_KNOB_P1_TAG : TEMPEST_KNOB_P2_TAG)->read();
 }
 
 CUSTOM_INPUT_MEMBER(tempest_state::tempest_buttons_r)
 {
-	return input_port_read(machine(), (m_player_select == 0) ?
-										TEMPEST_BUTTONS_P1_TAG : TEMPEST_BUTTONS_P2_TAG);
+	return ioport((m_player_select == 0) ? TEMPEST_BUTTONS_P1_TAG : TEMPEST_BUTTONS_P2_TAG)->read();
 }
 
 
@@ -354,13 +352,13 @@
 
 static READ8_DEVICE_HANDLER( input_port_1_bit_r )
 {
-	return (input_port_read(device->machine(), "IN1/DSW0") & (1 << offset)) ? 0 : 228;
+	return (device->machine().root_device().ioport("IN1/DSW0")->read() & (1 << offset)) ? 0 : 228;
 }
 
 
 static READ8_DEVICE_HANDLER( input_port_2_bit_r )
 {
-	return (input_port_read(device->machine(), "IN2") & (1 << offset)) ? 0 : 228;
+	return (device->machine().root_device().ioport("IN2")->read() & (1 << offset)) ? 0 : 228;
 }
 
 
diff -Nru src-old/mame/drivers/terracre.c src/mame/drivers/terracre.c
--- src-old/mame/drivers/terracre.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/terracre.c	2012-05-03 11:00:08.000000000 +0200
@@ -133,7 +133,7 @@
 
 READ16_MEMBER(terracre_state::horekid_IN2_r)
 {
-	int data = input_port_read(machine(), "IN2");
+	int data = ioport("IN2")->read();
 
 	if (!(data & 0x40))		// FAKE button 3 for "Debug Mode"
 	{
diff -Nru src-old/mame/drivers/tetrisp2.c src/mame/drivers/tetrisp2.c
--- src-old/mame/drivers/tetrisp2.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/tetrisp2.c	2012-05-03 11:00:08.000000000 +0200
@@ -212,7 +212,7 @@
 
 READ16_MEMBER(tetrisp2_state::tetrisp2_ip_1_word_r)
 {
-	return	( input_port_read(machine(), "SYSTEM") &  0xfcff ) |
+	return	( ioport("SYSTEM")->read() &  0xfcff ) |
 			(           machine().rand() & ~0xfcff ) |
 			(      1 << (8 + (machine().rand()&1)) );
 }
@@ -540,7 +540,7 @@
 READ16_MEMBER(stepstag_state::stepstag_coins_r)
 {
 	// bits 8 & 9?
-	return	( input_port_read(machine(), "COINS") &  0xfcff ) |
+	return	( ioport("COINS")->read() &  0xfcff ) |
 			(                 machine().rand()  & ~0xfcff ) |
 			(      1 << (8 + (machine().rand()&1)) );
 }
diff -Nru src-old/mame/drivers/thayers.c src/mame/drivers/thayers.c
--- src-old/mame/drivers/thayers.c	2012-04-09 13:58:25.000000000 +0200
+++ src/mame/drivers/thayers.c	2012-05-03 11:00:08.000000000 +0200
@@ -300,7 +300,7 @@
 
 			sprintf(port, "R%d", m_keylatch);
 
-			data = BIT(input_port_read(machine(), port), m_rx_bit - 5);
+			data = BIT(ioport(port)->read(), m_rx_bit - 5);
 
 			return data;
 		}
@@ -359,7 +359,7 @@
 
 READ8_MEMBER(thayers_state::dsw_b_r)
 {
-	return (input_port_read(machine(), "COIN") & 0xf0) | (input_port_read(machine(), "DSWB") & 0x0f);
+	return (ioport("COIN")->read() & 0xf0) | (ioport("DSWB")->read() & 0x0f);
 }
 
 READ8_MEMBER(thayers_state::laserdsc_data_r)
@@ -764,7 +764,7 @@
 	state->m_cart_present = 0;
 	state->m_pr7820_enter = 0;
 
-//  newtype = (input_port_read(machine, "DSWB") & 0x18) ? LASERDISC_TYPE_PIONEER_LDV1000 : LASERDISC_TYPE_PIONEER_PR7820;
+//  newtype = (state->ioport("DSWB")->read() & 0x18) ? LASERDISC_TYPE_PIONEER_LDV1000 : LASERDISC_TYPE_PIONEER_PR7820;
 //  laserdisc_set_type(state->m_laserdisc, newtype);
 }
 
diff -Nru src-old/mame/drivers/thedeep.c src/mame/drivers/thedeep.c
--- src-old/mame/drivers/thedeep.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/thedeep.c	2012-05-03 11:00:08.000000000 +0200
@@ -250,9 +250,9 @@
 {
 	UINT8 coin_mux;
 
-	coin_mux = ((input_port_read(machine(),"COINS") & 0x0e) == 0x0e); // bit 0 is hard-wired to ALL three coin latches
+	coin_mux = ((ioport("COINS")->read() & 0x0e) == 0x0e); // bit 0 is hard-wired to ALL three coin latches
 
-	return (input_port_read(machine(),"COINS") & 0xfe) | (coin_mux & 1);
+	return (ioport("COINS")->read() & 0xfe) | (coin_mux & 1);
 }
 
 static ADDRESS_MAP_START( mcu_io_map, AS_IO, 8, thedeep_state )
@@ -416,7 +416,7 @@
 	{
 		if (state->m_protection_command != 0x59)
 		{
-			int coins = input_port_read(timer.machine(), "MCU");
+			int coins = timer.machine().root_device().ioport("MCU")->read();
 			if		(coins & 1)	state->m_protection_data = 1;
 			else if	(coins & 2)	state->m_protection_data = 2;
 			else if	(coins & 4)	state->m_protection_data = 3;
diff -Nru src-old/mame/drivers/thepit.c src/mame/drivers/thepit.c
--- src-old/mame/drivers/thepit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/thepit.c	2012-05-03 11:00:08.000000000 +0200
@@ -536,14 +536,14 @@
 	PORT_DIPSETTING(    0x20, "Number of Wrong Answer" )
 	PORT_DIPSETTING(    0x00, "Number of Good Answer for Bonus Question" )
 	PORT_DIPNAME( 0xc0, 0x40, "Gaming Option Number" )
-	PORT_DIPSETTING(    0x00, "2" ) PORT_CONDITION("DSW", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x40, "3" ) PORT_CONDITION("DSW", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x80, "4" ) PORT_CONDITION("DSW", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0xc0, "5" ) PORT_CONDITION("DSW", 0x20, PORTCOND_EQUALS, 0x20)
-	PORT_DIPSETTING(    0x00, "4" ) PORT_CONDITION("DSW", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x40, "5" ) PORT_CONDITION("DSW", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0x80, "6" ) PORT_CONDITION("DSW", 0x20, PORTCOND_NOTEQUALS, 0x20)
-	PORT_DIPSETTING(    0xc0, "7" ) PORT_CONDITION("DSW", 0x20, PORTCOND_NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "2" ) PORT_CONDITION("DSW", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x40, "3" ) PORT_CONDITION("DSW", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x80, "4" ) PORT_CONDITION("DSW", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0xc0, "5" ) PORT_CONDITION("DSW", 0x20, EQUALS, 0x20)
+	PORT_DIPSETTING(    0x00, "4" ) PORT_CONDITION("DSW", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x40, "5" ) PORT_CONDITION("DSW", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0x80, "6" ) PORT_CONDITION("DSW", 0x20, NOTEQUALS, 0x20)
+	PORT_DIPSETTING(    0xc0, "7" ) PORT_CONDITION("DSW", 0x20, NOTEQUALS, 0x20)
 
 	/* Since the real inputs are multiplexed, we used this fake port
        to read the 2nd player controls when the screen is flipped */
diff -Nru src-old/mame/drivers/thief.c src/mame/drivers/thief.c
--- src-old/mame/drivers/thief.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/thief.c	2012-05-03 11:00:08.000000000 +0200
@@ -36,7 +36,7 @@
 static INTERRUPT_GEN( thief_interrupt )
 {
 	/* SLAM switch causes an NMI if it's pressed */
-	if( (input_port_read(device->machine(), "P2") & 0x10) == 0 )
+	if( (device->machine().root_device().ioport("P2")->read() & 0x10) == 0 )
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 	else
 		device_set_input_line(device, 0, HOLD_LINE);
@@ -141,10 +141,10 @@
 {
 	switch( m_input_select )
 	{
-		case 0x01: return input_port_read(machine(), "DSW1");
-		case 0x02: return input_port_read(machine(), "DSW2");
-		case 0x04: return input_port_read(machine(), "P1");
-		case 0x08: return input_port_read(machine(), "P2");
+		case 0x01: return ioport("DSW1")->read();
+		case 0x02: return ioport("DSW2")->read();
+		case 0x04: return ioport("P1")->read();
+		case 0x08: return ioport("P2")->read();
 	}
 	return 0x00;
 }
diff -Nru src-old/mame/drivers/thunderj.c src/mame/drivers/thunderj.c
--- src-old/mame/drivers/thunderj.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/thunderj.c	2012-05-03 11:00:08.000000000 +0200
@@ -70,7 +70,7 @@
 
 READ16_MEMBER(thunderj_state::special_port2_r)
 {
-	int result = input_port_read(machine(), "260012");
+	int result = ioport("260012")->read();
 
 	if (m_sound_to_cpu_ready) result ^= 0x0004;
 	if (m_cpu_to_sound_ready) result ^= 0x0008;
@@ -219,7 +219,7 @@
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_PLAYER(1)
 
 	PORT_START("260012")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0002, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )	/* Input buffer full (@260030) */
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )	/* Output buffer full (@360030) */
diff -Nru src-old/mame/drivers/tiamc1.c src/mame/drivers/tiamc1.c
--- src-old/mame/drivers/tiamc1.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/drivers/tiamc1.c	2012-05-03 11:00:08.000000000 +0200
@@ -188,7 +188,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_PLAYER(1) // Kick
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_PLAYER(1) // Jump
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static const gfx_layout sprites16x16_layout =
diff -Nru src-old/mame/drivers/tickee.c src/mame/drivers/tickee.c
--- src-old/mame/drivers/tickee.c	2012-04-19 09:47:35.000000000 +0200
+++ src/mame/drivers/tickee.c	2012-05-03 11:00:08.000000000 +0200
@@ -71,8 +71,8 @@
 {
 	const rectangle &visarea = machine.primary_screen->visible_area();
 
-	*x = (((input_port_read(machine, player ? "GUNX2" : "GUNX1") & 0xff) * visarea.width()) >> 8) + visarea.min_x;
-	*y = (((input_port_read(machine, player ? "GUNY2" : "GUNY1") & 0xff) * visarea.height()) >> 8) + visarea.min_y;
+	*x = (((machine.root_device().ioport(player ? "GUNX2" : "GUNX1")->read() & 0xff) * visarea.width()) >> 8) + visarea.min_x;
+	*y = (((machine.root_device().ioport(player ? "GUNY2" : "GUNY1")->read() & 0xff) * visarea.height()) >> 8) + visarea.min_y;
 }
 
 
diff -Nru src-old/mame/drivers/timeplt.c src/mame/drivers/timeplt.c
--- src-old/mame/drivers/timeplt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/timeplt.c	2012-05-04 19:04:42.000000000 +0200
@@ -280,11 +280,60 @@
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( chkun )
-	PORT_INCLUDE(timeplt)
+	PORT_START("IN0")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
+	PORT_START("IN1")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
-	PORT_MODIFY("DSW0")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_START("IN2")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
@@ -302,14 +351,197 @@
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) ) //service mode
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW0")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) ) // debug mode
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Unknown ) ) // Freeze?
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( bikkuric )
+	PORT_START("IN0")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("IN1")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("IN2")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW0")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW1")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
 
 /*************************************
  *
@@ -578,6 +810,28 @@
 	ROM_LOAD( "b.9f",   0x0100, 0x00eb, CRC(e3857f83) SHA1(674e70dc960fc02a9fbda4a0ef0770eb8214c466) )
 ROM_END
 
+ROM_START( bikkuric )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASE00 )
+	ROM_LOAD( "1.a16",        0x00000, 0x04000, CRC(e8d595ab) SHA1(01f6a5321274befcd03a0ec18ed9770aca4527b6) )
+	ROM_LOAD( "2.a14",        0x04000, 0x02000, CRC(63fd7d53) SHA1(b1ef666453c5c9e344bee544a0673068d60158fa) )
+
+	ROM_REGION( 0x10000, "tpsound", ROMREGION_ERASE00 )
+	ROM_LOAD( "5.l3",         0x00000, 0x02000, CRC(bc438531) SHA1(e19badc417b0538010cf535d3f733acc54b0cd96) )
+
+	ROM_REGION( 0x8000, "gfx1", ROMREGION_ERASE00 )
+	ROM_LOAD( "3.d4",         0x00000, 0x08000, CRC(74e8a64b) SHA1(b2542e1f6f4b54d8f7aec8f673cedcf5bff5e429) ) // 1st and 2nd identical, confirmed to be like this
+
+	ROM_REGION( 0x2000, "gfx2", ROMREGION_ERASE00 )
+	ROM_LOAD( "4.h8",         0x00000, 0x02000, CRC(d303942d) SHA1(688d43e6dbe505d44fc41fdde74858a02910080d) )
+
+	ROM_REGION( 0x0240, "proms", 0 )
+	ROM_LOAD( "timeplt.b4",   0x0000, 0x0020, BAD_DUMP CRC(34c91839) SHA1(f62e279e21fce171231d3139be7adabe1f4b8c2e) ) /* palette */
+	ROM_LOAD( "timeplt.b5",   0x0020, 0x0020, BAD_DUMP CRC(463b2b07) SHA1(9ad275365eba4869f94749f39ff8705d92056a10) ) /* palette */
+	ROM_LOAD( "timeplt.e9",   0x0040, 0x0100, BAD_DUMP CRC(4bbb2150) SHA1(678433b21aae1daa938e32d3293eeed529a42ef9) ) /* sprite lookup table */
+	ROM_LOAD( "timeplt.e12",  0x0140, 0x0100, BAD_DUMP CRC(f7b7663e) SHA1(151bd2dff4e4ef76d6438c1ab2cae71f987b9dad) ) /* char lookup table */
+ROM_END
+
+
 /*************************************
  *
  *  Game drivers
@@ -588,5 +842,8 @@
 GAME( 1982, timepltc, timeplt, timeplt, timeplt, 0, ROT90,  "Konami (Centuri license)", "Time Pilot (Centuri)", GAME_SUPPORTS_SAVE )
 GAME( 1982, timeplta, timeplt, timeplt, timeplt, 0, ROT90,  "Konami (Atari license)", "Time Pilot (Atari)", GAME_SUPPORTS_SAVE )
 GAME( 1982, spaceplt, timeplt, timeplt, timeplt, 0, ROT90,  "bootleg", "Space Pilot", GAME_SUPPORTS_SAVE )
-GAME( 1982, chkun,    0,       chkun,   chkun,  0, ROT90,  "<unknown>", "Chance Kun", GAME_SUPPORTS_SAVE | GAME_NOT_WORKING | GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
 GAME( 1988, psurge,   0,       psurge,  psurge,  0, ROT270, "<unknown>", "Power Surge", GAME_SUPPORTS_SAVE )
+// ROM says manufactured by Peni Soft for these two ... no, I'm not going to add THAT -.-"
+GAME( 1982, chkun,    0,       chkun,   chkun,   0, ROT90,  "<unknown>", "Chance Kun", GAME_SUPPORTS_SAVE | GAME_NOT_WORKING | GAME_IMPERFECT_COLORS | GAME_IMPERFECT_SOUND )
+GAME( 1987, bikkuric, 0,       chkun,   bikkuric,0, ROT90,  "<unknown>", "Bikkuri Card (Japan)", GAME_SUPPORTS_SAVE | GAME_NOT_WORKING | GAME_IMPERFECT_COLORS)
+
diff -Nru src-old/mame/drivers/timetrv.c src/mame/drivers/timetrv.c
--- src-old/mame/drivers/timetrv.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/timetrv.c	2012-05-03 11:00:08.000000000 +0200
@@ -59,13 +59,13 @@
 
 READ8_MEMBER(timetrv_state::test1_r)
 {
-	return input_port_read(machine(), "IN0");//machine().rand();
+	return ioport("IN0")->read();//machine().rand();
 }
 
 READ8_MEMBER(timetrv_state::test2_r)
 {
 	/*bit 7,eeprom read bit*/
-	return (input_port_read(machine(), "IN1") & 0x7f);//machine().rand();
+	return (ioport("IN1")->read() & 0x7f);//machine().rand();
 }
 
 
diff -Nru src-old/mame/drivers/tmaster.c src/mame/drivers/tmaster.c
--- src-old/mame/drivers/tmaster.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tmaster.c	2012-05-03 11:00:08.000000000 +0200
@@ -517,7 +517,7 @@
 
 READ16_MEMBER(tmaster_state::tmaster_coins_r)
 {
-	return input_port_read(machine(), "COIN")|(machine().rand()&0x0800);
+	return ioport("COIN")->read()|(machine().rand()&0x0800);
 }
 
 static ADDRESS_MAP_START( tmaster_map, AS_PROGRAM, 16, tmaster_state )
@@ -1834,7 +1834,7 @@
 static DRIVER_INIT( galgames )
 {
 	tmaster_state *state = machine.driver_data<tmaster_state>();
-	UINT8 *ROM	=	machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM	=	state->memregion("maincpu")->base();
 	int cart;
 
 	// RAM bank at 0x000000-0x03ffff and 0x200000-0x23ffff
@@ -1856,7 +1856,7 @@
 
 	for (cart = 1; cart <= 4; cart++)
 	{
-		UINT8 *CART = machine.root_device().memregion("maincpu")->base();
+		UINT8 *CART = state->memregion("maincpu")->base();
 
 		if  (0x200000 * (cart+1) <= state->memregion("maincpu")->bytes())
 			CART += 0x200000 * cart;
diff -Nru src-old/mame/drivers/tmmjprd.c src/mame/drivers/tmmjprd.c
--- src-old/mame/drivers/tmmjprd.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tmmjprd.c	2012-05-03 11:00:08.000000000 +0200
@@ -515,15 +515,15 @@
 READ32_MEMBER(tmmjprd_state::tmmjprd_mux_r)
 {
 
-	m_system_in = input_port_read(machine(), "SYSTEM");
+	m_system_in = ioport("SYSTEM")->read();
 
 	switch(m_mux_data)
 	{
-		case 0x01: return (m_system_in & 0xff) | (input_port_read(machine(), "PL1_1")<<8) | (input_port_read(machine(), "PL2_1")<<16) | 0xff000000;
-		case 0x02: return (m_system_in & 0xff) | (input_port_read(machine(), "PL1_2")<<8) | (input_port_read(machine(), "PL2_2")<<16) | 0xff000000;
-		case 0x04: return (m_system_in & 0xff) | (input_port_read(machine(), "PL1_3")<<8) | (input_port_read(machine(), "PL2_3")<<16) | 0xff000000;
-		case 0x08: return (m_system_in & 0xff) | (input_port_read(machine(), "PL1_4")<<8) | (input_port_read(machine(), "PL2_4")<<16) | 0xff000000;
-		case 0x10: return (m_system_in & 0xff) | (input_port_read(machine(), "PL1_5")<<8) | (input_port_read(machine(), "PL2_5")<<16) | 0xff000000;
+		case 0x01: return (m_system_in & 0xff) | (ioport("PL1_1")->read()<<8) | (ioport("PL2_1")->read()<<16) | 0xff000000;
+		case 0x02: return (m_system_in & 0xff) | (ioport("PL1_2")->read()<<8) | (ioport("PL2_2")->read()<<16) | 0xff000000;
+		case 0x04: return (m_system_in & 0xff) | (ioport("PL1_3")->read()<<8) | (ioport("PL2_3")->read()<<16) | 0xff000000;
+		case 0x08: return (m_system_in & 0xff) | (ioport("PL1_4")->read()<<8) | (ioport("PL2_4")->read()<<16) | 0xff000000;
+		case 0x10: return (m_system_in & 0xff) | (ioport("PL1_5")->read()<<8) | (ioport("PL2_5")->read()<<16) | 0xff000000;
 	}
 
 	return (m_system_in & 0xff) | 0xffffff00;
diff -Nru src-old/mame/drivers/tmnt.c src/mame/drivers/tmnt.c
--- src-old/mame/drivers/tmnt.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tmnt.c	2012-05-03 11:00:08.000000000 +0200
@@ -434,7 +434,7 @@
 
 	/* bit 3 is service button */
 	/* bit 6 is ??? VBLANK? OBJMPX? */
-	res = input_port_read(machine(), "COINS");
+	res = ioport("COINS")->read();
 
 	m_toggle ^= 0x40;
 	return res ^ m_toggle;
@@ -448,7 +448,7 @@
 	/* bit 1 is EEPROM ready */
 	/* bit 2 is VBLANK (???) */
 	/* bit 7 is service button */
-	res = input_port_read(machine(), "EEPROM");
+	res = ioport("EEPROM")->read();
 
 	m_toggle ^= 0x04;
 	return res ^ m_toggle;
@@ -462,7 +462,7 @@
 	/* bit 1 is EEPROM ready */
 	/* bit 2 is VBLANK (???) */
 	/* bit 3 is service button */
-	res = input_port_read(machine(), "EEPROM");
+	res = ioport("EEPROM")->read();
 
 	m_toggle ^= 0x04;
 	return res ^ m_toggle;
@@ -475,7 +475,7 @@
 		/* bit 0 is data */
 		/* bit 1 is cs (active low) */
 		/* bit 2 is clock (active high) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 }
 
@@ -498,7 +498,7 @@
 	/* bit 1 is EEPROM ready */
 	/* bit 3 is VBLANK (???) */
 	/* bit 7 is service button */
-	res = input_port_read(machine(), "P2/EEPROM");
+	res = ioport("P2/EEPROM")->read();
 	m_toggle ^= 0x0800;
 	return (res ^ m_toggle);
 }
@@ -511,7 +511,7 @@
 		/* bit 0 is data */
 		/* bit 1 is cs (active low) */
 		/* bit 2 is clock (active high) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 
 		/* bit 5 triggers IRQ on sound cpu */
 		if (m_last == 0 && (data & 0x20) != 0)
@@ -535,7 +535,7 @@
 		/* bit 8 is data */
 		/* bit 9 is cs (active low) */
 		/* bit 10 is clock (active high) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xffff);
+		ioport("EEPROMOUT")->write(data, 0xffff);
 	}
 }
 
@@ -1790,7 +1790,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SPECIAL )	/* EEPROM status? - always 1 */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: OBJMPX */
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )	/* ?? TMNT2: NVBLK */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ?? TMNT2: NVBLK */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: IPL0 */
 	PORT_BIT( 0x60, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_SERVICE_NO_TOGGLE( 0x80, IP_ACTIVE_LOW )
@@ -1828,7 +1828,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SPECIAL )	/* EEPROM status? - always 1 */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: OBJMPX */
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )	/* ?? TMNT2: NVBLK */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ?? TMNT2: NVBLK */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: IPL0 */
 	PORT_BIT( 0x60, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_SERVICE_NO_TOGGLE( 0x80, IP_ACTIVE_LOW )
@@ -1868,7 +1868,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SPECIAL )	/* EEPROM status? - always 1 */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: OBJMPX */
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )	/* ?? TMNT2: NVBLK */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ?? TMNT2: NVBLK */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: IPL0 */
 	PORT_BIT( 0x60, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_SERVICE_NO_TOGGLE( 0x80, IP_ACTIVE_LOW )
@@ -1957,7 +1957,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SPECIAL )	/* EEPROM status? - always 1 */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: OBJMPX */
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )	/* ?? TMNT2: NVBLK (needs to be ACTIVE_HIGH to avoid problems) */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* ?? TMNT2: NVBLK (needs to be ACTIVE_HIGH to avoid problems) */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* ?? TMNT2: IPL0 */
 	PORT_BIT( 0x60, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* unused? */
 	PORT_SERVICE_NO_TOGGLE( 0x80, IP_ACTIVE_LOW )
diff -Nru src-old/mame/drivers/tmspoker.c src/mame/drivers/tmspoker.c
--- src-old/mame/drivers/tmspoker.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tmspoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -300,7 +300,7 @@
 
 static MACHINE_RESET( tmspoker )
 {
-	UINT8 seldsw = (input_port_read(machine, "SELDSW") );
+	UINT8 seldsw = (machine.root_device().ioport("SELDSW")->read() );
 
 	popmessage("ROM Bank: %02X", seldsw);
 
diff -Nru src-old/mame/drivers/tnzs.c src/mame/drivers/tnzs.c
--- src-old/mame/drivers/tnzs.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tnzs.c	2012-05-03 11:00:08.000000000 +0200
@@ -680,8 +680,8 @@
 	tnzs_state *state = device->machine().driver_data<tnzs_state>();
 	int dsw, dsw1, dsw2;
 
-	dsw1 = input_port_read(device->machine(), "DSWA");
-	dsw2 = input_port_read(device->machine(), "DSWB");
+	dsw1 = state->ioport("DSWA")->read();
+	dsw2 = state->ioport("DSWB")->read();
 
 	switch (state->m_kageki_csport_sel)
 	{
diff -Nru src-old/mame/drivers/toaplan1.c src/mame/drivers/toaplan1.c
--- src-old/mame/drivers/toaplan1.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/toaplan1.c	2012-05-03 11:00:08.000000000 +0200
@@ -689,7 +689,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x0001, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xfffe, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 INPUT_PORTS_END
 
@@ -724,11 +724,11 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN2 )		\
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_START1 )	\
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START2 )	\
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 #define  TOAPLAN1_VBLANK_INPUT						\
 	PORT_START("VBLANK")						\
-	PORT_BIT( 0x0001, IP_ACTIVE_HIGH, IPT_VBLANK )	\
+	PORT_BIT( 0x0001, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	\
 	PORT_BIT( 0xfffe, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 
 
diff -Nru src-old/mame/drivers/toaplan2.c src/mame/drivers/toaplan2.c
--- src-old/mame/drivers/toaplan2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/toaplan2.c	2012-05-03 11:00:08.000000000 +0200
@@ -662,7 +662,7 @@
 {
 	INT8 value, new_value;
 
-	new_value = input_port_read(machine(), "PAD1");
+	new_value = ioport("PAD1")->read();
 	if (new_value == m_old_p1_paddle_h) return 0;
 	value = new_value - m_old_p1_paddle_h;
 	m_old_p1_paddle_h = new_value;
@@ -674,7 +674,7 @@
 {
 	INT8 value, new_value;
 
-	new_value = input_port_read(machine(), "PAD2");
+	new_value = ioport("PAD2")->read();
 	if (new_value == m_old_p2_paddle_h) return 0;
 	value = new_value - m_old_p2_paddle_h;
 	m_old_p2_paddle_h = new_value;
@@ -788,19 +788,19 @@
 
 READ8_MEMBER(toaplan2_state::v25_dswa_r)
 {
-	return input_port_read(machine(), "DSWA") ^ 0xff;
+	return ioport("DSWA")->read() ^ 0xff;
 }
 
 
 READ8_MEMBER(toaplan2_state::v25_dswb_r)
 {
-	return input_port_read(machine(), "DSWB") ^ 0xff;
+	return ioport("DSWB")->read() ^ 0xff;
 }
 
 
 READ8_MEMBER(toaplan2_state::v25_jmpr_r)
 {
-	return input_port_read(machine(), "JMPR") ^ 0xff;
+	return ioport("JMPR")->read() ^ 0xff;
 }
 
 
@@ -1010,7 +1010,7 @@
 		logerror("CPU #0 PC:%06X - Unknown EEPROM data being written %04X\n",cpu_get_pc(&space.device()),data);
 
 	if ( ACCESSING_BITS_0_7 )
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 
 	m_z80_busreq = data & 0x10;	// see bbakraid_eeprom_r above
 }
@@ -2521,25 +2521,25 @@
 	PORT_DIPSETTING(		0x0008, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(		0x000c, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(		0x001c, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
-	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
+	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
+	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSWA", 0x001c, NOTEQUALS, 0x001c)
 	// When Coin_A is set to Free_Play, Coin_A becomes Coin_A and Coin_B, and the following dips occur
-	PORT_DIPNAME( 0x0020,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
-	PORT_DIPSETTING(		0x0000, "90 degrees ACW" )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( Normal ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0040,	0x0000, "Effect" )				PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSWA", 0x001c, PORTCOND_EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0020,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
+	PORT_DIPSETTING(		0x0000, "90 degrees ACW" )		PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( Normal ) )		PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0040,	0x0000, "Effect" )				PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSWA", 0x001c, EQUALS, 0x001c)
 
 	PORT_START("DSWB")
 	PORT_DIPNAME( 0x0003,	0x0000, DEF_STR( Difficulty ) )		PORT_DIPLOCATION("SW2:!1,!2")
@@ -2563,10 +2563,10 @@
 	PORT_DIPSETTING(		0x0060, DEF_STR( Infinite ) )
 	PORT_DIPSETTING(		0x0070, "Invulnerability (Cheat)" )
 	PORT_DIPNAME( 0x0080,	0x0000, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:!8")
-	PORT_DIPSETTING(		0x0000, DEF_STR( None ) )		PORT_CONDITION("JMPR",0x0003,PORTCOND_NOTEQUALS,0x0000)	// Non-Japan
-	PORT_DIPSETTING(		0x0080, "Every 2000k" )			PORT_CONDITION("JMPR",0x0003,PORTCOND_NOTEQUALS,0x0000)	// Non-Japan
-	PORT_DIPSETTING(		0x0080, "1000k and 2000k" )		PORT_CONDITION("JMPR",0x0003,PORTCOND_EQUALS,0x0000)	// Japan
-	PORT_DIPSETTING(		0x0000, "Every 1000k" )			PORT_CONDITION("JMPR",0x0003,PORTCOND_EQUALS,0x0000)	// Japan
+	PORT_DIPSETTING(		0x0000, DEF_STR( None ) )		PORT_CONDITION("JMPR",0x0003,NOTEQUALS,0x0000)	// Non-Japan
+	PORT_DIPSETTING(		0x0080, "Every 2000k" )			PORT_CONDITION("JMPR",0x0003,NOTEQUALS,0x0000)	// Non-Japan
+	PORT_DIPSETTING(		0x0080, "1000k and 2000k" )		PORT_CONDITION("JMPR",0x0003,EQUALS,0x0000)	// Japan
+	PORT_DIPSETTING(		0x0000, "Every 1000k" )			PORT_CONDITION("JMPR",0x0003,EQUALS,0x0000)	// Japan
 
 	PORT_START("JMPR")
 	PORT_DIPNAME( 0x0008,	0x0000, "Stage Edit" )	PORT_DIPLOCATION("SW3:!1")
@@ -2642,12 +2642,12 @@
 
 	PORT_START("DSW")		// DSWA and DSWB
 	PORT_SERVICE_DIPLOC(0x0001, IP_ACTIVE_HIGH, "SW1:!1")
-	PORT_DIPNAME( 0x0002,	0x0000, "Credits to Start" )	PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!2")
-	PORT_DIPSETTING(		0x0000, "1" )					PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0002, "2" )					PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPNAME( 0x0002,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)		PORT_DIPLOCATION("SW1:!2")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0002, "90 degrees ACW" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0002,	0x0000, "Credits to Start" )	PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!2")
+	PORT_DIPSETTING(		0x0000, "1" )					PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0002, "2" )					PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPNAME( 0x0002,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)		PORT_DIPLOCATION("SW1:!2")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0002, "90 degrees ACW" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
 	PORT_DIPNAME( 0x001c,	0x0000, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:!3,!4,!5")
 	PORT_DIPSETTING(		0x0018, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(		0x0014, DEF_STR( 3C_1C ) )
@@ -2657,25 +2657,25 @@
 	PORT_DIPSETTING(		0x0008, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(		0x000c, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(		0x001c, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
-	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
+	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
+	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
 	// When Coin_A is set to Free_Play, Coin_A becomes Coin_A and Coin_B, and the following dips occur
-	PORT_DIPNAME( 0x0020,	0x0000, "Hit Score" )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0040,	0x0000, "Sound Effect" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0020,	0x0000, "Hit Score" )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0040,	0x0000, "Sound Effect" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
 	PORT_DIPNAME( 0x0300,	0x0000, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:!1,!2")
 	PORT_DIPSETTING(		0x0100, DEF_STR( Easy ) )
 	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )
@@ -2771,12 +2771,12 @@
 
 	PORT_START("DSW")		// DSWA and DSWB
 	PORT_SERVICE_DIPLOC(0x0001, IP_ACTIVE_HIGH, "SW1:!1")
-	PORT_DIPNAME( 0x0002,	0x0000, "Credits to Start" )	PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!2")
-	PORT_DIPSETTING(		0x0000, "1" )					PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0002, "2" )					PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPNAME( 0x0002,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)		PORT_DIPLOCATION("SW1:!2")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0002, "90 degrees ACW" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0002,	0x0000, "Credits to Start" )	PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!2")
+	PORT_DIPSETTING(		0x0000, "1" )					PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0002, "2" )					PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPNAME( 0x0002,	0x0000, "Joystick Mode" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)		PORT_DIPLOCATION("SW1:!2")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0002, "90 degrees ACW" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
 	PORT_DIPNAME( 0x001c,	0x0000, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:!3,!4,!5")
 	PORT_DIPSETTING(		0x0018, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(		0x0014, DEF_STR( 3C_1C ) )
@@ -2786,25 +2786,25 @@
 	PORT_DIPSETTING(		0x0008, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(		0x000c, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(		0x001c, DEF_STR( Free_Play ) )
-	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
-	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_NOTEQUALS, 0x001c)
+	PORT_DIPNAME( 0x00e0,	0x0000, DEF_STR( Coin_B ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6,!7,!8")
+	PORT_DIPSETTING(		0x00c0, DEF_STR( 4C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x00a0, DEF_STR( 3C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( 2C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0000, DEF_STR( 1C_1C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+//  PORT_DIPSETTING(        0x00e0, DEF_STR( 1C_1C ) )      PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( 1C_2C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( 1C_3C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0060, DEF_STR( 1C_4C ) )		PORT_CONDITION("DSW", 0x001c, NOTEQUALS, 0x001c)
 	// When Coin_A is set to Free_Play, Coin_A becomes Coin_A and Coin_B, and the following dips occur
-	PORT_DIPNAME( 0x0020,	0x0000, "Hit Score" )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0020, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0040,	0x0000, "Sound Effect" )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
-	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
-	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, PORTCOND_EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0020,	0x0000, "Hit Score" )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!6")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0020, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0040,	0x0000, "Sound Effect" )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!7")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0040, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPNAME( 0x0080,	0x0000, "Music" )				PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)	PORT_DIPLOCATION("SW1:!8")
+	PORT_DIPSETTING(		0x0000, DEF_STR( Off ) )		PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
+	PORT_DIPSETTING(		0x0080, DEF_STR( On ) )			PORT_CONDITION("DSW", 0x001c, EQUALS, 0x001c)
 	PORT_DIPNAME( 0x0300,	0x0000, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:!1,!2")
 	PORT_DIPSETTING(		0x0100, DEF_STR( Easy ) )
 	PORT_DIPSETTING(		0x0000, DEF_STR( Normal ) )
diff -Nru src-old/mame/drivers/tomcat.c src/mame/drivers/tomcat.c
--- src-old/mame/drivers/tomcat.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/tomcat.c	2012-05-03 11:00:08.000000000 +0200
@@ -89,8 +89,8 @@
 {
 	switch( m_control_num )
 	{
-	case 0: return input_port_read(machine(), "STICKY");
-	case 1: return input_port_read(machine(), "STICKX");
+	case 0: return ioport("STICKY")->read();
+	case 1: return ioport("STICKX")->read();
 	default: return 0x7f7f;
 	}
 }
@@ -99,7 +99,7 @@
 {
 	UINT16 result = 0;
 	if (ACCESSING_BITS_8_15)
-		result |= input_port_read(machine(), "IN0") << 8;
+		result |= ioport("IN0")->read() << 8;
 
 	return result;
 }
diff -Nru src-old/mame/drivers/toobin.c src/mame/drivers/toobin.c
--- src-old/mame/drivers/toobin.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/toobin.c	2012-05-03 11:00:08.000000000 +0200
@@ -90,7 +90,7 @@
 
 READ16_MEMBER(toobin_state::special_port1_r)
 {
-	int result = input_port_read(machine(), "FF9000");
+	int result = ioport("FF9000")->read();
 	if (atarigen_get_hblank(*machine().primary_screen)) result ^= 0x8000;
 	if (m_cpu_to_sound_ready) result ^= 0x2000;
 	return result;
@@ -158,7 +158,7 @@
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_SERVICE( 0x1000, IP_ACTIVE_LOW )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_INCLUDE( atarijsa_i )		/* audio port */
diff -Nru src-old/mame/drivers/topspeed.c src/mame/drivers/topspeed.c
--- src-old/mame/drivers/topspeed.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/topspeed.c	2012-05-03 11:00:08.000000000 +0200
@@ -324,8 +324,8 @@
 {
 	UINT8 port = tc0220ioc_port_r(m_tc0220ioc, 0);	/* read port number */
 	int steer = 0;
-	int analogue_steer = input_port_read_safe(machine(), STEER_PORT_TAG, 0x00);
-	int fake = input_port_read_safe(machine(), FAKE_PORT_TAG, 0x00);
+	int analogue_steer = ioport(STEER_PORT_TAG)->read_safe(0x00);
+	int fake = ioport(FAKE_PORT_TAG)->read_safe(0x00);
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
diff -Nru src-old/mame/drivers/toratora.c src/mame/drivers/toratora.c
--- src-old/mame/drivers/toratora.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/toratora.c	2012-05-03 11:00:08.000000000 +0200
@@ -148,14 +148,14 @@
 	if (state->m_timer & 0x100)
 		popmessage("watchdog!");
 
-	if (state->m_last != (input_port_read(device->machine(), "INPUT") & 0x0f))
+	if (state->m_last != (state->ioport("INPUT")->read() & 0x0f))
 	{
-		state->m_last = input_port_read(device->machine(), "INPUT") & 0x0f;
+		state->m_last = state->ioport("INPUT")->read() & 0x0f;
 		generic_pulse_irq_line(device, 0, 1);
 	}
-	state->m_pia_u1->set_a_input(input_port_read(device->machine(), "INPUT") & 0x0f, 0);
-	state->m_pia_u1->ca1_w(input_port_read(device->machine(), "INPUT") & 0x10);
-	state->m_pia_u1->ca2_w(input_port_read(device->machine(), "INPUT") & 0x20);
+	state->m_pia_u1->set_a_input(device->machine().root_device().ioport("INPUT")->read() & 0x0f, 0);
+	state->m_pia_u1->ca1_w(device->machine().root_device().ioport("INPUT")->read() & 0x10);
+	state->m_pia_u1->ca2_w(device->machine().root_device().ioport("INPUT")->read() & 0x20);
 }
 
 READ8_MEMBER(toratora_state::timer_r)
diff -Nru src-old/mame/drivers/tourtabl.c src/mame/drivers/tourtabl.c
--- src-old/mame/drivers/tourtabl.c	2012-04-18 19:25:26.000000000 +0200
+++ src/mame/drivers/tourtabl.c	2012-05-03 11:00:08.000000000 +0200
@@ -40,7 +40,7 @@
 {
 	static const char *const tianames[] = { "PADDLE4", "PADDLE3", "PADDLE2", "PADDLE1", "TIA_IN4", "TIA_IN5" };
 
-	return input_port_read(device->machine(), tianames[offset]);
+	return device->machine().root_device().ioport(tianames[offset])->read();
 }
 
 static READ8_DEVICE_HANDLER( tourtabl_get_databus_contents )
diff -Nru src-old/mame/drivers/tourvis.c src/mame/drivers/tourvis.c
--- src-old/mame/drivers/tourvis.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/tourvis.c	2012-05-06 04:09:52.000000000 +0200
@@ -18,7 +18,7 @@
     Power League IV
     Final Match Tennis
     Formation Soccer
-    Super Volleay Ball
+    Super Volley ball
     Rastan Saga II
     Dungeon Explorer
     Legendary Axe
@@ -492,15 +492,34 @@
 	TOURVISION_BIOS
 ROM_END
 
+
+ROM_START(tvlegaxe)
+	ROM_REGION( 0x100000, "maincpu", 0 )
+	ROM_LOAD( "tourv_makyodensetsuthelegendaryaxe.bin", 0x00000, 0x100000, CRC(50ec3f97) SHA1(d583fa240a4dfd14b0d53ff78762fbac52694dd2) )
+
+	TOURVISION_BIOS
+ROM_END
+
+
+ROM_START(tvsvball)
+	ROM_REGION( 0x100000, "maincpu", 0 )
+	ROM_LOAD( "tourv_supervolleyball.bin", 0x00000, 0x100000, CRC(8a32a1ca) SHA1(80144fb4035415eb9b2c67d78d55757ed0d641a1) )
+
+	TOURVISION_BIOS
+ROM_END
+
+
 static DRIVER_INIT(tourvision)
 {
 	DRIVER_INIT_CALL(pce);
 }
 
 GAME( 19??, tourvis,  0,       tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision)", "Tourvision PCE bootleg", GAME_IS_BIOS_ROOT | GAME_NOT_WORKING )
+GAME( 1988, tvlegaxe, tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Victor Musical Industries, Inc.", "Makyo Densetsu - The Legenary Axe (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1989, tvusapb,  tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Aicom", "USA Pro Basketball (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1989, tvdunexp, tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Hudson / Atlus", "Dungeon Explorer (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1990, tvthbld,  tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Sega / NEC Avenue", "Thunder Blade (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1990, tvrs2,    tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Taito", "Rastan Saga II (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
+GAME( 1990, tvsvball, tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Video System", "Super Volley ball (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1991, tvpwlg4,  tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Hudson", "Power League IV (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
 GAME( 1991, tvsci,    tourvis, tourvision, tourvision, tourvision, ROT0, "bootleg (Tourvision) / Taito", "Special Criminal Investigation (Tourvision PCE bootleg)", GAME_IMPERFECT_SOUND | GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/toypop.c src/mame/drivers/toypop.c
--- src-old/mame/drivers/toypop.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/toypop.c	2012-05-03 11:00:08.000000000 +0200
@@ -306,17 +306,17 @@
 	PORT_DIPSETTING(    0x1c, "40k 120k 200k 400k 600k 1m" )
 	PORT_DIPSETTING(    0x0c, "40k 140k 250k 400k 700k 1m" )
 	// bonus scores for 1, 2 or 3 lives
-	PORT_DIPSETTING(    0x14, "50k 150k 300k 500k 700k 1m" ) PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
-	PORT_DIPSETTING(    0x04, "40k 120k and every 120k" )    PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
-	PORT_DIPSETTING(    0x18, "40k 150k and every 150k" )    PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
-	PORT_DIPSETTING(    0x08, "50k 150k 300k" )              PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
-	PORT_DIPSETTING(    0x10, "40k 120k 200k" )              PORT_CONDITION("DSW1", 0x03, PORTCOND_NOTEQUALS, 0x01)
+	PORT_DIPSETTING(    0x14, "50k 150k 300k 500k 700k 1m" ) PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
+	PORT_DIPSETTING(    0x04, "40k 120k and every 120k" )    PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
+	PORT_DIPSETTING(    0x18, "40k 150k and every 150k" )    PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
+	PORT_DIPSETTING(    0x08, "50k 150k 300k" )              PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
+	PORT_DIPSETTING(    0x10, "40k 120k 200k" )              PORT_CONDITION("DSW1", 0x03, NOTEQUALS, 0x01)
 	// bonus scores for 5 lives
-	PORT_DIPSETTING(    0x14, "40k 120k" )                   PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x04, "50k 150k" )                   PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x18, "50k 150k and every 150k" )    PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x08, "60k 200k and every 200k" )    PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)
-	PORT_DIPSETTING(    0x10, "50k" )                        PORT_CONDITION("DSW1", 0x03, PORTCOND_EQUALS, 0x01)
+	PORT_DIPSETTING(    0x14, "40k 120k" )                   PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x04, "50k 150k" )                   PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x18, "50k 150k and every 150k" )    PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x08, "60k 200k and every 200k" )    PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)
+	PORT_DIPSETTING(    0x10, "50k" )                        PORT_CONDITION("DSW1", 0x03, EQUALS, 0x01)
 	// bonus scores for common
 	PORT_DIPSETTING(    0x00, DEF_STR( None ) )
 	PORT_DIPNAME( 0xe0, 0xe0, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SWA:3,2,1")
@@ -493,10 +493,10 @@
 
 ***************************************************************************/
 
-static READ8_DEVICE_HANDLER( dipA_l )	{ return input_port_read(device->machine(), "DSW1"); }				// dips A
-static READ8_DEVICE_HANDLER( dipA_h )	{ return input_port_read(device->machine(), "DSW1") >> 4; }			// dips A
-static READ8_DEVICE_HANDLER( dipB_l )	{ return input_port_read(device->machine(), "DSW2"); }				// dips B
-static READ8_DEVICE_HANDLER( dipB_h )	{ return input_port_read(device->machine(), "DSW2") >> 4; }			// dips B
+static READ8_DEVICE_HANDLER( dipA_l )	{ return device->machine().root_device().ioport("DSW1")->read(); }				// dips A
+static READ8_DEVICE_HANDLER( dipA_h )	{ return device->machine().root_device().ioport("DSW1")->read() >> 4; }			// dips A
+static READ8_DEVICE_HANDLER( dipB_l )	{ return device->machine().root_device().ioport("DSW2")->read(); }				// dips B
+static READ8_DEVICE_HANDLER( dipB_h )	{ return device->machine().root_device().ioport("DSW2")->read() >> 4; }			// dips B
 
 static WRITE8_DEVICE_HANDLER( out_coin0 )
 {
diff -Nru src-old/mame/drivers/trackfld.c src/mame/drivers/trackfld.c
--- src-old/mame/drivers/trackfld.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/trackfld.c	2012-05-03 11:00:08.000000000 +0200
@@ -634,8 +634,8 @@
 	PORT_DIPSETTING(    0x0b, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x09, DEF_STR( 1C_7C ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )	PORT_CONDITION("DSW1", 0xf0, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "No Coin A" )				PORT_CONDITION("DSW1", 0xf0, PORTCOND_NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )	PORT_CONDITION("DSW1", 0xf0, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "No Coin A" )				PORT_CONDITION("DSW1", 0xf0, NOTEQUALS, 0x00)
 	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:5,6,7,8")
 	PORT_DIPSETTING(    0x20, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x50, DEF_STR( 3C_1C ) )
@@ -652,8 +652,8 @@
 	PORT_DIPSETTING(    0xb0, DEF_STR( 1C_5C ) )
 	PORT_DIPSETTING(    0xa0, DEF_STR( 1C_6C ) )
 	PORT_DIPSETTING(    0x90, DEF_STR( 1C_7C ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )	PORT_CONDITION("DSW1", 0x0f, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, "No Coin B" )				PORT_CONDITION("DSW1", 0x0f, PORTCOND_NOTEQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )	PORT_CONDITION("DSW1", 0x0f, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, "No Coin B" )				PORT_CONDITION("DSW1", 0x0f, NOTEQUALS, 0x00)
 	/* No Coin X = coin slot X open (coins produce sound), but no effect on coin counter */
 
 	PORT_START("DSW2")
diff -Nru src-old/mame/drivers/triplhnt.c src/mame/drivers/triplhnt.c
--- src-old/mame/drivers/triplhnt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/triplhnt.c	2012-05-03 11:00:08.000000000 +0200
@@ -76,7 +76,7 @@
 	discrete_sound_w(discrete, TRIPLHNT_LAMP_EN, state->m_misc_flags & 0x02);	// Lamp is used to reset noise
 	discrete_sound_w(discrete, TRIPLHNT_BEAR_EN, state->m_misc_flags & 0x80);	// bear
 
-	is_witch_hunt = input_port_read(machine, "0C09") == 0x40;
+	is_witch_hunt = machine.root_device().ioport("0C09")->read() == 0x40;
 	bit = ~state->m_misc_flags & 0x40;
 
 	/* if we're not playing the sample yet, start it */
@@ -108,21 +108,21 @@
 READ8_MEMBER(triplhnt_state::triplhnt_input_port_4_r)
 {
 	watchdog_reset_w(space, 0, 0);
-	return input_port_read(machine(), "0C0B");
+	return ioport("0C0B")->read();
 }
 
 
 READ8_MEMBER(triplhnt_state::triplhnt_misc_r)
 {
 	triplhnt_update_misc(machine(), offset);
-	return input_port_read(machine(), "VBLANK") | m_hit_code;
+	return ioport("VBLANK")->read() | m_hit_code;
 }
 
 
 READ8_MEMBER(triplhnt_state::triplhnt_da_latch_r)
 {
-	int cross_x = input_port_read(machine(), "STICKX");
-	int cross_y = input_port_read(machine(), "STICKY");
+	int cross_x = ioport("STICKX")->read();
+	int cross_y = ioport("STICKY")->read();
 
 	m_da_latch = offset;
 
@@ -196,7 +196,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )
 
 	PORT_START("VBLANK")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("STICKX")
 	PORT_BIT( 0xfc, 0x80, IPT_AD_STICK_X ) PORT_MINMAX(0x00,0xfc)  PORT_CROSSHAIR(X, 62.0/64, 1.0/64, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15)
diff -Nru src-old/mame/drivers/truco.c src/mame/drivers/truco.c
--- src-old/mame/drivers/truco.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/truco.c	2012-05-03 11:00:08.000000000 +0200
@@ -395,7 +395,7 @@
 	truco_state *state = device->machine().driver_data<truco_state>();
 	/* coinup */
 
-	if ( input_port_read(device->machine(),  "COIN") & 1 )
+	if ( state->ioport("COIN")->read() & 1 )
 	{
 		if ( state->m_trigger == 0 )
 		{
diff -Nru src-old/mame/drivers/tryout.c src/mame/drivers/tryout.c
--- src-old/mame/drivers/tryout.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tryout.c	2012-05-03 11:00:08.000000000 +0200
@@ -140,7 +140,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CHANGED_MEMBER(DEVICE_SELF, tryout_state,coin_inserted, 0)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 static const gfx_layout charlayout =
diff -Nru src-old/mame/drivers/tugboat.c src/mame/drivers/tugboat.c
--- src-old/mame/drivers/tugboat.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tugboat.c	2012-05-03 11:00:08.000000000 +0200
@@ -145,15 +145,15 @@
 {
 	tugboat_state *state = device->machine().driver_data<tugboat_state>();
 	if (~state->m_ctrl & 0x80)
-		return input_port_read(device->machine(), "IN0");
+		return state->ioport("IN0")->read();
 	else if (~state->m_ctrl & 0x40)
-		return input_port_read(device->machine(), "IN1");
+		return state->ioport("IN1")->read();
 	else if (~state->m_ctrl & 0x20)
-		return input_port_read(device->machine(), "IN2");
+		return state->ioport("IN2")->read();
 	else if (~state->m_ctrl & 0x10)
-		return input_port_read(device->machine(), "IN3");
+		return state->ioport("IN3")->read();
 	else
-		return input_port_read(device->machine(), "IN4");
+		return state->ioport("IN4")->read();
 }
 
 static READ8_DEVICE_HANDLER( tugboat_ctrl_r )
diff -Nru src-old/mame/drivers/tumbleb.c src/mame/drivers/tumbleb.c
--- src-old/mame/drivers/tumbleb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tumbleb.c	2012-05-03 11:00:08.000000000 +0200
@@ -361,11 +361,11 @@
 	switch (offset << 1)
 	{
 		case 0:
-			return input_port_read(machine(), "PLAYERS");
+			return ioport("PLAYERS")->read();
 		case 2:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 8:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 10: /* ? */
 		case 12:
         	return 0;
@@ -952,7 +952,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1039,7 +1039,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1159,7 +1159,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1247,7 +1247,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1309,7 +1309,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1371,7 +1371,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1446,7 +1446,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1516,7 +1516,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_HIGH, IPT_UNKNOWN )      // must be high to avoid endless loops
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1593,7 +1593,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1671,7 +1671,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1814,7 +1814,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )       // to be confirmed
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")       // to be confirmed
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -2227,7 +2227,7 @@
 	tumbleb_state *state = machine.driver_data<tumbleb_state>();
 
 	/* copy protection data every reset */
-	UINT16 *PROTDATA = (UINT16*)machine.root_device().memregion("user1")->base();
+	UINT16 *PROTDATA = (UINT16*)state->memregion("user1")->base();
 	int i, len = state->memregion("user1")->bytes();
 
 	for (i = 0; i < len / 2; i++)
@@ -3441,7 +3441,7 @@
 	//mame_printf_debug("bcstory_io %06x\n",cpu_get_pc(&space.device()));
 
 	if (cpu_get_pc(&space.device())==0x0560) return 0x1a0;
-	else return input_port_read(machine(), "SYSTEM");
+	else return ioport("SYSTEM")->read();
 }
 
 static DRIVER_INIT ( bcstory )
@@ -3456,8 +3456,8 @@
 {
 
 	tumbleb_state *state = machine.driver_data<tumbleb_state>();
-//  UINT16 *HCROM = (UINT16*)machine.root_device().memregion("maincpu")->base();
-	UINT16 *PROTDATA = (UINT16*)machine.root_device().memregion("user1")->base();
+//  UINT16 *HCROM = (UINT16*)state->memregion("maincpu")->base();
+	UINT16 *PROTDATA = (UINT16*)state->memregion("user1")->base();
 	int i, len = state->memregion("user1")->bytes();
 	/* simulate RAM initialization done by the protection MCU */
 	/* verified on real hardware */
diff -Nru src-old/mame/drivers/tumblep.c src/mame/drivers/tumblep.c
--- src-old/mame/drivers/tumblep.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/tumblep.c	2012-05-03 11:00:08.000000000 +0200
@@ -89,11 +89,11 @@
 	switch (offset << 1)
 	{
 		case 0:
-			return input_port_read(machine(), "PLAYERS");
+			return ioport("PLAYERS")->read();
 		case 2:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 8:
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 		case 10: /* ? */
 		case 12:
         	return 0;
@@ -164,7 +164,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/tunhunt.c src/mame/drivers/tunhunt.c
--- src-old/mame/drivers/tunhunt.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/tunhunt.c	2012-05-03 11:00:08.000000000 +0200
@@ -88,38 +88,38 @@
 
 READ8_MEMBER(tunhunt_state::tunhunt_button_r)
 {
-	int data = input_port_read(machine(), "IN0");
+	int data = ioport("IN0")->read();
 	return ((data>>offset)&1)?0x00:0x80;
 }
 
 
 static READ8_DEVICE_HANDLER( dsw2_0r )
 {
-	return (input_port_read(device->machine(), "DSW")&0x0100)?0x80:0x00;
+	return (device->machine().root_device().ioport("DSW")->read()&0x0100)?0x80:0x00;
 }
 
 
 static READ8_DEVICE_HANDLER( dsw2_1r )
 {
-	return (input_port_read(device->machine(), "DSW")&0x0200)?0x80:0x00;
+	return (device->machine().root_device().ioport("DSW")->read()&0x0200)?0x80:0x00;
 }
 
 
 static READ8_DEVICE_HANDLER( dsw2_2r )
 {
-	return (input_port_read(device->machine(), "DSW")&0x0400)?0x80:0x00;
+	return (device->machine().root_device().ioport("DSW")->read()&0x0400)?0x80:0x00;
 }
 
 
 static READ8_DEVICE_HANDLER( dsw2_3r )
 {
-	return (input_port_read(device->machine(), "DSW")&0x0800)?0x80:0x00;
+	return (device->machine().root_device().ioport("DSW")->read()&0x0800)?0x80:0x00;
 }
 
 
 static READ8_DEVICE_HANDLER( dsw2_4r )
 {
-	return (input_port_read(device->machine(), "DSW")&0x1000)?0x80:0x00;
+	return (device->machine().root_device().ioport("DSW")->read()&0x1000)?0x80:0x00;
 }
 
 
@@ -171,7 +171,7 @@
 	PORT_BIT ( 0x10, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT ( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT ( 0x40, IP_ACTIVE_HIGH, IPT_START1 )
-	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT ( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0xff, 0x00, IPT_AD_STICK_Y ) PORT_SENSITIVITY(100) PORT_KEYDELTA(4)
diff -Nru src-old/mame/drivers/turbo.c src/mame/drivers/turbo.c
--- src-old/mame/drivers/turbo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/turbo.c	2012-05-03 11:00:08.000000000 +0200
@@ -490,7 +490,7 @@
 READ8_MEMBER(turbo_state::turbo_collision_r)
 {
 	machine().primary_screen->update_partial(machine().primary_screen->vpos());
-	return input_port_read(machine(), "DSW3") | (m_turbo_collision & 15);
+	return ioport("DSW3")->read() | (m_turbo_collision & 15);
 }
 
 
@@ -504,13 +504,13 @@
 static READ8_DEVICE_HANDLER( turbo_analog_r )
 {
 	turbo_state *state = device->machine().driver_data<turbo_state>();
-	return input_port_read(device->machine(), "DIAL") - state->m_turbo_last_analog;
+	return state->ioport("DIAL")->read() - state->m_turbo_last_analog;
 }
 
 
 WRITE8_MEMBER(turbo_state::turbo_analog_reset_w)
 {
-	m_turbo_last_analog = input_port_read(machine(), "DIAL");
+	m_turbo_last_analog = ioport("DIAL")->read();
 }
 
 
@@ -548,8 +548,8 @@
 
 READ8_MEMBER(turbo_state::buckrog_port_2_r)
 {
-	int inp1 = input_port_read(machine(), "DSW1");
-	int inp2 = input_port_read(machine(), "DSW2");
+	int inp1 = ioport("DSW1")->read();
+	int inp2 = ioport("DSW2")->read();
 
 	return  (((inp2 >> 6) & 1) << 7) |
 			(((inp2 >> 4) & 1) << 6) |
@@ -564,8 +564,8 @@
 
 READ8_MEMBER(turbo_state::buckrog_port_3_r)
 {
-	int inp1 = input_port_read(machine(), "DSW1");
-	int inp2 = input_port_read(machine(), "DSW2");
+	int inp1 = ioport("DSW1")->read();
+	int inp2 = ioport("DSW2")->read();
 
 	return  (((inp2 >> 7) & 1) << 7) |
 			(((inp2 >> 5) & 1) << 6) |
diff -Nru src-old/mame/drivers/twin16.c src/mame/drivers/twin16.c
--- src-old/mame/drivers/twin16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/twin16.c	2012-05-03 11:00:08.000000000 +0200
@@ -176,13 +176,13 @@
 {
 	switch( offset )
 	{
-		case 0x00: return input_port_read(machine(), "SYSTEM");
-		case 0x01: return input_port_read(machine(), "P1");
-		case 0x02: return input_port_read(machine(), "P2");
-		case 0x03: return input_port_read(machine(), "P3");
-		case 0x08: return input_port_read(machine(), "DSW2");
-		case 0x09: return input_port_read(machine(), "DSW1");
-		case 0x0c: return input_port_read(machine(), "DSW3");
+		case 0x00: return ioport("SYSTEM")->read();
+		case 0x01: return ioport("P1")->read();
+		case 0x02: return ioport("P2")->read();
+		case 0x03: return ioport("P3")->read();
+		case 0x08: return ioport("DSW2")->read();
+		case 0x09: return ioport("DSW1")->read();
+		case 0x0c: return ioport("DSW3")->read();
 		default: break;
 	}
 	return 0;
diff -Nru src-old/mame/drivers/twincobr.c src/mame/drivers/twincobr.c
--- src-old/mame/drivers/twincobr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/twincobr.c	2012-05-03 11:00:08.000000000 +0200
@@ -390,7 +390,7 @@
 
 	PORT_START("VBLANK")
 	PORT_BIT( 0x7f, IP_ACTIVE_HIGH, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 /* verified from M68000 and Z80 code */
@@ -425,7 +425,7 @@
 
 	PORT_MODIFY("VBLANK")
 	PORT_BIT( 0x7f, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 
@@ -471,7 +471,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START2 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 INPUT_PORTS_END
 
 /* verified from M68000 code */
diff -Nru src-old/mame/drivers/twinkle.c src/mame/drivers/twinkle.c
--- src-old/mame/drivers/twinkle.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/twinkle.c	2012-05-03 11:00:08.000000000 +0200
@@ -504,27 +504,27 @@
 		switch( m_io_offset )
 		{
 			case 0x07:
-				data |= input_port_read( machine(), "IN0" );
+				data |= ioport( "IN0" )->read();
 				break;
 
 			case 0x0f:
-				data |= input_port_read( machine(), "IN1" );
+				data |= ioport( "IN1" )->read();
 				break;
 
 			case 0x17:
-				data |= input_port_read( machine(), "IN2" );
+				data |= ioport( "IN2" )->read();
 				break;
 
 			case 0x1f:
-				data |= input_port_read( machine(), "IN3" );
+				data |= ioport( "IN3" )->read();
 				break;
 
 			case 0x27:
-				data |= input_port_read( machine(), "IN4" );
+				data |= ioport( "IN4" )->read();
 				break;
 
 			case 0x2f:
-				data |= input_port_read( machine(), "IN5" );
+				data |= ioport( "IN5" )->read();
 				break;
 
 			default:
@@ -1001,10 +1001,10 @@
 	TWINKLE_BIOS
 
 	DISK_REGION( "cdrom0" )	// program
-	DISK_IMAGE_READONLY("863jaa01", 0, SHA1(aee12de1dc5dd44e5bf7b62133ed695b80999390) )
+	DISK_IMAGE_READONLY("863jaa01", 0, BAD_DUMP SHA1(aee12de1dc5dd44e5bf7b62133ed695b80999390) )
 
 	DISK_REGION( "cdrom1" ) // video CD
-	DISK_IMAGE_READONLY("863jaa04", 0, SHA1(8f6a0d2e191153032c9388b5298d8ee531b22a41) )
+	DISK_IMAGE_READONLY("863jaa04", 0, BAD_DUMP SHA1(8f6a0d2e191153032c9388b5298d8ee531b22a41) )
 
 	DISK_REGION( "drive_0" )
 	DISK_IMAGE_READONLY("c44jaa03", 0, SHA1(53e9bd25d1674a04aeec81c0224b4e4e44af802a) )	// was part of a 1st mix machine, but "c44" indicates 8th mix?
@@ -1077,7 +1077,7 @@
 	ROM_LOAD( "896j.pd",      0x000000, 0x000100, BAD_DUMP CRC(1e5caf37) SHA1(75b378662b651cb322e41564d3bae68cc9edadc5) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "896jaabm", 0, SHA1(af008e5bcf18da4e9aea752a712c843e37a74be5) )
+	DISK_IMAGE_READONLY( "896jaabm", 0, BAD_DUMP SHA1(af008e5bcf18da4e9aea752a712c843e37a74be5) )
 //  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
 //  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
 ROM_END
@@ -1089,7 +1089,7 @@
 	ROM_LOAD( "984j.pd",      0x000000, 0x000100, BAD_DUMP CRC(213843e5) SHA1(5571db155a60fa4087dd996af48e8e27fc1c518c) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "984a01bm", 0, SHA1(d9b7d74a72a76e4e9cf7725e0fb8dafcc1c87187) )
+	DISK_IMAGE_READONLY( "984a01bm", 0, BAD_DUMP SHA1(d9b7d74a72a76e4e9cf7725e0fb8dafcc1c87187) )
 //  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
 //  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
 ROM_END
@@ -1101,7 +1101,7 @@
 	ROM_LOAD( "896j.pd",      0x000000, 0x000100, BAD_DUMP CRC(1e5caf37) SHA1(75b378662b651cb322e41564d3bae68cc9edadc5) )
 
 	DISK_REGION( "cdrom0" )
-	DISK_IMAGE_READONLY( "896jabbm", 0, SHA1(117ae4c876207bbaf9e8fe0fdf5bb161155c1bdb) )
+	DISK_IMAGE_READONLY( "896jabbm", 0, BAD_DUMP SHA1(117ae4c876207bbaf9e8fe0fdf5bb161155c1bdb) )
 //  DISK_IMAGE_READONLY( "abmjaahd", 1, NO_DUMP )
 //  DISK_IMAGE_READONLY( "abmjaa02", 2, NO_DUMP )
 ROM_END
diff -Nru src-old/mame/drivers/tx1.c src/mame/drivers/tx1.c
--- src-old/mame/drivers/tx1.c	2012-04-16 00:44:14.000000000 +0200
+++ src/mame/drivers/tx1.c	2012-05-03 11:00:08.000000000 +0200
@@ -381,7 +381,7 @@
 
 READ16_MEMBER(tx1_state::dipswitches_r)
 {
-	return (input_port_read(machine(), "DSW") & 0xfffe) | m_ts;
+	return (ioport("DSW")->read() & 0xfffe) | m_ts;
 }
 
 /*
@@ -417,8 +417,8 @@
 
 WRITE8_MEMBER(tx1_state::tx1_ppi_latch_w)
 {
-	m_ppi_latch_a = ((input_port_read(machine(), "AN_BRAKE") & 0xf) << 4) | (input_port_read(machine(), "AN_ACCELERATOR") & 0xf);
-	m_ppi_latch_b = input_port_read(machine(), "AN_STEERING");
+	m_ppi_latch_a = ((ioport("AN_BRAKE")->read() & 0xf) << 4) | (ioport("AN_ACCELERATOR")->read() & 0xf);
+	m_ppi_latch_b = ioport("AN_STEERING")->read();
 }
 
 static READ8_DEVICE_HANDLER( tx1_ppi_porta_r )
@@ -430,7 +430,7 @@
 static READ8_DEVICE_HANDLER( tx1_ppi_portb_r )
 {
 	tx1_state *state = device->machine().driver_data<tx1_state>();
-	return input_port_read(device->machine(), "PPI_PORTD") | state->m_ppi_latch_b;
+	return state->ioport("PPI_PORTD")->read() | state->m_ppi_latch_b;
 }
 
 
@@ -446,17 +446,17 @@
 READ8_MEMBER(tx1_state::bb_analog_r)
 {
 	if (offset == 0)
-		return bit_reverse8(((input_port_read(machine(), "AN_ACCELERATOR") & 0xf) << 4) | input_port_read(machine(), "AN_STEERING"));
+		return bit_reverse8(((ioport("AN_ACCELERATOR")->read() & 0xf) << 4) | ioport("AN_STEERING")->read());
 	else
-		return bit_reverse8((input_port_read(machine(), "AN_BRAKE") & 0xf) << 4);
+		return bit_reverse8((ioport("AN_BRAKE")->read() & 0xf) << 4);
 }
 
 READ8_MEMBER(tx1_state::bbjr_analog_r)
 {
 	if (offset == 0)
-		return ((input_port_read(machine(), "AN_ACCELERATOR") & 0xf) << 4) | input_port_read(machine(), "AN_STEERING");
+		return ((ioport("AN_ACCELERATOR")->read() & 0xf) << 4) | ioport("AN_STEERING")->read();
 	else
-		return (input_port_read(machine(), "AN_BRAKE") & 0xf) << 4;
+		return (ioport("AN_BRAKE")->read() & 0xf) << 4;
 }
 
 
diff -Nru src-old/mame/drivers/uapce.c src/mame/drivers/uapce.c
--- src-old/mame/drivers/uapce.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/uapce.c	2012-05-03 11:00:08.000000000 +0200
@@ -173,7 +173,7 @@
 {
 	UINT8 dsw_val;
 
-	dsw_val = input_port_read(machine(),  "DSW" );
+	dsw_val = ioport("DSW" )->read();
 
 	if ( BIT( offset, 7 ) == 0 )
 	{
@@ -216,11 +216,11 @@
 	uapce_state *state = machine.driver_data<uapce_state>();
 	if ( state->m_jamma_if_control_latch & 0x10 )
 	{
-		return input_port_read(machine,  "JOY" );
+		return state->ioport("JOY" )->read();
 	}
 	else
 	{
-		return input_port_read(machine,  "JOY" ) | 0x08;
+		return machine.root_device().ioport("JOY" )->read() | 0x08;
 	}
 }
 
diff -Nru src-old/mame/drivers/ultratnk.c src/mame/drivers/ultratnk.c
--- src-old/mame/drivers/ultratnk.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/ultratnk.c	2012-05-03 11:00:08.000000000 +0200
@@ -26,7 +26,7 @@
 
 CUSTOM_INPUT_MEMBER(ultratnk_state::get_joystick)
 {
-	UINT8 joy = input_port_read(machine(), (const char *)param) & 3;
+	UINT8 joy = ioport((const char *)param)->read() & 3;
 
 	if (joy == 1)
 	{
@@ -50,9 +50,9 @@
 
 	/* NMI and watchdog are disabled during service mode */
 
-	machine.watchdog_enable(input_port_read(machine, "IN0") & 0x40);
+	machine.watchdog_enable(machine.root_device().ioport("IN0")->read() & 0x40);
 
-	if (input_port_read(machine, "IN0") & 0x40)
+	if (machine.root_device().ioport("IN0")->read() & 0x40)
 		cputag_set_input_line(machine, "maincpu", INPUT_LINE_NMI, PULSE_LINE);
 
 	machine.scheduler().timer_set(machine.primary_screen->time_until_pos(scanline), FUNC(nmi_callback), scanline);
@@ -74,21 +74,21 @@
 
 READ8_MEMBER(ultratnk_state::ultratnk_analog_r)
 {
-	return (input_port_read(machine(), "ANALOG") << (~offset & 7)) & 0x80;
+	return (ioport("ANALOG")->read() << (~offset & 7)) & 0x80;
 }
 READ8_MEMBER(ultratnk_state::ultratnk_coin_r)
 {
-	return (input_port_read(machine(), "COIN") << (~offset & 7)) & 0x80;
+	return (ioport("COIN")->read() << (~offset & 7)) & 0x80;
 }
 READ8_MEMBER(ultratnk_state::ultratnk_collision_r)
 {
-	return (input_port_read(machine(), "COLLISION") << (~offset & 7)) & 0x80;
+	return (ioport("COLLISION")->read() << (~offset & 7)) & 0x80;
 }
 
 
 READ8_MEMBER(ultratnk_state::ultratnk_options_r)
 {
-	return (input_port_read(machine(), "DIP") >> (2 * (offset & 3))) & 3;
+	return (ioport("DIP")->read() >> (2 * (offset & 3))) & 3;
 }
 
 
@@ -181,7 +181,7 @@
 static INPUT_PORTS_START( ultratnk )
 	PORT_START("IN0")
 	PORT_SERVICE( 0x40, IP_ACTIVE_LOW )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN1")
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_NAME("Option 1") PORT_TOGGLE
diff -Nru src-old/mame/drivers/ultrsprt.c src/mame/drivers/ultrsprt.c
--- src-old/mame/drivers/ultrsprt.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/ultrsprt.c	2012-05-03 11:00:08.000000000 +0200
@@ -78,7 +78,7 @@
 	UINT32 r = 0;
 
 	if (ACCESSING_BITS_24_31)
-		r |= input_port_read(machine(), "SERVICE");
+		r |= ioport("SERVICE")->read();
 
 	return r;
 }
@@ -86,13 +86,13 @@
 WRITE32_MEMBER(ultrsprt_state::eeprom_w)
 {
 	if (ACCESSING_BITS_24_31)
-		input_port_write(machine(), "EEPROMOUT", data, 0xffffffff);
+		ioport("EEPROMOUT")->write(data, 0xffffffff);
 }
 
 CUSTOM_INPUT_MEMBER(ultrsprt_state::analog_ctrl_r)
 {
 	const char *tag = (const char *)param;
-	return input_port_read(machine(), tag) & 0xfff;
+	return ioport(tag)->read() & 0xfff;
 }
 
 WRITE32_MEMBER(ultrsprt_state::int_ack_w)
diff -Nru src-old/mame/drivers/undrfire.c src/mame/drivers/undrfire.c
--- src-old/mame/drivers/undrfire.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/undrfire.c	2012-05-03 11:00:08.000000000 +0200
@@ -262,12 +262,12 @@
 	{
 		case 0x00:
 		{
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 		}
 
 		case 0x01:
 		{
-			return input_port_read(machine(), "SYSTEM") | (m_coin_word << 16);
+			return ioport("SYSTEM")->read() | (m_coin_word << 16);
 		}
 	}
 
@@ -376,8 +376,8 @@
 
 		case 0x00:	/* P1 */
 		{
-			x = input_port_read(machine(), "GUNX1") << 6;
-			y = input_port_read(machine(), "GUNY1") << 6;
+			x = ioport("GUNX1")->read() << 6;
+			y = ioport("GUNY1")->read() << 6;
 
 			return ((x << 24) &0xff000000) | ((x << 8) &0xff0000)
 				 | ((y << 8) &0xff00) | ((y >> 8) &0xff) ;
@@ -385,8 +385,8 @@
 
 		case 0x01:	/* P2 */
 		{
-			x = input_port_read(machine(), "GUNX2") << 6;
-			y = input_port_read(machine(), "GUNY2") << 6;
+			x = ioport("GUNX2")->read() << 6;
+			y = ioport("GUNY2")->read() << 6;
 
 			return ((x << 24) &0xff000000) | ((x << 8) &0xff0000)
 				 | ((y << 8) &0xff00) | ((y >> 8) &0xff) ;
@@ -457,7 +457,7 @@
 
 READ32_MEMBER(undrfire_state::cbombers_adc_r)
 {
-	return (input_port_read(machine(), "STEER") << 24);
+	return (ioport("STEER")->read() << 24);
 }
 
 WRITE32_MEMBER(undrfire_state::cbombers_adc_w)
diff -Nru src-old/mame/drivers/unico.c src/mame/drivers/unico.c
--- src-old/mame/drivers/unico.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/unico.c	2012-05-03 11:00:08.000000000 +0200
@@ -104,7 +104,7 @@
 /* Light Gun - need to wiggle the input slightly otherwise fire doesn't work */
 READ16_MEMBER(unico_state::unico_gunx_0_msb_r)
 {
-	int x=input_port_read(machine(), "X0");
+	int x=ioport("X0")->read();
 
 	x=x*384/256; /* On screen pixel X */
 	if (x<0x160) x=0x30 + (x*0xd0/0x15f);
@@ -115,7 +115,7 @@
 
 READ16_MEMBER(unico_state::unico_guny_0_msb_r)
 {
-	int y=input_port_read(machine(), "Y0");
+	int y=ioport("Y0")->read();
 
 	y=0x18+((y*0xe0)/0xff);
 
@@ -124,7 +124,7 @@
 
 READ16_MEMBER(unico_state::unico_gunx_1_msb_r)
 {
-	int x=input_port_read(machine(), "X1");
+	int x=ioport("X1")->read();
 
 	x=x*384/256; /* On screen pixel X */
 	if (x<0x160) x=0x30 + (x*0xd0/0x15f);
@@ -135,7 +135,7 @@
 
 READ16_MEMBER(unico_state::unico_guny_1_msb_r)
 {
-	int y=input_port_read(machine(), "Y1");
+	int y=ioport("Y1")->read();
 
 	y=0x18+((y*0xe0)/0xff);
 
diff -Nru src-old/mame/drivers/unkhorse.c src/mame/drivers/unkhorse.c
--- src-old/mame/drivers/unkhorse.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/unkhorse.c	2012-05-03 11:00:08.000000000 +0200
@@ -95,9 +95,9 @@
 
 	switch (state->m_output >> 6 & 3)
 	{
-		case 0: return input_port_read(device->machine(), "IN0");
-		case 1: return input_port_read(device->machine(), "IN1");
-		case 2: return input_port_read(device->machine(), "IN2");
+		case 0: return state->ioport("IN0")->read();
+		case 1: return state->ioport("IN1")->read();
+		case 2: return state->ioport("IN2")->read();
 		default: break;
 	}
 
diff -Nru src-old/mame/drivers/upscope.c src/mame/drivers/upscope.c
--- src-old/mame/drivers/upscope.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/upscope.c	2012-05-03 11:00:08.000000000 +0200
@@ -218,7 +218,7 @@
 		if (data & 4)
 		{
 			if (LOG_IO) logerror("Internal register (%d) read\n", state->m_nvram_address_latch);
-			state->m_nvram_data_latch = (state->m_nvram_address_latch == 0) ? input_port_read(device->machine(), "IO0") : 0xff;
+			state->m_nvram_data_latch = (state->m_nvram_address_latch == 0) ? device->machine().root_device().ioport("IO0")->read() : 0xff;
 		}
 
 		/* if SEL == 0, we read NVRAM */
diff -Nru src-old/mame/drivers/usgames.c src/mame/drivers/usgames.c
--- src-old/mame/drivers/usgames.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/usgames.c	2012-05-03 11:00:08.000000000 +0200
@@ -131,7 +131,7 @@
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_SPECIAL ) // +12 Volts?
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("UNK1")
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
diff -Nru src-old/mame/drivers/vamphalf.c src/mame/drivers/vamphalf.c
--- src-old/mame/drivers/vamphalf.c	2012-04-16 10:28:56.000000000 +0200
+++ src/mame/drivers/vamphalf.c	2012-05-03 11:00:08.000000000 +0200
@@ -649,7 +649,7 @@
 CUSTOM_INPUT_MEMBER(vamphalf_state::boonggab_photo_sensors_r)
 {
 	static const UINT16 photo_sensors_table[8] = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 };
-	UINT8 res = input_port_read(machine(), "PHOTO_SENSORS");
+	UINT8 res = ioport("PHOTO_SENSORS")->read();
 
 	switch(res)
 	{
diff -Nru src-old/mame/drivers/vaportra.c src/mame/drivers/vaportra.c
--- src-old/mame/drivers/vaportra.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/vaportra.c	2012-05-03 11:00:08.000000000 +0200
@@ -34,11 +34,11 @@
 	switch (offset << 1)
 	{
 		case 4:
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 		case 2:
-			return input_port_read(machine(), "COINS");
+			return ioport("COINS")->read();
 		case 0:
-			return input_port_read(machine(), "PLAYERS");
+			return ioport("PLAYERS")->read();
 	}
 
 	logerror("Unknown control read at %d\n",offset);
@@ -112,7 +112,7 @@
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x0008, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/vball.c src/mame/drivers/vball.c
--- src-old/mame/drivers/vball.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/vball.c	2012-05-03 11:00:08.000000000 +0200
@@ -258,7 +258,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/vcombat.c src/mame/drivers/vcombat.c
--- src-old/mame/drivers/vcombat.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/vcombat.c	2012-05-03 11:00:08.000000000 +0200
@@ -199,17 +199,17 @@
 
 READ16_MEMBER(vcombat_state::control_1_r)
 {
-	return (input_port_read(machine(), "IN0") << 8);
+	return (ioport("IN0")->read() << 8);
 }
 
 READ16_MEMBER(vcombat_state::control_2_r)
 {
-	return (input_port_read(machine(), "IN1") << 8);
+	return (ioport("IN1")->read() << 8);
 }
 
 READ16_MEMBER(vcombat_state::control_3_r)
 {
-	return (input_port_read(machine(), "IN2") << 8);
+	return (ioport("IN2")->read() << 8);
 }
 
 static void wiggle_i860_common(device_t *device, UINT16 data)
diff -Nru src-old/mame/drivers/vectrex.c src/mame/drivers/vectrex.c
--- src-old/mame/drivers/vectrex.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/vectrex.c	2012-05-03 20:17:43.000000000 +0200
@@ -20,7 +20,7 @@
 
 
 static ADDRESS_MAP_START(vectrex_map, AS_PROGRAM, 8, vectrex_state )
-	AM_RANGE(0x0000, 0x7fff) AM_ROM
+	AM_RANGE(0x0000, 0x7fff) AM_RAMBANK("bank1") AM_REGION("maincpu", 0)
 	AM_RANGE(0xc800, 0xcbff) AM_RAM AM_MIRROR(0x0400) AM_SHARE("gce_vectorram")
 	AM_RANGE(0xd000, 0xd7ff) AM_READWRITE(vectrex_via_r, vectrex_via_w)
 	AM_RANGE(0xe000, 0xffff) AM_ROM
@@ -133,7 +133,7 @@
 MACHINE_CONFIG_END
 
 ROM_START(vectrex)
-	ROM_REGION(0x10000,"maincpu", 0)
+	ROM_REGION(0x18000,"maincpu", 0)
 	ROM_LOAD("system.img", 0xe000, 0x2000, CRC(ba13fb57) SHA1(65d07426b520ddd3115d40f255511e0fd2e20ae7))
 ROM_END
 
diff -Nru src-old/mame/drivers/vegaeo.c src/mame/drivers/vegaeo.c
--- src-old/mame/drivers/vegaeo.c	2012-04-09 15:23:05.000000000 +0200
+++ src/mame/drivers/vegaeo.c	2012-05-03 11:00:08.000000000 +0200
@@ -93,7 +93,7 @@
 READ32_MEMBER(vegaeo_state::vegaeo_custom_read)
 {
 	eolith_speedup_read(&space);
-	return input_port_read(machine(), "SYSTEM");
+	return ioport("SYSTEM")->read();
 }
 
 static ADDRESS_MAP_START( vega_map, AS_PROGRAM, 32, vegaeo_state )
diff -Nru src-old/mame/drivers/vegas.c src/mame/drivers/vegas.c
--- src-old/mame/drivers/vegas.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/vegas.c	2012-05-03 11:00:08.000000000 +0200
@@ -1428,7 +1428,7 @@
 
 	if (data < 8 || data > 15)
 		logerror("%08X:Unexpected analog port select = %08X\n", cpu_get_pc(&space->device()), data);
-	state->m_pending_analog_read = input_port_read_safe(space->machine(), portnames[data & 7], 0);
+	state->m_pending_analog_read = state->ioport(portnames[data & 7])->read_safe(0);
 }
 
 
diff -Nru src-old/mame/drivers/vendetta.c src/mame/drivers/vendetta.c
--- src-old/mame/drivers/vendetta.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/vendetta.c	2012-05-03 11:00:08.000000000 +0200
@@ -134,7 +134,7 @@
 		return;
 
 	/* EEPROM */
-	input_port_write(machine(), "EEPROMOUT", data, 0xff);
+	ioport("EEPROMOUT")->write(data, 0xff);
 
 	m_irq_enabled = (data >> 6) & 1;
 
@@ -322,7 +322,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* EEPROM ready */
 	PORT_SERVICE_NO_TOGGLE(0x04, IP_ACTIVE_LOW)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK ) /* not really vblank, object related. Its timed, otherwise sprites flicker */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") /* not really vblank, object related. Its timed, otherwise sprites flicker */
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START( "EEPROMOUT" )
@@ -378,7 +378,7 @@
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_UNKNOWN ) PORT_READ_LINE_DEVICE_MEMBER("eeprom", eeprom_device, read_bit)
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* EEPROM ready */
 	PORT_SERVICE_NO_TOGGLE(0x04, IP_ACTIVE_LOW)
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK ) /* not really vblank, object related. Its timed, otherwise sprites flicker */
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen") /* not really vblank, object related. Its timed, otherwise sprites flicker */
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START( "EEPROMOUT" )
diff -Nru src-old/mame/drivers/vicdual.c src/mame/drivers/vicdual.c
--- src-old/mame/drivers/vicdual.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/vicdual.c	2012-05-03 11:00:08.000000000 +0200
@@ -170,7 +170,7 @@
 
 int vicdual_is_cabinet_color(running_machine &machine)
 {
-	return (input_port_read(machine, COLOR_BW_PORT_TAG) == 0);
+	return (machine.root_device().ioport(COLOR_BW_PORT_TAG)->read() == 0);
 }
 
 
@@ -233,8 +233,8 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN1");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x08)  ret = ioport("IN1")->read();
 
 	return ret;
 }
@@ -315,8 +315,8 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN1");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x08)  ret = ioport("IN1")->read();
 
 	return ret;
 }
@@ -399,8 +399,8 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN1");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x08)  ret = ioport("IN1")->read();
 
 	return ret;
 }
@@ -507,8 +507,8 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN1");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x08)  ret = ioport("IN1")->read();
 
 	return ret;
 }
@@ -518,9 +518,9 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x04)  ret = input_port_read(machine(), "IN1");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN2");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x04)  ret = ioport("IN1")->read();
+	if (offset & 0x08)  ret = ioport("IN2")->read();
 
 	return ret;
 }
@@ -717,10 +717,10 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
 	if (offset & 0x02)  /* schematics show this as in input port, but never read from */
-	if (offset & 0x04)  ret = input_port_read(machine(), "IN1");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN2");
+	if (offset & 0x04)  ret = ioport("IN1")->read();
+	if (offset & 0x08)  ret = ioport("IN2")->read();
 	if (offset & 0x12)  logerror("********* Read from port %x\n", offset);
 
 	return ret;
@@ -1628,7 +1628,7 @@
 CUSTOM_INPUT_MEMBER(vicdual_state::brdrline_lives)
 {
 	int bit_mask = (FPTR)param;
-	return (input_port_read(machine(), "FAKE_LIVES") & bit_mask) ? 0x00 : 0x01;
+	return (ioport("FAKE_LIVES")->read() & bit_mask) ? 0x00 : 0x01;
 }
 
 static INPUT_PORTS_START( brdrline )
@@ -2167,8 +2167,8 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN1");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x08)  ret = ioport("IN1")->read();
 
 	return ret;
 }
@@ -2262,9 +2262,9 @@
 {
 	UINT8 ret = 0;
 
-	if (offset & 0x01)  ret = input_port_read(machine(), "IN0");
-	if (offset & 0x02)  ret = input_port_read(machine(), "IN1");
-	if (offset & 0x08)  ret = input_port_read(machine(), "IN2");
+	if (offset & 0x01)  ret = ioport("IN0")->read();
+	if (offset & 0x02)  ret = ioport("IN1")->read();
+	if (offset & 0x08)  ret = ioport("IN2")->read();
 
 	return ret;
 }
diff -Nru src-old/mame/drivers/videopin.c src/mame/drivers/videopin.c
--- src-old/mame/drivers/videopin.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/videopin.c	2012-05-03 11:00:08.000000000 +0200
@@ -25,7 +25,7 @@
 static void update_plunger(running_machine &machine)
 {
 	videopin_state *state = machine.driver_data<videopin_state>();
-	UINT8 val = input_port_read(machine, "IN2");
+	UINT8 val = state->ioport("IN2")->read();
 
 	if (state->m_prev != val)
 	{
@@ -94,7 +94,7 @@
 	// signals received. This results in the MPU displaying the
 	// ball being shot onto the playfield at a certain speed.
 
-	UINT8 val = input_port_read(machine(), "IN1");
+	UINT8 val = ioport("IN1")->read();
 
 	if (plunger >= 0.000 && plunger <= 0.001)
 	{
@@ -258,7 +258,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Nudge") PORT_CODE(KEYCODE_SPACE)
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("IN2")
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_BUTTON4 ) PORT_NAME("Ball Shooter") PORT_CODE(KEYCODE_DOWN)
diff -Nru src-old/mame/drivers/videopkr.c src/mame/drivers/videopkr.c
--- src-old/mame/drivers/videopkr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/videopkr.c	2012-05-03 11:00:08.000000000 +0200
@@ -493,7 +493,7 @@
 {
 	videopkr_state *state = machine.driver_data<videopkr_state>();
 	int offs = tile_index;
-	int attr = state->m_color_ram[offs] + input_port_read(machine, "IN2"); /* Color Switch Action */
+	int attr = state->m_color_ram[offs] + state->ioport("IN2")->read(); /* Color Switch Action */
 	int code = state->m_video_ram[offs];
 	int color = attr;
 	SET_TILE_INFO(0, code, color, 0);
@@ -536,9 +536,9 @@
 	{
 		case 0xef:	/* inputs are multiplexed through a diode matrix */
 		{
-			hf = ((input_port_read(machine(), "IN1") & 0x10 ) >> 4) & 1;			/* Hopper full detection */
-			co = 0x10 * ((input_port_read(machine(), "IN1") & 0x20 ) >> 5);		/* Coin Out detection */
-			kbdin = ((input_port_read(machine(), "IN1") & 0xaf ) << 8) + input_port_read(machine(), "IN0");
+			hf = ((ioport("IN1")->read() & 0x10 ) >> 4) & 1;			/* Hopper full detection */
+			co = 0x10 * ((ioport("IN1")->read() & 0x20 ) >> 5);		/* Coin Out detection */
+			kbdin = ((ioport("IN1")->read() & 0xaf ) << 8) + ioport("IN0")->read();
 
 			switch (kbdin)
 			{
diff -Nru src-old/mame/drivers/vindictr.c src/mame/drivers/vindictr.c
--- src-old/mame/drivers/vindictr.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/vindictr.c	2012-05-03 11:00:08.000000000 +0200
@@ -65,7 +65,7 @@
 
 READ16_MEMBER(vindictr_state::port1_r)
 {
-	int result = input_port_read(machine(), "260010");
+	int result = ioport("260010")->read();
 	if (m_sound_to_cpu_ready) result ^= 0x0004;
 	if (m_cpu_to_sound_ready) result ^= 0x0008;
 	result ^= 0x0010;
@@ -124,7 +124,7 @@
 	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN ) PORT_2WAY PORT_PLAYER(1)
 
 	PORT_START("260010")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_SERVICE( 0x0002, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_UNUSED )
diff -Nru src-old/mame/drivers/viper.c src/mame/drivers/viper.c
--- src-old/mame/drivers/viper.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/viper.c	2012-05-03 11:00:08.000000000 +0200
@@ -1604,12 +1604,12 @@
 	}
 	if (ACCESSING_BITS_32_39)
 	{
-		UINT64 reg = input_port_read(machine(), "IN0");
+		UINT64 reg = ioport("IN0")->read();
 		r |= reg << 32;
 	}
 	if (ACCESSING_BITS_24_31)
 	{
-		UINT64 reg = input_port_read(machine(), "IN1");
+		UINT64 reg = ioport("IN1")->read();
 		r |= reg << 24;
 	}
 	if (ACCESSING_BITS_16_23)
diff -Nru src-old/mame/drivers/vmetal.c src/mame/drivers/vmetal.c
--- src-old/mame/drivers/vmetal.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/vmetal.c	2012-05-03 11:00:08.000000000 +0200
@@ -164,14 +164,14 @@
 }
 
 
-READ16_MEMBER(vmetal_state::varia_dips_bit8_r){ return ((input_port_read(machine(), "DSW2") & 0x80) << 0) | ((input_port_read(machine(), "DSW1") & 0x80) >> 1); }
-READ16_MEMBER(vmetal_state::varia_dips_bit7_r){ return ((input_port_read(machine(), "DSW2") & 0x40) << 1) | ((input_port_read(machine(), "DSW1") & 0x40) >> 0); }
-READ16_MEMBER(vmetal_state::varia_dips_bit6_r){ return ((input_port_read(machine(), "DSW2") & 0x20) << 2) | ((input_port_read(machine(), "DSW1") & 0x20) << 1); }
-READ16_MEMBER(vmetal_state::varia_dips_bit5_r){ return ((input_port_read(machine(), "DSW2") & 0x10) << 3) | ((input_port_read(machine(), "DSW1") & 0x10) << 2); }
-READ16_MEMBER(vmetal_state::varia_dips_bit4_r){ return ((input_port_read(machine(), "DSW2") & 0x08) << 4) | ((input_port_read(machine(), "DSW1") & 0x08) << 3); }
-READ16_MEMBER(vmetal_state::varia_dips_bit3_r){ return ((input_port_read(machine(), "DSW2") & 0x04) << 5) | ((input_port_read(machine(), "DSW1") & 0x04) << 4); }
-READ16_MEMBER(vmetal_state::varia_dips_bit2_r){ return ((input_port_read(machine(), "DSW2") & 0x02) << 6) | ((input_port_read(machine(), "DSW1") & 0x02) << 5); }
-READ16_MEMBER(vmetal_state::varia_dips_bit1_r){ return ((input_port_read(machine(), "DSW2") & 0x01) << 7) | ((input_port_read(machine(), "DSW1") & 0x01) << 6); }
+READ16_MEMBER(vmetal_state::varia_dips_bit8_r){ return ((ioport("DSW2")->read() & 0x80) << 0) | ((ioport("DSW1")->read() & 0x80) >> 1); }
+READ16_MEMBER(vmetal_state::varia_dips_bit7_r){ return ((ioport("DSW2")->read() & 0x40) << 1) | ((ioport("DSW1")->read() & 0x40) >> 0); }
+READ16_MEMBER(vmetal_state::varia_dips_bit6_r){ return ((ioport("DSW2")->read() & 0x20) << 2) | ((ioport("DSW1")->read() & 0x20) << 1); }
+READ16_MEMBER(vmetal_state::varia_dips_bit5_r){ return ((ioport("DSW2")->read() & 0x10) << 3) | ((ioport("DSW1")->read() & 0x10) << 2); }
+READ16_MEMBER(vmetal_state::varia_dips_bit4_r){ return ((ioport("DSW2")->read() & 0x08) << 4) | ((ioport("DSW1")->read() & 0x08) << 3); }
+READ16_MEMBER(vmetal_state::varia_dips_bit3_r){ return ((ioport("DSW2")->read() & 0x04) << 5) | ((ioport("DSW1")->read() & 0x04) << 4); }
+READ16_MEMBER(vmetal_state::varia_dips_bit2_r){ return ((ioport("DSW2")->read() & 0x02) << 6) | ((ioport("DSW1")->read() & 0x02) << 5); }
+READ16_MEMBER(vmetal_state::varia_dips_bit1_r){ return ((ioport("DSW2")->read() & 0x01) << 7) | ((ioport("DSW1")->read() & 0x01) << 6); }
 
 static WRITE8_DEVICE_HANDLER( vmetal_control_w )
 {
@@ -423,7 +423,7 @@
 static void expand_gfx1(running_machine &machine)
 {
 	metro_state *state = machine.driver_data<metro_state>();
-	UINT8 *base_gfx = machine.root_device().memregion("gfx1")->base();
+	UINT8 *base_gfx = state->memregion("gfx1")->base();
 	UINT32 length = 2 * state->memregion("gfx1")->bytes();
 	state->m_expanded_gfx1 = auto_alloc_array(machine, UINT8, length);
 	for (int i = 0; i < length; i += 2)
diff -Nru src-old/mame/drivers/voyager.c src/mame/drivers/voyager.c
--- src-old/mame/drivers/voyager.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/drivers/voyager.c	2012-05-03 11:00:08.000000000 +0200
@@ -532,7 +532,7 @@
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNKNOWN ) // returns back to MS-DOS (likely to be unmapped and actually used as a lame protection check)
 	PORT_BIT( 0xff00, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_START("IOCARD3")
-	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0xdfff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IOCARD4")
diff -Nru src-old/mame/drivers/vpoker.c src/mame/drivers/vpoker.c
--- src-old/mame/drivers/vpoker.c	2012-04-03 09:01:48.000000000 +0200
+++ src/mame/drivers/vpoker.c	2012-05-03 11:00:08.000000000 +0200
@@ -158,7 +158,7 @@
 READ8_MEMBER(vpoker_state::blitter_r)
 {
 	if(offset == 6)
-		return input_port_read(machine(), "IN0");
+		return ioport("IN0")->read();
 
 	return 0;
 }
diff -Nru src-old/mame/drivers/wardner.c src/mame/drivers/wardner.c
--- src-old/mame/drivers/wardner.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/wardner.c	2012-05-03 11:00:08.000000000 +0200
@@ -291,7 +291,7 @@
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START2 )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )            /* "V-BLANKING" in "test mode" */
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")            /* "V-BLANKING" in "test mode" */
 
 	PORT_START("DSWA")
 	TOAPLAN_MACHINE_COCKTAIL_LOC(SW1)
diff -Nru src-old/mame/drivers/warpsped.c src/mame/drivers/warpsped.c
--- src-old/mame/drivers/warpsped.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/warpsped.c	2012-05-03 11:00:08.000000000 +0200
@@ -243,7 +243,7 @@
 	PORT_START("IN2")
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x7e, IP_ACTIVE_HIGH, IPT_UNUSED )
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("DSW")
 	PORT_DIPNAME( 0x07, 0x00, "Coin/Time" )
diff -Nru src-old/mame/drivers/warpwarp.c src/mame/drivers/warpwarp.c
--- src-old/mame/drivers/warpwarp.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/warpwarp.c	2012-05-03 11:00:08.000000000 +0200
@@ -155,10 +155,10 @@
 	static const char *const portnames[] = { "SW0", "SW1", "DSW2", "PLACEHOLDER" };	// "IN1" & "IN2" are read separately when offset==3
 
 	offset &= 3;
-	res = input_port_read_safe(machine(), portnames[offset], 0);
+	res = ioport(portnames[offset])->read_safe(0);
 	if (offset == 3)
 	{
-		res = input_port_read(machine(), (flip_screen() & 1) ? "IN2" : "IN1");	// read player 2 input in cocktail mode
+		res = ioport((flip_screen() & 1) ? "IN2" : "IN1")->read();	// read player 2 input in cocktail mode
 		if (m_handle_joystick)
 		{
 			/* map digital two-way joystick to two fixed VOLIN values */
@@ -231,13 +231,13 @@
 /* Read Switch Inputs */
 READ8_MEMBER(warpwarp_state::warpwarp_sw_r)
 {
-	return (input_port_read(machine(), "IN0") >> (offset & 7)) & 1;
+	return (ioport("IN0")->read() >> (offset & 7)) & 1;
 }
 
 /* Read Dipswitches */
 static READ8_DEVICE_HANDLER( warpwarp_dsw1_r )
 {
-	return (input_port_read(device->machine(), "DSW1") >> (offset & 7)) & 1;
+	return (device->machine().root_device().ioport("DSW1")->read() >> (offset & 7)) & 1;
 }
 
 /* Read mux Controller Inputs */
@@ -246,7 +246,7 @@
 	warpwarp_state *state = device->machine().driver_data<warpwarp_state>();
 	int res;
 
-	res = input_port_read(device->machine(), (state->flip_screen() & 1) ? "VOLIN2" : "VOLIN1");
+	res = state->ioport((state->flip_screen() & 1) ? "VOLIN2" : "VOLIN1")->read();
 	if (state->m_handle_joystick)
 	{
 		if (res & 1) return 0x0f;
@@ -379,14 +379,14 @@
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Free_Play ) )
 	PORT_DIPNAME( 0x30, 0x10, "Replay" )		PORT_DIPLOCATION("DSW2:5,6")	// awards 1 credit
-	PORT_DIPSETTING(    0x10, "40k 80k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, "70k 140k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, "100k 200k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, "60k 120k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x20, "100k 200k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x30, "150k 300k" )		PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
+	PORT_DIPSETTING(    0x10, "40k 80k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, "70k 140k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, "100k 200k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, "60k 120k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x20, "100k 200k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x30, "150k 300k" )		PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
 	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN1")
@@ -401,14 +401,14 @@
 
 	PORT_MODIFY("DSW2")
 	PORT_DIPNAME( 0x30, 0x10, "Replay" )		// awards 1 credit
-	PORT_DIPSETTING(    0x10, "40k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x20, "70k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x30, "100k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x10, "60k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x20, "100k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x30, "150k" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
+	PORT_DIPSETTING(    0x10, "40k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x20, "70k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x30, "100k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x10, "60k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x20, "100k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x30, "150k" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( navarone )
@@ -432,14 +432,14 @@
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x02, "3" )
 	PORT_DIPNAME( 0x0c, 0x04, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("DSW2:3,4")
-	PORT_DIPSETTING(    0x04, "5000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x08, "6000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x0c, "7000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x00)
-	PORT_DIPSETTING(    0x04, "6000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x08, "7000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x0c, "8000" )			PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
-	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, PORTCOND_EQUALS, 0x02)
+	PORT_DIPSETTING(    0x04, "5000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x08, "6000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x0c, "7000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x00)
+	PORT_DIPSETTING(    0x04, "6000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x08, "7000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x0c, "8000" )			PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
+	PORT_DIPSETTING(    0x00, DEF_STR( None ) )	PORT_CONDITION("DSW2", 0x02, EQUALS, 0x02)
 	PORT_DIPNAME( 0x30, 0x10, DEF_STR( Coinage ) )		PORT_DIPLOCATION("DSW2:5,6")
 	PORT_DIPSETTING(    0x30, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( 1C_1C ) )
@@ -661,14 +661,14 @@
 	PORT_DIPSETTING(    0x08, "4" )
 	PORT_DIPSETTING(    0x0c, "5" )
 	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("DSW1:5,6")
-	PORT_DIPSETTING(    0x00, "8k 30k 30k+" )	PORT_CONDITION("DSW1", 0x0c, PORTCOND_NOTEQUALS, 0x0c)
-	PORT_DIPSETTING(    0x10, "10k 40k 40k+" )	PORT_CONDITION("DSW1", 0x0c, PORTCOND_NOTEQUALS, 0x0c)
-	PORT_DIPSETTING(    0x20, "15k 60k 60k+" )	PORT_CONDITION("DSW1", 0x0c, PORTCOND_NOTEQUALS, 0x0c)
-	PORT_DIPSETTING(0x30, DEF_STR( None ) )	PORT_CONDITION("DSW1", 0x0c, PORTCOND_NOTEQUALS, 0x0c)
-	PORT_DIPSETTING(    0x00, "30k" )			PORT_CONDITION("DSW1", 0x0c, PORTCOND_EQUALS, 0x0c)
-	PORT_DIPSETTING(    0x10, "40k" )			PORT_CONDITION("DSW1", 0x0c, PORTCOND_EQUALS, 0x0c)
-	PORT_DIPSETTING(    0x20, "60k" )			PORT_CONDITION("DSW1", 0x0c, PORTCOND_EQUALS, 0x0c)
-	PORT_DIPSETTING(    0x30, DEF_STR( None ) )	PORT_CONDITION("DSW1", 0x0c, PORTCOND_EQUALS, 0x0c)
+	PORT_DIPSETTING(    0x00, "8k 30k 30k+" )	PORT_CONDITION("DSW1", 0x0c, NOTEQUALS, 0x0c)
+	PORT_DIPSETTING(    0x10, "10k 40k 40k+" )	PORT_CONDITION("DSW1", 0x0c, NOTEQUALS, 0x0c)
+	PORT_DIPSETTING(    0x20, "15k 60k 60k+" )	PORT_CONDITION("DSW1", 0x0c, NOTEQUALS, 0x0c)
+	PORT_DIPSETTING(0x30, DEF_STR( None ) )	PORT_CONDITION("DSW1", 0x0c, NOTEQUALS, 0x0c)
+	PORT_DIPSETTING(    0x00, "30k" )			PORT_CONDITION("DSW1", 0x0c, EQUALS, 0x0c)
+	PORT_DIPSETTING(    0x10, "40k" )			PORT_CONDITION("DSW1", 0x0c, EQUALS, 0x0c)
+	PORT_DIPSETTING(    0x20, "60k" )			PORT_CONDITION("DSW1", 0x0c, EQUALS, 0x0c)
+	PORT_DIPSETTING(    0x30, DEF_STR( None ) )	PORT_CONDITION("DSW1", 0x0c, EQUALS, 0x0c)
 	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Demo_Sounds ) )	PORT_DIPLOCATION("DSW1:7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
diff -Nru src-old/mame/drivers/wecleman.c src/mame/drivers/wecleman.c
--- src-old/mame/drivers/wecleman.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/wecleman.c	2012-05-03 11:00:08.000000000 +0200
@@ -371,9 +371,9 @@
 {
 	switch ( (m_selected_ip >> 5) & 3 )
 	{																	// From WEC Le Mans Schems:
-		case 0:  return input_port_read(machine(), "ACCEL");		// Accel - Schems: Accelevr
+		case 0:  return ioport("ACCEL")->read();		// Accel - Schems: Accelevr
 		case 1:  return ~0;												// ????? - Schems: Not Used
-		case 2:  return input_port_read(machine(), "STEER");		// Wheel - Schems: Handlevr
+		case 2:  return ioport("STEER")->read();		// Wheel - Schems: Handlevr
 		case 3:  return ~0;												// Table - Schems: Turnvr
 
 		default: return ~0;
@@ -1251,7 +1251,7 @@
 	wecleman_state *state = machine.driver_data<wecleman_state>();
 	int i, len;
 	UINT8 *RAM;
-//  UINT16 *RAM1 = (UINT16 *) machine.root_device().memregion("maincpu")->base();   /* Main CPU patches */
+//  UINT16 *RAM1 = (UINT16 *) state->memregion("maincpu")->base();   /* Main CPU patches */
 //  RAM1[0x08c2/2] = 0x601e;    // faster self test
 
 	/* Decode GFX Roms - Compensate for the address lines scrambling */
@@ -1261,7 +1261,7 @@
         I hope you'll appreciate this effort!  */
 
 	/* let's swap even and odd *pixels* of the sprites */
-	RAM = machine.root_device().memregion("gfx1")->base();
+	RAM = state->memregion("gfx1")->base();
 	len = state->memregion("gfx1")->bytes();
 	for (i = 0; i < len; i ++)
 	{
@@ -1393,7 +1393,7 @@
 static DRIVER_INIT( hotchase )
 {
 	wecleman_state *state = machine.driver_data<wecleman_state>();
-//  UINT16 *RAM1 = (UINT16) machine.root_device().memregion("maincpu")->base(); /* Main CPU patches */
+//  UINT16 *RAM1 = (UINT16) state->memregion("maincpu")->base(); /* Main CPU patches */
 //  RAM[0x1140/2] = 0x0015; RAM[0x195c/2] = 0x601A; // faster self test
 
 	UINT8 *RAM;
@@ -1401,7 +1401,7 @@
 	/* Decode GFX Roms */
 
 	/* Let's swap even and odd bytes of the sprites gfx roms */
-	RAM = machine.root_device().memregion("gfx1")->base();
+	RAM = state->memregion("gfx1")->base();
 
 	/* Now we can unpack each nibble of the sprites into a pixel (one byte) */
 	hotchase_sprite_decode(machine,3,0x80000*2);	// num banks, bank len
diff -Nru src-old/mame/drivers/wgp.c src/mame/drivers/wgp.c
--- src-old/mame/drivers/wgp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/wgp.c	2012-05-03 11:00:08.000000000 +0200
@@ -533,12 +533,12 @@
 READ16_MEMBER(wgp_state::wgp_adinput_r)
 {
 	int steer = 0x40;
-	int fake = input_port_read_safe(machine(), FAKE_PORT_TAG, 0x00);
+	int fake = ioport(FAKE_PORT_TAG)->read_safe(0x00);
 
 	if (!(fake & 0x10))	/* Analogue steer (the real control method) */
 	{
 		/* Reduce span to 0x80 */
-		steer = (input_port_read_safe(machine(), STEER_PORT_TAG, 0x00) * 0x80) / 0x100;
+		steer = (ioport(STEER_PORT_TAG)->read_safe(0x00) * 0x80) / 0x100;
 	}
 	else	/* Digital steer */
 	{
@@ -583,7 +583,7 @@
 		}
 
 		case 0x05:
-			return input_port_read_safe(machine(), UNKNOWN_PORT_TAG, 0x00);	/* unknown */
+			return ioport(UNKNOWN_PORT_TAG)->read_safe(0x00);	/* unknown */
 	}
 
 logerror("CPU #0 PC %06x: warning - read unmapped a/d input offset %06x\n",cpu_get_pc(&space.device()),offset);
diff -Nru src-old/mame/drivers/williams.c src/mame/drivers/williams.c
--- src-old/mame/drivers/williams.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/williams.c	2012-05-05 16:57:34.000000000 +0200
@@ -783,10 +783,10 @@
 	PORT_DIPSETTING(    0x00, "2" )
 	PORT_DIPSETTING(    0x01, "3")
 	PORT_DIPNAME( 0x02, 0x00, "Bonus At" )
-	PORT_DIPSETTING(    0x00, "20k/40k" )		PORT_CONDITION("IN2",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x02, "30k/50k" )		PORT_CONDITION("IN2",0x01,PORTCOND_NOTEQUALS,0x01)
-	PORT_DIPSETTING(    0x00, "30k/50k" )		PORT_CONDITION("IN2",0x01,PORTCOND_EQUALS,0x01)
-	PORT_DIPSETTING(    0x02, "40k/70k" )		PORT_CONDITION("IN2",0x01,PORTCOND_EQUALS,0x01)
+	PORT_DIPSETTING(    0x00, "20k/40k" )		PORT_CONDITION("IN2",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x02, "30k/50k" )		PORT_CONDITION("IN2",0x01,NOTEQUALS,0x01)
+	PORT_DIPSETTING(    0x00, "30k/50k" )		PORT_CONDITION("IN2",0x01,EQUALS,0x01)
+	PORT_DIPSETTING(    0x02, "40k/70k" )		PORT_CONDITION("IN2",0x01,EQUALS,0x01)
 	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Unknown ))		/* documented as unused */
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ))
 	PORT_DIPSETTING(    0x00, DEF_STR( On ))
@@ -1693,7 +1693,7 @@
 static MACHINE_CONFIG_DERIVED( joust2, williams2 )
 
 	/* basic machine hardware */
-	MCFG_WILLIAMS_CVSD_SOUND_ADD("cvsd")
+	MCFG_WILLIAMS_CVSD_SOUND_ADD("cvsd_sound")
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 	MCFG_MACHINE_START(joust2)
diff -Nru src-old/mame/drivers/wink.c src/mame/drivers/wink.c
--- src-old/mame/drivers/wink.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/wink.c	2012-05-03 11:00:08.000000000 +0200
@@ -95,12 +95,12 @@
 
 READ8_MEMBER(wink_state::analog_port_r)
 {
-	return input_port_read(machine(), /* player_mux ? "DIAL2" : */ "DIAL1");
+	return ioport(/* player_mux ? "DIAL2" : */ "DIAL1")->read();
 }
 
 READ8_MEMBER(wink_state::player_inputs_r)
 {
-	return input_port_read(machine(), /* player_mux ? "INPUTS2" : */ "INPUTS1");
+	return ioport(/* player_mux ? "INPUTS2" : */ "INPUTS1")->read();
 }
 
 WRITE8_MEMBER(wink_state::sound_irq_w)
diff -Nru src-old/mame/drivers/wiping.c src/mame/drivers/wiping.c
--- src-old/mame/drivers/wiping.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/wiping.c	2012-05-03 11:00:08.000000000 +0200
@@ -47,7 +47,7 @@
 
 	res = 0;
 	for (i = 0; i < 8; i++)
-		res |= ((input_port_read(machine(), portnames[i]) >> offset) & 1) << i;
+		res |= ((ioport(portnames[i])->read() >> offset) & 1) << i;
 
 	return res;
 }
diff -Nru src-old/mame/drivers/witch.c src/mame/drivers/witch.c
--- src-old/mame/drivers/witch.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/witch.c	2012-05-03 11:00:08.000000000 +0200
@@ -345,10 +345,10 @@
 	switch(offset)
 	{
 		case 0x02: return m_reg_a002;
-		case 0x04: return input_port_read(machine(), "A004");
-		case 0x05: return input_port_read(machine(), "A005");
-		case 0x0c: return input_port_read(machine(), "SERVICE");	// stats / reset
-		case 0x0e: return input_port_read(machine(), "A00E");		// coin/reset
+		case 0x04: return ioport("A004")->read();
+		case 0x05: return ioport("A005")->read();
+		case 0x0c: return ioport("SERVICE")->read();	// stats / reset
+		case 0x0e: return ioport("A00E")->read();		// coin/reset
 	}
 
 	if(offset == 0x00) //muxed with A002?
@@ -356,11 +356,11 @@
 		switch(m_reg_a002 & 0x3f)
 		{
 		case 0x3b:
-			return input_port_read(machine(), "UNK");	//bet10 / pay out
+			return ioport("UNK")->read();	//bet10 / pay out
 		case 0x3e:
-			return input_port_read(machine(), "INPUTS");	//TODO : trace f564
+			return ioport("INPUTS")->read();	//TODO : trace f564
 		case 0x3d:
-			return input_port_read(machine(), "A005");
+			return ioport("A005")->read();
 		default:
 			logerror("A000 read with mux=0x%02x\n", m_reg_a002 & 0x3f);
 		}
diff -Nru src-old/mame/drivers/wolfpack.c src/mame/drivers/wolfpack.c
--- src-old/mame/drivers/wolfpack.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/wolfpack.c	2012-05-03 11:00:08.000000000 +0200
@@ -33,7 +33,7 @@
 CUSTOM_INPUT_MEMBER(wolfpack_state::wolfpack_dial_r)
 {
 	int bit = (FPTR)param;
-	return ((input_port_read(machine(), "DIAL") + bit) / 2) & 0x01;
+	return ((ioport("DIAL")->read() + bit) / 2) & 0x01;
 }
 
 
diff -Nru src-old/mame/drivers/wwfwfest.c src/mame/drivers/wwfwfest.c
--- src-old/mame/drivers/wwfwfest.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/drivers/wwfwfest.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,13 +177,13 @@
 CUSTOM_INPUT_MEMBER(wwfwfest_state::dsw_3f_r)
 {
 	const char *tag = (const char *)param;
-	return input_port_read(machine(), tag) & 0x3f;
+	return ioport(tag)->read() & 0x3f;
 }
 
 CUSTOM_INPUT_MEMBER(wwfwfest_state::dsw_c0_r)
 {
 	const char *tag = (const char *)param;
-	return (input_port_read(machine(), tag) & 0xc0) >> 6;
+	return (ioport(tag)->read() & 0xc0) >> 6;
 }
 
 
@@ -237,7 +237,7 @@
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_START4 )
 	PORT_BIT( 0x0300, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, wwfwfest_state,dsw_c0_r, "DSW1")
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_UNKNOWN )
diff -Nru src-old/mame/drivers/xexex.c src/mame/drivers/xexex.c
--- src-old/mame/drivers/xexex.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/xexex.c	2012-05-03 11:00:08.000000000 +0200
@@ -183,7 +183,7 @@
 	/* bit 5  is enable irq 6 */
 	/* bit 6  is enable irq 5 */
 	/* bit 11 is watchdog */
-	input_port_write(machine, "EEPROMOUT", state->m_cur_control2, 0xff);
+	state->ioport("EEPROMOUT")->write(state->m_cur_control2, 0xff);
 
 	/* bit 8 = enable sprite ROM reading */
 	k053246_set_objcha_line(state->m_k053246, (state->m_cur_control2 & 0x0100) ? ASSERT_LINE : CLEAR_LINE);
@@ -684,7 +684,7 @@
 	if (!strcmp(machine.system().name, "xexex"))
 	{
 		// Invulnerability
-//      *(UINT16 *)(machine.root_device().memregion("maincpu")->base() + 0x648d4) = 0x4a79;
+//      *(UINT16 *)(state->memregion("maincpu")->base() + 0x648d4) = 0x4a79;
 //      *(UINT16 *)(state->memregion("maincpu")->base() + 0x00008) = 0x5500;
 		state->m_strip_0x1a = 1;
 	}
diff -Nru src-old/mame/drivers/xmen.c src/mame/drivers/xmen.c
--- src-old/mame/drivers/xmen.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/xmen.c	2012-05-03 11:00:08.000000000 +0200
@@ -54,7 +54,7 @@
 		/* bit 3 is clock (active high) */
 		/* bit 4 is cs (active low) */
 		/* bit 5 is enabled in IRQ3, disabled in IRQ5 (sprite DMA start?) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 	}
 	if (ACCESSING_BITS_8_15)
 	{
diff -Nru src-old/mame/drivers/xtheball.c src/mame/drivers/xtheball.c
--- src-old/mame/drivers/xtheball.c	2012-04-11 18:29:24.000000000 +0200
+++ src/mame/drivers/xtheball.c	2012-05-03 11:00:08.000000000 +0200
@@ -191,7 +191,7 @@
 
 READ16_MEMBER(xtheball_state::analogx_r)
 {
-	return (input_port_read(machine(), "ANALOGX") << 8) | 0x00ff;
+	return (ioport("ANALOGX")->read() << 8) | 0x00ff;
 }
 
 
@@ -199,7 +199,7 @@
 {
 	/* doubles as a watchdog address */
 	watchdog_reset_w(space,0,0);
-	return (input_port_read(machine(), "ANALOGY") << 8) | 0x00ff;
+	return (ioport("ANALOGY")->read() << 8) | 0x00ff;
 }
 
 
diff -Nru src-old/mame/drivers/xxmissio.c src/mame/drivers/xxmissio.c
--- src-old/mame/drivers/xxmissio.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/xxmissio.c	2012-05-03 11:00:08.000000000 +0200
@@ -199,7 +199,7 @@
 
 	PORT_START("STATUS")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, xxmissio_state,xxmissio_status_r, (void *)0x01)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, xxmissio_state,xxmissio_status_r, (void *)0x04)
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, xxmissio_state,xxmissio_status_r, (void *)0x08)
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, xxmissio_state,xxmissio_status_r, (void *)0x10)
diff -Nru src-old/mame/drivers/xybots.c src/mame/drivers/xybots.c
--- src-old/mame/drivers/xybots.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/xybots.c	2012-05-03 11:00:08.000000000 +0200
@@ -66,7 +66,7 @@
 
 READ16_MEMBER(xybots_state::special_port1_r)
 {
-	int result = input_port_read(machine(), "FFE200");
+	int result = ioport("FFE200")->read();
 
 	if (m_cpu_to_sound_ready) result ^= 0x0200;
 	result ^= m_h256 ^= 0x0400;
@@ -135,7 +135,7 @@
 	PORT_SERVICE( 0x0100, IP_ACTIVE_LOW )
 	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_UNUSED )	/* /AUDBUSY */
 	PORT_BIT( 0x0400, IP_ACTIVE_HIGH, IPT_UNUSED )	/* 256H */
-	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_VBLANK )	/* VBLANK */
+	PORT_BIT( 0x0800, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_VBLANK("screen")	/* VBLANK */
 	PORT_BIT( 0xf000, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_INCLUDE( atarijsa_i )		/* audio port */
diff -Nru src-old/mame/drivers/xyonix.c src/mame/drivers/xyonix.c
--- src-old/mame/drivers/xyonix.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/xyonix.c	2012-05-03 11:00:08.000000000 +0200
@@ -43,7 +43,7 @@
 
 	if (coin & 1)	// Coin 2 !
 	{
-		tmp = (input_port_read(machine, "DSW") & 0xc0) >> 6;
+		tmp = (state->ioport("DSW")->read() & 0xc0) >> 6;
 		state->m_coins++;
 		if (state->m_coins >= coinage_table[tmp][0])
 		{
@@ -56,7 +56,7 @@
 
 	if (coin & 2)	// Coin 1 !
 	{
-		tmp = (input_port_read(machine, "DSW") & 0x30) >> 4;
+		tmp = (machine.root_device().ioport("DSW")->read() & 0x30) >> 4;
 		state->m_coins++;
 		if (state->m_coins >= coinage_table[tmp][0])
 		{
@@ -89,12 +89,12 @@
 		switch (m_e0_data)
 		{
 			case 0x81 :
-				return input_port_read(machine(), "P1") & 0x7f;
+				return ioport("P1")->read() & 0x7f;
 			case 0x82 :
-				return input_port_read(machine(), "P2") & 0x7f;
+				return ioport("P2")->read() & 0x7f;
 			case 0x91:
 				/* check coin inputs */
-				coin = ((input_port_read(machine(), "P1") & 0x80) >> 7) | ((input_port_read(machine(), "P2") & 0x80) >> 6);
+				coin = ((ioport("P1")->read() & 0x80) >> 7) | ((ioport("P2")->read() & 0x80) >> 6);
 				if (coin ^ m_prev_coin && coin != 3)
 				{
 					if (m_credits < 9) handle_coins(machine(), coin);
@@ -102,7 +102,7 @@
 				m_prev_coin = coin;
 				return m_credits;
 			case 0x92:
-				return ((input_port_read(machine(), "P1") & 0x80) >> 7) | ((input_port_read(machine(), "P2") & 0x80) >> 6);
+				return ((ioport("P1")->read() & 0x80) >> 7) | ((ioport("P2")->read() & 0x80) >> 6);
 			case 0xe0:	/* reset? */
 				m_coins = 0;
 				m_credits = 0;
@@ -111,9 +111,9 @@
 				m_credits--;
 				return 0xff;
 			case 0xfe:	/* Dip Switches 1 to 4 */
-				return input_port_read(machine(), "DSW") & 0x0f;
+				return ioport("DSW")->read() & 0x0f;
 			case 0xff:	/* Dip Switches 5 to 8 */
-				return input_port_read(machine(), "DSW") >> 4;
+				return ioport("DSW")->read() >> 4;
 		}
 	}
 
diff -Nru src-old/mame/drivers/yunsung8.c src/mame/drivers/yunsung8.c
--- src-old/mame/drivers/yunsung8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/yunsung8.c	2012-05-03 11:00:08.000000000 +0200
@@ -466,8 +466,8 @@
 static MACHINE_START( yunsung8 )
 {
 	yunsung8_state *state = machine.driver_data<yunsung8_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
-	UINT8 *AUDIO = machine.root_device().memregion("audiocpu")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
+	UINT8 *AUDIO = state->memregion("audiocpu")->base();
 
 	state->m_videoram_0 = state->m_videoram + 0x0000;	// Ram is banked
 	state->m_videoram_1 = state->m_videoram + 0x2000;
diff -Nru src-old/mame/drivers/zac2650.c src/mame/drivers/zac2650.c
--- src-old/mame/drivers/zac2650.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/zac2650.c	2012-05-03 11:00:08.000000000 +0200
@@ -79,7 +79,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("1E85")
 	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -147,7 +147,7 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("SENSE")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
 
 	PORT_START("1E85")
 	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Difficulty ) )
diff -Nru src-old/mame/drivers/zaccaria.c src/mame/drivers/zaccaria.c
--- src-old/mame/drivers/zaccaria.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/drivers/zaccaria.c	2012-05-03 11:00:08.000000000 +0200
@@ -75,7 +75,7 @@
 {
 	static const char *const dswnames[] = { "IN0", "DSW0", "DSW1" };
 
-	return input_port_read(machine(), dswnames[m_dsw]);
+	return ioport(dswnames[m_dsw])->read();
 }
 
 
@@ -228,7 +228,7 @@
 	switch (offset)
 	{
 		case 0:
-			return input_port_read(machine(), "COINS");   /* bits 4 and 5 must be 0 in Jack Rabbit */
+			return ioport("COINS")->read();   /* bits 4 and 5 must be 0 in Jack Rabbit */
 
 		case 2:
 			return 0x10;    /* Jack Rabbit */
diff -Nru src-old/mame/drivers/zaxxon.c src/mame/drivers/zaxxon.c
--- src-old/mame/drivers/zaxxon.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/zaxxon.c	2012-05-03 11:00:08.000000000 +0200
@@ -356,7 +356,7 @@
 	int num = (FPTR)param;
 	int delta, res;
 
-	delta = input_port_read(machine(), dialname[num]);
+	delta = ioport(dialname[num])->read();
 
 	if (delta < 0x80)
 	{
@@ -1305,75 +1305,126 @@
 	ROM_LOAD( "1941a.u72",       0x0100, 0x0100, CRC(a5d0d97e) SHA1(2677508b44f9b7a6c6ee56e49a7b88073e80debe) )
 ROM_END
 
+/*
+Extra notes about Congo Bongo:
 
-ROM_START( congo )
-	ROM_REGION( 0x8000, "maincpu", 0 )
-	ROM_LOAD( "congo1.u35",   0x0000, 0x2000, CRC(09355b5b) SHA1(0085ac7eb0035a88cb54cdd3dd6b2643141d39db) )
-	ROM_LOAD( "congo2.u34",   0x2000, 0x2000, CRC(1c5e30ae) SHA1(7cc5420e0e7a2793a671b938c121ae4079f5b1b8) )
-	ROM_LOAD( "congo3.u33",   0x4000, 0x2000, CRC(5ee1132c) SHA1(26294cd69ee43dfd29fc3642e8c04552dcdbaa49) )
-	ROM_LOAD( "congo4.u32",   0x6000, 0x2000, CRC(5332b9bf) SHA1(8440cc6f92918b3b467a5a0b86c9defeb0a7db0e) )
+There is known to be a version of Congo Bongo with official Sega "EPR" numbers. Sega game ID number for this set is 834-5197
 
-	ROM_REGION( 0x2000, "audiocpu", 0 )
-	ROM_LOAD( "congo17.u11",  0x0000, 0x2000, CRC(5024e673) SHA1(6f846146a4e29bcdfd5bd1bc5f1211d344cd5afa) )
+3 board stack with 834-5181 stickered as 834-5207 with standard 834-5167 video board & 834-5168 sound board.
+EPR-5309A.rom1 @ U35
+EPR-5310A.rom2 @ U34
+EPR-5311A.rom3 @ U33
+EPR-5312A.rom4 @ U32
 
-	ROM_REGION( 0x1000, "gfx_tx", 0 )
-	ROM_LOAD( "congo5.u76",   0x00000, 0x1000, CRC(7bf6ba2b) SHA1(3a2bd21b0e0e55cbd737c7b075492b5e8f944150) )
+Uses the MR018 BPROM @ U68
 
-	ROM_REGION( 0x6000, "gfx_bg", 0 )
-	ROM_LOAD( "congo8.u93",   0x00000, 0x2000, CRC(db99a619) SHA1(499029197d26f9aea3ac15d66b5738ce7dea1f6c) )
-	ROM_LOAD( "congo9.u94",   0x02000, 0x2000, CRC(93e2309e) SHA1(bd8a74332cac0cf85f319c1f35d04a4781c9d655) )
-	ROM_LOAD( "congo10.u95",  0x04000, 0x2000, CRC(f27a9407) SHA1(d41c90c89ae28c92bf0c57927357d9b68ed7e0ef) )
+Oddly, it seems most Congo Bongo board sets (2 & 3 board stacks) have hand written labels for the program roms. At least
+all the PCB photos I found via Google as well as those included in a recent redump of both board set types.  And YES it's
+actually "CONGO BONGO REV C ROM 2A" this is verified in several PCB photos.
 
-	ROM_REGION( 0xc000, "gfx_spr", 0 )
-	ROM_LOAD( "congo12.u78",  0x00000, 0x2000, CRC(15e3377a) SHA1(04a7fbfd58924359fae0ba76ed152f325f07beae) )
-	ROM_LOAD( "congo13.u79",  0x02000, 0x2000, CRC(1d1321c8) SHA1(d12e156a24db105c5f941b7ef79f32181b616710) )
-	ROM_LOAD( "congo11.u77",  0x04000, 0x2000, CRC(73e2709f) SHA1(14919facf08f6983c3a9baad031239a1b57c8202) )
-	ROM_LOAD( "congo14.u104", 0x06000, 0x2000, CRC(bf9169fe) SHA1(303d68e38e9a47464f14dc5be6bff1be01b88bb6) )
-	ROM_LOAD( "congo16.u106", 0x08000, 0x2000, CRC(cb6d5775) SHA1(b1f8ead6e6f8ad995baaeb7f8554d41ed2296fff) )
-	ROM_LOAD( "congo15.u105", 0x0a000, 0x2000, CRC(7b15a7a4) SHA1(b1c05e60a1442e4dd56d197be8b768bcbf45e2d9) )
-
-	ROM_REGION( 0x4000, "tilemap_dat", 0 )
-	ROM_LOAD( "congo6.u57",   0x0000, 0x2000, CRC(d637f02b) SHA1(29127149924c5bfdeb9456d7df2a5a5d14098794) )
-	ROM_LOAD( "congo7.u58",   0x2000, 0x2000, CRC(80927943) SHA1(4683520c241d209c6cabeaead9b363f046c30f70) )
+*/
 
-	ROM_REGION( 0x0200, "proms", 0 )
-	ROM_LOAD( "congo.u68",    0x0000, 0x100, CRC(b788d8ae) SHA1(9765180f3087140c75e5953409df841787558160) )
+ROM_START( congo ) /* 2 board stack, Sega game ID number for this set is 834-5180 */
+	ROM_REGION( 0x8000, "maincpu", 0 ) /* Located on 834-5181 PCB,  AKA Tip Top-CONTR II */
+	ROM_LOAD( "congo_rev_c_rom1.u21",   0x0000, 0x2000, CRC(09355b5b) SHA1(0085ac7eb0035a88cb54cdd3dd6b2643141d39db) ) /* SUM16 written on label 044A */
+	ROM_LOAD( "congo_rev_c_rom2a.u22",  0x2000, 0x2000, CRC(1c5e30ae) SHA1(7cc5420e0e7a2793a671b938c121ae4079f5b1b8) ) /* SUM16 written on label DD4D */
+	ROM_LOAD( "congo_rev_c_rom3.u23",   0x4000, 0x2000, CRC(5ee1132c) SHA1(26294cd69ee43dfd29fc3642e8c04552dcdbaa49) ) /* SUM16 written on label C932 */
+	ROM_LOAD( "congo_rev_c_rom4.u24",   0x6000, 0x2000, CRC(5332b9bf) SHA1(8440cc6f92918b3b467a5a0b86c9defeb0a7db0e) ) /* SUM16 written on label 5128 */
+
+	ROM_REGION( 0x2000, "audiocpu", 0 ) /* Located on 834-5181 PCB,  AKA Tip Top-CONTR II */
+	ROM_LOAD( "tip_top_rom_17.u19",  0x0000, 0x2000, CRC(5024e673) SHA1(6f846146a4e29bcdfd5bd1bc5f1211d344cd5afa) )
+
+	ROM_REGION( 0x1000, "gfx_tx", 0 ) /* Located on 834-5181 PCB,  AKA Tip Top-CONTR II */
+	ROM_LOAD( "tip_top_rom_5.u76",   0x00000, 0x1000, CRC(7bf6ba2b) SHA1(3a2bd21b0e0e55cbd737c7b075492b5e8f944150) )
+
+	ROM_REGION( 0x6000, "gfx_bg", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_8.u93",   0x00000, 0x2000, CRC(db99a619) SHA1(499029197d26f9aea3ac15d66b5738ce7dea1f6c) )
+	ROM_LOAD( "tip_top_rom_9.u94",   0x02000, 0x2000, CRC(93e2309e) SHA1(bd8a74332cac0cf85f319c1f35d04a4781c9d655) )
+	ROM_LOAD( "tip_top_rom_10.u95",  0x04000, 0x2000, CRC(f27a9407) SHA1(d41c90c89ae28c92bf0c57927357d9b68ed7e0ef) )
+
+	ROM_REGION( 0xc000, "gfx_spr", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_12.u78",  0x00000, 0x2000, CRC(15e3377a) SHA1(04a7fbfd58924359fae0ba76ed152f325f07beae) )
+	ROM_LOAD( "tip_top_rom_13.u79",  0x02000, 0x2000, CRC(1d1321c8) SHA1(d12e156a24db105c5f941b7ef79f32181b616710) )
+	ROM_LOAD( "tip_top_rom_11.u77",  0x04000, 0x2000, CRC(73e2709f) SHA1(14919facf08f6983c3a9baad031239a1b57c8202) )
+	ROM_LOAD( "tip_top_rom_14.u104", 0x06000, 0x2000, CRC(bf9169fe) SHA1(303d68e38e9a47464f14dc5be6bff1be01b88bb6) )
+	ROM_LOAD( "tip_top_rom_16.u106", 0x08000, 0x2000, CRC(cb6d5775) SHA1(b1f8ead6e6f8ad995baaeb7f8554d41ed2296fff) )
+	ROM_LOAD( "tip_top_rom_15.u105", 0x0a000, 0x2000, CRC(7b15a7a4) SHA1(b1c05e60a1442e4dd56d197be8b768bcbf45e2d9) )
+
+	ROM_REGION( 0x4000, "tilemap_dat", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_6.u57",   0x0000, 0x2000, CRC(d637f02b) SHA1(29127149924c5bfdeb9456d7df2a5a5d14098794) )
+	ROM_LOAD( "tip_top_rom_7.u58",   0x2000, 0x2000, CRC(80927943) SHA1(4683520c241d209c6cabeaead9b363f046c30f70) )
+
+	ROM_REGION( 0x0200, "proms", 0 ) /* Located on 834-5181 PCB,  AKA Tip Top-CONTR II */
+	ROM_LOAD( "mr019.u87",    0x0000, 0x100, CRC(b788d8ae) SHA1(9765180f3087140c75e5953409df841787558160) ) /* BPROM type is a TBP28L22 per the schematics */
 	ROM_RELOAD(               0x0100, 0x100 )
 ROM_END
 
-ROM_START( tiptop )
-	ROM_REGION( 0x8000, "maincpu", 0 )
+ROM_START( congoa ) /* 3 board stack, Sega game ID number for this set is 834-5156 */
+	ROM_REGION( 0x8000, "maincpu", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
+	ROM_LOAD( "congo_rev_c_rom1.u35",   0x0000, 0x2000, CRC(09355b5b) SHA1(0085ac7eb0035a88cb54cdd3dd6b2643141d39db) ) /* SUM16 written on label 044A */
+	ROM_LOAD( "congo_rev_c_rom2a.u34",  0x2000, 0x2000, CRC(1c5e30ae) SHA1(7cc5420e0e7a2793a671b938c121ae4079f5b1b8) ) /* SUM16 written on label DD4D */
+	ROM_LOAD( "congo_rev_c_rom3.u33",   0x4000, 0x2000, CRC(5ee1132c) SHA1(26294cd69ee43dfd29fc3642e8c04552dcdbaa49) ) /* SUM16 written on label C932 */
+	ROM_LOAD( "congo_rev_c_rom4.u32",   0x6000, 0x2000, CRC(5332b9bf) SHA1(8440cc6f92918b3b467a5a0b86c9defeb0a7db0e) ) /* SUM16 written on label 5128 */
+
+	ROM_REGION( 0x2000, "audiocpu", 0 ) /* Located on 834-5168 PCB  AKA Tip Top-SOUND */
+	ROM_LOAD( "tip_top_rom_17.u11",  0x0000, 0x2000, CRC(5024e673) SHA1(6f846146a4e29bcdfd5bd1bc5f1211d344cd5afa) )
+
+	ROM_REGION( 0x1000, "gfx_tx", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
+	ROM_LOAD( "tip_top_rom_5.u76",   0x00000, 0x1000, CRC(7bf6ba2b) SHA1(3a2bd21b0e0e55cbd737c7b075492b5e8f944150) )
+
+	ROM_REGION( 0x6000, "gfx_bg", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_8.u93",   0x00000, 0x2000, CRC(db99a619) SHA1(499029197d26f9aea3ac15d66b5738ce7dea1f6c) )
+	ROM_LOAD( "tip_top_rom_9.u94",   0x02000, 0x2000, CRC(93e2309e) SHA1(bd8a74332cac0cf85f319c1f35d04a4781c9d655) )
+	ROM_LOAD( "tip_top_rom_10.u95",  0x04000, 0x2000, CRC(f27a9407) SHA1(d41c90c89ae28c92bf0c57927357d9b68ed7e0ef) )
+
+	ROM_REGION( 0xc000, "gfx_spr", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_12.u78",  0x00000, 0x2000, CRC(15e3377a) SHA1(04a7fbfd58924359fae0ba76ed152f325f07beae) )
+	ROM_LOAD( "tip_top_rom_13.u79",  0x02000, 0x2000, CRC(1d1321c8) SHA1(d12e156a24db105c5f941b7ef79f32181b616710) )
+	ROM_LOAD( "tip_top_rom_11.u77",  0x04000, 0x2000, CRC(73e2709f) SHA1(14919facf08f6983c3a9baad031239a1b57c8202) )
+	ROM_LOAD( "tip_top_rom_14.u104", 0x06000, 0x2000, CRC(bf9169fe) SHA1(303d68e38e9a47464f14dc5be6bff1be01b88bb6) )
+	ROM_LOAD( "tip_top_rom_16.u106", 0x08000, 0x2000, CRC(cb6d5775) SHA1(b1f8ead6e6f8ad995baaeb7f8554d41ed2296fff) )
+	ROM_LOAD( "tip_top_rom_15.u105", 0x0a000, 0x2000, CRC(7b15a7a4) SHA1(b1c05e60a1442e4dd56d197be8b768bcbf45e2d9) )
+
+	ROM_REGION( 0x4000, "tilemap_dat", 0 ) /* Located on 834-5167 PCB, Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_6.u57",   0x0000, 0x2000, CRC(d637f02b) SHA1(29127149924c5bfdeb9456d7df2a5a5d14098794) )
+	ROM_LOAD( "tip_top_rom_7.u58",   0x2000, 0x2000, CRC(80927943) SHA1(4683520c241d209c6cabeaead9b363f046c30f70) )
+
+	ROM_REGION( 0x0200, "proms", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
+	ROM_LOAD( "mr018.u68",    0x0000, 0x200, CRC(56b9f1ba) SHA1(32ae743087f7c2dfba6818df8e9d665d8d9a3ee7) ) /* dumped as TBP28S42, first 256 bytes match MR019 then 0xFF filled */
+ROM_END
+
+ROM_START( tiptop ) /* 3 board stack */
+	ROM_REGION( 0x8000, "maincpu", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
 	ROM_LOAD( "tiptop1.u35",  0x0000, 0x2000, CRC(e19dc77b) SHA1(d3782dd55701e0f5cd426ad2771c1bd0264c366a) )
 	ROM_LOAD( "tiptop2.u34",  0x2000, 0x2000, CRC(3fcd3b6e) SHA1(2898807ee36fca7fbc06616c9a070604beb782b9) )
 	ROM_LOAD( "tiptop3.u33",  0x4000, 0x2000, CRC(1c94250b) SHA1(cb70a91d07b0a9c61a093f1b5d37f2e69d1345c1) )
 	ROM_LOAD( "tiptop4.u32",  0x6000, 0x2000, CRC(577b501b) SHA1(5cad98a60a5241ba9467aa03fcd94c7490e6dbbb) )
 
-	ROM_REGION( 0x2000, "audiocpu", 0 )
-	ROM_LOAD( "congo17.u11",  0x0000, 0x2000, CRC(5024e673) SHA1(6f846146a4e29bcdfd5bd1bc5f1211d344cd5afa) )
-
-	ROM_REGION( 0x1000, "gfx_tx", 0 )
-	ROM_LOAD( "congo5.u76",   0x00000, 0x1000, CRC(7bf6ba2b) SHA1(3a2bd21b0e0e55cbd737c7b075492b5e8f944150) )
+	ROM_REGION( 0x2000, "audiocpu", 0 ) /* Located on 834-5168 PCB  AKA Tip Top-SOUND */
+	ROM_LOAD( "tip_top_rom_17.u11",  0x0000, 0x2000, CRC(5024e673) SHA1(6f846146a4e29bcdfd5bd1bc5f1211d344cd5afa) )
 
-	ROM_REGION( 0x6000, "gfx_bg", 0 )
-	ROM_LOAD( "congo8.u93",   0x00000, 0x2000, CRC(db99a619) SHA1(499029197d26f9aea3ac15d66b5738ce7dea1f6c) )
-	ROM_LOAD( "congo9.u94",   0x02000, 0x2000, CRC(93e2309e) SHA1(bd8a74332cac0cf85f319c1f35d04a4781c9d655) )
-	ROM_LOAD( "congo10.u95",  0x04000, 0x2000, CRC(f27a9407) SHA1(d41c90c89ae28c92bf0c57927357d9b68ed7e0ef) )
+	ROM_REGION( 0x1000, "gfx_tx", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
+	ROM_LOAD( "tip_top_rom_5.u76",   0x00000, 0x1000, CRC(7bf6ba2b) SHA1(3a2bd21b0e0e55cbd737c7b075492b5e8f944150) )
 
-	ROM_REGION( 0xc000, "gfx_spr", 0 )
-	ROM_LOAD( "congo12.u78",  0x00000, 0x2000, CRC(15e3377a) SHA1(04a7fbfd58924359fae0ba76ed152f325f07beae) )
-	ROM_LOAD( "congo13.u79",  0x02000, 0x2000, CRC(1d1321c8) SHA1(d12e156a24db105c5f941b7ef79f32181b616710) )
-	ROM_LOAD( "congo11.u77",  0x04000, 0x2000, CRC(73e2709f) SHA1(14919facf08f6983c3a9baad031239a1b57c8202) )
-	ROM_LOAD( "congo14.u104", 0x06000, 0x2000, CRC(bf9169fe) SHA1(303d68e38e9a47464f14dc5be6bff1be01b88bb6) )
-	ROM_LOAD( "congo16.u106", 0x08000, 0x2000, CRC(cb6d5775) SHA1(b1f8ead6e6f8ad995baaeb7f8554d41ed2296fff) )
-	ROM_LOAD( "congo15.u105", 0x0a000, 0x2000, CRC(7b15a7a4) SHA1(b1c05e60a1442e4dd56d197be8b768bcbf45e2d9) )
-
-	ROM_REGION( 0x4000, "tilemap_dat", 0 )
-	ROM_LOAD( "congo6.u57",   0x0000, 0x2000, CRC(d637f02b) SHA1(29127149924c5bfdeb9456d7df2a5a5d14098794) )
-	ROM_LOAD( "congo7.u58",   0x2000, 0x2000, CRC(80927943) SHA1(4683520c241d209c6cabeaead9b363f046c30f70) )
+	ROM_REGION( 0x6000, "gfx_bg", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_8.u93",   0x00000, 0x2000, CRC(db99a619) SHA1(499029197d26f9aea3ac15d66b5738ce7dea1f6c) )
+	ROM_LOAD( "tip_top_rom_9.u94",   0x02000, 0x2000, CRC(93e2309e) SHA1(bd8a74332cac0cf85f319c1f35d04a4781c9d655) )
+	ROM_LOAD( "tip_top_rom_10.u95",  0x04000, 0x2000, CRC(f27a9407) SHA1(d41c90c89ae28c92bf0c57927357d9b68ed7e0ef) )
+
+	ROM_REGION( 0xc000, "gfx_spr", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_12.u78",  0x00000, 0x2000, CRC(15e3377a) SHA1(04a7fbfd58924359fae0ba76ed152f325f07beae) )
+	ROM_LOAD( "tip_top_rom_13.u79",  0x02000, 0x2000, CRC(1d1321c8) SHA1(d12e156a24db105c5f941b7ef79f32181b616710) )
+	ROM_LOAD( "tip_top_rom_11.u77",  0x04000, 0x2000, CRC(73e2709f) SHA1(14919facf08f6983c3a9baad031239a1b57c8202) )
+	ROM_LOAD( "tip_top_rom_14.u104", 0x06000, 0x2000, CRC(bf9169fe) SHA1(303d68e38e9a47464f14dc5be6bff1be01b88bb6) )
+	ROM_LOAD( "tip_top_rom_16.u106", 0x08000, 0x2000, CRC(cb6d5775) SHA1(b1f8ead6e6f8ad995baaeb7f8554d41ed2296fff) )
+	ROM_LOAD( "tip_top_rom_15.u105", 0x0a000, 0x2000, CRC(7b15a7a4) SHA1(b1c05e60a1442e4dd56d197be8b768bcbf45e2d9) )
+
+	ROM_REGION( 0x4000, "tilemap_dat", 0 ) /* Located on 834-5167 PCB, AKA Tip Tip-VIDEO */
+	ROM_LOAD( "tip_top_rom_6.u57",   0x0000, 0x2000, CRC(d637f02b) SHA1(29127149924c5bfdeb9456d7df2a5a5d14098794) )
+	ROM_LOAD( "tip_top_rom_7.u58",   0x2000, 0x2000, CRC(80927943) SHA1(4683520c241d209c6cabeaead9b363f046c30f70) )
 
-	ROM_REGION( 0x0200, "proms", 0 )
-	ROM_LOAD( "congo.u68",    0x0000, 0x100, CRC(b788d8ae) SHA1(9765180f3087140c75e5953409df841787558160) )
-	ROM_RELOAD(               0x0100, 0x100 )
+	ROM_REGION( 0x0200, "proms", 0 ) /* Located on 834-5166 PCB  AKA Tip Top-CONTR */
+	ROM_LOAD( "mr018.u68",    0x0000, 0x200, CRC(56b9f1ba) SHA1(32ae743087f7c2dfba6818df8e9d665d8d9a3ee7) ) /* dumped as TBP28S42, first 256 bytes match MR019 then 0xFF filled */
 ROM_END
 
 
@@ -1532,11 +1583,11 @@
  *************************************/
 
 /* these games run on standard Zaxxon hardware */
-GAME( 1982, zaxxon,   0,      zaxxon,   zaxxon,   0,        ROT90,  "Sega",    "Zaxxon (set 1)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1982, zaxxon,   0,      zaxxon,   zaxxon,   0,        ROT90,  "Sega",    "Zaxxon (set 1)",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1982, zaxxon2,  zaxxon, zaxxon,   zaxxon,   0,        ROT90,  "Sega",    "Zaxxon (set 2)",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1982, zaxxon3,  zaxxon, zaxxon,   zaxxon,   0,        ROT90,  "Sega",    "Zaxxon (set 3)",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1982, zaxxonj,  zaxxon, zaxxon,   zaxxon,   zaxxonj,  ROT90,  "Sega",    "Zaxxon (Japan)",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
-GAME( 1982, zaxxonb,  zaxxon, zaxxon,   zaxxon,   zaxxonj,  ROT90,  "bootleg", "Jackson",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1982, zaxxonb,  zaxxon, zaxxon,   zaxxon,   zaxxonj,  ROT90,  "bootleg", "Jackson",         GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 
 /* standard Zaxxon hardware but extra sound board plugged into 8255 PPI socket and encrypted cpu */
 GAME( 1982, szaxxon,  0,      zaxxon,   szaxxon,  szaxxon,  ROT90,  "Sega",    "Super Zaxxon (315-5013)",  GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
@@ -1551,5 +1602,6 @@
 
 /* these games run on a slightly newer Zaxxon hardware with more ROM space and a */
 /* custom sprite DMA chip */
-GAME( 1983, congo,    0,      congo,    congo,    0,        ROT90,  "Sega",    "Congo Bongo", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
-GAME( 1983, tiptop,   congo,  congo,    congo,    0,        ROT90,  "Sega",    "Tip Top", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1983, congo,    0,      congo,    congo,    0,        ROT90,  "Sega",    "Congo Bongo (Rev C, 2 board stack)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1983, congoa,   congo,  congo,    congo,    0,        ROT90,  "Sega",    "Congo Bongo (Rev C, 3 board stack)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1983, tiptop,   congo,  congo,    congo,    0,        ROT90,  "Sega",    "Tip Top (3 board stack)",     GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/zn.c src/mame/drivers/zn.c
--- src-old/mame/drivers/zn.c	2012-04-22 11:09:28.000000000 +0200
+++ src/mame/drivers/zn.c	2012-05-03 11:00:08.000000000 +0200
@@ -342,7 +342,7 @@
 	{
 		if( state->m_b_lastclock )
 		{
-			int bit = ( ( input_port_read(machine, "DSW") >> state->m_n_dip_bit ) & 1 );
+			int bit = ( ( state->ioport("DSW")->read() >> state->m_n_dip_bit ) & 1 );
 			verboselog( machine, 2, "read dip %02x -> %02x\n", n_data, bit * PSX_SIO_IN_DATA );
 			psx_sio_input( machine, 0, PSX_SIO_IN_DATA, bit * PSX_SIO_IN_DATA );
 			state->m_n_dip_bit++;
@@ -2094,13 +2094,13 @@
 
 		if( state->m_jdredd_gun_mux == 0 )
 		{
-			x = input_port_read(state->machine(), "GUN1X");
-			y = input_port_read(state->machine(), "GUN1Y");
+			x = state->machine().root_device().ioport("GUN1X")->read();
+			y = state->machine().root_device().ioport("GUN1Y")->read();
 		}
 		else
 		{
-			x = input_port_read(state->machine(), "GUN2X");
-			y = input_port_read(state->machine(), "GUN2Y");
+			x = state->machine().root_device().ioport("GUN2X")->read();
+			y = state->machine().root_device().ioport("GUN2Y")->read();
 		}
 
 		if( x > 0x393 && x < 0xcb2 &&
diff -Nru src-old/mame/drivers/zr107.c src/mame/drivers/zr107.c
--- src-old/mame/drivers/zr107.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/drivers/zr107.c	2012-05-03 11:00:08.000000000 +0200
@@ -295,7 +295,7 @@
 		case 2:	/* I/O port 2 */
 		case 3:	/* System Port 0 */
 		case 4:	/* System Port 1 */
-			r = input_port_read(machine(), portnames[offset]);
+			r = ioport(portnames[offset])->read();
 			break;
 
 		case 5:	/* Parallel data port */
@@ -331,7 +331,7 @@
                 0x02 = EEPCLK
                 0x01 = EEPDI
             */
-			input_port_write(machine(), "EEPROMOUT", data & 0x07, 0xff);
+			ioport("EEPROMOUT")->write(data & 0x07, 0xff);
 			cputag_set_input_line(machine(), "audiocpu", INPUT_LINE_RESET, (data & 0x10) ? CLEAR_LINE : ASSERT_LINE);
 			mame_printf_debug("System register 0 = %02X\n", data);
 			break;
@@ -352,7 +352,7 @@
 			if (data & 0x40)	/* CG Board 0 IRQ Ack */
 				cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, CLEAR_LINE);
 			set_cgboard_id((data >> 4) & 3);
-			input_port_write(machine(), "OUT4", data, 0xff);
+			ioport("OUT4")->write(data, 0xff);
 			mame_printf_debug("System register 1 = %02X\n", data);
 			break;
 
@@ -647,11 +647,11 @@
 	switch (input)
 	{
 	case ADC083X_CH0:
-		return (double)(5 * input_port_read(device->machine(), "ANALOG1")) / 255.0;
+		return (double)(5 * device->machine().root_device().ioport("ANALOG1")->read()) / 255.0;
 	case ADC083X_CH1:
-		return (double)(5 * input_port_read(device->machine(), "ANALOG2")) / 255.0;
+		return (double)(5 * device->machine().root_device().ioport("ANALOG2")->read()) / 255.0;
 	case ADC083X_CH2:
-		return (double)(5 * input_port_read(device->machine(), "ANALOG3")) / 255.0;
+		return (double)(5 * device->machine().root_device().ioport("ANALOG3")->read()) / 255.0;
 	case ADC083X_CH3:
 		return 0;
 	case ADC083X_COM:
@@ -838,7 +838,7 @@
 	state->m_led_reg0 = state->m_led_reg1 = 0x7f;
 	state->m_ccu_vcth = state->m_ccu_vctl = 0;
 
-	K001005_preprocess_texture_data(machine.root_device().memregion("gfx1")->base(), state->memregion("gfx1")->bytes(), 0);
+	K001005_preprocess_texture_data(state->memregion("gfx1")->base(), state->memregion("gfx1")->bytes(), 0);
 }
 
 static DRIVER_INIT(zr107)
diff -Nru src-old/mame/etc/template_driver.c src/mame/etc/template_driver.c
--- src-old/mame/etc/template_driver.c	2012-04-01 15:12:40.000000000 +0200
+++ src/mame/etc/template_driver.c	2012-05-04 14:02:55.000000000 +0200
@@ -23,7 +23,7 @@
 	required_device<cpu_device> m_maincpu;
 
 	// screen updates
-	bool screen_update(screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect);
+	UINT32 screen_update(screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect);
 
 protected:
 	// driver_device overrides
@@ -38,7 +38,7 @@
 
 }
 
-bool xxx_state::screen_update( screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect )
+UINT32 xxx_state::screen_update( screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
 	return 0;
 }
diff -Nru src-old/mame/includes/bfm_sc45.h src/mame/includes/bfm_sc45.h
--- src-old/mame/includes/bfm_sc45.h	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/includes/bfm_sc45.h	2012-05-07 08:57:50.000000000 +0200
@@ -51,6 +51,8 @@
 
 	DECLARE_READ16_MEMBER(sc4_mem_r);
 	DECLARE_WRITE16_MEMBER(sc4_mem_w);
+
+	DECLARE_READ16_MEMBER(sc4_cs1_r);
 };
 
 class sc4_adder4_state : public sc4_state
@@ -61,6 +63,13 @@
 		  m_adder4cpu(*this, "adder4")
 	{ }
 
+	UINT32* m_adder4cpuregion;
+	UINT32* m_adder4ram;
+
+	DECLARE_READ32_MEMBER(adder4_mem_r);
+	DECLARE_WRITE32_MEMBER(adder4_mem_w);
+
+
 	// devices
 	required_device<cpu_device> m_adder4cpu;
 };
@@ -1270,9 +1279,13 @@
 	ROM_LOAD( "95008571.bin", 0x0000, 0x100000, CRC(50331772) SHA1(84aa448320210bfa8ea656f59cc4a320a0a46a32) ) \
 
 #define sc_hotsh_others \
-	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) /* PR3211 HOT SHOT SOUNDS11 */ \
+    ROM_LOAD( "95008794.bin", 0x000000, 0x100000, CRC(2bbe0adc) SHA1(1d5fb724ced3dbe8d744c2befae33fff69fbecba) ) \
+    ROM_LOAD( "95008795.bin", 0x100000, 0x100000, CRC(0affc9f9) SHA1(0eea59a9e8293fb68172a9389d23488be508dda5) ) \
+	ROM_REGION( 0x400000, "others", ROMREGION_ERASE00 ) /* PR1407 HOT SHOTS SOUNDS11 - for a different game? */ \
 	ROM_LOAD( "95008382.bin", 0x0000, 0x100000, CRC(cbf27ec8) SHA1(5be29fb836688e63d90e5a5108c6bdec09dd12a5) ) \
 
+
 #define sc_hotwd_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	/* PR1311 HOT WAD SOUNDS11 */ \
@@ -1457,6 +1470,8 @@
 
 #define sc_mdm_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+    ROM_LOAD( "95008844.bin", 0x000000, 0x100000, CRC(807916aa) SHA1(d266cdb2c4961337b1b1f5b6325a0b0bec934bad) ) \
+    ROM_LOAD( "95008845.bin", 0x100000, 0x100000, CRC(e1e74669) SHA1(32cb963c3698a0659c23c0662da04a97539a3c28) ) \
 
 #define sc_mhn_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
@@ -2078,11 +2093,21 @@
 	ROM_LOAD( "polesnd1.bin", 0x000000, 0x080000, CRC(09f720e3) SHA1(1a5c581b16b974e949679c3d71696984755f3c7c) ) \
 	ROM_LOAD( "polesnd2.bin", 0x080000, 0x080000, CRC(80c2702b) SHA1(6c7b1d535d8f1eeb25a1a84ccf9e97b3e453af6d) ) \
 
-#define sc_pog_others \
+#define PR1918_POTS_OF_GOLD_SOUNDS11 \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_LOAD( "pr1918 pots of gold sounds11", 0x000000, 0x100000, NO_DUMP ) \
+
+#define PR3082_C_POTS_OF_GOLD_SOUNDS11 \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008750.bin", 0x000000, 0x100000, CRC(25a94ab7) SHA1(9ee3a1acb2734a5663d925fa050c15d154f79678) ) \
 	ROM_LOAD( "95008751.bin", 0x100000, 0x100000, CRC(53c97577) SHA1(5ec3868967073b4ed429fed943fbcd568a85b4f3) ) \
 
+#define PR000050_POTOFGLD_1 \
+    ROM_REGION( 0x400000, "ymz", ROMREGION_ERASEFF) \
+    ROM_LOAD( "95008836.bin", 0x000000, 0x100000, CRC(45105fca) SHA1(3c603726bb9f4a01113a225868e864106da9fa35) ) \
+    ROM_LOAD( "95008837.bin", 0x100000, 0x100000, CRC(3db8829c) SHA1(e8de259afd2797279154252cfeb6682b482b54a9) ) \
+
+
 #define sc_rt_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008203_1.bin", 0x000000, 0x100000, CRC(778a18e5) SHA1(2ad4d0259f08786f50928064a4d345ffa6bb52e2) ) \
@@ -2119,25 +2144,36 @@
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008579.bin", 0x0000, 0x100000, CRC(b3741823) SHA1(77890bf89b848fa2222e885aeb51f05f033143ba) ) \
 
-#define sc_vivam_others \
+#define PR6927_CASINO_VMEXICO_SOUNDS11 \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_LOAD( "95004209.lo", 0x00001, 0x080000, CRC(40247425) SHA1(54c8540f9ce45b8b02f6616233b81e33af804f63) ) \
+	ROM_LOAD( "95004210.hi", 0x00000, 0x080000, CRC(6f6ce2c8) SHA1(7e9ce336a1307b8290196d58c7419996d0758ab9) ) \
+
+#define PR3010_VIVA_MEXICO_SOUNDS11 \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
-	/* pr6927 - casino */ \
-	ROM_LOAD( "95004246.bin", 0x000000, 0x080000, CRC(4e5a0143) SHA1(a9e668aceb21671a78b584fd55c21d5501ea1f8a) ) \
-	ROM_LOAD( "95004247.bin", 0x080000, 0x080000, CRC(4a35b6a1) SHA1(24e4ed93149b7f6caf785ecaa5a4685585a36f5b) ) \
-	/* pr3010 */ \
 	ROM_LOAD( "95008719.bin", 0x000000, 0x100000, CRC(f99eafef) SHA1(7a7dedf5bf8292b94ac6da78478441335bfcb66f) ) \
 	ROM_LOAD( "95008720.bin", 0x100000, 0x100000, CRC(6419033f) SHA1(3d222696dd9f4f201596fd444a031690cc8c1b0d) ) \
-	/* pr6907 */ \
+
+#define PR6927_CASINO_VMEXICO_SOUNDS21 \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_LOAD( "95004246.bin", 0x000000, 0x080000, CRC(4e5a0143) SHA1(a9e668aceb21671a78b584fd55c21d5501ea1f8a) ) \
+	ROM_LOAD( "95004247.bin", 0x080000, 0x080000, CRC(4a35b6a1) SHA1(24e4ed93149b7f6caf785ecaa5a4685585a36f5b) ) \
+
+#define PR6907_VIVA_MEXICO_SOUNDS11 \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "viva_mex.sn1", 0x000000, 0x080000, CRC(ed357575) SHA1(610047e83062fd4a6d23d9b9281a3a6c04d63f7d) ) \
 	ROM_LOAD( "viva_mex.sn2", 0x080000, 0x080000, CRC(aab9421d) SHA1(db2941e013597be3fe05a2b002aebdfb0f7a2b41) ) \
 
-#define sc_vmclb_others \
+#define PR7132_CLUB_VIVA_SOUNDS11 \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008101.bin", 0x000000, 0x100000, CRC(751a433f) SHA1(36aaf1b2425c58bd49671fc6bd61addc33a082f1) ) \
 	ROM_LOAD( "95008102.bin", 0x100000, 0x100000, CRC(155ec8ab) SHA1(5f38fb49facab94d041f315178a3d2adf9d95853) ) \
 
 #define sc_vmnv_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_LOAD( "95008095_viva_mexico_pr6984", 0x000000, 0x100000, NO_DUMP ) \
+
+
 
 #define sc_vrgcl_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
@@ -2324,7 +2360,10 @@
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008195.bin", 0x000000, 0x100000, CRC(e032e67a) SHA1(062f48bd2c38b51ffba8cda7860bb37abad40c71) ) \
 	ROM_LOAD( "95008196.bin", 0x100000, 0x100000, CRC(4a23e184) SHA1(2d1c1d92c9cdccd95ca4f466a2d7765def7d990b) ) \
-	ROM_LOAD( "95008288.bin", 0x000000, 0x100000, CRC(da74e2d3) SHA1(a16b3d6c0590b0ccc7b2488a2f23383a332c332a) ) /* casino */ \
+
+
+#define PR1326_CAS_EASY_STREAK_SOUNDS11 \
+	ROM_LOAD( "95008288.bin", 0x000000, 0x100000, CRC(da74e2d3) SHA1(a16b3d6c0590b0ccc7b2488a2f23383a332c332a) ) \
 
 #define sc_fastf_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
@@ -2586,11 +2625,15 @@
 #define sc_mbags_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 
-#define sc_mgr_others \
+#define PR1132_MONEY_GO_ROUND_SOUNDS11 \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
-	ROM_LOAD( "95008212.bin", 0x0000, 0x100000, CRC(1d0fffb3) SHA1(da7e10479b1ba9e67af94feaa20702bae687168f) ) \
 	ROM_LOAD( "snd_mgo.p1", 0x0000, 0x100000, CRC(b2f8dd11) SHA1(2db747a0c422d7dd18972f80ba94570c69564c9b) ) \
 
+
+#define PR1132_MONEY_GO_ROUND_SOUNDS11_ALT \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+	ROM_LOAD( "95008212.bin", 0x0000, 0x100000, CRC(1d0fffb3) SHA1(da7e10479b1ba9e67af94feaa20702bae687168f) ) \
+
 #define sc_mspid_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008278.bin", 0x0000, 0x100000, CRC(8fc20733) SHA1(6ede5578fa11cb3322291958d6e1ef8f6cd99da0) ) \
@@ -2711,10 +2754,6 @@
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008431.bin", 0x0000, 0x0ffeaf, CRC(400843fd) SHA1(35a0195b120e61c40e8f5e193b44f9fcb5b7d99d) ) \
 
-#define sc_pogbl_others \
-	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
-	ROM_LOAD( "95008750.bin", 0x000000, 0x100000, CRC(25a94ab7) SHA1(9ee3a1acb2734a5663d925fa050c15d154f79678) ) \
-	ROM_LOAD( "95008751.bin", 0x100000, 0x100000, CRC(53c97577) SHA1(5ec3868967073b4ed429fed943fbcd568a85b4f3) ) \
 
 #define sc_pwrsg_others \
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
@@ -3078,6 +3117,11 @@
 	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
 	ROM_LOAD( "95008475.bin", 0x0000, 0x100000, CRC(30f77b7e) SHA1(bbb16020f33c8440344670beec8b13dd554be858) ) \
 
+#define sc_clbmn_others \
+	ROM_REGION( 0x400000, "ymz", ROMREGION_ERASE00 ) \
+    ROM_LOAD( "95008666.bin", 0x000000, 0x100000, CRC(6dcb4a96) SHA1(844dc67bacb7136a3c0f897a69ac5bcacaa4968a) ) \
+    ROM_LOAD( "95008667.bin", 0x100000, 0x100000, CRC(5243784c) SHA1(771248de9fa3446ad6fe1bd35b240ad6ae23f008) ) \
+
 
 
 
diff -Nru src-old/mame/includes/bombjack.h src/mame/includes/bombjack.h
--- src-old/mame/includes/bombjack.h	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/includes/bombjack.h	2012-05-02 14:09:48.000000000 +0200
@@ -17,8 +17,6 @@
 	required_shared_ptr<UINT8> m_videoram;
 	required_shared_ptr<UINT8> m_colorram;
 	required_shared_ptr<UINT8> m_spriteram;
-//  UINT8 *     m_paletteram;  // currently this uses generic palette handling
-	size_t		m_spriteram_size;
 
 	/* video-related */
 	tilemap_t	*m_fg_tilemap;
diff -Nru src-old/mame/includes/galpnipt.h src/mame/includes/galpnipt.h
--- src-old/mame/includes/galpnipt.h	2011-08-12 20:00:24.000000000 +0200
+++ src/mame/includes/galpnipt.h	2012-05-03 11:00:08.000000000 +0200
@@ -101,17 +101,17 @@
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")\
 	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )\
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )\
-	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
-	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")\
 	PORT_DIPSETTING(      0x0080, DEF_STR( 2C_1C ) )\
 	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )\
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)
 
 #define COINAGE_TEST_LOC\
 	PORT_DIPUNUSED_DIPLOC( 0x0001, 0x0001, "SW1:1" )\
@@ -125,17 +125,17 @@
 	PORT_DIPNAME( 0x0030, 0x0030, DEF_STR( Coin_A ) )	PORT_DIPLOCATION("SW1:5,6")\
 	PORT_DIPSETTING(      0x0020, DEF_STR( 2C_1C ) )\
 	PORT_DIPSETTING(      0x0030, DEF_STR( 1C_1C ) )\
-	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
-	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0010, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
 	PORT_DIPNAME( 0x00c0, 0x00c0, DEF_STR( Coin_B ) )	PORT_DIPLOCATION("SW1:7,8")\
 	PORT_DIPSETTING(      0x0080, DEF_STR( 2C_1C ) )\
 	PORT_DIPSETTING(      0x00c0, DEF_STR( 1C_1C ) )\
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)\
-	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0000)\
-	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,PORTCOND_EQUALS,0x0008)
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_2C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)\
+	PORT_DIPSETTING(      0x0040, DEF_STR( 1C_3C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_4C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0000)\
+	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )	PORT_CONDITION("DSW1",0x0008,EQUALS,0x0008)
 
 
 #define DIFFICULTY_DEMO_SOUNDS\
diff -Nru src-old/mame/includes/iremipt.h src/mame/includes/iremipt.h
--- src-old/mame/includes/iremipt.h	2008-08-28 10:50:34.000000000 +0200
+++ src/mame/includes/iremipt.h	2012-05-03 11:00:08.000000000 +0200
@@ -94,24 +94,24 @@
 /* Mode 2 Coinage */
 
 #define IREM_COIN_MODE_2_OLD_LOC(DIPBANK) \
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6") \
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2", 0x04, EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6") \
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) \
 	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) \
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) \
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) ) \
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":7,8") \
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2", 0x04, EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":7,8") \
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) \
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) \
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_5C ) ) \
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )
 
 #define IREM_COIN_MODE_2_DSW1_LOC(DIPBANK) \
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6") \
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW2", 0x04, EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6") \
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) \
 	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) \
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) \
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":7,8") \
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW2", 0x04, EQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":7,8") \
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) \
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) \
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_5C ) ) \
@@ -122,24 +122,24 @@
 /* to make the definitions a bit more general. However, these are enough to cover */
 /* all the currently emulated games */
 #define IREM_COIN_MODE_2 \
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW2:5,6") \
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00) PORT_DIPLOCATION("SW2:5,6") \
 	PORT_DIPSETTING(    0x00, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(    0x10, DEF_STR( 3C_1C ) ) \
 	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) \
 	PORT_DIPSETTING(    0x30, DEF_STR( 1C_1C ) ) \
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW1", 0x04, PORTCOND_EQUALS, 0x00) PORT_DIPLOCATION("SW2:7,8") \
+	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW1", 0x04, EQUALS, 0x00) PORT_DIPLOCATION("SW2:7,8") \
 	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_2C ) ) \
 	PORT_DIPSETTING(    0x80, DEF_STR( 1C_3C ) ) \
 	PORT_DIPSETTING(    0x40, DEF_STR( 1C_5C ) ) \
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )
 
 #define IREM_COIN_MODE_2_HIGH \
-	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0800, PORTCOND_EQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6") \
+	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Coin_A ) ) PORT_CONDITION("DSW", 0x0800, EQUALS, 0x0000) PORT_DIPLOCATION("SW2:5,6") \
 	PORT_DIPSETTING(      0x0000, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(      0x1000, DEF_STR( 3C_1C ) ) \
 	PORT_DIPSETTING(      0x2000, DEF_STR( 2C_1C ) ) \
 	PORT_DIPSETTING(      0x3000, DEF_STR( 1C_1C ) ) \
-	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0800, PORTCOND_EQUALS, 0x0000) PORT_DIPLOCATION("SW2:7,8") \
+	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Coin_B ) ) PORT_CONDITION("DSW", 0x0800, EQUALS, 0x0000) PORT_DIPLOCATION("SW2:7,8") \
 	PORT_DIPSETTING(      0xc000, DEF_STR( 1C_2C ) ) \
 	PORT_DIPSETTING(      0x8000, DEF_STR( 1C_3C ) ) \
 	PORT_DIPSETTING(      0x4000, DEF_STR( 1C_5C ) ) \
@@ -150,7 +150,7 @@
 
 #define IREM_Z80_COINAGE_TYPE_1_LOC(DIPBANK) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
 /*  PORT_DIPSETTING(    0x80, DEF_STR( 1C_1C ) ) */ \
 	PORT_DIPSETTING(    0x90, DEF_STR( 7C_1C ) ) \
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) ) \
@@ -172,7 +172,7 @@
 
 #define IREM_Z80_COINAGE_TYPE_2_LOC(DIPBANK) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
 /*  PORT_DIPSETTING(    0x80, DEF_STR( Free_Play ) ) */ \
 /*  PORT_DIPSETTING(    0x90, DEF_STR( Free_Play ) ) */ \
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) ) \
@@ -194,7 +194,7 @@
 
 #define	IREM_Z80_COINAGE_TYPE_3_LOC(DIPBANK) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
 	PORT_DIPSETTING(    0x90, DEF_STR( 7C_1C ) ) \
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(    0xb0, DEF_STR( 5C_1C ) ) \
@@ -216,7 +216,7 @@
 
 #define	IREM_Z80_COINAGE_TYPE_4_LOC(DIPBANK) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(    0xb0, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(    0xc0, DEF_STR( 4C_1C ) ) \
@@ -238,7 +238,7 @@
 
 #define	IREM_Z80_COINAGE_TYPE_5_LOC(DIPBANK) \
 	/* Coin Mode 1 */ \
-	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, PORTCOND_NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
+	PORT_DIPNAME( 0xf0, 0xf0, DEF_STR( Coinage ) ) PORT_CONDITION("DSW2", 0x04, NOTEQUALS, 0x00) PORT_DIPLOCATION(#DIPBANK":5,6,7,8") \
 	PORT_DIPSETTING(    0x00, DEF_STR( 8C_1C ) ) \
 	PORT_DIPSETTING(    0xa0, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(    0xb0, DEF_STR( 5C_1C ) ) \
@@ -281,7 +281,7 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
 
 #define IREM_COIN_MODE_1_NEW_HIGH \
-	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, PORTCOND_NOTEQUALS, 0x0000)  PORT_DIPLOCATION("SW2:5,6,7,8") \
+	PORT_DIPNAME( 0xf000, 0xf000, DEF_STR( Coinage ) ) PORT_CONDITION("DSW", 0x0800, NOTEQUALS, 0x0000)  PORT_DIPLOCATION("SW2:5,6,7,8") \
 	PORT_DIPSETTING(      0xa000, DEF_STR( 6C_1C ) ) \
 	PORT_DIPSETTING(      0xb000, DEF_STR( 5C_1C ) ) \
 	PORT_DIPSETTING(      0xc000, DEF_STR( 4C_1C ) ) \
diff -Nru src-old/mame/includes/lockon.h src/mame/includes/lockon.h
--- src-old/mame/includes/lockon.h	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/includes/lockon.h	2012-05-02 14:10:49.000000000 +0200
@@ -33,19 +33,15 @@
 	required_shared_ptr<UINT16> m_ground_ram;
 	required_shared_ptr<UINT16> m_object_ram;
 
-	size_t	m_hudram_size;
-	size_t	m_objectram_size;
-	size_t	m_groundram_size;
-
 	/* video-related */
-	tilemap_t   *m_tilemap;
-	UINT8	      m_ground_ctrl;
-	UINT16      m_scroll_h;
-	UINT16      m_scroll_v;
+	tilemap_t		*m_tilemap;
+	UINT8			m_ground_ctrl;
+	UINT16			m_scroll_h;
+	UINT16			m_scroll_v;
 	bitmap_ind16    *m_front_buffer;
 	bitmap_ind16    *m_back_buffer;
-	emu_timer   *m_bufend_timer;
-	emu_timer   *m_cursor_timer;
+	emu_timer		*m_bufend_timer;
+	emu_timer		*m_cursor_timer;
 
 	/* Rotation Control */
 	UINT16      m_xsal;
@@ -59,7 +55,7 @@
 
 	/* Object palette RAM control */
 	UINT32      m_iden;
-	UINT8	*     m_obj_pal_ram;
+	UINT8		*m_obj_pal_ram;
 	UINT32      m_obj_pal_latch;
 	UINT32      m_obj_pal_addr;
 
diff -Nru src-old/mame/includes/lordgun.h src/mame/includes/lordgun.h
--- src-old/mame/includes/lordgun.h	2012-04-16 01:48:57.000000000 +0200
+++ src/mame/includes/lordgun.h	2012-05-03 11:00:08.000000000 +0200
@@ -55,7 +55,7 @@
 /*----------- defined in video/lordgun.c -----------*/
 
 
-float lordgun_crosshair_mapper(const input_field_config *field, float linear_value);
+float lordgun_crosshair_mapper(const ioport_field *field, float linear_value);
 void lordgun_update_gun(running_machine &machine, int i);
 
 VIDEO_START( lordgun );
diff -Nru src-old/mame/includes/mario.h src/mame/includes/mario.h
--- src-old/mame/includes/mario.h	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/includes/mario.h	2012-04-27 01:30:19.000000000 +0200
@@ -57,7 +57,6 @@
 
 	required_shared_ptr<UINT8> m_spriteram;
 	required_shared_ptr<UINT8> m_videoram;
-	size_t	m_spriteram_size;
 	tilemap_t *m_bg_tilemap;
 	int m_monitor;
 
diff -Nru src-old/mame/includes/megadriv.h src/mame/includes/megadriv.h
--- src-old/mame/includes/megadriv.h	2012-04-16 10:28:56.000000000 +0200
+++ src/mame/includes/megadriv.h	2012-05-07 08:57:50.000000000 +0200
@@ -103,10 +103,83 @@
 {
 public:
 	md_boot_state(const machine_config &mconfig, device_type type, const char *tag)
-	: md_base_state(mconfig, type, tag) { }
+	: md_base_state(mconfig, type, tag) { m_protcount = 0;}
 
 	// bootleg specific
 	int m_aladmdb_mcu_port;
+
+	int m_protcount;
+
+	// jzth protection
+	DECLARE_WRITE16_MEMBER( bl_710000_w )
+	{
+		int pc = cpu_get_pc(&space.device());
+
+		logerror("%06x writing to bl_710000_w %04x %04x\n", pc, data, mem_mask);
+
+		// protection value is read from  0x710000 after a series of writes.. and stored at ff0007
+		// startup
+		/*
+        059ce0 writing to bl_710000_w ff08 ffff
+        059d04 writing to bl_710000_w 000a ffff
+        059d04 writing to bl_710000_w 000b ffff
+        059d04 writing to bl_710000_w 000c ffff
+        059d04 writing to bl_710000_w 000f ffff
+        059d1c writing to bl_710000_w ff09 ffff
+        059d2a reading from bl_710000_r  (wants 0xe)
+        059ce0 writing to bl_710000_w ff08 ffff
+        059d04 writing to bl_710000_w 000a ffff
+        059d04 writing to bl_710000_w 000b ffff
+        059d04 writing to bl_710000_w 000c ffff
+        059d04 writing to bl_710000_w 000f ffff
+        059d1c writing to bl_710000_w ff09 ffff
+        059d2a reading from bl_710000_r  (wants 0xe)
+        */
+		// before lv stage 3
+		/*
+        059ce0 writing to bl_710000_w 0008 ffff
+        059d04 writing to bl_710000_w 000b ffff
+        059d04 writing to bl_710000_w 000f ffff
+        059d1c writing to bl_710000_w ff09 ffff
+        059d2a reading from bl_710000_r  (wants 0x4)
+        */
+		// start level 3
+		/*
+        059ce0 writing to bl_710000_w ff08 ffff
+        059d04 writing to bl_710000_w 000b ffff
+        059d04 writing to bl_710000_w 000c ffff
+        059d04 writing to bl_710000_w 000e ffff
+        059d1c writing to bl_710000_w ff09 ffff
+        059d2a reading from bl_710000_r  (wants 0x5)
+
+        // after end sequence
+        059ce0 writing to bl_710000_w 0008 ffff
+        059d04 writing to bl_710000_w 000a ffff
+        059d04 writing to bl_710000_w 000b ffff
+        059d04 writing to bl_710000_w 000c ffff
+        059d04 writing to bl_710000_w 000f ffff
+        059d1c writing to bl_710000_w ff09 ffff
+        059d2a reading from bl_710000_r  (wants 0xe)
+
+        */
+		m_protcount++;
+	}
+
+
+	DECLARE_READ16_MEMBER( bl_710000_r )
+	{
+		UINT16 ret;
+		int pc = cpu_get_pc(&space.device());
+		logerror("%06x reading from bl_710000_r\n", pc);
+
+		if (m_protcount==6) { ret = 0xe; }
+		else if (m_protcount==5) { ret = 0x5; }
+		else if (m_protcount==4) { ret = 0x4; }
+		else ret = 0xf;
+
+		m_protcount = 0;
+		return ret;
+	}
 };
 
 class segac2_state : public md_base_state
diff -Nru src-old/mame/includes/msisaac.h src/mame/includes/msisaac.h
--- src-old/mame/includes/msisaac.h	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/includes/msisaac.h	2012-05-02 14:11:19.000000000 +0200
@@ -17,10 +17,6 @@
 	required_shared_ptr<UINT8> m_videoram3;
 	required_shared_ptr<UINT8> m_videoram2;
 
-	size_t      m_videoram_size;
-	size_t      m_spriteram_size;
-	size_t      m_spriteram2_size;
-
 	/* video-related */
 	bitmap_ind16    *m_tmp_bitmap1;
 	bitmap_ind16    *m_tmp_bitmap2;
diff -Nru src-old/mame/includes/neogeo.h src/mame/includes/neogeo.h
--- src-old/mame/includes/neogeo.h	2012-04-09 14:55:12.000000000 +0200
+++ src/mame/includes/neogeo.h	2012-04-29 22:57:03.000000000 +0200
@@ -20,6 +20,10 @@
 #define NEOGEO_VBLANK_RELOAD_HPOS               (0x11f)
 
 #define NEOGEO_BANK_AUDIO_CPU_CART_BANK         "audio_cart"
+#define NEOGEO_BANK_AUDIO_CPU_CART_BANK0        "audio_cart0"
+#define NEOGEO_BANK_AUDIO_CPU_CART_BANK1        "audio_cart1"
+#define NEOGEO_BANK_AUDIO_CPU_CART_BANK2        "audio_cart2"
+#define NEOGEO_BANK_AUDIO_CPU_CART_BANK3        "audio_cart3"
 /* do not use 2, 3 and 4 */
 #define NEOGEO_BANK_CARTRIDGE                   "cartridge"
 #define NEOGEO_BANK_BIOS                        "bios"
diff -Nru src-old/mame/includes/pgm.h src/mame/includes/pgm.h
--- src-old/mame/includes/pgm.h	2012-04-16 10:28:56.000000000 +0200
+++ src/mame/includes/pgm.h	2012-04-26 02:43:00.000000000 +0200
@@ -138,7 +138,7 @@
 	UINT16        m_pgm_arm_type1_highlatch_68k_w;
 	UINT16        m_pgm_arm_type1_lowlatch_68k_w;
 	UINT32        m_pgm_arm_type1_counter;
-	required_shared_ptr<UINT32> m_arm7_shareram;
+	optional_shared_ptr<UINT32> m_arm7_shareram;
 
 	cpu_device *m_prot;
 };
diff -Nru src-old/mame/includes/scramble.h src/mame/includes/scramble.h
--- src-old/mame/includes/scramble.h	2012-04-19 09:47:35.000000000 +0200
+++ src/mame/includes/scramble.h	2012-04-27 19:24:02.000000000 +0200
@@ -8,7 +8,7 @@
 		: galaxold_state(mconfig, type, tag),
 		  m_soundram(*this, "soundram") { }
 
-	required_shared_ptr<UINT8> m_soundram;
+	optional_shared_ptr<UINT8> m_soundram;
 	UINT8 m_cavelon_bank;
 	UINT8 m_security_2B_counter;
 	UINT8 m_xb;
diff -Nru src-old/mame/includes/toaplipt.h src/mame/includes/toaplipt.h
--- src-old/mame/includes/toaplipt.h	2011-11-02 12:32:30.000000000 +0100
+++ src/mame/includes/toaplipt.h	2012-05-03 11:00:08.000000000 +0200
@@ -91,22 +91,22 @@
 
 #define TOAPLAN_COINAGE_DUAL_LOC(DIP, MASK, WORLD, DIPBANK) \
 	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coin_A ) ) PORT_DIPLOCATION(#DIPBANK":!5,!6") \
-	PORT_DIPSETTING(    0x30, DEF_STR( 4C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x20, DEF_STR( 3C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x30, DEF_STR( 4C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x20, DEF_STR( 3C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) \
-	PORT_DIPSETTING(    0x30, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x30, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
 	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Coin_B ) ) PORT_DIPLOCATION(#DIPBANK":!7,!8") \
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0xc0, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_6C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0xc0, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_6C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD)
 
 /* without location */
 #define TOAPLAN_COINAGE_JAPAN_COIN_A \
@@ -147,22 +147,22 @@
 
 #define TOAPLAN_COINAGE_DUAL(DIP, MASK, WORLD) \
 	PORT_DIPNAME( 0x30, 0x00, DEF_STR( Coin_A ) ) \
-	PORT_DIPSETTING(    0x30, DEF_STR( 4C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x20, DEF_STR( 3C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x30, DEF_STR( 4C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x20, DEF_STR( 3C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x20, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) \
-	PORT_DIPSETTING(    0x30, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x30, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x10, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
 	PORT_DIPNAME( 0xc0, 0x00, DEF_STR( Coin_B ) ) \
-	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0xc0, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_NOTEQUALS,WORLD) \
-	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD) \
-	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_6C ) ) PORT_CONDITION(#DIP,MASK,PORTCOND_EQUALS,WORLD)
+	PORT_DIPSETTING(    0x80, DEF_STR( 2C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0xc0, DEF_STR( 2C_3C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,NOTEQUALS,WORLD) \
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_2C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0x80, DEF_STR( 1C_4C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD) \
+	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_6C ) ) PORT_CONDITION(#DIP,MASK,EQUALS,WORLD)
 
 
 /************************** Difficulty Dip Switches ***************************/
diff -Nru src-old/mame/includes/vectrex.h src/mame/includes/vectrex.h
--- src-old/mame/includes/vectrex.h	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/includes/vectrex.h	2012-05-03 20:17:43.000000000 +0200
@@ -26,6 +26,7 @@
 		m_gce_vectorram(*this, "gce_vectorram"){ }
 
 	required_shared_ptr<UINT8> m_gce_vectorram;
+	int m_64k_cart;
 	int m_imager_status;
 	UINT32 m_beam_color;
 	unsigned char m_via_out[2];
diff -Nru src-old/mame/includes/williams.h src/mame/includes/williams.h
--- src-old/mame/includes/williams.h	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/includes/williams.h	2012-05-05 16:57:34.000000000 +0200
@@ -13,7 +13,7 @@
 public:
 	williams_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		  m_cvsd_sound(*this, "cvsd"),
+		  m_cvsd_sound(*this, "cvsd_sound"),
 		  m_nvram(*this, "nvram") ,
 		m_videoram(*this, "videoram"),
 		m_blaster_palette_0(*this, "blaster_pal0"),
diff -Nru src-old/mame/layout/awpdmd.lay src/mame/layout/awpdmd.lay
--- src-old/mame/layout/awpdmd.lay	2010-09-01 12:17:16.000000000 +0200
+++ src/mame/layout/awpdmd.lay	2012-04-30 21:59:48.000000000 +0200
@@ -20,394 +20,14 @@
 	</dotmatrix>
 	</element>
 
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
 
+
 	<view name="AWP Simulated Video (Reels and Lamp Matrix)">
 		<backdrop name="matrix0" element="matrix" state="0">
 			<bounds x="150" y="60" width="8" height="1"/>
diff -Nru src-old/mame/layout/awpvid14.lay src/mame/layout/awpvid14.lay
--- src-old/mame/layout/awpvid14.lay	2009-02-03 00:52:37.000000000 +0100
+++ src/mame/layout/awpvid14.lay	2012-04-30 21:59:48.000000000 +0200
@@ -14,393 +14,13 @@
 			<color red="0.0" green="1.0" blue="0.0" />
 		</rect>
 	</element>
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
+
 	<element name="vfd0">
 	<led14segsc>
 			<color red="0" green="0.6" blue="1.0" />
diff -Nru src-old/mame/layout/awpvid16.lay src/mame/layout/awpvid16.lay
--- src-old/mame/layout/awpvid16.lay	2009-02-03 00:52:37.000000000 +0100
+++ src/mame/layout/awpvid16.lay	2012-04-30 21:59:48.000000000 +0200
@@ -14,393 +14,13 @@
 			<color red="0.0" green="1.0" blue="0.0" />
 		</rect>
 	</element>
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
+
 	<element name="vfd0">
 	<led16segsc>
 			<color red="0" green="0.6" blue="1.0" />
diff -Nru src-old/mame/layout/bfm_sc1.lay src/mame/layout/bfm_sc1.lay
--- src-old/mame/layout/bfm_sc1.lay	2011-04-15 13:59:49.000000000 +0200
+++ src/mame/layout/bfm_sc1.lay	2012-05-07 08:57:50.000000000 +0200
@@ -19,391 +19,12 @@
 			<color red="0" green="0.6" blue="1.0" />
 	</led14segsc>
 	</element>
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
 
 	<view name="Full Output">
diff -Nru src-old/mame/layout/bfm_sc4.lay src/mame/layout/bfm_sc4.lay
--- src-old/mame/layout/bfm_sc4.lay	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/layout/bfm_sc4.lay	2012-05-07 08:57:50.000000000 +0200
@@ -14,14 +14,77 @@
 			<color red="0.0" green="1.0" blue="0.0" />
 		</rect>
 	</element>
+
+  <element name="reellamp">
+    <rect state ="0">
+      <bounds x="0" y="0" width="7" height="7" />
+      <color red="0.1" green="0.1" blue="0.1" />
+    </rect>
+    <rect state ="1">
+      <bounds x="0" y="0" width="7" height="7" />
+      <color red="0.6" green="0.6" blue="0.6" />
+    </rect>
+    <rect state ="2">
+      <bounds x="0" y="0" width="7" height="7" />
+      <color red="0.6" green="0.6" blue="0.6" />
+    </rect>
+  </element>
+
   <element name="Steppers" defstate="0">
-    <simplecounter maxstate="999" digits="2">
+    <simplecounter maxstate="999" digits="3">
       <color red="1.0" green="1.0" blue="1.0" />
-      <bounds x="0" y="0.1" width="1" height="1" />
+      <bounds x="0" y="0" width="1" height="1" />
     </simplecounter>
   </element>
 
-	<element name="vfd0">
+
+
+  <!-- a stateoffset of 682 will shift us by 1 step on a 96 step reel (0x10000/96) which seems a good default alignment for 96 step / 16 symbol reels -->
+  <element name="SteppersReel1" defstate="0">
+    <reel stateoffset="682" symbollist="Fruit1:image11.png,Fruit2:image12.png,Fruit3:image13.png,Fruit4:image14.png,Fruit5:image15.png,Fruit6:image16.png,Fruit7:image17.png,Fruit8:image18.png,Fruit9:image19.png,Fruit10:image110.png,Fruit11:image111.png,Fruit12:image112.png,Fruit13:image113.png,Fruit14:image114.png,Fruit15:image115.png,Fruit16:image116.png">
+      <color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+  <element name="SteppersReel2" defstate="0">
+    <reel stateoffset="682" symbollist="Fruit1,Fruit2,Fruit3,Fruit4,Fruit5,Fruit6,Fruit7,Fruit8,Fruit9,Fruit10,Fruit11,Fruit12,Fruit13,Fruit14,Fruit15,Fruit16">
+      "<color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+  <element name="SteppersReel3" defstate="0">
+    <reel stateoffset="682" symbollist="Fruit1,Fruit2,Fruit3,Fruit4,Fruit5,Fruit6,Fruit7,Fruit8,Fruit9,Fruit10,Fruit11,Fruit12,Fruit13,Fruit14,Fruit15,Fruit16">
+      <color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+  <element name="SteppersReel4" defstate="0">
+    <reel stateoffset="682" symbollist="Fruit1,Fruit2,Fruit3,Fruit4,Fruit5,Fruit6,Fruit7,Fruit8,Fruit9,Fruit10,Fruit11,Fruit12,Fruit13,Fruit14,Fruit15,Fruit16">
+      <color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+  <element name="SteppersReel5" defstate="0">
+    <reel symbollist="Example1,Example2,Example3,Example4,Example5,Example6,Example7,Example8,Example9,Example10,Example11,Example12">
+      <color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+  <element name="SteppersReel6" defstate="0">
+    <reel symbollist="Example1,Example2,Example3,Example4,Example5,Example6,Example7,Example8,Example9,Example10,Example11,Example12">
+      <color red="1.0" green="1.0" blue="1.0" />
+      <bounds x="0" y="0" width="1" height="1" />
+    </reel>
+  </element>
+
+
+
+  <element name="vfd0">
 	  <led14segsc>
 			  <color red="0" green="0.6" blue="1.0" />
 	  </led14segsc>
@@ -81,29 +144,93 @@
 		<backdrop name="vfd15" element="vfd0" state="0">
 			<bounds x="345" y="200" width="9" height="17"/>
 		</backdrop>
-		<backdrop name="reel1" element="Steppers" state="0">
-			<bounds x="210" y="300" width="50" height="50"/>
+
+
+    <backdrop name="reel1" element="Steppers" state="0">
+			<bounds x="250" y="350" width="10" height="5"/>
 		</backdrop>
 		<backdrop name="reel2" element="Steppers" state="0">
-			<bounds x="260" y="300" width="50" height="50"/>
+			<bounds x="300" y="350" width="10" height="5"/>
 		</backdrop>
 		<backdrop name="reel3" element="Steppers" state="0">
-			<bounds x="310" y="300" width="50" height="50"/>
+			<bounds x="350" y="350" width="10" height="5"/>
 		</backdrop>
+
 		<backdrop name="reel4" element="Steppers" state="0">
-			<bounds x="210" y="360" width="50" height="50"/>
+			<bounds x="250" y="410" width="10" height="5"/>
 		</backdrop>
 		<backdrop name="reel5" element="Steppers" state="0">
-			<bounds x="260" y="360" width="50" height="50"/>
+			<bounds x="300" y="410" width="10" height="5"/>
 		</backdrop>
 		<backdrop name="reel6" element="Steppers" state="0">
-			<bounds x="310" y="360" width="50" height="50"/>
+			<bounds x="350" y="410" width="10" height="5"/>
 		</backdrop>
 
+    <!-- these are typically the reel lamps, so duplicate them here -->
+    <backdrop name="lamp32" element="reellamp" state="0">
+      <bounds x="210" y="300" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp33" element="reellamp" state="0">
+      <bounds x="210" y="317" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp34" element="reellamp" state="0">
+      <bounds x="210" y="333" width="50" height="17"/>
+    </backdrop>
+
+    <backdrop name="lamp35" element="reellamp" state="0">
+      <bounds x="260" y="300" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp36" element="reellamp" state="0">
+      <bounds x="260" y="317" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp37" element="reellamp" state="0">
+      <bounds x="260" y="333" width="50" height="17"/>
+    </backdrop>
+
+    <backdrop name="lamp48" element="reellamp" state="0">
+      <bounds x="310" y="300" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp49" element="reellamp" state="0">
+      <bounds x="310" y="317" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp50" element="reellamp" state="0">
+      <bounds x="310" y="333" width="50" height="17"/>
+    </backdrop>
+
+    <backdrop name="lamp51" element="reellamp" state="0">
+      <bounds x="210" y="360" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp52" element="reellamp" state="0">
+      <bounds x="210" y="377" width="50" height="17"/>
+    </backdrop>
+    <backdrop name="lamp53" element="reellamp" state="0">
+      <bounds x="210" y="393" width="50" height="17"/>
+    </backdrop>
+
+    <backdrop name="sreel1" element="SteppersReel1" state="0">
+      <bounds x="210" y="300" width="50" height="50"/>
+    </backdrop>
+    <backdrop name="sreel2" element="SteppersReel2" state="0">
+      <bounds x="260" y="300" width="50" height="50"/>
+    </backdrop>
+    <backdrop name="sreel3" element="SteppersReel3" state="0">
+      <bounds x="310" y="300" width="50" height="50"/>
+    </backdrop>
+
+    <backdrop name="sreel4" element="SteppersReel4" state="0">
+      <bounds x="210" y="360" width="50" height="50"/>
+    </backdrop>
+    <backdrop name="sreel5" element="SteppersReel5" state="0">
+      <bounds x="260" y="360" width="50" height="50"/>
+    </backdrop>
+    <backdrop name="sreel6" element="SteppersReel6" state="0">
+      <bounds x="310" y="360" width="50" height="50"/>
+    </backdrop>
+
 
 
 
-		<backdrop name="lamp0" element="matrixlamp" state="0">
+    <backdrop name="lamp0" element="matrixlamp" state="0">
 			<bounds x="0" y="0" width="7" height="7"/>
 		</backdrop>
 		<backdrop name="lamp1" element="matrixlamp" state="0">
diff -Nru src-old/mame/layout/drwho.lay src/mame/layout/drwho.lay
--- src-old/mame/layout/drwho.lay	2009-02-03 00:52:37.000000000 +0100
+++ src/mame/layout/drwho.lay	2012-04-30 21:59:48.000000000 +0200
@@ -1,10 +1,5 @@
 <?xml version="1.0"?>
 <mamelayout version="2">
-	<element name="TotalReels" defstate="4"/>
-	<element name="ReelSteps1" defstate="6"/>
-	<element name="ReelSymbols1" defstate="3"/>
-	<element name="ReelSteps4" defstate="4"/>
-	<element name="ReelSymbols4" defstate="1"/>
 	<element name="vfd0">
 	<led14segsc>
 			<color red="0" green="0.6" blue="1.0" />
@@ -24,1552 +19,34 @@
 			<color red="0.0" green="1.0" blue="0.0"/>
 		</rect>
 	</element>
-	<element name="Reel1" defstate="96">
-		<text string="Cherry" state="0">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="1">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="2">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="3">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="4">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="5">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="6">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="7">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar K9" state="8">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="9">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="10">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="11">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="12">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="13">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="14">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="15">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="16">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="17">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="18">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="19">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="20">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="21">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="22">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="23">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="24">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="25">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(3)" state="26">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="27">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="28">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="29">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="30">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="31">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="32">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="33">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="34">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="35">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="36">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="37">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="38">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="39">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="40">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="41">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="42">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="43">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="44">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="45">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="46">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="47">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="48">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="49">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="50">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="51">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="52">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="53">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="54">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="55">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="56">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="57">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="58">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="59">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="60">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="61">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="62">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="63">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="64">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="65">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="66">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="67">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(2)" state="68">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="69">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="70">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="71">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="72">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="73">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="74">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="75">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="76">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="77">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="78">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="79">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="80">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="81">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="82">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="83">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="84">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="85">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="86">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="87">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="88">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="89">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="90">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="91">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="92">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="93">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="94">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="95">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
+
+
+	<element name="SteppersReel1" defstate="0">
+	<reel stateoffset="-6826" symbollist="Double Bar:DW_DBar.png,Blue 7:DW_Blue7.png,Single Bar (K9):DW_SBar_K9.png,Cherry:DW_Cherry.png,Red 7:DW_Red7.png,Cherry (2):DW_Cherry_2.png,Triple Bar:DW_TBar.png,Double Bar:DW_DBar.png,Single Bar (2):DW_SBar_2.png,Cherry:DW_Cherry.png,Double Bar:DW_DBar.png,Blue 7:DW_Blue7.png,Triple Bar (1):DW_TBar_1.png,Single Bar:DW_SBar.png,Red 7:DW_Red7.png,Cherry (3):DW_Cherry_3.png" reelreversed="1">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
 	</element>
 
-	<element name="Reel2" defstate="96">
-		<text string="Cherry" state="0">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="1">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="2">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="3">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="4">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="5">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="6">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="7">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="8">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="9">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="10">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="11">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="12">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="13">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="14">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="15">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="16">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="17">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="18">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="19">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="20">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="21">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="22">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="23">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="24">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="25">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="26">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="27">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="28">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="29">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="30">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="31">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="32">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="33">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="34">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="35">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="36">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="37">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="38">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="39">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="40">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="41">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="42">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="43">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar(1)" state="44">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="45">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="46">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="47">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="48">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="49">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="50">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="51">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="52">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="53">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="54">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="55">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar" state="56">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="57">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="58">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="59">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="60">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="61">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry K9" state="62">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="63">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="64">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="65">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="66">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="67">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="68">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="69">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="70">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="71">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="72">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="73">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="74">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="75">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="76">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="77">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="78">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="79">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="80">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="81">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="82">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="83">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="84">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="85">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="86">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="87">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="88">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="89">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="90">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="91">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="92">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="93">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="94">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="95">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
+	<element name="SteppersReel2" defstate="0">
+	<reel stateoffset="-6826" symbollist="Double Bar:DW_DBar.png,Triple Bar:DW_TBar.png,Single Bar (1):DW_Sbar_1.png,Cherry:DW_Cherry.png,Red 7:DW_Red7.png,Single Bar:DW_Sbar.png,Triple Bar:DW_TBar.png,Double Bar (3):DW_DBar_3.png,Single Bar:DW_Sbar.png,Cherry (K9):DW_Cherry_K9.png,Double Bar:DW_DBar.png,Blue 7:DW_Blue7.png,Triple Bar (1):DW_TBar_1.png,Single Bar:DW_Sbar.png,Blue 7:DW_Blue7.png,Cherry (2):DW_Cherry_2.png"  reelreversed="1">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
 	</element>
 
-	<element name="Reel3" defstate="96">
-		<text string="Cherry(2)" state="0">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="1">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="2">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="3">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="4">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="5">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="6">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="7">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="8">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="9">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="10">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="11">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="12">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="13">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="14">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="15">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="16">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="17">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="18">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="19">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(3)" state="20">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="21">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="22">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="23">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="24">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="25">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="26">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="27">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="28">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="29">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="30">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="31">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="32">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="33">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="34">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="35">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="36">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="37">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar(1)" state="38">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="39">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="40">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="41">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="42">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="43">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="44">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="45">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="46">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="47">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="48">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="49">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Blue 7" state="50">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="51">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="52">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="53">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="54">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="55">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(2)" state="56">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="57">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="58">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="59">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="60">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="61">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="62">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="63">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="64">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="65">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="66">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="67">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Single Bar" state="68">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="69">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="70">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="71">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="72">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="73">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Double Bar(1)" state="74">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="75">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="76">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="77">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="78">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="79">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Triple Bar" state="80">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="81">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="82">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="83">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="84">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="85">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry" state="86">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="87">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="88">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="89">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="90">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="91">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Red 7" state="92">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="93">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="94">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="Cherry(2)" state="95">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
+	<element name="SteppersReel3" defstate="0">
+	<reel stateoffset="-6826" symbollist="Double Bar (3):DW_DBar_3.png,Blue 7:DW_Blue7.png,Single Bar:DW_SBar.png,Cherry (2):DW_Cherry_2.png,Red 7:DW_Red7.png,Cherry:DW_Cherry.png,Triple Bar:DW_TBar.png,Double Bar (1):DW_DBar_1.png,Single Bar:DW_SBar.png,Cherry:DW_Cherry.png,Double Bar (2):DW_DBar_2.png,Blue 7:DW_Blue7.png,Triple Bar:DW_TBar.png,Single Bar (1):DW_SBar_1.png,Red 7:DW_Red7.png,Cherry:DW_Cherry.png"  reelreversed="1">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
 	</element>
 
-	<element name="Reel4" defstate="96">
-		<text string="4  3" state="0">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="1">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="2">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="3">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="4">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="5">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="6">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="7">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="8">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="9">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="10">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="11">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="12">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="13">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="14">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="15">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="16">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="17">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="18">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="19">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="20">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="21">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="22">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="23">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="24">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="25">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="26">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="27">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="28">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="29">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="30">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="31">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="32">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="33">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="34">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="35">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="36">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="37">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="38">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="39">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  1" state="40">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  1" state="41">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  1" state="42">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  1" state="43">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="44">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="45">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="46">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="47">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="48">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="49">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="50">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4  3" state="51">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="52">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="53">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="54">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="4" state="55">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="56">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="57">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="58">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5  4" state="59">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="60">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="61">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="62">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="5" state="63">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="64">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="65">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="66">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6  5" state="67">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="68">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="69">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="70">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="6" state="71">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="72">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="73">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="74">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1  6" state="75">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="76">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="77">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="78">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="1" state="79">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="80">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="81">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="82">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2  1" state="83">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="84">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="85">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="86">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="2" state="87">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  2" state="88">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  2" state="89">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  2" state="90">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3  2" state="91">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="92">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="93">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="94">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
-		<text string="3" state="95">
-			<color red="1.0" green="1.0" blue="1.0"/>
-			<bounds x="0" y="0.1" width="1" height="1"/>
-		</text>
+	<element name="SteppersReel4" defstate="0">
+	<reel stateoffset="-8192" symbollist="5:dice5.png,4:dice4.png,3:dice3.png,2:dice2.png,1:dice1.png,6:dice6.png,5:dice5.png,4:dice4.png,3:dice3.png,2:dice2.png,1:dice1.png,6:dice6.png" reelreversed="1" numsymbolsvisible="1">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
 	</element>
 
 	<view name="AWP Simulated Video (Lamp Matrix and Reels)">
@@ -1621,44 +98,18 @@
 		<backdrop name="vfd15" element="vfd0" state="0">
 			<bounds x="145" y="200" width="9" height="17"/>
 		</backdrop>
-		<backdrop name="TotalReels" element="TotalReels"/>
-		<backdrop name="ReelSteps2" element="ReelSteps1"/>
-		<backdrop name="ReelSteps3" element="ReelSteps1"/>
-		<backdrop name="ReelSteps1" element="ReelSteps1"/>
-		<backdrop name="ReelSteps4" element="ReelSteps4"/>
-		<backdrop name="ReelSymbols1" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols2" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols3" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols4" element="ReelSymbols4"/>
-		<backdrop name="reel1a1" element="Reel1" state="96">
-			<bounds x="85" y="463" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel1" element="Reel1" state="96">
-			<bounds x="85" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel1b1" element="Reel1" state="96">
-			<bounds x="85" y="520.6666" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel2a1" element="Reel2" state="96">
-			<bounds x="161" y="463" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel2" element="Reel2" state="96">
-			<bounds x="161" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel2b1" element="Reel2" state="96">
-			<bounds x="161" y="520.6666" width="49" height="29.3333"/>
-		</backdrop>
-		<backdrop name="reel3a1" element="Reel3" state="96">
-			<bounds x="236" y="463" width="49" height="29.3333"/>
+
+		<backdrop name="sreel1" element="SteppersReel1" state="0">
+			<bounds x="85" y="491.3333" width="50" height="90"/>
 		</backdrop>
-		<backdrop name="reel3" element="Reel3" state="96">
-			<bounds x="236" y="491.3333" width="49" height="29.3333"/>
+		<backdrop name="sreel2" element="SteppersReel2" state="0">
+			<bounds x="161" y="491.3333" width="50" height="90"/>
 		</backdrop>
-		<backdrop name="reel3b1" element="Reel3" state="96">
-			<bounds x="236" y="520.6666" width="49" height="29.3333"/>
+		<backdrop name="sreel3" element="SteppersReel3" state="0">
+			<bounds x="236" y="491.3333" width="50" height="90"/>
 		</backdrop>
-		<backdrop name="reel4" element="Reel4" state="0">
-			<bounds x="277" y="214" width="39" height="40"/>
+		<backdrop name="sreel4" element="SteppersReel4" state="0">
+			<bounds x="277" y="214" width="40" height="80"/>
 		</backdrop>
 		<backdrop name="lamp0" element="matrixlamp" state="0">
 			<bounds x="0" y="0" width="7" height="7"/>
diff -Nru src-old/mame/layout/gamball.lay src/mame/layout/gamball.lay
--- src-old/mame/layout/gamball.lay	2011-04-18 20:56:40.000000000 +0200
+++ src/mame/layout/gamball.lay	2012-04-30 21:59:48.000000000 +0200
@@ -1,9 +1,5 @@
 <?xml version="1.0"?>
 <mamelayout version="2">
-	<element name="TotalReels" defstate="4"/>
-	<element name="ReelSteps1" defstate="8"/>
-	<element name="ReelSymbols1" defstate="3"/>
-	<element name="ReelSteps2" defstate="6"/>
 	<element name="digit">
 	<led7seg>
 			<color red="1.0" green="0.0" blue="0.0" />
@@ -257,1552 +253,33 @@
 			<bounds x="0" y="0.1" width="1" height="1" />
 		</text>
 	</element>
-	<element name="Reel1" defstate="96">
-		<text string="3.00 RPT" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="3.00 RPT" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="POT" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="JACK" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="LOSE" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60p" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80p" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.00" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.20" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="1.60" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.00" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.20" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="2.40" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-	</element>
-
-	<element name="Reel2" defstate="96">
-		<text string="7" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-	</element>
-
-	<element name="Reel3" defstate="96">
-		<text string="7" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-	</element>
-
-	<element name="Reel4" defstate="96">
-		<text string="Bell" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Melon" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Cherry" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bar" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="Bell" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="7" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+
+	<element name="SteppersReel1" defstate="0">
+	<reel stateoffset="0" symbollist="3.00 RPT:300p.png,2.40:240.png,2.20:220.png,2.00:200.png,1.60:160.png,1.20:120.png,1.00:100p.png,80p:80p.png,60p:60p.png,LOSE:lose.png,JACK:jack.png,POT:pot.png" reelreversed="1" numsymbolsvisible="2">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
+	</element>
+
+	<element name="SteppersReel2" defstate="0">
+	<reel stateoffset="0" symbollist="Melon:melon.png,7:7.png,Cherry:cherry.png,Bar:bar.png,Melon:melon.png,7:7.png,Bar:bar.png,Bell:bell.png,Cherry:cherry.png,Melon:melon.png,Bell:bell.png,7:7.png,Bar:bar.png,Cherry:cherry.png,Bell:bell.png,Bar:bar.png" reelreversed="1" numsymbolsvisible="3">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
+	</element>
+
+	<element name="SteppersReel3" defstate="0">
+	<reel stateoffset="0" symbollist="Bell:bell.png,7:7.png,Melon:melon.png,Bell:bell.png,Cherry:cherry.png,Bar:bar.png,Bell:bell.png,Melon:melon.png,Bar:bar.png,Cherry:cherry.png,7:7.png,Melon:melon.png,Bar:bar.png,Cherry:cherry.png,Melon:melon.png,Cherry:cherry.png" reelreversed="1" numsymbolsvisible="3">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
+	</element>
+
+	<element name="SteppersReel4" defstate="0">
+	<reel stateoffset="0" symbollist="Melon:melon.png,Bell:bell.png,7:7.png,Bell:bell.png,Bar:bar.png,7:7.png,Cherry:cherry.png,Melon:melon.png,Bell:bell.png,Cherry:cherry.png,Bar:bar.png,7:7.png,Melon:melon.png,Cherry:cherry.png,Bell:bell.png,Bar:bar.png" reelreversed="1" numsymbolsvisible="3">
+	<color red="1.0" green="1.0" blue="1.0" />
+	<bounds x="0" y="0" width="1" height="1" />
+	</reel>
 	</element>
 	<element name="vfd0">
 	<led16segsc>
@@ -1811,27 +288,17 @@
 	</element>
 
 	<view name="Gamball AWP Simulated Video (No Artwork)">
-		<backdrop name="TotalReels" element="TotalReels"/>
-		<backdrop name="ReelSteps1" element="ReelSteps1"/>
-		<backdrop name="ReelSteps2" element="ReelSteps2"/>
-		<backdrop name="ReelSteps3" element="ReelSteps2"/>
-		<backdrop name="ReelSteps4" element="ReelSteps2"/>
-		<backdrop name="ReelSymbols1" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols2" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols3" element="ReelSymbols1"/>
-		<backdrop name="ReelSymbols4" element="ReelSymbols1"/>
 		<backdrop name="lamp8" element="reellamp" state="0">
 			<bounds x="85" y="491.3333" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel1" element="Reel1" state="96">
-			<bounds x="85" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp16" element="reellamp" state="0">
 			<bounds x="85" y="520.6666" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel1b1" element="Reel1" state="96">
-			<bounds x="85" y="520.6666" width="49" height="29.3333"/>
+
+		<backdrop name="sreel1" element="SteppersReel1" state="0">
+			<bounds x="85" y="491.3333" width="50" height="58.6666"/>
 		</backdrop>
+
 		<backdrop name="lamp26" element="cancol" state="0" inputtag="BLACK2" inputmask="0x04">
 			<bounds x="10" y="560" width="50" height="30"/>
 		</backdrop>
@@ -1879,58 +346,39 @@
 		<backdrop name="lamp1" element="reellamp" state="0">
 			<bounds x="161" y="463" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel2a1" element="Reel2" state="96">
-			<bounds x="161" y="463" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp9" element="reellamp" state="0">
 			<bounds x="161" y="491.3333" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel2" element="Reel2" state="96">
-			<bounds x="161" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp17" element="reellamp" state="0">
 			<bounds x="161" y="520.6666" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel2b1" element="Reel2" state="96">
-			<bounds x="161" y="520.6666" width="49" height="29.3333"/>
+		<backdrop name="sreel2" element="SteppersReel2" state="96">
+			<bounds x="161" y="463" width="49" height="87.9999"/>
 		</backdrop>
 		<backdrop name="lamp2" element="reellamp" state="0">
 			<bounds x="236" y="463" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel3a1" element="Reel3" state="96">
-			<bounds x="236" y="463" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp10" element="reellamp" state="0">
 			<bounds x="236" y="491.333" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel3" element="Reel3" state="96">
-			<bounds x="236" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp18" element="reellamp" state="0">
 			<bounds x="236" y="520.6666" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel3b1" element="Reel3" state="96">
-			<bounds x="236" y="520.6666" width="49" height="29.3333"/>
+		<backdrop name="sreel3" element="SteppersReel3" state="96">
+			<bounds x="236" y="463" width="49" height="87.9999"/>
 		</backdrop>
 		<backdrop name="lamp3" element="reellamp" state="0">
 			<bounds x="311" y="463" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel4a1" element="Reel4" state="96">
-			<bounds x="311" y="463" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp11" element="reellamp" state="0">
 			<bounds x="311" y="491.3333" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel4" element="Reel4" state="96">
-			<bounds x="311" y="491.3333" width="49" height="29.3333"/>
-		</backdrop>
 		<backdrop name="lamp19" element="reellamp" state="0">
 			<bounds x="311" y="520.6666" width="49" height="29.3333"/>
 		</backdrop>
-		<backdrop name="reel4b1" element="Reel4" state="96">
-			<bounds x="311" y="520.6666" width="49" height="29.3333"/>
+		<backdrop name="sreel4" element="SteppersReel4" state="96">
+			<bounds x="311" y="463" width="49" height="87.9999"/>
 		</backdrop>
-
 		<backdrop name="lamp68" element="1" state="0">
 			<bounds x="64" y="310" width="30" height="20"/>
 		</backdrop>
diff -Nru src-old/mame/layout/gldarrow.lay src/mame/layout/gldarrow.lay
--- src-old/mame/layout/gldarrow.lay	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/layout/gldarrow.lay	2012-05-01 01:31:32.000000000 +0200
@@ -0,0 +1,93 @@
+<?xml version="1.0"?>
+<mamelayout version="2">
+
+	<element name="stop1" defstate="0">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="STOP 1">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0.1" y="0.25" width="0.8" height="0.5" />
+		</text>
+	</element>
+
+	<element name="stop2" defstate="0">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="STOP 2">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0.1" y="0.25" width="0.8" height="0.5" />
+		</text>
+	</element>
+
+	<element name="stop3" defstate="0">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="STOP 3">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0.1" y="0.25" width="0.8" height="0.5" />
+		</text>
+	</element>
+
+	<element name="bet" defstate="0">
+		<rect state="1">
+			<color red="1.0" green="0.6" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.1" blue="0.0" />
+		</rect>
+		<text string="BET">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0.1" y="0.25" width="0.8" height="0.5" />
+		</text>
+	</element>
+
+	<element name="start" defstate="0">
+		<rect state="1">
+			<color red="1.0" green="1.0" blue="1.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.3" blue="0.3" />
+		</rect>
+		<text string="START">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0.1" y="0.25" width="0.8" height="0.5" />
+		</text>
+	</element>
+
+
+	<view name="Button Lamps">
+
+		<screen index="0">
+			<bounds left="0" top="0" right="4" bottom="3" />
+		</screen>
+
+		<bezel name="lamp10" element="stop3">
+			<bounds x="1.5" y="3.05" width="0.40" height="0.24" />
+		</bezel>
+		<bezel name="lamp11" element="stop2">
+			<bounds x="1.0" y="3.05" width="0.40" height="0.24" />
+		</bezel>
+		<bezel name="lamp12" element="stop1">
+			<bounds x="0.5" y="3.05" width="0.40" height="0.24" />
+		</bezel>
+		<bezel name="lamp9" element="start">
+			<bounds x="3.1" y="3.05" width="0.40" height="0.24" />
+		</bezel>
+		<bezel name="lamp8" element="bet">
+			<bounds x="2.6" y="3.05" width="0.40" height="0.24" />
+		</bezel>
+
+	</view>
+</mamelayout>
diff -Nru src-old/mame/layout/mpu4.lay src/mame/layout/mpu4.lay
--- src-old/mame/layout/mpu4.lay	2007-12-17 17:19:59.000000000 +0100
+++ src/mame/layout/mpu4.lay	2012-04-30 21:59:48.000000000 +0200
@@ -19,391 +19,11 @@
 			<color red="0.0" green="1.0" blue="0.0" />
 		</rect>
 	</element>
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
 	<element name="vfd0">
 	<led16segsc>
diff -Nru src-old/mame/layout/mpu4ext.lay src/mame/layout/mpu4ext.lay
--- src-old/mame/layout/mpu4ext.lay	2011-02-06 13:33:04.000000000 +0100
+++ src/mame/layout/mpu4ext.lay	2012-04-30 21:59:48.000000000 +0200
@@ -19,391 +19,11 @@
 			<color red="0.0" green="1.0" blue="0.0" />
 		</rect>
 	</element>
-	<element name="Steppers" defstate="96">
-		<text string="00" state="0">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="01" state="1">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="02" state="2">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="03" state="3">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="04" state="4">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="05" state="5">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="06" state="6">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="07" state="7">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="08" state="8">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="09" state="9">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="10" state="10">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="11" state="11">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="12" state="12">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="13" state="13">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="14" state="14">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="15" state="15">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="16" state="16">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="17" state="17">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="18" state="18">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="19" state="19">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="20" state="20">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="21" state="21">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="22" state="22">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="23" state="23">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="24" state="24">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="25" state="25">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="26" state="26">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="27" state="27">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="28" state="28">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="29" state="29">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="30" state="30">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="31" state="31">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="32" state="32">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="33" state="33">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="34" state="34">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="35" state="35">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="36" state="36">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="37" state="37">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="38" state="38">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="39" state="39">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="40" state="40">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="41" state="41">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="42" state="42">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="43" state="43">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="44" state="44">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="45" state="45">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="46" state="46">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="47" state="47">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="48" state="48">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="49" state="49">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="50" state="50">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="51" state="51">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="52" state="52">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="53" state="53">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="54" state="54">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="55" state="55">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="56" state="56">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="57" state="57">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="58" state="58">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="59" state="59">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="60" state="60">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="61" state="61">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="62" state="62">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="63" state="63">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="64" state="64">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="65" state="65">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="66" state="66">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="67" state="67">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="68" state="68">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="69" state="69">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="70" state="70">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="71" state="71">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="72" state="72">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="73" state="73">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="74" state="74">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="75" state="75">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="76" state="76">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="77" state="77">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="78" state="78">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="79" state="79">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="80" state="80">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="81" state="81">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="82" state="82">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="83" state="83">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="84" state="84">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="85" state="85">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="86" state="86">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="87" state="87">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="88" state="88">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="89" state="89">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="90" state="90">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="91" state="91">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="92" state="92">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="93" state="93">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="94" state="94">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
-		<text string="95" state="95">
-			<color red="1.0" green="1.0" blue="1.0" />
-			<bounds x="0" y="0.1" width="1" height="1" />
-		</text>
+	<element name="Steppers" defstate="0">
+    	<simplecounter maxstate="999" digits="3">
+		<color red="1.0" green="1.0" blue="1.0" />
+		<bounds x="0" y="0" width="1" height="1" />
+		</simplecounter>
 	</element>
 	<element name="vfd0">
 	<led16segsc>
diff -Nru src-old/mame/layout/suprstar.lay src/mame/layout/suprstar.lay
--- src-old/mame/layout/suprstar.lay	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/layout/suprstar.lay	2012-04-23 19:32:45.000000000 +0200
@@ -0,0 +1,130 @@
+<?xml version="1.0"?>
+<mamelayout version="2">
+	<element name="bet" defstate="1">
+		<rect state="1">
+			<color red="0.75" green="1.0" blue="0.75" />
+		</rect>
+		<rect state="0">
+			<color red="0.225" green="0.3" blue="0.225" />
+		</rect>
+		<text string="BET">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.1" width="1" height="0.4" />
+		</text>
+		<text string="HALF">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.5" width="1" height="0.4" />
+		</text>
+	</element>
+
+	<element name="start" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="1.0" blue="1.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.25" green="0.25" blue="0.25" />
+		</rect>
+		<text string="START">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.2" width="1" height="0.6" />
+		</text>
+	</element>
+
+	<element name="cancel" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="0.75" blue="0.75" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.225" blue="0.225" />
+		</rect>
+		<text string="CLEAR">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.1" width="1" height="0.4" />
+		</text>
+		<text string="TAKE">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.5" width="1" height="0.4" />
+		</text>
+	</element>
+
+	<element name="hold1" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="HOLD1">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.2" width="1" height="0.6" />
+		</text>
+	</element>
+
+	<element name="hold2" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="HOLD2">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.2" width="1" height="0.6" />
+		</text>
+	</element>
+
+	<element name="hold3" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="HOLD3">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.2" width="1" height="0.6" />
+		</text>
+	</element>
+
+	<element name="hold4" defstate="1">
+		<rect state="1">
+			<color red="1.0" green="0.0" blue="0.0" />
+		</rect>
+		<rect state="0">
+			<color red="0.3" green="0.0" blue="0.0" />
+		</rect>
+		<text string="HOLD4">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.2" width="1" height="0.6" />
+		</text>
+	</element>
+
+
+	<view name="Button Lamps">
+		<screen index="0">
+			<bounds left="0" top="0" right="3" bottom="4" />
+		</screen>
+		<bezel name="lamp4" element="hold1">
+			<bounds x="0" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+		<bezel name="lamp5" element="hold2">
+			<bounds x="0.4" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+		<bezel name="lamp3" element="hold3">
+			<bounds x="0.8" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+		<bezel name="lamp2" element="hold4">
+			<bounds x="1.2" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+		<bezel name="lamp6" element="cancel">
+			<bounds x="1.6" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+
+		<bezel name="lamp1" element="bet">
+			<bounds x="2.25" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+		<bezel name="lamp0" element="start">
+			<bounds x="2.65" y="4.05" width="0.35" height="0.24" />
+		</bezel>
+	</view>
+</mamelayout>
diff -Nru src-old/mame/machine/acitya.c src/mame/machine/acitya.c
--- src-old/mame/machine/acitya.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/acitya.c	2012-05-03 11:00:08.000000000 +0200
@@ -184,7 +184,7 @@
 MACHINE_START( acitya )
 {
 	pacman_state *state = machine.driver_data<pacman_state>();
-	UINT8 *RAM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *RAM = state->memregion("maincpu")->base();
 
 	/* While the PAL supports up to 16 decryption methods, only four
         are actually used in the PAL.  Therefore, we'll take a little
diff -Nru src-old/mame/machine/ajax.c src/mame/machine/ajax.c
--- src-old/mame/machine/ajax.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/ajax.c	2012-05-03 11:00:08.000000000 +0200
@@ -115,14 +115,14 @@
 			data = machine().rand();
 			break;
 		case 0x04:	/* 2P inputs */
-			data = input_port_read(machine(), "P2");
+			data = ioport("P2")->read();
 			break;
 		case 0x06:	/* 1P inputs + DIPSW #1 & #2 */
 			index = offset & 0x01;
-			data = input_port_read(machine(), (offset & 0x02) ? portnames[2 + index] : portnames[index]);
+			data = ioport((offset & 0x02) ? portnames[2 + index] : portnames[index])->read();
 			break;
 		case 0x07:	/* DIPSW #3 */
-			data = input_port_read(machine(), "DSW3");
+			data = ioport("DSW3")->read();
 			break;
 
 		default:
@@ -197,7 +197,7 @@
 MACHINE_START( ajax )
 {
 	ajax_state *state = machine.driver_data<ajax_state>();
-	UINT8 *MAIN = machine.root_device().memregion("maincpu")->base();
+	UINT8 *MAIN = state->memregion("maincpu")->base();
 	UINT8 *SUB  = state->memregion("sub")->base();
 
 	state->membank("bank1")->configure_entries(0,  9,  &SUB[0x10000], 0x2000);
diff -Nru src-old/mame/machine/amiga.c src/mame/machine/amiga.c
--- src-old/mame/machine/amiga.c	2012-04-16 10:42:02.000000000 +0200
+++ src/mame/machine/amiga.c	2012-05-03 11:00:08.000000000 +0200
@@ -419,7 +419,7 @@
 
 CUSTOM_INPUT_MEMBER( amiga_state::amiga_joystick_convert )
 {
-	UINT8 bits = input_port_read(machine(), (const char *)param);
+	UINT8 bits = ioport((const char *)param)->read();
 	int up = (bits >> 0) & 1;
 	int down = (bits >> 1) & 1;
 	int left = (bits >> 2) & 1;
@@ -1180,21 +1180,21 @@
 		case REG_JOY0DAT:
 			if (state->m_intf->joy0dat_r != NULL)
 				return (*state->m_intf->joy0dat_r)(space->machine());
-			return input_port_read_safe(space->machine(), "JOY0DAT", 0xffff);
+			return state->ioport("JOY0DAT")->read_safe(0xffff);
 
 		case REG_JOY1DAT:
 			if (state->m_intf->joy1dat_r != NULL)
 				return (*state->m_intf->joy1dat_r)(space->machine());
-			return input_port_read_safe(space->machine(), "JOY1DAT", 0xffff);
+			return state->ioport("JOY1DAT")->read_safe(0xffff);
 
 		case REG_POTGOR:
-			return input_port_read_safe(space->machine(), "POTGO", 0x5500);
+			return state->ioport("POTGO")->read_safe(0x5500);
 
 		case REG_POT0DAT:
-			return input_port_read_safe(space->machine(), "POT0DAT", 0x0000);
+			return state->ioport("POT0DAT")->read_safe(0x0000);
 
 		case REG_POT1DAT:
-			return input_port_read_safe(space->machine(), "POT1DAT", 0x0000);
+			return state->ioport("POT1DAT")->read_safe(0x0000);
 
 		case REG_DSKBYTR:
 			return space->machine().device<amiga_fdc>("fdc")->dskbytr_r();
diff -Nru src-old/mame/machine/arkanoid.c src/mame/machine/arkanoid.c
--- src-old/mame/machine/arkanoid.c	2012-04-09 14:25:58.000000000 +0200
+++ src/mame/machine/arkanoid.c	2012-05-03 11:00:08.000000000 +0200
@@ -116,7 +116,7 @@
 {
 	const char *tag1 = (const char *)param;
 	const char *tag2 = tag1 + strlen(tag1) + 1;
-	return input_port_read(machine(), (m_paddle_select == 0) ? tag1 : tag2);
+	return ioport((m_paddle_select == 0) ? tag1 : tag2)->read();
 }
 
 /*
@@ -575,7 +575,7 @@
 {
 	UINT8 arkanoid_bootleg_d008_bit[8];
 	UINT8 arkanoid_bootleg_d008_val;
-	UINT8 arkanoid_paddle_value = input_port_read(machine(), "MUX");
+	UINT8 arkanoid_paddle_value = ioport("MUX")->read();
 	int b;
 
 	arkanoid_bootleg_d008_bit[4] = arkanoid_bootleg_d008_bit[6] = arkanoid_bootleg_d008_bit[7] = 0;  /* untested bits */
diff -Nru src-old/mame/machine/asteroid.c src/mame/machine/asteroid.c
--- src-old/mame/machine/asteroid.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/machine/asteroid.c	2012-05-03 11:00:08.000000000 +0200
@@ -16,27 +16,27 @@
 INTERRUPT_GEN( asteroid_interrupt )
 {
 	/* Turn off interrupts if self-test is enabled */
-	if (!(input_port_read(device->machine(), "IN0") & 0x80))
+	if (!(device->machine().root_device().ioport("IN0")->read() & 0x80))
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
 INTERRUPT_GEN( asterock_interrupt )
 {
 	/* Turn off interrupts if self-test is enabled */
-	if ((input_port_read(device->machine(), "IN0") & 0x80))
+	if ((device->machine().root_device().ioport("IN0")->read() & 0x80))
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
 INTERRUPT_GEN( llander_interrupt )
 {
 	/* Turn off interrupts if self-test is enabled */
-	if (input_port_read(device->machine(), "IN0") & 0x02)
+	if (device->machine().root_device().ioport("IN0")->read() & 0x02)
 		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
 READ8_MEMBER(asteroid_state::asteroid_IN0_r)
 {
-	int res = input_port_read(machine(), "IN0");
+	int res = ioport("IN0")->read();
 	int bitmask = (1 << offset);
 
 	if (res & bitmask)
@@ -50,7 +50,7 @@
 
 READ8_MEMBER(asteroid_state::asterock_IN0_r)
 {
-	int res = input_port_read(machine(), "IN0");
+	int res = ioport("IN0")->read();
 	int bitmask = (1 << offset);
 
 	if (res & bitmask)
@@ -68,7 +68,7 @@
 
 READ8_MEMBER(asteroid_state::asteroid_IN1_r)
 {
-	int res = input_port_read(machine(), "IN1");
+	int res = ioport("IN1")->read();
 	int bitmask = (1 << (offset & 0x7));
 
 	if (res & bitmask)
@@ -85,7 +85,7 @@
 	int res;
 	int res1;
 
-	res1 = input_port_read(machine(), "DSW1");
+	res1 = ioport("DSW1")->read();
 
 	res = 0xfc | ((res1 >> (2 * (3 - (offset & 0x3)))) & 0x3);
 	return res;
diff -Nru src-old/mame/machine/atari.c src/mame/machine/atari.c
--- src-old/mame/machine/atari.c	2012-04-22 07:07:46.000000000 +0200
+++ src/mame/machine/atari.c	2012-05-03 11:00:08.000000000 +0200
@@ -64,12 +64,12 @@
 
 READ8_DEVICE_HANDLER(atari_pia_pa_r)
 {
-	return input_port_read_safe(device->machine(), "djoy_0_1", 0);
+	return device->machine().root_device().ioport("djoy_0_1")->read_safe(0);
 }
 
 READ8_DEVICE_HANDLER(atari_pia_pb_r)
 {
-	return input_port_read_safe(device->machine(), "djoy_2_3", 0);
+	return device->machine().root_device().ioport("djoy_2_3")->read_safe(0);
 }
 
 WRITE8_DEVICE_HANDLER(a600xl_pia_pb_w) { a600xl_mmu(device->machine(), data); }
@@ -169,7 +169,7 @@
 	/* check keyboard */
 	for( i = 0; i < 8; i++ )
 	{
-		ipt = input_port_read_safe(machine, tag[i], 0);
+		ipt = machine.root_device().ioport(tag[i])->read_safe(0);
 
 		if( ipt )
 		{
@@ -183,11 +183,11 @@
 			atari_code = i*8 + count;
 
 			/* SHIFT */
-			if(input_port_read_safe(machine, "fake", 0) & 0x01)
+			if(machine.root_device().ioport("fake")->read_safe(0) & 0x01)
 				atari_code |= 0x40;
 
 			/* CTRL */
-			if(input_port_read_safe(machine, "fake", 0) & 0x02)
+			if(machine.root_device().ioport("fake")->read_safe(0) & 0x02)
 				atari_code |= 0x80;
 
 			if( atari_code != AKEY_NONE )
@@ -251,7 +251,7 @@
 	/* check keypad */
 	for( i = 0; i < 4; i++ )
 	{
-		ipt = input_port_read_safe(machine, tag[i], 0);
+		ipt = machine.root_device().ioport(tag[i])->read_safe(0);
 
 		if( ipt )
 		{
@@ -281,7 +281,7 @@
 	}
 
 	/* check top button */
-	if ((input_port_read(machine, "djoy_b") & 0x10) == 0)
+	if ((machine.root_device().ioport("djoy_b")->read() & 0x10) == 0)
 	{
 		if (atari_last == 0xfe)
 			return;
@@ -316,7 +316,7 @@
 
 static UINT8 console_read(address_space *space)
 {
-	return input_port_read(space->machine(), "console");
+	return space->machine().root_device().ioport("console")->read();
 }
 
 
diff -Nru src-old/mame/machine/atarifb.c src/mame/machine/atarifb.c
--- src-old/mame/machine/atarifb.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/atarifb.c	2012-05-03 11:00:08.000000000 +0200
@@ -154,7 +154,7 @@
 			  (m_sign_x_2 >> 6) |
 			  (m_sign_y_1 >> 5) |
 			  (m_sign_x_1 >> 4) |
-			  input_port_read(machine(), "IN0");
+			  ioport("IN0")->read();
 		return val;
 	}
 	else
@@ -162,14 +162,14 @@
 		int new_x, new_y;
 
 		/* Read player 1 trackball */
-		new_x = input_port_read(machine(), "IN3");
+		new_x = ioport("IN3")->read();
 		if (new_x != m_counter_x_in0)
 		{
 			m_sign_x_1 = (new_x - m_counter_x_in0) & 0x80;
 			m_counter_x_in0 = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN2");
+		new_y = ioport("IN2")->read();
 		if (new_y != m_counter_y_in0)
 		{
 			m_sign_y_1 = (new_y - m_counter_y_in0) & 0x80;
@@ -186,21 +186,21 @@
 
 	if ((m_CTRLD & 0x20) == 0x00)
 	{
-		return input_port_read(machine(), "IN1");
+		return ioport("IN1")->read();
 	}
 	else
 	{
 		int new_x, new_y;
 
 		/* Read player 2 trackball */
-		new_x = input_port_read(machine(), "IN5");
+		new_x = ioport("IN5")->read();
 		if (new_x != m_counter_x_in2)
 		{
 			m_sign_x_2 = (new_x - m_counter_x_in2) & 0x80;
 			m_counter_x_in2 = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN4");
+		new_y = ioport("IN4")->read();
 		if (new_y != m_counter_y_in2)
 		{
 			m_sign_y_2 = (new_y - m_counter_y_in2) & 0x80;
@@ -235,14 +235,14 @@
 		int new_x, new_y;
 
 		/* Read player 1 trackball */
-		new_x = input_port_read(machine(), "IN3");
+		new_x = ioport("IN3")->read();
 		if (new_x != m_counter_x_in0)
 		{
 			m_sign_x_1 = (new_x - m_counter_x_in0) & 0x80;
 			m_counter_x_in0 = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN2");
+		new_y = ioport("IN2")->read();
 		if (new_y != m_counter_y_in0)
 		{
 			m_sign_y_1 = (new_y - m_counter_y_in0) & 0x80;
@@ -257,14 +257,14 @@
 		int new_x, new_y;
 
 		/* Read player 2 trackball */
-		new_x = input_port_read(machine(), "IN5");
+		new_x = ioport("IN5")->read();
 		if (new_x != m_counter_x_in0b)
 		{
 			m_sign_x_2 = (new_x - m_counter_x_in0b) & 0x80;
 			m_counter_x_in0b = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN4");
+		new_y = ioport("IN4")->read();
 		if (new_y != m_counter_y_in0b)
 		{
 			m_sign_y_2 = (new_y - m_counter_y_in0b) & 0x80;
@@ -283,7 +283,7 @@
 
 	if ((m_CTRLD & 0x40) == 0x00)
 	{
-		return input_port_read(machine(), "IN1");
+		return ioport("IN1")->read();
 	}
 	else if ((m_CTRLD & 0x60) == 0x60)
 	/* LD1 and LD2 both high, return Team 2 right player (player 3) */
@@ -291,14 +291,14 @@
 		int new_x, new_y;
 
 		/* Read player 3 trackball */
-		new_x = input_port_read(machine(), "IN7");
+		new_x = ioport("IN7")->read();
 		if (new_x != m_counter_x_in2)
 		{
 			m_sign_x_3 = (new_x - m_counter_x_in2) & 0x80;
 			m_counter_x_in2 = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN6");
+		new_y = ioport("IN6")->read();
 		if (new_y != m_counter_y_in2)
 		{
 			m_sign_y_3 = (new_y - m_counter_y_in2) & 0x80;
@@ -313,14 +313,14 @@
 		int new_x, new_y;
 
 		/* Read player 4 trackball */
-		new_x = input_port_read(machine(), "IN9");
+		new_x = ioport("IN9")->read();
 		if (new_x != m_counter_x_in2b)
 		{
 			m_sign_x_4 = (new_x - m_counter_x_in2b) & 0x80;
 			m_counter_x_in2b = new_x;
 		}
 
-		new_y = input_port_read(machine(), "IN8");
+		new_y = ioport("IN8")->read();
 		if (new_y != m_counter_y_in2b)
 		{
 			m_sign_y_4 = (new_y - m_counter_y_in2b) & 0x80;
diff -Nru src-old/mame/machine/balsente.c src/mame/machine/balsente.c
--- src-old/mame/machine/balsente.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/balsente.c	2012-05-03 11:00:08.000000000 +0200
@@ -62,8 +62,8 @@
 		/* we latch the beam values on the first interrupt after VBLANK */
 		if (param == 64)
 		{
-			state->m_shooter_x = input_port_read(timer.machine(), "FAKEX");
-			state->m_shooter_y = input_port_read(timer.machine(), "FAKEY");
+			state->m_shooter_x = timer.machine().root_device().ioport("FAKEX")->read();
+			state->m_shooter_y = timer.machine().root_device().ioport("FAKEY")->read();
 		}
 
 		/* which bits get returned depends on which scanline we're at */
@@ -172,8 +172,8 @@
 	memset(state->m_noise_position, 0, sizeof(state->m_noise_position));
 
 	/* point the banks to bank 0 */
-	numbanks = (machine.root_device().memregion("maincpu")->bytes() > 0x40000) ? 16 : 8;
-	state->membank("bank1")->configure_entries(0, numbanks, &machine.root_device().memregion("maincpu")->base()[0x10000], 0x6000);
+	numbanks = (state->memregion("maincpu")->bytes() > 0x40000) ? 16 : 8;
+	state->membank("bank1")->configure_entries(0, numbanks, &state->memregion("maincpu")->base()[0x10000], 0x6000);
 	state->membank("bank2")->configure_entries(0, numbanks, &state->memregion("maincpu")->base()[0x12000], 0x6000);
 	state->membank("bank1")->set_entry(0);
 	state->membank("bank2")->set_entry(0);
@@ -569,7 +569,7 @@
 	/* ports are read once a frame, just at varying intervals. To get around this, we */
 	/* read all the analog inputs at VBLANK time and just return the cached values. */
 	for (i = 0; i < 4; i++)
-		state->m_analog_input_data[i] = input_port_read(device->machine(), analog[i]);
+		state->m_analog_input_data[i] = device->machine().root_device().ioport(analog[i])->read();
 }
 
 
@@ -1140,9 +1140,9 @@
 	INT8 diff[3];
 
 	/* read the current steering values */
-	wheel[0] = input_port_read(machine, "AN0");
-	wheel[1] = input_port_read(machine, "AN1");
-	wheel[2] = input_port_read(machine, "AN2");
+	wheel[0] = state->ioport("AN0")->read();
+	wheel[1] = state->ioport("AN1")->read();
+	wheel[2] = state->ioport("AN2")->read();
 
 	/* diff the values */
 	diff[0] = wheel[0] - state->m_grudge_last_steering[0];
diff -Nru src-old/mame/machine/beezer.c src/mame/machine/beezer.c
--- src-old/mame/machine/beezer.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/beezer.c	2012-05-03 11:00:08.000000000 +0200
@@ -111,16 +111,16 @@
 		switch (data & 0x03)
 		{
 		case 0:
-			state->m_pbus = input_port_read(device->machine(), "IN0");
+			state->m_pbus = state->ioport("IN0")->read();
 			break;
 		case 1:
-			state->m_pbus = input_port_read(device->machine(), "IN1") | (input_port_read(device->machine(), "IN2") << 4);
+			state->m_pbus = state->ioport("IN1")->read() | (state->ioport("IN2")->read() << 4);
 			break;
 		case 2:
-			state->m_pbus = input_port_read(device->machine(), "DSWB");
+			state->m_pbus = state->ioport("DSWB")->read();
 			break;
 		case 3:
-			state->m_pbus = input_port_read(device->machine(), "DSWA"); // Technically DSWA isn't populated on the board and is pulled to 0xFF with resistor pack, but there IS a DSWA port in the driver so we may as well use it.
+			state->m_pbus = state->ioport("DSWA")->read(); // Technically DSWA isn't populated on the board and is pulled to 0xFF with resistor pack, but there IS a DSWA port in the driver so we may as well use it.
 			break;
 		}
 	}
diff -Nru src-old/mame/machine/bonzeadv.c src/mame/machine/bonzeadv.c
--- src-old/mame/machine/bonzeadv.c	2011-04-01 08:50:56.000000000 +0200
+++ src/mame/machine/bonzeadv.c	2012-05-03 11:00:08.000000000 +0200
@@ -446,10 +446,10 @@
 	{
 		switch (offset)
 		{
-		case 0x03: return input_port_read(space->machine(), "800007");    /* STARTn + SERVICE1 */
-		case 0x04: return input_port_read(space->machine(), "800009");    /* COINn */
-		case 0x05: return input_port_read(space->machine(), "80000B");    /* Player controls + TILT */
-		case 0x06: return input_port_read(space->machine(), "80000D");    /* Player controls (cocktail) */
+		case 0x03: return state->ioport("800007")->read();    /* STARTn + SERVICE1 */
+		case 0x04: return state->ioport("800009")->read();    /* COINn */
+		case 0x05: return state->ioport("80000B")->read();    /* Player controls + TILT */
+		case 0x06: return state->ioport("80000D")->read();    /* Player controls (cocktail) */
 		case 0x08: return state->m_cc_port;
 		}
 
diff -Nru src-old/mame/machine/bsktball.c src/mame/machine/bsktball.c
--- src-old/mame/machine/bsktball.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/bsktball.c	2012-05-03 11:00:08.000000000 +0200
@@ -58,10 +58,10 @@
 	int p2_vert;
 	int temp;
 
-	p1_horiz = input_port_read(machine(), "TRACK0_X");
-	p1_vert  = input_port_read(machine(), "TRACK0_Y");
-	p2_horiz = input_port_read(machine(), "TRACK1_X");
-	p2_vert  = input_port_read(machine(), "TRACK1_Y");
+	p1_horiz = ioport("TRACK0_X")->read();
+	p1_vert  = ioport("TRACK0_Y")->read();
+	p2_horiz = ioport("TRACK1_X")->read();
+	p2_vert  = ioport("TRACK1_Y")->read();
 
 	/* Set direction bits */
 
@@ -146,7 +146,7 @@
 	}
 	else
 	{
-		temp = input_port_read(machine(), "IN0") & 0x0f;
+		temp = ioport("IN0")->read() & 0x0f;
 
 		return (temp | m_dir0 | m_dir1 | m_dir2 | m_dir3);
 	}
diff -Nru src-old/mame/machine/bublbobl.c src/mame/machine/bublbobl.c
--- src-old/mame/machine/bublbobl.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/machine/bublbobl.c	2012-05-03 11:00:08.000000000 +0200
@@ -185,7 +185,7 @@
 {
 
 	//logerror("%04x: 6801U4 port 1 read\n", cpu_get_pc(&space.device()));
-	m_port1_in = input_port_read(machine(), "IN0");
+	m_port1_in = ioport("IN0")->read();
 	return (m_port1_out & m_ddr1) | (m_port1_in & ~m_ddr1);
 }
 
@@ -236,7 +236,7 @@
 		{
 			// read
 			if ((address & 0x0800) == 0x0000)
-				m_port3_in = input_port_read(machine(), portnames[address & 3]);
+				m_port3_in = ioport(portnames[address & 3])->read();
 			else if ((address & 0x0c00) == 0x0c00)
 				m_port3_in = m_mcu_sharedram[address & 0x03ff];
 			// logerror("reading %02x from shared RAM %04x\n", m_port3_in, address);
@@ -448,7 +448,7 @@
 			if ((m_address & 0x0800) == 0x0000)
 			{
 				//logerror("%04x: 68705 read input port %02x\n", cpu_get_pc(&space.device()), m_address);
-				m_latch = input_port_read(machine(), portnames[m_address & 3]);
+				m_latch = ioport(portnames[m_address & 3])->read();
 			}
 			else if ((m_address & 0x0c00) == 0x0c00)
 			{
diff -Nru src-old/mame/machine/carpolo.c src/mame/machine/carpolo.c
--- src-old/mame/machine/carpolo.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/carpolo.c	2012-05-03 11:00:08.000000000 +0200
@@ -217,7 +217,7 @@
 
 
 	/* check the coins here as well - they drive the clock of the flip-flops */
-	port_value = input_port_read(device->machine(), "IN0");
+	port_value = state->ioport("IN0")->read();
 
 	state->m_ttl7474_2s_1->clock_w((port_value & 0x01) >> 0);
 	state->m_ttl7474_2s_2->clock_w((port_value & 0x02) >> 1);
@@ -240,7 +240,7 @@
 			case 3:	movement_flip_flop = state->m_ttl7474_1a_1;	dir_flip_flop = state->m_ttl7474_1a_2;	break;
 		}
 
-		port_value = input_port_read(device->machine(), portnames[player]);
+		port_value = device->machine().root_device().ioport(portnames[player])->read();
 
 		if (port_value != state->m_last_wheel_value[player])
 		{
@@ -258,7 +258,7 @@
 
 
 	/* finally read the accelerator pedals */
-	port_value = input_port_read(device->machine(), "PEDALS");
+	port_value = device->machine().root_device().ioport("PEDALS")->read();
 
 	for (player = 0; player < 4; player++)
 	{
@@ -422,7 +422,7 @@
 		  (state->m_ttl7474_1c_2->output_r() ? 0x02 : 0x00) |
 		  (state->m_ttl7474_1d_2->output_r() ? 0x04 : 0x00) |
 		  (state->m_ttl7474_1f_2->output_r() ? 0x08 : 0x00) |
-		  (input_port_read(device->machine(), "IN2") & 0xf0);
+		  (state->ioport("IN2")->read() & 0xf0);
 
 	return ret;
 }
diff -Nru src-old/mame/machine/cchip.c src/mame/machine/cchip.c
--- src-old/mame/machine/cchip.c	2011-03-29 18:31:32.000000000 +0200
+++ src/mame/machine/cchip.c	2012-05-03 11:00:08.000000000 +0200
@@ -117,9 +117,9 @@
 	{
 		switch (offset)
 		{
-		case 0x00: return input_port_read(space->machine(), "IN0");    /* Player 1 controls + START1 */
-		case 0x01: return input_port_read(space->machine(), "IN1");    /* Player 2 controls + START2 */
-		case 0x02: return input_port_read(space->machine(), "IN2");    /* COINn + SERVICE1 + TILT */
+		case 0x00: return space->machine().root_device().ioport("IN0")->read();    /* Player 1 controls + START1 */
+		case 0x01: return space->machine().root_device().ioport("IN1")->read();    /* Player 2 controls + START2 */
+		case 0x02: return space->machine().root_device().ioport("IN2")->read();    /* COINn + SERVICE1 + TILT */
 		case 0x03: return cc_port;
 		}
 	}
diff -Nru src-old/mame/machine/cdislave.c src/mame/machine/cdislave.c
--- src-old/mame/machine/cdislave.c	2012-04-12 11:58:30.000000000 +0200
+++ src/mame/machine/cdislave.c	2012-05-03 11:00:08.000000000 +0200
@@ -79,9 +79,9 @@
 
 void cdislave_device::perform_mouse_update()
 {
-    UINT16 x = input_port_read(machine(), "MOUSEX");
-    UINT16 y = input_port_read(machine(), "MOUSEY");
-    UINT8 buttons = input_port_read(machine(), "MOUSEBTN");
+    UINT16 x = ioport("MOUSEX")->read();
+    UINT16 y = ioport("MOUSEY")->read();
+    UINT8 buttons = ioport("MOUSEBTN")->read();
 
     UINT16 old_mouse_x = m_real_mouse_x;
     UINT16 old_mouse_y = m_real_mouse_y;
diff -Nru src-old/mame/machine/dc-ctrl.c src/mame/machine/dc-ctrl.c
--- src-old/mame/machine/dc-ctrl.c	2011-05-02 21:58:35.000000000 +0200
+++ src/mame/machine/dc-ctrl.c	2012-05-03 11:00:08.000000000 +0200
@@ -72,14 +72,14 @@
 {
 	dest[0] = 0x20000000; // Controller
 	dest[1] =
-		(input_port_exists(machine(), port_tag[2]) ? 0x010000 : 0) |
-		(input_port_exists(machine(), port_tag[3]) ? 0x020000 : 0) |
-		(input_port_exists(machine(), port_tag[4]) ? 0x040000 : 0) |
-		(input_port_exists(machine(), port_tag[5]) ? 0x080000 : 0) |
-		(input_port_exists(machine(), port_tag[6]) ? 0x100000 : 0) |
-		(input_port_exists(machine(), port_tag[7]) ? 0x200000 : 0) |
-		(input_port_active_safe(machine(), port_tag[0], 0) << 8) |
-		input_port_active_safe(machine(), port_tag[1], 0); // 1st function - controller
+		((machine().root_device().ioport(port_tag[2]) != NULL) ? 0x010000 : 0) |
+		((machine().root_device().ioport(port_tag[3]) != NULL) ? 0x020000 : 0) |
+		((machine().root_device().ioport(port_tag[4]) != NULL) ? 0x040000 : 0) |
+		((machine().root_device().ioport(port_tag[5]) != NULL) ? 0x080000 : 0) |
+		((machine().root_device().ioport(port_tag[6]) != NULL) ? 0x100000 : 0) |
+		((machine().root_device().ioport(port_tag[7]) != NULL) ? 0x200000 : 0) |
+		(machine().root_device().ioport(port_tag[0])->active_safe(0) << 8) |
+		machine().root_device().ioport(port_tag[1])->active_safe(0); // 1st function - controller
 	dest[2] = 0; // No 2nd function
 	dest[3] = 0; // No 3rd function
 	dest[4] = 0x00ff; // Every region, no expansion
@@ -97,14 +97,14 @@
 {
 	dest[0] = 0x21000000; // Controller
 	dest[1] =
-		input_port_read_safe(machine(), port_tag[0], 0xff) |
-		(input_port_read_safe(machine(), port_tag[1], 0xff) << 8) |
-		(input_port_read_safe(machine(), port_tag[2], 0x00) << 16) |
-		(input_port_read_safe(machine(), port_tag[3], 0x00) << 24);
+		ioport(port_tag[0])->read_safe(0xff) |
+		(ioport(port_tag[1])->read_safe(0xff) << 8) |
+		(ioport(port_tag[2])->read_safe(0x00) << 16) |
+		(ioport(port_tag[3])->read_safe(0x00) << 24);
 	dest[2] =
-		input_port_read_safe(machine(), port_tag[4], 0x80) |
-		(input_port_read_safe(machine(), port_tag[5], 0x80) << 8) |
-		(input_port_read_safe(machine(), port_tag[6], 0x80) << 16) |
-		(input_port_read_safe(machine(), port_tag[7], 0x80) << 24);
+		ioport(port_tag[4])->read_safe(0x80) |
+		(ioport(port_tag[5])->read_safe(0x80) << 8) |
+		(ioport(port_tag[6])->read_safe(0x80) << 16) |
+		(ioport(port_tag[7])->read_safe(0x80) << 24);
 }
 
diff -Nru src-old/mame/machine/dec0.c src/mame/machine/dec0.c
--- src-old/mame/machine/dec0.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/dec0.c	2012-05-03 11:00:08.000000000 +0200
@@ -19,13 +19,13 @@
 	switch (offset<<1)
 	{
 		case 0: /* Player 1 & 2 joystick & buttons */
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 
 		case 2: /* Credits, start buttons */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 
 		case 4: /* Byte 4: Dipswitch bank 2, Byte 5: Dipswitch Bank 1 */
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 8: /* Intel 8751 mc, Bad Dudes & Heavy Barrel only */
 			//logerror("CPU #0 PC %06x: warning - read i8751 %06x - %04x\n", cpu_get_pc(&space.device()), 0x30c000+offset, m_i8751_return);
@@ -43,10 +43,10 @@
 	switch (offset<<1)
 	{
 		case 0: /* Player 1 rotary */
-			return ~(1 << input_port_read(machine(), "AN0"));
+			return ~(1 << ioport("AN0")->read());
 
 		case 8: /* Player 2 rotary */
-			return ~(1 << input_port_read(machine(), "AN1"));
+			return ~(1 << ioport("AN1")->read());
 
 		default:
 			logerror("Unknown rotary read at 300000 %02x\n", offset);
@@ -62,19 +62,19 @@
 	switch (offset<<1)
 	{
 		case 0: /* Player 1 Joystick + start, Player 2 Joystick + start */
-			return input_port_read(machine(), "INPUTS");
+			return ioport("INPUTS")->read();
 
 		case 2: /* Dipswitches */
-			return input_port_read(machine(), "DSW");
+			return ioport("DSW")->read();
 
 		case 4: /* Player 1 rotary */
-			return ~(1 << input_port_read(machine(), "AN0"));
+			return ~(1 << ioport("AN0")->read());
 
 		case 6: /* Player 2 rotary */
-			return ~(1 << input_port_read(machine(), "AN1"));
+			return ~(1 << ioport("AN1")->read());
 
 		case 8: /* Credits, start buttons */
-			return input_port_read(machine(), "SYSTEM");
+			return ioport("SYSTEM")->read();
 
 		case 12:
 			return 0;	/* ?? watchdog ?? */
diff -Nru src-old/mame/machine/decocass.c src/mame/machine/decocass.c
--- src-old/mame/machine/decocass.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/decocass.c	2012-05-03 11:00:08.000000000 +0200
@@ -152,10 +152,10 @@
 	decocass_state *state = space->machine().driver_data<decocass_state>();
 
 	/* just latch the analog controls here */
-	state->m_quadrature_decoder[0] = input_port_read(space->machine(), "AN0");
-	state->m_quadrature_decoder[1] = input_port_read(space->machine(), "AN1");
-	state->m_quadrature_decoder[2] = input_port_read(space->machine(), "AN2");
-	state->m_quadrature_decoder[3] = input_port_read(space->machine(), "AN3");
+	state->m_quadrature_decoder[0] = state->ioport("AN0")->read();
+	state->m_quadrature_decoder[1] = state->ioport("AN1")->read();
+	state->m_quadrature_decoder[2] = state->ioport("AN2")->read();
+	state->m_quadrature_decoder[3] = state->ioport("AN3")->read();
 }
 
 WRITE8_HANDLER( decocass_adc_w )
@@ -181,7 +181,7 @@
 	switch (offset & 7)
 	{
 	case 0: case 1: case 2:
-		data = input_port_read(space->machine(), portnames[offset & 7]);
+		data = space->machine().root_device().ioport(portnames[offset & 7])->read();
 		break;
 	case 3: case 4: case 5: case 6:
 		data = state->m_quadrature_decoder[(offset & 7) - 3];
diff -Nru src-old/mame/machine/decoprot.c src/mame/machine/decoprot.c
--- src-old/mame/machine/decoprot.c	2012-04-09 22:23:26.000000000 +0200
+++ src/mame/machine/decoprot.c	2012-05-03 11:00:08.000000000 +0200
@@ -130,16 +130,16 @@
 {
 	switch (offset<<1) {
 		case 0x110: /* Player input */
-			return input_port_read(space->machine(), "IN0");
+			return space->machine().root_device().ioport("IN0")->read();
 
 		case 0x36c: /* Coins */
 		case 0x334: /* Probably also, c6, 2c0, 2e0, 4b2, 46a, 4da, rohga is 44c */
-			return input_port_read(space->machine(), "IN1");
+			return space->machine().root_device().ioport("IN1")->read();
 		case 0x0dc:
-			return input_port_read(space->machine(), "IN1")<<4;
+			return space->machine().root_device().ioport("IN1")->read()<<4;
 
 		case 0x494: /* Dips */
-			return input_port_read(space->machine(), "DSW1_2");
+			return space->machine().root_device().ioport("DSW1_2")->read();
 
 		case 0x244:
 			return deco16_prot_ram[0];
@@ -364,9 +364,9 @@
 
 		/* Player 1 & 2 controls, read in IRQ then written *back* to protection device */
 		case 0x50: /* written to 9e byte */
-			return input_port_read(space->machine(), "IN0");
+			return space->machine().root_device().ioport("IN0")->read();
 		case 0x6f8: /* written to 76 byte */
-			return (input_port_read(space->machine(), "IN0")>>8)|(input_port_read(space->machine(), "IN0")<<8); /* byte swap IN0 */
+			return (space->machine().root_device().ioport("IN0")->read()>>8)|(space->machine().root_device().ioport("IN0")->read()<<8); /* byte swap IN0 */
 
 		case 0x5c: /* After coin insert, high 0x8000 bit set starts game */
 			return deco16_prot_ram[0x3b];
@@ -376,9 +376,9 @@
 			return ((deco16_prot_ram[0x9e/2]&0xff00)>>8) | ((deco16_prot_ram[0x9e/2]&0x00ff)<<8);
 
 		case 0xac: /* Dip switches */
-			return input_port_read(space->machine(), "DSW");
+			return space->machine().root_device().ioport("DSW")->read();
 		case 0xc2:
-			return input_port_read(space->machine(), "DSW") ^ deco16_prot_ram[0x2c/2];
+			return space->machine().root_device().ioport("DSW")->read() ^ deco16_prot_ram[0x2c/2];
 
 		case 0x5d4: /* The state of the dips last frame */
 			return deco16_prot_ram[0x34/2];
@@ -390,7 +390,7 @@
 			return (((deco16_prot_ram[0]&0xfff0)>>0) | ((deco16_prot_ram[0]&0x000c)>>2) | ((deco16_prot_ram[0]&0x0003)<<2)) & (~deco16_prot_ram[0x36/2]);
 
 		case 0x76a: /* Coins */
-			return input_port_read(space->machine(), "IN1");
+			return space->machine().root_device().ioport("IN1")->read();
 
 		case 0x284: /* Bit shifting with inverted mask register */
 			return (((deco16_prot_ram[0x40/2]&0xfff0)>>0) | ((deco16_prot_ram[0x40/2]&0x0007)<<1) | ((deco16_prot_ram[0x40/2]&0x0008)>>3)) & (~deco16_prot_ram[0x36/2]);
@@ -404,7 +404,7 @@
 			return (((deco16_prot_ram[0x6a/2]&0x00f0)<<4) | ((deco16_prot_ram[0x6a/2]&0x0f00)<<4) | ((deco16_prot_ram[0x6a/2]&0x0007)<<5) | ((deco16_prot_ram[0x6a/2]&0x0008)<<1)) & (~deco16_prot_ram[0x36/2]);
 
 		case 0x7d6: /* XOR IN0 */
-			return input_port_read(space->machine(), "IN0") ^ deco16_prot_ram[0x2c/2];
+			return space->machine().root_device().ioport("IN0")->read() ^ deco16_prot_ram[0x2c/2];
 		case 0x4b4:
 			return ((deco16_prot_ram[0x32/2]&0x00f0)<<8) | ((deco16_prot_ram[0x32/2]&0x000e)<<7) | ((deco16_prot_ram[0x32/2]&0x0001)<<11);
 	}
@@ -467,15 +467,15 @@
 
 	switch (offset*2) {
 		case 0xac: /* Dip switches */
-			return input_port_read(space->machine(), "DSW");
+			return space->machine().root_device().ioport("DSW")->read();
 		case 0xc2: /* Dip switches */
-			return input_port_read(space->machine(), "DSW") ^ deco16_prot_ram[0x2c/2];
+			return space->machine().root_device().ioport("DSW")->read() ^ deco16_prot_ram[0x2c/2];
 		case 0x46: /* Coins */
-			return input_port_read(space->machine(), "IN1") ^ deco16_prot_ram[0x2c/2];
+			return space->machine().root_device().ioport("IN1")->read() ^ deco16_prot_ram[0x2c/2];
 		case 0x50: /* Player 1 & 2 input ports */
-			return input_port_read(space->machine(), "IN0");
+			return space->machine().root_device().ioport("IN0")->read();
 		case 0x63c: /* Player 1 & 2 input ports */
-			return input_port_read(space->machine(), "IN0") ^ deco16_prot_ram[0x2c/2];
+			return space->machine().root_device().ioport("IN0")->read() ^ deco16_prot_ram[0x2c/2];
 
 		case 0x5f4:
 			return deco16_prot_ram[0x18/2];
@@ -652,13 +652,13 @@
 			return deco16_prot_ram[15];
 
 		case 0x36: /* Dip switches */
-			return input_port_read(space->machine(), "DSW");
+			return space->machine().root_device().ioport("DSW")->read();
 
 		case 0x1c8: /* Coins */
-			return input_port_read(space->machine(), "IN1");
+			return space->machine().root_device().ioport("IN1")->read();
 
 		case 0x22c: /* Player 1 & 2 input ports */
-			return input_port_read(space->machine(), "IN0");
+			return space->machine().root_device().ioport("IN0")->read();
 	}
 
 	logerror("Protection PC %06x: warning - read unmapped memory address %04x\n",cpu_get_pc(&space->device()),offset);
@@ -750,15 +750,15 @@
 			return ((deco16_prot_ram[0x78e>>1]>>4)&0xff00) | (deco16_prot_ram[0x78e>>1]&0x000f) | ((deco16_prot_ram[0x78e>>1]<<8)&0xf000);
 
 		case 0x00c >> 1: /* Player 1 & Player 2 joysticks & fire buttons */
-			return input_port_read(space->machine(), "INPUTS");
+			return space->machine().root_device().ioport("INPUTS")->read();
 		case 0x778 >> 1: /* Credits */
-			return input_port_read(space->machine(), "SYSTEM");
+			return space->machine().root_device().ioport("SYSTEM")->read();
 		case 0x382 >> 1: /* DIPS */
-			return input_port_read(space->machine(), "DSW");
+			return space->machine().root_device().ioport("DSW")->read();
 	}
 
 	if (cpu_get_pc(&space->device())!=0xc0ea)
-		logerror("CPU #0 PC %06x: warning - read unmapped control address %06x (ctrl %04x)\n", cpu_get_pc(&space->device()), offset<<1, input_port_read(space->machine(), "INPUTS"));
+		logerror("CPU #0 PC %06x: warning - read unmapped control address %06x (ctrl %04x)\n", cpu_get_pc(&space->device()), offset<<1, space->machine().root_device().ioport("INPUTS")->read());
 
 	return 0;
 }
@@ -868,13 +868,13 @@
 
 	switch (offset) {
 		case 0x88/2: /* Player 1 & 2 input ports */
-			return input_port_read(space->machine(), "IN0");
+			return space->machine().root_device().ioport("IN0")->read();
 		case 0x36c/2:
-			return input_port_read(space->machine(), "IN1");
+			return space->machine().root_device().ioport("IN1")->read();
 		case 0x44c/2:
-			return ((input_port_read(space->machine(), "IN1") & 0x7)<<13)|((input_port_read(space->machine(), "IN1") & 0x8)<<9);
+			return ((space->machine().root_device().ioport("IN1")->read() & 0x7)<<13)|((space->machine().root_device().ioport("IN1")->read() & 0x8)<<9);
 		case 0x292/2: /* Dips */
-			return input_port_read(space->machine(), "DSW1_2");
+			return space->machine().root_device().ioport("DSW1_2")->read();
 
 		case 0x44/2:
 			return ((((DECO_PORT(0x2c)&0x000f)<<12)) ^ deco16_xor) & (~deco16_mask);
@@ -1253,11 +1253,11 @@
 	switch (offset)
 	{
 	case 0x582: /* Player 1 & Player 2 */
-		return input_port_read(space->machine(), "IN0");
+		return space->machine().root_device().ioport("IN0")->read();
 	case 0x04c: /* Coins/VBL */
-		return input_port_read(space->machine(), "IN1");
+		return space->machine().root_device().ioport("IN1")->read();
 	case 0x672: /* Dip switches */
-		return input_port_read(space->machine(), "DSW1_2");
+		return space->machine().root_device().ioport("DSW1_2")->read();
 
 	case 0x13a:
 		return ((DECO_PORT(0x190)&0x00f0)<<8) | ((DECO_PORT(0x190)&0x0003)<<10) | ((DECO_PORT(0x190)&0x000c)<<6);
@@ -1315,8 +1315,8 @@
 
 	/*********************************************************************************/
 
-//  case 0x582: return input_port_read(space->machine(), "IN0"); /* IN0 */
-//  case 0x672: return input_port_read(space->machine(), "IN1"); /* IN1 */
+//  case 0x582: return space->machine().root_device().ioport("IN0")->read(); /* IN0 */
+//  case 0x672: return space->machine().root_device().ioport("IN1")->read(); /* IN1 */
 //  case 0x04c: return space->machine().device<eeprom_device>("eeprom")->read_bit();
 
 	case 0x468:
@@ -1664,8 +1664,8 @@
 	/* Special case inputs, because this is the only game with an eprom */
 	switch (addr)
 	{
-	case 0x582: return (input_port_read(space->machine(), "IN0")<<16) | 0xffff; /* IN0 */
-	case 0x672: return (input_port_read(space->machine(), "IN1")<<16) | 0xffff; /* IN1 */
+	case 0x582: return (space->machine().root_device().ioport("IN0")->read()<<16) | 0xffff; /* IN0 */
+	case 0x672: return (space->machine().root_device().ioport("IN1")->read()<<16) | 0xffff; /* IN1 */
 	case 0x04c: return (space->machine().device<eeprom_device>("eeprom")->read_bit()<<16) | 0xffff;
 	}
 
@@ -1740,9 +1740,9 @@
 {
 	switch (offset * 2)
 	{
-	case 0x298: return input_port_read(space->machine(), "IN0");
-	case 0x342: return input_port_read(space->machine(), "IN1");
-	case 0x506: return input_port_read(space->machine(), "DSW");
+	case 0x298: return space->machine().root_device().ioport("IN0")->read();
+	case 0x342: return space->machine().root_device().ioport("IN1")->read();
+	case 0x506: return space->machine().root_device().ioport("DSW")->read();
 	}
 
 	logerror("Protection PC %06x: warning - read unmapped memory address %04x\n", cpu_get_pc(&space->device()), offset<<1);
@@ -1769,9 +1769,9 @@
 	const UINT16* prot_ram=deco16_prot_ram;
 	switch (offset * 2)
 	{
-	case 0x5b2: return input_port_read(space->machine(), "SYSTEM");
-	case 0x44c: return input_port_read(space->machine(), "DSW");
-	case 0x042: return input_port_read(space->machine(), "INPUTS");
+	case 0x5b2: return space->machine().root_device().ioport("SYSTEM")->read();
+	case 0x44c: return space->machine().root_device().ioport("DSW")->read();
+	case 0x042: return space->machine().root_device().ioport("INPUTS")->read();
 
 	case 0x510: return DECO_PORT(0);
 	case 0x51a: return DECO_PORT(2);
diff -Nru src-old/mame/machine/gaelco2.c src/mame/machine/gaelco2.c
--- src-old/mame/machine/gaelco2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/gaelco2.c	2012-05-03 11:00:08.000000000 +0200
@@ -248,8 +248,8 @@
 	{
 		if (!(data & 0xff))
 		{
-			m_analog_ports[0] = input_port_read_safe(machine(), "ANALOG0", 0);
-			m_analog_ports[1] = input_port_read_safe(machine(), "ANALOG1", 0);
+			m_analog_ports[0] = ioport("ANALOG0")->read_safe(0);
+			m_analog_ports[1] = ioport("ANALOG1")->read_safe(0);
 		}
 	}
 	else
diff -Nru src-old/mame/machine/galaxold.c src/mame/machine/galaxold.c
--- src-old/mame/machine/galaxold.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/galaxold.c	2012-05-03 11:00:08.000000000 +0200
@@ -259,7 +259,7 @@
 	static const char *const portnames[] = { "FAKE1", "FAKE2", "FAKE3", "FAKE4" };
 	int bit_mask = (FPTR)param;
 
-	return (input_port_read(machine(), portnames[m__4in1_bank]) & bit_mask) ? 0x01 : 0x00;
+	return (ioport(portnames[m__4in1_bank])->read() & bit_mask) ? 0x01 : 0x00;
 }
 
 #ifdef UNUSED_FUNCTION
@@ -399,7 +399,7 @@
 {
 	galaxold_state *state = machine.driver_data<galaxold_state>();
 	address_space *space = machine.device("maincpu")->memory().space(AS_PROGRAM);
-	offs_t i, len = machine.root_device().memregion("maincpu")->bytes();
+	offs_t i, len = state->memregion("maincpu")->bytes();
 	UINT8 *RAM = state->memregion("maincpu")->base();
 
 	/* Decrypt Program Roms */
diff -Nru src-old/mame/machine/gaplus.c src/mame/machine/gaplus.c
--- src-old/mame/machine/gaplus.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/gaplus.c	2012-05-03 11:00:08.000000000 +0200
@@ -35,7 +35,7 @@
 	switch (offset)
 	{
 		case 0:
-			return input_port_read(machine(), "IN2");		/* cabinet & test mode */
+			return ioport("IN2")->read();		/* cabinet & test mode */
 		case 1:
 			return (mode == 2) ? m_customio_3[offset] : 0x0f;
 		case 2:
diff -Nru src-old/mame/machine/harddriv.c src/mame/machine/harddriv.c
--- src-old/mame/machine/harddriv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/harddriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -59,7 +59,7 @@
 	atarigen_init(machine);
 
 	/* predetermine memory regions */
-	state->m_sim_memory = (UINT16 *)machine.root_device().memregion("user1")->base();
+	state->m_sim_memory = (UINT16 *)state->memregion("user1")->base();
 	state->m_sim_memory_size = state->memregion("user1")->bytes() / 2;
 	state->m_adsp_pgm_memory_word = (UINT16 *)(reinterpret_cast<UINT8 *>(state->m_adsp_pgm_memory.target()) + 1);
 }
@@ -238,7 +238,7 @@
             .....
         0x8000 = SW1 #1
     */
-	int temp = input_port_read(space->machine(), "IN0");
+	int temp = space->machine().root_device().ioport("IN0")->read();
 	if (atarigen_get_hblank(*space->machine().primary_screen)) temp ^= 0x0002;
 	temp ^= 0x0018;		/* both EOCs always high for now */
 	return temp;
@@ -248,7 +248,7 @@
 READ16_HANDLER( hdc68k_port1_r )
 {
 	harddriv_state *state = space->machine().driver_data<harddriv_state>();
-	UINT16 result = input_port_read(space->machine(), "a80000");
+	UINT16 result = state->ioport("a80000")->read();
 	UINT16 diff = result ^ state->m_hdc68k_last_port1;
 
 	/* if a new shifter position is selected, use it */
@@ -277,7 +277,7 @@
 READ16_HANDLER( hda68k_port1_r )
 {
 	harddriv_state *state = space->machine().driver_data<harddriv_state>();
-	UINT16 result = input_port_read(space->machine(), "a80000");
+	UINT16 result = state->ioport("a80000")->read();
 
 	/* merge in the wheel edge latch bit */
 	if (state->m_hdc68k_wheel_edge)
@@ -292,7 +292,7 @@
 	harddriv_state *state = space->machine().driver_data<harddriv_state>();
 
 	/* grab the new wheel value and upconvert to 12 bits */
-	UINT16 new_wheel = input_port_read(space->machine(), "12BADC0") << 4;
+	UINT16 new_wheel = state->ioport("12BADC0")->read() << 4;
 
 	/* hack to display the wheel position */
 	if (space->machine().input().code_pressed(KEYCODE_LSHIFT))
@@ -350,14 +350,14 @@
 	if (state->m_adc_control & 0x08)
 	{
 		state->m_adc8_select = state->m_adc_control & 0x07;
-		state->m_adc8_data = input_port_read(space->machine(), adc8names[state->m_adc8_select]);
+		state->m_adc8_data = state->ioport(adc8names[state->m_adc8_select])->read();
 	}
 
 	/* handle a write to the 12-bit ADC address select */
 	if (state->m_adc_control & 0x40)
 	{
 		state->m_adc12_select = (state->m_adc_control >> 4) & 0x03;
-		state->m_adc12_data = input_port_read(space->machine(), adc12names[state->m_adc12_select]) << 4;
+		state->m_adc12_data = space->machine().root_device().ioport(adc12names[state->m_adc12_select])->read() << 4;
 	}
 
 	/* bit 7 selects which byte of the 12 bit data to read */
diff -Nru src-old/mame/machine/irobot.c src/mame/machine/irobot.c
--- src-old/mame/machine/irobot.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/irobot.c	2012-05-03 11:00:08.000000000 +0200
@@ -204,9 +204,9 @@
 {
 
 	if (m_control_num == 0)
-		return input_port_read(machine(), "AN0");
+		return ioport("AN0")->read();
 	else if (m_control_num == 1)
-		return input_port_read(machine(), "AN1");
+		return ioport("AN1")->read();
 	return 0;
 
 }
diff -Nru src-old/mame/machine/jvs13551.c src/mame/machine/jvs13551.c
--- src-old/mame/machine/jvs13551.c	2011-06-13 14:01:55.000000000 +0200
+++ src/mame/machine/jvs13551.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,9 +120,9 @@
 	if(count_players > 2 || bytes_per_switch > 2)
 		return false;
 
-	*buf++ = input_port_read_safe(machine(), port_tag[0], 0);
+	*buf++ = ioport(port_tag[0])->read_safe(0);
 	for(int i=0; i<count_players; i++) {
-		UINT32 val = input_port_read_safe(machine(), port_tag[1+i], 0);
+		UINT32 val = ioport(port_tag[1+i])->read_safe(0);
 		for(int j=0; j<bytes_per_switch; j++)
 			*buf++ = val >> ((1-j) << 3);
 	}
@@ -135,7 +135,7 @@
 	if(count > 8)
 		return false;
 	for(int i=0; i<count; i++) {
-		UINT16 val = input_port_read_safe(machine(), port_tag[3+i], 0x8000);
+		UINT16 val = ioport(port_tag[3+i])->read_safe(0x8000);
 		*buf++ = val >> 8;
 		*buf++ = val;
 	}
@@ -148,7 +148,7 @@
 		return false;
 	jvs_outputs = vals[0] & 0x3f;
 	logerror("837-13551: output %02x\n", jvs_outputs);
-	input_port_write_safe(machine(), port_tag[11], jvs_outputs, 0x3f);
+	machine().root_device().ioport(port_tag[11])->write_safe(jvs_outputs, 0x3f);
 	return true;
 }
 
diff -Nru src-old/mame/machine/kaneko16.c src/mame/machine/kaneko16.c
--- src-old/mame/machine/kaneko16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/kaneko16.c	2012-05-03 11:00:08.000000000 +0200
@@ -2059,7 +2059,7 @@
 
 	if ( calc3.mcu_status != (1|2|4|8) )	return;
 
-	if (calc3.dsw_addr) space->write_byte(calc3.dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
+	if (calc3.dsw_addr) space->write_byte(calc3.dsw_addr+0x200000, ( ~state->ioport("DSW1")->read())&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
 
 
 	//calc3.mcu_status = 0;
@@ -2100,7 +2100,7 @@
 			printf("Calc 3 Init Command - %04x ROM Checksum Address\n",  calc3.checksumaddress);
 			printf("Calc 3 Init Command - %08x Data Write Address\n",  calc3.writeaddress);
 #endif
-	//      space->write_byte(calc3.dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
+	//      space->write_byte(calc3.dsw_addr+0x200000, ( ~state->ioport("DSW1")->read())&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
 
 			state->m_mcu_ram[calc3.checksumaddress / 2] = calc3.mcu_crc;				// MCU Rom Checksum!
 
@@ -2406,7 +2406,7 @@
 
 		case 0x03:	// DSW
 		{
-			kaneko16_mcu_ram[mcu_offset] = input_port_read(machine, "DSW1");
+			kaneko16_mcu_ram[mcu_offset] = machine.root_device().ioport("DSW1")->read();
 			logerror("%s : MCU executed command: %04X %04X (read DSW)\n", machine.describe_context(), mcu_command, mcu_offset*2);
 		}
 		break;
@@ -2464,7 +2464,7 @@
 
 		case 0x03:	// DSW
 		{
-			kaneko16_mcu_ram[mcu_offset] = input_port_read(machine, "DSW1");
+			kaneko16_mcu_ram[mcu_offset] = machine.root_device().ioport("DSW1")->read();
 			logerror("%s : MCU executed command: %04X %04X (read DSW)\n", machine.describe_context(), mcu_command, mcu_offset*2);
 		}
 		break;
@@ -2537,7 +2537,7 @@
 
 		case 0x03:	// DSW
 		{
-			kaneko16_mcu_ram[mcu_offset] = input_port_read(machine, "DSW1");
+			kaneko16_mcu_ram[mcu_offset] = machine.root_device().ioport("DSW1")->read();
 		}
 		break;
 
diff -Nru src-old/mame/machine/leland.c src/mame/machine/leland.c
--- src-old/mame/machine/leland.c	2012-04-20 21:57:41.000000000 +0200
+++ src/mame/machine/leland.c	2012-05-03 11:00:08.000000000 +0200
@@ -83,16 +83,16 @@
 
 READ8_MEMBER(leland_state::cerberus_dial_1_r)
 {
-	int original = input_port_read(machine(), "IN0");
-	int modified = dial_compute_value(machine(), input_port_read(machine(), "AN0"), 0);
+	int original = ioport("IN0")->read();
+	int modified = dial_compute_value(machine(), ioport("AN0")->read(), 0);
 	return (original & 0xc0) | ((modified & 0x80) >> 2) | (modified & 0x1f);
 }
 
 
 READ8_MEMBER(leland_state::cerberus_dial_2_r)
 {
-	int original = input_port_read(machine(), "IN0");
-	int modified = dial_compute_value(machine(), input_port_read(machine(), "AN1"), 1);
+	int original = ioport("IN0")->read();
+	int modified = dial_compute_value(machine(), ioport("AN1")->read(), 1);
 	return (original & 0xc0) | ((modified & 0x80) >> 2) | (modified & 0x1f);
 }
 
@@ -136,8 +136,8 @@
 static void update_dangerz_xy(running_machine &machine)
 {
 	leland_state *state = machine.driver_data<leland_state>();
-	UINT8 newy = input_port_read(machine, "AN0");
-	UINT8 newx = input_port_read(machine, "AN1");
+	UINT8 newy = state->ioport("AN0")->read();
+	UINT8 newx = state->ioport("AN1")->read();
 	int deltay = newy - state->m_dial_last_input[0];
 	int deltax = newx - state->m_dial_last_input[1];
 
@@ -190,27 +190,27 @@
 
 READ8_MEMBER(leland_state::redline_pedal_1_r)
 {
-	int pedal = input_port_read(machine(), "IN0");
+	int pedal = ioport("IN0")->read();
 	return redline_pedal_value[pedal >> 5] | 0x0f;
 }
 
 
 READ8_MEMBER(leland_state::redline_pedal_2_r)
 {
-	int pedal = input_port_read(machine(), "IN2");
+	int pedal = ioport("IN2")->read();
 	return redline_pedal_value[pedal >> 5] | 0x0f;
 }
 
 
 READ8_MEMBER(leland_state::redline_wheel_1_r)
 {
-	return dial_compute_value(machine(), input_port_read(machine(), "AN0"), 0);
+	return dial_compute_value(machine(), ioport("AN0")->read(), 0);
 }
 
 
 READ8_MEMBER(leland_state::redline_wheel_2_r)
 {
-	return dial_compute_value(machine(), input_port_read(machine(), "AN1"), 1);
+	return dial_compute_value(machine(), ioport("AN1")->read(), 1);
 }
 
 
@@ -223,19 +223,19 @@
 
 READ8_MEMBER(leland_state::offroad_wheel_1_r)
 {
-	return dial_compute_value(machine(), input_port_read(machine(), "AN3"), 0);
+	return dial_compute_value(machine(), ioport("AN3")->read(), 0);
 }
 
 
 READ8_MEMBER(leland_state::offroad_wheel_2_r)
 {
-	return dial_compute_value(machine(), input_port_read(machine(), "AN4"), 1);
+	return dial_compute_value(machine(), ioport("AN4")->read(), 1);
 }
 
 
 READ8_MEMBER(leland_state::offroad_wheel_3_r)
 {
-	return dial_compute_value(machine(), input_port_read(machine(), "AN5"), 2);
+	return dial_compute_value(machine(), ioport("AN5")->read(), 2);
 }
 
 
@@ -250,7 +250,7 @@
 {
 	static const char *const tracknames[] = { "AN0", "AN1", "AN2", "AN3" };
 
-	return dial_compute_value(machine(), input_port_read(machine(), tracknames[offset]), offset);
+	return dial_compute_value(machine(), ioport(tracknames[offset])->read(), offset);
 }
 
 
@@ -265,7 +265,7 @@
 {
 	static const char *const tracknames[] = { "AN0", "AN1", "AN2" };
 
-	return dial_compute_value(machine(), input_port_read(machine(), tracknames[offset]), offset);
+	return dial_compute_value(machine(), ioport(tracknames[offset])->read(), offset);
 }
 
 
@@ -297,7 +297,7 @@
 	switch (offset)
 	{
 		case 3:
-			m_analog_result = input_port_read(machine(), tracknames[data]);
+			m_analog_result = ioport(tracknames[data])->read();
 			break;
 
 		case 0:
@@ -354,12 +354,12 @@
 	state->m_alternate_bank = 0;
 
 	/* initialize the master banks */
-	state->m_master_length = machine.root_device().memregion("master")->bytes();
-	state->m_master_base = machine.root_device().memregion("master")->base();
+	state->m_master_length = state->memregion("master")->bytes();
+	state->m_master_base = state->memregion("master")->base();
 	(*state->m_update_master_bank)(machine);
 
 	/* initialize the slave banks */
-	state->m_slave_length = machine.root_device().memregion("slave")->bytes();
+	state->m_slave_length = state->memregion("slave")->bytes();
 	state->m_slave_base = state->memregion("slave")->base();
 	if (state->m_slave_length > 0x10000)
 		state->membank("bank3")->set_base(&state->m_slave_base[0x10000]);
@@ -385,8 +385,8 @@
 	state->m_master_int_timer->adjust(machine.primary_screen->time_until_pos(8), 8);
 
 	/* initialize the XROM */
-	state->m_xrom_length = machine.root_device().memregion("user1")->bytes();
-	state->m_xrom_base = machine.root_device().memregion("user1")->base();
+	state->m_xrom_length = state->memregion("user1")->bytes();
+	state->m_xrom_base = state->memregion("user1")->base();
 	state->m_xrom1_addr = 0;
 	state->m_xrom2_addr = 0;
 
@@ -400,12 +400,12 @@
 	state->m_master_bank = 0;
 
 	/* initialize the master banks */
-	state->m_master_length = machine.root_device().memregion("master")->bytes();
-	state->m_master_base = machine.root_device().memregion("master")->base();
+	state->m_master_length = state->memregion("master")->bytes();
+	state->m_master_base = state->memregion("master")->base();
 	ataxx_bankswitch(machine);
 
 	/* initialize the slave banks */
-	state->m_slave_length = machine.root_device().memregion("slave")->bytes();
+	state->m_slave_length = state->memregion("slave")->bytes();
 	state->m_slave_base = state->memregion("slave")->base();
 	if (state->m_slave_length > 0x10000)
 		state->membank("bank3")->set_base(&state->m_slave_base[0x10000]);
@@ -452,7 +452,7 @@
 INTERRUPT_GEN( leland_master_interrupt )
 {
 	/* check for coins here */
-	if ((input_port_read(device->machine(), "IN1") & 0x0e) != 0x0e)
+	if ((device->machine().root_device().ioport("IN1")->read() & 0x0e) != 0x0e)
 		device_set_input_line(device, INPUT_LINE_NMI, ASSERT_LINE);
 }
 
@@ -824,7 +824,7 @@
 
 READ8_DEVICE_HANDLER( ataxx_eeprom_r )
 {
-	int port = input_port_read(device->machine(), "IN2");
+	int port = device->machine().root_device().ioport("IN2")->read();
 	if (LOG_EEPROM) logerror("%s:EE read\n", device->machine().describe_context());
 	return port;
 }
@@ -1060,7 +1060,7 @@
 			break;
 
 		case 0x01:	/* FE = analog port select/bankswitch */
-			m_analog_result = input_port_read(machine(), portnames[data & 15]);
+			m_analog_result = ioport(portnames[data & 15])->read();
 
 			/* update top board banking for some games */
 			if (LOG_BANKSWITCHING_M)
@@ -1091,11 +1091,11 @@
 	switch (offset)
 	{
 		case 0x00:	/* /GIN0 */
-			result = input_port_read(machine(), "IN0");
+			result = ioport("IN0")->read();
 			break;
 
 		case 0x01:	/* /GIN1 */
-			result = input_port_read(machine(), "IN1");
+			result = ioport("IN1")->read();
 			if (cpu_get_reg(machine().device("slave"), Z80_HALT))
 				result ^= 0x01;
 			break;
@@ -1111,11 +1111,11 @@
 			break;
 
 		case 0x10:	/* /GIN0 */
-			result = input_port_read(machine(), "IN2");
+			result = ioport("IN2")->read();
 			break;
 
 		case 0x11:	/* /GIN1 */
-			result = input_port_read(machine(), "IN3");
+			result = ioport("IN3")->read();
 			if (LOG_EEPROM) logerror("%04X:EE read\n", cpu_get_pc(&space.device()));
 			break;
 
@@ -1173,11 +1173,11 @@
 	switch (offset)
 	{
 		case 0x06:	/* /GIN0 */
-			result = input_port_read(machine(), "IN0");
+			result = ioport("IN0")->read();
 			break;
 
 		case 0x07:	/* /SLVBLK */
-			result = input_port_read(machine(), "IN1");
+			result = ioport("IN1")->read();
 			if (cpu_get_reg(machine().device("slave"), Z80_HALT))
 				result ^= 0x01;
 			break;
diff -Nru src-old/mame/machine/lsasquad.c src/mame/machine/lsasquad.c
--- src-old/mame/machine/lsasquad.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/lsasquad.c	2012-05-03 11:00:08.000000000 +0200
@@ -181,7 +181,7 @@
 
 READ8_MEMBER(lsasquad_state::lsasquad_mcu_status_r)
 {
-	int res = input_port_read(machine(), "MCU");
+	int res = ioport("MCU")->read();
 
 	/* bit 0 = when 1, mcu is ready to receive data from main cpu */
 	/* bit 1 = when 0, mcu has sent data to the main cpu */
@@ -196,7 +196,7 @@
 
 READ8_MEMBER(lsasquad_state::daikaiju_mcu_status_r)
 {
-	int res = input_port_read(machine(), "MCU");
+	int res = ioport("MCU")->read();
 
 	/* bit 0 = when 1, mcu is ready to receive data from main cpu */
 	/* bit 1 = when 0, mcu has sent data to the main cpu */
diff -Nru src-old/mame/machine/mcr68.c src/mame/machine/mcr68.c
--- src-old/mame/machine/mcr68.c	2012-04-18 21:40:59.000000000 +0200
+++ src/mame/machine/mcr68.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 
 static READ8_DEVICE_HANDLER( zwackery_port_1_r )
 {
-	UINT8 ret = input_port_read(device->machine(), "IN1");
+	UINT8 ret = device->machine().root_device().ioport("IN1")->read();
 
 	downcast<pia6821_device *>(device)->set_port_a_z_mask(ret);
 
@@ -51,7 +51,7 @@
 
 static READ8_DEVICE_HANDLER( zwackery_port_3_r )
 {
-	UINT8 ret = input_port_read(device->machine(), "IN3");
+	UINT8 ret = device->machine().root_device().ioport("IN3")->read();
 
 	downcast<pia6821_device *>(device)->set_port_a_z_mask(ret);
 
diff -Nru src-old/mame/machine/megadriv.c src/mame/machine/megadriv.c
--- src-old/mame/machine/megadriv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/megadriv.c	2012-05-03 11:00:08.000000000 +0200
@@ -1788,14 +1788,14 @@
 		{
 			/* here we read B, C & the additional buttons */
 			retdata = (megadrive_io_data_regs[portnum] & helper) |
-						(((input_port_read_safe(machine, pad3names[portnum], 0) & 0x30) |
-							(input_port_read_safe(machine, pad6names[portnum], 0) & 0x0f)) & ~helper);
+						(((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0x30) |
+							(machine.root_device().ioport(pad6names[portnum])->read_safe(0) & 0x0f)) & ~helper);
 		}
 		else
 		{
 			/* here we read B, C & the directional buttons */
 			retdata = (megadrive_io_data_regs[portnum] & helper) |
-						((input_port_read_safe(machine, pad3names[portnum], 0) & 0x3f) & ~helper);
+						((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0x3f) & ~helper);
 		}
 	}
 	else
@@ -1804,20 +1804,20 @@
 		{
 			/* here we read ((Start & A) >> 2) | 0x00 */
 			retdata = (megadrive_io_data_regs[portnum] & helper) |
-						(((input_port_read_safe(machine, pad3names[portnum], 0) & 0xc0) >> 2) & ~helper);
+						(((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0xc0) >> 2) & ~helper);
 		}
 		else if (io_stage[portnum]==2)
 		{
 			/* here we read ((Start & A) >> 2) | 0x0f */
 			retdata = (megadrive_io_data_regs[portnum] & helper) |
-						((((input_port_read_safe(machine, pad3names[portnum], 0) & 0xc0) >> 2) | 0x0f) & ~helper);
+						((((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0xc0) >> 2) | 0x0f) & ~helper);
 		}
 		else
 		{
 			/* here we read ((Start & A) >> 2) | Up and Down */
 			retdata = (megadrive_io_data_regs[portnum] & helper) |
-						((((input_port_read_safe(machine, pad3names[portnum], 0) & 0xc0) >> 2) |
-							(input_port_read_safe(machine, pad3names[portnum], 0) & 0x03)) & ~helper);
+						((((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0xc0) >> 2) |
+							(machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0x03)) & ~helper);
 		}
 	}
 
@@ -1837,14 +1837,14 @@
 	{
 		/* here we read B, C & the directional buttons */
 		retdata = (megadrive_io_data_regs[portnum] & helper) |
-					(((input_port_read_safe(machine, pad3names[portnum], 0) & 0x3f) | 0x40) & ~helper);
+					(((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0x3f) | 0x40) & ~helper);
 	}
 	else
 	{
 		/* here we read ((Start & A) >> 2) | Up and Down */
 		retdata = (megadrive_io_data_regs[portnum] & helper) |
-					((((input_port_read_safe(machine, pad3names[portnum], 0) & 0xc0) >> 2) |
-						(input_port_read_safe(machine, pad3names[portnum], 0) & 0x03) | 0x40) & ~helper);
+					((((machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0xc0) >> 2) |
+						(machine.root_device().ioport(pad3names[portnum])->read_safe(0) & 0x03) | 0x40) & ~helper);
 	}
 
 	return retdata;
@@ -1858,18 +1858,18 @@
 	if (ctrl == 0x55)
 	{
 			/* A keys */
-			retdata = ((input_port_read(machine, "PAD1") & 0x40) >> 2) |
-				((input_port_read(machine, "PAD2") & 0x40) >> 4) | 0xeb;
+			retdata = ((machine.root_device().ioport("PAD1")->read() & 0x40) >> 2) |
+				((machine.root_device().ioport("PAD2")->read() & 0x40) >> 4) | 0xeb;
 	}
 	else
 	{
 		if (offset == 0)
 		{
-			retdata = (input_port_read(machine, "PAD1") & 0x3f) | ((input_port_read(machine, "PAD2") & 0x03) << 6);
+			retdata = (machine.root_device().ioport("PAD1")->read() & 0x3f) | ((machine.root_device().ioport("PAD2")->read() & 0x03) << 6);
 		}
 		else
 		{
-			retdata = ((input_port_read(machine, "PAD2") & 0x3c) >> 2) | 0xf0;
+			retdata = ((machine.root_device().ioport("PAD2")->read() & 0x3c) >> 2) | 0xf0;
 		}
 
 	}
@@ -7133,7 +7133,7 @@
 /* emulate testmode plug */
 static UINT8 megadrive_io_read_data_port_svp(running_machine &machine, int portnum)
 {
-	if (portnum == 0 && input_port_read_safe(machine, "MEMORY_TEST", 0x00))
+	if (portnum == 0 && machine.root_device().ioport("MEMORY_TEST")->read_safe(0x00))
 	{
 		return (megadrive_io_data_regs[0] & 0xc0);
 	}
@@ -9277,7 +9277,7 @@
 	/* default state of z80 = reset, with bus */
 	mame_printf_debug("Resetting Megadrive / Genesis\n");
 
-	switch (input_port_read_safe(machine, "REGION", 0xff))
+	switch (machine.root_device().ioport("REGION")->read_safe(0xff))
 	{
 
 		case 1: // US
@@ -9414,7 +9414,7 @@
 		megadrive_imode_odd_frame^=1;
 //      cputag_set_input_line(machine, "genesis_snd_z80", 0, CLEAR_LINE); // if the z80 interrupt hasn't happened by now, clear it..
 
-		if (input_port_read_safe(screen.machine(), "RESET", 0x00) & 0x01)
+		if (screen.machine().root_device().ioport("RESET")->read_safe(0x00) & 0x01)
 			cputag_set_input_line(screen.machine(), "maincpu", INPUT_LINE_RESET, PULSE_LINE);
 
 /*
diff -Nru src-old/mame/machine/mexico86.c src/mame/machine/mexico86.c
--- src-old/mame/machine/mexico86.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/mexico86.c	2012-05-03 11:00:08.000000000 +0200
@@ -67,7 +67,7 @@
 		int i;
 		int coin_curr;
 
-		coin_curr = ~input_port_read(machine, "IN0") & 1;
+		coin_curr = ~machine.root_device().ioport("IN0")->read() & 1;
 		if (coin_curr && !state->m_coin_last && state->m_protection_ram[0x01] < 9)
 		{
 			state->m_protection_ram[0x01]++;	// increase credits counter
@@ -77,8 +77,8 @@
 
 		state->m_protection_ram[0x04] = 0x3c;	// coin inputs
 
-		state->m_protection_ram[0x02] = BITSWAP8(input_port_read(machine, "IN1"), 7,6,5,4,2,3,1,0);	// player 1
-		state->m_protection_ram[0x03] = BITSWAP8(input_port_read(machine, "IN2"), 7,6,5,4,2,3,1,0);	// player 2
+		state->m_protection_ram[0x02] = BITSWAP8(machine.root_device().ioport("IN1")->read(), 7,6,5,4,2,3,1,0);	// player 1
+		state->m_protection_ram[0x03] = BITSWAP8(machine.root_device().ioport("IN2")->read(), 7,6,5,4,2,3,1,0);	// player 2
 
 		if (state->m_protection_ram[0x19] == 0xaa)	// player 2 active
 			state->m_protection_ram[0x1b] = state->m_protection_ram[0x03];
@@ -293,7 +293,7 @@
 			else
 			{
 				//logerror("%04x: 68705 read input port %04x\n", cpu_get_pc(&space.device()), m_address);
-				m_latch = input_port_read(machine(), (m_address & 1) ? "IN2" : "IN1");
+				m_latch = ioport((m_address & 1) ? "IN2" : "IN1")->read();
 			}
 		}
 		else    /* write */
diff -Nru src-old/mame/machine/mhavoc.c src/mame/machine/mhavoc.c
--- src-old/mame/machine/mhavoc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/mhavoc.c	2012-05-03 11:00:08.000000000 +0200
@@ -214,7 +214,7 @@
 {
 	const char *tag1 = (const char *)param;
 	const char *tag2 = tag1 + strlen(tag1) + 1;
-	return input_port_read(machine(), m_player_1 ? tag2 : tag1) & 0x03;
+	return ioport(m_player_1 ? tag2 : tag1)->read() & 0x03;
 }
 
 CUSTOM_INPUT_MEMBER(mhavoc_state::gamma_rcvd_r)
diff -Nru src-old/mame/machine/micro3d.c src/mame/machine/micro3d.c
--- src-old/mame/machine/micro3d.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/micro3d.c	2012-05-03 11:00:08.000000000 +0200
@@ -488,16 +488,16 @@
 
 READ16_MEMBER(micro3d_state::micro3d_encoder_h_r)
 {
-	UINT16 x_encoder = input_port_read_safe(machine(), "JOYSTICK_X", 0);
-	UINT16 y_encoder = input_port_read_safe(machine(), "JOYSTICK_Y", 0);
+	UINT16 x_encoder = ioport("JOYSTICK_X")->read_safe(0);
+	UINT16 y_encoder = ioport("JOYSTICK_Y")->read_safe(0);
 
 	return (y_encoder & 0xf00) | ((x_encoder & 0xf00) >> 8);
 }
 
 READ16_MEMBER(micro3d_state::micro3d_encoder_l_r)
 {
-	UINT16 x_encoder = input_port_read_safe(machine(), "JOYSTICK_X", 0);
-	UINT16 y_encoder = input_port_read_safe(machine(), "JOYSTICK_Y", 0);
+	UINT16 x_encoder = ioport("JOYSTICK_X")->read_safe(0);
+	UINT16 y_encoder = ioport("JOYSTICK_Y")->read_safe(0);
 
 	return ((y_encoder & 0xff) << 8) | (x_encoder & 0xff);
 }
@@ -508,9 +508,9 @@
 
 	switch (param)
 	{
-		case 0: state->m_adc_val = input_port_read_safe(machine, "THROTTLE", 0);
+		case 0: state->m_adc_val = state->ioport("THROTTLE")->read_safe(0);
 				break;
-		case 1: state->m_adc_val = (UINT8)((255.0/100.0) * input_port_read(machine, "VOLUME") + 0.5);
+		case 1: state->m_adc_val = (UINT8)((255.0/100.0) * state->ioport("VOLUME")->read() + 0.5);
 				break;
 		case 2: break;
 		case 3: break;
diff -Nru src-old/mame/machine/midtunit.c src/mame/machine/midtunit.c
--- src-old/mame/machine/midtunit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/midtunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -105,7 +105,7 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "DSW" };
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 
@@ -526,7 +526,7 @@
 	/* sound chip protection (hidden RAM) */
 	machine.device("adpcm:cpu")->memory().space(AS_PROGRAM)->install_read_bank(0xfbcf, 0xfbf9, "bank7");
 	machine.device("adpcm:cpu")->memory().space(AS_PROGRAM)->install_write_bank(0xfbcf, 0xfbf9, "bank9");
-	state->membank("bank9")->set_base(auto_alloc_array(machine, UINT8, 0x80));
+	state->membank("adpcm:bank9")->set_base(auto_alloc_array(machine, UINT8, 0x80));
 
 #if ENABLE_ALL_JDREDD_LEVELS
 	/* how about the final levels? */
diff -Nru src-old/mame/machine/midwayic.c src/mame/machine/midwayic.c
--- src-old/mame/machine/midwayic.c	2011-04-09 20:38:50.000000000 +0200
+++ src/mame/machine/midwayic.c	2012-05-03 11:00:08.000000000 +0200
@@ -862,7 +862,7 @@
 	switch (offset)
 	{
 		case IOASIC_PORT0:
-			result = input_port_read(space->machine(), "DIPS");
+			result = space->machine().root_device().ioport("DIPS")->read();
 			/* bit 0 seems to be a ready flag before shuffling happens */
 			if (!ioasic.shuffle_active)
 			{
@@ -874,15 +874,15 @@
 			break;
 
 		case IOASIC_PORT1:
-			result = input_port_read(space->machine(), "SYSTEM");
+			result = space->machine().root_device().ioport("SYSTEM")->read();
 			break;
 
 		case IOASIC_PORT2:
-			result = input_port_read(space->machine(), "IN1");
+			result = space->machine().root_device().ioport("IN1")->read();
 			break;
 
 		case IOASIC_PORT3:
-			result = input_port_read(space->machine(), "IN2");
+			result = space->machine().root_device().ioport("IN2")->read();
 			break;
 
 		case IOASIC_UARTIN:
diff -Nru src-old/mame/machine/midwunit.c src/mame/machine/midwunit.c
--- src-old/mame/machine/midwunit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/midwunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -126,7 +126,7 @@
 		case 1:
 		case 2:
 		case 3:
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 
 		case 4:
 			return (midway_serial_pic_status_r() << 12) | midwunit_sound_state_r(space,0,0xffff);
@@ -156,7 +156,7 @@
 	register_state_saving(machine);
 
 	/* load the graphics ROMs -- quadruples */
-	midtunit_gfx_rom = base = machine.root_device().memregion("gfx1")->base();
+	midtunit_gfx_rom = base = state->memregion("gfx1")->base();
 	len = state->memregion("gfx1")->bytes();
 	for (i = 0; i < len / 0x400000; i++)
 	{
diff -Nru src-old/mame/machine/midxunit.c src/mame/machine/midxunit.c
--- src-old/mame/machine/midxunit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/midxunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -126,7 +126,7 @@
 		case 1:
 		case 2:
 		case 3:
-			return input_port_read(machine(), portnames[offset]);
+			return ioport(portnames[offset])->read();
 
 		default:
 			logerror("%08X:Unknown I/O read from %d\n", cpu_get_pc(&space.device()), offset);
@@ -140,7 +140,7 @@
 {
 	static const char *const portnames[] = { "AN0", "AN1", "AN2", "AN3", "AN4", "AN5" };
 
-	return input_port_read(machine(), portnames[m_analog_port]);
+	return ioport(portnames[m_analog_port])->read();
 }
 
 
@@ -299,7 +299,7 @@
 	register_state_saving(machine);
 
 	/* load the graphics ROMs -- quadruples */
-	midtunit_gfx_rom = base = machine.root_device().memregion("gfx1")->base();
+	midtunit_gfx_rom = base = state->memregion("gfx1")->base();
 	len = state->memregion("gfx1")->bytes();
 	for (i = 0; i < len / 0x200000; i++)
 	{
diff -Nru src-old/mame/machine/midyunit.c src/mame/machine/midyunit.c
--- src-old/mame/machine/midyunit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/midyunit.c	2012-05-03 11:00:08.000000000 +0200
@@ -114,7 +114,7 @@
 {
 	static const char *const portnames[] = { "IN0", "IN1", "IN2", "DSW", "UNK0", "UNK1" };
 
-	return input_port_read(machine(), portnames[offset]);
+	return ioport(portnames[offset])->read();
 }
 
 
@@ -130,15 +130,15 @@
 	static const char *const portnames[] = { "IN0", "IN1", NULL, "DSW", "UNK0", "UNK1" };
 
 	if (offset != 2)
-		return input_port_read(machine(), portnames[offset]);
+		return ioport(portnames[offset])->read();
 
 	switch (m_term2_analog_select)
 	{
 		default:
-		case 0:  return input_port_read(machine(), "STICK0_X");
-		case 1:  return input_port_read(machine(), "STICK0_Y");
-		case 2:  return input_port_read(machine(), "STICK1_X");
-		case 3:  return input_port_read(machine(), "STICK1_Y");
+		case 0:  return ioport("STICK0_X")->read();
+		case 1:  return ioport("STICK0_Y")->read();
+		case 2:  return ioport("STICK1_X")->read();
+		case 3:  return ioport("STICK1_Y")->read();
 	}
 }
 
diff -Nru src-old/mame/machine/mie.c src/mame/machine/mie.c
--- src-old/mame/machine/mie.c	2012-04-10 22:13:30.000000000 +0200
+++ src/mame/machine/mie.c	2012-05-03 11:00:08.000000000 +0200
@@ -202,7 +202,7 @@
 READ8_MEMBER(mie_device::gpio_r)
 {
 	if(gpiodir & (1 << offset))
-		return gpio_name[offset] ? input_port_read(machine(), gpio_name[offset]) : 0xff;
+		return gpio_name[offset] ? ioport(gpio_name[offset])->read() : 0xff;
 	else
 		return gpio_val[offset];
 }
@@ -211,7 +211,7 @@
 {
 	gpio_val[offset] = data;
 	if(!(gpiodir & (1 << offset)) && gpio_name[offset])
-		input_port_write(machine(), gpio_name[offset], data, 0xff);
+		ioport(gpio_name[offset])->write(data, 0xff);
 }
 
 READ8_MEMBER(mie_device::gpiodir_r)
diff -Nru src-old/mame/machine/n64.c src/mame/machine/n64.c
--- src-old/mame/machine/n64.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/n64.c	2012-05-03 11:00:08.000000000 +0200
@@ -1781,9 +1781,9 @@
 				case 1: //p2 inputs
 				{
 					//printf("Read p%d inputs\n", channel + 1);
-                    buttons = input_port_read(machine(), portnames[(channel*3) + 0]);
-                    x = input_port_read(machine(), portnames[(channel*3) + 1]) - 128;
-                    y = input_port_read(machine(), portnames[(channel*3) + 2]) - 128;
+                    buttons = ioport(portnames[(channel*3) + 0])->read();
+                    x = ioport(portnames[(channel*3) + 1])->read() - 128;
+                    y = ioport(portnames[(channel*3) + 2])->read() - 128;
 
 					rdata[0] = (buttons >> 8) & 0xff;
 					rdata[1] = (buttons >> 0) & 0xff;
diff -Nru src-old/mame/machine/namcos1.c src/mame/machine/namcos1.c
--- src-old/mame/machine/namcos1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/namcos1.c	2012-05-03 11:00:08.000000000 +0200
@@ -1282,9 +1282,9 @@
 		int ret;
 
 		if (!qnum)
-			ret = (input_port_read(space->machine(), "CONTROL0")&0x90) | qstrobe | (input_port_read(space->machine(), "PADDLE0")&0x0f);
+			ret = (space->machine().root_device().ioport("CONTROL0")->read()&0x90) | qstrobe | (space->machine().root_device().ioport("PADDLE0")->read()&0x0f);
 		else
-			ret = (input_port_read(space->machine(), "CONTROL0")&0x90) | qstrobe | (input_port_read(space->machine(), "PADDLE1")&0x0f);
+			ret = (space->machine().root_device().ioport("CONTROL0")->read()&0x90) | qstrobe | (space->machine().root_device().ioport("PADDLE1")->read()&0x0f);
 
 		qstrobe ^= 0x40;
 
@@ -1295,9 +1295,9 @@
 		int ret;
 
 		if (!qnum)
-			ret = (input_port_read(space->machine(), "CONTROL1")&0x90) | qnum | (input_port_read(space->machine(), "PADDLE0")>>4);
+			ret = (space->machine().root_device().ioport("CONTROL1")->read()&0x90) | qnum | (space->machine().root_device().ioport("PADDLE0")->read()>>4);
 		else
-			ret = (input_port_read(space->machine(), "CONTROL1")&0x90) | qnum | (input_port_read(space->machine(), "PADDLE1")>>4);
+			ret = (space->machine().root_device().ioport("CONTROL1")->read()&0x90) | qnum | (space->machine().root_device().ioport("PADDLE1")->read()>>4);
 
 		if (!qstrobe) qnum ^= 0x20;
 
@@ -1327,7 +1327,7 @@
 	{
 		int inp = input_count;
 
-		if (inp == 4) res = input_port_read(space->machine(), "CONTROL0");
+		if (inp == 4) res = space->machine().root_device().ioport("CONTROL0")->read();
 		else
 		{
 			char portname[40];
@@ -1336,7 +1336,7 @@
 			static int counter[4];
 
 			sprintf(portname,"IN%d",inp);	/* IN0-IN3 */
-			res = input_port_read(space->machine(), portname);
+			res = space->machine().root_device().ioport(portname)->read();
 			if (res & 0x80)
 			{
 				if (counter[inp] >= 0)
@@ -1360,7 +1360,7 @@
 				counter[inp] = -1;
 #else
 			sprintf(portname,"IN%d",inp);	/* IN0-IN3 */
-			res = input_port_read(space->machine(), portname);
+			res = space->machine().root_device().ioport(portname)->read();
 			if (res & 1) res = 0x7f;		/* weak */
 			else if (res & 2) res = 0x48;	/* medium */
 			else if (res & 4) res = 0x40;	/* strong */
@@ -1371,7 +1371,7 @@
 	}
 	else
 	{
-		res = input_port_read(space->machine(), "CONTROL1") & 0x8f;
+		res = space->machine().root_device().ioport("CONTROL1")->read() & 0x8f;
 
 		/* the strobe cannot happen too often, otherwise the MCU will waste too
            much time reading the inputs and won't have enough cycles to play two
@@ -1413,13 +1413,13 @@
 
 	if (offset == 0)
 	{
-		res = (input_port_read(space->machine(), "CONTROL0") & 0x80) | stored_input[0];
+		res = (space->machine().root_device().ioport("CONTROL0")->read() & 0x80) | stored_input[0];
 
 		return res;
 	}
 	else
 	{
-		res = input_port_read(space->machine(), "CONTROL1") & 0x80;
+		res = space->machine().root_device().ioport("CONTROL1")->read() & 0x80;
 
 		/* the strobe cannot happen too often, otherwise the MCU will waste too
            much time reading the inputs and won't have enough cycles to play two
@@ -1434,17 +1434,17 @@
 			switch (input_count)
 			{
 				case 0:
-					stored_input[0] = input_port_read(space->machine(), "IN0") & 0x1f;
-					stored_input[1] = (input_port_read(space->machine(), "IN3") & 0x07) << 3;
+					stored_input[0] = space->machine().root_device().ioport("IN0")->read() & 0x1f;
+					stored_input[1] = (space->machine().root_device().ioport("IN3")->read() & 0x07) << 3;
 					break;
 
 				case 3:
-					stored_input[0] = input_port_read(space->machine(), "IN2") & 0x1f;
+					stored_input[0] = space->machine().root_device().ioport("IN2")->read() & 0x1f;
 					break;
 
 				case 4:
-					stored_input[0] = input_port_read(space->machine(), "IN1") & 0x1f;
-					stored_input[1] = input_port_read(space->machine(), "IN3") & 0x18;
+					stored_input[0] = space->machine().root_device().ioport("IN1")->read() & 0x1f;
+					stored_input[1] = space->machine().root_device().ioport("IN3")->read() & 0x18;
 					break;
 
 				default:
diff -Nru src-old/mame/machine/namcos2.c src/mame/machine/namcos2.c
--- src-old/mame/machine/namcos2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/namcos2.c	2012-05-03 11:00:08.000000000 +0200
@@ -736,28 +736,28 @@
 		switch((data>>2) & 0x07)
 		{
 		case 0:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN0");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN0")->read();
 			break;
 		case 1:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN1");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN1")->read();
 			break;
 		case 2:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN2");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN2")->read();
 			break;
 		case 3:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN3");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN3")->read();
 			break;
 		case 4:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN4");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN4")->read();
 			break;
 		case 5:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN5");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN5")->read();
 			break;
 		case 6:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN6");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN6")->read();
 			break;
 		case 7:
-			namcos2_mcu_analog_data=input_port_read(space->machine(), "AN7");
+			namcos2_mcu_analog_data=space->machine().root_device().ioport("AN7")->read();
 			break;
 		default:
 			output_set_value("anunk",data);
@@ -815,14 +815,14 @@
 	int data = 0;
 
 	/* Read/convert the bits one at a time */
-	if(input_port_read(space->machine(), "AN0") > threshold) data |= 0x01;
-	if(input_port_read(space->machine(), "AN1") > threshold) data |= 0x02;
-	if(input_port_read(space->machine(), "AN2") > threshold) data |= 0x04;
-	if(input_port_read(space->machine(), "AN3") > threshold) data |= 0x08;
-	if(input_port_read(space->machine(), "AN4") > threshold) data |= 0x10;
-	if(input_port_read(space->machine(), "AN5") > threshold) data |= 0x20;
-	if(input_port_read(space->machine(), "AN6") > threshold) data |= 0x40;
-	if(input_port_read(space->machine(), "AN7") > threshold) data |= 0x80;
+	if(space->machine().root_device().ioport("AN0")->read() > threshold) data |= 0x01;
+	if(space->machine().root_device().ioport("AN1")->read() > threshold) data |= 0x02;
+	if(space->machine().root_device().ioport("AN2")->read() > threshold) data |= 0x04;
+	if(space->machine().root_device().ioport("AN3")->read() > threshold) data |= 0x08;
+	if(space->machine().root_device().ioport("AN4")->read() > threshold) data |= 0x10;
+	if(space->machine().root_device().ioport("AN5")->read() > threshold) data |= 0x20;
+	if(space->machine().root_device().ioport("AN6")->read() > threshold) data |= 0x40;
+	if(space->machine().root_device().ioport("AN7")->read() > threshold) data |= 0x80;
 
 	/* Return the result */
 	return data;
@@ -830,18 +830,18 @@
 
 READ8_HANDLER( namcos2_input_port_0_r )
 {
-	int data = input_port_read(space->machine(), "MCUB");
+	int data = space->machine().root_device().ioport("MCUB")->read();
 	return data;
 }
 
 READ8_HANDLER( namcos2_input_port_10_r )
 {
-	int data = input_port_read(space->machine(), "MCUH");
+	int data = space->machine().root_device().ioport("MCUH")->read();
 	return data;
 }
 
 READ8_HANDLER( namcos2_input_port_12_r )
 {
-	int data = input_port_read(space->machine(), "MCUDI0");
+	int data = space->machine().root_device().ioport("MCUDI0")->read();
 	return data;
 }
diff -Nru src-old/mame/machine/naomigd.c src/mame/machine/naomigd.c
--- src-old/mame/machine/naomigd.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/naomigd.c	2012-05-05 06:27:05.000000000 +0200
@@ -394,7 +394,7 @@
 
 	UINT64 key;
 
-	const UINT8 *picdata = memregion(pic_tag)->base();
+	const UINT8 *picdata = machine().root_device().memregion(pic_tag)->base();
 
 	if(picdata) {
 		if(machine().root_device().memregion(pic_tag)->bytes() >= 0x4000) {
diff -Nru src-old/mame/machine/naomim1.c src/mame/machine/naomim1.c
--- src-old/mame/machine/naomim1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/naomim1.c	2012-05-05 06:27:05.000000000 +0200
@@ -31,7 +31,7 @@
 {
 	naomi_board::device_start();
 
-	const UINT8 *key_data = memregion(key_tag)->base();
+	const UINT8 *key_data = machine().root_device().memregion(key_tag)->base();
 	key = (key_data[0] << 24) | (key_data[1] << 16) | (key_data[2] << 8) | key_data[3];
 	buffer = auto_alloc_array(machine(), UINT8, BUFFER_SIZE);
 
diff -Nru src-old/mame/machine/naomim2.c src/mame/machine/naomim2.c
--- src-old/mame/machine/naomim2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/naomim2.c	2012-05-05 06:27:05.000000000 +0200
@@ -20,7 +20,7 @@
 {
 	naomi_board::device_start();
 
-	const UINT8 *key_data = memregion(key_tag)->base();
+	const UINT8 *key_data = machine().root_device().memregion(key_tag)->base();
 	key = (key_data[0] << 24) | (key_data[1] << 16) | (key_data[2] << 8) | key_data[3];
 
 	ram = auto_alloc_array(machine(), UINT8, RAM_SIZE);
diff -Nru src-old/mame/machine/naomim4.c src/mame/machine/naomim4.c
--- src-old/mame/machine/naomim4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/naomim4.c	2012-05-05 06:27:05.000000000 +0200
@@ -45,7 +45,7 @@
 {
 	naomi_board::device_start();
 
-	const UINT8 *key_data = memregion(key_tag)->base();
+	const UINT8 *key_data = machine().root_device().memregion(key_tag)->base();
 	key = (key_data[2] << 8) | key_data[3];
 	iv = (key_data[0] << 8) | key_data[1];
 	buffer = auto_alloc_array(machine(), UINT8, BUFFER_SIZE);
diff -Nru src-old/mame/machine/nb1413m3.c src/mame/machine/nb1413m3.c
--- src-old/mame/machine/nb1413m3.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/nb1413m3.c	2012-05-03 11:00:08.000000000 +0200
@@ -138,8 +138,6 @@
 	nb1413m3_inputport = 0xff;
 	nb1413m3_outcoin_flag = 1;
 
-	nb1413m3_74ls193_counter = 0;
-
 	machine.scheduler().synchronize(FUNC(nb1413m3_timer_callback));
 }
 
@@ -365,55 +363,56 @@
 
 READ8_HANDLER( nb1413m3_inputport0_r )
 {
-	return ((input_port_read(space->machine(), "SYSTEM") & 0xfd) | ((nb1413m3_outcoin_flag & 0x01) << 1));
+	return ((space->machine().root_device().ioport("SYSTEM")->read() & 0xfd) | ((nb1413m3_outcoin_flag & 0x01) << 1));
 }
 
 READ8_HANDLER( nb1413m3_inputport1_r )
 {
+	device_t &root = space->machine().root_device();
 	switch (nb1413m3_type)
 	{
 		case NB1413M3_HYHOO:
 		case NB1413M3_HYHOO2:
 			switch ((nb1413m3_inputport ^ 0xff) & 0x07)
 			{
-				case 0x01:	return input_port_read(space->machine(), "IN0");
-				case 0x02:	return input_port_read(space->machine(), "IN1");
+				case 0x01:	return root.ioport("IN0")->read();
+				case 0x02:	return root.ioport("IN1")->read();
 				case 0x04:	return 0xff;
 				default:	return 0xff;
 			}
 			break;
 		case NB1413M3_MSJIKEN:
 		case NB1413M3_TELMAHJN:
-			if (input_port_read(space->machine(), "DSWA") & 0x80)
+			if (root.ioport("DSWA")->read() & 0x80)
 			{
 				switch ((nb1413m3_inputport ^ 0xff) & 0x1f)
 				{
-					case 0x01:	return input_port_read(space->machine(), "KEY0");
-					case 0x02:	return input_port_read(space->machine(), "KEY1");
-					case 0x04:	return input_port_read(space->machine(), "KEY2");
-					case 0x08:	return input_port_read(space->machine(), "KEY3");
-					case 0x10:	return input_port_read(space->machine(), "KEY4");
-					default:	return (input_port_read(space->machine(), "KEY0") & input_port_read(space->machine(), "KEY1") & input_port_read(space->machine(), "KEY2")
-										& input_port_read(space->machine(), "KEY3") & input_port_read(space->machine(), "KEY4"));
+					case 0x01:	return root.ioport("KEY0")->read();
+					case 0x02:	return root.ioport("KEY1")->read();
+					case 0x04:	return root.ioport("KEY2")->read();
+					case 0x08:	return root.ioport("KEY3")->read();
+					case 0x10:	return root.ioport("KEY4")->read();
+					default:	return (root.ioport("KEY0")->read() & root.ioport("KEY1")->read() & root.ioport("KEY2")->read()
+										& root.ioport("KEY3")->read() & root.ioport("KEY4")->read());
 				}
 			}
-			else return input_port_read(space->machine(), "JAMMA2");
+			else return root.ioport("JAMMA2")->read();
 			break;
 		case NB1413M3_PAIRSNB:
 		case NB1413M3_PAIRSTEN:
 		case NB1413M3_OHPAIPEE:
 		case NB1413M3_TOGENKYO:
-			return input_port_read(space->machine(), "P1");
+			return root.ioport("P1")->read();
 		default:
 			switch ((nb1413m3_inputport ^ 0xff) & 0x1f)
 			{
-				case 0x01:	return input_port_read(space->machine(), "KEY0");
-				case 0x02:	return input_port_read(space->machine(), "KEY1");
-				case 0x04:	return input_port_read(space->machine(), "KEY2");
-				case 0x08:	return input_port_read(space->machine(), "KEY3");
-				case 0x10:	return input_port_read(space->machine(), "KEY4");
-				default:	return (input_port_read(space->machine(), "KEY0") & input_port_read(space->machine(), "KEY1") & input_port_read(space->machine(), "KEY2")
-									& input_port_read(space->machine(), "KEY3") & input_port_read(space->machine(), "KEY4"));
+				case 0x01:	return root.ioport("KEY0")->read();
+				case 0x02:	return root.ioport("KEY1")->read();
+				case 0x04:	return root.ioport("KEY2")->read();
+				case 0x08:	return root.ioport("KEY3")->read();
+				case 0x10:	return root.ioport("KEY4")->read();
+				default:	return (root.ioport("KEY0")->read() & root.ioport("KEY1")->read() & root.ioport("KEY2")->read()
+									& root.ioport("KEY3")->read() & root.ioport("KEY4")->read());
 			}
 			break;
 	}
@@ -421,6 +420,7 @@
 
 READ8_HANDLER( nb1413m3_inputport2_r )
 {
+	device_t &root = space->machine().root_device();
 	switch (nb1413m3_type)
 	{
 		case NB1413M3_HYHOO:
@@ -429,42 +429,42 @@
 			{
 				case 0x01:	return 0xff;
 				case 0x02:	return 0xff;
-				case 0x04:	return input_port_read(space->machine(), "IN2");
+				case 0x04:	return root.ioport("IN2")->read();
 				default:	return 0xff;
 			}
 			break;
 		case NB1413M3_MSJIKEN:
 		case NB1413M3_TELMAHJN:
-			if (input_port_read(space->machine(), "DSWA") & 0x80)
+			if (root.ioport("DSWA")->read() & 0x80)
 			{
 				switch ((nb1413m3_inputport ^ 0xff) & 0x1f)
 				{
-					case 0x01:	return input_port_read(space->machine(), "KEY5");
-					case 0x02:	return input_port_read(space->machine(), "KEY6");
-					case 0x04:	return input_port_read(space->machine(), "KEY7");
-					case 0x08:	return input_port_read(space->machine(), "KEY8");
-					case 0x10:	return input_port_read(space->machine(), "KEY9");
-					default:	return (input_port_read(space->machine(), "KEY5") & input_port_read(space->machine(), "KEY6") & input_port_read(space->machine(), "KEY7")
-										& input_port_read(space->machine(), "KEY8") & input_port_read(space->machine(), "KEY9"));
+					case 0x01:	return root.ioport("KEY5")->read();
+					case 0x02:	return root.ioport("KEY6")->read();
+					case 0x04:	return root.ioport("KEY7")->read();
+					case 0x08:	return root.ioport("KEY8")->read();
+					case 0x10:	return root.ioport("KEY9")->read();
+					default:	return (root.ioport("KEY5")->read() & root.ioport("KEY6")->read() & root.ioport("KEY7")->read()
+										& root.ioport("KEY8")->read() & root.ioport("KEY9")->read());
 				}
 			}
-			else return input_port_read(space->machine(), "JAMMA1");
+			else return root.ioport("JAMMA1")->read();
 			break;
 		case NB1413M3_PAIRSNB:
 		case NB1413M3_PAIRSTEN:
 		case NB1413M3_OHPAIPEE:
 		case NB1413M3_TOGENKYO:
-			return input_port_read(space->machine(), "P2");
+			return root.ioport("P2")->read();
 		default:
 			switch ((nb1413m3_inputport ^ 0xff) & 0x1f)
 			{
-				case 0x01:	return input_port_read(space->machine(), "KEY5");
-				case 0x02:	return input_port_read(space->machine(), "KEY6");
-				case 0x04:	return input_port_read(space->machine(), "KEY7");
-				case 0x08:	return input_port_read(space->machine(), "KEY8");
-				case 0x10:	return input_port_read(space->machine(), "KEY9");
-				default:	return (input_port_read(space->machine(), "KEY5") & input_port_read(space->machine(), "KEY6") & input_port_read(space->machine(), "KEY7")
-									& input_port_read(space->machine(), "KEY8") & input_port_read(space->machine(), "KEY9"));
+				case 0x01:	return root.ioport("KEY5")->read();
+				case 0x02:	return root.ioport("KEY6")->read();
+				case 0x04:	return root.ioport("KEY7")->read();
+				case 0x08:	return root.ioport("KEY8")->read();
+				case 0x10:	return root.ioport("KEY9")->read();
+				default:	return (root.ioport("KEY5")->read() & root.ioport("KEY6")->read() & root.ioport("KEY7")->read()
+									& root.ioport("KEY8")->read() & root.ioport("KEY9")->read());
 			}
 			break;
 	}
@@ -495,18 +495,19 @@
 
 READ8_HANDLER( nb1413m3_dipsw1_r )
 {
+	device_t &root = space->machine().root_device();
 	switch (nb1413m3_type)
 	{
 		case NB1413M3_KANATUEN:
 		case NB1413M3_KYUHITO:
-			return input_port_read(space->machine(), "DSWB");
+			return root.ioport("DSWB")->read();
 		case NB1413M3_TAIWANMB:
-			return ((input_port_read(space->machine(), "DSWA") & 0xf0) | ((input_port_read(space->machine(), "DSWB") & 0xf0) >> 4));
+			return ((root.ioport("DSWA")->read() & 0xf0) | ((root.ioport("DSWB")->read() & 0xf0) >> 4));
 		case NB1413M3_OTONANO:
 		case NB1413M3_MJCAMERA:
 		case NB1413M3_IDHIMITU:
 		case NB1413M3_KAGUYA2:
-			return (((input_port_read(space->machine(), "DSWA") & 0x0f) << 4) | (input_port_read(space->machine(), "DSWB") & 0x0f));
+			return (((root.ioport("DSWA")->read() & 0x0f) << 4) | (root.ioport("DSWB")->read() & 0x0f));
 		case NB1413M3_SCANDAL:
 		case NB1413M3_SCANDALM:
 		case NB1413M3_MJFOCUSM:
@@ -517,7 +518,7 @@
 		case NB1413M3_UCHUUAI:
 		case NB1413M3_TOKIMBSJ:
 		case NB1413M3_TOKYOGAL:
-			return ((input_port_read(space->machine(), "DSWA") & 0x0f) | ((input_port_read(space->machine(), "DSWB") & 0x0f) << 4));
+			return ((root.ioport("DSWA")->read() & 0x0f) | ((root.ioport("DSWB")->read() & 0x0f) << 4));
 		case NB1413M3_TRIPLEW1:
 		case NB1413M3_NTOPSTAR:
 		case NB1413M3_PSTADIUM:
@@ -527,29 +528,30 @@
 		case NB1413M3_MJLSTORY:
 		case NB1413M3_QMHAYAKU:
 		case NB1413M3_MJGOTTUB:
-			return (((input_port_read(space->machine(), "DSWB") & 0x01) >> 0) | ((input_port_read(space->machine(), "DSWB") & 0x04) >> 1) |
-			        ((input_port_read(space->machine(), "DSWB") & 0x10) >> 2) | ((input_port_read(space->machine(), "DSWB") & 0x40) >> 3) |
-			        ((input_port_read(space->machine(), "DSWA") & 0x01) << 4) | ((input_port_read(space->machine(), "DSWA") & 0x04) << 3) |
-			        ((input_port_read(space->machine(), "DSWA") & 0x10) << 2) | ((input_port_read(space->machine(), "DSWA") & 0x40) << 1));
+			return (((root.ioport("DSWB")->read() & 0x01) >> 0) | ((root.ioport("DSWB")->read() & 0x04) >> 1) |
+			        ((root.ioport("DSWB")->read() & 0x10) >> 2) | ((root.ioport("DSWB")->read() & 0x40) >> 3) |
+			        ((root.ioport("DSWA")->read() & 0x01) << 4) | ((root.ioport("DSWA")->read() & 0x04) << 3) |
+			        ((root.ioport("DSWA")->read() & 0x10) << 2) | ((root.ioport("DSWA")->read() & 0x40) << 1));
 		default:
-			return input_port_read(space->machine(), "DSWA");
+			return space->machine().root_device().ioport("DSWA")->read();
 	}
 }
 
 READ8_HANDLER( nb1413m3_dipsw2_r )
 {
+	device_t &root = space->machine().root_device();
 	switch (nb1413m3_type)
 	{
 		case NB1413M3_KANATUEN:
 		case NB1413M3_KYUHITO:
-			return input_port_read(space->machine(), "DSWA");
+			return root.ioport("DSWA")->read();
 		case NB1413M3_TAIWANMB:
-			return (((input_port_read(space->machine(), "DSWA") & 0x0f) << 4) | (input_port_read(space->machine(), "DSWB") & 0x0f));
+			return (((root.ioport("DSWA")->read() & 0x0f) << 4) | (root.ioport("DSWB")->read() & 0x0f));
 		case NB1413M3_OTONANO:
 		case NB1413M3_MJCAMERA:
 		case NB1413M3_IDHIMITU:
 		case NB1413M3_KAGUYA2:
-			return ((input_port_read(space->machine(), "DSWA") & 0xf0) | ((input_port_read(space->machine(), "DSWB") & 0xf0) >> 4));
+			return ((root.ioport("DSWA")->read() & 0xf0) | ((root.ioport("DSWB")->read() & 0xf0) >> 4));
 		case NB1413M3_SCANDAL:
 		case NB1413M3_SCANDALM:
 		case NB1413M3_MJFOCUSM:
@@ -560,7 +562,7 @@
 		case NB1413M3_UCHUUAI:
 		case NB1413M3_TOKIMBSJ:
 		case NB1413M3_TOKYOGAL:
-			return (((input_port_read(space->machine(), "DSWA") & 0xf0) >> 4) | (input_port_read(space->machine(), "DSWB") & 0xf0));
+			return (((root.ioport("DSWA")->read() & 0xf0) >> 4) | (root.ioport("DSWB")->read() & 0xf0));
 		case NB1413M3_TRIPLEW1:
 		case NB1413M3_NTOPSTAR:
 		case NB1413M3_PSTADIUM:
@@ -570,23 +572,23 @@
 		case NB1413M3_MJLSTORY:
 		case NB1413M3_QMHAYAKU:
 		case NB1413M3_MJGOTTUB:
-			return (((input_port_read(space->machine(), "DSWB") & 0x02) >> 1) | ((input_port_read(space->machine(), "DSWB") & 0x08) >> 2) |
-			        ((input_port_read(space->machine(), "DSWB") & 0x20) >> 3) | ((input_port_read(space->machine(), "DSWB") & 0x80) >> 4) |
-			        ((input_port_read(space->machine(), "DSWA") & 0x02) << 3) | ((input_port_read(space->machine(), "DSWA") & 0x08) << 2) |
-			        ((input_port_read(space->machine(), "DSWA") & 0x20) << 1) | ((input_port_read(space->machine(), "DSWA") & 0x80) << 0));
+			return (((root.ioport("DSWB")->read() & 0x02) >> 1) | ((root.ioport("DSWB")->read() & 0x08) >> 2) |
+			        ((root.ioport("DSWB")->read() & 0x20) >> 3) | ((root.ioport("DSWB")->read() & 0x80) >> 4) |
+			        ((root.ioport("DSWA")->read() & 0x02) << 3) | ((root.ioport("DSWA")->read() & 0x08) << 2) |
+			        ((root.ioport("DSWA")->read() & 0x20) << 1) | ((root.ioport("DSWA")->read() & 0x80) << 0));
 		default:
-			return input_port_read(space->machine(), "DSWB");
+			return space->machine().root_device().ioport("DSWB")->read();
 	}
 }
 
 READ8_HANDLER( nb1413m3_dipsw3_l_r )
 {
-	return ((input_port_read(space->machine(), "DSWC") & 0xf0) >> 4);
+	return ((space->machine().root_device().ioport("DSWC")->read() & 0xf0) >> 4);
 }
 
 READ8_HANDLER( nb1413m3_dipsw3_h_r )
 {
-	return ((input_port_read(space->machine(), "DSWC") & 0x0f) >> 0);
+	return ((space->machine().root_device().ioport("DSWC")->read() & 0x0f) >> 0);
 }
 
 WRITE8_HANDLER( nb1413m3_outcoin_w )
diff -Nru src-old/mame/machine/nitedrvr.c src/mame/machine/nitedrvr.c
--- src-old/mame/machine/nitedrvr.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/nitedrvr.c	2012-05-03 11:00:08.000000000 +0200
@@ -21,7 +21,7 @@
 static int nitedrvr_steering( running_machine &machine )
 {
 	nitedrvr_state *state = machine.driver_data<nitedrvr_state>();
-	int this_val = input_port_read(machine, "STEER");
+	int this_val = state->ioport("STEER")->read();
 	int delta = this_val - state->m_last_steering_val;
 
 	state->m_last_steering_val = this_val;
@@ -98,7 +98,7 @@
 
 READ8_MEMBER(nitedrvr_state::nitedrvr_in0_r)
 {
-	int gear = input_port_read(machine(), "GEARS");
+	int gear = ioport("GEARS")->read();
 
 	if (gear & 0x10)				m_gear = 1;
 	else if (gear & 0x20)			m_gear = 2;
@@ -108,9 +108,9 @@
 	switch (offset & 0x03)
 	{
 		case 0x00:						/* No remapping necessary */
-			return input_port_read(machine(), "DSW0");
+			return ioport("DSW0")->read();
 		case 0x01:						/* No remapping necessary */
-			return input_port_read(machine(), "DSW1");
+			return ioport("DSW1")->read();
 		case 0x02:						/* Remap our gear shift */
 			if (m_gear == 1)
 				return 0xe0;
@@ -121,7 +121,7 @@
 			else
 				return 0x70;
 		case 0x03:						/* Remap our steering */
-			return (input_port_read(machine(), "DSW2") | nitedrvr_steering(machine()));
+			return (ioport("DSW2")->read() | nitedrvr_steering(machine()));
 		default:
 			return 0xff;
 	}
@@ -161,7 +161,7 @@
 
 READ8_MEMBER(nitedrvr_state::nitedrvr_in1_r)
 {
-	int port = input_port_read(machine(), "IN0");
+	int port = ioport("IN0")->read();
 
 	m_ac_line = (m_ac_line + 1) % 3;
 
diff -Nru src-old/mame/machine/opwolf.c src/mame/machine/opwolf.c
--- src-old/mame/machine/opwolf.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/opwolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -529,8 +529,8 @@
 	opwolf_state *state = machine.driver_data<opwolf_state>();
 
 	// Update input ports, these are used by both the 68k directly and by the c-chip
-	state->m_cchip_ram[0x4] = input_port_read(machine, "IN0");
-	state->m_cchip_ram[0x5] = input_port_read(machine, "IN1");
+	state->m_cchip_ram[0x4] = state->ioport("IN0")->read();
+	state->m_cchip_ram[0x5] = state->ioport("IN1")->read();
 
 	// Coin slots
 	if (state->m_cchip_ram[0x4] != state->m_cchip_last_04)
diff -Nru src-old/mame/machine/pcecommn.c src/mame/machine/pcecommn.c
--- src-old/mame/machine/pcecommn.c	2011-03-29 18:31:32.000000000 +0200
+++ src/mame/machine/pcecommn.c	2012-05-03 11:00:08.000000000 +0200
@@ -57,7 +57,7 @@
 	}
 	else
 	{
-		data = input_port_read(space->machine(), "JOY");
+		data = space->machine().root_device().ioport("JOY")->read();
 	}
 	if(joystick_data_select) data >>= 4;
 	ret = (data & 0x0F) | pce.io_port_options;
diff -Nru src-old/mame/machine/pckeybrd.c src/mame/machine/pckeybrd.c
--- src-old/mame/machine/pckeybrd.c	2012-04-22 07:07:46.000000000 +0200
+++ src/mame/machine/pckeybrd.c	2012-05-03 11:00:08.000000000 +0200
@@ -183,7 +183,7 @@
 	int scan_code_set;
 	int last_code;
 
-	const input_port_config *ports[8];
+	ioport_port *ports[8];
 } at_keyboard;
 
 static at_keyboard keyboard;
@@ -306,8 +306,8 @@
 
 static int at_keyboard_queue_size(void);
 static int at_keyboard_queue_chars(running_machine &machine, const unicode_char *text, size_t text_len);
-static int at_keyboard_accept_char(running_machine &machine, unicode_char ch);
-static int at_keyboard_charqueue_empty(running_machine &machine);
+static bool at_keyboard_accept_char(running_machine &machine, unicode_char ch);
+static bool at_keyboard_charqueue_empty(running_machine &machine);
 
 
 
@@ -339,10 +339,10 @@
 		keyboard.ports[i] = machine.root_device().ioport(buf);
 	}
 
-	inputx_setup_natural_keyboard(machine,
-		at_keyboard_queue_chars,
-		at_keyboard_accept_char,
-		at_keyboard_charqueue_empty);
+	machine.ioport().natkeyboard().configure(
+		ioport_queue_chars_delegate(FUNC(at_keyboard_queue_chars), &machine),
+		ioport_accept_char_delegate(FUNC(at_keyboard_accept_char), &machine),
+		ioport_charqueue_empty_delegate(FUNC(at_keyboard_charqueue_empty), &machine));
 }
 
 
@@ -499,7 +499,7 @@
 {
 	UINT32 result = 0;
 	if (keyboard.ports[port] != NULL)
-		result = input_port_read_direct(keyboard.ports[port]);
+		result = keyboard.ports[port]->read();
 	return result;
 }
 
@@ -1237,14 +1237,14 @@
   Inputx stuff
 ***************************************************************************/
 
-static int at_keyboard_accept_char(running_machine &machine, unicode_char ch)
+static bool at_keyboard_accept_char(running_machine &machine, unicode_char ch)
 {
 	return unicode_char_to_at_keycode(ch) != 0;
 }
 
 
 
-static int at_keyboard_charqueue_empty(running_machine &machine)
+static bool at_keyboard_charqueue_empty(running_machine &machine)
 {
 	return at_keyboard_queue_size() == 0;
 }
diff -Nru src-old/mame/machine/pgmprot.c src/mame/machine/pgmprot.c
--- src-old/mame/machine/pgmprot.c	2012-03-27 17:44:54.000000000 +0200
+++ src/mame/machine/pgmprot.c	2012-05-03 11:00:08.000000000 +0200
@@ -21,7 +21,7 @@
 
 	// The mode is dependent on the region
 	static const int modes[4] = { 1, 1, 3, 2 };
-	int mode = modes[input_port_read(machine, "Region") & 3];
+	int mode = modes[machine.root_device().ioport("Region")->read() & 3];
 
 	switch (mode)
 	{
@@ -60,9 +60,9 @@
 
 	switch (state->m_asic3_reg)
 	{
-	case 0x00: res = (state->m_asic3_latch[0] & 0xf7) | ((input_port_read(space->machine(), "Region") << 3) & 0x08); break;
+	case 0x00: res = (state->m_asic3_latch[0] & 0xf7) | ((state->ioport("Region")->read() << 3) & 0x08); break;
 	case 0x01: res = state->m_asic3_latch[1]; break;
-	case 0x02: res = (state->m_asic3_latch[2] & 0x7f) | ((input_port_read(space->machine(), "Region") << 6) & 0x80); break;
+	case 0x02: res = (state->m_asic3_latch[2] & 0x7f) | ((state->ioport("Region")->read() << 6) & 0x80); break;
 	case 0x03:
 		res = (BIT(state->m_asic3_hold, 15) << 0)
 			| (BIT(state->m_asic3_hold, 12) << 1)
diff -Nru src-old/mame/machine/pgmprot1.c src/mame/machine/pgmprot1.c
--- src-old/mame/machine/pgmprot1.c	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/machine/pgmprot1.c	2012-05-03 11:00:08.000000000 +0200
@@ -273,7 +273,7 @@
 static READ16_HANDLER( kovsh_fake_region_r )
 {
 	pgm_arm_type1_state *state = space->machine().driver_data<pgm_arm_type1_state>();
-	int regionhack = input_port_read(space->machine(), "RegionHack");
+	int regionhack = state->ioport("RegionHack")->read();
 	if (regionhack != 0xff) return regionhack;
 
 	offset = 0x4;
@@ -1388,7 +1388,7 @@
 static READ16_HANDLER( pgm_arm7_type1_sim_protram_r )
 {
 	if (offset == 4)
-		return input_port_read(space->machine(), "Region");
+		return space->machine().root_device().ioport("Region")->read();
 
 	return 0x0000;
 }
@@ -1398,7 +1398,7 @@
 	pgm_arm_type1_state *state = space->machine().driver_data<pgm_arm_type1_state>();
 
 	if (offset == 4)		//region
-		return input_port_read(space->machine(), "Region");
+		return state->ioport("Region")->read();
 	else if (offset >= 0x10)  //timer
 	{
 		logerror("PSTARS ACCESS COUNTER %6X\n", state->m_extra_ram[offset - 0x10]);
diff -Nru src-old/mame/machine/pgmprot2.c src/mame/machine/pgmprot2.c
--- src-old/mame/machine/pgmprot2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/pgmprot2.c	2012-05-03 11:00:08.000000000 +0200
@@ -182,7 +182,7 @@
 {
 	pgm_arm_type2_state *state = space->machine().driver_data<pgm_arm_type2_state>();
 	int pc = cpu_get_pc(&space->device());
-	int regionhack = input_port_read(space->machine(), "RegionHack");
+	int regionhack = state->ioport("RegionHack")->read();
 	if (pc==0x190 && regionhack != 0xff) data = (data & 0xffff0000) | (regionhack << 0);
 	COMBINE_DATA(&state->m_arm7_shareram[0x138/4]);
 }
@@ -235,7 +235,7 @@
 {
 	pgm_arm_type2_state *state = space->machine().driver_data<pgm_arm_type2_state>();
 	int pc = cpu_get_pc(&space->device());
-	int regionhack = input_port_read(space->machine(), "RegionHack");
+	int regionhack = state->ioport("RegionHack")->read();
 	if (pc==0x170 && regionhack != 0xff) data = (data & 0xffff0000) | (regionhack << 0);
 	COMBINE_DATA(&state->m_arm7_shareram[0x138/4]);
 }
@@ -256,7 +256,7 @@
 {
 	pgm_arm_type2_state *state = space->machine().driver_data<pgm_arm_type2_state>();
 	int pc = cpu_get_pc(&space->device());
-	int regionhack = input_port_read(space->machine(), "RegionHack");
+	int regionhack = state->ioport("RegionHack")->read();
 	if (pc==0x0174 && regionhack != 0xff) data = (data & 0x0000ffff) | (regionhack << 16);
 	COMBINE_DATA(&state->m_arm7_shareram[0x0]);
 }
@@ -312,8 +312,8 @@
 
 DRIVER_INIT( dw2001 )
 {
-	//pgm_arm_type2_state *state = machine.driver_data<pgm_arm_type2_state>();
-	UINT16 *mem16 = (UINT16 *)machine.root_device().memregion("maincpu")->base();
+	pgm_arm_type2_state *state = machine.driver_data<pgm_arm_type2_state>();
+	UINT16 *mem16 = (UINT16 *)state->memregion("maincpu")->base();
 
 	pgm_basic_init(machine);
 	kov2_latch_init(machine);
@@ -330,7 +330,7 @@
 	mem16[0x11eb04 / 2] = 0x4e71;
 
 	/* patch ARM area with fake code */
-	UINT16 *temp16 = (UINT16 *)machine.root_device().memregion("prot")->base();
+	UINT16 *temp16 = (UINT16 *)state->memregion("prot")->base();
 	temp16[(0x0000)/2] = 0xd088;
 	temp16[(0x0002)/2] = 0xe59f;
 	temp16[(0x0004)/2] = 0x0680;
@@ -346,8 +346,8 @@
 
 DRIVER_INIT( dwpc )
 {
-	//pgm_arm_type2_state *state = machine.driver_data<pgm_arm_type2_state>();
-	UINT16 *mem16 = (UINT16 *)machine.root_device().memregion("maincpu")->base();
+	pgm_arm_type2_state *state = machine.driver_data<pgm_arm_type2_state>();
+	UINT16 *mem16 = (UINT16 *)state->memregion("maincpu")->base();
 
 	pgm_basic_init(machine);
 	kov2_latch_init(machine);
@@ -365,7 +365,7 @@
 
 
 	/* patch ARM area with fake code */
-	UINT16 *temp16 = (UINT16 *)machine.root_device().memregion("prot")->base();
+	UINT16 *temp16 = (UINT16 *)state->memregion("prot")->base();
 	temp16[(0x0000)/2] = 0xd088;
 	temp16[(0x0002)/2] = 0xe59f;
 	temp16[(0x0004)/2] = 0x0680;
diff -Nru src-old/mame/machine/pgmprot4.c src/mame/machine/pgmprot4.c
--- src-old/mame/machine/pgmprot4.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/pgmprot4.c	2012-05-03 11:00:08.000000000 +0200
@@ -334,7 +334,7 @@
 			}
 			else
 			{
-				UINT32 protvalue = 0x89911400 | input_port_read(space->machine(), "Region");
+				UINT32 protvalue = 0x89911400 | space->machine().root_device().ioport("Region")->read();
 				ret = (protvalue >> (8 * (state->m_kb_ptr - 1))) & 0xff;
 			}
 
@@ -514,7 +514,7 @@
 		else if(state->m_kb_cmd==5)
 		{
 			UINT32 protvalue;
-			protvalue = 0x60000|input_port_read(space->machine(), "Region");
+			protvalue = 0x60000|space->machine().root_device().ioport("Region")->read();
 			res=(protvalue>>(8*(ptr-1)))&0xff;
 
 
diff -Nru src-old/mame/machine/pgmprot6.c src/mame/machine/pgmprot6.c
--- src-old/mame/machine/pgmprot6.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/pgmprot6.c	2012-05-03 11:00:08.000000000 +0200
@@ -120,7 +120,7 @@
 			res = state->m_olds_cmd3;
 		else if (state->m_kb_cmd == 5)
 		{
-			UINT32 protvalue = 0x900000 | input_port_read(space->machine(), "Region"); // region from protection device.
+			UINT32 protvalue = 0x900000 | state->ioport("Region")->read(); // region from protection device.
 			res = (protvalue >> (8 * (state->m_kb_ptr - 1))) & 0xff; // includes region 1 = taiwan , 2 = china, 3 = japan (title = orlegend special), 4 = korea, 5 = hongkong, 6 = world
 
 		}
diff -Nru src-old/mame/machine/playch10.c src/mame/machine/playch10.c
--- src-old/mame/machine/playch10.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/playch10.c	2012-05-03 11:00:08.000000000 +0200
@@ -46,7 +46,7 @@
 MACHINE_START( pc10 )
 {
 	playch10_state *state = machine.driver_data<playch10_state>();
-	state->m_vrom = machine.root_device().memregion("gfx2")->base();
+	state->m_vrom = state->memregion("gfx2")->base();
 
 	/* allocate 4K of nametable ram here */
 	/* move to individual boards as documentation of actual boards allows */
@@ -214,8 +214,8 @@
 		return;
 
 	/* load up the latches */
-	m_input_latch[0] = input_port_read(machine(), "P1");
-	m_input_latch[1] = input_port_read(machine(), "P2");
+	m_input_latch[0] = ioport("P1")->read();
+	m_input_latch[1] = ioport("P2")->read();
 
 	/* apply any masking from the BIOS */
 	if (m_cntrl_mask)
@@ -250,9 +250,9 @@
 	if (m_pc10_gun_controller)
 	{
 		ppu2c0x_device *ppu = machine().device<ppu2c0x_device>("ppu");
-		int trigger = input_port_read(machine(), "P1");
-		int x = input_port_read(machine(), "GUNX");
-		int y = input_port_read(machine(), "GUNY");
+		int trigger = ioport("P1")->read();
+		int x = ioport("GUNX")->read();
+		int y = ioport("GUNY")->read();
 		UINT32 pix, color_base;
 
 		/* no sprite hit (yet) */
diff -Nru src-old/mame/machine/qix.c src/mame/machine/qix.c
--- src-old/mame/machine/qix.c	2012-04-19 22:59:50.000000000 +0200
+++ src/mame/machine/qix.c	2012-05-03 11:00:08.000000000 +0200
@@ -410,7 +410,7 @@
 
 	UINT8 ddr = m_68705_ddr[1];
 	UINT8 out = m_68705_port_out[1];
-	UINT8 in = (input_port_read(machine(), "COIN") & 0x0f) | ((input_port_read(machine(), "COIN") & 0x80) >> 3);
+	UINT8 in = (ioport("COIN")->read() & 0x0f) | ((ioport("COIN")->read() & 0x80) >> 3);
 	return (out & ddr) | (in & ~ddr);
 }
 
@@ -420,7 +420,7 @@
 
 	UINT8 ddr = m_68705_ddr[2];
 	UINT8 out = m_68705_port_out[2];
-	UINT8 in = (m_coinctrl & 0x08) | ((input_port_read(machine(), "COIN") & 0x70) >> 4);
+	UINT8 in = (m_coinctrl & 0x08) | ((ioport("COIN")->read() & 0x70) >> 4);
 	return (out & ddr) | (in & ~ddr);
 }
 
@@ -534,7 +534,7 @@
 {
 	qix_state *state = device->machine().driver_data<qix_state>();
 
-	return input_port_read(device->machine(), state->m_flip ? "AN3" : "AN1");
+	return state->ioport(state->m_flip ? "AN3" : "AN1")->read();
 }
 
 
@@ -542,5 +542,5 @@
 {
 	qix_state *state = device->machine().driver_data<qix_state>();
 
-	return input_port_read(device->machine(), state->m_flip ? "AN2" : "AN0");
+	return state->ioport(state->m_flip ? "AN2" : "AN0")->read();
 }
diff -Nru src-old/mame/machine/rainbow.c src/mame/machine/rainbow.c
--- src-old/mame/machine/rainbow.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/rainbow.c	2012-05-03 11:00:08.000000000 +0200
@@ -761,10 +761,10 @@
 	coin_counter_w(machine, 1, state->m_CRAM[0][8] & 0x20);
 	coin_counter_w(machine, 0, state->m_CRAM[0][8] & 0x10);
 
-	state->m_CRAM[0][3] = input_port_read(machine, "800007");    /* STARTn + SERVICE1 */
-	state->m_CRAM[0][4] = input_port_read(machine, "800009");    /* COINn */
-	state->m_CRAM[0][5] = input_port_read(machine, "80000B");    /* Player controls + TILT */
-	state->m_CRAM[0][6] = input_port_read(machine, "80000D");    /* Player controls (cocktail) */
+	state->m_CRAM[0][3] = machine.root_device().ioport("800007")->read();    /* STARTn + SERVICE1 */
+	state->m_CRAM[0][4] = machine.root_device().ioport("800009")->read();    /* COINn */
+	state->m_CRAM[0][5] = machine.root_device().ioport("80000B")->read();    /* Player controls + TILT */
+	state->m_CRAM[0][6] = machine.root_device().ioport("80000D")->read();    /* Player controls (cocktail) */
 }
 
 /*************************************
diff -Nru src-old/mame/machine/scramble.c src/mame/machine/scramble.c
--- src-old/mame/machine/scramble.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/scramble.c	2012-05-03 11:00:08.000000000 +0200
@@ -43,7 +43,7 @@
 							  0x2b, 0x2a, 0x28, 0x29, 0x09, 0x08, 0x0a, 0x0b,
 							  0x0f, 0x0e, 0x0c, 0x0d, 0x2d, 0x2c, 0x2e, 0x2f,
 							  0x27, 0x26, 0x24, 0x25, 0x05, 0x04, 0x06, 0x07 };
-	UINT8 val = input_port_read(machine(), (const char *)param);
+	UINT8 val = ioport((const char *)param)->read();
 
 	return remap[val >> 2];
 }
diff -Nru src-old/mame/machine/segamsys.c src/mame/machine/segamsys.c
--- src-old/mame/machine/segamsys.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/segamsys.c	2012-05-03 11:00:08.000000000 +0200
@@ -1180,7 +1180,7 @@
 		end_of_frame(screen.machine(), md_sms_vdp);
 
 		// the SMS has a 'RESET' button on the machine, it generates an NMI
-		if (input_port_read_safe(screen.machine(),"PAUSE",0x00))
+		if (screen.machine().root_device().ioport("PAUSE")->read_safe(0x00))
 			cputag_set_input_line(screen.machine(), "maincpu", INPUT_LINE_NMI, PULSE_LINE);
 	}
 }
@@ -1464,7 +1464,7 @@
 
 static UINT8 ioport_gg00_r(running_machine& machine)
 {
-	UINT8 GG_START_BUTTON = input_port_read_safe(machine,"GGSTART",0x00);
+	UINT8 GG_START_BUTTON = machine.root_device().ioport("GGSTART")->read_safe(0x00);
 
 	return (GG_START_BUTTON << 7) |
 		   (0               << 6) |
@@ -1567,7 +1567,7 @@
 	running_machine &machine = space->machine();
 	/* 2009-05 FP: would it be worth to give separate inputs to SMS? SMS has only 2 keys A,B (which are B,C on megadrive) */
 	/* bit 4: TL-A; bit 5: TR-A */
-	return (input_port_read(machine, "PAD1") & 0x3f) | ((input_port_read(machine, "PAD2") & 0x03) << 6);
+	return (machine.root_device().ioport("PAD1")->read() & 0x3f) | ((machine.root_device().ioport("PAD2")->read() & 0x03) << 6);
 }
 
 READ8_HANDLER (megatech_sms_ioport_dd_r)
@@ -1575,7 +1575,7 @@
 	running_machine &machine = space->machine();
 	/* 2009-05 FP: would it be worth to give separate inputs to SMS? SMS has only 2 keys A,B (which are B,C on megadrive) */
 	/* bit 2: TL-B; bit 3: TR-B; bit 4: RESET; bit 5: unused; bit 6: TH-A; bit 7: TH-B*/
-	return ((input_port_read(machine, "PAD2") & 0x3c) >> 2) | 0x10;
+	return ((machine.root_device().ioport("PAD2")->read() & 0x3c) >> 2) | 0x10;
 }
 
 
diff -Nru src-old/mame/machine/seicop.c src/mame/machine/seicop.c
--- src-old/mame/machine/seicop.c	2012-04-09 22:23:26.000000000 +0200
+++ src/mame/machine/seicop.c	2012-05-03 11:00:08.000000000 +0200
@@ -1680,11 +1680,11 @@
 		//case (0x5b4/2):
 		//  return cop_mcu_ram[offset];
 
-		case (0x700/2): return input_port_read(space->machine(), "DSW1");
-		case (0x704/2):	return input_port_read(space->machine(), "PLAYERS12");
-		case (0x708/2):	return input_port_read(space->machine(), "PLAYERS34");
-		case (0x70c/2):	return input_port_read(space->machine(), "SYSTEM");
-		case (0x71c/2): return input_port_read(space->machine(), "DSW2");
+		case (0x700/2): return space->machine().root_device().ioport("DSW1")->read();
+		case (0x704/2):	return space->machine().root_device().ioport("PLAYERS12")->read();
+		case (0x708/2):	return space->machine().root_device().ioport("PLAYERS34")->read();
+		case (0x70c/2):	return space->machine().root_device().ioport("SYSTEM")->read();
+		case (0x71c/2): return space->machine().root_device().ioport("DSW2")->read();
 	}
 }
 
@@ -2676,7 +2676,7 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2726,12 +2726,12 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	if(offset == 0x35c/2)
 	{
-		return input_port_read(space->machine(), "DSW2");
+		return space->machine().root_device().ioport("DSW2")->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2768,12 +2768,12 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	if(offset == 0x31c/2)
 	{
-		return input_port_read(space->machine(), "DSW2");
+		return space->machine().root_device().ioport("DSW2")->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2820,7 +2820,7 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2867,12 +2867,12 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	if(offset == 0x35c/2)
 	{
-		return input_port_read(space->machine(), "DSW2");
+		return space->machine().root_device().ioport("DSW2")->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2919,12 +2919,12 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "PLAYERS34", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	if(offset == 0x35c/2)
 	{
-		return input_port_read(space->machine(), "DSW2");
+		return space->machine().root_device().ioport("DSW2")->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
@@ -2967,7 +2967,7 @@
 	{
 		static const char *const portnames[] = { "DSW1", "PLAYERS12", "UNK", "SYSTEM" };
 
-		return input_port_read(space->machine(), portnames[(offset >> 1) & 3]);
+		return space->machine().root_device().ioport(portnames[(offset >> 1) & 3])->read();
 	}
 
 	return generic_cop_r(space, offset, mem_mask);
diff -Nru src-old/mame/machine/simpsons.c src/mame/machine/simpsons.c
--- src-old/mame/machine/simpsons.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/simpsons.c	2012-05-03 11:00:08.000000000 +0200
@@ -17,7 +17,7 @@
 	if (data == 0xff)
 		return;
 
-	input_port_write(machine(), "EEPROMOUT", data, 0xff);
+	ioport("EEPROMOUT")->write(data, 0xff);
 
 	m_video_bank = data & 0x03;
 	simpsons_video_banking(machine(), m_video_bank);
diff -Nru src-old/mame/machine/slikshot.c src/mame/machine/slikshot.c
--- src-old/mame/machine/slikshot.c	2012-01-12 23:19:49.000000000 +0100
+++ src/mame/machine/slikshot.c	2012-05-03 11:00:08.000000000 +0200
@@ -559,8 +559,8 @@
 	SCREEN_UPDATE32_CALL(itech8_2page);
 
 	/* add the current X,Y positions to the list */
-	state->m_xbuffer[state->m_ybuffer_next % YBUFFER_COUNT] = input_port_read_safe(screen.machine(), "FAKEX", 0);
-	state->m_ybuffer[state->m_ybuffer_next % YBUFFER_COUNT] = input_port_read_safe(screen.machine(), "FAKEY", 0);
+	state->m_xbuffer[state->m_ybuffer_next % YBUFFER_COUNT] = state->ioport("FAKEX")->read_safe(0);
+	state->m_ybuffer[state->m_ybuffer_next % YBUFFER_COUNT] = state->ioport("FAKEY")->read_safe(0);
 	state->m_ybuffer_next++;
 
 	/* determine where to draw the starting point */
diff -Nru src-old/mame/machine/smpc.c src/mame/machine/smpc.c
--- src-old/mame/machine/smpc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/smpc.c	2012-05-03 11:00:08.000000000 +0200
@@ -345,7 +345,7 @@
 	static const char *const padnames[] = { "JOY1", "JOY2" };
 	UINT16 pad_data;
 
-	pad_data = input_port_read(machine, padnames[pad_num]);
+	pad_data = machine.root_device().ioport(padnames[pad_num])->read();
 	state->m_smpc.OREG[0+pad_num*offset] = 0xf1;
 	state->m_smpc.OREG[1+pad_num*offset] = 0x02;
 	state->m_smpc.OREG[2+pad_num*offset] = pad_data>>8;
@@ -360,16 +360,16 @@
 											   { "AN_X2", "AN_Y2", "AN_Z2" }};
 	UINT16 pad_data;
 
-	pad_data = input_port_read(machine, padnames[pad_num]);
+	pad_data = machine.root_device().ioport(padnames[pad_num])->read();
 	state->m_smpc.OREG[0+pad_num*offset] = 0xf1;
 	state->m_smpc.OREG[1+pad_num*offset] = id;
 	state->m_smpc.OREG[2+pad_num*offset] = pad_data>>8;
 	state->m_smpc.OREG[3+pad_num*offset] = pad_data & 0xff;
-	state->m_smpc.OREG[4+pad_num*offset] = input_port_read(machine, annames[pad_num][0]);
+	state->m_smpc.OREG[4+pad_num*offset] = machine.root_device().ioport(annames[pad_num][0])->read();
 	if(id == 0x15)
 	{
-		state->m_smpc.OREG[5+pad_num*offset] = input_port_read(machine, annames[pad_num][1]);
-		state->m_smpc.OREG[6+pad_num*offset] = input_port_read(machine, annames[pad_num][2]);
+		state->m_smpc.OREG[5+pad_num*offset] = machine.root_device().ioport(annames[pad_num][1])->read();
+		state->m_smpc.OREG[6+pad_num*offset] = machine.root_device().ioport(annames[pad_num][2])->read();
 	}
 }
 
@@ -380,19 +380,19 @@
 
 	game_key = 0xffff;
 
-	game_key ^= ((input_port_read(machine, "KEYS_1") & 0x80) << 8); // right
-	game_key ^= ((input_port_read(machine, "KEYS_1") & 0x40) << 8); // left
-	game_key ^= ((input_port_read(machine, "KEYS_1") & 0x20) << 8); // down
-	game_key ^= ((input_port_read(machine, "KEYS_1") & 0x10) << 8); // up
-	game_key ^= ((input_port_read(machine, "KEYF") & 0x80) << 4); // ESC -> START
-	game_key ^= ((input_port_read(machine, "KEY3") & 0x04) << 8); // Z / A trigger
-	game_key ^= ((input_port_read(machine, "KEY4") & 0x02) << 8); // C / C trigger
-	game_key ^= ((input_port_read(machine, "KEY6") & 0x04) << 6); // X / B trigger
-	game_key ^= ((input_port_read(machine, "KEY2") & 0x20) << 2); // Q / R trigger
-	game_key ^= ((input_port_read(machine, "KEY3") & 0x10) << 2); // A / X trigger
-	game_key ^= ((input_port_read(machine, "KEY3") & 0x08) << 2); // S / Y trigger
-	game_key ^= ((input_port_read(machine, "KEY4") & 0x08) << 1); // D / Z trigger
-	game_key ^= ((input_port_read(machine, "KEY4") & 0x10) >> 1); // E / L trigger
+	game_key ^= ((state->ioport("KEYS_1")->read() & 0x80) << 8); // right
+	game_key ^= ((state->ioport("KEYS_1")->read() & 0x40) << 8); // left
+	game_key ^= ((state->ioport("KEYS_1")->read() & 0x20) << 8); // down
+	game_key ^= ((state->ioport("KEYS_1")->read() & 0x10) << 8); // up
+	game_key ^= ((state->ioport("KEYF")->read() & 0x80) << 4); // ESC -> START
+	game_key ^= ((state->ioport("KEY3")->read() & 0x04) << 8); // Z / A trigger
+	game_key ^= ((state->ioport("KEY4")->read() & 0x02) << 8); // C / C trigger
+	game_key ^= ((state->ioport("KEY6")->read() & 0x04) << 6); // X / B trigger
+	game_key ^= ((state->ioport("KEY2")->read() & 0x20) << 2); // Q / R trigger
+	game_key ^= ((state->ioport("KEY3")->read() & 0x10) << 2); // A / X trigger
+	game_key ^= ((state->ioport("KEY3")->read() & 0x08) << 2); // S / Y trigger
+	game_key ^= ((state->ioport("KEY4")->read() & 0x08) << 1); // D / Z trigger
+	game_key ^= ((state->ioport("KEY4")->read() & 0x10) >> 1); // E / L trigger
 
 	state->m_smpc.OREG[0+pad_num*offset] = 0xf1;
 	state->m_smpc.OREG[1+pad_num*offset] = 0x34;
@@ -420,9 +420,9 @@
 	UINT8 mouse_ctrl;
 	INT16 mouse_x, mouse_y;
 
-	mouse_ctrl = input_port_read(machine, mousenames[pad_num][0]);
-	mouse_x = input_port_read(machine, mousenames[pad_num][1]);
-	mouse_y = input_port_read(machine, mousenames[pad_num][2]);
+	mouse_ctrl = machine.root_device().ioport(mousenames[pad_num][0])->read();
+	mouse_x = machine.root_device().ioport(mousenames[pad_num][1])->read();
+	mouse_y = machine.root_device().ioport(mousenames[pad_num][2])->read();
 
 	if(mouse_x < 0)
 		mouse_ctrl |= 0x10;
@@ -450,7 +450,7 @@
 	static const char *const padnames[] = { "MD_JOY1", "MD_JOY2" };
 	UINT16 pad_data;
 
-	pad_data = input_port_read(machine, padnames[pad_num]);
+	pad_data = machine.root_device().ioport(padnames[pad_num])->read();
 	state->m_smpc.OREG[0+pad_num*offset] = 0xf1;
 	state->m_smpc.OREG[1+pad_num*offset] = id;
 	state->m_smpc.OREG[2+pad_num*offset] = pad_data>>8;
@@ -475,8 +475,8 @@
 
 //  if (LOG_SMPC) logerror("SMPC: providing PAD data for intback, pad %d\n", intback_stage-2);
 
-	read_id[0] = (input_port_read(machine, "INPUT_TYPE")) & 0x0f;
-	read_id[1] = (input_port_read(machine, "INPUT_TYPE")) >> 4;
+	read_id[0] = (machine.root_device().ioport("INPUT_TYPE")->read()) & 0x0f;
+	read_id[1] = (machine.root_device().ioport("INPUT_TYPE")->read()) >> 4;
 
 	/* doesn't work? */
 	//pad_num = state->m_smpc.intback_stage - 1;
@@ -744,7 +744,7 @@
 		return_data = state->m_smpc.SF;
 
 	if (offset == 0x75)//PDR1 read
-		return_data = input_port_read(space->machine(), "DSW1");
+		return_data = state->ioport("DSW1")->read();
 
 	if (offset == 0x77)//PDR2 read
 		return_data = (0xfe | space->machine().device<eeprom_device>("eeprom")->read_bit());
@@ -866,7 +866,7 @@
 			const int shift_bit[4] = { 4, 12, 8, 0 };
 			const char *const padnames[] = { "JOY1", "JOY2" };
 
-			if(input_port_read(space->machine(), "INPUT_TYPE") && !(space->debugger_access()))
+			if(space->machine().root_device().ioport("INPUT_TYPE")->read() && !(space->debugger_access()))
 			{
 				popmessage("Warning: read with SH-2 direct mode with a non-pad device");
 				return 0;
@@ -879,7 +879,7 @@
 
 			if (LOG_SMPC) logerror("SMPC: SH-2 direct mode, returning data for phase %d\n", hshake);
 
-			return_data = 0x80 | 0x10 | ((input_port_read(space->machine(), padnames[offset == 0x77])>>shift_bit[hshake]) & 0xf);
+			return_data = 0x80 | 0x10 | ((space->machine().root_device().ioport(padnames[offset == 0x77])->read()>>shift_bit[hshake]) & 0xf);
 		}
 	}
 
diff -Nru src-old/mame/machine/snes.c src/mame/machine/snes.c
--- src-old/mame/machine/snes.c	2012-04-22 07:07:46.000000000 +0200
+++ src/mame/machine/snes.c	2012-05-03 11:00:08.000000000 +0200
@@ -577,9 +577,9 @@
 
 		case 0x4100:		/* NSS Dip-Switches */
 			{
-				const input_port_config *port = state->ioport("DSW");
+				ioport_port *port = state->ioport("DSW");
 				if (port != NULL)
-					return input_port_read(space->machine(), "DSW");
+					return space->machine().root_device().ioport("DSW")->read();
 				else
 					return snes_open_bus_r(space, 0);
 			}
@@ -1644,8 +1644,8 @@
 
 	for (port = 0; port < 2; port++)
 	{
-		state->m_data1[port] = input_port_read(machine, portnames[port][0]) | (input_port_read(machine, portnames[port][1]) << 8);
-		state->m_data2[port] = input_port_read(machine, portnames[port][2]) | (input_port_read(machine, portnames[port][3]) << 8);
+		state->m_data1[port] = state->ioport(portnames[port][0])->read() | (state->ioport(portnames[port][1])->read() << 8);
+		state->m_data2[port] = state->ioport(portnames[port][2])->read() | (state->ioport(portnames[port][3])->read() << 8);
 
 		// avoid sending signals that could crash games
 		// if left, no right
@@ -1998,7 +1998,7 @@
 	UINT16 total_blocks, read_blocks;
 	UINT8 *rom;
 
-	rom = machine.root_device().memregion("user3")->base();
+	rom = state->memregion("user3")->base();
 	snes_ram = auto_alloc_array_clear(machine, UINT8, 0x1400000);
 
 	/* all NSS games seem to use MODE 20 */
@@ -2064,7 +2064,7 @@
 	UINT16 total_blocks, read_blocks;
 	UINT8  *rom;
 
-	rom = machine.root_device().memregion("user3")->base();
+	rom = state->memregion("user3")->base();
 	snes_ram = auto_alloc_array(machine, UINT8, 0x1400000);
 	memset(snes_ram, 0, 0x1400000);
 
diff -Nru src-old/mame/machine/starwars.c src/mame/machine/starwars.c
--- src-old/mame/machine/starwars.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/starwars.c	2012-05-03 11:00:08.000000000 +0200
@@ -125,11 +125,11 @@
 {
 	/* pitch */
 	if (m_control_num == kPitch)
-		return input_port_read(machine(), "STICKY");
+		return ioport("STICKY")->read();
 
 	/* yaw */
 	else if (m_control_num == kYaw)
-		return input_port_read(machine(), "STICKX");
+		return ioport("STICKX")->read();
 
 	/* default to unused thrust */
 	else
diff -Nru src-old/mame/machine/stfight.c src/mame/machine/stfight.c
--- src-old/mame/machine/stfight.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/stfight.c	2012-05-03 11:00:08.000000000 +0200
@@ -132,7 +132,7 @@
 // Perhaps define dipswitches as active low?
 READ8_MEMBER(stfight_state::stfight_dsw_r)
 {
-    return( ~input_port_read(machine(), offset ? "DSW1" : "DSW0") );
+    return( ~ioport(offset ? "DSW1" : "DSW0")->read() );
 }
 
 READ8_MEMBER(stfight_state::stfight_coin_r)
@@ -154,7 +154,7 @@
      *        since it's read by the 30Hz interrupt ISR
      */
 
-    coin_mech_data = input_port_read(machine(), "COIN");
+    coin_mech_data = ioport("COIN")->read();
 
     for( i=0; i<2; i++ )
     {
diff -Nru src-old/mame/machine/subs.c src/mame/machine/subs.c
--- src-old/mame/machine/subs.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/subs.c	2012-05-03 11:00:08.000000000 +0200
@@ -26,7 +26,7 @@
 INTERRUPT_GEN( subs_interrupt )
 {
 	/* only do NMI interrupt if not in TEST mode */
-	if ((input_port_read(device->machine(), "IN1") & 0x40)==0x40)
+	if ((device->machine().root_device().ioport("IN1")->read() & 0x40)==0x40)
 		device_set_input_line(device,INPUT_LINE_NMI,PULSE_LINE);
 }
 
@@ -43,7 +43,7 @@
 	int this_val;
 	int delta;
 
-	this_val=input_port_read(machine, "DIAL2");
+	this_val=state->ioport("DIAL2")->read();
 
 	delta=this_val-state->m_last_val_1;
 	state->m_last_val_1=this_val;
@@ -72,7 +72,7 @@
 	int this_val;
 	int delta;
 
-	this_val=input_port_read(machine, "DIAL1");
+	this_val=state->ioport("DIAL1")->read();
 
 	delta=this_val-state->m_last_val_2;
 	state->m_last_val_2=this_val;
@@ -109,7 +109,7 @@
 ***************************************************************************/
 READ8_MEMBER(subs_state::subs_control_r)
 {
-	int inport = input_port_read(machine(), "IN0");
+	int inport = ioport("IN0")->read();
 
 	switch (offset & 0x07)
 	{
@@ -131,7 +131,7 @@
 ***************************************************************************/
 READ8_MEMBER(subs_state::subs_coin_r)
 {
-	int inport = input_port_read(machine(), "IN1");
+	int inport = ioport("IN1")->read();
 
 	switch (offset & 0x07)
 	{
@@ -153,7 +153,7 @@
 ***************************************************************************/
 READ8_MEMBER(subs_state::subs_options_r)
 {
-	int opts = input_port_read(machine(), "DSW");
+	int opts = ioport("DSW")->read();
 
 	switch (offset & 0x03)
 	{
diff -Nru src-old/mame/machine/tait8741.c src/mame/machine/tait8741.c
--- src-old/mame/machine/tait8741.c	2011-03-29 18:31:32.000000000 +0200
+++ src/mame/machine/tait8741.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,7 +177,7 @@
 					else
 					{ /* port select */
 						st->parallelselect = data & 0x07;
-						taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space,st->parallelselect) : st->portName ? input_port_read(space->machine(), st->portName) : 0);
+						taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space,st->parallelselect) : st->portName ? space->machine().root_device().ioport(st->portName)->read() : 0);
 					}
 				}
 			}
@@ -188,7 +188,7 @@
 			case -1: /* no command data */
 				break;
 			case 0x00: /* read from parallel port */
-				taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space,0) : st->portName ? input_port_read(space->machine(), st->portName) : 0 );
+				taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space,0) : st->portName ? space->machine().root_device().ioport(st->portName)->read() : 0 );
 				break;
 			case 0x01: /* read receive buffer 0 */
 			case 0x02: /* read receive buffer 1 */
@@ -201,7 +201,7 @@
 				taito8741_hostdata_w(st,st->rxd[data-1]);
 				break;
 			case 0x08:	/* latch received serial data */
-				st->txd[0] = st->portHandler ? st->portHandler(space,0) : st->portName ? input_port_read(space->machine(), st->portName) : 0;
+				st->txd[0] = st->portHandler ? st->portHandler(space,0) : st->portName ? space->machine().root_device().ioport(st->portName)->read() : 0;
 				if( sst )
 				{
 					space->machine().scheduler().synchronize(FUNC(taito8741_serial_tx), num);
@@ -295,7 +295,7 @@
 	switch( st->mode )
 	{
 	case TAITO8741_PORT: /* parallel data */
-		taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space, st->parallelselect) : st->portName ? input_port_read(space->machine(), st->portName) : 0);
+		taito8741_hostdata_w(st,st->portHandler ? st->portHandler(space, st->parallelselect) : st->portName ? space->machine().root_device().ioport(st->portName)->read() : 0);
 		break;
 	}
 	return ret;
@@ -472,7 +472,7 @@
 			break;
 		case 2:
 #if 1
-			mcu->rxd = input_port_read(space->machine(), "DSW2");
+			mcu->rxd = space->machine().root_device().ioport("DSW2")->read();
 			mcu->sts |= 0x01; /* RD ready */
 #endif
 			break;
@@ -515,7 +515,7 @@
 	if(offset==1)
 	{
 		if(mcu->rst)
-			mcu->rxd = input_port_read(space->machine(), mcu->initReadPort); /* port in */
+			mcu->rxd = space->machine().root_device().ioport(mcu->initReadPort)->read(); /* port in */
 		ret = mcu->sts;
 		LOG(("%s:8741[%d]       SR %02X\n",space->machine().describe_context(),num,ret));
 	}
@@ -579,11 +579,11 @@
 				cyclemb_mcu.rst = 0;
 				break;
 			case 2:
-				cyclemb_mcu.rxd = (input_port_read(space->machine(), "DSW2") & 0x1f) << 2;
+				cyclemb_mcu.rxd = (space->machine().root_device().ioport("DSW2")->read() & 0x1f) << 2;
 				cyclemb_mcu.rst = 0;
 				break;
 			case 3:
-				//cyclemb_mcu.rxd = input_port_read(space->machine(), "DSW2");
+				//cyclemb_mcu.rxd = space->machine().root_device().ioport("DSW2")->read();
 				cyclemb_mcu.rst = 1;
 				break;
 		}
@@ -613,15 +613,15 @@
 			/* FIXME: remove cpu_get_pc hack */
 			switch(cpu_get_pc(&space->device()))
 			{
-				case 0x760: cyclemb_mcu.rxd = ((input_port_read(space->machine(),"DSW1") & 0x1f) << 2); break;
+				case 0x760: cyclemb_mcu.rxd = ((space->machine().root_device().ioport("DSW1")->read() & 0x1f) << 2); break;
 				case 0x35c:
 				{
 					static UINT8 mux_r;
 					mux_r^=0x20;
 					if(mux_r & 0x20)
-						cyclemb_mcu.rxd = ((input_port_read(space->machine(),"DSW3")) & 0x9f) | (mux_r) | (space->machine().rand() & 0x40);
+						cyclemb_mcu.rxd = ((space->machine().root_device().ioport("DSW3")->read()) & 0x9f) | (mux_r) | (space->machine().rand() & 0x40);
 					else
-						cyclemb_mcu.rxd = ((input_port_read(space->machine(),"IN0")) & 0x9f) | (mux_r) | (space->machine().rand() & 0x40);
+						cyclemb_mcu.rxd = ((space->machine().root_device().ioport("IN0")->read()) & 0x9f) | (mux_r) | (space->machine().rand() & 0x40);
 				}
 				break;
 			}
diff -Nru src-old/mame/machine/taitosj.c src/mame/machine/taitosj.c
--- src-old/mame/machine/taitosj.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/taitosj.c	2012-05-03 11:00:08.000000000 +0200
@@ -19,7 +19,7 @@
 MACHINE_START( taitosj )
 {
 	taitosj_state *state = machine.driver_data<taitosj_state>();
-	state->membank("bank1")->configure_entry(0, machine.root_device().memregion("maincpu")->base() + 0x6000);
+	state->membank("bank1")->configure_entry(0, state->memregion("maincpu")->base() + 0x6000);
 	state->membank("bank1")->configure_entry(1, state->memregion("maincpu")->base() + 0x10000);
 
 	state->save_item(NAME(state->m_fromz80));
@@ -308,5 +308,5 @@
 
 READ8_MEMBER(taitosj_state::alpine_port_2_r)
 {
-	return input_port_read(machine(), "IN2") | m_protection_value;
+	return ioport("IN2")->read() | m_protection_value;
 }
diff -Nru src-old/mame/machine/tatsumi.c src/mame/machine/tatsumi.c
--- src-old/mame/machine/tatsumi.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/tatsumi.c	2012-05-03 11:00:08.000000000 +0200
@@ -108,12 +108,12 @@
 {
 	switch (m_apache3_adc)
 	{
-		case 0: return input_port_read(machine(), "STICK_X");
-		case 1: return input_port_read(machine(), "STICK_Y");
+		case 0: return ioport("STICK_X")->read();
+		case 1: return ioport("STICK_Y")->read();
 		case 2: return 0; // VSP1
 		case 3: return 0;
-		case 4: return (UINT8)((255./100) * (100 - input_port_read(machine(), "VR1")));
-		case 5: return input_port_read(machine(), "THROTTLE");
+		case 4: return (UINT8)((255./100) * (100 - ioport("VR1")->read()));
+		case 5: return ioport("THROTTLE")->read();
 		case 6: return 0; // RPSNC
 		case 7: return 0; // LPSNC
 	}
diff -Nru src-old/mame/machine/tnzs.c src/mame/machine/tnzs.c
--- src-old/mame/machine/tnzs.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/tnzs.c	2012-05-03 11:00:08.000000000 +0200
@@ -43,9 +43,9 @@
 
 	switch (m_input_select & 0x0f)
 	{
-		case 0x0a:	data = input_port_read(machine(), "IN2"); break;
-		case 0x0c:	data = input_port_read(machine(), "IN0"); break;
-		case 0x0d:	data = input_port_read(machine(), "IN1"); break;
+		case 0x0a:	data = ioport("IN2")->read(); break;
+		case 0x0c:	data = ioport("IN0")->read(); break;
+		case 0x0d:	data = ioport("IN1")->read(); break;
 		default:	data = 0xff; break;
 	}
 
@@ -56,7 +56,7 @@
 
 READ8_MEMBER(tnzs_state::tnzs_port2_r)
 {
-	int data = input_port_read(machine(), "IN2");
+	int data = ioport("IN2")->read();
 
 //  logerror("I8742:%04x  Read %02x from port 2\n", cpu_get_previouspc(&space.device()), data);
 
@@ -83,7 +83,7 @@
 
 //  logerror("PC %04x: read input %04x\n", cpu_get_pc(&space.device()), 0xf000 + offset);
 
-	val = input_port_read_safe(machine(), (offset / 2) ? "AN2" : "AN1", 0);
+	val = ioport((offset / 2) ? "AN2" : "AN1")->read_safe(0);
 	if (offset & 1)
 		return ((val >> 8) & 0xff);
 	else
@@ -214,7 +214,7 @@
 					}
 					else return m_mcu_credits;
 				}
-				else return input_port_read(machine(), "IN0");	/* buttons */
+				else return ioport("IN0")->read();	/* buttons */
 
 			default:
 				logerror("error, unknown mcu command\n");
@@ -306,16 +306,16 @@
 		switch (m_mcu_command)
 		{
 			case 0x01:
-				return input_port_read(machine(), "IN0") ^ 0xff;	/* player 1 joystick + buttons */
+				return ioport("IN0")->read() ^ 0xff;	/* player 1 joystick + buttons */
 
 			case 0x02:
-				return input_port_read(machine(), "IN1") ^ 0xff;	/* player 2 joystick + buttons */
+				return ioport("IN1")->read() ^ 0xff;	/* player 2 joystick + buttons */
 
 			case 0x1a:
-				return (input_port_read(machine(), "COIN1") | (input_port_read(machine(), "COIN2") << 1));
+				return (ioport("COIN1")->read() | (ioport("COIN2")->read() << 1));
 
 			case 0x21:
-				return input_port_read(machine(), "IN2") & 0x0f;
+				return ioport("IN2")->read() & 0x0f;
 
 			case 0x41:
 				return m_mcu_credits;
@@ -343,7 +343,7 @@
 					else return m_mcu_credits;
 				}
 				/* buttons */
-				else return ((input_port_read(machine(), "IN0") & 0xf0) | (input_port_read(machine(), "IN1") >> 4)) ^ 0xff;
+				else return ((ioport("IN0")->read() & 0xf0) | (ioport("IN1")->read() >> 4)) ^ 0xff;
 
 			default:
 				logerror("error, unknown mcu command\n");
@@ -610,9 +610,9 @@
 		case MCU_DRTOPPEL:
 		case MCU_PLUMPOP:
 			coin  = 0;
-			coin |= ((input_port_read(device->machine(), "COIN1") & 1) << 0);
-			coin |= ((input_port_read(device->machine(), "COIN2") & 1) << 1);
-			coin |= ((input_port_read(device->machine(), "IN2") & 3) << 2);
+			coin |= ((state->ioport("COIN1")->read() & 1) << 0);
+			coin |= ((state->ioport("COIN2")->read() & 1) << 1);
+			coin |= ((state->ioport("IN2")->read() & 3) << 2);
 			coin ^= 0x0c;
 			mcu_handle_coins(device->machine(), coin);
 			break;
@@ -671,7 +671,7 @@
 MACHINE_START( tnzs )
 {
 	tnzs_state *state = machine.driver_data<tnzs_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	UINT8 *SUB = state->memregion("sub")->base();
 
 	state->membank("bank1")->configure_entries(0, 8, &ROM[0x10000], 0x4000);
@@ -709,7 +709,7 @@
 MACHINE_START( jpopnics )
 {
 	tnzs_state *state = machine.driver_data<tnzs_state>();
-	UINT8 *ROM = machine.root_device().memregion("maincpu")->base();
+	UINT8 *ROM = state->memregion("maincpu")->base();
 	UINT8 *SUB = state->memregion("sub")->base();
 
 	state->membank("bank1")->configure_entries(0, 8, &ROM[0x10000], 0x4000);
diff -Nru src-old/mame/machine/toaplan1.c src/mame/machine/toaplan1.c
--- src-old/mame/machine/toaplan1.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/toaplan1.c	2012-05-03 11:00:08.000000000 +0200
@@ -187,7 +187,7 @@
 {
 	/* Bit 0x80 is secondary CPU (HD647180) ready signal */
 	logerror("PC:%04x Warning !!! IO reading from $14000a\n",cpu_get_previouspc(&space.device()));
-	return (0x80 | input_port_read(machine(), "TJUMP")) & 0xff;
+	return (0x80 | ioport("TJUMP")->read()) & 0xff;
 }
 
 READ16_MEMBER(toaplan1_state::vimana_system_port_r)
@@ -203,9 +203,9 @@
 	int data, p, r, d, slot, reg, dsw;
 
 	slot = -1;
-	d = input_port_read(machine(), "DSWA");
-	r = input_port_read(machine(), "TJUMP");
-	p = input_port_read(machine(), "SYSTEM");
+	d = ioport("DSWA")->read();
+	r = ioport("TJUMP")->read();
+	p = ioport("SYSTEM")->read();
 	m_vimana_latch ^= p;
 	data = (m_vimana_latch & p);
 
diff -Nru src-old/mame/machine/vectrex.c src/mame/machine/vectrex.c
--- src-old/mame/machine/vectrex.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/vectrex.c	2012-05-03 20:17:43.000000000 +0200
@@ -71,6 +71,11 @@
 	if (image.software_entry() == NULL)
 	{
 		image.fread( mem, 0x8000);
+		if (image.length() > 0x8000)
+		{
+			image.fread( mem+0x10000, 0x8000);
+			state->m_64k_cart = 1;
+		}
 	} else {
 		int size = image.get_software_region_length("rom");
 		memcpy(mem, image.get_software_region("rom"), size);
@@ -83,6 +88,10 @@
 		return IMAGE_INIT_FAIL;
 	}
 
+	if (memcmp(mem + 0x06,"SRAM",4)) {
+		image.device().machine().device("maincpu")->memory().space(AS_PROGRAM)->unmap_write(0x0000, 0x7fff);
+	}
+
 	/* If VIA T2 starts, reset refresh timer.
        This is the best strategy for most games. */
 	state->m_reset_refresh = 1;
@@ -125,7 +134,7 @@
 void vectrex_configuration(running_machine &machine)
 {
 	vectrex_state *state = machine.driver_data<vectrex_state>();
-	unsigned char cport = input_port_read(machine, "3DCONF");
+	unsigned char cport = state->ioport("3DCONF")->read();
 
 	/* Vectrex 'dipswitch' configuration */
 
@@ -202,7 +211,7 @@
 		state->m_beam_color = RGB_WHITE;
 		state->m_imager_colors[0] = state->m_imager_colors[1] = state->m_imager_colors[2] = state->m_imager_colors[3] = state->m_imager_colors[4] = state->m_imager_colors[5] = RGB_WHITE;
 	}
-	state->m_lightpen_port = input_port_read(machine, "LPENCONF") & 0x03;
+	state->m_lightpen_port = machine.root_device().ioport("LPENCONF")->read() & 0x03;
 }
 
 
@@ -224,7 +233,7 @@
 	int pot;
 	static const char *const ctrlnames[] = { "CONTR1X", "CONTR1Y", "CONTR2X", "CONTR2Y" };
 
-	pot = input_port_read(device->machine(), ctrlnames[(state->m_via_out[PORTB] & 0x6) >> 1]) - 0x80;
+	pot = device->machine().root_device().ioport(ctrlnames[(state->m_via_out[PORTB] & 0x6) >> 1])->read() - 0x80;
 
 	if (pot > (signed char)state->m_via_out[PORTA])
 		state->m_via_out[PORTB] |= 0x20;
@@ -253,7 +262,7 @@
 READ8_DEVICE_HANDLER(vectrex_s1_via_pb_r)
 {
 	vectrex_state *state = device->machine().driver_data<vectrex_state>();
-	return (state->m_via_out[PORTB] & ~0x40) | (input_port_read(device->machine(), "COIN") & 0x40);
+	return (state->m_via_out[PORTB] & ~0x40) | (state->ioport("COIN")->read() & 0x40);
 }
 
 
@@ -352,6 +361,7 @@
 	vectrex_state *state = machine.driver_data<vectrex_state>();
 	int i;
 
+	state->m_64k_cart = 0;
 	state->m_imager_angles = unknown_game_angles;
 	state->m_beam_color = RGB_WHITE;
 	for (i=0; i<ARRAY_LENGTH(state->m_imager_colors); i++)
diff -Nru src-old/mame/machine/vertigo.c src/mame/machine/vertigo.c
--- src-old/mame/machine/vertigo.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/vertigo.c	2012-05-03 11:00:08.000000000 +0200
@@ -119,7 +119,7 @@
 	if (offset > 2)
 		m_adc_result = 0;
 	else
-		m_adc_result = input_port_read(machine(), adcnames[offset]);
+		m_adc_result = ioport(adcnames[offset])->read();
 
 	update_irq_encoder(machine(), INPUT_LINE_IRQ2, ASSERT_LINE);
 	return 0;
@@ -136,14 +136,14 @@
 READ16_MEMBER(vertigo_state::vertigo_coin_r)
 {
 	update_irq_encoder(machine(), INPUT_LINE_IRQ6, CLEAR_LINE);
-	return (input_port_read(machine(), "COIN"));
+	return (ioport("COIN")->read());
 }
 
 
 INTERRUPT_GEN( vertigo_interrupt )
 {
 	/* Coin inputs cause IRQ6 */
-	if ((input_port_read(device->machine(), "COIN") & 0x7) < 0x7)
+	if ((device->machine().root_device().ioport("COIN")->read() & 0x7) < 0x7)
 		update_irq_encoder(device->machine(), INPUT_LINE_IRQ6, ASSERT_LINE);
 }
 
diff -Nru src-old/mame/machine/volfied.c src/mame/machine/volfied.c
--- src-old/mame/machine/volfied.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/machine/volfied.c	2012-05-03 11:00:08.000000000 +0200
@@ -436,10 +436,10 @@
 	{
 		switch (offset)
 		{
-		case 0x03: return input_port_read(machine(), "F00007");    /* STARTn + SERVICE1 */
-		case 0x04: return input_port_read(machine(), "F00009");    /* COINn */
-		case 0x05: return input_port_read(machine(), "F0000B");    /* Player controls + TILT */
-		case 0x06: return input_port_read(machine(), "F0000D");    /* Player controls (cocktail) */
+		case 0x03: return ioport("F00007")->read();    /* STARTn + SERVICE1 */
+		case 0x04: return ioport("F00009")->read();    /* COINn */
+		case 0x05: return ioport("F0000B")->read();    /* Player controls + TILT */
+		case 0x06: return ioport("F0000D")->read();    /* Player controls (cocktail) */
 		case 0x08: return m_cc_port;
 		}
 	}
diff -Nru src-old/mame/machine/vsnes.c src/mame/machine/vsnes.c
--- src-old/mame/machine/vsnes.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/vsnes.c	2012-05-03 11:00:08.000000000 +0200
@@ -38,8 +38,8 @@
 	if (data & 1)
 	{
 		/* load up the latches */
-		m_input_latch[0] = input_port_read(machine(), "IN0");
-		m_input_latch[1] = input_port_read(machine(), "IN1");
+		m_input_latch[0] = ioport("IN0")->read();
+		m_input_latch[1] = ioport("IN1")->read();
 	}
 }
 
@@ -50,8 +50,8 @@
 	/* shift */
 	m_input_latch[0] >>= 1;
 
-	ret |= input_port_read(machine(), "COINS");				/* merge coins, etc */
-	ret |= (input_port_read(machine(), "DSW0") & 3) << 3;		/* merge 2 dipswitches */
+	ret |= ioport("COINS")->read();				/* merge coins, etc */
+	ret |= (ioport("DSW0")->read() & 3) << 3;		/* merge 2 dipswitches */
 
 /* The gun games expect a 1 returned on every 5th read after sound_fix is reset*/
 /* Info Supplied by Ben Parnell <xodnizel@home.com> of FCE Ultra fame */
@@ -75,8 +75,8 @@
 	/* shift */
 	m_input_latch[0] >>= 1;
 
-	ret |= input_port_read(machine(), "COINS");				/* merge coins, etc */
-	ret |= (input_port_read(machine(), "DSW0") & 3) << 3;		/* merge 2 dipswitches */
+	ret |= ioport("COINS")->read();				/* merge coins, etc */
+	ret |= (ioport("DSW0")->read() & 3) << 3;		/* merge 2 dipswitches */
 
 	return ret;
 
@@ -86,7 +86,7 @@
 {
 	int ret = (m_input_latch[1]) & 1;
 
-	ret |= input_port_read(machine(), "DSW0") & ~3;			/* merge the rest of the dipswitches */
+	ret |= ioport("DSW0")->read() & ~3;			/* merge the rest of the dipswitches */
 
 	/* shift */
 	m_input_latch[1] >>= 1;
@@ -100,8 +100,8 @@
 	if (data & 1)
 	{
 		/* load up the latches */
-		m_input_latch[2] = input_port_read(machine(), "IN2");
-		m_input_latch[3] = input_port_read(machine(), "IN3");
+		m_input_latch[2] = ioport("IN2")->read();
+		m_input_latch[3] = ioport("IN3")->read();
 	}
 }
 
@@ -112,8 +112,8 @@
 	/* shift */
 	m_input_latch[2] >>= 1;
 
-	ret |= input_port_read(machine(), "COINS2");				/* merge coins, etc */
-	ret |= (input_port_read(machine(), "DSW1") & 3) << 3;		/* merge 2 dipswitches */
+	ret |= ioport("COINS2")->read();				/* merge coins, etc */
+	ret |= (ioport("DSW1")->read() & 3) << 3;		/* merge 2 dipswitches */
 	return ret;
 }
 
@@ -121,7 +121,7 @@
 {
 	int ret = (m_input_latch[3]) & 1;
 
-	ret |= input_port_read(machine(), "DSW1") & ~3;			/* merge the rest of the dipswitches */
+	ret |= ioport("DSW1")->read() & ~3;			/* merge the rest of the dipswitches */
 
 	/* shift */
 	m_input_latch[3] >>= 1;
@@ -202,7 +202,7 @@
 
 	ppu1_space->install_readwrite_handler(0x2000, 0x3eff, read8_delegate(FUNC(vsnes_state::vsnes_nt0_r),state), write8_delegate(FUNC(vsnes_state::vsnes_nt0_w),state));
 
-	state->m_vrom[0] = machine.root_device().memregion("gfx1")->base();
+	state->m_vrom[0] = state->memregion("gfx1")->base();
 	state->m_vrom_size[0] = state->memregion("gfx1")->bytes();
 	state->m_vrom_banks = state->m_vrom_size[0] / 0x400;
 
@@ -227,9 +227,9 @@
 MACHINE_START( vsdual )
 {
 	vsnes_state *state = machine.driver_data<vsnes_state>();
-	state->m_vrom[0] = machine.root_device().memregion("gfx1")->base();
-	state->m_vrom[1] = machine.root_device().memregion("gfx2")->base();
-	state->m_vrom_size[0] = machine.root_device().memregion("gfx1")->bytes();
+	state->m_vrom[0] = state->memregion("gfx1")->base();
+	state->m_vrom[1] = state->memregion("gfx2")->base();
+	state->m_vrom_size[0] = state->memregion("gfx1")->bytes();
 	state->m_vrom_size[1] = state->memregion("gfx2")->bytes();
 
 	/* establish nametable ram */
@@ -365,11 +365,11 @@
 	{
 
 		/* load up the latches */
-		m_input_latch[0] = input_port_read(machine(), "IN0");
+		m_input_latch[0] = ioport("IN0")->read();
 
 		/* do the gun thing */
-		int x = input_port_read(machine(), "GUNX");
-		int y = input_port_read(machine(), "GUNY");
+		int x = ioport("GUNX")->read();
+		int y = ioport("GUNY")->read();
 		UINT32 pix, color_base;
 
 		/* get the pixel at the gun position */
@@ -385,7 +385,7 @@
 			m_input_latch[0] |= 0x40;
 		}
 
-		m_input_latch[1] = input_port_read(machine(), "IN1");
+		m_input_latch[1] = ioport("IN1")->read();
 	}
 
     if ((m_zapstore & 1) && (!(data & 1)))
@@ -773,7 +773,7 @@
 DRIVER_INIT( MMC3 )
 {
 	vsnes_state *state = machine.driver_data<vsnes_state>();
-	UINT8 *prg = machine.root_device().memregion("maincpu")->base();
+	UINT8 *prg = state->memregion("maincpu")->base();
 	state->m_IRQ_enable = state->m_IRQ_count = state->m_IRQ_count_latch = 0;
 	int MMC3_prg_chunks = (state->memregion("maincpu")->bytes() - 0x10000) / 0x4000;
 
diff -Nru src-old/mame/machine/williams.c src/mame/machine/williams.c
--- src-old/mame/machine/williams.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/machine/williams.c	2012-05-03 11:00:08.000000000 +0200
@@ -622,7 +622,7 @@
 	if (m_port_select != 0)
 		tag += strlen(tag) + 1;
 
-	return input_port_read(machine(), tag);
+	return ioport(tag)->read();
 }
 
 /*
@@ -653,7 +653,7 @@
 READ8_DEVICE_HANDLER( williams_49way_port_0_r )
 {
 	static const UINT8 translate49[7] = { 0x0, 0x4, 0x6, 0x7, 0xb, 0x9, 0x8 };
-	return (translate49[input_port_read(device->machine(), "49WAYX") >> 4] << 4) | translate49[input_port_read(device->machine(), "49WAYY") >> 4];
+	return (translate49[device->machine().root_device().ioport("49WAYX")->read() >> 4] << 4) | translate49[device->machine().root_device().ioport("49WAYY")->read() >> 4];
 }
 
 
@@ -663,7 +663,7 @@
 	if (state->m_port_select)
 		return williams_49way_port_0_r(device, 0);
 	else
-		return input_port_read(device->machine(), "IN3");
+		return state->ioport("IN3")->read();
 }
 
 
@@ -879,7 +879,7 @@
 
 	/* banking is different for blaster */
 	state->membank("bank1")->configure_entry(0, state->m_videoram);
-	state->membank("bank1")->configure_entries(1, 16, machine.root_device().memregion("maincpu")->base() + 0x18000, 0x4000);
+	state->membank("bank1")->configure_entries(1, 16, state->memregion("maincpu")->base() + 0x18000, 0x4000);
 
 	state->membank("bank2")->configure_entry(0, state->m_videoram + 0x4000);
 	state->membank("bank2")->configure_entries(1, 16, state->memregion("maincpu")->base() + 0x10000, 0x0000);
@@ -946,7 +946,7 @@
 static READ8_DEVICE_HANDLER( tshoot_input_port_0_3_r )
 {
 	/* merge in the gun inputs with the standard data */
-	int data = input_port_read(device->machine(), "IN0");
+	int data = device->machine().root_device().ioport("IN0")->read();
 	int gun = (data & 0x3f) ^ ((data & 0x3f) >> 1);
 	return (data & 0xc0) | gun;
 
diff -Nru src-old/mame/machine/xevious.c src/mame/machine/xevious.c
--- src-old/mame/machine/xevious.c	2012-02-19 03:53:16.000000000 +0100
+++ src/mame/machine/xevious.c	2012-05-03 11:00:08.000000000 +0200
@@ -174,10 +174,10 @@
 	switch ( offset )
 	{
 		default:
-		case 0: return ~BITSWAP8(input_port_read(space->machine(), "IN0H"),7,6,5,4,2,3,1,0);
-		case 1: return ~input_port_read(space->machine(), "IN1L");
-		case 2: return ~input_port_read(space->machine(), "IN1H");
-		case 3: return ~input_port_read(space->machine(), "IN0L");
+		case 0: return ~BITSWAP8(space->machine().root_device().ioport("IN0H")->read(),7,6,5,4,2,3,1,0);
+		case 1: return ~space->machine().root_device().ioport("IN1L")->read();
+		case 2: return ~space->machine().root_device().ioport("IN1H")->read();
+		case 3: return ~space->machine().root_device().ioport("IN0L")->read();
 	}
 }
 
diff -Nru src-old/mame/mame.lst src/mame/mame.lst
--- src-old/mame/mame.lst	2012-04-22 16:10:44.000000000 +0200
+++ src/mame/mame.lst	2012-05-06 12:19:08.000000000 +0200
@@ -206,6 +206,7 @@
 mooncrsto		// (c) 1980 Nichibutsu
 mooncrstg		// (c) 1980 Gremlin
 mooncrstuk		// (c) 1980 Nichibutsu UK
+mooncrstuku		// (c) 1980 Nichibutsu UK
 smooncrs		// Gremlin
 sstarcrs		// Taito (Brazil)
 mooncmw			// bootleg
@@ -248,6 +249,7 @@
 vpool			// bootleg
 drivfrcg		// [1984] Shinkai (Magic Electronics USA license)
 drivfrcb		// bootleg
+drivfrct		// bootleg
 bongo			// (c) 1983 Jetsoft
 hunchbkg		// (c) 1983 Century
 harem			// [1983] I.G.R.
@@ -602,6 +604,7 @@
 wcatcher		// (c) 1993
 jituroku		// (c) 1993 Windom
 yosimoto		// (c) 1994 Nichibutsu/Yoshimoto Kougyou
+yosimotm		// (c) 1994 Nichibutsu/Yoshimoto Kougyou
 psailor1		// (c) 1994 SPHINX
 psailor2		// (c) 1994 SPHINX
 otatidai		// (c) 1995 SPHINX
@@ -617,10 +620,13 @@
 mjegolf			// (c) 1994 FUJIC/AV JAPAN
 
 mhhonban		// (c) 199?
+zokumahj		// (c) 199?
 4psimasy		// (c) 1994
 musobana		// (c) 1995
 niyanpai		// (c) 1996
 
+csplayh1		// (c) 1995
+
 junai			// (c) 1998
 csplayh5		// (c) 1998
 junai2			// (c) 1998
@@ -3960,8 +3966,9 @@
 futspy			// (c) 1984
 razmataz		// modified 834-0213, 834-0214 (c) 1983
 ixion			// (c) 1983
-congo			// 605-5167 (c) 1983
-tiptop			// 605-5167 (c) 1983
+congo			// 605-5167 (c) 1983 (2 board stack)
+congoa			// 605-5167 (c) 1983 (3 board stack)
+tiptop			// 605-5167 (c) 1983 (3 board stack)
 
 // Sega "LaserDisc hardware" games
 astron			// (c) 1983
@@ -4727,6 +4734,8 @@
 puckpkmna		// (c) 2000 IBS
 topshoot		// (c) 1995 Sun Mixing
 
+jzth
+
 // Sega MegaTech, the number shown is on the label of the instruction rom
 megatech
 mt_beast		// 01
@@ -6181,7 +6190,7 @@
 fax				// (c) 1983
 fax2			// (c) 1983
 circus			// no copyright notice [1977?]
-circusse		// bootleg
+springbd		// Sub-Electro bootleg of Circus
 robotbwl		// no copyright notice
 crash			// Exidy [1979?]
 smash			// bootleg
@@ -8320,6 +8329,7 @@
 funcube2		// (c) 2001 Namco
 funcube3		// (c) 2001 Namco
 funcube4		// (c) 2001 Namco
+funcube5		// (c) 2002 Namco
 trophyh			// (c) 2002 Sammy USA Corporation
 reelquak		// (c) ???? <unknown>
 
@@ -8473,6 +8483,7 @@
 lastday			// (c) 1990 Dooyong
 lastdaya		// (c) 1990 Dooyong
 gulfstrm		// (c) 1991 Dooyong
+gulfstrma		// (c) 1991 Dooyong
 gulfstrmm		// (c) 1991 Dooyong + distributed by Media Shoji
 pollux			// (c) 1991 Dooyong
 polluxa			// (c) 1991 Dooyong
@@ -8669,12 +8680,13 @@
 // Afega games
 twinactn		// (c) 1996 - bootleg of US AFF Mustang
 stagger1		// (c) 1998
-redhawk			// (c) 1997
+redhawk			// (c) 1997 New Vision Ent. license
 redhawke		// (c) 1997 Excellent Co., Ltd license
 redhawki		// (c) 1997 Haedong Corp. license
 redhawkb		// (c) 1997
-grdnstrm		// (c) 1998
-grdnstrmk		// (c) 1998
+grdnstrm		// (c) 1998 Apples Industries license
+grdnstrmk		// (c) 1998 (Korea)
+redfoxwp2		// (c) 1998 (China)
 bubl2000		// (c) 1998 Tuning
 hotbubl			// (c) 1998 Pandora
 popspops		// (c) 1999
@@ -9954,8 +9966,9 @@
 spaceint		// [1980] Shoei
 spaceintj		// [1980] Shoei
 spacefb			// (c) [1980?] Nintendo
-spacefbu		// (c) [1980?] Nintendo
 spacefbe		// (c) [1980?] Nintendo
+spacefbe2		// (c) [1980?] Nintendo
+spacefba		// (c) [1980?] Nintendo
 spacefbg		// 834-0031 (c) 1980 Gremlin
 spacefbb		// bootleg
 spacebrd		// bootleg
@@ -10018,6 +10031,7 @@
 policetr13a		// (c) 1996 P&P Marketing
 policetr13b		// (c) 1996 P&P Marketing
 sshooter		// (c) 1998 P&P Marketing
+sshooter17		// (c) 1998 P&P Marketing
 sshooter12		// (c) 1998 P&P Marketing
 sshooter11		// (c) 1998 P&P Marketing
 pass			// (c) 1992 Oksan
@@ -10031,9 +10045,9 @@
 gtsers9			// (c) 1984 Greyhound Electronics
 gtsers10		// (c) 1984 Greyhound Electronics
 gtsers11		// (c) 1984 Greyhound Electronics
+gtsers12		// (c) 1984 Greyhound Electronics
+gtsers14		// (c) 1984 Greyhound Electronics
 gt103a1			// (c) 1984 Greyhound Electronics
-gt103a2			// (c) 1984 Greyhound Electronics
-gt103a3			// (c) 1984 Greyhound Electronics
 gt103aa			// (c) 1984 Greyhound Electronics
 gt103asx		// (c) 1984 Greyhound Electronics
 reelfun			// (c) 1986 Grayhound Electronics
@@ -10354,6 +10368,7 @@
 pntnpuzl		// Century?
 trucocl			// (c) 1991 Miky SRL
 ertictac		// (c) 1992 Sisteme
+ertictaca		// (c) 1992 Sisteme
 poizone			// (c) 1990 Sisteme
 ssfindo			// (c) 1999 Icarus
 ppcar			// (c) 1999 Icarus
@@ -10561,6 +10576,7 @@
 sb2003a			// (c) 2003 Limenko
 spotty			// (c) 2001 Prince Co.
 carrera			// (c) 19?? BS Electronics
+chance32		// (c) 19?? PAL Company
 
 // Golden Poker / Potten's Poker / Witch Card hardware
 goldnpkr		// (c) 1981 Bonanza
@@ -10800,12 +10816,14 @@
 ggconnie		// (c) ???? Capcom
 paranoia		// (c) 1990 Naxat Soft
 tourvis			// (c) ???? Tourvision
+tvlegaxe		// (c) 1988 Victor Musical Industries, Inc. (Tourvision bootleg)
 tvusapb			// (c) 1989 Aicom (Tourvision bootleg)
 tvdunexp		// (c) 1989 Hudson / Atlus (Tourvision bootleg)
 tvthbld			// (c) 1990 Sega / NEC Avenue (Tourvision bootleg)
 tvrs2			// (c) 1990 Taito (Tourvision bootleg)
 tvpwlg4			// (c) 1991 Hudson (Tourvision bootleg)
 tvsci			// (c) 1991 Taito (Tourvision bootleg)
+tvsvball		// (c) 1990 Video System (Tourvision bootleg)
 vcombat			// (c) 1993 VR8 Inc.
 shadfgtr		// (c) 1993 DUTECH Inc.
 skimaxx			// (c) 1996 Kyle Hodgetts/ICE
@@ -12970,6 +12988,10 @@
 sc4cckeyi	//
 sc4cckeyj	//
 sc4cckeyk	//
+sc4cckeyl	//
+sc4cckeym	//
+sc4cckeyn	//
+sc4cckeyo	//
 sc4ckx		// Casino King X (Mazooma)
 sc4ckxa		//
 sc4ckxb		//
@@ -13054,6 +13076,8 @@
 sc4crcpf	//
 sc4crcpg	//
 sc4crcph	//
+sc4crcpi	//
+sc4crcpj	//
 sc4crgc		// Cops 'n' Robbers Gold Club (Bellfruit)
 sc4crgca	//
 sc4crgcb	//
@@ -13110,6 +13134,17 @@
 sc4cclimn	//
 sc4cclimo	//
 sc4cclimp	//
+sc4cclimq	//
+sc4cclimr	//
+sc4cclims	//
+sc4cclimt	//
+sc4cclimu	//
+sc4clbmn	//
+sc4clbmna	//
+sc4clbmnb	//
+sc4clbmnc	//
+sc4boomb	//
+sc4boomba	//
 sc4cfqps	// Crazy Fruits (Qps)
 sc4cfqpsa	//
 sc4cfqpsb	//
@@ -13123,6 +13158,24 @@
 sc4cfqpsj	//
 sc4cfqpsk	//
 sc4cfcas	// Crazy Fruits Casino (Bellfruit)
+sc4cfcasa	//
+sc4cfcasb	//
+sc4cfcasc	//
+sc4cfcasd	//
+sc4cfcase	//
+sc4cfcasf	//
+sc4cfcasg	//
+sc4cfcash	//
+sc4cfcasi	//
+sc4cfcasj	//
+sc4cfcask	//
+sc4cfcasl	//
+sc4cfcasm	//
+sc4cfcasn	//
+sc4cfcaso	//
+sc4cfcasp	//
+sc4cfcasq	//
+sc4cfcasr	//
 sc4cfcla	// Crazy Fruits Classic (Bellfruit)
 sc4cfclab	//
 sc4cfclac	//
@@ -13196,6 +13249,10 @@
 sc4crzkyq	//
 sc4crzkyr	//
 sc4crzkys	//
+sc4crzkyt	//
+sc4crzkyu	//
+sc4crzkyv	//
+sc4crzkyw	//
 sc4crzwl	// Crazy World (Mazooma)
 sc4crzwla	//
 sc4crzwlb	//
@@ -13786,6 +13843,10 @@
 sc4luckby	//
 sc4luckbz	//
 sc4luckb0	//
+sc4luckb1	//
+sc4luckb2	//
+sc4luckb3	//
+sc4luckb4	//
 sc4magci	// Magic Circle (Qps)
 sc4magcia	//
 sc4magcib	//
@@ -13840,6 +13901,10 @@
 sc4mgrg		//
 sc4mgrh		//
 sc4mgri		//
+sc4mgrj		//
+sc4mgrk		//
+sc4mgrl		//
+sc4mgrm		//
 sc4mspid	// Money Spider (Bellfruit)
 sc4mspida	//
 sc4mspidb	//
@@ -14027,6 +14092,8 @@
 sc4pogbla	//
 sc4pogblb	//
 sc4pogblc	//
+sc4pogbld	//
+sc4pogble	//
 sc4pwcrz	// Power Crazy (Bellfruit)
 sc4pwcrza	//
 sc4pwcrzb	//
@@ -14563,6 +14630,10 @@
 sc4wldbnk	//
 sc4wldbnl	//
 sc4wldbnm	//
+sc4wldbnn	//
+sc4wldbno	//
+sc4wldbnp	//
+sc4wldbnq	//
 sc4wthng	// Wild Thing (Bellfruit)
 sc4wthnga	//
 sc4wthngb	//
@@ -14778,6 +14849,7 @@
 sc4cariqf	//
 sc4cariqg	//
 sc4cblas	// Cash Blast (Bellfruit)
+sc4cblasa	//
 sc4casxt	// Casino Xtravaganza  (Mazooma)
 sc4casxta	//
 sc4casxtb	//
@@ -14873,6 +14945,8 @@
 sc4dndcsa	//
 sc4dndcsb	//
 sc4dndcsc	//
+sc4dndcsd	//
+sc4dndcse	//
 sc4dndbb	// Deal Or No Deal Break The Bank (Bellfruit)
 sc4dndbba	//
 sc4dndbbb	//
@@ -14909,9 +14983,13 @@
 sc4dndhfg	//
 sc4dndhfh	//
 sc4dndhfi	//
+sc4dndhfj	//
+sc4dndhfk	//
+sc4dndhfl	//
 sc4dndys	// Deal Or No Deal It's Your Show (Bellfruit)
 sc4dndysa	//
 sc4dndysb	//
+sc4dndysc	//
 sc4dndlp	// Deal Or No Deal Let's Play Deal Or No Deal (Bellfruit)
 sc4dndlpa	//
 sc4dndlpb	//
@@ -15049,6 +15127,8 @@
 sc4fguya	//
 sc4fguyb	//
 sc4fguyc	//
+sc4fguyd	//
+sc4fguye	//
 sc4fbspn	// Fat Boy Spin (Bellfruit)
 sc4fbspna	//
 sc4fbspnb	//
@@ -15195,6 +15275,10 @@
 sc4hntcsm	//
 sc4hntcsn	//
 sc4hntcso	//
+sc4hntcsp	//
+sc4hntcsq	//
+sc4hntcsr	//
+sc4hntcss	//
 sc4hellb	// Hells Bells (Bellfruit)
 sc4hellba	//
 sc4hellbb	//
@@ -15249,6 +15333,8 @@
 sc4ijobi	//
 sc4ijobj	//
 sc4ijobk	//
+sc4ijobl	//
+sc4ijobm	//
 sc4jjok		// Jackpot Jokers (Bellfruit)
 sc4jjoka	//
 sc4ldvl		// Little Devil (Mazooma)
@@ -15368,6 +15454,9 @@
 sc4mhpi		//
 sc4mhpj		//
 sc4mhpk		//
+sc4mhpl		//
+sc4mhpm		//
+sc4mhpn		//
 sc4mmb		// Monopoly Money Bags (Bellfruit)
 sc4mmba		//
 sc4mrh		// Monopoly Red Hot (Mazooma)
@@ -15442,6 +15531,8 @@
 sc4popeya	//
 sc4popeyb	//
 sc4popeyc	//
+sc4popeyd	//
+sc4popeye	//
 sc4pog		// Pots Of Gold (Bellfruit)
 sc4bulcsb	//
 sc4poga		//
@@ -15452,6 +15543,8 @@
 sc4poge		//
 sc4pogf		//
 sc4pogg		//
+sc4pogh		//
+sc4pogi		//
 sc4pwrpl	// Power Play (Mazooma)
 sc4pwrpla	//
 sc4pwrplb	//
@@ -15516,6 +15609,7 @@
 sc4showtc	//
 sc4showtd	//
 sc4showte	//
+sc4showtf	//
 sc4slad		// Snakes & Ladders (Bellfruit)
 sc4slada	//
 sc4sladb	//
@@ -19735,9 +19829,10 @@
 jnero			// (c) 2004 ICE/Play Mechanix
 
 // Amatic Trading GMBH
-am_uslot		// (c) 1996 Amatic
+suprstar		// (c) 1996 Amatic
 am_mg24			// (c) 2000 Amatic
 am_mg3			// (c) 2000 Amatic
+am_mg3a			// (c) 2000 Amatic
 
 neptunp2
 rgum
@@ -19993,6 +20088,7 @@
    Bally MPU AS-2518-133
 */
 babypac
+babypac2
 granny
 
 // by68701.c
@@ -21364,3 +21460,4 @@
 
 manohman		// 199?, Merkur.
 jankenmn		// 1985, Sunwise.
+bikkuric
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2012-04-21 01:38:29.000000000 +0200
+++ src/mame/mame.mak	2012-05-04 14:02:55.000000000 +0200
@@ -1696,6 +1696,7 @@
 	$(DRIVERS)/cb2001.o \
 	$(DRIVERS)/cdi.o $(VIDEO)/mcd212.o $(MACHINE)/cdi070.o $(MACHINE)/cdislave.o $(MACHINE)/cdicdic.o \
 	$(DRIVERS)/cesclass.o \
+	$(DRIVERS)/chance32.o \
 	$(DRIVERS)/chsuper.o \
 	$(DRIVERS)/cidelsa.o $(VIDEO)/cidelsa.o \
 	$(DRIVERS)/coinmstr.o \
@@ -1904,6 +1905,8 @@
 
 $(DRIVERS)/acefruit.o:	$(LAYOUT)/sidewndr.lh
 
+$(DRIVERS)/amaticmg.o:	$(LAYOUT)/suprstar.lh
+
 $(DRIVERS)/ampoker2.o:	$(LAYOUT)/ampoker2.lh \
 			$(LAYOUT)/sigmapkr.lh \
 
@@ -2069,6 +2072,8 @@
 			$(LAYOUT)/mdrawpkr.lh \
 			$(LAYOUT)/meybjack.lh
 
+$(DRIVERS)/meyc8088.o:	$(LAYOUT)/gldarrow.lh
+
 $(DRIVERS)/midzeus.o:	$(LAYOUT)/crusnexo.lh
 
 $(DRIVERS)/mil4000.o:	$(LAYOUT)/mil4000.lh
diff -Nru src-old/mame/video/aeroboto.c src/mame/video/aeroboto.c
--- src-old/mame/video/aeroboto.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/aeroboto.c	2012-05-03 11:00:08.000000000 +0200
@@ -81,7 +81,7 @@
 
 READ8_MEMBER(aeroboto_state::aeroboto_in0_r)
 {
-	return input_port_read(machine(), flip_screen() ? "P2" : "P1");
+	return ioport(flip_screen() ? "P2" : "P1")->read();
 }
 
 WRITE8_MEMBER(aeroboto_state::aeroboto_3000_w)
diff -Nru src-old/mame/video/amiga.c src/mame/video/amiga.c
--- src-old/mame/video/amiga.c	2012-01-12 23:19:49.000000000 +0100
+++ src/mame/video/amiga.c	2012-05-03 11:00:08.000000000 +0200
@@ -147,7 +147,7 @@
 {
 	amiga_state *state = screen.machine().driver_data<amiga_state>();
 	UINT32 hvpos = (state->m_last_scanline << 8) | (screen.hpos() >> 2);
-	UINT32 latchedpos = input_port_read_safe(screen.machine(), "HVPOS", 0);
+	UINT32 latchedpos = state->ioport("HVPOS")->read_safe(0);
 
 	/* if there's no latched position, or if we are in the active display area */
 	/* but before the latching point, return the live HV position */
diff -Nru src-old/mame/video/argus.c src/mame/video/argus.c
--- src-old/mame/video/argus.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/argus.c	2012-05-03 11:00:08.000000000 +0200
@@ -369,7 +369,7 @@
 	int voffs;
 	int offs;
 
-	UINT8 *VROM1 = machine.root_device().memregion("user1")->base();		/* "ag_15.bin" */
+	UINT8 *VROM1 = state->memregion("user1")->base();		/* "ag_15.bin" */
 	UINT8 *VROM2 = state->memregion("user2")->base();		/* "ag_16.bin" */
 
 	/* offset in pattern data */
diff -Nru src-old/mame/video/artmagic.c src/mame/video/artmagic.c
--- src-old/mame/video/artmagic.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/artmagic.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 VIDEO_START( artmagic )
 {
 	artmagic_state *state = machine.driver_data<artmagic_state>();
-	state->m_blitter_base = (UINT16 *)machine.root_device().memregion("gfx1")->base();
+	state->m_blitter_base = (UINT16 *)state->memregion("gfx1")->base();
 	state->m_blitter_mask = state->memregion("gfx1")->bytes()/2 - 1;
 
 	state_save_register_global_array(machine, state->m_xor);
diff -Nru src-old/mame/video/astrocde.c src/mame/video/astrocde.c
--- src-old/mame/video/astrocde.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/astrocde.c	2012-05-03 11:00:08.000000000 +0200
@@ -481,51 +481,51 @@
 			break;
 
 		case 0x10:	/* player 1 handle */
-			result = input_port_read_safe(machine(), "P1HANDLE", 0xff);
+			result = ioport("P1HANDLE")->read_safe(0xff);
 			break;
 
 		case 0x11:	/* player 2 handle */
-			result = input_port_read_safe(machine(), "P2HANDLE", 0xff);
+			result = ioport("P2HANDLE")->read_safe(0xff);
 			break;
 
 		case 0x12:	/* player 3 handle */
-			result = input_port_read_safe(machine(), "P3HANDLE", 0xff);
+			result = ioport("P3HANDLE")->read_safe(0xff);
 			break;
 
 		case 0x13:	/* player 4 handle */
-			result = input_port_read_safe(machine(), "P4HANDLE", 0xff);
+			result = ioport("P4HANDLE")->read_safe(0xff);
 			break;
 
 		case 0x14:	/* keypad column 0 */
-			result = input_port_read_safe(machine(), "KEYPAD0", 0xff);
+			result = ioport("KEYPAD0")->read_safe(0xff);
 			break;
 
 		case 0x15:	/* keypad column 1 */
-			result = input_port_read_safe(machine(), "KEYPAD1", 0xff);
+			result = ioport("KEYPAD1")->read_safe(0xff);
 			break;
 
 		case 0x16:	/* keypad column 2 */
-			result = input_port_read_safe(machine(), "KEYPAD2", 0xff);
+			result = ioport("KEYPAD2")->read_safe(0xff);
 			break;
 
 		case 0x17:	/* keypad column 3 */
-			result = input_port_read_safe(machine(), "KEYPAD3", 0xff);
+			result = ioport("KEYPAD3")->read_safe(0xff);
 			break;
 
 		case 0x1c:	/* player 1 knob */
-			result = input_port_read_safe(machine(), "P1_KNOB", 0xff);
+			result = ioport("P1_KNOB")->read_safe(0xff);
 			break;
 
 		case 0x1d:	/* player 2 knob */
-			result = input_port_read_safe(machine(), "P2_KNOB", 0xff);
+			result = ioport("P2_KNOB")->read_safe(0xff);
 			break;
 
 		case 0x1e:	/* player 3 knob */
-			result = input_port_read_safe(machine(), "P3_KNOB", 0xff);
+			result = ioport("P3_KNOB")->read_safe(0xff);
 			break;
 
 		case 0x1f:	/* player 4 knob */
-			result = input_port_read_safe(machine(), "P4_KNOB", 0xff);
+			result = ioport("P4_KNOB")->read_safe(0xff);
 			break;
 	}
 
diff -Nru src-old/mame/video/atari.c src/mame/video/atari.c
--- src-old/mame/video/atari.c	2012-01-15 23:40:54.000000000 +0100
+++ src/mame/video/atari.c	2012-05-03 11:00:08.000000000 +0200
@@ -774,7 +774,7 @@
 
 	copybitmap(bitmap, *antic.bitmap, 0, 0, 0, 0, cliprect);
 
-	new_tv_artifacts = input_port_read_safe(screen.machine(), "artifacts", 0);
+	new_tv_artifacts = screen.machine().root_device().ioport("artifacts")->read_safe(0);
 	if( tv_artifacts != new_tv_artifacts )
 	{
 		tv_artifacts = new_tv_artifacts;
@@ -1501,7 +1501,7 @@
 
     if( antic.scanline == VBL_START )
     {
-		button_port = input_port_read_safe(machine, "djoy_b", 0);
+		button_port = machine.root_device().ioport("djoy_b")->read_safe(0);
 
 		/* specify buttons relevant to this Atari variant */
 		for (i = 0; i < button_count; i++)
diff -Nru src-old/mame/video/atarisy1.c src/mame/video/atarisy1.c
--- src-old/mame/video/atarisy1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/atarisy1.c	2012-05-03 11:00:08.000000000 +0200
@@ -557,7 +557,7 @@
 static void decode_gfx(running_machine &machine, UINT16 *pflookup, UINT16 *molookup)
 {
 	atarisy1_state *state = machine.driver_data<atarisy1_state>();
-	UINT8 *prom1 = &machine.root_device().memregion("proms")->u8(0x000);
+	UINT8 *prom1 = &state->memregion("proms")->u8(0x000);
 	UINT8 *prom2 = &state->memregion("proms")->u8(0x200);
 	int obj, i;
 
diff -Nru src-old/mame/video/awpvid.c src/mame/video/awpvid.c
--- src-old/mame/video/awpvid.c	2010-01-10 20:00:42.000000000 +0100
+++ src/mame/video/awpvid.c	2012-05-07 08:57:50.000000000 +0200
@@ -1,31 +1,12 @@
 /*************************************************************************************
 
     AWP Hardware video simulation system
+    originally written for AGEMAME by J.Wallace
 
-    A.G.E Code Copyright J. Wallace and the AGEMAME Development Team.
-    Visit http://www.mameworld.net/agemame/ for more information.
+    M.A.M.E Core Copyright Nicola Salmoria and the MAME Team.
 
-    M.A.M.E Core Copyright Nicola Salmoria and the MAME Team,
-    used under license from http://mamedev.org
-
-**************************************************************************************
-
-   NOTE: Fading lamp system currently only recognises three lamp states:
-
-   0=off, 1, 2= fully on
-
-   Based on evidence, newer techs may need more states, but we can give them their own
-   handlers at some stage in the distant future.
-
-   Instructions:
-   In order to set up displays (dot matrices, etc) we normally set up the unique
-   displays first, and then add the remainder in order.
-
-   The priorities (in descending order) are:
-
-   Full video screens
-   Dot matrix displays
-   Other, as yet unknown devices
+    This is a primitive handler for generating reels with multiple symbols visible
+    hanging off steppers.c .
 
 **************************************************************************************/
 
@@ -34,56 +15,12 @@
 #include "rendlay.h"
 #include "machine/steppers.h"
 
-static UINT8 steps[MAX_STEPPERS];
-static UINT8 symbols[MAX_STEPPERS];
-static UINT8 reelpos[MAX_STEPPERS];
-
-void awp_reel_setup(void)
-{
-	int x,reels;
-	char rstep[16],rsym[16];
-
-	if (!output_get_value("TotalReels"))
-	{
-		reels = 6 ;
-	}
-	else
-	{
-		reels = output_get_value("TotalReels");
-	}
-
-	for ( x = 0; x < reels; x++ )
-	{
-		sprintf(rstep, "ReelSteps%d",x+1);
-		sprintf(rsym, "ReelSymbols%d",x+1);
-
-		if (!output_get_value(rstep))
-		{
-			steps[x] = 6 ;
-		}
-		else
-		{
-			steps[x] = output_get_value(rstep);
-		}
-
-		if (!output_get_value(rsym))
-		{
-			symbols[x] = 1 ;
-		}
-		else
-		{
-			symbols[x] = output_get_value(rsym);
-		}
-	}
-}
+static UINT16 reelpos[MAX_STEPPERS];
 
 void awp_draw_reel(int rno)
 {
-	int rsteps = steps[rno];
-	int rsymbols = symbols[rno];
-	int m;
 	int x = rno + 1;
-	char rg[16], rga[16], rgb[16];
+	char rg[16];
 
 	sprintf(rg,"reel%d", x);
 	reelpos[rno] = stepper_get_position(rno);
@@ -93,27 +30,17 @@
 	}
 	else
 	{
-		reelpos[rno] = stepper_get_position(rno)%(stepper_get_max(rno)-1);
-		for ( m = 0; m < (rsymbols-1); m++ )
+
+		output_set_value(rg,(reelpos[rno]));
+
+		// if the reel isn't configured don't do this, otherwise you'll get DIV0
+		if (stepper_get_max(rno))
 		{
-			{
-				sprintf(rga,"reel%da%d", x, m);
-				output_set_value(rga,(reelpos[rno] + rsteps * m)%stepper_get_max(rno));
-			}
-
-			{
-				if ((reelpos[rno] - rsteps * m) < 0)
-				{
-					sprintf(rgb,"reel%db%d", x, m);
-					output_set_value(rgb,(reelpos[rno] - (rsteps * m - stepper_get_max(rno))));
-				}
-				else
-				{
-					sprintf(rgb,"reel%db%d", x, m);
-					output_set_value(rgb,(reelpos[rno] - rsteps * m));
-				}
-			}
+			sprintf(rg,"sreel%d", x); // our new scrolling reels are called 'sreel'
+			// normalize the value
+			int sreelpos = (reelpos[rno] * 0x10000) / stepper_get_max(rno);
+
+			output_set_value(rg,sreelpos);
 		}
-		output_set_value(rg,(reelpos[rno]));
 	}
 }
diff -Nru src-old/mame/video/awpvid.h src/mame/video/awpvid.h
--- src-old/mame/video/awpvid.h	2011-03-25 18:02:59.000000000 +0100
+++ src/mame/video/awpvid.h	2012-05-03 19:38:32.000000000 +0200
@@ -10,6 +10,4 @@
 extern const char layout_awpvid16[];	/* main layout positioning 6 reels, a lamp matrix and a 16seg VFD */
 void awp_draw_reel(int rno);
 
-void awp_reel_setup(void);
-
 #endif
diff -Nru src-old/mame/video/balsente.c src/mame/video/balsente.c
--- src-old/mame/video/balsente.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/balsente.c	2012-05-03 11:00:08.000000000 +0200
@@ -22,11 +22,11 @@
 
 	/* reset the system */
 	state->m_palettebank_vis = 0;
-	state->m_sprite_bank[0] = machine.root_device().memregion("gfx1")->base();
-	state->m_sprite_bank[1] = machine.root_device().memregion("gfx1")->base() + 0x10000;
+	state->m_sprite_bank[0] = state->memregion("gfx1")->base();
+	state->m_sprite_bank[1] = state->memregion("gfx1")->base() + 0x10000;
 
 	/* determine sprite size */
-	state->m_sprite_data = machine.root_device().memregion("gfx1")->base();
+	state->m_sprite_data = state->memregion("gfx1")->base();
 	state->m_sprite_mask = state->memregion("gfx1")->bytes() - 1;
 
 	/* register for saving */
diff -Nru src-old/mame/video/bking.c src/mame/video/bking.c
--- src-old/mame/video/bking.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/bking.c	2012-05-03 11:00:08.000000000 +0200
@@ -194,12 +194,12 @@
 
 READ8_MEMBER(bking_state::bking_input_port_5_r)
 {
-	return input_port_read(machine(), m_controller ? "TRACK1_X" : "TRACK0_X");
+	return ioport(m_controller ? "TRACK1_X" : "TRACK0_X")->read();
 }
 
 READ8_MEMBER(bking_state::bking_input_port_6_r)
 {
-	return input_port_read(machine(), m_controller ? "TRACK1_Y" : "TRACK0_Y");
+	return ioport(m_controller ? "TRACK1_Y" : "TRACK0_Y")->read();
 }
 
 READ8_MEMBER(bking_state::bking_pos_r)
diff -Nru src-old/mame/video/blockade.c src/mame/video/blockade.c
--- src-old/mame/video/blockade.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/blockade.c	2012-05-03 11:00:08.000000000 +0200
@@ -6,7 +6,7 @@
 	m_videoram[offset] = data;
 	m_bg_tilemap->mark_tile_dirty(offset);
 
-	if (input_port_read(machine(), "IN3") & 0x80)
+	if (ioport("IN3")->read() & 0x80)
 	{
 		logerror("blockade_videoram_w: scanline %d\n", machine().primary_screen->vpos());
 		device_spin_until_interrupt(&space.device());
diff -Nru src-old/mame/video/bombjack.c src/mame/video/bombjack.c
--- src-old/mame/video/bombjack.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/bombjack.c	2012-05-02 14:09:48.000000000 +0200
@@ -77,7 +77,7 @@
 	bombjack_state *state = machine.driver_data<bombjack_state>();
 	int offs;
 
-	for (offs = state->m_spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram.bytes() - 4; offs >= 0; offs -= 4)
 	{
 
 /*
diff -Nru src-old/mame/video/btime.c src/mame/video/btime.c
--- src-old/mame/video/btime.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/btime.c	2012-05-03 11:00:08.000000000 +0200
@@ -264,7 +264,7 @@
 	/* For now we just check 0x40 in DSW1, and ignore the write if we */
 	/* are in upright controls mode. */
 
-	if (input_port_read(machine(), "DSW1") & 0x40) /* cocktail mode */
+	if (ioport("DSW1")->read() & 0x40) /* cocktail mode */
 		btime_video_control_w(space, offset, data);
 }
 
@@ -278,7 +278,7 @@
 
 	m_btime_palette = (data & 0x30) >> 3;
 
-	if (input_port_read(machine(), "DSW1") & 0x40) /* cocktail mode */
+	if (ioport("DSW1")->read() & 0x40) /* cocktail mode */
 		flip_screen_set(data & 0x80);
 }
 
@@ -286,7 +286,7 @@
 {
 	m_btime_palette = (data >> 2) & 0x03;
 
-	if (!(input_port_read(machine(), "DSW1") & 0x40)) /* cocktail mode */
+	if (!(ioport("DSW1")->read() & 0x40)) /* cocktail mode */
 		flip_screen_set(data & 0x01);
 }
 
diff -Nru src-old/mame/video/bwing.c src/mame/video/bwing.c
--- src-old/mame/video/bwing.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/bwing.c	2012-05-03 11:00:08.000000000 +0200
@@ -150,7 +150,7 @@
 	g = ((g << 5) + (g << 2) + (g >> 1));
 	b = ((b << 5) + (b << 2) + (b >> 1));
 
-	if ((i = input_port_read(machine(), "EXTRA")) < 4)
+	if ((i = ioport("EXTRA")->read()) < 4)
 	{
 		r = (float)r * rgb[i][0];
 		g = (float)g * rgb[i][1];
diff -Nru src-old/mame/video/canyon.c src/mame/video/canyon.c
--- src-old/mame/video/canyon.c	2012-04-12 10:33:20.000000000 +0200
+++ src/mame/video/canyon.c	2012-05-03 11:00:08.000000000 +0200
@@ -83,7 +83,7 @@
 	draw_bombs(screen.machine(), bitmap, cliprect);
 
 	/* watchdog is disabled during service mode */
-	screen.machine().watchdog_enable(!(input_port_read(screen.machine(), "IN2") & 0x10));
+	screen.machine().watchdog_enable(!(screen.machine().root_device().ioport("IN2")->read() & 0x10));
 
 	return 0;
 }
diff -Nru src-old/mame/video/cave.c src/mame/video/cave.c
--- src-old/mame/video/cave.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/cave.c	2012-05-03 11:00:08.000000000 +0200
@@ -515,7 +515,7 @@
 {
 	cave_state *state = machine.driver_data<cave_state>();
 	pen_t base_pal = 0;
-	const UINT8 *base_gfx = machine.root_device().memregion("sprites")->base();
+	const UINT8 *base_gfx = state->memregion("sprites")->base();
 	int code_max = state->memregion("sprites")->bytes() / (16*16);
 
 	UINT16 *source;
@@ -644,7 +644,7 @@
 {
 	cave_state *state = machine.driver_data<cave_state>();
 	pen_t base_pal = 0;
-	const UINT8 *base_gfx = machine.root_device().memregion("sprites")->base();
+	const UINT8 *base_gfx = state->memregion("sprites")->base();
 	int code_max = state->memregion("sprites")->bytes() / (16*16);
 
 	UINT16 *source;
diff -Nru src-old/mame/video/centiped.c src/mame/video/centiped.c
--- src-old/mame/video/centiped.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/centiped.c	2012-05-03 11:00:08.000000000 +0200
@@ -462,7 +462,7 @@
 {
 	centiped_state *state = screen.machine().driver_data<centiped_state>();
 	UINT8 *spriteram = state->m_spriteram;
-	int upright_mode = input_port_read(screen.machine(), "IN0") & 0x80;
+	int upright_mode = screen.machine().root_device().ioport("IN0")->read() & 0x80;
 	int offs;
 
 	/* if the cocktail/upright switch flipped, force refresh */
diff -Nru src-old/mame/video/changela.c src/mame/video/changela.c
--- src-old/mame/video/changela.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/changela.c	2012-05-03 11:00:08.000000000 +0200
@@ -175,9 +175,9 @@
 	changela_state *state = machine.driver_data<changela_state>();
 	int sx, i, j;
 
-	UINT8* ROM = machine.root_device().memregion("user2")->base();
+	UINT8* ROM = state->memregion("user2")->base();
 	UINT8* RAM = state->m_memory_devices + 0x800;
-	UINT8* TILE_ROM = machine.root_device().memregion("gfx1")->base();
+	UINT8* TILE_ROM = state->memregion("gfx1")->base();
 	UINT8* TILE_RAM = state->m_memory_devices + 0x1000;
 	UINT8* PROM = state->memregion("proms")->base();
 
@@ -355,13 +355,13 @@
 	int sx, i, j;
 
 	/* State machine */
-	UINT8* ROM = machine.root_device().memregion("user2")->base();
+	UINT8* ROM = state->memregion("user2")->base();
 	UINT8* RAM = state->m_memory_devices + 0x840 + 0x40 * tree_num;
-	UINT8* PROM = machine.root_device().memregion("proms")->base();
+	UINT8* PROM = state->memregion("proms")->base();
 
 	/* Tree Data */
 	UINT8* RAM2 = state->m_tree_ram + 0x20 * tree_num;
-	UINT8* TILE_ROM = (tree_num ? (machine.root_device().memregion("user3")->base() + 0x1000) : (machine.root_device().memregion("gfx1")->base() + 0x2000));
+	UINT8* TILE_ROM = (tree_num ? (state->memregion("user3")->base() + 0x1000) : (state->memregion("gfx1")->base() + 0x2000));
 	UINT8* TILE_RAM = (tree_num ? (state->memregion("user3")->base()) : (state->m_memory_devices + 0x1800));
 
 	int preload = ((sy < 32) ? 1 : 0);
diff -Nru src-old/mame/video/cinemat.c src/mame/video/cinemat.c
--- src-old/mame/video/cinemat.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/cinemat.c	2012-05-03 11:00:08.000000000 +0200
@@ -232,7 +232,7 @@
 
 SCREEN_UPDATE_RGB32( spacewar )
 {
-	int sw_option = input_port_read(screen.machine(), "INPUTS");
+	int sw_option = screen.machine().root_device().ioport("INPUTS")->read();
 
 	SCREEN_UPDATE32_CALL(cinemat);
 
diff -Nru src-old/mame/video/cischeat.c src/mame/video/cischeat.c
--- src-old/mame/video/cischeat.c	2012-04-09 22:23:26.000000000 +0200
+++ src/mame/video/cischeat.c	2012-05-03 11:00:08.000000000 +0200
@@ -299,25 +299,25 @@
 {
 	switch (offset)
 	{
-		case 0x0000/2 : return input_port_read(machine(), "IN1");	// Coins
-		case 0x0002/2 : return input_port_read(machine(), "IN2");	// Buttons
-		case 0x0004/2 : return input_port_read(machine(), "IN3");	// Motor Limit Switches
-		case 0x0006/2 : return input_port_read(machine(), "IN4");	// DSW 1 & 2
+		case 0x0000/2 : return ioport("IN1")->read();	// Coins
+		case 0x0002/2 : return ioport("IN2")->read();	// Buttons
+		case 0x0004/2 : return ioport("IN3")->read();	// Motor Limit Switches
+		case 0x0006/2 : return ioport("IN4")->read();	// DSW 1 & 2
 
 		case 0x0008/2 :	return soundlatch2_word_r(space,0,0xffff);	// From sound cpu
 
 		case 0x0010/2 :
 			switch (m_ip_select & 0x3)
 			{
-				case 0 : return input_port_read(machine(), "IN6");		// Driving Wheel
+				case 0 : return ioport("IN6")->read();		// Driving Wheel
 				case 1 : return 0xffff;					// Cockpit: Up / Down Position
 				case 2 : return 0xffff;					// Cockpit: Left / Right Position?
-				case 3 : return input_port_read(machine(), "PEDAL");	// Accelerator (Pedal)
+				case 3 : return ioport("PEDAL")->read();	// Accelerator (Pedal)
 				default: return 0xffff;
 			}
 
 
-		case 0x2200/2 : return input_port_read(machine(), "IN5");	// DSW 3 (4 bits)
+		case 0x2200/2 : return ioport("IN5")->read();	// DSW 3 (4 bits)
 
 		default:	SHOW_READ_ERROR("vreg %04X read!",offset*2);
 					return m_vregs[offset];
@@ -395,21 +395,21 @@
 {
 	switch (offset)
 	{
-		case 0x0000/2 : return input_port_read(machine(), "IN1");	// Coins
-		case 0x0002/2 : return input_port_read(machine(), "IN2");	// Buttons
-		case 0x0004/2 : return input_port_read(machine(), "IN3");	// Motor Limit Switches
-		case 0x0006/2 : return input_port_read(machine(), "IN4");	// DSW 1 & 2
+		case 0x0000/2 : return ioport("IN1")->read();	// Coins
+		case 0x0002/2 : return ioport("IN2")->read();	// Buttons
+		case 0x0004/2 : return ioport("IN3")->read();	// Motor Limit Switches
+		case 0x0006/2 : return ioport("IN4")->read();	// DSW 1 & 2
 
 		case 0x0010/2 :
 			switch (m_ip_select & 0x3)
 			{
-				case 0 : return input_port_read(machine(), "IN6");	// Driving Wheel
+				case 0 : return ioport("IN6")->read();	// Driving Wheel
 				case 1 : return ~0;					// Cockpit: Up / Down Position?
 				case 2 : return ~0;					// Cockpit: Left / Right Position?
 				default: return ~0;
 			}
 
-		case 0x2200/2 : return input_port_read(machine(), "IN5");	// DSW 3 (4 bits)
+		case 0x2200/2 : return ioport("IN5")->read();	// DSW 3 (4 bits)
 		case 0x2300/2 : return soundlatch2_byte_r(space,0);	// From sound cpu
 
 		default:	SHOW_READ_ERROR("vreg %04X read!",offset*2);
@@ -488,20 +488,20 @@
 {
 	switch (offset)
 	{
-		case 0x0000/2 :	return input_port_read(machine(), "IN1");	// DSW 1 & 2
+		case 0x0000/2 :	return ioport("IN1")->read();	// DSW 1 & 2
 
 //      case 0x0002/2 : return 0xFFFF;
 
-		case 0x0004/2 :	return input_port_read(machine(), "IN2");	// Buttons
+		case 0x0004/2 :	return ioport("IN2")->read();	// Buttons
 
-		case 0x0006/2 :	return input_port_read(machine(), "IN3");	// ? Read at boot only
+		case 0x0006/2 :	return ioport("IN3")->read();	// ? Read at boot only
 
 		case 0x0008/2 :	return soundlatch2_byte_r(space,0);		// From sound cpu
 
-		case 0x000c/2 :	return input_port_read(machine(), "IN4");	// DSW 3
+		case 0x000c/2 :	return ioport("IN4")->read();	// DSW 3
 
 		case 0x0010/2 :	// Accel + Driving Wheel
-			return (input_port_read(machine(), "PEDAL") & 0xff) + ((input_port_read(machine(), "IN5") & 0xff)<<8);
+			return (ioport("PEDAL")->read() & 0xff) + ((ioport("IN5")->read() & 0xff)<<8);
 
 		default:		SHOW_READ_ERROR("vreg %04X read!",offset*2);
 						return m_vregs[offset];
@@ -534,14 +534,14 @@
 
 	switch (offset)
 	{
-		case 0x0000/2 :	return input_port_read(machine(), "IN0"); // DSW 1 & 2
+		case 0x0000/2 :	return ioport("IN0")->read(); // DSW 1 & 2
 
-		case 0x0004/2 :	return input_port_read(machine(), "IN1"); // Buttons
+		case 0x0004/2 :	return ioport("IN1")->read(); // Buttons
 
 		case 0x0008/2 :	return soundlatch2_byte_r(space,0); // From sound cpu
 
 		case 0x0010/2 :	// X, Y
-			return input_port_read(machine(), "IN2") | (input_port_read(machine(), "IN3")<<8);
+			return ioport("IN2")->read() | (ioport("IN3")->read()<<8);
 
 		case 0x0018/2 :
 			return (m_f1gpstr2_ioready[0]&1) ? 0xff : 0xf0;
diff -Nru src-old/mame/video/cosmic.c src/mame/video/cosmic.c
--- src-old/mame/video/cosmic.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/cosmic.c	2012-05-03 11:00:08.000000000 +0200
@@ -373,7 +373,7 @@
 {
 	cosmic_state *state = machine.driver_data<cosmic_state>();
 	UINT8 y;
-	UINT8 *horz_PROM = machine.root_device().memregion("user2")->base();
+	UINT8 *horz_PROM = state->memregion("user2")->base();
 	UINT8 *vert_PROM = state->memregion("user3")->base();
 	offs_t horz_addr = 0;
 
diff -Nru src-old/mame/video/cps1.c src/mame/video/cps1.c
--- src-old/mame/video/cps1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/cps1.c	2012-05-03 11:00:08.000000000 +0200
@@ -1619,10 +1619,10 @@
 				m_cps_b_regs[m_game_config->mult_factor2 / 2]) >> 16;
 
 	if (offset == m_game_config->in2_addr / 2)	/* Extra input ports (on C-board) */
-		return input_port_read(machine(), "IN2");
+		return ioport("IN2")->read();
 
 	if (offset == m_game_config->in3_addr / 2)	/* Player 4 controls (on C-board) ("Captain Commando") */
-		return input_port_read(machine(), "IN3");
+		return ioport("IN3")->read();
 
 	if (m_cps_version == 2)
 	{
diff -Nru src-old/mame/video/dc.c src/mame/video/dc.c
--- src-old/mame/video/dc.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/dc.c	2012-05-03 11:00:08.000000000 +0200
@@ -2679,7 +2679,7 @@
 		pvr_drawframebuffer(screen.machine(),bitmap,cliprect);
 
 	// update this here so we only do string lookup once per frame
-	state->debug_dip_status = input_port_read(screen.machine(), "MAMEDEBUG");
+	state->debug_dip_status = screen.machine().root_device().ioport("MAMEDEBUG")->read();
 
 	return 0;
 }
diff -Nru src-old/mame/video/dcheese.c src/mame/video/dcheese.c
--- src-old/mame/video/dcheese.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/dcheese.c	2012-05-03 11:00:08.000000000 +0200
@@ -168,7 +168,7 @@
 	INT32 dxdy = (INT32)(((state->m_blitter_xparam[6] & 0x0fff) | ((state->m_blitter_xparam[7] & 0x0fff) << 12)) << 12) >> 12;
 	INT32 dydx = (INT32)(((state->m_blitter_yparam[4] & 0x0fff) | ((state->m_blitter_yparam[5] & 0x0fff) << 12)) << 12) >> 12;
 	INT32 dydy = (INT32)(((state->m_blitter_yparam[6] & 0x0fff) | ((state->m_blitter_yparam[7] & 0x0fff) << 12)) << 12) >> 12;
-	UINT8 *src = machine.root_device().memregion("gfx1")->base();
+	UINT8 *src = state->memregion("gfx1")->base();
 	UINT32 pagemask = (state->memregion("gfx1")->bytes() - 1) / 0x40000;
 	int xstart = state->m_blitter_xparam[14];
 	int xend = state->m_blitter_xparam[15] + 1;
@@ -307,9 +307,9 @@
 {
 	/* analog inputs seem to be hooked up here -- might not actually map to blitter */
 	if (offset == 0x02/2)
-		return input_port_read(machine(), "2a0002");
+		return ioport("2a0002")->read();
 	if (offset == 0x0e/2)
-		return input_port_read(machine(), "2a000e");
+		return ioport("2a000e")->read();
 
 	/* early code polls on this bit, wants it to be 0 */
 	if (offset == 0x36/2)
diff -Nru src-old/mame/video/deco_mlc.c src/mame/video/deco_mlc.c
--- src-old/mame/video/deco_mlc.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/deco_mlc.c	2012-05-03 11:00:08.000000000 +0200
@@ -216,7 +216,7 @@
 	UINT32 *index_ptr=0;
 	int offs,fx=0,fy=0,x,y,color,colorOffset,sprite,indx,h,w,bx,by,fx1,fy1;
 	int xoffs,yoffs;
-	UINT8 *rom = machine.root_device().memregion("gfx2")->base() + 0x20000, *index_ptr8;
+	UINT8 *rom = state->memregion("gfx2")->base() + 0x20000, *index_ptr8;
 	UINT8 *rawrom = state->memregion("gfx2")->base();
 	int blockIsTilemapIndex=0;
 	int sprite2=0,indx2=0,use8bppMode=0;
diff -Nru src-old/mame/video/decocass.c src/mame/video/decocass.c
--- src-old/mame/video/decocass.c	2012-04-12 10:33:20.000000000 +0200
+++ src/mame/video/decocass.c	2012-05-03 11:00:08.000000000 +0200
@@ -526,7 +526,7 @@
 	int scrollx, scrolly_l, scrolly_r;
 	rectangle clip;
 
-	if (0xc0 != (input_port_read(screen.machine(), "IN2") & 0xc0))  /* coin slots assert an NMI */
+	if (0xc0 != (screen.machine().root_device().ioport("IN2")->read() & 0xc0))  /* coin slots assert an NMI */
 		device_set_input_line(state->m_maincpu, INPUT_LINE_NMI, ASSERT_LINE);
 
 	if (0 == (state->m_watchdog_flip & 0x04))
diff -Nru src-old/mame/video/dkong.c src/mame/video/dkong.c
--- src-old/mame/video/dkong.c	2012-04-22 07:07:46.000000000 +0200
+++ src/mame/video/dkong.c	2012-05-03 11:00:08.000000000 +0200
@@ -880,13 +880,13 @@
 static void check_palette(running_machine &machine)
 {
 	dkong_state *state = machine.driver_data<dkong_state>();
-	const input_port_config *port;
+	ioport_port *port;
 	int newset;
 
 	port = state->ioport("VIDHW");
 	if (port != NULL)
 	{
-		newset = input_port_read_direct(port);
+		newset = port->read();
 		if (newset != state->m_vidhw)
 		{
 			state->m_vidhw = newset;
@@ -937,8 +937,8 @@
 	{
 		case HARDWARE_TRS02:
 			machine.primary_screen->register_screen_bitmap(state->m_bg_bits);
-			state->m_gfx3 = machine.root_device().memregion("gfx3")->base();
-			state->m_gfx3_len = machine.root_device().memregion("gfx3")->bytes();
+			state->m_gfx3 = state->memregion("gfx3")->base();
+			state->m_gfx3_len = state->memregion("gfx3")->bytes();
 		    /* fall through */
 		case HARDWARE_TKG04:
 		case HARDWARE_TKG02:
@@ -950,8 +950,8 @@
 			state->m_bg_tilemap->set_scrolldx(0, 128);
 
 			machine.primary_screen->register_screen_bitmap(state->m_bg_bits);
-			state->m_gfx4 = machine.root_device().memregion("gfx4")->base();
-			state->m_gfx3 = machine.root_device().memregion("gfx3")->base();
+			state->m_gfx4 = state->memregion("gfx4")->base();
+			state->m_gfx3 = state->memregion("gfx3")->base();
 			state->m_gfx3_len = state->memregion("gfx3")->bytes();
 
 			break;
diff -Nru src-old/mame/video/dooyong.c src/mame/video/dooyong.c
--- src-old/mame/video/dooyong.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/dooyong.c	2012-05-03 11:00:08.000000000 +0200
@@ -629,7 +629,7 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx5")->base();
+	state->m_bg_tilerom = state->memregion("gfx5")->base();
 	state->m_fg_tilerom = state->memregion("gfx6")->base();
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
@@ -669,7 +669,7 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx5")->base();
+	state->m_bg_tilerom = state->memregion("gfx5")->base();
 	state->m_fg_tilerom = state->memregion("gfx6")->base();
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
@@ -708,7 +708,7 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx5")->base();
+	state->m_bg_tilerom = state->memregion("gfx5")->base();
 	state->m_fg_tilerom = state->memregion("gfx6")->base();
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
@@ -744,8 +744,8 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx3")->base() + 0x78000;
-	state->m_fg_tilerom = machine.root_device().memregion("gfx4")->base() + 0x78000;
+	state->m_bg_tilerom = state->memregion("gfx3")->base() + 0x78000;
+	state->m_fg_tilerom = state->memregion("gfx4")->base() + 0x78000;
 	state->m_fg2_tilerom = state->memregion("gfx5")->base() + 0x38000;
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
@@ -785,7 +785,7 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx3")->base() + 0x78000;
+	state->m_bg_tilerom = state->memregion("gfx3")->base() + 0x78000;
 	state->m_fg_tilerom = state->memregion("gfx4")->base() + 0x78000;
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
@@ -821,8 +821,8 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx2")->base() + machine.root_device().memregion("gfx2")->bytes() - 0x8000;
-	state->m_fg_tilerom = machine.root_device().memregion("gfx3")->base() + state->memregion("gfx3")->bytes() - 0x8000;
+	state->m_bg_tilerom = state->memregion("gfx2")->base() + state->memregion("gfx2")->bytes() - 0x8000;
+	state->m_fg_tilerom = state->memregion("gfx3")->base() + state->memregion("gfx3")->bytes() - 0x8000;
 	state->m_bg_tilerom2 = NULL;
 	state->m_fg_tilerom2 = NULL;
 	state->m_bg_gfx = 1;
@@ -856,13 +856,13 @@
 {
 	dooyong_state *state = machine.driver_data<dooyong_state>();
 	/* Configure tilemap callbacks */
-	state->m_bg_tilerom = machine.root_device().memregion("gfx5")->base();
-	state->m_bg2_tilerom = machine.root_device().memregion("gfx4")->base();
-	state->m_fg_tilerom = machine.root_device().memregion("gfx3")->base();
-	state->m_fg2_tilerom = machine.root_device().memregion("gfx2")->base();
-	state->m_bg_tilerom2 = machine.root_device().memregion("gfx6")->base() + 0x60000;
-	state->m_bg2_tilerom2 = machine.root_device().memregion("gfx6")->base() + 0x40000;
-	state->m_fg_tilerom2 = machine.root_device().memregion("gfx6")->base() + 0x20000;
+	state->m_bg_tilerom = state->memregion("gfx5")->base();
+	state->m_bg2_tilerom = state->memregion("gfx4")->base();
+	state->m_fg_tilerom = state->memregion("gfx3")->base();
+	state->m_fg2_tilerom = state->memregion("gfx2")->base();
+	state->m_bg_tilerom2 = state->memregion("gfx6")->base() + 0x60000;
+	state->m_bg2_tilerom2 = state->memregion("gfx6")->base() + 0x40000;
+	state->m_fg_tilerom2 = state->memregion("gfx6")->base() + 0x20000;
 	state->m_fg2_tilerom2 = state->memregion("gfx6")->base() + 0x00000;
 	state->m_bg_gfx = 4;
 	state->m_bg2_gfx = 3;
diff -Nru src-old/mame/video/dynax.c src/mame/video/dynax.c
--- src-old/mame/video/dynax.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/dynax.c	2012-05-03 11:00:08.000000000 +0200
@@ -356,7 +356,7 @@
 {
 	dynax_state *state = machine.driver_data<dynax_state>();
 	UINT8 cmd;
-	UINT8 *ROM = machine.root_device().memregion(gfx)->base();
+	UINT8 *ROM = state->memregion(gfx)->base();
 	size_t ROM_size = state->memregion(gfx)->bytes();
 
 	int sx;
@@ -1204,7 +1204,7 @@
 	if (toggle)
 	{
 		dynax_state *state = machine.driver_data<dynax_state>();
-		UINT8 *RAM = machine.root_device().memregion( "gfx1" )->base();
+		UINT8 *RAM = state->memregion( "gfx1" )->base();
 		size_t size = state->memregion( "gfx1" )->bytes();
 		static int i = 0, c = 0, r = 0;
 
diff -Nru src-old/mame/video/esripsys.c src/mame/video/esripsys.c
--- src-old/mame/video/esripsys.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/esripsys.c	2012-05-03 11:00:08.000000000 +0200
@@ -225,7 +225,7 @@
 
 		if (x_flip)
 		{
-			rom_l = machine.root_device().memregion("8bpp_r")->base();
+			rom_l = state->memregion("8bpp_r")->base();
 			rom_r = state->memregion("8bpp_l")->base();
 		}
 		else
diff -Nru src-old/mame/video/exerion.c src/mame/video/exerion.c
--- src-old/mame/video/exerion.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/exerion.c	2012-05-03 11:00:08.000000000 +0200
@@ -111,7 +111,7 @@
 	UINT8 *gfx;
 
 	/* get pointers to the mixing and lookup PROMs */
-	state->m_background_mixer = machine.root_device().memregion("proms")->base() + 0x320;
+	state->m_background_mixer = state->memregion("proms")->base() + 0x320;
 
 	/* allocate memory for the decoded background graphics */
 	state->m_background_gfx[0] = auto_alloc_array(machine, UINT16, 256 * 256 * 4);
diff -Nru src-old/mame/video/exidy.c src/mame/video/exidy.c
--- src-old/mame/video/exidy.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/exidy.c	2012-05-03 11:00:08.000000000 +0200
@@ -62,7 +62,7 @@
 {
 	exidy_state *state = machine.driver_data<exidy_state>();
 	collision ^= state->m_collision_invert;
-	state->m_int_condition = (input_port_read(machine, "INTSOURCE") & ~0x1c) | (collision & state->m_collision_mask);
+	state->m_int_condition = (state->ioport("INTSOURCE")->read() & ~0x1c) | (collision & state->m_collision_mask);
 }
 
 
diff -Nru src-old/mame/video/exidy440.c src/mame/video/exidy440.c
--- src-old/mame/video/exidy440.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/exidy440.c	2012-05-03 11:00:08.000000000 +0200
@@ -435,8 +435,8 @@
 	{
 		int i;
 
-		int beamx = ((input_port_read(screen.machine(), "AN0") & 0xff) * (HBSTART - HBEND)) >> 8;
-		int beamy = ((input_port_read(screen.machine(), "AN1") & 0xff) * (VBSTART - VBEND)) >> 8;
+		int beamx = ((screen.machine().root_device().ioport("AN0")->read() & 0xff) * (HBSTART - HBEND)) >> 8;
+		int beamy = ((screen.machine().root_device().ioport("AN1")->read() & 0xff) * (VBSTART - VBEND)) >> 8;
 
 		/* The timing of this FIRQ is very important. The games look for an FIRQ
             and then wait about 650 cycles, clear the old FIRQ, and wait a
diff -Nru src-old/mame/video/f1gp.c src/mame/video/f1gp.c
--- src-old/mame/video/f1gp.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/f1gp.c	2012-05-03 11:00:08.000000000 +0200
@@ -52,7 +52,7 @@
 
 	state->m_fg_tilemap->set_transparent_pen(0xff);
 
-	state->m_zoomdata = (UINT16 *)machine.root_device().memregion("gfx4")->base();
+	state->m_zoomdata = (UINT16 *)state->memregion("gfx4")->base();
 	gfx_element_set_source(machine.gfx[3], (UINT8 *)state->m_zoomdata);
 
 //  state->save_pointer(NAME(state->m_zoomdata), state->memregion("gfx4")->bytes());
@@ -68,7 +68,7 @@
 
 	state->m_fg_tilemap->set_transparent_pen(0xff);
 
-	state->m_zoomdata = (UINT16 *)machine.root_device().memregion("gfx4")->base();
+	state->m_zoomdata = (UINT16 *)state->memregion("gfx4")->base();
 	gfx_element_set_source(machine.gfx[3], (UINT8 *)state->m_zoomdata);
 
 //  state->save_pointer(NAME(state->m_zoomdata), state->memregion("gfx4")->bytes());
diff -Nru src-old/mame/video/fgoal.c src/mame/video/fgoal.c
--- src-old/mame/video/fgoal.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/fgoal.c	2012-05-03 11:00:08.000000000 +0200
@@ -48,7 +48,7 @@
 
 	/* draw color overlay foreground and background */
 
-	if (state->m_fgoal_player == 1 && (input_port_read(screen.machine(), "IN1") & 0x40))
+	if (state->m_fgoal_player == 1 && (screen.machine().root_device().ioport("IN1")->read() & 0x40))
 	{
 		drawgfxzoom_opaque(state->m_fgbitmap, cliprect, screen.machine().gfx[0],
 			0, (state->m_fgoal_player << 2) | state->m_current_color,
diff -Nru src-old/mame/video/galaxia.c src/mame/video/galaxia.c
--- src-old/mame/video/galaxia.c	2012-04-08 16:12:02.000000000 +0200
+++ src/mame/video/galaxia.c	2012-04-24 13:58:27.000000000 +0200
@@ -210,7 +210,7 @@
 		{
 			// NOTE: similar to zac2650.c, the sprite chip runs at a different frequency than the background generator
 			// the exact timing ratio is unknown, so we'll have to do with guesswork
-			float s_ratio = 256.0 / 196.0;
+			float s_ratio = 256.0f / 196.0f;
 
 			float sx = x * s_ratio;
 			if ((int)(sx + 0.5) > cliprect.max_x)
diff -Nru src-old/mame/video/gomoku.c src/mame/video/gomoku.c
--- src-old/mame/video/gomoku.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/gomoku.c	2012-05-03 11:00:08.000000000 +0200
@@ -106,8 +106,8 @@
 VIDEO_START( gomoku )
 {
 	gomoku_state *state = machine.driver_data<gomoku_state>();
-	UINT8 *GOMOKU_BG_X = machine.root_device().memregion( "user1" )->base();
-	UINT8 *GOMOKU_BG_Y = machine.root_device().memregion( "user2" )->base();
+	UINT8 *GOMOKU_BG_X = state->memregion( "user1" )->base();
+	UINT8 *GOMOKU_BG_Y = state->memregion( "user2" )->base();
 	UINT8 *GOMOKU_BG_D = state->memregion( "user3" )->base();
 	int x, y;
 	int bgdata;
diff -Nru src-old/mame/video/gticlub.c src/mame/video/gticlub.c
--- src-old/mame/video/gticlub.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/gticlub.c	2012-04-24 13:58:27.000000000 +0200
@@ -1,3 +1,4 @@
+#include <float.h>
 #include "emu.h"
 #include "cpu/sharc/sharc.h"
 #include "machine/konppc.h"
@@ -564,7 +565,7 @@
 		if (color & 0xff000000)
 		{
 			fb[x] = color;
-			zb[x] = 0x7fffffff;		// FIXME
+			zb[x] = FLT_MAX;		// FIXME
 		}
 	}
 }
@@ -609,7 +610,7 @@
 		if (color & 0xff000000)
 		{
 			fb[x] = color;
-			zb[x] = 0x7fffffff;		// FIXME
+			zb[x] = FLT_MAX;		// FIXME
 		}
 
 		u += du;
diff -Nru src-old/mame/video/hyprduel.c src/mame/video/hyprduel.c
--- src-old/mame/video/hyprduel.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/hyprduel.c	2012-05-03 11:00:08.000000000 +0200
@@ -472,7 +472,7 @@
 {
 	hyprduel_state *state = machine.driver_data<hyprduel_state>();
 	UINT8 *base_gfx4 = state->m_expanded_gfx1;
-	UINT8 *base_gfx8 = machine.root_device().memregion("gfx1")->base();
+	UINT8 *base_gfx8 = state->memregion("gfx1")->base();
 	UINT32 gfx_size = state->memregion("gfx1")->bytes();
 
 	int max_x = machine.primary_screen->width();
diff -Nru src-old/mame/video/itech32.c src/mame/video/itech32.c
--- src-old/mame/video/itech32.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/itech32.c	2012-05-03 11:00:08.000000000 +0200
@@ -184,7 +184,7 @@
 		state->m_videoplane[0][i] = state->m_videoplane[1][i] = 0xff;
 
 	/* fetch the GROM base */
-	state->m_grom_base = machine.root_device().memregion("gfx1")->base();
+	state->m_grom_base = state->memregion("gfx1")->base();
 	state->m_grom_size = state->memregion("gfx1")->bytes();
 	state->m_grom_bank = 0;
 	state->m_grom_bank_mask = state->m_grom_size >> 24;
diff -Nru src-old/mame/video/itech8.c src/mame/video/itech8.c
--- src-old/mame/video/itech8.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/itech8.c	2012-05-03 11:00:08.000000000 +0200
@@ -175,7 +175,7 @@
 	state->m_page_select = 0xc0;
 
 	/* fetch the GROM base */
-	state->m_grom_base = machine.root_device().memregion("grom")->base();
+	state->m_grom_base = state->memregion("grom")->base();
 	state->m_grom_size = state->memregion("grom")->bytes();
 }
 
@@ -461,7 +461,7 @@
 
 	/* a read from offsets 12-15 return input port values */
 	if (offset >= 12 && offset <= 15)
-		result = input_port_read_safe(machine(), portnames[offset - 12], 0x00);
+		result = ioport(portnames[offset - 12])->read_safe(0x00);
 
 	return result;
 }
diff -Nru src-old/mame/video/jaguar.c src/mame/video/jaguar.c
--- src-old/mame/video/jaguar.c	2012-02-06 03:30:22.000000000 +0100
+++ src/mame/video/jaguar.c	2012-05-03 11:00:08.000000000 +0200
@@ -239,8 +239,8 @@
 	int width = visarea.width();
 	int height = visarea.height();
 	/* only 2 lightguns are connected */
-	*x = visarea.min_x + (((input_port_read(machine, player ? "FAKE2_X" : "FAKE1_X") & 0xff) * width) >> 8);
-	*y = visarea.min_y + (((input_port_read(machine, player ? "FAKE2_Y" : "FAKE1_Y") & 0xff) * height) >> 8);
+	*x = visarea.min_x + (((machine.root_device().ioport(player ? "FAKE2_X" : "FAKE1_X")->read() & 0xff) * width) >> 8);
+	*y = visarea.min_y + (((machine.root_device().ioport(player ? "FAKE2_Y" : "FAKE1_Y")->read() & 0xff) * height) >> 8);
 }
 
 
@@ -805,7 +805,7 @@
 			return (beamy << 16) | (beamx ^ 0x1ff);
 
 		case 2:
-			return input_port_read(space->machine(), "IN3");
+			return space->machine().root_device().ioport("IN3")->read();
 	}
 	return 0;
 }
diff -Nru src-old/mame/video/kangaroo.c src/mame/video/kangaroo.c
--- src-old/mame/video/kangaroo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/kangaroo.c	2012-05-03 11:00:08.000000000 +0200
@@ -101,7 +101,7 @@
 static void blitter_execute( running_machine &machine )
 {
 	kangaroo_state *state = machine.driver_data<kangaroo_state>();
-	UINT32 gfxhalfsize = machine.root_device().memregion("gfx1")->bytes() / 2;
+	UINT32 gfxhalfsize = state->memregion("gfx1")->bytes() / 2;
 	const UINT8 *gfxbase = state->memregion("gfx1")->base();
 	UINT16 src = state->m_video_control[0] + 256 * state->m_video_control[1];
 	UINT16 dst = state->m_video_control[2] + 256 * state->m_video_control[3];
diff -Nru src-old/mame/video/lazercmd.c src/mame/video/lazercmd.c
--- src-old/mame/video/lazercmd.c	2012-01-12 23:19:49.000000000 +0100
+++ src/mame/video/lazercmd.c	2012-05-03 11:00:08.000000000 +0200
@@ -29,7 +29,7 @@
 	int xbit, ybit, size;
 
 	size = 2;
-	if (input_port_read(machine, "DSW") & 0x40)
+	if (machine.root_device().ioport("DSW")->read() & 0x40)
 	{
 		size = 4;
 	}
@@ -55,7 +55,7 @@
 	lazercmd_state *state = screen.machine().driver_data<lazercmd_state>();
 	int i, x, y;
 
-	int video_inverted = input_port_read(screen.machine(), "DSW") & 0x20;
+	int video_inverted = screen.machine().root_device().ioport("DSW")->read() & 0x20;
 
 	/* The first row of characters are invisible */
 	for (i = 0; i < (VERT_RES - 1) * HORZ_RES; i++)
diff -Nru src-old/mame/video/lethalj.c src/mame/video/lethalj.c
--- src-old/mame/video/lethalj.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/lethalj.c	2012-05-03 11:00:08.000000000 +0200
@@ -27,8 +27,8 @@
 	int width = visarea.width();
 	int height = visarea.height();
 
-	*x = ((input_port_read_safe(machine, gunnames[player * 2], 0x00) & 0xff) * width) / 255;
-	*y = ((input_port_read_safe(machine, gunnames[1 + player * 2], 0x00) & 0xff) * height) / 255;
+	*x = ((machine.root_device().ioport(gunnames[player * 2])->read_safe(0x00) & 0xff) * width) / 255;
+	*y = ((machine.root_device().ioport(gunnames[1 + player * 2])->read_safe(0x00) & 0xff) * height) / 255;
 }
 
 
@@ -82,7 +82,7 @@
 	state->m_screenram = auto_alloc_array(machine, UINT16, BLITTER_DEST_WIDTH * BLITTER_DEST_HEIGHT);
 
 	/* predetermine blitter info */
-	state->m_blitter_base = (UINT16 *)machine.root_device().memregion("gfx1")->base();
+	state->m_blitter_base = (UINT16 *)state->memregion("gfx1")->base();
 	state->m_blitter_rows = state->memregion("gfx1")->bytes() / (2*BLITTER_SOURCE_WIDTH);
 }
 
diff -Nru src-old/mame/video/lockon.c src/mame/video/lockon.c
--- src-old/mame/video/lockon.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/lockon.c	2012-05-02 14:10:49.000000000 +0200
@@ -440,7 +440,7 @@
 	const UINT8  *const gfxrom = state->memregion("gfx5")->base();
 	const UINT8  *const sproms = state->memregion("proms")->base() + 0x800;
 
-	for (offs = 0; offs < state->m_objectram_size; offs += 4)
+	for (offs = 0; offs < state->m_object_ram.bytes(); offs += 4)
 	{
 		UINT32 y;
 		UINT32 xpos;
@@ -802,7 +802,7 @@
 	UINT8	*tile_rom = state->memregion("gfx3")->base();
 	UINT32 offs;
 
-	for (offs = 0x0; offs <= state->m_hudram_size; offs += 2)
+	for (offs = 0x0; offs <= state->m_hud_ram.bytes(); offs += 2)
 	{
 		UINT32 y;
 		UINT32 y_pos;
diff -Nru src-old/mame/video/lordgun.c src/mame/video/lordgun.c
--- src-old/mame/video/lordgun.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/lordgun.c	2012-05-03 11:00:08.000000000 +0200
@@ -177,7 +177,7 @@
 
 static const char *const gunnames[] = { "LIGHT0_X", "LIGHT1_X", "LIGHT0_Y", "LIGHT1_Y" };
 
-float lordgun_crosshair_mapper(const input_field_config *field, float linear_value)
+float lordgun_crosshair_mapper(ioport_field *field, float linear_value)
 {
 	int x = linear_value - 0x3c;
 
@@ -190,15 +190,15 @@
 static void lorddgun_calc_gun_scr(running_machine &machine, int i)
 {
 	lordgun_state *state = machine.driver_data<lordgun_state>();
-//  popmessage("%03x, %02x", input_port_read(machine, "LIGHT0_X"), input_port_read(machine, "LIGHT0_Y"));
+//  popmessage("%03x, %02x", machine, "LIGHT0_X"), state->ioport("LIGHT0_Y")->read());
 
-	int x = input_port_read(machine, gunnames[i]) - 0x3c;
+	int x = state->ioport(gunnames[i])->read() - 0x3c;
 
 	if ( (x < 0) || (x > sizeof(lordgun_gun_x_table)/sizeof(lordgun_gun_x_table[0])) )
 		x = 0;
 
 	state->m_gun[i].scr_x = lordgun_gun_x_table[x];
-	state->m_gun[i].scr_y = input_port_read(machine, gunnames[i+2]);
+	state->m_gun[i].scr_y = state->ioport(gunnames[i+2])->read();
 }
 
 void lordgun_update_gun(running_machine &machine, int i)
@@ -206,8 +206,8 @@
 	lordgun_state *state = machine.driver_data<lordgun_state>();
 	const rectangle &visarea = machine.primary_screen->visible_area();
 
-	state->m_gun[i].hw_x = input_port_read(machine, gunnames[i]);
-	state->m_gun[i].hw_y = input_port_read(machine, gunnames[i+2]);
+	state->m_gun[i].hw_x = state->ioport(gunnames[i])->read();
+	state->m_gun[i].hw_y = state->ioport(gunnames[i+2])->read();
 
 	lorddgun_calc_gun_scr(machine, i);
 
diff -Nru src-old/mame/video/lwings.c src/mame/video/lwings.c
--- src-old/mame/video/lwings.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/lwings.c	2012-05-03 11:00:08.000000000 +0200
@@ -63,7 +63,7 @@
 {
 	lwings_state *state = machine.driver_data<lwings_state>();
 	int code, color;
-	UINT8 *rom = machine.root_device().memregion("gfx5")->base();
+	UINT8 *rom = state->memregion("gfx5")->base();
 	int mask = state->memregion("gfx5")->bytes() - 1;
 
 	tile_index = (tile_index + state->m_bg2_image * 0x20) & mask;
diff -Nru src-old/mame/video/m52.c src/mame/video/m52.c
--- src-old/mame/video/m52.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/m52.c	2012-05-03 11:00:08.000000000 +0200
@@ -276,7 +276,7 @@
 WRITE8_MEMBER(m52_state::m52_flipscreen_w)
 {
 	/* screen flip is handled both by software and hardware */
-	flip_screen_set((data & 0x01) ^ (~input_port_read(machine(), "DSW2") & 0x01));
+	flip_screen_set((data & 0x01) ^ (~ioport("DSW2")->read() & 0x01));
 
 	coin_counter_w(machine(), 0, data & 0x02);
 	coin_counter_w(machine(), 1, data & 0x20);
diff -Nru src-old/mame/video/m57.c src/mame/video/m57.c
--- src-old/mame/video/m57.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/m57.c	2012-05-03 11:00:08.000000000 +0200
@@ -162,7 +162,7 @@
 {
 
 	/* screen flip is handled both by software and hardware */
-	m_flipscreen = (data & 0x01) ^ (~input_port_read(machine(), "DSW2") & 0x01);
+	m_flipscreen = (data & 0x01) ^ (~ioport("DSW2")->read() & 0x01);
 	m_bg_tilemap->set_flip(m_flipscreen ? (TILEMAP_FLIPY | TILEMAP_FLIPX) : 0);
 
 	coin_counter_w(machine(), 0,data & 0x02);
diff -Nru src-old/mame/video/m58.c src/mame/video/m58.c
--- src-old/mame/video/m58.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/m58.c	2012-05-03 11:00:08.000000000 +0200
@@ -201,7 +201,7 @@
 WRITE8_MEMBER(m58_state::yard_flipscreen_w)
 {
 	/* screen flip is handled both by software and hardware */
-	flip_screen_set((data & 0x01) ^ (~input_port_read(machine(), "DSW2") & 0x01));
+	flip_screen_set((data & 0x01) ^ (~ioport("DSW2")->read() & 0x01));
 
 	coin_counter_w(machine(), 0, data & 0x02);
 	coin_counter_w(machine(), 1, data & 0x20);
diff -Nru src-old/mame/video/m62.c src/mame/video/m62.c
--- src-old/mame/video/m62.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/m62.c	2012-05-03 11:00:08.000000000 +0200
@@ -305,7 +305,7 @@
 WRITE8_MEMBER(m62_state::m62_flipscreen_w)
 {
 	/* screen flip is handled both by software and hardware */
-	data ^= ~input_port_read(machine(), "DSW2") & 1;
+	data ^= ~ioport("DSW2")->read() & 1;
 
 	m_flipscreen = data & 0x01;
 	if (m_flipscreen)
diff -Nru src-old/mame/video/m72.c src/mame/video/m72.c
--- src-old/mame/video/m72.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/m72.c	2012-05-03 11:00:08.000000000 +0200
@@ -365,7 +365,7 @@
 		coin_counter_w(machine(), 1,data & 0x02);
 
 		/* bit 2 is flip screen (handled both by software and hardware) */
-		flip_screen_set(((data & 0x04) >> 2) ^ ((~input_port_read(machine(), "DSW") >> 8) & 1));
+		flip_screen_set(((data & 0x04) >> 2) ^ ((~ioport("DSW")->read() >> 8) & 1));
 
 		/* bit 3 is display disable */
 		m_video_off = data & 0x08;
@@ -391,7 +391,7 @@
 		coin_counter_w(machine(), 1,data & 0x02);
 
 		/* bit 2 is flip screen (handled both by software and hardware) */
-		flip_screen_set(((data & 0x04) >> 2) ^ ((~input_port_read(machine(), "DSW") >> 8) & 1));
+		flip_screen_set(((data & 0x04) >> 2) ^ ((~ioport("DSW")->read() >> 8) & 1));
 
 		/* bit 3 is display disable */
 		m_video_off = data & 0x08;
diff -Nru src-old/mame/video/m92.c src/mame/video/m92.c
--- src-old/mame/video/m92.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/video/m92.c	2012-05-03 11:00:08.000000000 +0200
@@ -545,7 +545,7 @@
 
 	/* Flipscreen appears hardwired to the dipswitch - strange */
 	m92_state *state = screen.machine().driver_data<m92_state>();
-	if (input_port_read(screen.machine(), "DSW") & 0x100)
+	if (screen.machine().root_device().ioport("DSW")->read() & 0x100)
 		state->flip_screen_set(0);
 	else
 		state->flip_screen_set(1);
@@ -563,7 +563,7 @@
 
 	/* Flipscreen appears hardwired to the dipswitch - strange */
 	m92_state *state = screen.machine().driver_data<m92_state>();
-	if (input_port_read(screen.machine(), "DSW") & 0x100)
+	if (screen.machine().root_device().ioport("DSW")->read() & 0x100)
 		state->flip_screen_set(0);
 	else
 		state->flip_screen_set(1);
diff -Nru src-old/mame/video/madalien.c src/mame/video/madalien.c
--- src-old/mame/video/madalien.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/madalien.c	2012-05-03 11:00:08.000000000 +0200
@@ -253,7 +253,7 @@
 static SCREEN_UPDATE_IND16( madalien )
 {
 	madalien_state *state = screen.machine().driver_data<madalien_state>();
-	int flip = BIT(input_port_read(screen.machine(), "DSW"), 6) && BIT(*state->m_video_control, 0);
+	int flip = BIT(screen.machine().root_device().ioport("DSW")->read(), 6) && BIT(*state->m_video_control, 0);
 
 	// bits #0 and #1 define scrolling mode
 	//
diff -Nru src-old/mame/video/mario.c src/mame/video/mario.c
--- src-old/mame/video/mario.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/mario.c	2012-05-03 11:00:08.000000000 +0200
@@ -165,7 +165,7 @@
 	mario_state	*state = machine.driver_data<mario_state>();
 	int offs;
 
-	for (offs = 0;offs < state->m_spriteram_size;offs += 4)
+	for (offs = 0; offs < state->m_spriteram.bytes(); offs += 4)
 	{
 		if (state->m_spriteram[offs])
 		{
@@ -209,7 +209,7 @@
 	mario_state	*state = screen.machine().driver_data<mario_state>();
 	int t;
 
-	t = input_port_read(screen.machine(), "MONITOR");
+	t = screen.machine().root_device().ioport("MONITOR")->read();
 	if (t != state->m_monitor)
 	{
 		state->m_monitor = t;
diff -Nru src-old/mame/video/mcatadv.c src/mame/video/mcatadv.c
--- src-old/mame/video/mcatadv.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/mcatadv.c	2012-05-03 11:00:08.000000000 +0200
@@ -60,7 +60,7 @@
 
 	UINT16 *destline;
 	UINT8 *priline;
-	UINT8 *sprdata = machine.root_device().memregion("gfx1")->base();
+	UINT8 *sprdata = state->memregion("gfx1")->base();
 	int sprmask = state->memregion("gfx1")->bytes()-1;
 
 	int xstart, xend, xinc;
diff -Nru src-old/mame/video/mcd212.c src/mame/video/mcd212.c
--- src-old/mame/video/mcd212.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/mcd212.c	2012-05-03 11:00:08.000000000 +0200
@@ -1115,7 +1115,7 @@
 {
     running_machine &machine = mcd212->machine();
     int x = 0;
-    UINT8 debug_mode = input_port_read(machine, "DEBUG");
+    UINT8 debug_mode = machine.root_device().ioport("DEBUG")->read();
     UINT8 global_plane_a_disable = debug_mode & 1;
     UINT8 global_plane_b_disable = debug_mode & 2;
     UINT8 debug_backdrop_enable = debug_mode & 4;
diff -Nru src-old/mame/video/metro.c src/mame/video/metro.c
--- src-old/mame/video/metro.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/metro.c	2012-05-03 11:00:08.000000000 +0200
@@ -446,7 +446,7 @@
 {
 	metro_state *state = machine.driver_data<metro_state>();
 	UINT8 *base_gfx4 = state->m_expanded_gfx1;
-	UINT8 *base_gfx8 = machine.root_device().memregion("gfx1")->base();
+	UINT8 *base_gfx8 = state->memregion("gfx1")->base();
 	UINT32 gfx_size = state->memregion("gfx1")->bytes();
 	const rectangle &visarea = machine.primary_screen->visible_area();
 
diff -Nru src-old/mame/video/model2.c src/mame/video/model2.c
--- src-old/mame/video/model2.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/model2.c	2012-05-03 11:00:08.000000000 +0200
@@ -2713,7 +2713,7 @@
 	machine.add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(model2_exit), &machine));
 
 	/* initialize the hardware rasterizer */
-	model2_3d_init( machine, (UINT16*)machine.root_device().memregion("user3")->base() );
+	model2_3d_init( machine, (UINT16*)state->memregion("user3")->base() );
 
 	/* initialize the geometry engine */
 	geo_init( machine, (UINT32*)state->memregion("user2")->base() );
diff -Nru src-old/mame/video/momoko.c src/mame/video/momoko.c
--- src-old/mame/video/momoko.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/momoko.c	2012-05-03 11:00:08.000000000 +0200
@@ -113,7 +113,7 @@
 	UINT8 *TEXT_COLOR = state->memregion("proms")->base();
 
 
-	flip = state->m_flipscreen ^ (input_port_read(screen.machine(), "FAKE") & 0x01);
+	flip = state->m_flipscreen ^ (screen.machine().root_device().ioport("FAKE")->read() & 0x01);
 
 	/* draw BG layer */
 	dx = (7 - state->m_bg_scrollx[0]) & 7;
diff -Nru src-old/mame/video/mystston.c src/mame/video/mystston.c
--- src-old/mame/video/mystston.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/mystston.c	2012-05-03 11:00:08.000000000 +0200
@@ -257,7 +257,7 @@
 {
 	mystston_state *state = screen.machine().driver_data<mystston_state>();
 
-	int flip = (*state->m_video_control & 0x80) ^ ((input_port_read(screen.machine(), "DSW1") & 0x20) << 2);
+	int flip = (*state->m_video_control & 0x80) ^ ((screen.machine().root_device().ioport("DSW1")->read() & 0x20) << 2);
 
 	set_palette(screen.machine(), state);
 
diff -Nru src-old/mame/video/n8080.c src/mame/video/n8080.c
--- src-old/mame/video/n8080.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/n8080.c	2012-05-03 11:00:08.000000000 +0200
@@ -254,8 +254,8 @@
 SCREEN_UPDATE_IND16( helifire )
 {
 	n8080_state *state = screen.machine().driver_data<n8080_state>();
-	int SUN_BRIGHTNESS = input_port_read(screen.machine(), "POT0");
-	int SEA_BRIGHTNESS = input_port_read(screen.machine(), "POT1");
+	int SUN_BRIGHTNESS = screen.machine().root_device().ioport("POT0")->read();
+	int SEA_BRIGHTNESS = screen.machine().root_device().ioport("POT1")->read();
 
 	static const int wave[8] = { 0, 1, 2, 2, 2, 1, 0, 0 };
 
diff -Nru src-old/mame/video/namcos22.c src/mame/video/namcos22.c
--- src-old/mame/video/namcos22.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/namcos22.c	2012-05-03 11:00:08.000000000 +0200
@@ -2741,9 +2741,9 @@
 	for (code = 0; code < machine.gfx[GFX_TEXTURE_TILE]->total_elements; code++)
 		gfx_element_decode(machine.gfx[GFX_TEXTURE_TILE], code);
 
-	Prepare3dTexture(machine, machine.root_device().memregion("textilemap")->base(), machine.gfx[GFX_TEXTURE_TILE]->gfxdata );
+	Prepare3dTexture(machine, state->memregion("textilemap")->base(), machine.gfx[GFX_TEXTURE_TILE]->gfxdata );
 	state->m_dirtypal = auto_alloc_array(machine, UINT8, NAMCOS22_PALETTE_SIZE/4);
-	state->m_mPtRomSize = machine.root_device().memregion("pointrom")->bytes()/3;
+	state->m_mPtRomSize = state->memregion("pointrom")->bytes()/3;
 	state->m_mpPolyL = state->memregion("pointrom")->base();
 	state->m_mpPolyM = state->m_mpPolyL + state->m_mPtRomSize;
 	state->m_mpPolyH = state->m_mpPolyM + state->m_mPtRomSize;
diff -Nru src-old/mame/video/naughtyb.c src/mame/video/naughtyb.c
--- src-old/mame/video/naughtyb.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/naughtyb.c	2012-05-03 11:00:08.000000000 +0200
@@ -117,7 +117,7 @@
 	pleiads_sound_control_c_w(machine().device("cust"),offset,data);
 
 	m_cocktail =
-		( ( input_port_read(machine(), "DSW0") & 0x80 ) &&	// cabinet == cocktail
+		( ( ioport("DSW0")->read() & 0x80 ) &&	// cabinet == cocktail
 		  ( data & 0x01 ) );				// handling player 2
 	m_palreg  = (data >> 1) & 0x03;			// palette sel is bit 1 & 2
 	m_bankreg = (data >> 2) & 0x01;			// banksel is just bit 2
@@ -129,7 +129,7 @@
 	pleiads_sound_control_c_w(machine().device("cust"),offset,data);
 
 	m_cocktail =
-		( ( input_port_read(machine(), "DSW0") & 0x80 ) &&	// cabinet == cocktail
+		( ( ioport("DSW0")->read() & 0x80 ) &&	// cabinet == cocktail
 		  ( data & 0x01 ) );				// handling player 2
 	m_palreg  = (data >> 1) & 0x03;			// palette sel is bit 1 & 2
 	m_bankreg = (data >> 3) & 0x01;			// banksel is just bit 3
diff -Nru src-old/mame/video/neogeo.c src/mame/video/neogeo.c
--- src-old/mame/video/neogeo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/neogeo.c	2012-05-03 11:00:08.000000000 +0200
@@ -271,7 +271,7 @@
 	neogeo_state *state = machine.driver_data<neogeo_state>();
 	int x;
 
-	UINT8* gfx_base = machine.root_device().memregion(state->m_fixed_layer_source ? "fixed" : "fixedbios")->base();
+	UINT8* gfx_base = state->memregion(state->m_fixed_layer_source ? "fixed" : "fixedbios")->base();
 	UINT32 addr_mask = state->memregion(state->m_fixed_layer_source ? "fixed" : "fixedbios")->bytes() - 1;
 	UINT16 *video_data = &state->m_videoram[0x7000 | (scanline >> 3)];
 	UINT32 *pixel_addr = &bitmap.pix32(scanline, NEOGEO_HBEND);
diff -Nru src-old/mame/video/niyanpai.c src/mame/video/niyanpai.c
--- src-old/mame/video/niyanpai.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/niyanpai.c	2012-05-01 00:02:17.000000000 +0200
@@ -330,7 +330,7 @@
 	}
 
 	state->m_nb19010_busyflag = 0;
-	machine.scheduler().timer_set(attotime::from_nsec(1650 * state->m_nb19010_busyctr), FUNC(blitter_timer_callback));
+	machine.scheduler().timer_set(attotime::from_nsec(1000 * state->m_nb19010_busyctr), FUNC(blitter_timer_callback));
 }
 
 /******************************************************************************
diff -Nru src-old/mame/video/nmk16.c src/mame/video/nmk16.c
--- src-old/mame/video/nmk16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/nmk16.c	2012-05-03 11:00:08.000000000 +0200
@@ -979,8 +979,8 @@
 	if (dsw_flipscreen)
 	{
 
-		state->flip_screen_x_set(~input_port_read(machine, "DSW1") & 0x0100);
-		state->flip_screen_y_set(~input_port_read(machine, "DSW1") & 0x0200);
+		state->flip_screen_x_set(~state->ioport("DSW1")->read() & 0x0100);
+		state->flip_screen_y_set(~state->ioport("DSW1")->read() & 0x0200);
 	}
 
 
diff -Nru src-old/mame/video/nycaptor.c src/mame/video/nycaptor.c
--- src-old/mame/video/nycaptor.c	2012-04-09 19:30:29.000000000 +0200
+++ src/mame/video/nycaptor.c	2012-04-22 17:13:29.000000000 +0200
@@ -23,6 +23,8 @@
 		return state->m_sharedram[0x299] ? state->m_sharedram[0x298] : 0;
 	else
 		return 0;
+
+    return 0;
 }
 
 WRITE8_MEMBER(nycaptor_state::nycaptor_spriteram_w)
@@ -263,7 +265,7 @@
 		draw_sprites(screen.machine(), bitmap, cliprect, 7);
 	}
 	else
-	#endif
+#endif
 	switch (nycaptor_spot(screen.machine()) & 3)
 	{
 	case 0:
diff -Nru src-old/mame/video/oneshot.c src/mame/video/oneshot.c
--- src-old/mame/video/oneshot.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/oneshot.c	2012-05-03 11:00:08.000000000 +0200
@@ -69,8 +69,8 @@
 	//int xpos,ypos;
 
 	/* get gun raw coordinates (player 1) */
-	state->m_gun_x_p1 = (input_port_read(machine, "LIGHT0_X") & 0xff) * 320 / 256;
-	state->m_gun_y_p1 = (input_port_read(machine, "LIGHT0_Y") & 0xff) * 240 / 256;
+	state->m_gun_x_p1 = (state->ioport("LIGHT0_X")->read() & 0xff) * 320 / 256;
+	state->m_gun_y_p1 = (state->ioport("LIGHT0_Y")->read() & 0xff) * 240 / 256;
 
 	/* compute the coordinates for drawing (from routine at 0x009ab0) */
 	//xpos = state->m_gun_x_p1;
@@ -84,8 +84,8 @@
 
 
 	/* get gun raw coordinates (player 2) */
-	state->m_gun_x_p2 = (input_port_read(machine, "LIGHT1_X") & 0xff) * 320 / 256;
-	state->m_gun_y_p2 = (input_port_read(machine, "LIGHT1_Y") & 0xff) * 240 / 256;
+	state->m_gun_x_p2 = (state->ioport("LIGHT1_X")->read() & 0xff) * 320 / 256;
+	state->m_gun_y_p2 = (state->ioport("LIGHT1_Y")->read() & 0xff) * 240 / 256;
 
 	/* compute the coordinates for drawing (from routine at 0x009b6e) */
 	//xpos = state->m_gun_x_p2;
diff -Nru src-old/mame/video/opwolf.c src/mame/video/opwolf.c
--- src-old/mame/video/opwolf.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/opwolf.c	2012-05-03 11:00:08.000000000 +0200
@@ -52,8 +52,8 @@
 
 	pc090oj_draw_sprites(state->m_pc090oj, bitmap, cliprect, 1);
 
-//  if (input_port_read(machine, "P1X"))
-//  popmessage("%d %d", input_port_read(machine, "P1X"), input_port_read(machine, "P1Y"));
+//  if (state->ioport("P1X")->read())
+//  popmessage("%d %d", machine, "P1X"), state->ioport("P1Y")->read());
 
 	return 0;
 }
diff -Nru src-old/mame/video/orbit.c src/mame/video/orbit.c
--- src-old/mame/video/orbit.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/orbit.c	2012-05-03 11:00:08.000000000 +0200
@@ -82,7 +82,7 @@
 {
 	orbit_state *state = screen.machine().driver_data<orbit_state>();
 
-	state->m_flip_screen = input_port_read(screen.machine(), "DSW2") & 8;
+	state->m_flip_screen = screen.machine().root_device().ioport("DSW2")->read() & 8;
 
 	state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
 
diff -Nru src-old/mame/video/pgm.c src/mame/video/pgm.c
--- src-old/mame/video/pgm.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/pgm.c	2012-05-03 11:00:08.000000000 +0200
@@ -620,7 +620,7 @@
 	pgm_state *state = machine.driver_data<pgm_state>();
 	int i;
 
-	state->m_bdata = machine.root_device().memregion("sprmask")->base();
+	state->m_bdata = state->memregion("sprmask")->base();
 	state->m_bdatasize = state->memregion("sprmask")->bytes() - 1;
 	state->m_aoffset = 0;
 	state->m_boffset = 0;
diff -Nru src-old/mame/video/phoenix.c src/mame/video/phoenix.c
--- src-old/mame/video/phoenix.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/phoenix.c	2012-05-03 11:00:08.000000000 +0200
@@ -251,7 +251,7 @@
 		m_videoram_pg_index = data & 1;
 		membank("bank1")->set_entry(m_videoram_pg_index);
 
-		m_cocktail_mode = m_videoram_pg_index && (input_port_read(machine(), "CAB") & 0x01);
+		m_cocktail_mode = m_videoram_pg_index && (ioport("CAB")->read() & 0x01);
 
 		machine().tilemap().set_flip_all(m_cocktail_mode ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
 		machine().tilemap().mark_all_dirty();
@@ -274,7 +274,7 @@
 		m_videoram_pg_index = data & 1;
 		membank("bank1")->set_entry(m_videoram_pg_index);
 
-		m_cocktail_mode = m_videoram_pg_index && (input_port_read(machine(), "CAB") & 0x01);
+		m_cocktail_mode = m_videoram_pg_index && (ioport("CAB")->read() & 0x01);
 
 		machine().tilemap().set_flip_all(m_cocktail_mode ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
 		machine().tilemap().mark_all_dirty();
@@ -310,9 +310,9 @@
 CUSTOM_INPUT_MEMBER(phoenix_state::player_input_r)
 {
 	if (m_cocktail_mode)
-		return (input_port_read(machine(), "CTRL") & 0xf0) >> 4;
+		return (ioport("CTRL")->read() & 0xf0) >> 4;
 	else
-		return (input_port_read(machine(), "CTRL") & 0x0f) >> 0;
+		return (ioport("CTRL")->read() & 0x0f) >> 0;
 }
 
 CUSTOM_INPUT_MEMBER(phoenix_state::pleiads_protection_r)
@@ -365,7 +365,7 @@
 #define REMAP_JS(js) ((ret & 0xf) | ( (js & 0xf)  << 4))
 READ8_MEMBER(phoenix_state::survival_input_port_0_r)
 {
-	UINT8 ret = ~input_port_read(machine(), "IN0");
+	UINT8 ret = ~ioport("IN0")->read();
 
 	if( m_survival_input_readc++ == 2 )
 	{
diff -Nru src-old/mame/video/policetr.c src/mame/video/policetr.c
--- src-old/mame/video/policetr.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/policetr.c	2012-05-03 11:00:08.000000000 +0200
@@ -26,7 +26,7 @@
 {
 	policetr_state *state = machine.driver_data<policetr_state>();
 	/* the source bitmap is in ROM */
-	state->m_srcbitmap = machine.root_device().memregion("gfx1")->base();
+	state->m_srcbitmap = state->memregion("gfx1")->base();
 
 	/* compute the height */
 	state->m_srcbitmap_height_mask = (state->memregion("gfx1")->bytes() / SRCBITMAP_WIDTH) - 1;
@@ -267,25 +267,25 @@
 	{
 		/* latch 0x00 is player 1's gun X coordinate */
 		case 0x00:
-			inputval = ((input_port_read(machine(), "GUNX1") & 0xff) * width) >> 8;
+			inputval = ((ioport("GUNX1")->read() & 0xff) * width) >> 8;
 			inputval += 0x50;
 			return (inputval << 20) | 0x20000000;
 
 		/* latch 0x01 is player 1's gun Y coordinate */
 		case 0x01:
-			inputval = ((input_port_read(machine(), "GUNY1") & 0xff) * height) >> 8;
+			inputval = ((ioport("GUNY1")->read() & 0xff) * height) >> 8;
 			inputval += 0x17;
 			return (inputval << 20);
 
 		/* latch 0x02 is player 2's gun X coordinate */
 		case 0x02:
-			inputval = ((input_port_read(machine(), "GUNX2") & 0xff) * width) >> 8;
+			inputval = ((ioport("GUNX2")->read() & 0xff) * width) >> 8;
 			inputval += 0x50;
 			return (inputval << 20) | 0x20000000;
 
 		/* latch 0x03 is player 2's gun Y coordinate */
 		case 0x03:
-			inputval = ((input_port_read(machine(), "GUNY2") & 0xff) * height) >> 8;
+			inputval = ((ioport("GUNY2")->read() & 0xff) * height) >> 8;
 			inputval += 0x17;
 			return (inputval << 20);
 
diff -Nru src-old/mame/video/prehisle.c src/mame/video/prehisle.c
--- src-old/mame/video/prehisle.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/prehisle.c	2012-05-03 11:00:08.000000000 +0200
@@ -29,11 +29,11 @@
 
 	switch (offset)
 	{
-	case 0x08: return input_port_read(machine(), "P2");						// Player 2
-	case 0x10: return input_port_read(machine(), "COIN");						// Coins, Tilt, Service
-	case 0x20: return input_port_read(machine(), "P1") ^ m_invert_controls;		// Player 1
-	case 0x21: return input_port_read(machine(), "DSW0");						// DIPs
-	case 0x22: return input_port_read(machine(), "DSW1");						// DIPs + VBLANK
+	case 0x08: return ioport("P2")->read();						// Player 2
+	case 0x10: return ioport("COIN")->read();						// Coins, Tilt, Service
+	case 0x20: return ioport("P1")->read() ^ m_invert_controls;		// Player 1
+	case 0x21: return ioport("DSW0")->read();						// DIPs
+	case 0x22: return ioport("DSW1")->read();						// DIPs + VBLANK
 	default: return 0;
 	}
 }
diff -Nru src-old/mame/video/psikyo.c src/mame/video/psikyo.c
--- src-old/mame/video/psikyo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/psikyo.c	2012-05-03 11:00:08.000000000 +0200
@@ -533,7 +533,7 @@
 
 	tilemap_t *tmptilemap0, *tmptilemap1;
 
-	state->flip_screen_set(~input_port_read(screen.machine(), "DSW") & 0x00010000);		// hardwired to a DSW bit
+	state->flip_screen_set(~screen.machine().root_device().ioport("DSW")->read() & 0x00010000);		// hardwired to a DSW bit
 
 	/* Layers enable (not quite right) */
 
@@ -707,7 +707,7 @@
 
 	tilemap_t *tmptilemap0, *tmptilemap1;
 
-	state->flip_screen_set(~input_port_read(screen.machine(), "DSW") & 0x00010000);		// hardwired to a DSW bit
+	state->flip_screen_set(~screen.machine().root_device().ioport("DSW")->read() & 0x00010000);		// hardwired to a DSW bit
 
 	/* Layers enable (not quite right) */
 
diff -Nru src-old/mame/video/psychic5.c src/mame/video/psychic5.c
--- src-old/mame/video/psychic5.c	2012-04-15 07:44:22.000000000 +0200
+++ src/mame/video/psychic5.c	2012-05-03 11:00:08.000000000 +0200
@@ -110,11 +110,11 @@
 	{
 		switch (offset)
 		{
-			case 0x00: return input_port_read(machine(), "SYSTEM");
-			case 0x01: return input_port_read(machine(), "P1");
-			case 0x02: return input_port_read(machine(), "P2");
-			case 0x03: return input_port_read(machine(), "DSW1");
-			case 0x04: return input_port_read(machine(), "DSW2");
+			case 0x00: return ioport("SYSTEM")->read();
+			case 0x01: return ioport("P1")->read();
+			case 0x02: return ioport("P2")->read();
+			case 0x03: return ioport("DSW1")->read();
+			case 0x04: return ioport("DSW2")->read();
 		}
 	}
 
diff -Nru src-old/mame/video/rdptpipe.c src/mame/video/rdptpipe.c
--- src-old/mame/video/rdptpipe.c	2012-02-19 13:21:36.000000000 +0100
+++ src/mame/video/rdptpipe.c	2012-04-24 13:58:27.000000000 +0200
@@ -1372,7 +1372,7 @@
 	tbase += tile[tilenum].tmem;
 	UINT32 tpal	= tile[tilenum].palette;
 
-	UINT32 index = (tformat << 4) | (tsize << 2) | (object.OtherModes.en_tlut << 1) | object.OtherModes.tlut_type;
+	UINT32 index = (tformat << 4) | (tsize << 2) | ((UINT32) object.OtherModes.en_tlut << 1) | (UINT32) object.OtherModes.tlut_type;
 
 	return ((this)->*(TexelFetch[index]))(s, t, tbase, tpal, userdata);
 }
diff -Nru src-old/mame/video/route16.c src/mame/video/route16.c
--- src-old/mame/video/route16.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/route16.c	2012-05-03 11:00:08.000000000 +0200
@@ -130,7 +130,7 @@
 	route16_state *state = machine.driver_data<route16_state>();
 	offs_t offs;
 
-	UINT8 *color_prom1 = &machine.root_device().memregion("proms")->base()[0x000];
+	UINT8 *color_prom1 = &state->memregion("proms")->base()[0x000];
 	UINT8 *color_prom2 = &state->memregion("proms")->base()[0x100];
 
 	for (offs = 0; offs < state->m_videoram1.bytes(); offs++)
diff -Nru src-old/mame/video/shisen.c src/mame/video/shisen.c
--- src-old/mame/video/shisen.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/shisen.c	2012-05-03 11:00:08.000000000 +0200
@@ -66,7 +66,7 @@
 	// on Irem boards, screen flip is handled in both hardware and software.
 	// this game doesn't have cocktail mode so if there's software control we don't
 	// know where it is mapped.
-	state->flip_screen_set(~input_port_read(screen.machine(), "DSW2") & 1);
+	state->flip_screen_set(~screen.machine().root_device().ioport("DSW2")->read() & 1);
 
 
 	state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
diff -Nru src-old/mame/video/snes.c src/mame/video/snes.c
--- src-old/mame/video/snes.c	2012-02-06 03:30:22.000000000 +0100
+++ src/mame/video/snes.c	2012-05-03 11:00:08.000000000 +0200
@@ -1505,7 +1505,7 @@
 	struct SCANLINE *scanline1, *scanline2;
 	UINT16 c;
 	UINT16 prev_colour = 0;
-	int blurring = input_port_read_safe(machine, "OPTIONS", 0) & 0x01;
+	int blurring = machine.root_device().ioport("OPTIONS")->read_safe(0) & 0x01;
 
 	g_profiler.start(PROFILER_VIDEO);
 
@@ -2661,13 +2661,13 @@
 static UINT8 snes_dbg_video( running_machine &machine, UINT16 curline )
 {
 	int i;
-	UINT8 toggles = input_port_read_safe(machine, "DEBUG1", 0);
+	UINT8 toggles = machine.root_device().ioport("DEBUG1")->read_safe(0);
 	debug_options.select_pri[SNES_BG1] = (toggles & 0x03);
 	debug_options.select_pri[SNES_BG2] = (toggles & 0x0c) >> 2;
 	debug_options.select_pri[SNES_BG3] = (toggles & 0x30) >> 4;
 	debug_options.select_pri[SNES_BG4] = (toggles & 0xc0) >> 6;
 
-	toggles = input_port_read_safe(machine, "DEBUG2", 0);
+	toggles = machine.root_device().ioport("DEBUG2")->read_safe(0);
 	for (i = 0; i < 4; i++)
 		DEBUG_TOGGLE(i, debug_options.bg_disabled[i], ("Debug: Disabled BG%d.\n", i + 1), ("Debug: Enabled BG%d.\n", i + 1))
 	DEBUG_TOGGLE(4, debug_options.bg_disabled[SNES_OAM], ("Debug: Disabled OAM.\n"), ("Debug: Enabled OAM.\n"))
@@ -2675,11 +2675,11 @@
 	DEBUG_TOGGLE(6, debug_options.colormath_disabled, ("Debug: Disabled Color Math.\n"), ("Debug: Enabled Color Math.\n"))
 	DEBUG_TOGGLE(7, debug_options.windows_disabled, ("Debug: Disabled Window Masks.\n"), ("Debug: Enabled Window Masks.\n"))
 
-	toggles = input_port_read_safe(machine, "DEBUG4", 0);
+	toggles = machine.root_device().ioport("DEBUG4")->read_safe(0);
 	for (i = 0; i < 8; i++)
 		DEBUG_TOGGLE(i, debug_options.mode_disabled[i], ("Debug: Disabled Mode %d drawing.\n", i), ("Debug: Enabled Mode %d drawing.\n", i))
 
-	toggles = input_port_read_safe(machine, "DEBUG3", 0);
+	toggles = machine.root_device().ioport("DEBUG3")->read_safe(0);
 	DEBUG_TOGGLE(2, debug_options.mosaic_disabled, ("Debug: Disabled Mosaic.\n"), ("Debug: Enabled Mosaic.\n"))
 	debug_options.sprite_reversed = BIT(toggles, 7);
 	debug_options.select_pri[SNES_OAM] = (toggles & 0x70) >> 4;
diff -Nru src-old/mame/video/system1.c src/mame/video/system1.c
--- src-old/mame/video/system1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/system1.c	2012-05-03 11:00:08.000000000 +0200
@@ -363,7 +363,7 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int xoffset)
 {
 	system1_state *state = machine.driver_data<system1_state>();
-	UINT32 gfxbanks = machine.root_device().memregion("sprites")->bytes() / 0x8000;
+	UINT32 gfxbanks = state->memregion("sprites")->bytes() / 0x8000;
 	const UINT8 *gfxbase = state->memregion("sprites")->base();
 	UINT8 *spriteram = state->m_spriteram;
 	int flipscreen = state->flip_screen();
diff -Nru src-old/mame/video/thepit.c src/mame/video/thepit.c
--- src-old/mame/video/thepit.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/thepit.c	2012-05-03 11:00:08.000000000 +0200
@@ -210,11 +210,11 @@
        horizontal flip switch. (This is how the real PCB does it) */
 	if (m_flip_screen_x)
 	{
-		return input_port_read(machine(), "IN2");
+		return ioport("IN2")->read();
 	}
 	else
 	{
-		return input_port_read(machine(), "IN0");
+		return ioport("IN0")->read();
 	}
 }
 
diff -Nru src-old/mame/video/tmnt.c src/mame/video/tmnt.c
--- src-old/mame/video/tmnt.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/tmnt.c	2012-05-03 11:00:08.000000000 +0200
@@ -466,7 +466,7 @@
 		/* bit 0 is data */
 		/* bit 1 is cs (active low) */
 		/* bit 2 is clock (active high) */
-		input_port_write(machine(), "EEPROMOUT", data, 0xff);
+		ioport("EEPROMOUT")->write(data, 0xff);
 
 		/* bits 3-4 control palette dimming */
 		/* 4 = DIMPOL = when set, negate SHAD */
diff -Nru src-old/mame/video/travrusa.c src/mame/video/travrusa.c
--- src-old/mame/video/travrusa.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/travrusa.c	2012-05-03 11:00:08.000000000 +0200
@@ -276,7 +276,7 @@
 WRITE8_MEMBER(travrusa_state::travrusa_flipscreen_w)
 {
 	/* screen flip is handled both by software and hardware */
-	data ^= ~input_port_read(machine(), "DSW2") & 1;
+	data ^= ~ioport("DSW2")->read() & 1;
 
 	flip_screen_set(data & 1);
 
diff -Nru src-old/mame/video/turbo.c src/mame/video/turbo.c
--- src-old/mame/video/turbo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/turbo.c	2012-05-07 08:57:50.000000000 +0200
@@ -341,7 +341,7 @@
                     VR1 = 310 Ohm
                     VR2 = 910 Ohm
             */
-			info->step[level] = sprite_xscale(xscale, 1.0e3 * input_port_read(machine, "VR1") / 100.0, 1.0e3 * input_port_read(machine, "VR2") / 100.0, 100e-12);
+			info->step[level] = sprite_xscale(xscale, 1.0e3 * machine.root_device().ioport("VR1")->read() / 100.0, 1.0e3 * machine.root_device().ioport("VR2")->read() / 100.0, 100e-12);
 		}
 	}
 }
diff -Nru src-old/mame/video/tx1.c src/mame/video/tx1.c
--- src-old/mame/video/tx1.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/tx1.c	2012-05-03 11:00:08.000000000 +0200
@@ -416,7 +416,7 @@
 	UINT8	pix[2][4][3];
 
 	/* Road slice map ROMs */
-	const UINT8 *const gfx3 = machine.root_device().memregion("gfx3")->base();
+	const UINT8 *const gfx3 = state->memregion("gfx3")->base();
 	const UINT8 *const rom_a = gfx3;
 	const UINT8 *const rom_b = gfx3 + 0x2000;
 	const UINT8 *const rom_c = gfx3 + 0x4000;
@@ -859,15 +859,15 @@
 	UINT32 offs;
 
 	/* The many lookup table ROMs */
-	const UINT8 *const ic48 = machine.root_device().memregion("user3")->base();
+	const UINT8 *const ic48 = state->memregion("user3")->base();
 	const UINT8 *const ic281 = ic48 + 0x2000;
 
-	const UINT8 *const proms = machine.root_device().memregion("proms")->base();
+	const UINT8 *const proms = state->memregion("proms")->base();
 	const UINT8 *const ic190 = proms + 0xc00;
 	const UINT8 *const ic162 = proms + 0xe00;
 	const UINT8 *const ic25  = proms + 0x1000;
 
-	const UINT8 *const ic106 = machine.root_device().memregion("obj_map")->base();
+	const UINT8 *const ic106 = state->memregion("obj_map")->base();
 	const UINT8 *const ic73  = ic106 + 0x4000;
 
 	const UINT8 *const pixdata_rgn = state->memregion("obj_tiles")->base();
@@ -1300,7 +1300,7 @@
 	UINT32 x_mask;
 
 	/* 2bpp characters */
-	chars = machine.root_device().memregion("char_tiles")->base();
+	chars = state->memregion("char_tiles")->base();
 	gfx2 = state->memregion("char_tiles")->base() + 0x4000;
 
 	/* X/Y scroll values are the last word in char RAM */
@@ -1535,7 +1535,7 @@
 	UINT32 rva20_6;
 
 	/* ROM/PROM lookup tables */
-	const UINT8 *rcols = (UINT8*)(machine.root_device().memregion("proms")->base() + 0x1500);
+	const UINT8 *rcols = (UINT8*)(state->memregion("proms")->base() + 0x1500);
 	const UINT8 *rom   = state->memregion("road")->base();
 	const UINT8 *prom0 = rom + 0x4000;
 	const UINT8 *prom1 = rom + 0x4200;
@@ -2167,7 +2167,7 @@
 	UINT32 rva20_6;
 
 	/* ROM/PROM lookup tables */
-	const UINT8 *rcols = (UINT8*)(machine.root_device().memregion("proms")->base() + 0x1500);
+	const UINT8 *rcols = (UINT8*)(state->memregion("proms")->base() + 0x1500);
 	const UINT8 *rom   = state->memregion("road")->base();
 	const UINT8 *prom0 = rom + 0x4000;
 	const UINT8 *prom1 = rom + 0x4200;
@@ -2580,14 +2580,14 @@
 	UINT32 x_stride;
 
 	/* The many lookup table ROMs */
-	const UINT8 *const bug13  = (UINT8*)machine.root_device().memregion("obj_luts")->base();
+	const UINT8 *const bug13  = (UINT8*)state->memregion("obj_luts")->base();
 	const UINT8 *const bug18s = bug13 + 0x2000;
-	const UINT8 *const bb8    = (UINT8*)machine.root_device().memregion("proms")->base() + 0x1600;
+	const UINT8 *const bb8    = (UINT8*)state->memregion("proms")->base() + 0x1600;
 
-	const UINT8 *const bug16s = (UINT8*)machine.root_device().memregion("obj_map")->base();
+	const UINT8 *const bug16s = (UINT8*)state->memregion("obj_map")->base();
 	const UINT8 *const bug17s = bug16s + 0x8000;
 
-	const UINT8 *const bb9o = (UINT8*)machine.root_device().memregion("proms")->base() + 0x500;
+	const UINT8 *const bb9o = (UINT8*)state->memregion("proms")->base() + 0x500;
 	const UINT8 *const bb9e = bb9o + 0x800;
 
 	const UINT8 *const pixdata_rgn = (UINT8*)state->memregion("obj_tiles")->base();
diff -Nru src-old/mame/video/undrfire.c src/mame/video/undrfire.c
--- src-old/mame/video/undrfire.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/undrfire.c	2012-05-03 11:00:08.000000000 +0200
@@ -212,7 +212,7 @@
 {
 	undrfire_state *state = machine.driver_data<undrfire_state>();
 	UINT32 *spriteram32 = state->m_spriteram;
-	UINT16 *spritemap = (UINT16 *)machine.root_device().memregion("user1")->base();
+	UINT16 *spritemap = (UINT16 *)state->memregion("user1")->base();
 	UINT8 *spritemapHibit = (UINT8 *)state->memregion("user2")->base();
 
 	int offs, data, tilenum, color, flipx, flipy;
@@ -468,7 +468,7 @@
 	/* See if we should draw artificial gun targets */
 	/* (not yet implemented...) */
 
-	if (input_port_read(screen.machine(), "FAKE") & 0x1)	/* Fake DSW */
+	if (screen.machine().root_device().ioport("FAKE")->read() & 0x1)	/* Fake DSW */
 	{
 		popmessage("Gunsights on");
 	}
diff -Nru src-old/mame/video/vectrex.c src/mame/video/vectrex.c
--- src-old/mame/video/vectrex.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/vectrex.c	2012-05-03 20:17:43.000000000 +0200
@@ -386,6 +386,14 @@
 		}
 	}
 
+	/* Cartridge bank-switching */
+	if (state->m_64k_cart && ((data ^ state->m_via_out[PORTB]) & 0x40))
+	{
+		device_t &root_device = device->machine().root_device();
+
+		root_device.membank("bank1")->set_base(root_device.memregion("maincpu")->base() + ((data & 0x40) ? 0x10000 : 0x0000));
+	}
+
 	/* Sound */
 	if (data & 0x10)
 	{
@@ -435,12 +443,12 @@
 		/* Check lightpen */
 		if (state->m_lightpen_port != 0)
 		{
-			state->m_lightpen_down = input_port_read(device->machine(), "LPENCONF") & 0x10;
+			state->m_lightpen_down = state->ioport("LPENCONF")->read() & 0x10;
 
 			if (state->m_lightpen_down)
 			{
-				state->m_pen_x = input_port_read(device->machine(), "LPENX") * (state->m_x_max / 0xff);
-				state->m_pen_y = input_port_read(device->machine(), "LPENY") * (state->m_y_max / 0xff);
+				state->m_pen_x = state->ioport("LPENX")->read() * (state->m_x_max / 0xff);
+				state->m_pen_y = state->ioport("LPENY")->read() * (state->m_y_max / 0xff);
 
 				dx = abs(state->m_pen_x - state->m_x_int);
 				dy = abs(state->m_pen_y - state->m_y_int);
diff -Nru src-old/mame/video/vertigo.c src/mame/video/vertigo.c
--- src-old/mame/video/vertigo.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/vertigo.c	2012-05-03 11:00:08.000000000 +0200
@@ -159,7 +159,7 @@
 	int i;
 	UINT64 *mcode;
 
-	state->m_vectorrom = (UINT16 *)machine.root_device().memregion("user1")->base();
+	state->m_vectorrom = (UINT16 *)state->memregion("user1")->base();
 	mcode = (UINT64 *)state->memregion("proms")->base();
 
 	/* Decode microcode */
diff -Nru src-old/mame/video/wecleman.c src/mame/video/wecleman.c
--- src-old/mame/video/wecleman.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/wecleman.c	2012-05-03 11:00:08.000000000 +0200
@@ -77,7 +77,7 @@
 {
 	wecleman_state *state = machine.driver_data<wecleman_state>();
 	const pen_t *base_pal = machine.pens;
-	UINT8 *base_gfx = machine.root_device().memregion("gfx1")->base();
+	UINT8 *base_gfx = state->memregion("gfx1")->base();
 	int gfx_max     = state->memregion("gfx1")->bytes();
 
 	UINT16 *source = state->m_spriteram;
diff -Nru src-old/mame/video/williams.c src/mame/video/williams.c
--- src-old/mame/video/williams.c	2012-04-20 07:54:39.000000000 +0200
+++ src/mame/video/williams.c	2012-04-24 22:12:29.000000000 +0200
@@ -352,13 +352,19 @@
 
 READ8_MEMBER(williams_state::williams_video_counter_r)
 {
-	return machine().primary_screen->vpos() & 0xfc;
+	if (machine().primary_screen->vpos() < 0x100)
+		return machine().primary_screen->vpos() & 0xfc;
+	else
+		return 0xfc;
 }
 
 
 READ8_MEMBER(williams_state::williams2_video_counter_r)
 {
-	return machine().primary_screen->vpos();
+	if (machine().primary_screen->vpos() < 0x100)
+		return machine().primary_screen->vpos() & 0xfc;
+	else
+		return 0xfc;
 }
 
 
diff -Nru src-old/mame/video/zac2650.c src/mame/video/zac2650.c
--- src-old/mame/video/zac2650.c	2012-04-06 16:29:31.000000000 +0200
+++ src/mame/video/zac2650.c	2012-05-03 11:00:08.000000000 +0200
@@ -41,7 +41,7 @@
 
 READ8_MEMBER(zac2650_state::tinvader_port_0_r)
 {
-	return input_port_read(machine(), "1E80") - m_CollisionBackground;
+	return ioport("1E80")->read() - m_CollisionBackground;
 }
 
 /*****************************************/
diff -Nru src-old/osd/sdl/debugosx.m src/osd/sdl/debugosx.m
--- src-old/osd/sdl/debugosx.m	2012-03-07 21:46:01.000000000 +0100
+++ src/osd/sdl/debugosx.m	2012-05-03 11:16:42.000000000 +0200
@@ -827,10 +827,10 @@
 	{
 		NSInteger tag;
 		for (tag = 1; tag <= 8; tag <<= 1) {
-			NSString	*title = [NSString stringWithFormat:@"%d-byte Chunks", tag];
+			NSString	*title = [NSString stringWithFormat:@"%ld-byte Chunks", tag];
 			NSMenuItem	*chunkItem = [menu insertItemWithTitle:title
 														action:@selector(showChunkSize:)
-												 keyEquivalent:[NSString stringWithFormat:@"%d", tag]
+												 keyEquivalent:[NSString stringWithFormat:@"%ld", tag]
 													   atIndex:index++];
 			[chunkItem setTarget:self];
 			[chunkItem setTag:tag];
@@ -900,13 +900,13 @@
 
 	item = [contextMenu addItemWithTitle:@"Toggle Breakpoint"
 								  action:@selector(debugToggleBreakpoint:)
-						   keyEquivalent:[NSString stringWithFormat:@"%C", NSF9FunctionKey]];
+						   keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF9FunctionKey]];
 	[item setKeyEquivalentModifierMask:0];
 	[item setTarget:self];
 
 	item = [contextMenu addItemWithTitle:@"Disable Breakpoint"
 								  action:@selector(debugToggleBreakpointEnable:)
-						   keyEquivalent:[NSString stringWithFormat:@"%C", NSF9FunctionKey]];
+						   keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF9FunctionKey]];
 	[item setKeyEquivalentModifierMask:NSShiftKeyMask];
 	[item setTarget:self];
 
@@ -914,7 +914,7 @@
 
 	item = [contextMenu addItemWithTitle:@"Run to Cursor"
 								  action:@selector(debugRunToCursor:)
-						   keyEquivalent:[NSString stringWithFormat:@"%C", NSF4FunctionKey]];
+						   keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF4FunctionKey]];
 	[item setKeyEquivalentModifierMask:0];
 	[item setTarget:self];
 
@@ -1163,7 +1163,7 @@
 	{
 		NSMenuItem *breakItem = [menu insertItemWithTitle:@"Toggle Breakpoint at Cursor"
 												   action:@selector(debugToggleBreakpoint:)
-											keyEquivalent:[NSString stringWithFormat:@"%C", NSF9FunctionKey]
+											keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF9FunctionKey]
 												  atIndex:index++];
 		[breakItem setKeyEquivalentModifierMask:0];
 		[breakItem setTarget:self];
@@ -1171,7 +1171,7 @@
 	{
 		NSMenuItem *disableItem = [menu insertItemWithTitle:@"Disable Breakpoint at Cursor"
 													 action:@selector(debugToggleBreakpointEnable:)
-											  keyEquivalent:[NSString stringWithFormat:@"%C", NSF9FunctionKey]
+											  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF9FunctionKey]
 													atIndex:index++];
 		[disableItem setKeyEquivalentModifierMask:NSShiftKeyMask];
 		[disableItem setAlternate:YES];
@@ -1183,11 +1183,11 @@
 		if (runMenu != nil) {
 			runItem = [runMenu addItemWithTitle:@"to Cursor"
 										 action:@selector(debugRunToCursor:)
-								  keyEquivalent:[NSString stringWithFormat:@"%C", NSF4FunctionKey]];
+								  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF4FunctionKey]];
 		} else {
 			runItem = [menu insertItemWithTitle:@"Run to Cursor"
 										 action:@selector(debugRunToCursor:)
-								  keyEquivalent:[NSString stringWithFormat:@"%C", NSF4FunctionKey]
+								  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF4FunctionKey]
 										atIndex:index++];
 		}
 		[runItem setKeyEquivalentModifierMask:0];
@@ -1350,26 +1350,26 @@
 	{
 		NSMenuItem *runParentItem = [menu addItemWithTitle:@"Run"
 													action:@selector(debugRun:)
-											 keyEquivalent:[NSString stringWithFormat:@"%C", NSF5FunctionKey]];
+											 keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF5FunctionKey]];
 		NSMenu *runMenu = [[NSMenu allocWithZone:[NSMenu menuZone]] initWithTitle:@"Run"];
 		[runParentItem setSubmenu:runMenu];
 		[runMenu release];
 		[runParentItem setKeyEquivalentModifierMask:0];
 		[[runMenu addItemWithTitle:@"and Hide Debugger"
 							action:@selector(debugRunAndHide:)
-					 keyEquivalent:[NSString stringWithFormat:@"%C", NSF12FunctionKey]]
+					 keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF12FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[runMenu addItemWithTitle:@"to Next CPU"
 							action:@selector(debugRunToNextCPU:)
-					 keyEquivalent:[NSString stringWithFormat:@"%C", NSF6FunctionKey]]
+					 keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF6FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[runMenu addItemWithTitle:@"until Next Interrupt on Current CPU"
 							action:@selector(debugRunToNextInterrupt:)
-					 keyEquivalent:[NSString stringWithFormat:@"%C", NSF7FunctionKey]]
+					 keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF7FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[runMenu addItemWithTitle:@"until Next VBLANK"
 							action:@selector(debugRunToNextVBLANK:)
-					 keyEquivalent:[NSString stringWithFormat:@"%C", NSF8FunctionKey]]
+					 keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF8FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 	}
 	{
@@ -1379,15 +1379,15 @@
 		[stepMenu release];
 		[[stepMenu addItemWithTitle:@"Into"
 							 action:@selector(debugStepInto:)
-					  keyEquivalent:[NSString stringWithFormat:@"%C", NSF11FunctionKey]]
+					  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF11FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[stepMenu addItemWithTitle:@"Over"
 							 action:@selector(debugStepOver:)
-					  keyEquivalent:[NSString stringWithFormat:@"%C", NSF10FunctionKey]]
+					  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF10FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[stepMenu addItemWithTitle:@"Out"
 							 action:@selector(debugStepOut:)
-					  keyEquivalent:[NSString stringWithFormat:@"%C", NSF10FunctionKey]]
+					  keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF10FunctionKey]]
 		 setKeyEquivalentModifierMask:NSShiftKeyMask];
 	}
 	{
@@ -1397,11 +1397,11 @@
 		[resetMenu release];
 		[[resetMenu addItemWithTitle:@"Soft"
 							  action:@selector(debugSoftReset:)
-					   keyEquivalent:[NSString stringWithFormat:@"%C", NSF3FunctionKey]]
+					   keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF3FunctionKey]]
 		 setKeyEquivalentModifierMask:0];
 		[[resetMenu addItemWithTitle:@"Hard"
 							  action:@selector(debugHardReset:)
-					   keyEquivalent:[NSString stringWithFormat:@"%C", NSF3FunctionKey]]
+					   keyEquivalent:[NSString stringWithFormat:@"%C", (short)NSF3FunctionKey]]
 		 setKeyEquivalentModifierMask:NSShiftKeyMask];
 	}
 	[menu addItem:[NSMenuItem separatorItem]];
diff -Nru src-old/osd/sdl/input.c src/osd/sdl/input.c
--- src-old/osd/sdl/input.c	2012-02-16 03:38:13.000000000 +0100
+++ src/osd/sdl/input.c	2012-05-03 11:00:08.000000000 +0200
@@ -1651,7 +1651,7 @@
 	// loop over the defaults
 	for (entry = typelist.first(); entry != NULL; entry = entry->next())
 	{
-		switch (entry->type)
+		switch (entry->type())
 		{
 			// configurable UI mode switch
 			case IPT_UI_TOGGLE_UI:
@@ -1670,26 +1670,23 @@
 					mameid_code = lookup_mame_code(fullmode);
 				}
 				ui_code = input_code(DEVICE_CLASS_KEYBOARD, 0, ITEM_CLASS_SWITCH, ITEM_MODIFIER_NONE, input_item_id(mameid_code));
-				entry->defseq[SEQ_TYPE_STANDARD].set(ui_code);
+				entry->defseq(SEQ_TYPE_STANDARD).set(ui_code);
 				break;
 			// alt-enter for fullscreen
 			case IPT_OSD_1:
-				entry->token = "TOGGLE_FULLSCREEN";
-				entry->name = "Toggle Fullscreen";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_ENTER, KEYCODE_LALT);
+				entry->configure_osd("TOGGLE_FULLSCREEN", "Toggle Fullscreen");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_ENTER, KEYCODE_LALT);
 				break;
 
 			// disable UI_SELECT when LALT is down, this stops selecting
 			// things in the menu when toggling fullscreen with LALT+ENTER
 /*          case IPT_UI_SELECT:
-                entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_ENTER, input_seq::not_code, KEYCODE_LALT);
+                entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_ENTER, input_seq::not_code, KEYCODE_LALT);
                 break;*/
 
 			// page down for fastforward (must be OSD_3 as per src/emu/ui.c)
 			case IPT_UI_FAST_FORWARD:
-				entry->token = "FAST_FORWARD";
-				entry->name = "Fast Forward";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_PGDN);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_PGDN);
 				break;
 
 			// OSD hotkeys use LCTRL and start at F3, they start at
@@ -1699,68 +1696,67 @@
 
 			// LCTRL-F3 to toggle fullstretch
 			case IPT_OSD_2:
-				entry->token = "TOGGLE_FULLSTRETCH";
-				entry->name = "Toggle Uneven stretch";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F3, KEYCODE_LCONTROL);
+				entry->configure_osd("TOGGLE_FULLSTRETCH", "Toggle Uneven stretch");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F3, KEYCODE_LCONTROL);
 				break;
 			// add a Not lcrtl condition to the reset key
 			case IPT_UI_SOFT_RESET:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F3, input_seq::not_code, KEYCODE_LCONTROL, input_seq::not_code, KEYCODE_LSHIFT);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F3, input_seq::not_code, KEYCODE_LCONTROL, input_seq::not_code, KEYCODE_LSHIFT);
 				break;
 
 			// LCTRL-F4 to toggle keep aspect
 			case IPT_OSD_4:
-				entry->token = "TOGGLE_KEEP_ASPECT";
-				entry->name = "Toggle Keepaspect";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F4, KEYCODE_LCONTROL);
+				entry->configure_osd("TOGGLE_KEEP_ASPECT", "Toggle Keepaspect");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F4, KEYCODE_LCONTROL);
 				break;
 			// add a Not lcrtl condition to the show gfx key
 			case IPT_UI_SHOW_GFX:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F4, input_seq::not_code, KEYCODE_LCONTROL);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F4, input_seq::not_code, KEYCODE_LCONTROL);
 				break;
 
 			// LCTRL-F5 to toggle OpenGL filtering
 			case IPT_OSD_5:
-				entry->token = "TOGGLE_FILTER";
-				entry->name = "Toggle Filter";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F5, KEYCODE_LCONTROL);
+				entry->configure_osd("TOGGLE_FILTER", "Toggle Filter");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F5, KEYCODE_LCONTROL);
 				break;
 			// add a Not lcrtl condition to the toggle debug key
 			case IPT_UI_TOGGLE_DEBUG:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F5, input_seq::not_code, KEYCODE_LCONTROL);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F5, input_seq::not_code, KEYCODE_LCONTROL);
 				break;
 
 			// LCTRL-F6 to decrease OpenGL prescaling
 			case IPT_OSD_6:
-				entry->token = "DECREASE_PRESCALE";
-				entry->name = "Decrease Prescaling";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F6, KEYCODE_LCONTROL);
+				entry->configure_osd("DECREASE_PRESCALE", "Decrease Prescaling");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F6, KEYCODE_LCONTROL);
 				break;
 			// add a Not lcrtl condition to the toggle cheat key
 			case IPT_UI_TOGGLE_CHEAT:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F6, input_seq::not_code, KEYCODE_LCONTROL);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F6, input_seq::not_code, KEYCODE_LCONTROL);
 				break;
 
 			// LCTRL-F7 to increase OpenGL prescaling
 			case IPT_OSD_7:
-				entry->token = "INCREASE_PRESCALE";
-				entry->name = "Increase Prescaling";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F7, KEYCODE_LCONTROL);
+				entry->configure_osd("INCREASE_PRESCALE", "Increase Prescaling");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F7, KEYCODE_LCONTROL);
 				break;
 			// add a Not lcrtl condition to the load state key
 			case IPT_UI_LOAD_STATE:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F7, input_seq::not_code, KEYCODE_LCONTROL, input_seq::not_code, KEYCODE_LSHIFT);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F7, input_seq::not_code, KEYCODE_LCONTROL, input_seq::not_code, KEYCODE_LSHIFT);
 				break;
 
 			// add a Not lcrtl condition to the throttle key
 			case IPT_UI_THROTTLE:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_F10, input_seq::not_code, KEYCODE_LCONTROL);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_F10, input_seq::not_code, KEYCODE_LCONTROL);
 				break;
 
 			// disable the config menu if the ALT key is down
 			// (allows ALT-TAB to switch between apps)
 			case IPT_UI_CONFIGURE:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_TAB, input_seq::not_code, KEYCODE_LALT, input_seq::not_code, KEYCODE_RALT);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_TAB, input_seq::not_code, KEYCODE_LALT, input_seq::not_code, KEYCODE_RALT);
+				break;
+
+			// leave everything else alone
+			default:
 				break;
 		}
 	}
diff -Nru src-old/osd/windows/debugwin.c src/osd/windows/debugwin.c
--- src-old/osd/windows/debugwin.c	2012-01-24 22:18:55.000000000 +0100
+++ src/osd/windows/debugwin.c	2012-05-03 11:00:08.000000000 +0200
@@ -335,7 +335,7 @@
 
 static int debugwin_seq_pressed(running_machine &machine)
 {
-	const input_seq &seq = input_type_seq(machine, IPT_UI_DEBUG_BREAK, 0, SEQ_TYPE_STANDARD);
+	const input_seq &seq = machine.ioport().type_seq(IPT_UI_DEBUG_BREAK);
 	int result = FALSE;
 	int invert = FALSE;
 	int first = TRUE;
diff -Nru src-old/osd/windows/input.c src/osd/windows/input.c
--- src-old/osd/windows/input.c	2012-03-25 19:55:05.000000000 +0200
+++ src/osd/windows/input.c	2012-05-07 08:57:50.000000000 +0200
@@ -767,33 +767,34 @@
 
 	// loop over the defaults
 	for (entry = typelist.first(); entry != NULL; entry = entry->next())
-		switch (entry->type)
+		switch (entry->type())
 		{
 			// disable the config menu if the ALT key is down
 			// (allows ALT-TAB to switch between windows apps)
 			case IPT_UI_CONFIGURE:
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_TAB, input_seq::not_code, KEYCODE_LALT, input_seq::not_code, KEYCODE_RALT);
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_TAB, input_seq::not_code, KEYCODE_LALT, input_seq::not_code, KEYCODE_RALT);
 				break;
 
 			// alt-enter for fullscreen
 			case IPT_OSD_1:
-				entry->token = "TOGGLE_FULLSCREEN";
-				entry->name = "Toggle Fullscreen";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_LALT, KEYCODE_ENTER);
+				entry->configure_osd("TOGGLE_FULLSCREEN", "Toggle Fullscreen");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_LALT, KEYCODE_ENTER);
 				break;
 
 			// alt-F12 for fullscreen snap
 			case IPT_OSD_2:
-				entry->token = "RENDER_SNAP";
-				entry->name = "Take Rendered Snapshot";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_LALT, KEYCODE_F12);
+				entry->configure_osd("RENDER_SNAP", "Take Rendered Snapshot");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_LALT, KEYCODE_F12);
 				break;
 
 			// alt-F11 for fullscreen video
 			case IPT_OSD_3:
-				entry->token = "RENDER_AVI";
-				entry->name = "Record Rendered Video";
-				entry->defseq[SEQ_TYPE_STANDARD].set(KEYCODE_LALT, KEYCODE_F11);
+				entry->configure_osd("RENDER_AVI", "Record Rendered Video");
+				entry->defseq(SEQ_TYPE_STANDARD).set(KEYCODE_LALT, KEYCODE_F11);
+				break;
+
+			// leave everything else alone
+			default:
 				break;
 		}
 }
diff -Nru src-old/osd/windows/windows.mak src/osd/windows/windows.mak
--- src-old/osd/windows/windows.mak	2012-04-22 16:10:44.000000000 +0200
+++ src/osd/windows/windows.mak	2012-05-03 18:45:36.000000000 +0200
@@ -242,11 +242,6 @@
 # add our prefix files to the mix
 CCOMFLAGS += -include $(WINSRC)/winprefix.h
 
-# for 32-bit apps, add unicows for Unicode support on Win9x
-ifneq ($(PTR64),1)
-LIBS += -lunicows
-endif
-
 # ensure we statically link the gcc runtime lib
 LDFLAGS += -static-libgcc
 TEST_GCC = $(shell gcc --version)
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2012-04-22 16:10:44.000000000 +0200
+++ src/version.c	2012-05-07 08:57:50.000000000 +0200
@@ -38,4 +38,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.145u7 ("__DATE__")";
+const char build_version[] = "0.145u8 ("__DATE__")";
