diff -Nru hash-old/neogeo.xml hash/neogeo.xml
--- hash-old/neogeo.xml	2011-12-24 20:09:32.000000000 +0100
+++ hash/neogeo.xml	2012-03-11 11:27:24.000000000 +0100
@@ -1979,7 +1979,7 @@
         <rom loadflag="load16_word_swap" name="040-p1.p1" offset="0x000000" size="0x100000" crc="6dde02c2" sha1="e432e63feb88c71629ec96aa84650dcfe356a551" />
       </dataarea>
       <dataarea name="fixed" size="0x040000">
-        <rom offset="0x000000" size="0x020000" name="040-s1.s1" crc="cd9802a3" sha1="f685d4638f4f68e7e3f101c0c39128454536721b" />
+        <rom offset="0x000000" size="0x020000" name="040-s1.s1" crc="cd9802a3" sha1="f685d4638f4f68e7e3f101c0c39128454536721b" />        <!-- TC531000 -->
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
         <rom offset="0x000000" size="0x020000" name="040-m1.m1" crc="d4de4bca" sha1="ecf604d06f01d40b04e285facef66a6ae2d35661" />
@@ -3496,22 +3496,23 @@
       <!-- MVS ONLY RELEASE -->
       <feature name="crypt" value="zupapa_prot" />
       <dataarea name="maincpu" size="0x100000">
-        <rom loadflag="load16_word_swap" name="070-p1.p1" offset="0x000000" size="0x100000" crc="5a96203e" sha1="49cddec9ca6cc51e5ecf8a34e447a23e1f8a15a1" />
+        <rom loadflag="load16_word_swap" name="070-p1.p1" offset="0x000000" size="0x100000" crc="5a96203e" sha1="49cddec9ca6cc51e5ecf8a34e447a23e1f8a15a1" />        <!-- TC5316200 -->
       </dataarea>
       <dataarea name="fixed" size="0x20000">
         <!-- The Encrypted Boards do _not_ have an s1 rom, data for it comes from the Cx ROMs -->
         <rom value="0" size="0x20000" offset="0x000000" loadflag="fill" />
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
-        <rom offset="0x000000" size="0x020000" name="070-m1.m1" crc="5a3b3191" sha1="fa9a9930e18c64e598841fb344c4471d3d2c1964" />
+        <rom offset="0x000000" size="0x020000" name="070-epr.m1" crc="5a3b3191" sha1="fa9a9930e18c64e598841fb344c4471d3d2c1964" />        <!-- M27C1001 -->
+        <!-- M1 on eprom, correct chip label unknown -->
       </dataarea>
       <dataarea name="ymsnd" size="0x200000">
-        <rom name="070-v1.v1" offset="0x000000" size="0x200000" crc="d3a7e1ff" sha1="4a4a227e10f4af58168f6c26011ea1d414253f92" />
+        <rom name="070-v1.v1" offset="0x000000" size="0x200000" crc="d3a7e1ff" sha1="4a4a227e10f4af58168f6c26011ea1d414253f92" />        <!-- TC5316200 -->
       </dataarea>
       <dataarea name="sprites" size="0x1000000">
         <!-- Encrypted -->
-        <rom loadflag="load16_byte" name="070-c1.c1" offset="0x000000" size="0x800000" crc="f8ad02d8" sha1="9be54532332a8e963ec35ff1e518947bb11ebade" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="070-c2.c2" offset="0x000001" size="0x800000" crc="70156dde" sha1="06286bf043d50199b47df9a76ca91f39cb28cb90" />        <!-- Plane 2,3 -->
+        <rom loadflag="load16_byte" name="070-c1.c1" offset="0x000000" size="0x800000" crc="f8ad02d8" sha1="9be54532332a8e963ec35ff1e518947bb11ebade" />        <!-- Plane 0,1 -->        <!-- TC5364205 -->
+        <rom loadflag="load16_byte" name="070-c2.c2" offset="0x000001" size="0x800000" crc="70156dde" sha1="06286bf043d50199b47df9a76ca91f39cb28cb90" />        <!-- Plane 2,3 -->        <!-- TC5364205 -->
       </dataarea>
     </part>
   </software>
@@ -4797,24 +4798,24 @@
     <sharedfeat name="aescompatible" value="yes" />
     <part name="cart" interface="neo_cart">
       <dataarea name="maincpu" size="0x200000">
-        <rom loadflag="load16_word_swap" name="201-p1.p1" offset="0x100000" size="0x100000" crc="08d8daa5" sha1="b888993dbb7e9f0a28a01d7d2e1da00ef9cf6f38" />
+        <rom loadflag="load16_word_swap" name="201-p1.p1" offset="0x100000" size="0x100000" crc="08d8daa5" sha1="b888993dbb7e9f0a28a01d7d2e1da00ef9cf6f38" />        <!-- TC5316200 -->
         <rom size="0x100000" offset="0x000000" loadflag="continue" />
       </dataarea>
       <dataarea name="fixed" size="0x040000">
-        <rom offset="0x000000" size="0x020000" name="201-s1.s1" crc="2f55958d" sha1="550b53628daec9f1e1e11a398854092d90f9505a" />
+        <rom offset="0x000000" size="0x020000" name="201-s1.s1" crc="2f55958d" sha1="550b53628daec9f1e1e11a398854092d90f9505a" />        <!-- TC531000 -->
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
-        <rom offset="0x000000" size="0x020000" name="201-m1.m1" crc="c28b3253" sha1="fd75bd15aed30266a8b3775f276f997af57d1c06" />
+        <rom offset="0x000000" size="0x020000" name="201-m1.m1" crc="c28b3253" sha1="fd75bd15aed30266a8b3775f276f997af57d1c06" />        <!-- TC531001 -->
       </dataarea>
       <dataarea name="ymsnd" size="0x800000">
-        <rom name="201-v1.v1" offset="0x000000" size="0x400000" crc="23d22ed1" sha1="cd076928468ad6bcc5f19f88cb843ecb5e660681" />
-        <rom name="201-v2.v2" offset="0x400000" size="0x400000" crc="472cf9db" sha1="5f79ea9286d22ed208128f9c31ca75552ce08b57" />
+        <rom name="201-v1.v1" offset="0x000000" size="0x400000" crc="23d22ed1" sha1="cd076928468ad6bcc5f19f88cb843ecb5e660681" />        <!-- TC5332204 -->
+        <rom name="201-v2.v2" offset="0x400000" size="0x400000" crc="472cf9db" sha1="5f79ea9286d22ed208128f9c31ca75552ce08b57" />        <!-- TC5332204 -->
       </dataarea>
       <dataarea name="sprites" size="0x1000000">
-        <rom loadflag="load16_byte" name="201-c1.c1" offset="0x000000" size="0x400000" crc="72813676" sha1="7b045d1a48980cb1a140699011cb1a3d4acdc4d1" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="201-c2.c2" offset="0x000001" size="0x400000" crc="96f62574" sha1="cb7254b885989223bba597b8ff0972dfa5957816" />        <!-- Plane 2,3 -->
-        <rom loadflag="load16_byte" name="201-c3.c3" offset="0x800000" size="0x400000" crc="5121456a" sha1="0a7a27d603d1bb2520b5570ebf5b34a106e255a6" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="201-c4.c4" offset="0x800001" size="0x400000" crc="f4ad59a3" sha1="4e94fda8ee63abf0f92afe08060a488546e5c280" />        <!-- Plane 2,3 -->
+        <rom loadflag="load16_byte" name="201-c1.c1" offset="0x000000" size="0x400000" crc="72813676" sha1="7b045d1a48980cb1a140699011cb1a3d4acdc4d1" />        <!-- Plane 0,1 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="201-c2.c2" offset="0x000001" size="0x400000" crc="96f62574" sha1="cb7254b885989223bba597b8ff0972dfa5957816" />        <!-- Plane 2,3 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="201-c3.c3" offset="0x800000" size="0x400000" crc="5121456a" sha1="0a7a27d603d1bb2520b5570ebf5b34a106e255a6" />        <!-- Plane 0,1 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="201-c4.c4" offset="0x800001" size="0x400000" crc="f4ad59a3" sha1="4e94fda8ee63abf0f92afe08060a488546e5c280" />        <!-- Plane 2,3 -->        <!-- TC5332205 -->
       </dataarea>
     </part>
   </software>
@@ -5119,7 +5120,7 @@
         <rom size="0x100000" offset="0x000000" loadflag="continue" />
       </dataarea>
       <dataarea name="fixed" size="0x040000">
-        <rom offset="0x000000" size="0x020000" name="213-s1.s1" crc="b76b61bc" sha1="5fdb407d16ab9e33c4f26ee09ff70891ae1d2bd0" />
+        <rom offset="0x000000" size="0x020000" name="213-s1.s1" crc="b76b61bc" sha1="5fdb407d16ab9e33c4f26ee09ff70891ae1d2bd0" />        <!-- TC531000 -->
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
         <rom offset="0x000000" size="0x020000" name="213-m1.m1" crc="200045f1" sha1="7a6cd1c8d4447ea260d7ff4520c676b8d685f2e4" />
@@ -6969,23 +6970,23 @@
     <part name="cart" interface="neo_cart">
       <!-- MVS ONLY RELEASE -->
       <dataarea name="maincpu" size="0x100000">
-        <rom loadflag="load16_word_swap" name="248-p1.p1" offset="0x000000" size="0x100000" crc="9d6c0754" sha1="95c70c2d51fc4de01e768e03cc800a850aaad5dc" />
+        <rom loadflag="load16_word_swap" name="248-p1.p1" offset="0x000000" size="0x100000" crc="9d6c0754" sha1="95c70c2d51fc4de01e768e03cc800a850aaad5dc" />        <!-- TC538200 -->
       </dataarea>
       <dataarea name="fixed" size="0x040000">
-        <rom offset="0x000000" size="0x020000" name="248-s1.s1" crc="0a3fee41" sha1="0ab2120e462086be942efcf6ffb37f58ea966ca3" />
+        <rom offset="0x000000" size="0x020000" name="248-s1.s1" crc="0a3fee41" sha1="0ab2120e462086be942efcf6ffb37f58ea966ca3" />        <!-- TC531000DP -->
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
-        <rom offset="0x000000" size="0x020000" name="248-m1.m1" crc="883097a9" sha1="677bf9684c0c7977a9a3f0c1288e430040a53b49" />
+        <rom offset="0x000000" size="0x020000" name="248-m1.m1" crc="883097a9" sha1="677bf9684c0c7977a9a3f0c1288e430040a53b49" />        <!-- TC531001 -->
       </dataarea>
       <dataarea name="ymsnd" size="0x800000">
-        <rom name="248-v1.v1" offset="0x000000" size="0x400000" crc="57fde1fa" sha1="af39bc141fc35b78dcacfd42b3abb29d7e5c2c89" />
-        <rom name="248-v2.v2" offset="0x400000" size="0x400000" crc="4b966ef3" sha1="083c0e9fd7b8e506087648cdd8ec4206103984cd" />
+        <rom name="248-v1.v1" offset="0x000000" size="0x400000" crc="57fde1fa" sha1="af39bc141fc35b78dcacfd42b3abb29d7e5c2c89" />        <!-- TC5332204 -->
+        <rom name="248-v2.v2" offset="0x400000" size="0x400000" crc="4b966ef3" sha1="083c0e9fd7b8e506087648cdd8ec4206103984cd" />        <!-- TC5332204 -->
       </dataarea>
       <dataarea name="sprites" size="0xa00000">
-        <rom loadflag="load16_byte" name="248-c1.c1" offset="0x000000" size="0x400000" crc="d9115327" sha1="a49aa836a902326cfe785428e1699fefcf8566d4" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="248-c2.c2" offset="0x000001" size="0x400000" crc="77f9fdac" sha1="4642d71d32b6a05dc8bfa0f95c936a77c7cef05e" />        <!-- Plane 2,3 -->
-        <rom loadflag="load16_byte" name="248-c3.c3" offset="0x800000" size="0x100000" crc="8890bf7c" sha1="a52f6bafd60e72003bfe38c80c1dde24b4983b2a" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="248-c4.c4" offset="0x800001" size="0x100000" crc="8efead3f" sha1="f577d2f7c6f850b3d100c36947ad15e33dfa0bed" />        <!-- Plane 2,3 -->
+        <rom loadflag="load16_byte" name="248-c1.c1" offset="0x000000" size="0x400000" crc="d9115327" sha1="a49aa836a902326cfe785428e1699fefcf8566d4" />        <!-- Plane 0,1 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="248-c2.c2" offset="0x000001" size="0x400000" crc="77f9fdac" sha1="4642d71d32b6a05dc8bfa0f95c936a77c7cef05e" />        <!-- Plane 2,3 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="248-c3.c3" offset="0x800000" size="0x100000" crc="8890bf7c" sha1="a52f6bafd60e72003bfe38c80c1dde24b4983b2a" />        <!-- Plane 0,1 -->        <!-- TC538200 -->
+        <rom loadflag="load16_byte" name="248-c4.c4" offset="0x800001" size="0x100000" crc="8efead3f" sha1="f577d2f7c6f850b3d100c36947ad15e33dfa0bed" />        <!-- Plane 2,3 -->        <!-- TC538200 -->
       </dataarea>
     </part>
   </software>
@@ -7008,22 +7009,22 @@
     <part name="cart" interface="neo_cart">
       <!-- MVS ONLY RELEASE -->
       <dataarea name="maincpu" size="0x200000">
-        <rom loadflag="load16_word_swap" name="249-p1.p1" offset="0x100000" size="0x100000" crc="c9386118" sha1="5554662c7bc8605889cac4a67fee05bbb4eb786f" />
+        <rom loadflag="load16_word_swap" name="249-p1.p1" offset="0x100000" size="0x100000" crc="c9386118" sha1="5554662c7bc8605889cac4a67fee05bbb4eb786f" />        <!-- TC5316200 -->
         <rom size="0x100000" offset="0x000000" loadflag="continue" />
       </dataarea>
       <dataarea name="fixed" size="0x040000">
-        <rom offset="0x000000" size="0x020000" name="249-s1.s1" crc="dc9eb372" sha1="b8aa142243ba303799554479bfc88eb49260f3b1" />
+        <rom offset="0x000000" size="0x020000" name="249-s1.s1" crc="dc9eb372" sha1="b8aa142243ba303799554479bfc88eb49260f3b1" />        <!-- TC531000DP -->
       </dataarea>
       <dataarea name="audiocpu" size="0x020000">
-        <rom offset="0x000000" size="0x020000" name="249-m1.m1" crc="80328a47" sha1="34b6b1a81eab1cf38834b2eea55454ce1b6100e2" />
+        <rom offset="0x000000" size="0x020000" name="249-m1.m1" crc="80328a47" sha1="34b6b1a81eab1cf38834b2eea55454ce1b6100e2" />        <!-- TC531001 -->
       </dataarea>
       <dataarea name="ymsnd" size="0x500000">
-        <rom name="249-v1.v1" offset="0x000000" size="0x400000" crc="de7c8f27" sha1="3681a68a702ab5da8f509b8301d6cada75959332" />
-        <rom name="249-v2.v2" offset="0x400000" size="0x100000" crc="c8e40119" sha1="738f525c381ed68c0b8a89318a3e4d0089473c45" />
+        <rom name="249-v1.v1" offset="0x000000" size="0x400000" crc="de7c8f27" sha1="3681a68a702ab5da8f509b8301d6cada75959332" />        <!-- TC5332204 -->
+        <rom name="249-v2.v2" offset="0x400000" size="0x100000" crc="c8e40119" sha1="738f525c381ed68c0b8a89318a3e4d0089473c45" />        <!-- TC538200 -->
       </dataarea>
       <dataarea name="sprites" size="0x800000">
-        <rom loadflag="load16_byte" name="249-c1.c1" offset="0x000000" size="0x400000" crc="041fb8ee" sha1="dacc84d713d76818d89a26358374afaa22fa82a2" />        <!-- Plane 0,1 -->
-        <rom loadflag="load16_byte" name="249-c2.c2" offset="0x000001" size="0x400000" crc="74f3cdf4" sha1="55ddabaf77f4d575f4deb24fe63e4bdc2c6f31e1" />        <!-- Plane 2,3 -->
+        <rom loadflag="load16_byte" name="249-c1.c1" offset="0x000000" size="0x400000" crc="041fb8ee" sha1="dacc84d713d76818d89a26358374afaa22fa82a2" />        <!-- Plane 0,1 -->        <!-- TC5332205 -->
+        <rom loadflag="load16_byte" name="249-c2.c2" offset="0x000001" size="0x400000" crc="74f3cdf4" sha1="55ddabaf77f4d575f4deb24fe63e4bdc2c6f31e1" />        <!-- Plane 2,3 -->        <!-- TC5332205 -->
       </dataarea>
     </part>
   </software>
@@ -8762,7 +8763,7 @@
 
 
   <!--***************************************
- ID-0008 (official?)
+ B-J-02
  . ???-????
  MVS PROGV (2000.11.17) / NEO-MVS CHAFIO (1999.6.14)
 ***************************************-->
@@ -8770,7 +8771,7 @@
   <!-- jockeygp requires very specific hardware and is loaded in neodrvr.c -->
 
   <!--***************************************
- ID-03E7 (incorrect ID-code)
+ B-V-01
  . ???-????
  MVS PROGV (2000.11.17) / MVS CHAV (2000.10.26)
 ***************************************-->
diff -Nru src-old/emu/clifront.c src/emu/clifront.c
--- src-old/emu/clifront.c	2012-02-26 15:31:24.000000000 +0100
+++ src/emu/clifront.c	2012-03-02 08:48:15.000000000 +0100
@@ -1201,10 +1201,6 @@
 					{
 						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"reload\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
 					}
-					else if ( ROMENTRY_ISCONTINUE(rom) )
-					{
-						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"continue\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
-					}
 					else if ( ROMENTRY_ISFILL(rom) )
 					{
 						fprintf( out, "\t\t\t\t\t<rom size=\"%d\" offset=\"0x%x\" loadflag=\"fill\" />\n", ROM_GETLENGTH(rom), ROM_GETOFFSET(rom) );
diff -Nru src-old/emu/cpu/cpu.mak src/emu/cpu/cpu.mak
--- src-old/emu/cpu/cpu.mak	2012-02-20 09:25:57.000000000 +0100
+++ src/emu/cpu/cpu.mak	2012-03-09 19:50:18.000000000 +0100
@@ -1712,12 +1712,10 @@
 
 $(CPUOBJ)/tms57002/tms57002.o:	$(CPUSRC)/tms57002/tms57002.c \
 								$(CPUSRC)/tms57002/tms57002.h \
-								$(CPUSRC)/tms57002/tms57kpr.h \
 								$(CPUOBJ)/tms57002/tms57002.inc
 
 $(CPUOBJ)/tms57002/tms57kdec.o:	$(CPUSRC)/tms57002/tms57kdec.c \
 								$(CPUSRC)/tms57002/tms57002.h \
-								$(CPUSRC)/tms57002/tms57kpr.h \
 								$(CPUOBJ)/tms57002/tms57002.inc
 
 $(CPUOBJ)/tms57002/57002dsm.o:	$(CPUSRC)/tms57002/57002dsm.c \
diff -Nru src-old/emu/cpu/i386/i386.c src/emu/cpu/i386/i386.c
--- src-old/emu/cpu/i386/i386.c	2012-02-26 15:31:24.000000000 +0100
+++ src/emu/cpu/i386/i386.c	2012-03-11 18:17:00.000000000 +0100
@@ -34,7 +34,7 @@
 
 #define INT_DEBUG	1
 
-static void i386_load_protected_mode_segment(i386_state *cpustate, I386_SREG *seg )
+static UINT32 i386_load_protected_mode_segment(i386_state *cpustate, I386_SREG *seg, UINT64 *desc )
 {
 	UINT32 v1,v2;
 	UINT32 base, limit;
@@ -51,7 +51,7 @@
 
 	entry = seg->selector & ~0x7;
 	if (limit == 0 || entry + 7 > limit)
-		return;
+		return 0;
 
 	v1 = READ32(cpustate, base + entry );
 	v2 = READ32(cpustate, base + entry + 4 );
@@ -63,6 +63,10 @@
 		seg->limit = (seg->limit << 12) | 0xfff;
 	seg->d = (seg->flags & 0x4000) ? 1 : 0;
 	seg->valid = (seg->selector & ~3)?(true):(false);
+
+	if(desc)
+		*desc = ((UINT64)v2<<32)|v1;
+	return 1;
 }
 
 static void i386_load_call_gate(i386_state* cpustate, I386_CALL_GATE *gate)
@@ -101,7 +105,7 @@
 	if (PROTECTED_MODE)
 	{
 		if (!V8086_MODE)
-			i386_load_protected_mode_segment(cpustate, &cpustate->sreg[segment] );
+			i386_load_protected_mode_segment(cpustate, &cpustate->sreg[segment], NULL );
 		else
 		{
 			cpustate->sreg[segment].base = cpustate->sreg[segment].selector << 4;
@@ -358,7 +362,7 @@
 
 	memset(&desc, 0, sizeof(desc));
 	desc.selector = selector;
-	i386_load_protected_mode_segment(cpustate,&desc);
+	i386_load_protected_mode_segment(cpustate,&desc,NULL);
 	DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 	RPL = selector & 0x03;
 
@@ -401,7 +405,8 @@
 	{
 		if((cpustate->sreg[seg].flags & 0x0018) == 0x0010 && cpustate->sreg[seg].flags & 0x0004) // if expand-down data segment
 		{
-			if(offset <= cpustate->sreg[seg].limit)
+			// compare if greater then 0xffffffff when we're passed the access size
+			if((offset <= cpustate->sreg[seg].limit) || ((cpustate->sreg[seg].d)?0:(offset > 0xffff)))
 			{
 				logerror("Limit check at 0x%08x failed. Segment %04x, limit %08x, offset %08x (expand-down)\n",cpustate->pc,cpustate->sreg[seg].selector,cpustate->sreg[seg].limit,offset);
 				return 1;
@@ -433,7 +438,7 @@
 
 		memset(&stack, 0, sizeof(stack));
 		stack.selector = selector;
-		i386_load_protected_mode_segment(cpustate,&stack);
+		i386_load_protected_mode_segment(cpustate,&stack,NULL);
 		DPL = (stack.flags >> 5) & 0x03;
 
 		if((selector & ~0x0003) == 0)
@@ -491,7 +496,7 @@
 
 		memset(&desc, 0, sizeof(desc));
 		desc.selector = selector;
-		i386_load_protected_mode_segment(cpustate,&desc);
+		i386_load_protected_mode_segment(cpustate,&desc,NULL);
 		DPL = (desc.flags >> 5) & 0x03;
 
 		if(selector & 0x0004)  // LDT
@@ -692,7 +697,7 @@
 			/* Task gate */
 			memset(&desc, 0, sizeof(desc));
 			desc.selector = segment;
-			i386_load_protected_mode_segment(cpustate,&desc);
+			i386_load_protected_mode_segment(cpustate,&desc,NULL);
 			if(segment & 0x04)
 			{
 				logerror("IRQ: Task gate: TSS is not in the GDT.\n");
@@ -729,7 +734,7 @@
 			/* Interrupt or Trap gate */
 			memset(&desc, 0, sizeof(desc));
 			desc.selector = segment;
-			i386_load_protected_mode_segment(cpustate,&desc);
+			i386_load_protected_mode_segment(cpustate,&desc,NULL);
 			CPL = cpustate->CPL;  // current privilege level
 			DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 //          RPL = segment & 0x03;  // requested privilege level
@@ -777,7 +782,7 @@
 					stack.selector = i386_get_stack_segment(cpustate,DPL);
 				else
 					stack.selector = i286_get_stack_segment(cpustate,DPL);
-				i386_load_protected_mode_segment(cpustate,&stack);
+				i386_load_protected_mode_segment(cpustate,&stack,NULL);
 				oldSS = cpustate->sreg[SS].selector;
 				if(flags & 0x0008)
 					oldESP = REG32(ESP);
@@ -1011,7 +1016,7 @@
 	cpustate->task.segment = selector;
 	memset(&seg, 0, sizeof(seg));
 	seg.selector = cpustate->task.segment;
-	i386_load_protected_mode_segment(cpustate,&seg);
+	i386_load_protected_mode_segment(cpustate,&seg,NULL);
 	cpustate->task.limit = seg.limit;
 	cpustate->task.base = seg.base;
 	cpustate->task.flags = seg.flags;
@@ -1023,7 +1028,7 @@
 	tss = cpustate->task.base;
 	cpustate->ldtr.segment = READ16(cpustate,tss+0x2a) & 0xffff;
 	seg.selector = cpustate->ldtr.segment;
-	i386_load_protected_mode_segment(cpustate,&seg);
+	i386_load_protected_mode_segment(cpustate,&seg,NULL);
 	cpustate->ldtr.limit = seg.limit;
 	cpustate->ldtr.base = seg.base;
 	cpustate->ldtr.flags = seg.flags;
@@ -1121,7 +1126,7 @@
 	cpustate->task.segment = selector;
 	memset(&seg, 0, sizeof(seg));
 	seg.selector = cpustate->task.segment;
-	i386_load_protected_mode_segment(cpustate,&seg);
+	i386_load_protected_mode_segment(cpustate,&seg,NULL);
 	cpustate->task.limit = seg.limit;
 	cpustate->task.base = seg.base;
 	cpustate->task.flags = seg.flags;
@@ -1133,7 +1138,7 @@
 	tss = cpustate->task.base;
 	cpustate->ldtr.segment = READ32(cpustate,tss+0x60) & 0xffff;
 	seg.selector = cpustate->ldtr.segment;
-	i386_load_protected_mode_segment(cpustate,&seg);
+	i386_load_protected_mode_segment(cpustate,&seg,NULL);
 	cpustate->ldtr.limit = seg.limit;
 	cpustate->ldtr.base = seg.base;
 	cpustate->ldtr.flags = seg.flags;
@@ -1233,7 +1238,7 @@
 	/* Determine segment type */
 	memset(&desc, 0, sizeof(desc));
 	desc.selector = segment;
-	i386_load_protected_mode_segment(cpustate,&desc);
+	i386_load_protected_mode_segment(cpustate,&desc,NULL);
 	CPL = cpustate->CPL;  // current privilege level
 	DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 	RPL = segment & 0x03;  // requested privilege level
@@ -1291,7 +1296,7 @@
 				logerror("JMP: Available 386 TSS at %08x\n",cpustate->pc);
 				memset(&desc, 0, sizeof(desc));
 				desc.selector = segment;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 				if(DPL < CPL)
 				{
@@ -1362,7 +1367,7 @@
 					}
 				}
 				desc.selector = call_gate.selector;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				DPL = (desc.flags >> 5) & 0x03;
 				if((desc.flags & 0x0018) != 0x18)
 				{
@@ -1421,7 +1426,7 @@
 				}
 				/* Check the TSS that the task gate points to */
 				desc.selector = call_gate.selector;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 				RPL = call_gate.selector & 0x03;  // requested privilege level
 				if(call_gate.selector & 0x04)
@@ -1507,7 +1512,7 @@
 	/* Determine segment type */
 	memset(&desc, 0, sizeof(desc));
 	desc.selector = selector;
-	i386_load_protected_mode_segment(cpustate,&desc);
+	i386_load_protected_mode_segment(cpustate,&desc,NULL);
 	CPL = cpustate->CPL;  // current privilege level
 	DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 	RPL = selector & 0x03;  // requested privilege level
@@ -1653,7 +1658,7 @@
 						FAULT(FAULT_GP,desc.selector & ~0x03)  // #GP(selector)
 					}
 				}
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				if((desc.flags & 0x0018) != 0x18)
 				{
 					logerror("CALL: Call gate: Segment is not a code segment.\n");
@@ -1682,7 +1687,7 @@
 						stack.selector = i386_get_stack_segment(cpustate,DPL);
 					else
 						stack.selector = i286_get_stack_segment(cpustate,DPL);
-					i386_load_protected_mode_segment(cpustate,&stack);
+					i386_load_protected_mode_segment(cpustate,&stack,NULL);
 					if((stack.selector & ~0x07) == 0)
 					{
 						logerror("CALL: Call gate: TSS selector is null\n");
@@ -1786,7 +1791,7 @@
 
 					memset(&temp, 0, sizeof(temp));
 					temp.selector = oldSS;
-					i386_load_protected_mode_segment(cpustate,&temp);
+					i386_load_protected_mode_segment(cpustate,&temp,NULL);
 					/* copy parameters from old stack to new stack */
 					for(x=(gate.dword_count & 0x1f)-1;x>=0;x--)
 					{
@@ -1850,7 +1855,7 @@
 				}
 				/* Check the TSS that the task gate points to */
 				desc.selector = gate.selector;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				if(gate.selector & 0x04)
 				{
 					logerror("CALL: Task Gate: TSS is not global.\n");
@@ -1933,7 +1938,7 @@
 
 	memset(&desc, 0, sizeof(desc));
 	desc.selector = newCS;
-	i386_load_protected_mode_segment(cpustate,&desc);
+	i386_load_protected_mode_segment(cpustate,&desc,NULL);
 	CPL = cpustate->CPL;  // current privilege level
 	DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 	RPL = newCS & 0x03;
@@ -2113,7 +2118,7 @@
 
 		/* Check SS selector and descriptor */
 		desc.selector = newSS;
-		i386_load_protected_mode_segment(cpustate,&desc);
+		i386_load_protected_mode_segment(cpustate,&desc,NULL);
 		DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 		if((newSS & ~0x07) == 0)
 		{
@@ -2252,7 +2257,7 @@
 		}
 		memset(&desc, 0, sizeof(desc));
 		desc.selector = task;
-		i386_load_protected_mode_segment(cpustate,&desc);
+		i386_load_protected_mode_segment(cpustate,&desc,NULL);
 		if((desc.flags & 0x001f) != 0x000b)
 		{
 			logerror("IRET (%08x): Task return: Back-linked TSS is not a busy TSS.\n",cpustate->pc);
@@ -2286,12 +2291,12 @@
 			}
 			memset(&desc, 0, sizeof(desc));
 			desc.selector = newCS;
-			i386_load_protected_mode_segment(cpustate,&desc);
+			i386_load_protected_mode_segment(cpustate,&desc,NULL);
 			DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 			RPL = newCS & 0x03;
 			memset(&stack, 0, sizeof(stack));
 			stack.selector = newSS;
-			i386_load_protected_mode_segment(cpustate,&stack);
+			i386_load_protected_mode_segment(cpustate,&stack,NULL);
 			//SSRPL = newSS & 0x03;
 			//SSDPL = (stack.flags >> 5) & 0x03;
 
@@ -2502,7 +2507,7 @@
 				}
 				memset(&desc, 0, sizeof(desc));
 				desc.selector = newCS;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 				RPL = newCS & 0x03;
 				if((desc.flags & 0x0018) != 0x0018)
@@ -2563,7 +2568,7 @@
 				/* return to outer privilege level */
 				memset(&desc, 0, sizeof(desc));
 				desc.selector = newCS;
-				i386_load_protected_mode_segment(cpustate,&desc);
+				i386_load_protected_mode_segment(cpustate,&desc,NULL);
 				DPL = (desc.flags >> 5) & 0x03;  // descriptor privilege level
 				RPL = newCS & 0x03;
 				if(operand32 == 0)
@@ -2646,7 +2651,7 @@
 				}
 				memset(&stack, 0, sizeof(stack));
 				stack.selector = newSS;
-				i386_load_protected_mode_segment(cpustate,&stack);
+				i386_load_protected_mode_segment(cpustate,&stack,NULL);
 				DPL = (stack.flags >> 5) & 0x03;
 				if((newSS & ~0x03) == 0)
 				{
@@ -2852,7 +2857,7 @@
 	{
 		memset(&seg, 0, sizeof(seg));
 		seg.selector = (UINT16) param[0];
-		i386_load_protected_mode_segment(cpustate,&seg);
+		i386_load_protected_mode_segment(cpustate,&seg,NULL);
 		result = seg.base;
 	}
 	else
@@ -2873,7 +2878,7 @@
 	{
 		memset(&seg, 0, sizeof(seg));
 		seg.selector = (UINT16) param[0];
-		i386_load_protected_mode_segment(cpustate,&seg);
+		i386_load_protected_mode_segment(cpustate,&seg,NULL);
 		result = seg.limit;
 	}
 	return result;
@@ -3139,7 +3144,7 @@
 			if(cpustate->TF && cpustate->old_tf)
 			{
 				cpustate->prev_eip = cpustate->eip;
-				cpustate->ext = 0;
+				cpustate->ext = 1;
 				i386_trap(cpustate,1,0,0);
 			}
 
diff -Nru src-old/emu/cpu/i386/i386op16.c src/emu/cpu/i386/i386op16.c
--- src-old/emu/cpu/i386/i386op16.c	2012-02-23 00:42:26.000000000 +0100
+++ src/emu/cpu/i386/i386op16.c	2012-03-09 22:54:29.000000000 +0100
@@ -61,45 +61,74 @@
 		switch( (modrm >> 3) & 0x7 )
 		{
 			case 0:			/* ROL rm16, i8 */
+				if(!(shift & 15))
+				{
+					if(shift & 16)
+					{
+						cpustate->CF = src & 1;
+						cpustate->OF = (src & 1) ^ ((src >> 15) & 1);
+					}
+					break;
+				}
+				shift &= 15;
 				dst = ((src & ((UINT16)0xffff >> shift)) << shift) |
 					  ((src & ((UINT16)0xffff << (16-shift))) >> (16-shift));
-				cpustate->CF = (src >> (16-shift)) & 0x1;
+				cpustate->CF = dst & 0x1;
+				cpustate->OF = (dst & 1) ^ (dst >> 15);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 1:			/* ROR rm16, i8 */
+				if(!(shift & 15))
+				{
+					if(shift & 16)
+					{
+						cpustate->CF = (src >> 15) & 1;
+						cpustate->OF = ((src >> 15) & 1) ^ ((src >> 14) & 1);
+					}
+					break;
+				}
+				shift &= 15;
 				dst = ((src & ((UINT16)0xffff << shift)) >> shift) |
 					  ((src & ((UINT16)0xffff >> (16-shift))) << (16-shift));
-				cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->CF = (dst >> 15) & 1;
+				cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 2:			/* RCL rm16, i8 */
+				shift %= 17;
 				dst = ((src & ((UINT16)0xffff >> shift)) << shift) |
 					  ((src & ((UINT16)0xffff << (17-shift))) >> (17-shift)) |
 					  (cpustate->CF << (shift-1));
-				cpustate->CF = (src >> (16-shift)) & 0x1;
+				if(shift) cpustate->CF = (src >> (16-shift)) & 0x1;
+				cpustate->OF = cpustate->CF ^ ((dst >> 15) & 1);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 3:			/* RCR rm16, i8 */
+				shift %= 17;
 				dst = ((src & ((UINT16)0xffff << shift)) >> shift) |
 					  ((src & ((UINT16)0xffff >> (16-shift))) << (17-shift)) |
 					  (cpustate->CF << (16-shift));
-				cpustate->CF = (src >> (shift-1)) & 0x1;
+				if(shift) cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 4:			/* SHL/SAL rm16, i8 */
 			case 6:
+				shift &= 31;
 				dst = src << shift;
 				cpustate->CF = (src & (1 << (16-shift))) ? 1 : 0;
 				SetSZPF16(dst);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 5:			/* SHR rm16, i8 */
+				shift &= 31;
 				dst = src >> shift;
 				cpustate->CF = (src & (1 << (shift-1))) ? 1 : 0;
 				SetSZPF16(dst);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 7:			/* SAR rm16, i8 */
+				shift &= 31;
 				dst = (INT16)src >> shift;
 				cpustate->CF = (src & (1 << (shift-1))) ? 1 : 0;
 				SetSZPF16(dst);
@@ -329,7 +358,7 @@
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 bit = LOAD_REG16(modrm);
 
-		if( dst & (1 << bit) )
+		if( dst & (1 << (bit & 0xf)) )
 			cpustate->CF = 1;
 		else
 			cpustate->CF = 0;
@@ -339,6 +368,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,0);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -358,11 +388,11 @@
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 bit = LOAD_REG16(modrm);
 
-		if( dst & (1 << bit) )
+		if( dst & (1 << (bit & 0xf)) )
 			cpustate->CF = 1;
 		else
 			cpustate->CF = 0;
-		dst ^= (1 << bit);
+		dst ^= (1 << (bit & 0xf));
 
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTC_REG_REG);
@@ -370,6 +400,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -391,11 +422,11 @@
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 bit = LOAD_REG16(modrm);
 
-		if( dst & (1 << bit) )
+		if( dst & (1 << (bit & 0xf)) )
 			cpustate->CF = 1;
 		else
 			cpustate->CF = 0;
-		dst &= ~(1 << bit);
+		dst &= ~(1 << (bit & 0xf));
 
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTR_REG_REG);
@@ -403,6 +434,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -424,11 +456,11 @@
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 bit = LOAD_REG16(modrm);
 
-		if( dst & (1 << bit) )
+		if( dst & (1 << (bit & 0xf)) )
 			cpustate->CF = 1;
 		else
 			cpustate->CF = 0;
-		dst |= (1 << bit);
+		dst |= (1 << (bit & 0xf));
 
 		STORE_RM16(modrm, dst);
 		CYCLES(cpustate,CYCLES_BTS_REG_REG);
@@ -436,6 +468,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT16 bit = LOAD_REG16(modrm);
 		ea += 2*(bit/16);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 16;
 		UINT16 dst = READ16(cpustate,ea);
 
@@ -1994,21 +2027,24 @@
 
 static void I386OP(shld16_i8)(i386_state *cpustate)			// Opcode 0x0f a4
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else if( shift > 15 ) {
-			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
+			cpustate->CF = (upper & (1 << (16-shift))) ? 1 : 0;
+			// ppro and above should be (dst >> (32-shift))
 			dst = (upper << (shift-16)) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (16-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		}
 		STORE_RM16(modrm, dst);
@@ -2018,15 +2054,18 @@
 		UINT16 dst = READ16(cpustate,ea);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else if( shift > 15 ) {
-			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
+			cpustate->CF = (upper & (1 << (16-shift))) ? 1 : 0;
 			dst = (upper << (shift-16)) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (16-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		}
 		WRITE16(cpustate,ea, dst);
@@ -2036,21 +2075,23 @@
 
 static void I386OP(shld16_cl)(i386_state *cpustate)			// Opcode 0x0f a5
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else if( shift > 15 ) {
-			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
+			cpustate->CF = (upper & (1 << (16-shift))) ? 1 : 0;
 			dst = (upper << (shift-16)) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (16-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		}
 		STORE_RM16(modrm, dst);
@@ -2060,15 +2101,18 @@
 		UINT16 dst = READ16(cpustate,ea);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else if( shift > 15 ) {
-			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
+			cpustate->CF = (upper & (1 << (16-shift))) ? 1 : 0;
 			dst = (upper << (shift-16)) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (16-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (16-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 15);
 			SetSZPF16(dst);
 		}
 		WRITE16(cpustate,ea, dst);
@@ -2078,17 +2122,23 @@
 
 static void I386OP(shrd16_i8)(i386_state *cpustate)			// Opcode 0x0f ac
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 15 || shift == 0) {
+		shift &= 31;
+		if( shift == 0) {
 
+		} else if( shift > 15 ) {
+			cpustate->CF = (upper & (1 << (shift-1))) ? 1 : 0;
+			dst = (upper >> (shift-16)) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
+			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (16-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 			SetSZPF16(dst);
 		}
 		STORE_RM16(modrm, dst);
@@ -2098,11 +2148,18 @@
 		UINT16 dst = READ16(cpustate,ea);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 15 || shift == 0) {
+		shift &= 31;
+		if( shift == 0) {
 
+		} else if( shift > 15 ) {
+			cpustate->CF = (upper & (1 << (shift-1))) ? 1 : 0;
+			dst = (upper >> (shift-16)) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
+			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (16-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 			SetSZPF16(dst);
 		}
 		WRITE16(cpustate,ea, dst);
@@ -2112,17 +2169,23 @@
 
 static void I386OP(shrd16_cl)(i386_state *cpustate)			// Opcode 0x0f ad
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 15 || shift == 0) {
+		shift &= 31;
+		if( shift == 0) {
 
+		} else if( shift > 15 ) {
+			cpustate->CF = (upper & (1 << (shift-1))) ? 1 : 0;
+			dst = (upper >> (shift-16)) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
+			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (16-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 			SetSZPF16(dst);
 		}
 		STORE_RM16(modrm, dst);
@@ -2132,11 +2195,18 @@
 		UINT16 dst = READ16(cpustate,ea);
 		UINT16 upper = LOAD_REG16(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 15 || shift == 0) {
+		shift &= 31;
+		if( shift == 0) {
 
+		} else if( shift > 15 ) {
+			cpustate->CF = (upper & (1 << (shift-1))) ? 1 : 0;
+			dst = (upper >> (shift-16)) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
+			SetSZPF16(dst);
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (16-shift));
+			cpustate->OF = ((dst >> 15) ^ (dst >> 14)) & 1;
 			SetSZPF16(dst);
 		}
 		WRITE16(cpustate,ea, dst);
@@ -2823,9 +2893,7 @@
 							cpustate->CF = 1;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
@@ -2857,9 +2925,7 @@
 							cpustate->CF = 1;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
@@ -3072,7 +3138,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = cpustate->ldtr.segment;
-				i386_load_protected_mode_segment(cpustate,&seg);
+				i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				cpustate->ldtr.limit = seg.limit;
 				cpustate->ldtr.base = seg.base;
 				cpustate->ldtr.flags = seg.flags;
@@ -3099,7 +3165,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = cpustate->task.segment;
-				i386_load_protected_mode_segment(cpustate,&seg);
+				i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				cpustate->task.limit = seg.limit;
 				cpustate->task.base = seg.base;
 				cpustate->task.flags = seg.flags;
@@ -3124,22 +3190,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = address;
-				i386_load_protected_mode_segment(cpustate,&seg);
-				// check if the segment is within the bounds of the GDT or LDT
-				if(seg.selector & 0x04)
-				{  // LDT
-					if((seg.selector & 0xf8) > cpustate->ldtr.limit)
-					{
-						result = 0;
-					}
-				}
-				else
-				{  // GDT
-					if((seg.selector & 0xf8) > cpustate->gdtr.limit)
-					{
-						result = 0;
-					}
-				}
+				result = i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				// check if the segment is a code or data segment (not a special segment type, like a TSS, gate, LDT...)
 				if(!(seg.flags & 0x10))
 					result = 0;
@@ -3187,22 +3238,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = address;
-				i386_load_protected_mode_segment(cpustate,&seg);
-				// check if the segment is within the bounds of the GDT or LDT
-				if(seg.selector & 0x04)
-				{  // LDT
-					if((seg.selector & 0xf8) > cpustate->ldtr.limit)
-					{
-						result = 0;
-					}
-				}
-				else
-				{  // GDT
-					if((seg.selector & 0xf8) > cpustate->gdtr.limit)
-					{
-						result = 0;
-					}
-				}
+				result = i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				// check if the segment is a code or data segment (not a special segment type, like a TSS, gate, LDT...)
 				if(!(seg.flags & 0x10))
 					result = 0;
@@ -3488,7 +3524,16 @@
 		}
 		else
 		{
-			i386_load_protected_mode_segment(cpustate,&seg);
+			if(!i386_load_protected_mode_segment(cpustate,&seg,NULL))
+			{
+				SetZF(0);
+				return;
+			}
+			if(((seg.flags >> 5) & 3) < cpustate->CPL)
+			{
+				SetZF(0);
+				return;
+			}
 			if(!(seg.flags & 0x10))  // special segment
 			{
 				// check for invalid segment types
@@ -3499,14 +3544,12 @@
 				}
 				else
 				{
-					// TODO: check current privilege level
 					STORE_REG16(modrm,(seg.flags << 8) & 0xff00);
 					SetZF(1);
 				}
 			}
 			else
 			{  // data or code segment (both are valid for LAR)
-				// TODO: check current privilege level
 				STORE_REG16(modrm,(seg.flags << 8) & 0xff00);
 				SetZF(1);
 			}
@@ -3544,11 +3587,38 @@
 		}
 		else
 		{
-			// TODO: check segment type
-			i386_load_protected_mode_segment(cpustate,&seg);
-			limit = seg.limit;
-			STORE_REG16(modrm,limit & 0x0000ffff);
-			SetZF(1);
+			UINT8 type;
+			if(!i386_load_protected_mode_segment(cpustate,&seg,NULL))
+			{
+				SetZF(0);
+				return;
+			}
+			if(((seg.flags >> 5) & 3) < cpustate->CPL)
+			{
+				SetZF(0);
+				return;
+			}
+			type = seg.flags & 0x1f;
+			switch(type)
+			{
+			case 0:
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+			case 8:
+			case 10:
+			case 12:
+			case 13:
+			case 14:
+			case 15:
+				SetZF(0);
+				return;
+			default:
+				limit = seg.limit;
+				STORE_REG16(modrm,limit & 0x0000ffff);
+				SetZF(1);
+			}
 		}
 	}
 	else
diff -Nru src-old/emu/cpu/i386/i386op32.c src/emu/cpu/i386/i386op32.c
--- src-old/emu/cpu/i386/i386op32.c	2012-02-23 00:42:26.000000000 +0100
+++ src/emu/cpu/i386/i386op32.c	2012-03-09 22:54:29.000000000 +0100
@@ -59,19 +59,21 @@
 		}
 
 	} else {
-
+		shift &= 31;
 		switch( (modrm >> 3) & 0x7 )
 		{
 			case 0:			/* ROL rm32, i8 */
 				dst = ((src & ((UINT32)0xffffffff >> shift)) << shift) |
 					  ((src & ((UINT32)0xffffffff << (32-shift))) >> (32-shift));
-				cpustate->CF = (src >> (32-shift)) & 0x1;
+				cpustate->CF = dst & 0x1;
+				cpustate->OF = (dst & 1) ^ (dst >> 31);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 1:			/* ROR rm32, i8 */
 				dst = ((src & ((UINT32)0xffffffff << shift)) >> shift) |
 					  ((src & ((UINT32)0xffffffff >> (32-shift))) << (32-shift));
-				cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->CF = (dst >> 31) & 0x1;
+				cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 2:			/* RCL rm32, i8 */
@@ -79,6 +81,7 @@
 					  ((src & ((UINT32)0xffffffff << (33-shift))) >> (33-shift)) |
 					  (cpustate->CF << (shift-1));
 				cpustate->CF = (src >> (32-shift)) & 0x1;
+				cpustate->OF = cpustate->CF ^ ((dst >> 31) & 1);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 3:			/* RCR rm32, i8 */
@@ -86,6 +89,7 @@
 					  ((src & ((UINT32)0xffffffff >> (32-shift))) << (33-shift)) |
 					  (cpustate->CF << (32-shift));
 				cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 4:			/* SHL/SAL rm32, i8 */
@@ -340,6 +344,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,0);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -371,6 +376,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -404,6 +410,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -437,6 +444,7 @@
 		UINT32 ea = GetEA(cpustate,modrm,1);
 		UINT32 bit = LOAD_REG32(modrm);
 		ea += 4*(bit/32);
+		ea = (cpustate->address_size)?ea:(ea&0xffff);
 		bit %= 32;
 		UINT32 dst = READ32(cpustate,ea);
 
@@ -1867,17 +1875,18 @@
 
 static void I386OP(shld32_i8)(i386_state *cpustate)			// Opcode 0x0f a4
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT32 dst = LOAD_RM32(modrm);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (32-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 31);
 			SetSZPF32(dst);
 		}
 		STORE_RM32(modrm, dst);
@@ -1887,11 +1896,13 @@
 		UINT32 dst = READ32(cpustate,ea);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (32-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 31);
 			SetSZPF32(dst);
 		}
 		WRITE32(cpustate,ea, dst);
@@ -1901,17 +1912,18 @@
 
 static void I386OP(shld32_cl)(i386_state *cpustate)			// Opcode 0x0f a5
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT32 dst = LOAD_RM32(modrm);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (32-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 31);
 			SetSZPF32(dst);
 		}
 		STORE_RM32(modrm, dst);
@@ -1921,11 +1933,13 @@
 		UINT32 dst = READ32(cpustate,ea);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (32-shift))) ? 1 : 0;
 			dst = (dst << shift) | (upper >> (32-shift));
+			cpustate->OF = cpustate->CF ^ (dst >> 31);
 			SetSZPF32(dst);
 		}
 		WRITE32(cpustate,ea, dst);
@@ -1935,17 +1949,18 @@
 
 static void I386OP(shrd32_i8)(i386_state *cpustate)			// Opcode 0x0f ac
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT32 dst = LOAD_RM32(modrm);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 			SetSZPF32(dst);
 		}
 		STORE_RM32(modrm, dst);
@@ -1955,11 +1970,13 @@
 		UINT32 dst = READ32(cpustate,ea);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = FETCH(cpustate);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 			SetSZPF32(dst);
 		}
 		WRITE32(cpustate,ea, dst);
@@ -1969,17 +1986,18 @@
 
 static void I386OP(shrd32_cl)(i386_state *cpustate)			// Opcode 0x0f ad
 {
-	/* TODO: Correct flags */
 	UINT8 modrm = FETCH(cpustate);
 	if( modrm >= 0xc0 ) {
 		UINT32 dst = LOAD_RM32(modrm);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 			SetSZPF32(dst);
 		}
 		STORE_RM32(modrm, dst);
@@ -1989,11 +2007,13 @@
 		UINT32 dst = READ32(cpustate,ea);
 		UINT32 upper = LOAD_REG32(modrm);
 		UINT8 shift = REG8(CL);
-		if( shift > 31 || shift == 0 ) {
+		shift &= 31;
+		if( shift == 0 ) {
 
 		} else {
 			cpustate->CF = (dst & (1 << (shift-1))) ? 1 : 0;
 			dst = (dst >> shift) | (upper << (32-shift));
+			cpustate->OF = ((dst >> 31) ^ (dst >> 30)) & 1;
 			SetSZPF32(dst);
 		}
 		WRITE32(cpustate,ea, dst);
@@ -2675,9 +2695,7 @@
 						REG32(EAX) = (UINT32)result;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
@@ -2705,9 +2723,7 @@
 						REG32(EAX) = (UINT32)result;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
@@ -2919,7 +2935,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = cpustate->ldtr.segment;
-				i386_load_protected_mode_segment(cpustate,&seg);
+				i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				cpustate->ldtr.limit = seg.limit;
 				cpustate->ldtr.base = seg.base;
 				cpustate->ldtr.flags = seg.flags;
@@ -2946,7 +2962,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = cpustate->task.segment;
-				i386_load_protected_mode_segment(cpustate,&seg);
+				i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				cpustate->task.limit = seg.limit;
 				cpustate->task.base = seg.base;
 				cpustate->task.flags = seg.flags;
@@ -2960,7 +2976,6 @@
 		case 4:  /* VERR */
 			if ( PROTECTED_MODE && !V8086_MODE )
 			{
-				result = 1;
 				if( modrm >= 0xc0 ) {
 					address = LOAD_RM32(modrm);
 					CYCLES(cpustate,CYCLES_VERR_REG);
@@ -2971,22 +2986,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = address;
-				i386_load_protected_mode_segment(cpustate,&seg);
-				// check if the segment is within the bounds of the GDT or LDT
-				if(seg.selector & 0x04)
-				{  // LDT
-					if((seg.selector & 0xf8) > cpustate->ldtr.limit)
-					{
-						result = 0;
-					}
-				}
-				else
-				{  // GDT
-					if((seg.selector & 0xf8) > cpustate->gdtr.limit)
-					{
-						result = 0;
-					}
-				}
+				result = i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				// check if the segment is a code or data segment (not a special segment type, like a TSS, gate, LDT...)
 				if(!(seg.flags & 0x10))
 					result = 0;
@@ -3023,7 +3023,6 @@
 		case 5:  /* VERW */
 			if ( PROTECTED_MODE && !V8086_MODE )
 			{
-				result = 1;
 				if( modrm >= 0xc0 ) {
 					address = LOAD_RM16(modrm);
 					CYCLES(cpustate,CYCLES_VERW_REG);
@@ -3034,22 +3033,7 @@
 				}
 				memset(&seg, 0, sizeof(seg));
 				seg.selector = address;
-				i386_load_protected_mode_segment(cpustate,&seg);
-				// check if the segment is within the bounds of the GDT or LDT
-				if(seg.selector & 0x04)
-				{  // LDT
-					if((seg.selector & 0xf8) > cpustate->ldtr.limit)
-					{
-						result = 0;
-					}
-				}
-				else
-				{  // GDT
-					if((seg.selector & 0xf8) > cpustate->gdtr.limit)
-					{
-						result = 0;
-					}
-				}
+				result = i386_load_protected_mode_segment(cpustate,&seg,NULL);
 				// check if the segment is a code or data segment (not a special segment type, like a TSS, gate, LDT...)
 				if(!(seg.flags & 0x10))
 					result = 0;
@@ -3334,7 +3318,17 @@
 		}
 		else
 		{
-			i386_load_protected_mode_segment(cpustate,&seg);
+			UINT64 desc;
+			if(!i386_load_protected_mode_segment(cpustate,&seg,&desc))
+			{
+				SetZF(0);
+				return;
+			}
+			if(((seg.flags >> 5) & 3) < cpustate->CPL)
+			{
+				SetZF(0);
+				return;
+			}
 			if(!(seg.flags & 0x10))  // special segment
 			{
 				// check for invalid segment types
@@ -3345,15 +3339,13 @@
 				}
 				else
 				{
-					// TODO: check current privilege level
-					STORE_REG32(modrm,(seg.flags << 8) & 0x00ffff00);
+					STORE_REG32(modrm,(desc>>32) & 0x00ffff00);
 					SetZF(1);
 				}
 			}
 			else
 			{
-				// TODO: check current privilege level
-				STORE_REG32(modrm,(seg.flags << 8) & 0x00ffff00);
+				STORE_REG32(modrm,(desc>>32) & 0x00ffff00);
 				SetZF(1);
 			}
 		}
@@ -3390,11 +3382,38 @@
 		}
 		else
 		{
-			// TODO: check segment type
-			i386_load_protected_mode_segment(cpustate,&seg);
-			limit = seg.limit;
-			STORE_REG32(modrm,limit);
-			SetZF(1);
+			UINT8 type;
+			if(!i386_load_protected_mode_segment(cpustate,&seg,NULL))
+			{
+				SetZF(0);
+				return;
+			}
+			if(((seg.flags >> 5) & 3) < cpustate->CPL)
+			{
+				SetZF(0);
+				return;
+			}
+			type = seg.flags & 0x1f;
+			switch(type)
+			{
+			case 0:
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+			case 8:
+			case 10:
+			case 12:
+			case 13:
+			case 14:
+			case 15:
+				SetZF(0);
+				return;
+			default:
+				limit = seg.limit;
+				STORE_REG32(modrm,limit);
+				SetZF(1);
+			}
 		}
 	}
 	else
diff -Nru src-old/emu/cpu/i386/i386ops.c src/emu/cpu/i386/i386ops.c
--- src-old/emu/cpu/i386/i386ops.c	2012-02-24 22:04:08.000000000 +0100
+++ src/emu/cpu/i386/i386ops.c	2012-03-09 22:54:29.000000000 +0100
@@ -62,45 +62,74 @@
 		switch( (modrm >> 3) & 0x7 )
 		{
 			case 0:			/* ROL rm8, i8 */
+				if(!(shift & 7))
+				{
+					if(shift & 0x18)
+					{
+						cpustate->CF = src & 1;
+						cpustate->OF = (src & 1) ^ ((src >> 7) & 1);
+					}
+					break;
+				}
+				shift &= 7;
 				dst = ((src & ((UINT8)0xff >> shift)) << shift) |
 					  ((src & ((UINT8)0xff << (8-shift))) >> (8-shift));
-				cpustate->CF = (src >> (8-shift)) & 0x1;
+				cpustate->CF = dst & 0x1;
+				cpustate->OF = (dst & 1) ^ (dst >> 7);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 1:			/* ROR rm8, i8 */
+				if(!(shift & 7))
+				{
+					if(shift & 0x18)
+					{
+						cpustate->CF = (src >> 7) & 1;
+						cpustate->OF = ((src >> 7) & 1) ^ ((src >> 6) & 1);
+					}
+					break;
+				}
+				shift &= 7;
 				dst = ((src & ((UINT8)0xff << shift)) >> shift) |
 					  ((src & ((UINT8)0xff >> (8-shift))) << (8-shift));
-				cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->CF = (dst >> 7) & 1;
+				cpustate->OF = ((dst >> 7) ^ (dst >> 6)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 2:			/* RCL rm8, i8 */
+				shift %= 9;
 				dst = ((src & ((UINT8)0xff >> shift)) << shift) |
 					  ((src & ((UINT8)0xff << (9-shift))) >> (9-shift)) |
 					  (cpustate->CF << (shift-1));
-				cpustate->CF = (src >> (8-shift)) & 0x1;
+				if(shift) cpustate->CF = (src >> (8-shift)) & 0x1;
+				cpustate->OF = cpustate->CF ^ ((dst >> 7) & 1);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 3:			/* RCR rm8, i8 */
+				shift %= 9;
 				dst = ((src & ((UINT8)0xff << shift)) >> shift) |
 					  ((src & ((UINT8)0xff >> (8-shift))) << (9-shift)) |
 					  (cpustate->CF << (8-shift));
-				cpustate->CF = (src >> (shift-1)) & 0x1;
+				if(shift) cpustate->CF = (src >> (shift-1)) & 0x1;
+				cpustate->OF = ((dst >> 7) ^ (dst >> 6)) & 1;
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_CARRY_REG, CYCLES_ROTATE_CARRY_MEM);
 				break;
 			case 4:			/* SHL/SAL rm8, i8 */
 			case 6:
+				shift &= 31;
 				dst = src << shift;
-				cpustate->CF = (src & (1 << (8-shift))) ? 1 : 0;
+				cpustate->CF = (src >> (8 - shift)) & 0x1;
 				SetSZPF8(dst);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 5:			/* SHR rm8, i8 */
+				shift &= 31;
 				dst = src >> shift;
 				cpustate->CF = (src & (1 << (shift-1))) ? 1 : 0;
 				SetSZPF8(dst);
 				CYCLES_RM(cpustate,modrm, CYCLES_ROTATE_REG, CYCLES_ROTATE_MEM);
 				break;
 			case 7:			/* SAR rm8, i8 */
+				shift &= 31;
 				dst = (INT8)src >> shift;
 				cpustate->CF = (src & (1 << (shift-1))) ? 1 : 0;
 				SetSZPF8(dst);
@@ -1189,7 +1218,16 @@
 	{
 		cpustate->eip = repeated_eip;
 		cpustate->pc = repeated_pc;
-		I386OP(decode_opcode)(cpustate);
+		try
+		{
+			I386OP(decode_opcode)(cpustate);
+		}
+		catch (UINT64 e)
+		{
+			cpustate->eip = cpustate->prev_eip;
+			throw e;
+		}
+
 		CYCLES_NUM(cycle_adjustment);
 
 		if (cpustate->address_size)
@@ -2074,9 +2112,7 @@
 							cpustate->CF = 1;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
@@ -2108,9 +2144,7 @@
 							cpustate->CF = 1;
 					}
 				} else {
-					cpustate->ext = 0;
 					i386_trap(cpustate, 0, 0, 0);
-					cpustate->ext = 1;
 				}
 			}
 			break;
diff -Nru src-old/emu/cpu/i386/i386priv.h src/emu/cpu/i386/i386priv.h
--- src-old/emu/cpu/i386/i386priv.h	2012-02-08 22:26:25.000000000 +0100
+++ src/emu/cpu/i386/i386priv.h	2012-03-10 11:49:43.000000000 +0100
@@ -492,7 +492,7 @@
 	if(!ret)
 	{
 		if(rwn != -1)
-			*error |= ((rwn && 1)<<1) | ((cpustate->CPL==3)?1<<2:0);
+			*error |= ((rwn & 1)<<1) | ((cpustate->CPL==3)?1<<2:0);
 		return 0;
 	}
 	return 1;
diff -Nru src-old/emu/cpu/i386/i486ops.c src/emu/cpu/i386/i486ops.c
--- src-old/emu/cpu/i386/i486ops.c	2012-02-23 00:42:26.000000000 +0100
+++ src/emu/cpu/i386/i486ops.c	2012-03-09 22:54:29.000000000 +0100
@@ -67,7 +67,7 @@
 		UINT8 src = LOAD_REG8(modrm);
 
 		if( REG8(AL) == dst ) {
-			WRITE8(cpustate,modrm, src);
+			WRITE8(cpustate,ea, src);
 			cpustate->ZF = 1;
 			CYCLES(cpustate,CYCLES_CMPXCHG_REG_MEM_T);
 		} else {
@@ -100,7 +100,7 @@
 		UINT16 src = LOAD_REG16(modrm);
 
 		if( REG16(AX) == dst ) {
-			WRITE16(cpustate,modrm, src);
+			WRITE16(cpustate,ea, src);
 			cpustate->ZF = 1;
 			CYCLES(cpustate,CYCLES_CMPXCHG_REG_MEM_T);
 		} else {
@@ -150,8 +150,8 @@
 	if( modrm >= 0xc0 ) {
 		UINT8 dst = LOAD_RM8(modrm);
 		UINT8 src = LOAD_REG8(modrm);
-		STORE_RM16(modrm, dst + src);
-		STORE_REG16(modrm, dst);
+		STORE_REG8(modrm, dst);
+		STORE_RM8(modrm, dst + src);
 		CYCLES(cpustate,CYCLES_XADD_REG_REG);
 	} else {
 		UINT32 ea = GetEA(cpustate,modrm,1);
@@ -169,8 +169,8 @@
 	if( modrm >= 0xc0 ) {
 		UINT16 dst = LOAD_RM16(modrm);
 		UINT16 src = LOAD_REG16(modrm);
-		STORE_RM16(modrm, dst + src);
 		STORE_REG16(modrm, dst);
+		STORE_RM16(modrm, dst + src);
 		CYCLES(cpustate,CYCLES_XADD_REG_REG);
 	} else {
 		UINT32 ea = GetEA(cpustate,modrm,1);
@@ -188,8 +188,8 @@
 	if( modrm >= 0xc0 ) {
 		UINT32 dst = LOAD_RM32(modrm);
 		UINT32 src = LOAD_REG32(modrm);
-		STORE_RM32(modrm, dst + src);
 		STORE_REG32(modrm, dst);
+		STORE_RM32(modrm, dst + src);
 		CYCLES(cpustate,CYCLES_XADD_REG_REG);
 	} else {
 		UINT32 ea = GetEA(cpustate,modrm,1);
diff -Nru src-old/emu/cpu/i386/x87ops.c src/emu/cpu/i386/x87ops.c
--- src-old/emu/cpu/i386/x87ops.c	2012-02-11 09:13:49.000000000 +0100
+++ src/emu/cpu/i386/x87ops.c	2012-03-09 22:54:29.000000000 +0100
@@ -292,8 +292,13 @@
 
 	if ((cpustate->x87_sw & ~cpustate->x87_cw) & 0x3f)
 	{
-		// TODO
-		fatalerror("Unimplemented: unmasked x87 exception (CW:%.4x, SW:%.4x)", cpustate->x87_cw, cpustate->x87_sw);
+		// device_set_input_line(cpustate->device, INPUT_LINE_FERR, RAISE_LINE);
+		logerror("Unmasked x87 exception (CW:%.4x, SW:%.4x)\n", cpustate->x87_cw, cpustate->x87_sw);
+		if (cpustate->cr[0] & 0x20) // FIXME: 486 and up only
+		{
+			cpustate->ext = 1;
+			i386_trap(cpustate, FAULT_MF, 0, 0);
+		}
 		return 0;
 	}
 
@@ -465,6 +470,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -472,7 +478,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -500,6 +505,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -507,7 +513,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -637,6 +642,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -644,7 +650,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -672,6 +677,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -679,7 +685,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -714,6 +719,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -721,7 +727,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -749,6 +754,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -756,7 +762,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -886,6 +891,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -893,7 +899,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -921,6 +926,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -928,7 +934,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -963,6 +968,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -970,7 +976,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = float32_to_floatx80(m32real);
@@ -998,6 +1003,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1005,7 +1011,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = float64_to_floatx80(m64real);
@@ -1135,6 +1140,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1142,7 +1148,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = int32_to_floatx80(m32int);
@@ -1170,6 +1175,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1177,7 +1183,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = int32_to_floatx80(m16int);
@@ -1212,6 +1217,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1219,7 +1225,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1247,6 +1252,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1254,7 +1260,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1388,6 +1393,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1395,7 +1401,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1423,6 +1428,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1430,7 +1436,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1465,6 +1470,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1472,7 +1478,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = float32_to_floatx80(m32real);
@@ -1500,6 +1505,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1507,7 +1513,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = float64_to_floatx80(m64real);
@@ -1642,6 +1647,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1649,7 +1655,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = int32_to_floatx80(m32int);
@@ -1677,6 +1682,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1684,7 +1690,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ32(cpustate, ea);
 
 		floatx80 a = int32_to_floatx80(m16int);
@@ -1719,6 +1724,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1726,7 +1732,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1753,6 +1758,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1760,7 +1766,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1886,6 +1891,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1893,7 +1899,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -1920,6 +1925,7 @@
 {
 	floatx80 result;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -1927,7 +1933,6 @@
 	}
 	else
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -2332,9 +2337,9 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (x87_dec_stack(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		value = float32_to_floatx80(m32real);
@@ -2362,9 +2367,9 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (x87_dec_stack(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		value = float64_to_floatx80(m64real);
@@ -2392,10 +2397,10 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (x87_dec_stack(cpustate))
 	{
 		cpustate->x87_sw &= ~X87_SW_C1;
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		value = READ80(cpustate, ea);
 	}
 	else
@@ -2433,6 +2438,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (!x87_dec_stack(cpustate))
 	{
 		value = fx80_inan;
@@ -2441,7 +2447,6 @@
 	{
 		cpustate->x87_sw &= ~X87_SW_C1;
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 		value = int32_to_floatx80(m16int);
 	}
@@ -2456,6 +2461,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (!x87_dec_stack(cpustate))
 	{
 		value = fx80_inan;
@@ -2464,7 +2470,6 @@
 	{
 		cpustate->x87_sw &= ~X87_SW_C1;
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 		value = int32_to_floatx80(m32int);
 	}
@@ -2479,6 +2484,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (!x87_dec_stack(cpustate))
 	{
 		value = fx80_inan;
@@ -2487,7 +2493,6 @@
 	{
 		cpustate->x87_sw &= ~X87_SW_C1;
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT64 m64int = READ64(cpustate, ea);
 		value = int64_to_floatx80(m64int);
 	}
@@ -2502,6 +2507,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (!x87_dec_stack(cpustate))
 	{
 		value = fx80_inan;
@@ -2510,7 +2516,6 @@
 	{
 		cpustate->x87_sw &= ~X87_SW_C1;
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64val = 0;
 		UINT16 sign;
 
@@ -2547,6 +2552,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -2561,7 +2567,6 @@
 	if (x87_check_exceptions(cpustate))
 	{
 		UINT32 m32real = floatx80_to_float32(value);
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE32(cpustate, ea, m32real);
 	}
 
@@ -2572,6 +2577,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -2586,7 +2592,6 @@
 	if (x87_check_exceptions(cpustate))
 	{
 		UINT64 m64real = floatx80_to_float64(value);
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE64(cpustate, ea, m64real);
 	}
 
@@ -2619,6 +2624,7 @@
 {
 	floatx80 value;
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -2633,7 +2639,6 @@
 	if (x87_check_exceptions(cpustate))
 	{
 		UINT32 m32real = floatx80_to_float32(value);
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE32(cpustate, ea, m32real);
 		x87_inc_stack(cpustate);
 	}
@@ -2657,10 +2662,10 @@
 	}
 
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
 		UINT64 m64real = floatx80_to_float64(value);
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE64(cpustate, ea, m64real);
 		x87_inc_stack(cpustate);
 	}
@@ -2683,9 +2688,9 @@
 		value = ST(0);
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE80(cpustate, ea, value);
 		x87_inc_stack(cpustate);
 	}
@@ -2742,9 +2747,9 @@
 			m16int = -32768;
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE16(cpustate, ea, m16int);
 	}
 
@@ -2775,9 +2780,9 @@
 			m32int = 0x80000000;
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE32(cpustate, ea, m32int);
 	}
 
@@ -2808,9 +2813,9 @@
 			m16int = (UINT16)0x8000;
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE16(cpustate, ea, m16int);
 		x87_inc_stack(cpustate);
 	}
@@ -2842,9 +2847,9 @@
 			m32int = 0x80000000;
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE32(cpustate, ea, m32int);
 		x87_inc_stack(cpustate);
 	}
@@ -2876,9 +2881,9 @@
 			m64int = U64(0x8000000000000000);
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE64(cpustate, ea, m64int);
 		x87_inc_stack(cpustate);
 	}
@@ -2911,9 +2916,9 @@
 		result.high |= ST(0).high & 0x8000;
 	}
 
+	UINT32 ea = GetEA(cpustate, modrm, 1);
 	if (x87_check_exceptions(cpustate))
 	{
-		UINT32 ea = GetEA(cpustate, modrm, 1);
 		WRITE80(cpustate, ea, result);
 		x87_inc_stack(cpustate);
 	}
@@ -3385,6 +3390,7 @@
 
 void x87_ficom_m16int(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3394,7 +3400,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3422,6 +3427,7 @@
 
 void x87_ficom_m32int(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3431,7 +3437,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3459,6 +3464,7 @@
 
 void x87_ficomp_m16int(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3468,7 +3474,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT16 m16int = READ16(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3497,6 +3502,7 @@
 
 void x87_ficomp_m32int(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3506,7 +3512,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		INT32 m32int = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3536,6 +3541,7 @@
 
 void x87_fcom_m32real(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3545,7 +3551,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3573,6 +3578,7 @@
 
 void x87_fcom_m64real(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3582,7 +3588,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3646,6 +3651,7 @@
 
 void x87_fcomp_m32real(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3655,7 +3661,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT32 m32real = READ32(cpustate, ea);
 
 		floatx80 a = ST(0);
@@ -3684,6 +3689,7 @@
 
 void x87_fcomp_m64real(i386_state *cpustate, UINT8 modrm)
 {
+	UINT32 ea = GetEA(cpustate, modrm, 0);
 	if (X87_IS_ST_EMPTY(0))
 	{
 		x87_set_stack_underflow(cpustate);
@@ -3693,7 +3699,6 @@
 	{
 		cpustate->x87_sw &= ~(X87_SW_C3 | X87_SW_C2 | X87_SW_C1 | X87_SW_C0);
 
-		UINT32 ea = GetEA(cpustate, modrm, 0);
 		UINT64 m64real = READ64(cpustate, ea);
 
 		floatx80 a = ST(0);
diff -Nru src-old/emu/cpu/lr35902/lr35902.c src/emu/cpu/lr35902/lr35902.c
--- src-old/emu/cpu/lr35902/lr35902.c	2012-02-25 22:22:21.000000000 +0100
+++ src/emu/cpu/lr35902/lr35902.c	2012-03-11 18:17:00.000000000 +0100
@@ -41,98 +41,144 @@
 #include "debugger.h"
 #include "lr35902.h"
 
-#define FLAG_Z	0x80
-#define FLAG_N  0x40
-#define FLAG_H  0x20
-#define FLAG_C  0x10
-
-#define CYCLES_PASSED(X)		cpustate->icount -= ((X) / (cpustate->gb_speed));	\
-					if ( cpustate->timer_expired_func ) {			\
-						cpustate->timer_expired_func( cpustate->device, X );		\
-					}
 
-typedef struct _lr35902_state {
-	UINT8 A;
-	UINT8 F;
-	UINT8 B;
-	UINT8 C;
-	UINT8 D;
-	UINT8 E;
-	UINT8 H;
-	UINT8 L;
-
-	UINT16 SP;
-	UINT16 PC;
-	/* Interrupt related */
-	UINT8	IE;
-	UINT8	IF;
-	int	irq_state;
-	int	ei_delay;
-	device_irq_callback irq_callback;
-	legacy_cpu_device *device;
-	address_space *program;
-	int icount;
-	/* Timer stuff */
-	lr35902_timer_fired_func timer_expired_func;
-	/* Fetch & execute related */
-	int		execution_state;
-	UINT8	op;
-	/* Others */
-	int gb_speed;
-	int gb_speed_change_pending;
-	int enable;
-	int doHALTbug;
-	UINT8	features;
-	const lr35902_cpu_core *config;
-} lr35902_state;
-
-INLINE lr35902_state *get_safe_token(device_t *device)
-{
-	assert(device != NULL);
-	assert(device->type() == LR35902);
-	return (lr35902_state *)downcast<legacy_cpu_device *>(device)->token();
+#define IME     0x01
+#define HALTED  0x02
+
+
+//**************************************************************************
+//  LR35902 DEVICE
+//**************************************************************************
+
+const device_type LR35902 = &device_creator<lr35902_cpu_device>;
+
+
+lr35902_cpu_device::lr35902_cpu_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: cpu_device(mconfig, LR35902, "LR35902", tag, owner, clock),
+	 m_program_config("program", ENDIANNESS_LITTLE, 8, 16, 0)
+{
+	c_regs = NULL;
+	c_features = 0;
+	c_timer_expired_func = NULL;
 }
 
-typedef int (*OpcodeEmulator) (lr35902_state *cpustate);
 
-#define IME     0x01
-#define HALTED	0x02
+void lr35902_cpu_device::static_set_config(device_t &device, const lr35902_config &config)
+{
+	lr35902_cpu_device &conf = downcast<lr35902_cpu_device &>(device);
+	static_cast<lr35902_config &>(conf) = config;
+}
+
 
 /****************************************************************************/
 /* Memory functions                                                         */
 /****************************************************************************/
 
-#define mem_ReadByte(cs,A)		((UINT8)(cs)->program->read_byte(A)); CYCLES_PASSED(4);
-#define mem_WriteByte(cs,A,V)	((cs)->program->write_byte(A,V)); CYCLES_PASSED(4);
+inline void lr35902_cpu_device::cycles_passed(UINT8 cycles)
+{
+	m_icount -= cycles / m_gb_speed;
+	if ( m_timer_expired_func )
+	{
+		m_timer_expired_func( this, cycles );
+	}
+}
 
-INLINE UINT8 mem_ReadOp(lr35902_state *cpustate)
+
+inline UINT8 lr35902_cpu_device::mem_read_byte( UINT16 addr )
+{
+	UINT8 data = m_program->read_byte( addr );
+	cycles_passed( 4 );
+	return data;
+}
+
+
+inline void lr35902_cpu_device::mem_write_byte( UINT16 addr, UINT8 data )
 {
-	UINT8 r = mem_ReadByte (cpustate, cpustate->PC++);
-	return r;
+	m_program->write_byte( addr, data );
+	cycles_passed( 4 );
 }
 
-INLINE UINT16 mem_ReadWord (lr35902_state *cpustate, UINT32 address)
+
+inline UINT16 lr35902_cpu_device::mem_read_word( UINT16 addr )
 {
-	UINT16 value = mem_ReadByte (cpustate, (address + 1) & 0xffff);
-	value <<= 8;
-	value |= mem_ReadByte (cpustate, address);
-	return value;
+	UINT16 data = mem_read_byte( addr );
+	data |= ( mem_read_byte( addr + 1 ) << 8 );
+	return data;
 }
 
-INLINE void mem_WriteWord (lr35902_state *cpustate, UINT32 address, UINT16 value)
+
+inline void lr35902_cpu_device::mem_write_word( UINT16 addr, UINT16 data )
 {
-	mem_WriteByte (cpustate, address, value & 0xFF);
-	mem_WriteByte (cpustate, (address + 1) & 0xffff, value >> 8);
+	mem_write_byte( addr, data & 0xFF );
+	mem_write_byte( addr + 1, data >> 8 );
 }
 
-static CPU_INIT( lr35902 )
+
+void lr35902_cpu_device::device_start()
 {
-	lr35902_state *cpustate = get_safe_token(device);
+	m_device = this;
+	m_program = this->space(AS_PROGRAM);
 
-	cpustate->config = (const lr35902_cpu_core *) device->static_config();
-	cpustate->irq_callback = irqcallback;
-	cpustate->device = device;
-	cpustate->program = device->space(AS_PROGRAM);
+	save_item(NAME(m_A));
+	save_item(NAME(m_F));
+	save_item(NAME(m_B));
+	save_item(NAME(m_C));
+	save_item(NAME(m_D));
+	save_item(NAME(m_E));
+	save_item(NAME(m_H));
+	save_item(NAME(m_L));
+	save_item(NAME(m_PC));
+	save_item(NAME(m_SP));
+	save_item(NAME(m_IE));
+	save_item(NAME(m_IF));
+	save_item(NAME(m_irq_state));
+	save_item(NAME(m_ei_delay));
+	save_item(NAME(m_execution_state));
+	save_item(NAME(m_op));
+	save_item(NAME(m_gb_speed));
+	save_item(NAME(m_gb_speed_change_pending));
+	save_item(NAME(m_enable));
+	save_item(NAME(m_doHALTbug));
+
+	// Register state for debugger
+	state_add( LR35902_PC, "PC", m_PC ).callimport().callexport().formatstr("%04X");
+	state_add( LR35902_SP, "SP", m_SP ).callimport().callexport().formatstr("%04X");
+	state_add( LR35902_A,  "A",  m_A  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_F,  "F",  m_F  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_B,  "B",  m_B  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_C,  "C",  m_C  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_D,  "D",  m_D  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_E,  "E",  m_E  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_H,  "H",  m_H  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_L,  "L",  m_L  ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_IRQ_STATE, "IRQ", m_enable ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_IE, "IE", m_IE ).callimport().callexport().formatstr("%02X");
+	state_add( LR35902_IF, "IF", m_IF ).callimport().callexport().formatstr("%02X");
+
+	state_add(STATE_GENPC, "curpc", m_PC).callimport().callexport().formatstr("%8s").noshow();
+	state_add(STATE_GENFLAGS, "GENFLAGS",  m_F).mask(0xf0).formatstr("%8s").noshow();
+
+	m_icountptr = &m_icount;
+}
+
+
+void lr35902_cpu_device::state_string_export(const device_state_entry &entry, astring &string)
+{
+	switch (entry.index())
+	{
+		case LR35902_SPEED:
+			string.printf("%02X", 0x7E | ( ( m_gb_speed - 1 ) << 7 ) | m_gb_speed_change_pending );
+			break;
+
+		case STATE_GENFLAGS:
+			string.printf("%c%c%c%c",
+				m_F & FLAG_Z   ? 'Z' : '.',
+				m_F & FLAG_N   ? 'N' : '.',
+				m_F & FLAG_H   ? 'H' : '.',
+				m_F & FLAG_C   ? 'C' : '.'
+			);
+			break;
+	}
 }
 
 /*** Reset lr353902 registers: ******************************/
@@ -140,64 +186,68 @@
 /*** file before starting execution with lr35902_execute(cpustate)***/
 /*** It sets the registers to their initial values.       ***/
 /************************************************************/
-static CPU_RESET( lr35902 )
+void lr35902_cpu_device::device_reset()
 {
-	lr35902_state *cpustate = get_safe_token(device);
-
-	cpustate->A = 0x00;
-	cpustate->F = 0x00;
-	cpustate->B = 0x00;
-	cpustate->C = 0x00;
-	cpustate->D = 0x00;
-	cpustate->E = 0x00;
-	cpustate->H = 0x00;
-	cpustate->L = 0x00;
-	cpustate->SP = 0x0000;
-	cpustate->PC = 0x0000;
-	cpustate->timer_expired_func = NULL;
-	cpustate->features = LR35902_FEATURE_HALT_BUG;
-	if (cpustate->config)
-	{
-		if ( cpustate->config->regs ) {
-			cpustate->A = cpustate->config->regs[0] >> 8;
-			cpustate->F = cpustate->config->regs[0] & 0xFF;
-			cpustate->B = cpustate->config->regs[1] >> 8;
-			cpustate->C = cpustate->config->regs[1] & 0xFF;
-			cpustate->D = cpustate->config->regs[2] >> 8;
-			cpustate->E = cpustate->config->regs[2] & 0xFF;
-			cpustate->H = cpustate->config->regs[3] >> 8;
-			cpustate->L = cpustate->config->regs[3] & 0xFF;
-			cpustate->SP = cpustate->config->regs[4];
-			cpustate->PC = cpustate->config->regs[5];
-		}
-		cpustate->timer_expired_func = cpustate->config->timer_expired_func;
-		cpustate->features = cpustate->config->features;
+	m_A = 0x00;
+	m_F = 0x00;
+	m_B = 0x00;
+	m_C = 0x00;
+	m_D = 0x00;
+	m_E = 0x00;
+	m_H = 0x00;
+	m_L = 0x00;
+	m_SP = 0x0000;
+	m_PC = 0x0000;
+	m_timer_expired_func = NULL;
+	m_features = LR35902_FEATURE_HALT_BUG;
+	if ( c_regs ) {
+		m_A = c_regs[0] >> 8;
+		m_F = c_regs[0] & 0xFF;
+		m_B = c_regs[1] >> 8;
+		m_C = c_regs[1] & 0xFF;
+		m_D = c_regs[2] >> 8;
+		m_E = c_regs[2] & 0xFF;
+		m_H = c_regs[3] >> 8;
+		m_L = c_regs[3] & 0xFF;
+		m_SP = c_regs[4];
+		m_PC = c_regs[5];
 	}
-	cpustate->enable = 0;
-	cpustate->IE = 0;
-	cpustate->IF = 0;
+	m_timer_expired_func = c_timer_expired_func;
+	m_features = c_features;
+
+	m_enable = 0;
+	m_IE = 0;
+	m_IF = 0;
 
-	cpustate->execution_state = 0;
-	cpustate->doHALTbug = 0;
-	cpustate->ei_delay = 0;
-	cpustate->gb_speed_change_pending = 0;
-	cpustate->gb_speed = 1;
+	m_execution_state = 0;
+	m_doHALTbug = 0;
+	m_ei_delay = 0;
+	m_gb_speed_change_pending = 0;
+	m_gb_speed = 1;
 }
 
-INLINE void lr35902_ProcessInterrupts (lr35902_state *cpustate)
+
+offs_t lr35902_cpu_device::disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options)
 {
-	UINT8 irq = cpustate->IE & cpustate->IF;
+	extern CPU_DISASSEMBLE( lr35902 );
+	return CPU_DISASSEMBLE_NAME( lr35902 )(NULL, buffer, pc, oprom, opram, 0);
+}
+
+
+void lr35902_cpu_device::check_interrupts()
+{
+	UINT8 irq = m_IE & m_IF;
 
 	/* Interrupts should be taken after the first instruction after an EI instruction */
-	if (cpustate->ei_delay) {
-		cpustate->ei_delay = 0;
+	if (m_ei_delay) {
+		m_ei_delay = 0;
 		return;
 	}
 
 	/*
        logerror("Attempting to process LR35902 Interrupt IRQ $%02X\n", irq);
-       logerror("Attempting to process LR35902 Interrupt IE $%02X\n", cpustate->IE);
-       logerror("Attempting to process LR35902 Interrupt IF $%02X\n", cpustate->IF);
+       logerror("Attempting to process LR35902 Interrupt IE $%02X\n", m_IE);
+       logerror("Attempting to process LR35902 Interrupt IF $%02X\n", m_IF);
     */
 	if (irq)
 	{
@@ -210,34 +260,32 @@
 		{
 			if( irq & (1<<irqline) )
 			{
-				if (cpustate->enable & HALTED)
+				if (m_enable & HALTED)
 				{
-					cpustate->enable &= ~HALTED;
-					cpustate->PC++;
-					if ( cpustate->features & LR35902_FEATURE_HALT_BUG ) {
-						if ( ! ( cpustate->enable & IME ) ) {
+					m_enable &= ~HALTED;
+					m_PC++;
+					if ( m_features & LR35902_FEATURE_HALT_BUG ) {
+						if ( ! ( m_enable & IME ) ) {
 							/* Old cpu core (dmg/mgb/sgb) */
-							cpustate->doHALTbug = 1;
+							m_doHALTbug = 1;
 						}
 					} else {
 						/* New cpu core (cgb/agb/ags) */
 						/* Adjust for internal syncing with video core */
 						/* This feature needs more investigation */
 						if ( irqline < 2 ) {
-							CYCLES_PASSED( 4 );
+							cycles_passed( 4 );
 						}
 					}
 				}
-				if ( cpustate->enable & IME ) {
-					if ( cpustate->irq_callback )
-						(*cpustate->irq_callback)(cpustate->device, irqline);
-					cpustate->enable &= ~IME;
-					cpustate->IF &= ~(1 << irqline);
-					CYCLES_PASSED( 12 );
-					cpustate->SP -= 2;
-					mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-					cpustate->PC = 0x40 + irqline * 8;
-					/*logerror("LR35902 Interrupt PC $%04X\n", cpustate->PC );*/
+				if ( m_enable & IME ) {
+					m_enable &= ~IME;
+					m_IF &= ~(1 << irqline);
+					cycles_passed( 12 );
+					m_SP -= 2;
+					mem_write_word( m_SP, m_PC );
+					m_PC = 0x40 + irqline * 8;
+					/*logerror("LR35902 Interrupt PC $%04X\n", m_PC );*/
 					return;
 				}
 			}
@@ -245,198 +293,63 @@
 	}
 }
 
+
 /************************************************************/
 /*** Execute lr35902 code for cycles cycles, return nr of ***/
 /*** cycles actually executed.                            ***/
 /************************************************************/
-static CPU_EXECUTE( lr35902 )
+void lr35902_cpu_device::execute_run()
 {
-	lr35902_state *cpustate = get_safe_token(device);
-
 	do
 	{
-		if ( cpustate->execution_state ) {
+		if ( m_execution_state ) {
 			UINT8	x;
 			/* Execute instruction */
-			switch( cpustate->op ) {
+			switch( m_op ) {
 #include "opc_main.h"
 			}
 		} else {
 			/* Fetch and count cycles */
-			lr35902_ProcessInterrupts (cpustate);
-			debugger_instruction_hook(device, cpustate->PC);
-			if ( cpustate->enable & HALTED ) {
-				CYCLES_PASSED( 4 );
-				cpustate->execution_state = 1;
+			check_interrupts();
+			debugger_instruction_hook(this, m_PC);
+			if ( m_enable & HALTED ) {
+				cycles_passed( 4 );
+				m_execution_state = 1;
 			} else {
-				cpustate->op = mem_ReadOp (cpustate);
-				if ( cpustate->doHALTbug ) {
-					cpustate->PC--;
-					cpustate->doHALTbug = 0;
+				m_op = mem_read_byte( m_PC++ );
+				if ( m_doHALTbug ) {
+					m_PC--;
+					m_doHALTbug = 0;
 				}
 			}
 		}
-		cpustate->execution_state ^= 1;
-	} while (cpustate->icount > 0);
+		m_execution_state ^= 1;
+	} while (m_icount > 0);
 }
 
-static CPU_BURN( lr35902 )
-{
-	lr35902_state *cpustate = get_safe_token(device);
-
-    if( cycles > 0 )
-    {
-        /* NOP takes 4 cycles per instruction */
-        int n = (cycles + 3) / 4;
-        cpustate->icount -= 4 * n;
-    }
-}
 
-static void lr35902_set_irq_line (lr35902_state *cpustate, int irqline, int state)
+void lr35902_cpu_device::execute_set_input( int inptnum, int state )
 {
-	/*logerror("setting irq line 0x%02x state 0x%08x\n", irqline, state);*/
-	//if( cpustate->irq_state == state )
-	//  return;
-
-	cpustate->irq_state = state;
+	m_irq_state = state;
 	if( state == ASSERT_LINE )
 	{
-
-		cpustate->IF |= (0x01 << irqline);
-		/*logerror("LR35902 assert irq line %d ($%02X)\n", irqline, cpustate->IF);*/
-
+		m_IF |= (0x01 << inptnum);
 	}
 	else
 	{
-
-		cpustate->IF &= ~(0x01 << irqline);
-		/*logerror("LR35902 clear irq line %d ($%02X)\n", irqline, cpustate->IF);*/
-
+		m_IF &= ~(0x01 << inptnum);
 	}
 }
 
-#ifdef UNUSED_FUNCTION
-static void lr35902_clear_pending_interrupts (lr35902_state *cpustate)
-{
-    cpustate->IF = 0;
-}
-#endif
 
-static CPU_SET_INFO( lr35902 )
+UINT8 lr35902_cpu_device::get_speed()
 {
-	lr35902_state *cpustate = get_safe_token(device);
-
-	switch (state)
-	{
-	/* --- the following bits of info are set as 64-bit signed integers --- */
-	case CPUINFO_INT_INPUT_STATE + 0:
-	case CPUINFO_INT_INPUT_STATE + 1:
-	case CPUINFO_INT_INPUT_STATE + 2:
-	case CPUINFO_INT_INPUT_STATE + 3:
-	case CPUINFO_INT_INPUT_STATE + 4:			lr35902_set_irq_line(cpustate, state-CPUINFO_INT_INPUT_STATE, info->i); break;
-
-	case CPUINFO_INT_SP:						cpustate->SP = info->i;						break;
-	case CPUINFO_INT_PC:						cpustate->PC = info->i;						break;
-
-	case CPUINFO_INT_REGISTER + LR35902_PC:		cpustate->PC = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_SP:		cpustate->SP = info->i;						break;
-	case CPUINFO_INT_REGISTER + LR35902_AF:		cpustate->A = info->i >> 8; cpustate->F = info->i & 0xFF;		break;
-	case CPUINFO_INT_REGISTER + LR35902_BC:		cpustate->B = info->i >> 8; cpustate->C = info->i & 0xFF;		break;
-	case CPUINFO_INT_REGISTER + LR35902_DE:		cpustate->D = info->i >> 8; cpustate->E = info->i & 0xFF;		break;
-	case CPUINFO_INT_REGISTER + LR35902_HL:		cpustate->H = info->i >> 8; cpustate->L = info->i & 0xFF;		break;
-	case CPUINFO_INT_REGISTER + LR35902_IE:		cpustate->IE = info->i; break;
-	case CPUINFO_INT_REGISTER + LR35902_IF:		cpustate->IF = info->i; break;
-	case CPUINFO_INT_REGISTER + LR35902_SPEED:	cpustate->gb_speed_change_pending = info->i & 0x01; break;
-	}
+	return 0x7E | ( ( m_gb_speed - 1 ) << 7 ) | m_gb_speed_change_pending;
 }
 
-CPU_GET_INFO( lr35902 )
-{
-	lr35902_state *cpustate = (device != NULL && device->token() != NULL) ? get_safe_token(device) : NULL;
 
-	switch (state)
-	{
-	/* --- the following bits of info are returned as 64-bit signed integers --- */
-	case CPUINFO_INT_CONTEXT_SIZE:					info->i = sizeof(lr35902_state);					break;
-	case CPUINFO_INT_INPUT_LINES:						info->i = 5;							break;
-	case CPUINFO_INT_DEFAULT_IRQ_VECTOR:			info->i = 0xff;							break;
-	case DEVINFO_INT_ENDIANNESS:					info->i = ENDIANNESS_LITTLE;					break;
-	case CPUINFO_INT_CLOCK_MULTIPLIER:				info->i = 1;							break;
-	case CPUINFO_INT_CLOCK_DIVIDER:					info->i = 1;							break;
-	case CPUINFO_INT_MIN_INSTRUCTION_BYTES:			info->i = 1;							break;
-	case CPUINFO_INT_MAX_INSTRUCTION_BYTES:			info->i = 4;							break;
-	case CPUINFO_INT_MIN_CYCLES:					info->i = 1;	/* right? */			break;
-	case CPUINFO_INT_MAX_CYCLES:					info->i = 16;	/* right? */			break;
-
-	case DEVINFO_INT_DATABUS_WIDTH + AS_PROGRAM:	info->i = 8;					break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_PROGRAM: info->i = 16;					break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_PROGRAM: info->i = 0;					break;
-	case DEVINFO_INT_DATABUS_WIDTH + AS_DATA:	info->i = 0;					break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_DATA:	info->i = 0;					break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_DATA:	info->i = 0;					break;
-	case DEVINFO_INT_DATABUS_WIDTH + AS_IO:		info->i = 8;					break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_IO:		info->i = 16;					break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_IO:		info->i = 0;					break;
-
-	case CPUINFO_INT_SP:							info->i = cpustate->SP;					break;
-	case CPUINFO_INT_PC:							info->i = cpustate->PC;					break;
-	case CPUINFO_INT_PREVIOUSPC:					info->i = 0;	/* TODO??? */			break;
-
-	case CPUINFO_INT_INPUT_STATE + 0:
-	case CPUINFO_INT_INPUT_STATE + 1:
-	case CPUINFO_INT_INPUT_STATE + 2:
-	case CPUINFO_INT_INPUT_STATE + 3:
-	case CPUINFO_INT_INPUT_STATE + 4:					info->i = cpustate->IF & (1 << (state-CPUINFO_INT_INPUT_STATE)); break;
-
-	case CPUINFO_INT_REGISTER + LR35902_PC:			info->i = cpustate->PC;					break;
-	case CPUINFO_INT_REGISTER + LR35902_SP:			info->i = cpustate->SP;					break;
-	case CPUINFO_INT_REGISTER + LR35902_AF:			info->i = ( cpustate->A << 8 ) | cpustate->F;					break;
-	case CPUINFO_INT_REGISTER + LR35902_BC:			info->i = ( cpustate->B << 8 ) | cpustate->C;					break;
-	case CPUINFO_INT_REGISTER + LR35902_DE:			info->i = ( cpustate->D << 8 ) | cpustate->E;					break;
-	case CPUINFO_INT_REGISTER + LR35902_HL:			info->i = ( cpustate->H << 8 ) | cpustate->L;					break;
-	case CPUINFO_INT_REGISTER + LR35902_IE:			info->i = cpustate->IE;					break;
-	case CPUINFO_INT_REGISTER + LR35902_IF:			info->i = cpustate->IF;					break;
-	case CPUINFO_INT_REGISTER + LR35902_SPEED:		info->i = 0x7E | ( ( cpustate->gb_speed - 1 ) << 7 ) | cpustate->gb_speed_change_pending; break;
-
-	/* --- the following bits of info are returned as pointers to data or functions --- */
-	case CPUINFO_FCT_SET_INFO:						info->setinfo = CPU_SET_INFO_NAME(lr35902);		break;
-	case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(lr35902);				break;
-	case CPUINFO_FCT_RESET:							info->reset = CPU_RESET_NAME(lr35902);			break;
-	case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(lr35902);		break;
-	case CPUINFO_FCT_BURN:							info->burn = CPU_BURN_NAME(lr35902);				break;
-	case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(lr35902);		break;
-	case CPUINFO_PTR_INSTRUCTION_COUNTER:			info->icount = &cpustate->icount;			break;
-
-	/* --- the following bits of info are returned as NULL-terminated strings --- */
-	case DEVINFO_STR_NAME:							strcpy(info->s, "LR35902"); break;
-	case DEVINFO_STR_FAMILY:					strcpy(info->s, "Sharp LR35902"); break;
-	case DEVINFO_STR_VERSION:					strcpy(info->s, "1.4"); break;
-	case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__); break;
-	case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright The MESS Team."); break;
-
-	case CPUINFO_STR_FLAGS:
-		sprintf(info->s, "%c%c%c%c%c%c%c%c",
-			cpustate->F & 0x80 ? 'Z':'.',
-			cpustate->F & 0x40 ? 'N':'.',
-			cpustate->F & 0x20 ? 'H':'.',
-			cpustate->F & 0x10 ? 'C':'.',
-			cpustate->F & 0x08 ? '3':'.',
-			cpustate->F & 0x04 ? '2':'.',
-			cpustate->F & 0x02 ? '1':'.',
-			cpustate->F & 0x01 ? '0':'.');
-		break;
-
-	case CPUINFO_STR_REGISTER + LR35902_PC: sprintf(info->s, "PC:%04X", cpustate->PC); break;
-	case CPUINFO_STR_REGISTER + LR35902_SP: sprintf(info->s, "SP:%04X", cpustate->SP); break;
-	case CPUINFO_STR_REGISTER + LR35902_AF: sprintf(info->s, "AF:%02X%02X", cpustate->A, cpustate->F); break;
-	case CPUINFO_STR_REGISTER + LR35902_BC: sprintf(info->s, "BC:%02X%02X", cpustate->B, cpustate->C); break;
-	case CPUINFO_STR_REGISTER + LR35902_DE: sprintf(info->s, "DE:%02X%02X", cpustate->D, cpustate->E); break;
-	case CPUINFO_STR_REGISTER + LR35902_HL: sprintf(info->s, "HL:%02X%02X", cpustate->H, cpustate->L); break;
-	case CPUINFO_STR_REGISTER + LR35902_IRQ_STATE: sprintf(info->s, "IRQ:%X", cpustate->enable & IME ); break;
-	case CPUINFO_STR_REGISTER + LR35902_IE: sprintf(info->s, "IE:%02X", cpustate->IE); break;
-	case CPUINFO_STR_REGISTER + LR35902_IF: sprintf(info->s, "IF:%02X", cpustate->IF); break;
-	case CPUINFO_STR_REGISTER + LR35902_SPEED: sprintf(info->s, "SPD:%02x", 0x7E | ( ( cpustate->gb_speed - 1 ) << 7 ) | cpustate->gb_speed_change_pending ); break;
-	}
+void lr35902_cpu_device::set_speed( UINT8 speed_request )
+{
+	m_gb_speed_change_pending = speed_request & 0x01;
 }
 
-DEFINE_LEGACY_CPU_DEVICE(LR35902, lr35902);
diff -Nru src-old/emu/cpu/lr35902/lr35902.h src/emu/cpu/lr35902/lr35902.h
--- src-old/emu/cpu/lr35902/lr35902.h	2011-02-06 08:15:01.000000000 +0100
+++ src/emu/cpu/lr35902/lr35902.h	2012-02-26 21:36:24.000000000 +0100
@@ -4,19 +4,24 @@
 #define __LR35902_H__
 
 
-typedef void (*lr35902_timer_fired_func)(device_t *device, int cycles);
+#define MCFG_LR35902_CONFIG(_config) \
+	lr35902_cpu_device::static_set_config(*device, _config);
 
-typedef struct _lr35902_cpu_core lr35902_cpu_core;
-struct _lr35902_cpu_core
+class lr35902_cpu_device;
+
+// Perhaps replace this with a standard device callback
+typedef void (*lr35902_timer_fired_func)(lr35902_cpu_device *device, int cycles);
+
+struct lr35902_config
 {
-	const UINT16	*regs;
-	UINT8			features;
-	lr35902_timer_fired_func timer_expired_func;
+	const UINT16	*c_regs;
+	UINT8			c_features;
+	lr35902_timer_fired_func c_timer_expired_func;
 };
 
 enum
 {
-	LR35902_PC=1, LR35902_SP, LR35902_AF, LR35902_BC, LR35902_DE, LR35902_HL,
+	LR35902_PC=1, LR35902_SP, LR35902_A, LR35902_F, LR35902_B, LR35902_C, LR35902_D, LR35902_E, LR35902_H, LR35902_L,
 	LR35902_IRQ_STATE,
 	/* Pseudo registers to keep track of the interrupt statuses */
 	LR35902_IE, LR35902_IF,
@@ -24,13 +29,100 @@
 	LR35902_SPEED,
 };
 
+// This and the features configuration could be removed if we introduce proper subclasses
 #define LR35902_FEATURE_HALT_BUG	0x01
 
-/****************************************************************************/
-/* Return register contents                                                 */
-/****************************************************************************/
-DECLARE_LEGACY_CPU_DEVICE(LR35902, lr35902);
 
-extern CPU_DISASSEMBLE( lr35902 );
+class lr35902_cpu_device :	public cpu_device,
+							public lr35902_config
+{
+public:
+	// construction/destruction
+	lr35902_cpu_device(const machine_config &mconfig, const char *_tag, device_t *_owner, UINT32 _clock);
+
+	static void static_set_config(device_t &device, const lr35902_config &config);
+
+	UINT8 get_speed();
+	void set_speed( UINT8 speed_request );
+
+	UINT8 get_ie() { return m_IE; }
+	void set_ie( UINT8 data ) { m_IE = data; }
+
+	UINT8 get_if() { return m_IF; }
+	void set_if( UINT8 data ) { m_IF = data; }
+
+protected:
+	// device-level overrides
+	virtual void device_start();
+	virtual void device_reset();
+
+	// device_execute_interface overrides
+	virtual UINT32 execute_min_cycles() const { return 1; }
+	virtual UINT32 execute_max_cycles() const { return 16; }
+	virtual UINT32 execute_input_lines() const { return 5; }
+	virtual void execute_run();
+	virtual void execute_set_input(int inputnum, int state);
+
+	// device_memory_interface overrides
+	virtual const address_space_config *memory_space_config(address_spacenum spacenum = AS_0) const { return (spacenum == AS_PROGRAM) ? &m_program_config : NULL; }
+
+	// device_state_interface overrides
+	void state_string_export(const device_state_entry &entry, astring &string);
+
+	// device_disasm_interface overrides
+	virtual UINT32 disasm_min_opcode_bytes() const { return 1; }
+	virtual UINT32 disasm_max_opcode_bytes() const { return 4; }
+	virtual offs_t disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options);
+
+	inline void cycles_passed(UINT8 cycles);
+	inline UINT8 mem_read_byte(UINT16 addr);
+	inline void mem_write_byte(UINT16 addr, UINT8 data);
+	inline UINT16 mem_read_word(UINT16 addr);
+	inline void mem_write_word(UINT16 addr, UINT16 data);
+	inline void check_interrupts();
+
+protected:
+	address_space_config m_program_config;
+
+	UINT8 m_A;
+	UINT8 m_F;
+	UINT8 m_B;
+	UINT8 m_C;
+	UINT8 m_D;
+	UINT8 m_E;
+	UINT8 m_H;
+	UINT8 m_L;
+
+	UINT16 m_SP;
+	UINT16 m_PC;
+	/* Interrupt related */
+	UINT8	m_IE;
+	UINT8	m_IF;
+	int	m_irq_state;
+	int	m_ei_delay;
+	lr35902_cpu_device *m_device;
+	address_space *m_program;
+	int m_icount;
+	/* Timer stuff */
+	lr35902_timer_fired_func m_timer_expired_func;
+	/* Fetch & execute related */
+	int		m_execution_state;
+	UINT8	m_op;
+	/* Others */
+	int m_gb_speed;
+	int m_gb_speed_change_pending;
+	int m_enable;
+	int m_doHALTbug;
+	UINT8	m_features;
+	const struct lr35902_config *m_config;
+
+	/* Flag bit definitions */
+	static const UINT8 FLAG_Z = 0x80;
+	static const UINT8 FLAG_N = 0x40;
+	static const UINT8 FLAG_H = 0x20;
+	static const UINT8 FLAG_C = 0x10;
+};
+
+extern const device_type LR35902;
 
 #endif /* __LR35902_H__ */
diff -Nru src-old/emu/cpu/lr35902/opc_cb.h src/emu/cpu/lr35902/opc_cb.h
--- src-old/emu/cpu/lr35902/opc_cb.h	2012-02-25 22:22:21.000000000 +0100
+++ src/emu/cpu/lr35902/opc_cb.h	2012-02-26 21:36:24.000000000 +0100
@@ -8,17 +8,17 @@
 		f=0;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->F=f;			\
+	m_F=f;			\
 }
 
 #define	RL_8BIT(x)				\
 {								\
 	register UINT8 r;			\
 	r=((x)&0x80)?FLAG_C:0;		\
-	(x)=(UINT8)(((x)<<1)|((cpustate->F&FLAG_C)?1:0));	 \
+	(x)=(UINT8)(((x)<<1)|((m_F&FLAG_C)?1:0));	 \
 	if( (x)==0 )				\
 		r|=FLAG_Z;				\
-	cpustate->F=r;			\
+	m_F=r;			\
 }
 
 #define	RRC_8BIT(x)				\
@@ -31,17 +31,17 @@
 		f=0;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->F=f;			\
+	m_F=f;			\
 }
 
 #define	RR_8BIT(x)				\
 {								\
 	register UINT8 r;			\
 	r=((x)&1)?FLAG_C:0;			\
-	(x)=(UINT8)(((x)>>1)|((cpustate->F&FLAG_C)?0x80:0));	 \
+	(x)=(UINT8)(((x)>>1)|((m_F&FLAG_C)?0x80:0));	 \
 	if( (x)==0 )				\
 		r|=FLAG_Z;				\
-	cpustate->F=r;			\
+	m_F=r;			\
 }
 
 #define	SLA_8BIT(x)				\
@@ -54,7 +54,7 @@
 	(x)<<=1;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->F=f;			\
+	m_F=f;			\
 }
 
 #define	SRA_8BIT(x)				\
@@ -67,15 +67,15 @@
 	(x)=(UINT8)(((char)(x))>>1);	 \
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->F=f;			\
+	m_F=f;			\
 }
 
 #define	SWAP_8BIT(x)			\
 	(x)=(UINT8)(((x)>>4)|((x)<<4)); 	 \
 	if( (x)==0 )				\
-		cpustate->F=FLAG_Z;	\
+		m_F=FLAG_Z;	\
 	else						\
-		cpustate->F=0;
+		m_F=0;
 
 
 #define	SRL_8BIT(x)				\
@@ -88,14 +88,14 @@
 	(x)>>=1;					\
 	if( (x)==0 )				\
 		f|=FLAG_Z;				\
-	cpustate->F=f;			\
+	m_F=f;			\
 }
 
 #define	BIT_8BIT(n,x)			\
 	if( (x)&(1<<(n)) )			\
-		cpustate->F=(UINT8)(FLAG_H|(cpustate->F&FLAG_C));  \
+		m_F=(UINT8)(FLAG_H|(m_F&FLAG_C));  \
 	else						\
-		cpustate->F=(UINT8)(FLAG_Z|FLAG_H|(cpustate->F&FLAG_C));
+		m_F=(UINT8)(FLAG_Z|FLAG_H|(m_F&FLAG_C));
 
 #define	RES_8BIT(n,x)	(x)&=~(1<<(n));
 
@@ -105,1432 +105,1432 @@
 case 0x00:
   /*      RLC B */
 
-  RLC_8BIT (cpustate->B)
+  RLC_8BIT (m_B)
   break;
 case 0x01:
   /*      RLC C */
 
-  RLC_8BIT (cpustate->C)
+  RLC_8BIT (m_C)
   break;
 case 0x02:
   /*      RLC D */
 
-  RLC_8BIT (cpustate->D)
+  RLC_8BIT (m_D)
   break;
 case 0x03:
   /*      RLC E */
 
-  RLC_8BIT (cpustate->E)
+  RLC_8BIT (m_E)
   break;
 case 0x04:
   /*      RLC H */
 
-  RLC_8BIT (cpustate->H)
+  RLC_8BIT (m_H)
   break;
 case 0x05:
   /*      RLC L */
 
-  RLC_8BIT (cpustate->L)
+  RLC_8BIT (m_L)
   break;
 case 0x06:
 	/*      RLC (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr );
 		RLC_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x );
 	}
 	break;
 case 0x07:
   /*      RLC A */
 
-  RLC_8BIT (cpustate->A)
+  RLC_8BIT (m_A)
   break;
 case 0x08:
   /*      RRC B */
 
-  RRC_8BIT (cpustate->B)
+  RRC_8BIT (m_B)
   break;
 case 0x09:
   /*      RRC C */
 
-  RRC_8BIT (cpustate->C)
+  RRC_8BIT (m_C)
   break;
 case 0x0A:
   /*      RRC D */
 
-  RRC_8BIT (cpustate->D)
+  RRC_8BIT (m_D)
   break;
 case 0x0B:
   /*      RRC E */
 
-  RRC_8BIT (cpustate->E)
+  RRC_8BIT (m_E)
   break;
 case 0x0C:
   /*      RRC H */
 
-  RRC_8BIT (cpustate->H)
+  RRC_8BIT (m_H)
   break;
 case 0x0D:
   /*      RRC L */
 
-  RRC_8BIT (cpustate->L)
+  RRC_8BIT (m_L)
   break;
 case 0x0E:
 	/*      RRC (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RRC_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x0F:
   /*      RRC A */
 
-  RRC_8BIT (cpustate->A)
+  RRC_8BIT (m_A)
   break;
 case 0x10:
   /*      RL B */
 
-  RL_8BIT (cpustate->B)
+  RL_8BIT (m_B)
   break;
 case 0x11:
   /*      RL C */
 
-  RL_8BIT (cpustate->C)
+  RL_8BIT (m_C)
   break;
 case 0x12:
   /*      RL D */
 
-  RL_8BIT (cpustate->D)
+  RL_8BIT (m_D)
   break;
 case 0x13:
   /*      RL E */
 
-  RL_8BIT (cpustate->E)
+  RL_8BIT (m_E)
   break;
 case 0x14:
   /*      RL H */
 
-  RL_8BIT (cpustate->H)
+  RL_8BIT (m_H)
   break;
 case 0x15:
   /*      RL L */
 
-  RL_8BIT (cpustate->L)
+  RL_8BIT (m_L)
   break;
 case 0x16:
 	/*      RL (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RL_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x17:
   /*      RL A */
 
-  RL_8BIT (cpustate->A)
+  RL_8BIT (m_A)
   break;
 case 0x18:
   /*      RR B */
 
-  RR_8BIT (cpustate->B)
+  RR_8BIT (m_B)
   break;
 case 0x19:
   /*      RR C */
 
-  RR_8BIT (cpustate->C)
+  RR_8BIT (m_C)
   break;
 case 0x1A:
   /*      RR D */
 
-  RR_8BIT (cpustate->D)
+  RR_8BIT (m_D)
   break;
 case 0x1B:
   /*      RR E */
 
-  RR_8BIT (cpustate->E)
+  RR_8BIT (m_E)
   break;
 case 0x1C:
   /*      RR H */
 
-  RR_8BIT (cpustate->H)
+  RR_8BIT (m_H)
   break;
 case 0x1D:
   /*      RR L */
 
-  RR_8BIT (cpustate->L)
+  RR_8BIT (m_L)
   break;
 case 0x1E:
 	/*      RR (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RR_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x1F:
   /*      RR A */
 
-  RR_8BIT (cpustate->A)
+  RR_8BIT (m_A)
   break;
 case 0x20:
   /*      SLA B */
 
-  SLA_8BIT (cpustate->B)
+  SLA_8BIT (m_B)
   break;
 case 0x21:
   /*      SLA C */
 
-  SLA_8BIT (cpustate->C)
+  SLA_8BIT (m_C)
   break;
 case 0x22:
   /*      SLA D */
 
-  SLA_8BIT (cpustate->D)
+  SLA_8BIT (m_D)
   break;
 case 0x23:
   /*      SLA E */
 
-  SLA_8BIT (cpustate->E)
+  SLA_8BIT (m_E)
   break;
 case 0x24:
   /*      SLA H */
 
-  SLA_8BIT (cpustate->H)
+  SLA_8BIT (m_H)
   break;
 case 0x25:
   /*      SLA L */
 
-  SLA_8BIT (cpustate->L)
+  SLA_8BIT (m_L)
   break;
 case 0x26:
 	/*      SLA (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SLA_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x27:
   /*      SLA A */
 
-  SLA_8BIT (cpustate->A)
+  SLA_8BIT (m_A)
   break;
 case 0x28:
   /*      SRA B */
 
-  SRA_8BIT (cpustate->B)
+  SRA_8BIT (m_B)
   break;
 case 0x29:
   /*      SRA C */
 
-  SRA_8BIT (cpustate->C)
+  SRA_8BIT (m_C)
   break;
 case 0x2A:
   /*      SRA D */
 
-  SRA_8BIT (cpustate->D)
+  SRA_8BIT (m_D)
   break;
 case 0x2B:
   /*      SRA E */
 
-  SRA_8BIT (cpustate->E)
+  SRA_8BIT (m_E)
   break;
 case 0x2C:
   /*      SRA H */
 
-  SRA_8BIT (cpustate->H)
+  SRA_8BIT (m_H)
   break;
 case 0x2D:
   /*      SRA L */
 
-  SRA_8BIT (cpustate->L)
+  SRA_8BIT (m_L)
   break;
 case 0x2E:
 	/*      SRA (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SRA_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x2F:
   /*      SRA A */
 
-  SRA_8BIT (cpustate->A)
+  SRA_8BIT (m_A)
   break;
 case 0x30:
   /*      SWAP B */
 
-  SWAP_8BIT (cpustate->B)
+  SWAP_8BIT (m_B)
   break;
 case 0x31:
   /*      SWAP C */
 
-  SWAP_8BIT (cpustate->C)
+  SWAP_8BIT (m_C)
   break;
 case 0x32:
   /*      SWAP D */
 
-  SWAP_8BIT (cpustate->D)
+  SWAP_8BIT (m_D)
   break;
 case 0x33:
   /*      SWAP E */
 
-  SWAP_8BIT (cpustate->E)
+  SWAP_8BIT (m_E)
   break;
 case 0x34:
   /*      SWAP H */
 
-  SWAP_8BIT (cpustate->H)
+  SWAP_8BIT (m_H)
   break;
 case 0x35:
   /*      SWAP L */
 
-  SWAP_8BIT (cpustate->L)
+  SWAP_8BIT (m_L)
   break;
 case 0x36:
 	/*      SWAP (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SWAP_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x37:
   /*      SWAP A */
 
-  SWAP_8BIT (cpustate->A)
+  SWAP_8BIT (m_A)
   break;
 case 0x38:
   /*      SRL B */
 
-  SRL_8BIT (cpustate->B)
+  SRL_8BIT (m_B)
   break;
 case 0x39:
   /*      SRL C */
 
-  SRL_8BIT (cpustate->C)
+  SRL_8BIT (m_C)
   break;
 case 0x3A:
   /*      SRL D */
 
-  SRL_8BIT (cpustate->D)
+  SRL_8BIT (m_D)
   break;
 case 0x3B:
   /*      SRL E */
 
-  SRL_8BIT (cpustate->E)
+  SRL_8BIT (m_E)
   break;
 case 0x3C:
   /*      SRL H */
 
-  SRL_8BIT (cpustate->H)
+  SRL_8BIT (m_H)
   break;
 case 0x3D:
   /*      SRL L */
 
-  SRL_8BIT (cpustate->L)
+  SRL_8BIT (m_L)
   break;
 case 0x3E:
 	/*      SRL (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SRL_8BIT (x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x3F:
   /*      SRL A */
 
-  SRL_8BIT (cpustate->A)
+  SRL_8BIT (m_A)
   break;
 case 0x40:
   /*      BIT 0,B */
 
-  BIT_8BIT (0, cpustate->B)
+  BIT_8BIT (0, m_B)
   break;
 case 0x41:
   /*      BIT 0,C */
 
-  BIT_8BIT (0, cpustate->C)
+  BIT_8BIT (0, m_C)
   break;
 case 0x42:
   /*      BIT 0,D */
 
-  BIT_8BIT (0, cpustate->D)
+  BIT_8BIT (0, m_D)
   break;
 case 0x43:
   /*      BIT 0,E */
 
-  BIT_8BIT (0, cpustate->E)
+  BIT_8BIT (0, m_E)
   break;
 case 0x44:
   /*      BIT 0,H */
 
-  BIT_8BIT (0, cpustate->H)
+  BIT_8BIT (0, m_H)
   break;
 case 0x45:
   /*      BIT 0,L */
 
-  BIT_8BIT (0, cpustate->L)
+  BIT_8BIT (0, m_L)
   break;
 case 0x46:
 	/*      BIT 0,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (0, x)
 	}
 	break;
 case 0x47:
   /*      BIT 0,A */
 
-  BIT_8BIT (0, cpustate->A)
+  BIT_8BIT (0, m_A)
   break;
 case 0x48:
   /*      BIT 1,B */
 
-  BIT_8BIT (1, cpustate->B)
+  BIT_8BIT (1, m_B)
   break;
 case 0x49:
   /*      BIT 1,C */
 
-  BIT_8BIT (1, cpustate->C)
+  BIT_8BIT (1, m_C)
   break;
 case 0x4A:
   /*      BIT 1,D */
 
-  BIT_8BIT (1, cpustate->D)
+  BIT_8BIT (1, m_D)
   break;
 case 0x4B:
   /*      BIT 1,E */
 
-  BIT_8BIT (1, cpustate->E)
+  BIT_8BIT (1, m_E)
   break;
 case 0x4C:
   /*      BIT 1,H */
 
-  BIT_8BIT (1, cpustate->H)
+  BIT_8BIT (1, m_H)
   break;
 case 0x4D:
   /*      BIT 1,L */
 
-  BIT_8BIT (1, cpustate->L)
+  BIT_8BIT (1, m_L)
   break;
 case 0x4E:
 	/*      BIT 1,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (1, x)
 	}
 	break;
 case 0x4F:
   /*      BIT 1,A */
 
-  BIT_8BIT (1, cpustate->A)
+  BIT_8BIT (1, m_A)
   break;
 case 0x50:
   /*      BIT 2,B */
 
-  BIT_8BIT (2, cpustate->B)
+  BIT_8BIT (2, m_B)
   break;
 case 0x51:
   /*      BIT 2,C */
 
-  BIT_8BIT (2, cpustate->C)
+  BIT_8BIT (2, m_C)
   break;
 case 0x52:
   /*      BIT 2,D */
 
-  BIT_8BIT (2, cpustate->D)
+  BIT_8BIT (2, m_D)
   break;
 case 0x53:
   /*      BIT 2,E */
 
-  BIT_8BIT (2, cpustate->E)
+  BIT_8BIT (2, m_E)
   break;
 case 0x54:
   /*      BIT 2,H */
 
-  BIT_8BIT (2, cpustate->H)
+  BIT_8BIT (2, m_H)
   break;
 case 0x55:
   /*      BIT 2,L */
 
-  BIT_8BIT (2, cpustate->L)
+  BIT_8BIT (2, m_L)
   break;
 case 0x56:
 	/*      BIT 2,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (2, x)
 	}
 	break;
 case 0x57:
   /*      BIT 2,A */
 
-  BIT_8BIT (2, cpustate->A)
+  BIT_8BIT (2, m_A)
   break;
 case 0x58:
   /*      BIT 3,B */
 
-  BIT_8BIT (3, cpustate->B)
+  BIT_8BIT (3, m_B)
   break;
 case 0x59:
   /*      BIT 3,C */
 
-  BIT_8BIT (3, cpustate->C)
+  BIT_8BIT (3, m_C)
   break;
 case 0x5A:
   /*      BIT 3,D */
 
-  BIT_8BIT (3, cpustate->D)
+  BIT_8BIT (3, m_D)
   break;
 case 0x5B:
   /*      BIT 3,E */
 
-  BIT_8BIT (3, cpustate->E)
+  BIT_8BIT (3, m_E)
   break;
 case 0x5C:
   /*      BIT 3,H */
 
-  BIT_8BIT (3, cpustate->H)
+  BIT_8BIT (3, m_H)
   break;
 case 0x5D:
   /*      BIT 3,L */
 
-  BIT_8BIT (3, cpustate->L)
+  BIT_8BIT (3, m_L)
   break;
 case 0x5E:
 	/*      BIT 3,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (3, x)
 	}
 	break;
 case 0x5F:
   /*      BIT 3,A */
 
-  BIT_8BIT (3, cpustate->A)
+  BIT_8BIT (3, m_A)
   break;
 case 0x60:
   /*      BIT 4,B */
 
-  BIT_8BIT (4, cpustate->B)
+  BIT_8BIT (4, m_B)
   break;
 case 0x61:
   /*      BIT 4,C */
 
-  BIT_8BIT (4, cpustate->C)
+  BIT_8BIT (4, m_C)
   break;
 case 0x62:
   /*      BIT 4,D */
 
-  BIT_8BIT (4, cpustate->D)
+  BIT_8BIT (4, m_D)
   break;
 case 0x63:
   /*      BIT 4,E */
 
-  BIT_8BIT (4, cpustate->E)
+  BIT_8BIT (4, m_E)
   break;
 case 0x64:
   /*      BIT 4,H */
 
-  BIT_8BIT (4, cpustate->H)
+  BIT_8BIT (4, m_H)
   break;
 case 0x65:
   /*      BIT 4,L */
 
-  BIT_8BIT (4, cpustate->L)
+  BIT_8BIT (4, m_L)
   break;
 case 0x66:
 	/*      BIT 4,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (4, x)
 	}
 	break;
 case 0x67:
   /*      BIT 4,A */
 
-  BIT_8BIT (4, cpustate->A)
+  BIT_8BIT (4, m_A)
   break;
 case 0x68:
   /*      BIT 5,B */
 
-  BIT_8BIT (5, cpustate->B)
+  BIT_8BIT (5, m_B)
   break;
 case 0x69:
   /*      BIT 5,C */
 
-  BIT_8BIT (5, cpustate->C)
+  BIT_8BIT (5, m_C)
   break;
 case 0x6A:
   /*      BIT 5,D */
 
-  BIT_8BIT (5, cpustate->D)
+  BIT_8BIT (5, m_D)
   break;
 case 0x6B:
   /*      BIT 5,E */
 
-  BIT_8BIT (5, cpustate->E)
+  BIT_8BIT (5, m_E)
   break;
 case 0x6C:
   /*      BIT 5,H */
 
-  BIT_8BIT (5, cpustate->H)
+  BIT_8BIT (5, m_H)
   break;
 case 0x6D:
   /*      BIT 5,L */
 
-  BIT_8BIT (5, cpustate->L)
+  BIT_8BIT (5, m_L)
   break;
 case 0x6E:
 	/*      BIT 5,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (5, x)
 	}
 	break;
 case 0x6F:
   /*      BIT 5,A */
 
-  BIT_8BIT (5, cpustate->A)
+  BIT_8BIT (5, m_A)
   break;
 case 0x70:
   /*      BIT 6,B */
 
-  BIT_8BIT (6, cpustate->B)
+  BIT_8BIT (6, m_B)
   break;
 case 0x71:
   /*      BIT 6,C */
 
-  BIT_8BIT (6, cpustate->C)
+  BIT_8BIT (6, m_C)
   break;
 case 0x72:
   /*      BIT 6,D */
 
-  BIT_8BIT (6, cpustate->D)
+  BIT_8BIT (6, m_D)
   break;
 case 0x73:
   /*      BIT 6,E */
 
-  BIT_8BIT (6, cpustate->E)
+  BIT_8BIT (6, m_E)
   break;
 case 0x74:
   /*      BIT 6,H */
 
-  BIT_8BIT (6, cpustate->H)
+  BIT_8BIT (6, m_H)
   break;
 case 0x75:
   /*      BIT 6,L */
 
-  BIT_8BIT (6, cpustate->L)
+  BIT_8BIT (6, m_L)
   break;
 case 0x76:
 	/*      BIT 6,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (6, x)
 	}
 	break;
 case 0x77:
   /*      BIT 6,A */
 
-  BIT_8BIT (6, cpustate->A)
+  BIT_8BIT (6, m_A)
   break;
 case 0x78:
   /*      BIT 7,B */
 
-  BIT_8BIT (7, cpustate->B)
+  BIT_8BIT (7, m_B)
   break;
 case 0x79:
   /*      BIT 7,C */
 
-  BIT_8BIT (7, cpustate->C)
+  BIT_8BIT (7, m_C)
   break;
 case 0x7A:
   /*      BIT 7,D */
 
-  BIT_8BIT (7, cpustate->D)
+  BIT_8BIT (7, m_D)
   break;
 case 0x7B:
   /*      BIT 7,E */
 
-  BIT_8BIT (7, cpustate->E)
+  BIT_8BIT (7, m_E)
   break;
 case 0x7C:
   /*      BIT 7,H */
 
-  BIT_8BIT (7, cpustate->H)
+  BIT_8BIT (7, m_H)
   break;
 case 0x7D:
   /*      BIT 7,L */
 
-  BIT_8BIT (7, cpustate->L)
+  BIT_8BIT (7, m_L)
   break;
 case 0x7E:
 	/*      BIT 7,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		BIT_8BIT (7, x)
 	}
 	break;
 case 0x7F:
   /*      BIT 7,A */
 
-  BIT_8BIT (7, cpustate->A)
+  BIT_8BIT (7, m_A)
   break;
 case 0x80:
   /*      RES 0,B */
 
-  RES_8BIT (0, cpustate->B)
+  RES_8BIT (0, m_B)
   break;
 case 0x81:
   /*      RES 0,C */
 
-  RES_8BIT (0, cpustate->C)
+  RES_8BIT (0, m_C)
   break;
 case 0x82:
   /*      RES 0,D */
 
-  RES_8BIT (0, cpustate->D)
+  RES_8BIT (0, m_D)
   break;
 case 0x83:
   /*      RES 0,E */
 
-  RES_8BIT (0, cpustate->E)
+  RES_8BIT (0, m_E)
   break;
 case 0x84:
   /*      RES 0,H */
 
-  RES_8BIT (0, cpustate->H)
+  RES_8BIT (0, m_H)
   break;
 case 0x85:
   /*      RES 0,L */
 
-  RES_8BIT (0, cpustate->L)
+  RES_8BIT (0, m_L)
   break;
 case 0x86:
 	/*      RES 0,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (0, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x87:
   /*      RES 0,A */
 
-  RES_8BIT (0, cpustate->A)
+  RES_8BIT (0, m_A)
   break;
 case 0x88:
   /*      RES 1,B */
 
-  RES_8BIT (1, cpustate->B)
+  RES_8BIT (1, m_B)
   break;
 case 0x89:
   /*      RES 1,C */
 
-  RES_8BIT (1, cpustate->C)
+  RES_8BIT (1, m_C)
   break;
 case 0x8A:
   /*      RES 1,D */
 
-  RES_8BIT (1, cpustate->D)
+  RES_8BIT (1, m_D)
   break;
 case 0x8B:
   /*      RES 1,E */
 
-  RES_8BIT (1, cpustate->E)
+  RES_8BIT (1, m_E)
   break;
 case 0x8C:
   /*      RES 1,H */
 
-  RES_8BIT (1, cpustate->H)
+  RES_8BIT (1, m_H)
   break;
 case 0x8D:
   /*      RES 1,L */
 
-  RES_8BIT (1, cpustate->L)
+  RES_8BIT (1, m_L)
   break;
 case 0x8E:
 	/*      RES 1,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (1, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x8F:
   /*      RES 1,A */
 
-  RES_8BIT (1, cpustate->A)
+  RES_8BIT (1, m_A)
   break;
 case 0x90:
   /*      RES 2,B */
 
-  RES_8BIT (2, cpustate->B)
+  RES_8BIT (2, m_B)
   break;
 case 0x91:
   /*      RES 2,C */
 
-  RES_8BIT (2, cpustate->C)
+  RES_8BIT (2, m_C)
   break;
 case 0x92:
   /*      RES 2,D */
 
-  RES_8BIT (2, cpustate->D)
+  RES_8BIT (2, m_D)
   break;
 case 0x93:
   /*      RES 2,E */
 
-  RES_8BIT (2, cpustate->E)
+  RES_8BIT (2, m_E)
   break;
 case 0x94:
   /*      RES 2,H */
 
-  RES_8BIT (2, cpustate->H)
+  RES_8BIT (2, m_H)
   break;
 case 0x95:
   /*      RES 2,L */
 
-  RES_8BIT (2, cpustate->L)
+  RES_8BIT (2, m_L)
   break;
 case 0x96:
 	/*      RES 2,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (2, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x97:
   /*      RES 2,A */
 
-  RES_8BIT (2, cpustate->A)
+  RES_8BIT (2, m_A)
   break;
 case 0x98:
   /*      RES 3,B */
 
-  RES_8BIT (3, cpustate->B)
+  RES_8BIT (3, m_B)
   break;
 case 0x99:
   /*      RES 3,C */
 
-  RES_8BIT (3, cpustate->C)
+  RES_8BIT (3, m_C)
   break;
 case 0x9A:
   /*      RES 3,D */
 
-  RES_8BIT (3, cpustate->D)
+  RES_8BIT (3, m_D)
   break;
 case 0x9B:
   /*      RES 3,E */
 
-  RES_8BIT (3, cpustate->E)
+  RES_8BIT (3, m_E)
   break;
 case 0x9C:
   /*      RES 3,H */
 
-  RES_8BIT (3, cpustate->H)
+  RES_8BIT (3, m_H)
   break;
 case 0x9D:
   /*      RES 3,L */
 
-  RES_8BIT (3, cpustate->L)
+  RES_8BIT (3, m_L)
   break;
 case 0x9E:
 	/*      RES 3,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (3, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0x9F:
   /*      RES 3,A */
 
-  RES_8BIT (3, cpustate->A)
+  RES_8BIT (3, m_A)
   break;
 case 0xA0:
   /*      RES 4,B */
 
-  RES_8BIT (4, cpustate->B)
+  RES_8BIT (4, m_B)
   break;
 case 0xA1:
   /*      RES 4,C */
 
-  RES_8BIT (4, cpustate->C)
+  RES_8BIT (4, m_C)
   break;
 case 0xA2:
   /*      RES 4,D */
 
-  RES_8BIT (4, cpustate->D)
+  RES_8BIT (4, m_D)
   break;
 case 0xA3:
   /*      RES 4,E */
 
-  RES_8BIT (4, cpustate->E)
+  RES_8BIT (4, m_E)
   break;
 case 0xA4:
   /*      RES 4,H */
 
-  RES_8BIT (4, cpustate->H)
+  RES_8BIT (4, m_H)
   break;
 case 0xA5:
   /*      RES 4,L */
 
-  RES_8BIT (4, cpustate->L)
+  RES_8BIT (4, m_L)
   break;
 case 0xA6:
 	/*      RES 4,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (4, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xA7:
   /*      RES 4,A */
 
-  RES_8BIT (4, cpustate->A)
+  RES_8BIT (4, m_A)
   break;
 case 0xA8:
   /*      RES 5,B */
 
-  RES_8BIT (5, cpustate->B)
+  RES_8BIT (5, m_B)
   break;
 case 0xA9:
   /*      RES 5,C */
 
-  RES_8BIT (5, cpustate->C)
+  RES_8BIT (5, m_C)
   break;
 case 0xAA:
   /*      RES 5,D */
 
-  RES_8BIT (5, cpustate->D)
+  RES_8BIT (5, m_D)
   break;
 case 0xAB:
   /*      RES 5,E */
 
-  RES_8BIT (5, cpustate->E)
+  RES_8BIT (5, m_E)
   break;
 case 0xAC:
   /*      RES 5,H */
 
-  RES_8BIT (5, cpustate->H)
+  RES_8BIT (5, m_H)
   break;
 case 0xAD:
   /*      RES 5,L */
 
-  RES_8BIT (5, cpustate->L)
+  RES_8BIT (5, m_L)
   break;
 case 0xAE:
 	/*      RES 5,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (5, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xAF:
   /*      RES 5,A */
 
-  RES_8BIT (5, cpustate->A)
+  RES_8BIT (5, m_A)
   break;
 case 0xB0:
   /*      RES 6,B */
 
-  RES_8BIT (6, cpustate->B)
+  RES_8BIT (6, m_B)
   break;
 case 0xB1:
   /*      RES 6,C */
 
-  RES_8BIT (6, cpustate->C)
+  RES_8BIT (6, m_C)
   break;
 case 0xB2:
   /*      RES 6,D */
 
-  RES_8BIT (6, cpustate->D)
+  RES_8BIT (6, m_D)
   break;
 case 0xB3:
   /*      RES 6,E */
 
-  RES_8BIT (6, cpustate->E)
+  RES_8BIT (6, m_E)
   break;
 case 0xB4:
   /*      RES 6,H */
 
-  RES_8BIT (6, cpustate->H)
+  RES_8BIT (6, m_H)
   break;
 case 0xB5:
   /*      RES 6,L */
 
-  RES_8BIT (6, cpustate->L)
+  RES_8BIT (6, m_L)
   break;
 case 0xB6:
 	/*      RES 6,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (6, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xB7:
   /*      RES 6,A */
 
-  RES_8BIT (6, cpustate->A)
+  RES_8BIT (6, m_A)
   break;
 case 0xB8:
   /*      RES 7,B */
 
-  RES_8BIT (7, cpustate->B)
+  RES_8BIT (7, m_B)
   break;
 case 0xB9:
   /*      RES 7,C */
 
-  RES_8BIT (7, cpustate->C)
+  RES_8BIT (7, m_C)
   break;
 case 0xBA:
   /*      RES 7,D */
 
-  RES_8BIT (7, cpustate->D)
+  RES_8BIT (7, m_D)
   break;
 case 0xBB:
   /*      RES 7,E */
 
-  RES_8BIT (7, cpustate->E)
+  RES_8BIT (7, m_E)
   break;
 case 0xBC:
   /*      RES 7,H */
 
-  RES_8BIT (7, cpustate->H)
+  RES_8BIT (7, m_H)
   break;
 case 0xBD:
   /*      RES 7,L */
 
-  RES_8BIT (7, cpustate->L)
+  RES_8BIT (7, m_L)
   break;
 case 0xBE:
 	/*      RES 7,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		RES_8BIT (7, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xBF:
   /*      RES 7,A */
 
-  RES_8BIT (7, cpustate->A)
+  RES_8BIT (7, m_A)
   break;
 case 0xC0:
   /*      SET 0,B */
 
-  SET_8BIT (0, cpustate->B)
+  SET_8BIT (0, m_B)
   break;
 case 0xC1:
   /*      SET 0,C */
 
-  SET_8BIT (0, cpustate->C)
+  SET_8BIT (0, m_C)
   break;
 case 0xC2:
   /*      SET 0,D */
 
-  SET_8BIT (0, cpustate->D)
+  SET_8BIT (0, m_D)
   break;
 case 0xC3:
   /*      SET 0,E */
 
-  SET_8BIT (0, cpustate->E)
+  SET_8BIT (0, m_E)
   break;
 case 0xC4:
   /*      SET 0,H */
 
-  SET_8BIT (0, cpustate->H)
+  SET_8BIT (0, m_H)
   break;
 case 0xC5:
   /*      SET 0,L */
 
-  SET_8BIT (0, cpustate->L)
+  SET_8BIT (0, m_L)
   break;
 case 0xC6:
 	/*      SET 0,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (0, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xC7:
   /*      SET 0,A */
 
-  SET_8BIT (0, cpustate->A)
+  SET_8BIT (0, m_A)
   break;
 case 0xC8:
   /*      SET 1,B */
 
-  SET_8BIT (1, cpustate->B)
+  SET_8BIT (1, m_B)
   break;
 case 0xC9:
   /*      SET 1,C */
 
-  SET_8BIT (1, cpustate->C)
+  SET_8BIT (1, m_C)
   break;
 case 0xCA:
   /*      SET 1,D */
 
-  SET_8BIT (1, cpustate->D)
+  SET_8BIT (1, m_D)
   break;
 case 0xCB:
   /*      SET 1,E */
 
-  SET_8BIT (1, cpustate->E)
+  SET_8BIT (1, m_E)
   break;
 case 0xCC:
   /*      SET 1,H */
 
-  SET_8BIT (1, cpustate->H)
+  SET_8BIT (1, m_H)
   break;
 case 0xCD:
   /*      SET 1,L */
 
-  SET_8BIT (1, cpustate->L)
+  SET_8BIT (1, m_L)
   break;
 case 0xCE:
 	/*      SET 1,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (1, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xCF:
   /*      SET 1,A */
 
-  SET_8BIT (1, cpustate->A)
+  SET_8BIT (1, m_A)
   break;
 case 0xD0:
   /*      SET 2,B */
 
-  SET_8BIT (2, cpustate->B)
+  SET_8BIT (2, m_B)
   break;
 case 0xD1:
   /*      SET 2,C */
 
-  SET_8BIT (2, cpustate->C)
+  SET_8BIT (2, m_C)
   break;
 case 0xD2:
   /*      SET 2,D */
 
-  SET_8BIT (2, cpustate->D)
+  SET_8BIT (2, m_D)
   break;
 case 0xD3:
   /*      SET 2,E */
 
-  SET_8BIT (2, cpustate->E)
+  SET_8BIT (2, m_E)
   break;
 case 0xD4:
   /*      SET 2,H */
 
-  SET_8BIT (2, cpustate->H)
+  SET_8BIT (2, m_H)
   break;
 case 0xD5:
   /*      SET 2,L */
 
-  SET_8BIT (2, cpustate->L)
+  SET_8BIT (2, m_L)
   break;
 case 0xD6:
 	/*      SET 2,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (2, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xD7:
   /*      SET 2,A */
 
-  SET_8BIT (2, cpustate->A)
+  SET_8BIT (2, m_A)
   break;
 case 0xD8:
   /*      SET 3,B */
 
-  SET_8BIT (3, cpustate->B)
+  SET_8BIT (3, m_B)
   break;
 case 0xD9:
   /*      SET 3,C */
 
-  SET_8BIT (3, cpustate->C)
+  SET_8BIT (3, m_C)
   break;
 case 0xDA:
   /*      SET 3,D */
 
-  SET_8BIT (3, cpustate->D)
+  SET_8BIT (3, m_D)
   break;
 case 0xDB:
   /*      SET 3,E */
 
-  SET_8BIT (3, cpustate->E)
+  SET_8BIT (3, m_E)
   break;
 case 0xDC:
   /*      SET 3,H */
 
-  SET_8BIT (3, cpustate->H)
+  SET_8BIT (3, m_H)
   break;
 case 0xDD:
   /*      SET 3,L */
 
-  SET_8BIT (3, cpustate->L)
+  SET_8BIT (3, m_L)
   break;
 case 0xDE:
 	/*      SET 3,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (3, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xDF:
   /*      SET 3,A */
 
-  SET_8BIT (3, cpustate->A)
+  SET_8BIT (3, m_A)
   break;
 case 0xE0:
   /*      SET 4,B */
 
-  SET_8BIT (4, cpustate->B)
+  SET_8BIT (4, m_B)
   break;
 case 0xE1:
   /*      SET 4,C */
 
-  SET_8BIT (4, cpustate->C)
+  SET_8BIT (4, m_C)
   break;
 case 0xE2:
   /*      SET 4,D */
 
-  SET_8BIT (4, cpustate->D)
+  SET_8BIT (4, m_D)
   break;
 case 0xE3:
   /*      SET 4,E */
 
-  SET_8BIT (4, cpustate->E)
+  SET_8BIT (4, m_E)
   break;
 case 0xE4:
   /*      SET 4,H */
 
-  SET_8BIT (4, cpustate->H)
+  SET_8BIT (4, m_H)
   break;
 case 0xE5:
   /*      SET 4,L */
 
-  SET_8BIT (4, cpustate->L)
+  SET_8BIT (4, m_L)
   break;
 case 0xE6:
 	/*      SET 4,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (4, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xE7:
   /*      SET 4,A */
 
-  SET_8BIT (4, cpustate->A)
+  SET_8BIT (4, m_A)
   break;
 case 0xE8:
   /*      SET 5,B */
 
-  SET_8BIT (5, cpustate->B)
+  SET_8BIT (5, m_B)
   break;
 case 0xE9:
   /*      SET 5,C */
 
-  SET_8BIT (5, cpustate->C)
+  SET_8BIT (5, m_C)
   break;
 case 0xEA:
   /*      SET 5,D */
 
-  SET_8BIT (5, cpustate->D)
+  SET_8BIT (5, m_D)
   break;
 case 0xEB:
   /*      SET 5,E */
 
-  SET_8BIT (5, cpustate->E)
+  SET_8BIT (5, m_E)
   break;
 case 0xEC:
   /*      SET 5,H */
 
-  SET_8BIT (5, cpustate->H)
+  SET_8BIT (5, m_H)
   break;
 case 0xED:
   /*      SET 5,L */
 
-  SET_8BIT (5, cpustate->L)
+  SET_8BIT (5, m_L)
   break;
 case 0xEE:
 	/*      SET 5,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (5, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xEF:
   /*      SET 5,A */
 
-  SET_8BIT (5, cpustate->A)
+  SET_8BIT (5, m_A)
   break;
 case 0xF0:
   /*      SET 6,B */
 
-  SET_8BIT (6, cpustate->B)
+  SET_8BIT (6, m_B)
   break;
 case 0xF1:
   /*      SET 6,C */
 
-  SET_8BIT (6, cpustate->C)
+  SET_8BIT (6, m_C)
   break;
 case 0xF2:
   /*      SET 6,D */
 
-  SET_8BIT (6, cpustate->D)
+  SET_8BIT (6, m_D)
   break;
 case 0xF3:
   /*      SET 6,E */
 
-  SET_8BIT (6, cpustate->E)
+  SET_8BIT (6, m_E)
   break;
 case 0xF4:
   /*      SET 6,H */
 
-  SET_8BIT (6, cpustate->H)
+  SET_8BIT (6, m_H)
   break;
 case 0xF5:
   /*      SET 6,L */
 
-  SET_8BIT (6, cpustate->L)
+  SET_8BIT (6, m_L)
   break;
 case 0xF6:
 	/*      SET 6,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (6, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xF7:
   /*      SET 6,A */
 
-  SET_8BIT (6, cpustate->A)
+  SET_8BIT (6, m_A)
   break;
 case 0xF8:
   /*      SET 7,B */
 
-  SET_8BIT (7, cpustate->B)
+  SET_8BIT (7, m_B)
   break;
 case 0xF9:
   /*      SET 7,C */
 
-  SET_8BIT (7, cpustate->C)
+  SET_8BIT (7, m_C)
   break;
 case 0xFA:
   /*      SET 7,D */
 
-  SET_8BIT (7, cpustate->D)
+  SET_8BIT (7, m_D)
   break;
 case 0xFB:
   /*      SET 7,E */
 
-  SET_8BIT (7, cpustate->E)
+  SET_8BIT (7, m_E)
   break;
 case 0xFC:
   /*      SET 7,H */
 
-  SET_8BIT (7, cpustate->H)
+  SET_8BIT (7, m_H)
   break;
 case 0xFD:
   /*      SET 7,L */
 
-  SET_8BIT (7, cpustate->L)
+  SET_8BIT (7, m_L)
   break;
 case 0xFE:
 	/*      SET 7,(HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 
-		x = mem_ReadByte (cpustate, addr);
+		x = mem_read_byte( addr);
 		SET_8BIT (7, x)
-		mem_WriteByte (cpustate, addr, x);
+		mem_write_byte( addr, x);
 	}
 	break;
 case 0xFF:
   /*      SET 7,A */
 
-  SET_8BIT (7, cpustate->A)
+  SET_8BIT (7, m_A)
   break;
diff -Nru src-old/emu/cpu/lr35902/opc_main.h src/emu/cpu/lr35902/opc_main.h
--- src-old/emu/cpu/lr35902/opc_main.h	2012-02-25 22:22:21.000000000 +0100
+++ src/emu/cpu/lr35902/opc_main.h	2012-02-26 21:36:24.000000000 +0100
@@ -3,10 +3,10 @@
   register UINT8 r,f; \
   x++; \
   r=(x);  \
-  f=(UINT8)(cpustate->F&FLAG_C); \
+  f=(UINT8)(m_F&FLAG_C); \
   if( r==0 )       f|=FLAG_Z; \
   if( (r&0xF)==0 ) f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	DEC_8BIT(x) \
@@ -14,52 +14,52 @@
   register UINT8 r,f; \
   x--; \
   r=(x);  \
-  f=(UINT8)((cpustate->F&FLAG_C)|FLAG_N); \
+  f=(UINT8)((m_F&FLAG_C)|FLAG_N); \
   if( r==0 )       f|=FLAG_Z; \
   if( (r&0xF)==0xF ) f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	ADD_HL_RR(x) \
 { \
   register UINT32 r1,r2; \
   register UINT8 f; \
-  r1=((cpustate->H<<8)|cpustate->L)+(x); \
-  r2=(((cpustate->H<<8)|cpustate->L)&0xFFF)+((x)&0xFFF); \
-  f=(UINT8)(cpustate->F&FLAG_Z); \
+  r1=((m_H<<8)|m_L)+(x); \
+  r2=(((m_H<<8)|m_L)&0xFFF)+((x)&0xFFF); \
+  f=(UINT8)(m_F&FLAG_Z); \
   if( r1>0xFFFF ) f|=FLAG_C; \
   if( r2>0x0FFF ) f|=FLAG_H; \
-  cpustate->L = r1; \
-  cpustate->H = r1 >> 8; \
-  cpustate->F=f; \
+  m_L = r1; \
+  m_H = r1 >> 8; \
+  m_F=f; \
 }
 
 #define	ADD_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->A&0xF)+((x)&0xF)); \
-  r2=(UINT16)(cpustate->A+(x)); \
-  cpustate->A=(UINT8)r2; \
+  r1=(UINT16)((m_A&0xF)+((x)&0xF)); \
+  r2=(UINT16)(m_A+(x)); \
+  m_A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_Z; \
     else f=0; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	SUB_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)); \
-  r2=(UINT16)(cpustate->A-(x)); \
-  cpustate->A=(UINT8)r2; \
+  r1=(UINT16)((m_A&0xF)-((x)&0xF)); \
+  r2=(UINT16)(m_A-(x)); \
+  m_A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 /*
@@ -67,15 +67,15 @@
    { \
    register UINT16 r; \
    register UINT8 f; \
-   r=(UINT16)(cpustate->A-(x)); \
+   r=(UINT16)(m_A-(x)); \
    if( ((UINT8)r)==0 ) \
    f=FLAG_N|FLAG_Z; \
    else \
    f=FLAG_N; \
    f|=(UINT8)((r>>8)&FLAG_C); \
-   if( (r^cpustate->A^(x))&0x10 ) \
+   if( (r^m_A^(x))&0x10 ) \
    f|=FLAG_H; \
-   cpustate->F=f; \
+   m_F=f; \
    }
  */
 
@@ -83,450 +83,455 @@
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)); \
-  r2=(UINT16)(cpustate->A-(x)); \
+  r1=(UINT16)((m_A&0xF)-((x)&0xF)); \
+  r2=(UINT16)(m_A-(x)); \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	SBC_A_X(x) \
 { \
   register UINT16 r1,r2; \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->A&0xF)-((x)&0xF)-((cpustate->F&FLAG_C)?1:0)); \
-  r2=(UINT16)(cpustate->A-(x)-((cpustate->F&FLAG_C)?1:0)); \
-  cpustate->A=(UINT8)r2; \
+  r1=(UINT16)((m_A&0xF)-((x)&0xF)-((m_F&FLAG_C)?1:0)); \
+  r2=(UINT16)(m_A-(x)-((m_F&FLAG_C)?1:0)); \
+  m_A=(UINT8)r2; \
   if( ((UINT8)r2)==0 ) f=FLAG_N|FLAG_Z; \
     else f=FLAG_N; \
   if( r2>0xFF ) f|=FLAG_C; \
   if( r1>0xF )  f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	ADC_A_X(x) \
 { \
   register UINT16 r1,r2;  \
   register UINT8 f; \
-  r1=(UINT16)((cpustate->A&0xF)+((x)&0xF)+((cpustate->F&FLAG_C)?1:0));  \
-  r2=(UINT16)(cpustate->A+(x)+((cpustate->F&FLAG_C)?1:0)); \
-  if( (cpustate->A=(UINT8)r2)==0 ) f=FLAG_Z; \
+  r1=(UINT16)((m_A&0xF)+((x)&0xF)+((m_F&FLAG_C)?1:0));  \
+  r2=(UINT16)(m_A+(x)+((m_F&FLAG_C)?1:0)); \
+  if( (m_A=(UINT8)r2)==0 ) f=FLAG_Z; \
     else f=0; \
   if( r2>0xFF )	f|=FLAG_C; \
   if( r1>0xF )	f|=FLAG_H; \
-  cpustate->F=f; \
+  m_F=f; \
 }
 
 #define	AND_A_X(x) \
-  if( (cpustate->A&=(x))==0 ) \
-    cpustate->F=FLAG_H|FLAG_Z; \
+  if( (m_A&=(x))==0 ) \
+    m_F=FLAG_H|FLAG_Z; \
   else \
-    cpustate->F=FLAG_H;
+    m_F=FLAG_H;
 
 #define XOR_A_X(x) \
-  if( (cpustate->A^=(x))==0 ) \
-    cpustate->F=FLAG_Z; \
+  if( (m_A^=(x))==0 ) \
+    m_F=FLAG_Z; \
   else \
-    cpustate->F=0;
+    m_F=0;
 
 #define	OR_A_X(x) \
-  if( (cpustate->A|=(x))==0 ) \
-    cpustate->F=FLAG_Z; \
+  if( (m_A|=(x))==0 ) \
+    m_F=FLAG_Z; \
   else \
-    cpustate->F=0;
+    m_F=0;
 
 #define POP(x,y) \
-	y = mem_ReadByte( cpustate, cpustate->SP++ ); \
-	x = mem_ReadByte( cpustate, cpustate->SP++ );
+	y = mem_read_byte( m_SP++ ); \
+	x = mem_read_byte( m_SP++ );
 
 #define PUSH(x,y) \
-	cpustate->SP--; \
-	mem_WriteByte( cpustate, cpustate->SP, x ); \
-	cpustate->SP--; \
-	mem_WriteByte( cpustate, cpustate->SP, y );
+	m_SP--; \
+	mem_write_byte( m_SP, x ); \
+	m_SP--; \
+	mem_write_byte( m_SP, y );
 
 case 0x00: /*      NOP */
-  break;
+	break;
+
 case 0x01: /*      LD BC,n16 */
-	cpustate->C = mem_ReadOp (cpustate);
-	cpustate->B = mem_ReadOp (cpustate);
+	m_C = mem_read_byte( m_PC++ );
+	m_B = mem_read_byte( m_PC++ );
 	break;
+
 case 0x02: /*      LD (BC),A */
-  mem_WriteByte (cpustate, ( cpustate->B << 8 ) | cpustate->C, cpustate->A);
-  break;
+	mem_write_byte( ( m_B << 8 ) | m_C, m_A );
+	break;
+
 case 0x03: /*      INC BC */
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->B == 0xFE)
+  if (m_B == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->C++;
-	if ( cpustate->C == 0 )
+	m_C++;
+	if ( m_C == 0 )
 	{
-		cpustate->B++;
+		m_B++;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x04: /*      INC B */
-	INC_8BIT (cpustate->B)
+	INC_8BIT (m_B)
 	break;
 case 0x05: /*      DEC B */
 
-  DEC_8BIT (cpustate->B)
+  DEC_8BIT (m_B)
   break;
+
 case 0x06: /*      LD B,n8 */
+	m_B = mem_read_byte( m_PC++ );
+	break;
 
-  cpustate->B = mem_ReadByte (cpustate, cpustate->PC++);
-  break;
 case 0x07: /*      RLCA */
 
-  cpustate->A = (UINT8) ((cpustate->A << 1) | (cpustate->A >> 7));
-  if (cpustate->A & 1)
+  m_A = (UINT8) ((m_A << 1) | (m_A >> 7));
+  if (m_A & 1)
   {
-    cpustate->F = FLAG_C;
+    m_F = FLAG_C;
   }
   else
   {
-    cpustate->F = 0;
+    m_F = 0;
   }
   break;
+
 case 0x08: /*      LD (n16),SP */
+	mem_write_word (mem_read_word (m_PC), m_SP);
+	m_PC += 2;
+	break;
 
-  mem_WriteWord (cpustate, mem_ReadWord (cpustate, cpustate->PC), cpustate->SP);
-  cpustate->PC += 2;
-  break;
 case 0x09: /*      ADD HL,BC */
-	ADD_HL_RR ((cpustate->B<<8)|cpustate->C)
-	CYCLES_PASSED( 4 );
+	ADD_HL_RR ((m_B<<8)|m_C)
+	cycles_passed( 4 );
 	break;
 case 0x0A: /*      LD A,(BC) */
 
-  cpustate->A = mem_ReadByte (cpustate, (cpustate->B<<8)|cpustate->C);
+  m_A = mem_read_byte ( (m_B<<8)|m_C );
   break;
 case 0x0B: /*      DEC BC */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->B == 0xFE)
+  if (m_B == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->C--;
-	if ( cpustate->C == 0xFF )
+	m_C--;
+	if ( m_C == 0xFF )
 	{
-		cpustate->B--;
+		m_B--;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x0C: /*      INC C */
 
-  INC_8BIT (cpustate->C)
+  INC_8BIT (m_C)
   break;
 case 0x0D: /*      DEC C */
 
-  DEC_8BIT (cpustate->C)
+  DEC_8BIT (m_C)
   break;
 case 0x0E: /*      LD C,n8 */
 
-  cpustate->C = mem_ReadByte (cpustate, cpustate->PC++);
+  m_C = mem_read_byte ( m_PC++ );
   break;
 case 0x0F: /*      RRCA */
 
-  cpustate->A = (UINT8) ((cpustate->A >> 1) | (cpustate->A << 7));
-  cpustate->F = 0;
-  if (cpustate->A & 0x80)
+  m_A = (UINT8) ((m_A >> 1) | (m_A << 7));
+  m_F = 0;
+  if (m_A & 0x80)
   {
-    cpustate->F |= FLAG_C;
+    m_F |= FLAG_C;
   }
   break;
 case 0x10: /*      STOP */
-  if ( cpustate->gb_speed_change_pending ) {
-    cpustate->gb_speed = ( cpustate->gb_speed == 1 ) ? 2 : 1;
+  if ( m_gb_speed_change_pending ) {
+    m_gb_speed = ( m_gb_speed == 1 ) ? 2 : 1;
   }
-  cpustate->gb_speed_change_pending = 0;
+  m_gb_speed_change_pending = 0;
   break;
 case 0x11: /*      LD DE,n16 */
-	cpustate->E = mem_ReadOp (cpustate);
-	cpustate->D = mem_ReadOp (cpustate);
+	m_E = mem_read_byte( m_PC++ );
+	m_D = mem_read_byte( m_PC++ );
 	break;
 case 0x12: /*      LD (DE),A */
-  mem_WriteByte (cpustate, ( cpustate->D << 8 ) | cpustate->E, cpustate->A);
+  mem_write_byte( ( m_D << 8 ) | m_E, m_A );
   break;
 case 0x13: /*      INC DE */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->D == 0xFE)
+  if (m_D == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->E++;
-	if ( cpustate->E == 0 )
+	m_E++;
+	if ( m_E == 0 )
 	{
-		cpustate->D++;
+		m_D++;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x14: /*      INC D */
 
-  INC_8BIT (cpustate->D)
+  INC_8BIT (m_D)
   break;
 case 0x15: /*      DEC D */
 
-  DEC_8BIT (cpustate->D)
+  DEC_8BIT (m_D)
   break;
 case 0x16: /*      LD D,n8 */
 
-  cpustate->D = mem_ReadByte (cpustate, cpustate->PC++);
+  m_D = mem_read_byte ( m_PC++ );
   break;
 case 0x17: /*      RLA */
 
-  x = (cpustate->A & 0x80) ? FLAG_C : 0;
+  x = (m_A & 0x80) ? FLAG_C : 0;
 
-  cpustate->A = (UINT8) ((cpustate->A << 1) | ((cpustate->F & FLAG_C) ? 1 : 0));
-  cpustate->F = x;
+  m_A = (UINT8) ((m_A << 1) | ((m_F & FLAG_C) ? 1 : 0));
+  m_F = x;
   break;
 case 0x18: /*      JR      n8 */
   {
 	INT8 offset;
 
-    offset = mem_ReadByte (cpustate, cpustate->PC++);
-    cpustate->PC += offset;
-	CYCLES_PASSED( 4 );
+    offset = mem_read_byte( m_PC++ );
+    m_PC += offset;
+	cycles_passed( 4 );
   }
   break;
 case 0x19: /*      ADD HL,DE */
-	ADD_HL_RR (( cpustate->D << 8 ) | cpustate->E)
-	CYCLES_PASSED( 4 );
+	ADD_HL_RR (( m_D << 8 ) | m_E)
+	cycles_passed( 4 );
 	break;
 case 0x1A: /*      LD A,(DE) */
 
-  cpustate->A = mem_ReadByte (cpustate, ( cpustate->D << 8 ) | cpustate->E);
+  m_A = mem_read_byte( ( m_D << 8 ) | m_E );
   break;
 case 0x1B: /*      DEC DE */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->D == 0xFE)
+  if (m_D == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->E--;
-	if ( cpustate->E == 0xFF )
+	m_E--;
+	if ( m_E == 0xFF )
 	{
-		cpustate->D--;
+		m_D--;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x1C: /*      INC E */
 
-  INC_8BIT (cpustate->E)
+  INC_8BIT (m_E)
   break;
 case 0x1D: /*      DEC E */
 
-  DEC_8BIT (cpustate->E)
+  DEC_8BIT (m_E)
   break;
 case 0x1E: /*      LD E,n8 */
 
-  cpustate->E = mem_ReadByte (cpustate, cpustate->PC++);
+  m_E = mem_read_byte( m_PC++ );
   break;
 case 0x1F: /*      RRA */
 
-  x = (cpustate->A & 1) ? FLAG_C : 0;
+  x = (m_A & 1) ? FLAG_C : 0;
 
-  cpustate->A = (UINT8) ((cpustate->A >> 1) | ((cpustate->F & FLAG_C) ? 0x80 : 0));
-  cpustate->F = x;
+  m_A = (UINT8) ((m_A >> 1) | ((m_F & FLAG_C) ? 0x80 : 0));
+  m_F = x;
   break;
 case 0x20: /*      JR NZ,n8 */
 	{
-		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
-		if (! (cpustate->F & FLAG_Z) )
+		INT8 offset = mem_read_byte( m_PC++ );
+		if (! (m_F & FLAG_Z) )
 		{
-			cpustate->PC += offset;
-			CYCLES_PASSED( 4 );
+			m_PC += offset;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0x21: /*      LD HL,n16 */
-	cpustate->L = mem_ReadOp (cpustate);
-	cpustate->H = mem_ReadOp (cpustate);
+	m_L = mem_read_byte( m_PC++ );
+	m_H = mem_read_byte( m_PC++ );
 	break;
 case 0x22: /*      LD (HL+),A */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	mem_WriteByte (cpustate, (cpustate->H << 8 ) | cpustate->L, cpustate->A);
-	cpustate->L++;
-	if ( cpustate->L == 0 )
+	mem_write_byte( (m_H << 8 ) | m_L, m_A );
+	m_L++;
+	if ( m_L == 0 )
 	{
-		cpustate->H++;
+		m_H++;
 	}
 	break;
 case 0x23: /*      INC HL */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->L++;
-	if ( cpustate->L == 0 )
+	m_L++;
+	if ( m_L == 0 )
 	{
-		cpustate->H++;
+		m_H++;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x24: /*      INC H */
 
-  INC_8BIT (cpustate->H);
+  INC_8BIT (m_H);
   break;
 case 0x25: /*      DEC H */
 
-  DEC_8BIT (cpustate->H);
+  DEC_8BIT (m_H);
   break;
 case 0x26: /*      LD H,n8 */
 
-  cpustate->H = mem_ReadByte (cpustate, cpustate->PC++);
+  m_H = mem_read_byte( m_PC++ );
   break;
 case 0x27: /*      DAA */
 	{
-		int tmp = cpustate->A;
+		int tmp = m_A;
 
-		if ( ! ( cpustate->F & FLAG_N ) ) {
-			if ( ( cpustate->F & FLAG_H ) || ( tmp & 0x0F ) > 9 )
+		if ( ! ( m_F & FLAG_N ) ) {
+			if ( ( m_F & FLAG_H ) || ( tmp & 0x0F ) > 9 )
 				tmp += 6;
-			if ( ( cpustate->F & FLAG_C ) || tmp > 0x9F )
+			if ( ( m_F & FLAG_C ) || tmp > 0x9F )
 				tmp += 0x60;
 		} else {
-			if ( cpustate->F & FLAG_H ) {
+			if ( m_F & FLAG_H ) {
 				tmp -= 6;
-				if ( ! ( cpustate->F & FLAG_C ) )
+				if ( ! ( m_F & FLAG_C ) )
 					tmp &= 0xFF;
 			}
-			if ( cpustate->F & FLAG_C )
+			if ( m_F & FLAG_C )
 					tmp -= 0x60;
 		}
-		cpustate->F &= ~ ( FLAG_H | FLAG_Z );
+		m_F &= ~ ( FLAG_H | FLAG_Z );
 		if ( tmp & 0x100 )
-			cpustate->F |= FLAG_C;
-		cpustate->A = tmp & 0xFF;
-		if ( ! cpustate->A )
-			cpustate->F |= FLAG_Z;
+			m_F |= FLAG_C;
+		m_A = tmp & 0xFF;
+		if ( ! m_A )
+			m_F |= FLAG_Z;
 	}
   break;
 case 0x28: /*      JR Z,n8 */
 	{
-		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);;
+		INT8 offset = mem_read_byte( m_PC++ );
 
-		if (cpustate->F & FLAG_Z)
+		if (m_F & FLAG_Z)
 		{
-			cpustate->PC += offset;
-			CYCLES_PASSED( 4 );
+			m_PC += offset;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0x29: /*      ADD HL,HL */
-	ADD_HL_RR ((cpustate->H << 8 ) | cpustate->L)
-	CYCLES_PASSED( 4 );
+	ADD_HL_RR ((m_H << 8 ) | m_L)
+	cycles_passed( 4 );
 	break;
 case 0x2A: /*      LD A,(HL+) */
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
-	cpustate->L++;
-	if ( cpustate->L == 0 )
+	m_A = mem_read_byte( ( m_H << 8 ) | m_L );
+	m_L++;
+	if ( m_L == 0 )
 	{
-		cpustate->H++;
+		m_H++;
 	}
 	break;
 case 0x2B: /*      DEC HL */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->L--;
-	if ( cpustate->L == 0xFF )
+	m_L--;
+	if ( m_L == 0xFF )
 	{
-		cpustate->H--;
+		m_H--;
 	}
-	CYCLES_PASSED( 4 );
+	cycles_passed( 4 );
 	break;
 case 0x2C: /*      INC L */
 
-  INC_8BIT (cpustate->L);
+  INC_8BIT (m_L);
   break;
 case 0x2D: /*      DEC L */
 
-  DEC_8BIT (cpustate->L);
+  DEC_8BIT (m_L);
   break;
 case 0x2E: /*      LD L,n8 */
 
-  cpustate->L = mem_ReadByte (cpustate, cpustate->PC++);
+  m_L = mem_read_byte( m_PC++ );
   break;
 case 0x2F: /*      CPL */
 
-  cpustate->A = ~cpustate->A;
-  cpustate->F |= FLAG_N | FLAG_H;
+  m_A = ~m_A;
+  m_F |= FLAG_N | FLAG_H;
   break;
 case 0x30: /*      JR NC,n8 */
 	{
-		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
+		INT8 offset = mem_read_byte( m_PC++ );
 
-		if ( ! (cpustate->F & FLAG_C) )
+		if ( ! (m_F & FLAG_C) )
 		{
-			cpustate->PC += offset;
-			CYCLES_PASSED( 4 );
+			m_PC += offset;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0x31: /*      LD SP,n16 */
 
-  cpustate->SP = mem_ReadWord (cpustate, cpustate->PC);
-  cpustate->PC += 2;
+  m_SP = mem_read_word( m_PC );
+  m_PC += 2;
   break;
 case 0x32: /*      LD (HL-),A */
 
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->A);
-	cpustate->L--;
-	if ( cpustate->L == 0xFF )
+	mem_write_byte( ( m_H << 8 ) | m_L, m_A );
+	m_L--;
+	if ( m_L == 0xFF )
 	{
-		cpustate->H--;
+		m_H--;
 	}
 	break;
 case 0x33: /*      INC SP */
-	cpustate->SP += 1;
-	CYCLES_PASSED( 4 );
+	m_SP += 1;
+	cycles_passed( 4 );
 	break;
 case 0x34: /*      INC (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 		register UINT8 r, f;
 
-		f = (UINT8) (cpustate->F & FLAG_C);
-		r = mem_ReadByte (cpustate, addr);
+		f = (UINT8) (m_F & FLAG_C);
+		r = mem_read_byte( addr );
 		r += 1;
-		mem_WriteByte (cpustate, addr, r);
+		mem_write_byte( addr, r );
 
 		if (r == 0)
 			f |= FLAG_Z;
@@ -534,18 +539,18 @@
 		if ((r & 0xF) == 0)
 			f |= FLAG_H;
 
-		cpustate->F = f;
+		m_F = f;
 	}
 	break;
 case 0x35: /*      DEC (HL) */
 	{
-		UINT16 addr = ( cpustate->H << 8 ) | cpustate->L;
+		UINT16 addr = ( m_H << 8 ) | m_L;
 		register UINT8 r, f;
 
-		f = (UINT8) ((cpustate->F & FLAG_C) | FLAG_N);
-		r = mem_ReadByte (cpustate, addr);
+		f = (UINT8) ((m_F & FLAG_C) | FLAG_N);
+		r = mem_read_byte( addr );
 		r -= 1;
-		mem_WriteByte (cpustate, addr, r);
+		mem_write_byte( addr, r );
 
 		if (r == 0)
 			f |= FLAG_Z;
@@ -553,667 +558,663 @@
 		if ((r & 0xF) == 0xF)
 			f |= FLAG_H;
 
-		cpustate->F = f;
+		m_F = f;
 	}
 	break;
 case 0x36: /*      LD (HL),n8 */
 	{
-		UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
-		mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, v);
+		UINT8 v = mem_read_byte( m_PC++ );
+		mem_write_byte( ( m_H << 8 ) | m_L, v );
 	}
 	break;
 case 0x37: /*      SCF */
 
-  cpustate->F = (UINT8) ((cpustate->F & FLAG_Z) | FLAG_C);
+  m_F = (UINT8) ((m_F & FLAG_Z) | FLAG_C);
   break;
 case 0x38: /*      JR C,n8 */
 	{
-		INT8 offset = mem_ReadByte (cpustate, cpustate->PC++);
+		INT8 offset = mem_read_byte( m_PC++ );
 
-		if (cpustate->F & FLAG_C)
+		if (m_F & FLAG_C)
 		{
-			cpustate->PC += offset;
-			CYCLES_PASSED( 4 );
+			m_PC += offset;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0x39: /*      ADD HL,SP */
-	ADD_HL_RR (cpustate->SP)
-	CYCLES_PASSED( 4 );
+	ADD_HL_RR (m_SP)
+	cycles_passed( 4 );
 	break;
 case 0x3A: /*      LD A,(HL-) */
 #if 0				/* FIXME ?? do we want to support this? (bug emulation) */
-  if (cpustate->H == 0xFE)
+  if (m_H == 0xFE)
   {
     trash_sprites (state);
   }
 #endif
-	cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
-	cpustate->L--;
-	if ( cpustate->L == 0xFF )
+	m_A = mem_read_byte( ( m_H << 8 ) | m_L );
+	m_L--;
+	if ( m_L == 0xFF )
 	{
-		cpustate->H--;
+		m_H--;
 	}
 	break;
 case 0x3B: /*      DEC SP */
-	cpustate->SP -= 1;
-	CYCLES_PASSED( 4 );
+	m_SP -= 1;
+	cycles_passed( 4 );
 	break;
 case 0x3C: /*      INC     A */
 
-  INC_8BIT (cpustate->A);
+  INC_8BIT (m_A);
   break;
 case 0x3D: /*      DEC     A */
 
-  DEC_8BIT (cpustate->A);
+  DEC_8BIT (m_A);
   break;
 case 0x3E: /*      LD A,n8 */
 
-  cpustate->A = mem_ReadByte (cpustate, cpustate->PC++);
+  m_A = mem_read_byte( m_PC++ );
   break;
 case 0x3F: /*      CCF */
 
-  cpustate->F = (UINT8) ((cpustate->F & FLAG_Z) | ((cpustate->F & FLAG_C) ? 0 : FLAG_C));
+  m_F = (UINT8) ((m_F & FLAG_Z) | ((m_F & FLAG_C) ? 0 : FLAG_C));
   break;
 case 0x40: /*      LD B,B */
   break;
 case 0x41: /*      LD B,C */
 
-  cpustate->B = cpustate->C;
+  m_B = m_C;
   break;
 case 0x42: /*      LD B,D */
 
-  cpustate->B = cpustate->D;
+  m_B = m_D;
   break;
 case 0x43: /*      LD B,E */
 
-  cpustate->B = cpustate->E;
+  m_B = m_E;
   break;
 case 0x44: /*      LD B,H */
 
-  cpustate->B = cpustate->H;
+  m_B = m_H;
   break;
 case 0x45: /*      LD B,L */
 
-  cpustate->B = cpustate->L;
+  m_B = m_L;
   break;
 case 0x46: /*      LD B,(HL) */
+	m_B = mem_read_byte( ( m_H << 8 ) | m_L) ;
+	break;
 
-  cpustate->B = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
-  break;
 case 0x47: /*      LD B,A */
 
-  cpustate->B = cpustate->A;
+  m_B = m_A;
   break;
 case 0x48: /*      LD C,B */
 
-  cpustate->C = cpustate->B;
+  m_C = m_B;
   break;
 case 0x49: /*      LD C,C */
   break;
 case 0x4A: /*      LD C,D */
 
-  cpustate->C = cpustate->D;
+  m_C = m_D;
   break;
 case 0x4B: /*      LD C,E */
 
-  cpustate->C = cpustate->E;
+  m_C = m_E;
   break;
 case 0x4C: /*      LD C,H */
 
-  cpustate->C = cpustate->H;
+  m_C = m_H;
   break;
 case 0x4D: /*      LD C,L */
 
-  cpustate->C = cpustate->L;
+  m_C = m_L;
   break;
+
 case 0x4E: /*      LD C,(HL) */
+	m_C = mem_read_byte( ( m_H << 8 ) | m_L );
+	break;
 
-  cpustate->C = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
-  break;
 case 0x4F: /*      LD C,A */
 
-  cpustate->C = cpustate->A;
+  m_C = m_A;
   break;
 case 0x50: /*      LD D,B */
 
-  cpustate->D = cpustate->B;
+  m_D = m_B;
   break;
 case 0x51: /*      LD D,C */
 
-  cpustate->D = cpustate->C;
+  m_D = m_C;
   break;
 case 0x52: /*      LD D,D */
   break;
 case 0x53: /*      LD D,E */
 
-  cpustate->D = cpustate->E;
+  m_D = m_E;
   break;
 case 0x54: /*      LD D,H */
 
-  cpustate->D = cpustate->H;
+  m_D = m_H;
   break;
 case 0x55: /*      LD D,L */
 
-  cpustate->D = cpustate->L;
+  m_D = m_L;
   break;
 case 0x56: /*      LD D,(HL) */
 
-  cpustate->D = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  m_D = mem_read_byte( ( m_H << 8 ) | m_L );
   break;
 case 0x57: /*      LD D,A */
 
-  cpustate->D = cpustate->A;
+  m_D = m_A;
   break;
 case 0x58: /*      LD E,B */
 
-  cpustate->E = cpustate->B;
+  m_E = m_B;
   break;
 case 0x59: /*      LD E,C */
 
-  cpustate->E = cpustate->C;
+  m_E = m_C;
   break;
 case 0x5A: /*      LD E,D */
 
-  cpustate->E = cpustate->D;
+  m_E = m_D;
   break;
 case 0x5B: /*      LD E,E */
   break;
 case 0x5C: /*      LD E,H */
 
-  cpustate->E = cpustate->H;
+  m_E = m_H;
   break;
 case 0x5D: /*      LD E,L */
 
-  cpustate->E = cpustate->L;
+  m_E = m_L;
   break;
 case 0x5E: /*      LD E,(HL) */
 
-  cpustate->E = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  m_E = mem_read_byte( ( m_H << 8 ) | m_L );
   break;
 case 0x5F: /*      LD E,A */
 
-  cpustate->E = cpustate->A;
+  m_E = m_A;
   break;
 case 0x60: /*      LD H,B */
 
-  cpustate->H = cpustate->B;
+  m_H = m_B;
   break;
 case 0x61: /*      LD H,C */
 
-  cpustate->H = cpustate->C;
+  m_H = m_C;
   break;
 case 0x62: /*      LD H,D */
 
-  cpustate->H = cpustate->D;
+  m_H = m_D;
   break;
 case 0x63: /*      LD H,E */
 
-  cpustate->H = cpustate->E;
+  m_H = m_E;
   break;
 case 0x64: /*      LD H,H */
   break;
 case 0x65: /*      LD H,L */
 
-  cpustate->H = cpustate->L;
+  m_H = m_L;
   break;
 case 0x66: /*      LD H,(HL) */
 
-  cpustate->H = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  m_H = mem_read_byte( ( m_H << 8 ) | m_L );
   break;
 case 0x67: /*      LD H,A */
 
-  cpustate->H = cpustate->A;
+  m_H = m_A;
   break;
 case 0x68: /*      LD L,B */
 
-  cpustate->L = cpustate->B;
+  m_L = m_B;
   break;
 case 0x69: /*      LD L,C */
 
-  cpustate->L = cpustate->C;
+  m_L = m_C;
   break;
 case 0x6A: /*      LD L,D */
-  cpustate->L = cpustate->D;
+  m_L = m_D;
   break;
 case 0x6B: /*      LD L,E */
 
-  cpustate->L = cpustate->E;
+  m_L = m_E;
   break;
 case 0x6C: /*      LD L,H */
 
-  cpustate->L = cpustate->H;
+  m_L = m_H;
   break;
 case 0x6D: /*      LD L,L */
   break;
 case 0x6E: /*      LD L,(HL) */
 
-  cpustate->L = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  m_L = mem_read_byte( ( m_H << 8 ) | m_L );
   break;
 case 0x6F: /*      LD L,A */
 
-  cpustate->L = cpustate->A;
+  m_L = m_A;
   break;
+
 case 0x70: /*      LD (HL),B */
+	mem_write_byte( ( m_H << 8 ) | m_L, m_B );
+	break;
 
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->B);
-  break;
 case 0x71: /*      LD (HL),C */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->C);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_C );
+	break;
 case 0x72: /*      LD (HL),D */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->D);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_D );
+	break;
 case 0x73: /*      LD (HL),E */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->E);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_E );
+	break;
 case 0x74: /*      LD (HL),H */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->H);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_H );
+	break;
 case 0x75: /*      LD (HL),L */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->L);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_L );
+	break;
 case 0x76: /*      HALT */
-	cpustate->enable |= HALTED;
-	cpustate->PC--;
-  break;
+	m_enable |= HALTED;
+	m_PC--;
+	break;
 case 0x77: /*      LD (HL),A */
-
-  mem_WriteByte (cpustate, ( cpustate->H << 8 ) | cpustate->L, cpustate->A);
-  break;
+	mem_write_byte( ( m_H << 8 ) | m_L, m_A );
+	break;
 case 0x78: /*      LD A,B */
 
-  cpustate->A = cpustate->B;
+  m_A = m_B;
   break;
 case 0x79: /*      LD A,C */
 
-  cpustate->A = cpustate->C;
+  m_A = m_C;
   break;
 case 0x7A: /*      LD A,D */
 
-  cpustate->A = cpustate->D;
+  m_A = m_D;
   break;
 case 0x7B: /*      LD A,E */
 
-  cpustate->A = cpustate->E;
+  m_A = m_E;
   break;
 case 0x7C: /*      LD A,H */
 
-  cpustate->A = cpustate->H;
+  m_A = m_H;
   break;
 case 0x7D: /*      LD A,L */
 
-  cpustate->A = cpustate->L;
+  m_A = m_L;
   break;
 case 0x7E: /*      LD A,(HL) */
 
-  cpustate->A = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  m_A = mem_read_byte( ( m_H << 8 ) | m_L );
   break;
 case 0x7F: /*      LD A,A */
   break;
 case 0x80: /*      ADD A,B */
 
-  ADD_A_X (cpustate->B)
+  ADD_A_X (m_B)
   break;
 case 0x81: /*      ADD A,C */
 
-  ADD_A_X (cpustate->C)
+  ADD_A_X (m_C)
   break;
 case 0x82: /*      ADD A,D */
 
-  ADD_A_X (cpustate->D)
+  ADD_A_X (m_D)
   break;
 case 0x83: /*      ADD A,E */
 
-  ADD_A_X (cpustate->E)
+  ADD_A_X (m_E)
   break;
 case 0x84: /*      ADD A,H */
 
-  ADD_A_X (cpustate->H)
+  ADD_A_X (m_H)
   break;
 case 0x85: /*      ADD A,L */
 
-  ADD_A_X (cpustate->L)
+  ADD_A_X (m_L)
   break;
 case 0x86: /*      ADD A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   ADD_A_X (x)
   break;
 case 0x87: /*      ADD A,A */
 
-  ADD_A_X (cpustate->A)
+  ADD_A_X (m_A)
   break;
 case 0x88: /*      ADC A,B */
 
-  ADC_A_X (cpustate->B)
+  ADC_A_X (m_B)
   break;
 case 0x89: /*      ADC A,C */
 
-  ADC_A_X (cpustate->C)
+  ADC_A_X (m_C)
   break;
 case 0x8A: /*      ADC A,D */
 
-  ADC_A_X (cpustate->D)
+  ADC_A_X (m_D)
   break;
 case 0x8B: /*      ADC A,E */
 
-  ADC_A_X (cpustate->E)
+  ADC_A_X (m_E)
   break;
 case 0x8C: /*      ADC A,H */
 
-  ADC_A_X (cpustate->H)
+  ADC_A_X (m_H)
   break;
 case 0x8D: /*      ADC A,L */
 
-  ADC_A_X (cpustate->L)
+  ADC_A_X (m_L)
   break;
 case 0x8E: /*      ADC A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   ADC_A_X (x)
   break;
 case 0x8F: /*      ADC A,A */
 
-  ADC_A_X (cpustate->A)
+  ADC_A_X (m_A)
   break;
 case 0x90: /*      SUB A,B */
 
-  SUB_A_X (cpustate->B)
+  SUB_A_X (m_B)
   break;
 case 0x91: /*      SUB A,C */
 
-  SUB_A_X (cpustate->C)
+  SUB_A_X (m_C)
   break;
 case 0x92: /*      SUB A,D */
 
-  SUB_A_X (cpustate->D)
+  SUB_A_X (m_D)
   break;
 case 0x93: /*      SUB A,E */
 
-  SUB_A_X (cpustate->E)
+  SUB_A_X (m_E)
   break;
 case 0x94: /*      SUB A,H */
 
-  SUB_A_X (cpustate->H)
+  SUB_A_X (m_H)
   break;
 case 0x95: /*      SUB A,L */
 
-  SUB_A_X (cpustate->L)
+  SUB_A_X (m_L)
   break;
 case 0x96: /*      SUB A,(HL) */
 
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   SUB_A_X (x)
   break;
 case 0x97: /*      SUB A,A */
 
-  SUB_A_X (cpustate->A)
+  SUB_A_X (m_A)
   break;
 case 0x98: /*      SBC A,B */
 
-  SBC_A_X (cpustate->B)
+  SBC_A_X (m_B)
   break;
 case 0x99: /*      SBC A,C */
 
-  SBC_A_X (cpustate->C)
+  SBC_A_X (m_C)
   break;
 case 0x9A: /*      SBC A,D */
 
-  SBC_A_X (cpustate->D)
+  SBC_A_X (m_D)
   break;
 case 0x9B: /*      SBC A,E */
 
-  SBC_A_X (cpustate->E)
+  SBC_A_X (m_E)
   break;
 case 0x9C: /*      SBC A,H */
 
-  SBC_A_X (cpustate->H)
+  SBC_A_X (m_H)
   break;
 case 0x9D: /*      SBC A,L */
 
-  SBC_A_X (cpustate->L)
+  SBC_A_X (m_L)
   break;
 case 0x9E: /*      SBC A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   SBC_A_X (x)
   break;
 case 0x9F: /*      SBC A,A */
 
-  SBC_A_X (cpustate->A)
+  SBC_A_X (m_A)
   break;
 case 0xA0: /*      AND A,B */
 
-  AND_A_X (cpustate->B)
+  AND_A_X (m_B)
   break;
 case 0xA1: /*      AND A,C */
 
-  AND_A_X (cpustate->C)
+  AND_A_X (m_C)
   break;
 case 0xA2: /*      AND A,D */
 
-  AND_A_X (cpustate->D)
+  AND_A_X (m_D)
   break;
 case 0xA3: /*      AND A,E */
 
-  AND_A_X (cpustate->E)
+  AND_A_X (m_E)
   break;
 case 0xA4: /*      AND A,H */
 
-  AND_A_X (cpustate->H)
+  AND_A_X (m_H)
   break;
 case 0xA5: /*      AND A,L */
 
-  AND_A_X (cpustate->L)
+  AND_A_X (m_L)
   break;
 case 0xA6: /*      AND A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   AND_A_X (x)
   break;
 case 0xA7: /*      AND A,A */
 
-  cpustate->F = (cpustate->A == 0) ? (FLAG_H | FLAG_Z) : FLAG_H;
+  m_F = (m_A == 0) ? (FLAG_H | FLAG_Z) : FLAG_H;
   break;
 case 0xA8: /*      XOR A,B */
 
-  XOR_A_X (cpustate->B)
+  XOR_A_X (m_B)
   break;
 case 0xA9: /*      XOR A,C */
 
-  XOR_A_X (cpustate->C)
+  XOR_A_X (m_C)
   break;
 case 0xAA: /*      XOR A,D */
 
-  XOR_A_X (cpustate->D)
+  XOR_A_X (m_D)
   break;
 case 0xAB: /*      XOR A,E */
 
-  XOR_A_X (cpustate->E)
+  XOR_A_X (m_E)
   break;
 case 0xAC: /*      XOR A,H */
 
-  XOR_A_X (cpustate->H)
+  XOR_A_X (m_H)
   break;
 case 0xAD: /*      XOR A,L */
 
-  XOR_A_X (cpustate->L)
+  XOR_A_X (m_L)
   break;
 case 0xAE: /*      XOR A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   XOR_A_X (x)
   break;
 case 0xAF: /*      XOR A,A */
 
-  XOR_A_X (cpustate->A)
+  XOR_A_X (m_A)
   break;
 case 0xB0: /*      OR A,B */
 
-  OR_A_X (cpustate->B)
+  OR_A_X (m_B)
   break;
 case 0xB1: /*      OR A,C */
 
-  OR_A_X (cpustate->C)
+  OR_A_X (m_C)
   break;
 case 0xB2: /*      OR A,D */
 
-  OR_A_X (cpustate->D)
+  OR_A_X (m_D)
   break;
 case 0xB3: /*      OR A,E */
 
-  OR_A_X (cpustate->E)
+  OR_A_X (m_E)
   break;
 case 0xB4: /*      OR A,H */
 
-  OR_A_X (cpustate->H)
+  OR_A_X (m_H)
   break;
 case 0xB5: /*      OR A,L */
 
-  OR_A_X (cpustate->L)
+  OR_A_X (m_L)
   break;
 case 0xB6: /*      OR A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   OR_A_X (x)
   break;
 case 0xB7: /*      OR A,A */
 
-  OR_A_X (cpustate->A)
+  OR_A_X (m_A)
   break;
 case 0xB8: /*      CP A,B */
 
-  CP_A_X (cpustate->B)
+  CP_A_X (m_B)
   break;
 case 0xB9: /*      CP A,C */
 
-  CP_A_X (cpustate->C)
+  CP_A_X (m_C)
   break;
 case 0xBA: /*      CP A,D */
 
-  CP_A_X (cpustate->D)
+  CP_A_X (m_D)
   break;
 case 0xBB: /*      CP A,E */
 
-  CP_A_X (cpustate->E)
+  CP_A_X (m_E)
   break;
 case 0xBC: /*      CP A,H */
 
-  CP_A_X (cpustate->H)
+  CP_A_X (m_H)
   break;
 case 0xBD: /*      CP A,L */
 
-  CP_A_X (cpustate->L)
+  CP_A_X (m_L)
   break;
 case 0xBE: /*      CP A,(HL) */
 
-  x = mem_ReadByte (cpustate, ( cpustate->H << 8 ) | cpustate->L);
+  x = mem_read_byte( ( m_H << 8 ) | m_L );
 
   CP_A_X (x)
   break;
 case 0xBF: /*      CP A,A */
 
-  CP_A_X (cpustate->A)
+  CP_A_X (m_A)
   break;
 case 0xC0: /*      RET NZ */
-	CYCLES_PASSED( 4 );
-	if (!(cpustate->F & FLAG_Z))
+	cycles_passed( 4 );
+	if (!(m_F & FLAG_Z))
 	{
-		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-		cpustate->SP += 2;
-		CYCLES_PASSED( 4 );
+		m_PC = mem_read_word( m_SP );
+		m_SP += 2;
+		cycles_passed( 4 );
 	}
 	break;
 case 0xC1: /*      POP BC */
-	POP( cpustate->B, cpustate->C );
+	POP( m_B, m_C );
 	break;
 case 0xC2: /*      JP NZ,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if ( ! (cpustate->F & FLAG_Z) )
+		if ( ! (m_F & FLAG_Z) )
 		{
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0xC3: /*      JP n16 */
-	cpustate->PC = mem_ReadWord (cpustate, cpustate->PC);
-	CYCLES_PASSED( 4 );
+	m_PC = mem_read_word( m_PC );
+	cycles_passed( 4 );
 	break;
 case 0xC4: /*      CALL NZ,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if ( ! (cpustate->F & FLAG_Z) )
+		if ( ! (m_F & FLAG_Z) )
 		{
-			cpustate->SP -= 2;
-			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_SP -= 2;
+			mem_write_word( m_SP, m_PC );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0xC5: /*      PUSH BC */
-	PUSH( cpustate->B, cpustate->C );
-	CYCLES_PASSED( 4 );
+	PUSH( m_B, m_C );
+	cycles_passed( 4 );
 	break;
 case 0xC6: /*      ADD A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   ADD_A_X (x)
   break;
 case 0xC7: /*      RST 0 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0;
+	cycles_passed( 4 );
 	break;
 case 0xC8: /*      RET Z */
-	CYCLES_PASSED( 4 );
-	if (cpustate->F & FLAG_Z)
+	cycles_passed( 4 );
+	if (m_F & FLAG_Z)
 	{
-		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-		cpustate->SP += 2;
-		CYCLES_PASSED( 4 );
+		m_PC = mem_read_word( m_SP );
+		m_SP += 2;
+		cycles_passed( 4 );
 	}
 	break;
 case 0xC9: /*      RET */
-	cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-	cpustate->SP += 2;
-	CYCLES_PASSED( 4 );
+	m_PC = mem_read_word( m_SP );
+	m_SP += 2;
+	cycles_passed( 4 );
 	break;
 case 0xCA: /*      JP Z,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if (cpustate->F & FLAG_Z)
+		if (m_F & FLAG_Z)
 		{
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0xCB: /*      PREFIX! */
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   switch (x)
   {
     #include "opc_cb.h"
@@ -1221,61 +1222,61 @@
   break;
 case 0xCC: /*      CALL Z,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if (cpustate->F & FLAG_Z)
+		if (m_F & FLAG_Z)
 		{
-			cpustate->SP -= 2;
-			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_SP -= 2;
+			mem_write_word( m_SP, m_PC );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0xCD: /*      CALL n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		cpustate->SP -= 2;
-		mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-		cpustate->PC = addr;
-		CYCLES_PASSED( 4 );
+		m_SP -= 2;
+		mem_write_word( m_SP, m_PC );
+		m_PC = addr;
+		cycles_passed( 4 );
 	}
 	break;
 case 0xCE: /*      ADC A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   ADC_A_X (x)
   break;
 case 0xCF: /*      RST 8 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 8;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 8;
+	cycles_passed( 4 );
 	break;
 case 0xD0: /*      RET NC */
-	CYCLES_PASSED( 4 );
-	if (!(cpustate->F & FLAG_C))
+	cycles_passed( 4 );
+	if (!(m_F & FLAG_C))
 	{
-		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-		cpustate->SP += 2;
-		CYCLES_PASSED( 4 );
+		m_PC = mem_read_word( m_SP );
+		m_SP += 2;
+		cycles_passed( 4 );
 	}
 	break;
 case 0xD1: /*      POP DE */
-	POP( cpustate->D, cpustate->E );
+	POP( m_D, m_E );
 	break;
 case 0xD2: /*      JP NC,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if ( ! (cpustate->F & FLAG_C) )
+		if ( ! (m_F & FLAG_C) )
 		{
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
@@ -1283,57 +1284,57 @@
   break;
 case 0xD4: /*      CALL NC,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if ( ! (cpustate->F & FLAG_C) )
+		if ( ! (m_F & FLAG_C) )
 		{
-			cpustate->SP -= 2;
-			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_SP -= 2;
+			mem_write_word( m_SP, m_PC );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
 case 0xD5: /*      PUSH DE */
-	PUSH( cpustate->D, cpustate->E );
-	CYCLES_PASSED( 4 );
+	PUSH( m_D, m_E );
+	cycles_passed( 4 );
 	break;
 case 0xD6: /*      SUB A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   SUB_A_X (x)
   break;
 case 0xD7: /*      RST     $10 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x10;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x10;
+	cycles_passed( 4 );
 	break;
 case 0xD8: /*      RET C */
-	CYCLES_PASSED( 4 );
-	if (cpustate->F & FLAG_C)
+	cycles_passed( 4 );
+	if (m_F & FLAG_C)
 	{
-		cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-		cpustate->SP += 2;
-		CYCLES_PASSED( 4 );
+		m_PC = mem_read_word( m_SP );
+		m_SP += 2;
+		cycles_passed( 4 );
 	}
 	break;
 case 0xD9: /*      RETI */
-	cpustate->PC = mem_ReadWord (cpustate, cpustate->SP);
-	cpustate->SP += 2;
-	cpustate->enable |= IME;
-	CYCLES_PASSED( 4 );
+	m_PC = mem_read_word( m_SP );
+	m_SP += 2;
+	m_enable |= IME;
+	cycles_passed( 4 );
 	break;
 case 0xDA: /*      JP C,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if (cpustate->F & FLAG_C)
+		if (m_F & FLAG_C)
 		{
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
@@ -1341,15 +1342,15 @@
   break;
 case 0xDC: /*      CALL C,n16 */
 	{
-		UINT16 addr = mem_ReadWord (cpustate, cpustate->PC);
-		cpustate->PC += 2;
+		UINT16 addr = mem_read_word( m_PC );
+		m_PC += 2;
 
-		if (cpustate->F & FLAG_C)
+		if (m_F & FLAG_C)
 		{
-			cpustate->SP -= 2;
-			mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-			cpustate->PC = addr;
-			CYCLES_PASSED( 4 );
+			m_SP -= 2;
+			mem_write_word( m_SP, m_PC );
+			m_PC = addr;
+			cycles_passed( 4 );
 		}
 	}
 	break;
@@ -1357,46 +1358,46 @@
   break;
 case 0xDE: /*      SBC A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   SBC_A_X (x)
   break;
 case 0xDF: /*      RST     $18 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x18;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x18;
+	cycles_passed( 4 );
 	break;
 case 0xE0: /*      LD      ($FF00+n8),A */
   {
-	UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
-	mem_WriteByte (cpustate, 0xFF00 + v, cpustate->A);
+	UINT8 v = mem_read_byte( m_PC++ );
+	mem_write_byte( 0xFF00 + v, m_A );
   }
   break;
 case 0xE1: /*      POP HL */
-	POP( cpustate->H, cpustate->L );
+	POP( m_H, m_L );
 	break;
 case 0xE2: /*      LD ($FF00+C),A */
 
-  mem_WriteByte (cpustate, (UINT16) (0xFF00 + cpustate->C), cpustate->A);
+  mem_write_byte( 0xFF00 + m_C, m_A );
   break;
 case 0xE3: /*      EH? */
   break;
 case 0xE4: /*      EH? */
   break;
 case 0xE5: /*      PUSH HL */
-	PUSH( cpustate->H, cpustate->L );
-	CYCLES_PASSED( 4 );
+	PUSH( m_H, m_L );
+	cycles_passed( 4 );
 	break;
 case 0xE6: /*      AND A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   AND_A_X (x)
   break;
 case 0xE7: /*      RST $20 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x20;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x20;
+	cycles_passed( 4 );
 	break;
 case 0xE8: /*      ADD SP,n8 */
 /*
@@ -1409,33 +1410,33 @@
   {
 	register INT32 n;
 
-	n = (INT8) mem_ReadByte (cpustate, cpustate->PC++);
+	n = (INT8) mem_read_byte( m_PC++ );
 
-	if ( ( cpustate->SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
+	if ( ( m_SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
     {
-      cpustate->F = FLAG_C;
+      m_F = FLAG_C;
     }
     else
     {
-      cpustate->F = 0;
+      m_F = 0;
     }
 
-    if ( ( cpustate->SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
+    if ( ( m_SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
     {
-      cpustate->F |= FLAG_H;
+      m_F |= FLAG_H;
     }
 
-	cpustate->SP = (UINT16) ( cpustate->SP + n );
+	m_SP = (UINT16) ( m_SP + n );
   }
-  CYCLES_PASSED( 8 );
+  cycles_passed( 8 );
   break;
 case 0xE9: /*      JP (HL) */
-	cpustate->PC = ( cpustate->H << 8 ) | cpustate->L;
+	m_PC = ( m_H << 8 ) | m_L;
 	break;
 case 0xEA: /*      LD (n16),A */
 
-  mem_WriteByte (cpustate, mem_ReadWord (cpustate, cpustate->PC), cpustate->A);
-  cpustate->PC += 2;
+  mem_write_byte( mem_read_word( m_PC ), m_A );
+  m_PC += 2;
   break;
 case 0xEB: /*      EH? */
   break;
@@ -1445,50 +1446,50 @@
   break;
 case 0xEE: /*      XOR A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   XOR_A_X (x)
   break;
 case 0xEF: /*      RST $28 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x28;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x28;
+	cycles_passed( 4 );
 	break;
 case 0xF0: /*      LD A,($FF00+n8) */
   {
-	UINT8 v = mem_ReadByte (cpustate, cpustate->PC++);
-	cpustate->A = mem_ReadByte (cpustate, 0xFF00 + v);
+	UINT8 v = mem_read_byte( m_PC++ );
+	m_A = mem_read_byte( 0xFF00 + v );
   }
   break;
 case 0xF1: /*      POP AF */
-	POP( cpustate->A, cpustate->F );
-	cpustate->F &= 0xF0;
+	POP( m_A, m_F );
+	m_F &= 0xF0;
 	break;
 case 0xF2: /*      LD A,($FF00+C) */
 
-  cpustate->A = mem_ReadByte (cpustate, (UINT16) (0xFF00 + cpustate->C));
+  m_A = mem_read_byte( 0xFF00 + m_C );
   break;
 case 0xF3: /*      DI */
-  cpustate->ei_delay = 0;
-  cpustate->enable &= ~IME;
+  m_ei_delay = 0;
+  m_enable &= ~IME;
   break;
 case 0xF4: /*      EH? */
   break;
 case 0xF5: /*      PUSH AF */
-	cpustate->F &= 0xF0;
-	PUSH( cpustate->A, cpustate->F );
-	CYCLES_PASSED( 4 );
+	m_F &= 0xF0;
+	PUSH( m_A, m_F );
+	cycles_passed( 4 );
 	break;
 case 0xF6: /*      OR A,n8 */
 
-  x = mem_ReadByte (cpustate, cpustate->PC++);
+  x = mem_read_byte( m_PC++ );
   OR_A_X (x)
   break;
 case 0xF7: /*      RST $30 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x30;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x30;
+	cycles_passed( 4 );
 	break;
 case 0xF8: /*      LD HL,SP+n8 */
 /*
@@ -1504,52 +1505,52 @@
   {
 	register INT32 n;
 
-	n = (INT8) mem_ReadByte (cpustate, cpustate->PC++);
+	n = (INT8) mem_read_byte( m_PC++ );
 
-	if ( ( cpustate->SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
+	if ( ( m_SP & 0xFF ) + (UINT8)(n & 0xFF) > 0xFF )
     {
-      cpustate->F = FLAG_C;
+      m_F = FLAG_C;
     }
     else
     {
-      cpustate->F = 0;
+      m_F = 0;
     }
 
-	if ( ( cpustate->SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
+	if ( ( m_SP & 0x0F ) + ( n & 0x0F ) > 0x0F )
     {
-      cpustate->F |= FLAG_H;
+      m_F |= FLAG_H;
     }
 
-	UINT16 res = cpustate->SP + n;
+	UINT16 res = m_SP + n;
 
-	cpustate->L = res & 0xFF;
-	cpustate->H = res >> 8;
+	m_L = res & 0xFF;
+	m_H = res >> 8;
   }
-  CYCLES_PASSED( 4 );
+  cycles_passed( 4 );
   break;
 case 0xF9: /*      LD SP,HL */
-	cpustate->SP = ( cpustate->H << 8 ) | cpustate->L;
-	CYCLES_PASSED( 4 );
+	m_SP = ( m_H << 8 ) | m_L;
+	cycles_passed( 4 );
 	break;
 case 0xFA: /*      LD A,(n16) */
-	cpustate->A = mem_ReadByte (cpustate, mem_ReadWord (cpustate, cpustate->PC));
-	cpustate->PC += 2;
+	m_A = mem_read_byte( mem_read_word( m_PC ) );
+	m_PC += 2;
 	break;
 case 0xFB: /*      EI */
-	cpustate->enable |= IME;
-	cpustate->ei_delay = 1;
+	m_enable |= IME;
+	m_ei_delay = 1;
 	break;
 case 0xFC: /*      EH? */
 	break;
 case 0xFD: /*      EH? */
 	break;
 case 0xFE: /*      CP A,n8 */
-	x = mem_ReadByte (cpustate, cpustate->PC++);
+	x = mem_read_byte( m_PC++ );
 	CP_A_X (x)
 	break;
 case 0xFF: /*      RST $38 */
-	cpustate->SP -= 2;
-	mem_WriteWord (cpustate, cpustate->SP, cpustate->PC);
-	cpustate->PC = 0x38;
-	CYCLES_PASSED( 4 );
+	m_SP -= 2;
+	mem_write_word( m_SP, m_PC );
+	m_PC = 0x38;
+	cycles_passed( 4 );
 	break;
diff -Nru src-old/emu/cpu/m6502/ill02.h src/emu/cpu/m6502/ill02.h
--- src-old/emu/cpu/m6502/ill02.h	2010-08-19 17:10:19.000000000 +0200
+++ src/emu/cpu/m6502/ill02.h	2012-03-11 18:17:00.000000000 +0100
@@ -165,10 +165,17 @@
 	A = X = (UINT8)tmp; 										\
 	SET_NZ(A)
 
+/* 6502 ********************************************************
+ *  OAL load accumulator and index X
+ ***************************************************************/
+#define OAL														\
+	A = X = (UINT8)(A&tmp);										\
+	SET_NZ(A)
+
 /* 6510 ********************************************************
  *  OAL load accumulator and index X
  ***************************************************************/
-#define OAL 													\
+#define OAL_6510												\
 	A = X = (UINT8)((A|0xee)&tmp);								\
 	SET_NZ(A)
 
diff -Nru src-old/emu/cpu/m6502/t6510.c src/emu/cpu/m6502/t6510.c
--- src-old/emu/cpu/m6502/t6510.c	2008-01-06 01:47:40.000000000 +0100
+++ src/emu/cpu/m6502/t6510.c	2012-02-29 21:06:12.000000000 +0100
@@ -23,5 +23,339 @@
  *
  *****************************************************************************/
 
-#define insn6510 insn6502
+#undef	OP
+#define OP(nn) INLINE void m6510_##nn(m6502_Regs *cpustate)
+
+/*****************************************************************************
+ *****************************************************************************
+ *
+ *   plain vanilla 6502 opcodes
+ *
+ *****************************************************************************
+ * op    temp     cycles             rdmem   opc  wrmem   ********************/
+
+OP(00) {                  BRK;                 } /* 7 BRK */
+OP(20) {                  JSR;                 } /* 6 JSR */
+OP(40) {                  RTI;                 } /* 6 RTI */
+OP(60) {                  RTS;                 } /* 6 RTS */
+OP(80) { RDOPARG(); NOP;                 } /* 2 NOP IMM */
+OP(a0) { int tmp; RD_IMM; LDY;                 } /* 2 LDY IMM */
+OP(c0) { int tmp; RD_IMM; CPY;                 } /* 2 CPY IMM */
+OP(e0) { int tmp; RD_IMM; CPX;                 } /* 2 CPX IMM */
+
+OP(10) { BPL;                                  } /* 2-4 BPL REL */
+OP(30) { BMI;                                  } /* 2-4 BMI REL */
+OP(50) { BVC;                                  } /* 2-4 BVC REL */
+OP(70) { BVS;                                  } /* 2-4 BVS REL */
+OP(90) { BCC;                                  } /* 2-4 BCC REL */
+OP(b0) { BCS;                                  } /* 2-4 BCS REL */
+OP(d0) { BNE;                                  } /* 2-4 BNE REL */
+OP(f0) { BEQ;                                  } /* 2-4 BEQ REL */
+
+OP(01) { int tmp; RD_IDX; ORA;                 } /* 6 ORA IDX */
+OP(21) { int tmp; RD_IDX; AND;                 } /* 6 AND IDX */
+OP(41) { int tmp; RD_IDX; EOR;                 } /* 6 EOR IDX */
+OP(61) { int tmp; RD_IDX; ADC;                 } /* 6 ADC IDX */
+OP(81) { int tmp; STA; WR_IDX;                 } /* 6 STA IDX */
+OP(a1) { int tmp; RD_IDX; LDA;                 } /* 6 LDA IDX */
+OP(c1) { int tmp; RD_IDX; CMP;                 } /* 6 CMP IDX */
+OP(e1) { int tmp; RD_IDX; SBC;                 } /* 6 SBC IDX */
+
+OP(11) { int tmp; RD_IDY_P; ORA;               } /* 5 ORA IDY page penalty */
+OP(31) { int tmp; RD_IDY_P; AND;               } /* 5 AND IDY page penalty */
+OP(51) { int tmp; RD_IDY_P; EOR;               } /* 5 EOR IDY page penalty */
+OP(71) { int tmp; RD_IDY_P; ADC;               } /* 5 ADC IDY page penalty */
+OP(91) { int tmp; STA; WR_IDY_NP;              } /* 6 STA IDY */
+OP(b1) { int tmp; RD_IDY_P; LDA;               } /* 5 LDA IDY page penalty */
+OP(d1) { int tmp; RD_IDY_P; CMP;               } /* 5 CMP IDY page penalty */
+OP(f1) { int tmp; RD_IDY_P; SBC;               } /* 5 SBC IDY page penalty */
+
+OP(02) {                  KIL;                 } /* 1 KIL */
+OP(22) {                  KIL;                 } /* 1 KIL */
+OP(42) {                  KIL;                 } /* 1 KIL */
+OP(62) {                  KIL;                 } /* 1 KIL */
+OP(82) { RDOPARG(); NOP;                 } /* 2 NOP IMM */
+OP(a2) { int tmp; RD_IMM; LDX;                 } /* 2 LDX IMM */
+OP(c2) { RDOPARG(); NOP;                 } /* 2 NOP IMM */
+OP(e2) { RDOPARG(); NOP;                 } /* 2 NOP IMM */
+
+OP(12) { KIL;                                  } /* 1 KIL */
+OP(32) { KIL;                                  } /* 1 KIL */
+OP(52) { KIL;                                  } /* 1 KIL */
+OP(72) { KIL;                                  } /* 1 KIL */
+OP(92) { KIL;                                  } /* 1 KIL */
+OP(b2) { KIL;                                  } /* 1 KIL */
+OP(d2) { KIL;                                  } /* 1 KIL */
+OP(f2) { KIL;                                  } /* 1 KIL */
+
+OP(03) { int tmp; RD_IDX; WB_EA; SLO; WB_EA;   } /* 7 SLO IDX */
+OP(23) { int tmp; RD_IDX; WB_EA; RLA; WB_EA;   } /* 7 RLA IDX */
+OP(43) { int tmp; RD_IDX; WB_EA; SRE; WB_EA;   } /* 7 SRE IDX */
+OP(63) { int tmp; RD_IDX; WB_EA; RRA; WB_EA;   } /* 7 RRA IDX */
+OP(83) { int tmp;                SAX; WR_IDX;  } /* 6 SAX IDX */
+OP(a3) { int tmp; RD_IDX; LAX;                 } /* 6 LAX IDX */
+OP(c3) { int tmp; RD_IDX; WB_EA; DCP; WB_EA;   } /* 7 DCP IDX */
+OP(e3) { int tmp; RD_IDX; WB_EA; ISB; WB_EA;   } /* 7 ISB IDX */
+
+OP(13) { int tmp; RD_IDY_NP; WB_EA; SLO; WB_EA; } /* 7 SLO IDY */
+OP(33) { int tmp; RD_IDY_NP; WB_EA; RLA; WB_EA; } /* 7 RLA IDY */
+OP(53) { int tmp; RD_IDY_NP; WB_EA; SRE; WB_EA; } /* 7 SRE IDY */
+OP(73) { int tmp; RD_IDY_NP; WB_EA; RRA; WB_EA; } /* 7 RRA IDY */
+OP(93) { int tmp; EA_IDY_NP; SAH; WB_EA;        } /* 5 SAH IDY */
+OP(b3) { int tmp; RD_IDY_P; LAX;                } /* 5 LAX IDY page penalty */
+OP(d3) { int tmp; RD_IDY_NP; WB_EA; DCP; WB_EA; } /* 7 DCP IDY */
+OP(f3) { int tmp; RD_IDY_NP; WB_EA; ISB; WB_EA; } /* 7 ISB IDY */
+
+OP(04) { RD_ZPG_DISCARD; NOP;                  } /* 3 NOP ZPG */
+OP(24) { int tmp; RD_ZPG; BIT;                  } /* 3 BIT ZPG */
+OP(44) { RD_ZPG_DISCARD; NOP;                  } /* 3 NOP ZPG */
+OP(64) { RD_ZPG_DISCARD; NOP;                  } /* 3 NOP ZPG */
+OP(84) { int tmp; STY; WR_ZPG;                  } /* 3 STY ZPG */
+OP(a4) { int tmp; RD_ZPG; LDY;                  } /* 3 LDY ZPG */
+OP(c4) { int tmp; RD_ZPG; CPY;                  } /* 3 CPY ZPG */
+OP(e4) { int tmp; RD_ZPG; CPX;                  } /* 3 CPX ZPG */
+
+OP(14) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+OP(34) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+OP(54) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+OP(74) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+OP(94) { int tmp; STY; WR_ZPX;                  } /* 4 STY ZPX */
+OP(b4) { int tmp; RD_ZPX; LDY;                  } /* 4 LDY ZPX */
+OP(d4) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+OP(f4) { RD_ZPX_DISCARD; NOP;                  } /* 4 NOP ZPX */
+
+OP(05) { int tmp; RD_ZPG; ORA;                  } /* 3 ORA ZPG */
+OP(25) { int tmp; RD_ZPG; AND;                  } /* 3 AND ZPG */
+OP(45) { int tmp; RD_ZPG; EOR;                  } /* 3 EOR ZPG */
+OP(65) { int tmp; RD_ZPG; ADC;                  } /* 3 ADC ZPG */
+OP(85) { int tmp; STA; WR_ZPG;                  } /* 3 STA ZPG */
+OP(a5) { int tmp; RD_ZPG; LDA;                  } /* 3 LDA ZPG */
+OP(c5) { int tmp; RD_ZPG; CMP;                  } /* 3 CMP ZPG */
+OP(e5) { int tmp; RD_ZPG; SBC;                  } /* 3 SBC ZPG */
+
+OP(15) { int tmp; RD_ZPX; ORA;                  } /* 4 ORA ZPX */
+OP(35) { int tmp; RD_ZPX; AND;                  } /* 4 AND ZPX */
+OP(55) { int tmp; RD_ZPX; EOR;                  } /* 4 EOR ZPX */
+OP(75) { int tmp; RD_ZPX; ADC;                  } /* 4 ADC ZPX */
+OP(95) { int tmp; STA; WR_ZPX;                  } /* 4 STA ZPX */
+OP(b5) { int tmp; RD_ZPX; LDA;                  } /* 4 LDA ZPX */
+OP(d5) { int tmp; RD_ZPX; CMP;                  } /* 4 CMP ZPX */
+OP(f5) { int tmp; RD_ZPX; SBC;                  } /* 4 SBC ZPX */
+
+OP(06) { int tmp; RD_ZPG; WB_EA; ASL; WB_EA;    } /* 5 ASL ZPG */
+OP(26) { int tmp; RD_ZPG; WB_EA; ROL; WB_EA;    } /* 5 ROL ZPG */
+OP(46) { int tmp; RD_ZPG; WB_EA; LSR; WB_EA;    } /* 5 LSR ZPG */
+OP(66) { int tmp; RD_ZPG; WB_EA; ROR; WB_EA;    } /* 5 ROR ZPG */
+OP(86) { int tmp; STX; WR_ZPG;                  } /* 3 STX ZPG */
+OP(a6) { int tmp; RD_ZPG; LDX;                  } /* 3 LDX ZPG */
+OP(c6) { int tmp; RD_ZPG; WB_EA; DEC; WB_EA;    } /* 5 DEC ZPG */
+OP(e6) { int tmp; RD_ZPG; WB_EA; INC; WB_EA;    } /* 5 INC ZPG */
+
+OP(16) { int tmp; RD_ZPX; WB_EA; ASL; WB_EA;    } /* 6 ASL ZPX */
+OP(36) { int tmp; RD_ZPX; WB_EA; ROL; WB_EA;    } /* 6 ROL ZPX */
+OP(56) { int tmp; RD_ZPX; WB_EA; LSR; WB_EA;    } /* 6 LSR ZPX */
+OP(76) { int tmp; RD_ZPX; WB_EA; ROR; WB_EA;    } /* 6 ROR ZPX */
+OP(96) { int tmp; STX; WR_ZPY;                  } /* 4 STX ZPY */
+OP(b6) { int tmp; RD_ZPY; LDX;                  } /* 4 LDX ZPY */
+OP(d6) { int tmp; RD_ZPX; WB_EA; DEC; WB_EA;    } /* 6 DEC ZPX */
+OP(f6) { int tmp; RD_ZPX; WB_EA; INC; WB_EA;    } /* 6 INC ZPX */
+
+OP(07) { int tmp; RD_ZPG; WB_EA; SLO; WB_EA;    } /* 5 SLO ZPG */
+OP(27) { int tmp; RD_ZPG; WB_EA; RLA; WB_EA;    } /* 5 RLA ZPG */
+OP(47) { int tmp; RD_ZPG; WB_EA; SRE; WB_EA;    } /* 5 SRE ZPG */
+OP(67) { int tmp; RD_ZPG; WB_EA; RRA; WB_EA;    } /* 5 RRA ZPG */
+OP(87) { int tmp; SAX; WR_ZPG;                  } /* 3 SAX ZPG */
+OP(a7) { int tmp; RD_ZPG; LAX;                  } /* 3 LAX ZPG */
+OP(c7) { int tmp; RD_ZPG; WB_EA; DCP; WB_EA;    } /* 5 DCP ZPG */
+OP(e7) { int tmp; RD_ZPG; WB_EA; ISB; WB_EA;    } /* 5 ISB ZPG */
+
+OP(17) { int tmp; RD_ZPX; WB_EA; SLO; WB_EA;    } /* 6 SLO ZPX */
+OP(37) { int tmp; RD_ZPX; WB_EA; RLA; WB_EA;    } /* 6 RLA ZPX */
+OP(57) { int tmp; RD_ZPX; WB_EA; SRE; WB_EA;    } /* 6 SRE ZPX */
+OP(77) { int tmp; RD_ZPX; WB_EA; RRA; WB_EA;    } /* 6 RRA ZPX */
+OP(97) { int tmp; SAX; WR_ZPY;                  } /* 4 SAX ZPY */
+OP(b7) { int tmp; RD_ZPY; LAX;                  } /* 4 LAX ZPY */
+OP(d7) { int tmp; RD_ZPX; WB_EA; DCP; WB_EA;    } /* 6 DCP ZPX */
+OP(f7) { int tmp; RD_ZPX; WB_EA; ISB; WB_EA;    } /* 6 ISB ZPX */
+
+OP(08) { RD_DUM; PHP;                           } /* 3 PHP */
+OP(28) { RD_DUM; PLP;                           } /* 4 PLP */
+OP(48) { RD_DUM; PHA;                           } /* 3 PHA */
+OP(68) { RD_DUM; PLA;                           } /* 4 PLA */
+OP(88) { RD_DUM; DEY;                           } /* 2 DEY */
+OP(a8) { RD_DUM; TAY;                           } /* 2 TAY */
+OP(c8) { RD_DUM; INY;                           } /* 2 INY */
+OP(e8) { RD_DUM; INX;                           } /* 2 INX */
+
+OP(18) { RD_DUM; CLC;                           } /* 2 CLC */
+OP(38) { RD_DUM; SEC;                           } /* 2 SEC */
+OP(58) { RD_DUM; CLI;                           } /* 2 CLI */
+OP(78) { RD_DUM; SEI;                           } /* 2 SEI */
+OP(98) { RD_DUM; TYA;                           } /* 2 TYA */
+OP(b8) { RD_DUM; CLV;                           } /* 2 CLV */
+OP(d8) { RD_DUM; CLD;                           } /* 2 CLD */
+OP(f8) { RD_DUM; SED;                           } /* 2 SED */
+
+OP(09) { int tmp; RD_IMM; ORA;                  } /* 2 ORA IMM */
+OP(29) { int tmp; RD_IMM; AND;                  } /* 2 AND IMM */
+OP(49) { int tmp; RD_IMM; EOR;                  } /* 2 EOR IMM */
+OP(69) { int tmp; RD_IMM; ADC;                  } /* 2 ADC IMM */
+OP(89) { RD_IMM_DISCARD; NOP;                  } /* 2 NOP IMM */
+OP(a9) { int tmp; RD_IMM; LDA;                  } /* 2 LDA IMM */
+OP(c9) { int tmp; RD_IMM; CMP;                  } /* 2 CMP IMM */
+OP(e9) { int tmp; RD_IMM; SBC;                  } /* 2 SBC IMM */
+
+OP(19) { int tmp; RD_ABY_P; ORA;                } /* 4 ORA ABY page penalty */
+OP(39) { int tmp; RD_ABY_P; AND;                } /* 4 AND ABY page penalty */
+OP(59) { int tmp; RD_ABY_P; EOR;                } /* 4 EOR ABY page penalty */
+OP(79) { int tmp; RD_ABY_P; ADC;                } /* 4 ADC ABY page penalty */
+OP(99) { int tmp; STA; WR_ABY_NP;               } /* 5 STA ABY */
+OP(b9) { int tmp; RD_ABY_P; LDA;                } /* 4 LDA ABY page penalty */
+OP(d9) { int tmp; RD_ABY_P; CMP;                } /* 4 CMP ABY page penalty */
+OP(f9) { int tmp; RD_ABY_P; SBC;                } /* 4 SBC ABY page penalty */
+
+OP(0a) { int tmp; RD_DUM; RD_ACC; ASL; WB_ACC;  } /* 2 ASL A */
+OP(2a) { int tmp; RD_DUM; RD_ACC; ROL; WB_ACC;  } /* 2 ROL A */
+OP(4a) { int tmp; RD_DUM; RD_ACC; LSR; WB_ACC;  } /* 2 LSR A */
+OP(6a) { int tmp; RD_DUM; RD_ACC; ROR; WB_ACC;  } /* 2 ROR A */
+OP(8a) { RD_DUM; TXA;                           } /* 2 TXA */
+OP(aa) { RD_DUM; TAX;                           } /* 2 TAX */
+OP(ca) { RD_DUM; DEX;                           } /* 2 DEX */
+OP(ea) { RD_DUM; NOP;                           } /* 2 NOP */
+
+OP(1a) { RD_DUM; NOP;                           } /* 2 NOP */
+OP(3a) { RD_DUM; NOP;                           } /* 2 NOP */
+OP(5a) { RD_DUM; NOP;                           } /* 2 NOP */
+OP(7a) { RD_DUM; NOP;                           } /* 2 NOP */
+OP(9a) { RD_DUM; TXS;                           } /* 2 TXS */
+OP(ba) { RD_DUM; TSX;                           } /* 2 TSX */
+OP(da) { RD_DUM; NOP;                           } /* 2 NOP */
+OP(fa) { RD_DUM; NOP;                           } /* 2 NOP */
+
+OP(0b) { int tmp; RD_IMM; ANC;                  } /* 2 ANC IMM */
+OP(2b) { int tmp; RD_IMM; ANC;                  } /* 2 ANC IMM */
+OP(4b) { int tmp; RD_IMM; ASR; WB_ACC;          } /* 2 ASR IMM */
+OP(6b) { int tmp; RD_IMM; ARR; WB_ACC;          } /* 2 ARR IMM */
+OP(8b) { int tmp; RD_IMM; AXA;                  } /* 2 AXA IMM */
+OP(ab) { int tmp; RD_IMM; OAL_6510;             } /* 2 OAL IMM */
+OP(cb) { int tmp; RD_IMM; ASX;                  } /* 2 ASX IMM */
+OP(eb) { int tmp; RD_IMM; SBC;                  } /* 2 SBC IMM */
+
+OP(1b) { int tmp; RD_ABY_NP; WB_EA; SLO; WB_EA; } /* 7 SLO ABY */
+OP(3b) { int tmp; RD_ABY_NP; WB_EA; RLA; WB_EA; } /* 7 RLA ABY */
+OP(5b) { int tmp; RD_ABY_NP; WB_EA; SRE; WB_EA; } /* 7 SRE ABY */
+OP(7b) { int tmp; RD_ABY_NP; WB_EA; RRA; WB_EA; } /* 7 RRA ABY */
+OP(9b) { int tmp; EA_ABY_NP; SSH; WB_EA;        } /* 5 SSH ABY */
+OP(bb) { int tmp; RD_ABY_P; AST;                } /* 4 AST ABY page penalty */
+OP(db) { int tmp; RD_ABY_NP; WB_EA; DCP; WB_EA; } /* 7 DCP ABY */
+OP(fb) { int tmp; RD_ABY_NP; WB_EA; ISB; WB_EA; } /* 7 ISB ABY */
+
+OP(0c) { RD_ABS_DISCARD; NOP;                  } /* 4 NOP ABS */
+OP(2c) { int tmp; RD_ABS; BIT;                  } /* 4 BIT ABS */
+OP(4c) { EA_ABS; JMP;                           } /* 3 JMP ABS */
+OP(6c) { int tmp; EA_IND; JMP;                  } /* 5 JMP IND */
+OP(8c) { int tmp; STY; WR_ABS;                  } /* 4 STY ABS */
+OP(ac) { int tmp; RD_ABS; LDY;                  } /* 4 LDY ABS */
+OP(cc) { int tmp; RD_ABS; CPY;                  } /* 4 CPY ABS */
+OP(ec) { int tmp; RD_ABS; CPX;                  } /* 4 CPX ABS */
+
+OP(1c) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+OP(3c) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+OP(5c) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+OP(7c) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+OP(9c) { int tmp; EA_ABX_NP; SYH; WB_EA;        } /* 5 SYH ABX */
+OP(bc) { int tmp; RD_ABX_P; LDY;                } /* 4 LDY ABX page penalty */
+OP(dc) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+OP(fc) { RD_ABX_P_DISCARD; NOP;                } /* 4 NOP ABX page penalty */
+
+OP(0d) { int tmp; RD_ABS; ORA;                  } /* 4 ORA ABS */
+OP(2d) { int tmp; RD_ABS; AND;                  } /* 4 AND ABS */
+OP(4d) { int tmp; RD_ABS; EOR;                  } /* 4 EOR ABS */
+OP(6d) { int tmp; RD_ABS; ADC;                  } /* 4 ADC ABS */
+OP(8d) { int tmp; STA; WR_ABS;                  } /* 4 STA ABS */
+OP(ad) { int tmp; RD_ABS; LDA;                  } /* 4 LDA ABS */
+OP(cd) { int tmp; RD_ABS; CMP;                  } /* 4 CMP ABS */
+OP(ed) { int tmp; RD_ABS; SBC;                  } /* 4 SBC ABS */
+
+OP(1d) { int tmp; RD_ABX_P; ORA;                } /* 4 ORA ABX page penalty */
+OP(3d) { int tmp; RD_ABX_P; AND;                } /* 4 AND ABX page penalty */
+OP(5d) { int tmp; RD_ABX_P; EOR;                } /* 4 EOR ABX page penalty */
+OP(7d) { int tmp; RD_ABX_P; ADC;                } /* 4 ADC ABX page penalty */
+OP(9d) { int tmp; STA; WR_ABX_NP;               } /* 5 STA ABX */
+OP(bd) { int tmp; RD_ABX_P; LDA;                } /* 4 LDA ABX page penalty */
+OP(dd) { int tmp; RD_ABX_P; CMP;                } /* 4 CMP ABX page penalty */
+OP(fd) { int tmp; RD_ABX_P; SBC;                } /* 4 SBC ABX page penalty */
+
+OP(0e) { int tmp; RD_ABS; WB_EA; ASL; WB_EA;    } /* 6 ASL ABS */
+OP(2e) { int tmp; RD_ABS; WB_EA; ROL; WB_EA;    } /* 6 ROL ABS */
+OP(4e) { int tmp; RD_ABS; WB_EA; LSR; WB_EA;    } /* 6 LSR ABS */
+OP(6e) { int tmp; RD_ABS; WB_EA; ROR; WB_EA;    } /* 6 ROR ABS */
+OP(8e) { int tmp; STX; WR_ABS;                  } /* 4 STX ABS */
+OP(ae) { int tmp; RD_ABS; LDX;                  } /* 4 LDX ABS */
+OP(ce) { int tmp; RD_ABS; WB_EA; DEC; WB_EA;    } /* 6 DEC ABS */
+OP(ee) { int tmp; RD_ABS; WB_EA; INC; WB_EA;    } /* 6 INC ABS */
+
+OP(1e) { int tmp; RD_ABX_NP; WB_EA; ASL; WB_EA; } /* 7 ASL ABX */
+OP(3e) { int tmp; RD_ABX_NP; WB_EA; ROL; WB_EA; } /* 7 ROL ABX */
+OP(5e) { int tmp; RD_ABX_NP; WB_EA; LSR; WB_EA; } /* 7 LSR ABX */
+OP(7e) { int tmp; RD_ABX_NP; WB_EA; ROR; WB_EA; } /* 7 ROR ABX */
+OP(9e) { int tmp; EA_ABY_NP; SXH; WB_EA;	} /* 5 SXH ABY */
+OP(be) { int tmp; RD_ABY_P; LDX;		} /* 4 LDX ABY page penalty */
+OP(de) { int tmp; RD_ABX_NP; WB_EA; DEC; WB_EA; } /* 7 DEC ABX */
+OP(fe) { int tmp; RD_ABX_NP; WB_EA; INC; WB_EA; } /* 7 INC ABX */
+
+OP(0f) { int tmp; RD_ABS; WB_EA; SLO; WB_EA;    } /* 6 SLO ABS */
+OP(2f) { int tmp; RD_ABS; WB_EA; RLA; WB_EA;    } /* 6 RLA ABS */
+OP(4f) { int tmp; RD_ABS; WB_EA; SRE; WB_EA;    } /* 6 SRE ABS */
+OP(6f) { int tmp; RD_ABS; WB_EA; RRA; WB_EA;    } /* 6 RRA ABS */
+OP(8f) { int tmp; SAX; WR_ABS;                  } /* 4 SAX ABS */
+OP(af) { int tmp; RD_ABS; LAX;                  } /* 4 LAX ABS */
+OP(cf) { int tmp; RD_ABS; WB_EA; DCP; WB_EA;    } /* 6 DCP ABS */
+OP(ef) { int tmp; RD_ABS; WB_EA; ISB; WB_EA;    } /* 6 ISB ABS */
+
+OP(1f) { int tmp; RD_ABX_NP; WB_EA; SLO; WB_EA; } /* 7 SLO ABX */
+OP(3f) { int tmp; RD_ABX_NP; WB_EA; RLA; WB_EA; } /* 7 RLA ABX */
+OP(5f) { int tmp; RD_ABX_NP; WB_EA; SRE; WB_EA; } /* 7 SRE ABX */
+OP(7f) { int tmp; RD_ABX_NP; WB_EA; RRA; WB_EA; } /* 7 RRA ABX */
+OP(9f) { int tmp; EA_ABY_NP; SAH; WB_EA;        } /* 5 SAH ABY */
+OP(bf) { int tmp; RD_ABY_P; LAX;                } /* 4 LAX ABY page penalty */
+OP(df) { int tmp; RD_ABX_NP; WB_EA; DCP; WB_EA; } /* 7 DCP ABX */
+OP(ff) { int tmp; RD_ABX_NP; WB_EA; ISB; WB_EA; } /* 7 ISB ABX */
+
+/* and here's the array of function pointers */
+
+static void (*const insn6510[0x100])(m6502_Regs *cpustate) = {
+	m6510_00,m6510_01,m6510_02,m6510_03,m6510_04,m6510_05,m6510_06,m6510_07,
+	m6510_08,m6510_09,m6510_0a,m6510_0b,m6510_0c,m6510_0d,m6510_0e,m6510_0f,
+	m6510_10,m6510_11,m6510_12,m6510_13,m6510_14,m6510_15,m6510_16,m6510_17,
+	m6510_18,m6510_19,m6510_1a,m6510_1b,m6510_1c,m6510_1d,m6510_1e,m6510_1f,
+	m6510_20,m6510_21,m6510_22,m6510_23,m6510_24,m6510_25,m6510_26,m6510_27,
+	m6510_28,m6510_29,m6510_2a,m6510_2b,m6510_2c,m6510_2d,m6510_2e,m6510_2f,
+	m6510_30,m6510_31,m6510_32,m6510_33,m6510_34,m6510_35,m6510_36,m6510_37,
+	m6510_38,m6510_39,m6510_3a,m6510_3b,m6510_3c,m6510_3d,m6510_3e,m6510_3f,
+	m6510_40,m6510_41,m6510_42,m6510_43,m6510_44,m6510_45,m6510_46,m6510_47,
+	m6510_48,m6510_49,m6510_4a,m6510_4b,m6510_4c,m6510_4d,m6510_4e,m6510_4f,
+	m6510_50,m6510_51,m6510_52,m6510_53,m6510_54,m6510_55,m6510_56,m6510_57,
+	m6510_58,m6510_59,m6510_5a,m6510_5b,m6510_5c,m6510_5d,m6510_5e,m6510_5f,
+	m6510_60,m6510_61,m6510_62,m6510_63,m6510_64,m6510_65,m6510_66,m6510_67,
+	m6510_68,m6510_69,m6510_6a,m6510_6b,m6510_6c,m6510_6d,m6510_6e,m6510_6f,
+	m6510_70,m6510_71,m6510_72,m6510_73,m6510_74,m6510_75,m6510_76,m6510_77,
+	m6510_78,m6510_79,m6510_7a,m6510_7b,m6510_7c,m6510_7d,m6510_7e,m6510_7f,
+	m6510_80,m6510_81,m6510_82,m6510_83,m6510_84,m6510_85,m6510_86,m6510_87,
+	m6510_88,m6510_89,m6510_8a,m6510_8b,m6510_8c,m6510_8d,m6510_8e,m6510_8f,
+	m6510_90,m6510_91,m6510_92,m6510_93,m6510_94,m6510_95,m6510_96,m6510_97,
+	m6510_98,m6510_99,m6510_9a,m6510_9b,m6510_9c,m6510_9d,m6510_9e,m6510_9f,
+	m6510_a0,m6510_a1,m6510_a2,m6510_a3,m6510_a4,m6510_a5,m6510_a6,m6510_a7,
+	m6510_a8,m6510_a9,m6510_aa,m6510_ab,m6510_ac,m6510_ad,m6510_ae,m6510_af,
+	m6510_b0,m6510_b1,m6510_b2,m6510_b3,m6510_b4,m6510_b5,m6510_b6,m6510_b7,
+	m6510_b8,m6510_b9,m6510_ba,m6510_bb,m6510_bc,m6510_bd,m6510_be,m6510_bf,
+	m6510_c0,m6510_c1,m6510_c2,m6510_c3,m6510_c4,m6510_c5,m6510_c6,m6510_c7,
+	m6510_c8,m6510_c9,m6510_ca,m6510_cb,m6510_cc,m6510_cd,m6510_ce,m6510_cf,
+	m6510_d0,m6510_d1,m6510_d2,m6510_d3,m6510_d4,m6510_d5,m6510_d6,m6510_d7,
+	m6510_d8,m6510_d9,m6510_da,m6510_db,m6510_dc,m6510_dd,m6510_de,m6510_df,
+	m6510_e0,m6510_e1,m6510_e2,m6510_e3,m6510_e4,m6510_e5,m6510_e6,m6510_e7,
+	m6510_e8,m6510_e9,m6510_ea,m6510_eb,m6510_ec,m6510_ed,m6510_ee,m6510_ef,
+	m6510_f0,m6510_f1,m6510_f2,m6510_f3,m6510_f4,m6510_f5,m6510_f6,m6510_f7,
+	m6510_f8,m6510_f9,m6510_fa,m6510_fb,m6510_fc,m6510_fd,m6510_fe,m6510_ff
+};
 
diff -Nru src-old/emu/cpu/m68000/m68000.h src/emu/cpu/m68000/m68000.h
--- src-old/emu/cpu/m68000/m68000.h	2012-02-20 09:25:57.000000000 +0100
+++ src/emu/cpu/m68000/m68000.h	2012-02-28 00:43:07.000000000 +0100
@@ -93,6 +93,8 @@
 
 
 DECLARE_LEGACY_CPU_DEVICE(M68000, m68000);
+DECLARE_LEGACY_CPU_DEVICE(M68301, m68301);
+DECLARE_LEGACY_CPU_DEVICE(M68307, m68307);
 DECLARE_LEGACY_CPU_DEVICE(M68008, m68008);
 DECLARE_LEGACY_CPU_DEVICE(M68008PLCC, m68008plcc);
 DECLARE_LEGACY_CPU_DEVICE(M68010, m68010);
diff -Nru src-old/emu/cpu/m68000/m68kcpu.c src/emu/cpu/m68000/m68kcpu.c
--- src-old/emu/cpu/m68000/m68kcpu.c	2012-02-20 09:25:57.000000000 +0100
+++ src/emu/cpu/m68000/m68kcpu.c	2012-03-11 18:17:00.000000000 +0100
@@ -643,6 +643,8 @@
 {
 	assert(device != NULL);
 	assert(device->type() == M68000 ||
+		   device->type() == M68301 ||
+		   device->type() == M68307 ||
 		   device->type() == M68008 ||
 		   device->type() == M68008PLCC ||
 		   device->type() == M68010 ||
@@ -1327,6 +1329,83 @@
 	write32 = m68k_write32_delegate(FUNC(address_space::write_dword), &space);
 }
 
+
+
+
+UINT16 m68k_memory_interface::simple_read_immediate_16_68307(offs_t address)
+{
+    if ( address >= 0xf0 && address < 0x100 )
+	{
+		return 0;
+	}
+
+	return m_direct->read_decrypted_word(address);
+}
+
+UINT8 m68k_memory_interface::read_byte_68307(offs_t address)
+{
+    if ( address >= 0xf0 && address < 0x100 )
+	{
+		return 0;
+	}
+
+	return m_space->read_byte(address);
+}
+
+UINT16 m68k_memory_interface::read_word_68307(offs_t address)
+{
+    if ( address >= 0xf0 && address < 0x100 )
+	{
+		return 0;
+	}
+
+	return m_space->read_word(address);
+}
+
+UINT32 m68k_memory_interface::read_dword_68307(offs_t address)
+{
+    if ( address >= 0xf0 && address < 0x100 )
+	{
+		return 0;
+	}
+
+	return m_space->read_dword(address);
+}
+
+void m68k_memory_interface::write_byte_68307(offs_t address, UINT8 data)
+{
+	m_space->write_byte(address, data);
+}
+
+void m68k_memory_interface::write_word_68307(offs_t address, UINT16 data)
+{
+	m_space->write_word(address, data);
+}
+
+void m68k_memory_interface::write_dword_68307(offs_t address, UINT32 data)
+{
+	m_space->write_dword(address, data);
+}
+
+
+
+
+void m68k_memory_interface::init16_68307(address_space &space)
+{
+	m_space = &space;
+	m_direct = &space.direct();
+	m_cpustate = get_safe_token(&space.device());
+	opcode_xor = 0;
+
+	readimm16 = m68k_readimm16_delegate(FUNC(m68k_memory_interface::simple_read_immediate_16_68307), this);
+	read8 = m68k_read8_delegate(FUNC(m68k_memory_interface::read_byte_68307), this);
+	read16 = m68k_read16_delegate(FUNC(m68k_memory_interface::read_word_68307), this);
+	read32 = m68k_read32_delegate(FUNC(m68k_memory_interface::read_dword_68307), this);
+	write8 = m68k_write8_delegate(FUNC(m68k_memory_interface::write_byte_68307), this);
+	write16 = m68k_write16_delegate(FUNC(m68k_memory_interface::write_word_68307), this);
+	write32 = m68k_write32_delegate(FUNC(m68k_memory_interface::write_dword_68307), this);
+}
+
 /****************************************************************************
  * 32-bit data memory interface
  ****************************************************************************/
@@ -1830,6 +1909,59 @@
 	}
 }
 
+static CPU_INIT( m68301 )
+{
+//  m68ki_cpu_core *m68k = get_safe_token(device);
+
+	CPU_INIT_CALL(m68000);
+
+	/* there is a basic implementation of this in emu/machine/tmp68301.c but it should be moved here */
+
+}
+
+CPU_GET_INFO( m68301 )
+{
+	switch (state)
+	{
+		/* --- the following bits of info are returned as pointers to data or functions --- */
+		case CPUINFO_FCT_INIT:						info->init = CPU_INIT_NAME(m68301);				break;
+
+		/* --- the following bits of info are returned as NULL-terminated strings --- */
+		case DEVINFO_STR_NAME:						strcpy(info->s, "68301");						break;
+
+		default:									CPU_GET_INFO_CALL(m68k);						break;
+	}
+}
+
+
+static CPU_INIT( m68307 )
+{
+	m68ki_cpu_core *m68k = get_safe_token(device);
+
+	CPU_INIT_CALL(m68000);
+
+	/* basic CS logic, timers, mbus, serial logic
+       set via remappable register
+    */
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init16_68307(*m68k->program);
+
+}
+
+CPU_GET_INFO( m68307 )
+{
+	switch (state)
+	{
+		/* --- the following bits of info are returned as pointers to data or functions --- */
+		case CPUINFO_FCT_INIT:						info->init = CPU_INIT_NAME(m68307);				break;
+
+		/* --- the following bits of info are returned as NULL-terminated strings --- */
+		case DEVINFO_STR_NAME:						strcpy(info->s, "68307");						break;
+
+		default:									CPU_GET_INFO_CALL(m68k);						break;
+	}
+}
+
 
 /****************************************************************************
  * M68008 section
@@ -2538,6 +2670,8 @@
 }
 
 DEFINE_LEGACY_CPU_DEVICE(M68000, m68000);
+DEFINE_LEGACY_CPU_DEVICE(M68301, m68301);
+DEFINE_LEGACY_CPU_DEVICE(M68307, m68307);
 DEFINE_LEGACY_CPU_DEVICE(M68008, m68008);
 DEFINE_LEGACY_CPU_DEVICE(M68008PLCC, m68008plcc);
 DEFINE_LEGACY_CPU_DEVICE(M68010, m68010);
diff -Nru src-old/emu/cpu/m68000/m68kcpu.h src/emu/cpu/m68000/m68kcpu.h
--- src-old/emu/cpu/m68000/m68kcpu.h	2012-02-23 15:07:01.000000000 +0100
+++ src/emu/cpu/m68000/m68kcpu.h	2012-02-28 00:43:07.000000000 +0100
@@ -552,6 +552,7 @@
 public:
 	void init8(address_space &space);
 	void init16(address_space &space);
+	void init16_68307(address_space &space);
 	void init32(address_space &space);
 	void init32mmu(address_space &space);
 	void init32hmmu(address_space &space);
@@ -570,6 +571,14 @@
 	UINT16 read_immediate_16(offs_t address);
 	UINT16 simple_read_immediate_16(offs_t address);
 
+	UINT16 simple_read_immediate_16_68307(offs_t address);
+	UINT8 read_byte_68307(offs_t address);
+	UINT16 read_word_68307(offs_t address);
+	UINT32 read_dword_68307(offs_t address);
+	void write_byte_68307(offs_t address, UINT8 data);
+	void write_word_68307(offs_t address, UINT16 data);
+	void write_dword_68307(offs_t address, UINT32 data);
+
 	UINT8 read_byte_32_mmu(offs_t address);
 	void write_byte_32_mmu(offs_t address, UINT8 data);
 	UINT16 read_immediate_16_mmu(offs_t address);
diff -Nru src-old/emu/cpu/powerpc/ppcdrc.c src/emu/cpu/powerpc/ppcdrc.c
--- src-old/emu/cpu/powerpc/ppcdrc.c	2012-02-25 16:02:06.000000000 +0100
+++ src/emu/cpu/powerpc/ppcdrc.c	2012-03-11 18:17:00.000000000 +0100
@@ -2270,11 +2270,15 @@
 	if (xermask & XER_OV)
 	{
 		UML_ROLAND(block, I0, I0, 31, 1);								// roland  i0,i0,31,0x0001
-		UML_OR(block, XERSO32, XERSO32, I0);											// or      [xerso],i0
-		UML_OR(block, CR32(0), I1, I0);											// or      [cr0],i1,i0
+		UML_OR(block, XERSO32, XERSO32, I0);							// or      [xerso],i0
+        UML_AND(block, CR32(0), CR32(0), 0xfffffffe);                   // and  [cr0], [cr0], 0xfffffffe (clear SO copy in CR32)
+		UML_OR(block, CR32(0), I1, XERSO32);							// or      [cr0],i1,[xerso]
 	}
 	else
-		UML_OR(block, CR32(0), I1, XERSO32);											// or      [cr0],i1,[xerso]
+    {
+        UML_AND(block, CR32(0), CR32(0), 0xfffffffe);                   // and  [cr0], [cr0], 0xfffffffe (clear SO copy in CR32)
+		UML_OR(block, CR32(0), I1, XERSO32);							// or      [cr0],i1,[xerso] (OR in new value from XERSO)
+    }
 }
 
 /*-------------------------------------------------
@@ -2942,7 +2946,7 @@
 			UML_ADD(block, R32(G_RD(op)), R32(G_RA(op)), R32(G_RB(op)));					// add     rd,ra,rb
 			generate_compute_flags(ppc, block, desc, op & M_RC, ((op & M_OE) ? XER_OV : 0), FALSE);
 																							// <update flags>
-			return TRUE;
+            return TRUE;
 
 		case 0x00a:	/* ADDCx */
 		case 0x20a:	/* ADDCOx */
@@ -3068,10 +3072,44 @@
 			return TRUE;
 
 		case 0x1eb:	/* DIVWx */
-		case 0x3eb:	/* DIVWOx */
+        case 0x3eb:	/* DIVWOx */
+            UML_CMP(block, R32(G_RB(op)), 0x0);                 // cmp rb, #0
+            UML_JMPc(block, COND_NE, compiler->labelnum);       // bne 0:
+            UML_CMP(block, R32(G_RA(op)), 0x80000000);          // cmp rb, #80000000
+            UML_JMPc(block, COND_AE, compiler->labelnum);       // bae 0:
+
+            UML_MOV(block, R32(G_RD(op)), 0x0);                 // move rd, #0
+            if (op & M_OE)
+            {
+                UML_OR(block, XERSO32, XERSO32, 0x1);           // SO = 1
+            }
+            UML_JMP(block, compiler->labelnum+3);               // jmp 3:
+
+            UML_LABEL(block, compiler->labelnum++);             // 0:
+
+            UML_CMP(block, R32(G_RB(op)), 0x0);                 // cmp rb, #0
+            UML_JMPc(block, COND_Z, compiler->labelnum);        // beq 1:
+
+            UML_CMP(block, R32(G_RB(op)), 0xffffffff);          // cmp rb, #ffffffff
+            UML_JMPc(block, COND_NE, compiler->labelnum+1);     // bne 2:
+            UML_CMP(block, R32(G_RA(op)), 0x80000000);          // cmp ra, #80000000
+            UML_JMPc(block, COND_NE, compiler->labelnum+1);     // bne 2:
+
+            UML_LABEL(block, compiler->labelnum++);             // 1:
+            // do second branch
+            UML_MOV(block, R32(G_RD(op)), 0xffffffff);          // move rd, #ffffffff
+            if (op & M_OE)
+            {
+                UML_OR(block, XERSO32, XERSO32, 0x1);           // SO = 1
+            }
+            UML_JMP(block, compiler->labelnum+1);               // jmp 3:
+
+            UML_LABEL(block, compiler->labelnum++);             // 2:
 			UML_DIVS(block, R32(G_RD(op)), R32(G_RD(op)), R32(G_RA(op)), R32(G_RB(op)));	// divs    rd,rd,ra,rb
-			generate_compute_flags(ppc, block, desc, op & M_RC, ((op & M_OE) ? XER_OV : 0), FALSE);// <update flags>
-			return TRUE;
+            generate_compute_flags(ppc, block, desc, op & M_RC, ((op & M_OE) ? XER_OV : 0), FALSE);// <update flags>
+
+            UML_LABEL(block, compiler->labelnum++);             // 3:
+            return TRUE;
 
 		case 0x01c:	/* ANDx */
 			UML_AND(block, R32(G_RA(op)), R32(G_RS(op)), R32(G_RB(op)));					// and     ra,rs,rb
diff -Nru src-old/emu/cpu/tms57002/57002dsm.c src/emu/cpu/tms57002/57002dsm.c
--- src-old/emu/cpu/tms57002/57002dsm.c	2010-01-10 01:29:26.000000000 +0100
+++ src/emu/cpu/tms57002/57002dsm.c	2012-03-09 20:13:38.000000000 +0100
@@ -1,14 +1,47 @@
+/***************************************************************************
+
+    57002dsm.c
+
+    TMS57002 "DASP" emulator.
+
+****************************************************************************
+
+    Copyright Olivier Galibert
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
 #include "emu.h"
 #include "debugger.h"
 #include "tms57002.h"
 
-#ifdef __GNUC__
-#define noinline __attribute__((noinline))
-#else
-#define noinline /* */
-#endif
-
-static const char *tms57002_get_memadr(UINT32 opcode, char type)
+const char *tms57002_device::get_memadr(UINT32 opcode, char type)
 {
 	static char buff[2][10];
 	static int index = 0;
@@ -31,8 +64,17 @@
 	return buf;
 }
 
+UINT32 tms57002_device::disasm_min_opcode_bytes() const
+{
+	return 4;
+}
+
+UINT32 tms57002_device::disasm_max_opcode_bytes() const
+{
+	return 4;
+}
 
-CPU_DISASSEMBLE(tms57002)
+offs_t tms57002_device::disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options)
 {
 	UINT32 opcode = opram[0] | (opram[1] << 8) | (opram[2] << 16);
 	UINT8 fa = opcode >> 18;
diff -Nru src-old/emu/cpu/tms57002/tms57002.c src/emu/cpu/tms57002/tms57002.c
--- src-old/emu/cpu/tms57002/tms57002.c	2011-03-27 08:37:24.000000000 +0200
+++ src/emu/cpu/tms57002/tms57002.c	2012-03-09 20:13:38.000000000 +0100
@@ -1,439 +1,299 @@
+/***************************************************************************
+
+    tms57002.c
+
+    TMS57002 "DASP" emulator.
+
+****************************************************************************
+
+    Copyright Olivier Galibert
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#define ADDRESS_MAP_MODERN
+
 #include "emu.h"
 #include "debugger.h"
 #include "tms57002.h"
-#include "tms57kpr.h"
 
-INLINE tms57002_t *get_safe_token(device_t *device)
+const device_type TMS57002 = &device_creator<tms57002_device>;
+
+// Can't use a DEVICE_ADDRESS_MAP, not yet anyway
+static ADDRESS_MAP_START(internal_pgm, AS_PROGRAM, 32, tms57002_device)
+	AM_RANGE(0x000, 0x3ff) AM_RAM
+ADDRESS_MAP_END
+
+tms57002_device::tms57002_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: cpu_device(mconfig, TMS57002, "TMS57002", tag, owner, clock),
+	  program_config("program", ENDIANNESS_LITTLE, 32, 8, -2, ADDRESS_MAP_NAME(internal_pgm)),
+	  data_config("data", ENDIANNESS_LITTLE, 8, 20)
 {
-	assert(device != NULL);
-	assert(device->type() == TMS57002);
-	return (tms57002_t *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-static void tms57002_cache_flush(tms57002_t *s);
 
-WRITE8_DEVICE_HANDLER(tms57002_pload_w)
+WRITE8_MEMBER(tms57002_device::pload_w)
 {
-	tms57002_t *s = get_safe_token(device);
-	UINT8 olds = s->sti;
-
+	UINT8 olds = sti;
 	if(data)
-		s->sti &= ~IN_PLOAD;
+		sti &= ~IN_PLOAD;
 	else
-		s->sti |= IN_PLOAD;
-
-	if(olds ^ s->sti)
-		s->hidx = 0;
+		sti |= IN_PLOAD;
+	if(olds ^ sti)
+		hidx = 0;
 }
 
-WRITE8_DEVICE_HANDLER(tms57002_cload_w)
+WRITE8_MEMBER(tms57002_device::cload_w)
 {
-	tms57002_t *s = get_safe_token(device);
-	UINT8 olds = s->sti;
+	UINT8 olds = sti;
 	if(data)
-		s->sti &= ~IN_CLOAD;
+		sti &= ~IN_CLOAD;
 	else
-		s->sti |= IN_CLOAD;
-	if(olds ^ s->sti)
-		s->hidx = 0;
+		sti |= IN_CLOAD;
+	if(olds ^ sti)
+		hidx = 0;
 }
 
-static CPU_RESET(tms57002)
+void tms57002_device::device_reset()
 {
-	tms57002_t *s = get_safe_token(device);
-
-	s->sti = (s->sti & ~(SU_MASK|S_READ|S_WRITE|S_BRANCH|S_HOST)) | (SU_ST0|S_IDLE);
-	s->pc = 0;
-	s->ca = 0;
-	s->hidx = 0;
-	s->id = 0;
-	s->ba0 = 0;
-	s->ba1 = 0;
-	s->st0 &= ~(ST0_INCS | ST0_DIRI | ST0_FI | ST0_SIM | ST0_PLRI |
-				ST0_PBCI | ST0_DIRO | ST0_FO | ST0_SOM | ST0_PLRO |
-				ST0_PBCO | ST0_CNS);
-	s->st1 &= ~(ST1_AOV | ST1_SFAI | ST1_SFAO | ST1_MOVM | ST1_MOV |
-				ST1_SFMA | ST1_SFMO | ST1_RND | ST1_CRM | ST1_DBP);
+	sti = (sti & ~(SU_MASK|S_READ|S_WRITE|S_BRANCH|S_HOST)) | (SU_ST0|S_IDLE);
+	pc = 0;
+	ca = 0;
+	hidx = 0;
+	id = 0;
+	ba0 = 0;
+	ba1 = 0;
+	st0 &= ~(ST0_INCS | ST0_DIRI | ST0_FI | ST0_SIM | ST0_PLRI |
+			ST0_PBCI | ST0_DIRO | ST0_FO | ST0_SOM | ST0_PLRO |
+			ST0_PBCO | ST0_CNS);
+	st1 &= ~(ST1_AOV | ST1_SFAI | ST1_SFAO | ST1_MOVM | ST1_MOV |
+			ST1_SFMA | ST1_SFMO | ST1_RND | ST1_CRM | ST1_DBP);
 
-	s->xba = 0; // Not sure but makes sense
+	xba = 0; // Not sure but makes sense
 
-	tms57002_cache_flush(s);
+	cache_flush();
 }
 
-
-WRITE8_DEVICE_HANDLER(tms57002_data_w)
+WRITE8_MEMBER(tms57002_device::data_w)
 {
-	tms57002_t *s = get_safe_token(device);
-
-	switch(s->sti & (IN_PLOAD|IN_CLOAD)) {
+	switch(sti & (IN_PLOAD|IN_CLOAD)) {
 	case 0:
-		s->hidx = 0;
-		s->sti &= ~SU_CVAL;
+		hidx = 0;
+		sti &= ~SU_CVAL;
 		break;
 	case IN_PLOAD:
-		s->host[s->hidx++] = data;
-		if(s->hidx >= 3) {
-			UINT32 val = (s->host[0]<<16) | (s->host[1]<<8) | s->host[2];
-			s->hidx = 0;
+		host[hidx++] = data;
+		if(hidx >= 3) {
+			UINT32 val = (host[0]<<16) | (host[1]<<8) | host[2];
+			hidx = 0;
 
-			switch(s->sti & SU_MASK) {
+			switch(sti & SU_MASK) {
 			case SU_ST0:
-				s->st0 = val;
-				s->sti = (s->sti & ~SU_MASK) | SU_ST1;
+				st0 = val;
+				sti = (sti & ~SU_MASK) | SU_ST1;
 				break;
 			case SU_ST1:
-				s->st1 = val;
-				s->sti = (s->sti & ~SU_MASK) | SU_PRG;
+				st1 = val;
+				sti = (sti & ~SU_MASK) | SU_PRG;
 				break;
 			case SU_PRG:
-				s->program->write_dword((s->pc++) << 2, val);
+				program->write_dword((pc++) << 2, val);
 				break;
 			}
 		}
 		break;
 	case IN_CLOAD:
-		if(s->sti & SU_CVAL) {
-			s->host[s->hidx++] = data;
-			if(s->hidx >= 4) {
-				UINT32 val = (s->host[0]<<24) | (s->host[1]<<16) | (s->host[2]<<8) | s->host[3];
-				s->cmem[s->sa] = val;
-				s->sti &= ~SU_CVAL;
-				s->allow_update = 0;
+		if(sti & SU_CVAL) {
+			host[hidx++] = data;
+			if(hidx >= 4) {
+				UINT32 val = (host[0]<<24) | (host[1]<<16) | (host[2]<<8) | host[3];
+				cmem[sa] = val;
+				sti &= ~SU_CVAL;
+				allow_update = 0;
 			}
 		} else {
-			s->sa = data;
-			s->hidx = 0;
-			s->sti |= SU_CVAL;
+			sa = data;
+			hidx = 0;
+			sti |= SU_CVAL;
 		}
 
 		break;
 	case IN_PLOAD|IN_CLOAD:
-		s->host[s->hidx++] = data;
-		if(s->hidx >= 4) {
-			UINT32 val = (s->host[0]<<24) | (s->host[1]<<16) | (s->host[2]<<8) | s->host[3];
-			s->hidx = 0;
-			s->cmem[s->ca++] = val;
+		host[hidx++] = data;
+		if(hidx >= 4) {
+			UINT32 val = (host[0]<<24) | (host[1]<<16) | (host[2]<<8) | host[3];
+			hidx = 0;
+			cmem[ca++] = val;
 		}
 		break;
 	};
 }
 
-READ8_DEVICE_HANDLER(tms57002_data_r)
+READ8_MEMBER(tms57002_device::data_r)
 {
-	tms57002_t *s = get_safe_token(device);
 	UINT8 res;
-	if(!(s->sti & S_HOST))
+	if(!(sti & S_HOST))
 		return 0xff;
 
-	res = s->host[s->hidx];
-	s->hidx++;
-	if(s->hidx == 4) {
-		s->hidx = 0;
-		s->sti &= ~S_HOST;
+	res = host[hidx];
+	hidx++;
+	if(hidx == 4) {
+		hidx = 0;
+		sti &= ~S_HOST;
 	}
 
 	return res;
 }
 
-READ8_DEVICE_HANDLER(tms57002_empty_r)
+READ8_MEMBER(tms57002_device::empty_r)
 {
 	return 1;
 }
 
-READ8_DEVICE_HANDLER(tms57002_dready_r)
+READ8_MEMBER(tms57002_device::dready_r)
 {
-	tms57002_t *s = get_safe_token(device);
-	return s->sti & S_HOST ? 0 : 1;
+	return sti & S_HOST ? 0 : 1;
 }
 
-void tms57002_sync(device_t *device)
+void tms57002_device::sync()
 {
-	tms57002_t *s = get_safe_token(device);
-
-	if(s->sti & (IN_PLOAD | IN_CLOAD))
+	if(sti & (IN_PLOAD | IN_CLOAD))
 		return;
 
-	s->allow_update = 1;
-	s->pc = 0;
-	s->ca = 0;
-	s->id = 0;
-	if(!(s->st0 & ST0_INCS)) {
-		s->ba0--;
-		s->ba1++;
-	}
-	s->xba = (s->xba-1) & 0x7ffff;
-	s->st1 &= ~(ST1_AOV | ST1_MOV);
-	s->sti &= ~S_IDLE;
-}
-
-#ifdef UNUSED_FUNCTION
-static UINT32 tms57002_read_c(tms57002_t *s, UINT8 index)
-{
-	UINT32 v = s->cmem[index];
-	if((s->st1 & ST1_CRM) != ST1_CRM_32) {
-		if((s->st1 & ST1_CRM) == ST1_CRM_16H)
-			v &= 0xffff0000;
-		else if((s->st1 & ST1_CRM) == ST1_CRM_16L)
-			v <<= 16;
-	}
-	return v;
-}
-
-static void tms57002_write_c(tms57002_t *s, UINT8 index, UINT32 v)
-{
-	s->cmem[index] = v;
-}
-
-static void tms57002_write_d(tms57002_t *s, UINT8 index, UINT32 v)
-{
-	if(s->st1 & ST1_DBP)
-		s->dmem1[(s->ba1 + index) & 0x1f] = v;
-	else
-		s->dmem0[(s->ba0 + index) & 0xff] = v;
-}
-
-static UINT32 tms57002_read_d(tms57002_t *s, UINT8 index)
-{
-	if(s->st1 & ST1_DBP)
-		return s->dmem1[(s->ba1 + index) & 0x1f];
-	else
-		return s->dmem0[(s->ba0 + index) & 0xff];
-}
-
-static void tms57002_opc_write_c(tms57002_t *s, UINT32 opcode, UINT32 v)
-{
-	if(opcode & 0x400) {
-		if(opcode & 0x100)
-			tms57002_write_c(s, opcode & 0xff, v);
-		else if(opcode & 0x80)
-			tms57002_write_c(s, s->ca++, v);
-		else
-			tms57002_write_c(s, s->ca, v);
-	} else if(opcode & 0x200)
-		tms57002_write_c(s, s->ca++, v);
-	else
-		tms57002_write_c(s, s->ca, v);
-}
-
-static UINT32 tms57002_opc_read_c(tms57002_t *s, UINT32 opcode)
-{
-	if(opcode & 0x400) {
-		if(opcode & 0x100)
-			return tms57002_read_c(s, opcode & 0xff);
-		else if(opcode & 0x80)
-			return tms57002_read_c(s, s->ca++);
-		else
-			return tms57002_read_c(s, s->ca);
-	} else if(opcode & 0x200)
-		return tms57002_read_c(s, s->ca++);
-	else
-		return tms57002_read_c(s, s->ca);
-}
-
-static void tms57002_opc_write_d(tms57002_t *s, UINT32 opcode, UINT32 v)
-{
-	if(!(opcode & 0x400)) {
-		if(opcode & 0x100)
-			tms57002_write_d(s, opcode & 0xff, v);
-		else if(opcode & 0x80)
-			tms57002_write_d(s, s->id++, v);
-		else
-			tms57002_write_d(s, s->id, v);
-	} else if(opcode & 0x200)
-		tms57002_write_d(s, s->id++, v);
-	else
-		tms57002_write_d(s, s->id, v);
-}
-
-static UINT32 tms57002_opc_read_d(tms57002_t *s, UINT32 opcode)
-{
-	if(!(opcode & 0x400)) {
-		if(opcode & 0x100)
-			return tms57002_read_d(s, opcode & 0xff);
-		else if(opcode & 0x80)
-			return tms57002_read_d(s, s->id++);
-		else
-			return tms57002_read_d(s, s->id);
-	} else if(opcode & 0x200)
-		return tms57002_read_d(s, s->id++);
-	else
-		return tms57002_read_d(s, s->id);
+	allow_update = 1;
+	pc = 0;
+	ca = 0;
+	id = 0;
+	if(!(st0 & ST0_INCS)) {
+		ba0--;
+		ba1++;
+	}
+	xba = (xba-1) & 0x7ffff;
+	st1 &= ~(ST1_AOV | ST1_MOV);
+	sti &= ~S_IDLE;
 }
-#endif
 
-static void tms57002_xm_init(tms57002_t *s)
+void tms57002_device::xm_init()
 {
-	UINT32 adr = s->xoa + s->xba;
+	UINT32 adr = xoa + xba;
 	UINT32 mask = 0;
 
-	switch(s->st0 & ST0_M) {
+	switch(st0 & ST0_M) {
 	case ST0_M_64K:  mask = 0x0ffff; break;
 	case ST0_M_256K: mask = 0x3ffff; break;
 	case ST0_M_1M:   mask = 0xfffff; break;
 	}
-	if(s->st0 & ST0_WORD)
+	if(st0 & ST0_WORD)
 		adr <<= 2;
 	else
 		adr <<= 1;
 
-	if(!(s->st0 & ST0_SEL))
+	if(!(st0 & ST0_SEL))
 		adr <<= 1;
 
-	s->xm_adr = adr & mask;
+	xm_adr = adr & mask;
 }
 
-static void tms57002_xm_step_read(tms57002_t *s)
+void tms57002_device::xm_step_read()
 {
-	UINT32 adr = s->xm_adr;
-	UINT8 v = s->data->read_byte(adr);
+	UINT32 adr = xm_adr;
+	UINT8 v = data->read_byte(adr);
 	int done;
-	if(s->st0 & ST0_WORD) {
-		if(s->st0 & ST0_SEL) {
+	if(st0 & ST0_WORD) {
+		if(st0 & ST0_SEL) {
 			int off = (adr & 3) << 3;
-			s->xrd = (s->xrd & ~(0xff << off)) | (v << off);
+			xrd = (xrd & ~(0xff << off)) | (v << off);
 			done = off == 16;
 		} else {
 			int off = (adr & 7) << 2;
-			s->xrd = (s->xrd & ~(0xf << off)) | ((v & 0xf) << off);
+			xrd = (xrd & ~(0xf << off)) | ((v & 0xf) << off);
 			done = off == 20;
 		}
 	} else {
-		if(s->st0 & ST0_SEL) {
+		if(st0 & ST0_SEL) {
 			int off = (adr & 1) << 3;
-			s->xrd = (s->xrd & ~(0xff << off)) | (v << off);
+			xrd = (xrd & ~(0xff << off)) | (v << off);
 			done = off == 8;
 			if(done)
-				s->xrd &= 0x00ffff;
+				xrd &= 0x00ffff;
 		} else {
 			int off = (adr & 3) << 2;
-			s->xrd = (s->xrd & ~(0xf << off)) | ((v & 0xf) << off);
+			xrd = (xrd & ~(0xf << off)) | ((v & 0xf) << off);
 			done = off == 12;
 			if(done)
-				s->xrd &= 0x00ffff;
+				xrd &= 0x00ffff;
 		}
 	}
 	if(done) {
-		s->sti &= ~S_READ;
-		s->xm_adr = 0;
+		sti &= ~S_READ;
+		xm_adr = 0;
 	} else
-		s->xm_adr = adr+1;
+		xm_adr = adr+1;
 }
 
-static void tms57002_xm_step_write(tms57002_t *s)
+void tms57002_device::xm_step_write()
 {
-	UINT32 adr = s->xm_adr;
+	UINT32 adr = xm_adr;
 	UINT8 v;
 	int done;
-	if(s->st0 & ST0_WORD) {
-		if(s->st0 & ST0_SEL) {
+	if(st0 & ST0_WORD) {
+		if(st0 & ST0_SEL) {
 			int off = (adr & 3) << 3;
-			v = s->xwr >> off;
+			v = xwr >> off;
 			done = off == 16;
 		} else {
 			int off = (adr & 7) << 2;
-			v = (s->xwr >> off) & 0xf;
+			v = (xwr >> off) & 0xf;
 			done = off == 20;
 		}
 	} else {
-		if(s->st0 & ST0_SEL) {
+		if(st0 & ST0_SEL) {
 			int off = (adr & 1) << 3;
-			v = s->xwr >> off;
+			v = xwr >> off;
 			done = off == 8;
 		} else {
 			int off = (adr & 3) << 2;
-			v = (s->xwr >> off) & 0xf;
+			v = (xwr >> off) & 0xf;
 			done = off == 12;
 		}
 	}
-	s->data->write_byte(adr, v);
+	data->write_byte(adr, v);
 	if(done) {
-		s->sti &= ~S_WRITE;
-		s->xm_adr = 0;
+		sti &= ~S_WRITE;
+		xm_adr = 0;
 	} else
-		s->xm_adr = adr+1;
-}
-
-#ifdef UNUSED_FUNCTION
-static UINT32 tms57002_aacc_to_output(tms57002_t *s)
-{
-	if(s->st1 & ST1_SFAO)
-		return s->aacc << 7;
-	else
-		return s->aacc;
+		xm_adr = adr+1;
 }
 
-static INT64 tms57002_macc_to_output(tms57002_t *s)
+INT64 tms57002_device::macc_to_output_0(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
-	UINT64 m1;
-	int over = 0, rmode;
-	static const INT64 rounding[8] = {
-		0,
-		1LL << (48-32-1),
-		1LL << (48-24-1),
-		1LL << (48-30-1),
-		1LL << (48-16-1),
-		0, 0, 0
-	};
-	static const UINT64 rmask[8] = {
-		~0ULL,
-		(~0ULL) << (48-32),
-		(~0ULL) << (48-24),
-		(~0ULL) << (48-30),
-		(~0ULL) << (48-16),
-		~0ULL, ~0ULL, ~0ULL
-	};
-
-	// Overflow detection and shifting
-	switch((s->st1 & ST1_SFMO) >> ST1_SFMO_SHIFT) {
-	case 0: // sfmo 0
-		m1 = m & 0xf800000000000ULL;
-		if(m1 && m1 != 0xf800000000000ULL)
-			over = 1;
-		break;
-	case 1: // sfmo 2
-		m1 = m & 0xfe00000000000ULL;
-		if(m1 && m1 != 0xfe00000000000ULL)
-			over = 1;
-		m <<= 2;
-		break;
-	case 2: // sfmo 4
-		m1 = m & 0xff80000000000ULL;
-		if(m1 && m1 != 0xff80000000000ULL)
-			over = 1;
-		m <<= 4;
-		break;
-	case 3: // sfmo -8
-		m >>= 8;
-		break;
-	}
-
-	// Rounder
-	rmode = (s->st1 & ST1_RND) >> ST1_RND_SHIFT;
-	m = (m + rounding[rmode]) & rmask[rmode];
-
-	// Second overflow detection
-	m1 = m & 0xf800000000000ULL;
-	if(m1 && m1 != 0xf800000000000ULL)
-		over = 1;
-
-	// Overflow handling
-	if(over) {
-		s->st1 |= ST1_MOV;
-		if(s->st1 & ST1_MOVM) {
-			if(m & 0x8000000000000ULL)
-				m = 0xffff800000000000ULL;
-			else
-				m = 0x00007fffffffffffULL;
-		}
-	}
-	return m;
-}
-#endif
-
-static noinline INT64 tms57002_macc_to_output_0(tms57002_t *s, INT64 rounding, UINT64 rmask)
-{
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -451,14 +311,14 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_1(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_1(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -477,14 +337,14 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_2(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_2(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -503,14 +363,14 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_3(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_3(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -526,14 +386,14 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_0s(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_0s(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -551,7 +411,7 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -560,9 +420,9 @@
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_1s(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_1s(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -581,7 +441,7 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -590,9 +450,9 @@
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_2s(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_2s(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -611,7 +471,7 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -620,9 +480,9 @@
 	return m;
 }
 
-static noinline INT64 tms57002_macc_to_output_3s(tms57002_t *s, INT64 rounding, UINT64 rmask)
+INT64 tms57002_device::macc_to_output_3s(INT64 rounding, UINT64 rmask)
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 	int over = 0;
 
@@ -638,7 +498,7 @@
 
 	// Overflow handling
 	if(over) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -647,101 +507,59 @@
 	return m;
 }
 
-#ifdef UNUSED_FUNCTION
-static INT64 tms57002_check_macc_overflow(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_0()
 {
-	INT64 m = s->macc;
-	UINT64 m1;
-	int over = 0;
-
-	// Overflow detection
-	switch((s->st1 & ST1_SFMO) >> ST1_SFMO_SHIFT) {
-	case 0: // sfmo 0
-		m1 = m & 0xf800000000000ULL;
-		if(m1 && m1 != 0xf800000000000ULL)
-			over = 1;
-		break;
-	case 1: // sfmo 2
-		m1 = m & 0xfe00000000000ULL;
-		if(m1 && m1 != 0xfe00000000000ULL)
-			over = 1;
-		break;
-	case 2: // sfmo 4
-		m1 = m & 0xff80000000000ULL;
-		if(m1 && m1 != 0xff80000000000ULL)
-			over = 1;
-		break;
-	case 3: // sfmo -8
-		break;
-	}
-
-	// Overflow handling
-	if(over) {
-		s->st1 |= ST1_MOV;
-		if(s->st1 & ST1_MOVM) {
-			if(m & 0x8000000000000ULL)
-				m = 0xffff800000000000ULL;
-			else
-				m = 0x00007fffffffffffULL;
-		}
-	}
-	return m;
-}
-#endif
-
-static noinline INT64 tms57002_check_macc_overflow_0(tms57002_t *s)
-{
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xf800000000000ULL;
 	if(m1 && m1 != 0xf800000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_check_macc_overflow_1(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_1()
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xfe00000000000ULL;
 	if(m1 && m1 != 0xfe00000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static noinline INT64 tms57002_check_macc_overflow_2(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_2()
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xff80000000000ULL;
 	if(m1 && m1 != 0xff80000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 	}
 	return m;
 }
 
-static INT64 tms57002_check_macc_overflow_3(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_3()
 {
-	return s->macc;
+	return macc;
 }
 
-static noinline INT64 tms57002_check_macc_overflow_0s(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_0s()
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xf800000000000ULL;
 	if(m1 && m1 != 0xf800000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -750,15 +568,15 @@
 	return m;
 }
 
-static noinline INT64 tms57002_check_macc_overflow_1s(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_1s()
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xfe00000000000ULL;
 	if(m1 && m1 != 0xfe00000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -767,15 +585,15 @@
 	return m;
 }
 
-static noinline INT64 tms57002_check_macc_overflow_2s(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_2s()
 {
-	INT64 m = s->macc;
+	INT64 m = macc;
 	UINT64 m1;
 
 	// Overflow detection
 	m1 = m & 0xff80000000000ULL;
 	if(m1 && m1 != 0xff80000000000ULL) {
-		s->st1 |= ST1_MOV;
+		st1 |= ST1_MOV;
 		if(m & 0x8000000000000ULL)
 			m = 0xffff800000000000ULL;
 		else
@@ -784,279 +602,153 @@
 	return m;
 }
 
-static INT64 tms57002_check_macc_overflow_3s(tms57002_t *s)
+INT64 tms57002_device::check_macc_overflow_3s()
 {
-	return s->macc;
+	return macc;
 }
 
-#ifdef UNUSED_FUNCTION
-static INT64 tms57002_macc_to_loop(tms57002_t *s)
-{
-	INT64 m = s->macc;
-
-	// sfma shifting
-	switch((s->st1 & ST1_SFMA) >> ST1_SFMA_SHIFT) {
-	case 0: // sfma 0
-		break;
-	case 1: // sfma 2
-		m <<= 2;
-		break;
-	case 2: // sfma 4
-		m <<= 4;
-		break;
-	case 3: // sfma -16
-		if(m & 0x8000000000000ULL)
-			m |= 0xfff0000000000000ULL;
-		m >>= 16;
-		break;
-	}
-
-	return m;
-}
-
-static void tms57002_execute_cat1(tms57002_t *s, UINT32 opcode)
-{
-	UINT32 c, d;
-	INT64 r;
-	switch(opcode >> 18) {
-	case 0x00: // nop
-		break;
-
-#define INTRP1
-#include "cpu/tms57002/tms57002.inc"
-#undef INTRP1
-
-	default:
-		fatalerror("Unhandled case in tms57002_execute_cat1");
-	}
-}
-
-static void tms57002_execute_cat2_pre(tms57002_t *s, UINT32 opcode)
-{
-	switch((opcode >> 11) & 0x7f) {
-	case 0x00: // nop
-		break;
-
-#define INTRP2A
-#include "cpu/tms57002/tms57002.inc"
-#undef INTRP2A
-
-	default:
-		fatalerror("Unhandled case in tms57002_execute_cat2_pre");
-	}
-}
-
-static void tms57002_execute_cat2_post(tms57002_t *s, UINT32 opcode)
-{
-	UINT32 c;
-	switch((opcode >> 11) & 0x7f) {
-	case 0x00: // nop
-		break;
-
-#define INTRP2B
-#include "cpu/tms57002/tms57002.inc"
-#undef INTRP2B
-
-	default:
-		fatalerror("Unhandled case in tms57002_execute_cat2_post");
-	}
-}
-
-static void tms57002_execute_cat3(tms57002_t *s, UINT32 opcode)
-{
-	switch((opcode >> 11) & 0x7f) {
-	case 0x00: // nop
-		break;
-
-#define INTRP3
-#include "cpu/tms57002/tms57002.inc"
-#undef INTRP3
-
-	default:
-		fatalerror("Unhandled case in tms57002_execute_cat3");
-	}
-}
-
-void tms57002_execute(tms57002_t *s)
-{
-	while(!(s->sti & (S_IDLE | IN_PLOAD | IN_CLOAD))) {
-		UINT32 opcode = s->program->read_dword(s->pc << 2);
-
-		if(s->sti & (S_READ|S_WRITE)) {
-			if(s->sti & S_READ)
-				tms57002_xm_step_read(s);
-			else
-				tms57002_xm_step_write(s);
-		}
-
-		if((opcode & 0xfc0000) == 0xfc0000)
-			tms57002_execute_cat3(s, opcode);
-		else {
-			tms57002_execute_cat2_pre(s, opcode);
-			tms57002_execute_cat1(s, opcode);
-			tms57002_execute_cat2_post(s, opcode);
-		}
-
-		if(s->rptc)
-			s->rptc--;
-		else if(s->sti & S_BRANCH)
-			s->sti &= ~S_BRANCH;
-		else
-			s->pc++; // Wraps if it reaches 256
-
-		if(s->rptc_next) {
-			s->rptc = s->rptc_next;
-			s->rptc_next = 0;
-		}
-	}
-}
-#endif
-
-static void tms57002_cache_flush(tms57002_t *s)
+void tms57002_device::cache_flush()
 {
 	int i;
-	s->cache.hused = s->cache.iused = 0;
+	cache.hused = cache.iused = 0;
 	for(i=0; i != 256; i++)
-		s->cache.hashbase[i] = -1;
+		cache.hashbase[i] = -1;
 	for(i=0; i != HBS; i++) {
-		s->cache.hashnode[i].st1 = 0;
-		s->cache.hashnode[i].ipc = -1;
-		s->cache.hashnode[i].next = -1;
+		cache.hashnode[i].st1 = 0;
+		cache.hashnode[i].ipc = -1;
+		cache.hashnode[i].next = -1;
 	}
 	for(i=0; i != IBS; i++) {
-		s->cache.inst[i].op = 0;
-		s->cache.inst[i].next = -1;
-		s->cache.inst[i].param = 0;
+		cache.inst[i].op = 0;
+		cache.inst[i].next = -1;
+		cache.inst[i].param = 0;
 	}
 }
 
-static void tms57002_add_one(tms57002_t *s, cstate *cs, unsigned short op, UINT8 param)
+void tms57002_device::add_one(cstate *cs, unsigned short op, UINT8 param)
 {
-	short ipc = s->cache.iused++;
-	s->cache.inst[ipc].op = op;
-	s->cache.inst[ipc].param = param;
-	s->cache.inst[ipc].next = -1;
+	short ipc = cache.iused++;
+	cache.inst[ipc].op = op;
+	cache.inst[ipc].param = param;
+	cache.inst[ipc].next = -1;
 	if(cs->ipc != -1)
-		s->cache.inst[cs->ipc].next = ipc;
+		cache.inst[cs->ipc].next = ipc;
 	cs->ipc = ipc;
 	if(cs->hnode != -1) {
-		s->cache.hashnode[cs->hnode].ipc = ipc;
+		cache.hashnode[cs->hnode].ipc = ipc;
 		cs->hnode = -1;
 	}
 }
 
-static void tms57002_decode_one(tms57002_t *s, UINT32 opcode, cstate *cs, void (*dec)(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs))
+void tms57002_device::decode_one(UINT32 opcode, cstate *cs, void (tms57002_device::*dec)(UINT32 opcode, unsigned short *op, cstate *cs))
 {
 	unsigned short op = 0;
-	dec(s, opcode, &op, cs);
+	(this->*dec)(opcode, &op, cs);
 	if(!op)
 		return;
-	tms57002_add_one(s, cs, op, opcode & 0xff);
+	add_one(cs, op, opcode & 0xff);
 }
 
-static short tms57002_get_hash(tms57002_t *s, unsigned char adr, UINT32 st1, short *pnode)
+short tms57002_device::get_hash(unsigned char adr, UINT32 st1, short *pnode)
 {
 	short hnode;
 	st1 &= ST1_CACHE;
 	*pnode = -1;
-	hnode = s->cache.hashbase[adr];
+	hnode = cache.hashbase[adr];
 	while(hnode != -1) {
-		if(s->cache.hashnode[hnode].st1 == st1)
-			return s->cache.hashnode[hnode].ipc;
+		if(cache.hashnode[hnode].st1 == st1)
+			return cache.hashnode[hnode].ipc;
 		*pnode = hnode;
-		hnode = s->cache.hashnode[hnode].next;
+		hnode = cache.hashnode[hnode].next;
 	}
 	return -1;
 }
 
-static short tms57002_get_hashnode(tms57002_t *s, unsigned char adr, UINT32 st1, short pnode)
+short tms57002_device::get_hashnode(unsigned char adr, UINT32 st1, short pnode)
 {
-	short hnode = s->cache.hused++;
-	s->cache.hashnode[hnode].st1 = st1 & ST1_CACHE;
-	s->cache.hashnode[hnode].ipc = -1;
-	s->cache.hashnode[hnode].next = -1;
+	short hnode = cache.hused++;
+	cache.hashnode[hnode].st1 = st1 & ST1_CACHE;
+	cache.hashnode[hnode].ipc = -1;
+	cache.hashnode[hnode].next = -1;
 	if(pnode == -1)
-		s->cache.hashbase[adr] = hnode;
+		cache.hashbase[adr] = hnode;
 	else
-		s->cache.hashnode[pnode].next = hnode;
+		cache.hashnode[pnode].next = hnode;
 	return hnode;
 }
 
-static int tms57002_decode_get_pc(tms57002_t *s)
+int tms57002_device::decode_get_pc()
 {
-	UINT32 st1 = s->st1;
 	short pnode, res;
 	cstate cs;
-	UINT8 adr = s->pc;
+	UINT8 adr = pc;
 
-	res = tms57002_get_hash(s, adr, st1, &pnode);
+	res = get_hash(adr, st1, &pnode);
 	if(res != -1)
 		return res;
 
-	if(HBS - s->cache.hused < 256 || IBS - s->cache.iused < 256*3) {
-		tms57002_cache_flush(s);
+	if(HBS - cache.hused < 256 || IBS - cache.iused < 256*3) {
+		cache_flush();
 		pnode = -1;
 	}
 
-	cs.hnode = res = tms57002_get_hashnode(s, adr, st1, pnode);
+	cs.hnode = res = get_hashnode(adr, st1, pnode);
 	cs.ipc = -1;
 	cs.branch = 0;
 
 	for(;;) {
 		short ipc;
-		UINT32 opcode = s->program->read_dword(adr << 2);
+		UINT32 opcode = program->read_dword(adr << 2);
 
 		if((opcode & 0xfc0000) == 0xfc0000)
-			tms57002_decode_one(s, opcode, &cs, tms57002_decode_cat3);
+			decode_one(opcode, &cs, &tms57002_device::decode_cat3);
 		else {
-			tms57002_decode_one(s, opcode, &cs, tms57002_decode_cat2_pre);
-			tms57002_decode_one(s, opcode, &cs, tms57002_decode_cat1);
-			tms57002_decode_one(s, opcode, &cs, tms57002_decode_cat2_post);
+			decode_one(opcode, &cs, &tms57002_device::decode_cat2_pre);
+			decode_one(opcode, &cs, &tms57002_device::decode_cat1);
+			decode_one(opcode, &cs, &tms57002_device::decode_cat2_post);
 		}
-		tms57002_add_one(s, &cs, 0, 0);
+		add_one(&cs, 0, 0);
 
 		if(cs.branch)
 			break;
 
 		adr++;
-		ipc = tms57002_get_hash(s, adr, st1, &pnode);
+		ipc = get_hash(adr, st1, &pnode);
 		if(ipc != -1) {
-			s->cache.inst[cs.ipc].next = ipc;
+			cache.inst[cs.ipc].next = ipc;
 			break;
 		}
-		cs.hnode = tms57002_get_hashnode(s, adr, s->st1, pnode);
+		cs.hnode = get_hashnode(adr, st1, pnode);
 	}
 
-	s->st1 = st1;
-	return s->cache.hashnode[res].ipc;
+	return cache.hashnode[res].ipc;
 }
 
-static CPU_EXECUTE(tms57002)
+void tms57002_device::execute_run()
 {
-	tms57002_t *s = get_safe_token(device);
 	int ipc = -1;
 
-	while(s->icount > 0 && !(s->sti & (S_IDLE | IN_PLOAD | IN_CLOAD))) {
+	while(icount > 0 && !(sti & (S_IDLE | IN_PLOAD | IN_CLOAD))) {
 		int iipc;
 
-		debugger_instruction_hook(device, s->pc);
+		debugger_instruction_hook(this, pc);
 
 		if(ipc == -1)
-			ipc = tms57002_decode_get_pc(s);
+			ipc = decode_get_pc();
 
 		iipc = ipc;
 
-		if(s->sti & (S_READ|S_WRITE)) {
-			if(s->sti & S_READ)
-				tms57002_xm_step_read(s);
+		if(sti & (S_READ|S_WRITE)) {
+			if(sti & S_READ)
+				xm_step_read();
 			else
-				tms57002_xm_step_write(s);
+				xm_step_write();
 		}
 
 		for(;;) {
 			UINT32 c, d;
 			INT64 r;
-			const icd *i = s->cache.inst + ipc;
+			const icd *i = cache.inst + ipc;
 
 			ipc = i->next;
 			switch(i->op) {
@@ -1072,81 +764,92 @@
 			}
 		}
 	inst:
-		s->icount--;
+		icount--;
 
-		if(s->rptc) {
-			s->rptc--;
+		if(rptc) {
+			rptc--;
 			ipc = iipc;
-		} else if(s->sti & S_BRANCH) {
-			s->sti &= ~S_BRANCH;
+		} else if(sti & S_BRANCH) {
+			sti &= ~S_BRANCH;
 			ipc = -1;
 		} else
-			s->pc++; // Wraps if it reaches 256, next wraps too
+			pc++; // Wraps if it reaches 256, next wraps too
 
-		if(s->rptc_next) {
-			s->rptc = s->rptc_next;
-			s->rptc_next = 0;
+		if(rptc_next) {
+			rptc = rptc_next;
+			rptc_next = 0;
 		}
 	}
 
-	if(s->icount > 0)
-		s->icount = 0;
+	if(icount > 0)
+		icount = 0;
 }
 
-static CPU_INIT(tms57002)
+void tms57002_device::device_start()
 {
-	tms57002_t *s = get_safe_token(device);
-	tms57002_cache_flush(s);
-	s->sti = S_IDLE;
-	s->program = device->space(AS_PROGRAM);
-	s->data    = device->space(AS_DATA);
-}
+	sti = S_IDLE;
+	program = space(AS_PROGRAM);
+	data    = space(AS_DATA);
+
+	state_add(STATE_GENPC,"GENPC", pc).noshow();
+
+	m_icountptr = &icount;
+
+	save_item(NAME(macc));
+
+	save_item(NAME(cmem));
+	save_item(NAME(dmem0));
+	save_item(NAME(dmem1));
+
+	save_item(NAME(si));
+	save_item(NAME(so));
+
+	save_item(NAME(st0));
+	save_item(NAME(st1));
+	save_item(NAME(sti));
+	save_item(NAME(aacc));
+	save_item(NAME(xoa));
+	save_item(NAME(xba));
+	save_item(NAME(xwr));
+	save_item(NAME(xrd));
+	save_item(NAME(creg));
 
+	save_item(NAME(pc));
+	save_item(NAME(ca));
+	save_item(NAME(id));
+	save_item(NAME(ba0));
+	save_item(NAME(ba1));
+	save_item(NAME(rptc));
+	save_item(NAME(rptc_next));
+	save_item(NAME(sa));
 
-static CPU_SET_INFO(tms57002)
+	save_item(NAME(xm_adr));
+
+	save_item(NAME(host));
+	save_item(NAME(hidx));
+	save_item(NAME(allow_update));
+}
+
+UINT32 tms57002_device::execute_min_cycles() const
 {
+	return 1;
 }
 
-static ADDRESS_MAP_START(internal_pgm, AS_PROGRAM, 32)
-	AM_RANGE(0x000, 0x3ff) AM_RAM
-ADDRESS_MAP_END
+UINT32 tms57002_device::execute_max_cycles() const
+{
+	return 3;
+}
 
-CPU_GET_INFO(tms57002)
+UINT32 tms57002_device::execute_input_lines() const
 {
-	tms57002_t *s = (device != NULL && device->token() != NULL) ? get_safe_token(device) : NULL;
+	return 0;
+}
 
-	switch(state) {
-	case CPUINFO_INT_CONTEXT_SIZE:				info->i = sizeof(tms57002_t); break;
-	case CPUINFO_INT_INPUT_LINES:				info->i = 0; break;
-	case DEVINFO_INT_ENDIANNESS:				info->i = ENDIANNESS_LITTLE; break;
-	case CPUINFO_INT_CLOCK_MULTIPLIER:			info->i = 1; break;
-	case CPUINFO_INT_CLOCK_DIVIDER:				info->i = 1; break;
-	case CPUINFO_INT_MIN_INSTRUCTION_BYTES:		info->i = 4; break;
-	case CPUINFO_INT_MAX_INSTRUCTION_BYTES:		info->i = 4; break;
-	case CPUINFO_INT_MIN_CYCLES:				info->i = 1; break;
-	case CPUINFO_INT_MAX_CYCLES:				info->i = 3; break;
-	case DEVINFO_INT_DATABUS_WIDTH + AS_PROGRAM:		info->i = 32; break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_PROGRAM:		info->i = 8; break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_PROGRAM:		info->i = -2; break;
-	case DEVINFO_INT_DATABUS_WIDTH + AS_DATA:		info->i = 8; break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_DATA:		info->i = 20; break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_DATA:		info->i = 0; break;
-	case DEVINFO_INT_DATABUS_WIDTH + AS_IO:			info->i = 0; break;
-	case DEVINFO_INT_ADDRBUS_WIDTH + AS_IO:			info->i = 0; break;
-	case DEVINFO_INT_ADDRBUS_SHIFT + AS_IO:			info->i = 0; break;
-	case CPUINFO_FCT_SET_INFO:					info->setinfo = CPU_SET_INFO_NAME(tms57002); break;
-	case CPUINFO_FCT_INIT:						info->init = CPU_INIT_NAME(tms57002); break;
-	case CPUINFO_FCT_RESET:						info->reset = CPU_RESET_NAME(tms57002); break;
-	case CPUINFO_FCT_EXECUTE:					info->execute = CPU_EXECUTE_NAME(tms57002); break;
-	case CPUINFO_FCT_DISASSEMBLE:				info->disassemble = CPU_DISASSEMBLE_NAME(tms57002); break;
-	case CPUINFO_PTR_INSTRUCTION_COUNTER:		info->icount = &s->icount; break;
-	case DEVINFO_PTR_INTERNAL_MEMORY_MAP + AS_PROGRAM:info->internal_map32 = ADDRESS_MAP_NAME(internal_pgm); break;
-	case DEVINFO_STR_NAME:						strcpy( info->s, "TMS57002" ); break;
-	case DEVINFO_STR_FAMILY:				strcpy( info->s, "Texas Instruments TMS57002 (DASP)" ); break;
-	case DEVINFO_STR_VERSION:				strcpy( info->s, "1.0" ); break;
-	case DEVINFO_STR_SOURCE_FILE:					strcpy( info->s, __FILE__ ); break;
-	case DEVINFO_STR_CREDITS:				strcpy( info->s, "Copyright Olivier Galibert" ); break;
+const address_space_config *tms57002_device::memory_space_config(address_spacenum spacenum) const
+{
+	switch(spacenum) {
+	case AS_PROGRAM: return &program_config;
+	case AS_DATA: return &data_config;
+	default: return 0;
 	}
 }
-
-DEFINE_LEGACY_CPU_DEVICE(TMS57002, tms57002);
diff -Nru src-old/emu/cpu/tms57002/tms57002.h src/emu/cpu/tms57002/tms57002.h
--- src-old/emu/cpu/tms57002/tms57002.h	2010-12-31 22:42:55.000000000 +0100
+++ src/emu/cpu/tms57002/tms57002.h	2012-03-09 20:13:38.000000000 +0100
@@ -1,24 +1,223 @@
+/***************************************************************************
+
+    tms57002.h
+
+    TMS57002 "DASP" emulator.
+
+****************************************************************************
+
+    Copyright Olivier Galibert
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
 #pragma once
 
 #ifndef __TMS57002_H__
 #define __TMS57002_H__
 
+class tms57002_device : public cpu_device {
+public:
+	tms57002_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	DECLARE_READ8_MEMBER(data_r);
+	DECLARE_WRITE8_MEMBER(data_w);
+
+	DECLARE_WRITE8_MEMBER(pload_w);
+	DECLARE_WRITE8_MEMBER(cload_w);
+	DECLARE_READ8_MEMBER(empty_r);
+	DECLARE_READ8_MEMBER(dready_r);
+
+	void sync();
+
+protected:
+	virtual void device_start();
+	virtual void device_reset();
+	virtual const address_space_config *memory_space_config(address_spacenum spacenum = AS_0) const;
+	virtual UINT32 execute_min_cycles() const;
+	virtual UINT32 execute_max_cycles() const;
+	virtual UINT32 execute_input_lines() const;
+	virtual void execute_run();
+	virtual UINT32 disasm_min_opcode_bytes() const;
+	virtual UINT32 disasm_max_opcode_bytes() const;
+	virtual offs_t disasm_disassemble(char *buffer, offs_t pc, const UINT8 *oprom, const UINT8 *opram, UINT32 options);
+
+private:
+	enum {
+		IN_PLOAD = 0x00000001,
+		IN_CLOAD = 0x00000002,
+		SU_CVAL  = 0x00000004,
+		SU_MASK  = 0x00000018, SU_ST0 = 0x00, SU_ST1 = 0x08, SU_PRG = 0x10,
+		S_IDLE   = 0x00000020,
+		S_READ   = 0x00000040,
+		S_WRITE  = 0x00000080,
+		S_BRANCH = 0x00000100,
+		S_HOST   = 0x00000200
+	};
+
+	enum {
+		ST0_INCS = 0x000001,
+		ST0_DIRI = 0x000002,
+		ST0_FI   = 0x000004,
+		ST0_SIM  = 0x000008,
+		ST0_PLRI = 0x000020,
+		ST0_PBCI = 0x000040,
+		ST0_DIRO = 0x000080,
+		ST0_FO   = 0x000100,
+		ST0_SOM  = 0x000600,
+		ST0_PLRO = 0x000800,
+		ST0_PBCO = 0x001000,
+		ST0_CNS  = 0x002000,
+		ST0_WORD = 0x004000,
+		ST0_SEL  = 0x008000,
+		ST0_M    = 0x030000, ST0_M_64K = 0x000000, ST0_M_256K = 0x010000, ST0_M_1M = 0x020000,
+		ST0_SRAM = 0x200000,
+
+		ST1_AOV  = 0x000001,
+		ST1_SFAI = 0x000002,
+		ST1_SFAO = 0x000004,
+		ST1_MOVM = 0x000020,
+		ST1_MOV  = 0x000040,
+		ST1_SFMA = 0x000180, ST1_SFMA_SHIFT = 7,
+		ST1_SFMO = 0x001800, ST1_SFMO_SHIFT = 11,
+		ST1_RND  = 0x038000, ST1_RND_SHIFT = 15,
+		ST1_CRM  = 0x0C0000, ST1_CRM_SHIFT = 18, ST1_CRM_32 = 0x000000, ST1_CRM_16H = 0x040000, ST1_CRM_16L = 0x080000,
+		ST1_DBP  = 0x100000,
+		ST1_CAS  = 0x200000,
+
+		ST1_CACHE = ST1_SFAI|ST1_SFAO|ST1_MOVM|ST1_SFMA|ST1_SFMO|ST1_RND|ST1_CRM|ST1_DBP
+	};
+
+
+	enum { BR_UB, BR_CB, BR_IDLE };
+
+	enum { IBS = 8192, HBS = 4096 };
+
+	struct icd {
+		unsigned short op;
+		short next;
+		unsigned char param;
+	};
+
+	struct hcd {
+		unsigned int st1;
+		short ipc;
+		short next;
+	};
+
+	struct cd {
+		short hashbase[256];
+		hcd hashnode[HBS];
+		icd inst[IBS];
+		int hused, iused;
+	};
+
+	struct cstate {
+		int branch;
+		short hnode;
+		short ipc;
+	};
+
+	INT64 macc;
+
+	UINT32 cmem[256];
+	UINT32 dmem0[256];
+	UINT32 dmem1[32];
+
+	UINT32 si[4], so[4];
+
+	UINT32 st0, st1, sti;
+	UINT32 aacc, xoa, xba, xwr, xrd, creg;
+
+	UINT8 pc, ca, id, ba0, ba1, rptc, rptc_next, sa;
+
+	UINT32 xm_adr;
+
+	UINT8 host[4], hidx, allow_update;
+
+	cd cache;
+
+	const address_space_config program_config, data_config;
+
+	address_space *program, *data;
+	int icount;
+	int unsupported_inst_warning;
+
+	void decode_error(UINT32 opcode);
+	void decode_cat1(UINT32 opcode, unsigned short *op, cstate *cs);
+	void decode_cat2_pre(UINT32 opcode, unsigned short *op, cstate *cs);
+	void decode_cat3(UINT32 opcode, unsigned short *op, cstate *cs);
+	void decode_cat2_post(UINT32 opcode, unsigned short *op, cstate *cs);
+
+	inline int xmode(UINT32 opcode, char type);
+	inline int sfao(UINT32 st1);
+	inline int dbp(UINT32 st1);
+	inline int crm(UINT32 st1);
+	inline int sfai(UINT32 st1);
+	inline int sfmo(UINT32 st1);
+	inline int rnd(UINT32 st1);
+	inline int movm(UINT32 st1);
+	inline int sfma(UINT32 st1);
+
+	const char *get_memadr(UINT32 opcode, char type);
+
+	void xm_init();
+	void xm_step_read();
+	void xm_step_write();
+	INT64 macc_to_output_0(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_1(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_2(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_3(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_0s(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_1s(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_2s(INT64 rounding, UINT64 rmask);
+	INT64 macc_to_output_3s(INT64 rounding, UINT64 rmask);
+	INT64 check_macc_overflow_0();
+	INT64 check_macc_overflow_1();
+	INT64 check_macc_overflow_2();
+	INT64 check_macc_overflow_3();
+	INT64 check_macc_overflow_0s();
+	INT64 check_macc_overflow_1s();
+	INT64 check_macc_overflow_2s();
+	INT64 check_macc_overflow_3s();
+	void cache_flush();
+	void add_one(cstate *cs, unsigned short op, UINT8 param);
+	void decode_one(UINT32 opcode, cstate *cs, void (tms57002_device::*dec)(UINT32 opcode, unsigned short *op, cstate *cs));
+	short get_hash(unsigned char adr, UINT32 st1, short *pnode);
+	short get_hashnode(unsigned char adr, UINT32 st1, short pnode);
+	int decode_get_pc();
+};
 
 enum {
 	TMS57002_PC=1
 };
 
-DECLARE_LEGACY_CPU_DEVICE(TMS57002, tms57002);
-
-WRITE8_DEVICE_HANDLER(tms57002_data_w);
-READ8_DEVICE_HANDLER(tms57002_data_r);
-
-WRITE8_DEVICE_HANDLER(tms57002_pload_w);
-WRITE8_DEVICE_HANDLER(tms57002_cload_w);
-READ8_DEVICE_HANDLER(tms57002_empty_r);
-READ8_DEVICE_HANDLER(tms57002_dready_r);
-
-void tms57002_sync(device_t *cpu);
+extern const device_type TMS57002;
 
 #endif
 
diff -Nru src-old/emu/cpu/tms57002/tms57kdec.c src/emu/cpu/tms57002/tms57kdec.c
--- src-old/emu/cpu/tms57002/tms57kdec.c	2011-02-07 00:46:37.000000000 +0100
+++ src/emu/cpu/tms57002/tms57kdec.c	2012-03-10 15:13:57.000000000 +0100
@@ -1,31 +1,118 @@
+/***************************************************************************
+
+    tms57kdec.c
+
+    TMS57002 "DASP" emulator.
+
+****************************************************************************
+
+    Copyright Olivier Galibert
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
 #include "emu.h"
 #include "debugger.h"
 #include "tms57002.h"
-#include "tms57kpr.h"
 
-#ifdef __GNUC__
-#define noinline __attribute__((noinline))
-#else
-#define noinline /* */
-#endif
+inline int tms57002_device::xmode(UINT32 opcode, char type)
+{
+	if(((opcode & 0x400) && (type == 'c')) || (!(opcode & 0x400) && (type == 'd'))) {
+		if(opcode & 0x100)
+			return 0;
+		else if(opcode & 0x80)
+			return 2;
+		else
+			return 1;
+	} else if(opcode & 0x200)
+		return 2;
+
+	return 1;
+}
+
+inline int tms57002_device::sfao(UINT32 st1)
+{
+	return st1 & ST1_SFAO ? 1 : 0;
+}
+
+inline int tms57002_device::dbp(UINT32 st1)
+{
+	return st1 & ST1_DBP ? 1 : 0;
+}
+
+inline int tms57002_device::crm(UINT32 st1)
+{
+	return (st1 & ST1_CRM) >> ST1_CRM_SHIFT;
+}
+
+inline int tms57002_device::sfai(UINT32 st1)
+{
+	return st1 & ST1_SFAI ? 1 : 0;
+}
+
+inline int tms57002_device::sfmo(UINT32 st1)
+{
+	return (st1 & ST1_SFMO) >> ST1_SFMO_SHIFT;
+}
+
+inline int tms57002_device::rnd(UINT32 st1)
+{
+	return (st1 & ST1_RND) >> ST1_RND_SHIFT;
+}
+
+inline int tms57002_device::movm(UINT32 st1)
+{
+	return st1 & ST1_MOVM ? 1 : 0;
+}
+
+inline int tms57002_device::sfma(UINT32 st1)
+{
+	return (st1 & ST1_SFMA) >> ST1_SFMA_SHIFT;
+}
 
-static void tms57002_decode_error(tms57002_t *s, UINT32 opcode)
+void tms57002_device::decode_error(UINT32 opcode)
 {
 	char buf[256];
 	UINT8 opr[3];
-	if(s->unsupported_inst_warning)
+	if(unsupported_inst_warning)
 		return;
 
-	s->unsupported_inst_warning = 1;
+	unsupported_inst_warning = 1;
 	opr[0] = opcode;
 	opr[1] = opcode >> 8;
 	opr[2] = opcode >> 16;
 
-	CPU_DISASSEMBLE_NAME(tms57002)(0, buf, s->pc, opr, opr, 0);
+	disasm_disassemble(buf, pc, opr, opr, 0);
 	popmessage("tms57002: %s - Contact Mamedev", buf);
 }
 
-void tms57002_decode_cat1(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs)
+void tms57002_device::decode_cat1(UINT32 opcode, unsigned short *op, cstate *cs)
 {
 	switch(opcode >> 18) {
 	case 0x00: // nop
@@ -36,12 +123,12 @@
 #undef CDEC1
 
 	default:
-		tms57002_decode_error(s, opcode);
+		decode_error(opcode);
 		break;
 	}
 }
 
-void tms57002_decode_cat2_pre(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs)
+void tms57002_device::decode_cat2_pre(UINT32 opcode, unsigned short *op, cstate *cs)
 {
 	switch((opcode >> 11) & 0x7f) {
 	case 0x00: // nop
@@ -52,12 +139,12 @@
 #undef CDEC2A
 
 	default:
-		tms57002_decode_error(s, opcode);
+		decode_error(opcode);
 		break;
 	}
 }
 
-void tms57002_decode_cat2_post(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs)
+void tms57002_device::decode_cat2_post(UINT32 opcode, unsigned short *op, cstate *cs)
 {
 	switch((opcode >> 11) & 0x7f) {
 	case 0x00: // nop
@@ -68,12 +155,12 @@
 #undef CDEC2B
 
 	default:
-		tms57002_decode_error(s, opcode);
+		decode_error(opcode);
 		break;
 	}
 }
 
-void tms57002_decode_cat3(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs)
+void tms57002_device::decode_cat3(UINT32 opcode, unsigned short *op, cstate *cs)
 {
 	switch((opcode >> 11) & 0x7f) {
 	case 0x00: // nop
@@ -84,7 +171,7 @@
 #undef CDEC3
 
 	default:
-		tms57002_decode_error(s, opcode);
+		decode_error(opcode);
 		break;
 	}
 }
diff -Nru src-old/emu/cpu/tms57002/tms57kpr.h src/emu/cpu/tms57002/tms57kpr.h
--- src-old/emu/cpu/tms57002/tms57kpr.h	2011-02-07 00:46:37.000000000 +0100
+++ src/emu/cpu/tms57002/tms57kpr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,171 +0,0 @@
-#ifndef TMS57KPRIVATE_H
-#define TMS57KPRIVATE_H
-
-CPU_DISASSEMBLE(tms57002);
-
-#ifdef __GNUC__
-#define noinline __attribute__((noinline))
-#else
-#define noinline /* */
-#endif
-
-enum {
-	IN_PLOAD = 0x00000001,
-	IN_CLOAD = 0x00000002,
-	SU_CVAL  = 0x00000004,
-	SU_MASK  = 0x00000018, SU_ST0 = 0x00, SU_ST1 = 0x08, SU_PRG = 0x10,
-	S_IDLE   = 0x00000020,
-	S_READ   = 0x00000040,
-	S_WRITE  = 0x00000080,
-	S_BRANCH = 0x00000100,
-	S_HOST   = 0x00000200
-};
-
-enum {
-	ST0_INCS = 0x000001,
-	ST0_DIRI = 0x000002,
-	ST0_FI   = 0x000004,
-	ST0_SIM  = 0x000008,
-	ST0_PLRI = 0x000020,
-	ST0_PBCI = 0x000040,
-	ST0_DIRO = 0x000080,
-	ST0_FO   = 0x000100,
-	ST0_SOM  = 0x000600,
-	ST0_PLRO = 0x000800,
-	ST0_PBCO = 0x001000,
-	ST0_CNS  = 0x002000,
-	ST0_WORD = 0x004000,
-	ST0_SEL  = 0x008000,
-	ST0_M    = 0x030000, ST0_M_64K = 0x000000, ST0_M_256K = 0x010000, ST0_M_1M = 0x020000,
-	ST0_SRAM = 0x200000,
-
-	ST1_AOV  = 0x000001,
-	ST1_SFAI = 0x000002,
-	ST1_SFAO = 0x000004,
-	ST1_MOVM = 0x000020,
-	ST1_MOV  = 0x000040,
-	ST1_SFMA = 0x000180, ST1_SFMA_SHIFT = 7,
-	ST1_SFMO = 0x001800, ST1_SFMO_SHIFT = 11,
-	ST1_RND  = 0x038000, ST1_RND_SHIFT = 15,
-	ST1_CRM  = 0x0C0000, ST1_CRM_SHIFT = 18, ST1_CRM_32 = 0x000000, ST1_CRM_16H = 0x040000, ST1_CRM_16L = 0x080000,
-	ST1_DBP  = 0x100000,
-	ST1_CAS  = 0x200000,
-
-	ST1_CACHE = ST1_SFAI|ST1_SFAO|ST1_MOVM|ST1_SFMA|ST1_SFMO|ST1_RND|ST1_CRM|ST1_DBP
-};
-
-enum { BR_UB, BR_CB, BR_IDLE };
-
-enum { IBS = 8192, HBS = 4096 };
-
-typedef struct {
-	unsigned short op;
-	short next;
-	unsigned char param;
-} icd;
-
-typedef struct {
-	unsigned int st1;
-	short ipc;
-	short next;
-} hcd;
-
-typedef struct {
-	short hashbase[256];
-	hcd hashnode[HBS];
-	icd inst[IBS];
-	int hused, iused;
-} cd;
-
-typedef struct {
-	int branch;
-	short hnode;
-	short ipc;
-} cstate;
-
-typedef struct {
-	INT64 macc;
-
-	UINT32 cmem[256];
-	UINT32 dmem0[256];
-	UINT32 dmem1[32];
-
-	UINT32 si[4], so[4];
-
-	UINT32 st0, st1, sti;
-	UINT32 aacc, xoa, xba, xwr, xrd, creg;
-
-	UINT8 pc, ca, id, ba0, ba1, rptc, rptc_next, sa;
-
-	UINT32 xm_adr;
-
-	UINT8 host[4], hidx, allow_update;
-
-	cd cache;
-
-	address_space *program, *data;
-	int icount;
-	int unsupported_inst_warning;
-} tms57002_t;
-
-void tms57002_decode_cat1(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs);
-void tms57002_decode_cat2_pre(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs);
-void tms57002_decode_cat3(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs);
-void tms57002_decode_cat2_post(tms57002_t *s, UINT32 opcode, unsigned short *op, cstate *cs);
-
-INLINE int xmode(UINT32 opcode, char type)
-{
-	if(((opcode & 0x400) && (type == 'c')) || (!(opcode & 0x400) && (type == 'd'))) {
-		if(opcode & 0x100)
-			return 0;
-		else if(opcode & 0x80)
-			return 2;
-		else
-			return 1;
-	} else if(opcode & 0x200)
-		return 2;
-
-	return 1;
-}
-
-INLINE int sfao(UINT32 st1)
-{
-	return st1 & ST1_SFAO ? 1 : 0;
-}
-
-INLINE int dbp(UINT32 st1)
-{
-	return st1 & ST1_DBP ? 1 : 0;
-}
-
-INLINE int crm(UINT32 st1)
-{
-	return (st1 & ST1_CRM) >> ST1_CRM_SHIFT;
-}
-
-INLINE int sfai(UINT32 st1)
-{
-	return st1 & ST1_SFAI ? 1 : 0;
-}
-
-INLINE int sfmo(UINT32 st1)
-{
-	return (st1 & ST1_SFMO) >> ST1_SFMO_SHIFT;
-}
-
-INLINE int rnd(UINT32 st1)
-{
-	return (st1 & ST1_RND) >> ST1_RND_SHIFT;
-}
-
-INLINE int movm(UINT32 st1)
-{
-	return st1 & ST1_MOVM ? 1 : 0;
-}
-
-INLINE int sfma(UINT32 st1)
-{
-	return (st1 & ST1_SFMA) >> ST1_SFMA_SHIFT;
-}
-
-#endif
diff -Nru src-old/emu/cpu/tms57002/tmsinstr.lst src/emu/cpu/tms57002/tmsinstr.lst
--- src-old/emu/cpu/tms57002/tmsinstr.lst	2009-03-07 20:41:14.000000000 +0100
+++ src/emu/cpu/tms57002/tmsinstr.lst	2012-03-09 19:50:18.000000000 +0100
@@ -1,10 +1,10 @@
 abs  1  01 1 n
   abs
-  s->aacc = %a;
-  if(((INT32)s->aacc) < 0) {
-    s->aacc = - s->aacc;
-    if(((INT32)s->aacc) < 0)
-      s->st1 |= ST1_AOV;
+  aacc = %a;
+  if(((INT32)aacc) < 0) {
+    aacc = - aacc;
+    if(((INT32)aacc) < 0)
+      st1 |= ST1_AOV;
   }
 
 add  1  03 1 y
@@ -40,16 +40,16 @@
 and  1  14 1 n
   and %d,a
   %sfai(d, %d);
-  s->aacc &= d;
+  aacc &= d;
 
 and  1  15 1 n
   and %c,a
-  s->aacc &= %c;
+  aacc &= %c;
 
 and  1  16 1 n
   and %d,%c
   %sfai(d, %d);
-  s->aacc = %c & d;
+  aacc = %c & d;
 
 b    3  48 3 n b
   b %i
@@ -57,7 +57,7 @@
 
 bgz  3  50 3 n cb
   bgz %i
-  if(((INT32)s->aacc) > 0) {
+  if(((INT32)aacc) > 0) {
     %b(%i);
   }
 
@@ -66,20 +66,20 @@
 
 blz  3  58 3 n cb
   blz %i
-  if(((INT32)s->aacc) < 0) {
+  if(((INT32)aacc) < 0) {
     %b(%i);
   }
 
 bnz  3  60 3 n cb
   bnz %i
-  if(s->aacc) {
+  if(aacc) {
     %b(%i);
   }
 
 bv   3  78 3 n cb
   bv %i
-  if(s->st1 & ST1_AOV) {
-    s->st1 &= ~ST1_AOV;
+  if(st1 & ST1_AOV) {
+    st1 &= ~ST1_AOV;
     %b(%i);
   }
 
@@ -112,35 +112,35 @@
 
 dis  2a 10 1 n
   dis si0_l,%d
-  %wd(s->si[0]);
+  %wd(si[0]);
 
 dis  2a 11 1 n
   dis si0_r,%d
-  %wd(s->si[1]);
+  %wd(si[1]);
 
 dis  2a 12 1 n
   dis si1_l,%d
-  %wd(s->si[2]);
+  %wd(si[2]);
 
 dis  2a 13 1 n
   dis si1_r,%d
-  %wd(s->si[3]);
+  %wd(si[3]);
 
 domh 2a 20 1 n
   domh so0_l
-  s->so[0] = (%mo >> 24) & 0xffffff;
+  so[0] = (%mo >> 24) & 0xffffff;
 
 domh 2a 21 1 n
   domh so0_r
-  s->so[1] = (%mo >> 24) & 0xffffff;
+  so[1] = (%mo >> 24) & 0xffffff;
 
 domh 2a 22 1 n
   domh so1_l
-  s->so[2] = (%mo >> 24) & 0xffffff;
+  so[2] = (%mo >> 24) & 0xffffff;
 
 domh 2a 23 1 n
   domh so1_r
-  s->so[3] = (%mo >> 24) & 0xffffff;
+  so[3] = (%mo >> 24) & 0xffffff;
 
 doml 2a 24 1 n
   doml so0_l
@@ -168,78 +168,78 @@
 
 idle 3  08 1 n i
   idle
-  s->sti |= S_IDLE;
+  sti |= S_IDLE;
 
 incd 2a 42 1 y
   incd
 
 lacc 1  12 1 n
   lacc %c
-  s->aacc = %c;
+  aacc = %c;
 
 lacd 1  11 1 n
   lacd %d
   %sfai(d, %d);
-  s->aacc = d;
+  aacc = d;
 
 lbrk 3  28 1 n
   lbrk %i
 
 lcaa 2a 08 1 y
   lcaa
-  s->ca = %a >> 24;
+  ca = %a >> 24;
 
 lcac 3  40 1 n
   lcac %i
-  if(((INT32)s->aacc) >= 0)
-    s->ca = %i;
+  if(((INT32)aacc) >= 0)
+    ca = %i;
 
 lcak 3  18 1 n
   lcak %i
-  s->ca = %i;
+  ca = %i;
 
 ldpk 2a 44 1 n f
   ldpk 0
-  s->st1 &= ~ST1_DBP;
+  st1 &= ~ST1_DBP;
 
 ldpk 2a 45 1 n f
   ldpk 1
-  s->st1 |= ST1_DBP;
+  st1 |= ST1_DBP;
 
 ld0t 2b 0c 1 y
   ld0t %d
 
 lira 2a 09 1 y
   lira
-  s->id = %a >> 24;
+  id = %a >> 24;
 
 lirk 3  20 1 n
   lirk %i
-  s->id = %i;
+  id = %i;
 
 lmhc 1  33 1 n
   lmhc %c
-  s->macc = ((INT64)(INT32)%c) << 16;
+  macc = ((INT64)(INT32)%c) << 16;
 
 lmhd 1  31 1 n
   lmhd %d
-  s->macc = ((INT64)(INT32)%d) << 16;
+  macc = ((INT64)(INT32)%d) << 16;
 
 lmld 1  32 1 n
   lmld %d
-  s->macc = (s->macc & ~0xffffffULL) | %d24;
+  macc = (macc & ~0xffffffULL) | %d24;
 
 lpc  2b 31 1 n
   lpc %c
-  if(s->sti & S_HOST)
+  if(sti & S_HOST)
     break;
   c = %c;
-  s->host[0] = c >> 24;
-  s->host[1] = c >> 16;
-  s->host[2] = c >> 8;
-  s->host[3] = c;
-  s->hidx = 0;
-  s->sti |= S_HOST;
+  host[0] = c >> 24;
+  host[1] = c >> 16;
+  host[2] = c >> 8;
+  host[3] = c;
+  hidx = 0;
+  sti |= S_HOST;
 
 lpd  2b 30 1 n
   lpd %d
@@ -249,63 +249,63 @@
   d = %d24;
   if(d & 0x00800000)
     d |= 0xff000000;
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)(INT32)d;
-  s->macc = %ml + (r >> 7);
+  macc = %ml + (r >> 7);
 
 mac  1  25 1 y
   mac a,%d
 
 mac  1  26 1 y
   mac %c,a
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)(INT32)%a;
-  s->macc = %ml + (r >> 15);
+  macc = %ml + (r >> 15);
 
 macs 1  2e 1 y
   macs %c,a
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)(INT32)%a;
-  s->macc = %ml + (r >> 14);
+  macc = %ml + (r >> 14);
 
 macu 1  29 1 y
   macu %d,%c
   d = %d24; // d is 24bits unsigned
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)d;
-  s->macc = %ml + (r >> 7);
+  macc = %ml + (r >> 7);
 
 macu 1  2a 1 y
   macu a,%d
   d = %d24; // d is 24bits unsigned
-  s->creg = c = %a;
+  creg = c = %a;
   r = (INT64)(INT32)c * (INT64)d;
-  s->macc = %ml + (r >> 7);
+  macc = %ml + (r >> 7);
 
 mpy  1  21 1 y
   mpy %d,%c
   d = %d24;
   if(d & 0x00800000)
     d |= 0xff000000;
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)(INT32)d;
-  s->macc = r >> 7;
+  macc = r >> 7;
 
 mpy  1  22 1 y
   mpy %c,a
-  s->creg = c = %c;
+  creg = c = %c;
   r = (INT64)(INT32)c * (INT64)(INT32)%a;
-  s->macc = r >> 15;
+  macc = r >> 15;
 
 mpy  1  23 1 y
   mpy creg,%d
 
 mpyu 1  28 1 y
   mpyu %d,%c
-  s->creg = c = %c;
+  creg = c = %c;
   d = %d24; // d is 24bits unsigned
   r = (INT64)(INT32)c * (INT64)d;
-  s->macc = r >> 7;
+  macc = r >> 7;
 
 neg  1  02 1 n
   neg
@@ -313,27 +313,27 @@
 or   1  17 1 n
   or %d,a
   %sfai(d, %d);
-  s->aacc |= d;
+  aacc |= d;
 
 or   1  18 1 n
   or %c,a
-  s->aacc |= %c;
+  aacc |= %c;
 
 or   1  19 1 n
   or %d,%c
   %sfai(d, %d);
-  s->aacc = %c | d;
+  aacc = %c | d;
 
 raov 2a 38 1 n
   raov
 
 rde  1  39 1 n
   rde %c
-  if(s->sti & (S_READ|S_WRITE))
+  if(sti & (S_READ|S_WRITE))
     break;
-  s->xoa = %c;
-  tms57002_xm_init(s);
-  s->sti |= S_READ;
+  xoa = %c;
+  xm_init();
+  sti |= S_READ;
 
 ref  2a 0e 1 n
   ref
@@ -341,47 +341,47 @@
 
 rmom 2a 40 1 n f
   rmom
-  s->st1 &= ~ST1_MOVM;
+  st1 &= ~ST1_MOVM;
 
 rmov 2a 3a 1 n
   rmov
-  s->st1 &= ~ST1_MOV;
+  st1 &= ~ST1_MOV;
 
 rnd  2a 68 1 n f
   rnd 48
-  s->st1 = (s->st1 & ~ST1_RND) | (0 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (0 << ST1_RND_SHIFT);
 
 rnd  2a 69 1 n f
   rnd 32
-  s->st1 = (s->st1 & ~ST1_RND) | (1 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (1 << ST1_RND_SHIFT);
 
 rnd  2a 6a 1 n f
   rnd 24
-  s->st1 = (s->st1 & ~ST1_RND) | (2 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (2 << ST1_RND_SHIFT);
 
 rnd  2a 6b 1 n f
   rnd 20
-  s->st1 = (s->st1 & ~ST1_RND) | (3 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (3 << ST1_RND_SHIFT);
 
 rnd  2a 6c 1 n f
   rnd 16
-  s->st1 = (s->st1 & ~ST1_RND) | (4 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (4 << ST1_RND_SHIFT);
 
 rnd  2a 6d 1 n f
   rnd <5>
-  s->st1 = (s->st1 & ~ST1_RND) | (5 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (5 << ST1_RND_SHIFT);
 
 rnd  2a 6e 1 n f
   rnd <6>
-  s->st1 = (s->st1 & ~ST1_RND) | (6 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (6 << ST1_RND_SHIFT);
 
 rnd  2a 6f 1 n f
   rnd <7>
-  s->st1 = (s->st1 & ~ST1_RND) | (7 << ST1_RND_SHIFT);
+  st1 = (st1 & ~ST1_RND) | (7 << ST1_RND_SHIFT);
 
 rptk 3  10 1 n
   rptk %i
-  s->rptc_next = %i;
+  rptc_next = %i;
 
 sacc 2a 01 1 y
   sacc %c
@@ -393,71 +393,71 @@
 
 scrm 2a 48 1 n f
   scrm 32
-  s->st1 = (s->st1 & ~ST1_CRM) | (0 << ST1_CRM_SHIFT);
+  st1 = (st1 & ~ST1_CRM) | (0 << ST1_CRM_SHIFT);
 
 scrm 2a 49 1 n f
   scrm 16h
-  s->st1 = (s->st1 & ~ST1_CRM) | (1 << ST1_CRM_SHIFT);
+  st1 = (st1 & ~ST1_CRM) | (1 << ST1_CRM_SHIFT);
 
 scrm 2a 4a 1 n f
   scrm 16l
-  s->st1 = (s->st1 & ~ST1_CRM) | (2 << ST1_CRM_SHIFT);
+  st1 = (st1 & ~ST1_CRM) | (2 << ST1_CRM_SHIFT);
 
 scrm 2a 4b 1 n f
   scrm <3>
-  s->st1 = (s->st1 & ~ST1_CRM) | (3 << ST1_CRM_SHIFT);
+  st1 = (st1 & ~ST1_CRM) | (3 << ST1_CRM_SHIFT);
 
 sfai 2b 54 1 n f
   sfai 0
-  s->st1 &= ~ST1_SFAI;
+  st1 &= ~ST1_SFAI;
 
 sfai 2b 55 1 n f
   sfai -1
-  s->st1 |= ST1_SFAI;
+  st1 |= ST1_SFAI;
 
 sfao 2a 50 1 n f
   sfao 0
-  s->st1 &= ~ST1_SFAO;
+  st1 &= ~ST1_SFAO;
 
 sfao 2a 51 1 n f
   sfao 7
-  s->st1 |= ST1_SFAI;
+  st1 |= ST1_SFAI;
 
 sfma 2b 58 1 n f
   sfma 0
-  s->st1 = (s->st1 & ~ST1_SFMA) | (0 << ST1_SFMA_SHIFT);
+  st1 = (st1 & ~ST1_SFMA) | (0 << ST1_SFMA_SHIFT);
 
 sfma 2b 59 1 n f
   sfma 2
-  s->st1 = (s->st1 & ~ST1_SFMA) | (1 << ST1_SFMA_SHIFT);
+  st1 = (st1 & ~ST1_SFMA) | (1 << ST1_SFMA_SHIFT);
 
 sfma 2b 5a 1 n f
   sfma 4
-  s->st1 = (s->st1 & ~ST1_SFMA) | (2 << ST1_SFMA_SHIFT);
+  st1 = (st1 & ~ST1_SFMA) | (2 << ST1_SFMA_SHIFT);
 
 sfma 2b 5b 1 n f
   sfma -16
-  s->st1 = (s->st1 & ~ST1_SFMA) | (3 << ST1_SFMA_SHIFT);
+  st1 = (st1 & ~ST1_SFMA) | (3 << ST1_SFMA_SHIFT);
 
 sfml 1  34 1 y
   sfml
-  s->macc = (s->macc & 0x8000000000000ULL) | ((s->macc << 1) & 0x7ffffffffffffULL);
+  macc = (macc & 0x8000000000000ULL) | ((macc << 1) & 0x7ffffffffffffULL);
 
 sfmo 2a 60 1 n f
   sfmo 0
-  s->st1 = (s->st1 & ~ST1_SFMO) | (0 << ST1_SFMO_SHIFT);
+  st1 = (st1 & ~ST1_SFMO) | (0 << ST1_SFMO_SHIFT);
 
 sfmo 2a 61 1 n f
   sfmo 2
-  s->st1 = (s->st1 & ~ST1_SFMO) | (1 << ST1_SFMO_SHIFT);
+  st1 = (st1 & ~ST1_SFMO) | (1 << ST1_SFMO_SHIFT);
 
 sfmo 2a 62 1 n f
   sfmo 4
-  s->st1 = (s->st1 & ~ST1_SFMO) | (2 << ST1_SFMO_SHIFT);
+  st1 = (st1 & ~ST1_SFMO) | (2 << ST1_SFMO_SHIFT);
 
 sfmo 2a 63 1 n f
   sfmo -8
-  s->st1 = (s->st1 & ~ST1_SFMO) | (3 << ST1_SFMO_SHIFT);
+  st1 = (st1 & ~ST1_SFMO) | (3 << ST1_SFMO_SHIFT);
 
 sfmr 1  35 1 y
   sfmr
@@ -483,11 +483,11 @@
 
 smom 2a 41 1 n f
   smom
-  s->st1 |= ST1_MOVM;
+  st1 |= ST1_MOVM;
 
 srbd 2a 0f 1 y
   srbd %d
-  %wd(s->xrd);
+  %wd(xrd);
 
 std1 2a 0d 1 y
   std1 %d
@@ -512,12 +512,12 @@
 
 wre  1  38 1 n
   wre %d,%c
-  if(s->sti & (S_READ|S_WRITE))
+  if(sti & (S_READ|S_WRITE))
     break;
-  s->xwr = %d24;
-  s->xoa = %c;
-  tms57002_xm_init(s);
-  s->sti |= S_WRITE;
+  xwr = %d24;
+  xoa = %c;
+  xm_init();
+  sti |= S_WRITE;
 
 xor  1  1a 1 n
   xor %d,a
diff -Nru src-old/emu/cpu/tms57002/tmsmake.c src/emu/cpu/tms57002/tmsmake.c
--- src-old/emu/cpu/tms57002/tmsmake.c	2011-07-21 14:19:08.000000000 +0200
+++ src/emu/cpu/tms57002/tmsmake.c	2012-03-09 19:50:18.000000000 +0100
@@ -86,14 +86,14 @@
 static const vinfo vinf[] = {
   { I_CMODE, 3, "cmode", "xmode(opcode, 'c')" },
   { I_DMODE, 3, "dmode", "xmode(opcode, 'd')" },
-  { I_SFAI,  2, "sfai",  "sfai(s->st1)"       },
-  { I_CRM,   4, "crm",   "crm(s->st1)"        },
-  { I_DBP,   2, "dbp",   "dbp(s->st1)"        },
-  { I_SFAO,  2, "sfao",  "sfao(s->st1)"       },
-  { I_SFMO,  4, "sfmo",  "sfmo(s->st1)"       },
-  { I_RND,   8, "rnd",   "rnd(s->st1)"        },
-  { I_MOVM,  2, "movm",  "movm(s->st1)"       },
-  { I_SFMA,  4, "sfma",  "sfma(s->st1)"       },
+  { I_SFAI,  2, "sfai",  "sfai(st1)"       },
+  { I_CRM,   4, "crm",   "crm(st1)"        },
+  { I_DBP,   2, "dbp",   "dbp(st1)"        },
+  { I_SFAO,  2, "sfao",  "sfao(st1)"       },
+  { I_SFMO,  4, "sfmo",  "sfmo(st1)"       },
+  { I_RND,   8, "rnd",   "rnd(st1)"        },
+  { I_MOVM,  2, "movm",  "movm(st1)"       },
+  { I_SFMA,  4, "sfma",  "sfma(st1)"       },
   { 0 }
 };
 
@@ -453,10 +453,10 @@
       for(j=0; j != pc; j++)
 	switch(par[j]) {
 	case PC:
-	  fprintf(f, ", tms57002_get_memadr(opcode, 'c')");
+	  fprintf(f, ", get_memadr(opcode, 'c')");
 	  break;
 	case PD:
-	  fprintf(f, ", tms57002_get_memadr(opcode, 'd')");
+	  fprintf(f, ", get_memadr(opcode, 'd')");
 	  break;
 	case PI:
 	  fprintf(f, ", opcode & 0xff");
@@ -482,15 +482,15 @@
       break;
 
     case PA:
-      scs(p, "tms57002_aacc_to_output(s)");
+      scs(p, "aacc_to_output()");
       break;
 
     case PC:
-      scs(p, "tms57002_opc_read_c(s, opcode)");
+      scs(p, "opc_read_c(opcode)");
       break;
 
     case PD:
-      scs(p, "(tms57002_opc_read_d(s, opcode) << 8)");
+      scs(p, "(opc_read_d(opcode) << 8)");
       break;
 
     case PI:
@@ -498,26 +498,26 @@
       break;
 
     case PD24:
-      scs(p, "tms57002_opc_read_d(s, opcode)");
+      scs(p, "opc_read_d(opcode)");
       break;
 
     case PML:
-      scs(p, "tms57002_macc_to_loop(s)");
+      scs(p, "macc_to_loop()");
       break;
 
     case PMO:
-      scs(p, "tms57002_macc_to_output(s)");
+      scs(p, "macc_to_output()");
       break;
 
     case PMV:
-      scs(p, "tms57002_check_macc_overflow(s)");
+      scs(p, "check_macc_overflow()");
       break;
 
     case PB:
-      scs(p, "s->pc = ");
+      scs(p, "pc = ");
       intrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1]);
       scs(p, ";\n");
-      scs(p, "  s->sti |= S_BRANCH");
+      scs(p, "  sti |= S_BRANCH");
       break;
 
     case PWA:
@@ -525,18 +525,18 @@
       intrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1]);
       scs(p, ";\n");
       scs(p, "  if(r < -0x80000000 || r > 0x7fffffff)\n");
-      scs(p, "    s->st1 |= ST1_AOV;\n");
-      scs(p, "  s->aacc = r");
+      scs(p, "    st1 |= ST1_AOV;\n");
+      scs(p, "  aacc = r");
       break;
 
     case PWC:
-      scs(p, "tms57002_opc_write_c(s, opcode, ");
+      scs(p, "opc_write_c(opcode, ");
       intrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1]);
       scs(p, ")");
       break;
 
     case PWD:
-      scs(p, "tms57002_opc_write_d(s, opcode, ");
+      scs(p, "opc_write_d(opcode, ");
       intrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1]);
       scs(p, ")");
       break;
@@ -546,7 +546,7 @@
       scs(p, " = ");
       intrp_expand(p, parse_res[i].ppos[1], parse_res[i].ppos[2]);
       scs(p, ";\n");
-      scs(p, "  if(s->st1 & ST1_SFAI)\n");
+      scs(p, "  if(st1 & ST1_SFAI)\n");
       scs(p, "    ");
       intrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1]);
       scs(p, " = ((INT32)");
@@ -636,19 +636,19 @@
 
     case PA:
       if(cv[IxSFAO])
-	scs(p, "(s->aacc << 7)");
+	scs(p, "(aacc << 7)");
       else
-	scs(p, "s->aacc");
+	scs(p, "aacc");
       break;
 
     case PC: {
       const char *r = NULL;
       if(cv[IxCMODE] == 0)
-	r = "s->cmem[i->param]";
+	r = "cmem[i->param]";
       else if(cv[IxCMODE] == 1)
-	r = "s->cmem[s->ca]";
+	r = "cmem[ca]";
       else if(cv[IxCMODE] == 2)
-	r = "s->cmem[s->ca++]";
+	r = "cmem[ca++]";
       else
 	abort();
 
@@ -670,19 +670,19 @@
     case PD:
       if(cv[IxDMODE] == 0)
 	if(cv[IxDBP])
-	  scs(p, "(s->dmem1[(i->param + s->ba1) & 0x1f] << 8)");
+	  scs(p, "(dmem1[(i->param + ba1) & 0x1f] << 8)");
 	else
-	  scs(p, "(s->dmem0[(i->param + s->ba0) & 0xff] << 8)");
+	  scs(p, "(dmem0[(i->param + ba0) & 0xff] << 8)");
       else if(cv[IxDMODE] == 1)
 	if(cv[IxDBP])
-	  scs(p, "(s->dmem1[(s->id + s->ba1) & 0x1f] << 8)");
+	  scs(p, "(dmem1[(id + ba1) & 0x1f] << 8)");
 	else
-	  scs(p, "(s->dmem0[(s->id + s->ba0) & 0xff] << 8)");
+	  scs(p, "(dmem0[(id + ba0) & 0xff] << 8)");
       else if(cv[IxDMODE] == 2)
 	if(cv[IxDBP])
-	  scs(p, "(s->dmem1[((s->id++) + s->ba1) & 0x1f] << 8)");
+	  scs(p, "(dmem1[((id++) + ba1) & 0x1f] << 8)");
 	else
-	  scs(p, "(s->dmem0[((s->id++) + s->ba0) & 0xff] << 8)");
+	  scs(p, "(dmem0[((id++) + ba0) & 0xff] << 8)");
       else
 	abort();
       break;
@@ -694,32 +694,32 @@
     case PD24:
       if(cv[IxDMODE] == 0)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[(i->param + s->ba1) & 0x1f]");
+	  scs(p, "dmem1[(i->param + ba1) & 0x1f]");
 	else
-	  scs(p, "s->dmem0[(i->param + s->ba0) & 0xff]");
+	  scs(p, "dmem0[(i->param + ba0) & 0xff]");
       else if(cv[IxDMODE] == 1)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[(s->id + s->ba1) & 0x1f]");
+	  scs(p, "dmem1[(id + ba1) & 0x1f]");
 	else
-	  scs(p, "s->dmem0[(s->id + s->ba0) & 0xff]");
+	  scs(p, "dmem0[(id + ba0) & 0xff]");
       else if(cv[IxDMODE] == 2)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[((s->id++) + s->ba1) & 0x1f]");
+	  scs(p, "dmem1[((id++) + ba1) & 0x1f]");
 	else
-	  scs(p, "s->dmem0[((s->id++) + s->ba0) & 0xff]");
+	  scs(p, "dmem0[((id++) + ba0) & 0xff]");
       else
 	abort();
       break;
 
     case PML:
       if(cv[IxSFMA] == 0)
-	scs(p, "s->macc");
+	scs(p, "macc");
       else if(cv[IxSFMA] == 1)
-	scs(p, "(s->macc << 2)");
+	scs(p, "(macc << 2)");
       else if(cv[IxSFMA] == 2)
-	scs(p, "(s->macc << 4)");
+	scs(p, "(macc << 4)");
       else if(cv[IxSFMA] == 3)
-	scs(p, "(s->macc >> 16)");
+	scs(p, "(macc >> 16)");
       else
 	abort();
       break;
@@ -743,23 +743,23 @@
       };
 
       char r[256];
-      sprintf(r, "tms57002_macc_to_output_%d%s(s, 0x%016" I64FMT "xULL, 0x%016" I64FMT "xULL)", cv[IxSFMO], cv[IxMOVM] ? "s" : "", rounding[cv[IxRND]], rmask[cv[IxRND]]);
+      sprintf(r, "macc_to_output_%d%s(0x%016" I64FMT "xULL, 0x%016" I64FMT "xULL)", cv[IxSFMO], cv[IxMOVM] ? "s" : "", rounding[cv[IxRND]], rmask[cv[IxRND]]);
       scs(p, r);
       break;
     }
 
     case PMV: {
       char r[256];
-      sprintf(r, "tms57002_check_macc_overflow_%d%s(s)", cv[IxSFMO], cv[IxMOVM] ? "s" : "");
+      sprintf(r, "check_macc_overflow_%d%s()", cv[IxSFMO], cv[IxMOVM] ? "s" : "");
       scs(p, r);
       break;
     }
 
     case PB:
-      scs(p, "s->pc = ");
+      scs(p, "pc = ");
       cintrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1], cv);
       scs(p, ";\n");
-      scs(p, "  s->sti |= S_BRANCH");
+      scs(p, "  sti |= S_BRANCH");
       break;
 
     case PWA:
@@ -767,17 +767,17 @@
       cintrp_expand(p, parse_res[i].ppos[0], parse_res[i].ppos[1], cv);
       scs(p, ";\n");
       scs(p, "  if(r < -0x80000000 || r > 0x7fffffff)\n");
-      scs(p, "    s->st1 |= ST1_AOV;\n");
-      scs(p, "  s->aacc = r");
+      scs(p, "    st1 |= ST1_AOV;\n");
+      scs(p, "  aacc = r");
       break;
 
     case PWC:
       if(cv[IxCMODE] == 0)
-	scs(p, "s->cmem[i->param] = ");
+	scs(p, "cmem[i->param] = ");
       else if(cv[IxCMODE] == 1)
-	scs(p, "s->cmem[s->ca] = ");
+	scs(p, "cmem[ca] = ");
       else if(cv[IxCMODE] == 2)
-	scs(p, "s->cmem[s->ca++] = ");
+	scs(p, "cmem[ca++] = ");
       else
 	abort();
 
@@ -787,19 +787,19 @@
     case PWD:
       if(cv[IxDMODE] == 0)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[(i->param + s->ba1) & 0x1f] = ");
+	  scs(p, "dmem1[(i->param + ba1) & 0x1f] = ");
 	else
-	  scs(p, "s->dmem0[(i->param + s->ba0) & 0xff] = ");
+	  scs(p, "dmem0[(i->param + ba0) & 0xff] = ");
       else if(cv[IxDMODE] == 1)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[(s->id + s->ba1) & 0x1f] = ");
+	  scs(p, "dmem1[(id + ba1) & 0x1f] = ");
 	else
-	  scs(p, "s->dmem0[(s->id + s->ba0) & 0xff] = ");
+	  scs(p, "dmem0[(id + ba0) & 0xff] = ");
       else if(cv[IxDMODE] == 2)
 	if(cv[IxDBP])
-	  scs(p, "s->dmem1[((s->id++) + s->ba1) & 0x1f] = ");
+	  scs(p, "dmem1[((id++) + ba1) & 0x1f] = ");
 	else
-	  scs(p, "s->dmem0[((s->id++) + s->ba0) & 0xff] = ");
+	  scs(p, "dmem0[((id++) + ba0) & 0xff] = ");
       else
 	abort();
 
@@ -876,7 +876,7 @@
   save_dasm_cat(f, "DASM3", cat3, 0x80);
 }
 
-static void save_intrp(FILE *f)
+void save_intrp(FILE *f)
 {
   save_intrp_cat(f, "INTRP1",  cat1, 0x40, 0,      0);
   save_intrp_cat(f, "INTRP2A", cat2, 0x80, I_POST, 0);
@@ -916,7 +916,7 @@
   compute_cache_ids();
 
   save_dasm(f);
-  save_intrp(f);
+  //  save_intrp(f);
   save_cdec(f);
   save_cintrp(f);
 
diff -Nru src-old/emu/device.c src/emu/device.c
--- src-old/emu/device.c	2012-02-25 20:21:35.000000000 +0100
+++ src/emu/device.c	2012-03-08 08:39:27.000000000 +0100
@@ -871,21 +871,9 @@
 //  find_shared_ptr - find a shared pointer
 //-------------------------------------------------
 
-void *device_t::auto_finder_base::find_shared_ptr(device_t &base, const char *tag)
+void *device_t::auto_finder_base::find_shared_ptr(device_t &base, const char *tag, size_t &bytes)
 {
-	return memory_get_shared(base.machine(), tag);
-}
-
-
-//-------------------------------------------------
-//  find_shared_size - find a shared pointer size
-//-------------------------------------------------
-
-size_t device_t::auto_finder_base::find_shared_size(device_t &base, const char *tag)
-{
-	size_t result = 0;
-	memory_get_shared(base.machine(), tag, result);
-	return result;
+	return memory_get_shared(base.machine(), tag, bytes);
 }
 
 
diff -Nru src-old/emu/device.h src/emu/device.h
--- src-old/emu/device.h	2012-02-01 01:45:55.000000000 +0100
+++ src/emu/device.h	2012-03-11 18:17:00.000000000 +0100
@@ -301,8 +301,7 @@
 
 		// helpers
 		device_t *find_device(device_t &device, const char *tag);
-		void *find_shared_ptr(device_t &device, const char *tag);
-		size_t find_shared_size(device_t &device, const char *tag);
+		void *find_shared_ptr(device_t &device, const char *tag, size_t &bytes);
 
 		// internal state
 		auto_finder_base *m_next;
@@ -335,6 +334,7 @@
 				throw emu_fatalerror("Unable to find required object '%s'", this->m_tag);
 		}
 
+	protected:
 		// internal state
 		_TargetType m_target;
 	};
@@ -362,8 +362,13 @@
 	class optional_shared_ptr : public auto_finder_type<_PointerType *, false>
 	{
 	public:
-		optional_shared_ptr(device_t &base, const char *tag) : auto_finder_type<_PointerType *, false>(base, tag) { }
-		virtual void findit(device_t &base) { this->set_target(reinterpret_cast<_PointerType *>(this->find_shared_ptr(base, this->m_tag))); }
+		optional_shared_ptr(device_t &base, const char *tag) : auto_finder_type<_PointerType *, false>(base, tag), m_bytes(0) { }
+		virtual void findit(device_t &base) { this->set_target(reinterpret_cast<_PointerType *>(this->find_shared_ptr(base, this->m_tag, m_bytes))); }
+		UINT32 bytes() const { return m_bytes; }
+
+	private:
+		// internal state
+		size_t m_bytes;
 	};
 
 	// required shared pointer finder
@@ -371,24 +376,13 @@
 	class required_shared_ptr : public auto_finder_type<_PointerType *, true>
 	{
 	public:
-		required_shared_ptr(device_t &base, const char *tag) : auto_finder_type<_PointerType *, true>(base, tag) { }
-		virtual void findit(device_t &base) { this->set_target(reinterpret_cast<_PointerType *>(this->find_shared_ptr(base, this->m_tag))); }
-	};
-
-	// optional shared pointer size finder
-	class optional_shared_size : public auto_finder_type<size_t, false>
-	{
-	public:
-		optional_shared_size(device_t &base, const char *tag) : auto_finder_type<size_t, false>(base, tag) { }
-		virtual void findit(device_t &base) { this->set_target(find_shared_size(base, this->m_tag)); }
-	};
+		required_shared_ptr(device_t &base, const char *tag) : auto_finder_type<_PointerType *, true>(base, tag), m_bytes(0) { }
+		virtual void findit(device_t &base) { this->set_target(reinterpret_cast<_PointerType *>(this->find_shared_ptr(base, this->m_tag, m_bytes))); }
+		UINT32 bytes() const { return m_bytes; }
 
-	// required shared pointer size finder
-	class required_shared_size : public auto_finder_type<size_t, true>
-	{
-	public:
-		required_shared_size(device_t &base, const char *tag) : auto_finder_type<size_t, true>(base, tag) { }
-		virtual void findit(device_t &base) { this->set_target(find_shared_size(base, this->m_tag)); }
+	private:
+		// internal state
+		size_t m_bytes;
 	};
 
 	// internal helpers
diff -Nru src-old/emu/devimage.c src/emu/devimage.c
--- src-old/emu/devimage.c	2011-11-26 19:10:06.000000000 +0100
+++ src/emu/devimage.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,176 +0,0 @@
-/***************************************************************************
-
-    devimage.c
-
-    Legacy image device helpers.
-
-****************************************************************************
-
-    Copyright Miodrag Milanovic
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-***************************************************************************/
-
-
-#include "emu.h"
-#include "devlegcy.h"
-
-
-//**************************************************************************
-//  LEGACY IMAGE DEVICE CONFIGURATION
-//**************************************************************************
-
-//-------------------------------------------------
-//  legacy_device_base - destructor
-//-------------------------------------------------
-
-legacy_image_device_base::~legacy_image_device_base()
-{
-}
-
-//**************************************************************************
-//  LIVE LEGACY IMAGE DEVICE
-//**************************************************************************
-
-//-------------------------------------------------
-//  legacy_image_device_base - constructor
-//-------------------------------------------------
-
-legacy_image_device_base::legacy_image_device_base(const machine_config &mconfig, device_type type, const char *tag, device_t *owner, UINT32 clock, device_get_config_func get_config)
-	: legacy_device_base(mconfig, type, tag, owner, clock, get_config),
-	  device_image_interface(mconfig, *this)
-{
-}
-
-
-//-------------------------------------------------
-//  device_config_complete - update configuration
-//  based on completed device setup
-//-------------------------------------------------
-
-void legacy_image_device_base::device_config_complete()
-{
-    image_device_format **formatptr;
-    image_device_format *format;
-    formatptr = &m_formatlist;
-    int cnt = 0;
-
-    int format_count = get_legacy_int(DEVINFO_INT_IMAGE_CREATE_OPTCOUNT);
-
-	for (int i = 0; i < format_count; i++)
-	{
-		// only add if creatable
-		if (get_legacy_string(DEVINFO_PTR_IMAGE_CREATE_OPTSPEC + i)) {
-			// allocate a new format
-			format = global_alloc_clear(image_device_format);
-
-			// populate it
-			format->m_index       = cnt;
-			format->m_name        = get_legacy_string(DEVINFO_STR_IMAGE_CREATE_OPTNAME + i);
-			format->m_description = get_legacy_string(DEVINFO_STR_IMAGE_CREATE_OPTDESC + i);
-			format->m_extensions  = get_legacy_string(DEVINFO_STR_IMAGE_CREATE_OPTEXTS + i);
-			format->m_optspec     = get_legacy_string(DEVINFO_PTR_IMAGE_CREATE_OPTSPEC + i);
-
-			// and append it to the list
-			*formatptr = format;
-			formatptr = &format->m_next;
-			cnt++;
-		}
-	}
-
-	update_names();
-
-	// Override in case of hardcoded values
-	if (strlen(get_legacy_string(DEVINFO_STR_IMAGE_INSTANCE_NAME))>0) {
-		m_instance_name = get_legacy_string(DEVINFO_STR_IMAGE_INSTANCE_NAME);
-	}
-	if (strlen(get_legacy_string(DEVINFO_STR_IMAGE_BRIEF_INSTANCE_NAME))>0) {
-		m_brief_instance_name = get_legacy_string(DEVINFO_STR_IMAGE_BRIEF_INSTANCE_NAME);
-	}
-}
-
-
-bool legacy_image_device_base::call_load()
-{
-	device_image_load_func func = reinterpret_cast<device_image_load_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_LOAD));
-	if (func) {
-		return (*func)(*this);
-	} else {
-		return FALSE;
-	}
-}
-
-bool legacy_image_device_base::call_softlist_load(char *swlist, char *swname, rom_entry *start_entry)
-{
-	device_image_softlist_load_func func = reinterpret_cast<device_image_softlist_load_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_SOFTLIST_LOAD));
-	if (func) {
-		return (*func)(*this,swlist,swname,start_entry);
-	} else {
-		return FALSE;
-	}
-}
-
-bool legacy_image_device_base::call_create(int format_type, option_resolution *format_options)
-{
-	device_image_create_func func = reinterpret_cast<device_image_create_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_CREATE));
-	if (func) {
-		return (*func)(*this,format_type,format_options);
-	} else {
-		return FALSE;
-	}
-}
-
-void legacy_image_device_base::call_unload()
-{
-	device_image_unload_func func = reinterpret_cast<device_image_unload_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_UNLOAD));
-	if (func) (*func)(*this);
-}
-
-void legacy_image_device_base::call_display()
-{
-	device_image_display_func func = reinterpret_cast<device_image_display_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_DISPLAY));
-	if (func) (*func)(*this);
-}
-
-void legacy_image_device_base::call_display_info()
-{
-	device_image_display_info_func func = reinterpret_cast<device_image_display_info_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_DISPLAY_INFO));
-	if (func) (*func)(*this);
-}
-
-void legacy_image_device_base::call_get_devices()
-{
-	device_image_get_devices_func func = reinterpret_cast<device_image_get_devices_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_GET_DEVICES));
-	if (func) (*func)(*this);
-}
-
-device_image_partialhash_func legacy_image_device_base::get_partial_hash() const
-{
-	return reinterpret_cast<device_image_partialhash_func>(get_legacy_fct(DEVINFO_FCT_IMAGE_PARTIAL_HASH));
-}
diff -Nru src-old/emu/devlegcy.h src/emu/devlegcy.h
--- src-old/emu/devlegcy.h	2012-02-03 14:28:28.000000000 +0100
+++ src/emu/devlegcy.h	2012-03-08 08:39:27.000000000 +0100
@@ -134,47 +134,7 @@
 
 	DEVINFO_STR_CLASS_SPECIFIC = 0x34000,				// R/W: device-specific values start here
 	DEVINFO_STR_DEVICE_SPECIFIC = 0x38000,				// R/W: device-specific values start here
-	DEVINFO_STR_LAST = 0x3ffff,
-
-    /* --- image device related --- */
-	/* --- the following bits of info are returned as integers --- */
-    DEVINFO_INT_IMAGE_FIRST = DEVINFO_INT_FIRST + 0x7000,
-    DEVINFO_INT_IMAGE_TYPE,
-    DEVINFO_INT_IMAGE_READABLE,
-    DEVINFO_INT_IMAGE_WRITEABLE,
-    DEVINFO_INT_IMAGE_CREATABLE,
-    DEVINFO_INT_IMAGE_MUST_BE_LOADED,
-    DEVINFO_INT_IMAGE_RESET_ON_LOAD,
-    DEVINFO_INT_IMAGE_CREATE_OPTCOUNT,
-    DEVINFO_INT_IMAGE_LAST = DEVINFO_INT_IMAGE_FIRST + 0x0fff,
-
-    /* --- the following bits of info are returned as pointers --- */
-    DEVINFO_PTR_IMAGE_FIRST = DEVINFO_PTR_FIRST + 0x7000,
-    DEVINFO_PTR_IMAGE_CREATE_OPTGUIDE,
-    DEVINFO_PTR_IMAGE_CREATE_OPTSPEC,
-
-    /* --- the following bits of info are returned as pointers to functions --- */
-    DEVINFO_FCT_IMAGE_FIRST = DEVINFO_FCT_FIRST + 0x7000,
-    DEVINFO_FCT_IMAGE_LOAD,                                     /* R/O: device_image_load_func */
-    DEVINFO_FCT_IMAGE_CREATE,                                   /* R/O: device_image_create_func */
-    DEVINFO_FCT_IMAGE_UNLOAD,                                   /* R/O: device_image_unload_func */
-    DEVINFO_FCT_IMAGE_DISPLAY,                                  /* R/O: device_image_display_func */
-    DEVINFO_FCT_IMAGE_PARTIAL_HASH,                             /* R/O: device_image_partialhash_func */
-    DEVINFO_FCT_IMAGE_DISPLAY_INFO,                             /* R/O: device_image_display_info_func */
-    DEVINFO_FCT_IMAGE_GET_DEVICES,                              /* R/O: device_image_get_devices_func */
-	DEVINFO_FCT_IMAGE_SOFTLIST_LOAD,                            /* R/O: device_image_softlist_load_func */
-    DEVINFO_FCT_IMAGE_LAST = DEVINFO_FCT_FIRST + 0x0fff,
-
-    /* --- the following bits of info are returned as NULL-terminated strings --- */
-    DEVINFO_STR_IMAGE_FIRST = DEVINFO_STR_FIRST + 0x7000,
-    DEVINFO_STR_IMAGE_FILE_EXTENSIONS,
-    DEVINFO_STR_IMAGE_INSTANCE_NAME,
-    DEVINFO_STR_IMAGE_BRIEF_INSTANCE_NAME,
-    DEVINFO_STR_IMAGE_CREATE_OPTNAME,
-    DEVINFO_STR_IMAGE_CREATE_OPTDESC = DEVINFO_STR_IMAGE_CREATE_OPTNAME + DEVINFO_IMAGE_CREATE_OPTMAX,
-    DEVINFO_STR_IMAGE_CREATE_OPTEXTS = DEVINFO_STR_IMAGE_CREATE_OPTDESC + DEVINFO_IMAGE_CREATE_OPTMAX,
-	DEVINFO_STR_IMAGE_INTERFACE,
-    DEVINFO_STR_IMAGE_LAST = DEVINFO_STR_IMAGE_FIRST + 0x0fff
+	DEVINFO_STR_LAST = 0x3ffff
 };
 
 //**************************************************************************
@@ -215,11 +175,9 @@
 // reduced macros that are easier to use, and map to the above two macros
 #define DECLARE_LEGACY_DEVICE(name, basename) _DECLARE_LEGACY_DEVICE(name, basename, basename##_device, legacy_device_base)
 #define DECLARE_LEGACY_SOUND_DEVICE(name, basename) _DECLARE_LEGACY_DEVICE(name, basename, basename##_device, legacy_sound_device_base)
-#define DECLARE_LEGACY_IMAGE_DEVICE(name, basename) _DECLARE_LEGACY_DEVICE(name, basename, basename##_device, legacy_image_device_base)
 
 #define DEFINE_LEGACY_DEVICE(name, basename) _DEFINE_LEGACY_DEVICE(name, basename, basename##_device, legacy_device_base)
 #define DEFINE_LEGACY_SOUND_DEVICE(name, basename) _DEFINE_LEGACY_DEVICE(name, basename, basename##_device, legacy_sound_device_base)
-#define DEFINE_LEGACY_IMAGE_DEVICE(name, basename) _DEFINE_LEGACY_DEVICE(name, basename, basename##_device, legacy_image_device_base)
 
 
 // macros to wrap legacy device functions
@@ -267,38 +225,6 @@
 #define MCFG_DEVICE_CONFIG_DATA32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) \
 	MCFG_DEVICE_CONFIG_DATA32_EXPLICIT(structsizeof(_memstruct, _member), offsetof(_struct, _field) + (_index) * structsizeof(_struct, _field[0]) + offsetof(_memstruct, _member), _val)
 
-#define MCFG_NEW_DEVICE_CONFIG_DATA32(_struct, _field, _val) \
-	MCFG_DEVICE_CONFIG_DATA32_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field), DEVCONFIG_OFFSETOF(_struct, _field), _val)
-
-#define MCFG_NEW_DEVICE_CONFIG_DATA32_ARRAY(_struct, _field, _index, _val) \
-	MCFG_DEVICE_CONFIG_DATA32_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field[0]), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]), _val)
-
-#define MCFG_NEW_DEVICE_CONFIG_DATA32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) \
-	MCFG_DEVICE_CONFIG_DATA32_EXPLICIT(DEVCONFIG_SIZEOF(_memstruct, _member), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]) + DEVCONFIG_OFFSETOF(_memstruct, _member), _val)
-
-
-// inline device configurations that require 32 bits of fixed-point storage in the token
-#define MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(_size, _offset, _val, _fixbits) \
-	legacy_device_base::static_set_inline_float(*device, _offset, _size, (float)(_val));
-
-#define MCFG_DEVICE_CONFIG_DATAFP32(_struct, _field, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(structsizeof(_struct, _field), offsetof(_struct, _field), _val, _fixbits)
-
-#define MCFG_DEVICE_CONFIG_DATAFP32_ARRAY(_struct, _field, _index, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(structsizeof(_struct, _field[0]), offsetof(_struct, _field) + (_index) * structsizeof(_struct, _field[0]), _val, _fixbits)
-
-#define MCFG_DEVICE_CONFIG_DATAFP32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(structsizeof(_memstruct, _member), offsetof(_struct, _field) + (_index) * structsizeof(_struct, _field[0]) + offsetof(_memstruct, _member), _val, _fixbits)
-
-#define MCFG_DEVICE_NEW_CONFIG_DATAFP32(_struct, _field, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field), DEVCONFIG_OFFSETOF(_struct, _field), _val, _fixbits)
-
-#define MCFG_DEVICE_NEW_CONFIG_DATAFP32_ARRAY(_struct, _field, _index, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field[0]), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]), _val, _fixbits)
-
-#define MCFG_DEVICE_NEW_CONFIG_DATAFP32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val, _fixbits) \
-	MCFG_DEVICE_CONFIG_DATAFP32_EXPLICIT(DEVCONFIG_SIZEOF(_memstruct, _member), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]) + DEVCONFIG_OFFSETOF(_memstruct, _member), _val, _fixbits)
-
 
 // inline device configurations that require 64 bits of storage in the token
 #define MCFG_DEVICE_CONFIG_DATA64_EXPLICIT(_size, _offset, _val) \
@@ -313,15 +239,6 @@
 #define MCFG_DEVICE_CONFIG_DATA64_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) \
 	MCFG_DEVICE_CONFIG_DATA64_EXPLICIT(structsizeof(_memstruct, _member), offsetof(_struct, _field) + (_index) * structsizeof(_struct, _field[0]) + offsetof(_memstruct, _member), _val)
 
-#define MCFG_DEVICE_NEW_CONFIG_DATA64(_struct, _field, _val) \
-	MCFG_DEVICE_CONFIG_DATA64_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field), DEVCONFIG_OFFSETOF(_struct, _field), _val)
-
-#define MCFG_DEVICE_NEW_CONFIG_DATA64_ARRAY(_struct, _field, _index, _val) \
-	MCFG_DEVICE_CONFIG_DATA64_EXPLICIT(DEVCONFIG_SIZEOF(_struct, _field[0]), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]), _val)
-
-#define MCFG_DEVICE_NEW_CONFIG_DATA64_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) \
-	MCFG_DEVICE_CONFIG_DATA64_EXPLICIT(DEVCONFIG_SIZEOF(_memstruct, _member), DEVCONFIG_OFFSETOF(_struct, _field) + (_index) * DEVCONFIG_SIZEOF(_struct, _field[0]) + DEVCONFIG_OFFSETOF(_memstruct, _member), _val)
-
 
 // inline device configurations that require a pointer-sized amount of storage in the token
 #ifdef PTR64
@@ -329,17 +246,11 @@
 #define MCFG_DEVICE_CONFIG_DATAPTR(_struct, _field, _val) MCFG_DEVICE_CONFIG_DATA64(_struct, _field, _val)
 #define MCFG_DEVICE_CONFIG_DATAPTR_ARRAY(_struct, _field, _index, _val) MCFG_DEVICE_CONFIG_DATA64_ARRAY(_struct, _field, _index, _val)
 #define MCFG_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) MCFG_DEVICE_CONFIG_DATA64_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val)
-#define MCFG_DEVICE_NEW_CONFIG_DATAPTR(_struct, _field, _val) MCFG_DEVICE_NEW_CONFIG_DATA64(_struct, _field, _val)
-#define MCFG_DEVICE_NEW_CONFIG_DATAPTR_ARRAY(_struct, _field, _index, _val) MCFG_DEVICE_NEW_CONFIG_DATA64_ARRAY(_struct, _field, _index, _val)
-#define MCFG_DEVICE_NEW_CONFIG_DATAPTR_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) MCFG_DEVICE_NEW_CONFIG_DATA64_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val)
 #else
 #define MCFG_DEVICE_CONFIG_DATAPTR_EXPLICIT(_struct, _size, _offset) MCFG_DEVICE_CONFIG_DATA32_EXPLICIT(_struct, _size, _offset)
 #define MCFG_DEVICE_CONFIG_DATAPTR(_struct, _field, _val) MCFG_DEVICE_CONFIG_DATA32(_struct, _field, _val)
 #define MCFG_DEVICE_CONFIG_DATAPTR_ARRAY(_struct, _field, _index, _val) MCFG_DEVICE_CONFIG_DATA32_ARRAY(_struct, _field, _index, _val)
 #define MCFG_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) MCFG_DEVICE_CONFIG_DATA32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val)
-#define MCFG_DEVICE_CONFIG_NEW_DATAPTR(_struct, _field, _val) MCFG_DEVICE_NEW_CONFIG_DATA32(_struct, _field, _val)
-#define MCFG_DEVICE_CONFIG_NEW_DATAPTR_ARRAY(_struct, _field, _index, _val) MCFG_DEVICE_NEW_CONFIG_DATA32_ARRAY(_struct, _field, _index, _val)
-#define MCFG_DEVICE_CONFIG_NEW_DATAPTR_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val) MCFG_DEVICE_NEW_CONFIG_DATA32_ARRAY_MEMBER(_struct, _field, _index, _memstruct, _member, _val)
 #endif
 
 
@@ -457,40 +368,4 @@
 
 
 
-// ======================> legacy_image_device
-
-// legacy_image_device is a legacy_device_base with a image interface
-class legacy_image_device_base :	public legacy_device_base,
-									public device_image_interface
-{
-public:
-	virtual bool call_load();
-	virtual bool call_softlist_load(char *swlist, char *swname, rom_entry *start_entry);
-	virtual bool call_create(int format_type, option_resolution *format_options);
-	virtual void call_unload();
-	virtual void call_display();
-	virtual void call_display_info();
-	virtual device_image_partialhash_func get_partial_hash() const;
-	virtual void call_get_devices();
-
-	virtual iodevice_t image_type() const { return static_cast<iodevice_t>(get_legacy_int(DEVINFO_INT_IMAGE_TYPE)); }
-
-	virtual bool is_readable()  const { return get_legacy_int(DEVINFO_INT_IMAGE_READABLE)!=0; }
-	virtual bool is_writeable() const { return get_legacy_int(DEVINFO_INT_IMAGE_WRITEABLE)!=0; }
-	virtual bool is_creatable() const { return get_legacy_int(DEVINFO_INT_IMAGE_CREATABLE)!=0; }
-	virtual bool must_be_loaded() const { return get_legacy_int(DEVINFO_INT_IMAGE_MUST_BE_LOADED)!=0; }
-	virtual bool is_reset_on_load() const { return get_legacy_int(DEVINFO_INT_IMAGE_RESET_ON_LOAD)!=0; }
-	virtual const char *image_interface() const { return get_legacy_string(DEVINFO_STR_IMAGE_INTERFACE); }
-	virtual const char *file_extensions() const { return get_legacy_string(DEVINFO_STR_IMAGE_FILE_EXTENSIONS); }
-	virtual const option_guide *create_option_guide() const { return reinterpret_cast<const option_guide *>(get_legacy_ptr(DEVINFO_PTR_IMAGE_CREATE_OPTGUIDE)); }
-protected:
-	// device overrides
-	virtual void device_config_complete();
-
-	// construction/destruction
-	legacy_image_device_base(const machine_config &mconfig, device_type type, const char *tag, device_t *owner, UINT32 clock, device_get_config_func get_config);
-	~legacy_image_device_base();
-};
-
-
 #endif	/* __DEVLEGCY_H__ */
diff -Nru src-old/emu/diimage.c src/emu/diimage.c
--- src-old/emu/diimage.c	2012-02-26 15:31:24.000000000 +0100
+++ src/emu/diimage.c	2012-03-06 08:30:55.000000000 +0100
@@ -1097,7 +1097,7 @@
     update_names - update brief and instance names
 -------------------------------------------------*/
 
-void device_image_interface::update_names()
+void device_image_interface::update_names(const device_type device_type, const char *inst, const char *brief)
 {
 	image_interface_iterator iter(device().mconfig().root_device());
 	int count = 0;
@@ -1106,18 +1106,20 @@
 	{
 		if (this == image)
 			index = count;
-		if (image->image_type() == image_type())
+		if ((image->image_type() == image_type() && device_type==NULL) || (device_type==image->device().type()))
 			count++;
 	}
+	const char *inst_name = (device_type!=NULL) ? inst : device_typename(image_type());
+	const char *brief_name = (device_type!=NULL) ? brief : device_brieftypename(image_type());
 	if (count > 1)
 	{
-		m_instance_name.printf("%s%d", device_typename(image_type()), index + 1);
-		m_brief_instance_name.printf("%s%d", device_brieftypename(image_type()), index + 1);
+		m_instance_name.printf("%s%d", inst_name , index + 1);
+		m_brief_instance_name.printf("%s%d", brief_name, index + 1);
 	}
 	else
 	{
-		m_instance_name = device_typename(image_type());
-		m_brief_instance_name = device_brieftypename(image_type());
+		m_instance_name = inst_name;
+		m_brief_instance_name = brief_name;
 	}
 }
 
diff -Nru src-old/emu/diimage.h src/emu/diimage.h
--- src-old/emu/diimage.h	2012-02-21 13:43:14.000000000 +0100
+++ src/emu/diimage.h	2012-03-06 13:57:06.000000000 +0100
@@ -108,12 +108,8 @@
 
 // device image interface function types
 typedef int (*device_image_load_func)(device_image_interface &image);
-typedef int (*device_image_create_func)(device_image_interface &image, int format_type, option_resolution *format_options);
 typedef void (*device_image_unload_func)(device_image_interface &image);
-typedef void (*device_image_display_func)(device_image_interface &image);
 typedef void (*device_image_partialhash_func)(hash_collection &, const unsigned char *, unsigned long, const char *);
-typedef void (*device_image_get_devices_func)(device_image_interface &device);
-typedef bool (*device_image_softlist_load_func)(device_image_interface &image, char *swlist, char *swname, rom_entry *start_entry);
 typedef void (*device_image_display_info_func)(device_image_interface &image);
 
 //**************************************************************************
@@ -128,26 +124,12 @@
 #define DEVICE_IMAGE_LOAD_NAME(name)        device_load_##name
 #define DEVICE_IMAGE_LOAD(name)             int DEVICE_IMAGE_LOAD_NAME(name)(device_image_interface &image)
 
-#define DEVICE_IMAGE_CREATE_NAME(name)      device_create_##name
-#define DEVICE_IMAGE_CREATE(name)           int DEVICE_IMAGE_CREATE_NAME(name)(device_image_interface &image, int create_format, option_resolution *create_args)
-
 #define DEVICE_IMAGE_UNLOAD_NAME(name)      device_unload_##name
 #define DEVICE_IMAGE_UNLOAD(name)           void DEVICE_IMAGE_UNLOAD_NAME(name)(device_image_interface &image)
 
-#define DEVICE_IMAGE_DISPLAY_NAME(name)     device_image_display_func##name
-#define DEVICE_IMAGE_DISPLAY(name)          void DEVICE_IMAGE_DISPLAY_NAME(name)(device_image_interface &image)
-
 #define DEVICE_IMAGE_DISPLAY_INFO_NAME(name)     device_image_display_info_func##name
 #define DEVICE_IMAGE_DISPLAY_INFO(name)          void DEVICE_IMAGE_DISPLAY_INFO_NAME(name)(device_image_interface &image)
 
-#define DEVICE_IMAGE_GET_DEVICES_NAME(name) device_image_get_devices_##name
-#define DEVICE_IMAGE_GET_DEVICES(name)      void DEVICE_IMAGE_GET_DEVICES_NAME(name)(device_image_interface &image)
-
-#define DEVICE_IMAGE_SOFTLIST_LOAD_NAME(name)        device_softlist_load_##name
-#define DEVICE_IMAGE_SOFTLIST_LOAD(name)             bool DEVICE_IMAGE_SOFTLIST_LOAD_NAME(name)(device_image_interface &image, char *swlist, char *swname, rom_entry *start_entry)
-
-
-
 // ======================> device_image_interface
 
 // class representing interface-specific live image
@@ -170,7 +152,6 @@
 	virtual void call_unload() { }
 	virtual void call_display() { }
 	virtual void call_display_info() { }
-	virtual void call_get_devices() { }
 	virtual device_image_partialhash_func get_partial_hash() const { return NULL; }
 	virtual iodevice_t image_type()  const = 0;
 	virtual bool is_readable()  const = 0;
@@ -272,7 +253,7 @@
 	int read_hash_config(const char *sysname);
 	void run_hash(void (*partialhash)(hash_collection &, const unsigned char *, unsigned long, const char *), hash_collection &hashes, const char *types);
 	void image_checkhash();
-	void update_names();
+	void update_names(const device_type device_type = NULL, const char *inst = NULL, const char *brief = NULL);
 	// derived class overrides
 
 	// configuration
diff -Nru src-old/emu/disound.h src/emu/disound.h
--- src-old/emu/disound.h	2012-02-25 20:21:35.000000000 +0100
+++ src/emu/disound.h	2012-02-28 10:21:05.000000000 +0100
@@ -176,5 +176,8 @@
 	sound_stream *		m_mixer_stream;			// mixing stream
 };
 
+// iterator
+typedef device_interface_iterator<device_mixer_interface> mixer_interface_iterator;
+
 
 #endif	/* __DISOUND_H__ */
diff -Nru src-old/emu/emu.mak src/emu/emu.mak
--- src-old/emu/emu.mak	2012-02-09 04:41:36.000000000 +0100
+++ src/emu/emu.mak	2012-03-08 08:39:27.000000000 +0100
@@ -57,7 +57,6 @@
 	$(EMUOBJ)/devcb.o \
 	$(EMUOBJ)/devcpu.o \
 	$(EMUOBJ)/device.o \
-	$(EMUOBJ)/devimage.o \
 	$(EMUOBJ)/devlegcy.o \
 	$(EMUOBJ)/didisasm.o \
 	$(EMUOBJ)/diexec.o \
@@ -268,6 +267,7 @@
 
 EMUVIDEOOBJS = \
 	$(EMUVIDEO)/315_5124.o		\
+	$(EMUVIDEO)/bufsprite.o		\
 	$(EMUVIDEO)/cdp1861.o		\
 	$(EMUVIDEO)/cdp1862.o		\
 	$(EMUVIDEO)/crt9007.o		\
diff -Nru src-old/emu/image.c src/emu/image.c
--- src-old/emu/image.c	2012-02-20 12:42:40.000000000 +0100
+++ src/emu/image.c	2012-03-06 13:57:06.000000000 +0100
@@ -251,8 +251,6 @@
 				fatalerror_exitcode(machine, MAMERR_DEVICE, "Driver requires that device \"%s\" must have an image to load", image->instance_name());
 			}
 		}
-
-		image->call_get_devices();
 	}
 }
 
diff -Nru src-old/emu/imagedev/flopdrv.c src/emu/imagedev/flopdrv.c
--- src-old/emu/imagedev/flopdrv.c	2012-01-26 11:28:50.000000000 +0100
+++ src/emu/imagedev/flopdrv.c	2012-03-11 18:17:00.000000000 +0100
@@ -117,14 +117,11 @@
 /***************************************************************************
     IMPLEMENTATION
 ***************************************************************************/
-//DECLARE_LEGACY_IMAGE_DEVICE(FLOPPY_APPLE, apple525);
-//DECLARE_LEGACY_IMAGE_DEVICE(FLOPPY_SONY, sonydriv);
 
 INLINE floppy_drive *get_safe_token(device_t *device)
 {
 	assert( device != NULL );
-	//assert( device->type() == LEGACY_FLOPPY || device->type() == FLOPPY_APPLE || device->type() == FLOPPY_SONY);
-	return (floppy_drive *) downcast<legacy_device_base *>(device)->token();
+	return (floppy_drive *) downcast<legacy_floppy_image_device *>(device)->token();
 }
 
 floppy_image_legacy *flopimg_get_image(device_t *image)
@@ -561,40 +558,6 @@
 	drv->controller = controller;
 }
 
-/* ----------------------------------------------------------------------- */
-DEVICE_START( floppy )
-{
-	floppy_drive *floppy = get_safe_token( device );
-	floppy->config = (const floppy_interface*)device->static_config();
-	floppy_drive_init(device);
-
-	floppy->drive_id = floppy_get_drive(device);
-	floppy->active = FALSE;
-
-	/* resolve callbacks */
-	floppy->out_idx_func.resolve(floppy->config->out_idx_func, *device);
-	floppy->in_mon_func.resolve(floppy->config->in_mon_func, *device);
-	floppy->out_tk00_func.resolve(floppy->config->out_tk00_func, *device);
-	floppy->out_wpt_func.resolve(floppy->config->out_wpt_func, *device);
-	floppy->out_rdy_func.resolve(floppy->config->out_rdy_func, *device);
-//  floppy->out_dskchg_func.resolve(floppy->config->out_dskchg_func, *device);
-
-	/* by default we are not write-protected */
-	floppy->wpt = ASSERT_LINE;
-	floppy->out_wpt_func(floppy->wpt);
-
-	/* not at track 0 */
-	floppy->tk00 = ASSERT_LINE;
-	floppy->out_tk00_func(floppy->tk00);
-
-	/* motor off */
-	floppy->mon = ASSERT_LINE;
-
-	/* disk changed */
-	floppy->dskchg = CLEAR_LINE;
-//  floppy->out_dskchg_func(floppy->dskchg);
-}
-
 static int internal_floppy_device_load(device_image_interface *image, int create_format, option_resolution *create_args)
 {
 	floperr_t err;
@@ -654,60 +617,6 @@
 	flopimg->out_wpt_func(param);
 }
 
-DEVICE_IMAGE_LOAD( floppy )
-{
-	floppy_drive *flopimg;
-	int retVal = internal_floppy_device_load(&image, -1, NULL);
-	flopimg = get_safe_token( &image.device() );
-	if (retVal==IMAGE_INIT_PASS) {
-		/* if we have one of our hacky unload procs, call it */
-		if (flopimg->load_proc)
-			flopimg->load_proc(image);
-	}
-
-	/* push disk halfway into drive */
-	flopimg->wpt = CLEAR_LINE;
-	flopimg->out_wpt_func(flopimg->wpt);
-
-	/* set timer for disk load */
-	int next_wpt;
-
-	if (!image.is_readonly())
-		next_wpt = ASSERT_LINE;
-	else
-		next_wpt = CLEAR_LINE;
-
-	image.device().machine().scheduler().timer_set(attotime::from_msec(250), FUNC(set_wpt), next_wpt, flopimg);
-
-	return retVal;
-}
-
-DEVICE_IMAGE_CREATE( floppy )
-{
-	return internal_floppy_device_load(&image, create_format, create_args);
-}
-
-DEVICE_IMAGE_UNLOAD( floppy )
-{
-	floppy_drive *flopimg = get_safe_token( &image.device() );
-	if (flopimg->unload_proc)
-		flopimg->unload_proc(image);
-
-	floppy_close(flopimg->floppy);
-	flopimg->floppy = NULL;
-
-	/* disk changed */
-	flopimg->dskchg = CLEAR_LINE;
-	//flopimg->out_dskchg_func(flopimg->dskchg);
-
-	/* pull disk halfway out of drive */
-	flopimg->wpt = CLEAR_LINE;
-	flopimg->out_wpt_func(flopimg->wpt);
-
-	/* set timer for disk eject */
-	image.device().machine().scheduler().timer_set(attotime::from_msec(250), FUNC(set_wpt), ASSERT_LINE, flopimg);
-}
-
 device_t *floppy_get_device(running_machine &machine,int drive)
 {
 	switch(drive) {
@@ -949,121 +858,193 @@
 	return !(floppy_drive_get_flag_state(device, FLOPPY_DRIVE_READY) == FLOPPY_DRIVE_READY);
 }
 
-/*-------------------------------------------------
-    DEVICE_IMAGE_SOFTLIST_LOAD(floppy)
--------------------------------------------------*/
-static DEVICE_IMAGE_SOFTLIST_LOAD(floppy)
-{
-	return image.load_software(swlist, swname, start_entry);
-}
-
-/*************************************
- *
- *  Device specification function
- *
- *************************************/
-/*-------------------------------------------------
-    safe_strcpy - hack
--------------------------------------------------*/
-
-static void safe_strcpy(char *dst, const char *src)
-{
-	strcpy(dst, src ? src : "");
-}
-
-DEVICE_GET_INFO(floppy)
-{
-	switch( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:				info->i = sizeof(floppy_drive); break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:		info->i = 0; break;
-		case DEVINFO_INT_IMAGE_TYPE:				info->i = IO_FLOPPY; break;
-		case DEVINFO_INT_IMAGE_READABLE:			info->i = 1; break;
-		case DEVINFO_INT_IMAGE_WRITEABLE:			info->i = 1; break;
-		case DEVINFO_INT_IMAGE_CREATABLE:
-											{
-												int cnt = 0;
-												if ( device && device->static_config() )
-												{
-													const struct FloppyFormat *floppy_options = ((floppy_interface*)device->static_config())->formats;
-													int	i;
-													for ( i = 0; floppy_options[i].construct; i++ ) {
-														if(floppy_options[i].param_guidelines) cnt++;
-													}
-												}
-												info->i = (cnt>0) ? 1 : 0;
-											}
-											break;
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(floppy); break;
-		case DEVINFO_FCT_IMAGE_CREATE:				info->f = (genf *) DEVICE_IMAGE_CREATE_NAME(floppy); break;
-		case DEVINFO_FCT_IMAGE_LOAD:				info->f = (genf *) DEVICE_IMAGE_LOAD_NAME(floppy); break;
-		case DEVINFO_FCT_IMAGE_UNLOAD:				info->f = (genf *) DEVICE_IMAGE_UNLOAD_NAME(floppy); break;
-		case DEVINFO_FCT_IMAGE_SOFTLIST_LOAD:		info->f = (genf *) DEVICE_IMAGE_SOFTLIST_LOAD_NAME(floppy);	break;
-		case DEVINFO_FCT_IMAGE_DISPLAY_INFO:
-			if (device->type() == LEGACY_FLOPPY) {
-				if ( device && downcast<const legacy_image_device_base *>(device)->static_config() && ((floppy_interface*)(device)->static_config())->device_displayinfo) {
-					info->f = (genf *) ((floppy_interface*)(device)->static_config())->device_displayinfo;
-				} else {
-					info->f = NULL;
-				}
-			}
-			break;
+// device type definition
+const device_type LEGACY_FLOPPY = &device_creator<legacy_floppy_image_device>;
 
-		case DEVINFO_PTR_IMAGE_CREATE_OPTGUIDE:		info->p = (void *)floppy_option_guide; break;
-		case DEVINFO_INT_IMAGE_CREATE_OPTCOUNT:
-		{
-			const struct FloppyFormat *floppy_options = ((floppy_interface*)device->static_config())->formats;
-			int count;
-			for (count = 0; floppy_options[count].construct; count++)
-				;
-			info->i = count;
-			break;
+//-------------------------------------------------
+//  legacy_floppy_image_device - constructor
+//-------------------------------------------------
+
+legacy_floppy_image_device::legacy_floppy_image_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+    : device_t(mconfig, LEGACY_FLOPPY, "Floppy Disk", tag, owner, clock),
+	  device_image_interface(mconfig, *this),
+	  m_token(NULL)
+{
+	m_token = global_alloc_array_clear(UINT8, sizeof(floppy_drive));
+}
+
+legacy_floppy_image_device::legacy_floppy_image_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock)
+    : device_t(mconfig, type, name, tag, owner, clock),
+	  device_image_interface(mconfig, *this),
+	  m_token(NULL)
+{
+	m_token = global_alloc_array_clear(UINT8, sizeof(floppy_drive));
+}
+
+//-------------------------------------------------
+//  legacy_floppy_image_device - destructor
+//-------------------------------------------------
+
+legacy_floppy_image_device::~legacy_floppy_image_device()
+{
+	global_free(m_token);
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void legacy_floppy_image_device::device_start()
+{
+	floppy_drive *floppy = get_safe_token( this );
+	floppy->config = (const floppy_interface*)static_config();
+	floppy_drive_init(this);
+
+	floppy->drive_id = floppy_get_drive(this);
+	floppy->active = FALSE;
+
+	/* resolve callbacks */
+	floppy->out_idx_func.resolve(floppy->config->out_idx_func, *this);
+	floppy->in_mon_func.resolve(floppy->config->in_mon_func, *this);
+	floppy->out_tk00_func.resolve(floppy->config->out_tk00_func, *this);
+	floppy->out_wpt_func.resolve(floppy->config->out_wpt_func, *this);
+	floppy->out_rdy_func.resolve(floppy->config->out_rdy_func, *this);
+//  floppy->out_dskchg_func.resolve(floppy->config->out_dskchg_func, *this);
+
+	/* by default we are not write-protected */
+	floppy->wpt = ASSERT_LINE;
+	floppy->out_wpt_func(floppy->wpt);
+
+	/* not at track 0 */
+	floppy->tk00 = ASSERT_LINE;
+	floppy->out_tk00_func(floppy->tk00);
+
+	/* motor off */
+	floppy->mon = ASSERT_LINE;
+
+	/* disk changed */
+	floppy->dskchg = CLEAR_LINE;
+//  floppy->out_dskchg_func(floppy->dskchg);
+}
+
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void legacy_floppy_image_device::device_config_complete()
+{
+    image_device_format **formatptr;
+    image_device_format *format;
+    formatptr = &m_formatlist;
+    int cnt = 0;
+
+	m_extension_list[0] = '\0';
+	const struct FloppyFormat *floppy_options = ((floppy_interface*)static_config())->formats;
+	for (int i = 0; floppy_options[i].construct; i++)
+	{
+		// only add if creatable
+		if (floppy_options[i].param_guidelines) {
+			// allocate a new format
+			format = global_alloc_clear(image_device_format);
+
+			// populate it
+			format->m_index       = cnt;
+			format->m_name        = floppy_options[i].name;
+			format->m_description = floppy_options[i].description;
+			format->m_extensions  = floppy_options[i].extensions;
+			format->m_optspec     = floppy_options[i].param_guidelines;
+
+			// and append it to the list
+			*formatptr = format;
+			formatptr = &format->m_next;
+			cnt++;
 		}
+		image_specify_extension( m_extension_list, 256, floppy_options[i].extensions );
+	}
 
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "Floppy Disk"); break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Floppy Disk"); break;
-		case DEVINFO_STR_SOURCE_FILE:				strcpy(info->s, __FILE__); break;
-		case DEVINFO_STR_IMAGE_FILE_EXTENSIONS:
-			if ( device && device->static_config() )
-			{
-				const struct FloppyFormat *floppy_options = ((floppy_interface*)device->static_config())->formats;
-				int		i;
-				/* set up a temporary string */
-				info->s[0] = '\0';
-				for ( i = 0; floppy_options[i].construct; i++ )
-					image_specify_extension( info->s, 256, floppy_options[i].extensions );
-			}
-			break;
-		case DEVINFO_STR_IMAGE_INTERFACE:
-			if ( device && device->static_config() && ((floppy_interface *)device->static_config())->interface)
-			{
-				strcpy(info->s, ((floppy_interface *)device->static_config())->interface );
-			}
-			break;
-		default:
-			{
-				if ( device && device->static_config() )
-				{
-					const struct FloppyFormat *floppy_options = ((floppy_interface*)device->static_config())->formats;
-					if ((state >= DEVINFO_PTR_IMAGE_CREATE_OPTSPEC) && (state < DEVINFO_PTR_IMAGE_CREATE_OPTSPEC + DEVINFO_IMAGE_CREATE_OPTMAX)) {
-						info->p = (void *) floppy_options[state - DEVINFO_PTR_IMAGE_CREATE_OPTSPEC].param_guidelines;
-					} else if ((state >= DEVINFO_STR_IMAGE_CREATE_OPTNAME) && (state < DEVINFO_STR_IMAGE_CREATE_OPTNAME + DEVINFO_IMAGE_CREATE_OPTMAX)) {
-						safe_strcpy(info->s,floppy_options[state - DEVINFO_STR_IMAGE_CREATE_OPTNAME].name);
-					}
-					else if ((state >= DEVINFO_STR_IMAGE_CREATE_OPTDESC) && (state < DEVINFO_STR_IMAGE_CREATE_OPTDESC + DEVINFO_IMAGE_CREATE_OPTMAX)) {
-						safe_strcpy(info->s,floppy_options[state - DEVINFO_STR_IMAGE_CREATE_OPTDESC].description);
-					}
-					else if ((state >= DEVINFO_STR_IMAGE_CREATE_OPTEXTS) && (state < DEVINFO_STR_IMAGE_CREATE_OPTEXTS + DEVINFO_IMAGE_CREATE_OPTMAX)) {
-						safe_strcpy(info->s,floppy_options[state - DEVINFO_STR_IMAGE_CREATE_OPTEXTS].extensions);
-					}
-				}
-			}
+	// set brief and instance name
+	update_names();
+}
+
+bool legacy_floppy_image_device::call_create(int format_type, option_resolution *format_options)
+{
+	return internal_floppy_device_load(this, format_type, format_options);
+}
 
-			break;
+bool legacy_floppy_image_device::call_load()
+{
+	floppy_drive *flopimg;
+	int retVal = internal_floppy_device_load(this, -1, NULL);
+	flopimg = get_safe_token( this);
+	if (retVal==IMAGE_INIT_PASS) {
+		/* if we have one of our hacky unload procs, call it */
+		if (flopimg->load_proc)
+			flopimg->load_proc(*this);
 	}
+
+	/* push disk halfway into drive */
+	flopimg->wpt = CLEAR_LINE;
+	flopimg->out_wpt_func(flopimg->wpt);
+
+	/* set timer for disk load */
+	int next_wpt;
+
+	if (!is_readonly())
+		next_wpt = ASSERT_LINE;
+	else
+		next_wpt = CLEAR_LINE;
+
+	machine().scheduler().timer_set(attotime::from_msec(250), FUNC(set_wpt), next_wpt, flopimg);
+
+	return retVal;
+}
+
+void legacy_floppy_image_device::call_unload()
+{
+	floppy_drive *flopimg = get_safe_token( this);
+	if (flopimg->unload_proc)
+		flopimg->unload_proc(*this);
+
+	floppy_close(flopimg->floppy);
+	flopimg->floppy = NULL;
+
+	/* disk changed */
+	flopimg->dskchg = CLEAR_LINE;
+	//flopimg->out_dskchg_func(flopimg->dskchg);
+
+	/* pull disk halfway out of drive */
+	flopimg->wpt = CLEAR_LINE;
+	flopimg->out_wpt_func(flopimg->wpt);
+
+	/* set timer for disk eject */
+	machine().scheduler().timer_set(attotime::from_msec(250), FUNC(set_wpt), ASSERT_LINE, flopimg);
+}
+
+void legacy_floppy_image_device::call_display_info()
+{
+	if (((floppy_interface*)(this)->static_config())->device_displayinfo) {
+		((floppy_interface*)(this)->static_config())->device_displayinfo(*this);
+	}
+}
+
+bool legacy_floppy_image_device::is_creatable() const
+{
+	int cnt = 0;
+	if (static_config() )
+	{
+		const struct FloppyFormat *floppy_options = ((floppy_interface*)static_config())->formats;
+		int	i;
+		for ( i = 0; floppy_options[i].construct; i++ ) {
+			if(floppy_options[i].param_guidelines) cnt++;
+		}
+	}
+	return (cnt>0) ? 1 : 0;
 }
 
-DEFINE_LEGACY_IMAGE_DEVICE(LEGACY_FLOPPY, floppy);
+const char *legacy_floppy_image_device::image_interface() const
+{
+	return ((floppy_interface *)static_config())->interface;
+}
diff -Nru src-old/emu/imagedev/flopdrv.h src/emu/imagedev/flopdrv.h
--- src-old/emu/imagedev/flopdrv.h	2012-01-16 13:53:52.000000000 +0100
+++ src/emu/imagedev/flopdrv.h	2012-03-11 18:17:00.000000000 +0100
@@ -181,12 +181,45 @@
 // drive ready
 READ_LINE_DEVICE_HANDLER( floppy_ready_r );
 
-DECLARE_LEGACY_IMAGE_DEVICE(LEGACY_FLOPPY, floppy);
+class legacy_floppy_image_device :	public device_t,
+									public device_image_interface
+{
+public:
+	// construction/destruction
+	legacy_floppy_image_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	legacy_floppy_image_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
+	~legacy_floppy_image_device();
+
+	virtual bool call_load();
+	virtual bool call_softlist_load(char *swlist, char *swname, rom_entry *start_entry) {	return load_software(swlist, swname, start_entry); }
+	virtual bool call_create(int format_type, option_resolution *format_options);
+	virtual void call_unload();
+	virtual void call_display_info();
+
+	virtual iodevice_t image_type() const { return IO_FLOPPY; }
+
+	virtual bool is_readable()  const { return 1; }
+	virtual bool is_writeable() const { return 1; }
+	virtual bool is_creatable() const;
+	virtual bool must_be_loaded() const { return 0; }
+	virtual bool is_reset_on_load() const { return 0; }
+	virtual const char *image_interface() const;
+	virtual const char *file_extensions() const { return m_extension_list; }
+	virtual const option_guide *create_option_guide() const { return floppy_option_guide; }
+
+	// access to legacy token
+	void *token() const { assert(m_token != NULL); return m_token; }
+protected:
+	// device overrides
+	virtual void device_config_complete();
+	virtual void device_start();
+
+	void *m_token;
+	char			m_extension_list[256];
+};
 
-extern DEVICE_START( floppy );
-extern DEVICE_IMAGE_LOAD( floppy );
-extern DEVICE_IMAGE_CREATE( floppy );
-extern DEVICE_IMAGE_UNLOAD( floppy );
+// device type definition
+extern const device_type LEGACY_FLOPPY;
 
 /***************************************************************************
     DEVICE CONFIGURATION MACROS
diff -Nru src-old/emu/imagedev/floppy.h src/emu/imagedev/floppy.h
--- src-old/emu/imagedev/floppy.h	2012-02-23 15:19:37.000000000 +0100
+++ src/emu/imagedev/floppy.h	2012-02-29 16:08:25.000000000 +0100
@@ -46,7 +46,7 @@
 	virtual bool call_create(int format_type, option_resolution *format_options);
 	virtual void call_display_info() {}
 	virtual bool call_softlist_load(char *swlist, char *swname, rom_entry *start_entry) { return load_software(swlist, swname, start_entry); }
-
+	virtual const char *image_interface() const = 0;
 	virtual iodevice_t image_type() const { return IO_FLOPPY; }
 
 	virtual bool is_readable()  const { return true; }
@@ -166,6 +166,7 @@
 	virtual ~floppy_35_dd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
 	virtual void device_config_complete() { m_shortname = "floppy_35_dd"; }
+	virtual const char *image_interface() const { return "floppy_3_5"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -176,6 +177,7 @@
 	virtual ~floppy_35_dd_nosd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
 	virtual void device_config_complete() { m_shortname = "floppy_35_dd_nosd"; }
+	virtual const char *image_interface() const { return "floppy_3_5"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -186,6 +188,7 @@
 	virtual ~floppy_35_hd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
 	virtual void device_config_complete() { m_shortname = "floppy_35_hd"; }
+	virtual const char *image_interface() const { return "floppy_3_5"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -196,6 +199,7 @@
 	virtual ~floppy_35_ed();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
 	virtual void device_config_complete() { m_shortname = "floppy_35_ed"; }
+	virtual const char *image_interface() const { return "floppy_3_5"; }
 protected:
 	virtual void setup_characteristics();
 };
@@ -206,6 +210,7 @@
 	virtual ~floppy_525_dd();
 	virtual void handled_variants(UINT32 *variants, int &var_count) const;
 	virtual void device_config_complete() { m_shortname = "floppy_525_dd"; }
+	virtual const char *image_interface() const { return "floppy_5_25"; }
 protected:
 	virtual void setup_characteristics();
 };
diff -Nru src-old/emu/inpttype.h src/emu/inpttype.h
--- src-old/emu/inpttype.h	2011-10-27 06:37:46.000000000 +0200
+++ src/emu/inpttype.h	2012-03-05 21:11:39.000000000 +0100
@@ -48,7 +48,9 @@
 #define INPUT_PORT_ANALOG_TYPE(_player,_group,_type,_name,_seq,_decseq,_incseq) \
 	typelist.append(*global_alloc(input_type_entry(IPT_##_type, IPG_##_group, (_player == 0) ? _player : (_player) - 1, (_player == 0) ? #_type : ("P" #_player "_" #_type), _name, _seq, _decseq, _incseq)));
 
-
+#if defined(__GNUC__) && __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+__attribute__((optimize("O0")))
+#endif
 void construct_core_types(simple_list<input_type_entry> &typelist)
 {
 	INPUT_PORT_DIGITAL_TYPE( 1, PLAYER1, JOYSTICK_UP,         "P1 Up",                  input_seq(KEYCODE_UP, input_seq::or_code, JOYCODE_Y_UP_SWITCH_INDEXED(0)) )
diff -Nru src-old/emu/machine/amigafdc.c src/emu/machine/amigafdc.c
--- src-old/emu/machine/amigafdc.c	2012-01-25 10:52:18.000000000 +0100
+++ src/emu/machine/amigafdc.c	2012-02-29 10:13:22.000000000 +0100
@@ -195,7 +195,7 @@
 			}
 
 			if(cur_live.bit_counter > 8)
-				abort();
+				fatalerror("amiga_fdc::live_run - cur_live.bit_counter > 8");
 
 			if(cur_live.bit_counter == 8) {
 				live_delay(RUNNING_SYNCPOINT);
diff -Nru src-old/emu/machine/idectrl.c src/emu/machine/idectrl.c
--- src-old/emu/machine/idectrl.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/machine/idectrl.c	2012-02-29 10:13:22.000000000 +0100
@@ -2143,6 +2143,8 @@
 				ide_build_features();
 		}
 	}
+	else
+		m_disk = NULL;
 
 }
 
diff -Nru src-old/emu/machine/ins8250.c src/emu/machine/ins8250.c
--- src-old/emu/machine/ins8250.c	2012-02-26 15:31:24.000000000 +0100
+++ src/emu/machine/ins8250.c	2012-03-11 18:17:00.000000000 +0100
@@ -19,6 +19,11 @@
 the BIOS dependent on the flaws being present, so subsequent parts like the
 8250A, 16450 or 16550 could not be used in the original IBM PC or IBM PC/XT.
 
+The original 8250 pulses the interrupt line if a higher priority interrupt is
+cleared but a lower priority one is still active.  It also clears the tsre bit
+for a moment before loading the tsr from the thr.  These may be the bugs the
+PC and XT depend on as the 8250A and up fix them.
+
 INS8250-B
 This is the slower speed of the INS8250 made from NMOS technology. It contains
 the same problems as the original INS8250.
@@ -45,6 +50,10 @@
 Same as NS16450 with a 16-byte send and receive buffer but the buffer design
 was flawed and could not be reliably be used.
 
+The 16550 sometimes will send more then one character over the bus from the fifo
+when the rbr is read making the rx fifo useless.  It's unlikely anything depends
+on this behavior.
+
 NS16550A
 Same as NS16550 with the buffer flaws corrected. The 16550A and its successors
 have become the most popular UART design in the PC industry, mainly due to
@@ -108,6 +117,7 @@
 #define COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY 0x0002
 #define COM_INT_PENDING_RECEIVER_LINE_STATUS 0x0004
 #define COM_INT_PENDING_MODEM_STATUS_REGISTER 0x0008
+#define COM_INT_PENDING_CHAR_TIMEOUT 0x0011
 
 /* ints will continue to be set for as long as there are ints pending */
 void ins8250_uart_device::update_interrupt()
@@ -121,13 +131,17 @@
 
 		/* set int */
 		state = 1;
-		m_regs.iir &= ~(0x04|0x02);
+		m_regs.iir &= ~(0x08|0x04|0x02);
 
 		/* highest to lowest */
 		if (m_regs.ier & m_int_pending & COM_INT_PENDING_RECEIVER_LINE_STATUS)
 			m_regs.iir |=0x04|0x02;
 		else if (m_regs.ier & m_int_pending & COM_INT_PENDING_RECEIVED_DATA_AVAILABLE)
+		{
 			m_regs.iir |=0x04;
+			if ((m_int_pending & COM_INT_PENDING_CHAR_TIMEOUT) == 0x11)
+				m_regs.iir |= 0x08;
+		}
 		else if (m_regs.ier & m_int_pending & COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY)
 			m_regs.iir |=0x02;
 
@@ -142,7 +156,7 @@
 		/* no ints pending */
 		m_regs.iir |= 0x01;
 		/* priority level */
-		m_regs.iir &= ~(0x04|0x02);
+		m_regs.iir &= ~(0x08|0x04|0x02);
 	}
 
 	/* set or clear the int */
@@ -202,8 +216,13 @@
 					trigger_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
 				}
 				else
+				{
+					if((m_device_type >= TYPE_NS16550) && (m_regs.fcr & 1))
+						push_tx(data);
+					clear_int(COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
 					if(m_regs.lsr & 0x40)
 						tra_complete();
+				}
 			}
 			break;
 		case 1:
@@ -217,9 +236,10 @@
 				m_regs.ier = data;
 				update_interrupt();
 			}
-            break;
+			break;
 		case 2:
-            break;
+			set_fcr(data);
+			break;
 		case 3:
 			m_regs.lcr = data;
 			switch ((m_regs.lcr>>3) & 7)
@@ -264,9 +284,9 @@
 				else
 				{
 					m_out_dtr_func(m_regs.mcr & 1);
-					m_out_rts_func((m_regs.mcr & 2) && 1);
-					m_out_out1_func((m_regs.mcr & 4) && 1);
-					m_out_out2_func((m_regs.mcr & 8) && 1);
+					m_out_rts_func(m_regs.mcr & 2);
+					m_out_out1_func(m_regs.mcr & 4);
+					m_out_out2_func(m_regs.mcr & 8);
 				}
 			}
             break;
@@ -313,11 +333,15 @@
 				data = (m_regs.dl & 0xff);
 			else
 			{
+				if((m_device_type >= TYPE_NS16550) && (m_regs.fcr & 1) && !(m_regs.mcr & 0x10))
+					m_regs.rbr = pop_rx();
+				else
+				{
+					clear_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
+					if( m_regs.lsr & 0x01 )
+						m_regs.lsr &= ~0x01;
+				}
 				data = m_regs.rbr;
-				if( m_regs.lsr & 0x01 )
-					m_regs.lsr &= ~0x01;		/* clear data ready status */
-
-				clear_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
 			}
 			break;
 		case 1:
@@ -357,11 +381,54 @@
 			break;
 		case 7:
 			data = m_regs.scr;
-            break;
+			break;
 	}
     return data;
 }
 
+void ns16550_device::rcv_complete()
+{
+	if(!(m_regs.fcr & 1))
+		return ins8250_uart_device::rcv_complete();
+
+	receive_register_extract();
+
+	if(m_rnum == 16)
+	{
+		m_regs.lsr |= 0x02; //overrun
+		trigger_int(COM_INT_PENDING_RECEIVER_LINE_STATUS);
+		return;
+	}
+
+	m_regs.lsr |= 0x01;
+	m_rfifo[m_rhead] = get_received_char();
+	++m_rhead &= 0x0f;
+	m_rnum++;
+	if(m_rnum >= m_rintlvl)
+		trigger_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
+	set_timer();
+}
+
+void ns16550_device::tra_complete()
+{
+	if(!(m_regs.fcr & 1))
+		return ins8250_uart_device::tra_complete();
+
+	if(m_ttail != m_thead)
+	{
+		transmit_register_setup(m_tfifo[m_ttail]);
+		++m_ttail &= 0x0f;
+		m_regs.lsr &= ~0x40;
+		if(m_ttail == m_thead)
+		{
+			m_regs.lsr |= 0x20;
+			trigger_int(COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
+		}
+	}
+	else
+		m_regs.lsr |= 0x40;
+}
+
 void ins8250_uart_device::rcv_complete()
 {
 	if(m_regs.lsr & 0x01)
@@ -409,22 +476,22 @@
 
 WRITE_LINE_MEMBER(ins8250_uart_device::dcd_w)
 {
-	update_msr(3, (state&&1));
+	update_msr(3, (state&1));
 }
 
 WRITE_LINE_MEMBER(ins8250_uart_device::dsr_w)
 {
-	update_msr(1, (state&&1));
+	update_msr(1, (state&1));
 }
 
 WRITE_LINE_MEMBER(ins8250_uart_device::ri_w)
 {
-	update_msr(2, (state&&1));
+	update_msr(2, (state&1));
 }
 
 WRITE_LINE_MEMBER(ins8250_uart_device::cts_w)
 {
-	update_msr(0, (state&&1));
+	update_msr(0, (state&1));
 }
 
 void ins8250_uart_device::device_start()
@@ -474,3 +541,80 @@
 		memset(&m_out_out2_cb, 0, sizeof(m_out_out2_cb));
 	}
 }
+
+void ns16550_device::device_reset()
+{
+	memset(&m_rfifo, '\0', sizeof(m_rfifo));
+	memset(&m_tfifo, '\0', sizeof(m_tfifo));
+	m_rhead = m_rtail = m_rnum = 0;
+	m_thead = m_ttail = 0;
+	m_timeout->adjust(attotime::never);
+	ins8250_uart_device::device_reset();
+}
+
+void ns16550_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	trigger_int(COM_INT_PENDING_CHAR_TIMEOUT);
+	m_timeout->adjust(attotime::never);
+}
+
+void ns16550_device::push_tx(UINT8 data)
+{
+	m_tfifo[m_thead] = data;
+	++m_thead &= 0x0f;
+}
+
+UINT8 ns16550_device::pop_rx()
+{
+	UINT8 data = m_rfifo[m_rtail];
+	clear_int(COM_INT_PENDING_CHAR_TIMEOUT & ~1); // don't clear bit 1 yet
+
+	if(m_rnum)
+	{
+		++m_rtail &= 0x0f;
+		m_rnum--;
+	}
+	else
+		data = 0;
+
+	if(m_rnum < m_rintlvl)
+		clear_int(COM_INT_PENDING_RECEIVED_DATA_AVAILABLE);
+
+	if(m_rnum)
+		set_timer();
+	else
+	{
+		m_timeout->adjust(attotime::never);
+		m_regs.lsr &= ~1;
+	}
+
+	return data;
+}
+
+void ns16550_device::set_fcr(UINT8 data)
+{
+	const int bytes_per_int[] = {1, 4, 8, 14};
+	if(!(data & 1))
+	{
+		m_regs.fcr = 0;
+		m_regs.iir &= ~0xc8;
+		return;
+	}
+	if(!(m_regs.fcr & 1) && (data & 1))
+		data |= 0x06;
+	if(data & 2)
+	{
+		memset(&m_rfifo, '\0', sizeof(m_rfifo));
+		m_rhead = m_rtail = m_rnum = 0;
+	}
+	if(data & 4)
+	{
+		memset(&m_tfifo, '\0', sizeof(m_tfifo));
+		m_thead = m_ttail = 0;
+	}
+	m_rintlvl = bytes_per_int[(data>>6)&3];
+	m_regs.iir |= 0xc0;
+	m_regs.fcr = data & ~0xc9;
+	m_regs.lsr |= 0x20;
+	trigger_int(COM_INT_PENDING_TRANSMITTER_HOLDING_REGISTER_EMPTY);
+}
diff -Nru src-old/emu/machine/ins8250.h src/emu/machine/ins8250.h
--- src-old/emu/machine/ins8250.h	2012-02-20 09:05:19.000000000 +0100
+++ src/emu/machine/ins8250.h	2012-02-28 09:46:44.000000000 +0100
@@ -45,6 +45,13 @@
 	virtual void tra_complete();
 	virtual void tra_callback();
 
+	virtual void set_fcr(UINT8 data) {}
+	virtual void push_tx(UINT8 data) {}
+	virtual UINT8 pop_rx() { return 0; }
+
+	void trigger_int(int flag);
+	void clear_int(int flag);
+
 	enum {
 			TYPE_INS8250 = 0,
 			TYPE_INS8250A,
@@ -53,20 +60,21 @@
 			TYPE_NS16550A,
 			TYPE_PC16550D,
 	};
-	int	m_device_type;
-private:
+	int m_device_type;
 	struct {
 		UINT8 thr;  /* 0 -W transmitter holding register */
 		UINT8 rbr;  /* 0 R- receiver buffer register */
 		UINT8 ier;  /* 1 RW interrupt enable register */
 		UINT16 dl;  /* 0/1 RW divisor latch (if DLAB = 1) */
 		UINT8 iir;  /* 2 R- interrupt identification register */
+		UINT8 fcr;
 		UINT8 lcr;  /* 3 RW line control register (bit 7: DLAB) */
 		UINT8 mcr;  /* 4 RW modem control register */
 		UINT8 lsr;  /* 5 R- line status register */
 		UINT8 msr;  /* 6 R- modem status register */
 		UINT8 scr;  /* 7 RW scratch register */
 	} m_regs;
+private:
 	UINT8 m_int_pending;
 
 	devcb_resolved_write_line	m_out_tx_func;
@@ -78,8 +86,6 @@
 
 	void update_interrupt();
 	void update_clock();
-	void trigger_int(int flag);
-	void clear_int(int flag);
 	void update_msr(int bit, UINT8 state);
 };
 
@@ -99,6 +105,23 @@
 {
 public:
 	ns16550_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+protected:
+	virtual void device_start() { m_timeout = timer_alloc(); ins8250_uart_device::device_start(); }
+	virtual void device_reset();
+	virtual void rcv_complete();
+	virtual void tra_complete();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+	virtual void set_fcr(UINT8 data);
+	virtual void push_tx(UINT8 data);
+	virtual UINT8 pop_rx();
+private:
+	void set_timer() { m_timeout->adjust(attotime::from_hz((clock()*4*8)/(m_regs.dl*16))); }
+	int m_rintlvl;
+	UINT8 m_rfifo[16];
+	UINT8 m_tfifo[16];
+	int m_rhead, m_rtail, m_rnum;
+	int m_thead, m_ttail;
+	emu_timer *m_timeout;
 };
 
 extern const device_type INS8250;
diff -Nru src-old/emu/machine/ncr539x.h src/emu/machine/ncr539x.h
--- src-old/emu/machine/ncr539x.h	2011-11-13 21:35:34.000000000 +0100
+++ src/emu/machine/ncr539x.h	2012-03-10 20:09:58.000000000 +0100
@@ -15,10 +15,10 @@
     devcb_write_line m_out_drq_cb;          /* DRQ line */
 };
 
-// 539x registers
-enum
-{
-};
+//// 539x registers
+//enum
+//{
+//};
 
 // device stuff
 #define MCFG_NCR539X_ADD(_tag, _clock, _intrf) \
diff -Nru src-old/emu/machine/nscsi_bus.c src/emu/machine/nscsi_bus.c
--- src-old/emu/machine/nscsi_bus.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/machine/nscsi_bus.c	2012-03-05 07:59:43.000000000 +0100
@@ -248,7 +248,7 @@
 
 	case RECV_BYTE_T_WAIT_ACK_1 << SUB_SHIFT:
 		if(ctrl & S_ACK) {
-			received(scsi_bus->data_r());
+			scsi_put_data(data_buffer_id, data_buffer_pos++, scsi_bus->data_r());
 			scsi_state = (scsi_state & STATE_MASK) | (RECV_BYTE_T_WAIT_ACK_0 << SUB_SHIFT);
 			scsi_bus->ctrl_w(scsi_refid, 0, S_REQ);
 		}
@@ -282,6 +282,8 @@
 		control *ctl = buf_control_pop();
 		switch(ctl->action) {
 		case BC_MSG_OR_COMMAND:
+			data_buffer_id = SBUF_MAIN;
+			data_buffer_pos = 0;
 			if(ctrl & S_ATN) {
 				scsi_state = TARGET_WAIT_MSG_BYTE;
 				scsi_bus->ctrl_w(scsi_refid, S_PHASE_MSG_OUT, S_PHASE_MASK);
@@ -289,7 +291,6 @@
 				scsi_state = TARGET_WAIT_CMD_BYTE;
 				scsi_bus->ctrl_w(scsi_refid, S_PHASE_COMMAND, S_PHASE_MASK);
 			}
-			scsi_cmdsize = 0;
 			target_recv_byte();
 			break;
 
@@ -307,6 +308,15 @@
 			target_send_buffer_byte();
 			break;
 
+		case BC_DATA_OUT:
+			scsi_bus->ctrl_w(scsi_refid, S_PHASE_DATA_OUT, S_PHASE_MASK);
+			data_buffer_id = ctl->param1;
+			data_buffer_size = ctl->param2;
+			data_buffer_pos = 0;
+			scsi_state = TARGET_WAIT_DATA_OUT_BYTE;
+			target_recv_byte();
+			break;
+
 		case BC_MESSAGE_1:
 			scsi_bus->ctrl_w(scsi_refid, S_PHASE_MSG_IN, S_PHASE_MASK);
 			target_send_byte(ctl->param1);
@@ -328,12 +338,20 @@
 		target_send_buffer_byte();
 		break;
 
+	case TARGET_WAIT_DATA_OUT_BYTE:
+		if(data_buffer_pos == data_buffer_size-1)
+			scsi_state = TARGET_NEXT_CONTROL;
+		target_recv_byte();
+		break;
+
 	case TARGET_WAIT_MSG_BYTE:
 		if(ctrl & S_SEL)
 			return;
 		if(!(ctrl & S_ATN)) {
+			scsi_cmdsize = data_buffer_pos;
 			scsi_message();
-			scsi_cmdsize = 0;
+			data_buffer_id = SBUF_MAIN;
+			data_buffer_pos = 0;
 			scsi_state = TARGET_WAIT_CMD_BYTE;
 			scsi_bus->ctrl_w(scsi_refid, S_PHASE_COMMAND, S_PHASE_MASK);
 		}
@@ -350,6 +368,7 @@
 		}
 
 		if(command_done()) {
+			scsi_cmdsize = data_buffer_pos;
 			scsi_bus->ctrl_wait(scsi_refid, 0, S_ACK);
 			scsi_command();
 			scsi_state = TARGET_NEXT_CONTROL;
@@ -383,11 +402,6 @@
 	step(false);
 }
 
-void nscsi_full_device::received(UINT8 val)
-{
-	scsi_cmdbuf[scsi_cmdsize++] = val;
-}
-
 UINT8 nscsi_full_device::scsi_get_data(int id, int pos)
 {
 	switch(id) {
@@ -396,7 +410,22 @@
 	case SBUF_SENSE:
 		return scsi_sense_buffer[pos];
 	default:
-		abort();
+		fatalerror("nscsi_full_device::scsi_get_data - unknown id");
+		return 0; // shut up compiler
+	}
+}
+
+void nscsi_full_device::scsi_put_data(int id, int pos, UINT8 data)
+{
+	switch(id) {
+	case SBUF_MAIN:
+		scsi_cmdbuf[pos] = data;
+		break;
+	case SBUF_SENSE:
+		scsi_sense_buffer[pos] = data;
+		break;
+	default:
+		fatalerror("nscsi_full_device::scsi_put_data - unknown id");
 	}
 }
 
@@ -407,16 +436,16 @@
 
 bool nscsi_full_device::command_done()
 {
-	if(!scsi_cmdsize)
+	if(!data_buffer_pos)
 		return false;
 	UINT8 h = scsi_cmdbuf[0];
 	switch(h >> 5) {
-	case 0: return scsi_cmdsize == 6;
-	case 1: return scsi_cmdsize == 10;
-	case 2: return scsi_cmdsize == 10;
+	case 0: return data_buffer_pos == 6;
+	case 1: return data_buffer_pos == 10;
+	case 2: return data_buffer_pos == 10;
 	case 3: return true;
 	case 4: return true;
-	case 5: return scsi_cmdsize == 12;
+	case 5: return data_buffer_pos == 12;
 	case 6: return true;
 	case 7: return true;
 	}
diff -Nru src-old/emu/machine/nscsi_bus.h src/emu/machine/nscsi_bus.h
--- src-old/emu/machine/nscsi_bus.h	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/machine/nscsi_bus.h	2012-03-05 07:59:43.000000000 +0100
@@ -218,6 +218,7 @@
 	void bad_lun();
 
 	virtual UINT8 scsi_get_data(int buf, int offset);
+	virtual void scsi_put_data(int buf, int offset, UINT8 data);
 
 	// Default delays:
 
@@ -294,6 +295,7 @@
 		TARGET_WAIT_MSG_BYTE,
 		TARGET_WAIT_CMD_BYTE,
 		TARGET_WAIT_DATA_IN_BYTE,
+		TARGET_WAIT_DATA_OUT_BYTE,
 	};
 
 	enum {
@@ -340,7 +342,6 @@
 	void step(bool timeout);
 	void target_recv_byte();
 	void target_send_byte(UINT8 val);
-	void received(UINT8 val);
 	void target_send_buffer_byte();
 	bool command_done();
 };
diff -Nru src-old/emu/machine/nscsi_hd.c src/emu/machine/nscsi_hd.c
--- src-old/emu/machine/nscsi_hd.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/machine/nscsi_hd.c	2012-03-11 18:17:00.000000000 +0100
@@ -25,6 +25,7 @@
 		const hard_disk_info *hdinfo = hard_disk_get_info(harddisk);
 		bytes_per_sector = hdinfo->sectorbytes;
 	}
+	cur_lba = -1;
 }
 
 harddisk_interface nscsi_harddisk_device::hd_intf = { 0, 0 };
@@ -50,7 +51,23 @@
 			memset(block, 0, sizeof(block));
 		}
 	}
-	return block[pos & (bytes_per_sector - 1)];
+	return block[pos % bytes_per_sector];
+}
+
+void nscsi_harddisk_device::scsi_put_data(int id, int pos, UINT8 data)
+{
+	if(id != 2) {
+		nscsi_full_device::scsi_put_data(id, pos, data);
+		return;
+	}
+
+	int offset = pos % bytes_per_sector;
+	block[offset] = data;
+	int clba = lba + pos / bytes_per_sector;
+	if(offset == bytes_per_sector-1) {
+		if(!hard_disk_write(harddisk, clba, block))
+			logerror("%s: HD WRITE ERROR !\n", tag());
+	}
 }
 
 void nscsi_harddisk_device::scsi_command()
@@ -76,7 +93,7 @@
 
 	case SC_INQUIRY: {
 		int lun = get_lun(scsi_cmdbuf[1] >> 5);
-		logerror("%s: INQUIRY lun=%d EVPD=%d page=%d alloc=%02x link=%02x\n",
+		logerror("%s: command INQUIRY lun=%d EVPD=%d page=%d alloc=%02x link=%02x\n",
 				 tag(),
 				 lun, scsi_cmdbuf[1] & 1, scsi_cmdbuf[2], scsi_cmdbuf[4], scsi_cmdbuf[5]);
 		if(lun) {
@@ -106,6 +123,115 @@
 		break;
 	}
 
+	case SC_MODE_SENSE_6: {
+		int lun = get_lun(scsi_cmdbuf[1] >> 5);
+		logerror("%s: command MODE SENSE 6 lun=%d page=%02x alloc=%02x link=%02x\n",
+				 tag(),
+				 lun, scsi_cmdbuf[2] & 0x3f, scsi_cmdbuf[4], scsi_cmdbuf[5]);
+		if(lun) {
+			bad_lun();
+			return;
+		}
+
+		int page = scsi_cmdbuf[2] & 0x3f;
+		int size = scsi_cmdbuf[4];
+		int pos = 1;
+		scsi_cmdbuf[pos++] = 0x00; // medium type
+		scsi_cmdbuf[pos++] = 0x00; // WP, cache
+
+		hard_disk_info *info = hard_disk_get_info(harddisk);
+		UINT32 dsize = info->cylinders * info->heads * info->sectors - 1;
+		scsi_cmdbuf[pos++] = 0x08; // Block descriptor length
+		scsi_cmdbuf[pos++] = 0x00;
+		scsi_cmdbuf[pos++] = (dsize>>16) & 0xff;
+		scsi_cmdbuf[pos++] = (dsize>>8) & 0xff;
+		scsi_cmdbuf[pos++] = (dsize & 0xff);
+		scsi_cmdbuf[pos++] = 0x00;
+		scsi_cmdbuf[pos++] = (info->sectorbytes>>16)&0xff;
+		scsi_cmdbuf[pos++] = (info->sectorbytes>>8)&0xff;
+		scsi_cmdbuf[pos++] = (info->sectorbytes & 0xff);
+
+		int pmax = page == 0x3f ? 0x3e : page;
+		int pmin = page == 0x3f ? 0x00 : page;
+		for(int page=pmax; page >= pmin; page--) {
+			switch(page) {
+			case 0x00: // Unit attention parameters page (weird)
+				scsi_cmdbuf[pos++] = 0x80; // PS, page id
+				scsi_cmdbuf[pos++] = 0x02; // Page length
+				scsi_cmdbuf[pos++] = 0x00; // Meh
+				scsi_cmdbuf[pos++] = 0x00; // Double meh
+				break;
+
+			case 0x03:  { // Format parameters page
+				scsi_cmdbuf[pos++] = 0x83; // PS, page id
+				scsi_cmdbuf[pos++] = 0x16; // Page length
+				scsi_cmdbuf[pos++] = (info->cylinders * info->heads) >> 8; // Track/zone
+				scsi_cmdbuf[pos++] = info->cylinders * info->heads;        // Track/zone
+				scsi_cmdbuf[pos++] = 0x00; // Alt sect/zone
+				scsi_cmdbuf[pos++] = 0x00; // Alt sect/zone
+				scsi_cmdbuf[pos++] = 0x00; // Alt track/zone
+				scsi_cmdbuf[pos++] = 0x00; // Alt track/zone
+				scsi_cmdbuf[pos++] = 0x00; // Alt track/volume
+				scsi_cmdbuf[pos++] = 0x00; // Alt track/volume
+				scsi_cmdbuf[pos++] = info->sectors >> 8; // Sectors/track
+				scsi_cmdbuf[pos++] = info->sectors;      // Sectors/track
+				scsi_cmdbuf[pos++] = info->sectorbytes >> 8; // Bytes/sector
+				scsi_cmdbuf[pos++] = info->sectorbytes;      // Bytes/sector
+				scsi_cmdbuf[pos++] = 0x00; // Interleave
+				scsi_cmdbuf[pos++] = 0x00; // Interleave
+				scsi_cmdbuf[pos++] = 0x00; // Track skew
+				scsi_cmdbuf[pos++] = 0x00; // Track skew
+				scsi_cmdbuf[pos++] = 0x00; // Cylinder skew
+				scsi_cmdbuf[pos++] = 0x00; // Cylinder skew
+				scsi_cmdbuf[pos++] = 0x00; // Sectoring type
+				scsi_cmdbuf[pos++] = 0x00; // Reserved
+				scsi_cmdbuf[pos++] = 0x00; // Reserved
+				scsi_cmdbuf[pos++] = 0x00; // Reserved
+				break;
+			}
+
+			case 0x04: { // Rigid drive geometry page
+				scsi_cmdbuf[pos++] = 0x84; // PS, page id
+				scsi_cmdbuf[pos++] = 0x16; // Page length
+				scsi_cmdbuf[pos++] = info->cylinders >> 16; // Cylinders
+				scsi_cmdbuf[pos++] = info->cylinders >> 8;  // Cylinders
+				scsi_cmdbuf[pos++] = info->cylinders;       // Cylinders
+				scsi_cmdbuf[pos++] = info->heads;           // Heads
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - write precomp
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - write precomp
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - write precomp
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - reduced write current
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - reduced write current
+				scsi_cmdbuf[pos++] = 0x00;                  // Starting cylinder - reduced write current
+				scsi_cmdbuf[pos++] = 0x00;                  // Drive step rate
+				scsi_cmdbuf[pos++] = 0x00;                  // Drive step rate
+				scsi_cmdbuf[pos++] = 0x00;                  // Landing zone cylinder
+				scsi_cmdbuf[pos++] = 0x00;                  // Landing zone cylinder
+				scsi_cmdbuf[pos++] = 0x00;                  // Landing zone cylinder
+				scsi_cmdbuf[pos++] = 0x00;                  // RPL
+				scsi_cmdbuf[pos++] = 0x00;                  // Rotational offset
+				scsi_cmdbuf[pos++] = 0x00;                  // Reserved
+				scsi_cmdbuf[pos++] = UINT8(10000 >> 8);     // Medium rotation rate
+				scsi_cmdbuf[pos++] = UINT8(10000);          // Medium rotation rate
+				scsi_cmdbuf[pos++] = 0x00;                  // Reserved
+				scsi_cmdbuf[pos++] = 0x00;                  // Reserved
+				break;
+			}
+
+			default:
+				logerror("%s: mode sense page %02x unhandled\n", tag(), page);
+				break;
+			}
+		}
+		scsi_cmdbuf[0] = pos;
+		if(pos > size)
+			pos = size;
+
+		scsi_data_in(0, pos);
+		scsi_status_complete(SS_GOOD);
+		break;
+	}
+
 	case SC_START_STOP_UNIT:
 		logerror("%s: command START STOP UNIT\n", tag());
 		scsi_status_complete(SS_GOOD);
@@ -114,19 +240,13 @@
 	case SC_READ_CAPACITY: {
 		logerror("%s: command READ CAPACITY\n", tag());
 
-		hard_disk_info *info;
-		UINT32 temp;
+		hard_disk_info *info = hard_disk_get_info(harddisk);
+		UINT32 size = info->cylinders * info->heads * info->sectors - 1;
 
-		info = hard_disk_get_info(harddisk);
-
-		// get # of sectors
-		temp = info->cylinders * info->heads * info->sectors;
-		temp--;
-
-		scsi_cmdbuf[0] = (temp>>24) & 0xff;
-		scsi_cmdbuf[1] = (temp>>16) & 0xff;
-		scsi_cmdbuf[2] = (temp>>8) & 0xff;
-		scsi_cmdbuf[3] = (temp & 0xff);
+		scsi_cmdbuf[0] = (size>>24) & 0xff;
+		scsi_cmdbuf[1] = (size>>16) & 0xff;
+		scsi_cmdbuf[2] = (size>>8) & 0xff;
+		scsi_cmdbuf[3] = (size & 0xff);
 		scsi_cmdbuf[4] = (info->sectorbytes>>24)&0xff;
 		scsi_cmdbuf[5] = (info->sectorbytes>>16)&0xff;
 		scsi_cmdbuf[6] = (info->sectorbytes>>8)&0xff;
@@ -148,6 +268,17 @@
 		scsi_status_complete(SS_GOOD);
 		break;
 
+	case SC_WRITE_EXTENDED:
+		lba = (scsi_cmdbuf[2]<<24) | (scsi_cmdbuf[3]<<16) | (scsi_cmdbuf[4]<<8) | scsi_cmdbuf[5];
+		blocks = (scsi_cmdbuf[7] << 8) | scsi_cmdbuf[8];
+
+		logerror("%s: command WRITE EXTENDED start=%08x blocks=%04x\n",
+				 tag(), lba, blocks);
+
+		scsi_data_out(2, blocks*bytes_per_sector);
+		scsi_status_complete(SS_GOOD);
+		break;
+
 	default:
 		nscsi_full_device::scsi_command();
 		break;
diff -Nru src-old/emu/machine/nscsi_hd.h src/emu/machine/nscsi_hd.h
--- src-old/emu/machine/nscsi_hd.h	2012-02-23 15:19:37.000000000 +0100
+++ src/emu/machine/nscsi_hd.h	2012-03-05 07:59:43.000000000 +0100
@@ -22,6 +22,7 @@
 
 	virtual void scsi_command();
 	virtual UINT8 scsi_get_data(int id, int pos);
+	virtual void scsi_put_data(int buf, int offset, UINT8 data);
 
 private:
 	UINT8 block[512];
diff -Nru src-old/emu/machine/pic8259.c src/emu/machine/pic8259.c
--- src-old/emu/machine/pic8259.c	2012-02-14 11:57:29.000000000 +0100
+++ src/emu/machine/pic8259.c	2012-03-09 22:54:29.000000000 +0100
@@ -277,6 +277,7 @@
 				pic8259->icw4_needed		= (data & 0x01) ? 1 : 0;
 				pic8259->vector_addr_low	= (data & 0xe0);
 				pic8259->state			= STATE_ICW2;
+				pic8259->out_int_func(0);
 			}
 			else if (pic8259->state == STATE_READY)
 			{
@@ -308,9 +309,6 @@
 								if (pic8259->isr & mask)
 								{
 									pic8259->isr &= ~mask;
-									if (pic8259->level_trig_mode)
-										pic8259->irr = pic8259->irq_lines;
-									pic8259->irr &= ~mask;
 									break;
 								}
 							}
@@ -344,9 +342,6 @@
 							if( pic8259->isr & mask )
 							{
 								pic8259->isr &= ~mask;
-								if (pic8259->level_trig_mode)
-									pic8259->irr = pic8259->irq_lines;
-								pic8259->irr &= ~mask;
 								pic8259->prio = (pic8259->prio + 1) & 7;
 							}
 							break;
diff -Nru src-old/emu/machine/scsicd.c src/emu/machine/scsicd.c
--- src-old/emu/machine/scsicd.c	2011-06-15 14:10:37.000000000 +0200
+++ src/emu/machine/scsicd.c	2012-03-09 16:31:23.000000000 +0100
@@ -607,6 +607,26 @@
 					// indicate max volume
 					data[9] = data[11] = data[13] = data[15] = 0xff;
 					break;
+				case 0x2a:	// Page capabilities
+					data[0] = 0x2a;
+					data[1] = 0x14;	// page length
+					data[2] = 0x00; data[3] = 0x00; // CD-R only
+					data[4] = 0x01; // can play audio
+					data[5] = 0;
+					data[6] = 0;
+					data[7] = 0;
+					data[8] = 0x02; data[9] = 0xc0; // 4x speed
+					data[10] = 0;
+					data[11] = 2; // two volumen levels
+					data[12] = 0x00; data[13] = 0x00; // buffer
+					data[14] = 0x02; data[15] = 0xc0; // 4x read speed
+					data[16] = 0;
+					data[17] = 0;
+					data[18] = 0;
+					data[19] = 0;
+					data[20] = 0;
+					data[21] = 0;
+					break;
 
 				default:
 					logerror("SCSICD: MODE SENSE unknown page %x\n", command[2] & 0x3f);
diff -Nru src-old/emu/machine.c src/emu/machine.c
--- src-old/emu/machine.c	2012-02-26 15:31:24.000000000 +0100
+++ src/emu/machine.c	2012-03-08 10:54:00.000000000 +0100
@@ -253,6 +253,7 @@
 	m_render = auto_alloc(*this, render_manager(*this));
 	generic_machine_init(*this);
 	generic_sound_init(*this);
+	generic_video_init(*this);
 
 	// allocate a soft_reset timer
 	m_soft_reset_timer = m_scheduler.timer_alloc(timer_expired_delegate(FUNC(running_machine::soft_reset), this));
@@ -286,9 +287,6 @@
 	memory_init(*this);
 	watchdog_init(*this);
 
-	// must happen after memory_init because this relies on generic.spriteram
-	generic_video_init(*this);
-
 	// allocate the gfx elements prior to device initialization
 	gfx_init(*this);
 
diff -Nru src-old/emu/machine.h src/emu/machine.h
--- src-old/emu/machine.h	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/machine.h	2012-03-08 10:54:00.000000000 +0100
@@ -263,12 +263,6 @@
 // holds generic pointers that are commonly used
 struct generic_pointers
 {
-	generic_ptr				spriteram;			// spriteram
-	UINT32					spriteram_size;
-	generic_ptr				spriteram2;			// secondary spriteram
-	UINT32					spriteram2_size;
-	generic_ptr				buffered_spriteram;	// buffered spriteram
-	generic_ptr				buffered_spriteram2;// secondary buffered spriteram
 	generic_ptr				paletteram;			// palette RAM
 	generic_ptr				paletteram2;		// secondary palette RAM
 };
diff -Nru src-old/emu/mconfig.h src/emu/mconfig.h
--- src-old/emu/mconfig.h	2012-02-11 17:15:39.000000000 +0100
+++ src/emu/mconfig.h	2012-03-08 08:39:27.000000000 +0100
@@ -72,9 +72,6 @@
 // automatically extend the palette creating a brighter copy for highlights
 #define VIDEO_HAS_HIGHLIGHTS			0x0020
 
-// Mish 181099:  See comments in video/generic.c for details
-#define VIDEO_BUFFERS_SPRITERAM			0x0040
-
 // force VIDEO_UPDATE to be called even for skipped frames
 #define VIDEO_ALWAYS_UPDATE				0x0080
 
diff -Nru src-old/emu/save.h src/emu/save.h
--- src-old/emu/save.h	2012-01-12 22:19:49.000000000 +0100
+++ src/emu/save.h	2012-03-11 18:17:00.000000000 +0100
@@ -306,4 +306,35 @@
 }
 
 
+//-------------------------------------------------
+//  save_item - specialized save_item for
+//  dynamic_arrays
+//-------------------------------------------------
+
+// surely there must be a syntax for doing this templated??
+template<>
+inline void save_manager::save_item(const char *module, const char *tag, int index, dynamic_array<UINT8> &value, const char *name)
+{
+	save_memory(module, tag, index, name, &value[0], sizeof(UINT8), value.count());
+}
+
+template<>
+inline void save_manager::save_item(const char *module, const char *tag, int index, dynamic_array<UINT16> &value, const char *name)
+{
+	save_memory(module, tag, index, name, &value[0], sizeof(UINT16), value.count());
+}
+
+template<>
+inline void save_manager::save_item(const char *module, const char *tag, int index, dynamic_array<UINT32> &value, const char *name)
+{
+	save_memory(module, tag, index, name, &value[0], sizeof(UINT32), value.count());
+}
+
+template<>
+inline void save_manager::save_item(const char *module, const char *tag, int index, dynamic_array<UINT64> &value, const char *name)
+{
+	save_memory(module, tag, index, name, &value[0], sizeof(UINT64), value.count());
+}
+
+
 #endif	/* __SAVE_H__ */
diff -Nru src-old/emu/schedule.c src/emu/schedule.c
--- src-old/emu/schedule.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/schedule.c	2012-02-28 10:21:38.000000000 +0100
@@ -251,7 +251,10 @@
 
 attotime emu_timer::remaining() const
 {
-	return m_expire - machine().time();
+	attotime curtime = machine().time();
+	if (curtime >= m_expire)
+		return attotime::zero;
+	return m_expire - curtime;
 }
 
 
diff -Nru src-old/emu/screen.h src/emu/screen.h
--- src-old/emu/screen.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/screen.h	2012-03-08 08:35:14.000000000 +0100
@@ -396,10 +396,10 @@
 	screen_device::static_set_screen_vblank(*device, screen_vblank_delegate(&screen_vblank_##_func, "screen_vblank_" #_func)); \
 
 #define MCFG_SCREEN_VBLANK_DRIVER(_class, _method) \
-	screen_device::static_set_screen_vblank(*device, screen_vblank_delegate(&_class::_method, #_class "::" #_method, NULL)); \
+	screen_device::static_set_screen_vblank(*device, screen_vblank_delegate(&_class::_method, #_class "::" #_method, NULL, (_class *)0)); \
 
 #define MCFG_SCREEN_VBLANK_DEVICE(_device, _class, _method) \
-	screen_device::static_set_screen_vblank(*device, screen_vblank_delegate(&_class::_method, #_class "::" #_method, _device)); \
+	screen_device::static_set_screen_vblank(*device, screen_vblank_delegate(&_class::_method, #_class "::" #_method, _device, (_class *)0)); \
 
 
 
diff -Nru src-old/emu/sound/3526intf.c src/emu/sound/3526intf.c
--- src-old/emu/sound/3526intf.c	2011-04-27 06:11:18.000000000 +0200
+++ src/emu/sound/3526intf.c	2012-03-07 19:42:58.000000000 +0100
@@ -30,6 +30,8 @@
 	void *			chip;
 	const ym3526_interface *intf;
 	device_t *device;
+
+	devcb_resolved_write_line out_int_func;
 };
 
 
@@ -45,7 +47,7 @@
 static void IRQHandler(void *param,int irq)
 {
 	ym3526_state *info = (ym3526_state *)param;
-	if (info->intf->handler) (info->intf->handler)(info->device, irq ? ASSERT_LINE : CLEAR_LINE);
+	info->out_int_func(irq ? ASSERT_LINE : CLEAR_LINE);
 }
 /* Timer overflow callback from timer.c */
 static TIMER_CALLBACK( timer_callback_0 )
@@ -88,13 +90,16 @@
 
 static DEVICE_START( ym3526 )
 {
-	static const ym3526_interface dummy = { 0 };
+	static const ym3526_interface dummy = { DEVCB_NULL };
 	ym3526_state *info = get_safe_token(device);
 	int rate = device->clock()/72;
 
 	info->intf = device->static_config() ? (const ym3526_interface *)device->static_config() : &dummy;
 	info->device = device;
 
+	// resolve callbacks
+	info->out_int_func.resolve(info->intf->out_int_func, *device);
+
 	/* stream system initialize */
 	info->chip = ym3526_init(device,device->clock(),rate);
 	assert_always(info->chip != NULL, "Error creating YM3526 chip");
diff -Nru src-old/emu/sound/3526intf.h src/emu/sound/3526intf.h
--- src-old/emu/sound/3526intf.h	2010-12-31 22:42:55.000000000 +0100
+++ src/emu/sound/3526intf.h	2012-03-07 19:42:58.000000000 +0100
@@ -8,7 +8,7 @@
 typedef struct _ym3526_interface ym3526_interface;
 struct _ym3526_interface
 {
-	void (*handler)(device_t *device, int linestate);
+	devcb_write_line out_int_func;
 };
 
 READ8_DEVICE_HANDLER( ym3526_r );
diff -Nru src-old/emu/sound/k054539.c src/emu/sound/k054539.c
--- src-old/emu/sound/k054539.c	2011-05-30 20:07:19.000000000 +0200
+++ src/emu/sound/k054539.c	2012-03-11 18:17:00.000000000 +0100
@@ -20,10 +20,30 @@
 #include "emu.h"
 #include "k054539.h"
 
+const device_type K054539 = &device_creator<k054539_device>;
+
 #define CHANNEL_DEBUG 0
 #define VERBOSE 0
 #define LOG(x) do { if (VERBOSE) logerror x; } while (0)
 
+k054539_device::k054539_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, K054539, "K054539", "k054539", tag, owner, clock),
+	  device_sound_interface(mconfig, *this)
+{
+}
+
+
+//-------------------------------------------------
+//  static_set_interface - configuration helper
+//  to set the interface
+//-------------------------------------------------
+
+void k054539_device::static_set_interface(device_t &device, const k054539_interface &interface)
+{
+	k054539_device &k = downcast<k054539_device &>(device);
+	static_cast<k054539_interface &>(k) = interface;
+}
+
 /* Registers:
    00..ff: 20 bytes/channel, 8 channels
      00..02: pitch (lsb, mid, msb)
@@ -49,89 +69,40 @@
    22f: enable pcm (b0), disable register ram updating (b7)
 
    The chip has a 0x4000 bytes reverb buffer (the ram from 0x22e).
-   The reverb delay is actually an offset in this buffer.  This driver
-   uses some tricks (doubling the buffer size so that the longest
-   reverbs don't fold over the sound to output, and adding a space at
-   the end to fold back overflows in) to be able to do frame-based
-   rendering instead of sample-based.
+   The reverb delay is actually an offset in this buffer.
 */
 
-typedef struct _k054539_channel k054539_channel;
-struct _k054539_channel {
-	UINT32 pos;
-	UINT32 pfrac;
-	INT32 val;
-	INT32 pval;
-};
-
-typedef struct _k054539_state k054539_state;
-struct _k054539_state {
-	const k054539_interface *intf;
-	device_t *device;
-	double voltab[256];
-	double pantab[0xf];
-
-	double k054539_gain[8];
-	UINT8 k054539_posreg_latch[8][3];
-	int k054539_flags;
-
-	unsigned char regs[0x230];
-	unsigned char *ram;
-	int reverb_pos;
-
-	INT32 cur_ptr;
-	int cur_limit;
-	unsigned char *cur_zone;
-	unsigned char *rom;
-	UINT32 rom_size;
-	UINT32 rom_mask;
-	sound_stream * stream;
-
-	k054539_channel channels[8];
-};
-
-INLINE k054539_state *get_safe_token(device_t *device)
-{
-	assert(device != NULL);
-	assert(device->type() == K054539);
-	return (k054539_state *)downcast<legacy_device_base *>(device)->token();
-}
-
-//*
-
-void k054539_init_flags(device_t *device, int flags)
+void k054539_device::init_flags(int _flags)
 {
-	k054539_state *info = get_safe_token(device);
-	info->k054539_flags = flags;
+	flags = _flags;
 }
 
-void k054539_set_gain(device_t *device, int channel, double gain)
+void k054539_device::set_gain(int channel, double _gain)
 {
-	k054539_state *info = get_safe_token(device);
-	if (gain >= 0) info->k054539_gain[channel] = gain;
+	if(_gain >= 0)
+		gain[channel] = _gain;
 }
 //*
 
-static int k054539_regupdate(k054539_state *info)
+bool k054539_device::regupdate()
 {
-	return !(info->regs[0x22f] & 0x80);
+	return !(regs[0x22f] & 0x80);
 }
 
-static void k054539_keyon(k054539_state *info, int channel)
+void k054539_device::keyon(int channel)
 {
-	if(k054539_regupdate(info))
-		info->regs[0x22c] |= 1 << channel;
+	if(regupdate())
+		regs[0x22c] |= 1 << channel;
 }
 
-static void k054539_keyoff(k054539_state *info, int channel)
+void k054539_device::keyoff(int channel)
 {
-	if(k054539_regupdate(info))
-		info->regs[0x22c] &= ~(1 << channel);
+	if(regupdate())
+		regs[0x22c] &= ~(1 << channel);
 }
 
-static STREAM_UPDATE( k054539_update )
+void k054539_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
 {
-	k054539_state *info = (k054539_state *)param;
 #define VOL_CAP 1.80
 
 	static const INT16 dpcm[16] = {
@@ -139,111 +110,86 @@
 		-64<<8, -49<<8, -36<<8, -25<<8, -16<<8, -9<<8, -4<<8, -1<<8
 	};
 
-	int ch, reverb_pos;
-	short *rbase;
-	unsigned char *rom;
-	UINT32 rom_mask;
-
-	unsigned char *base1, *base2;
-	k054539_channel *chan;
-	stream_sample_t *bufl, *bufr;
-	int cur_pos, cur_pfrac, cur_val, cur_pval;
-	int delta, rdelta, fdelta, pdelta;
-	int vol, bval, pan, i;
-
-	double gain, lvol, rvol, rbvol;
-
-	reverb_pos = info->reverb_pos;
-	rbase = (short *)(info->ram);
-
-	memset(outputs[0], 0, samples*sizeof(*outputs[0]));
-	memset(outputs[1], 0, samples*sizeof(*outputs[1]));
-
-	rom = info->rom;
-	rom_mask = info->rom_mask;
-
-	if(!(info->regs[0x22f] & 1)) return;
-
-	info->reverb_pos = (reverb_pos + samples) & 0x3fff;
-
-
-	for(ch=0; ch<8; ch++)
-		if(info->regs[0x22c] & (1<<ch)) {
-			base1 = info->regs + 0x20*ch;
-			base2 = info->regs + 0x200 + 0x2*ch;
-			chan = info->channels + ch;
-//*
-			delta = base1[0x00] | (base1[0x01] << 8) | (base1[0x02] << 16);
-
-			vol = base1[0x03];
-
-			bval = vol + base1[0x04];
-			if (bval > 255) bval = 255;
-
-			pan = base1[0x05];
-// DJ Main: 81-87 right, 88 middle, 89-8f left
-if (pan >= 0x81 && pan <= 0x8f)
-pan -= 0x81;
-else
-			if (pan >= 0x11 && pan <= 0x1f) pan -= 0x11; else pan = 0x18 - 0x11;
-
-			gain = info->k054539_gain[ch];
 
-			lvol = info->voltab[vol] * info->pantab[pan] * gain;
-			if (lvol > VOL_CAP) lvol = VOL_CAP;
+	INT16 *rbase = (INT16 *)ram;
 
-			rvol = info->voltab[vol] * info->pantab[0xe - pan] * gain;
-			if (rvol > VOL_CAP) rvol = VOL_CAP;
+	if(!(regs[0x22f] & 1))
+		return;
 
-			rbvol= info->voltab[bval] * gain / 2;
-			if (rbvol > VOL_CAP) rbvol = VOL_CAP;
-
-/*
-    INT x FLOAT could be interpreted as INT x (int)FLOAT instead of (float)INT x FLOAT on some compilers
-    causing precision loss. (rdelta - 0x2000) wraps around on zero reverb and the scale factor should
-    actually be 1/freq_ratio because the target is an offset to the reverb buffer not sample source.
-*/
-			rdelta = (base1[6] | (base1[7] << 8)) >> 3;
-//          rdelta = (reverb_pos + (int)((rdelta - 0x2000) * info->freq_ratio)) & 0x3fff;
-			rdelta = (int)(rdelta + reverb_pos) & 0x3fff;
-
-			cur_pos = (base1[0x0c] | (base1[0x0d] << 8) | (base1[0x0e] << 16)) & rom_mask;
-
-			bufl = outputs[0];
-			bufr = outputs[1];
-//*
-
-			if(base2[0] & 0x20) {
-				delta = -delta;
-				fdelta = +0x10000;
-				pdelta = -1;
-			} else {
-				fdelta = -0x10000;
-				pdelta = +1;
-			}
+	for(int sample = 0; sample != samples; sample++) {
+		double lval, rval;
+		if(!(flags & DISABLE_REVERB))
+			lval = rval = rbase[reverb_pos];
+		else
+			lval = rval = 0;
+		rbase[reverb_pos] = 0;
+
+		for(int ch=0; ch<8; ch++)
+			if(regs[0x22c] & (1<<ch)) {
+				unsigned char *base1 = regs + 0x20*ch;
+				unsigned char *base2 = regs + 0x200 + 0x2*ch;
+				channel *chan = channels + ch;
+
+				int delta = base1[0x00] | (base1[0x01] << 8) | (base1[0x02] << 16);
+
+				int vol = base1[0x03];
+
+				int bval = vol + base1[0x04];
+				if (bval > 255)
+					bval = 255;
+
+				int pan = base1[0x05];
+				// DJ Main: 81-87 right, 88 middle, 89-8f left
+				if (pan >= 0x81 && pan <= 0x8f)
+					pan -= 0x81;
+				else if (pan >= 0x11 && pan <= 0x1f)
+					pan -= 0x11;
+				else
+					pan = 0x18 - 0x11;
+
+				double cur_gain = gain[ch];
+
+				double lvol = voltab[vol] * pantab[pan] * cur_gain;
+				if (lvol > VOL_CAP)
+					lvol = VOL_CAP;
+
+				double rvol = voltab[vol] * pantab[0xe - pan] * cur_gain;
+				if (rvol > VOL_CAP)
+					rvol = VOL_CAP;
+
+				double rbvol= voltab[bval] * cur_gain / 2;
+				if (rbvol > VOL_CAP)
+					rbvol = VOL_CAP;
+
+				int rdelta = (base1[6] | (base1[7] << 8)) >> 3;
+				rdelta = (rdelta + reverb_pos) & 0x3fff;
+
+				int cur_pos = (base1[0x0c] | (base1[0x0d] << 8) | (base1[0x0e] << 16)) & rom_mask;
+
+				int fdelta, pdelta;
+				if(base2[0] & 0x20) {
+					delta = -delta;
+					fdelta = +0x10000;
+					pdelta = -1;
+				} else {
+					fdelta = -0x10000;
+					pdelta = +1;
+				}
 
-			if(cur_pos != chan->pos) {
-				chan->pos = cur_pos;
-				cur_pfrac = 0;
-				cur_val = 0;
-				cur_pval = 0;
-			} else {
-				cur_pfrac = chan->pfrac;
-				cur_val = chan->val;
-				cur_pval = chan->pval;
-			}
+				int cur_pfrac, cur_val, cur_pval;
+				if(cur_pos != chan->pos) {
+					chan->pos = cur_pos;
+					cur_pfrac = 0;
+					cur_val = 0;
+					cur_pval = 0;
+				} else {
+					cur_pfrac = chan->pfrac;
+					cur_val = chan->val;
+					cur_pval = chan->pval;
+				}
 
-#define UPDATE_CHANNELS																	\
-			do {																		\
-				*bufl++ += (INT16)(cur_val*lvol);										\
-				*bufr++ += (INT16)(cur_val*rvol);										\
-				rbase[rdelta++] += (INT16)(cur_val*rbvol);										\
-				rdelta &= 0x3fff;										\
-			} while(0)
-
-			switch(base2[0] & 0xc) {
-			case 0x0: { // 8bit pcm
-				for(i=0; i<samples; i++) {
+				switch(base2[0] & 0xc) {
+				case 0x0: { // 8bit pcm
 					cur_pfrac += delta;
 					while(cur_pfrac & ~0xffff) {
 						cur_pfrac += fdelta;
@@ -251,27 +197,22 @@
 
 						cur_pval = cur_val;
 						cur_val = (INT16)(rom[cur_pos] << 8);
+						if(cur_val == (INT16)0x8000 && (base2[1] & 1)) {
+							cur_pos = (base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask;
+							cur_val = (INT16)(rom[cur_pos] << 8);
+						}
 						if(cur_val == (INT16)0x8000) {
-							if(base2[1] & 1) {
-								cur_pos = (base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask;
-								cur_val = (INT16)(rom[cur_pos] << 8);
-								if(cur_val != (INT16)0x8000)
-									continue;
-							}
-							k054539_keyoff(info, ch);
-							goto end_channel_0;
+							keyoff(ch);
+							cur_val = 0;
+							break;
 						}
 					}
-
-					UPDATE_CHANNELS;
+					break;
 				}
-			end_channel_0:
-				break;
-			}
-			case 0x4: { // 16bit pcm lsb first
-				pdelta <<= 1;
 
-				for(i=0; i<samples; i++) {
+				case 0x4: { // 16bit pcm lsb first
+					pdelta <<= 1;
+
 					cur_pfrac += delta;
 					while(cur_pfrac & ~0xffff) {
 						cur_pfrac += fdelta;
@@ -279,32 +220,27 @@
 
 						cur_pval = cur_val;
 						cur_val = (INT16)(rom[cur_pos] | rom[cur_pos+1]<<8);
+						if(cur_val == (INT16)0x8000 && (base2[1] & 1)) {
+							cur_pos = (base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask;
+							cur_val = (INT16)(rom[cur_pos] | rom[cur_pos+1]<<8);
+						}
 						if(cur_val == (INT16)0x8000) {
-							if(base2[1] & 1) {
-								cur_pos = (base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask;
-								cur_val = (INT16)(rom[cur_pos] | rom[cur_pos+1]<<8);
-								if(cur_val != (INT16)0x8000)
-									continue;
-							}
-							k054539_keyoff(info, ch);
-							goto end_channel_4;
+							keyoff(ch);
+							cur_val = 0;
+							break;
 						}
 					}
-
-					UPDATE_CHANNELS;
-				}
-			end_channel_4:
-				break;
-			}
-			case 0x8: { // 4bit dpcm
-				cur_pos <<= 1;
-				cur_pfrac <<= 1;
-				if(cur_pfrac & 0x10000) {
-					cur_pfrac &= 0xffff;
-					cur_pos |= 1;
+					break;
 				}
 
-				for(i=0; i<samples; i++) {
+				case 0x8: { // 4bit dpcm
+					cur_pos <<= 1;
+					cur_pfrac <<= 1;
+					if(cur_pfrac & 0x10000) {
+						cur_pfrac &= 0xffff;
+						cur_pos |= 1;
+					}
+
 					cur_pfrac += delta;
 					while(cur_pfrac & ~0xffff) {
 						cur_pfrac += fdelta;
@@ -312,17 +248,15 @@
 
 						cur_pval = cur_val;
 						cur_val = rom[cur_pos>>1];
+						if(cur_val == 0x88 && (base2[1] & 1)) {
+							cur_pos = ((base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask) << 1;
+							cur_val = rom[cur_pos>>1];
+						}
 						if(cur_val == 0x88) {
-							if(base2[1] & 1) {
-								cur_pos = ((base1[0x08] | (base1[0x09] << 8) | (base1[0x0a] << 16)) & rom_mask) << 1;
-								cur_val = rom[cur_pos>>1];
-								if(cur_val != 0x88)
-									goto next_iter;
-							}
-							k054539_keyoff(info, ch);
-							goto end_channel_8;
+							keyoff(ch);
+							cur_val = 0;
+							break;
 						}
-					next_iter:
 						if(cur_pos & 1)
 							cur_val >>= 4;
 						else
@@ -334,258 +268,179 @@
 							cur_val = 32767;
 					}
 
-					UPDATE_CHANNELS;
+					cur_pfrac >>= 1;
+					if(cur_pos & 1)
+						cur_pfrac |= 0x8000;
+					cur_pos >>= 1;
+					break;
 				}
-			end_channel_8:
-				cur_pfrac >>= 1;
-				if(cur_pos & 1)
-					cur_pfrac |= 0x8000;
-				cur_pos >>= 1;
-				break;
-			}
-			default:
-				LOG(("Unknown sample type %x for channel %d\n", base2[0] & 0xc, ch));
-				break;
-			}
-			chan->pos = cur_pos;
-			chan->pfrac = cur_pfrac;
-			chan->pval = cur_pval;
-			chan->val = cur_val;
-			if(k054539_regupdate(info)) {
-				base1[0x0c] = cur_pos     & 0xff;
-				base1[0x0d] = cur_pos>> 8 & 0xff;
-				base1[0x0e] = cur_pos>>16 & 0xff;
-			}
-		}
-
-	//* drivers should be given the option to disable reverb when things go terribly wrong
-	if(!(info->k054539_flags & K054539_DISABLE_REVERB))
-	{
-		for(i=0; i<samples; i++) {
-			short val = rbase[(i+reverb_pos) & 0x3fff];
-			outputs[0][i] += val;
-			outputs[1][i] += val;
-		}
-	}
-
-	if(reverb_pos + samples > 0x4000) {
-		i = 0x4000 - reverb_pos;
-		memset(rbase + reverb_pos, 0, i*2);
-		memset(rbase, 0, (samples-i)*2);
-	} else
-		memset(rbase + reverb_pos, 0, samples*2);
-
-	#if CHANNEL_DEBUG
-	{
-		static const char gc_msg[32] = "chip :                         ";
-		static int gc_active=0, gc_chip=0, gc_pos[2]={0,0};
-		double *gc_fptr;
-		char *gc_cptr;
-		double gc_f0;
-		int gc_i, gc_j, gc_k, gc_l;
-
-		if (device->machine().input().code_pressed_once(KEYCODE_DEL_PAD))
-		{
-			gc_active ^= 1;
-			if (!gc_active) popmessage(NULL);
-		}
-
-		if (gc_active)
-		{
-			if (device->machine().input().code_pressed_once(KEYCODE_0_PAD)) gc_chip ^= 1;
-
-			gc_i = gc_pos[gc_chip];
-			gc_j = 0;
-			if (device->machine().input().code_pressed_once(KEYCODE_4_PAD)) { gc_i--; gc_j = 1; }
-			if (device->machine().input().code_pressed_once(KEYCODE_6_PAD)) { gc_i++; gc_j = 1; }
-			if (gc_j) { gc_i &= 7; gc_pos[gc_chip] = gc_i; }
-
-			if (device->machine().input().code_pressed_once(KEYCODE_5_PAD))
-				info->k054539_gain[gc_i] = 1.0;
-			else
-			{
-				gc_fptr = &info->k054539_gain[gc_i];
-				gc_f0 = *gc_fptr;
-				gc_j = 0;
-				if (device->machine().input().code_pressed_once(KEYCODE_2_PAD)) { gc_f0 -= 0.1; gc_j = 1; }
-				if (device->machine().input().code_pressed_once(KEYCODE_8_PAD)) { gc_f0 += 0.1; gc_j = 1; }
-				if (gc_j) { if (gc_f0 < 0) gc_f0 = 0; *gc_fptr = gc_f0; }
-			}
+				default:
+					LOG(("Unknown sample type %x for channel %d\n", base2[0] & 0xc, ch));
+					break;
+				}
+				lval += cur_val * lvol;
+				rval += cur_val * rvol;
+				rbase[(rdelta + reverb_pos) & 0x1fff] += INT16(cur_val*rbvol);
 
-			gc_fptr = &info->k054539_gain[0] + 8;
-			gc_cptr = gc_msg + 7;
-			for (gc_j=-8; gc_j; gc_j++)
-			{
-				gc_k = (int)(gc_fptr[gc_j] * 10);
-				gc_l = gc_k / 10;
-				gc_k = gc_k % 10;
-				gc_cptr[0] = gc_l + '0';
-				gc_cptr[1] = gc_k + '0';
-				gc_cptr += 3;
+				chan->pos = cur_pos;
+				chan->pfrac = cur_pfrac;
+				chan->pval = cur_pval;
+				chan->val = cur_val;
+
+				if(regupdate()) {
+					base1[0x0c] = cur_pos     & 0xff;
+					base1[0x0d] = cur_pos>> 8 & 0xff;
+					base1[0x0e] = cur_pos>>16 & 0xff;
+				}
 			}
-			gc_i = (gc_i + gc_i*2 + 6);
-			gc_msg[4] = gc_chip + '0';
-			gc_msg[gc_i  ] = '[';
-			gc_msg[gc_i+3] = ']';
-			popmessage("%s", gc_msg);
-			gc_msg[gc_i+3] = gc_msg[gc_i] = ' ';
-		}
+		reverb_pos = (reverb_pos + 1) & 0x1fff;
+		outputs[0][sample] = INT16(lval);
+		outputs[1][sample] = INT16(rval);
 	}
-	#endif
 }
 
 
-static TIMER_CALLBACK( k054539_irq )
+void k054539_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
 {
-	k054539_state *info = (k054539_state *)ptr;
-	if(info->regs[0x22f] & 0x20)
-		info->intf->irq(info->device);
+	if(regs[0x22f] & 0x20)
+		irq(this);
 }
 
-static void k054539_init_chip(device_t *device, k054539_state *info)
+void k054539_device::init_chip()
 {
-	int i;
-
-	memset(info->regs, 0, sizeof(info->regs));
-	memset(info->k054539_posreg_latch, 0, sizeof(info->k054539_posreg_latch)); //*
-	info->k054539_flags |= K054539_UPDATE_AT_KEYON; //* make it default until proven otherwise
-
-	// Real size of 0x4000, the addon is to simplify the reverb buffer computations
-	info->ram = auto_alloc_array(device->machine(), unsigned char, 0x4000*2+device->clock()/50*2);
-	info->reverb_pos = 0;
-	info->cur_ptr = 0;
-	memset(info->ram, 0, 0x4000*2+device->clock()/50*2);
-
-	const memory_region *region = (info->intf->rgnoverride != NULL) ? device->machine().region(info->intf->rgnoverride) : device->region();
-	info->rom = *region;
-	info->rom_size = region->bytes();
-	info->rom_mask = 0xffffffffU;
-	for(i=0; i<32; i++)
-		if((1U<<i) >= info->rom_size) {
-			info->rom_mask = (1U<<i) - 1;
+	memset(regs, 0, sizeof(regs));
+	memset(posreg_latch, 0, sizeof(posreg_latch)); //*
+	flags |= UPDATE_AT_KEYON; //* make it default until proven otherwise
+
+	ram = auto_alloc_array(machine(), unsigned char, 0x4000);
+	reverb_pos = 0;
+	cur_ptr = 0;
+	memset(ram, 0, 0x4000);
+
+	const memory_region *reg = (rgnoverride != NULL) ? machine().region(rgnoverride) : region();
+	rom = *reg;
+	rom_size = reg->bytes();
+	rom_mask = 0xffffffffU;
+	for(int i=0; i<32; i++)
+		if((1U<<i) >= rom_size) {
+			rom_mask = (1U<<i) - 1;
 			break;
 		}
 
-	if(info->intf->irq)
+	if(irq) {
 		// One or more of the registers must be the timer period
 		// And anyway, this particular frequency is probably wrong
 		// 480 hz is TRUSTED by gokuparo disco stage - the looping sample doesn't line up otherwise
-		device->machine().scheduler().timer_pulse(attotime::from_hz(480), FUNC(k054539_irq), 0, info);
+		emu_timer *tm = timer_alloc();
+		tm->adjust(attotime::from_hz(480), 0, attotime::from_hz(480));
+	}
 
-	info->stream = device->machine().sound().stream_alloc(*device, 0, 2, device->clock(), info, k054539_update);
+	// If the clock is anything else than 48000, things are going to go wrong.
+	stream = stream_alloc(0, 2, clock());
 
-	device->save_item(NAME(info->regs));
-	device->save_pointer(NAME(info->ram), 0x4000);
-	device->save_item(NAME(info->cur_ptr));
+	save_item(NAME(regs));
+	save_pointer(NAME(ram), 0x4000);
+	save_item(NAME(cur_ptr));
 }
 
-WRITE8_DEVICE_HANDLER( k054539_w )
+WRITE8_MEMBER(k054539_device::write)
 {
-	k054539_state *info = get_safe_token(device);
+	if(0) {
+		int voice, reg;
 
-#if 0
-	int voice, reg;
+		/* The K054539 has behavior like many other wavetable chips including
+           the Ensoniq 550x and Gravis GF-1: if a voice is active, writing
+           to it's current position is silently ignored.
 
-	/* The K054539 has behavior like many other wavetable chips including
-       the Ensoniq 550x and Gravis GF-1: if a voice is active, writing
-       to it's current position is silently ignored.
-
-       Dadandaan depends on this or the vocals go wrong.
-       */
-	if (offset < 8*0x20)
-	{
-		voice = offset / 0x20;
-		reg = offset & ~0x20;
-
-		if(info->regs[0x22c] & (1<<voice))
+           Dadandaan depends on this or the vocals go wrong.
+        */
+		if (offset < 8*0x20)
 		{
-			if (reg >= 0xc && reg <= 0xe)
-			{
-				return;
-			}
+			voice = offset / 0x20;
+			reg = offset & ~0x20;
+
+			if(regs[0x22c] & (1<<voice))
+				if (reg >= 0xc && reg <= 0xe)
+					return;
 		}
 	}
-#endif
-
-	int latch, offs, ch, pan;
-	UINT8 *regbase, *regptr, *posptr;
 
-	regbase = info->regs;
-	latch = (info->k054539_flags & K054539_UPDATE_AT_KEYON) && (regbase[0x22f] & 1);
+	bool latch = (flags & UPDATE_AT_KEYON) && (regs[0x22f] & 1);
 
 	if (latch && offset < 0x100)
 	{
-		offs = (offset & 0x1f) - 0xc;
-		ch = offset >> 5;
+		int offs = (offset & 0x1f) - 0xc;
+		int ch = offset >> 5;
 
 		if (offs >= 0 && offs <= 2)
 		{
 			// latch writes to the position index registers
-			info->k054539_posreg_latch[ch][offs] = data;
+			posreg_latch[ch][offs] = data;
 			return;
 		}
 	}
 
-	else switch(offset)
-	{
-		case 0x13f:
-			pan = data >= 0x11 && data <= 0x1f ? data - 0x11 : 0x18 - 0x11;
-			if(info->intf->apan)
-				info->intf->apan(info->device, info->pantab[pan], info->pantab[0xe - pan]);
-		break;
+	else
+		switch(offset) {
+		case 0x13f: {
+			int pan = data >= 0x11 && data <= 0x1f ? data - 0x11 : 0x18 - 0x11;
+			if(apan)
+				apan(this, pantab[pan], pantab[0xe - pan]);
+			break;
+		}
 
 		case 0x214:
 			if (latch)
 			{
-				for(ch=0; ch<8; ch++)
+				for(int ch=0; ch<8; ch++)
 				{
 					if(data & (1<<ch))
 					{
-						posptr = &info->k054539_posreg_latch[ch][0];
-						regptr = regbase + (ch<<5) + 0xc;
+						UINT8 *posptr = &posreg_latch[ch][0];
+						UINT8 *regptr = regs + (ch<<5) + 0xc;
 
 						// update the chip at key-on
 						regptr[0] = posptr[0];
 						regptr[1] = posptr[1];
 						regptr[2] = posptr[2];
 
-						k054539_keyon(info, ch);
+						keyon(ch);
 					}
 				}
 			}
 			else
 			{
-				for(ch=0; ch<8; ch++)
+				for(int ch=0; ch<8; ch++)
 					if(data & (1<<ch))
-						k054539_keyon(info, ch);
+						keyon(ch);
 			}
 		break;
 
 		case 0x215:
-			for(ch=0; ch<8; ch++)
+			for(int ch=0; ch<8; ch++)
 				if(data & (1<<ch))
-					k054539_keyoff(info, ch);
+					keyoff(ch);
 		break;
 
 		case 0x22d:
-			if(regbase[0x22e] == 0x80)
-				info->cur_zone[info->cur_ptr] = data;
-			info->cur_ptr++;
-			if(info->cur_ptr == info->cur_limit)
-				info->cur_ptr = 0;
+			if(regs[0x22e] == 0x80)
+				cur_zone[cur_ptr] = data;
+			cur_ptr++;
+			if(cur_ptr == cur_limit)
+				cur_ptr = 0;
 		break;
 
 		case 0x22e:
-			info->cur_zone =
-				data == 0x80 ? info->ram :
-				info->rom + 0x20000*data;
-			info->cur_limit = data == 0x80 ? 0x4000 : 0x20000;
-			info->cur_ptr = 0;
+			cur_zone =
+				data == 0x80 ? ram :
+				rom + 0x20000*data;
+			cur_limit = data == 0x80 ? 0x4000 : 0x20000;
+			cur_ptr = 0;
 		break;
 
 		default:
 #if 0
-			if(regbase[offset] != data) {
+			if(regs[offset] != data) {
 				if((offset & 0xff00) == 0) {
 					chanoff = offset & 0x1f;
 					if(chanoff < 4 || chanoff == 5 ||
@@ -601,28 +456,25 @@
 		break;
 	}
 
-	regbase[offset] = data;
+	regs[offset] = data;
 }
 
-static void reset_zones(k054539_state *info)
+void k054539_device::reset_zones()
 {
-	int data = info->regs[0x22e];
-	info->cur_zone =
-		data == 0x80 ? info->ram :
-		info->rom + 0x20000*data;
-	info->cur_limit = data == 0x80 ? 0x4000 : 0x20000;
+	int data = regs[0x22e];
+	cur_zone = data == 0x80 ? ram : rom + 0x20000*data;
+	cur_limit = data == 0x80 ? 0x4000 : 0x20000;
 }
 
-READ8_DEVICE_HANDLER( k054539_r )
+READ8_MEMBER(k054539_device::read)
 {
-	k054539_state *info = get_safe_token(device);
 	switch(offset) {
 	case 0x22d:
-		if(info->regs[0x22f] & 0x10) {
-			UINT8 res = info->cur_zone[info->cur_ptr];
-			info->cur_ptr++;
-			if(info->cur_ptr == info->cur_limit)
-				info->cur_ptr = 0;
+		if(regs[0x22f] & 0x10) {
+			UINT8 res = cur_zone[cur_ptr];
+			cur_ptr++;
+			if(cur_ptr == cur_limit)
+				cur_ptr = 0;
 			return res;
 		} else
 			return 0;
@@ -632,22 +484,14 @@
 		LOG(("K054539 read %03x\n", offset));
 		break;
 	}
-	return info->regs[offset];
+	return regs[offset];
 }
 
-static DEVICE_START( k054539 )
+void k054539_device::device_start()
 {
-	static const k054539_interface defintrf = { 0 };
-	int i;
-	k054539_state *info = get_safe_token(device);
-
-	info->device = device;
-
-	for (i = 0; i < 8; i++)
-		info->k054539_gain[i] = 1.0;
-	info->k054539_flags = K054539_RESET_FLAGS;
-
-	info->intf = (device->static_config() != NULL) ? (const k054539_interface *)device->static_config() : &defintrf;
+	for (int i = 0; i < 8; i++)
+		gain[i] = 1.0;
+	flags = RESET_FLAGS;
 
 	/*
         I've tried various equations on volume control but none worked consistently.
@@ -661,48 +505,21 @@
     */
 	// Factor the 1/4 for the number of channels in the volume (1/8 is too harsh, 1/2 gives clipping)
 	// vol=0 -> no attenuation, vol=0x40 -> -36dB
-	for(i=0; i<256; i++)
-		info->voltab[i] = pow(10.0, (-36.0 * (double)i / (double)0x40) / 20.0) / 4.0;
+	for(int i=0; i<256; i++)
+		voltab[i] = pow(10.0, (-36.0 * (double)i / (double)0x40) / 20.0) / 4.0;
 
 	// Pan table for the left channel
 	// Right channel is identical with inverted index
 	// Formula is such that pan[i]**2+pan[0xe-i]**2 = 1 (constant output power)
 	// and pan[0xe] = 1 (full panning)
-	for(i=0; i<0xf; i++)
-		info->pantab[i] = sqrt((double)i) / sqrt((double)0xe);
+	for(int i=0; i<0xf; i++)
+		pantab[i] = sqrt((double)i) / sqrt((double)0xe);
 
-	k054539_init_chip(device, info);
+	init_chip();
 
-	device->machine().save().register_postload(save_prepost_delegate(FUNC(reset_zones), info));
+	machine().save().register_postload(save_prepost_delegate(FUNC(k054539_device::reset_zones), this));
 }
 
-
-
-
-/**************************************************************************
- * Generic get_info
- **************************************************************************/
-
-DEVICE_GET_INFO( k054539 )
+void k054539_device::device_reset()
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(k054539_state);				break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME( k054539 );		break;
-		case DEVINFO_FCT_STOP:							/* nothing */									break;
-		case DEVINFO_FCT_RESET:							/* nothing */									break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "K054539");						break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Konami custom");				break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.0");							break;
-		case DEVINFO_STR_SOURCE_FILE:						strcpy(info->s, __FILE__);						break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
 }
-
-
-DEFINE_LEGACY_SOUND_DEVICE(K054539, k054539);
diff -Nru src-old/emu/sound/k054539.h src/emu/sound/k054539.h
--- src-old/emu/sound/k054539.h	2011-08-23 05:59:11.000000000 +0200
+++ src/emu/sound/k054539.h	2012-03-11 18:17:00.000000000 +0100
@@ -9,10 +9,11 @@
 #ifndef __K054539_H__
 #define __K054539_H__
 
-#include "devlegcy.h"
+#define MCFG_K054539_ADD(_tag, _clock, _interface) \
+	MCFG_DEVICE_ADD(_tag, K054539, _clock) \
+	k054539_device::static_set_interface(*device, _interface); \
 
-typedef struct _k054539_interface k054539_interface;
-struct _k054539_interface
+struct k054539_interface
 {
 	const char *rgnoverride;
 	void (*apan)(device_t *, double, double);	/* Callback for analog output mixing levels (0..1 for each channel) */
@@ -20,9 +21,6 @@
 };
 
 
-WRITE8_DEVICE_HANDLER( k054539_w );
-READ8_DEVICE_HANDLER( k054539_r );
-
 //* control flags, may be set at DRIVER_INIT().
 #define K054539_RESET_FLAGS     0
 #define K054539_REVERSE_STEREO  1
@@ -31,20 +29,89 @@
 
 void k054539_init_flags(device_t *device, int flags);
 
-/*
-    Note that the eight PCM channels of a K054539 do not have separate
-    volume controls. Considering the global attenuation equation may not
-    be entirely accurate, k054539_set_gain() provides means to control
-    channel gain. It can be called anywhere but preferrably from
-    DRIVER_INIT().
-
-    Parameters:
-        chip    : 0 / 1
-        channel : 0 - 7
-        gain    : 0.0=silent, 1.0=no gain, 2.0=twice as loud, etc.
-*/
 void k054539_set_gain(device_t *device, int channel, double gain);
 
-DECLARE_LEGACY_SOUND_DEVICE(K054539, k054539);
+class k054539_device : public device_t,
+					   public device_sound_interface,
+					   public k054539_interface
+{
+public:
+	enum {
+		RESET_FLAGS     = 0,
+		REVERSE_STEREO  = 1,
+		DISABLE_REVERB  = 2,
+		UPDATE_AT_KEYON = 4
+	};
+
+	// construction/destruction
+	k054539_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	// static configuration helpers
+	static void static_set_interface(device_t &device, const k054539_interface &interface);
+
+	DECLARE_WRITE8_MEMBER(write);
+	DECLARE_READ8_MEMBER(read);
+
+	void init_flags(int flags);
+
+	/*
+      Note that the eight PCM channels of a K054539 do not have separate
+      volume controls. Considering the global attenuation equation may not
+      be entirely accurate, k054539_set_gain() provides means to control
+      channel gain. It can be called anywhere but preferrably from
+      DRIVER_INIT().
+
+      Parameters:
+          channel : 0 - 7
+          gain    : 0.0=silent, 1.0=no gain, 2.0=twice as loud, etc.
+    */
+	void set_gain(int channel, double gain);
+
+protected:
+	// device-level overrides
+	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+	// device_sound_interface overrides
+	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+
+private:
+	struct channel {
+		UINT32 pos;
+		UINT32 pfrac;
+		INT32 val;
+		INT32 pval;
+	};
+
+	double voltab[256];
+	double pantab[0xf];
+
+	double gain[8];
+	UINT8 posreg_latch[8][3];
+	int flags;
+
+	unsigned char regs[0x230];
+	unsigned char *ram;
+	int reverb_pos;
+
+	INT32 cur_ptr;
+	int cur_limit;
+	unsigned char *cur_zone;
+	unsigned char *rom;
+	UINT32 rom_size;
+	UINT32 rom_mask;
+
+	channel channels[8];
+	sound_stream *stream;
+
+	bool regupdate();
+	void keyon(int channel);
+	void keyoff(int channel);
+	void init_chip();
+	void reset_zones();
+};
+
+extern const device_type K054539;
 
 #endif /* __K054539_H__ */
diff -Nru src-old/emu/sound/votrax.c src/emu/sound/votrax.c
--- src-old/emu/sound/votrax.c	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/sound/votrax.c	2012-03-11 18:17:00.000000000 +0100
@@ -2,8 +2,7 @@
 
     votrax.c
 
-    Hacked up votrax simulator that maps to samples, until a real one
-    is written.
+    Simple VOTRAX SC-01 simulator based on sample fragments.
 
 ****************************************************************************
 
@@ -42,24 +41,76 @@
 #include "votrax.h"
 
 
+//**************************************************************************
+//  DEBUGGING
+//**************************************************************************
+
+#define TEMP_HACKS		(1)
+
+#define LOG_TIMING		(0)
+#define LOG_LOWPARAM	(0)
+#define LOG_GLOTTAL		(0)
+#define LOG_TRANSITION	(0)
+
+
+
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+// note that according to the patent timing circuit, p1/p2 and phi1/phi2
+// run 4x faster than all references in the patent text
+const UINT32 P_CLOCK_BIT = 5;		// 5 according to timing diagram
+const UINT32 PHI_CLOCK_BIT = 3;		// 3 according to timing diagram
+
+
 
 //**************************************************************************
 //  GLOBAL VARIABLES
 //**************************************************************************
 
 // device type definition
-const device_type VOTRAX = &device_creator<votrax_device>;
+const device_type VOTRAX_SC01 = &device_creator<votrax_sc01_device>;
+
+// ROM definition for the Votrax phoneme ROM
+ROM_START( votrax_sc01 )
+	ROM_REGION( 0x200, "phoneme", 0 )
+	ROM_LOAD( "sc01.bin", 0x0000, 0x200, CRC(0353dd6c) SHA1(00e8e497b96a10bd9f4d7e559433c3c209b0d3a8) )
+ROM_END
 
-const char *const votrax_device::s_phoneme_table[64] =
+// textual phoneme names for debugging
+const char *const votrax_sc01_device::s_phoneme_table[64] =
 {
-	"EH3",	"EH2",	"EH1",	" "/*PA0*/"DT",	"A1",	"A2",	"ZH",
+	"EH3",	"EH2",	"EH1",	"PA0",	"DT",	"A1",	"A2",	"ZH",
 	"AH2",	"I3",	"I2",	"I1",	"M",	"N",	"B",	"V",
 	"CH",	"SH",	"Z",	"AW1",	"NG",	"AH1",	"OO1",	"OO",
 	"L",	"K",	"J",	"H",	"G",	"F",	"D",	"S",
 	"A",	"AY",	"Y1",	"UH3",	"AH",	"P",	"O",	"I",
 	"U",	"Y",	"T",	"R",	"E",	"W",	"AE",	"AE1",
 	"AW2",	"UH2",	"UH1",	"UH",	"O2",	"O1",	"IU",	"U1",
-	"THV",	"TH",	"ER",	"EH",	"E1",	"AW",	" "/*PA1*/, "."/*STOP*/
+	"THV",	"TH",	"ER",	"EH",	"E1",	"AW",	"PA1",	"STOP"
+};
+
+// this waveform is derived from measuring fig. 10 in the patent
+// it is only an approximation
+const double votrax_sc01_device::s_glottal_wave[16] =
+{
+	0,
+	16.0/22.0,
+	-22.0/22.0,
+	-17.0/22.0,
+	-15.0/22.0,
+	-10.0/22.0,
+	-7.0/22.0,
+	-4.0/22.0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0
 };
 
 
@@ -69,11 +120,14 @@
 //**************************************************************************
 
 //-------------------------------------------------
-//  votrax_device - constructor
+//  votrax_sc01_device - constructor
 //-------------------------------------------------
 
-votrax_device::votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
-	: samples_device(mconfig, VOTRAX, "VOTRAX SC-01", tag, owner, clock)
+votrax_sc01_device::votrax_sc01_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, VOTRAX_SC01, "Votrax SC-01", "votrax", tag, owner, clock),
+	  device_sound_interface(mconfig, *this),
+	  m_stream(NULL),
+	  m_phoneme_timer(NULL)
 {
 }
 
@@ -83,10 +137,10 @@
 //  to set the interface
 //-------------------------------------------------
 
-void votrax_device::static_set_interface(device_t &device, const votrax_interface &interface)
+void votrax_sc01_device::static_set_interface(device_t &device, const votrax_sc01_interface &interface)
 {
-	votrax_device &samples = downcast<votrax_device &>(device);
-	static_cast<votrax_interface &>(samples) = interface;
+	votrax_sc01_device &votrax = downcast<votrax_sc01_device &>(device);
+	static_cast<votrax_sc01_interface &>(votrax) = interface;
 }
 
 
@@ -99,42 +153,991 @@
 //  write - handle a write to the control register
 //-------------------------------------------------
 
-WRITE8_MEMBER( votrax_device::write )
+WRITE8_MEMBER( votrax_sc01_device::write )
 {
-	// append to the current string
-	m_current.cat(s_phoneme_table[data & 0x3f]);
+	// flush out anything currently processing
+	m_stream->update();
 
-	// look for a match in our sample table
-	for (int index = 0; m_votrax_map[index].phoneme != NULL; index++)
-		if (m_current.find(m_votrax_map[index].phoneme) != -1)
-		{
-			// if we found it, play the corresponding sample and flush the buffer
-			start(0, index);
-			m_current.replace(m_votrax_map[index].phoneme, "");
-			m_current.trimspace();
-			if (m_current.len() > 0)
-				mame_printf_warning("Votrax missed partial match: %s\n", m_current.cstr());
-			m_current.reset();
-			return;
-		}
+	// only 6 bits matter
+	m_phoneme = data & 0x3f;
+const UINT8 *rom = m_rom + (m_phoneme << 3);
+mame_printf_debug("%s: STROBE %s (F1=%X F2=%X FC=%X F3=%X F2Q=%X VA=%X FA=%X CL=%X CLD=%X VD=%X PAC=%X PH=%02X)\n",
+		machine().time().as_string(3), s_phoneme_table[m_phoneme],
+		rom[0] >> 4, rom[1] >> 4, rom[2] >> 4, rom[3] >> 4, rom[4] >> 4, rom[5] >> 4, rom[6] >> 4,
+		rom[3] & 0xf, rom[4] & 0xf, rom[5] & 0xf, rom[6] & 0xf, rom[7]);
+
+	// the STROBE signal resets the phoneme counter
+	m_counter_84 = 0xf;
+
+	// not in the schematics, but necessary to fully reset the request latch
+	m_latch_92 = 0;
+
+	// clear the request signal
+	m_request_func(m_request_state = m_internal_request = CLEAR_LINE);
+	m_phoneme_timer->adjust(attotime::zero);
+}
 
-	// if we got a stop and didn't find a match, print it
-	if ((data & 0x3f) == 0x3f)
-	{
-		mame_printf_warning("Votrax missed match: %s\n", m_current.cstr());
-		m_current.reset();
-	}
+
+//-------------------------------------------------
+//  inflection_w - handle a write to the
+//  inflection bits
+//-------------------------------------------------
+
+WRITE8_MEMBER( votrax_sc01_device::inflection_w )
+{
+	// only 2 bits matter
+	data &= 3;
+	if (m_inflection == data)
+		return;
+
+	// append an inflection marker
+	m_stream->update();
+	m_inflection = data;
+}
+
+
+
+//**************************************************************************
+//  CORE LOGIC
+//**************************************************************************
+
+//-------------------------------------------------
+//  update_subphoneme_clock_period - re-compute the
+//  period of the sub-phoneme clock, as a multiple
+//  of the master clock
+//-------------------------------------------------
+
+void votrax_sc01_device::update_subphoneme_clock_period()
+{
+	assert(m_latch_80 < 128);
+
+/*
+    The sub-phoneme timing circuit is based off the switching capacitor
+    technique described in the Votrax patent. Replacing the capacitor
+    ladder with [Rx] representing the effective resistance, the circuit
+    becomes essentially a pair of op-amps:
+
+         VM
+         | i1
+        [R1]
+         |                       Vc
+         +----------------------+
+         |        +---|C1|---+  |
+        [R2]      |          |  |  |\
+         |Vb i2   |    |\    |  +--++\
+         +--[Rx]--+----+-\   |     |  >
+         |             |  >--+-----+-/
+        [R3]      +----++/   Vc    |/
+         |i3      |    |/
+         +--------+ Va
+         |
+        [R4]
+         |
+         0
+
+    We have two op-amps, the left used as a standard amplifier, the right
+    one as a comparator.  The circuit triggers when the two inputs of the
+    right op-amp are equal.
+
+    The left part of the circuit (before C1) is simply a current injector.
+    It's all made of resistors, there's no modulated input, so everything
+    is going to be constant.  If you don't know about op-amps used as
+    amplifiers, you just need to know that it forces its two inputs to
+    have the same voltage while not sending or providing any current
+    through there (only though its output in fact).
+
+    In the schema, the injected current is i2.  Basic equations apply:
+      Va = R4.i3
+      Vb = Va + R3.i3
+      Vb = Va + Rx.i2
+      Vc = Vb + R2.i1
+      VM = Vc + R1.i1
+      i1 = i2 + i3
+
+    And the tipping happens when the voltage on the right of C1 reaches
+    Vc, so:
+      Vc = Va + i2.T/C1
+
+    (i2 being a constant, the integration is kinda easy)
+
+    Some maths later:
+      R3.i3 = Rx.i2 -> i3 = Rx/R3.i2
+      i1 = (1+Rx/R3).i2
+      Va + (Rx + R2 + R2.Rx/R3).i2 = Va + T/C1.i2
+      T = C1*(Rx*(1+R2/R3) + R2)
+
+    Which isn't, interestingly though not surprisingly, dependant on Vm,
+    R1 or R4.  And you have to round it to the next multiple of
+    0.2ms+0.1ms due to the clocking on p2 and its offset to p1 (charging
+    only happens on p1 active), and add one p1/p2 cycle (0.2ms) for the
+    discharge.
+
+    So now you have your base clock, which you have to multiply by 16 to
+    get the phoneme length.
+
+    r2 = 9e3
+    r3 = 1e3
+    c1 = 1000e-12
+    rx = 1/(5KHz * cx)
+*/
+
+	// determine total capacitance
+	double cx = 0;
+	if ((m_latch_80 & 0x01) != 0) cx += 5e-12;
+	if ((m_latch_80 & 0x02) != 0) cx += 11e-12;
+	if ((m_latch_80 & 0x04) != 0) cx += 21e-12;
+	if ((m_latch_80 & 0x08) != 0) cx += 43e-12;
+	if ((m_latch_80 & 0x10) != 0) cx += 86e-12;
+	if ((m_latch_80 & 0x20) != 0) cx += 173e-12;
+	if ((m_latch_80 & 0x40) != 0) cx += 345e-12;
+
+	// apply the equation above to determine charging time
+	// note that the 5kHz listed above for P1 is for a nominal master
+	// clock frequency of 1.28MHz, meaning it is master clock / 128
+	// which should be the P1 clock but appears to be a bit different
+	double p1_frequency = double(m_master_clock_freq) / double(1 << (P_CLOCK_BIT + 2));
+	double rx = 1.0 / (p1_frequency * cx);
+	double period = 1000e-12 * (rx * (1.0 + 9e3 / 1e3) + 9e3);
+
+	// convert to master clock cycles and round up
+	m_subphoneme_period = UINT32(ceil(period * double(m_master_clock_freq)));
+}
+
+//-------------------------------------------------
+//  bits_to_caps - compute the final capacity from
+//  a grid of bit-selected caps
+//-------------------------------------------------
+
+double votrax_sc01_device::bits_to_caps(UINT32 value, int caps_count, const double *caps_values)
+{
+	double sum = 0;
+	for(int i=0; i<caps_count; i++)
+		if(value & (1<<i))
+			sum += caps_values[i];
+	return sum;
+}
+
+/*
+  Playing with analog filters, or where all the magic filter formulas are coming from.
+
+  First you start with an analog circuit, for instance this one:
+
+  |                     +--[R2]--+
+  |                     |        |
+  |                     +--|C2|--+<V1     +--|C3|--+
+  |                     |        |        |        |
+  |  Vi   +--[R1]--+    |  |\    |        |  |\    |
+  |  -----+        +----+--+-\   |        +--+-\   |
+  |       +--|C1|--+       |  >--+--[Rx]--+  |  >--+----- Vo
+  |                |     0-++/             0-++/   |
+  |                |       |/    +--[R0]--+  |/    |
+  |                |             |        |        |
+  |                |             |    /|  |        |
+  |                |             |   /-+--+--[R0]--+
+  |                +--[R4]-------+--<  |
+  |                            V2^   \++-0
+  |                                   \|
+
+  You need to determine the transfer function H(s) of the circuit, which is
+  defined as the ratio Vo/Vi.  To do that, you use some properties:
+
+  - The intensity through an element is equal to the voltage
+    difference through the element divided by the impedence
+
+  - The impedence of a resistance is equal to its resistance
+
+  - The impedence of a capacitor is 1/(s*C) where C is its capacitance
+
+  - The impedence of elements in series is the sum of the impedences
+
+  - The impedence of elements in parallel is the inverse of the sum of
+    the inverses
+
+  - The sum of all intensities flowing into a node is 0 (there's no
+    charge accumulation in a wire)
+
+  - An operational amplifier in looped mode is an interesting beast:
+    the intensity at its two inputs is always 0, and the voltage is
+    forced identical between the inputs.  In our case, since the '+'
+    inputs are all tied to ground, that means that the '-' inputs are at
+    voltage 0, intensity 0.
+
+  From here we can build some equations.  Noting:
+  X1 = 1/(1/R1 + s*C1)
+  X2 = 1/(1/R2 + s*C2)
+  X3 = 1/(s*C3)
+
+  Then computing the intensity flow at each '-' input we have:
+  Vi/X1 + V2/R4 + V1/X2 = 0
+  V2/R0 + Vo/R0 = 0
+  V1/Rx + Vo/X3 = 0
+
+  Wrangling the equations, one eventually gets:
+  |                            1 + s * C1*R1
+  | Vo/Vi = H(s) = (R4/R1) * -------------------------------------------
+  |                            1 + s * C3*Rx*R4/R2 + s^2 * C2*C3*Rx*R4
+
+  To check the mathematics between the 's' stuff, check "Laplace
+  transform".  In short, it's a nice way of manipulating derivatives
+  and integrals without having to manipulate derivatives and
+  integrals.
+
+  With that transfer function, we first can compute what happens to
+  every frequency in the input signal.  You just compute H(2i*pi*f)
+  where f is the frequency, which will give you a complex number
+  representing the amplitude and phase effect.  To get the usual dB
+  curves, compute 20*log10(abs(v))).
+
+  Now, once you have an analog transfer function, you can build a
+  digital filter from it using what is called the bilinear transform.
+
+  In our case, we have an analog filter with the transfer function:
+  |                 1 + k[0]*s
+  |        H(s) = -------------------------
+  |                 1 + k[1]*s + k[2]*s^2
+
+  We can always reintroduce the global multipler later, and it's 1 in
+  most of our cases anyway.
+
+  The we pose:
+  |                    z-1
+  |        s(z) = zc * ---
+  |                    z+1
+
+  where zc = 2*pi*fr/tan(pi*fr/fs)
+  with fs = sampling frequency
+  and fr = most interesting frequency
+
+  Then we rewrite H in function of negative integer powers of z.
+
+  Noting m0 = zc*k[0], m1 = zc*k[1], m2=zc*zc*k[2],
+
+  a little equation wrangling then gives:
+
+  |                 (1+m0)    + (3+m0)   *z^-1 + (3-m0)   *z^-2 +    (1-m0)*z^-3
+  |        H(z) = ----------------------------------------------------------------
+  |                 (1+m1+m2) + (3+m1-m2)*z^-1 + (3-m1-m2)*z^-2 + (1-m1+m2)*z^-3
+
+  That beast in the digital transfer function, of which you can
+  extract response curves by posing z = exp(2*i*pi*f/fs).
+
+  Note that the bilinear transform is an approximation, and H(z(f)) =
+  H(s(f)) only at frequency fr.  And the shape of the filter will be
+  better respected around fr.  If you look at the curves of the
+  filters we're interested in, the frequency:
+  fr = sqrt(abs(k[0]*k[1]-k[2]))/(2*pi*k[2])
+
+  which is a (good) approximation of the filter peak position is a
+  good choice.
+
+  Note that terminology wise, the "standard" bilinear transform is
+  with fr = fs/2, and using a different fr is called "pre-warping".
+
+  So now we have a digital transfer function of the generic form:
+
+  |                 a[0] + a[1]*z^-1 + a[2]*z^-2 + a[3]*z^-3
+  |        H(z) = --------------------------------------------
+  |                 b[0] + b[1]*z^-1 + b[2]*z^-2 + b[3]*z^-3
+
+  The magic then is that the powers of z represent time in samples.
+  Noting x the input stream and y the output stream, you have:
+  H(z) = y(z)/x(z)
+
+  or in other words:
+  y*b[0]*z^0 + y*b[1]*z^-1 + y*b[2]*z^-2 + y*b[3]*z^-3 = x*a[0]*z^0 + x*a[1]*z^-1 + x*a[2]*z^-2 + x*a[3]*z^-3
+
+  i.e.
+
+  y*z^0 = (x*a[0]*z^0 + x*a[1]*z^-1 + x*a[2]*z^-2 + x*a[3]*z^-3 - y*b[1]*z^-1 - y*b[2]*z^-2 - y*b[3]*z^-3) / b[0]
+
+  and powers of z being time in samples,
+
+  y[0] = (x[0]*a[0] + x[-1]*a[1] + x[-2]*a[2] + x[-3]*a[3] - y[-1]*b[1] - y[-2]*b[2] - y[-3]*b[3]) / b[0]
+
+  So you have a filter you can apply.  Note that this is why you want
+  negative powers of z.  Positive powers would mean looking into the
+  future (which is possible in some cases, in particular with x, and
+  has some very interesting properties, but is not very useful in
+  analog circuit simulation).
+
+  Note that if you have multiple inputs, all this stuff is linear.
+  Or, in other words, you just have to split it in multiple circuits
+  with only one input connected each time and sum the results.  It
+  will be correct.
+
+  Also, since we're in practice in a dynamic system, for an amplifying
+  filter (i.e. where things like r4/r1 is not 1), it's better to
+  proceed in two steps:
+
+  - amplify the input by the current value of the coefficient, and
+    historize it
+  - apply the now non-amplifying filter to the historized amplified
+    input
+
+  That way reduces the probability of the output boucing all over the
+  place.
+
+*/
+
+
+//-------------------------------------------------------------
+//  filter_s_to_z - analog to digital filter transformation
+//-------------------------------------------------------------
+
+void votrax_sc01_device::filter_s_to_z(const double *k, double fs, double *a, double *b)
+{
+	double fpeak = sqrt(fabs(k[0]*k[1]-k[2]))/(2*M_PI*k[2]);
+	double zc = 2*M_PI*fpeak/tan(M_PI*fpeak/fs);
+
+	double m0 = zc*k[0];
+	double m1 = zc*k[1];
+	double m2 = zc*zc*k[2];
+
+	a[0] = 1+m0;
+	a[1] = 3+m0;
+	a[2] = 3-m0;
+	a[3] = 1-m0;
+	b[0] = 1+m1+m2;
+	b[1] = 3+m1-m2;
+	b[2] = 3-m1-m2;
+	b[3] = 1-m1+m2;
+}
+
+
+//-------------------------------------------------------------
+//  apply_filter - apply the digital filter (before output
+//                 shifting, so y[0] is one step in the past)
+//-------------------------------------------------------------
+double votrax_sc01_device::apply_filter(const double *x, const double *y, const double *a, const double *b)
+{
+	return (x[0]*a[0] + x[1]*a[1] + x[2]*a[2] + x[3]*a[3] - y[0]*b[1] - y[1]*b[2] - y[2]*b[3]) / b[0];
+}
+
+
+//-------------------------------------------------------------
+//  shift_hist - shift a value in an output history
+//-------------------------------------------------------------
+
+void votrax_sc01_device::shift_hist(double val, double *hist_array, int hist_size)
+{
+	for(int i = 0; i < hist_size-1; i++)
+		hist_array[hist_size-1-i] = hist_array[hist_size-2-i];
+	hist_array[0] = val;
 }
 
 
 //-------------------------------------------------
-//  status - read the status line
+//  sound_stream_update - handle update requests
+//  for our sound stream
 //-------------------------------------------------
 
-READ_LINE_MEMBER( votrax_device::status )
+void votrax_sc01_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
 {
-	// is this correct, or is it really a ready line and should be inverted?
-	return (m_current.len() > 0 || playing(0)) ? ASSERT_LINE : CLEAR_LINE;
+	// determine how many master half-clocks per sample
+	int clocks_per_sample = m_master_clock_freq / stream.sample_rate();
+
+	// iterate over clocks (samples)
+	stream_sample_t *dest = outputs[0];
+	while (samples--)
+	{
+		// run the digital logic at the master clock rate
+		double glottal_out = 0;
+		UINT8 noise_out_digital = 0;
+		for (int curclock = 0; curclock < clocks_per_sample; curclock++)
+		{
+if (LOG_TIMING | LOG_LOWPARAM | LOG_GLOTTAL | LOG_TRANSITION)
+{
+	if (m_counter_34 % 32 == 0 && m_master_clock == 0)
+	{
+	if (LOG_TIMING)
+		mame_printf_debug("MCLK C034 L070 L072 BET1  P1   P2  PHI1 PHI2 PH1' PH2' SUBC C088 C084 L092 IIRQ ");
+	if (LOG_LOWPARAM)
+		mame_printf_debug("F132 F114 F112 F142 L080 ");
+	if (LOG_GLOTTAL)
+		mame_printf_debug("C220 C222 C224 C234 C236 FGAT GLSY ");
+	if (LOG_TRANSITION)
+		mame_printf_debug("0625 C046 L046 A0-2 L168 L170  FC   VA   FA   F1   F2   F3   F2Q ");
+	mame_printf_debug("\n");
+	}
+	if (LOG_TIMING)
+		mame_printf_debug("%4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X ", m_master_clock, m_counter_34, m_latch_70, m_latch_72, m_beta1, m_p1, m_p2, m_phi1, m_phi2, m_phi1_20, m_phi2_20, m_subphoneme_count, m_clock_88, m_counter_84, m_latch_92, m_internal_request);
+	if (LOG_LOWPARAM)
+		mame_printf_debug("%4X %4X %4X %4X %4X ", m_srff_132, m_srff_114, m_srff_112, m_srff_142, m_latch_80);
+	if (LOG_GLOTTAL)
+		mame_printf_debug("%4X %4X %4X %4X %4X %4X %4X ", m_counter_220, m_counter_222, m_counter_224, m_counter_234, m_counter_236, m_fgate, m_glottal_sync);
+	if (LOG_TRANSITION)
+		mame_printf_debug("%4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X %4X ", m_0625_clock, m_counter_46, m_latch_46, m_latch_72 & 7, m_latch_168, m_latch_170, m_fc, m_va, m_fa, m_f1, m_f2, m_f3, m_f2q);
+	mame_printf_debug("\n");
+}
+
+			//==============================================
+			//
+			// Timing circuit (patent figure 2a)
+			//
+			//==============================================
+
+			// update master clock
+			m_master_clock ^= 1;
+
+			// on the falling edge of the master clock, advance the 10-bit counter at 34
+			UINT8 old_latch_72 = m_latch_72;
+			if (m_master_clock == 0)
+				m_counter_34 = (m_counter_34 + 1) & 0x3ff;
+			else
+			{
+				m_latch_70 = m_counter_34 & 0xf;
+				m_latch_72 = ((m_counter_34 >> 4) & 7) | ((m_counter_34 >> 6) & 8);
+			}
+
+			// derive beta 1 clock:
+			//  set if m_latch_70.0 == 1
+			//  reset if m_latch_70.0 == 0
+//          UINT8 old_beta1 = m_beta1;
+			m_beta1 = BIT(m_latch_70, 0);
+
+			// derive p2 clock:
+			//  set if (m_counter_34.P_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.P_CLOCK_BIT == 0)
+			UINT8 old_p2 = m_p2;
+			if (BIT(m_counter_34, P_CLOCK_BIT) & m_master_clock)
+				m_p2 = 1;
+			else if (!BIT(m_counter_34, P_CLOCK_BIT))
+				m_p2 = 0;
+
+			// derive p1 clock:
+			//  set if (!m_counter_34.P_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.P_CLOCK_BIT == 1)
+//          UINT8 old_p1 = m_p1;
+			if (BIT(~m_counter_34, P_CLOCK_BIT) & m_master_clock)
+				m_p1 = 1;
+			else if (BIT(m_counter_34, P_CLOCK_BIT))
+				m_p1 = 0;
+
+			// derive phi2 clock:
+			//  set if (m_counter_34.PHI_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.PHI_CLOCK_BIT == 0)
+			UINT8 old_phi2 = m_phi2;
+			if (BIT(m_counter_34, PHI_CLOCK_BIT) & m_master_clock)
+				m_phi2 = 1;
+			else if (!BIT(m_counter_34, PHI_CLOCK_BIT))
+				m_phi2 = 0;
+
+			// derive phi1 clock:
+			//  set if (!m_counter_34.PHI_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.PHI_CLOCK_BIT == 1)
+			UINT8 old_phi1 = m_phi1;
+			if (BIT(~m_counter_34, PHI_CLOCK_BIT) & m_master_clock)
+				m_phi1 = 1;
+			else if (BIT(m_counter_34, PHI_CLOCK_BIT))
+				m_phi1 = 0;
+
+			// derive alternate phi2 clock:
+			//  set if (m_counter_34.PHI_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.PHI_CLOCK_BIT == 0)
+			UINT8 old_phi2_20 = m_phi2_20;
+			if (BIT(m_counter_34, PHI_CLOCK_BIT + 2) & m_master_clock)
+				m_phi2_20 = 1;
+			else if (!BIT(m_counter_34, PHI_CLOCK_BIT + 2))
+				m_phi2_20 = 0;
+
+			// derive alternate phi1 clock:
+			//  set if (!m_counter_34.PHI_CLOCK_BIT & clock) == 1
+			//  reset if (m_counter_34.PHI_CLOCK_BIT == 1)
+//          UINT8 old_phi1_20 = m_phi1_20;
+			if (BIT(~m_counter_34, PHI_CLOCK_BIT + 2) & m_master_clock)
+				m_phi1_20 = 1;
+			else if (BIT(m_counter_34, PHI_CLOCK_BIT + 2))
+				m_phi1_20 = 0;
+
+			// determine rising edges of each clock of interest
+//          UINT8 beta1_rising = (old_beta1 ^ m_beta1) & m_beta1;
+			UINT8 p2_rising = (old_p2 ^ m_p2) & m_p2;
+//          UINT8 p1_rising = (old_p1 ^ m_p1) & m_p1;
+			UINT8 phi2_rising = (old_phi2 ^ m_phi2) & m_phi2;
+			UINT8 phi1_rising = (old_phi1 ^ m_phi1) & m_phi1;
+			UINT8 phi2_20_rising = (old_phi2_20 ^ m_phi2_20) & m_phi2_20;
+//          UINT8 phi1_20_rising = (old_phi1_20 ^ m_phi1_20) & m_phi1_20;
+			UINT8 a0_rising = BIT((old_latch_72 ^ m_latch_72) & m_latch_72, 0);
+			UINT8 a2_rising = BIT((old_latch_72 ^ m_latch_72) & m_latch_72, 2);
+			UINT8 _125k_rising = BIT((old_latch_72 ^ m_latch_72) & m_latch_72, 3);
+
+			// track subphoneme counter state
+			if (!(m_latch_42 | m_phi1))
+				m_subphoneme_count = 0;
+			else
+				m_subphoneme_count++;
+			if (p2_rising)
+				m_latch_42 = (m_subphoneme_count < m_subphoneme_period);
+
+			// update the state of the subphoneme clock line
+			UINT8 old_clock_88 = m_clock_88;
+			m_clock_88 = !m_latch_42;	//!(m_latch_42 | m_phi1); -- figure 7 seems to be wrong here
+			UINT8 clock_88_rising = (old_clock_88 ^ m_clock_88) & m_clock_88;
+
+			// the A/R line holds the counter in reset except during phoneme processing,
+			// when it is clocked on the rising edge of the subphoneme timer clock
+			if (m_internal_request != CLEAR_LINE)
+				m_counter_84 = 0xf;
+			else if (clock_88_rising)
+			{
+				m_counter_84 = (m_counter_84 - 1) & 0x0f;
+mame_printf_debug("counter=%d\n", m_counter_84);
+			}
+
+			// clock the zero count latch
+			if (p2_rising)
+				m_latch_92 = ((m_counter_84 == 0) | (m_latch_92 << 1)) & 3;
+
+			// once both bits are set, the request line goes high
+			if (m_latch_92 == 3)
+			{
+				// if the request line was previously low, reset the VD/CLD flip-flops
+				if (m_internal_request == CLEAR_LINE)
+					m_srff_112 = m_srff_114 = 0;
+				m_internal_request = ASSERT_LINE;
+			}
+
+			//==============================================
+			//
+			// Low parameter clocking (patent figure 2b)
+			//
+			//==============================================
+
+			// fetch ROM data; note that the address lines come directly from
+			// counter_34 and not from the latches, which are 1 cycle delayed
+			UINT8 romdata = m_rom[(m_phoneme << 3) | ((m_counter_34 >> 4) & 7)];
+
+			// update the ROM data; ROM format is (upper nibble/lower nibble)
+			//  +00 = F1 parameter / 0
+			//  +01 = F2 parameter / 0
+			//  +02 = FC parameter / 0
+			//  +03 = F3 parameter / CL
+			//  +04 = F2Q Parameter / CLD
+			//  +05 = VA Parameter / VD
+			//  +06 = FA Parameter / PAC
+			//  +07 = Phoneme timing (full 7 bits)
+
+			// latch a new value from ROM on phi2
+			UINT8 a = m_latch_72 & 7;
+			UINT8 romdata_swapped;
+			if (phi2_rising)
+			{
+				switch (a)
+				{
+					// update CL
+					case 3:
+						m_srff_132 = m_srff_114 & BIT(~romdata, 3);
+						break;
+
+					// update CLD
+					case 4:
+						romdata_swapped = (BIT(romdata, 0) << 3) | (BIT(romdata, 1) << 2) | (BIT(romdata, 2) << 1) | (BIT(romdata, 3) << 0);
+						if (m_counter_84 != 0 && romdata_swapped == (m_counter_84 ^ 0xf))
+							m_srff_114 = 1;
+						break;
+
+					// update VD
+					case 5:
+						romdata_swapped = (BIT(romdata, 0) << 3) | (BIT(romdata, 1) << 2) | (BIT(romdata, 2) << 1) | (BIT(romdata, 3) << 0);
+						if (m_counter_84 != 0 && romdata_swapped == (m_counter_84 ^ 0xf))
+							m_srff_112 = 1;
+						break;
+
+					// update FF == PAC & (VA | FA)
+					case 6:
+						m_srff_142 = BIT(romdata, 3);
+						break;
+
+					// update PH
+					case 7:
+						if (m_latch_80 != (romdata & 0x7f))
+						{
+							m_latch_80 = romdata & 0x7f;
+mame_printf_debug("[PH=%02X]\n", m_latch_80);
+							UINT32 old_period = m_subphoneme_period;
+							update_subphoneme_clock_period();
+							m_subphoneme_count = (m_subphoneme_count * m_subphoneme_period) / old_period;
+							m_phoneme_timer->adjust(attotime::zero);
+						}
+						break;
+				}
+			}
+
+			//==============================================
+			//
+			// Glottal circuit (patent figure 6)
+			//
+			//==============================================
+
+			// determine the TC output from the counters (note that TC requires ET)
+			UINT8 counter_222_tc = (m_counter_222 == 0xf);
+			UINT8 counter_220_tc = (m_counter_220 == 0xf && counter_222_tc);
+			UINT8 counter_224_tc = (m_counter_224 == 0xf && counter_222_tc);
+
+			// clock glottal counter 224 on rising edge of a0
+			if (a0_rising)
+			{
+				// counter 224 is only enabled if TC of counter 222 is 1
+				if (counter_222_tc)
+				{
+					// if counter 220's TC is 1, do a load instead of a count
+					if (counter_220_tc)
+						m_counter_224 = (m_inflection << 1) | ((~m_f1 & 0x8) >> 3);
+					else
+						m_counter_224 = (m_counter_224 + 1) & 0xf;
+				}
+			}
+
+			// clock remaining glottal counters (220, 222, 236) on rising edge of phi2
+			if (phi2_20_rising)
+			{
+				// counter 220 is only enabled if TC of counter 222 is 1
+				if (counter_222_tc)
+				{
+					// if counter 220's TC is 1, do a load instead of a count
+					if (counter_220_tc)
+						m_counter_220 = (m_inflection << 1) | ((~m_f1 & 0x8) >> 3);
+					else
+						m_counter_220 = (m_counter_220 + 1) & 0xf;
+				}
+
+				// counter 222 is always enabled
+				if (1)
+				{
+					// if counter 220's TC is 1, do a load instead of a count
+					if (counter_220_tc)
+						m_counter_222 = (~m_f1 & 0x7) << 1;
+					else
+						m_counter_222 = (m_counter_222 + 1) & 0xf;
+				}
+
+				// counter 236 is always enabled
+				if (1)
+				{
+					m_counter_236 = (m_counter_236 + 1) & 0xf;
+
+					// rising edge of Q1 from counter 236 clocks counter 234
+					if ((m_counter_236 & 0x3) == 0x2)
+					{
+						// counter 234 is only enabled if it has not reached terminal
+						if (m_counter_234 != 0xf)
+							m_counter_234 = (m_counter_234 + 1) & 0xf;
+					}
+				}
+			}
+
+			// update FGATE state
+			if (counter_220_tc)
+				m_fgate = 0;
+			if (counter_224_tc)
+				m_fgate = 1;
+
+			// apply asynchronous clear to counters 234/236
+			if (counter_220_tc && m_phi1_20)
+				m_counter_236 = m_counter_234 = 0;
+
+			// derive glottal circuit output signals
+#if !TEMP_HACKS
+			UINT8 old_glottal_sync = m_glottal_sync;
+#endif
+			m_glottal_sync = (m_counter_234 == 0);
+			glottal_out = s_glottal_wave[m_counter_234];
+
+			//==============================================
+			//
+			// Transition circuit (patent figure 3a/3b)
+			//
+			//==============================================
+
+			// divide 1.25k clock by 2 (lower-left of 46)
+			UINT8 old_0625_clock = m_0625_clock;
+			if (_125k_rising)
+				m_0625_clock = !m_0625_clock;
+			UINT8 _0625_rising = (old_0625_clock ^ m_0625_clock) & m_0625_clock;
+
+			// update counter above
+			if (_0625_rising)
+			{
+				if (m_counter_46 == 0xf)
+					m_counter_46 = 0xd;
+				else
+					m_counter_46 = (m_counter_46 + 1) & 0xf;
+			}
+
+			// and then the latch to the right
+			if (a2_rising)
+				m_latch_46 = (BIT(m_counter_46, 1) << 0) |
+							 (BIT(m_latch_46, 0) << 1) |
+							 (m_0625_clock << 2) |
+							 (BIT(m_latch_46, 2) << 3);
+
+#if TEMP_HACKS
+			m_latch_46 = 0xf;
+#endif
+
+			// determine the read/write signal
+			UINT8 ram_write = 0;
+			switch (a)
+			{
+				// write if not FF and low 2 bits of latch
+				// FF is the S/R flip-flop at 142 ANDed with !(/FA & /VA)
+				case 0:	case 1:	case 2: case 3: case 4:
+					if (!(m_srff_142 & !((m_fa == 0) & (m_va == 0))) && (m_latch_46 & 0x3) == 0x3)
+						ram_write = 1;
+					break;
+
+				case 5:
+					if ((m_latch_46 & 0xc) == 0xc && m_srff_112)
+						ram_write = 1;
+					break;
+
+				case 6:
+					if ((m_latch_46 & 0xc) == 0xc && m_srff_114)
+						ram_write = 1;
+					break;
+			}
+
+			// gate on the phi2 clock (OR gate @ 172)
+			ram_write &= m_phi2;
+
+			// write the transitioned values to RAM if requested
+			// (note we consolidate the serial addition and clocking steps here)
+			if (ram_write)
+			{
+				UINT8 old = (m_latch_168 << 4) | m_latch_170;
+				m_ram[a] = old - (old >> 3) + ((romdata & 0xf0) >> 3);
+			}
+
+			// latch some parameter values on rising edge of phi2
+			if (phi2_rising)
+			{
+				switch (a)
+				{
+					case 2:
+						m_fc = m_latch_168;
+						break;
+
+					case 5:
+						m_va = m_latch_168;
+						break;
+
+					case 6:
+						m_fa = m_latch_168;
+						break;
+				}
+			}
+
+			// latch remaining parameter values on rising edge of (phi2 & glottal sync)
+#if TEMP_HACKS
+			if (phi2_rising)
+#else
+			UINT8 old_phi2_glottal = (old_phi2 & old_glottal_sync);
+			UINT8 new_phi2_glottal = m_phi2 & m_glottal_sync;
+			if ((old_phi2_glottal ^ new_phi2_glottal) & new_phi2_glottal)
+#endif
+				switch (a)
+				{
+					case 0:
+						m_f1 = m_latch_168;
+						break;
+
+					case 1:
+						m_f2 = (m_latch_168 << 1) | (m_latch_170 >> 3);
+						break;
+
+					case 3:
+						m_f3 = m_latch_168;
+						break;
+
+					case 4:
+						m_f2q = m_latch_168;
+						break;
+				}
+
+			// latch value from RAM on rising edge of phi1
+			if (phi1_rising)
+			{
+				m_latch_168 = m_ram[a] >> 4;
+				m_latch_170 = m_ram[a] & 0xf;
+			}
+
+			//==============================================
+			//
+			// Noise generator circuit (patent figure 8)
+			//
+			//==============================================
+
+			// nose is clocked by the NOR of /FA and P1
+			UINT8 old_noise_clock = m_noise_clock;
+			m_noise_clock = !((m_fa == 0) | m_p1);
+			UINT8 noise_clock_rising = (old_noise_clock ^ m_noise_clock) & m_noise_clock;
+			UINT8 noise_clock_falling = (old_noise_clock ^ m_noise_clock) & old_noise_clock;
+
+			// falling edge clocks the shift register
+			if (noise_clock_falling)
+			{
+				// shift register 252 is actually 4 shift registers (2 4-bit, 2 5-bit)
+				// d1 and d3 are the 4-bit registers, d2 and d4 are the 5-bit registers
+				// XOR'ed input goes into d4, which shifts in to d2, then d3, then d1
+				// thus the full 18-bit value is effectively
+				//
+				//  d4 = (m_shift_252 >> 0) & 0x1f;
+				//  d2 = (m_shift_252 >> 5) & 0x1f;
+				//  d3 = (m_shift_252 >> 10) & 0xf;
+				//  d1 = (m_shift_252 >> 14) & 0xf;
+				//
+				// input at the low end is ((d1+4 ^ d2+5) ^ (d4+4 ^ d4+5)) ^ !(counter2 | counter3)
+				// output is tapped at d3+4
+
+				UINT32 old_shift = m_shift_252;
+				m_shift_252 <<= 1;
+				m_shift_252 |= ((BIT(old_shift, 17) ^ BIT(old_shift, 9)) ^ (BIT(old_shift, 3) ^ BIT(old_shift, 4))) ^
+								 ((m_counter_250 & 0xc) == 0);
+			}
+
+			// rising edge clocks the counter
+			if (noise_clock_rising)
+			{
+				// counter is reset to 1 if terminal, otherwise it increments
+				if (m_counter_250 == 0xf)
+					m_counter_250 = 0x1;
+				else
+					m_counter_250 = (m_counter_250 + 1) & 0xf;
+			}
+
+			// compute final noise out signal
+			noise_out_digital = !(BIT(m_shift_252, 13) & (m_fgate | (m_va == 0)));
+		}
+
+		// TODO: cache the filters
+		// filter coefs
+		double k[3], a[4], b[4];
+
+		// base frequencies
+		double fc = m_master_clock_freq / 30.0; // Nominal is 20KHz
+		double fs = stream.sample_rate();
+
+		// useful temporaries
+		double rcp, rcq, rca;
+
+		// amplification stage
+		static const double va_caps[4] = { 27, 53, 107, 213 };
+		double va_out = glottal_out * bits_to_caps(m_va, 4, va_caps) / 400;
+
+		shift_hist(va_out, m_va_hist, 4);
+
+
+		// noise shaping
+		static const double fa_caps[4] = { 27, 53, 107, 213 };
+		rcp = bits_to_caps(m_fa,  4, fa_caps);
+
+		shift_hist(-noise_out_digital * 400*rcp/(358.0*100000*566*(fc*rcp*1e-12 + 1.0/100000 + 1.0/2000)), m_ni_hist, 4);
+
+		k[0] = 400/(fc*358);
+		k[1] = 400*400/(fc*358*566);
+		k[2] = 400*400/(fc*fc*358*358);
+
+		filter_s_to_z(k, fs, a, b);
+		double no_out = apply_filter(m_ni_hist, m_no_hist, a, b);
+		shift_hist(no_out, m_no_hist, 4);
+
+
+		// stage 1 filter
+
+		static const double s1_p_caps[4] = { 16.4, 33, 66, 130 };
+		rcp = 24 + bits_to_caps(m_f1, 4, s1_p_caps);
+		rcq = 20;
+
+		k[0] = 253/(fc*270);
+		k[1] = 1080*rcq/(fc*270*rcp);
+		k[2] = 1080*1080/(fc*fc*270*rcp);
+
+		filter_s_to_z(k, fs, a, b);
+		double s1_out = apply_filter(m_va_hist, m_s1_hist, a, b);
+		shift_hist(s1_out, m_s1_hist, 4);
+
+
+		// stage 2 filter, glottal half
+
+		static const double s2_p_caps[5] = { 14, 28, 56, 113, 226 };
+		static const double s2_q_caps[4] = { 23, 46, 93, 186 };
+		rcp = 46 + bits_to_caps(m_f2,  5, s2_p_caps);
+		rcq = 20 + bits_to_caps(m_f2q, 4, s2_q_caps);;
+
+		k[0] = 400/(fc*470);
+		k[1] = 620*rcq/(fc*470*rcp);
+		k[2] = 620*620/(fc*fc*470*rcp);
+
+		filter_s_to_z(k, fs, a, b);
+		double s2g_out = apply_filter(m_s1_hist, m_s2g_hist, a, b);
+		shift_hist(s2g_out, m_s2g_hist, 4);
+
+
+		// stage 2 filter, noise half (rcp and rcq kept from stage 2 glottal)
+
+		static const double s2_n_caps[5] = { 19, 38, 76, 152 };
+		rca = bits_to_caps(m_fc, 4, s2_n_caps);
+
+		shift_hist(-no_out*rcq*rca/(470*rcp), m_s2ni_hist, 4);
+
+		k[0] = 400/(fc*470);
+		k[1] = 620*rcq/(fc*470*rcp);
+		k[2] = 620*620/(fc*fc*470*rcp);
+
+		filter_s_to_z(k, fs, a, b);
+		double s2n_out = apply_filter(m_s2ni_hist, m_s2n_hist, a, b);
+		shift_hist(s2n_out, m_s2n_hist, 4);
+
+		// sum the stage 2 outputs
+		double s2_out = s2g_out + s2n_out;
+		shift_hist(s2_out, m_s2_hist, 4);
+
+
+		// stage 3 filter
+
+		static const double s3_p_caps[4] = { 21, 42, 84, 168 };
+		rcp = 76 + bits_to_caps(m_f3, 4, s3_p_caps);
+		rcq = 20;
+
+		k[0] = 0;
+		k[1] = 420*rcq/(fc*390*rcp);
+		k[2] = 420*420/(fc*fc*390*rcp);
+
+		filter_s_to_z(k, fs, a, b);
+		double s3_out = apply_filter(m_s2_hist, m_s3_hist, a, b);
+		shift_hist(s3_out, m_s3_hist, 4);
+
+
+		// stage 4 filter, noise injection
+
+		// The resulting non-amplifying filter is identical, so we
+		// inject instead of splitting
+
+		static const double s4_n_caps[4] = { 24, 48, 96, 192 };
+		rca = 115 + bits_to_caps(~m_fc, 4, s4_n_caps);
+
+		shift_hist(s3_out + no_out*470/rca, m_s4i_hist, 4);
+
+
+		// stage 4 filter
+
+		rcp = 30;
+		rcq = 20;
+
+		k[0] = 0;
+		k[1] = 338*rcq/(fc*470*rcp);
+		k[2] = 338*338/(fc*fc*470*rcp);
+
+		filter_s_to_z(k, fs, a, b);
+		double s4_out = apply_filter(m_s4i_hist, m_s4_hist, a, b);
+		shift_hist(s4_out, m_s4_hist, 4);
+
+
+		// TODO: apply closure circuit (undocumented)
+
+		// output the current result
+		*dest++ = INT16(s4_out * 4000);
+	}
 }
 
 
@@ -144,20 +1147,258 @@
 //**************************************************************************
 
 //-------------------------------------------------
+//  rom_region - return a pointer to the device's
+//  internal ROM region
+//-------------------------------------------------
+
+const rom_entry *votrax_sc01_device::device_rom_region() const
+{
+	return ROM_NAME( votrax_sc01 );
+}
+
+
+//-------------------------------------------------
 //  device_start - handle device startup
 //-------------------------------------------------
 
-void votrax_device::device_start()
+void votrax_sc01_device::device_start()
+{
+	// initialize internal state
+	m_master_clock_freq = clock();
+	m_stream = stream_alloc(0, 1, m_master_clock_freq / 16);
+	m_phoneme_timer = timer_alloc();
+	m_rom = subregion("phoneme")->base();
+
+	// reset inputs
+	m_inflection = 0;
+	m_phoneme = 0x3f;
+
+	// reset outputs
+	m_request_func.resolve(m_request_cb, *this);
+	m_request_state = ASSERT_LINE;
+	m_internal_request = ASSERT_LINE;
+
+	// save inputs
+	save_item(NAME(m_inflection));
+	save_item(NAME(m_phoneme));
+
+	// save outputs
+	save_item(NAME(m_request_state));
+	save_item(NAME(m_internal_request));
+
+	// save timing circuit
+	save_item(NAME(m_master_clock_freq));
+	save_item(NAME(m_master_clock));
+	save_item(NAME(m_counter_34));
+	save_item(NAME(m_latch_70));
+	save_item(NAME(m_latch_72));
+	save_item(NAME(m_beta1));
+	save_item(NAME(m_p2));
+	save_item(NAME(m_p1));
+	save_item(NAME(m_phi2));
+	save_item(NAME(m_phi1));
+	save_item(NAME(m_subphoneme_period));
+	save_item(NAME(m_subphoneme_count));
+	save_item(NAME(m_clock_88));
+	save_item(NAME(m_latch_42));
+	save_item(NAME(m_counter_84));
+	save_item(NAME(m_latch_92));
+
+	// save low parameter clocking
+	save_item(NAME(m_srff_132));
+	save_item(NAME(m_srff_114));
+	save_item(NAME(m_srff_112));
+	save_item(NAME(m_srff_142));
+	save_item(NAME(m_latch_80));
+
+	// save glottal circuit
+	save_item(NAME(m_counter_220));
+	save_item(NAME(m_counter_222));
+	save_item(NAME(m_counter_224));
+	save_item(NAME(m_counter_234));
+	save_item(NAME(m_counter_236));
+	save_item(NAME(m_fgate));
+	save_item(NAME(m_glottal_sync));
+
+	// save transition circuit
+	save_item(NAME(m_0625_clock));
+	save_item(NAME(m_counter_46));
+	save_item(NAME(m_latch_46));
+	save_item(NAME(m_ram));
+	save_item(NAME(m_latch_168));
+	save_item(NAME(m_latch_170));
+	save_item(NAME(m_f1));
+	save_item(NAME(m_f2));
+	save_item(NAME(m_fc));
+	save_item(NAME(m_f3));
+	save_item(NAME(m_f2q));
+	save_item(NAME(m_va));
+	save_item(NAME(m_fa));
+
+	// save noise generator circuit
+	save_item(NAME(m_noise_clock));
+	save_item(NAME(m_shift_252));
+	save_item(NAME(m_counter_250));
+
+	// save filter histories
+	save_item(NAME(m_ni_hist));
+	save_item(NAME(m_no_hist));
+	save_item(NAME(m_va_hist));
+	save_item(NAME(m_s1_hist));
+	save_item(NAME(m_s2g_hist));
+	save_item(NAME(m_s2n_hist));
+	save_item(NAME(m_s2ni_hist));
+	save_item(NAME(m_s2_hist));
+	save_item(NAME(m_s3_hist));
+	save_item(NAME(m_s4i_hist));
+	save_item(NAME(m_s4_hist));
+}
+
+
+//-------------------------------------------------
+//  device_reset - handle device reset
+//-------------------------------------------------
+
+void votrax_sc01_device::device_reset()
+{
+	// set the initial state
+	m_stream->update();
+
+	// reset inputs
+	m_phoneme = 0x3f;
+	m_request_func(m_internal_request = m_request_state = ASSERT_LINE);
+
+	// reset timing circuit
+	m_master_clock = 0;
+	m_counter_34 = 0;
+	m_latch_70 = 0;
+	m_latch_72 = 0;
+	m_beta1 = 0;
+	m_p2 = 0;
+	m_p1 = 0;
+	m_phi2 = 0;
+	m_phi1 = 0;
+	m_subphoneme_period = 1000;
+	m_subphoneme_count = 0;
+	m_clock_88 = 0;
+	m_latch_42 = 0;
+	m_counter_84 = 0;
+	m_latch_92 = 0;
+
+	// reset low parameter clocking
+	m_srff_132 = 0;
+	m_srff_114 = 0;
+	m_srff_112 = 0;
+	m_srff_142 = 0;
+	m_latch_80 = 50;
+	update_subphoneme_clock_period();
+
+	// reset glottal circuit
+	m_counter_220 = 0;
+	m_counter_222 = 0;
+	m_counter_224 = 0;
+	m_counter_234 = 0;
+	m_counter_236 = 0;
+	m_fgate = 0;
+	m_glottal_sync = 0;
+
+	// reset transition circuit
+	m_0625_clock = 0;
+	m_counter_46 = 0;
+	m_latch_46 = 0;
+	memset(m_ram, 0, sizeof(m_ram));
+	m_latch_168 = 0;
+	m_latch_170 = 0;
+	m_f1 = 0;
+	m_f2 = 0;
+	m_fc = 0;
+	m_f3 = 0;
+	m_f2q = 0;
+	m_va = 0;
+	m_fa = 0;
+
+	// reset noise circuit
+	m_noise_clock = 0;
+	m_shift_252 = 0;
+	m_counter_250 = 0;
+
+	// reset filter histories
+	memset(m_ni_hist,   0, sizeof(m_ni_hist));
+	memset(m_no_hist,   0, sizeof(m_no_hist));
+	memset(m_va_hist,   0, sizeof(m_va_hist));
+	memset(m_s1_hist,   0, sizeof(m_s1_hist));
+	memset(m_s2g_hist,  0, sizeof(m_s2g_hist));
+	memset(m_s2n_hist,  0, sizeof(m_s2n_hist));
+	memset(m_s2ni_hist, 0, sizeof(m_s2ni_hist));
+	memset(m_s2_hist,   0, sizeof(m_s2_hist));
+	memset(m_s3_hist,   0, sizeof(m_s3_hist));
+	memset(m_s4i_hist,  0, sizeof(m_s4i_hist));
+	memset(m_s4_hist,   0, sizeof(m_s4_hist));
+}
+
+
+//-------------------------------------------------
+//  device_clock_changed - handle dynamic clock
+//  changes by altering our output frequency
+//-------------------------------------------------
+
+void votrax_sc01_device::device_clock_changed()
 {
-	// build up a samples list
-	for (const votrax_map *curmap = m_votrax_map; curmap->phoneme != NULL; curmap++)
-		m_sample_list.append((curmap->samplename != NULL) ? curmap->samplename : "");
-
-	// create the samples interface
-	m_channels = 1;
-	m_names = m_sample_list;
-	m_start = NULL;
+	// compute new frequency of the master clock, and update if changed
+	UINT32 newfreq = clock();
+	if (newfreq != m_master_clock_freq)
+	{
+		// if we have a stream
+		if (m_stream != NULL)
+		{
+			m_stream->update();
+			m_stream->set_sample_rate(newfreq / 16);
+		}
+
+		// determine how many clock ticks remained on the phoneme timer
+		UINT64 remaining = m_phoneme_timer->remaining().as_ticks(m_master_clock_freq);
+
+		// recompute the master clock
+		m_master_clock_freq = newfreq;
+
+		// adjust the phoneme timer to the same number of ticks based on the new frequency
+		if (remaining > 0)
+			m_phoneme_timer->adjust(attotime::from_ticks(remaining, newfreq));
+	}
+}
+
+
+//-------------------------------------------------
+//  device_timer - handle device timer
+//-------------------------------------------------
+
+void votrax_sc01_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	// force a stream update
+	m_stream->update();
+
+	// if we're requesting more data, no need for timing
+	if (m_request_state == ASSERT_LINE)
+		return;
+
+	// if we're supposed to have fired, do it now
+	if (m_internal_request == ASSERT_LINE)
+	{
+mame_printf_debug("%s: REQUEST\n", timer.machine().time().as_string(3));
+		m_request_func(m_request_state = ASSERT_LINE);
+		return;
+	}
+
+	// account for the rest of this subphoneme clock
+	UINT32 clocks_until_request = 0;
+	if (m_counter_84 != 0)
+	{
+		if (m_subphoneme_count < m_subphoneme_period)
+			clocks_until_request += m_subphoneme_period - m_subphoneme_count;
+		clocks_until_request += m_subphoneme_period * (m_counter_84 - 1);
+	}
 
-	// let the samples device do the rest
-	samples_device::device_start();
+	// plus 1/2
+	clocks_until_request = MAX(clocks_until_request, (1 << P_CLOCK_BIT) / 2);
+	timer.adjust(attotime::from_ticks(clocks_until_request, m_master_clock_freq));
 }
diff -Nru src-old/emu/sound/votrax.h src/emu/sound/votrax.h
--- src-old/emu/sound/votrax.h	2012-02-19 16:23:23.000000000 +0100
+++ src/emu/sound/votrax.h	2012-03-11 18:17:00.000000000 +0100
@@ -2,8 +2,7 @@
 
     votrax.h
 
-    Hacked up votrax simulator that maps to samples, until a real one
-    is written.
+    Simple VOTRAX SC-01 simulator based on sample fragments.
 
 ****************************************************************************
 
@@ -50,9 +49,9 @@
 //  INTERFACE CONFIGURATION MACROS
 //**************************************************************************
 
-#define MCFG_VOTRAX_ADD(_tag, _clock, _interface) \
-	MCFG_DEVICE_ADD(_tag, VOTRAX, 0) \
-	votrax_device::static_set_interface(*device, _interface);
+#define MCFG_VOTRAX_SC01_ADD(_tag, _clock, _interface) \
+	MCFG_DEVICE_ADD(_tag, VOTRAX_SC01, _clock) \
+	votrax_sc01_device::static_set_interface(*device, _interface); \
 
 
 
@@ -60,46 +59,137 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-// ======================> votrax_interface sample
+// ======================> votrax_sc01_interface
 
-struct votrax_map
+struct votrax_sc01_interface
 {
-	const char *phoneme;
-	const char *samplename;
-};
-
-struct votrax_interface
-{
-	votrax_map const *m_votrax_map;		// array of map entries
+	devcb_write_line m_request_cb;		// callback for request
 };
 
 
-// ======================> votrax_device
+// ======================> votrax_sc01_device
 
-class votrax_device :	public samples_device,
-						public votrax_interface
+class votrax_sc01_device :	public device_t,
+							public device_sound_interface,
+							public votrax_sc01_interface
 {
 public:
 	// construction/destruction
-	votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	votrax_sc01_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 
 	// static configuration helpers
-	static void static_set_interface(device_t &device, const votrax_interface &interface);
+	static void static_set_interface(device_t &device, const votrax_sc01_interface &interface);
 
 	// writers
 	DECLARE_WRITE8_MEMBER( write );
-	DECLARE_READ_LINE_MEMBER( status );
+	DECLARE_WRITE8_MEMBER( inflection_w );
+	DECLARE_READ_LINE_MEMBER( request ) { return m_request_state; }
 
 protected:
 	// device-level overrides
+	const rom_entry *device_rom_region() const;
 	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_clock_changed();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+	// device_sound_interface overrides
+	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
 
 private:
+	// internal helpers
+	void update_subphoneme_clock_period();
+	static double bits_to_caps(UINT32 value, int caps_count, const double *caps_values);
+	static void shift_hist(double val, double *hist_array, int hist_size);
+	static void filter_s_to_z(const double *k, double fs, double *a, double *b);
+	static double apply_filter(const double *x, const double *y, const double *a, const double *b);
+
 	// internal state
-	astring						m_current;
-	dynamic_array<const char *>	m_sample_list;
+	sound_stream *				m_stream;				// output stream
+	emu_timer *					m_phoneme_timer;		// phoneme timer
+	const UINT8 *				m_rom;					// pointer to our ROM
+
+	// inputs
+	UINT8						m_inflection;			// 2-bit inflection value
+	UINT8						m_phoneme;				// 6-bit phoneme value
+
+	// outputs
+	devcb_resolved_write_line	m_request_func;			// request callback
+	UINT8						m_request_state;		// request as seen to the outside world
+	UINT8						m_internal_request;		// request managed by stream timing
+
+	// timing circuit
+	UINT32						m_master_clock_freq;	// frequency of the master clock
+	UINT8						m_master_clock;			// master clock
+	UINT16						m_counter_34;			// ripple counter @ 34
+	UINT8						m_latch_70;				// 4-bit latch @ 70
+	UINT8						m_latch_72;				// 4-bit latch @ 72
+	UINT8						m_beta1;				// beta1 clock state
+	UINT8						m_p2;					// P2 clock state
+	UINT8						m_p1;					// P1 clock state
+	UINT8						m_phi2;					// phi2 clock state
+	UINT8						m_phi1;					// phi1 clock state
+	UINT8						m_phi2_20;				// alternate phi2 clock state (20kHz)
+	UINT8						m_phi1_20;				// alternate phi1 clock state (20kHz)
+	UINT32						m_subphoneme_period;	// period of the subphoneme timer
+	UINT32						m_subphoneme_count;		// number of ticks executed already
+	UINT8						m_clock_88;				// subphoneme clock output @ 88
+	UINT8						m_latch_42;				// D flip-flop @ 42
+	UINT8						m_counter_84;			// 4-bit phoneme counter @ 84
+	UINT8						m_latch_92;				// 2-bit latch @ 92
+
+	// low parameter clocking
+	UINT8						m_srff_132;				// S/R flip-flop @ 132
+	UINT8						m_srff_114;				// S/R flip-flop @ 114
+	UINT8						m_srff_112;				// S/R flip-flop @ 112
+	UINT8						m_srff_142;				// S/R flip-flop @ 142
+	UINT8						m_latch_80;				// phoneme timing latch @ 80
+
+	// glottal circuit
+	UINT8						m_counter_220;			// 4-bit counter @ 220
+	UINT8						m_counter_222;			// 4-bit counter @ 222
+	UINT8						m_counter_224;			// 4-bit counter @ 224
+	UINT8						m_counter_234;			// 4-bit counter @ 234
+	UINT8						m_counter_236;			// 4-bit counter @ 236
+	UINT8						m_fgate;				// FGATE signal
+	UINT8						m_glottal_sync;			// Glottal Sync signal
+
+	// transition circuit
+	UINT8						m_0625_clock;			// state of 0.625kHz clock
+	UINT8						m_counter_46;			// 4-bit counter in block @ 46
+	UINT8						m_latch_46;				// 4-bit latch in block @ 46
+	UINT8						m_ram[8];				// RAM to hold parameters
+	UINT8						m_latch_168;			// 4-bit latch @ 168
+	UINT8						m_latch_170;			// 4-bit latch @ 170
+	UINT8						m_f1;					// latched 4-bit F1 value
+	UINT8						m_f2;					// latched 5-bit F2 value
+	UINT8						m_fc;					// latched 4-bit FC value
+	UINT8						m_f3;					// latched 4-bit F3 value
+	UINT8						m_f2q;					// latched 4-bit F2Q value
+	UINT8						m_va;					// latched 4-bit VA value
+	UINT8						m_fa;					// latched 4-bit FA value
+
+	// noise generator circuit
+	UINT8						m_noise_clock;			// clock input to noise generator
+	UINT32						m_shift_252;			// shift register @ 252
+	UINT8						m_counter_250;			// 4-bit counter @ 250
+
+	// stages outputs history
+	double						m_ni_hist[4];
+	double						m_no_hist[4];
+	double						m_va_hist[4];
+	double						m_s1_hist[4];
+	double						m_s2g_hist[4];
+	double						m_s2ni_hist[4];
+	double						m_s2n_hist[4];
+	double						m_s2_hist[4];
+	double						m_s3_hist[4];
+	double						m_s4i_hist[4];
+	double						m_s4_hist[4];
 
+	// static tables
 	static const char *const s_phoneme_table[64];
+	static const double s_glottal_wave[16];
 };
 
 
@@ -109,7 +199,7 @@
 //**************************************************************************
 
 // device type definition
-extern const device_type VOTRAX;
+extern const device_type VOTRAX_SC01;
 
 
 #endif /* __VOTRAX_H__ */
diff -Nru src-old/emu/sound/ymf271.c src/emu/sound/ymf271.c
--- src-old/emu/sound/ymf271.c	2011-08-17 23:34:19.000000000 +0200
+++ src/emu/sound/ymf271.c	2012-03-08 13:48:15.000000000 +0100
@@ -1452,6 +1452,8 @@
 					{
 						chip->timerA |= (data & 0xff)<<8;
 					}
+					else
+						chip->timerA |= 0x200;
 				}
 				break;
 
diff -Nru src-old/emu/sound.c src/emu/sound.c
--- src-old/emu/sound.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/sound.c	2012-02-28 10:21:05.000000000 +0100
@@ -786,10 +786,10 @@
 	if (m_nosound_mode && wavfile[0] == 0 && avifile[0] == 0)
 		machine.m_sample_rate = 11025;
 
-	// count the speakers
+	// count the mixers
 #if VERBOSE
-	speaker_device_iterator iter(machine.root_device());
-	VPRINTF(("total speakers = %d\n", iter.count()));
+	mixer_interface_iterator iter(machine.root_device());
+	VPRINTF(("total mixers = %d\n", iter.count()));
 #endif
 
 	// allocate memory for mix buffers
@@ -856,24 +856,24 @@
 
 
 //-------------------------------------------------
-//  indexed_speaker_input - return the speaker
-//  device and input index of the global speaker
+//  indexed_mixer_input - return the mixer
+//  device and input index of the global mixer
 //  input
 //-------------------------------------------------
 
-bool sound_manager::indexed_speaker_input(int index, speaker_input &info) const
+bool sound_manager::indexed_mixer_input(int index, mixer_input &info) const
 {
-	// scan through the speakers until we find the indexed input
-	speaker_device_iterator iter(machine().root_device());
-	for (info.speaker = iter.first(); info.speaker != NULL; info.speaker = iter.next())
+	// scan through the mixers until we find the indexed input
+	mixer_interface_iterator iter(machine().root_device());
+	for (info.mixer = iter.first(); info.mixer != NULL; info.mixer = iter.next())
 	{
-		if (index < info.speaker->inputs())
+		if (index < info.mixer->inputs())
 		{
-			info.stream = info.speaker->input_to_stream_input(index, info.inputnum);
+			info.stream = info.mixer->input_to_stream_input(index, info.inputnum);
 			assert(info.stream != NULL);
 			return true;
 		}
-		index -= info.speaker->inputs();
+		index -= info.mixer->inputs();
 	}
 
 	// didn't locate
@@ -946,8 +946,8 @@
 	// iterate over channel nodes
 	for (xml_data_node *channelnode = xml_get_sibling(parentnode->child, "channel"); channelnode != NULL; channelnode = xml_get_sibling(channelnode->next, "channel"))
 	{
-		speaker_input info;
-		if (indexed_speaker_input(xml_get_attribute_int(channelnode, "index", -1), info))
+		mixer_input info;
+		if (indexed_mixer_input(xml_get_attribute_int(channelnode, "index", -1), info))
 		{
 			float defvol = xml_get_attribute_float(channelnode, "defvol", -1000.0);
 			float newvol = xml_get_attribute_float(channelnode, "newvol", -1000.0);
@@ -973,8 +973,8 @@
 	if (parentnode != NULL)
 		for (int mixernum = 0; ; mixernum++)
 		{
-			speaker_input info;
-			if (!indexed_speaker_input(mixernum, info))
+			mixer_input info;
+			if (!indexed_mixer_input(mixernum, info))
 				break;
 			float defvol = info.stream->initial_input_gain(info.inputnum);
 			float newvol = info.stream->input_gain(info.inputnum);
diff -Nru src-old/emu/sound.h src/emu/sound.h
--- src-old/emu/sound.h	2011-04-29 21:45:40.000000000 +0200
+++ src/emu/sound.h	2012-02-28 10:21:05.000000000 +0100
@@ -60,16 +60,15 @@
 //**************************************************************************
 
 // forward references
-class speaker_device;
 typedef struct _wav_file wav_file;
 
 
-// structure describing an indexed speaker
-struct speaker_input
+// structure describing an indexed mixer
+struct mixer_input
 {
-	speaker_device *	speaker;					// owning device
-	sound_stream *		stream;						// stream within the device
-	int					inputnum;					// input on the stream
+	device_mixer_interface *mixer;			// owning device interface
+	sound_stream *			stream;			// stream within the device
+	int						inputnum;		// input on the stream
 };
 
 
@@ -237,7 +236,7 @@
 	void system_enable(bool turn_on = true) { mute(!turn_on, MUTE_REASON_SYSTEM); }
 
 	// user gain controls
-	bool indexed_speaker_input(int index, speaker_input &info) const;
+	bool indexed_mixer_input(int index, mixer_input &info) const;
 
 private:
 	// internal helpers
diff -Nru src-old/emu/ui.c src/emu/ui.c
--- src-old/emu/ui.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/ui.c	2012-03-08 08:34:13.000000000 +0100
@@ -23,7 +23,6 @@
 #include <ctype.h>
 
 
-
 /***************************************************************************
     CONSTANTS
 ***************************************************************************/
@@ -1016,12 +1015,9 @@
 
 astring &game_info_astring(running_machine &machine, astring &string)
 {
-	screen_device_iterator scriter(machine.root_device());
-	int scrcount = scriter.count();
-	int found_sound = FALSE;
-
 	/* print description, manufacturer, and CPU: */
-	string.printf("%s\n%s %s\n\nCPU:\n", machine.system().description, machine.system().year, machine.system().manufacturer);
+	astring tempstr;
+	string.printf("%s\n%s %s\nDriver: %s\n\nCPU:\n", machine.system().description, machine.system().year, machine.system().manufacturer, core_filename_extract_base(tempstr, machine.system().source_file).cstr());
 
 	/* loop over all CPUs */
 	execute_interface_iterator execiter(machine.root_device());
@@ -1058,6 +1054,7 @@
 	/* loop over all sound chips */
 	sound_interface_iterator snditer(machine.root_device());
 	tagmap_t<UINT8> soundtags;
+	bool found_sound = false;
 	for (device_sound_interface *sound = snditer.first(); sound != NULL; sound = snditer.next())
 	{
 		if (soundtags.add(sound->device().tag(), 1, FALSE) == TMERR_DUPLICATE)
@@ -1066,7 +1063,7 @@
 		/* append the Sound: string */
 		if (!found_sound)
 			string.cat("\nSound:\n");
-		found_sound = TRUE;
+		found_sound = true;
 
 		/* count how many identical sound chips we have */
 		int count = 1;
@@ -1094,12 +1091,13 @@
 
 	/* display screen information */
 	string.cat("\nVideo:\n");
+	screen_device_iterator scriter(machine.root_device());
+	int scrcount = scriter.count();
 	if (scrcount == 0)
 		string.cat("None\n");
 	else
 	{
-		screen_device_iterator iter(machine.root_device());
-		for (screen_device *screen = iter.first(); screen != NULL; screen = iter.next())
+		for (screen_device *screen = scriter.first(); screen != NULL; screen = scriter.next())
 		{
 			if (scrcount > 1)
 			{
@@ -1654,8 +1652,8 @@
 	tailptr = &(*tailptr)->next;
 
 	/* add per-channel volume */
-	speaker_input info;
-	for (item = 0; machine.sound().indexed_speaker_input(item, info); item++)
+	mixer_input info;
+	for (item = 0; machine.sound().indexed_mixer_input(item, info); item++)
 	{
 		INT32 maxval = 2000;
 		INT32 defval = info.stream->initial_input_gain(info.inputnum) * 1000.0f + 0.5f;
@@ -1815,8 +1813,8 @@
 
 static INT32 slider_mixervol(running_machine &machine, void *arg, astring *string, INT32 newval)
 {
-	speaker_input info;
-	if (!machine.sound().indexed_speaker_input((FPTR)arg, info))
+	mixer_input info;
+	if (!machine.sound().indexed_mixer_input((FPTR)arg, info))
 		return 0;
 	if (newval != SLIDER_NOCHANGE)
 	{
diff -Nru src-old/emu/uimain.c src/emu/uimain.c
--- src-old/emu/uimain.c	2012-02-06 02:30:22.000000000 +0100
+++ src/emu/uimain.c	2012-03-04 00:19:45.000000000 +0100
@@ -308,7 +308,7 @@
 			break;
 
 		default:
-			abort();
+			fatalerror("ui_menu_main::handle - unknown reference");
 		}
 	}
 }
@@ -2631,7 +2631,7 @@
 	const game_driver *driver;
 	float width, maxwidth;
 	float x1, y1, x2, y2;
-	char tempbuf[4][256];
+	char tempbuf[5][256];
 	rgb_t color;
 	int line;
 
@@ -2678,13 +2678,16 @@
 		/* next line is year, manufacturer */
 		sprintf(&tempbuf[1][0], "%s, %-.100s", driver->year, driver->manufacturer);
 
+		/* next line source path */
+		sprintf(&tempbuf[2][0], "Driver: %-.100s", strrchr(driver->source_file, '/')+1);
+
 		/* next line is overall driver status */
 		if (driver->flags & GAME_NOT_WORKING)
-			strcpy(&tempbuf[2][0], "Overall: NOT WORKING");
+			strcpy(&tempbuf[3][0], "Overall: NOT WORKING");
 		else if (driver->flags & GAME_UNEMULATED_PROTECTION)
-			strcpy(&tempbuf[2][0], "Overall: Unemulated Protection");
+			strcpy(&tempbuf[3][0], "Overall: Unemulated Protection");
 		else
-			strcpy(&tempbuf[2][0], "Overall: Working");
+			strcpy(&tempbuf[3][0], "Overall: Working");
 
 		/* next line is graphics, sound status */
 		if (driver->flags & (GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_IMPERFECT_COLORS))
@@ -2699,7 +2702,7 @@
 		else
 			soundstat = "OK";
 
-		sprintf(&tempbuf[3][0], "Gfx: %s, Sound: %s", gfxstat, soundstat);
+		sprintf(&tempbuf[4][0], "Gfx: %s, Sound: %s", gfxstat, soundstat);
 	}
 	else
 	{
diff -Nru src-old/emu/uimenu.c src/emu/uimenu.c
--- src-old/emu/uimenu.c	2012-01-12 22:19:49.000000000 +0100
+++ src/emu/uimenu.c	2012-03-06 22:28:52.000000000 +0100
@@ -979,6 +979,7 @@
 {
 	menu->parent = menu_stack;
 	menu_stack = menu;
+	menu->reset(UI_MENU_RESET_SELECT_FIRST);
 	ui_input_reset(menu->machine());
 }
 
diff -Nru src-old/emu/video/bufsprite.c src/emu/video/bufsprite.c
--- src-old/emu/video/bufsprite.c	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/video/bufsprite.c	2012-03-08 08:39:27.000000000 +0100
@@ -0,0 +1,71 @@
+/*********************************************************************
+
+    bufsprite.h
+
+    Buffered Sprite RAM device.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+*********************************************************************/
+
+#include "emu.h"
+#include "bufsprite.h"
+
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+// device type definition
+extern const device_type BUFFERED_SPRITERAM8 = &device_creator<buffered_spriteram8_device>;
+extern const device_type BUFFERED_SPRITERAM16 = &device_creator<buffered_spriteram16_device>;
+extern const device_type BUFFERED_SPRITERAM32 = &device_creator<buffered_spriteram32_device>;
+extern const device_type BUFFERED_SPRITERAM64 = &device_creator<buffered_spriteram64_device>;
+
+
+
+/* ----- sprite buffering ----- */
+
+/* buffered sprite RAM write handlers */
+WRITE8_HANDLER( buffer_spriteram_w ) { }
+WRITE16_HANDLER( buffer_spriteram16_w ) { }
+WRITE32_HANDLER( buffer_spriteram32_w ) { }
+WRITE8_HANDLER( buffer_spriteram_2_w ) { }
+WRITE16_HANDLER( buffer_spriteram16_2_w ) { }
+WRITE32_HANDLER( buffer_spriteram32_2_w ) { }
+
+/* perform the actual buffering */
+void buffer_spriteram(running_machine &machine, UINT8 *ptr, int length) { }
+void buffer_spriteram_2(running_machine &machine, UINT8 *ptr, int length) { }
+
+
+
diff -Nru src-old/emu/video/bufsprite.h src/emu/video/bufsprite.h
--- src-old/emu/video/bufsprite.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/video/bufsprite.h	2012-03-11 18:17:00.000000000 +0100
@@ -0,0 +1,176 @@
+/*********************************************************************
+
+    bufsprite.h
+
+    Buffered Sprite RAM device.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+*********************************************************************/
+
+#pragma once
+
+#ifndef __BUFSPRITE_H__
+#define __BUFSPRITE_H__
+
+
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+// device type definition
+extern const device_type BUFFERED_SPRITERAM8;
+extern const device_type BUFFERED_SPRITERAM16;
+extern const device_type BUFFERED_SPRITERAM32;
+extern const device_type BUFFERED_SPRITERAM64;
+
+
+
+//**************************************************************************
+//  DEVICE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MCFG_BUFFERED_SPRITERAM8_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, BUFFERED_SPRITERAM8, 0) \
+
+#define MCFG_BUFFERED_SPRITERAM16_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, BUFFERED_SPRITERAM16, 0) \
+
+#define MCFG_BUFFERED_SPRITERAM32_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, BUFFERED_SPRITERAM32, 0) \
+
+#define MCFG_BUFFERED_SPRITERAM64_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, BUFFERED_SPRITERAM64, 0) \
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> buffered_spriteram_device
+
+// base class to manage buffered spriteram
+template<typename _Type>
+class buffered_spriteram_device : public device_t
+{
+public:
+	// construction
+	buffered_spriteram_device(const machine_config &mconfig, device_type type, const char *tag, device_t *owner, UINT32 clock)
+		: device_t(mconfig, type, "Buffered Sprite RAM", tag, owner, clock),
+		  m_spriteram(*owner, tag) { }
+
+	// getters
+	_Type *live() const { return m_spriteram; }
+	_Type *buffer() { return m_buffered; }
+	UINT32 bytes() const { return m_spriteram.bytes(); }
+
+	// operations
+	_Type *copy(UINT32 srcoffset = 0, UINT32 srclength = 0x7fffffff)
+	{
+		assert(m_spriteram != NULL);
+		if (m_spriteram != NULL)
+			memcpy(m_buffered, m_spriteram + srcoffset, MIN(srclength, m_spriteram.bytes() / sizeof(_Type) - srcoffset) * sizeof(_Type));
+		return m_buffered;
+	}
+
+	// read/write handlers
+	void write(address_space &space, offs_t offset, _Type data, _Type mem_mask = ~_Type(0)) { copy(); }
+
+	// VBLANK handlers
+	void vblank_copy_rising(screen_device &screen, bool state) { if (state) copy(); }
+	void vblank_copy_falling(screen_device &screen, bool state) { if (!state) copy(); }
+
+protected:
+	// first-time setup
+	virtual void device_start()
+	{
+		if (m_spriteram != NULL)
+		{
+			m_buffered.resize(m_spriteram.bytes() / sizeof(_Type));
+			save_item(NAME(m_buffered));
+		}
+	}
+
+private:
+	// internal state
+	required_shared_ptr<_Type>	m_spriteram;
+	dynamic_array<_Type>		m_buffered;
+};
+
+
+// ======================> buffered_spriteram8_device
+
+class buffered_spriteram8_device : public buffered_spriteram_device<UINT8>
+{
+public:
+	// construction
+	buffered_spriteram8_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: buffered_spriteram_device<UINT8>(mconfig, BUFFERED_SPRITERAM8, tag, owner, clock) { }
+};
+
+
+// ======================> buffered_spriteram16_device
+
+class buffered_spriteram16_device : public buffered_spriteram_device<UINT16>
+{
+public:
+	// construction
+	buffered_spriteram16_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: buffered_spriteram_device<UINT16>(mconfig, BUFFERED_SPRITERAM16, tag, owner, clock) { }
+};
+
+
+// ======================> buffered_spriteram32_device
+
+class buffered_spriteram32_device : public buffered_spriteram_device<UINT32>
+{
+public:
+	// construction
+	buffered_spriteram32_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: buffered_spriteram_device<UINT32>(mconfig, BUFFERED_SPRITERAM32, tag, owner, clock) { }
+};
+
+
+// ======================> buffered_spriteram64_device
+
+class buffered_spriteram64_device : public buffered_spriteram_device<UINT64>
+{
+public:
+	// construction
+	buffered_spriteram64_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+		: buffered_spriteram_device<UINT64>(mconfig, BUFFERED_SPRITERAM64, tag, owner, clock) { }
+};
+
+
+#endif	/* __BUFSPRITE_H__ */
diff -Nru src-old/emu/video/generic.c src/emu/video/generic.c
--- src-old/emu/video/generic.c	2012-01-17 01:25:05.000000000 +0100
+++ src/emu/video/generic.c	2012-03-08 08:39:27.000000000 +0100
@@ -235,135 +235,6 @@
 
 	machine.save().save_item(NAME(state->flip_screen_x));
 	machine.save().save_item(NAME(state->flip_screen_y));
-
-	// create spriteram buffers if necessary
-	if (machine.config().m_video_attributes & VIDEO_BUFFERS_SPRITERAM)
-	{
-		assert_always(machine.generic.spriteram_size != 0, "Video buffers spriteram but spriteram size is 0");
-
-		// allocate memory for the back buffer
-		machine.generic.buffered_spriteram.u8 = auto_alloc_array(machine, UINT8, machine.generic.spriteram_size);
-
-		// register for saving it
-		state_save_register_global_pointer(machine, machine.generic.buffered_spriteram.u8, machine.generic.spriteram_size);
-
-		// do the same for the second back buffer, if present
-		if (machine.generic.spriteram2_size)
-		{
-			// allocate memory
-			machine.generic.buffered_spriteram2.u8 = auto_alloc_array(machine, UINT8, machine.generic.spriteram2_size);
-
-			// register for saving it
-			state_save_register_global_pointer(machine, machine.generic.buffered_spriteram2.u8, machine.generic.spriteram2_size);
-		}
-	}
-}
-
-
-
-/***************************************************************************
-    GENERIC SPRITE BUFFERING
-***************************************************************************/
-
-/* Mish:  171099
-
-    'Buffered spriteram' is where the graphics hardware draws the sprites
-from private ram that the main CPU cannot access.  The main CPU typically
-prepares sprites for the next frame in it's own sprite ram as the graphics
-hardware renders sprites for the current frame from private ram.  Main CPU
-sprite ram is usually copied across to private ram by setting some flag
-in the VBL interrupt routine.
-
-    The reason for this is to avoid sprite flicker or lag - if a game
-is unable to prepare sprite ram within a frame (for example, lots of sprites
-on screen) then it doesn't trigger the buffering hardware - instead the
-graphics hardware will use the sprites from the last frame. An example is
-Dark Seal - the buffer flag is only written to if the CPU is idle at the time
-of the VBL interrupt.  If the buffering is not emulated the sprites flicker
-at busy scenes.
-
-    Some games seem to use buffering because of hardware constraints -
-Capcom games (Cps1, Last Duel, etc) render spriteram _1 frame ahead_ and
-buffer this spriteram at the end of a frame, so the _next_ frame must be drawn
-from the buffer.  Presumably the graphics hardware and the main cpu cannot
-share the same spriteram for whatever reason.
-
-    Sprite buffering & Mame:
-
-    To use sprite buffering in a driver use VIDEO_BUFFERS_SPRITERAM in the
-machine driver.  This will automatically create an area for buffered spriteram
-equal to the size of normal spriteram.
-
-    Spriteram size _must_ be declared in the memory map:
-
-    AM_RANGE(0x120000, 0x1207ff) AM_RAMBANK("sprites") AM_BASE_SIZE_GENERIC(spriteram)
-
-    Then the video driver must draw the sprites from the buffered_spriteram
-pointer.  The function buffer_spriteram_w() is used to simulate hardware
-which buffers the spriteram from a memory location write.  The function
-buffer_spriteram(UINT8 *ptr, int length) can be used where
-more control is needed over what is buffered.
-
-    For examples see darkseal.c, contra.c, lastduel.c, bionicc.c etc.
-
-*/
-
-
-/*-------------------------------------------------
-    buffer_spriteram_w - triggered writes to
-    buffer spriteram
--------------------------------------------------*/
-
-WRITE8_HANDLER( buffer_spriteram_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram.u8, space->machine().generic.spriteram.u8, space->machine().generic.spriteram_size);
-}
-
-WRITE16_HANDLER( buffer_spriteram16_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram.u16, space->machine().generic.spriteram.u16, space->machine().generic.spriteram_size);
-}
-
-WRITE32_HANDLER( buffer_spriteram32_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram.u32, space->machine().generic.spriteram.u32, space->machine().generic.spriteram_size);
-}
-
-
-/*-------------------------------------------------
-    buffer_spriteram_2_w - triggered writes to
-    buffer spriteram_2
--------------------------------------------------*/
-
-WRITE8_HANDLER( buffer_spriteram_2_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram2.u8, space->machine().generic.spriteram2.u8, space->machine().generic.spriteram2_size);
-}
-
-WRITE16_HANDLER( buffer_spriteram16_2_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram2.u16, space->machine().generic.spriteram2.u16, space->machine().generic.spriteram2_size);
-}
-
-WRITE32_HANDLER( buffer_spriteram32_2_w )
-{
-	memcpy(space->machine().generic.buffered_spriteram2.u32, space->machine().generic.spriteram2.u32, space->machine().generic.spriteram2_size);
-}
-
-
-/*-------------------------------------------------
-    buffer_spriteram - for manually buffering
-    spriteram
--------------------------------------------------*/
-
-void buffer_spriteram(running_machine &machine, UINT8 *ptr, int length)
-{
-	memcpy(machine.generic.buffered_spriteram.u8, ptr, length);
-}
-
-void buffer_spriteram_2(running_machine &machine, UINT8 *ptr, int length)
-{
-	memcpy(machine.generic.buffered_spriteram2.u8, ptr, length);
 }
 
 
diff -Nru src-old/emu/video/generic.h src/emu/video/generic.h
--- src-old/emu/video/generic.h	2012-01-02 08:37:22.000000000 +0100
+++ src/emu/video/generic.h	2012-03-08 08:39:27.000000000 +0100
@@ -42,22 +42,6 @@
 
 
 
-/* ----- sprite buffering ----- */
-
-/* buffered sprite RAM write handlers */
-WRITE8_HANDLER( buffer_spriteram_w );
-WRITE16_HANDLER( buffer_spriteram16_w );
-WRITE32_HANDLER( buffer_spriteram32_w );
-WRITE8_HANDLER( buffer_spriteram_2_w );
-WRITE16_HANDLER( buffer_spriteram16_2_w );
-WRITE32_HANDLER( buffer_spriteram32_2_w );
-
-/* perform the actual buffering */
-void buffer_spriteram(running_machine &machine, UINT8 *ptr, int length);
-void buffer_spriteram_2(running_machine &machine, UINT8 *ptr, int length);
-
-
-
 /* ----- global attributes ----- */
 
 /* set global attributes */
diff -Nru src-old/lib/formats/ap_dsk35.c src/lib/formats/ap_dsk35.c
--- src-old/lib/formats/ap_dsk35.c	2012-01-25 10:52:18.000000000 +0100
+++ src/lib/formats/ap_dsk35.c	2012-02-29 10:13:22.000000000 +0100
@@ -1300,7 +1300,7 @@
 	UINT8 format = h[0x51];
 
 	if((encoding != 0x00 || format != 0x02) && (encoding != 0x01 || format != 0x22)) {
-		logerror("dc42: Unsupported encoding/format combination %02x\%02x\n", encoding, format);
+		logerror("dc42: Unsupported encoding/format combination %02x/%02x\n", encoding, format);
 		return false;
 	}
 
diff -Nru src-old/lib/lib.mak src/lib/lib.mak
--- src-old/lib/lib.mak	2012-02-16 10:47:18.000000000 +0100
+++ src/lib/lib.mak	2012-03-11 18:17:00.000000000 +0100
@@ -281,7 +281,25 @@
 # libflac library objects
 #-------------------------------------------------
 
-FLACOPTS=-DFLAC__NO_ASM -DHAVE_INTTYPES_H -DHAVE_ICONV -DHAVE_LANGINFO_CODESET -DHAVE_SOCKLEN_T -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
+ifeq ($(TARGETOS),macosx)
+ifdef BIGENDIAN
+ifeq ($(PTR64),1)
+ARCHFLAGS = -arch ppc64 -DWORDS_BIGENDIAN=1
+else
+ARCHFLAGS = -arch ppc -DWORDS_BIGENDIAN=1
+endif
+else	# BIGENDIAN
+ifeq ($(PTR64),1)
+ARCHFLAGS = -arch x86_64 -DWORDS_BIGENDIAN=0
+else
+ARCHFLAGS = -m32 -arch i386 -DWORDS_BIGENDIAN=0
+endif
+endif	# BIGENDIAN
+else    # ifeq ($(TARGETOS),macosx)
+ARCHFLAGS = -DWORDS_BIGENDIAN=0
+endif   # ifeq ($(TARGETOS),macosx)
+
+FLACOPTS=-DFLAC__NO_ASM -DHAVE_INTTYPES_H -DHAVE_ICONV -DHAVE_LANGINFO_CODESET -DHAVE_SOCKLEN_T -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 $(ARCHFLAGS)
 
 LIBFLACOBJS = \
 	$(LIBOBJ)/libflac/bitmath.o \
diff -Nru src-old/lib/lib7z/CpuArch.h src/lib/lib7z/CpuArch.h
--- src-old/lib/lib7z/CpuArch.h	2012-02-12 18:55:51.000000000 +0100
+++ src/lib/lib7z/CpuArch.h	2012-02-29 10:13:22.000000000 +0100
@@ -98,6 +98,7 @@
 #endif
 
 #if defined(MY_CPU_LE_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)
+#include <stdlib.h>
 
 #pragma intrinsic(_byteswap_ulong)
 #pragma intrinsic(_byteswap_uint64)
diff -Nru src-old/lib/libflac/libflac/bitreader.c src/lib/libflac/libflac/bitreader.c
--- src-old/lib/libflac/libflac/bitreader.c	2012-01-29 17:34:26.000000000 +0100
+++ src/lib/libflac/libflac/bitreader.c	2012-03-04 16:25:10.000000000 +0100
@@ -143,13 +143,15 @@
 };
 
 
+#if !WORDS_BIGENDIAN
 static FLAC__uint32 local_swap32_(FLAC__uint32 x)
 {
 	x = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
 	return (x>>16) | (x<<16);
 }
+#endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 /* OPT: an MSVC built-in would be better */
 static void local_swap32_block_(FLAC__uint32 *start, FLAC__uint32 len)
 {
@@ -258,7 +260,7 @@
 #if WORDS_BIGENDIAN
 #else
 	end = (br->words*FLAC__BYTES_PER_WORD + br->bytes + bytes + (FLAC__BYTES_PER_WORD-1)) / FLAC__BYTES_PER_WORD;
-# if defined(_MSC_VER) && (FLAC__BYTES_PER_WORD == 4)
+# if defined(_MSC_VER) && (FLAC__BYTES_PER_WORD == 4) && defined(_M_IX86)
 	if(br->cpu_info.type == FLAC__CPUINFO_TYPE_IA32 && br->cpu_info.data.ia32.bswap) {
 		start = br->words;
 		local_swap32_block_(br->buffer + start, end - start);
diff -Nru src-old/lib/libflac/libflac/bitwriter.c src/lib/libflac/libflac/bitwriter.c
--- src-old/lib/libflac/libflac/bitwriter.c	2012-01-29 17:34:26.000000000 +0100
+++ src/lib/libflac/libflac/bitwriter.c	2012-03-04 16:25:10.000000000 +0100
@@ -103,12 +103,13 @@
 
 
 /* OPT: an MSVC built-in would be better */
+#if !WORDS_BIGENDIAN
 static FLAC__uint32 local_swap32_(FLAC__uint32 x)
 {
 	x = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
 	return (x>>16) | (x<<16);
 }
-
+#endif
 
 /* * WATCHOUT: The current implementation only grows the buffer. */
 static FLAC__bool bitwriter_grow_(FLAC__BitWriter *bw, unsigned bits_to_add)
diff -Nru src-old/lib/libflac/libflac++/metadata.cpp src/lib/libflac/libflac++/metadata.cpp
--- src-old/lib/libflac/libflac++/metadata.cpp	2012-01-22 19:38:22.000000000 +0100
+++ src/lib/libflac/libflac++/metadata.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1589 +0,0 @@
-/* libFLAC++ - Free Lossless Audio Codec library
- * Copyright (C) 2002,2003,2004,2005,2006,2007  Josh Coalson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * - Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * - Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * - Neither the name of the Xiph.org Foundation nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#define __STDC_LIMIT_MACROS 1 /* otherwise SIZE_MAX is not defined for c++ */
-#include "share/alloc.h"
-#include "flac++/metadata.h"
-#include "flac/assert.h"
-#include <stdlib.h> // for malloc(), free()
-#include <string.h> // for memcpy() etc.
-
-#ifdef _MSC_VER
-// warning C4800: 'int' : forcing to bool 'true' or 'false' (performance warning)
-#pragma warning ( disable : 4800 )
-#endif
-
-namespace FLAC {
-	namespace Metadata {
-
-		// local utility routines
-
-		namespace local {
-
-			Prototype *construct_block(::FLAC__StreamMetadata *object)
-			{
-				Prototype *ret = 0;
-				switch(object->type) {
-					case FLAC__METADATA_TYPE_STREAMINFO:
-						ret = new StreamInfo(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_PADDING:
-						ret = new Padding(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_APPLICATION:
-						ret = new Application(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_SEEKTABLE:
-						ret = new SeekTable(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_VORBIS_COMMENT:
-						ret = new VorbisComment(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_CUESHEET:
-						ret = new CueSheet(object, /*copy=*/false);
-						break;
-					case FLAC__METADATA_TYPE_PICTURE:
-						ret = new Picture(object, /*copy=*/false);
-						break;
-					default:
-						ret = new Unknown(object, /*copy=*/false);
-						break;
-				}
-				return ret;
-			}
-
-		}
-
-		FLACPP_API Prototype *clone(const Prototype *object)
-		{
-			FLAC__ASSERT(0 != object);
-
-			const StreamInfo *streaminfo = dynamic_cast<const StreamInfo *>(object);
-			const Padding *padding = dynamic_cast<const Padding *>(object);
-			const Application *application = dynamic_cast<const Application *>(object);
-			const SeekTable *seektable = dynamic_cast<const SeekTable *>(object);
-			const VorbisComment *vorbiscomment = dynamic_cast<const VorbisComment *>(object);
-			const CueSheet *cuesheet = dynamic_cast<const CueSheet *>(object);
-			const Picture *picture = dynamic_cast<const Picture *>(object);
-			const Unknown *unknown = dynamic_cast<const Unknown *>(object);
-
-			if(0 != streaminfo)
-				return new StreamInfo(*streaminfo);
-			else if(0 != padding)
-				return new Padding(*padding);
-			else if(0 != application)
-				return new Application(*application);
-			else if(0 != seektable)
-				return new SeekTable(*seektable);
-			else if(0 != vorbiscomment)
-				return new VorbisComment(*vorbiscomment);
-			else if(0 != cuesheet)
-				return new CueSheet(*cuesheet);
-			else if(0 != picture)
-				return new Picture(*picture);
-			else if(0 != unknown)
-				return new Unknown(*unknown);
-			else {
-				FLAC__ASSERT(0);
-				return 0;
-			}
-		}
-
-		//
-		// Prototype
-		//
-
-		Prototype::Prototype(const Prototype &object):
-		object_(::FLAC__metadata_object_clone(object.object_)),
-		is_reference_(false)
-		{
-			FLAC__ASSERT(object.is_valid());
-		}
-
-		Prototype::Prototype(const ::FLAC__StreamMetadata &object):
-		object_(::FLAC__metadata_object_clone(&object)),
-		is_reference_(false)
-		{
-		}
-
-		Prototype::Prototype(const ::FLAC__StreamMetadata *object):
-		object_(::FLAC__metadata_object_clone(object)),
-		is_reference_(false)
-		{
-			FLAC__ASSERT(0 != object);
-		}
-
-		Prototype::Prototype(::FLAC__StreamMetadata *object, bool copy):
-		object_(copy? ::FLAC__metadata_object_clone(object) : object),
-		is_reference_(false)
-		{
-			FLAC__ASSERT(0 != object);
-		}
-
-		Prototype::~Prototype()
-		{
-			clear();
-		}
-
-		void Prototype::clear()
-		{
-			if(0 != object_ && !is_reference_)
-				FLAC__metadata_object_delete(object_);
-			object_ = 0;
-		}
-
-		Prototype &Prototype::operator=(const Prototype &object)
-		{
-			FLAC__ASSERT(object.is_valid());
-			clear();
-			is_reference_ = false;
-			object_ = ::FLAC__metadata_object_clone(object.object_);
-			return *this;
-		}
-
-		Prototype &Prototype::operator=(const ::FLAC__StreamMetadata &object)
-		{
-			clear();
-			is_reference_ = false;
-			object_ = ::FLAC__metadata_object_clone(&object);
-			return *this;
-		}
-
-		Prototype &Prototype::operator=(const ::FLAC__StreamMetadata *object)
-		{
-			FLAC__ASSERT(0 != object);
-			clear();
-			is_reference_ = false;
-			object_ = ::FLAC__metadata_object_clone(object);
-			return *this;
-		}
-
-		Prototype &Prototype::assign_object(::FLAC__StreamMetadata *object, bool copy)
-		{
-			FLAC__ASSERT(0 != object);
-			clear();
-			object_ = (copy? ::FLAC__metadata_object_clone(object) : object);
-			is_reference_ = false;
-			return *this;
-		}
-
-		bool Prototype::get_is_last() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)object_->is_last;
-		}
-
-		FLAC__MetadataType Prototype::get_type() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->type;
-		}
-
-		unsigned Prototype::get_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->length;
-		}
-
-		void Prototype::set_is_last(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			object_->is_last = value;
-		}
-
-
-		//
-		// StreamInfo
-		//
-
-		StreamInfo::StreamInfo():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_STREAMINFO), /*copy=*/false)
-		{ }
-
-		StreamInfo::~StreamInfo()
-		{ }
-
-		unsigned StreamInfo::get_min_blocksize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.min_blocksize;
-		}
-
-		unsigned StreamInfo::get_max_blocksize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.max_blocksize;
-		}
-
-		unsigned StreamInfo::get_min_framesize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.min_framesize;
-		}
-
-		unsigned StreamInfo::get_max_framesize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.max_framesize;
-		}
-
-		unsigned StreamInfo::get_sample_rate() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.sample_rate;
-		}
-
-		unsigned StreamInfo::get_channels() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.channels;
-		}
-
-		unsigned StreamInfo::get_bits_per_sample() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.bits_per_sample;
-		}
-
-		FLAC__uint64 StreamInfo::get_total_samples() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.total_samples;
-		}
-
-		const FLAC__byte *StreamInfo::get_md5sum() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.stream_info.md5sum;
-		}
-
-		void StreamInfo::set_min_blocksize(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value >= FLAC__MIN_BLOCK_SIZE);
-			FLAC__ASSERT(value <= FLAC__MAX_BLOCK_SIZE);
-			object_->data.stream_info.min_blocksize = value;
-		}
-
-		void StreamInfo::set_max_blocksize(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value >= FLAC__MIN_BLOCK_SIZE);
-			FLAC__ASSERT(value <= FLAC__MAX_BLOCK_SIZE);
-			object_->data.stream_info.max_blocksize = value;
-		}
-
-		void StreamInfo::set_min_framesize(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value < (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN));
-			object_->data.stream_info.min_framesize = value;
-		}
-
-		void StreamInfo::set_max_framesize(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value < (1u << FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN));
-			object_->data.stream_info.max_framesize = value;
-		}
-
-		void StreamInfo::set_sample_rate(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(FLAC__format_sample_rate_is_valid(value));
-			object_->data.stream_info.sample_rate = value;
-		}
-
-		void StreamInfo::set_channels(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value > 0);
-			FLAC__ASSERT(value <= FLAC__MAX_CHANNELS);
-			object_->data.stream_info.channels = value;
-		}
-
-		void StreamInfo::set_bits_per_sample(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value >= FLAC__MIN_BITS_PER_SAMPLE);
-			FLAC__ASSERT(value <= FLAC__MAX_BITS_PER_SAMPLE);
-			object_->data.stream_info.bits_per_sample = value;
-		}
-
-		void StreamInfo::set_total_samples(FLAC__uint64 value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value < (((FLAC__uint64)1) << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN));
-			object_->data.stream_info.total_samples = value;
-		}
-
-		void StreamInfo::set_md5sum(const FLAC__byte value[16])
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != value);
-			memcpy(object_->data.stream_info.md5sum, value, 16);
-		}
-
-
-		//
-		// Padding
-		//
-
-		Padding::Padding():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_PADDING), /*copy=*/false)
-		{ }
-
-		Padding::~Padding()
-		{ }
-
-		void Padding::set_length(unsigned length)
-		{
-			FLAC__ASSERT(is_valid());
-			object_->length = length;
-		}
-
-
-		//
-		// Application
-		//
-
-		Application::Application():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_APPLICATION), /*copy=*/false)
-		{ }
-
-		Application::~Application()
-		{ }
-
-		const FLAC__byte *Application::get_id() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.application.id;
-		}
-
-		const FLAC__byte *Application::get_data() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.application.data;
-		}
-
-		void Application::set_id(const FLAC__byte value[4])
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != value);
-			memcpy(object_->data.application.id, value, 4);
-		}
-
-		bool Application::set_data(const FLAC__byte *data, unsigned length)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_application_set_data(object_, (FLAC__byte*)data, length, true);
-		}
-
-		bool Application::set_data(FLAC__byte *data, unsigned length, bool copy)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_application_set_data(object_, data, length, copy);
-		}
-
-
-		//
-		// SeekTable
-		//
-
-		SeekTable::SeekTable():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_SEEKTABLE), /*copy=*/false)
-		{ }
-
-		SeekTable::~SeekTable()
-		{ }
-
-		unsigned SeekTable::get_num_points() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.seek_table.num_points;
-		}
-
-		::FLAC__StreamMetadata_SeekPoint SeekTable::get_point(unsigned index) const
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.seek_table.num_points);
-			return object_->data.seek_table.points[index];
-		}
-
-		void SeekTable::set_point(unsigned index, const ::FLAC__StreamMetadata_SeekPoint &point)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.seek_table.num_points);
-			::FLAC__metadata_object_seektable_set_point(object_, index, point);
-		}
-
-		bool SeekTable::insert_point(unsigned index, const ::FLAC__StreamMetadata_SeekPoint &point)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index <= object_->data.seek_table.num_points);
-			return (bool)::FLAC__metadata_object_seektable_insert_point(object_, index, point);
-		}
-
-		bool SeekTable::delete_point(unsigned index)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.seek_table.num_points);
-			return (bool)::FLAC__metadata_object_seektable_delete_point(object_, index);
-		}
-
-		bool SeekTable::is_legal() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_seektable_is_legal(object_);
-		}
-
-
-		//
-		// VorbisComment::Entry
-		//
-
-		VorbisComment::Entry::Entry()
-		{
-			zero();
-		}
-
-		VorbisComment::Entry::Entry(const char *field, unsigned field_length)
-		{
-			zero();
-			construct(field, field_length);
-		}
-
-		VorbisComment::Entry::Entry(const char *field)
-		{
-			zero();
-			construct(field);
-		}
-
-		VorbisComment::Entry::Entry(const char *field_name, const char *field_value, unsigned field_value_length)
-		{
-			zero();
-			construct(field_name, field_value, field_value_length);
-		}
-
-		VorbisComment::Entry::Entry(const char *field_name, const char *field_value)
-		{
-			zero();
-			construct(field_name, field_value);
-		}
-
-		VorbisComment::Entry::Entry(const Entry &entry)
-		{
-			FLAC__ASSERT(entry.is_valid());
-			zero();
-			construct((const char *)entry.entry_.entry, entry.entry_.length);
-		}
-
-		VorbisComment::Entry &VorbisComment::Entry::operator=(const Entry &entry)
-		{
-			FLAC__ASSERT(entry.is_valid());
-			clear();
-			construct((const char *)entry.entry_.entry, entry.entry_.length);
-			return *this;
-		}
-
-		VorbisComment::Entry::~Entry()
-		{
-			clear();
-		}
-
-		bool VorbisComment::Entry::is_valid() const
-		{
-			return is_valid_;
-		}
-
-		unsigned VorbisComment::Entry::get_field_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return entry_.length;
-		}
-
-		unsigned VorbisComment::Entry::get_field_name_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return field_name_length_;
-		}
-
-		unsigned VorbisComment::Entry::get_field_value_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return field_value_length_;
-		}
-
-		::FLAC__StreamMetadata_VorbisComment_Entry VorbisComment::Entry::get_entry() const
-		{
-			FLAC__ASSERT(is_valid());
-			return entry_;
-		}
-
-		const char *VorbisComment::Entry::get_field() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (const char *)entry_.entry;
-		}
-
-		const char *VorbisComment::Entry::get_field_name() const
-		{
-			FLAC__ASSERT(is_valid());
-			return field_name_;
-		}
-
-		const char *VorbisComment::Entry::get_field_value() const
-		{
-			FLAC__ASSERT(is_valid());
-			return field_value_;
-		}
-
-		bool VorbisComment::Entry::set_field(const char *field, unsigned field_length)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != field);
-
-			if(!::FLAC__format_vorbiscomment_entry_is_legal((const ::FLAC__byte*)field, field_length))
-				return is_valid_ = false;
-
-			clear_entry();
-
-			if(0 == (entry_.entry = (FLAC__byte*)safe_malloc_add_2op_(field_length, /*+*/1))) {
-				is_valid_ = false;
-			}
-			else {
-				entry_.length = field_length;
-				memcpy(entry_.entry, field, field_length);
-				entry_.entry[field_length] = '\0';
-				(void) parse_field();
-			}
-
-			return is_valid_;
-		}
-
-		bool VorbisComment::Entry::set_field(const char *field)
-		{
-			return set_field(field, strlen(field));
-		}
-
-		bool VorbisComment::Entry::set_field_name(const char *field_name)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != field_name);
-
-			if(!::FLAC__format_vorbiscomment_entry_name_is_legal(field_name))
-				return is_valid_ = false;
-
-			clear_field_name();
-
-			if(0 == (field_name_ = strdup(field_name))) {
-				is_valid_ = false;
-			}
-			else {
-				field_name_length_ = strlen(field_name_);
-				compose_field();
-			}
-
-			return is_valid_;
-		}
-
-		bool VorbisComment::Entry::set_field_value(const char *field_value, unsigned field_value_length)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != field_value);
-
-			if(!::FLAC__format_vorbiscomment_entry_value_is_legal((const FLAC__byte*)field_value, field_value_length))
-				return is_valid_ = false;
-
-			clear_field_value();
-
-			if(0 == (field_value_ = (char *)safe_malloc_add_2op_(field_value_length, /*+*/1))) {
-				is_valid_ = false;
-			}
-			else {
-				field_value_length_ = field_value_length;
-				memcpy(field_value_, field_value, field_value_length);
-				field_value_[field_value_length] = '\0';
-				compose_field();
-			}
-
-			return is_valid_;
-		}
-
-		bool VorbisComment::Entry::set_field_value(const char *field_value)
-		{
-			return set_field_value(field_value, strlen(field_value));
-		}
-
-		void VorbisComment::Entry::zero()
-		{
-			is_valid_ = true;
-			entry_.length = 0;
-			entry_.entry = 0;
-			field_name_ = 0;
-			field_name_length_ = 0;
-			field_value_ = 0;
-			field_value_length_ = 0;
-		}
-
-		void VorbisComment::Entry::clear()
-		{
-			clear_entry();
-			clear_field_name();
-			clear_field_value();
-			is_valid_ = true;
-		}
-
-		void VorbisComment::Entry::clear_entry()
-		{
-			if(0 != entry_.entry) {
-				free(entry_.entry);
-				entry_.entry = 0;
-				entry_.length = 0;
-			}
-		}
-
-		void VorbisComment::Entry::clear_field_name()
-		{
-			if(0 != field_name_) {
-				free(field_name_);
-				field_name_ = 0;
-				field_name_length_ = 0;
-			}
-		}
-
-		void VorbisComment::Entry::clear_field_value()
-		{
-			if(0 != field_value_) {
-				free(field_value_);
-				field_value_ = 0;
-				field_value_length_ = 0;
-			}
-		}
-
-		void VorbisComment::Entry::construct(const char *field, unsigned field_length)
-		{
-			if(set_field(field, field_length))
-				parse_field();
-		}
-
-		void VorbisComment::Entry::construct(const char *field)
-		{
-			construct(field, strlen(field));
-		}
-
-		void VorbisComment::Entry::construct(const char *field_name, const char *field_value, unsigned field_value_length)
-		{
-			if(set_field_name(field_name) && set_field_value(field_value, field_value_length))
-				compose_field();
-		}
-
-		void VorbisComment::Entry::construct(const char *field_name, const char *field_value)
-		{
-			construct(field_name, field_value, strlen(field_value));
-		}
-
-		void VorbisComment::Entry::compose_field()
-		{
-			clear_entry();
-
-			if(0 == (entry_.entry = (FLAC__byte*)safe_malloc_add_4op_(field_name_length_, /*+*/1, /*+*/field_value_length_, /*+*/1))) {
-				is_valid_ = false;
-			}
-			else {
-				memcpy(entry_.entry, field_name_, field_name_length_);
-				entry_.length += field_name_length_;
-				memcpy(entry_.entry + entry_.length, "=", 1);
-				entry_.length += 1;
-				memcpy(entry_.entry + entry_.length, field_value_, field_value_length_);
-				entry_.length += field_value_length_;
-				entry_.entry[entry_.length] = '\0';
-				is_valid_ = true;
-			}
-		}
-
-		void VorbisComment::Entry::parse_field()
-		{
-			clear_field_name();
-			clear_field_value();
-
-			const char *p = (const char *)memchr(entry_.entry, '=', entry_.length);
-
-			if(0 == p)
-				p = (const char *)entry_.entry + entry_.length;
-
-			field_name_length_ = (unsigned)(p - (const char *)entry_.entry);
-			if(0 == (field_name_ = (char *)safe_malloc_add_2op_(field_name_length_, /*+*/1))) { // +1 for the trailing \0
-				is_valid_ = false;
-				return;
-			}
-			memcpy(field_name_, entry_.entry, field_name_length_);
-			field_name_[field_name_length_] = '\0';
-
-			if(entry_.length - field_name_length_ == 0) {
-				field_value_length_ = 0;
-				if(0 == (field_value_ = (char *)safe_malloc_(0))) {
-					is_valid_ = false;
-					return;
-				}
-			}
-			else {
-				field_value_length_ = entry_.length - field_name_length_ - 1;
-				if(0 == (field_value_ = (char *)safe_malloc_add_2op_(field_value_length_, /*+*/1))) { // +1 for the trailing \0
-					is_valid_ = false;
-					return;
-				}
-				memcpy(field_value_, ++p, field_value_length_);
-				field_value_[field_value_length_] = '\0';
-			}
-
-			is_valid_ = true;
-		}
-
-
-		//
-		// VorbisComment
-		//
-
-		VorbisComment::VorbisComment():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_VORBIS_COMMENT), /*copy=*/false)
-		{ }
-
-		VorbisComment::~VorbisComment()
-		{ }
-
-		unsigned VorbisComment::get_num_comments() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.vorbis_comment.num_comments;
-		}
-
-		const FLAC__byte *VorbisComment::get_vendor_string() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.vorbis_comment.vendor_string.entry;
-		}
-
-		VorbisComment::Entry VorbisComment::get_comment(unsigned index) const
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.vorbis_comment.num_comments);
-			return Entry((const char *)object_->data.vorbis_comment.comments[index].entry, object_->data.vorbis_comment.comments[index].length);
-		}
-
-		bool VorbisComment::set_vendor_string(const FLAC__byte *string)
-		{
-			FLAC__ASSERT(is_valid());
-			// vendor_string is a special kind of entry
-			const ::FLAC__StreamMetadata_VorbisComment_Entry vendor_string = { strlen((const char *)string), (FLAC__byte*)string }; // we can cheat on const-ness because we make a copy below:
-			return (bool)::FLAC__metadata_object_vorbiscomment_set_vendor_string(object_, vendor_string, /*copy=*/true);
-		}
-
-		bool VorbisComment::set_comment(unsigned index, const VorbisComment::Entry &entry)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.vorbis_comment.num_comments);
-			return (bool)::FLAC__metadata_object_vorbiscomment_set_comment(object_, index, entry.get_entry(), /*copy=*/true);
-		}
-
-		bool VorbisComment::insert_comment(unsigned index, const VorbisComment::Entry &entry)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index <= object_->data.vorbis_comment.num_comments);
-			return (bool)::FLAC__metadata_object_vorbiscomment_insert_comment(object_, index, entry.get_entry(), /*copy=*/true);
-		}
-
-		bool VorbisComment::append_comment(const VorbisComment::Entry &entry)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_vorbiscomment_append_comment(object_, entry.get_entry(), /*copy=*/true);
-		}
-
-		bool VorbisComment::delete_comment(unsigned index)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(index < object_->data.vorbis_comment.num_comments);
-			return (bool)::FLAC__metadata_object_vorbiscomment_delete_comment(object_, index);
-		}
-
-
-		//
-		// CueSheet::Track
-		//
-
-		CueSheet::Track::Track():
-		object_(::FLAC__metadata_object_cuesheet_track_new())
-		{ }
-
-		CueSheet::Track::Track(const ::FLAC__StreamMetadata_CueSheet_Track *track):
-		object_(::FLAC__metadata_object_cuesheet_track_clone(track))
-		{ }
-
-		CueSheet::Track::Track(const Track &track):
-		object_(::FLAC__metadata_object_cuesheet_track_clone(track.object_))
-		{ }
-
-		CueSheet::Track &CueSheet::Track::operator=(const Track &track)
-		{
-			if(0 != object_)
-				::FLAC__metadata_object_cuesheet_track_delete(object_);
-			object_ = ::FLAC__metadata_object_cuesheet_track_clone(track.object_);
-			return *this;
-		}
-
-		CueSheet::Track::~Track()
-		{
-			if(0 != object_)
-				::FLAC__metadata_object_cuesheet_track_delete(object_);
-		}
-
-		bool CueSheet::Track::is_valid() const
-		{
-			return(0 != object_);
-		}
-
-		::FLAC__StreamMetadata_CueSheet_Index CueSheet::Track::get_index(unsigned i) const
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(i < object_->num_indices);
-			return object_->indices[i];
-		}
-
-		void CueSheet::Track::set_isrc(const char value[12])
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != value);
-			memcpy(object_->isrc, value, 12);
-			object_->isrc[12] = '\0';
-		}
-
-		void CueSheet::Track::set_type(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(value <= 1);
-			object_->type = value;
-		}
-
- 		void CueSheet::Track::set_index(unsigned i, const ::FLAC__StreamMetadata_CueSheet_Index &index)
- 		{
- 			FLAC__ASSERT(is_valid());
- 			FLAC__ASSERT(i < object_->num_indices);
- 			object_->indices[i] = index;
- 		}
-
-
-		//
-		// CueSheet
-		//
-
-		CueSheet::CueSheet():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_CUESHEET), /*copy=*/false)
-		{ }
-
-		CueSheet::~CueSheet()
-		{ }
-
-		const char *CueSheet::get_media_catalog_number() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.cue_sheet.media_catalog_number;
-		}
-
-		FLAC__uint64 CueSheet::get_lead_in() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.cue_sheet.lead_in;
-		}
-
-		bool CueSheet::get_is_cd() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.cue_sheet.is_cd? true : false;
-		}
-
-		unsigned CueSheet::get_num_tracks() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.cue_sheet.num_tracks;
-		}
-
-		CueSheet::Track CueSheet::get_track(unsigned i) const
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(i < object_->data.cue_sheet.num_tracks);
-			return Track(object_->data.cue_sheet.tracks + i);
-		}
-
-		void CueSheet::set_media_catalog_number(const char value[128])
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(0 != value);
-			memcpy(object_->data.cue_sheet.media_catalog_number, value, 128);
-			object_->data.cue_sheet.media_catalog_number[128] = '\0';
-		}
-
-		void CueSheet::set_lead_in(FLAC__uint64 value)
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.cue_sheet.lead_in = value;
-		}
-
-		void CueSheet::set_is_cd(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.cue_sheet.is_cd = value;
-		}
-
-		void CueSheet::set_index(unsigned track_num, unsigned index_num, const ::FLAC__StreamMetadata_CueSheet_Index &index)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(track_num < object_->data.cue_sheet.num_tracks);
-			FLAC__ASSERT(index_num < object_->data.cue_sheet.tracks[track_num].num_indices);
-			object_->data.cue_sheet.tracks[track_num].indices[index_num] = index;
-		}
-
-		bool CueSheet::insert_index(unsigned track_num, unsigned index_num, const ::FLAC__StreamMetadata_CueSheet_Index &index)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(track_num < object_->data.cue_sheet.num_tracks);
-			FLAC__ASSERT(index_num <= object_->data.cue_sheet.tracks[track_num].num_indices);
-			return (bool)::FLAC__metadata_object_cuesheet_track_insert_index(object_, track_num, index_num, index);
-		}
-
-		bool CueSheet::delete_index(unsigned track_num, unsigned index_num)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(track_num < object_->data.cue_sheet.num_tracks);
-			FLAC__ASSERT(index_num < object_->data.cue_sheet.tracks[track_num].num_indices);
-			return (bool)::FLAC__metadata_object_cuesheet_track_delete_index(object_, track_num, index_num);
-		}
-
-		bool CueSheet::set_track(unsigned i, const CueSheet::Track &track)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(i < object_->data.cue_sheet.num_tracks);
-			// We can safely const_cast since copy=true
-			return (bool)::FLAC__metadata_object_cuesheet_set_track(object_, i, const_cast< ::FLAC__StreamMetadata_CueSheet_Track*>(track.get_track()), /*copy=*/true);
-		}
-
-		bool CueSheet::insert_track(unsigned i, const CueSheet::Track &track)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(i <= object_->data.cue_sheet.num_tracks);
-			// We can safely const_cast since copy=true
-			return (bool)::FLAC__metadata_object_cuesheet_insert_track(object_, i, const_cast< ::FLAC__StreamMetadata_CueSheet_Track*>(track.get_track()), /*copy=*/true);
-		}
-
-		bool CueSheet::delete_track(unsigned i)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(i < object_->data.cue_sheet.num_tracks);
-			return (bool)::FLAC__metadata_object_cuesheet_delete_track(object_, i);
-		}
-
-		bool CueSheet::is_legal(bool check_cd_da_subset, const char **violation) const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_cuesheet_is_legal(object_, check_cd_da_subset, violation);
-		}
-
-		FLAC__uint32 CueSheet::calculate_cddb_id() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__metadata_object_cuesheet_calculate_cddb_id(object_);
-		}
-
-
-		//
-		// Picture
-		//
-
-		Picture::Picture():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_PICTURE), /*copy=*/false)
-		{ }
-
-		Picture::~Picture()
-		{ }
-
-		::FLAC__StreamMetadata_Picture_Type Picture::get_type() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.type;
-		}
-
-		const char *Picture::get_mime_type() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.mime_type;
-		}
-
-		const FLAC__byte *Picture::get_description() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.description;
-		}
-
-		FLAC__uint32 Picture::get_width() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.width;
-		}
-
-		FLAC__uint32 Picture::get_height() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.height;
-		}
-
-		FLAC__uint32 Picture::get_depth() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.depth;
-		}
-
-		FLAC__uint32 Picture::get_colors() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.colors;
-		}
-
-		FLAC__uint32 Picture::get_data_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.data_length;
-		}
-
-		const FLAC__byte *Picture::get_data() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.picture.data;
-		}
-
-		void Picture::set_type(::FLAC__StreamMetadata_Picture_Type type)
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.picture.type = type;
-		}
-
-		bool Picture::set_mime_type(const char *string)
-		{
-			FLAC__ASSERT(is_valid());
-			// We can safely const_cast since copy=true
-			return (bool)::FLAC__metadata_object_picture_set_mime_type(object_, const_cast<char*>(string), /*copy=*/true);
-		}
-
-		bool Picture::set_description(const FLAC__byte *string)
-		{
-			FLAC__ASSERT(is_valid());
-			// We can safely const_cast since copy=true
-			return (bool)::FLAC__metadata_object_picture_set_description(object_, const_cast<FLAC__byte*>(string), /*copy=*/true);
-		}
-
-		void Picture::set_width(FLAC__uint32 value) const
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.picture.width = value;
-		}
-
-		void Picture::set_height(FLAC__uint32 value) const
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.picture.height = value;
-		}
-
-		void Picture::set_depth(FLAC__uint32 value) const
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.picture.depth = value;
-		}
-
-		void Picture::set_colors(FLAC__uint32 value) const
-		{
-			FLAC__ASSERT(is_valid());
-			object_->data.picture.colors = value;
-		}
-
-		bool Picture::set_data(const FLAC__byte *data, FLAC__uint32 data_length)
-		{
-			FLAC__ASSERT(is_valid());
-			// We can safely const_cast since copy=true
-			return (bool)::FLAC__metadata_object_picture_set_data(object_, const_cast<FLAC__byte*>(data), data_length, /*copy=*/true);
-		}
-
-
-		//
-		// Unknown
-		//
-
-		Unknown::Unknown():
-		Prototype(FLAC__metadata_object_new(FLAC__METADATA_TYPE_APPLICATION), /*copy=*/false)
-		{ }
-
-		Unknown::~Unknown()
-		{ }
-
-		const FLAC__byte *Unknown::get_data() const
-		{
-			FLAC__ASSERT(is_valid());
-			return object_->data.application.data;
-		}
-
-		bool Unknown::set_data(const FLAC__byte *data, unsigned length)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_application_set_data(object_, (FLAC__byte*)data, length, true);
-		}
-
-		bool Unknown::set_data(FLAC__byte *data, unsigned length, bool copy)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_object_application_set_data(object_, data, length, copy);
-		}
-
-
-		// ============================================================
-		//
-		//  Level 0
-		//
-		// ============================================================
-
-		FLACPP_API bool get_streaminfo(const char *filename, StreamInfo &streaminfo)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata object;
-
-			if(::FLAC__metadata_get_streaminfo(filename, &object)) {
-				streaminfo = object;
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_tags(const char *filename, VorbisComment *&tags)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			tags = 0;
-
-			if(::FLAC__metadata_get_tags(filename, &object)) {
-				tags = new VorbisComment(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_tags(const char *filename, VorbisComment &tags)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			if(::FLAC__metadata_get_tags(filename, &object)) {
-				tags.assign(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_cuesheet(const char *filename, CueSheet *&cuesheet)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			cuesheet = 0;
-
-			if(::FLAC__metadata_get_cuesheet(filename, &object)) {
-				cuesheet = new CueSheet(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_cuesheet(const char *filename, CueSheet &cuesheet)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			if(::FLAC__metadata_get_cuesheet(filename, &object)) {
-				cuesheet.assign(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_picture(const char *filename, Picture *&picture, ::FLAC__StreamMetadata_Picture_Type type, const char *mime_type, const FLAC__byte *description, unsigned max_width, unsigned max_height, unsigned max_depth, unsigned max_colors)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			picture = 0;
-
-			if(::FLAC__metadata_get_picture(filename, &object, type, mime_type, description, max_width, max_height, max_depth, max_colors)) {
-				picture = new Picture(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-		FLACPP_API bool get_picture(const char *filename, Picture &picture, ::FLAC__StreamMetadata_Picture_Type type, const char *mime_type, const FLAC__byte *description, unsigned max_width, unsigned max_height, unsigned max_depth, unsigned max_colors)
-		{
-			FLAC__ASSERT(0 != filename);
-
-			::FLAC__StreamMetadata *object;
-
-			if(::FLAC__metadata_get_picture(filename, &object, type, mime_type, description, max_width, max_height, max_depth, max_colors)) {
-				picture.assign(object, /*copy=*/false);
-				return true;
-			}
-			else
-				return false;
-		}
-
-
-		// ============================================================
-		//
-		//  Level 1
-		//
-		// ============================================================
-
-		SimpleIterator::SimpleIterator():
-		iterator_(::FLAC__metadata_simple_iterator_new())
-		{ }
-
-		SimpleIterator::~SimpleIterator()
-		{
-			clear();
-		}
-
-		void SimpleIterator::clear()
-		{
-			if(0 != iterator_)
-				FLAC__metadata_simple_iterator_delete(iterator_);
-			iterator_ = 0;
-		}
-
-		bool SimpleIterator::init(const char *filename, bool read_only, bool preserve_file_stats)
-		{
-			FLAC__ASSERT(0 != filename);
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_init(iterator_, filename, read_only, preserve_file_stats);
-		}
-
-		bool SimpleIterator::is_valid() const
-		{
-			return 0 != iterator_;
-		}
-
-		SimpleIterator::Status SimpleIterator::status()
-		{
-			FLAC__ASSERT(is_valid());
-			return Status(::FLAC__metadata_simple_iterator_status(iterator_));
-		}
-
-		bool SimpleIterator::is_writable() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_is_writable(iterator_);
-		}
-
-		bool SimpleIterator::next()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_next(iterator_);
-		}
-
-		bool SimpleIterator::prev()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_prev(iterator_);
-		}
-
-		//@@@@ add to tests
-		bool SimpleIterator::is_last() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_is_last(iterator_);
-		}
-
-		//@@@@ add to tests
-		off_t SimpleIterator::get_block_offset() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__metadata_simple_iterator_get_block_offset(iterator_);
-		}
-
-		::FLAC__MetadataType SimpleIterator::get_block_type() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__metadata_simple_iterator_get_block_type(iterator_);
-		}
-
-		//@@@@ add to tests
-		unsigned SimpleIterator::get_block_length() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__metadata_simple_iterator_get_block_length(iterator_);
-		}
-
-		//@@@@ add to tests
-		bool SimpleIterator::get_application_id(FLAC__byte *id)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_get_application_id(iterator_, id);
-		}
-
-		Prototype *SimpleIterator::get_block()
-		{
-			FLAC__ASSERT(is_valid());
-			return local::construct_block(::FLAC__metadata_simple_iterator_get_block(iterator_));
-		}
-
-		bool SimpleIterator::set_block(Prototype *block, bool use_padding)
-		{
-			FLAC__ASSERT(0 != block);
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_set_block(iterator_, block->object_, use_padding);
-		}
-
-		bool SimpleIterator::insert_block_after(Prototype *block, bool use_padding)
-		{
-			FLAC__ASSERT(0 != block);
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_insert_block_after(iterator_, block->object_, use_padding);
-		}
-
-		bool SimpleIterator::delete_block(bool use_padding)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_simple_iterator_delete_block(iterator_, use_padding);
-		}
-
-
-		// ============================================================
-		//
-		//  Level 2
-		//
-		// ============================================================
-
-		Chain::Chain():
-		chain_(::FLAC__metadata_chain_new())
-		{ }
-
-		Chain::~Chain()
-		{
-			clear();
-		}
-
-		void Chain::clear()
-		{
-			if(0 != chain_)
-				FLAC__metadata_chain_delete(chain_);
-			chain_ = 0;
-		}
-
-		bool Chain::is_valid() const
-		{
-			return 0 != chain_;
-		}
-
-		Chain::Status Chain::status()
-		{
-			FLAC__ASSERT(is_valid());
-			return Status(::FLAC__metadata_chain_status(chain_));
-		}
-
-		bool Chain::read(const char *filename, bool is_ogg)
-		{
-			FLAC__ASSERT(0 != filename);
-			FLAC__ASSERT(is_valid());
-			return is_ogg?
-				(bool)::FLAC__metadata_chain_read_ogg(chain_, filename) :
-				(bool)::FLAC__metadata_chain_read(chain_, filename)
-			;
-		}
-
-		bool Chain::read(FLAC__IOHandle handle, ::FLAC__IOCallbacks callbacks, bool is_ogg)
-		{
-			FLAC__ASSERT(is_valid());
-			return is_ogg?
-				(bool)::FLAC__metadata_chain_read_ogg_with_callbacks(chain_, handle, callbacks) :
-				(bool)::FLAC__metadata_chain_read_with_callbacks(chain_, handle, callbacks)
-			;
-		}
-
-		bool Chain::check_if_tempfile_needed(bool use_padding)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_chain_check_if_tempfile_needed(chain_, use_padding);
-		}
-
-		bool Chain::write(bool use_padding, bool preserve_file_stats)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_chain_write(chain_, use_padding, preserve_file_stats);
-		}
-
-		bool Chain::write(bool use_padding, ::FLAC__IOHandle handle, ::FLAC__IOCallbacks callbacks)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_chain_write_with_callbacks(chain_, use_padding, handle, callbacks);
-		}
-
-		bool Chain::write(bool use_padding, ::FLAC__IOHandle handle, ::FLAC__IOCallbacks callbacks, ::FLAC__IOHandle temp_handle, ::FLAC__IOCallbacks temp_callbacks)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_chain_write_with_callbacks_and_tempfile(chain_, use_padding, handle, callbacks, temp_handle, temp_callbacks);
-		}
-
-		void Chain::merge_padding()
-		{
-			FLAC__ASSERT(is_valid());
-			::FLAC__metadata_chain_merge_padding(chain_);
-		}
-
-		void Chain::sort_padding()
-		{
-			FLAC__ASSERT(is_valid());
-			::FLAC__metadata_chain_sort_padding(chain_);
-		}
-
-
-		Iterator::Iterator():
-		iterator_(::FLAC__metadata_iterator_new())
-		{ }
-
-		Iterator::~Iterator()
-		{
-			clear();
-		}
-
-		void Iterator::clear()
-		{
-			if(0 != iterator_)
-				FLAC__metadata_iterator_delete(iterator_);
-			iterator_ = 0;
-		}
-
-		bool Iterator::is_valid() const
-		{
-			return 0 != iterator_;
-		}
-
-		void Iterator::init(Chain &chain)
-		{
-			FLAC__ASSERT(is_valid());
-			FLAC__ASSERT(chain.is_valid());
-			::FLAC__metadata_iterator_init(iterator_, chain.chain_);
-		}
-
-		bool Iterator::next()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_iterator_next(iterator_);
-		}
-
-		bool Iterator::prev()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_iterator_prev(iterator_);
-		}
-
-		::FLAC__MetadataType Iterator::get_block_type() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__metadata_iterator_get_block_type(iterator_);
-		}
-
-		Prototype *Iterator::get_block()
-		{
-			FLAC__ASSERT(is_valid());
-			Prototype *block = local::construct_block(::FLAC__metadata_iterator_get_block(iterator_));
-			if(0 != block)
-				block->set_reference(true);
-			return block;
-		}
-
-		bool Iterator::set_block(Prototype *block)
-		{
-			FLAC__ASSERT(0 != block);
-			FLAC__ASSERT(is_valid());
-			bool ret = (bool)::FLAC__metadata_iterator_set_block(iterator_, block->object_);
-			if(ret) {
-				block->set_reference(true);
-				delete block;
-			}
-			return ret;
-		}
-
-		bool Iterator::delete_block(bool replace_with_padding)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__metadata_iterator_delete_block(iterator_, replace_with_padding);
-		}
-
-		bool Iterator::insert_block_before(Prototype *block)
-		{
-			FLAC__ASSERT(0 != block);
-			FLAC__ASSERT(is_valid());
-			bool ret = (bool)::FLAC__metadata_iterator_insert_block_before(iterator_, block->object_);
-			if(ret) {
-				block->set_reference(true);
-				delete block;
-			}
-			return ret;
-		}
-
-		bool Iterator::insert_block_after(Prototype *block)
-		{
-			FLAC__ASSERT(0 != block);
-			FLAC__ASSERT(is_valid());
-			bool ret = (bool)::FLAC__metadata_iterator_insert_block_after(iterator_, block->object_);
-			if(ret) {
-				block->set_reference(true);
-				delete block;
-			}
-			return ret;
-		}
-
-	}
-}
diff -Nru src-old/lib/libflac/libflac++/stream_decoder.cpp src/lib/libflac/libflac++/stream_decoder.cpp
--- src-old/lib/libflac/libflac++/stream_decoder.cpp	2012-01-22 19:38:22.000000000 +0100
+++ src/lib/libflac/libflac++/stream_decoder.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,389 +0,0 @@
-/* libFLAC++ - Free Lossless Audio Codec library
- * Copyright (C) 2002,2003,2004,2005,2006,2007  Josh Coalson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * - Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * - Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * - Neither the name of the Xiph.org Foundation nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "flac++/decoder.h"
-#include "flac/assert.h"
-
-#ifdef _MSC_VER
-// warning C4800: 'int' : forcing to bool 'true' or 'false' (performance warning)
-#pragma warning ( disable : 4800 )
-#endif
-
-namespace FLAC {
-	namespace Decoder {
-
-		// ------------------------------------------------------------
-		//
-		// Stream
-		//
-		// ------------------------------------------------------------
-
-		Stream::Stream():
-		decoder_(::FLAC__stream_decoder_new())
-		{ }
-
-		Stream::~Stream()
-		{
-			if(0 != decoder_) {
-				(void)::FLAC__stream_decoder_finish(decoder_);
-				::FLAC__stream_decoder_delete(decoder_);
-			}
-		}
-
-		bool Stream::is_valid() const
-		{
-			return 0 != decoder_;
-		}
-
-		bool Stream::set_ogg_serial_number(long value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_ogg_serial_number(decoder_, value);
-		}
-
-		bool Stream::set_md5_checking(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_md5_checking(decoder_, value);
-		}
-
-		bool Stream::set_metadata_respond(::FLAC__MetadataType type)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_respond(decoder_, type);
-		}
-
-		bool Stream::set_metadata_respond_application(const FLAC__byte id[4])
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_respond_application(decoder_, id);
-		}
-
-		bool Stream::set_metadata_respond_all()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_respond_all(decoder_);
-		}
-
-		bool Stream::set_metadata_ignore(::FLAC__MetadataType type)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_ignore(decoder_, type);
-		}
-
-		bool Stream::set_metadata_ignore_application(const FLAC__byte id[4])
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_ignore_application(decoder_, id);
-		}
-
-		bool Stream::set_metadata_ignore_all()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_set_metadata_ignore_all(decoder_);
-		}
-
-		Stream::State Stream::get_state() const
-		{
-			FLAC__ASSERT(is_valid());
-			return State(::FLAC__stream_decoder_get_state(decoder_));
-		}
-
-		bool Stream::get_md5_checking() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_get_md5_checking(decoder_);
-		}
-
-		FLAC__uint64 Stream::get_total_samples() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_total_samples(decoder_);
-		}
-
-		unsigned Stream::get_channels() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_channels(decoder_);
-		}
-
-		::FLAC__ChannelAssignment Stream::get_channel_assignment() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_channel_assignment(decoder_);
-		}
-
-		unsigned Stream::get_bits_per_sample() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_bits_per_sample(decoder_);
-		}
-
-		unsigned Stream::get_sample_rate() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_sample_rate(decoder_);
-		}
-
-		unsigned Stream::get_blocksize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_blocksize(decoder_);
-		}
-
-		bool Stream::get_decode_position(FLAC__uint64 *position) const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_get_decode_position(decoder_, position);
-		}
-
-		::FLAC__StreamDecoderInitStatus Stream::init()
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_init_stream(decoder_, read_callback_, seek_callback_, tell_callback_, length_callback_, eof_callback_, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamDecoderInitStatus Stream::init_ogg()
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_decoder_init_ogg_stream(decoder_, read_callback_, seek_callback_, tell_callback_, length_callback_, eof_callback_, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		bool Stream::finish()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_finish(decoder_);
-		}
-
-		bool Stream::flush()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_flush(decoder_);
-		}
-
-		bool Stream::reset()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_reset(decoder_);
-		}
-
-		bool Stream::process_single()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_process_single(decoder_);
-		}
-
-		bool Stream::process_until_end_of_metadata()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_process_until_end_of_metadata(decoder_);
-		}
-
-		bool Stream::process_until_end_of_stream()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_process_until_end_of_stream(decoder_);
-		}
-
-		bool Stream::skip_single_frame()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_skip_single_frame(decoder_);
-		}
-
-		bool Stream::seek_absolute(FLAC__uint64 sample)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_decoder_seek_absolute(decoder_, sample);
-		}
-
-		::FLAC__StreamDecoderSeekStatus Stream::seek_callback(FLAC__uint64 absolute_byte_offset)
-		{
-			(void)absolute_byte_offset;
-			return ::FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;
-		}
-
-		::FLAC__StreamDecoderTellStatus Stream::tell_callback(FLAC__uint64 *absolute_byte_offset)
-		{
-			(void)absolute_byte_offset;
-			return ::FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;
-		}
-
-		::FLAC__StreamDecoderLengthStatus Stream::length_callback(FLAC__uint64 *stream_length)
-		{
-			(void)stream_length;
-			return ::FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
-		}
-
-		bool Stream::eof_callback()
-		{
-			return false;
-		}
-
-		void Stream::metadata_callback(const ::FLAC__StreamMetadata *metadata)
-		{
-			(void)metadata;
-		}
-
-		::FLAC__StreamDecoderReadStatus Stream::read_callback_(const ::FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
-		{
-			(void)decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->read_callback(buffer, bytes);
-		}
-
-		::FLAC__StreamDecoderSeekStatus Stream::seek_callback_(const ::FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)
-		{
-			(void) decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->seek_callback(absolute_byte_offset);
-		}
-
-		::FLAC__StreamDecoderTellStatus Stream::tell_callback_(const ::FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
-		{
-			(void) decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->tell_callback(absolute_byte_offset);
-		}
-
-		::FLAC__StreamDecoderLengthStatus Stream::length_callback_(const ::FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)
-		{
-			(void) decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->length_callback(stream_length);
-		}
-
-		FLAC__bool Stream::eof_callback_(const ::FLAC__StreamDecoder *decoder, void *client_data)
-		{
-			(void) decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->eof_callback();
-		}
-
-		::FLAC__StreamDecoderWriteStatus Stream::write_callback_(const ::FLAC__StreamDecoder *decoder, const ::FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data)
-		{
-			(void)decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->write_callback(frame, buffer);
-		}
-
-		void Stream::metadata_callback_(const ::FLAC__StreamDecoder *decoder, const ::FLAC__StreamMetadata *metadata, void *client_data)
-		{
-			(void)decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			instance->metadata_callback(metadata);
-		}
-
-		void Stream::error_callback_(const ::FLAC__StreamDecoder *decoder, ::FLAC__StreamDecoderErrorStatus status, void *client_data)
-		{
-			(void)decoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			instance->error_callback(status);
-		}
-
-		// ------------------------------------------------------------
-		//
-		// File
-		//
-		// ------------------------------------------------------------
-
-		File::File():
-			Stream()
-		{ }
-
-		File::~File()
-		{
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init(FILE *file)
-		{
-			FLAC__ASSERT(0 != decoder_);
-			return ::FLAC__stream_decoder_init_FILE(decoder_, file, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init(const char *filename)
-		{
-			FLAC__ASSERT(0 != decoder_);
-			return ::FLAC__stream_decoder_init_file(decoder_, filename, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init(const std::string &filename)
-		{
-			return init(filename.c_str());
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init_ogg(FILE *file)
-		{
-			FLAC__ASSERT(0 != decoder_);
-			return ::FLAC__stream_decoder_init_ogg_FILE(decoder_, file, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init_ogg(const char *filename)
-		{
-			FLAC__ASSERT(0 != decoder_);
-			return ::FLAC__stream_decoder_init_ogg_file(decoder_, filename, write_callback_, metadata_callback_, error_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamDecoderInitStatus File::init_ogg(const std::string &filename)
-		{
-			return init_ogg(filename.c_str());
-		}
-
-		// This is a dummy to satisfy the pure virtual from Stream; the
-		// read callback will never be called since we are initializing
-		// with FLAC__stream_decoder_init_FILE() or
-		// FLAC__stream_decoder_init_file() and those supply the read
-		// callback internally.
-		::FLAC__StreamDecoderReadStatus File::read_callback(FLAC__byte buffer[], size_t *bytes)
-		{
-			(void)buffer, (void)bytes;
-			FLAC__ASSERT(false);
-			return ::FLAC__STREAM_DECODER_READ_STATUS_ABORT; // double protection
-		}
-
-	}
-}
diff -Nru src-old/lib/libflac/libflac++/stream_encoder.cpp src/lib/libflac/libflac++/stream_encoder.cpp
--- src-old/lib/libflac/libflac++/stream_encoder.cpp	2012-01-22 19:38:22.000000000 +0100
+++ src/lib/libflac/libflac++/stream_encoder.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,511 +0,0 @@
-/* libFLAC++ - Free Lossless Audio Codec library
- * Copyright (C) 2002,2003,2004,2005,2006,2007  Josh Coalson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * - Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * - Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * - Neither the name of the Xiph.org Foundation nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "flac++/encoder.h"
-#include "flac++/metadata.h"
-#include "flac/assert.h"
-
-#ifdef _MSC_VER
-// warning C4800: 'int' : forcing to bool 'true' or 'false' (performance warning)
-#pragma warning ( disable : 4800 )
-#endif
-
-namespace FLAC {
-	namespace Encoder {
-
-		// ------------------------------------------------------------
-		//
-		// Stream
-		//
-		// ------------------------------------------------------------
-
-		Stream::Stream():
-		encoder_(::FLAC__stream_encoder_new())
-		{ }
-
-		Stream::~Stream()
-		{
-			if(0 != encoder_) {
-				(void)::FLAC__stream_encoder_finish(encoder_);
-				::FLAC__stream_encoder_delete(encoder_);
-			}
-		}
-
-		bool Stream::is_valid() const
-		{
-			return 0 != encoder_;
-		}
-
-		bool Stream::set_ogg_serial_number(long value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_ogg_serial_number(encoder_, value);
-		}
-
-		bool Stream::set_verify(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_verify(encoder_, value);
-		}
-
-		bool Stream::set_streamable_subset(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_streamable_subset(encoder_, value);
-		}
-
-		bool Stream::set_channels(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_channels(encoder_, value);
-		}
-
-		bool Stream::set_bits_per_sample(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_bits_per_sample(encoder_, value);
-		}
-
-		bool Stream::set_sample_rate(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_sample_rate(encoder_, value);
-		}
-
-		bool Stream::set_compression_level(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_compression_level(encoder_, value);
-		}
-
-		bool Stream::set_blocksize(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_blocksize(encoder_, value);
-		}
-
-		bool Stream::set_do_mid_side_stereo(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_do_mid_side_stereo(encoder_, value);
-		}
-
-		bool Stream::set_loose_mid_side_stereo(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_loose_mid_side_stereo(encoder_, value);
-		}
-
-		bool Stream::set_apodization(const char *specification)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_apodization(encoder_, specification);
-		}
-
-		bool Stream::set_max_lpc_order(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_max_lpc_order(encoder_, value);
-		}
-
-		bool Stream::set_qlp_coeff_precision(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_qlp_coeff_precision(encoder_, value);
-		}
-
-		bool Stream::set_do_qlp_coeff_prec_search(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_do_qlp_coeff_prec_search(encoder_, value);
-		}
-
-		bool Stream::set_do_escape_coding(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_do_escape_coding(encoder_, value);
-		}
-
-		bool Stream::set_do_exhaustive_model_search(bool value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_do_exhaustive_model_search(encoder_, value);
-		}
-
-		bool Stream::set_min_residual_partition_order(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_min_residual_partition_order(encoder_, value);
-		}
-
-		bool Stream::set_max_residual_partition_order(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_max_residual_partition_order(encoder_, value);
-		}
-
-		bool Stream::set_rice_parameter_search_dist(unsigned value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_rice_parameter_search_dist(encoder_, value);
-		}
-
-		bool Stream::set_total_samples_estimate(FLAC__uint64 value)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_total_samples_estimate(encoder_, value);
-		}
-
-		bool Stream::set_metadata(::FLAC__StreamMetadata **metadata, unsigned num_blocks)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_set_metadata(encoder_, metadata, num_blocks);
-		}
-
-		bool Stream::set_metadata(FLAC::Metadata::Prototype **metadata, unsigned num_blocks)
-		{
-			FLAC__ASSERT(is_valid());
-#if (defined _MSC_VER) || (defined __BORLANDC__) || (defined __SUNPRO_CC)
-			// MSVC++ can't handle:
-			// ::FLAC__StreamMetadata *m[num_blocks];
-			// so we do this ugly workaround
-			::FLAC__StreamMetadata **m = new ::FLAC__StreamMetadata*[num_blocks];
-#else
-			::FLAC__StreamMetadata *m[num_blocks];
-#endif
-			for(unsigned i = 0; i < num_blocks; i++) {
-				// we can get away with the const_cast since we know the encoder will only correct the is_last flags
-				m[i] = const_cast< ::FLAC__StreamMetadata*>((const ::FLAC__StreamMetadata*)metadata[i]);
-			}
-#if (defined _MSC_VER) || (defined __BORLANDC__) || (defined __SUNPRO_CC)
-			// complete the hack
-			const bool ok = (bool)::FLAC__stream_encoder_set_metadata(encoder_, m, num_blocks);
-			delete [] m;
-			return ok;
-#else
-			return (bool)::FLAC__stream_encoder_set_metadata(encoder_, m, num_blocks);
-#endif
-		}
-
-		Stream::State Stream::get_state() const
-		{
-			FLAC__ASSERT(is_valid());
-			return State(::FLAC__stream_encoder_get_state(encoder_));
-		}
-
-		Decoder::Stream::State Stream::get_verify_decoder_state() const
-		{
-			FLAC__ASSERT(is_valid());
-			return Decoder::Stream::State(::FLAC__stream_encoder_get_verify_decoder_state(encoder_));
-		}
-
-		void Stream::get_verify_decoder_error_stats(FLAC__uint64 *absolute_sample, unsigned *frame_number, unsigned *channel, unsigned *sample, FLAC__int32 *expected, FLAC__int32 *got)
-		{
-			FLAC__ASSERT(is_valid());
-			::FLAC__stream_encoder_get_verify_decoder_error_stats(encoder_, absolute_sample, frame_number, channel, sample, expected, got);
-		}
-
-		bool Stream::get_verify() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_verify(encoder_);
-		}
-
-		bool Stream::get_streamable_subset() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_streamable_subset(encoder_);
-		}
-
-		bool Stream::get_do_mid_side_stereo() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_do_mid_side_stereo(encoder_);
-		}
-
-		bool Stream::get_loose_mid_side_stereo() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_loose_mid_side_stereo(encoder_);
-		}
-
-		unsigned Stream::get_channels() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_channels(encoder_);
-		}
-
-		unsigned Stream::get_bits_per_sample() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_bits_per_sample(encoder_);
-		}
-
-		unsigned Stream::get_sample_rate() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_sample_rate(encoder_);
-		}
-
-		unsigned Stream::get_blocksize() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_blocksize(encoder_);
-		}
-
-		unsigned Stream::get_max_lpc_order() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_max_lpc_order(encoder_);
-		}
-
-		unsigned Stream::get_qlp_coeff_precision() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_qlp_coeff_precision(encoder_);
-		}
-
-		bool Stream::get_do_qlp_coeff_prec_search() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_do_qlp_coeff_prec_search(encoder_);
-		}
-
-		bool Stream::get_do_escape_coding() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_do_escape_coding(encoder_);
-		}
-
-		bool Stream::get_do_exhaustive_model_search() const
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_get_do_exhaustive_model_search(encoder_);
-		}
-
-		unsigned Stream::get_min_residual_partition_order() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_min_residual_partition_order(encoder_);
-		}
-
-		unsigned Stream::get_max_residual_partition_order() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_max_residual_partition_order(encoder_);
-		}
-
-		unsigned Stream::get_rice_parameter_search_dist() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_rice_parameter_search_dist(encoder_);
-		}
-
-		FLAC__uint64 Stream::get_total_samples_estimate() const
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_get_total_samples_estimate(encoder_);
-		}
-
-		::FLAC__StreamEncoderInitStatus Stream::init()
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_stream(encoder_, write_callback_, seek_callback_, tell_callback_, metadata_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamEncoderInitStatus Stream::init_ogg()
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_ogg_stream(encoder_, read_callback_, write_callback_, seek_callback_, tell_callback_, metadata_callback_, /*client_data=*/(void*)this);
-		}
-
-		bool Stream::finish()
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_finish(encoder_);
-		}
-
-		bool Stream::process(const FLAC__int32 * const buffer[], unsigned samples)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_process(encoder_, buffer, samples);
-		}
-
-		bool Stream::process_interleaved(const FLAC__int32 buffer[], unsigned samples)
-		{
-			FLAC__ASSERT(is_valid());
-			return (bool)::FLAC__stream_encoder_process_interleaved(encoder_, buffer, samples);
-		}
-
-		::FLAC__StreamEncoderReadStatus Stream::read_callback(FLAC__byte buffer[], size_t *bytes)
-		{
-			(void)buffer, (void)bytes;
-			return ::FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED;
-		}
-
-		::FLAC__StreamEncoderSeekStatus Stream::seek_callback(FLAC__uint64 absolute_byte_offset)
-		{
-			(void)absolute_byte_offset;
-			return ::FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;
-		}
-
-		::FLAC__StreamEncoderTellStatus Stream::tell_callback(FLAC__uint64 *absolute_byte_offset)
-		{
-			(void)absolute_byte_offset;
-			return ::FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;
-		}
-
-		void Stream::metadata_callback(const ::FLAC__StreamMetadata *metadata)
-		{
-			(void)metadata;
-		}
-
-		::FLAC__StreamEncoderReadStatus Stream::read_callback_(const ::FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->read_callback(buffer, bytes);
-		}
-
-		::FLAC__StreamEncoderWriteStatus Stream::write_callback_(const ::FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->write_callback(buffer, bytes, samples, current_frame);
-		}
-
-		::FLAC__StreamEncoderSeekStatus Stream::seek_callback_(const ::FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->seek_callback(absolute_byte_offset);
-		}
-
-		::FLAC__StreamEncoderTellStatus Stream::tell_callback_(const ::FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			return instance->tell_callback(absolute_byte_offset);
-		}
-
-		void Stream::metadata_callback_(const ::FLAC__StreamEncoder *encoder, const ::FLAC__StreamMetadata *metadata, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			Stream *instance = reinterpret_cast<Stream *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			instance->metadata_callback(metadata);
-		}
-
-		// ------------------------------------------------------------
-		//
-		// File
-		//
-		// ------------------------------------------------------------
-
-		File::File():
-			Stream()
-		{ }
-
-		File::~File()
-		{
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init(FILE *file)
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_FILE(encoder_, file, progress_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init(const char *filename)
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_file(encoder_, filename, progress_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init(const std::string &filename)
-		{
-			return init(filename.c_str());
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init_ogg(FILE *file)
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_ogg_FILE(encoder_, file, progress_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init_ogg(const char *filename)
-		{
-			FLAC__ASSERT(is_valid());
-			return ::FLAC__stream_encoder_init_ogg_file(encoder_, filename, progress_callback_, /*client_data=*/(void*)this);
-		}
-
-		::FLAC__StreamEncoderInitStatus File::init_ogg(const std::string &filename)
-		{
-			return init_ogg(filename.c_str());
-		}
-
-		// This is a dummy to satisfy the pure virtual from Stream; the
-		// read callback will never be called since we are initializing
-		// with FLAC__stream_decoder_init_FILE() or
-		// FLAC__stream_decoder_init_file() and those supply the read
-		// callback internally.
-		::FLAC__StreamEncoderWriteStatus File::write_callback(const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame)
-		{
-			(void)buffer, (void)bytes, (void)samples, (void)current_frame;
-			FLAC__ASSERT(false);
-			return ::FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR; // double protection
-		}
-
-		void File::progress_callback(FLAC__uint64 bytes_written, FLAC__uint64 samples_written, unsigned frames_written, unsigned total_frames_estimate)
-		{
-			(void)bytes_written, (void)samples_written, (void)frames_written, (void)total_frames_estimate;
-		}
-
-		void File::progress_callback_(const ::FLAC__StreamEncoder *encoder, FLAC__uint64 bytes_written, FLAC__uint64 samples_written, unsigned frames_written, unsigned total_frames_estimate, void *client_data)
-		{
-			(void)encoder;
-			FLAC__ASSERT(0 != client_data);
-			File *instance = reinterpret_cast<File *>(client_data);
-			FLAC__ASSERT(0 != instance);
-			instance->progress_callback(bytes_written, samples_written, frames_written, total_frames_estimate);
-		}
-
-	}
-}
diff -Nru src-old/lib/util/cdrom.c src/lib/util/cdrom.c
--- src-old/lib/util/cdrom.c	2012-02-19 18:22:07.000000000 +0100
+++ src/lib/util/cdrom.c	2012-03-11 18:17:00.000000000 +0100
@@ -702,11 +702,11 @@
 	/* start with no tracks */
 	for (toc->numtrks = 0; toc->numtrks < CD_MAX_TRACKS; toc->numtrks++)
 	{
-		int tracknum = -1, frames = 0, pregap, postgap;
+		int tracknum = -1, frames = 0, pregap, postgap, padframes;
 		char type[16], subtype[16], pgtype[16], pgsub[16];
 		cdrom_track_info *track;
 
-		pregap = postgap = 0;
+		pregap = postgap = padframes = 0;
 
 		/* fetch the metadata for this track */
 		err = chd->read_metadata(CDROM_TRACK_METADATA_TAG, toc->numtrks, metadata);
@@ -723,16 +723,37 @@
 		else
 		{
 			err = chd->read_metadata(CDROM_TRACK_METADATA2_TAG, toc->numtrks, metadata);
-			if (err != CHDERR_NONE)
-				break;
-			/* parse the metadata */
-			type[0] = subtype[0] = 0;
-			pregap = postgap = 0;
-			if (sscanf(metadata, CDROM_TRACK_METADATA2_FORMAT, &tracknum, type, subtype, &frames, &pregap, pgtype, pgsub, &postgap) != 8)
-				return CHDERR_INVALID_DATA;
-			if (tracknum == 0 || tracknum > CD_MAX_TRACKS)
-				return CHDERR_INVALID_DATA;
-			track = &toc->tracks[tracknum - 1];
+			if (err == CHDERR_NONE)
+            {
+                /* parse the metadata */
+                type[0] = subtype[0] = 0;
+                pregap = postgap = 0;
+                if (sscanf(metadata, CDROM_TRACK_METADATA2_FORMAT, &tracknum, type, subtype, &frames, &pregap, pgtype, pgsub, &postgap) != 8)
+                    return CHDERR_INVALID_DATA;
+                if (tracknum == 0 || tracknum > CD_MAX_TRACKS)
+                    return CHDERR_INVALID_DATA;
+                track = &toc->tracks[tracknum - 1];
+            }
+            else
+            {
+                err = chd->read_metadata(GDROM_TRACK_METADATA_TAG, toc->numtrks, metadata);
+
+                if (err == CHDERR_NONE)
+                {
+                    /* parse the metadata */
+                    type[0] = subtype[0] = 0;
+                    pregap = postgap = 0;
+                    if (sscanf(metadata, GDROM_TRACK_METADATA_FORMAT, &tracknum, type, subtype, &frames, &padframes, &pregap, pgtype, pgsub, &postgap) != 9)
+                        return CHDERR_INVALID_DATA;
+                    if (tracknum == 0 || tracknum > CD_MAX_TRACKS)
+                        return CHDERR_INVALID_DATA;
+                    track = &toc->tracks[tracknum - 1];
+                }
+                else
+                {
+                    break;
+                }
+            }
 		}
 
 		/* extract the track type and determine the data size */
@@ -749,6 +770,7 @@
 
 		/* set the frames and extra frames data */
 		track->frames = frames;
+        track->padframes = padframes;
 		int padded = (frames + CD_TRACK_PADDING - 1) / CD_TRACK_PADDING;
 		track->extraframes = padded * CD_TRACK_PADDING - frames;
 
@@ -769,6 +791,8 @@
 	if (toc->numtrks > 0)
 		return CHDERR_NONE;
 
+    printf("toc->numtrks = %d?!\n", toc->numtrks);
+
 	/* look for old-style metadata */
 	dynamic_buffer oldmetadata;
 	err = chd->read_metadata(CDROM_OLD_METADATA_TAG, 0, oldmetadata);
@@ -806,6 +830,7 @@
 			toc->tracks[i].datasize = FLIPENDIAN_INT32(toc->tracks[i].datasize);
 			toc->tracks[i].subsize = FLIPENDIAN_INT32(toc->tracks[i].subsize);
 			toc->tracks[i].frames = FLIPENDIAN_INT32(toc->tracks[i].frames);
+			toc->tracks[i].padframes = FLIPENDIAN_INT32(toc->tracks[i].padframes);
 			toc->tracks[i].extraframes = FLIPENDIAN_INT32(toc->tracks[i].extraframes);
 		}
 	}
@@ -826,13 +851,25 @@
 	/* write the metadata */
 	for (i = 0; i < toc->numtrks; i++)
 	{
-		astring metadata;
-		metadata.format(CDROM_TRACK_METADATA2_FORMAT, i + 1, cdrom_get_type_string(toc->tracks[i].trktype),
-				cdrom_get_subtype_string(toc->tracks[i].subtype), toc->tracks[i].frames, toc->tracks[i].pregap,
-				cdrom_get_type_string(toc->tracks[i].pgtype), cdrom_get_subtype_string(toc->tracks[i].pgsub),
-				toc->tracks[i].postgap);
+        astring metadata;
+        if (!(toc->flags & CD_FLAG_GDROM))
+        {
+            metadata.format(CDROM_TRACK_METADATA2_FORMAT, i + 1, cdrom_get_type_string(toc->tracks[i].trktype),
+                    cdrom_get_subtype_string(toc->tracks[i].subtype), toc->tracks[i].frames, toc->tracks[i].pregap,
+                    cdrom_get_type_string(toc->tracks[i].pgtype), cdrom_get_subtype_string(toc->tracks[i].pgsub),
+                    toc->tracks[i].postgap);
+
+            err = chd->write_metadata(CDROM_TRACK_METADATA2_TAG, i, metadata);
+        }
+        else
+        {
+            metadata.format(GDROM_TRACK_METADATA_FORMAT, i + 1, cdrom_get_type_string(toc->tracks[i].trktype),
+                    cdrom_get_subtype_string(toc->tracks[i].subtype), toc->tracks[i].frames, toc->tracks[i].padframes,
+                    toc->tracks[i].pregap, cdrom_get_type_string(toc->tracks[i].pgtype),
+                    cdrom_get_subtype_string(toc->tracks[i].pgsub), toc->tracks[i].postgap);
 
-		err = chd->write_metadata(CDROM_TRACK_METADATA2_TAG, i, metadata);
+            err = chd->write_metadata(GDROM_TRACK_METADATA_TAG, i, metadata);
+        }
 		if (err != CHDERR_NONE)
 			return err;
 	}
diff -Nru src-old/lib/util/cdrom.h src/lib/util/cdrom.h
--- src-old/lib/util/cdrom.h	2012-02-26 08:18:28.000000000 +0100
+++ src/lib/util/cdrom.h	2012-03-04 03:17:35.000000000 +0100
@@ -84,7 +84,7 @@
 	CD_SUB_NONE					/* no subcode data stored */
 };
 
-
+#define	CD_FLAG_GDROM	0x00000001	// disc is a GD-ROM, all tracks should be stored with GD-ROM metadata
 
 /***************************************************************************
     TYPE DEFINITIONS
@@ -109,6 +109,9 @@
 	UINT32 pgdatasize;	/* size of data in each sector of the pregap */
 	UINT32 pgsubsize;	/* size of subchannel data in each sector of the pregap */
 
+	/* fields used in CHDMAN only */
+	UINT32 padframes;	/* number of frames of padding to add to the end of the track; needed for GDI */
+
 	/* fields used in MAME only */
 	UINT32 physframeofs;	/* frame number on the real CD this track starts at */
 	UINT32 chdframeofs;	/* frame number this track starts at on the CHD */
@@ -118,6 +121,7 @@
 struct cdrom_toc
 {
 	UINT32 numtrks;		/* number of tracks */
+	UINT32 flags;		/* see FLAG_ above */
 	cdrom_track_info tracks[CD_MAX_TRACKS];
 };
 
diff -Nru src-old/lib/util/chd.c src/lib/util/chd.c
--- src-old/lib/util/chd.c	2012-02-20 15:51:09.000000000 +0100
+++ src/lib/util/chd.c	2012-03-04 03:17:35.000000000 +0100
@@ -58,6 +58,7 @@
 const char *HARD_DISK_METADATA_FORMAT = "CYLS:%d,HEADS:%d,SECS:%d,BPS:%d";
 const char *CDROM_TRACK_METADATA_FORMAT = "TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d";
 const char *CDROM_TRACK_METADATA2_FORMAT = "TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d PREGAP:%d PGTYPE:%s PGSUB:%s POSTGAP:%d";
+const char *GDROM_TRACK_METADATA_FORMAT = "TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d PAD:%d PREGAP:%d PGTYPE:%s PGSUB:%s POSTGAP:%d";
 const char *AV_METADATA_FORMAT = "FPS:%d.%06d WIDTH:%d HEIGHT:%d INTERLACED:%d CHANNELS:%d SAMPLERATE:%d";
 
 static const UINT32 METADATA_HEADER_SIZE = 16;			// metadata header size
@@ -1440,7 +1441,8 @@
 	// look for CD-ROM metadata; if found, then the unit size == CD frame size
 	if (read_metadata(CDROM_OLD_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
 		read_metadata(CDROM_TRACK_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
-		read_metadata(CDROM_TRACK_METADATA2_TAG, 0, metadata) == CHDERR_NONE)
+		read_metadata(CDROM_TRACK_METADATA2_TAG, 0, metadata) == CHDERR_NONE ||
+		read_metadata(GDROM_TRACK_METADATA_TAG, 0, metadata) == CHDERR_NONE)
 		return CD_FRAME_SIZE;
 
 	// otherwise, just map 1:1 with the hunk size
diff -Nru src-old/lib/util/chd.h src/lib/util/chd.h
--- src-old/lib/util/chd.h	2012-02-19 16:23:23.000000000 +0100
+++ src/lib/util/chd.h	2012-03-06 18:58:12.000000000 +0100
@@ -254,6 +254,8 @@
 extern const char *CDROM_TRACK_METADATA_FORMAT;
 const chd_metadata_tag CDROM_TRACK_METADATA2_TAG = CHD_MAKE_TAG('C','H','T','2');
 extern const char *CDROM_TRACK_METADATA2_FORMAT;
+const chd_metadata_tag GDROM_TRACK_METADATA_TAG = CHD_MAKE_TAG('C','H','G','T');
+extern const char *GDROM_TRACK_METADATA_FORMAT;
 
 // standard A/V metadata
 const chd_metadata_tag AV_METADATA_TAG = CHD_MAKE_TAG('A','V','A','V');
@@ -378,8 +380,8 @@
 	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, void *output, UINT32 outputlen, UINT32 &resultlen);
 	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, dynamic_buffer &output, chd_metadata_tag &resulttag, UINT8 &resultflags);
 	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const void *inputbuf, UINT32 inputlen, UINT8 flags = CHD_MDFLAGS_CHECKSUM);
-	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const astring &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input.cstr(), input.len() + 1, flags = CHD_MDFLAGS_CHECKSUM); }
-	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const dynamic_buffer &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input, input.count(), flags = CHD_MDFLAGS_CHECKSUM); }
+	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const astring &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input.cstr(), input.len() + 1, flags); }
+	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const dynamic_buffer &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input, input.count(), flags); }
 	chd_error delete_metadata(chd_metadata_tag metatag, UINT32 metaindex);
 	chd_error clone_all_metadata(chd_file &source);
 
diff -Nru src-old/lib/util/chdcd.c src/lib/util/chdcd.c
--- src-old/lib/util/chdcd.c	2012-02-19 18:22:07.000000000 +0100
+++ src/lib/util/chdcd.c	2012-03-04 03:17:35.000000000 +0100
@@ -1,7 +1,7 @@
 /***************************************************************************
 
     TOC parser for CHD compression frontend
-    Handles CDRDAO .toc, CDRWIN .cue, and Sega GDROM .gdi
+    Handles CDRDAO .toc, CDRWIN .cue, Nero .nrg, and Sega GDROM .gdi
 
     Copyright Nicola Salmoria and the MAME Team.
     Visit http://mamedev.org for licensing and usage restrictions.
@@ -301,7 +301,7 @@
 }
 
 /*-------------------------------------------------
-    chdcd_parse_toc - parse a CDRWin format CUE file
+    chdcd_parse_nero - parse a Nero .NRG file
 -------------------------------------------------*/
 
 chd_error chdcd_parse_nero(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo)
@@ -427,6 +427,7 @@
 				outtoc.tracks[track-1].pgsub = CD_SUB_NONE;
 				outtoc.tracks[track-1].pgdatasize = 0;
 				outtoc.tracks[track-1].pgsubsize = 0;
+				outtoc.tracks[track-1].padframes = 0;
 
 				offset += (UINT32)index2-index1;
 			}
@@ -455,7 +456,6 @@
 {
 	FILE *infile;
 	int i, numtracks;
-	//int chdpos=0;
 
 	astring path = astring(tocfname);
 
@@ -471,6 +471,7 @@
 	memset(&outtoc, 0, sizeof(outtoc));
 	outinfo.reset();
 
+    outtoc.flags = CD_FLAG_GDROM;
 
 	fgets(linebuffer,511,infile);
 	numtracks=atoi(linebuffer);
@@ -481,8 +482,6 @@
 		int trknum;
 		int trksize,trktype;
 		int sz;
-		int hunks;
-
 
 		fgets(linebuffer,511,infile);
 
@@ -493,8 +492,7 @@
 		outinfo.track[trknum].swap=false;
 		outinfo.track[trknum].offset=0;
 
-		//outtoc.tracks[trknum].trktype = CD_TRACK_MODE1;
-		outtoc.tracks[trknum].datasize = 0;
+        outtoc.tracks[trknum].datasize = 0;
 		outtoc.tracks[trknum].subtype = CD_SUB_NONE;
 		outtoc.tracks[trknum].subsize = 0;
 
@@ -519,7 +517,6 @@
 		}
 		if(trktype==0)
 		{
-			//assert(trksize==2352);
 			outtoc.tracks[trknum].trktype=CD_TRACK_AUDIO;
 			outtoc.tracks[trknum].datasize=2352;
 		}
@@ -540,35 +537,26 @@
 		}
 		outinfo.track[trknum].fname.cpy(path).cat(name);
 
-		sz=get_file_size(outinfo.track[trknum].fname);
+		sz = get_file_size(outinfo.track[trknum].fname);
 
-		outtoc.tracks[trknum].frames=sz/trksize;
-		outtoc.tracks[trknum].extraframes=0;
+		outtoc.tracks[trknum].frames = sz/trksize;
+		outtoc.tracks[trknum].padframes = 0;
 
-		if(trknum!=0)
+		if (trknum != 0)
 		{
 			int dif=outtoc.tracks[trknum].physframeofs-(outtoc.tracks[trknum-1].frames+outtoc.tracks[trknum-1].physframeofs);
-			outtoc.tracks[trknum-1].frames+=dif;
+			outtoc.tracks[trknum-1].frames += dif;
+			outtoc.tracks[trknum-1].padframes = dif;
 		}
-
-/*
-        if(trknum!=0)
-        {
-            outtoc.tracks[trknum-1].extraframes=outtoc.tracks[trknum].physframeofs-(outtoc.tracks[trknum-1].frames+outtoc.tracks[trknum-1].physframeofs);
-        }
-*/
-		hunks = (outtoc.tracks[trknum].frames+CD_FRAMES_PER_HUNK - 1) / CD_FRAMES_PER_HUNK;
-		outtoc.tracks[trknum].extraframes = hunks * CD_FRAMES_PER_HUNK - outtoc.tracks[trknum].frames;
-
-		//chdpos+=outtoc.tracks[trknum].frames+outtoc.tracks[trknum].extraframes;
-
 	}
-	/*
-    for(i=0;i<numtracks;++i)
+
+    #if 0
+	for(i=0; i < numtracks; i++)
     {
-        printf("%s %d %d %d\n",outinfo.track[i].fname,outtoc.tracks[i].frames,outtoc.tracks[i].extraframes,outtoc.tracks[i].physframeofs);
+        printf("%s %d %d %d (true %d)\n", outinfo.track[i].fname.cstr(), outtoc.tracks[i].frames, outtoc.tracks[i].padframes, outtoc.tracks[i].physframeofs, outtoc.tracks[i].frames - outtoc.tracks[i].padframes);
     }
-    */
+    #endif
+
 	/* close the input TOC */
 	fclose(infile);
 
@@ -683,6 +671,7 @@
 				outtoc.tracks[trknum].subtype = CD_SUB_NONE;
 				outtoc.tracks[trknum].subsize = 0;
 				outtoc.tracks[trknum].pregap = 0;
+				outtoc.tracks[trknum].padframes = 0;
 				outinfo.track[trknum].idx0offs = -1;
 				outinfo.track[trknum].idx1offs = 0;
 
@@ -988,6 +977,7 @@
 				outtoc.tracks[trknum].datasize = 0;
 				outtoc.tracks[trknum].subtype = CD_SUB_NONE;
 				outtoc.tracks[trknum].subsize = 0;
+				outtoc.tracks[trknum].padframes = 0;
 
 				cdrom_convert_type_string_to_track_info(token, &outtoc.tracks[trknum]);
 				if (outtoc.tracks[trknum].datasize == 0)
diff -Nru src-old/mame/audio/gorf.c src/mame/audio/gorf.c
--- src-old/mame/audio/gorf.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/audio/gorf.c	2012-03-01 09:36:39.000000000 +0100
@@ -20,6 +20,7 @@
 #include "emu.h"
 #include "cpu/z80/z80.h"
 #include "sound/samples.h"
+#include "sound/votrax.h"
 #include "includes/astrocde.h"
 
 
@@ -111,11 +112,12 @@
 
 READ8_HANDLER( gorf_speech_r )
 {
+	UINT8 data = offset >> 8;
+#if USE_FAKE_VOTRAX
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
 	samples_device *samples = space->machine().device<samples_device>("samples");
 	int Phoneme, Intonation;
 	int i = 0;
-	UINT8 data = offset >> 8;
 	offset &= 0xff;
 
 	state->m_totalword_ptr = state->m_totalword;
@@ -169,6 +171,11 @@
 			return data;
 		}
 	}
+#else
+	votrax_sc01_device *votrax = space->machine().device<votrax_sc01_device>("votrax");
+	votrax->inflection_w(*space, 0, data >> 6);
+	votrax->write(*space, 0, data);
+#endif
 
 	/* Note : We should really also use volume in this as well as frequency */
 	return data;				                   /* Return nicely */
@@ -177,6 +184,11 @@
 
 CUSTOM_INPUT( gorf_speech_status_r )
 {
+#if USE_FAKE_VOTRAX
 	samples_device *samples = field.machine().device<samples_device>("samples");
 	return !samples->playing(0);
+#else
+	votrax_sc01_device *votrax = field.machine().device<votrax_sc01_device>("votrax");
+	return votrax->request();
+#endif
 }
diff -Nru src-old/mame/audio/gottlieb.c src/mame/audio/gottlieb.c
--- src-old/mame/audio/gottlieb.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/audio/gottlieb.c	2012-03-11 18:17:00.000000000 +0100
@@ -1,19 +1,46 @@
 /***************************************************************************
 
-    Gottlieb hardware
-    dedicated to Warren Davis, Jeff Lee, Tim Skelly & David Thiel
+    gottlieb.h
+
+    Gottlieb 6502-based sound hardware implementations.
+
+    Dedicated to Warren Davis, Jeff Lee, Tim Skelly & David Thiel
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ***************************************************************************/
+#define ADDRESS_MAP_MODERN
 
 #include "emu.h"
-#include "debugger.h"
-#include "cpu/m6502/m6502.h"
-#include "machine/6532riot.h"
-#include "sound/samples.h"
-#include "sound/dac.h"
-#include "sound/ay8910.h"
-//#include "sound/votrax.h"
-#include "sound/sp0250.h"
 #include "includes/gottlieb.h"
 
 
@@ -22,118 +49,26 @@
 #define SOUND2_SPEECH_CLOCK	XTAL_3_12MHz
 
 
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
+extern const device_type GOTTLIEB_SOUND_REV1 = &device_creator<gottlieb_sound_r1_device>;
+extern const device_type GOTTLIEB_SOUND_REV1_WITH_VOTRAX = &device_creator<gottlieb_sound_r1_with_votrax_device>;
+extern const device_type GOTTLIEB_SOUND_REV2 = &device_creator<gottlieb_sound_r2_device>;
 
 
 
+//**************************************************************************
+//  OLD CRAPPY SAMPLE PLAYER
+//**************************************************************************
 
+#if USE_FAKE_VOTRAX
 
-
-static void gottlieb1_sh_w(device_t *riot, UINT8 data);
-static void gottlieb2_sh_w(address_space *space, UINT8 data);
-static void trigger_sample(samples_device *samples, UINT8 data);
-
-
-
-/*************************************
- *
- *  Generic interfaces
- *
- *************************************/
-
-WRITE8_HANDLER( gottlieb_sh_w )
-{
-	device_t *riot = space->machine().device("riot");
-
-	/* identify rev1 boards by the presence of a 6532 RIOT device */
-	if (riot != NULL)
-		gottlieb1_sh_w(riot, data);
-	else
-		gottlieb2_sh_w(space, data);
-}
-
-
-
-/*************************************
- *
- *  Rev. 1 handlers
- *
- *************************************/
-
-static void gottlieb1_sh_w(device_t *riot, UINT8 data)
-{
-	samples_device *samples = riot->machine().device<samples_device>("samples");
-	int pa7 = (data & 0x0f) != 0xf;
-	int pa0_5 = ~data & 0x3f;
-
-	/* snoop the data looking for commands that need samples */
-	if (pa7 && samples != NULL)
-		trigger_sample(samples, pa0_5);
-
-	/* write the command data to the low 6 bits, and the trigger to the upper bit */
-	riot6532_porta_in_set(riot, pa0_5 | (pa7 << 7), 0xbf);
-}
-
-
-
-/*************************************
- *
- *  Rev. 1 RIOT interfaces
- *
- *************************************/
-
-static WRITE_LINE_DEVICE_HANDLER( snd_interrupt )
-{
-	cputag_set_input_line(device->machine(), "audiocpu", M6502_IRQ_LINE, state);
-}
-
-
-static WRITE8_DEVICE_HANDLER( r6532_portb_w )
-{
-	/* unsure if this is ever used, but the NMI is connected to the RIOT's PB7 */
-	cputag_set_input_line(device->machine(), "audiocpu", INPUT_LINE_NMI, (data & 0x80) ? CLEAR_LINE : ASSERT_LINE);
-}
-
-
-static const riot6532_interface gottlieb_riot6532_intf =
-{
-	DEVCB_NULL,
-	DEVCB_INPUT_PORT("SB1"),
-	DEVCB_NULL,
-	DEVCB_HANDLER(r6532_portb_w),
-	DEVCB_LINE(snd_interrupt)
-};
-
-
-
-/*************************************
- *
- *  Rev. 1 sample players
- *
- *************************************/
-
-static void play_sample(samples_device *samples, const char *phonemes)
-{
-	if (strcmp(phonemes, "[0] HEH3LOOW     AH1EH3I3YMTERI2NDAHN") == 0)	  /* Q-Bert - Hello, I am turned on */
-		samples->start(0, 42);
-	else if (strcmp(phonemes, "[0]BAH1EH1Y") == 0)							  /* Q-Bert - Bye, bye */
-		samples->start(0, 43);
-	else if (strcmp(phonemes, "[0]A2YHT LEH2FTTH") == 0)					  /* Reactor - Eight left */
-		samples->start(0, 0);
-	else if (strcmp(phonemes, "[0]SI3KS DTYN LEH2FTTH") == 0)				  /* Reactor - Sixteen left */
-		samples->start(0, 1);
-	else if (strcmp(phonemes, "[0]WO2RNYNG KO2R UH1NSDTABUH1L") == 0)		  /* Reactor - Warning core unstable */
-		samples->start(0, 5);
-	else if (strcmp(phonemes, "[0]CHAMBERR   AE1EH2KTI1VA1I3DTEH1DT ") == 0) /* Reactor - Chamber activated */
-		samples->start(0, 7);
-}
-
-
-static void trigger_sample(samples_device *samples, UINT8 data)
+void gottlieb_sound_r1_device::trigger_sample(UINT8 data)
 {
-	gottlieb_state *state = samples->machine().driver_data<gottlieb_state>();
 	/* Reactor samples */
-	if (strcmp(samples->machine().system().name, "reactor") == 0)
+	if (strcmp(machine().system().name, "reactor") == 0)
 	{
 		switch (data)
 		{
@@ -141,17 +76,17 @@
 			case 56:
 			case 57:
 			case 59:
-				samples->start(0, data - 53);
+				m_samples->start(0, data - 53);
 				break;
 
 			case 31:
-				state->m_score_sample = 7;
+				m_score_sample = 7;
 				break;
 
 			case 39:
-				state->m_score_sample++;
-				if (state->m_score_sample < 20)
-					samples->start(0, state->m_score_sample);
+				m_score_sample++;
+				if (m_score_sample < 20)
+					m_samples->start(0, m_score_sample);
 				break;
 		}
 	}
@@ -166,52 +101,28 @@
 			case 19:
 			case 20:
 			case 21:
-				samples->start(0, (data - 17) * 8 + state->m_random_offset);
-				state->m_random_offset = (state->m_random_offset + 1) & 7;
+				m_samples->start(0, (data - 17) * 8 + m_random_offset);
+				m_random_offset = (m_random_offset + 1) & 7;
 				break;
 
 			case 22:
-				samples->start(0,40);
+				m_samples->start(0,40);
 				break;
 
 			case 23:
-				samples->start(0,41);
+				m_samples->start(0,41);
 				break;
 		}
 	}
 }
 
-
-#ifdef UNUSED_FUNCTION
-void gottlieb_knocker(running_machine &machine)
+void gottlieb_sound_r1_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
 {
-	samples_device *samples = space->machine().device<samples_device>("samples");
-	if (!strcmp(machine.system().name,"reactor"))	/* reactor */
-	{
-	}
-	else if (samples != NULL)	/* qbert */
-		samples->start(0,44);
+	m_audiocpu->set_input_line(INPUT_LINE_NMI, PULSE_LINE);
 }
-#endif
-
 
-
-/*************************************
- *
- *  Rev. 1 speech interface
- *
- *************************************/
-
-/* callback for the timer */
-static TIMER_CALLBACK( gottlieb_nmi_generate )
-{
-	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_NMI, PULSE_LINE);
-}
-
-
-static WRITE8_HANDLER( vortrax_data_w )
+void gottlieb_sound_r1_device::fake_votrax_data_w(UINT8 data)
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
 	static const char *const PhonemeTable[0x40] =
 	{
 		"EH3", "EH2", "EH1", "PA0", "DT" , "A1" , "A2" , "ZH",
@@ -228,23 +139,22 @@
 
 logerror("Votrax: intonation %d, phoneme %02x %s\n",data >> 6,data & 0x3f,PhonemeTable[data & 0x3f]);
 
-	state->m_votrax_queue[state->m_votrax_queuepos++] = data;
+	m_votrax_queue[m_votrax_queuepos++] = data;
 
 	if ((data & 0x3f) == 0x3f)
 	{
-		if (state->m_votrax_queuepos > 1)
+		if (m_votrax_queuepos > 1)
 		{
-			samples_device *samples = space->machine().device<samples_device>("samples");
 			int last = -1;
 			int i;
 			char phonemes[200];
 
 			phonemes[0] = 0;
-			for (i = 0;i < state->m_votrax_queuepos-1;i++)
+			for (i = 0;i < m_votrax_queuepos-1;i++)
 			{
 				static const char *const inf[4] = { "[0]", "[1]", "[2]", "[3]" };
-				int phoneme = state->m_votrax_queue[i] & 0x3f;
-				int inflection = state->m_votrax_queue[i] >> 6;
+				int phoneme = m_votrax_queue[i] & 0x3f;
+				int inflection = m_votrax_queue[i] >> 6;
 				if (inflection != last) strcat(phonemes, inf[inflection]);
 				last = inflection;
 				if (phoneme == 0x03 || phoneme == 0x3e) strcat(phonemes," ");
@@ -252,93 +162,339 @@
 			}
 
 			mame_printf_debug("Votrax played '%s'\n", phonemes);
-			play_sample(samples, phonemes);
-#if 0
-			popmessage("%s", phonemes);
-#endif
+			if (strcmp(phonemes, "[0] HEH3LOOW     AH1EH3I3YMTERI2NDAHN") == 0)	  /* Q-Bert - Hello, I am turned on */
+				m_samples->start(0, 42);
+			else if (strcmp(phonemes, "[0]BAH1EH1Y") == 0)							  /* Q-Bert - Bye, bye */
+				m_samples->start(0, 43);
+			else if (strcmp(phonemes, "[0]A2YHT LEH2FTTH") == 0)					  /* Reactor - Eight left */
+				m_samples->start(0, 0);
+			else if (strcmp(phonemes, "[0]SI3KS DTYN LEH2FTTH") == 0)				  /* Reactor - Sixteen left */
+				m_samples->start(0, 1);
+			else if (strcmp(phonemes, "[0]WO2RNYNG KO2R UH1NSDTABUH1L") == 0)		  /* Reactor - Warning core unstable */
+				m_samples->start(0, 5);
+			else if (strcmp(phonemes, "[0]CHAMBERR   AE1EH2KTI1VA1I3DTEH1DT ") == 0) /* Reactor - Chamber activated */
+				m_samples->start(0, 7);
 		}
 
-		state->m_votrax_queuepos = 0;
+		m_votrax_queuepos = 0;
 	}
 
 	/* generate a NMI after a while to make the CPU continue to send data */
-	space->machine().scheduler().timer_set(attotime::from_usec(50), FUNC(gottlieb_nmi_generate));
+	timer_set(attotime::from_usec(50));
+}
+
+static const char *const reactor_sample_names[] =
+{
+	"*reactor",
+	"fx_53", /* "8 left" */
+	"fx_54", /* "16 left" */
+	"fx_55", /* "24 left" */
+	"fx_56", /* "32 left" */
+	"fx_57", /* "40 left" */
+	"fx_58", /* "warning, core unstable" */
+	"fx_59", /* "bonus" */
+	"fx_31", /* "chamber activated" */
+	"fx_39a", /* "2000" */
+	"fx_39b", /* "5000" */
+	"fx_39c", /* "10000" */
+	"fx_39d", /* "15000" */
+	"fx_39e", /* "20000" */
+	"fx_39f", /* "25000" */
+	"fx_39g", /* "30000" */
+	"fx_39h", /* "35000" */
+	"fx_39i", /* "40000" */
+	"fx_39j", /* "45000" */
+	"fx_39k", /* "50000" */
+	"fx_39l", /* "55000" */
+     0	/* end of array */
+};
+
+static const char *const qbert_sample_names[] =
+{
+	"*qbert",
+	"fx_17a", /* random speech, voice clock 255 */
+	"fx_17b", /* random speech, voice clock 255 */
+	"fx_17c", /* random speech, voice clock 255 */
+	"fx_17d", /* random speech, voice clock 255 */
+	"fx_17e", /* random speech, voice clock 255 */
+	"fx_17f", /* random speech, voice clock 255 */
+	"fx_17g", /* random speech, voice clock 255 */
+	"fx_17h", /* random speech, voice clock 255 */
+	"fx_18a", /* random speech, voice clock 176 */
+	"fx_18b", /* random speech, voice clock 176 */
+	"fx_18c", /* random speech, voice clock 176 */
+	"fx_18d", /* random speech, voice clock 176 */
+	"fx_18e", /* random speech, voice clock 176 */
+	"fx_18f", /* random speech, voice clock 176 */
+	"fx_18g", /* random speech, voice clock 176 */
+	"fx_18h", /* random speech, voice clock 176 */
+	"fx_19a", /* random speech, voice clock 128 */
+	"fx_19b", /* random speech, voice clock 128 */
+	"fx_19c", /* random speech, voice clock 128 */
+	"fx_19d", /* random speech, voice clock 128 */
+	"fx_19e", /* random speech, voice clock 128 */
+	"fx_19f", /* random speech, voice clock 128 */
+	"fx_19g", /* random speech, voice clock 128 */
+	"fx_19h", /* random speech, voice clock 128 */
+	"fx_20a", /* random speech, voice clock 96 */
+	"fx_20b", /* random speech, voice clock 96 */
+	"fx_20c", /* random speech, voice clock 96 */
+	"fx_20d", /* random speech, voice clock 96 */
+	"fx_20e", /* random speech, voice clock 96 */
+	"fx_20f", /* random speech, voice clock 96 */
+	"fx_20g", /* random speech, voice clock 96 */
+	"fx_20h", /* random speech, voice clock 96 */
+	"fx_21a", /* random speech, voice clock 62 */
+	"fx_21b", /* random speech, voice clock 62 */
+	"fx_21c", /* random speech, voice clock 62 */
+	"fx_21d", /* random speech, voice clock 62 */
+	"fx_21e", /* random speech, voice clock 62 */
+	"fx_21f", /* random speech, voice clock 62 */
+	"fx_21g", /* random speech, voice clock 62 */
+	"fx_21h", /* random speech, voice clock 62 */
+	"fx_22", /* EH2 with decreasing voice clock */
+	"fx_23", /* O1 with varying voice clock */
+	"fx_28",
+	"fx_36",
+	"knocker",
+	0	/* end of array */
+};
+
+static const samples_interface reactor_samples_interface =
+{
+	1,	/* one channel */
+	reactor_sample_names
+};
+
+static const samples_interface qbert_samples_interface =
+{
+	1,	/* one channel */
+	qbert_sample_names
+};
+
+MACHINE_CONFIG_FRAGMENT( reactor_samples )
+	MCFG_SAMPLES_ADD("samples", reactor_samples_interface)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_CONFIG_END
+
+MACHINE_CONFIG_FRAGMENT( qbert_samples )
+	MCFG_SAMPLES_ADD("samples", qbert_samples_interface)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_CONFIG_END
+
+#endif
+
+
+
+//**************************************************************************
+//  REV 1 SOUND BOARD: 6502 + DAC
+//**************************************************************************
+
+//-------------------------------------------------
+//  gottlieb_sound_r1_device - constructors
+//-------------------------------------------------
+
+gottlieb_sound_r1_device::gottlieb_sound_r1_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, GOTTLIEB_SOUND_REV1, "Gottlieb Sound rev. 1", "gotsndr1", tag, owner, clock),
+	  device_mixer_interface(mconfig, *this),
+	  m_audiocpu(*this, "audiocpu"),
+	  m_riot(*this, "riot"),
+	  m_dac(*this, "dac"),
+	  m_votrax(*this, "votrax"),
+	  m_populate_votrax(false),
+	  m_last_speech_clock(0)
+#if USE_FAKE_VOTRAX
+	  , m_samples(*this, ":samples"),
+	  m_score_sample(0),
+	  m_random_offset(0),
+	  m_votrax_queuepos(0)
+#endif
+{
+}
+
+gottlieb_sound_r1_device::gottlieb_sound_r1_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock, bool populate_votrax)
+	: device_t(mconfig, GOTTLIEB_SOUND_REV1, "Gottlieb Sound rev. 1", "gotsndr1", tag, owner, clock),
+	  device_mixer_interface(mconfig, *this),
+	  m_audiocpu(*this, "audiocpu"),
+	  m_riot(*this, "riot"),
+	  m_dac(*this, "dac"),
+	  m_votrax(*this, "votrax"),
+	  m_populate_votrax(populate_votrax),
+	  m_last_speech_clock(0)
+#if USE_FAKE_VOTRAX
+	  , m_samples(*this, ":samples"),
+	  m_score_sample(0),
+	  m_random_offset(0),
+	  m_votrax_queuepos(0)
+#endif
+{
+}
+
+
+//-------------------------------------------------
+//  write - handle an external command write
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r1_device::write )
+{
+	// write the command data to the low 6 bits, and the trigger to the upper bit
+	UINT8 pa7 = (data & 0x0f) != 0xf;
+	UINT8 pa0_5 = ~data & 0x3f;
+	m_riot->porta_in_set(pa0_5 | (pa7 << 7), 0xbf);
+
+#if USE_FAKE_VOTRAX
+	if (pa7 && m_samples != NULL)
+		trigger_sample(pa0_5);
+#endif
+}
+
+
+//-------------------------------------------------
+//  snd_interrupt - signal a sound interrupt
+//-------------------------------------------------
+
+WRITE_LINE_MEMBER( gottlieb_sound_r1_device::snd_interrupt )
+{
+	m_audiocpu->set_input_line(M6502_IRQ_LINE, state);
+}
+
+
+//-------------------------------------------------
+//  r6532_portb_w - handle writes to the RIOT's
+//  port B
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r1_device::r6532_portb_w )
+{
+	// unsure if this is ever used, but the NMI is connected to the RIOT's PB7
+	m_audiocpu->set_input_line(INPUT_LINE_NMI, (data & 0x80) ? CLEAR_LINE : ASSERT_LINE);
 }
 
-static WRITE8_HANDLER( speech_clock_dac_w )
+
+//-------------------------------------------------
+//  votrax_data_w - write data to the Votrax SC-01
+//  speech chip
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r1_device::votrax_data_w )
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
-if (data != state->m_last)
-	mame_printf_debug("clock = %02X\n", data);
-state->m_last = data;
+	if (m_votrax != NULL)
+	{
+		m_votrax->inflection_w(space, offset, data >> 6);
+		m_votrax->write(space, offset, ~data & 0x3f);
+	}
+
+#if USE_FAKE_VOTRAX
+	fake_votrax_data_w(data);
+#endif
 }
 
 
-/*************************************
- *
- *  Rev 1. initialization
- *
- *************************************/
+//-------------------------------------------------
+//  speech_clock_dac_w - modify the clock driving
+//  the Votrax SC-01 speech chip
+//-------------------------------------------------
 
-static SOUND_START( gottlieb1 )
+WRITE8_MEMBER( gottlieb_sound_r1_device::speech_clock_dac_w )
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	state->m_score_sample = 7;
-	state->m_random_offset = 0;
+	if (m_votrax != NULL)
+	{
+		// nominal clock is 0xa0
+		if (data != m_last_speech_clock)
+		{
+			mame_printf_debug("clock = %02X\n", data);
 
-	state_save_register_global_array(machine, state->m_votrax_queue);
-	state_save_register_global(machine, state->m_votrax_queuepos);
+			// totally random guesswork; would like to get real measurements on a board
+			if (m_votrax != NULL)
+				m_votrax->set_unscaled_clock(600000 + (data - 0xa0) * 10000);
+			m_last_speech_clock = data;
+		}
+	}
 }
 
 
+//-------------------------------------------------
+//  votrax_request - map the VOTRAX SC-01 request
+//  line to the NMI pin on the sound chip
+//-------------------------------------------------
+
+WRITE_LINE_MEMBER( gottlieb_sound_r1_device::votrax_request )
+{
+	m_audiocpu->set_input_line(INPUT_LINE_NMI, state);
+}
 
-/*************************************
- *
- *  Rev 1. address map
- *
- *************************************/
 
-static ADDRESS_MAP_START( gottlieb_sound1_map, AS_PROGRAM, 8 )
-	/* A15 not decoded except in expansion socket */
+//-------------------------------------------------
+//  RIOT interface
+//-------------------------------------------------
+
+static const riot6532_interface gottlieb_riot6532_intf =
+{
+	DEVCB_NULL,
+	DEVCB_INPUT_PORT("SB1"),
+	DEVCB_NULL,
+	DEVCB_DEVICE_MEMBER(DEVICE_SELF_OWNER, gottlieb_sound_r1_device, r6532_portb_w),
+	DEVCB_DEVICE_LINE_MEMBER(DEVICE_SELF_OWNER, gottlieb_sound_r1_device, snd_interrupt)
+};
+
+
+//-------------------------------------------------
+//  VOTRAX interface
+//-------------------------------------------------
+
+static const votrax_sc01_interface gottlieb_votrax_interface =
+{
+	DEVCB_DEVICE_LINE_MEMBER(DEVICE_SELF_OWNER, gottlieb_sound_r1_device, votrax_request)
+};
+
+
+//-------------------------------------------------
+//  audio CPU map
+//-------------------------------------------------
+
+static ADDRESS_MAP_START( gottlieb_sound_r1_map, AS_PROGRAM, 8, gottlieb_sound_r1_device )
+	// A15 not decoded except in expansion socket
 	ADDRESS_MAP_GLOBAL_MASK(0x7fff)
 	AM_RANGE(0x0000, 0x007f) AM_MIRROR(0x0d80) AM_RAM
-	AM_RANGE(0x0200, 0x021f) AM_MIRROR(0x0de0) AM_DEVREADWRITE("riot", riot6532_r, riot6532_w)
-	AM_RANGE(0x1000, 0x1000) AM_MIRROR(0x0fff) AM_DEVWRITE("dac", dac_w)
-	AM_RANGE(0x2000, 0x2000) AM_MIRROR(0x0fff) AM_WRITE(vortrax_data_w)
+	AM_RANGE(0x0200, 0x021f) AM_MIRROR(0x0de0) AM_DEVREADWRITE("riot", riot6532_device, read, write)
+	AM_RANGE(0x1000, 0x1000) AM_MIRROR(0x0fff) AM_DEVWRITE_LEGACY("dac", dac_w)
+	AM_RANGE(0x2000, 0x2000) AM_MIRROR(0x0fff) AM_WRITE(votrax_data_w)
 	AM_RANGE(0x3000, 0x3000) AM_MIRROR(0x0fff) AM_WRITE(speech_clock_dac_w)
 	AM_RANGE(0x6000, 0x7fff) AM_ROM
 ADDRESS_MAP_END
 
 
+//-------------------------------------------------
+//  machine configuration
+//-------------------------------------------------
+
+MACHINE_CONFIG_FRAGMENT( gottlieb_sound_r1 )
+	// audio CPU
+	MCFG_CPU_ADD("audiocpu", M6502, SOUND1_CLOCK/4)	// the board can be set to /2 as well
+	MCFG_CPU_PROGRAM_MAP(gottlieb_sound_r1_map)
 
-/*************************************
- *
- *  Rev. 1 machine driver
- *
- *************************************/
-
-MACHINE_CONFIG_FRAGMENT( gottlieb_soundrev1 )
-	MCFG_SOUND_START(gottlieb1)
-
+	// I/O configuration
 	MCFG_RIOT6532_ADD("riot", SOUND1_CLOCK/4, gottlieb_riot6532_intf)
 
-	MCFG_CPU_ADD("audiocpu", M6502, SOUND1_CLOCK/4)	/* the board can be set to /2 as well */
-	MCFG_CPU_PROGRAM_MAP(gottlieb_sound1_map)
-
-	/* sound hardware */
+	// sound devices
 	MCFG_SOUND_ADD("dac", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 0.50)
 MACHINE_CONFIG_END
 
+MACHINE_CONFIG_FRAGMENT( gottlieb_sound_r1_with_votrax )
+	MCFG_FRAGMENT_ADD(gottlieb_sound_r1)
+
+	// add the VOTRAX
+	MCFG_VOTRAX_SC01_ADD("votrax", 720000, gottlieb_votrax_interface)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 0.50)
+MACHINE_CONFIG_END
 
 
-/*************************************
- *
- *  Rev. 1 input ports
- *
- *************************************/
+//-------------------------------------------------
+//  input ports
+//-------------------------------------------------
 
-INPUT_PORTS_START( gottlieb1_sound )
+INPUT_PORTS_START( gottlieb_sound_r1 )
 	PORT_START("SB1")
 	PORT_DIPUNKNOWN_DIPLOC( 0x01, 0x01, "SB1:7" )
 	PORT_DIPUNKNOWN_DIPLOC( 0x02, 0x02, "SB1:6" )
@@ -349,341 +505,387 @@
 	PORT_DIPNAME( 0x40, 0x40, "Sound Test" )			PORT_DIPLOCATION("SB1:2")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x80, 0x80, IPT_UNKNOWN )	/* To U3-6 on QBert */
+	PORT_BIT( 0x80, 0x80, IPT_SPECIAL )
 INPUT_PORTS_END
 
+INPUT_PORTS_START( gottlieb_sound_r1_with_votrax )
+	PORT_INCLUDE(gottlieb_sound_r1)
+	PORT_MODIFY("SB1")
+	PORT_BIT( 0x80, 0x80, IPT_SPECIAL ) PORT_READ_LINE_DEVICE_MEMBER("votrax", votrax_sc01_device, request)
+INPUT_PORTS_END
 
 
-/*************************************
- *
- *  Rev. 2 communication handlers
- *
- *************************************/
+//-------------------------------------------------
+//  device_mconfig_additions - return a pointer to
+//  the device's machine fragment
+//-------------------------------------------------
 
-static void gottlieb2_sh_w(address_space *space, UINT8 data)
+machine_config_constructor gottlieb_sound_r1_device::device_mconfig_additions() const
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
-	/* when data is not 0xff, the transparent latch at A3 allows it to pass through unmolested */
-	if (data != 0xff)
-	{
-		/* each CPU has its own latch */
-		soundlatch_w(space, 0, data);
-		soundlatch2_w(space, 0, data);
-
-		/* if the previous data was 0xff, clock an IRQ on each */
-		if (state->m_last_command == 0xff)
-		{
-			cputag_set_input_line(space->machine(), "audiocpu", M6502_IRQ_LINE, ASSERT_LINE);
-			cputag_set_input_line(space->machine(), "speech", M6502_IRQ_LINE, ASSERT_LINE);
-		}
-	}
-	state->m_last_command = data;
+	return MACHINE_CONFIG_NAME( gottlieb_sound_r1 );
 }
 
 
-static READ8_HANDLER( speech_data_r )
+//-------------------------------------------------
+//  device_input_ports - return a pointer to
+//  the device's I/O ports
+//-------------------------------------------------
+
+ioport_constructor gottlieb_sound_r1_device::device_input_ports() const
 {
-	cputag_set_input_line(space->machine(), "speech", M6502_IRQ_LINE, CLEAR_LINE);
-	return soundlatch_r(space, offset);
+	return INPUT_PORTS_NAME( gottlieb_sound_r1 );
 }
 
 
-static READ8_HANDLER( audio_data_r )
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void gottlieb_sound_r1_device::device_start()
 {
-	cputag_set_input_line(space->machine(), "audiocpu", M6502_IRQ_LINE, CLEAR_LINE);
-	return soundlatch2_r(space, offset);
 }
 
 
-static WRITE8_HANDLER( signal_audio_nmi_w )
+
+//**************************************************************************
+//  REV 1 SOUND BOARD WITH VOTRAX
+//**************************************************************************
+
+//-------------------------------------------------
+//  gottlieb_sound_r1_with_votrax_device -
+//  constructor
+//-------------------------------------------------
+
+gottlieb_sound_r1_with_votrax_device::gottlieb_sound_r1_with_votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: gottlieb_sound_r1_device(mconfig, tag, owner, clock, true)
 {
-	cputag_set_input_line(space->machine(), "audiocpu", INPUT_LINE_NMI, ASSERT_LINE);
-	cputag_set_input_line(space->machine(), "audiocpu", INPUT_LINE_NMI, CLEAR_LINE);
 }
 
 
+//-------------------------------------------------
+//  device_mconfig_additions - return a pointer to
+//  the device's machine fragment
+//-------------------------------------------------
+
+machine_config_constructor gottlieb_sound_r1_with_votrax_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME( gottlieb_sound_r1_with_votrax );
+}
 
-/*************************************
- *
- *  Rev. 2 NMI timer
- *
- *************************************/
 
-INLINE void nmi_timer_adjust(running_machine &machine)
+//-------------------------------------------------
+//  device_input_ports - return a pointer to
+//  the device's I/O ports
+//-------------------------------------------------
+
+ioport_constructor gottlieb_sound_r1_with_votrax_device::device_input_ports() const
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	/* adjust timer to go off in the future based on the current rate */
-	state->m_nmi_timer->adjust(attotime::from_hz(SOUND2_CLOCK/16) * (256 * (256 - state->m_nmi_rate)));
+	return INPUT_PORTS_NAME( gottlieb_sound_r1_with_votrax );
 }
 
 
-INLINE void nmi_state_update(running_machine &machine)
+
+//**************************************************************************
+//  REV 2 SOUND BOARD: 6502 + 2 x DAC + 2 x AY-8913
+//**************************************************************************
+
+//-------------------------------------------------
+//  gottlieb_sound_r2_device - constructor
+//-------------------------------------------------
+
+gottlieb_sound_r2_device::gottlieb_sound_r2_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, GOTTLIEB_SOUND_REV2, "Gottlieb Sound rev. 2", "gotsndr2", tag, owner, clock),
+	  device_mixer_interface(mconfig, *this),
+	  m_audiocpu(*this, "audiocpu"),
+	  m_speechcpu(*this, "speechcpu"),
+	  m_dac(*this, "dac"),
+	  m_ay1(*this, "ay1"),
+	  m_ay2(*this, "ay2"),
+	  m_sp0250(*this, "spsnd"),
+	  m_cobram3_mod(false),
+	  m_nmi_timer(NULL),
+	  m_nmi_state(0),
+	  m_audiocpu_latch(0),
+	  m_speechcpu_latch(0),
+	  m_speech_control(0),
+	  m_last_command(0),
+	  m_psg_latch(0),
+	  m_psg_data_latch(0),
+	  m_sp0250_latch(0)
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	/* update the NMI line state based on the enable and state */
-	cputag_set_input_line(machine, "speech", INPUT_LINE_NMI, (state->m_nmi_state && (state->m_speech_control & 1)) ? ASSERT_LINE : CLEAR_LINE);
 }
 
 
-static TIMER_CALLBACK( nmi_clear )
+//-------------------------------------------------
+//  static_enable_cobram3_mods - enable changes
+//  for cobram3
+//-------------------------------------------------
+
+void gottlieb_sound_r2_device::static_enable_cobram3_mods(device_t &device)
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	/* clear the NMI state and update it */
-	state->m_nmi_state = 0;
-	nmi_state_update(machine);
+	downcast<gottlieb_sound_r2_device &>(device).m_cobram3_mod = true;
 }
 
 
-static TIMER_CALLBACK( nmi_callback )
+//-------------------------------------------------
+//  write - handle an external command write
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r2_device::write )
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	/* assert the NMI if it is not disabled */
-	state->m_nmi_state = 1;
-	nmi_state_update(machine);
+	// when data is not 0xff, the transparent latch at A3 allows it to pass through unmolested
+	if (data != 0xff)
+	{
+		// latch data on a timer
+		synchronize(TID_SOUND_LATCH_WRITE, data);
 
-	/* set a timer to turn it off again on hte next SOUND_CLOCK/16 */
-	machine.scheduler().timer_set(attotime::from_hz(SOUND2_CLOCK/16), FUNC(nmi_clear));
+		// if the previous data was 0xff, clock an IRQ on each
+		if (m_last_command == 0xff)
+		{
+			m_audiocpu->set_input_line(M6502_IRQ_LINE, ASSERT_LINE);
+			m_speechcpu->set_input_line(M6502_IRQ_LINE, ASSERT_LINE);
+		}
+	}
+	m_last_command = data;
+}
 
-	/* adjust the NMI timer for the next time */
-	nmi_timer_adjust(machine);
+
+//-------------------------------------------------
+//  nmi_timer_adjust - adjust the NMI timer to
+//  fire based on its configured rate
+//-------------------------------------------------
+
+inline void gottlieb_sound_r2_device::nmi_timer_adjust()
+{
+	// adjust timer to go off in the future based on the current rate
+	m_nmi_timer->adjust(attotime::from_hz(SOUND2_CLOCK/16) * (256 * (256 - m_nmi_rate)));
 }
 
 
-static WRITE8_HANDLER( nmi_rate_w )
+//-------------------------------------------------
+//  nmi_state_update - update the NMI state based
+//  on the timer firing and the enable control
+//-------------------------------------------------
+
+inline void gottlieb_sound_r2_device::nmi_state_update()
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
-	/* the new rate is picked up when the previous timer expires */
-	state->m_nmi_rate = data;
+	// update the NMI line state based on the enable and state
+	m_speechcpu->set_input_line(INPUT_LINE_NMI, (m_nmi_state && (m_speech_control & 1)) ? ASSERT_LINE : CLEAR_LINE);
 }
 
 
+//-------------------------------------------------
+//  speech_data_r - read the input command latch
+//  from the audio CPU
+//-------------------------------------------------
+
+READ8_MEMBER( gottlieb_sound_r2_device::audio_data_r )
+{
+	m_audiocpu->set_input_line(M6502_IRQ_LINE, CLEAR_LINE);
+	return m_audiocpu_latch;
+}
 
-/*************************************
- *
- *  Rev. 2 sound chip access
- *
- *************************************/
 
-static CUSTOM_INPUT( speech_drq_custom_r )
+//-------------------------------------------------
+//  speech_data_r - read the input command latch
+//  from the speech CPU
+//-------------------------------------------------
+
+READ8_MEMBER( gottlieb_sound_r2_device::speech_data_r )
 {
-	return sp0250_drq_r(field.machine().device("spsnd"));
+	m_speechcpu->set_input_line(M6502_IRQ_LINE, CLEAR_LINE);
+	return m_speechcpu_latch;
 }
 
 
-static WRITE8_DEVICE_HANDLER( gottlieb_dac_w )
+//-------------------------------------------------
+//  signal_audio_nmi_w - signal an NMI from the
+//  speech CPU to the audio CPU
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r2_device::signal_audio_nmi_w )
 {
-	gottlieb_state *state = device->machine().driver_data<gottlieb_state>();
-	/* dual DAC; the first DAC serves as the reference voltage for the
-       second, effectively scaling the output */
-	state->m_dac_data[offset] = data;
-	dac_data_16_w(device, state->m_dac_data[0] * state->m_dac_data[1]);
+	m_audiocpu->set_input_line(INPUT_LINE_NMI, ASSERT_LINE);
+	m_audiocpu->set_input_line(INPUT_LINE_NMI, CLEAR_LINE);
 }
 
 
-static WRITE8_HANDLER( speech_control_w )
+//-------------------------------------------------
+//  nmi_rate_w - adjust the NMI rate on the speech
+//  CPU
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r2_device::nmi_rate_w )
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
-	UINT8 previous = state->m_speech_control;
-	state->m_speech_control = data;
+	// the new rate is picked up when the previous timer expires
+	m_nmi_rate = data;
+}
 
-	/* bit 0 enables/disables the NMI line */
-	nmi_state_update(space->machine());
 
-	/* bit 1 controls a LED on the sound board */
+//-------------------------------------------------
+//  speech_drq_custom_r - return the SP0250
+//  request line as an input port bit
+//-------------------------------------------------
 
-	/* bit 2 goes to 8913 BDIR pin */
-	if ((previous & 0x04) != 0 && (data & 0x04) == 0)
-	{
-		/* bit 3 selects which of the two 8913 to enable */
-		/* bit 4 goes to the 8913 BC1 pin */
-		device_t *ay = space->machine().device((data & 0x08) ? "ay1" : "ay2");
-		ay8910_data_address_w(ay, data >> 4, *state->m_psg_latch);
-	}
+CUSTOM_INPUT_MEMBER( gottlieb_sound_r2_device::speech_drq_custom_r )
+{
+	return sp0250_drq_r(m_sp0250);
+}
 
-	/* bit 5 goes to the speech chip DIRECT DATA TEST pin */
 
-	/* bit 6 = speech chip DATA PRESENT pin; high then low to make the chip read data */
-	if ((previous & 0x40) == 0 && (data & 0x40) != 0)
-	{
-		device_t *sp = space->machine().device("spsnd");
-		sp0250_w(sp, 0, *state->m_sp0250_latch);
-	}
+//-------------------------------------------------
+//  dac_w - write to one of the two DACs on the
+//  board
+//-------------------------------------------------
 
-	/* bit 7 goes to the speech chip RESET pin */
-	if ((previous ^ data) & 0x80)
-		space->machine().device("spsnd")->reset();
+WRITE8_MEMBER( gottlieb_sound_r2_device::dac_w )
+{
+	// dual DAC; the first DAC serves as the reference voltage for the
+    // second, effectively scaling the output
+	m_dac_data[offset] = data;
+	dac_data_16_w(m_dac, m_dac_data[0] * m_dac_data[1]);
 }
 
-static WRITE8_HANDLER( cobram3_speech_control_w )
+
+//-------------------------------------------------
+//  speech_control_w - primary audio control
+//  register on the speech board
+//-------------------------------------------------
+
+WRITE8_MEMBER( gottlieb_sound_r2_device::speech_control_w )
 {
-	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
-	UINT8 previous = state->m_speech_control;
-	state->m_speech_control = data;
+	UINT8 previous = m_speech_control;
+	m_speech_control = data;
 
-	/* bit 0 enables/disables the NMI line */
-	nmi_state_update(space->machine());
+	// bit 0 enables/disables the NMI line
+	nmi_state_update();
 
-	/* bit 1 controls a LED on the sound board */
+	// bit 1 controls a LED on the sound board
 
-	if ( data & 0x10 )
+	// bits 2-4 control the AY-8913, but act differently between the
+	// standard sound board and the modified Cobra Command board
+	if (!m_cobram3_mod)
 	{
-		state->m_psg_data_latch = *state->m_psg_latch;
+		// bit 2 goes to 8913 BDIR pin
+		if ((previous & 0x04) != 0 && (data & 0x04) == 0)
+		{
+			// bit 3 selects which of the two 8913 to enable
+			// bit 4 goes to the 8913 BC1 pin
+			if ((data & 0x08) != 0)
+				ay8910_data_address_w(m_ay1, data >> 4, m_psg_latch);
+			else
+				ay8910_data_address_w(m_ay2, data >> 4, m_psg_latch);
+		}
 	}
 	else
 	{
-		device_t *ay = space->machine().device((data & 0x08) ? "ay1" : "ay2");
-		ay8910_address_w(ay, 0, *state->m_psg_latch);
-		ay8910_data_w(ay, 0, state->m_psg_data_latch);
+		if ( data & 0x10 )
+		{
+			m_psg_data_latch = m_psg_latch;
+		}
+		else
+		{
+			device_t *ay = machine().device((data & 0x08) ? "ay1" : "ay2");
+			ay8910_address_w(ay, 0, m_psg_latch);
+			ay8910_data_w(ay, 0, m_psg_data_latch);
+		}
 	}
-	/* bit 5 goes to the speech chip DIRECT DATA TEST pin */
 
-	/* bit 6 = speech chip DATA PRESENT pin; high then low to make the chip read data */
+	// bit 5 goes to the speech chip DIRECT DATA TEST pin
+
+	// bit 6 = speech chip DATA PRESENT pin; high then low to make the chip read data
 	if ((previous & 0x40) == 0 && (data & 0x40) != 0)
-	{
-		device_t *sp = space->machine().device("spsnd");
-		sp0250_w(sp, 0, *state->m_sp0250_latch);
-	}
+		sp0250_w(m_sp0250, 0, m_sp0250_latch);
 
-	/* bit 7 goes to the speech chip RESET pin */
+	// bit 7 goes to the speech chip RESET pin
 	if ((previous ^ data) & 0x80)
-		space->machine().device("spsnd")->reset();
+		m_sp0250->reset();
 }
 
 
-/*************************************
- *
- *  Rev. 2 initialization
- *
- *************************************/
+//-------------------------------------------------
+//  psg_latch_w - store an 8-bit value in the PSG
+//  latch register
+//-------------------------------------------------
 
-static SOUND_START( gottlieb2 )
+WRITE8_MEMBER( gottlieb_sound_r2_device::psg_latch_w )
 {
-	gottlieb_state *state = machine.driver_data<gottlieb_state>();
-	/* set up the NMI timer */
-	state->m_nmi_timer = machine.scheduler().timer_alloc(FUNC(nmi_callback));
-	state->m_nmi_rate = 0;
-	nmi_timer_adjust(machine);
+	m_psg_latch = data;
+}
 
-	state->m_dac_data[0] = state->m_dac_data[1] = 0xff;
 
-	/* register for save states */
-	state_save_register_global(machine, state->m_nmi_rate);
-	state_save_register_global(machine, state->m_nmi_state);
-	state_save_register_global(machine, state->m_speech_control);
-	state_save_register_global(machine, state->m_last_command);
-}
+//-------------------------------------------------
+//  psg_latch_w - store an 8-bit value in the
+//  SP0250 latch register
+//-------------------------------------------------
 
+WRITE8_MEMBER( gottlieb_sound_r2_device::sp0250_latch_w )
+{
+	m_sp0250_latch = data;
+}
 
 
-/*************************************
- *
- *  Rev. 2 address map
- *
- *************************************/
+//-------------------------------------------------
+//  sound CPU address map
+//-------------------------------------------------
 
-static ADDRESS_MAP_START( gottlieb_speech2_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x03ff) AM_MIRROR(0x1c00) AM_RAM
-	AM_RANGE(0x2000, 0x2000) AM_MIRROR(0x1fff) AM_WRITEONLY AM_BASE_MEMBER(gottlieb_state, m_sp0250_latch)
-	AM_RANGE(0x4000, 0x4000) AM_MIRROR(0x1fff) AM_WRITE(speech_control_w)
-	AM_RANGE(0x6000, 0x6000) AM_MIRROR(0x1fff) AM_READ_PORT("SB2")
-	AM_RANGE(0x8000, 0x8000) AM_MIRROR(0x1fff) AM_WRITEONLY AM_BASE_MEMBER(gottlieb_state, m_psg_latch)
-	AM_RANGE(0xa000, 0xa000) AM_MIRROR(0x07ff) AM_WRITE(nmi_rate_w)
-	AM_RANGE(0xa800, 0xa800) AM_MIRROR(0x07ff) AM_READ(speech_data_r)
-	AM_RANGE(0xb000, 0xb000) AM_MIRROR(0x07ff) AM_WRITE(signal_audio_nmi_w)
-	AM_RANGE(0xc000, 0xffff) AM_ROM
+static ADDRESS_MAP_START( gottlieb_sound_r2_map, AS_PROGRAM, 8, gottlieb_sound_r2_device )
+	AM_RANGE(0x0000, 0x03ff) AM_MIRROR(0x3c00) AM_RAM
+	AM_RANGE(0x4000, 0x4001) AM_MIRROR(0x3ffe) AM_WRITE(dac_w)
+	AM_RANGE(0x8000, 0x8000) AM_MIRROR(0x3fff) AM_READ(audio_data_r)
+	AM_RANGE(0xe000, 0xffff) AM_MIRROR(0x2000) AM_ROM
 ADDRESS_MAP_END
 
 
-static ADDRESS_MAP_START( gottlieb_cobram3_speech2_map, AS_PROGRAM, 8 )
+//-------------------------------------------------
+//  sppech CPU address map
+//-------------------------------------------------
+
+static ADDRESS_MAP_START( gottlieb_speech_r2_map, AS_PROGRAM, 8, gottlieb_sound_r2_device )
 	AM_RANGE(0x0000, 0x03ff) AM_MIRROR(0x1c00) AM_RAM
-	AM_RANGE(0x2000, 0x2000) AM_MIRROR(0x1fff) AM_WRITEONLY AM_BASE_MEMBER(gottlieb_state, m_sp0250_latch)
-	AM_RANGE(0x4000, 0x4000) AM_MIRROR(0x1fff) AM_WRITE(cobram3_speech_control_w)
+	AM_RANGE(0x2000, 0x2000) AM_MIRROR(0x1fff) AM_WRITE(sp0250_latch_w)
+	AM_RANGE(0x4000, 0x4000) AM_MIRROR(0x1fff) AM_WRITE(speech_control_w)
 	AM_RANGE(0x6000, 0x6000) AM_MIRROR(0x1fff) AM_READ_PORT("SB2")
-	AM_RANGE(0x8000, 0x8000) AM_MIRROR(0x1fff) AM_WRITEONLY AM_BASE_MEMBER(gottlieb_state, m_psg_latch)
+	AM_RANGE(0x8000, 0x8000) AM_MIRROR(0x1fff) AM_WRITE(psg_latch_w)
 	AM_RANGE(0xa000, 0xa000) AM_MIRROR(0x07ff) AM_WRITE(nmi_rate_w)
 	AM_RANGE(0xa800, 0xa800) AM_MIRROR(0x07ff) AM_READ(speech_data_r)
 	AM_RANGE(0xb000, 0xb000) AM_MIRROR(0x07ff) AM_WRITE(signal_audio_nmi_w)
 	AM_RANGE(0xc000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( gottlieb_audio2_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x03ff) AM_MIRROR(0x3c00) AM_RAM
-	AM_RANGE(0x4000, 0x4001) AM_MIRROR(0x3ffe) AM_DEVWRITE("dac1", gottlieb_dac_w) AM_BASE_MEMBER(gottlieb_state, m_dac_data)
-	AM_RANGE(0x8000, 0x8000) AM_MIRROR(0x3fff) AM_READ(audio_data_r)
-	AM_RANGE(0xe000, 0xffff) AM_MIRROR(0x2000) AM_ROM
-ADDRESS_MAP_END
-
 
+//-------------------------------------------------
+//  machine configuration
+//-------------------------------------------------
 
-/*************************************
- *
- *  Rev. 2 machine driver
- *
- *************************************/
-
-MACHINE_CONFIG_FRAGMENT( gottlieb_soundrev2 )
-	/* audio CPUs */
+MACHINE_CONFIG_FRAGMENT( gottlieb_sound_r2 )
+	// audio CPUs
 	MCFG_CPU_ADD("audiocpu", M6502, SOUND2_CLOCK/4)
-	MCFG_CPU_PROGRAM_MAP(gottlieb_audio2_map)
-
-	MCFG_CPU_ADD("speech", M6502, SOUND2_CLOCK/4)
-	MCFG_CPU_PROGRAM_MAP(gottlieb_speech2_map)
+	MCFG_CPU_PROGRAM_MAP(gottlieb_sound_r2_map)
 
-	/* sound hardware */
-	MCFG_SOUND_START( gottlieb2 )
+	MCFG_CPU_ADD("speechcpu", M6502, SOUND2_CLOCK/4)
+	MCFG_CPU_PROGRAM_MAP(gottlieb_speech_r2_map)
 
-	MCFG_SOUND_ADD("dac1", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
-
-	MCFG_SOUND_ADD("dac2", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
+	// sound hardware
+	MCFG_SOUND_ADD("dac", DAC, 0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 0.15)
 
 	MCFG_SOUND_ADD("ay1", AY8913, SOUND2_CLOCK/2)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 0.15)
 
 	MCFG_SOUND_ADD("ay2", AY8913, SOUND2_CLOCK/2)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 0.15)
 
 	MCFG_SOUND_ADD("spsnd", SP0250, SOUND2_SPEECH_CLOCK)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 1.0)
 MACHINE_CONFIG_END
 
-MACHINE_CONFIG_FRAGMENT( gottlieb_cobram3_soundrev2 )
-	/* audio CPUs */
-	MCFG_CPU_ADD("audiocpu", M6502, SOUND2_CLOCK/4)
-	MCFG_DEVICE_DISABLE()
-	MCFG_CPU_PROGRAM_MAP(gottlieb_audio2_map)
-
-	MCFG_CPU_ADD("speech", M6502, SOUND2_CLOCK/4)
-	MCFG_CPU_PROGRAM_MAP(gottlieb_cobram3_speech2_map)
-
-	/* sound hardware */
-	MCFG_SOUND_START( gottlieb2 )
-
-	MCFG_SOUND_ADD("dac1", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
-
-	MCFG_SOUND_ADD("dac2", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
 
-	MCFG_SOUND_ADD("ay1", AY8913, SOUND2_CLOCK/2)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
-
-	MCFG_SOUND_ADD("ay2", AY8913, SOUND2_CLOCK/2)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+//-------------------------------------------------
+//  input ports
+//-------------------------------------------------
 
-	MCFG_SOUND_ADD("spsnd", SP0250, SOUND2_SPEECH_CLOCK)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
-MACHINE_CONFIG_END
-
-
-/*************************************
- *
- *  Rev. 2 input ports
- *
- *************************************/
-
-INPUT_PORTS_START( gottlieb2_sound )
+INPUT_PORTS_START( gottlieb_sound_r2 )
 	PORT_START("SB2")
 	PORT_DIPUNKNOWN_DIPLOC( 0x01, 0x01, "SB2:1")
 	PORT_DIPUNKNOWN_DIPLOC( 0x02, 0x02, "SB2:2")
@@ -694,5 +896,88 @@
 	PORT_DIPNAME( 0x40, 0x40, "Sound Test" )			PORT_DIPLOCATION("SB2:7")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM(speech_drq_custom_r, NULL)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM_MEMBER(DEVICE_SELF, gottlieb_sound_r2_device, speech_drq_custom_r, NULL)
 INPUT_PORTS_END
+
+
+//-------------------------------------------------
+//  device_mconfig_additions - return a pointer to
+//  the device's machine fragment
+//-------------------------------------------------
+
+machine_config_constructor gottlieb_sound_r2_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME( gottlieb_sound_r2 );
+}
+
+
+//-------------------------------------------------
+//  device_input_ports - return a pointer to
+//  the device's I/O ports
+//-------------------------------------------------
+
+ioport_constructor gottlieb_sound_r2_device::device_input_ports() const
+{
+	return INPUT_PORTS_NAME( gottlieb_sound_r2 );
+}
+
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void gottlieb_sound_r2_device::device_start()
+{
+	// set up the NMI timer
+	m_nmi_timer = timer_alloc(TID_NMI_GENERATE);
+	m_nmi_rate = 0;
+	nmi_timer_adjust();
+
+	// reset the DACs
+	m_dac_data[0] = m_dac_data[1] = 0xff;
+
+	// disable the non-speech CPU for cobram3
+	if (m_cobram3_mod)
+		m_audiocpu->set_input_line(INPUT_LINE_HALT, ASSERT_LINE);
+
+	// register for save states
+	save_item(NAME(m_nmi_rate));
+	save_item(NAME(m_nmi_state));
+	save_item(NAME(m_speech_control));
+	save_item(NAME(m_last_command));
+}
+
+
+//-------------------------------------------------
+//  device_timer - handle timer-based behaviors
+//-------------------------------------------------
+
+void gottlieb_sound_r2_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	switch (id)
+	{
+		case TID_NMI_GENERATE:
+			// update state
+			m_nmi_state = 1;
+			nmi_state_update();
+
+			// set a timer to turn it off again on hte next SOUND_CLOCK/16
+			timer_set(attotime::from_hz(SOUND2_CLOCK/16), TID_NMI_CLEAR);
+
+			// adjust the NMI timer for the next time
+			nmi_timer_adjust();
+			break;
+
+		case TID_NMI_CLEAR:
+			// update state
+			m_nmi_state = 0;
+			nmi_state_update();
+			break;
+
+		case TID_SOUND_LATCH_WRITE:
+			// each CPU has its own latch
+			m_audiocpu_latch = param;
+			m_speechcpu_latch = param;
+			break;
+	}
+}
diff -Nru src-old/mame/audio/wow.c src/mame/audio/wow.c
--- src-old/mame/audio/wow.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/audio/wow.c	2012-03-01 09:36:39.000000000 +0100
@@ -21,6 +21,7 @@
 #include "emu.h"
 #include "cpu/z80/z80.h"
 #include "sound/samples.h"
+#include "sound/votrax.h"
 #include "includes/astrocde.h"
 
 
@@ -102,11 +103,12 @@
 
 READ8_HANDLER( wow_speech_r )
 {
+	UINT8 data = offset >> 8;
+#if USE_FAKE_VOTRAX
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
 	samples_device *samples = space->machine().device<samples_device>("samples");
 	int Phoneme/*, Intonation*/;
 	int i = 0;
-	UINT8 data = offset >> 8;
 	offset &= 0xff;
 
 	state->m_totalword_ptr = state->m_totalword;
@@ -163,6 +165,11 @@
 			return data;
 		}
 	}
+#else
+	votrax_sc01_device *votrax = space->machine().device<votrax_sc01_device>("votrax");
+	votrax->inflection_w(*space, 0, data >> 6);
+	votrax->write(*space, 0, data);
+#endif
 
 	/* Note : We should really also use volume in this as well as frequency */
 	return data;				                   /* Return nicely */
@@ -171,6 +178,11 @@
 
 CUSTOM_INPUT( wow_speech_status_r )
 {
+#if USE_FAKE_VOTRAX
 	samples_device *samples = field.machine().device<samples_device>("samples");
 	return !samples->playing(0);
+#else
+	votrax_sc01_device *votrax = field.machine().device<votrax_sc01_device>("votrax");
+	return votrax->request();
+#endif
 }
diff -Nru src-old/mame/drivers/3do.c src/mame/drivers/3do.c
--- src-old/mame/drivers/3do.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/3do.c	2012-02-28 22:08:18.000000000 +0100
@@ -190,24 +190,39 @@
 	MCFG_CDROM_ADD( "cdrom", _3do_cdrom)
 MACHINE_CONFIG_END
 
+#if 0
+#define NTSC_BIOS \
+	ROM_REGION32_BE( 0x200000, "user1", 0 ) \
+	ROM_SYSTEM_BIOS( 0, "panafz10", "Panasonic FZ-10 R.E.A.L. 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "panafz10.bin", 0x000000, 0x100000, CRC(58242cee) SHA1(3c912300775d1ad730dc35757e279c274c0acaad), ROM_BIOS(1) ) \
+	ROM_SYSTEM_BIOS( 1, "goldstar", "Goldstar 3DO Interactive Multiplayer v1.01m" ) \
+	ROMX_LOAD( "goldstar.bin", 0x000000, 0x100000, CRC(b6f5028b) SHA1(c4a2e5336f77fb5f743de1eea2cda43675ee2de7), ROM_BIOS(2) ) \
+	ROM_SYSTEM_BIOS( 2, "panafz1", "Panasonic FZ-1 R.E.A.L. 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "panafz1.bin", 0x000000, 0x100000, CRC(c8c8ff89) SHA1(34bf189111295f74d7b7dfc1f304d98b8d36325a), ROM_BIOS(3) ) \
+	ROM_SYSTEM_BIOS( 3, "gsalive2", "Goldstar 3DO Alive II" ) \
+	ROMX_LOAD( "gsalive2.bin", 0x000000, 0x100000, NO_DUMP, ROM_BIOS(4) ) \
+	ROM_SYSTEM_BIOS( 4, "sanyotry", "Sanyo TRY 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "sanyotry.bin", 0x000000, 0x100000, CRC(d5cbc509) SHA1(b01c53da256dde43ffec4ad3fc3adfa8d635e943), ROM_BIOS(5) )
+#else
+#define NTSC_BIOS \
+	ROM_REGION32_BE( 0x200000, "user1", 0 ) \
+	ROM_SYSTEM_BIOS( 0, "panafz10", "Panasonic FZ-10 R.E.A.L. 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "panafz10.bin", 0x000000, 0x100000, CRC(58242cee) SHA1(3c912300775d1ad730dc35757e279c274c0acaad), ROM_BIOS(1) ) \
+	ROM_SYSTEM_BIOS( 1, "goldstar", "Goldstar 3DO Interactive Multiplayer v1.01m" ) \
+	ROMX_LOAD( "goldstar.bin", 0x000000, 0x100000, CRC(b6f5028b) SHA1(c4a2e5336f77fb5f743de1eea2cda43675ee2de7), ROM_BIOS(2) ) \
+	ROM_SYSTEM_BIOS( 2, "panafz1", "Panasonic FZ-1 R.E.A.L. 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "panafz1.bin", 0x000000, 0x100000, CRC(c8c8ff89) SHA1(34bf189111295f74d7b7dfc1f304d98b8d36325a), ROM_BIOS(3) ) \
+	ROM_SYSTEM_BIOS( 3, "sanyotry", "Sanyo TRY 3DO Interactive Multiplayer" ) \
+	ROMX_LOAD( "sanyotry.bin", 0x000000, 0x100000, CRC(d5cbc509) SHA1(b01c53da256dde43ffec4ad3fc3adfa8d635e943), ROM_BIOS(4) )
+#endif
 
 ROM_START(3do)
-	ROM_REGION32_BE( 0x100000, "user1", 0 )
-	ROM_SYSTEM_BIOS( 0, "panafz10", "Panasonic FZ-10 R.E.A.L. 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "panafz10.bin", 0x000000, 0x100000, CRC(58242cee) SHA1(3c912300775d1ad730dc35757e279c274c0acaad), ROM_BIOS(1) )
-	ROM_SYSTEM_BIOS( 1, "goldstar", "Goldstar 3DO Interactive Multiplayer v1.01m" )
-	ROMX_LOAD( "goldstar.bin", 0x000000, 0x100000, CRC(b6f5028b) SHA1(c4a2e5336f77fb5f743de1eea2cda43675ee2de7), ROM_BIOS(2) )
-	ROM_SYSTEM_BIOS( 2, "panafz1", "Panasonic FZ-1 R.E.A.L. 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "panafz1.bin", 0x000000, 0x100000, CRC(c8c8ff89) SHA1(34bf189111295f74d7b7dfc1f304d98b8d36325a), ROM_BIOS(3) )
-	ROM_SYSTEM_BIOS( 3, "gsalive2", "Goldstar 3DO Alive II" )
-	ROMX_LOAD( "gsalive2.bin", 0x000000, 0x100000, NO_DUMP, ROM_BIOS(4) )
-	ROM_SYSTEM_BIOS( 4, "sanyotry", "Sanyo TRY 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "sanyotry.bin", 0x000000, 0x100000, CRC(d5cbc509) SHA1(b01c53da256dde43ffec4ad3fc3adfa8d635e943), ROM_BIOS(5) )
+	NTSC_BIOS
 ROM_END
 
 
 ROM_START(3do_pal)
-    ROM_REGION32_BE( 0x100000, "user1", 0 )
+    ROM_REGION32_BE( 0x200000, "user1", 0 )
     ROM_SYSTEM_BIOS( 0, "panafz10", "Panasonic FZ-10 R.E.A.L. 3DO Interactive Multiplayer" )
     ROMX_LOAD( "panafz10.bin", 0x000000, 0x100000, CRC(58242cee) SHA1(3c912300775d1ad730dc35757e279c274c0acaad), ROM_BIOS(1) )
     ROM_SYSTEM_BIOS( 1, "goldstar", "Goldstar 3DO Interactive Multiplayer v1.01m" )
@@ -217,17 +232,7 @@
 ROM_END
 
 ROM_START(orbatak)
-	ROM_REGION32_BE( 0x100000, "user1", 0 )
-	ROM_SYSTEM_BIOS( 0, "panafz10", "Panasonic FZ-10 R.E.A.L. 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "panafz10.bin", 0x000000, 0x100000, CRC(58242cee) SHA1(3c912300775d1ad730dc35757e279c274c0acaad), ROM_BIOS(1) )
-	ROM_SYSTEM_BIOS( 1, "goldstar", "Goldstar 3DO Interactive Multiplayer v1.01m" )
-	ROMX_LOAD( "goldstar.bin", 0x000000, 0x100000, CRC(b6f5028b) SHA1(c4a2e5336f77fb5f743de1eea2cda43675ee2de7), ROM_BIOS(2) )
-	ROM_SYSTEM_BIOS( 2, "panafz1", "Panasonic FZ-1 R.E.A.L. 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "panafz1.bin", 0x000000, 0x100000, CRC(c8c8ff89) SHA1(34bf189111295f74d7b7dfc1f304d98b8d36325a), ROM_BIOS(3) )
-	ROM_SYSTEM_BIOS( 3, "gsalive2", "Goldstar 3DO Alive II" )
-	ROMX_LOAD( "gsalive2.bin", 0x000000, 0x100000, NO_DUMP, ROM_BIOS(4) )
-	ROM_SYSTEM_BIOS( 4, "sanyotry", "Sanyo TRY 3DO Interactive Multiplayer" )
-	ROMX_LOAD( "sanyotry.bin", 0x000000, 0x100000, CRC(d5cbc509) SHA1(b01c53da256dde43ffec4ad3fc3adfa8d635e943), ROM_BIOS(5) )
+	NTSC_BIOS
 
     DISK_REGION( "cdrom" )
     DISK_IMAGE_READONLY( "orbatak", 0, SHA1(25cb3b889cf09dbe5faf2b0ca4aae5e03453da00) )
diff -Nru src-old/mame/drivers/8080bw.c src/mame/drivers/8080bw.c
--- src-old/mame/drivers/8080bw.c	2012-02-22 00:51:07.000000000 +0100
+++ src/mame/drivers/8080bw.c	2012-03-08 19:01:06.000000000 +0100
@@ -402,6 +402,29 @@
 
 MACHINE_CONFIG_END
 
+static DRIVER_INIT( invadpt2br )
+{
+	UINT8 *rom = machine.region("maincpu")->base();
+	int offs;
+
+	// simple encryption on rom pv01 0x4fc-0x5fb
+	// (with additional mask on 4-byte parts below)
+	for (offs = 0x4fc; offs < 0x5fc; offs++)
+		rom[offs] ^= 0x6c;
+
+	// 0x4fc + 1 * 0x56
+	for (offs = 0x54e; offs < 0x552; offs++)
+		rom[offs] ^= 0x03;
+
+	// 0x4fc + 2 * 0x56
+	for (offs = 0x5a4; offs < 0x5a8; offs++)
+		rom[offs] ^= 0x01;
+
+	// 0x4fc + 3 * 0x56
+	for (offs = 0x5fa; offs < 0x5fc; offs++)
+		rom[offs] ^= 0x02;
+}
+
 /*******************************************************/
 /*                                                     */
 /* Space Wars (Sanritsu)                               */
@@ -2641,8 +2664,7 @@
 
 ROM_START( invadpt2br )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "pv01_bad",    0x0000, 0x0800, BAD_DUMP CRC(2931a033) SHA1(b04ccde4a4a04b37aa65edc4af4e53a8c1f03dfe) ) // chunk of garbage in prg area $500-$600, the rest of rom contents is same as parent
-	ROM_LOAD( "pv01",        0x0000, 0x0800, CRC(7288a511) SHA1(ff617872784c28ed03591aefa9f0519e5651701f) ) // so let's load the parent rom instead
+	ROM_LOAD( "br_pv01",     0x0000, 0x0800, CRC(2931a033) SHA1(b04ccde4a4a04b37aa65edc4af4e53a8c1f03dfe) )
 	ROM_LOAD( "br_pv02",     0x0800, 0x0800, CRC(420c7c35) SHA1(b51265f4d9e5a8cf9d53099a97cadd25ea0b34ce) )
 	ROM_LOAD( "br_pv03",     0x1000, 0x0800, CRC(dffd04b9) SHA1(d51a0f27e90b0a49cf2d57ec82a863dcae9f3ea4) )
 	ROM_LOAD( "br_pv04",     0x1800, 0x0800, CRC(b0626aff) SHA1(b7de6c21030732bd0479228f057ca4c87b913b0a) )
@@ -3417,7 +3439,7 @@
 GAME( 1979, grescue,  lrescue,  lrescue,  lrescue,  0, ROT270, "Taito (Universal license?)", "Galaxy Rescue", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1979, desterth, lrescue,  lrescue,  invrvnge, 0, ROT270, "bootleg", "Destination Earth", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1979, invadpt2, 0,        invadpt2, invadpt2, 0, ROT270, "Taito", "Space Invaders Part II (Taito)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
-GAME( 1979, invadpt2br,invadpt2,invadpt2, invadpt2, 0, ROT270, "Taito do Brasil", "Space Invaders Part II (Brazil)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
+GAME( 1979, invadpt2br,invadpt2,invadpt2, invadpt2, invadpt2br, ROT270, "Taito do Brasil", "Space Invaders Part II (Brazil)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1980, invaddlx, invadpt2, invaders, invadpt2, 0, ROT270, "Taito (Midway license)", "Space Invaders Deluxe", GAME_SUPPORTS_SAVE )
 GAME( 1980, vortex,   0,        vortex,   vortex, vortex, ROT270, "Zilec Electronics", "Vortex", GAME_IMPERFECT_COLORS | GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND ) /* Encrypted 8080/IO */
 GAME( 1979, cosmo,    0,        cosmo,    cosmo,    0, ROT90,  "TDS & Mints", "Cosmo", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/ace.c src/mame/drivers/ace.c
--- src-old/mame/drivers/ace.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/ace.c	2012-02-27 18:48:43.000000000 +0100
@@ -42,11 +42,11 @@
 
 #define MASTER_CLOCK XTAL_18MHz
 
-
-class ace_state : public driver_device
+// ace_state was also defined in mess/drivers/ace.c
+class aceal_state : public driver_device
 {
 public:
-	ace_state(const machine_config &mconfig, device_type type, const char *tag)
+	aceal_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag) { }
 
 	/* video-related */
@@ -61,21 +61,21 @@
 
 static WRITE8_HANDLER( ace_objpos_w )
 {
-	ace_state *state = space->machine().driver_data<ace_state>();
+	aceal_state *state = space->machine().driver_data<aceal_state>();
 	state->m_objpos[offset] = data;
 }
 
 #if 0
 static READ8_HANDLER( ace_objpos_r )
 {
-	ace_state *state = space->machine().driver_data<ace_state>();
+	aceal_state *state = space->machine().driver_data<aceal_state>();
 	return state->m_objpos[offset];
 }
 #endif
 
 static VIDEO_START( ace )
 {
-	ace_state *state = machine.driver_data<ace_state>();
+	aceal_state *state = machine.driver_data<aceal_state>();
 	gfx_element_set_source(machine.gfx[1], state->m_characterram);
 	gfx_element_set_source(machine.gfx[2], state->m_characterram);
 	gfx_element_set_source(machine.gfx[3], state->m_characterram);
@@ -84,7 +84,7 @@
 
 static SCREEN_UPDATE_IND16( ace )
 {
-	ace_state *state = screen.machine().driver_data<ace_state>();
+	aceal_state *state = screen.machine().driver_data<aceal_state>();
 	int offs;
 
 	/* first of all, fill the screen with the background color */
@@ -130,7 +130,7 @@
 
 static WRITE8_HANDLER( ace_characterram_w )
 {
-	ace_state *state = space->machine().driver_data<ace_state>();
+	aceal_state *state = space->machine().driver_data<aceal_state>();
 	if (state->m_characterram[offset] != data)
 	{
 		if (data & ~0x07)
@@ -147,7 +147,7 @@
 
 static WRITE8_HANDLER( ace_scoreram_w )
 {
-	ace_state *state = space->machine().driver_data<ace_state>();
+	aceal_state *state = space->machine().driver_data<aceal_state>();
 	state->m_scoreram[offset] = data;
 	gfx_element_mark_dirty(space->machine().gfx[4], offset / 32);
 }
@@ -166,9 +166,9 @@
 
 	AM_RANGE(0x0000, 0x09ff) AM_ROM
 
-	AM_RANGE(0x2000, 0x20ff) AM_RAM_WRITE(ace_scoreram_w) AM_BASE_MEMBER(ace_state, m_scoreram)	/* 2x2101 */
-	AM_RANGE(0x8300, 0x83ff) AM_RAM AM_BASE_MEMBER(ace_state, m_ram2)	/* 2x2101 */
-	AM_RANGE(0x8000, 0x80ff) AM_RAM_WRITE(ace_characterram_w) AM_BASE_MEMBER(ace_state, m_characterram)	/* 3x3101 (3bits: 0, 1, 2) */
+	AM_RANGE(0x2000, 0x20ff) AM_RAM_WRITE(ace_scoreram_w) AM_BASE_MEMBER(aceal_state, m_scoreram)	/* 2x2101 */
+	AM_RANGE(0x8300, 0x83ff) AM_RAM AM_BASE_MEMBER(aceal_state, m_ram2)	/* 2x2101 */
+	AM_RANGE(0x8000, 0x80ff) AM_RAM_WRITE(ace_characterram_w) AM_BASE_MEMBER(aceal_state, m_characterram)	/* 3x3101 (3bits: 0, 1, 2) */
 
 	AM_RANGE(0xc000, 0xc005) AM_WRITE(ace_objpos_w)
 
@@ -327,21 +327,21 @@
 
 static MACHINE_START( ace )
 {
-	ace_state *state = machine.driver_data<ace_state>();
+	aceal_state *state = machine.driver_data<aceal_state>();
 	state->save_item(NAME(state->m_objpos));
 	machine.save().register_postload(save_prepost_delegate(FUNC(ace_postload), &machine));
 }
 
 static MACHINE_RESET( ace )
 {
-	ace_state *state = machine.driver_data<ace_state>();
+	aceal_state *state = machine.driver_data<aceal_state>();
 	int i;
 
 	for (i = 0; i < 8; i++)
 		state->m_objpos[i] = 0;
 }
 
-static MACHINE_CONFIG_START( ace, ace_state )
+static MACHINE_CONFIG_START( ace, aceal_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", I8080, MASTER_CLOCK/9)	/* 2 MHz ? */
diff -Nru src-old/mame/drivers/actfancr.c src/mame/drivers/actfancr.c
--- src-old/mame/drivers/actfancr.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/actfancr.c	2012-03-08 08:39:27.000000000 +0100
@@ -68,13 +68,11 @@
 {
 	actfancr_state *state = space->machine().driver_data<actfancr_state>();
 
-	UINT8* buffered_spriteram = space->machine().generic.buffered_spriteram.u8;
-	// make a buffered copy
-	memcpy(buffered_spriteram, space->machine().generic.spriteram.u8, 0x800);
+	UINT8 *src = reinterpret_cast<UINT8 *>(memory_get_shared(space->machine(), "spriteram"));
 	// copy to a 16-bit region for our sprite draw code too
 	for (int i=0;i<0x800/2;i++)
 	{
-		state->m_spriteram16[i] = buffered_spriteram[i*2] | (buffered_spriteram[(i*2)+1] <<8);
+		state->m_spriteram16[i] = src[i*2] | (src[(i*2)+1] <<8);
 	}
 }
 
@@ -86,7 +84,7 @@
 	AM_RANGE(0x070000, 0x070007) AM_DEVWRITE("tilegen2", deco_bac06_pf_control0_8bit_w)
 	AM_RANGE(0x070010, 0x07001f) AM_DEVWRITE("tilegen2", deco_bac06_pf_control1_8bit_swap_w)
 	AM_RANGE(0x072000, 0x0727ff) AM_DEVREADWRITE("tilegen2", deco_bac06_pf_data_8bit_swap_r, deco_bac06_pf_data_8bit_swap_w)
-	AM_RANGE(0x100000, 0x1007ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x100000, 0x1007ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x110000, 0x110001) AM_WRITE(actfancr_buffer_spriteram_w)
 	AM_RANGE(0x120000, 0x1205ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_le_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x130000, 0x130000) AM_READ_PORT("P1")
@@ -110,7 +108,7 @@
 	AM_RANGE(0x066400, 0x0667ff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_rowscroll_8bit_swap_r, deco_bac06_pf_rowscroll_8bit_swap_w)
 	AM_RANGE(0x100000, 0x100001) AM_WRITE(actfancr_sound_w)
 	AM_RANGE(0x110000, 0x110001) AM_WRITE(actfancr_buffer_spriteram_w)
-	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x130000, 0x1305ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_le_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x140000, 0x140001) AM_READNOP /* Value doesn't matter */
 	AM_RANGE(0x1f0000, 0x1f3fff) AM_RAM AM_BASE_MEMBER(actfancr_state, m_main_ram) /* Main ram */
@@ -342,8 +340,6 @@
 	MCFG_MACHINE_RESET(actfancr)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529))
@@ -395,8 +391,6 @@
 	MCFG_MACHINE_RESET(triothep)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529))
diff -Nru src-old/mame/drivers/aleck64.c src/mame/drivers/aleck64.c
--- src-old/mame/drivers/aleck64.c	2012-02-13 17:12:01.000000000 +0100
+++ src/mame/drivers/aleck64.c	2012-02-26 22:20:33.000000000 +0100
@@ -589,7 +589,7 @@
 	PORT_BIT( 0x00040000, IP_ACTIVE_LOW, IPT_COIN1 )
 INPUT_PORTS_END
 
- static INPUT_PORTS_START( kurufev )
+ static INPUT_PORTS_START( doncdoon )
 	PORT_START("P1")
 	PORT_START("P1_ANALOG_X")
 	PORT_START("P1_ANALOG_Y")
@@ -630,8 +630,8 @@
 	PORT_BIT( 0x00010000, IP_ACTIVE_LOW, IPT_START1 )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( doncdoon )
-	PORT_INCLUDE( kurufev )
+static INPUT_PORTS_START( kurufev )
+	PORT_INCLUDE( doncdoon )
 
 	PORT_MODIFY("IN0")
 	PORT_BIT(0x00004040, IP_ACTIVE_LOW, IPT_UNUSED )
@@ -1009,7 +1009,7 @@
 ROM_END
 
 
-ROM_START( doncdoon )
+ROM_START( kurufev )
 	ROM_REGION32_BE( 0x800, "user1", ROMREGION_ERASE00 )
 	PIF_BOOTROM
 
@@ -1027,7 +1027,7 @@
     ROM_LOAD( "normslp.rom", 0x00, 0x80, CRC(4f2ae525) SHA1(eab43f8cc52c8551d9cff6fced18ef80eaba6f05) )
 ROM_END
 
-ROM_START( kurufev )
+ROM_START( doncdoon )
 	ROM_REGION32_BE( 0x800, "user1", ROMREGION_ERASE00 )
 	PIF_BOOTROM
 
@@ -1075,7 +1075,7 @@
 GAME( 1999, srmvs,    aleck64,  aleck64, srmvs,    aleck64, ROT0, "Seta", "Super Real Mahjong VS", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 2003, twrshaft, aleck64,  aleck64, twrshaft, aleck64, ROT0, "Aruze", "Tower & Shaft", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 2003, hipai,    aleck64,  aleck64, hipai,    aleck64, ROT0, "Aruze / Seta", "Hi Pai Paradise", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 2003, doncdoon, aleck64,  aleck64, doncdoon, aleck64, ROT0, "Aruze / Takumi", "Donchan no Hanabi de Doon", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 2003, doncdoon, aleck64,  aleck64, doncdoon, aleck64, ROT0, "Aruze", "Hanabi de Doon! - Don-chan Puzzle", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 2003, kurufev,  aleck64,  aleck64, kurufev,  aleck64, ROT0, "Aruze / Takumi", "Kurukuru Fever", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 2000, mayjin3,  aleck64,  aleck64, aleck64,  aleck64, ROT0, "Seta / Able Corporation", "Mayjinsen 3", GAME_NOT_WORKING|GAME_NO_SOUND )
 
diff -Nru src-old/mame/drivers/arcadia.c src/mame/drivers/arcadia.c
--- src-old/mame/drivers/arcadia.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/arcadia.c	2012-02-27 18:48:43.000000000 +0100
@@ -55,11 +55,11 @@
 #include "machine/amigafdc.h"
 
 
-
-class arcadia_state : public amiga_state
+// arcadia_state was also defined in mess/includes/arcadia.h
+class arcadia_amiga_state : public amiga_state
 {
 public:
-	arcadia_state(const machine_config &mconfig, device_type type, const char *tag)
+	arcadia_amiga_state(const machine_config &mconfig, device_type type, const char *tag)
 		: amiga_state(mconfig, type, tag) { }
 
 	UINT8 coin_counter[2];
@@ -138,7 +138,7 @@
 	/* writing a 0 in the low bit clears one of the coins */
 	if ((data & 1) == 0)
 	{
-		UINT8 *coin_counter = device->machine().driver_data<arcadia_state>()->coin_counter;
+		UINT8 *coin_counter = device->machine().driver_data<arcadia_amiga_state>()->coin_counter;
 
 		if (coin_counter[0] > 0)
 			coin_counter[0]--;
@@ -158,7 +158,7 @@
 static CUSTOM_INPUT( coin_counter_r )
 {
 	int coin = (FPTR)param;
-	UINT8 *coin_counter = field.machine().driver_data<arcadia_state>()->coin_counter;
+	UINT8 *coin_counter = field.machine().driver_data<arcadia_amiga_state>()->coin_counter;
 
 	/* return coin counter values */
 	return coin_counter[coin] & 3;
@@ -168,7 +168,7 @@
 static INPUT_CHANGED( coin_changed_callback )
 {
 	int coin = (FPTR)param;
-	UINT8 *coin_counter = field.machine().driver_data<arcadia_state>()->coin_counter;
+	UINT8 *coin_counter = field.machine().driver_data<arcadia_amiga_state>()->coin_counter;
 
 	/* check for a 0 -> 1 transition */
 	if (!oldval && newval && coin_counter[coin] < 3)
@@ -178,7 +178,7 @@
 
 static void arcadia_reset_coins(running_machine &machine)
 {
-	UINT8 *coin_counter = machine.driver_data<arcadia_state>()->coin_counter;
+	UINT8 *coin_counter = machine.driver_data<arcadia_amiga_state>()->coin_counter;
 
 	/* reset coin counters */
 	coin_counter[0] = coin_counter[1] = 0;
@@ -194,9 +194,9 @@
 
 static ADDRESS_MAP_START( amiga_map, AS_PROGRAM, 16 )
 	ADDRESS_MAP_UNMAP_HIGH
-	AM_RANGE(0x000000, 0x07ffff) AM_RAMBANK("bank1") AM_BASE_SIZE_MEMBER(arcadia_state, m_chip_ram, m_chip_ram_size)
+	AM_RANGE(0x000000, 0x07ffff) AM_RAMBANK("bank1") AM_BASE_SIZE_MEMBER(arcadia_amiga_state, m_chip_ram, m_chip_ram_size)
 	AM_RANGE(0xbfd000, 0xbfefff) AM_READWRITE(amiga_cia_r, amiga_cia_w)
-	AM_RANGE(0xc00000, 0xdfffff) AM_READWRITE(amiga_custom_r, amiga_custom_w) AM_BASE_MEMBER(arcadia_state, m_custom_regs)
+	AM_RANGE(0xc00000, 0xdfffff) AM_READWRITE(amiga_custom_r, amiga_custom_w) AM_BASE_MEMBER(arcadia_amiga_state, m_custom_regs)
 	AM_RANGE(0xe80000, 0xe8ffff) AM_READWRITE(amiga_autoconfig_r, amiga_autoconfig_w)
 	AM_RANGE(0xf80000, 0xffffff) AM_ROM AM_REGION("user1", 0)		/* Kickstart BIOS */
 
@@ -297,7 +297,7 @@
 	DEVCB_NULL
 };
 
-static MACHINE_CONFIG_START( arcadia, arcadia_state )
+static MACHINE_CONFIG_START( arcadia, arcadia_amiga_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", M68000, AMIGA_68000_NTSC_CLOCK)
@@ -791,7 +791,7 @@
 
 static void arcadia_init(running_machine &machine)
 {
-	arcadia_state *state = machine.driver_data<arcadia_state>();
+	arcadia_amiga_state *state = machine.driver_data<arcadia_amiga_state>();
 	static const amiga_machine_interface arcadia_intf =
 	{
 		ANGUS_CHIP_RAM_MASK,
diff -Nru src-old/mame/drivers/armedf.c src/mame/drivers/armedf.c
--- src-old/mame/drivers/armedf.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/armedf.c	2012-03-11 18:17:00.000000000 +0100
@@ -393,7 +393,7 @@
 
 static ADDRESS_MAP_START( terraf_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x060000, 0x0603ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x0603ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x060400, 0x063fff) AM_RAM
 	AM_RANGE(0x064000, 0x064fff) AM_RAM_WRITE(paletteram16_xxxxRRRRGGGGBBBB_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x068000, 0x069fff) AM_READWRITE8(nb1414m4_text_videoram_r,nb1414m4_text_videoram_w,0x00ff)
@@ -414,7 +414,7 @@
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( kozure_map, AS_PROGRAM, 16 )
-	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x061000, 0x063fff) AM_RAM
 //  AM_RANGE(0x07c000, 0x07c001) AM_WRITE(kozure_io_w)
 //  AM_RANGE(0x0c0000, 0x0c0001) AM_WRITENOP /* watchdog? */
@@ -424,7 +424,7 @@
 
 static ADDRESS_MAP_START( cclimbr2_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x061000, 0x063fff) AM_RAM
 	AM_RANGE(0x064000, 0x064fff) AM_RAM_WRITE(paletteram16_xxxxRRRRGGGGBBBB_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x068000, 0x069fff) AM_READWRITE8(nb1414m4_text_videoram_r,nb1414m4_text_videoram_w,0x00ff)
@@ -446,7 +446,7 @@
 
 static ADDRESS_MAP_START( legion_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x061000, 0x063fff) AM_RAM
 	AM_RANGE(0x064000, 0x064fff) AM_RAM_WRITE(paletteram16_xxxxRRRRGGGGBBBB_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x068000, 0x069fff) AM_READWRITE8(nb1414m4_text_videoram_r,nb1414m4_text_videoram_w,0x00ff)
@@ -480,7 +480,7 @@
 static ADDRESS_MAP_START( legiono_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x040000, 0x04003f) AM_WRITE8(legiono_fg_scroll_w,0x00ff)
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x061000, 0x063fff) AM_RAM
 	AM_RANGE(0x064000, 0x064fff) AM_RAM_WRITE(paletteram16_xxxxRRRRGGGGBBBB_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x068000, 0x069fff) AM_READWRITE8(nb1414m4_text_videoram_r,nb1414m4_text_videoram_w,0x00ff)
@@ -502,7 +502,7 @@
 
 static ADDRESS_MAP_START( armedf_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
-	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x060000, 0x060fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x061000, 0x065fff) AM_RAM
 	AM_RANGE(0x066000, 0x066fff) AM_RAM_WRITE(armedf_bg_videoram_w) AM_BASE_MEMBER(armedf_state, m_bg_videoram)
 	AM_RANGE(0x067000, 0x067fff) AM_RAM_WRITE(armedf_fg_videoram_w) AM_BASE_MEMBER(armedf_state, m_fg_videoram)
@@ -679,7 +679,7 @@
 
 static ADDRESS_MAP_START( bigfghtr_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
-	AM_RANGE(0x080000, 0x0805ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x080000, 0x0805ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x080600, 0x083fff) AM_READWRITE(sharedram_r, sharedram_w) AM_BASE_MEMBER(bigfghtr_state, m_sharedram)
 	AM_RANGE(0x084000, 0x085fff) AM_RAM //work ram
 	AM_RANGE(0x086000, 0x086fff) AM_RAM_WRITE(armedf_bg_videoram_w) AM_BASE_MEMBER(armedf_state, m_bg_videoram)
@@ -1204,8 +1204,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(57)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1214,12 +1212,14 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1253,8 +1253,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(57)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1263,11 +1261,13 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1297,8 +1297,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1307,11 +1305,13 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1341,8 +1341,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(57)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1351,11 +1349,13 @@
 
 	MCFG_VIDEO_START(armedf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1385,8 +1385,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1395,11 +1393,13 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1429,8 +1429,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1439,11 +1437,13 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1473,8 +1473,6 @@
 	MCFG_MACHINE_RESET(armedf)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1483,11 +1481,13 @@
 
 	MCFG_VIDEO_START(terraf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
@@ -1532,8 +1532,6 @@
 	MCFG_MACHINE_RESET(bigfghtr)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(57)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -1542,11 +1540,13 @@
 
 	MCFG_VIDEO_START(armedf)
 	MCFG_SCREEN_UPDATE_STATIC(armedf)
-	MCFG_SCREEN_VBLANK_STATIC(armedf)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(armedf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
diff -Nru src-old/mame/drivers/astrocde.c src/mame/drivers/astrocde.c
--- src-old/mame/drivers/astrocde.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/astrocde.c	2012-03-05 16:12:45.000000000 +0100
@@ -118,6 +118,7 @@
 #include "machine/z80ctc.h"
 #include "machine/nvram.h"
 #include "sound/samples.h"
+#include "sound/votrax.h"
 #include "sound/astrocde.h"
 #include "sound/ay8910.h"
 
@@ -341,7 +342,11 @@
 		case 5: state->m_sparkle[3] = data;	break;
 		case 6:
 			space->machine().device<astrocade_device>("astrocade1")->set_output_gain(0, data ? 0.0 : 1.0);
+#if USE_FAKE_VOTRAX
 			space->machine().device<samples_device>("samples")->set_output_gain(0, data ? 1.0 : 0.0);
+#else
+			space->machine().device<votrax_sc01_device>("votrax")->set_output_gain(0, data ? 1.0 : 0.0);
+#endif
 			break;
 		case 7:	mame_printf_debug("io_1:%d\n", data); break;
 	}
@@ -811,9 +816,6 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("P3HANDLE")
-	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM(ebases_trackball_r, NULL)
-
-	PORT_START("P4HANDLE")
 	PORT_DIPNAME( 0x01, 0x00, "2 Players Game" )	PORT_DIPLOCATION( "S1:1" )
 	PORT_DIPSETTING(    0x00, "1 Credit" )
 	PORT_DIPSETTING(    0x01, "2 Credits" )
@@ -825,6 +827,9 @@
 	PORT_DIPUNUSED_DIPLOC( 0x40, 0x00, "S1:7" )
 	PORT_DIPUNUSED_DIPLOC( 0x80, 0x00, "S1:8" )
 
+	PORT_START("P4HANDLE")
+	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM(ebases_trackball_r, NULL)
+
 	PORT_START("TRACKX1")
 	PORT_BIT( 0xff, 0x00, IPT_TRACKBALL_X ) PORT_SENSITIVITY(50) PORT_KEYDELTA(10) PORT_RESET
 
@@ -1404,6 +1409,13 @@
 MACHINE_CONFIG_END
 
 
+#if !USE_FAKE_VOTRAX
+static votrax_sc01_interface votrax_interface =
+{
+	DEVCB_NULL
+};
+#endif
+
 static MACHINE_CONFIG_DERIVED( wow, astrocade_base )
 	MCFG_FRAGMENT_ADD(astrocade_stereo_sound)
 
@@ -1420,7 +1432,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_ADD("center", 0.0, 0.0, 1.0)
 
+#if USE_FAKE_VOTRAX
 	MCFG_SAMPLES_ADD("samples", wow_samples_interface)
+#else
+	MCFG_VOTRAX_SC01_ADD("votrax", 720000, votrax_interface)
+#endif
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "center", 0.85)
 MACHINE_CONFIG_END
 
@@ -1446,7 +1462,11 @@
 	MCFG_SOUND_ADD("astrocade2",  ASTROCADE, ASTROCADE_CLOCK/4)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lower", 1.0)
 
+#if USE_FAKE_VOTRAX
 	MCFG_SAMPLES_ADD("samples", gorf_samples_interface)
+#else
+	MCFG_VOTRAX_SC01_ADD("votrax", 720000, votrax_interface)
+#endif
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "upper", 0.85)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/atvtrack.c src/mame/drivers/atvtrack.c
--- src-old/mame/drivers/atvtrack.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/atvtrack.c	2012-03-07 21:23:54.000000000 +0100
@@ -257,7 +257,7 @@
 {
 	if (offset == SH4_IOPORT_16/8) {
 		// much simplified way
-		if (strcmp(space->device().tag(), "maincpu") == 0)
+		if (strcmp(space->device().tag(), ":maincpu") == 0)
 #ifndef SPECIALMODE
 			return -1; // normal
 #else
diff -Nru src-old/mame/drivers/battlane.c src/mame/drivers/battlane.c
--- src-old/mame/drivers/battlane.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/battlane.c	2012-03-07 19:42:58.000000000 +0100
@@ -256,15 +256,9 @@
  *
  *************************************/
 
-static void irqhandler( device_t *device, int irq )
-{
-	battlane_state *state = device->machine().driver_data<battlane_state>();
-	device_set_input_line(state->m_maincpu, M6809_FIRQ_LINE, irq ? ASSERT_LINE : CLEAR_LINE);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("maincpu", M6809_FIRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/bbusters.c src/mame/drivers/bbusters.c
--- src-old/mame/drivers/bbusters.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/bbusters.c	2012-03-11 18:17:00.000000000 +0100
@@ -331,9 +331,9 @@
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x080000, 0x08ffff) AM_RAM AM_BASE_MEMBER(bbusters_state, m_ram)
 	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_MEMBER(bbusters_state, m_videoram)
-	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x0a1000, 0x0a7fff) AM_RAM		/* service mode */
-	AM_RANGE(0x0a8000, 0x0a8fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0x0a8000, 0x0a8fff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0x0a9000, 0x0affff) AM_RAM		/* service mode */
 	AM_RANGE(0x0b0000, 0x0b1fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE_MEMBER(bbusters_state, m_pf1_data)
 	AM_RANGE(0x0b2000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf2_w) AM_BASE_MEMBER(bbusters_state, m_pf2_data)
@@ -361,7 +361,7 @@
 	AM_RANGE(0x000000, 0x06ffff) AM_ROM
 	AM_RANGE(0x070000, 0x07ffff) AM_RAM AM_BASE_MEMBER(bbusters_state, m_ram)
 	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_MEMBER(bbusters_state, m_videoram)
-	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x0a1000, 0x0a7fff) AM_WRITENOP
 	AM_RANGE(0x0b0000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE_MEMBER(bbusters_state, m_pf1_data)
 	AM_RANGE(0x0b8000, 0x0b8003) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, m_pf1_scroll_data)
@@ -666,24 +666,9 @@
 
 static SCREEN_VBLANK( bbuster )
 {
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space,0,0,0xffff);
-		buffer_spriteram16_2_w(space,0,0,0xffff);
-	}
-}
-
-static SCREEN_VBLANK( mechatt )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-		buffer_spriteram16_w(space,0,0,0xffff);
-	}
+	bbusters_state *state = screen.machine().driver_data<bbusters_state>();
+	state->m_spriteram->vblank_copy_rising(screen, vblank_on);
+	state->m_spriteram2->vblank_copy_rising(screen, vblank_on);
 }
 
 static MACHINE_CONFIG_START( bbusters, bbusters_state )
@@ -700,8 +685,6 @@
 	MCFG_NVRAM_ADD_0FILL("eeprom")
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(64*8, 32*8)
@@ -714,6 +697,9 @@
 
 	MCFG_VIDEO_START(bbuster)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
@@ -737,20 +723,20 @@
 	MCFG_CPU_IO_MAP(sounda_portmap)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(mechatt)
-	MCFG_SCREEN_VBLANK_STATIC(mechatt)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(mechatt)
 	MCFG_PALETTE_LENGTH(1024)
 
 	MCFG_VIDEO_START(mechatt)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
diff -Nru src-old/mame/drivers/bfm_sc1.c src/mame/drivers/bfm_sc1.c
--- src-old/mame/drivers/bfm_sc1.c	2012-02-11 11:01:01.000000000 +0100
+++ src/mame/drivers/bfm_sc1.c	2012-03-11 18:17:00.000000000 +0100
@@ -1227,33 +1227,83 @@
 
 // ROM definition ///////////////////////////////////////////////////////////////////
 
+/* are these used, or for one of the other revs? */
+#define sc1_china_sound \
+	ROM_REGION( 0x20000, "upd", 0 )  \
+	ROM_LOAD( "ctowsnd1.bin", 0x00000, 0x010000, CRC(faf28e18) SHA1(0586a905f944bcc990d4a1b400629412a69fc160) )\
+	ROM_LOAD( "ctowsnd2.bin", 0x10000, 0x010000, CRC(f4f9c1a4) SHA1(af5aff58b3e362a14e26a5e8cae83affda905819) )\
+
+#define sc1_cl65_sound \
+	ROM_REGION( 0x20000, "upd", 0 )\
+	ROM_LOAD( "65sndp1.bin", 0x000000, 0x010000, CRC(e532fcf5) SHA1(7de3bd4a3efae7d1cfeee23c008efbff39ce46f8) )\
+	ROM_LOAD( "65sndp2.bin", 0x010000, 0x010000, CRC(2703ea2d) SHA1(a4876a10d8d4b1de01dfab76e4ee21cb120aa783) )\
+
+/* This is in the set too, for now I'm storing it separately in the club sets that it appeared to come from, but it may need to be compared*/
+
+#define sc1_cl65_sound_alt  \
+	ROM_REGION( 0x20000, "upd", 0 )\
+	ROM_LOAD( "club-six-five-special_snd_a.bin", 0x0000, 0x010000, CRC(915802cd) SHA1(5bca3a80199a6534e084a5cf4337da4e9c48f45c) )\
+	ROM_LOAD( "club-six-five-special_snd_b.bin", 0x0000, 0x010000, CRC(b3b230d8) SHA1(022e95f38b14922137222805c0bec7498c5956cc) )\
+
+#define sc1_clbw_sound \
+	ROM_REGION( 0x20000, "upd", 0 )\
+	ROM_LOAD( "wisesnd1.bin", 0x0000, 0x010000, CRC(204605a6) SHA1(193a60878ed46f122e5d2d8f35fc6ea967b8734f) )\
+	ROM_LOAD( "wisesnd2.bin", 0x010000, 0x010000, CRC(6aa66166) SHA1(2e7cc67afdce2febb541bb1d0e7c107876d4233d) )\
+
+#define sc1_dblch_sound \
+	ROM_REGION( 0x40000, "upd", 0 )\
+	ROM_LOAD( "doublechancesnd1.bin", 0x0000, 0x010000, CRC(bee6af3e) SHA1(334fe491a00f58a2142f65344674b26c766a7c5b) )\
+	ROM_LOAD( "doublechancesnd2.bin", 0x0000, 0x010000, CRC(bbadc876) SHA1(902e387ea9bcd833cf75a6f049b5b2822ec6dc2a) )\
+
+#define sc1_funh_sound \
+	ROM_REGION( 0x40000, "upd", 0 )\
+	ROM_LOAD( "fhsesnd1.bin", 0x0000, 0x010000, CRC(bf371dbf) SHA1(0c9bc0d0964a858fba5324080a2cf5da119bf3db) )\
+	ROM_LOAD( "fhsesnd2.bin", 0x0000, 0x010000, CRC(c51415e3) SHA1(f0e4eb5ce38faaef336a5b69e598985ea2486ceb) )\
+
+	#define sc1_pwrl_sound \
+	ROM_REGION( 0x40000, "upd", 0 )\
+	ROM_LOAD( "powl_snd.bin", 0x00000, 0x40000, CRC(e87af436) SHA1(fc853eca052fe13babde5f4579e202321ecb8f7e) )\
+
+#define sc1_winst_sound \
+	ROM_REGION( 0x80000, "upd", 0 )\
+	ROM_LOAD( "winningstreaksnd.bin", 0x0000, 0x080000, CRC(ba30cb97) SHA1(e7f5ca36ca993ad14b3a348868e73d7ba02be7c5) )\
+
+//not upd?
+#define sc1_driv_sound \
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )\
+	ROM_LOAD( "ds_snd1.bin", 0x000000, 0x020000, CRC(a9d7e8ec) SHA1(5b1d459d378e23d3108a1190b5988eebedf95667) )\
+	ROM_LOAD( "ds_snd2.bin", 0x020000, 0x020000, CRC(3b67c1b3) SHA1(8b9dbff45955f72a73fb739b5e74aa2f9c23dd08) )\
+	ROM_LOAD( "ds_snd3.bin", 0x040000, 0x020000, CRC(00c252ec) SHA1(5de2e70f142a71f22eeb28a271ca9d7809322faa) )\
+
 ROM_START( sc1lotus )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "lotusse.bin",  0x0000, 0x10000,  CRC(636dadc4) SHA1(85bad5d76dac028fe9f3303dd09e8266aba7db4d))
+	ROM_LOAD( "lotusse.bin",  0x00000, 0x10000,  CRC(636dadc4) SHA1(85bad5d76dac028fe9f3303dd09e8266aba7db4d))
+ROM_END
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "lotusse_.bin", 0x0000, 0x010000, CRC(e5f51a36) SHA1(9cddf757c1636911fce370168e636ffcff7bfab6) )
+ROM_START( sc1lotusa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "lotusse_.bin", 0x00000, 0x010000, CRC(e5f51a36) SHA1(9cddf757c1636911fce370168e636ffcff7bfab6) )
 ROM_END
 
 /////////////////////////////////////////////////////////////////////////////////////
 
 ROM_START( sc1roul )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "rou029.bin",   0x8000, 0x08000,  CRC(31723f0A) SHA1(e220976116a0aaf24dc0c4af78a9311a360e8104))
+	ROM_LOAD( "rou029.bin",   0x8000, 0x8000,  CRC(31723f0A) SHA1(e220976116a0aaf24dc0c4af78a9311a360e8104))
 ROM_END
 
 /////////////////////////////////////////////////////////////////////////////////////
 
 ROM_START( sc1clatt )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "39370196.1",   0x8000, 0x08000,  CRC(4c2e465f) SHA1(101939d37d9c033f6d1dfb83b4beb54e4061aec2))
-	ROM_LOAD( "39370196.2",   0x0000, 0x08000,  CRC(c809c22d) SHA1(fca7515bc84d432150ffe5e32fccc6aed458b8b0))
+	ROM_LOAD( "39370196.2",   0x0000, 0x8000,  CRC(c809c22d) SHA1(fca7515bc84d432150ffe5e32fccc6aed458b8b0))
+	ROM_LOAD( "39370196.1",   0x8000, 0x8000,  CRC(4c2e465f) SHA1(101939d37d9c033f6d1dfb83b4beb54e4061aec2))
 ROM_END
 
 ROM_START( sc1clatta )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club attraction 393717552 prom a.bin", 0x8000, 0x008000, CRC(795e93cf) SHA1(017fa5ea3d9ad1f7a7a619d88a5892a9ffe6f3bc) )
-	ROM_LOAD( "club attraction 393717553 prom b.bin", 0x0000, 0x008000, CRC(06f41627) SHA1(0e54314147a5f0d833d83f6f0ee828bd1c875f3e) )
+	ROM_LOAD( "club attraction 393717553 prom b.bin", 0x0000, 0x8000, CRC(06f41627) SHA1(0e54314147a5f0d833d83f6f0ee828bd1c875f3e) )
+	ROM_LOAD( "club attraction 393717552 prom a.bin", 0x8000, 0x8000, CRC(795e93cf) SHA1(017fa5ea3d9ad1f7a7a619d88a5892a9ffe6f3bc) )
 ROM_END
 
 
@@ -1262,10 +1312,10 @@
 
 ROM_START( m_tppokr )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95750899.bin", 0x0000, 0x10000,  CRC(639d1d62) SHA1(80620c14bf9f953588555510fc2e6e930140923f))
+	ROM_LOAD( "95750899.bin", 0x00000, 0x10000,  CRC(639d1d62) SHA1(80620c14bf9f953588555510fc2e6e930140923f))
 
 	ROM_REGION( 0x20000, "adder2", 0 )
-	ROM_LOAD( "tpk010.vid", 0x0000, 0x20000,  CRC(ea4eddca) SHA1(5fb805d35376ec7ee8d58684e584621dbb2b2a9c))
+	ROM_LOAD( "tpk010.vid", 0x00000, 0x20000,  CRC(ea4eddca) SHA1(5fb805d35376ec7ee8d58684e584621dbb2b2a9c))
 
 	ROM_REGION( 0x40000, "gfx1", ROMREGION_ERASEFF )
 	ROM_LOAD( "tpk011.chr",	0x00000, 0x20000,  CRC(4dc23ad8) SHA1(8e8cc699412dbb092e16e14518f407353f477ee1))
@@ -1284,7 +1334,7 @@
 
 ROM_START( sc1armad )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "armada.bin", 0x0000, 0x010000, CRC(9a1be4ca) SHA1(d18b7c8779a8eb50321fbff4d6d8cf6d512bea8b) )
+	ROM_LOAD( "armada.bin", 0x00000, 0x010000, CRC(9a1be4ca) SHA1(d18b7c8779a8eb50321fbff4d6d8cf6d512bea8b) )
 ROM_END
 
 
@@ -1303,35 +1353,49 @@
 	ROM_LOAD( "95740352 b.bin", 0x0000, 0x8000, CRC(6dc3cfd3) SHA1(d71d433ae560ac4db345630ee7f04a7cfb7e933e) )
 	ROM_LOAD( "95740351 a.bin", 0x8000, 0x8000, CRC(0891350b) SHA1(ea1295768738b9b89eac19d04411220a8c9d10c7) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "barcode 5_10p a.bin", 0x0000, 0x008000, CRC(e864aba1) SHA1(b3f707b6d5f3d7236e4a5e9ed78c61a78c3e8196) )
-	ROM_LOAD( "barcode 5_10p b.bin", 0x0000, 0x008000, CRC(69d4d0b2) SHA1(bb73b917cf414623dcd239c5daeeccb4e0ccc2ed) )
-	ROM_LOAD( "barcode.p1", 0x0000, 0x008000, CRC(0be64bfb) SHA1(3b5cfee8825f2b7d2598f04411d50b8f1245ac65) )
-	ROM_LOAD( "barcode.p2", 0x0000, 0x008000, CRC(44b79b14) SHA1(ec0745be0dde818c673c62ca584e22871a73e66e) )
+	ROM_REGION( 0x20000, "upd", 0 )
+	ROM_LOAD( "barsnd1.bin", 0x00000, 0x10000, CRC(c9de8ff4) SHA1(c3e77e84d4ecc1c779929a96d1c445a1af24865b) )
+	ROM_LOAD( "barsnd2.bin", 0x10000, 0x10000, CRC(56af984a) SHA1(aebd30f3ca767dc5fc77fb01765833ee627a5aee) )
+ROM_END
+
+ROM_START( sc1barcda )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "barcode 5_10p b.bin", 0x0000, 0x8000, CRC(69d4d0b2) SHA1(bb73b917cf414623dcd239c5daeeccb4e0ccc2ed) )
+	ROM_LOAD( "barcode 5_10p a.bin", 0x8000, 0x8000, CRC(e864aba1) SHA1(b3f707b6d5f3d7236e4a5e9ed78c61a78c3e8196) )
+
+	ROM_REGION( 0x20000, "upd", 0 )
+	ROM_LOAD( "barsnd1.bin", 0x00000, 0x10000, CRC(c9de8ff4) SHA1(c3e77e84d4ecc1c779929a96d1c445a1af24865b) )
+	ROM_LOAD( "barsnd2.bin", 0x10000, 0x10000, CRC(56af984a) SHA1(aebd30f3ca767dc5fc77fb01765833ee627a5aee) )
+ROM_END
+
+ROM_START( sc1barcdb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "barcode.p2", 0x0000, 0x8000, CRC(44b79b14) SHA1(ec0745be0dde818c673c62ca584e22871a73e66e) )
+	ROM_LOAD( "barcode.p1", 0x8000, 0x8000, CRC(0be64bfb) SHA1(3b5cfee8825f2b7d2598f04411d50b8f1245ac65) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "barsnd1.bin", 0x000000, 0x010000, CRC(c9de8ff4) SHA1(c3e77e84d4ecc1c779929a96d1c445a1af24865b) )
-	ROM_LOAD( "barsnd2.bin", 0x010000, 0x010000, CRC(56af984a) SHA1(aebd30f3ca767dc5fc77fb01765833ee627a5aee) )
+	ROM_LOAD( "barsnd1.bin", 0x00000, 0x10000, CRC(c9de8ff4) SHA1(c3e77e84d4ecc1c779929a96d1c445a1af24865b) )
+	ROM_LOAD( "barsnd2.bin", 0x10000, 0x10000, CRC(56af984a) SHA1(aebd30f3ca767dc5fc77fb01765833ee627a5aee) )
 ROM_END
 
 ROM_START( sc1bigmt )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "bigmatch.bin", 0x0000, 0x010000, CRC(3c81663c) SHA1(a9670a48059d35d6581ce3007c0a6223291e0a12) )
+	ROM_LOAD( "bigmatch.bin", 0x00000, 0x10000, CRC(3c81663c) SHA1(a9670a48059d35d6581ce3007c0a6223291e0a12) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "bigmsnd1.bin", 0x000000, 0x010000, CRC(51828aa0) SHA1(99b46c1c4b45f26a393bf3e658ad499c84bdf8f5) )
-	ROM_LOAD( "bigmsnd2.bin", 0x010000, 0x010000, CRC(cf1f0f6b) SHA1(6521f0fe52a0587af049940bb81846d40d8847b8) )
+	ROM_LOAD( "bigmsnd1.bin", 0x00000, 0x10000, CRC(51828aa0) SHA1(99b46c1c4b45f26a393bf3e658ad499c84bdf8f5) )
+	ROM_LOAD( "bigmsnd2.bin", 0x10000, 0x10000, CRC(cf1f0f6b) SHA1(6521f0fe52a0587af049940bb81846d40d8847b8) )
 ROM_END
 
 
 ROM_START( sc1calyp )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "calypso.bin", 0x0000, 0x010000, CRC(b8194d31) SHA1(de7d374d8a1c18ec324daf92112652461e2a113e) )
+	ROM_LOAD( "calypso.bin", 0x00000, 0x10000, CRC(b8194d31) SHA1(de7d374d8a1c18ec324daf92112652461e2a113e) )
 ROM_END
 
 ROM_START( sc1carro )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "carrousel.bin", 0x0000, 0x010000, CRC(d1f7ae57) SHA1(301727b95f30d8e934a9c790838daf65aadd6dc7) )
+	ROM_LOAD( "carrousel.bin", 0x00000, 0x10000, CRC(d1f7ae57) SHA1(301727b95f30d8e934a9c790838daf65aadd6dc7) )
 ROM_END
 
 ROM_START( sc1cshat )
@@ -1340,21 +1404,31 @@
 	ROM_LOAD( "cash_attraction_a", 0x8000, 0x8000, CRC(fab3283c) SHA1(669b425687faad0ebf88c1aaaafa40c446fa2e24) )
 
 	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "957172.20 std var% a.bin", 0x0000, 0x008000, CRC(e67fc9e1) SHA1(39ac2c30d605f2b3109a57c6633a597e77651e79) )
-	ROM_LOAD( "957172.21 var% b.bin", 0x0000, 0x008000, CRC(ea705443) SHA1(fdd941b5e6785d97e990f4ca74578e539512422b) )
 	ROM_LOAD( "957172.40 b std var%.bin", 0x0000, 0x008000, CRC(5e4381f9) SHA1(ae6d64c42ae7ddc2ed0ab5c3b56222090004d88a) )
-	ROM_LOAD( "95717270 20 n.p a.bin", 0x0000, 0x008000, CRC(4e90868a) SHA1(f88a1b578b2d9091f5e5212768547db19e6b5379) )
-	ROM_LOAD( "95717271 20p std b.bin", 0x0000, 0x008000, CRC(79870574) SHA1(89e5db89064a9e24bc37389d78f4defb7d2f479b) )
 	ROM_LOAD( "957182.20 var% proto a.bin", 0x0000, 0x008000, CRC(3a2dd72d) SHA1(29d962702095aa0f252210da68a89c557fa9db69) )
 	ROM_LOAD( "957182.39 74-78 proto a.bin", 0x0000, 0x008000, CRC(f890b2d3) SHA1(e714973c63486e6983912fb6aebee3a71e003be5) )
 	ROM_LOAD( "957182.39 proto var%.bin", 0x0000, 0x008000, CRC(43f452a7) SHA1(13ef94b4a4ecf729dfe481da26804f2e6f0631b0) )
-	ROM_LOAD( "957272.20 74-78 standard.bin", 0x0000, 0x008000, CRC(06def19d) SHA1(721d8ffc7e6b0e76f097d82b3be7618d97d73041) )
-	ROM_LOAD( "957272.21 74-78b.bin", 0x0000, 0x008000, CRC(531e97fb) SHA1(c7ae94c503f9e13d68ae463dd19212f146b0e8bc) )
 	ROM_LOAD( "957272.40 74-78b.bin", 0x0000, 0x008000, CRC(e72d4241) SHA1(487a00f49fa5451f39c2400f6f23a5f067afaa66) )
-	ROM_LOAD( "95728.20 74-78 proto a.bin", 0x0000, 0x008000, CRC(7e557f21) SHA1(49bbbbafff757acd078d156bae2c942991f055af) )
 	ROM_LOAD( "957282.20 74-78 proto a.bin", 0x0000, 0x008000, CRC(7e557f21) SHA1(49bbbbafff757acd078d156bae2c942991f055af) )
 ROM_END
 
+ROM_START( sc1cshata )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957272.21 74-78b.bin", 0x0000, 0x8000, CRC(531e97fb) SHA1(c7ae94c503f9e13d68ae463dd19212f146b0e8bc) )
+	ROM_LOAD( "957272.20 74-78 standard.bin", 0x8000, 0x8000, CRC(06def19d) SHA1(721d8ffc7e6b0e76f097d82b3be7618d97d73041) )
+ROM_END
+
+ROM_START( sc1cshatb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957172.71 20p std b.bin", 0x0000, 0x8000, CRC(79870574) SHA1(89e5db89064a9e24bc37389d78f4defb7d2f479b) )
+	ROM_LOAD( "957172.70 20 n.p a.bin", 0x8000, 0x8000, CRC(4e90868a) SHA1(f88a1b578b2d9091f5e5212768547db19e6b5379) )
+ROM_END
+
+ROM_START( sc1cshatc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957172.21 var% b.bin", 0x0000, 0x8000, CRC(ea705443) SHA1(fdd941b5e6785d97e990f4ca74578e539512422b) )
+	ROM_LOAD( "957172.20 std var% a.bin", 0x8000, 0x8000, CRC(e67fc9e1) SHA1(39ac2c30d605f2b3109a57c6633a597e77651e79) )
+ROM_END
 
 ROM_START( sc1cshcd )
 	ROM_REGION( 0x10000, "maincpu", 0 )
@@ -1388,79 +1462,125 @@
 	ROM_LOAD( "cashexpl.bin", 0x8000, 0x008000, CRC(83c6196c) SHA1(931fb5223c3ebc52ca2bd232d71000b8af4397e1) )
 ROM_END
 
-
 ROM_START( sc1cexpl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cashxpl2.bin", 0x0000, 0x008000, CRC(0199136c) SHA1(bed1df64ecc0d7ef951a59717e219e6fe7ebf99c) )
-	ROM_LOAD( "cashxpl1.bin", 0x8000, 0x008000, CRC(0fe62ead) SHA1(bd56a216292e9bf2b7753616a6cd25b37e22095f) )
+	ROM_LOAD( "cashxpl2.bin", 0x0000, 0x8000, CRC(0199136c) SHA1(bed1df64ecc0d7ef951a59717e219e6fe7ebf99c) )
+	ROM_LOAD( "cashxpl1.bin", 0x8000, 0x8000, CRC(0fe62ead) SHA1(bd56a216292e9bf2b7753616a6cd25b37e22095f) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 ) // i think some of this is on different hw
-	ROM_LOAD( "95717083a mk1.bin", 0x0000, 0x008000, CRC(949c2d18) SHA1(26db983c7d8624c3fd0461dba2336d5c59be29f0) )
-	ROM_LOAD( "95717083a mk2 var%.bin", 0x0000, 0x008000, CRC(1fe1b3a1) SHA1(dd10d74c71a455900a2325ac9d7b3c8e45eb9c6c) )
-	ROM_LOAD( "95717083a.bin", 0x0000, 0x008000, CRC(1fe1b3a1) SHA1(dd10d74c71a455900a2325ac9d7b3c8e45eb9c6c) )
-	ROM_LOAD( "95717084b mk1.bin", 0x0000, 0x008000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
-	ROM_LOAD( "95717084b mk2 var%.bin", 0x0000, 0x008000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
-	ROM_LOAD( "95717084b.bin", 0x0000, 0x008000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
+	ROM_REGION( 0x10000, "altrevs", 0 ) // i think some of this is on different hw (SC2?)
 	ROM_LOAD( "cash_explosion_dat_ac_8_10pnd_20p_a.bin", 0x0000, 0x010000, CRC(1d155799) SHA1(4e76328a4d093d1f9c64c633c3558db2dce4e219) )
 	ROM_LOAD( "cash_explosion_dat_ac_var_8pnd_a.bin", 0x0000, 0x010000, CRC(4aa53121) SHA1(cf0510e224de62b837915d39c2fe3559cfe8c85f) )
 	ROM_LOAD( "cash_explosion_dat_wi_ac_10pnd_20p_a.bin", 0x0000, 0x010000, CRC(889eb206) SHA1(91b23a2cc475e68470d01976b88b9ea7aa0afed9) )
 	ROM_LOAD( "cash_explosion_std_ac_8_10pnd_20p_a.bin", 0x0000, 0x010000, CRC(de6bbee2) SHA1(3c321fa442b25a27c3f14b7ac94255f020056663) )
 	ROM_LOAD( "cash_explosion_std_ac_var_8pnd_a.bin", 0x0000, 0x010000, CRC(e8a21401) SHA1(479edd734ca949e344fb7e17ed7af7c8c9604efc) )
 	ROM_LOAD( "cash_explosion_std_wi_ac_10pnd_20p_a.bin", 0x0000, 0x010000, CRC(2901a315) SHA1(c9733488894ccead7a69b161f2afacdb3f892b89) )
-	ROM_LOAD( "cbexpp1", 0x0000, 0x008000, CRC(8819728c) SHA1(691d6317fd38e09fa333fc49c82e85f69a04e359) )
-	ROM_LOAD( "cbexpp2", 0x0000, 0x008000, CRC(82eb61ac) SHA1(9c06542b43b01be5ec7be081fead92bfe9f905c5) )
 ROM_END
 
+ROM_START( sc1cexpla )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717084b mk1.bin", 0x0000, 0x8000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
+	ROM_LOAD( "95717083a mk1.bin", 0x8000, 0x8000, CRC(949c2d18) SHA1(26db983c7d8624c3fd0461dba2336d5c59be29f0) )
+ROM_END
+
+ROM_START( sc1cexplb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717084b mk2 var%.bin", 0x0000, 0x8000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
+	ROM_LOAD( "95717083a mk2 var%.bin", 0x8000, 0x8000, CRC(1fe1b3a1) SHA1(dd10d74c71a455900a2325ac9d7b3c8e45eb9c6c) )
+ROM_END
+
+ROM_START( sc1cexplc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717084b.bin", 0x0000, 0x8000, CRC(e2d973be) SHA1(56ed3e3d6caf12f82d6ccc1527ff8da215e09cb0) )
+	ROM_LOAD( "95717083a.bin", 0x8000, 0x8000, CRC(1fe1b3a1) SHA1(dd10d74c71a455900a2325ac9d7b3c8e45eb9c6c) )
+ROM_END
+
+ROM_START( sc1cexpld )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cbexpp2", 0x0000, 0x8000, CRC(82eb61ac) SHA1(9c06542b43b01be5ec7be081fead92bfe9f905c5) )
+	ROM_LOAD( "cbexpp1", 0x8000, 0x8000, CRC(8819728c) SHA1(691d6317fd38e09fa333fc49c82e85f69a04e359) )
+ROM_END
 
 ROM_START( sc1cshwz )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95717205a std.bin", 0x8000, 0x008000, CRC(795bbeea) SHA1(22e0fc9bc3c70e05e51cb98837a9c706eb2ca080) )
-	ROM_LOAD( "95717206b std.bin", 0x0000, 0x008000, CRC(2478530f) SHA1(be82a4e36a3c076b9e94fa2364904ca463b6b4ed) )
+	ROM_LOAD( "95717206b std.bin", 0x0000, 0x8000, CRC(2478530f) SHA1(be82a4e36a3c076b9e94fa2364904ca463b6b4ed) )
+	ROM_LOAD( "95717205a std.bin", 0x8000, 0x8000, CRC(795bbeea) SHA1(22e0fc9bc3c70e05e51cb98837a9c706eb2ca080) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
+	ROM_REGION( 0x10000, "altrevs", 0 )//these seem to be halves without a partner, do these share the same b ROM?
 	ROM_LOAD( "95718205a std ptel.bin", 0x0000, 0x008000, CRC(c88f476c) SHA1(a5d8f12ade77bdb100ece5f2eecec35ae09f3b0e) )
 	ROM_LOAD( "95718210a proto var.bin", 0x0000, 0x008000, CRC(0997c4e9) SHA1(1013a12803796d3926cceeb671c7c07cc66d418e) )
-	ROM_LOAD( "95727205a 74-78 adj.bin", 0x0000, 0x008000, CRC(7c7ddabc) SHA1(b4c7a9ee929b5635091366948257f273a21d7818) )
-	ROM_LOAD( "95727206b 74-78 adj.bin", 0x0000, 0x008000, CRC(2b0ea9dc) SHA1(a9099abe2cf4cdf119a00e5a218507798d410eff) )
-	ROM_LOAD( "95727210a 74-78 sw.bin", 0x0000, 0x008000, CRC(6276ee67) SHA1(cc9b794f0add6d68677858719831e10afbdbc699) )
-	ROM_LOAD( "95727211b 74-78 sw.bin", 0x0000, 0x008000, CRC(e20ee4d3) SHA1(3440ad647f8e009a13de6ff9797a47c636a50123) )
 	ROM_LOAD( "95728205a 74-78 adj proto.bin", 0x0000, 0x008000, CRC(1cdadddb) SHA1(33c7ed10b1c9ddc0fc6065ad9b1cf80ee9f8e958) )
 	ROM_LOAD( "95728210a 74-78 proto.bin", 0x0000, 0x008000, CRC(5c502423) SHA1(4fc93de9dd3aff7a8a8f828760d8b095b7a13630) )
-	ROM_LOAD( "cashwisep1.bin", 0x0000, 0x008000, CRC(6276ee67) SHA1(cc9b794f0add6d68677858719831e10afbdbc699) )
-	ROM_LOAD( "cashwisep2.bin", 0x0000, 0x008000, CRC(e20ee4d3) SHA1(3440ad647f8e009a13de6ff9797a47c636a50123) )
-	ROM_LOAD( "cwise_a.bin", 0x0000, 0x008000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
-	ROM_LOAD( "cwise_b.bin", 0x0000, 0x008000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
+
 ROM_END
 
+ROM_START( sc1cshwza )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95727206b 74-78 adj.bin", 0x0000, 0x8000, CRC(2b0ea9dc) SHA1(a9099abe2cf4cdf119a00e5a218507798d410eff) )
+	ROM_LOAD( "95727205a 74-78 adj.bin", 0x8000, 0x8000, CRC(7c7ddabc) SHA1(b4c7a9ee929b5635091366948257f273a21d7818) )
+ROM_END
 
-ROM_START( sc1cshin )
+ROM_START( sc1cshwzb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cashino-a.bin", 0x8000, 0x008000, CRC(8a585683) SHA1(01859c82a6d6b082de11e9208f8d38c519dc2575) )
-	ROM_LOAD( "cashino-b.bin", 0x0000, 0x008000, CRC(c0d3fb09) SHA1(7e0a302547b18946851d31be4d25c17aca32b767) )
+	ROM_LOAD( "cwise_b.bin", 0x0000, 0x8000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
+	ROM_LOAD( "cwise_a.bin", 0x8000, 0x8000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
 ROM_END
 
+ROM_START( sc1cshwzc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95727211b 74-78 sw.bin", 0x0000, 0x8000, CRC(e20ee4d3) SHA1(3440ad647f8e009a13de6ff9797a47c636a50123) )
+	ROM_LOAD( "95727210a 74-78 sw.bin", 0x8000, 0x8000, CRC(6276ee67) SHA1(cc9b794f0add6d68677858719831e10afbdbc699) )
+ROM_END
+
+ROM_START( sc1cshin )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cashino-b.bin", 0x0000, 0x8000, CRC(c0d3fb09) SHA1(7e0a302547b18946851d31be4d25c17aca32b767) )
+	ROM_LOAD( "cashino-a.bin", 0x8000, 0x8000, CRC(8a585683) SHA1(01859c82a6d6b082de11e9208f8d38c519dc2575) )
+ROM_END
 
 ROM_START( sc1china )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club-china-town_dat_ac_200pnd_ass.bin", 0x8000, 0x008000, CRC(5aa465b9) SHA1(3c2d805f0421d7d1db93f21358a2beb648c05f8e) )
-	ROM_LOAD( "club-china-town_dat_ac_200pnd_bss.bin", 0x0000, 0x008000, CRC(4895098f) SHA1(e08f9b85c634a423a93608a7b592436ae253ca42) )
+	ROM_LOAD( "club-china-town_std_ac_200pnd_rot_bss.bin", 0x0000, 0x8000, CRC(4895098f) SHA1(e08f9b85c634a423a93608a7b592436ae253ca42) )
+	ROM_LOAD( "club-china-town_std_ac_200pnd_rot_ass.bin", 0x8000, 0x8000, CRC(a9ed6493) SHA1(8049fe4b42110afab91dd2d9ccd132d4f2c1c0ff) )
+	sc1_china_sound
+ROM_END
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "39371857.p1", 0x0000, 0x008000, CRC(5aa465b9) SHA1(3c2d805f0421d7d1db93f21358a2beb648c05f8e) )
-	ROM_LOAD( "club-china-town_dat_ac_150pnd_lfj_ass.bin", 0x0000, 0x008000, CRC(9547727a) SHA1(ac4a23ae78d9331261ee0ab59816f65c5c1547d7) )
-	ROM_LOAD( "club-china-town_dat_ac_150pnd_lfj_bss.bin", 0x0000, 0x008000, CRC(d41c6999) SHA1(cc2eb2e74ca3bfa78d74dd08f83acb2fe650e13d) )
-	ROM_LOAD( "club-china-town_dat_ac_rot_ass.bin", 0x0000, 0x008000, CRC(109b722c) SHA1(19426f3f907f108dc16b4036d3986c6395f799d0) )
-	ROM_LOAD( "club-china-town_dat_ac_rot_bss.bin", 0x0000, 0x008000, CRC(6e09a878) SHA1(4084b1dc3425ceb980ef5c63a883720f3ad84d7f) )
-	ROM_LOAD( "club-china-town_std_ac_150pnd_lfj_ass.bin", 0x0000, 0x008000, CRC(8c3e69f1) SHA1(cb0cbf7a6039549b969160a162a0cd5511b24cd3) )
-	ROM_LOAD( "club-china-town_std_ac_150pnd_lfj_bss.bin", 0x0000, 0x008000, CRC(d41c6999) SHA1(cc2eb2e74ca3bfa78d74dd08f83acb2fe650e13d) )
-	ROM_LOAD( "club-china-town_std_ac_200pnd_rot_ass.bin", 0x0000, 0x008000, CRC(a9ed6493) SHA1(8049fe4b42110afab91dd2d9ccd132d4f2c1c0ff) )
-	ROM_LOAD( "club-china-town_std_ac_200pnd_rot_bss.bin", 0x0000, 0x008000, CRC(4895098f) SHA1(e08f9b85c634a423a93608a7b592436ae253ca42) )
-	ROM_LOAD( "club-china-town_std_ac_rot_ass.bin", 0x0000, 0x008000, CRC(de12ac34) SHA1(0caeb2a6b209ee34d67d4c619dd63562c839261e) )
-	ROM_LOAD( "club-china-town_std_ac_rot_bss.bin", 0x0000, 0x008000, CRC(6e09a878) SHA1(4084b1dc3425ceb980ef5c63a883720f3ad84d7f) )
-
-	ROM_REGION( 0x20000, "upd", 0 ) // are these used, or for one of the other revs?
-	ROM_LOAD( "ctowsnd1.bin", 0x00000, 0x010000, CRC(faf28e18) SHA1(0586a905f944bcc990d4a1b400629412a69fc160) )
-	ROM_LOAD( "ctowsnd2.bin", 0x10000, 0x010000, CRC(f4f9c1a4) SHA1(af5aff58b3e362a14e26a5e8cae83affda905819) )
+ROM_START( sc1chinap )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-china-town_dat_ac_200pnd_bss.bin", 0x0000, 0x8000, CRC(4895098f) SHA1(e08f9b85c634a423a93608a7b592436ae253ca42) )
+	ROM_LOAD( "club-china-town_dat_ac_200pnd_ass.bin", 0x8000, 0x8000, CRC(5aa465b9) SHA1(3c2d805f0421d7d1db93f21358a2beb648c05f8e) )//39371857
+
+	sc1_china_sound
+ROM_END
+
+ROM_START( sc1chinaa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-china-town_std_ac_rot_bss.bin", 0x0000, 0x8000, CRC(6e09a878) SHA1(4084b1dc3425ceb980ef5c63a883720f3ad84d7f) )
+	ROM_LOAD( "club-china-town_std_ac_rot_ass.bin", 0x8000, 0x8000, CRC(de12ac34) SHA1(0caeb2a6b209ee34d67d4c619dd63562c839261e) )
+	sc1_china_sound
+ROM_END
+
+ROM_START( sc1chinaap )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-china-town_dat_ac_rot_bss.bin", 0x0000, 0x8000, CRC(6e09a878) SHA1(4084b1dc3425ceb980ef5c63a883720f3ad84d7f) )
+	ROM_LOAD( "club-china-town_dat_ac_rot_ass.bin", 0x8000, 0x8000, CRC(109b722c) SHA1(19426f3f907f108dc16b4036d3986c6395f799d0) )
+
+	sc1_china_sound
+ROM_END
+
+ROM_START( sc1chinab )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-china-town_std_ac_150pnd_lfj_bss.bin", 0x0000, 0x8000, CRC(d41c6999) SHA1(cc2eb2e74ca3bfa78d74dd08f83acb2fe650e13d) )
+	ROM_LOAD( "club-china-town_std_ac_150pnd_lfj_ass.bin", 0x8000, 0x8000, CRC(8c3e69f1) SHA1(cb0cbf7a6039549b969160a162a0cd5511b24cd3) )
+
+	sc1_china_sound
+ROM_END
+
+ROM_START( sc1chinabp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-china-town_dat_ac_150pnd_lfj_bss.bin", 0x0000, 0x8000, CRC(d41c6999) SHA1(cc2eb2e74ca3bfa78d74dd08f83acb2fe650e13d) )
+	ROM_LOAD( "club-china-town_dat_ac_150pnd_lfj_ass.bin", 0x8000, 0x8000, CRC(9547727a) SHA1(ac4a23ae78d9331261ee0ab59816f65c5c1547d7) )
+
+	sc1_china_sound
 ROM_END
 
 ROM_START( sc1class )
@@ -1470,8 +1590,8 @@
 
 ROM_START( sc1cwcl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95717153a.bin", 0x8000, 0x008000, CRC(233174a1) SHA1(94cf071a955e3716f463c4370daabfe94db2fd0e) )
-	ROM_LOAD( "95717154b.bin", 0x0000, 0x008000, CRC(e6422f75) SHA1(4ab33a5503209377f4739dbe11e4afa8d7e43699) )
+	ROM_LOAD( "95717154b.bin", 0x0000, 0x8000, CRC(e6422f75) SHA1(4ab33a5503209377f4739dbe11e4afa8d7e43699) )
+	ROM_LOAD( "95717153a.bin", 0x8000, 0x8000, CRC(233174a1) SHA1(94cf071a955e3716f463c4370daabfe94db2fd0e) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
 	ROM_LOAD( "95000001snd.bin", 0x00000, 0x008000, CRC(38f85127) SHA1(c9c7c8892396180aa4c4a727422391b9ce93a10a) )
@@ -1492,86 +1612,111 @@
 
 ROM_START( sc1cl2k )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club2000.rom", 0x0000, 0x010000, CRC(2806b89d) SHA1(d1641b33e61de42dc7a643875226a276cf480832) )
+	ROM_LOAD( "club2000.rom", 0x00000, 0x10000, CRC(2806b89d) SHA1(d1641b33e61de42dc7a643875226a276cf480832) )
 ROM_END
 
 ROM_START( sc1cl2k1 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club2001.bin", 0x0000, 0x010000, CRC(4bb26aca) SHA1(41a896be314f2fefdaba962b44e9562aaf0642b1) )
+	ROM_LOAD( "club2001.bin", 0x00000, 0x10000, CRC(4bb26aca) SHA1(41a896be314f2fefdaba962b44e9562aaf0642b1) )
 ROM_END
 
-
 ROM_START( sc1cl65 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "65spp1", 0x8000, 0x008000, CRC(2c4cb63b) SHA1(5d09b575cf80beecd83c07286b74af29de7ec553) )
-	ROM_LOAD( "65spp2", 0x0000, 0x008000, CRC(11332a28) SHA1(76f9eee54351e0d8dc4b620ec92661538929e75d) )
+	ROM_LOAD( "65spp2", 0x0000, 0x8000, CRC(11332a28) SHA1(76f9eee54351e0d8dc4b620ec92661538929e75d) )
+	ROM_LOAD( "65spp1", 0x8000, 0x8000, CRC(2c4cb63b) SHA1(5d09b575cf80beecd83c07286b74af29de7ec553) )
 
 	ROM_REGION( 0x10000, "altrevs", 0 )
 	ROM_LOAD( "39370694.p2", 0x0000, 0x008000, CRC(3371dc55) SHA1(52d75a90933acc7a03821e5c2821df6126c72a6c) )
 	ROM_LOAD( "39370714.p2", 0x0000, 0x008000, CRC(cb9f944f) SHA1(49955a968264f3d963317f5c772629d9bbdd33f7) )
 	ROM_LOAD( "39370858.p2", 0x0000, 0x008000, CRC(ff0e35c0) SHA1(0d3d46b541e188200cb4b9cc65eb60eac913dc2b) )
 	ROM_LOAD( "39370859.p2", 0x0000, 0x008000, CRC(f04065a0) SHA1(d63ba578931b2f4f156ca875da9cf69cf283a27c) )
-	ROM_LOAD( "club-six-five-special_dat_ac_200pnd_rot_10po_ass.bin", 0x0000, 0x008000, CRC(836e65d8) SHA1(931e5831b0b64e7ce29fb497435d486e40dce839) )
-	ROM_LOAD( "club-six-five-special_dat_ac_200pnd_rot_20po_ass.bin", 0x0000, 0x008000, CRC(83a0253f) SHA1(a9b463e2aa87a736f88c5e71f233ff9d6a8b25b4) )
-	ROM_LOAD( "club-six-five-special_dat_ac_rot_10po_ass.bin", 0x0000, 0x008000, CRC(77ddf81d) SHA1(522d9f84ab6e31586f371548e2f146ac193f06f5) )
 	ROM_LOAD( "club-six-five-special_dat_ac_rot_20po_ass.bin", 0x0000, 0x008000, CRC(028ff7b2) SHA1(500b6f8d85678e99ae804600099fe78b542ad6a3) )
-	ROM_LOAD( "club-six-five-special_snd_a.bin", 0x0000, 0x010000, CRC(915802cd) SHA1(5bca3a80199a6534e084a5cf4337da4e9c48f45c) )
-	ROM_LOAD( "club-six-five-special_snd_b.bin", 0x0000, 0x010000, CRC(b3b230d8) SHA1(022e95f38b14922137222805c0bec7498c5956cc) )
-	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_10po_ass.bin", 0x0000, 0x008000, CRC(eedd9fa1) SHA1(6233e8304ac94798cfb908b2ba31ec6c98808ce8) )
-	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_10po_bss.bin", 0x0000, 0x008000, CRC(f04065a0) SHA1(d63ba578931b2f4f156ca875da9cf69cf283a27c) )
-	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_20po_ass.bin", 0x0000, 0x008000, CRC(dd188272) SHA1(d6b7f7b060e632bd3eacc7f7721399a1c8349698) )
-	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_20po_bss.bin", 0x0000, 0x008000, CRC(ff0e35c0) SHA1(0d3d46b541e188200cb4b9cc65eb60eac913dc2b) )
-	ROM_LOAD( "club-six-five-special_std_ac_a.bin", 0x0000, 0x008000, CRC(8bd817f8) SHA1(6ae91a29a6263c085f6254a049fb3c2ba9cac662) )
-	ROM_LOAD( "club-six-five-special_std_ac_b.bin", 0x0000, 0x008000, CRC(cb9f944f) SHA1(49955a968264f3d963317f5c772629d9bbdd33f7) )
-	ROM_LOAD( "club-six-five-special_std_ac_rot_10po_ass.bin", 0x0000, 0x008000, CRC(cf48ba99) SHA1(5da4321ff349964e903f1bebd3e5ddd0799fc478) )
-	ROM_LOAD( "club-six-five-special_std_ac_rot_10po_bss.bin", 0x0000, 0x008000, CRC(3371dc55) SHA1(52d75a90933acc7a03821e5c2821df6126c72a6c) )
 
-	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "65sndp1.bin", 0x000000, 0x010000, CRC(e532fcf5) SHA1(7de3bd4a3efae7d1cfeee23c008efbff39ce46f8) )
-	ROM_LOAD( "65sndp2.bin", 0x010000, 0x010000, CRC(2703ea2d) SHA1(a4876a10d8d4b1de01dfab76e4ee21cb120aa783) )
+	sc1_cl65_sound
 ROM_END
 
+ROM_START( sc1cl65a )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_20po_bss.bin", 0x0000, 0x8000, CRC(ff0e35c0) SHA1(0d3d46b541e188200cb4b9cc65eb60eac913dc2b) )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_20po_ass.bin", 0x8000, 0x8000, CRC(dd188272) SHA1(d6b7f7b060e632bd3eacc7f7721399a1c8349698) )
 
+	sc1_cl65_sound_alt
+ROM_END
 
-ROM_START( sc1clbdm )
+ROM_START( sc1cl65ap )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "clubdiamond.bin", 0x8000, 0x008000, CRC(7e6a569e) SHA1(ba15478ae0312d3e9c21546aa676b4ab95ae944c) )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_20po_bss.bin", 0x0000, 0x8000, CRC(ff0e35c0) SHA1(0d3d46b541e188200cb4b9cc65eb60eac913dc2b) )
+	ROM_LOAD( "club-six-five-special_dat_ac_200pnd_rot_20po_ass.bin", 0x8000, 0x8000, CRC(83a0253f) SHA1(a9b463e2aa87a736f88c5e71f233ff9d6a8b25b4) )
+
+	sc1_cl65_sound_alt
 ROM_END
 
+ROM_START( sc1cl65b )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_10po_bss.bin", 0x0000, 0x8000, CRC(f04065a0) SHA1(d63ba578931b2f4f156ca875da9cf69cf283a27c) )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_10po_ass.bin", 0x8000, 0x8000, CRC(eedd9fa1) SHA1(6233e8304ac94798cfb908b2ba31ec6c98808ce8) )
+
+	sc1_cl65_sound_alt
+ROM_END
 
+ROM_START( sc1cl65bp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-six-five-special_std_ac_200pnd_rot_10po_bss.bin", 0x0000, 0x8000, CRC(f04065a0) SHA1(d63ba578931b2f4f156ca875da9cf69cf283a27c) )
+	ROM_LOAD( "club-six-five-special_dat_ac_200pnd_rot_10po_ass.bin", 0x8000, 0x8000, CRC(836e65d8) SHA1(931e5831b0b64e7ce29fb497435d486e40dce839) )
 
+	sc1_cl65_sound_alt
+ROM_END
 
-ROM_START( sc1clbxp )
+ROM_START( sc1cl65c )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "clubexplosion1.bin", 0x8000, 0x008000, CRC(876161db) SHA1(a6262d70870a6edb71469ec8cea317b185aec49e) )
-	ROM_LOAD( "clubexplosion2.bin", 0x0000, 0x008000, CRC(da56fbdd) SHA1(0ea35f6672a4a4b9236d8341733496450b64238e) )
+	ROM_LOAD( "club-six-five-special_std_ac_b.bin", 0x0000, 0x8000, CRC(cb9f944f) SHA1(49955a968264f3d963317f5c772629d9bbdd33f7) )
+	ROM_LOAD( "club-six-five-special_std_ac_a.bin", 0x8000, 0x8000, CRC(8bd817f8) SHA1(6ae91a29a6263c085f6254a049fb3c2ba9cac662) )
 
-	ROM_REGION( 0x20000, "upd", 0 )//Did a version of this have a UPD sound board, if so, these seem to be ROMs for it
-	ROM_LOAD( "95000004.bin", 0x000000, 0x008000, CRC(6ed10c9b) SHA1(cd209e8f9e0a3fd41e4ed8b6c9387ee91c19704c) )
-	ROM_LOAD( "95000005.bin", 0x008000, 0x008000, CRC(9e16aee2) SHA1(25610fcd4c073ff7f20a3d24f96792913fa447f7) )
-	ROM_LOAD( "95000006.bin", 0x010000, 0x008000, CRC(41636b3d) SHA1(8bc4dfcd5bd56422e303c73d50c2e7afa2edef5a) )
+	sc1_cl65_sound_alt
 ROM_END
 
+ROM_START( sc1cl65d )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-six-five-special_std_ac_rot_10po_bss.bin", 0x0000, 0x8000, CRC(3371dc55) SHA1(52d75a90933acc7a03821e5c2821df6126c72a6c) )
+	ROM_LOAD( "club-six-five-special_std_ac_rot_10po_ass.bin", 0x8000, 0x8000, CRC(cf48ba99) SHA1(5da4321ff349964e903f1bebd3e5ddd0799fc478) )
 
+	sc1_cl65_sound_alt
+ROM_END
 
+ROM_START( sc1cl65dp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-six-five-special_std_ac_rot_10po_bss.bin", 0x0000, 0x8000, CRC(3371dc55) SHA1(52d75a90933acc7a03821e5c2821df6126c72a6c) )
+	ROM_LOAD( "club-six-five-special_dat_ac_rot_10po_ass.bin", 0x8000, 0x8000, CRC(77ddf81d) SHA1(522d9f84ab6e31586f371548e2f146ac193f06f5) )
 
+	sc1_cl65_sound_alt
+ROM_END
 
-ROM_START( sc1clbrn )
+ROM_START( sc1clbdm )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "clubrunner.bin", 0x0000, 0x010000, CRC(32b2d57b) SHA1(26523518bfb726d55d6808451f4041756f99b1d9) )
+	ROM_LOAD( "clubdiamond.bin", 0x8000, 0x8000, CRC(7e6a569e) SHA1(ba15478ae0312d3e9c21546aa676b4ab95ae944c) )
 ROM_END
 
+ROM_START( sc1clbxp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "clubexplosion2.bin", 0x0000, 0x8000, CRC(da56fbdd) SHA1(0ea35f6672a4a4b9236d8341733496450b64238e) )
+	ROM_LOAD( "clubexplosion1.bin", 0x8000, 0x8000, CRC(876161db) SHA1(a6262d70870a6edb71469ec8cea317b185aec49e) )
 
+	ROM_REGION( 0x20000, "upd", 0 )//Did a version of this have a UPD sound board, if so, these seem to be ROMs for it
+	ROM_LOAD( "95000004.bin", 0x000000, 0x008000, CRC(6ed10c9b) SHA1(cd209e8f9e0a3fd41e4ed8b6c9387ee91c19704c) )
+	ROM_LOAD( "95000005.bin", 0x008000, 0x008000, CRC(9e16aee2) SHA1(25610fcd4c073ff7f20a3d24f96792913fa447f7) )
+	ROM_LOAD( "95000006.bin", 0x010000, 0x008000, CRC(41636b3d) SHA1(8bc4dfcd5bd56422e303c73d50c2e7afa2edef5a) )
+ROM_END
 
+ROM_START( sc1clbrn )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "clubrunner.bin", 0x00000, 0x10000, CRC(32b2d57b) SHA1(26523518bfb726d55d6808451f4041756f99b1d9) )
+ROM_END
 
 ROM_START( sc1clbsp )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "rveclsp0108_1.bin", 0x0000, 0x010000, CRC(d60c9f4b) SHA1(dcbb6a10db2f658b734ed0fdecf907a4a32eedaa) )
 ROM_END
 
-
-
-
 ROM_START( sc1clbtm )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 
@@ -1595,48 +1740,53 @@
     ROM_LOAD( "club-temptation_mtx_(ihex)ss.hex", 0x0000, 0x01d0da, CRC(08ebee96) SHA1(2e87d734c966abab1d4a59c9481ebea161f77286) )
     ROM_LOAD( "clubtempdot.bin", 0x0000, 0x010000, CRC(283d2d9c) SHA1(5b76a13ad674f8a40c270e5dbc61dac04d411d02) )
     */
-	ROM_LOAD( "temp11a.bin", 0x8000, 0x008000, CRC(37c8b73e) SHA1(f718572d170be7b582c3818df7163309cea232b5) )
-	ROM_LOAD( "temp12b.bin", 0x0000, 0x008000, CRC(3c27c592) SHA1(081d61f974e2ae5c64729b32be4c0e5067a20550) )
-
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "temptp1", 0x0000, 0x008000, CRC(6f03648d) SHA1(a6402c94ebf4d570d1d3fb462eb621566c27f307) )
-	ROM_LOAD( "temptp2", 0x0000, 0x008000, CRC(d165fa87) SHA1(aef8a4af8b6e83ef09dffc8aca305eaf7dd3936b) )
-
+	ROM_LOAD( "temp12b.bin", 0x0000, 0x8000, CRC(3c27c592) SHA1(081d61f974e2ae5c64729b32be4c0e5067a20550) )
+	ROM_LOAD( "temp11a.bin", 0x8000, 0x8000, CRC(37c8b73e) SHA1(f718572d170be7b582c3818df7163309cea232b5) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "tempsnd1.bin", 0x0000, 0x010000, CRC(168e2a18) SHA1(db97acf9131b1a54efe1cd375aecae1679bab19e) )
-	ROM_LOAD( "tempsnd2.bin", 0x0000, 0x010000, CRC(b717f347) SHA1(189c82318d622f18580a23eed48b17c0c34dedd5) )
+	ROM_LOAD( "tempsnd1.bin", 0x00000, 0x10000, CRC(168e2a18) SHA1(db97acf9131b1a54efe1cd375aecae1679bab19e) )
+	ROM_LOAD( "tempsnd2.bin", 0x00000, 0x10000, CRC(b717f347) SHA1(189c82318d622f18580a23eed48b17c0c34dedd5) )
 ROM_END
 
+ROM_START( sc1clbtma )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "temptp2", 0x0000, 0x8000, CRC(d165fa87) SHA1(aef8a4af8b6e83ef09dffc8aca305eaf7dd3936b) )
+	ROM_LOAD( "temptp1", 0x8000, 0x8000, CRC(6f03648d) SHA1(a6402c94ebf4d570d1d3fb462eb621566c27f307) )
 
-
+	ROM_REGION( 0x40000, "upd", 0 )
+	ROM_LOAD( "tempsnd1.bin", 0x00000, 0x10000, CRC(168e2a18) SHA1(db97acf9131b1a54efe1cd375aecae1679bab19e) )
+	ROM_LOAD( "tempsnd2.bin", 0x00000, 0x10000, CRC(b717f347) SHA1(189c82318d622f18580a23eed48b17c0c34dedd5) )
+ROM_END
 
 ROM_START( sc1clbw )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "clbwzp1", 0x8000, 0x008000, CRC(c61dd4eb) SHA1(e1756f8841dabe1bc002aadba6b224a558096a96) )
-	ROM_LOAD( "clbwzp2", 0x0000, 0x008000, CRC(44bb7e16) SHA1(d3c258ea286be18dc667df6a7138280462db661b) )
-
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "club wise 95717550a.bin", 0x0000, 0x008000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
-	ROM_LOAD( "club wise 95717551b.bin", 0x0000, 0x008000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
-	ROM_LOAD( "cwise_a.bin", 0x0000, 0x008000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
-	ROM_LOAD( "cwise_b.bin", 0x0000, 0x008000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
+	ROM_LOAD( "clbwzp2", 0x0000, 0x8000, CRC(44bb7e16) SHA1(d3c258ea286be18dc667df6a7138280462db661b) )
+	ROM_LOAD( "clbwzp1", 0x8000, 0x8000, CRC(c61dd4eb) SHA1(e1756f8841dabe1bc002aadba6b224a558096a96) )
+	sc1_clbw_sound
+ROM_END
 
-	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "wisesnd.bin", 0x0000, 0x020000, CRC(35cb0314) SHA1(6ceec1fc17015d8228d55331fcffb77390161136) )
-	ROM_LOAD( "wisesnd1.bin", 0x0000, 0x010000, CRC(204605a6) SHA1(193a60878ed46f122e5d2d8f35fc6ea967b8734f) )
-	ROM_LOAD( "wisesnd2.bin", 0x010000, 0x010000, CRC(6aa66166) SHA1(2e7cc67afdce2febb541bb1d0e7c107876d4233d) )
+ROM_START( sc1clbwa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club wise 95717551b.bin", 0x0000, 0x8000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
+	ROM_LOAD( "club wise 95717550a.bin", 0x8000, 0x8000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
+	sc1_clbw_sound
 ROM_END
 
+ROM_START( sc1clbwb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cwise_b.bin", 0x0000, 0x8000, CRC(0528a718) SHA1(27f4225c948d93ce1c833679f97e045f3b7a6aac) )
+	ROM_LOAD( "cwise_a.bin", 0x8000, 0x8000, CRC(5b305f11) SHA1(592ea71fcb72eaa90fd421e3bd3761cfd686b019) )
+	sc1_clbw_sound
+ROM_END
 
 
 ROM_START( sc1copdd )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "game_835.bin", 0x0000, 0x010000, CRC(af134088) SHA1(c6467102903a2910c67f2b8051e1f788576ef62f) )
+	ROM_LOAD( "game_835.bin", 0x00000, 0x10000, CRC(af134088) SHA1(c6467102903a2910c67f2b8051e1f788576ef62f) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "snd1ic7_519.bin", 0x0000, 0x010000, CRC(5cd39b04) SHA1(83cc51c208e8a9d3ccd0b4fcd2ab74a5f71e0c28) )
-	ROM_LOAD( "snd2ic8_520.bin", 0x0000, 0x010000, CRC(a22621ec) SHA1(add91e6b1e14118c718614a7cfaa2d3aabbf01b3) )
+	ROM_LOAD( "snd1ic7_519.bin", 0x00000, 0x10000, CRC(5cd39b04) SHA1(83cc51c208e8a9d3ccd0b4fcd2ab74a5f71e0c28) )
+	ROM_LOAD( "snd2ic8_520.bin", 0x00000, 0x10000, CRC(a22621ec) SHA1(add91e6b1e14118c718614a7cfaa2d3aabbf01b3) )
 ROM_END
 
 
@@ -1644,12 +1794,12 @@
 
 ROM_START( sc1copdx )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cops & robbers deluxe 5p-10p 6 p1 95840219 (27256)", 0x8000, 0x008000, CRC(47867f55) SHA1(33f879a8e1e4e2f53b5da8b4ee597bd3870c75d1) )
-	ROM_LOAD( "cops & robbers deluxe 5p-10p 6 p2 95840220 (27256)", 0x0000, 0x008000, CRC(32a22682) SHA1(c173688ace476a2ada398d5e7b5dfed5306e3c50) )
+	ROM_LOAD( "cops & robbers deluxe 5p-10p 6 p2 95840220 (27256)", 0x0000, 0x8000, CRC(32a22682) SHA1(c173688ace476a2ada398d5e7b5dfed5306e3c50) )
+	ROM_LOAD( "cops & robbers deluxe 5p-10p 6 p1 95840219 (27256)", 0x8000, 0x8000, CRC(47867f55) SHA1(33f879a8e1e4e2f53b5da8b4ee597bd3870c75d1) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "cops & robbers deluxe sound 1 295 (27512)", 0x000000, 0x010000, CRC(81227c21) SHA1(6af8e15f8405fdfbaa3a8853ec7ec62fe5ec34ae) )
-	ROM_LOAD( "cops & robbers deluxe sound 2 296 (27512)", 0x010000, 0x010000, CRC(8ecf1f5e) SHA1(4159b5c3800708cde94ce62a5e07b58ad8aaedf8) )
+	ROM_LOAD( "cops & robbers deluxe sound 1 295 (27512)", 0x00000, 0x10000, CRC(81227c21) SHA1(6af8e15f8405fdfbaa3a8853ec7ec62fe5ec34ae) )
+	ROM_LOAD( "cops & robbers deluxe sound 2 296 (27512)", 0x10000, 0x10000, CRC(8ecf1f5e) SHA1(4159b5c3800708cde94ce62a5e07b58ad8aaedf8) )
 ROM_END
 
 
@@ -1657,21 +1807,32 @@
 
 ROM_START( sc1count )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club-count-cash_std_ac_200pnd_rot_ass.bin", 0x8000, 0x008000, CRC(a6a1a604) SHA1(86e59578fed7023b0e6a42495b9a60e7178ee566) )
-	ROM_LOAD( "club-count-cash_std_ac_200pnd_rot_bss.bin", 0x0000, 0x008000, CRC(8e385a9e) SHA1(67c45734501c16be3b8270f388dc1313bce289f8) )
+	ROM_LOAD( "club-count-cash_std_ac_200pnd_rot_bss.bin", 0x0000, 0x8000, CRC(8e385a9e) SHA1(67c45734501c16be3b8270f388dc1313bce289f8) )
+	ROM_LOAD( "club-count-cash_std_ac_200pnd_rot_ass.bin", 0x8000, 0x8000, CRC(a6a1a604) SHA1(86e59578fed7023b0e6a42495b9a60e7178ee566) )
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "club-count-cash_dat_ac_200pnd_rot_ass.bin", 0x0000, 0x008000, CRC(da097abe) SHA1(85f01d8b5dce535a5559fadaf1cf7373c6967882) )
-	ROM_LOAD( "club-count-cash_dat_ac_200pnd_rot_bss.bin", 0x0000, 0x008000, CRC(8e385a9e) SHA1(67c45734501c16be3b8270f388dc1313bce289f8) )
-	ROM_LOAD( "club-count-cash_dat_ac_rnr_ass.bin", 0x0000, 0x008000, CRC(87f68f57) SHA1(fe99c8577a80a7ec791bf87e78cf429eebbc7785) )
-	ROM_LOAD( "club-count-cash_dat_ac_rnr_bss.bin", 0x0000, 0x008000, CRC(69df417d) SHA1(a7788a9f3056919017616960ba5017bcd94b8a98) )
-	ROM_LOAD( "club-count-cash_std_ac_rot_ass.bin", 0x0000, 0x008000, CRC(b081333c) SHA1(75a46634458a790f91360be26cace0e42bbf3481) )
-	ROM_LOAD( "club-count-cash_std_ac_rot_bss.bin", 0x0000, 0x008000, CRC(69df417d) SHA1(a7788a9f3056919017616960ba5017bcd94b8a98) )
-	ROM_LOAD( "club-game-show_std_ac_250pnd-25p_ass.bin", 0x0000, 0x010000, CRC(36efa743) SHA1(0f5392f55e42d7ac17e179c966997f41859f925a) )
+ROM_START( sc1countp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-count-cash_dat_ac_200pnd_rot_bss.bin", 0x0000, 0x8000, CRC(8e385a9e) SHA1(67c45734501c16be3b8270f388dc1313bce289f8) )
+	ROM_LOAD( "club-count-cash_dat_ac_200pnd_rot_ass.bin", 0x8000, 0x8000, CRC(da097abe) SHA1(85f01d8b5dce535a5559fadaf1cf7373c6967882) )
 ROM_END
 
+ROM_START( sc1counta )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-count-cash_std_ac_rot_bss.bin", 0x0000, 0x8000, CRC(69df417d) SHA1(a7788a9f3056919017616960ba5017bcd94b8a98) )
+	ROM_LOAD( "club-count-cash_std_ac_rot_ass.bin", 0x8000, 0x8000, CRC(b081333c) SHA1(75a46634458a790f91360be26cace0e42bbf3481) )
+ROM_END
 
+ROM_START( sc1countap )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-count-cash_dat_ac_rnr_bss.bin", 0x0000, 0x8000, CRC(69df417d) SHA1(a7788a9f3056919017616960ba5017bcd94b8a98) )
+	ROM_LOAD( "club-count-cash_dat_ac_rnr_ass.bin", 0x8000, 0x8000, CRC(87f68f57) SHA1(fe99c8577a80a7ec791bf87e78cf429eebbc7785) )
+ROM_END
 
+ROM_START( sc1countb )
+	ROM_REGION( 0x10000, "maincpu", 0 )//odds are this needs to be split in two
+	ROM_LOAD( "club-game-show_std_ac_250pnd-25p_ass.bin", 0x0000, 0x010000, CRC(36efa743) SHA1(0f5392f55e42d7ac17e179c966997f41859f925a) )
+ROM_END
 
 ROM_START( sc1dago )
 	ROM_REGION( 0x10000, "maincpu", 0 )
@@ -1683,74 +1844,69 @@
 
 ROM_START( sc1disc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "disc-88.a", 0x8000, 0x008000, CRC(1ac052d0) SHA1(a37cc2896fb884af7e922289d7fda1e7d26fc387) )
 	ROM_LOAD( "disc-88.b", 0x0000, 0x008000, CRC(f6e2d800) SHA1(a0c7ab0c913d9284cdbfa1d35b62afefb903c086) )
+	ROM_LOAD( "disc-88.a", 0x8000, 0x008000, CRC(1ac052d0) SHA1(a37cc2896fb884af7e922289d7fda1e7d26fc387) )
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
+ROM_START( sc1disca )
+	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "ds1.bin", 0x0000, 0x008000, CRC(22f6ce92) SHA1(5db8f54bc83e963687ebe2f13769e3f2f678d356) )
 	ROM_LOAD( "ds2.bin", 0x0000, 0x008000, CRC(fa549c55) SHA1(93a31e4f847dcd326760d17753c994f6210fb6ed) )
 ROM_END
 
 
-
-
 ROM_START( sc1dblch )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "doublechancegame1.bin", 0x8000, 0x008000, CRC(9e24e0e3) SHA1(fff1fe9219c052750709d13c06148c7926a22910) )
 	ROM_LOAD( "doublechancegame2.bin", 0x0000, 0x008000, CRC(d4f49454) SHA1(53b97f941a4abfeb3e498b4295f98e80bd182b7e) )
+	ROM_LOAD( "doublechancegame1.bin", 0x8000, 0x008000, CRC(9e24e0e3) SHA1(fff1fe9219c052750709d13c06148c7926a22910) )
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "717416_dc_std.a", 0x0000, 0x008000, CRC(949726ed) SHA1(6ecebd20387aa73b0404ab4b7342e2b39d77b37f) )
-	ROM_LOAD( "717417_dc_std.b", 0x0000, 0x008000, CRC(51e5459b) SHA1(b6ffbcff63fd3543226778c61fbe2246f40635dd) )
-	ROM_LOAD( "95000110_dc_sound_2", 0x0000, 0x010000, CRC(bee6af3e) SHA1(334fe491a00f58a2142f65344674b26c766a7c5b) )
-	ROM_LOAD( "95000111_dc_sound_1", 0x0000, 0x010000, CRC(bbadc876) SHA1(902e387ea9bcd833cf75a6f049b5b2822ec6dc2a) )
+	ROM_REGION( 0x40000, "altrevs", 0 )//orphans?
 	ROM_LOAD( "95717787 10p20p.bin", 0x0000, 0x008000, CRC(69ba126c) SHA1(f59aa5a632d0bc5102c206f986f86b6c7c1352fb) )
 	ROM_LOAD( "95717789 10p.bin", 0x0000, 0x008000, CRC(fc338d38) SHA1(65457f2611ffa22ac35f1e7ad10c290c01b9c3ac) )
 	ROM_LOAD( "95717790 5p.bin", 0x0000, 0x008000, CRC(c82e57f9) SHA1(456ce5290db322292170412a00f0252b86743ed0) )
 
-	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "doublechancesnd1.bin", 0x0000, 0x010000, CRC(bee6af3e) SHA1(334fe491a00f58a2142f65344674b26c766a7c5b) )
-	ROM_LOAD( "doublechancesnd2.bin", 0x0000, 0x010000, CRC(bbadc876) SHA1(902e387ea9bcd833cf75a6f049b5b2822ec6dc2a) )
+	sc1_dblch_sound
 ROM_END
 
-
-
-
+ROM_START( sc1dblcha )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717417_dc_std.b", 0x0000, 0x8000, CRC(51e5459b) SHA1(b6ffbcff63fd3543226778c61fbe2246f40635dd) )
+	ROM_LOAD( "95717416_dc_std.a", 0x8000, 0x8000, CRC(949726ed) SHA1(6ecebd20387aa73b0404ab4b7342e2b39d77b37f) )
+	sc1_dblch_sound
+ROM_END
 
 ROM_START( sc1dream )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "95752021.bin", 0x0000, 0x010000, CRC(ea7d1cec) SHA1(d277b639575498c458f98e0e1a629d914ca36cfe) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "95000604.bin", 0x0000, 0x010000, CRC(7c2f52ed) SHA1(d435402459efc9311707ac691992874b56cbbeec) )
-	ROM_LOAD( "95000605.bin", 0x0000, 0x010000, CRC(23b99731) SHA1(7cc1c51d9b72480d8a1020fc3621a05ba83d7629) )
+	ROM_LOAD( "95000604.bin", 0x00000, 0x10000, CRC(7c2f52ed) SHA1(d435402459efc9311707ac691992874b56cbbeec) )
+	ROM_LOAD( "95000605.bin", 0x00000, 0x10000, CRC(23b99731) SHA1(7cc1c51d9b72480d8a1020fc3621a05ba83d7629) )
 ROM_END
 
 
-
-
 ROM_START( sc1final )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "finaltouch_prg.bin", 0x0000, 0x010000, CRC(27a74fbb) SHA1(8c3e76c67605866acf8e6e28b14788a5cbcd43b4) )
+	ROM_LOAD( "finaltouch_prg.bin", 0x00000, 0x10000, CRC(27a74fbb) SHA1(8c3e76c67605866acf8e6e28b14788a5cbcd43b4) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "finaltouch_snd1.bin", 0x000000, 0x010000, CRC(18ebcdd2) SHA1(17efd903d205d7285f642017de8b5799ede2110b) )
-	ROM_LOAD( "finaltouch_snd2.bin", 0x010000, 0x010000, CRC(75a76a6a) SHA1(a660285d56517876414dc951e98185ea14e8fb4e) )
+	ROM_LOAD( "finaltouch_snd1.bin", 0x00000, 0x10000, CRC(18ebcdd2) SHA1(17efd903d205d7285f642017de8b5799ede2110b) )
+	ROM_LOAD( "finaltouch_snd2.bin", 0x10000, 0x10000, CRC(75a76a6a) SHA1(a660285d56517876414dc951e98185ea14e8fb4e) )
 ROM_END
 
 
 
 ROM_START( sc1flash )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "flash.bin", 0x0000, 0x010000, CRC(42475bd9) SHA1(634759e64ecc001da5eca01b89e5b93749de541d) )
+	ROM_LOAD( "flash.bin", 0x00000, 0x10000, CRC(42475bd9) SHA1(634759e64ecc001da5eca01b89e5b93749de541d) )
 ROM_END
 
 
 
 ROM_START( sc1fruit )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "fruitlnsa.bin", 0x8000, 0x008000, CRC(c002dde4) SHA1(7f7601108975f09ed5846d8acf90a5db36319bbd) )
-	ROM_LOAD( "fruitlnsb.bin", 0x0000, 0x008000, CRC(9a44bfdc) SHA1(cd7890b781411b1fdf8abe17e3337a92b40596c7) )
+	ROM_LOAD( "fruitlnsb.bin", 0x0000, 0x8000, CRC(9a44bfdc) SHA1(cd7890b781411b1fdf8abe17e3337a92b40596c7) )
+	ROM_LOAD( "fruitlnsa.bin", 0x8000, 0x8000, CRC(c002dde4) SHA1(7f7601108975f09ed5846d8acf90a5db36319bbd) )
 ROM_END
 
 
@@ -1761,55 +1917,63 @@
 ROM_END
 
 
-
 ROM_START( sc1funh )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club-fun-house_std_ac_a.bin", 0x008000, 0x008000, CRC(f81dff1b) SHA1(4c205b3901f683d3679af9d311813ad912ecb436) )
-	ROM_LOAD( "club-fun-house_std_ac_b.bin", 0x0000, 0x008000, CRC(1a838f0d) SHA1(747153e1bb9fc4fc28451e828fa2473f2e6d5e0e) )
+	ROM_LOAD( "club-fun-house_std_ac_b.bin", 0x0000, 0x8000, CRC(1a838f0d) SHA1(747153e1bb9fc4fc28451e828fa2473f2e6d5e0e) )
+	ROM_LOAD( "club-fun-house_std_ac_a.bin", 0x8000, 0x8000, CRC(f81dff1b) SHA1(4c205b3901f683d3679af9d311813ad912ecb436) )
+	sc1_funh_sound
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "club-fun-house_dat_ac_rot_ass.bin", 0x0000, 0x00781f, CRC(9a24dc71) SHA1(bb19ef26d6d46605107c8b53c6d9b4f08ed4c721) )
+ROM_START( sc1funhp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "club-fun-house_dat_ac_rot_bss.bin", 0x0000, 0x008000, CRC(1a838f0d) SHA1(747153e1bb9fc4fc28451e828fa2473f2e6d5e0e) )
-	ROM_LOAD( "club-fun-house_std_ac_ass.bin", 0x0000, 0x008000, CRC(f81dff1b) SHA1(4c205b3901f683d3679af9d311813ad912ecb436) )
-	ROM_LOAD( "club-fun-house_std_ac_bss.bin", 0x0000, 0x008000, CRC(1a838f0d) SHA1(747153e1bb9fc4fc28451e828fa2473f2e6d5e0e) )
-	ROM_LOAD( "funhop1", 0x0000, 0x008000, CRC(282d5651) SHA1(bd8c0985143d8fb5c8e0a2bfedea248569c8cf98) )
-	ROM_LOAD( "funhop2", 0x0000, 0x008000, CRC(2454e295) SHA1(9785d278afe05c632e1ab326d1b8fbabcc591fb6) )
-	ROM_LOAD( "funhouse.bin", 0x0000, 0x010000, CRC(4e342025) SHA1(288125ff5e3da7249d89dfcc3cd0915f791f7d43) )
+	ROM_LOAD( "club-fun-house_dat_ac_rot_ass.bin", 0x8000, 0x00781f,  BAD_DUMP CRC(9a24dc71) SHA1(bb19ef26d6d46605107c8b53c6d9b4f08ed4c721) )
+	sc1_funh_sound
+ROM_END
 
-	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "fhsesnd1.bin", 0x0000, 0x010000, CRC(bf371dbf) SHA1(0c9bc0d0964a858fba5324080a2cf5da119bf3db) )
-	ROM_LOAD( "fhsesnd2.bin", 0x0000, 0x010000, CRC(c51415e3) SHA1(f0e4eb5ce38faaef336a5b69e598985ea2486ceb) )
+ROM_START( sc1funha )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "funhop2", 0x0000, 0x8000, CRC(2454e295) SHA1(9785d278afe05c632e1ab326d1b8fbabcc591fb6) )
+	ROM_LOAD( "funhop1", 0x8000, 0x8000, CRC(282d5651) SHA1(bd8c0985143d8fb5c8e0a2bfedea248569c8cf98) )
+
+	sc1_funh_sound
 ROM_END
 
+ROM_START( sc1funhb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "funhouse.bin", 0x00000, 0x10000, CRC(4e342025) SHA1(288125ff5e3da7249d89dfcc3cd0915f791f7d43) )
+
+	sc1_funh_sound
+ROM_END
 
 
 ROM_START( sc1gtime )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "goodtime.bin", 0x0000, 0x010000, CRC(9958dc86) SHA1(43221d0eb50ebe3db8b1d1e784e19b5cbb86c24c) )
+	ROM_LOAD( "goodtime.bin", 0x00000, 0x10000, CRC(9958dc86) SHA1(43221d0eb50ebe3db8b1d1e784e19b5cbb86c24c) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "goodtimesound1.bin", 0x0000, 0x010000, CRC(554d1157) SHA1(ae802338b40a0b35dcdf788c19ef42c2ed7e9a37) )
-	ROM_LOAD( "goodtimesound2.bin", 0x010000, 0x010000, CRC(e6c53e20) SHA1(30cb83d03fe873b4ec822d3aa1001b7fed9571ff) )
+	ROM_LOAD( "goodtimesound1.bin", 0x00000, 0x10000, CRC(554d1157) SHA1(ae802338b40a0b35dcdf788c19ef42c2ed7e9a37) )
+	ROM_LOAD( "goodtimesound2.bin", 0x10000, 0x10000, CRC(e6c53e20) SHA1(30cb83d03fe873b4ec822d3aa1001b7fed9571ff) )
 ROM_END
 
 ROM_START( sc1tiara )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "tiara_prg1u.bin", 0x0000, 0x010000, CRC(963fc838) SHA1(375bc2fb72c89095d1afae77762e94d7adb79133) )
+	ROM_LOAD( "tiara_prg1u.bin", 0x00000, 0x10000, CRC(963fc838) SHA1(375bc2fb72c89095d1afae77762e94d7adb79133) )
 
 	ROM_REGION( 0x40000, "upd", 0 ) // same sound roms as good times?
-	ROM_LOAD( "tiara_snd1.bin", 0x0000, 0x010000, CRC(554d1157) SHA1(ae802338b40a0b35dcdf788c19ef42c2ed7e9a37) )
-	ROM_LOAD( "tiara_snd2.bin", 0x010000, 0x010000, CRC(e6c53e20) SHA1(30cb83d03fe873b4ec822d3aa1001b7fed9571ff) )
+	ROM_LOAD( "tiara_snd1.bin", 0x00000, 0x10000, CRC(554d1157) SHA1(ae802338b40a0b35dcdf788c19ef42c2ed7e9a37) )
+	ROM_LOAD( "tiara_snd2.bin", 0x00000, 0x10000, CRC(e6c53e20) SHA1(30cb83d03fe873b4ec822d3aa1001b7fed9571ff) )
 ROM_END
 
 
 
 ROM_START( sc1gprix )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "gp.bin", 0x0000, 0x010000, CRC(35cfe52c) SHA1(5debd45553e91d2aab102c5a712f912efdd6ada3) )
+	ROM_LOAD( "gp.bin", 0x00000, 0x10000, CRC(35cfe52c) SHA1(5debd45553e91d2aab102c5a712f912efdd6ada3) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "grandprix_snd1.bin", 0x0000, 0x010000, CRC(86139b6a) SHA1(13b9483f7379e3cc25f5474fa950878e0a2853d2) )
-	ROM_LOAD( "grandprix_snd2.bin", 0x010000, 0x010000, CRC(f1a91ced) SHA1(97e3f03b7eac975ff9dd4e0f10eb18314c36f201) )
+	ROM_LOAD( "grandprix_snd1.bin", 0x00000, 0x10000, CRC(86139b6a) SHA1(13b9483f7379e3cc25f5474fa950878e0a2853d2) )
+	ROM_LOAD( "grandprix_snd2.bin", 0x10000, 0x10000, CRC(f1a91ced) SHA1(97e3f03b7eac975ff9dd4e0f10eb18314c36f201) )
 ROM_END
 
 
@@ -1817,13 +1981,11 @@
 
 ROM_START( sc1gslam )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "gs.bin", 0x0000, 0x010000, CRC(7a239eef) SHA1(5af894dd2df7256c9347b46a5aabd93961c83324) )
+	ROM_LOAD( "gs.bin", 0x00000, 0x10000, CRC(7a239eef) SHA1(5af894dd2df7256c9347b46a5aabd93961c83324) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "gslsnd1.bin", 0x0000, 0x010000, CRC(52ca000a) SHA1(a8d4cedf02fae8bb24ea8cf1f62dace49c773858) )
-	ROM_LOAD( "gslsnd2.bin", 0x0000, 0x010000, CRC(cb52721e) SHA1(395024a425f057f78a8d83cdbbbc9bf1521f3597) )
-	ROM_LOAD( "grandslam_snd_a.bin", 0x0000, 0x010000, CRC(52ca000a) SHA1(a8d4cedf02fae8bb24ea8cf1f62dace49c773858) )
-	ROM_LOAD( "grandslam_snd_b.bin", 0x0000, 0x010000, CRC(cb52721e) SHA1(395024a425f057f78a8d83cdbbbc9bf1521f3597) )
+	ROM_LOAD( "gslsnd1.bin", 0x00000, 0x10000, CRC(52ca000a) SHA1(a8d4cedf02fae8bb24ea8cf1f62dace49c773858) )
+	ROM_LOAD( "gslsnd2.bin", 0x10000, 0x10000, CRC(cb52721e) SHA1(395024a425f057f78a8d83cdbbbc9bf1521f3597) )
 ROM_END
 
 
@@ -1831,11 +1993,11 @@
 
 ROM_START( sc1happy )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "happyhourromd.bin", 0x0000, 0x010000, CRC(7a03df4f) SHA1(78dbadd4acc3ac7d06e2bc8bf9be080e4cd888fb) )
+	ROM_LOAD( "happyhourromd.bin", 0x00000, 0x10000, CRC(7a03df4f) SHA1(78dbadd4acc3ac7d06e2bc8bf9be080e4cd888fb) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "happyhoursnd1.bin", 0x0000, 0x010000, CRC(a7b84f42) SHA1(bfe0b4f7b1c6c55d4fa45ac26f95a045cc21313e) )
-	ROM_LOAD( "happyhoursnd2.bin", 0x010000, 0x010000, CRC(e90ffa86) SHA1(8b4f68e3f010854e13abd689db0961092d2dc491) )
+	ROM_LOAD( "happyhoursnd1.bin", 0x00000, 0x10000, CRC(a7b84f42) SHA1(bfe0b4f7b1c6c55d4fa45ac26f95a045cc21313e) )
+	ROM_LOAD( "happyhoursnd2.bin", 0x10000, 0x10000, CRC(e90ffa86) SHA1(8b4f68e3f010854e13abd689db0961092d2dc491) )
 ROM_END
 
 
@@ -1843,18 +2005,18 @@
 
 ROM_START( sc1impc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "impact.bin", 0x0000, 0x010000, CRC(dd5d94d4) SHA1(1674ec497daa7dd61412a07ebca3447b69c5780e) )
+	ROM_LOAD( "impact.bin", 0x00000, 0x10000, CRC(dd5d94d4) SHA1(1674ec497daa7dd61412a07ebca3447b69c5780e) )
 ROM_END
 
 
 
 ROM_START( sc1kings )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "kingsclub.bin", 0x0000, 0x010000, CRC(6f547e05) SHA1(e52872ab94e6bdcb8aa131db6f21535b78cf53ef) )
+	ROM_LOAD( "kingsclub.bin", 0x00000, 0x10000, CRC(6f547e05) SHA1(e52872ab94e6bdcb8aa131db6f21535b78cf53ef) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "kings279.bin", 0x000000, 0x010000, CRC(8388d112) SHA1(fa31f001011fb463d7cffe88b7cd994ceb3a6977) )
-	ROM_LOAD( "kings280.bin", 0x010000, 0x010000, CRC(5566f2bd) SHA1(a49b7a25cf3a008c78dc59c08aaccb6e0e1e480f) )
+	ROM_LOAD( "kings279.bin", 0x00000, 0x10000, CRC(8388d112) SHA1(fa31f001011fb463d7cffe88b7cd994ceb3a6977) )
+	ROM_LOAD( "kings280.bin", 0x10000, 0x10000, CRC(5566f2bd) SHA1(a49b7a25cf3a008c78dc59c08aaccb6e0e1e480f) )
 ROM_END
 
 
@@ -1862,14 +2024,20 @@
 
 ROM_START( sc1linx )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95710137 a.bin", 0x8000, 0x008000, CRC(29c6b8b1) SHA1(643d06a5064ba74902bfbe115b1bd7b1abe14381) )
-	ROM_LOAD( "95710138 b.bin", 0x0000, 0x008000, CRC(e731dc61) SHA1(c65b2c7006e58e924370261bdb5ac3f5e3e86471) )
+	ROM_LOAD( "95710138 b.bin", 0x0000, 0x8000, CRC(e731dc61) SHA1(c65b2c7006e58e924370261bdb5ac3f5e3e86471) )
+	ROM_LOAD( "95710137 a.bin", 0x8000, 0x8000, CRC(29c6b8b1) SHA1(643d06a5064ba74902bfbe115b1bd7b1abe14381) )
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "linx 10p a.bin", 0x0000, 0x008000, CRC(87d8907c) SHA1(3584441870b0a57284e831b0e68422fa3138b4bf) )
-	ROM_LOAD( "linx 20p n.p.a 95717315.bin", 0x0000, 0x008000, CRC(ea53e0e1) SHA1(d8d57d44188a33e2751bfc4f21249efc32815877) )
-	ROM_LOAD( "linx 20p std 95717316 b.bin", 0x0000, 0x008000, CRC(419b3d7e) SHA1(83b27914cb95afc1053578a279dc936181562217) )
-	ROM_LOAD( "linx var% data 10p b.bin", 0x0000, 0x008000, CRC(c23fc39c) SHA1(4e6d2a16606544c00bd175ade4d9e6491ec317ff) )
+ROM_START( sc1linxa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "linx 20p std 95717316 b.bin", 0x0000, 0x8000, CRC(419b3d7e) SHA1(83b27914cb95afc1053578a279dc936181562217) )
+	ROM_LOAD( "linx 20p n.p.a 95717315.bin", 0x8000, 0x8000, CRC(ea53e0e1) SHA1(d8d57d44188a33e2751bfc4f21249efc32815877) )
+ROM_END
+
+ROM_START( sc1linxp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "linx var% data 10p b.bin", 0x0000, 0x8000, CRC(c23fc39c) SHA1(4e6d2a16606544c00bd175ade4d9e6491ec317ff) )
+	ROM_LOAD( "linx 10p a.bin", 0x8000, 0x8000, CRC(87d8907c) SHA1(3584441870b0a57284e831b0e68422fa3138b4bf) )
 ROM_END
 
 
@@ -1884,8 +2052,8 @@
 
 ROM_START( sc1manha )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "mana.bin", 0x8000, 0x008000, CRC(961dc746) SHA1(98ecfce91f8d111b38d9e658b50bfd921e567a68) )
-	ROM_LOAD( "manb.bin", 0x0000, 0x008000, CRC(a0e73800) SHA1(bb56f2aa211ff48e5d4d8bfdff4fc1c7464e01ca) )
+	ROM_LOAD( "manb.bin", 0x0000, 0x8000, CRC(a0e73800) SHA1(bb56f2aa211ff48e5d4d8bfdff4fc1c7464e01ca) )
+	ROM_LOAD( "mana.bin", 0x8000, 0x8000, CRC(961dc746) SHA1(98ecfce91f8d111b38d9e658b50bfd921e567a68) )
 ROM_END
 
 
@@ -1893,11 +2061,11 @@
 
 ROM_START( sc1mast )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "masterclubgame.bin", 0x0000, 0x010000, CRC(1156383a) SHA1(eb93fae25b1083bfd343015bcbc33f029571b700) )
+	ROM_LOAD( "masterclubgame.bin", 0x00000, 0x10000, CRC(1156383a) SHA1(eb93fae25b1083bfd343015bcbc33f029571b700) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "asnd1.bin", 0x0000, 0x010000, CRC(229d0666) SHA1(68650c920d60df1eff00cd77e0308f5c2fd88baf) )
-	ROM_LOAD( "asnd2.bin", 0x0000, 0x010000, CRC(3b286391) SHA1(0e0cd818d23d73b681905db98c0b9890809b25f6) )
+	ROM_LOAD( "asnd1.bin", 0x00000, 0x10000, CRC(229d0666) SHA1(68650c920d60df1eff00cd77e0308f5c2fd88baf) )
+	ROM_LOAD( "asnd2.bin", 0x10000, 0x10000, CRC(3b286391) SHA1(0e0cd818d23d73b681905db98c0b9890809b25f6) )
 ROM_END
 
 
@@ -1905,7 +2073,7 @@
 
 ROM_START( sc1mist )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "mistral.bin", 0x0000, 0x010000, CRC(7da31d22) SHA1(a63cd098d66af869d3967b15694b6d6ba8cc8d1e) )
+	ROM_LOAD( "mistral.bin", 0x00000, 0x10000, CRC(7da31d22) SHA1(a63cd098d66af869d3967b15694b6d6ba8cc8d1e) )
 ROM_END
 
 
@@ -1913,16 +2081,16 @@
 
 ROM_START( sc1olym )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "olympia.bin", 0x0000, 0x010000, CRC(15728d0a) SHA1(addf84f0efec140eecad48116a84c36662a85db2) )
+	ROM_LOAD( "olympia.bin", 0x00000, 0x10000, CRC(15728d0a) SHA1(addf84f0efec140eecad48116a84c36662a85db2) )
 ROM_END
 
 
 
 
 ROM_START( sc1orac )
-	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "oracle_a.bin", 0x0000, 0x008000, CRC(2177f249) SHA1(5144819a8934734b5de9d56384ae89d015b8acee) )
-	ROM_LOAD( "oracle_b.bin", 0x8000, 0x008000, CRC(93f38e60) SHA1(741402d0f25b59a9d651875bf5ccbc06389b1ea9) )
+	ROM_REGION( 0x10000, "maincpu", 0 )//Is this the right way round? Goes against other labels...
+	ROM_LOAD( "oracle_a.bin", 0x0000, 0x8000, CRC(2177f249) SHA1(5144819a8934734b5de9d56384ae89d015b8acee) )
+	ROM_LOAD( "oracle_b.bin", 0x8000, 0x8000, CRC(93f38e60) SHA1(741402d0f25b59a9d651875bf5ccbc06389b1ea9) )
 ROM_END
 
 
@@ -1930,18 +2098,21 @@
 
 ROM_START( sc1pwrl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "powlinea.bin", 0x8000, 0x008000, CRC(6d03d6ce) SHA1(4a932b87e44e37fed44ff80da542228f2d4b9876) )
-	ROM_LOAD( "powlineb.bin", 0x0000, 0x008000, CRC(9d13e39e) SHA1(2df1f402fb49aacc3fc1fecdf536ea1dcee5521f) )
+	ROM_LOAD( "powlineb.bin", 0x0000, 0x8000, CRC(9d13e39e) SHA1(2df1f402fb49aacc3fc1fecdf536ea1dcee5521f) )
+	ROM_LOAD( "powlinea.bin", 0x8000, 0x8000, CRC(6d03d6ce) SHA1(4a932b87e44e37fed44ff80da542228f2d4b9876) )
 
-	ROM_REGION( 0x40000, "altrevs", 0 ) // or something else?
+	ROM_REGION( 0x40000, "altrevs", 0 ) // check with set below, this is either an alternate (datapak) rom or we're missing one
 	ROM_LOAD( "95000013.bin", 0x0000, 0x008000, CRC(80573db9) SHA1(34e028d1d01328719f6260aafb58f40d664ab7ea) )
-	ROM_LOAD( "95000014.bin", 0x0000, 0x008000, CRC(cad7c87b) SHA1(052324bbad28b67d23a018d61a03783dd4dfd9cf) )
-	ROM_LOAD( "95000015.bin", 0x0000, 0x008000, CRC(c46911ca) SHA1(a270d0708574a549b88f13f9cde1d7dcdfc624a9) )
 
+	sc1_pwrl_sound
+ROM_END
 
-	ROM_REGION( 0x40000, "upd", 0 )
-	ROM_LOAD( "powl_snd.bin", 0x0000, 0x040000, CRC(e87af436) SHA1(fc853eca052fe13babde5f4579e202321ecb8f7e) )
+ROM_START( sc1pwrla ) // or something else?
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95000015.bin", 0x0000, 0x008000, CRC(c46911ca) SHA1(a270d0708574a549b88f13f9cde1d7dcdfc624a9) )
+	ROM_LOAD( "95000014.bin", 0x0000, 0x008000, CRC(cad7c87b) SHA1(052324bbad28b67d23a018d61a03783dd4dfd9cf) )
 
+	sc1_pwrl_sound
 ROM_END
 
 
@@ -1949,7 +2120,7 @@
 
 ROM_START( sc1quat )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "quatro.bin", 0x0000, 0x010000, CRC(c264c520) SHA1(469e0b394061ae4dcf9b0a2c66c6b85404113f5f) )
+	ROM_LOAD( "quatro.bin", 0x00000, 0x10000, CRC(c264c520) SHA1(469e0b394061ae4dcf9b0a2c66c6b85404113f5f) )
 ROM_END
 
 
@@ -1957,8 +2128,8 @@
 
 ROM_START( sc1rain )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "rainbow1.bin", 0x8000, 0x008000, CRC(cdc20fc9) SHA1(306f9877c59b4cfb0653e1f453ef188c93b7b4d3) )
-	ROM_LOAD( "rainbow2.bin", 0x0000, 0x008000, CRC(1adf16b0) SHA1(90d0935ec3a0803e1f7fcf8be24cce36f3a53962) )
+	ROM_LOAD( "rainbow1.bin", 0x8000, 0x8000, CRC(cdc20fc9) SHA1(306f9877c59b4cfb0653e1f453ef188c93b7b4d3) )
+	ROM_LOAD( "rainbow2.bin", 0x0000, 0x8000, CRC(1adf16b0) SHA1(90d0935ec3a0803e1f7fcf8be24cce36f3a53962) )
 ROM_END
 
 
@@ -1966,7 +2137,7 @@
 
 ROM_START( sc1re )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "reelcashd.bin", 0x0000, 0x010000, CRC(2519c32f) SHA1(b371dbddad617a6d749e1b784cba11758e3b37b8) )
+	ROM_LOAD( "reelcashd.bin", 0x00000, 0x10000, CRC(2519c32f) SHA1(b371dbddad617a6d749e1b784cba11758e3b37b8) )
 ROM_END
 
 
@@ -1974,7 +2145,7 @@
 
 ROM_START( sc1rese )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "reelcashse.bin", 0x0000, 0x010000, CRC(db24d5aa) SHA1(3e673b3652899d2e7e65554ffdfaca67cf3b02bf) )
+	ROM_LOAD( "reelcashse.bin", 0x00000, 0x10000, CRC(db24d5aa) SHA1(3e673b3652899d2e7e65554ffdfaca67cf3b02bf) )
 ROM_END
 
 
@@ -1982,7 +2153,7 @@
 
 ROM_START( sc1revo )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "revolution.bin", 0x8000, 0x008000, CRC(d477e4ab) SHA1(01614f9009f1736d1f1c5f2ddea48cf92fd66b0e) )
+	ROM_LOAD( "revolution.bin", 0x8000, 0x8000, CRC(d477e4ab) SHA1(01614f9009f1736d1f1c5f2ddea48cf92fd66b0e) )
 ROM_END
 
 
@@ -1991,14 +2162,14 @@
 
 ROM_START( sc1rose )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "rosecrow.802", 0x0000, 0x010000, CRC(b4cb3517) SHA1(d19e0cc8da5da7d1bcde174cf68cf7d9230cd53d) )
+	ROM_LOAD( "rosecrow.802", 0x00000, 0x10000, CRC(b4cb3517) SHA1(d19e0cc8da5da7d1bcde174cf68cf7d9230cd53d) )
 ROM_END
 
 
 
 ROM_START( sc1sant )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "santana.bin", 0x0000, 0x010000, CRC(debd19fc) SHA1(e4394c014c5db621647dd54aa7d434705431750c) )
+	ROM_LOAD( "santana.bin", 0x00000, 0x10000, CRC(debd19fc) SHA1(e4394c014c5db621647dd54aa7d434705431750c) )
 ROM_END
 
 
@@ -2006,7 +2177,7 @@
 
 ROM_START( sc1sat )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "sat.bin", 0x8000, 0x008000, CRC(5e1843db) SHA1(14cef347b5409ded4e52ae60fc4990dc79bfbae3) )
+	ROM_LOAD( "sat.bin", 0x8000, 0x8000, CRC(5e1843db) SHA1(14cef347b5409ded4e52ae60fc4990dc79bfbae3) )
 ROM_END
 
 
@@ -2014,8 +2185,8 @@
 
 ROM_START( sc1shan )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "sha626a.dat", 0x8000, 0x008000, CRC(ea770c35) SHA1(247cec799c439d11d739a7a6f2d1c0cdc7b61e18) )
-	ROM_LOAD( "sha626b.dat", 0x0000, 0x008000, CRC(1df2ca25) SHA1(c960a5e536a3fe1c868ae7f0f9983e7f77f61a2a) )
+	ROM_LOAD( "sha626b.dat", 0x0000, 0x8000, CRC(1df2ca25) SHA1(c960a5e536a3fe1c868ae7f0f9983e7f77f61a2a) )
+	ROM_LOAD( "sha626a.dat", 0x8000, 0x8000, CRC(ea770c35) SHA1(247cec799c439d11d739a7a6f2d1c0cdc7b61e18) )
 ROM_END
 
 
@@ -2024,18 +2195,22 @@
 
 ROM_START( sc1spct )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "spectre_1.bin", 0x8000, 0x008000, CRC(2dadb250) SHA1(d648678864e482bedd27008b50c3bfe50553f0c2) )
 	ROM_LOAD( "spectre_2.bin", 0x0000, 0x008000, CRC(7edc2788) SHA1(8336166151a89f9df5735e969d376375059b0024) )
-
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "spec5pa", 0x0000, 0x010000, CRC(65fa549c) SHA1(68fd5a11eb89088f87a727e9c3bb621a4235adf4) )
+	ROM_LOAD( "spectre_1.bin", 0x8000, 0x008000, CRC(2dadb250) SHA1(d648678864e482bedd27008b50c3bfe50553f0c2) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
 	ROM_LOAD( "spectre_snd_1.bin", 0x000000, 0x010000, CRC(ecdf085b) SHA1(117c63f7672112308bfe64527148ee66f8c26c12) )
 	ROM_LOAD( "spectre_snd_2.bin", 0x010000, 0x010000, CRC(55087557) SHA1(a3f2613a27defa547f8c2e46ee0cdf9ee18678be) )
 ROM_END
 
+ROM_START( sc1spcta )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "spec5pa", 0x0000, 0x010000, CRC(65fa549c) SHA1(68fd5a11eb89088f87a727e9c3bb621a4235adf4) )
 
+	ROM_REGION( 0x20000, "upd", 0 )
+	ROM_LOAD( "spectre_snd_1.bin", 0x000000, 0x010000, CRC(ecdf085b) SHA1(117c63f7672112308bfe64527148ee66f8c26c12) )
+	ROM_LOAD( "spectre_snd_2.bin", 0x010000, 0x010000, CRC(55087557) SHA1(a3f2613a27defa547f8c2e46ee0cdf9ee18678be) )
+ROM_END
 
 ROM_START( sc1spit )
 	ROM_REGION( 0x10000, "maincpu", 0 )
@@ -2053,30 +2228,40 @@
 
 ROM_START( sc1str4 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "strike4.ts", 0x8000, 0x008000, CRC(c636f698) SHA1(7373ad663966e51dd1a0737a447bd61e07cd16e2) )
+	ROM_LOAD( "strike4.ts", 0x8000, 0x8000, CRC(c636f698) SHA1(7373ad663966e51dd1a0737a447bd61e07cd16e2) )
 ROM_END
 
 ROM_START( sc1str4a )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "strike4.bin", 0x8000, 0x008000, CRC(1abcfb49) SHA1(f13891a38e260a72ffe841862ed73532c94f6c44) )
+	ROM_LOAD( "strike4.bin", 0x8000, 0x8000, CRC(1abcfb49) SHA1(f13891a38e260a72ffe841862ed73532c94f6c44) )
 ROM_END
 
 ROM_START( sc1sir )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "s.i.rich 2p 2.40 p1 9.3.90 0b49.bin", 0x8000, 0x008000, CRC(c54703f8) SHA1(9ac3af9021cf5012562b0ab057a30e11e01eef65) )
-	ROM_LOAD( "s.i.rich 2p 2.40 p2 9.3.90 1a96.bin", 0x0000, 0x008000, CRC(618841ca) SHA1(2e690ca91da0a1ff36245a6f1e2ad681a6ed4f32) )
+	ROM_LOAD( "s.i.rich 2p 2.40 p2 9.3.90 1a96.bin", 0x0000, 0x8000, CRC(618841ca) SHA1(2e690ca91da0a1ff36245a6f1e2ad681a6ed4f32) )
+	ROM_LOAD( "s.i.rich 2p 2.40 p1 9.3.90 0b49.bin", 0x8000, 0x8000, CRC(c54703f8) SHA1(9ac3af9021cf5012562b0ab057a30e11e01eef65) )
 
 	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "95717077 proto.bin", 0x0000, 0x008000, CRC(38691d92) SHA1(17f33f74d221ac37249a04846670a1a1c0ee618e) )
-	ROM_LOAD( "95717078 proto.bin", 0x0000, 0x008000, CRC(7a83b794) SHA1(8befa43c7afa37a296b309730d5cdfd32dfc363d) )
 	ROM_LOAD( "rich2_1.rom", 0x0000, 0x008000, CRC(ee75ebcb) SHA1(968b8a0bff9779681b16456f9399b0d122b1796c) )
-	ROM_LOAD( "s.i.rich 5p 2.40 p1 9.3.90.bin", 0x0000, 0x008000, CRC(6a37f38d) SHA1(1e7640446ecb6e00d57a92ab3592c389a172f257) )
-	ROM_LOAD( "s.i.rich 5p 2.40 p2 9.3.90.bin", 0x0000, 0x008000, CRC(cd3df765) SHA1(798d051afbba5a474b1b619621e4425f5ff7f8db) )
-	ROM_LOAD( "strike it rich a.bin", 0x0000, 0x008000, CRC(92ddbbca) SHA1(d888e663d0965d99dbfa68e3aed995e31411f2ba) )
-	ROM_LOAD( "strike it rich b.bin", 0x8000, 0x008000, CRC(bdafc4c9) SHA1(5ffc46088818f0e89eb840e039296945905ca4f3) )
+ROM_END
 
+ROM_START( sc1sira )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717078 proto.bin", 0x0000, 0x8000, CRC(7a83b794) SHA1(8befa43c7afa37a296b309730d5cdfd32dfc363d) )
+	ROM_LOAD( "95717077 proto.bin", 0x8000, 0x8000, CRC(38691d92) SHA1(17f33f74d221ac37249a04846670a1a1c0ee618e) )
 ROM_END
 
+ROM_START( sc1sirb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "s.i.rich 5p 2.40 p2 9.3.90.bin", 0x0000, 0x8000, CRC(cd3df765) SHA1(798d051afbba5a474b1b619621e4425f5ff7f8db) )
+	ROM_LOAD( "s.i.rich 5p 2.40 p1 9.3.90.bin", 0x8000, 0x8000, CRC(6a37f38d) SHA1(1e7640446ecb6e00d57a92ab3592c389a172f257) )
+ROM_END
+
+ROM_START( sc1sirc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "strike it rich a.bin", 0x0000, 0x008000, CRC(92ddbbca) SHA1(d888e663d0965d99dbfa68e3aed995e31411f2ba) )//right way round?
+	ROM_LOAD( "strike it rich b.bin", 0x8000, 0x008000, CRC(bdafc4c9) SHA1(5ffc46088818f0e89eb840e039296945905ca4f3) )
+ROM_END
 
 
 ROM_START( sc1sups )
@@ -2092,10 +2277,16 @@
 
 ROM_START( sc1torn )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "tor930a", 0x8000, 0x008000, CRC(c645212d) SHA1(0cb0a6f15b22e3174a1600fe15a742d5f63d9ab2) )
-	ROM_LOAD( "tor930b", 0x0000, 0x008000, CRC(f6181dd5) SHA1(44b12e6f66bf45e2b2a91424941b10ea5e75428f) )
+	ROM_LOAD( "tor930b", 0x0000, 0x8000, CRC(f6181dd5) SHA1(44b12e6f66bf45e2b2a91424941b10ea5e75428f) )
+	ROM_LOAD( "tor930a", 0x8000, 0x8000, CRC(c645212d) SHA1(0cb0a6f15b22e3174a1600fe15a742d5f63d9ab2) )
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
+	ROM_REGION( 0x40000, "upd", 0 )
+	ROM_LOAD( "torsnd1.bin", 0x0000, 0x010000, CRC(713ae672) SHA1(a6038004da7a4907eb413b5f39a00d7e131a2382) )
+	ROM_LOAD( "torsnd2.bin", 0x010000, 0x010000, CRC(187f0c17) SHA1(acc8cffc91f8a92257bfd87ee8dc809139dc5301) )
+ROM_END
+
+ROM_START( sc1torna )
+	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "tornado.792", 0x0000, 0x010000, CRC(7e8e8ad1) SHA1(0e093b81f4ab3d202f89215b26b360aac7f32218) )
 
 	ROM_REGION( 0x40000, "upd", 0 )
@@ -2104,66 +2295,84 @@
 ROM_END
 
 
-
 ROM_START( sc1tri )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "20p a.bin", 0x8000, 0x008000, CRC(d162ebd5) SHA1(cfab100ab8cc34b61108fc7b8a3ec1f1b22f90ba) )
-	ROM_LOAD( "20p b.bin", 0x0000, 0x008000, CRC(ef5bc525) SHA1(2881b9292f9dd7376997992941e07d288640703b) )
+	ROM_LOAD( "20p b.bin", 0x0000, 0x8000, CRC(ef5bc525) SHA1(2881b9292f9dd7376997992941e07d288640703b) )
+	ROM_LOAD( "20p a.bin", 0x8000, 0x8000, CRC(d162ebd5) SHA1(cfab100ab8cc34b61108fc7b8a3ec1f1b22f90ba) )
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "957172.41 std var% a.bin", 0x0000, 0x008000, CRC(b314f739) SHA1(793c01f292c5144a1f5975b276b4985c565a2833) )
-	ROM_LOAD( "957172.42 std var% b.bin", 0x0000, 0x008000, CRC(d8d70cac) SHA1(8137ab06912bc27f26bcbb800a09b095ba2175bb) )
-	ROM_LOAD( "957182.41 proto var% a.bin", 0x0000, 0x008000, CRC(1af55594) SHA1(9e65c7bbb37d75662e4243fc6ba13f249183e2a3) )
-	ROM_LOAD( "957272.41 std a.bin", 0x0000, 0x008000, CRC(635ded7e) SHA1(3e8bda8c2fa6fc8e46ba3e3a70dfb183fad3223b) )
-	ROM_LOAD( "957272.42 std b.bin", 0x0000, 0x008000, CRC(634b1927) SHA1(60f2bf02a12021da3c7995122dff85ce7831ed42) )
-	ROM_LOAD( "957282.41 proto std a.bin", 0x0000, 0x008000, CRC(e5999ec8) SHA1(0a11544da03fc2197dc2cc6780cbaeee55372069) )
+ROM_START( sc1tria )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957172.42 std var% b.bin", 0x0000, 0x8000, CRC(d8d70cac) SHA1(8137ab06912bc27f26bcbb800a09b095ba2175bb) )
+	ROM_LOAD( "957172.41 std var% a.bin", 0x8000, 0x8000, CRC(b314f739) SHA1(793c01f292c5144a1f5975b276b4985c565a2833) )
 ROM_END
 
+ROM_START( sc1triap )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957172.42 std var% b.bin", 0x0000, 0x8000, CRC(d8d70cac) SHA1(8137ab06912bc27f26bcbb800a09b095ba2175bb) )
+	ROM_LOAD( "957182.41 proto var% a.bin", 0x8000, 0x8000, CRC(1af55594) SHA1(9e65c7bbb37d75662e4243fc6ba13f249183e2a3) )
+ROM_END
 
+ROM_START( sc1trib )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "957272.42 std b.bin", 0x0000, 0x8000, CRC(634b1927) SHA1(60f2bf02a12021da3c7995122dff85ce7831ed42) )
+	ROM_LOAD( "957272.41 std a.bin", 0x8000, 0x8000, CRC(635ded7e) SHA1(3e8bda8c2fa6fc8e46ba3e3a70dfb183fad3223b) )
+ROM_END
 
-ROM_START( sc1typ )
+ROM_START( sc1tribp )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "club-typhoon_std_ac_rot_ass.bin", 0x8000, 0x008000, CRC(5d6819b2) SHA1(14cc0b3b5f42f4ff92ff96629737b9e75bb0ea10) )
-	ROM_LOAD( "club-typhoon_std_ac_rot_bss.bin", 0x0000, 0x008000, CRC(0f3e160d) SHA1(3be936fe288b23e2f35be7d5638894776d676c11) )
+	ROM_LOAD( "957272.42 std b.bin", 0x0000, 0x8000, CRC(634b1927) SHA1(60f2bf02a12021da3c7995122dff85ce7831ed42) )
+	ROM_LOAD( "957282.41 proto std a.bin", 0x8000, 0x8000, CRC(e5999ec8) SHA1(0a11544da03fc2197dc2cc6780cbaeee55372069) )
+ROM_END
 
-	ROM_REGION( 0x40000, "altrevs", 0 )
-	ROM_LOAD( "club-typhoon_dat_ac_rot_ass.bin", 0x0000, 0x008000, CRC(3a67d55e) SHA1(ce75e5c07795b3c67f234a869efb78fbf22b76c2) )
-	ROM_LOAD( "club-typhoon_dat_ac_rot_bss.bin", 0x0000, 0x008000, CRC(0f3e160d) SHA1(3be936fe288b23e2f35be7d5638894776d676c11) )
+ROM_START( sc1typ )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-typhoon_std_ac_rot_bss.bin", 0x0000, 0x8000, CRC(0f3e160d) SHA1(3be936fe288b23e2f35be7d5638894776d676c11) )
+	ROM_LOAD( "club-typhoon_std_ac_rot_ass.bin", 0x8000, 0x8000, CRC(5d6819b2) SHA1(14cc0b3b5f42f4ff92ff96629737b9e75bb0ea10) )
 
-	ROM_REGION( 0x40000, "xxxx", 0 )
+	ROM_REGION( 0x40000, "xxxx", 0 )//Don't decode as Intel Hex, what are they?
 	ROM_LOAD( "club-typhoon_snd_a_(inhex)ss.hex", 0x0000, 0x026efc, CRC(c913008a) SHA1(9b75a40670db0fbe8a0f6fc54784d3b415a975f5) )
 	ROM_LOAD( "club-typhoon_snd_b_(inhex)ss.hex", 0x0000, 0x023972, CRC(2106a5f1) SHA1(17e0f24c4e9a8ba227c5a6ec63bcba3d8796f7f7) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "club-typhoon_snd_a.bin", 0x000000, 0x010000, CRC(ffec0dde) SHA1(a8c66a6ebb4d805e04d7eb7d1fe2ecd90e7eee54) )
-	ROM_LOAD( "club-typhoon_snd_b.bin", 0x010000, 0x010000, CRC(52e36599) SHA1(4bc003a08e666f9e1abfe00e82bb43a33009b6f2) )
+	ROM_LOAD( "club-typhoon_snd_a.bin", 0x00000, 0x10000, CRC(ffec0dde) SHA1(a8c66a6ebb4d805e04d7eb7d1fe2ecd90e7eee54) )
+	ROM_LOAD( "club-typhoon_snd_b.bin", 0x10000, 0x10000, CRC(52e36599) SHA1(4bc003a08e666f9e1abfe00e82bb43a33009b6f2) )
 ROM_END
 
+ROM_START( sc1typp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "club-typhoon_dat_ac_rot_bss.bin", 0x0000, 0x8000, CRC(0f3e160d) SHA1(3be936fe288b23e2f35be7d5638894776d676c11) )
+	ROM_LOAD( "club-typhoon_dat_ac_rot_ass.bin", 0x8000, 0x8000, CRC(3a67d55e) SHA1(ce75e5c07795b3c67f234a869efb78fbf22b76c2) )
 
+	ROM_REGION( 0x20000, "upd", 0 )
+	ROM_LOAD( "club-typhoon_snd_a.bin", 0x00000, 0x10000, CRC(ffec0dde) SHA1(a8c66a6ebb4d805e04d7eb7d1fe2ecd90e7eee54) )
+	ROM_LOAD( "club-typhoon_snd_b.bin", 0x10000, 0x10000, CRC(52e36599) SHA1(4bc003a08e666f9e1abfe00e82bb43a33009b6f2) )
+
+ROM_END
 
 ROM_START( sc1ult )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ultimate.bin", 0x0000, 0x010000, CRC(66c34ef8) SHA1(2c7e2e826f6bd7a31cb3432dc74ebe382c131225) )
+	ROM_LOAD( "ultimate.bin", 0x00000, 0x010000, CRC(66c34ef8) SHA1(2c7e2e826f6bd7a31cb3432dc74ebe382c131225) )
 
 	ROM_REGION( 0x20000, "upd", 0 )
-	ROM_LOAD( "ult1.bin", 0x0000, 0x010000, CRC(7c2f52ed) SHA1(d435402459efc9311707ac691992874b56cbbeec) )
-	ROM_LOAD( "ult2.bin", 0x0000, 0x010000, CRC(23b99731) SHA1(7cc1c51d9b72480d8a1020fc3621a05ba83d7629) )
+	ROM_LOAD( "ult1.bin", 0x00000, 0x10000, CRC(7c2f52ed) SHA1(d435402459efc9311707ac691992874b56cbbeec) )
+	ROM_LOAD( "ult2.bin", 0x00000, 0x10000, CRC(23b99731) SHA1(7cc1c51d9b72480d8a1020fc3621a05ba83d7629) )
 ROM_END
 
 
 
 ROM_START( sc1vent )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ventura1.bin", 0x8000, 0x008000, CRC(7c05f39e) SHA1(84793abbffbc345bf08873ddd3185bffd8fc95df) )
-	ROM_LOAD( "ventura2.bin", 0x0000, 0x008000, CRC(3c396285) SHA1(a9cb8b54ace1d228a0d365909836bc2b02db1931) )
+	ROM_LOAD( "ventura2.bin", 0x0000, 0x8000, CRC(3c396285) SHA1(a9cb8b54ace1d228a0d365909836bc2b02db1931) )
+	ROM_LOAD( "ventura1.bin", 0x8000, 0x8000, CRC(7c05f39e) SHA1(84793abbffbc345bf08873ddd3185bffd8fc95df) )
 ROM_END
 
 
 
 ROM_START( sc1vict )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "vic1.bin", 0x8000, 0x008000, CRC(2cfbdc26) SHA1(45e492f4cba1cb90e0670fbe8f4fcd0440414316) )
-	ROM_LOAD( "vic2.bin", 0x0000, 0x008000, CRC(9eab3510) SHA1(29ba3445c75a0dcdf325312fbc64e8911ba958c3) )
+	ROM_LOAD( "vic2.bin", 0x0000, 0x8000, CRC(9eab3510) SHA1(29ba3445c75a0dcdf325312fbc64e8911ba958c3) )
+	ROM_LOAD( "vic1.bin", 0x8000, 0x8000, CRC(2cfbdc26) SHA1(45e492f4cba1cb90e0670fbe8f4fcd0440414316) )
 
 	ROM_REGION( 0x10000, "xxx", 0 )
 	ROM_LOAD( "pal.bin", 0x0000, 0x000010, CRC(d33fb7d2) SHA1(6de1a205808bccb9bc86f630c0eda261041a3b00) )
@@ -2174,77 +2383,157 @@
 
 ROM_START( sc1voy )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "voyager_042_arcade.bin", 0x0000, 0x010000, CRC(7db87ef9) SHA1(e2160457a862d6eba3d8348866429043df0ed2bb) )
+	ROM_LOAD( "voyager_042_arcade.bin", 0x00000, 0x10000, CRC(7db87ef9) SHA1(e2160457a862d6eba3d8348866429043df0ed2bb) )
 ROM_END
 
 ROM_START( sc1voya )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "voyager_052_single_site_euro.bin", 0x0000, 0x010000, CRC(a9042f9e) SHA1(0469ef2d2a2f9c7c4147ee8d528ec369bf943103) )
+	ROM_LOAD( "voyager_052_single_site_euro.bin", 0x00000, 0x10000, CRC(a9042f9e) SHA1(0469ef2d2a2f9c7c4147ee8d528ec369bf943103) )
 ROM_END
 
 
 
 ROM_START( sc1winfl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "winfalls_a.bin", 0x0000, 0x008000, CRC(4617ec80) SHA1(8ac5a47d2ae94c2869cc6645f01cfe9d880b1e5c) )
-	ROM_LOAD( "winfalls_b.bin", 0x8000, 0x008000, CRC(7498ede7) SHA1(5fb66c39865ea963fb7eeb9d4813cfa5e68f709e) )
+	ROM_LOAD( "winfalls_a.bin", 0x0000, 0x8000, CRC(4617ec80) SHA1(8ac5a47d2ae94c2869cc6645f01cfe9d880b1e5c) )
+	ROM_LOAD( "winfalls_b.bin", 0x8000, 0x8000, CRC(7498ede7) SHA1(5fb66c39865ea963fb7eeb9d4813cfa5e68f709e) )
 ROM_END
 
 
 
-
 ROM_START( sc1winst )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95717110 proto var% b.bin", 0x0000, 0x008000, CRC(1c2ebd26) SHA1(462baa4df7c01d101798df1d90bb5719cdc9647e) )
-	ROM_LOAD( "95718109 proto var% a.bin", 0x8000, 0x008000, CRC(05d5ad4a) SHA1(5e165499601978e88159726f83310576216853c4) )
+	ROM_LOAD( "95717110 var% b.bin", 0x0000, 0x8000, CRC(1c2ebd26) SHA1(462baa4df7c01d101798df1d90bb5719cdc9647e) )
+	ROM_LOAD( "95717109 var% a.bin", 0x8000, 0x8000, CRC(f8b03a06) SHA1(b919366b432d23fd9f0c986e112650048621d7b2) )
+
+	sc1_winst_sound
+ROM_END
+
+
+ROM_START( sc1winstp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717110 var% b.bin", 0x0000, 0x8000, CRC(1c2ebd26) SHA1(462baa4df7c01d101798df1d90bb5719cdc9647e) )
+	ROM_LOAD( "95718109 proto var% a.bin", 0x8000, 0x8000, CRC(05d5ad4a) SHA1(5e165499601978e88159726f83310576216853c4) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winsta )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95719110b ws 78%.bin", 0x0000, 0x8000, CRC(5871aad0) SHA1(6677c94b74a2e2dcece3fdcd730fbc8034833a7d) )
+	ROM_LOAD( "95719109a ws 78%.bin", 0x0000, 0x8000, CRC(cea7ff32) SHA1(ce20742bcad1eea450affab81822cfdaaf927984) )
+
+	sc1_winst_sound
+ROM_END
+
+//the following may well be different hardware
+ROM_START( sc1winstb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_ac_var_8-10pnd_ass.bin", 0x00000, 0x10000, CRC(f2d16bd5) SHA1(bd6a9da9da24459b14917386c64ecbc46c8adfda) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstbp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_dat_ac_var_8-10pnd_ass.bin", 0x00000, 0x10000, CRC(351560f4) SHA1(b33c6bdeadeabbe5a4231b8bd5b134f9ea402133) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_ar_var_8pnd_ass.bin", 0x00000, 0x10000, CRC(d7a10aeb) SHA1(7346c83df7fd3de57a1b6f0ce498daabacb11491) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 ) // are some of these different hw?
-	ROM_LOAD( "95717109 var% a.bin", 0x0000, 0x008000, CRC(f8b03a06) SHA1(b919366b432d23fd9f0c986e112650048621d7b2) )
-	ROM_LOAD( "95717110 var% b.bin", 0x0000, 0x008000, CRC(1c2ebd26) SHA1(462baa4df7c01d101798df1d90bb5719cdc9647e) )
-	ROM_LOAD( "95719109a ws 78%.bin", 0x0000, 0x008000, CRC(cea7ff32) SHA1(ce20742bcad1eea450affab81822cfdaaf927984) )
-	ROM_LOAD( "95719110b ws 78%.bin", 0x0000, 0x008000, CRC(5871aad0) SHA1(6677c94b74a2e2dcece3fdcd730fbc8034833a7d) )
-	ROM_LOAD( "winning-streak_dat_ac_var_8-10pnd_ass.bin", 0x0000, 0x010000, CRC(351560f4) SHA1(b33c6bdeadeabbe5a4231b8bd5b134f9ea402133) )
-	ROM_LOAD( "winning-streak_dat_ar_var_8pnd_ass.bin", 0x0000, 0x010000, CRC(a83633ef) SHA1(66caadd3127a424249fe78918ff99be833b81fad) )
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstcp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_dat_ar_var_8pnd_ass.bin", 0x00000, 0x10000, CRC(a83633ef) SHA1(66caadd3127a424249fe78918ff99be833b81fad) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstd )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_ss_var_ass.bin", 0x00000, 0x10000, CRC(c88f9a6e) SHA1(19a2b708f90a53a8dcfe69d2f6c683362867daba) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstdp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "winning-streak_dat_ss_var_ass.bin", 0x0000, 0x010000, CRC(311550dd) SHA1(17dc789cba542e7c3c137a7e6a2a2d8869c84a7a) )
-	ROM_LOAD( "winning-streak_dat_wi_ac_10pnd-20p_ass.bin", 0x0000, 0x010000, CRC(ae418733) SHA1(f63c63232056929760742fcf7f8beda387f5c597) )
-	ROM_LOAD( "winning-streak_dat_wi_ac_10pnd-20p_tri3_ass.bin", 0x0000, 0x010000, CRC(39ac4021) SHA1(bd5f4d8800a794fdca8abee15acc3ea8d30c538a) )
-	ROM_LOAD( "winning-streak_std_ac_tri3_ass.bin", 0x0000, 0x010000, CRC(b3e2b2d6) SHA1(0008e9d329327b4aecae5d861303c486942ef694) )
-	ROM_LOAD( "winning-streak_std_ac_var_8-10pnd_ass.bin", 0x0000, 0x010000, CRC(f2d16bd5) SHA1(bd6a9da9da24459b14917386c64ecbc46c8adfda) )
-	ROM_LOAD( "winning-streak_std_ar_var_8pnd_ass.bin", 0x0000, 0x010000, CRC(d7a10aeb) SHA1(7346c83df7fd3de57a1b6f0ce498daabacb11491) )
-	ROM_LOAD( "winning-streak_std_ss_var_ass.bin", 0x0000, 0x010000, CRC(c88f9a6e) SHA1(19a2b708f90a53a8dcfe69d2f6c683362867daba) )
-	ROM_LOAD( "winning-streak_std_wi_ac_10pnd-20p_ass.bin", 0x0000, 0x010000, CRC(ecbb7707) SHA1(ea064149c515e39b17e851bcd39092ea3ae999a0) )
-	ROM_LOAD( "winning-streak_std_wi_ac_10pnd-20p_tri3_ass.bin", 0x0000, 0x010000, CRC(eb9ee9ae) SHA1(3150aec95039aa65a9126a0326e4dd10829347b2) )
 
-	ROM_REGION( 0x80000, "upd", 0 )
-	ROM_LOAD( "winningstreaksnd.bin", 0x0000, 0x080000, CRC(ba30cb97) SHA1(e7f5ca36ca993ad14b3a348868e73d7ba02be7c5) )
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winste )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_wi_ac_10pnd-20p_ass.bin", 0x00000, 0x10000, CRC(ecbb7707) SHA1(ea064149c515e39b17e851bcd39092ea3ae999a0) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstep )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_dat_wi_ac_10pnd-20p_ass.bin", 0x00000, 0x10000, CRC(ae418733) SHA1(f63c63232056929760742fcf7f8beda387f5c597) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstf )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_wi_ac_10pnd-20p_tri3_ass.bin", 0x00000, 0x10000, CRC(eb9ee9ae) SHA1(3150aec95039aa65a9126a0326e4dd10829347b2) )
+
+	sc1_winst_sound
+ROM_END
+
+ROM_START( sc1winstfp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_dat_wi_ac_10pnd-20p_tri3_ass.bin", 0x00000, 0x10000, CRC(39ac4021) SHA1(bd5f4d8800a794fdca8abee15acc3ea8d30c538a) )
+
+	sc1_winst_sound
 ROM_END
 
+ROM_START( sc1winstg )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "winning-streak_std_ac_tri3_ass.bin", 0x00000, 0x10000, CRC(b3e2b2d6) SHA1(0008e9d329327b4aecae5d861303c486942ef694) )
+
+	sc1_winst_sound
+ROM_END
 
 
 ROM_START( sc1zep )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "zepp.bin", 0x8000, 0x008000, CRC(fbc38903) SHA1(9eefef9bbde263e35a98e51b7aeb8d2348d36c06) )
-	ROM_LOAD( "zepp1.bin", 0x0000, 0x008000, CRC(bfbbbc35) SHA1(5c28b6359d79c96d53319408fbc2d7cb2629185d) )
+	ROM_LOAD( "zepp1.bin", 0x0000, 0x8000, CRC(bfbbbc35) SHA1(5c28b6359d79c96d53319408fbc2d7cb2629185d) )
+	ROM_LOAD( "zepp.bin", 0x8000, 0x8000, CRC(fbc38903) SHA1(9eefef9bbde263e35a98e51b7aeb8d2348d36c06) )
 ROM_END
 
 ROM_START( sc1wthn )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "wildthingprogamm1.bin", 0x0000, 0x010000, CRC(80157a9c) SHA1(ec8e217e17ac7f4c5bc05d9848bf5f37b2d82fac) )
+	ROM_LOAD( "wildthingprogamm1.bin", 0x00000, 0x010000, CRC(80157a9c) SHA1(ec8e217e17ac7f4c5bc05d9848bf5f37b2d82fac) )
 
 	ROM_REGION( 0x80000, "upd", 0 )
-	ROM_LOAD( "wildthingsound1.bin", 0x00000, 0x010000, CRC(85389209) SHA1(029dda285b035525b730b4c72ff182554f5dbe47) )
-	ROM_LOAD( "wildthingsound2.bin", 0x010000, 0x010000, CRC(664ab695) SHA1(d4148ebffbe41eb1d265548991ad3cb984205497) )
+	ROM_LOAD( "wildthingsound1.bin", 0x00000, 0x10000, CRC(85389209) SHA1(029dda285b035525b730b4c72ff182554f5dbe47) )
+	ROM_LOAD( "wildthingsound2.bin", 0x10000, 0x10000, CRC(664ab695) SHA1(d4148ebffbe41eb1d265548991ad3cb984205497) )
 ROM_END
 
 
 ROM_START( sc1days )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "all2-5n.p2", 0x0000, 0x008000, CRC(fa75d835) SHA1(78e6b48bea8f1297530f08dff6bada4d228e090d) )
-	ROM_LOAD( "all2-5n.p1", 0x8000, 0x008000, CRC(7d58a415) SHA1(8bd0d23ac825ba0294f2fd26e9acb87eb1f3d10c) )
+	ROM_LOAD( "all2-5n.p2", 0x0000, 0x8000, CRC(fa75d835) SHA1(78e6b48bea8f1297530f08dff6bada4d228e090d) )
+	ROM_LOAD( "all2-5n.p1", 0x8000, 0x8000, CRC(7d58a415) SHA1(8bd0d23ac825ba0294f2fd26e9acb87eb1f3d10c) )
 
-	ROM_REGION( 0x20000, "altrevs", 0 )
-	ROM_LOAD( "allinv1-6b.bin", 0x0000, 0x008000, CRC(59589a00) SHA1(c73b45f383f908d1257f6d031f359f73e5b2f966) )
-	ROM_LOAD( "allinv1-6a.bin", 0x8000, 0x008000, CRC(36a83181) SHA1(a2cb6493efb00e9bcf76388f65098af9346f855e) )
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 ) // not upd?
+	/* missing? */
+ROM_END
+
+ROM_START( sc1daysa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "allinv1-6b.bin", 0x0000, 0x8000, CRC(59589a00) SHA1(c73b45f383f908d1257f6d031f359f73e5b2f966) )
+	ROM_LOAD( "allinv1-6a.bin", 0x8000, 0x8000, CRC(36a83181) SHA1(a2cb6493efb00e9bcf76388f65098af9346f855e) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 ) // not upd?
 	/* missing? */
@@ -2253,41 +2542,72 @@
 
 ROM_START( sc1cscl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cldl1-8n.p1", 0x8000, 0x008000, CRC(4cb5239d) SHA1(a0f22440a5453ea28093f32856ab5417a6c82037) )
-	ROM_LOAD( "cldl1-8n.p2", 0x0000, 0x008000, CRC(8feee244) SHA1(50c7eab298078def5d82bc3bebbe3e08b612bc47) )
-
-	ROM_REGION( 0x20000, "altrevs", 0 )
-	ROM_LOAD( "cash classic 2p sa1-083.bin", 0x0000, 0x010000, CRC(36a45c0d) SHA1(51eb91e42297894ae575502903833e219ac5add9) )
-	ROM_LOAD( "cash classic sa1-082 5p.bin", 0x0000, 0x010000, CRC(42d68675) SHA1(ed191e03bc7b42ae1884657b4559588eeedbdf31) )
-	ROM_LOAD( "clas2-0n.p2", 0x0000, 0x008000, CRC(45d40f1e) SHA1(03388a8ea809b088850865cb288af3181d3dd962) )
-	ROM_LOAD( "clas2-0n.p1", 0x8000, 0x008000, CRC(ebd514b1) SHA1(5267b49de98f8a93ac206f68d56ee12e1d228a7d) )
+	ROM_LOAD( "cldl1-8n.p2", 0x0000, 0x8000, CRC(8feee244) SHA1(50c7eab298078def5d82bc3bebbe3e08b612bc47) )
+	ROM_LOAD( "cldl1-8n.p1", 0x8000, 0x8000, CRC(4cb5239d) SHA1(a0f22440a5453ea28093f32856ab5417a6c82037) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 ) // not upd?
 	/* missing? */
 ROM_END
 
+ROM_START( sc1cscla )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "clas2-0n.p2", 0x0000, 0x8000, CRC(45d40f1e) SHA1(03388a8ea809b088850865cb288af3181d3dd962) )
+	ROM_LOAD( "clas2-0n.p1", 0x8000, 0x8000, CRC(ebd514b1) SHA1(5267b49de98f8a93ac206f68d56ee12e1d228a7d) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
+//The names of these imply they may be Maygay M1 or MMM sets, need further investigation (they have standard MAYGAY 1990 strings)
+ROM_START( sc1csclb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cash classic sa1-082 5p.bin", 0x0000, 0x010000, CRC(42d68675) SHA1(ed191e03bc7b42ae1884657b4559588eeedbdf31) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
+
+ROM_START( sc1csclc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cash classic 2p sa1-083.bin", 0x0000, 0x010000, CRC(36a45c0d) SHA1(51eb91e42297894ae575502903833e219ac5add9) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
 ROM_START( sc1driv )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ddslb1-3.p2", 0x0000, 0x008000, CRC(32896702) SHA1(1ef36daca6bf3f45dfff5edc401bdbd313ad9121) )
-	ROM_LOAD( "ddslb1-3.p1", 0x8000, 0x008000, CRC(81fc84a7) SHA1(f0d5a181d4ca027df2c5ca11573eb7687b3abf29) )
+	ROM_LOAD( "ddslb1-3.p2", 0x0000, 0x8000, CRC(32896702) SHA1(1ef36daca6bf3f45dfff5edc401bdbd313ad9121) )
+	ROM_LOAD( "ddslb1-3.p1", 0x8000, 0x8000, CRC(81fc84a7) SHA1(f0d5a181d4ca027df2c5ca11573eb7687b3abf29) )
 
-	ROM_REGION( 0x20000, "altrevs", 0 )
-	ROM_LOAD( "ddsnl1-3.p1", 0x0000, 0x008000, CRC(96f8bc52) SHA1(de0d180d4640eef451984f466be8732d0a08cee8) )
-	ROM_LOAD( "ddsnl1-3.p2", 0x0000, 0x008000, CRC(a5b663c8) SHA1(5b6675874ff4e3a5c74dbd66c4a47c34d36f1222) )
-	ROM_LOAD( "dslb1-5.p1", 0x0000, 0x008000, CRC(6adaf17b) SHA1(8930daac71fbe3f7eb91358d7101f2b8d05d224e) )
-	ROM_LOAD( "dslb1-5.p2", 0x0000, 0x008000, CRC(193e6aaa) SHA1(f083747a9cad72690b01181cc46ae7bdc3de6ea6) )
-	ROM_LOAD( "dsnl1-6.p1", 0x0000, 0x008000, CRC(174c4432) SHA1(82519ede8220d3d717ee0ebe57374357afe38949) )
-	ROM_LOAD( "dsnl1-6.p2", 0x0000, 0x008000, CRC(0eb10c01) SHA1(16456ec1e32bfbd873bdebd6a760041bc9cd8648) )
+	sc1_driv_sound
+ROM_END
 
-	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 ) // not upd?
-	ROM_LOAD( "ds_snd1.bin", 0x000000, 0x020000, CRC(a9d7e8ec) SHA1(5b1d459d378e23d3108a1190b5988eebedf95667) )
-	ROM_LOAD( "ds_snd2.bin", 0x020000, 0x020000, CRC(3b67c1b3) SHA1(8b9dbff45955f72a73fb739b5e74aa2f9c23dd08) )
-	ROM_LOAD( "ds_snd3.bin", 0x040000, 0x020000, CRC(00c252ec) SHA1(5de2e70f142a71f22eeb28a271ca9d7809322faa) )
+ROM_START( sc1driva )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "ddsnl1-3.p2", 0x0000, 0x8000, CRC(a5b663c8) SHA1(5b6675874ff4e3a5c74dbd66c4a47c34d36f1222) )
+	ROM_LOAD( "ddsnl1-3.p1", 0x8000, 0x8000, CRC(96f8bc52) SHA1(de0d180d4640eef451984f466be8732d0a08cee8) )
+
+	sc1_driv_sound
+ROM_END
+
+ROM_START( sc1drivb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "dslb1-5.p2", 0x0000, 0x8000, CRC(193e6aaa) SHA1(f083747a9cad72690b01181cc46ae7bdc3de6ea6) )
+	ROM_LOAD( "dslb1-5.p1", 0x8000, 0x8000, CRC(6adaf17b) SHA1(8930daac71fbe3f7eb91358d7101f2b8d05d224e) )
+
+	sc1_driv_sound
+ROM_END
+
+ROM_START( sc1drivc )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "dsnl1-6.p2", 0x0000, 0x8000, CRC(0eb10c01) SHA1(16456ec1e32bfbd873bdebd6a760041bc9cd8648) )
+	ROM_LOAD( "dsnl1-6.p1", 0x8000, 0x8000, CRC(174c4432) SHA1(82519ede8220d3d717ee0ebe57374357afe38949) )
+
+	sc1_driv_sound
 ROM_END
 
 ROM_START( sc1vsd )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "supd1-4n.p1", 0x8000, 0x008000, CRC(ad581f7d) SHA1(99b9bf1016cd52467f5c9f6e427305e81033e82f) )
+	ROM_LOAD( "supd1-4n.p1", 0x8000, 0x8000, CRC(ad581f7d) SHA1(99b9bf1016cd52467f5c9f6e427305e81033e82f) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 ) // not upd?
 	/* missing? */
@@ -2296,22 +2616,22 @@
 
 ROM_START( sc1moonl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "moon lite 5p 86var v5.1.bin", 0x8000, 0x008000, CRC(31db928a) SHA1(0e07c11bf85a13df62bb704a03a42712d6e7ff62) )
+	ROM_LOAD( "moon lite 5p 86var v5.1.bin", 0x8000, 0x8000, CRC(31db928a) SHA1(0e07c11bf85a13df62bb704a03a42712d6e7ff62) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1ltdv )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "little devil v4 arcade.bin", 0x8000, 0x008000, CRC(ff32cdcf) SHA1(84bb86e30ace57aa8f591a3778801d44fb3f8fe1) )
+	ROM_LOAD( "little devil v4 arcade.bin", 0x8000, 0x8000, CRC(ff32cdcf) SHA1(84bb86e30ace57aa8f591a3778801d44fb3f8fe1) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1t1k )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "top1000b.bin", 0x8000, 0x008000, CRC(0124b7c0) SHA1(620196e7580f44423ede6644f76e37091fdf30b6) )
-	ROM_LOAD( "top1000a.bin", 0x0000, 0x008000, CRC(c986ee8b) SHA1(e5a600942e725d0ad6be10fbac7fb05eb0d2b07f) )
+	ROM_LOAD( "top1000a.bin", 0x0000, 0x8000, CRC(c986ee8b) SHA1(e5a600942e725d0ad6be10fbac7fb05eb0d2b07f) )
+	ROM_LOAD( "top1000b.bin", 0x8000, 0x8000, CRC(0124b7c0) SHA1(620196e7580f44423ede6644f76e37091fdf30b6) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	/* missing? */
@@ -2319,10 +2639,10 @@
 
 ROM_START( sc1dip )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "dip0111.bin", 0x0000, 0x010000, CRC(19632509) SHA1(69c9947da11892b99e9936675d0b1bdabdc16ae8) )
+	ROM_LOAD( "dip0111.bin", 0x00000, 0x10000, CRC(19632509) SHA1(69c9947da11892b99e9936675d0b1bdabdc16ae8) )
 
 	ROM_REGION( 0x200000, "ram", ROMREGION_ERASE00 ) // is this just some default settings?
-	ROM_LOAD( "ram.bin", 0x0000, 0x002000, CRC(3962d8cf) SHA1(b893a92d467e8f5ffc2cffa8a7121d92fe2492eb) )
+	ROM_LOAD( "ram.bin", 0x0000, 0x2000, CRC(3962d8cf) SHA1(b893a92d467e8f5ffc2cffa8a7121d92fe2492eb) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	/* missing? */
@@ -2330,7 +2650,7 @@
 
 ROM_START( sc1lamb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "lambada.bin", 0x0000, 0x010000, CRC(4321495c) SHA1(d3ef15d2a1b2c7aec33ac226c89a7a0c0a18884a) )
+	ROM_LOAD( "lambada.bin", 0x00000, 0x10000, CRC(4321495c) SHA1(d3ef15d2a1b2c7aec33ac226c89a7a0c0a18884a) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	/* missing? */
@@ -2338,79 +2658,113 @@
 
 ROM_START( sc1reply )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "repl0110.bin", 0x0000, 0x010000, CRC(b2bfa2fb) SHA1(9c704321428c05f97593ea7541ba1a08ff448571) )
+	ROM_LOAD( "repl0110.bin", 0x00000, 0x10000, CRC(b2bfa2fb) SHA1(9c704321428c05f97593ea7541ba1a08ff448571) )
 
 	ROM_REGION( 0x80000, "upd", 0 )
-	ROM_LOAD( "repl0110snd.bin", 0x0000, 0x010000, CRC(86547dc7) SHA1(4bf64f22e84c0ee82d961b0ba64932b8bf6a521f) )
+	ROM_LOAD( "repl0110snd.bin", 0x00000, 0x10000, CRC(86547dc7) SHA1(4bf64f22e84c0ee82d961b0ba64932b8bf6a521f) )
 ROM_END
 
 
 ROM_START( sc1smoke )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD( "sb6-3_0b.bin", 0x0000, 0x008000, CRC(31647e2f) SHA1(35dd1bef0dd72fd45c063f181cd190f8d21df207) )
-	ROM_LOAD( "sb6-3_0a.bin", 0x8000, 0x008000, CRC(45ca0067) SHA1(be1947d055320c101ea75c669733b19d2f61a0f9) )
+	ROM_LOAD( "sb6-3_0b.bin", 0x0000, 0x8000, CRC(31647e2f) SHA1(35dd1bef0dd72fd45c063f181cd190f8d21df207) )
+	ROM_LOAD( "sb6-3_0a.bin", 0x8000, 0x8000, CRC(45ca0067) SHA1(be1947d055320c101ea75c669733b19d2f61a0f9) )
 
 	ROM_REGION( 0x80000, "altrevs", 0 )
-	ROM_LOAD( "sb8-5_0a.bin", 0x0000, 0x008000, CRC(eafe5fac) SHA1(4798a37ada523d078f2e10976c5f90cccab1c406) )
-	ROM_LOAD( "sb8-5_0b.bin", 0x0000, 0x008000, CRC(0aac6b91) SHA1(85b4dfe15d456b7d808295c890264163bc6115f1) )
 	ROM_LOAD( "svb58pa", 0x0000, 0x008000, CRC(4496ce3d) SHA1(400dee4249fd930473cb003d85b25bb991041bc6) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
+ROM_START( sc1smokea )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "sb8-5_0b.bin", 0x0000, 0x8000, CRC(0aac6b91) SHA1(85b4dfe15d456b7d808295c890264163bc6115f1) )
+	ROM_LOAD( "sb8-5_0a.bin", 0x8000, 0x8000, CRC(eafe5fac) SHA1(4798a37ada523d078f2e10976c5f90cccab1c406) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
 ROM_START( sc1ccroc )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD( "cc6-4_0b.bin", 0x0000, 0x008000, CRC(4093cbe6) SHA1(6ea678d0e288bb075d58ef72089ae387d6285477) )
-	ROM_LOAD( "cc6-4_0a.bin", 0x8000, 0x008000, CRC(c3d963e8) SHA1(35688841e102c264124c23de526417db618ea898) )
+	ROM_LOAD( "cc6-4_0b.bin", 0x0000, 0x8000, CRC(4093cbe6) SHA1(6ea678d0e288bb075d58ef72089ae387d6285477) )
+	ROM_LOAD( "cc6-4_0a.bin", 0x8000, 0x8000, CRC(c3d963e8) SHA1(35688841e102c264124c23de526417db618ea898) )
 
-	ROM_REGION( 0x80000, "altrevs", 0 )
-	ROM_LOAD( "cc8-7_0a.bin", 0x0000, 0x008000, CRC(4a6cd887) SHA1(27f394a63bdb68d35d6eecb6b0f6b3f3f61d36b5) )
-	ROM_LOAD( "cc8-7_0b.bin", 0x0000, 0x008000, CRC(a638c58a) SHA1(0a5d53a9c0f772263c7a726f90943a1ccfe5db20) )
-	ROM_LOAD( "cct-8_0a.bin", 0x0000, 0x008000, CRC(a90a5f23) SHA1(befb389cc6ff045462f02c2aa9025d92c47da0fa) )
-	ROM_LOAD( "cct-8_0b.bin", 0x0000, 0x008000, CRC(1e0e93f3) SHA1(e5ceef529bd406d2b395b6e24cff370422b0e1f2) )
-	ROM_LOAD( "crocs6a.bin", 0x0000, 0x008000, CRC(087330cb) SHA1(f143a8a44024f0f851a8b677f42b9d4011ab92d4) )
-	ROM_LOAD( "crocs6b.bin", 0x0000, 0x008000, CRC(42ad6fb0) SHA1(d60961d9993a8458668177013d7561d0b7423cda) )
+	ROM_REGION( 0x80000, "altrevs", 0 ) //this can't be the right hardware
 	ROM_LOAD( "cs1_1.rom", 0x0000, 0x040000, CRC(f4c6f9f1) SHA1(4277ff51dc91c35d4c6e9ab1c16e087ef7e8d140) )
 	ROM_LOAD( "cs1_2.rom", 0x0000, 0x040000, CRC(ba4dad49) SHA1(795342d5fd3deaa058a20d491206c028c529fd55) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
+ROM_START( sc1ccroca )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "cc8-7_0b.bin", 0x0000, 0x8000, CRC(a638c58a) SHA1(0a5d53a9c0f772263c7a726f90943a1ccfe5db20) )
+	ROM_LOAD( "cc8-7_0a.bin", 0x8000, 0x8000, CRC(4a6cd887) SHA1(27f394a63bdb68d35d6eecb6b0f6b3f3f61d36b5) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
+ROM_START( sc1ccrocb )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "cct-8_0b.bin", 0x0000, 0x8000, CRC(1e0e93f3) SHA1(e5ceef529bd406d2b395b6e24cff370422b0e1f2) )
+	ROM_LOAD( "cct-8_0a.bin", 0x8000, 0x8000, CRC(a90a5f23) SHA1(befb389cc6ff045462f02c2aa9025d92c47da0fa) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
+ROM_START( sc1ccrocc )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "crocs6b.bin", 0x0000, 0x8000, CRC(42ad6fb0) SHA1(d60961d9993a8458668177013d7561d0b7423cda) )
+	ROM_LOAD( "crocs6a.bin", 0x8000, 0x8000, CRC(087330cb) SHA1(f143a8a44024f0f851a8b677f42b9d4011ab92d4) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
 ROM_START( sc1crocr )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD( "croc58pb", 0x0000, 0x010000, CRC(95d2b0ac) SHA1(369a2f5efc981aa03780b80e0b14d5171c25e72b) ) // 2nd half empty
-	ROM_LOAD( "croc58pa", 0x8000, 0x010000, CRC(39501e80) SHA1(f03bc602df839374adf7722af295cee562353782) ) // 2nd half empty
+	ROM_LOAD( "croc58pb", 0x0000, 0x10000, CRC(95d2b0ac) SHA1(369a2f5efc981aa03780b80e0b14d5171c25e72b) ) // 2nd half empty
+	ROM_LOAD( "croc58pa", 0x8000, 0x10000, CRC(39501e80) SHA1(f03bc602df839374adf7722af295cee562353782) ) // 2nd half empty
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1btclk )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD( "bc6-4_0b.bin", 0x0000, 0x008000, CRC(106265c8) SHA1(6465f7e868c5b04776fee69295a52197abb45ad0) )
-	ROM_LOAD( "bc6-4_0a.bin", 0x8000, 0x008000, CRC(750645e7) SHA1(65eee2a00a1914bb8dc989b131eaa39d2881105d) )
+	ROM_LOAD( "bc6-4_0b.bin", 0x0000, 0x8000, CRC(106265c8) SHA1(6465f7e868c5b04776fee69295a52197abb45ad0) )
+	ROM_LOAD( "bc6-4_0a.bin", 0x8000, 0x8000, CRC(750645e7) SHA1(65eee2a00a1914bb8dc989b131eaa39d2881105d) )
 
-	ROM_REGION( 0x80000, "altrevs", 0 )
-	ROM_LOAD( "bc8-5_0a.bin", 0x0000, 0x008000, CRC(f8fafc49) SHA1(7d8109fdabe37c7e958696512d3c2c35f9890bee) )
-	ROM_LOAD( "bc8-5_0b.bin", 0x0000, 0x008000, CRC(4be7220f) SHA1(5eb2b3fd05ff06b645f16bf95f6766b8bea82525) )
-	ROM_LOAD( "btc58pa", 0x0000, 0x010000, CRC(d21e5ed9) SHA1(99c189fde84f5abbdcd85d1f816c61f8fe72554e) )
-	ROM_LOAD( "btc58pb", 0x0000, 0x010000, CRC(4cfde48a) SHA1(8567667f4af96fd00a807380a65fe809cd051c76) )
+//  ROM_REGION( 0x80000, "altrevs", 0 )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
+
+ROM_START( sc1btclka )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "bc8-5_0b.bin", 0x0000, 0x8000, CRC(4be7220f) SHA1(5eb2b3fd05ff06b645f16bf95f6766b8bea82525) )
+	ROM_LOAD( "bc8-5_0a.bin", 0x8000, 0x8000, CRC(f8fafc49) SHA1(7d8109fdabe37c7e958696512d3c2c35f9890bee) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
+ROM_START( sc1btclkb )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "btc58pb", 0x0000, 0x10000, CRC(4cfde48a) SHA1(8567667f4af96fd00a807380a65fe809cd051c76) ) // 2nd half empty
+	ROM_LOAD( "btc58pa", 0x8000, 0x10000, CRC(d21e5ed9) SHA1(99c189fde84f5abbdcd85d1f816c61f8fe72554e) ) // 2nd half empty
 
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
 
 
 ROM_START( sc1btbc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "beatb34", 0x8000, 0x008000, CRC(0791f889) SHA1(f090b9aacdbb33cc0934f53621e43520b970d789) )
+	ROM_LOAD( "beatb34", 0x8000, 0x8000, CRC(0791f889) SHA1(f090b9aacdbb33cc0934f53621e43520b970d789) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1boncl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cb_v91.bin", 0x8000, 0x008000, CRC(a1b902f4) SHA1(47bff5f0921800052ac99fd7b945ea05fc5951d6) )
+	ROM_LOAD( "cb_v91.bin", 0x8000, 0x8000, CRC(a1b902f4) SHA1(47bff5f0921800052ac99fd7b945ea05fc5951d6) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
@@ -2418,57 +2772,58 @@
 
 ROM_START( sc1clins )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cashlines5p2.40p1 9.3.90.bin", 0x8000, 0x008000, CRC(cb69c335) SHA1(8fe302274d01e98f8636fbc44eb4736180345b16) )
-	ROM_LOAD( "cashlines5p2.40p2 9.3.90.bin", 0x0000, 0x008000, CRC(068959a2) SHA1(6c212ceb756024662ed880b66b4c6aac21b0c726) )
+	ROM_LOAD( "cashlines5p2.40p2 9.3.90.bin", 0x0000, 0x8000, CRC(068959a2) SHA1(6c212ceb756024662ed880b66b4c6aac21b0c726) )
+	ROM_LOAD( "cashlines5p2.40p1 9.3.90.bin", 0x8000, 0x8000, CRC(cb69c335) SHA1(8fe302274d01e98f8636fbc44eb4736180345b16) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1clinsa )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cashlines2p2.40p1 9.3.90.bin", 0x8000, 0x008000, CRC(4dcdfcd1) SHA1(38b67a2450ededd9cf27b9f5d5fffe45f4e4b80d) )
-	ROM_LOAD( "cashlines2p2.40p2 9.3.90.bin", 0x0000, 0x008000, CRC(0a4d6692) SHA1(9437a0ed1fb9eb706dede7a6b1670e2bd873d7fe) )
+	ROM_LOAD( "cashlines2p2.40p2 9.3.90.bin", 0x0000, 0x8000, CRC(0a4d6692) SHA1(9437a0ed1fb9eb706dede7a6b1670e2bd873d7fe) )
+	ROM_LOAD( "cashlines2p2.40p1 9.3.90.bin", 0x8000, 0x8000, CRC(4dcdfcd1) SHA1(38b67a2450ededd9cf27b9f5d5fffe45f4e4b80d) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clinsb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-//  ROM_LOAD( "95718066 proto.bin", 0x0000, 0x008000, CRC(0977e287) SHA1(e937a3787d4cd056c5f9944bca1532b84ed335f6) )
-	ROM_LOAD( "clines proto a.bin", 0x8000, 0x008000, CRC(0977e287) SHA1(e937a3787d4cd056c5f9944bca1532b84ed335f6) )
-	ROM_LOAD( "clines proto b.bin", 0x0000, 0x008000, CRC(fca396e1) SHA1(3304a58a30fd0c79e8d1decd4bd8792d3acbad3e) )
+	ROM_LOAD( "clines proto b.bin", 0x0000, 0x8000, CRC(fca396e1) SHA1(3304a58a30fd0c79e8d1decd4bd8792d3acbad3e) )
+	ROM_LOAD( "clines proto a.bin", 0x8000, 0x8000, CRC(0977e287) SHA1(e937a3787d4cd056c5f9944bca1532b84ed335f6) )//95718066
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clinsc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "39370028a.bin", 0x8000, 0x008000, CRC(e0250ea4) SHA1(01cc9013c37bc22f5ab69565d453ece99f739e6b) )
-	ROM_LOAD( "39370028b.bin", 0x0000, 0x008000, CRC(fca396e1) SHA1(3304a58a30fd0c79e8d1decd4bd8792d3acbad3e) )
+	ROM_LOAD( "39370028b.bin", 0x0000, 0x8000, CRC(fca396e1) SHA1(3304a58a30fd0c79e8d1decd4bd8792d3acbad3e) )
+	ROM_LOAD( "39370028a.bin", 0x8000, 0x8000, CRC(e0250ea4) SHA1(01cc9013c37bc22f5ab69565d453ece99f739e6b) )
 //  ROM_LOAD( "95717067b.bin", 0x0000, 0x008000, CRC(fca396e1) SHA1(3304a58a30fd0c79e8d1decd4bd8792d3acbad3e) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clinsd )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "957172.00 all cash.bin", 0x8000, 0x008000, CRC(cafc2409) SHA1(125f7c1826e58619a53b56ecd4f5b0b7f607aeef) )
-	ROM_LOAD( "957172.01 all cash.bin", 0x0000, 0x008000, CRC(27d941cf) SHA1(797d47c15d6a52f5647a566eb8ad1985324d81cb) )
+	ROM_LOAD( "957172.01 all cash.bin", 0x0000, 0x8000, CRC(27d941cf) SHA1(797d47c15d6a52f5647a566eb8ad1985324d81cb) )
+	ROM_LOAD( "957172.00 all cash.bin", 0x8000, 0x8000, CRC(cafc2409) SHA1(125f7c1826e58619a53b56ecd4f5b0b7f607aeef) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clinse ) // bad? (SUMCHECK ERROR)
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "957171.11 var% a.bin", 0x8000, 0x008000, CRC(1e74ef1a) SHA1(6c70f9b7f3caf6a5e9734b2e4ee74985c2b169d6) )
-	ROM_LOAD( "957171.12 var% b.bin", 0x0000, 0x008000, CRC(80243558) SHA1(6b7cc811998d11397e5fa03a50154d165997ae7b) )
+	ROM_LOAD( "957171.12 var% b.bin", 0x0000, 0x8000, CRC(80243558) SHA1(6b7cc811998d11397e5fa03a50154d165997ae7b) )
+	ROM_LOAD( "957171.11 var% a.bin", 0x8000, 0x8000, CRC(1e74ef1a) SHA1(6c70f9b7f3caf6a5e9734b2e4ee74985c2b169d6) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1clb3 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cl3000.bin", 0x0000, 0x010000, CRC(998b58fa) SHA1(73b2837d6287667f16c64edada1e3ec5ffa54c74) )
+	ROM_LOAD( "cl3000.bin", 0x00000, 0x10000, CRC(998b58fa) SHA1(73b2837d6287667f16c64edada1e3ec5ffa54c74) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
-	ROM_LOAD( "95000593.ic7", 0x000000, 0x010000, CRC(743d4ecd) SHA1(23c2a3673d6b09bc829297751c283de444d32fa3) )
-	ROM_LOAD( "95000594.ic8", 0x010000, 0x010000, CRC(9e143e49) SHA1(28547cc2f271f76a29d332f670e47a8bb836593e) )
+	ROM_LOAD( "95000593.ic7", 0x00000, 0x10000, CRC(743d4ecd) SHA1(23c2a3673d6b09bc829297751c283de444d32fa3) )
+	ROM_LOAD( "95000594.ic8", 0x10000, 0x10000, CRC(9e143e49) SHA1(28547cc2f271f76a29d332f670e47a8bb836593e) )
 ROM_END
 
 
@@ -2476,42 +2831,47 @@
 
 ROM_START( sc1czbrk )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "crazybreakp1.bin", 0x0000, 0x008000, CRC(47cbb5fd) SHA1(b5a7a20f9874f1010f7fc973d0cc5fcb87beaaf5) )
-	ROM_LOAD( "crazybreakp2.bin", 0x8000, 0x008000, CRC(71bfb2fe) SHA1(3371421268a1e0a4518eafd27b2c23a0c7475e11) )
+	ROM_LOAD( "crazybreakp1.bin", 0x0000, 0x8000, CRC(47cbb5fd) SHA1(b5a7a20f9874f1010f7fc973d0cc5fcb87beaaf5) )
+	ROM_LOAD( "crazybreakp2.bin", 0x8000, 0x8000, CRC(71bfb2fe) SHA1(3371421268a1e0a4518eafd27b2c23a0c7475e11) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1energ )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "energy_v109_u2.bin", 0x8000, 0x008000, CRC(ce5da71b) SHA1(c0cb687523bf7a8f42740dd3f54999eaa1db3cd0) )
-	ROM_LOAD( "energy_v109_u4.bin", 0x0000, 0x008000, CRC(bde92e45) SHA1(ae1b73ecd59131a11202487ecb4d34fc68e4101d) )
+	ROM_LOAD( "energy_v109_u4.bin", 0x0000, 0x8000, CRC(bde92e45) SHA1(ae1b73ecd59131a11202487ecb4d34fc68e4101d) )
+	ROM_LOAD( "energy_v109_u2.bin", 0x8000, 0x8000, CRC(ce5da71b) SHA1(c0cb687523bf7a8f42740dd3f54999eaa1db3cd0) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1frpus )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "95750025.p1", 0x0000, 0x010000, CRC(75d21cbf) SHA1(8161dec9b0533383acc6172da564f1353e4367c1) )
+	ROM_LOAD( "95750025.p1", 0x00000, 0x10000, CRC(75d21cbf) SHA1(8161dec9b0533383acc6172da564f1353e4367c1) )
 
-	ROM_REGION( 0x80000, "altrevs", 0 )
-	ROM_LOAD( "95752025.p1", 0x0000, 0x010000, CRC(0d223a7d) SHA1(7b110989b988f5fc57eac2b21b9f0cdb326174a0) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
+ROM_START( sc1frpusa )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95752025.p1", 0x00000, 0x10000, CRC(0d223a7d) SHA1(7b110989b988f5fc57eac2b21b9f0cdb326174a0) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+ROM_END
 
 
 ROM_START( sc1hipt )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "high point 6 b 20p.bin", 0x0000, 0x008000, CRC(535c1df1) SHA1(99d3033ee708c27134d461591eb7d19a573768d4) )
-	ROM_LOAD( "high point 6 a 20p.bin", 0x8000, 0x008000, CRC(228c3eef) SHA1(c60da857fa5630809b072c20cf1f24ee26c38d0b) )
+	ROM_LOAD( "high point 6 b 20p.bin", 0x0000, 0x8000, CRC(535c1df1) SHA1(99d3033ee708c27134d461591eb7d19a573768d4) )
+	ROM_LOAD( "high point 6 a 20p.bin", 0x8000, 0x8000, CRC(228c3eef) SHA1(c60da857fa5630809b072c20cf1f24ee26c38d0b) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1hipta )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "high point 69 6.bin", 0x8000, 0x008000, CRC(82564d75) SHA1(436b75e6617a6c2bb89ea0994696928b8452317d) )
-	ROM_LOAD( "high point 70 6.bin", 0x0000, 0x008000, CRC(752b4c6e) SHA1(30503128ccca5c88e66174bd3e54b115eded1db6) )
+	ROM_LOAD( "high point 70 6.bin", 0x0000, 0x8000, CRC(752b4c6e) SHA1(30503128ccca5c88e66174bd3e54b115eded1db6) )
+	ROM_LOAD( "high point 69 6.bin", 0x8000, 0x8000, CRC(82564d75) SHA1(436b75e6617a6c2bb89ea0994696928b8452317d) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
@@ -2519,13 +2879,13 @@
 
 ROM_START( sc1satse )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "satellitese.bin", 0x0000, 0x010000, CRC(de88d59c) SHA1(0df9ff2aa4be2634bc66e8f5539a7aa8c71b340a) )
+	ROM_LOAD( "satellitese.bin", 0x00000, 0x10000, CRC(de88d59c) SHA1(0df9ff2aa4be2634bc66e8f5539a7aa8c71b340a) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1strk )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "strike.bin", 0x0000, 0x010000, CRC(8bfae942) SHA1(325b74e3df527ad56e68b58b206fb3a491a44305) )
+	ROM_LOAD( "strike.bin", 0x00000, 0x10000, CRC(8bfae942) SHA1(325b74e3df527ad56e68b58b206fb3a491a44305) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	ROM_LOAD( "strikesoundp1.bin", 0x0000, 0x010000, CRC(bca5518c) SHA1(1b66e72e110702754eb3991f351cce689d6ad41c) )
 	ROM_LOAD( "strikesoundp2.bin", 0x0000, 0x010000, CRC(50d6c506) SHA1(cb9851ebad21c0b14cf3d57159034a8660a32f74) )
@@ -2533,15 +2893,15 @@
 
 ROM_START( sc1supfl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "superflushse.bin", 0x0000, 0x010000, CRC(50f890d1) SHA1(6edad44aaba069b2a3cc2bd16ed4cf383d6f7029) )
+	ROM_LOAD( "superflushse.bin", 0x00000, 0x10000, CRC(50f890d1) SHA1(6edad44aaba069b2a3cc2bd16ed4cf383d6f7029) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1ofs56 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ofs56cp1", 0x8000, 0x008000, CRC(928c0a32) SHA1(1c83e497d62112850ff1607f9b20a12fe07a88cc) )
-	ROM_LOAD( "ofs56cp2", 0x0000, 0x008000, CRC(c3af2861) SHA1(4fe47355ea9431360f17ff4004a7529111aa1d50) )
+	ROM_LOAD( "ofs56cp2", 0x0000, 0x8000, CRC(c3af2861) SHA1(4fe47355ea9431360f17ff4004a7529111aa1d50) )
+	ROM_LOAD( "ofs56cp1", 0x8000, 0x8000, CRC(928c0a32) SHA1(1c83e497d62112850ff1607f9b20a12fe07a88cc) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
@@ -2549,85 +2909,102 @@
 
 ROM_START( sc1wof )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "frds1-4n.p1", 0x8000, 0x008000, CRC(add2f2f8) SHA1(6c9852493b5e13cc694deacb96fe6d04f49e5c30) )
-	ROM_LOAD( "frds1-4n.p2", 0x0000, 0x008000, CRC(60e56657) SHA1(4f02be663cfb36beeaa47be37fca7447d6ff9ebc) )
+	ROM_LOAD( "frds1-4n.p2", 0x0000, 0x8000, CRC(60e56657) SHA1(4f02be663cfb36beeaa47be37fca7447d6ff9ebc) )
+	ROM_LOAD( "frds1-4n.p1", 0x8000, 0x8000, CRC(add2f2f8) SHA1(6c9852493b5e13cc694deacb96fe6d04f49e5c30) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1wofa )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "wfor3-3n.p1", 0x8000, 0x008000, CRC(a6bb27bd) SHA1(abe240ecb5ceee1012d0ff547380e2d122380efc) )
-	ROM_LOAD( "wfor3-3n.p2", 0x0000, 0x008000, CRC(610f5700) SHA1(1752604a2ea3ac658d86b5a5baea03d67b8a6e99) )
+	ROM_LOAD( "wfor3-3n.p2", 0x0000, 0x8000, CRC(610f5700) SHA1(1752604a2ea3ac658d86b5a5baea03d67b8a6e99) )
+	ROM_LOAD( "wfor3-3n.p1", 0x8000, 0x8000, CRC(a6bb27bd) SHA1(abe240ecb5ceee1012d0ff547380e2d122380efc) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1wofb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "wof.bin", 0x0000, 0x010000, CRC(6aa9ccce) SHA1(d8781e225c97ccf2fd847ead1ae8e200358f8a96) )
+	ROM_LOAD( "wof.bin", 0x00000, 0x10000, CRC(6aa9ccce) SHA1(d8781e225c97ccf2fd847ead1ae8e200358f8a96) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1crzyc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "craz1-5n.p1", 0x8000, 0x008000, CRC(943166ce) SHA1(9fbc97a1ede5ef18d5d5c544484b4a63f9a9901b) )
+	ROM_LOAD( "craz1-5n.p1", 0x8000, 0x8000, CRC(943166ce) SHA1(9fbc97a1ede5ef18d5d5c544484b4a63f9a9901b) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1crzyca )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ccds1-2n.p1", 0x8000, 0x008000, CRC(62d75b51) SHA1(82c9a211e9465c04cbf7597481ee4fb3cbac9a94) )
+	ROM_LOAD( "ccds1-2n.p1", 0x8000, 0x8000, CRC(62d75b51) SHA1(82c9a211e9465c04cbf7597481ee4fb3cbac9a94) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clbdy )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ddpv1-1a.gg", 0x8000, 0x008000, CRC(1614ee7b) SHA1(e777a122062f24a18fbe827371e359bbdd4298e7) )
-	ROM_LOAD( "ddpv1-1b.gg", 0x0000, 0x008000, CRC(692d4347) SHA1(6cdf3dbbaffe47fc026debaa74303d4ad36a5b63) )
+	ROM_LOAD( "ddpv1-1b.gg", 0x0000, 0x8000, CRC(692d4347) SHA1(6cdf3dbbaffe47fc026debaa74303d4ad36a5b63) )
+	ROM_LOAD( "ddpv1-1a.gg", 0x8000, 0x8000, CRC(1614ee7b) SHA1(e777a122062f24a18fbe827371e359bbdd4298e7) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1clbdya )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "dyn1-6n.p1", 0x8000, 0x008000, CRC(9cb42e58) SHA1(bb92e7618efb9a95e96d55d6ee46ba4f08cb825b) )
-	ROM_LOAD( "dyn1-6n.p2", 0x0000, 0x008000, CRC(425b8cf6) SHA1(8b3dd294ff965103b5621da462b39629445456b9) )
+	ROM_LOAD( "dyn1-6n.p2", 0x0000, 0x8000, CRC(425b8cf6) SHA1(8b3dd294ff965103b5621da462b39629445456b9) )
+	ROM_LOAD( "dyn1-6n.p1", 0x8000, 0x8000, CRC(9cb42e58) SHA1(bb92e7618efb9a95e96d55d6ee46ba4f08cb825b) )
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 
 ROM_START( sc1chqfl )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cflg1-5n.p1", 0x8000, 0x008000, CRC(2337b8ed) SHA1(c27b3b91ca52dd7edb05743753b4510c05f29055) )
+	ROM_LOAD( "cflg1-5n.p1", 0x8000, 0x8000, CRC(2337b8ed) SHA1(c27b3b91ca52dd7edb05743753b4510c05f29055) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1s1000 )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "super1000.bin", 0x8000, 0x008000, CRC(879e56e6) SHA1(5c0a08375a30213142e1d3835ea46462d882982d) )
+	ROM_LOAD( "super1000.bin", 0x8000, 0x8000, CRC(879e56e6) SHA1(5c0a08375a30213142e1d3835ea46462d882982d) )
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1cdm )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "dd13b.bin", 0x0000, 0x008000, CRC(7a663587) SHA1(6d03a34047ba5f995b1877fc4c0ab9703aa4defc) )
-	ROM_LOAD( "dd13a.bin", 0x8000, 0x008000, CRC(e674bca9) SHA1(31481d791f3aaf1d4ba790924f0f9e4100a82da5) )
+	ROM_LOAD( "dd13b.bin", 0x0000, 0x8000, CRC(7a663587) SHA1(6d03a34047ba5f995b1877fc4c0ab9703aa4defc) )
+	ROM_LOAD( "dd13a.bin", 0x8000, 0x8000, CRC(e674bca9) SHA1(31481d791f3aaf1d4ba790924f0f9e4100a82da5) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "dd13ap.bin", 0x0000, 0x008000, CRC(84a51666) SHA1(89cf10c7e732b5f77b798bf58fe8ebfc701da57b) )
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+	ROM_LOAD( "dd_snd1.bin", 0x00000, 0x10000, CRC(c00a70ab) SHA1(c0014b3e4308281203921994f41f19e0243148e0) )
+	ROM_LOAD( "dd_snd2.bin", 0x10000, 0x10000, CRC(c03827f6) SHA1(16e844fb83d79d1e4fbb0069debaf71af5ad6814) )
+ROM_END
+
+ROM_START( sc1cdmp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "dd13b.bin", 0x0000, 0x8000, CRC(7a663587) SHA1(6d03a34047ba5f995b1877fc4c0ab9703aa4defc) )
+	ROM_LOAD( "dd13ap.bin", 0x8000, 0x8000, CRC(84a51666) SHA1(89cf10c7e732b5f77b798bf58fe8ebfc701da57b) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
-	ROM_LOAD( "dd_snd1.bin", 0x000000, 0x010000, CRC(c00a70ab) SHA1(c0014b3e4308281203921994f41f19e0243148e0) )
-	ROM_LOAD( "dd_snd2.bin", 0x010000, 0x010000, CRC(c03827f6) SHA1(16e844fb83d79d1e4fbb0069debaf71af5ad6814) )
+	ROM_LOAD( "dd_snd1.bin", 0x00000, 0x10000, CRC(c00a70ab) SHA1(c0014b3e4308281203921994f41f19e0243148e0) )
+	ROM_LOAD( "dd_snd2.bin", 0x10000, 0x10000, CRC(c03827f6) SHA1(16e844fb83d79d1e4fbb0069debaf71af5ad6814) )
 ROM_END
 
 ROM_START( sc1hfcc )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "cz14b.bin", 0x0000, 0x008000, CRC(976233ca) SHA1(554da440a0fe1d66fa95bef51ac168cec35d1636) )
-	ROM_LOAD( "cz14a.bin", 0x8000, 0x008000, CRC(34324f0b) SHA1(946ff8fa40788748a0caabd48d125f2a4f9c36c3) )
+	ROM_LOAD( "cz14b.bin", 0x0000, 0x8000, CRC(976233ca) SHA1(554da440a0fe1d66fa95bef51ac168cec35d1636) )
+	ROM_LOAD( "cz14a.bin", 0x8000, 0x8000, CRC(34324f0b) SHA1(946ff8fa40788748a0caabd48d125f2a4f9c36c3) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "cz14ap.bin", 0x0000, 0x008000, CRC(56e3e5c4) SHA1(3017007e03139204732f7945ded61d35499055ac) )
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+	/* Missing? */
+ROM_END
+
+ROM_START( sc1hfccp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "cz14b.bin", 0x0000, 0x8000, CRC(976233ca) SHA1(554da440a0fe1d66fa95bef51ac168cec35d1636) )
+	ROM_LOAD( "cz14ap.bin", 0x8000, 0x8000, CRC(56e3e5c4) SHA1(3017007e03139204732f7945ded61d35499055ac) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	/* Missing? */
@@ -2643,15 +3020,26 @@
 
 ROM_START( sc1chain )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-//  ROM_LOAD( "95717174 b.bin", 0x0000, 0x008000, CRC(6cdc8d15) SHA1(582e5e7bcefe0085917d3499b7c83e27c19662d2) )
-//  ROM_LOAD( "95717173 a.bin", 0x8000, 0x008000, CRC(4989e6c6) SHA1(17184c6a3624dfaa61bc4ddb3ac1813949eaf834) )
-	ROM_LOAD( "95717174.bin", 0x0000, 0x008000, CRC(6cdc8d15) SHA1(582e5e7bcefe0085917d3499b7c83e27c19662d2) )
-	ROM_LOAD( "95717173.bin", 0x8000, 0x008000, CRC(4989e6c6) SHA1(17184c6a3624dfaa61bc4ddb3ac1813949eaf834) )
+	ROM_LOAD( "95717174.bin", 0x0000, 0x8000, CRC(6cdc8d15) SHA1(582e5e7bcefe0085917d3499b7c83e27c19662d2) )
+	ROM_LOAD( "95717173.bin", 0x8000, 0x8000, CRC(4989e6c6) SHA1(17184c6a3624dfaa61bc4ddb3ac1813949eaf834) )
 
-	ROM_REGION( 0x10000, "altrevs", 0 )
-	ROM_LOAD( "95716173 proto.bin", 0x0000, 0x008000, CRC(4f806f1d) SHA1(cfa8bcc2afbb47e549836d968c3390bef04c6c30) )
-	ROM_LOAD( "95717210.bin", 0x0000, 0x008000, CRC(102d2bc8) SHA1(8ed5f44e6014e21f677762e40076d648901d1ff2) )
-	ROM_LOAD( "95717211.bin", 0x0000, 0x008000, CRC(ed781e00) SHA1(67ebb58beda5123f061a22dacd008f1feb75b8d9) )
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+	/* Missing? */
+ROM_END
+
+ROM_START( sc1chainp )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717174.bin", 0x0000, 0x8000, CRC(6cdc8d15) SHA1(582e5e7bcefe0085917d3499b7c83e27c19662d2) )
+	ROM_LOAD( "95716173 proto.bin", 0x8000, 0x8000, CRC(4f806f1d) SHA1(cfa8bcc2afbb47e549836d968c3390bef04c6c30) )
+
+	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
+	/* Missing? */
+ROM_END
+
+ROM_START( sc1chaina )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "95717211.bin", 0x0000, 0x8000, CRC(ed781e00) SHA1(67ebb58beda5123f061a22dacd008f1feb75b8d9) )
+	ROM_LOAD( "95717210.bin", 0x8000, 0x8000, CRC(102d2bc8) SHA1(8ed5f44e6014e21f677762e40076d648901d1ff2) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	/* Missing? */
@@ -2659,16 +3047,16 @@
 
 ROM_START( sc1potp )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "potp 95715159 2x1.bin", 0x6000, 0x002000, CRC(b47cd8f3) SHA1(bf26fdc440a111dc1326b200281c2dff5c517c67) )
-	ROM_LOAD( "potp 95717908 2x1.bin", 0x8000, 0x008000, CRC(953c3e78) SHA1(f14ab2c4337e93605be4baac51b8ad3b9bf0e155) )
+	ROM_LOAD( "potp 95715159 2x1.bin", 0x6000, 0x2000, CRC(b47cd8f3) SHA1(bf26fdc440a111dc1326b200281c2dff5c517c67) )
+	ROM_LOAD( "potp 95717908 2x1.bin", 0x8000, 0x8000, CRC(953c3e78) SHA1(f14ab2c4337e93605be4baac51b8ad3b9bf0e155) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( sc1potpa )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "potp 95715146.bin", 0x6000, 0x002000, CRC(9557ebc4) SHA1(a9d3b2d901875b9d53ac9500acdb9b725b4edcb5) )
-	ROM_LOAD( "potp 95350166.bin", 0x8000, 0x008000, CRC(45f0effa) SHA1(afd7aabac7da04b5960c2cc55863b917a2692c4f) )
+	ROM_LOAD( "potp 95715146.bin", 0x6000, 0x2000, CRC(9557ebc4) SHA1(a9d3b2d901875b9d53ac9500acdb9b725b4edcb5) )
+	ROM_LOAD( "potp 95350166.bin", 0x8000, 0x8000, CRC(45f0effa) SHA1(afd7aabac7da04b5960c2cc55863b917a2692c4f) )
 
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 ROM_END
@@ -2692,7 +3080,8 @@
 
 #define GAME_FLAGS GAME_SUPPORTS_SAVE|GAME_REQUIRES_ARTWORK|GAME_NOT_WORKING|GAME_MECHANICAL
 
-GAME( 1988, sc1lotus		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Lotus SE (Dutch)", GAME_FLAGS )
+GAME( 1988, sc1lotus		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Lotus SE (Dutch) (set 1)", GAME_FLAGS )
+GAME( 1988, sc1lotusa		, sc1lotus	, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Lotus SE (Dutch) (set 2)", GAME_FLAGS )
 GAME( 1988, sc1roul			, 0			, scorpion1			, scorpion1	, rou029		, 0,       "BFM/ELAM", "Roulette (Dutch, Game Card 39-360-129?)", GAME_FLAGS )
 GAME( 1990, sc1clatt		, 0			, scorpion1			, clatt		, clatt			, 0,       "BFM",      "Club Attraction (UK, Game Card 39-370-196)", GAME_FLAGS )
 GAME( 1990, sc1clatta		, sc1clatt	, scorpion1			, clatt		, clatt			, 0,       "BFM",      "Club Attraction (set 2)", GAME_FLAGS )
@@ -2700,93 +3089,161 @@
 GAME( 198?, sc1armad		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Armada (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1bartk		, 0			, scorpion1_viper	, clatt		, lotse			, 0,       "BFM",      "Bar Trek (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1barcd		, 0			, scorpion1_viper	, clatt		, lotse			, 0,       "BFM",      "Barcode (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1barcda		, sc1barcd	, scorpion1_viper	, clatt		, lotse			, 0,       "BFM",      "Barcode (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1bigmt		, 0			, scorpion1_viper	, clatt		, nocrypt		, 0,       "BFM",      "The Big Match (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1calyp		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Calypso (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1carro		, 0			, scorpion1			, scorpion1	, nocrypt_bank0	, 0,       "BFM/ELAM", "Carrousel (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cshat		, 0			, scorpion1			, scorpion1 , lotse 		, 0,       "BFM",      "Cash Attraction (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshat		, 0			, scorpion1			, scorpion1 , lotse 		, 0,       "BFM",      "Cash Attraction (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshata		, sc1cshat	, scorpion1			, scorpion1 , lotse 		, 0,       "BFM",      "Cash Attraction (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshatb		, sc1cshat	, scorpion1			, scorpion1 , lotse 		, 0,       "BFM",      "Cash Attraction (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshatc		, sc1cshat	, scorpion1			, scorpion1 , lotse 		, 0,       "BFM",      "Cash Attraction (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+
 GAME( 198?, sc1cshcd		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cash Card (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cshcda		, sc1cshcd	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",	   "Cash Card (Bellfruit) (Scorpion 1, set 1)", GAME_FLAGS )
-GAME( 198?, sc1cshcdb		, sc1cshcd	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Card (Bellfruit) (Scorpion 1, set 2)", GAME_FLAGS )
+GAME( 198?, sc1cshcda		, sc1cshcd	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",	   "Cash Card (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshcdb		, sc1cshcd	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Card (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1ccoin		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Coin (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cexpd		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cash Explosion (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cexpl		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cshwz		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Wise (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cshin		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cashino (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1china		, 0			, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1class		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Classic (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexpd		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cash Explosion (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexpl		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexpla		, sc1cexpl	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexplb		, sc1cexpl	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexplc		, sc1cexpl	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cexpld		, sc1cexpl	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Explosion (Bellfruit) (set 5) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshwz		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Wise (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshwza		, sc1cshwz	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Wise (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshwzb		, sc1cshwz	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Wise (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshwzc		, sc1cshwz	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cash Wise (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cshin		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cashino (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1china		, 0			, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1chinap		, sc1china	, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1chinaa		, sc1china	, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1chinaap		, sc1china	, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 2, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1chinab		, sc1china	, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1chinabp		, sc1china	, scorpion1_viper	, scorpion1	, lotse			, 0,       "BFM",      "China Town Club (Bellfruit) (set 3, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1class		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Classic (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1cwcl			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Clockwise Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1clown		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Clown Around (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1cl2k			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Club 2000 (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cl2k1		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Club 2001 (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1cl65			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl2k1		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Club 2001 (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65a		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65ap		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 2, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65b		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65bp		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 3, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65c		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65d		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 5) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1cl65dp		, sc1cl65	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club 65 Special (Bellfruit) (set 5, Protocol) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1clbdm		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Diamond (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1clbxp		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Explosion (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1clbrn		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Runner (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1clbsp		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Spinner (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1clbtm		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Temptation (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1clbw			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Wise (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1copdd		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cops 'n' Robbers Deluxe (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1clbtm		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Temptation (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1clbtma		, sc1clbtm	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Temptation (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1clbw			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Wise (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1clbwa		, sc1clbw	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Wise (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1clbwb		, sc1clbw	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Club Wise (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1copdd		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Cops 'n' Robbers Deluxe (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1copdx		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Cops 'n' Robbers Deluxe (Bellfruit) (Scorpion 1)", GAME_FLAGS ) // is this really sc1? it does nothing
-GAME( 198?, sc1count		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1dago			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Dagobert's Vault (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1disc			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Discovey (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1dblch		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Double Chance (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1count		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1countp		, sc1count	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1counta		, sc1count	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1countap		, sc1count	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (set 2, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1countb		, sc1count	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Count Cash Club (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1dago			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Dagobert's Vault (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1disc			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Discovey (Bellfruit) (Dutch) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1disca		, sc1disc	, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Discovey (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1dblch		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Double Chance (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1dblcha		, sc1dblch	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Double Chance (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1dream		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Dream Machine (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1final		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Final Touch (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1flash		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Flash (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1fruit		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Fruit Lines (Bellfruit) (Scorpion 1, set 1)", GAME_FLAGS )
-GAME( 198?, sc1frtln		, sc1fruit	, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Fruit Lines (Bellfruit) (Scorpion 1, set 2)", GAME_FLAGS )
-GAME( 198?, sc1funh			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Fun House Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1flash		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Flash (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1fruit		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Fruit Lines (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1frtln		, sc1fruit	, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Fruit Lines (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1funh			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Fun House Club (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1funhp		, sc1funh	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Fun House Club (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1funha		, sc1funh	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Fun House Club (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1funhb		, sc1funh	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Fun House Club (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1gtime		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Good Times (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1tiara		, 0			, scorpion1			, scorpion1	, nocrypt       , 0,       "ELAM",     "Tiara (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1gprix		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Grand Prix (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1gslam		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM",      "Grand Slam (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1gprix		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Grand Prix (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1gslam		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM",      "Grand Slam (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1happy		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM",      "Happy Hour (Bellfruit - Elam) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1impc			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Impact (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1kings		, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Kings Club (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1linx			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Linx (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1magc			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Magic Circle (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1manha		, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Manhattan (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1impc			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Impact (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1kings		, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Kings Club (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1linx			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Linx (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1linxa		, sc1linx	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Linx (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1linxp		, sc1linx	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Linx (Bellfruit) (set 3, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1magc			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Magic Circle (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1manha		, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Manhattan (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1mast			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Master Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1quat			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Quatro (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1mist			, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Mistral (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1olym			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Olympia (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1orac			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Oracle (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1pwrl			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Power Lines (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1rain			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Rainbow (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1re			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Reel Cash (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1rese			, sc1re		, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Reel Cash SE (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS ) // doesn't say 'SE'
-GAME( 198?, sc1revo			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Revolution (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1rose			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Rose 'n' Crown (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1sant			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Santana (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1sat			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Satellite (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1shan			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Shanghai (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1spct			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Spectre (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1quat			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Quatro (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1mist			, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,       "BFM/ELAM", "Mistral (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1olym			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Olympia (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1orac			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Oracle (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1pwrl			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Power Lines (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1pwrla		, sc1pwrl	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Power Lines (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1rain			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Rainbow (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1re			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Reel Cash (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1rese			, sc1re		, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Reel Cash SE (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS ) // doesn't say 'SE'
+GAME( 198?, sc1revo			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Revolution (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1rose			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Rose 'n' Crown (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sant			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Santana (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sat			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Satellite (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1shan			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Shanghai (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1spct			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Spectre (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1spcta		, sc1spct	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Spectre (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1spit			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Spitfire (Elam) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1ster			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Sterling (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1str4			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike 4 (Bellfruit) (Scorpion 1, set 1)", GAME_FLAGS )
-GAME( 198?, sc1str4a		, sc1str4	, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Strike 4 (Bellfruit) (Scorpion 1, set 2)", GAME_FLAGS )
-GAME( 198?, sc1sir			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike It Rich (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1sups			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Superstar (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1torn			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Tornado (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1tri			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1typ			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Typhoon Club (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1ster			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Sterling (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1str4			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike 4 (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1str4a		, sc1str4	, scorpion1			, scorpion1	, nocrypt		, 0,       "BFM/ELAM", "Strike 4 (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sir			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike It Rich (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sira			, sc1sir	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike It Rich (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sirb			, sc1sir	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike It Rich (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sirc			, sc1sir	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Strike It Rich (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1sups			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Superstar (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1torn			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Tornado (Bellfruit) (Dutch) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1torna		, sc1torn	, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Tornado (Bellfruit) (Dutch) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1tri			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1tria			, sc1tri	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1triap		, sc1tri	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (set 2, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1trib			, sc1tri	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1tribp		, sc1tri	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Tri Star (Bellfruit) (set 3, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1typ			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Typhoon Club (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1typp			, sc1typ	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Typhoon Club (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1ult			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Ultimate (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1vent			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Ventura (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1vict			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Victory (Bellfruit) [Dutch] (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1voy			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Voyager (Bellfruit) (Scorpion 1, set 1)", GAME_FLAGS )
-GAME( 198?, sc1voya			, sc1voy	, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Voyager (Bellfruit) (Scorpion 1, set 2)", GAME_FLAGS )
-GAME( 198?, sc1winfl		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Winfalls [Dutch] (Bellfruit) (Scorpion 1)", GAME_FLAGS )
-GAME( 198?, sc1winst		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1vent			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Ventura (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1vict			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Victory (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1voy			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Voyager (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1voya			, sc1voy	, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Voyager (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winfl		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM/ELAM", "Winfalls (Dutch) (Bellfruit) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winst		, 0			, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstp		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winsta		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstb		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 3) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstbp		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 3, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstc		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 4) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstcp		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 4, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstd		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 5) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstdp		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 5, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winste		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 6) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstep		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 6, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstf		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 7) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstfp		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 7, Protocol) (Scorpion 1)", GAME_FLAGS )
+GAME( 198?, sc1winstg		, sc1winst	, scorpion1			, scorpion1	, lotse			, 0,       "BFM",      "Winning Streak (Bellfruit) (set 8) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1zep			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "ELAM",     "Zeppelin (Bellfruit) (Scorpion 1)", GAME_FLAGS )
 GAME( 198?, sc1wthn			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "Eurocoin", "Wild Thing (Eurocoin) (Scorpion 1)", GAME_FLAGS )
 GAME( 199?, sc1moonl		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Bwb",      "Moon Lite (Bwb)", GAME_FLAGS)
 GAME( 199?, sc1ltdv			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Pcp",      "Little Devil (Pcp)", GAME_FLAGS)
 GAME( 198?, sc1t1k			, 0			, scorpion1			, scorpion1	, lotse			, 0,       "Eurocoin", "Top 1000 (Eurocoin) (Scorpion 1)", GAME_FLAGS )
-GAME( 199?, sc1smoke		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Smokey Vs The Bandit (Mdm) (Scorpion 2/3)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
-GAME( 199?, sc1ccroc		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Crazy Crocs (Mdm) (Scorpion 2/3)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
-GAME( 199?, sc1crocr		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Croc And Roll (Mdm) (Scorpion 2/3)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
-GAME( 199?, sc1btclk		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Beat The Clock (Mdm) (Scorpion 2/3)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1smoke		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Smokey Vs The Bandit (Mdm) (set 1) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1smokea		, sc1smoke	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Smokey Vs The Bandit (Mdm) (set 2) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1ccroc		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Crazy Crocs (Mdm) (set 1) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1ccroca		, sc1ccroc	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Crazy Crocs (Mdm) (set 2) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1ccrocb		, sc1ccroc	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Crazy Crocs (Mdm) (set 3) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1ccrocc		, sc1ccroc	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Crazy Crocs (Mdm) (set 4) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1crocr		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Croc And Roll (Mdm) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1btclk		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Beat The Clock (Mdm) (set 1) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1btclka		, sc1btclk	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Beat The Clock (Mdm) (set 2) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
+GAME( 199?, sc1btclkb		, sc1btclk	, scorpion1			, scorpion1	, nocrypt		, 0,	   "Mdm",      "Beat The Clock (Mdm) (set 3) (Scorpion 2/3?)",   GAME_NOT_WORKING|GAME_REQUIRES_ARTWORK|GAME_NO_SOUND )
 GAME( 199?, sc1clins		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM/PCP",  "Cash Lines (Bellfruit) (Scorpion 1) (set 1)", GAME_FLAGS)
 GAME( 199?, sc1clinsa		, sc1clins	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM/PCP",  "Cash Lines (Bellfruit) (Scorpion 1) (set 2)", GAME_FLAGS)
 GAME( 199?, sc1clinsb		, sc1clins	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",	   "Cash Lines (Bellfruit) (Scorpion 1) (set 3)", GAME_FLAGS)
@@ -2803,13 +3260,23 @@
 GAME( 199?, sc1supfl		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM/ELAM", "Super Flush (Bellfruit) (Dutch) (Scorpion 1)", GAME_FLAGS)
 // are they really SC1?
 GAME( 199?, sc1btbc			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Beat The Bank Club (Bellfruit) (Scorpion 1?)", GAME_FLAGS) // behaves like sc1clbdya, but then locks up
-GAME( 199?, sc1frpus		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Fruit Pursuit (Bellfruit) (Scorpion 1?)", GAME_FLAGS)
-GAME( 199?, sc1ofs56		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "unknown 'ofs56cp' (Bellfruit) (Scorpion 1?)", GAME_FLAGS) // OFAH - Phoenix 1
+GAME( 199?, sc1frpus		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Fruit Pursuit (Bellfruit) (set 1) (Scorpion 1?)", GAME_FLAGS)
+GAME( 199?, sc1frpusa		, sc1frpus	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Fruit Pursuit (Bellfruit) (set 2) (Scorpion 1?)", GAME_FLAGS)
+GAME( 199?, sc1ofs56		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "unknown 'ofs56cp' (Bellfruit) (Scorpion 1?)", GAME_FLAGS) // OFAH - Phoenix 1 - Only Fools and Horses?
 GAME( 199?, sc1boncl		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Bonanza Club (Bellfruit) (Scorpion 1)", GAME_FLAGS)
 // are these really SC1? they do more here than in SC2 at least!
-GAME( 199?, sc1days			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "All In A Days Work (Global)", GAME_FLAGS)
-GAME( 199?, sc1cscl			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Cash Classic (Global)", GAME_FLAGS)
-GAME( 199?, sc1driv			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Driving School (Global)", GAME_FLAGS)
+GAME( 199?, sc1days			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "All In A Days Work (Global) (set 1)", GAME_FLAGS)
+GAME( 199?, sc1daysa		, sc1days	, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "All In A Days Work (Global) (set 2)", GAME_FLAGS)
+GAME( 199?, sc1cscl			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Cash Classic (Global) (set 1)", GAME_FLAGS)
+GAME( 199?, sc1cscla		, sc1cscl	, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Cash Classic (Global) (set 2)", GAME_FLAGS)
+GAME( 199?, sc1csclb		, sc1cscl	, scorpion1			, scorpion1	, lotse			, 0,	   "Maygay?",  "Cash Classic (Maygay/Global?) (set 3)", GAME_FLAGS)
+GAME( 199?, sc1csclc		, sc1cscl	, scorpion1			, scorpion1	, lotse			, 0,	   "Maygay",   "Cash Classic (Maygay/Global?) (set 4)", GAME_FLAGS)
+
+GAME( 199?, sc1driv			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Driving School (Global) (set 1)", GAME_FLAGS)
+GAME( 199?, sc1driva		, sc1driv	, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Driving School (Global) (set 2)", GAME_FLAGS)
+GAME( 199?, sc1drivb		, sc1driv	, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Driving School (Global) (set 3)", GAME_FLAGS)
+GAME( 199?, sc1drivc		, sc1driv	, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Driving School (Global) (set 4)", GAME_FLAGS)
+
 GAME( 199?, sc1vsd			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "Global",   "Vegas Super Deal (Global)", GAME_FLAGS)
 
 GAME( 199?, sc1wof			, 0			, scorpion1			, scorpion1	, lotse		    , 0,	   "Global",   "Wheel Of Fortune (Global) (set 1)", GAME_FLAGS)
@@ -2820,7 +3287,7 @@
 GAME( 199?, sc1clbdy		, 0			, scorpion1			, scorpion1	, lotse	        , 0,	   "Global",   "Club Dynamite (Global) (set 1)", GAME_FLAGS)
 GAME( 199?, sc1clbdya		, sc1clbdy	, scorpion1			, scorpion1	, lotse	        , 0,	   "Global",   "Club Dynamite (Global) (set 2)", GAME_FLAGS)
 GAME( 199?, sc1chqfl		, 0			, scorpion1			, scorpion1	, lotse	        , 0,	   "Global",   "Chequered Flag (Global)", GAME_FLAGS)
-GAME( 1992, sc1s1000		, 0			, scorpion1			, scorpion1	, lotse	        , 0,	   "Deltasoft",   "Super 1000 (Deltasoft)", GAME_FLAGS) // JT/Deltasoft Nov 1992
+GAME( 1992, sc1s1000		, 0			, scorpion1			, scorpion1	, lotse	        , 0,	   "Deltasoft","Super 1000 (Deltasoft)", GAME_FLAGS) // JT/Deltasoft Nov 1992
 
 
 
@@ -2829,19 +3296,25 @@
 GAME( 199?, sc1lamb			, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Eurocoin", "Lambada (Eurocoin) (Scorpion 1)", GAME_FLAGS) //
 GAME( 199?, sc1reply		, 0			, scorpion1			, scorpion1	, nocrypt		, 0,	   "Eurocoin", "Replay (Eurocoin) (Scorpion 1)", GAME_FLAGS) //
 
-GAME( 199?, sc1cdm		, 0			,  scorpion1		, scorpion1		, lotse_bank0		, 0,		 "Crystal",   "Club Diamond (Crystal) (Scorpion 1)", GAME_FLAGS)
-GAME( 199?, sc1hfcc		, 0			,  scorpion1		, scorpion1		, lotse_bank0		, 0,		 "Crystal",   "Hi Flyer Club (Crystal) (Scorpion 1)", GAME_FLAGS)
+GAME( 199?, sc1cdm			, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,	   "Crystal",  "Club Diamond (Crystal) (set 1) (Scorpion 1)", GAME_FLAGS)
+GAME( 199?, sc1cdmp			, sc1cdm	, scorpion1			, scorpion1	, lotse_bank0	, 0,	   "Crystal",  "Club Diamond (Crystal) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS)
+
+GAME( 199?, sc1hfcc			, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,	   "Crystal",  "Hi Flyer Club (Crystal) (set 1) (Scorpion 1)", GAME_FLAGS)
+GAME( 199?, sc1hfccp		, sc1hfcc	, scorpion1			, scorpion1	, lotse_bank0	, 0,	   "Crystal",  "Hi Flyer Club (Crystal) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS)
+
+GAME( 199?, sc1twice		, 0			, scorpion1			, scorpion1	, lotse_bank0	, 0,	   "Associated Leisure",   "Twice As Nice (Associated Leisure) (Scorpion 1)", GAME_FLAGS) // this has valid strings in it BEFORE the bfm decode, but decodes to valid code, does it use some funky mapping, or did they just fill unused space with valid looking data?
+GAME( 199?, sc1chain		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Chain Reaction (Bellfruit) (set 1) (Scorpion 1)", GAME_FLAGS)
+GAME( 199?, sc1chainp		, sc1chain	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Chain Reaction (Bellfruit) (set 1, Protocol) (Scorpion 1)", GAME_FLAGS)
+GAME( 199?, sc1chaina		, sc1chain	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Chain Reaction (Bellfruit) (set 2) (Scorpion 1)", GAME_FLAGS)
 
-GAME( 199?, sc1twice		, 0			,  scorpion1		, scorpion1		, lotse_bank0		, 0,		 "Associated Leisure",   "Twice As Nice (Associated Leisure) (Scorpion 1)", GAME_FLAGS) // this has valid strings in it BEFORE the bfm decode, but decodes to valid code, does it use some funky mapping, or did they just fill unused space with valid looking data?
-GAME( 199?, sc1chain			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Chain Reaction (Bellfruit) (Scorpion 1)", GAME_FLAGS)
 GAME( 199?, sc1potp			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Pick Of The Pack (Bellfruit) (Scorpion 1)", GAME_FLAGS) //was mixed with the sc4/5 potp roms..  System status 98
-GAME( 199?, sc1potpa			, sc1potp			, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Double Dealer (Bellfruit) (Scorpion 1)", GAME_FLAGS) // ^ with above.. seems the same game, but different name
+GAME( 199?, sc1potpa		, sc1potp	, scorpion1			, scorpion1	, lotse			, 0,	   "BFM",      "Double Dealer (Bellfruit) (Scorpion 1)", GAME_FLAGS) // ^ with above.. seems the same game, but different name
 
 
-GAME( 199?, sc1scunk			, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "<unknown>",      "unknown Scorpion 1 'Super ?' (Bellfruit) (Scorpion 1)", GAME_FLAGS) // ^ with above.. seems the same game, but different name
+GAME( 199?, sc1scunk		, 0			, scorpion1			, scorpion1	, lotse			, 0,	   "<unknown>",      "unknown Scorpion 1 'Super ?' (Bellfruit) (Scorpion 1)", GAME_FLAGS) // ^ with above.. seems the same game, but different name
 
 
 //Adder 2
-GAME( 1996, m_tppokr, 0,        scorpion1_adder2	, toppoker	, toppoker		, 0,       "BFM/ELAM",    "Top Poker (Dutch, Game Card 95-750-899)", GAME_FLAGS )
+GAME( 1996, m_tppokr		, 0			,  scorpion1_adder2	, toppoker	, toppoker		, 0,       "BFM/ELAM",    "Top Poker (Dutch, Game Card 95-750-899)", GAME_FLAGS )
 
 
diff -Nru src-old/mame/drivers/bfm_sc4.c src/mame/drivers/bfm_sc4.c
--- src-old/mame/drivers/bfm_sc4.c	2012-02-19 05:06:59.000000000 +0100
+++ src/mame/drivers/bfm_sc4.c	2012-02-28 00:43:07.000000000 +0100
@@ -95,7 +95,7 @@
 INPUT_PORTS_END
 
 static MACHINE_CONFIG_START( sc4, sc4_state )
-	MCFG_CPU_ADD("maincpu", M68000, 16000000)	 // 68307! (EC000 core)
+	MCFG_CPU_ADD("maincpu", M68307, 16000000)	 // 68307! (EC000 core)
 	MCFG_CPU_PROGRAM_MAP(sc4_map)
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
diff -Nru src-old/mame/drivers/bionicc.c src/mame/drivers/bionicc.c
--- src-old/mame/drivers/bionicc.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/bionicc.c	2012-03-11 18:17:00.000000000 +0100
@@ -149,7 +149,7 @@
 static ADDRESS_MAP_START( main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0xfe0000, 0xfe07ff) AM_RAM	/* RAM? */
-	AM_RANGE(0xfe0800, 0xfe0cff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfe0800, 0xfe0cff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xfe0d00, 0xfe3fff) AM_RAM              /* RAM? */
 	AM_RANGE(0xfe4000, 0xfe4001) AM_WRITE(bionicc_gfxctrl_w)	/* + coin counters */
 	AM_RANGE(0xfe4000, 0xfe4001) AM_READ_PORT("SYSTEM")
@@ -375,21 +375,21 @@
 	MCFG_MACHINE_RESET(bionicc)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(bionicc)
-	MCFG_SCREEN_VBLANK_STATIC(bionicc)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(bionicc)
 	MCFG_PALETTE_LENGTH(1024)
 
 	MCFG_VIDEO_START(bionicc)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 	MCFG_SOUND_ADD("ymsnd", YM2151, 3579545)
diff -Nru src-old/mame/drivers/blktiger.c src/mame/drivers/blktiger.c
--- src-old/mame/drivers/blktiger.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/blktiger.c	2012-03-11 18:17:00.000000000 +0100
@@ -79,7 +79,7 @@
 	AM_RANGE(0xd800, 0xdbff) AM_RAM_WRITE(paletteram_xxxxBBBBRRRRGGGG_split1_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xdc00, 0xdfff) AM_RAM_WRITE(paletteram_xxxxBBBBRRRRGGGG_split2_w) AM_BASE_GENERIC(paletteram2)
 	AM_RANGE(0xe000, 0xfdff) AM_RAM
-	AM_RANGE(0xfe00, 0xffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfe00, 0xffff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( blktiger_io_map, AS_IO, 8 )
@@ -337,21 +337,21 @@
 	MCFG_MACHINE_RESET(blktiger)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(blktiger)
-	MCFG_SCREEN_VBLANK_STATIC(blktiger)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(blktiger)
 	MCFG_PALETTE_LENGTH(1024)
 
 	MCFG_VIDEO_START(blktiger)
 
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
diff -Nru src-old/mame/drivers/bloodbro.c src/mame/drivers/bloodbro.c
--- src-old/mame/drivers/bloodbro.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/bloodbro.c	2012-03-08 17:46:13.000000000 +0100
@@ -474,8 +474,8 @@
 
 ROM_START( bloodbro )
 	ROM_REGION( 0x80000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "bb_02.bin",    0x00001, 0x20000, CRC(c0fdc3e4) SHA1(31968f693de2054a0c8ba50a8d44a371dd9c2848) )
-	ROM_LOAD16_BYTE( "bb_01.bin",    0x00000, 0x20000, CRC(2d7e0fdf) SHA1(8fe22d8a1ef7d562a475a5b6c98303b0cb1af561) )
+	ROM_LOAD16_BYTE( "2j.u021",      0x00001, 0x20000, CRC(c0fdc3e4) SHA1(31968f693de2054a0c8ba50a8d44a371dd9c2848) )
+	ROM_LOAD16_BYTE( "1j.i022",      0x00000, 0x20000, CRC(2d7e0fdf) SHA1(8fe22d8a1ef7d562a475a5b6c98303b0cb1af561) )
 	ROM_LOAD16_BYTE( "bb_04.bin",    0x40001, 0x20000, CRC(fd951c2c) SHA1(f4031bf303c67c82f2f78f7456f78382d8c1ac85) )
 	ROM_LOAD16_BYTE( "bb_03.bin",    0x40000, 0x20000, CRC(18d3c460) SHA1(93b86af1199f0fedeaf1fe64d27ffede4b819e42) )
 
diff -Nru src-old/mame/drivers/boogwing.c src/mame/drivers/boogwing.c
--- src-old/mame/drivers/boogwing.c	2012-01-29 15:04:52.000000000 +0100
+++ src/mame/drivers/boogwing.c	2012-03-11 18:17:00.000000000 +0100
@@ -97,10 +97,10 @@
 	AM_RANGE(0x220000, 0x220001) AM_DEVWRITE("deco_common", decocomn_priority_w)
 	AM_RANGE(0x220002, 0x22000f) AM_NOP
 
-	AM_RANGE(0x240000, 0x240001) AM_WRITE(buffer_spriteram16_w)
-	AM_RANGE(0x242000, 0x2427ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x244000, 0x244001) AM_WRITE(buffer_spriteram16_2_w)
-	AM_RANGE(0x246000, 0x2467ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0x240000, 0x240001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write)
+	AM_RANGE(0x242000, 0x2427ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x244000, 0x244001) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write)
+	AM_RANGE(0x246000, 0x2467ff) AM_RAM AM_SHARE("spriteram2")
 
 	AM_RANGE(0x24e6c0, 0x24e6c1) AM_READ_PORT("DSW")
 	AM_RANGE(0x24e138, 0x24e139) AM_READ_PORT("SYSTEM")
@@ -350,8 +350,6 @@
 	MCFG_CPU_PROGRAM_MAP(audio_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
@@ -364,6 +362,9 @@
 
 	MCFG_VIDEO_START(boogwing)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
+
 	MCFG_DECOCOMN_ADD("deco_common", boogwing_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", boogwing_deco16ic_tilegen1_intf)
diff -Nru src-old/mame/drivers/brkthru.c src/mame/drivers/brkthru.c
--- src-old/mame/drivers/brkthru.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/brkthru.c	2012-03-07 19:42:58.000000000 +0100
@@ -354,16 +354,9 @@
  *
  *************************************/
 
-/* handler called by the 3812 emulator when the internal timers cause an IRQ */
-static void irqhandler( device_t *device, int linestate )
-{
-	brkthru_state *state = device->machine().driver_data<brkthru_state>();
-	device_set_input_line(state->m_audiocpu, M6809_IRQ_LINE, linestate);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6809_IRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/cninja.c src/mame/drivers/cninja.c
--- src-old/mame/drivers/cninja.c	2012-01-28 16:47:35.000000000 +0100
+++ src/mame/drivers/cninja.c	2012-03-11 18:17:00.000000000 +0100
@@ -185,8 +185,8 @@
 	AM_RANGE(0x190000, 0x190007) AM_READWRITE(cninja_irq_r, cninja_irq_w)
 	AM_RANGE(0x19c000, 0x19dfff) AM_RAM_DEVWRITE("deco_common", decocomn_nonbuffered_palette_w) AM_BASE_GENERIC(paletteram)
 
-	AM_RANGE(0x1a4000, 0x1a47ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			/* Sprites */
-	AM_RANGE(0x1b4000, 0x1b4001) AM_WRITE(buffer_spriteram16_w) /* DMA flag */
+	AM_RANGE(0x1a4000, 0x1a47ff) AM_RAM AM_SHARE("spriteram")			/* Sprites */
+	AM_RANGE(0x1b4000, 0x1b4001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* DMA flag */
 	AM_RANGE(0x1bc000, 0x1bc0ff) AM_WRITE(deco16_104_cninja_prot_w) AM_BASE(&deco16_prot_ram)		/* Protection writes */
 	AM_RANGE(0x1bc000, 0x1bcfff) AM_READ(deco16_104_cninja_prot_r) AM_BASE(&deco16_prot_ram)		/* Protection device */
 
@@ -196,7 +196,7 @@
 static ADDRESS_MAP_START( cninjabl_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0bffff) AM_ROM
 
-	AM_RANGE(0x138000, 0x1387ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* bootleg sprite-ram (sprites rewritten here in new format) */
+	AM_RANGE(0x138000, 0x1387ff) AM_RAM AM_SHARE("spriteram") /* bootleg sprite-ram (sprites rewritten here in new format) */
 
 	AM_RANGE(0x140000, 0x14000f) AM_WRITE(cninja_pf12_control_w)
 	AM_RANGE(0x144000, 0x144fff) AM_DEVREADWRITE("tilegen1", deco16ic_pf1_data_r, deco16ic_pf1_data_w)
@@ -220,7 +220,7 @@
 	AM_RANGE(0x190000, 0x190007) AM_READWRITE(cninja_irq_r, cninja_irq_w)
 	AM_RANGE(0x19c000, 0x19dfff) AM_RAM_DEVWRITE("deco_common", decocomn_nonbuffered_palette_w) AM_BASE_GENERIC(paletteram)
 
-	AM_RANGE(0x1b4000, 0x1b4001) AM_WRITE(buffer_spriteram16_w) /* DMA flag */
+	AM_RANGE(0x1b4000, 0x1b4001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* DMA flag */
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( edrandy_map, AS_PROGRAM, 16 )
@@ -245,8 +245,8 @@
 	AM_RANGE(0x199750, 0x199751) AM_WRITENOP /* Looks like a bug in game code, a protection write is referenced off a5 instead of a6 and ends up here */
 
 	AM_RANGE(0x1a4000, 0x1a4007) AM_READWRITE(cninja_irq_r, cninja_irq_w)
-	AM_RANGE(0x1ac000, 0x1ac001) AM_WRITE(buffer_spriteram16_w) /* DMA flag */
-	AM_RANGE(0x1bc000, 0x1bc7ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Sprites */
+	AM_RANGE(0x1ac000, 0x1ac001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* DMA flag */
+	AM_RANGE(0x1bc000, 0x1bc7ff) AM_RAM AM_SHARE("spriteram") /* Sprites */
 	AM_RANGE(0x1bc800, 0x1bcfff) AM_WRITENOP /* Another bug in game code?  Sprite list can overrun.  Doesn't seem to mirror */
 ADDRESS_MAP_END
 
@@ -266,11 +266,11 @@
 	AM_RANGE(0x15c000, 0x15c7ff) AM_RAM AM_BASE_MEMBER(cninja_state, m_pf3_rowscroll)
 	AM_RANGE(0x15e000, 0x15e7ff) AM_RAM AM_BASE_MEMBER(cninja_state, m_pf4_rowscroll)
 
-	AM_RANGE(0x180000, 0x1807ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x180000, 0x1807ff) AM_RAM AM_SHARE("spriteram")
 //  AM_RANGE(0x18c000, 0x18c0ff) AM_WRITE(cninja_loopback_w) /* Protection writes */
 	AM_RANGE(0x18c000, 0x18c7ff) AM_READ(robocop2_prot_r) /* Protection device */
 	AM_RANGE(0x18c064, 0x18c065) AM_WRITE(cninja_sound_w)
-	AM_RANGE(0x198000, 0x198001) AM_WRITE(buffer_spriteram16_w) /* DMA flag */
+	AM_RANGE(0x198000, 0x198001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* DMA flag */
 	AM_RANGE(0x1a8000, 0x1a9fff) AM_RAM_DEVWRITE("deco_common", decocomn_nonbuffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x1b0000, 0x1b0007) AM_READWRITE(cninja_irq_r, cninja_irq_w)
 	AM_RANGE(0x1b8000, 0x1bbfff) AM_RAM AM_BASE_MEMBER(cninja_state, m_ram) /* Main ram */
@@ -281,14 +281,14 @@
 static ADDRESS_MAP_START( mutantf_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x100000, 0x103fff) AM_RAM
-	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x140000, 0x1407ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x140000, 0x1407ff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0x160000, 0x161fff) AM_RAM_DEVWRITE("deco_common", decocomn_nonbuffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x180000, 0x180001) AM_DEVWRITE("deco_common", decocomn_priority_w)
 	AM_RANGE(0x180002, 0x180003) AM_WRITENOP /* VBL irq ack */
 	AM_RANGE(0x1a0000, 0x1a07ff) AM_READWRITE(deco16_66_prot_r, deco16_66_prot_w) AM_BASE(&deco16_prot_ram) /* Protection device */
-	AM_RANGE(0x1c0000, 0x1c0001) AM_WRITE(buffer_spriteram16_w) AM_DEVREAD("deco_common", decocomn_71_r)
-	AM_RANGE(0x1e0000, 0x1e0001) AM_WRITE(buffer_spriteram16_2_w)
+	AM_RANGE(0x1c0000, 0x1c0001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) AM_DEVREAD("deco_common", decocomn_71_r)
+	AM_RANGE(0x1e0000, 0x1e0001) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write)
 
 	AM_RANGE(0x300000, 0x30000f) AM_WRITE(cninja_pf12_control_w)
 	AM_RANGE(0x304000, 0x305fff) AM_DEVREADWRITE("tilegen1", deco16ic_pf1_data_r, deco16ic_pf1_data_w)
@@ -924,8 +924,6 @@
 	MCFG_TIMER_ADD("raster_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
@@ -935,6 +933,8 @@
 	MCFG_GFXDECODE(cninja)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", cninja_deco16ic_tilegen1_intf)
@@ -978,8 +978,6 @@
 	MCFG_TIMER_ADD("raster_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
@@ -991,6 +989,8 @@
 
 	MCFG_VIDEO_START(stoneage)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", cninja_deco16ic_tilegen1_intf)
@@ -1032,8 +1032,6 @@
 	MCFG_TIMER_ADD("raster_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
@@ -1043,6 +1041,8 @@
 	MCFG_GFXDECODE(cninjabl)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", cninja_deco16ic_tilegen1_intf)
@@ -1077,8 +1077,6 @@
 	MCFG_TIMER_ADD("raster_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
@@ -1088,6 +1086,8 @@
 	MCFG_GFXDECODE(cninja)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", edrandy_deco16ic_tilegen1_intf)
@@ -1131,8 +1131,6 @@
 	MCFG_TIMER_ADD("raster_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(40*8, 32*8)
@@ -1142,6 +1140,8 @@
 	MCFG_GFXDECODE(robocop2)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", robocop2_deco16ic_tilegen1_intf)
@@ -1186,8 +1186,6 @@
 	MCFG_MACHINE_RESET(cninja)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(40*8, 32*8)
@@ -1199,6 +1197,9 @@
 	MCFG_GFXDECODE(mutantf)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
+
 	MCFG_DECOCOMN_ADD("deco_common", cninja_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", mutantf_deco16ic_tilegen1_intf)
@@ -1353,6 +1354,47 @@
 	ROM_LOAD( "mb7122h.7v", 0x00000,  0x400,  CRC(a1267336) SHA1(d11ea9d78526ac3c0dc6e57a2da5914273ad1e3f) )	/* Priority  Unused */
 ROM_END
 
+ROM_START( cninjaa )
+	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
+	ROM_LOAD16_BYTE( "1.1k",       0x00000, 0x20000, CRC(a6c40959) SHA1(01d223b76a7798d5bd8b542b9ce8e3ca203205be) )
+	ROM_LOAD16_BYTE( "4.3k",       0x00001, 0x20000, CRC(2e01d1fd) SHA1(14ba377c86535c409b7b01deddf6fb5681fa3397) )
+	ROM_LOAD16_BYTE( "2.2j",       0x40000, 0x20000, CRC(18f0527c) SHA1(17b7ea68909c7c8b819578e2039f5be4a640ea75) )
+	ROM_LOAD16_BYTE( "5.3j",       0x40001, 0x20000, CRC(ea4b6d53) SHA1(263319750524756319587b6e51dfead0265809cb) )
+	ROM_LOAD16_BYTE( "gn-00.rom",  0x80000, 0x20000, CRC(0b110b16) SHA1(a967c8aeae3f0cee1f354583cf26ee736636aaf8) )
+	ROM_LOAD16_BYTE( "gn-03.rom",  0x80001, 0x20000, CRC(1e28e697) SHA1(2313e97f3a34892dfdc338944c0f00538fcae800) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 ) /* Sound CPU */
+	ROM_LOAD( "gl-07.rom",  0x00000,  0x10000,  CRC(ca8bef96) SHA1(fcdbd598c85e339a3389a2ef58cf2d5b3a2779af) )
+
+	ROM_REGION( 0x020000, "gfx1", 0 )
+	ROM_LOAD16_BYTE( "gl-08.rom",  0x00001,  0x10000,  CRC(33a2b400) SHA1(fdb8de315f33705719c0ac03a61fb56ffbfdf597) )	/* chars */
+	ROM_LOAD16_BYTE( "gl-09.rom",  0x00000,  0x10000,  CRC(5a2d4752) SHA1(617dd10a99b5b55ca64dcdd22a0f133b0d6b770d) )
+
+	ROM_REGION( 0x080000, "gfx2", 0 )
+	ROM_LOAD( "mag-02.rom", 0x000000, 0x80000,  CRC(de89c69a) SHA1(b41bdf859854b5541c7eae7cd541b910cea1f839) )	/* tiles 3 */
+
+	ROM_REGION( 0x100000, "gfx3", 0 )
+	ROM_LOAD( "mag-00.rom", 0x000000, 0x40000,  CRC(a8f05d33) SHA1(a1330bc9ca4648219403db087622badfc632b47d) )	/* tiles 1 */
+	ROM_CONTINUE(           0x080000, 0x40000 )
+	ROM_LOAD( "mag-01.rom", 0x040000, 0x40000,  CRC(5b399eed) SHA1(490f8f9c0c557b0ba94c6019e3fe680641a0787e) )	/* tiles 2 */
+	ROM_CONTINUE(           0x0c0000, 0x40000 )
+
+	ROM_REGION( 0x200000, "gfx4", 0 )
+	ROM_LOAD16_BYTE( "mag-03.rom", 0x000000, 0x80000,  CRC(2220eb9f) SHA1(bdf0bd6e6ba375f0770b9d08a7efa32201cbb6ef) )	/* sprites */
+	ROM_LOAD16_BYTE( "mag-05.rom", 0x000001, 0x80000,  CRC(56a53254) SHA1(10940cfdc6fbe9013865107de3394ca7f782d9c7) )
+	ROM_LOAD16_BYTE( "mag-04.rom", 0x100000, 0x80000,  CRC(144b94cc) SHA1(d982508608942a714b428a2b721bf24e1627cbb6) )
+	ROM_LOAD16_BYTE( "mag-06.rom", 0x100001, 0x80000,  CRC(82d44749) SHA1(c471fa573e00c2f8ae44068439ba6d849a124c68) )
+
+	ROM_REGION( 0x40000, "oki1", 0 ) /* Oki samples */
+	ROM_LOAD( "gl-06.rom",  0x00000,  0x20000,  CRC(d92e519d) SHA1(08238f12bf7058a3965ab6348b468e3d35d4cd23) )
+
+	ROM_REGION( 0x80000, "oki2", 0 ) /* Extra Oki samples */
+	ROM_LOAD( "mag-07.rom", 0x00000,  0x80000,  CRC(08eb5264) SHA1(3e33085f00b758acfc78034dc9a75fd6921fc3fe) )	/* banked */
+
+	ROM_REGION( 1024, "proms", 0 )
+	ROM_LOAD( "mb7122h.7v", 0x00000,  0x400,  CRC(a1267336) SHA1(d11ea9d78526ac3c0dc6e57a2da5914273ad1e3f) )	/* Priority  Unused */
+ROM_END
+
 ROM_START( joemac ) /* Japan ver 1 */
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
 	ROM_LOAD16_BYTE( "gl-02-2.1k", 0x00000, 0x20000,  CRC(80da12e2) SHA1(1037ed56c15dbe1eb8bb8b70f0bc3affc1119782) )
@@ -2052,6 +2094,7 @@
 GAME( 1990, edrandyj, edrandy, edrandy,  edrandc, 0,        ROT0, "Data East Corporation", "The Cliffhanger - Edward Randy (Japan ver 3)", GAME_SUPPORTS_SAVE )
 GAME( 1991, cninja,   0,       cninja,   cninja,  cninja,   ROT0, "Data East Corporation", "Caveman Ninja (World ver 4)", GAME_SUPPORTS_SAVE )
 GAME( 1991, cninja1,  cninja,  cninja,   cninja,  cninja,   ROT0, "Data East Corporation", "Caveman Ninja (World ver 1)", GAME_SUPPORTS_SAVE )
+GAME( 1991, cninjaa,  cninja,  cninja,   cninja,  cninja,   ROT0, "Data East Corporation", "Caveman Ninja (alternate)", GAME_SUPPORTS_SAVE )
 GAME( 1991, cninjau,  cninja,  cninja,   cninjau, cninja,   ROT0, "Data East Corporation", "Caveman Ninja (US ver 4)", GAME_SUPPORTS_SAVE )
 GAME( 1991, joemac,   cninja,  cninja,   cninja,  cninja,   ROT0, "Data East Corporation", "Tatakae Genshizin Joe & Mac (Japan ver 1)", GAME_SUPPORTS_SAVE )
 GAME( 1991, stoneage, cninja,  stoneage, cninja,  stoneage, ROT0, "bootleg", "Stoneage (bootleg of Caveman Ninja)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/commando.c src/mame/drivers/commando.c
--- src-old/mame/drivers/commando.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/commando.c	2012-03-11 18:17:00.000000000 +0100
@@ -66,7 +66,7 @@
 	AM_RANGE(0xd800, 0xdbff) AM_RAM_WRITE(commando_videoram_w) AM_BASE_MEMBER(commando_state, m_videoram)
 	AM_RANGE(0xdc00, 0xdfff) AM_RAM_WRITE(commando_colorram_w) AM_BASE_MEMBER(commando_state, m_colorram)
 	AM_RANGE(0xe000, 0xfdff) AM_RAM
-	AM_RANGE(0xfe00, 0xff7f) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfe00, 0xff7f) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xff80, 0xffff) AM_RAM
 ADDRESS_MAP_END
 
@@ -259,15 +259,13 @@
 	MCFG_MACHINE_RESET(commando)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(commando)
-	MCFG_SCREEN_VBLANK_STATIC(commando)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(commando)
 	MCFG_PALETTE_LENGTH(256)
@@ -275,6 +273,8 @@
 	MCFG_PALETTE_INIT(RRRR_GGGG_BBBB)
 	MCFG_VIDEO_START(commando)
 
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
diff -Nru src-old/mame/drivers/cps1.c src/mame/drivers/cps1.c
--- src-old/mame/drivers/cps1.c	2012-02-21 19:11:26.000000000 +0100
+++ src/mame/drivers/cps1.c	2012-03-11 00:51:30.000000000 +0100
@@ -3452,12 +3452,7 @@
 	ROMX_LOAD( "lw_14.10b", 0x200002, 0x20000, CRC(82862cce) SHA1(727ca4ee55e076185b071a49afc87533fde9ec27) , ROM_SKIP(7) )	// == lw-09.12f
 	ROMX_LOAD( "lw_13.10a", 0x200003, 0x20000, CRC(b81c0e96) SHA1(09f4235786b8ff92a57112669c0385b64477eb01) , ROM_SKIP(7) )	// == lw-09.12f
 	ROMX_LOAD( "lw-06.9d",  0x200004, 0x80000, CRC(5b9edffc) SHA1(6fd8f4a3ab070733b52365ab1945bf86acb2bf62) , ROM_GROUPWORD | ROM_SKIP(6) )	// == lw-06.12e
-	ROMX_LOAD( "lw-13.10d", 0x200006, 0x80000, BAD_DUMP CRC(8e058ef5) SHA1(00f2c0050fd106276ea5398511c5861ebfbc0d10) , ROM_GROUPWORD | ROM_SKIP(6) )
-/*
-The dumper missed to dump the surface mounted ROM LW-13.10D assuming it was identical to the MASK ROM LW-13.12G taken from
-the other sets, but it could not be correct since the four EPROMs used in forgottn LW_25.10C, LW_26.10E, LW_27.11C, LW_28.11E
-doesn't match with LW-13.12G.
-*/
+	ROMX_LOAD( "lw-13.10d", 0x200006, 0x80000, CRC(8e058ef5) SHA1(00f2c0050fd106276ea5398511c5861ebfbc0d10) , ROM_GROUPWORD | ROM_SKIP(6) )	// == lw-13.12g
 	ROMX_LOAD( "lw_16.11b", 0x300002, 0x20000, CRC(40b26554) SHA1(b4b27573d6c329bc2bc4c64fd857475bf2a10877) , ROM_SKIP(7) )	// == lw-09.12f
 	ROMX_LOAD( "lw_15.11a", 0x300003, 0x20000, CRC(1b7d2e07) SHA1(0edf4d4b314fd9c29e7915d5d1adef6f9617f921) , ROM_SKIP(7) )	// == lw-09.12f
 
@@ -3485,6 +3480,49 @@
 ROM_END
 
 /* B-Board 88618B-2 */
+/* Note that this set is equivalent to forgottnu, but ROMs use the 88618B-2 B-Board layout. */
+ROM_START( forgottnu1 )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )
+	ROM_LOAD16_BYTE( "lw11c.14f",      0x00000, 0x20000, CRC(e62742b6) SHA1(39dd3bdd405a8217d8816567d4f2014fc77f5ce8) )
+	ROM_LOAD16_BYTE( "lw15c.14g",      0x00001, 0x20000, CRC(1b70f216) SHA1(f200f615dca8aa23d166e74b8baa9a8863ee7a95) )
+	ROM_LOAD16_BYTE( "lw10c.13f",      0x40000, 0x20000, CRC(8f5ea3f5) SHA1(c3e43659bd7e03ec3d5c79647db380bde391b0f1) )
+	ROM_LOAD16_BYTE( "lw14c.13g",      0x40001, 0x20000, CRC(708e7472) SHA1(44f82db41ffd1eece2d3f3c977f481fd84dfdbf3) )
+	ROM_LOAD16_WORD_SWAP( "lw-07.13e", 0x80000, 0x80000, CRC(fd252a26) SHA1(5cfb097984912a5167a8c7ec4c2e119b642f9970) )
+
+	ROM_REGION( 0x400000, "gfx", 0 )
+	ROMX_LOAD( "lw-01.9d",  0x000000, 0x80000, CRC(0318f298) SHA1(178ffd6da7bf845e30abf1bfc38a469cd319a73f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-08.9f",  0x000002, 0x80000, CRC(25a8e43c) SHA1(d57cee1fc508db2677e84882fb814e4d9ad20543) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-05.9e",  0x000004, 0x80000, CRC(e4552fd7) SHA1(11147afc475904848458425661473586dd6f60cc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-12.9g",  0x000006, 0x80000, CRC(8e6a832b) SHA1(d63a1331fda2365f090fa31950098f321a720ea8) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-02.12d", 0x200000, 0x80000, CRC(43e6c5c8) SHA1(d3e6c971de0477ec4e178adc82508208dd8b397f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-09.12f", 0x200002, 0x80000, CRC(899cb4ad) SHA1(95e61af338945e690f2a82746feba3871ea224eb) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-06.12e", 0x200004, 0x80000, CRC(5b9edffc) SHA1(6fd8f4a3ab070733b52365ab1945bf86acb2bf62) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "lw-13.12g", 0x200006, 0x80000, CRC(8e058ef5) SHA1(00f2c0050fd106276ea5398511c5861ebfbc0d10) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( 0x8000, "stars", 0 )
+	ROM_COPY( "gfx", 0x200000, 0x000000, 0x8000 )
+
+	ROM_REGION( 0x18000, "audiocpu", 0 )
+	ROM_LOAD( "lw_00.14a",  0x00000, 0x08000, CRC(59df2a63) SHA1(dfe1fffc7a17179a80a2ae623e93b30a7d6df20d) )	// == lw_00b.14a
+	ROM_CONTINUE(           0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "lw-03u.14c", 0x00000, 0x20000, CRC(807d051f) SHA1(720e4733787b9b11f4d1cdce0892b69475802844) )
+	ROM_LOAD( "lw-04u.13c", 0x20000, 0x20000, CRC(e6cd098e) SHA1(667f6e5736f76a1c4c450c4e2035574ea89d7910) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "lwchr.3a",     0x0000, 0x0117, CRC(54ed4c39) SHA1(961309335dc1c84482ebe99ea938b32d3a6ae9a8) )
+	ROM_LOAD( "lwio.15e",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )
+ROM_END
+
+/* B-Board 88618B-2 */
 ROM_START( forgottnua )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )
 	ROM_LOAD16_BYTE( "lwu_11a.14f",    0x00000, 0x20000, CRC(ddf78831) SHA1(b9c815613efdfde933d4500b588798b7fb4c1854) )
@@ -4229,7 +4267,7 @@
 	ROM_LOAD16_BYTE( "wlu_30.11f",     0x00000, 0x20000, CRC(d604dbb1) SHA1(b5d78871011ff11a67f1a0cad147cd4de8d67f35) )
 	ROM_LOAD16_BYTE( "35.11h",         0x00001, 0x20000, CRC(7a791e77) SHA1(fe1429588b7eceab1d369abe03f2cad8de727f71) )
 	ROM_LOAD16_BYTE( "wlu_31.12f",     0x40000, 0x20000, CRC(0eb48a83) SHA1(28c40c4b5d767f88922cd899e948abf11a85a864) )
-	ROM_LOAD16_BYTE( "wl_36.12h",      0x40001, 0x20000, CRC(36100209) SHA1(63c9338e71dba8b52daffba50b4bca31aaa10d9e) )
+	ROM_LOAD16_BYTE( "wlu_36.12h",     0x40001, 0x20000, CRC(36100209) SHA1(63c9338e71dba8b52daffba50b4bca31aaa10d9e) )	/* seen the same pcb with WL_36.12H */
 	ROM_LOAD16_WORD_SWAP( "wlm-32.8h", 0x80000, 0x80000, CRC(dfd9f643) SHA1(9c760c30af593a87e7fd39fb213a4c73c68ca440) )
 
 	ROM_REGION( 0x400000, "gfx", 0 )
@@ -4275,7 +4313,7 @@
 	ROM_LOAD16_BYTE( "wlu_30.11f",     0x00000, 0x20000, CRC(d604dbb1) SHA1(b5d78871011ff11a67f1a0cad147cd4de8d67f35) )
 	ROM_LOAD16_BYTE( "wlu_35.11h",     0x00001, 0x20000, CRC(daee72fe) SHA1(2ec62f44394fac2887821881f56b6f24d05234b3) )
 	ROM_LOAD16_BYTE( "wlu_31.12f",     0x40000, 0x20000, CRC(0eb48a83) SHA1(28c40c4b5d767f88922cd899e948abf11a85a864) )
-	ROM_LOAD16_BYTE( "wlu_36.12h",     0x40001, 0x20000, CRC(36100209) SHA1(63c9338e71dba8b52daffba50b4bca31aaa10d9e) )	// == wl_36.12h
+	ROM_LOAD16_BYTE( "wlu_36.12h",     0x40001, 0x20000, CRC(36100209) SHA1(63c9338e71dba8b52daffba50b4bca31aaa10d9e) )
 	ROM_LOAD16_WORD_SWAP( "wlm-32.8h", 0x80000, 0x80000, CRC(dfd9f643) SHA1(9c760c30af593a87e7fd39fb213a4c73c68ca440) )
 
 	ROM_REGION( 0x400000, "gfx", 0 )
@@ -4370,7 +4408,7 @@
 	ROM_LOAD( "lwio.12c",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )
 ROM_END
 
-/* B-Board 89624B-3 */
+/* B-Board 89624B-2 */
 ROM_START( unsquad )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_BYTE( "aru_30.11f",     0x00000, 0x20000, CRC(24d8f88d) SHA1(9c39aa1140e92307d6d9c0ca198003282bf78c78) )
@@ -4380,17 +4418,17 @@
 	ROM_LOAD16_WORD_SWAP( "ar-32m.8h", 0x80000, 0x80000, CRC(ae1d7fb0) SHA1(bb51e77574db5e2d807c4ca8e85a5d9661f5d3b3) )
 
 	ROM_REGION( 0x200000, "gfx", 0 )
-	ROMX_LOAD( "ar-5m.7a", 0x000000, 0x80000, CRC(bf4575d8) SHA1(1b268e1698be8ff9c16f80f7b9081b6be9f72601) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "ar-7m.9a", 0x000002, 0x80000, CRC(a02945f4) SHA1(ff35cdbd6c1e43b16a906f68e416559cb3d5746b) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "ar-1m.3a", 0x000004, 0x80000, CRC(5965ca8d) SHA1(49abf80fc012a7f73306139a2871aeac7fd6a3d0) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "ar-3m.5a", 0x000006, 0x80000, CRC(ac6db17d) SHA1(78eef9ba6a392859f70467f6d7cb5aa91964abed) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ar-5m.7a",  0x000000, 0x80000, CRC(bf4575d8) SHA1(1b268e1698be8ff9c16f80f7b9081b6be9f72601) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ar-7m.9a",  0x000002, 0x80000, CRC(a02945f4) SHA1(ff35cdbd6c1e43b16a906f68e416559cb3d5746b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ar-1m.3a",  0x000004, 0x80000, CRC(5965ca8d) SHA1(49abf80fc012a7f73306139a2871aeac7fd6a3d0) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ar-3m.5a",  0x000006, 0x80000, CRC(ac6db17d) SHA1(78eef9ba6a392859f70467f6d7cb5aa91964abed) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "ar_09.12b", 0x00000, 0x08000, CRC(f3dd1367) SHA1(09eef72e862ac6b1a5cce5a45938b45bf4e456ad) )
-	ROM_CONTINUE(          0x10000, 0x08000 )
+	ROM_LOAD( "ar_09.12b",  0x00000, 0x08000, CRC(f3dd1367) SHA1(09eef72e862ac6b1a5cce5a45938b45bf4e456ad) )
+	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "ar_18.11c", 0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )
+	ROM_LOAD( "aru_18.11c", 0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )
 	/* 20000-3ffff empty */
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
@@ -4440,7 +4478,7 @@
 	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "ar_30.12e",  0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )	// == ar_18.11c
+	ROM_LOAD( "ar_30.12e",  0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )	// == aru_18.11c
 	/* 20000-3ffff empty */
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
@@ -4472,7 +4510,7 @@
 	ROM_CONTINUE(           0x10000, 0x18000 )	// second half of ROM is unused, not mapped in memory
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "ara_18.11c", 0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )	// == ar_18.11c
+	ROM_LOAD( "ara_18.11c", 0x00000, 0x20000, CRC(584b43a9) SHA1(7820815c8c67d484baf2fdad7e55d8c14b98b860) )	// == aru_18.11c
 	/* 20000-3ffff empty */
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
@@ -4524,7 +4562,42 @@
 
 	ROM_REGION( 0x0200, "bboardplds", 0 )
 	ROM_LOAD( "s224b.1a",     0x0000, 0x0117, CRC(4e85b158) SHA1(0476840361fb8bcfacc60a213dbbc58bf242431e) )
-	ROM_LOAD( "iob1.11e",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "iob1.11e",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )	/* seen the same pcb with LWIO.11E */
+ROM_END
+
+/* B-Board 89624B-3 */
+ROM_START( ffighta )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_BYTE( "ffe_30.11f",     0x00000, 0x20000, CRC(2347bf51) SHA1(de05b347a8b4df4889d4e594e1abf741afdf0ab4) )
+	ROM_LOAD16_BYTE( "ffe_35.11h",     0x00001, 0x20000, CRC(5f694ecc) SHA1(57c45ffcada0cdaf1f97c7e33c8300539828a238) )
+	ROM_LOAD16_BYTE( "ffe_31.12f",     0x40000, 0x20000, CRC(6dc6b792) SHA1(553abebed2a1fa1ee2d85a4117f40d90e2321cea) )
+	ROM_LOAD16_BYTE( "ffe_36.12h",     0x40001, 0x20000, CRC(b36a0b99) SHA1(cfb27987ee3d54c83c6fb73437a79dcdd96df22f) )
+	ROM_LOAD16_WORD_SWAP( "ff-32m.8h", 0x80000, 0x80000, CRC(c747696e) SHA1(d3362dadded31ccb7eaf71ef282d698d18edd722) )
+
+	ROM_REGION( 0x200000, "gfx", 0 )
+	ROMX_LOAD( "ff-5m.7a",  0x000000, 0x80000, CRC(9c284108) SHA1(7868f5801347340867720255f8380548ad1a65a7) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ff-7m.9a",  0x000002, 0x80000, CRC(a7584dfb) SHA1(f7b00a3ca8cb85264ab293089f9f540a8292b49c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ff-1m.3a",  0x000004, 0x80000, CRC(0b605e44) SHA1(5ce16af72858a57aefbf6efed820c2c51935882a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ff-3m.5a",  0x000006, 0x80000, CRC(52291cd2) SHA1(df5f3d3aa96a7a33ff22f2a31382942c4c4f1111) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "ffe_23.12b", 0x00000, 0x08000, CRC(b8367eb5) SHA1(ec3db29fdd6200e9a8f4f8073a7e34aef731354f) )	// == ff_09.12b /* label is FFE_23, pcb verified */
+	ROM_CONTINUE(           0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "ff_18.11c",  0x00000, 0x20000, CRC(375c66e7) SHA1(36189e23209ce4ae5d9cbabd1574540d0591e7b3) )
+	ROM_LOAD( "ff_19.12c",  0x20000, 0x20000, CRC(1ef137f9) SHA1(974b5e72aa28b87ebfa7438efbdfeda769dedf5e) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "s224b.1a",     0x0000, 0x0117, CRC(4e85b158) SHA1(0476840361fb8bcfacc60a213dbbc58bf242431e) )
+	ROM_LOAD( "lwio.11e",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )
 ROM_END
 
 /* B-Board 89624B-3 */
@@ -5686,7 +5759,7 @@
 	ROMX_LOAD( "sf2-11m.5d", 0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "22" socket
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )	// missing sticker, could be sf2_09.12a
+	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )
 	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
@@ -5955,7 +6028,7 @@
 	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
-/* B-Board 90629B-? */
+/* B-Board 90629B-3 */
 ROM_START( sf2ud )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_BYTE( "sf2u_30d.11e", 0x00000, 0x20000, CRC(4bb2657c) SHA1(b2d077296b77be7db371f953b7fc446a67d8a9d6) )
@@ -5982,7 +6055,7 @@
 	ROMX_LOAD( "sf2-11m.5d", 0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "22" socket
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )	// could be sf2_09.12a
+	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )	// missing sticker, could be sf2_09.12a
 	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
@@ -6105,6 +6178,55 @@
 ROM_END
 
 /* B-Board 90629B-3 */
+ROM_START( sf2ug )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_BYTE( "sf2u_30g.11e", 0x00000, 0x20000, CRC(fe39ee33) SHA1(22558eb15e035b09b80935a32b8425d91cd79669) )	// == sf2e_30g.11e
+	ROM_LOAD16_BYTE( "sf2u_37g.11f", 0x00001, 0x20000, CRC(5886cae7) SHA1(8a621d267dfcf5d214b1bbec12b98a06153c86d3) )
+	ROM_LOAD16_BYTE( "sf2u_31g.12e", 0x40000, 0x20000, CRC(69a0a301) SHA1(86a3954335310865b14ce8b4e0e4499feb14fc12) )	// == sf2e_31g.12e
+	ROM_LOAD16_BYTE( "sf2u_38g.12f", 0x40001, 0x20000, CRC(5e22db70) SHA1(6565946591a18eaf46f04c1aa449ee0ae9ac2901) )	// == sf2e_38g.12f
+	ROM_LOAD16_BYTE( "sf2u_28g.9e",  0x80000, 0x20000, CRC(8bf9f1e5) SHA1(bbcef63f35e5bff3f373968ba1278dd6bd86b593) )	// == sf2e_28g.9e
+	ROM_LOAD16_BYTE( "sf2u_35g.9f",  0x80001, 0x20000, CRC(626ef934) SHA1(507bda3e4519de237aca919cf72e543403ec9724) )	// == sf2e_35g.9f
+	ROM_LOAD16_BYTE( "sf2_29b.10e",  0xc0000, 0x20000, CRC(bb4af315) SHA1(75f0827f4f7e9f292add46467f8d4fe19b2514c9) )
+	ROM_LOAD16_BYTE( "sf2_36b.10f",  0xc0001, 0x20000, CRC(c02a13eb) SHA1(b807cc495bff3f95d03b061fc629c95f965cb6d8) )
+
+	ROM_REGION( 0x600000, "gfx", 0 )
+	ROMX_LOAD( "sf2-5m.4a",  0x000000, 0x80000, CRC(22c9cc8e) SHA1(b9194fb337b30502c1c9501cd6c64ae4035544d4) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "2" socket
+	ROMX_LOAD( "sf2-7m.6a",  0x000002, 0x80000, CRC(57213be8) SHA1(3759b851ac0904ec79cbb67a2264d384b6f2f9f9) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "4" socket
+	ROMX_LOAD( "sf2-1m.3a",  0x000004, 0x80000, CRC(ba529b4f) SHA1(520840d727161cf09ca784919fa37bc9b54cc3ce) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "1" socket
+	ROMX_LOAD( "sf2-3m.5a",  0x000006, 0x80000, CRC(4b1b33a8) SHA1(2360cff890551f76775739e2d6563858bff80e41) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "3" socket
+	ROMX_LOAD( "sf2-6m.4c",  0x200000, 0x80000, CRC(2c7e2229) SHA1(357c2275af9133fd0bd6fbb1fa9ad5e0b490b3a2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "11" socket
+	ROMX_LOAD( "sf2-8m.6c",  0x200002, 0x80000, CRC(b5548f17) SHA1(baa92b91cf616bc9e2a8a66adc777ffbf962a51b) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "13" socket
+	ROMX_LOAD( "sf2-2m.3c",  0x200004, 0x80000, CRC(14b84312) SHA1(2eea16673e60ba7a10bd4d8f6c217bb2441a5b0e) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "10" socket
+	ROMX_LOAD( "sf2-4m.5c",  0x200006, 0x80000, CRC(5e9cd89a) SHA1(f787aab98668d4c2c54fc4ba677c0cb808e4f31e) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "12" socket
+	ROMX_LOAD( "sf2-13m.4d", 0x400000, 0x80000, CRC(994bfa58) SHA1(5669b845f624b10e7be56bfc89b76592258ce48b) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "21" socket
+	ROMX_LOAD( "sf2-15m.6d", 0x400002, 0x80000, CRC(3e66ad9d) SHA1(9af9df0826988872662753e9717c48d46f2974b0) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "23" socket
+	ROMX_LOAD( "sf2-9m.3d",  0x400004, 0x80000, CRC(c1befaa8) SHA1(a6a7f4725e52678cbd8d557285c01cdccb2c2602) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "20" socket
+	ROMX_LOAD( "sf2-11m.5d", 0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "22" socket
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )
+	ROM_CONTINUE(            0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "sf2_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
+	ROM_LOAD( "sf2_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "stf29.1a",     0x0000, 0x0117, CRC(043309c5) SHA1(f6b9610c9f896c495041ba56a654776a521c356b) )
+	ROM_LOAD( "iob1.11d",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
+/* B-Board 90629B-3 */
 ROM_START( sf2ui )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_BYTE( "sf2u_30i.11e", 0x00000, 0x20000, CRC(fe39ee33) SHA1(22558eb15e035b09b80935a32b8425d91cd79669) )	// == sf2e_30g.11e
@@ -6635,7 +6757,6 @@
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
 	ROM_LOAD( "rt_23.13b",  0x00000, 0x08000, CRC(abfca165) SHA1(428069d3bdc45775854cd0e8abe447f134fe5492) )	// == rt_9.12b
-//  ROM_LOAD( "rt_23.13b",  0x00000, 0x08000, CRC(7d5a77a7) SHA1(4f2a6534d7a9e518061102c1dd7d7aca39600c33) )    // one byte different, verification required
 	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
@@ -7684,11 +7805,57 @@
 ROM_END
 
 /* B-Board 91634B-2 */
-ROM_START( sf2cej )
+ROM_START( sf2cejc )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "s92j_23c.8f", 0x000000, 0x80000, CRC(f0120635) SHA1(5e4a9a4b0f65c6139e76ee4ffa02b9db245b1858) )
+	ROM_LOAD16_WORD_SWAP( "s92j_22c.7f", 0x080000, 0x80000, CRC(8c0b2ed6) SHA1(408db039b4dad72b41458723575ed5352b71e10b) )
+	ROM_LOAD16_WORD_SWAP( "s92j_21a.6f", 0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
+
+	ROM_REGION( 0x600000, "gfx", 0 )
+	ROMX_LOAD( "s92_01.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-1m.3a
+	ROMX_LOAD( "s92_02.4a",  0x000002, 0x80000, CRC(840289ec) SHA1(2fb42a242f60ba7e74009b5a90eb26e035ba1e82) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-3m.5a
+	ROMX_LOAD( "s92_03.5a",  0x000004, 0x80000, CRC(cdb5f027) SHA1(4c7d944fef200fdfcaf57758b901b5511188ed2e) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-2m.4a
+	ROMX_LOAD( "s92_04.6a",  0x000006, 0x80000, CRC(e2799472) SHA1(27d3796429338d82a8de246a0ea06dd487a87768) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-4m.6a
+	ROMX_LOAD( "s92_05.7a",  0x200000, 0x80000, CRC(ba8a2761) SHA1(4b696d66c51611e43522bed752654314e76d33b6) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-5m.7a
+	ROMX_LOAD( "s92_06.8a",  0x200002, 0x80000, CRC(e584bfb5) SHA1(ebdf1f5e2638eed3a65dda82b1ed9151a355f4c9) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-7m.9a
+	ROMX_LOAD( "s92_07.9a",  0x200004, 0x80000, CRC(21e3f87d) SHA1(4a4961bb68c3a1ce15f9d393d9c03ecb2466cc29) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-6m.8a
+	ROMX_LOAD( "s92_08.10a", 0x200006, 0x80000, CRC(befc47df) SHA1(520390420da3a0271ba90b0a933e65143265e5cf) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-8m.10a
+	ROMX_LOAD( "s92_10.3c",  0x400000, 0x80000, CRC(960687d5) SHA1(2868c31121b1c7564e9767b9a19cdbf655c7ed1d) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-10m.3c
+	ROMX_LOAD( "s92_11.4c",  0x400002, 0x80000, CRC(978ecd18) SHA1(648a59706b93c84b4206a968ecbdc3e834c476f6) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-12m.5c
+	ROMX_LOAD( "s92_12.5c",  0x400004, 0x80000, CRC(d6ec9a0a) SHA1(ed6143f8737013b6ef1684e37c05e037e7a80dae) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-11m.4c
+	ROMX_LOAD( "s92_13.6c",  0x400006, 0x80000, CRC(ed2c67f6) SHA1(0083c0ffaf6fe7659ff0cf822be4346cd6e61329) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-13m.6c
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "s92_09.12a",  0x00000, 0x08000, CRC(08f6b60e) SHA1(8258fcaca4ac419312531eec67079b97f471179c) )	// == s92_09.11a
+	ROM_CONTINUE(            0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "s92_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
+	ROM_LOAD( "s92_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "s9263b.1a",    0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "iob1.12d",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "bprg1.11d",    0x0000, 0x0117, CRC(31793da7) SHA1(400fa7ac517421c978c1ee7773c30b9ed0c5d3f3) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
+/* B-Board 91634B-2 */
+ROM_START( sf2cejb )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "s92j_23b.8f", 0x000000, 0x80000, CRC(140876c5) SHA1(304630e6d8bae9f8d29090e05f7e013c7dafe9cc) )
 	ROM_LOAD16_WORD_SWAP( "s92j_22b.7f", 0x080000, 0x80000, CRC(2fbb3bfe) SHA1(e364564a12022730c2c0d0e8fd435e2c30ef9410) )
-	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )	// could be s92j_21a.6f
+	ROM_LOAD16_WORD_SWAP( "s92j_21a.6f", 0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
 
 	ROM_REGION( 0x600000, "gfx", 0 )
 	ROMX_LOAD( "s92_01.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-1m.3a
@@ -7734,7 +7901,7 @@
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "s92j_23a.8f", 0x000000, 0x80000, CRC(4f42bb5a) SHA1(59d0587c554e06ea45d4092ea4299ff086509d4b) )
 	ROM_LOAD16_WORD_SWAP( "s92j_22a.7f", 0x080000, 0x80000, CRC(c4f64bcd) SHA1(262c0419bf727da80c2ac52b877a19276d9aac3c) )
-	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )	// could be s92j_21a.6f
+	ROM_LOAD16_WORD_SWAP( "s92j_21a.6f", 0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
 
 	ROM_REGION( 0x600000, "gfx", 0 )
 	ROMX_LOAD( "s92_01.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-1m.3a
@@ -8388,7 +8555,7 @@
 
 	ROM_REGION( 0x0200, "bboardplds", 0 )
 	ROM_LOAD( "q522b.1a",     0x0000, 0x0117, NO_DUMP )
-	ROM_LOAD( "lwio.12e",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )
+	ROM_LOAD( "lwio.12e",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )	/* seen the same pcb with IOB1.12E */
 
 	ROM_REGION( 0x0200, "cboardplds", 0 )
 	ROM_LOAD( "ioc1.ic1",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
@@ -8565,17 +8732,17 @@
 	ROM_LOAD16_BYTE( "qdu_43a.13h", 0x40001, 0x20000, CRC(15e6beb9) SHA1(68d11e9bdd82775060281c5880f249e3515dc235) )
 
 	ROM_REGION( 0x200000, "gfx", 0 )
-	ROMX_LOAD( "qdu_09.4b", 0x000000, 0x20000, CRC(8c3f9f44) SHA1(b5ab20515b7f3e7db023be42d4c7ed1941b37d9b) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_01.4a", 0x000001, 0x20000, CRC(f688cf8f) SHA1(1b20095e536a24406513715cded249c9be1aa1d2) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_13.9b", 0x000002, 0x20000, CRC(afbd551b) SHA1(02e2f12196c542a004325689bda8949213ef0333) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_05.9a", 0x000003, 0x20000, CRC(c3db0910) SHA1(cf3aa3d3b64031dea92a80e5650151315cf871bf) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_24.5e", 0x000004, 0x20000, CRC(2f1bd0ec) SHA1(017e0dc521bf402c700775ee06cbc124f7ce0e3f) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_17.5c", 0x000005, 0x20000, CRC(a812f9e2) SHA1(9b7ceb347fbe00c40338b97ee6e8e4d1db9e7cb3) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_38.8h", 0x000006, 0x20000, CRC(ccdddd1f) SHA1(8304c4cdfaa1ae6b37e2733e9a6ddce9252fd43a) , ROM_SKIP(7) )
-	ROMX_LOAD( "qdu_32.8f", 0x000007, 0x20000, CRC(a8d295d3) SHA1(d4d0bdaeb40f652ef33b317cb2b566b4c3550242) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_09.4b",  0x000000, 0x20000, CRC(8c3f9f44) SHA1(b5ab20515b7f3e7db023be42d4c7ed1941b37d9b) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_01.4a",  0x000001, 0x20000, CRC(f688cf8f) SHA1(1b20095e536a24406513715cded249c9be1aa1d2) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_13.9b",  0x000002, 0x20000, CRC(afbd551b) SHA1(02e2f12196c542a004325689bda8949213ef0333) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_05.9a",  0x000003, 0x20000, CRC(c3db0910) SHA1(cf3aa3d3b64031dea92a80e5650151315cf871bf) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_24.5e",  0x000004, 0x20000, CRC(2f1bd0ec) SHA1(017e0dc521bf402c700775ee06cbc124f7ce0e3f) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_17.5c",  0x000005, 0x20000, CRC(a812f9e2) SHA1(9b7ceb347fbe00c40338b97ee6e8e4d1db9e7cb3) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_38.8h",  0x000006, 0x20000, CRC(ccdddd1f) SHA1(8304c4cdfaa1ae6b37e2733e9a6ddce9252fd43a) , ROM_SKIP(7) )
+	ROMX_LOAD( "qd_32.8f",  0x000007, 0x20000, CRC(a8d295d3) SHA1(d4d0bdaeb40f652ef33b317cb2b566b4c3550242) , ROM_SKIP(7) )
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "qdu_23.13b", 0x00000, 0x08000, CRC(cfb5264b) SHA1(e662ed5555d02ccf4e62cdbcfa0bbfc019734ee1) )
+	ROM_LOAD( "qd_23.13b",  0x00000, 0x08000, CRC(cfb5264b) SHA1(e662ed5555d02ccf4e62cdbcfa0bbfc019734ee1) )
 	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
@@ -8591,7 +8758,7 @@
 
 	ROM_REGION( 0x0200, "bboardplds", 0 )
 	ROM_LOAD( "qd22b.1a",     0x0000, 0x0117, CRC(783c53ab) SHA1(1bf87e5fe7e7cbcec0d76ed094dcac823e45af14) )
-	ROM_LOAD( "iob1.12e",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "iob1.12e",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )	/* seen the same pcb with LWIO.12E */
 
 	ROM_REGION( 0x0200, "cboardplds", 0 )
 	ROM_LOAD( "ioc1.ic1",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
@@ -9419,7 +9586,7 @@
 	ROM_LOAD( "d10f1.10f",    0x0000, 0x0117, CRC(6619c494) SHA1(3aef656c07182a2186f810f30e0d854dd5bd8d18) )
 ROM_END
 
-/* FIXME B-Board uncertain but should be 91634B from the program ROM names */
+/* B-Board 91634B-2 */
 ROM_START( punisherj )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "psj_23.8f", 0x000000, 0x80000, CRC(6b2fda52) SHA1(5f95a79b7b802609ae9ddd6641cc52610d428bf4) )
@@ -10641,8 +10808,9 @@
 
 
 GAME( 1988, forgottn,    0,        cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (World)", GAME_SUPPORTS_SAVE )	// (c) Capcom U.S.A. but World "warning"
-GAME( 1988, forgottnu,   forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (USA, B-Board 88621B-2)", GAME_SUPPORTS_SAVE )
-GAME( 1988, forgottnua,  forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (USA, B-Board 88618B-2)", GAME_SUPPORTS_SAVE )
+GAME( 1988, forgottnu,   forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (USA, B-Board 88621B-2, Rev. C)", GAME_SUPPORTS_SAVE )
+GAME( 1988, forgottnu1,  forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (USA, B-Board 88618B-2, Rev. C)", GAME_SUPPORTS_SAVE )
+GAME( 1988, forgottnua,  forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Forgotten Worlds (USA, B-Board 88618B-2, Rev. A)", GAME_SUPPORTS_SAVE )
 GAME( 1988, lostwrld,    forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Lost Worlds (Japan)", GAME_SUPPORTS_SAVE )
 GAME( 1988, lostwrldo,   forgottn, cps1_10MHz, forgottn,   forgottn, ROT0,   "Capcom", "Lost Worlds (Japan Old Ver.)", GAME_SUPPORTS_SAVE )
 GAME( 1988, ghouls,      0,        cps1_10MHz, ghouls,     cps1,     ROT0,   "Capcom", "Ghouls'n Ghosts (World)", GAME_SUPPORTS_SAVE )	// "EXPORT" // Wed.26.10.1988 in the ROMs
@@ -10663,7 +10831,8 @@
 GAME( 1989, unsquad,     0,        cps1_10MHz, unsquad,    cps1,     ROT0,   "Capcom / Daipro", "U.N. Squadron (USA)", GAME_SUPPORTS_SAVE )
 GAME( 1989, area88,      unsquad,  cps1_10MHz, unsquad,    cps1,     ROT0,   "Capcom / Daipro", "Area 88 (Japan)", GAME_SUPPORTS_SAVE )
 GAME( 1989, area88r,     unsquad,  cps1_12MHz, unsquad,    cps1,     ROT0,   "Capcom / Daipro", "Area 88 (Japan Resale Ver.)", GAME_SUPPORTS_SAVE )	// 12MHz verified
-GAME( 1989, ffight,      0,        cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (World)", GAME_SUPPORTS_SAVE )
+GAME( 1989, ffight,      0,        cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (World, set 1)", GAME_SUPPORTS_SAVE )
+GAME( 1989, ffighta,     ffight,   cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (World, set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1989, ffightu,     ffight,   cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (USA, set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1989, ffightu1,    ffight,   cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (USA, set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1989, ffightua,    ffight,   cps1_10MHz, ffight,     cps1,     ROT0,   "Capcom", "Final Fight (USA 900112)", GAME_SUPPORTS_SAVE )
@@ -10700,7 +10869,8 @@
 GAME( 1991, sf2ud,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910318)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2ue,       sf2,      cps1_10MHz, sf2,        sf2ee,    ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910228)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2uf,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910411)", GAME_SUPPORTS_SAVE )
-GAME( 1991, sf2ui,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910522)", GAME_SUPPORTS_SAVE )
+GAME( 1991, sf2ug,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910522, Rev. G)", GAME_SUPPORTS_SAVE )
+GAME( 1991, sf2ui,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910522, Rev. I)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2uk,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 911101)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2j,        sf2,      cps1_10MHz, sf2j,       cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (Japan 911210)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2ja,       sf2,      cps1_10MHz, sf2j,       cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (Japan 910214)", GAME_SUPPORTS_SAVE )
@@ -10733,8 +10903,9 @@
 GAME( 1992, sf2ceua,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920313)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceub,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920513)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceuc,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920803)", GAME_SUPPORTS_SAVE )
-GAME( 1992, sf2cej,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920513)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceja,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920322)", GAME_SUPPORTS_SAVE )
+GAME( 1992, sf2cejb,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920513)", GAME_SUPPORTS_SAVE )
+GAME( 1992, sf2cejc,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (Japan 920803)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2rb,       sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 1, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
 GAME( 1992, sf2rb2,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 2, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
 GAME( 1992, sf2rb3,      sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II': Champion Edition (Rainbow set 3, bootleg)", GAME_SUPPORTS_SAVE )			// 920322 - based on World version
diff -Nru src-old/mame/drivers/cps2.c src/mame/drivers/cps2.c
--- src-old/mame/drivers/cps2.c	2012-02-21 19:11:26.000000000 +0100
+++ src/mame/drivers/cps2.c	2012-02-28 01:04:12.000000000 +0100
@@ -4846,6 +4846,37 @@
 	ROM_LOAD16_WORD_SWAP( "vph.12m",   0x200000, 0x200000, CRC(fbd3cd90) SHA1(4813c25802ad71b77ca04fd8f3a86344f99f0d6a) )
 ROM_END
 
+ROM_START( vhuntjr1s )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "vphjstop.03b", 0x000000, 0x80000,CRC(9c4e6191) SHA1(a247beae3400583d5bf950b7c856befef45d3ad6) ) // should be 03c?, handwritten label..
+	ROM_LOAD16_WORD_SWAP( "vphj.04c", 0x080000, 0x80000, CRC(c95cf304) SHA1(0544ab9d0f398b558e1119d94885058ad4a7d929) )
+	ROM_LOAD16_WORD_SWAP( "vphj.05d", 0x100000, 0x80000, CRC(50de5ddd) SHA1(2bcc6c254ead06e9ea0a9ae4348195d3d55de277) )
+	ROM_LOAD16_WORD_SWAP( "vphj.06c", 0x180000, 0x80000, CRC(ac3bd3d5) SHA1(c0aa04c43dba2876d97d95fffd4766a28193b300) )
+	ROM_LOAD16_WORD_SWAP( "vphj.07b", 0x200000, 0x80000, CRC(0761309f) SHA1(7c6f9ec4d93ea9dbd634142558baaaf170cd4c76) )
+	ROM_LOAD16_WORD_SWAP( "vphj.08b", 0x280000, 0x80000, CRC(5a5c2bf5) SHA1(296c6a5a0062b58bc71a297bc8b27eea099c8518) )
+	ROM_LOAD16_WORD_SWAP( "vphj.09b", 0x300000, 0x80000, CRC(823d6d99) SHA1(17be75b2ebfbf60a2141aef67c386454d23565f2) )
+	ROM_LOAD16_WORD_SWAP( "vphj.10b", 0x380000, 0x80000, CRC(32c7d8f0) SHA1(47075fa80ceff6adfa6cc58dbe32ed4ee01ba4fc) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "vph.13m",   0x0000000, 0x400000, CRC(c51baf99) SHA1(2fb6642908e542e404391eb17392f8270e87bf48) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.15m",   0x0000002, 0x400000, CRC(3ce83c77) SHA1(93369b23c6d7d834297434691bb047ee3dd9539c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.17m",   0x0000004, 0x400000, CRC(4f2408e0) SHA1(cd49c6b3c7e6470c6058f98ccc5210b052bb13e2) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.19m",   0x0000006, 0x400000, CRC(9ff60250) SHA1(d69ba4dc6bd37d003245f0cf3211d6e2623005b8) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.14m",   0x1000000, 0x400000, CRC(7a0e1add) SHA1(6b28a91bd59bba97886fdea30116a5b1071109ed) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.16m",   0x1000002, 0x400000, CRC(2f41ca75) SHA1(f4a67e60b62001e6fe75cb05b9c81040a8a09f54) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.18m",   0x1000004, 0x400000, CRC(64498eed) SHA1(d64e54a9ad1cbb927b7bac2eb16e1487834c5706) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vph.20m",   0x1000006, 0x400000, CRC(17f2433f) SHA1(0cbf8c96f92016fefb4a9c668ce5fd260342d712) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "vph.01",   0x00000, 0x08000, CRC(5045dcac) SHA1(fd1a6586fbdd48a707df1fa52309b4cf50e3cc4c) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "vph.02",   0x28000, 0x20000, CRC(86b60e59) SHA1(197d07ced8b9850729c83fa59b7afc283500bdee) )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "vph.11m",   0x000000, 0x200000, CRC(e1837d33) SHA1(e3cb69f64767bacbec7286d0b4cd0ce7a0ba13d8) )
+	ROM_LOAD16_WORD_SWAP( "vph.12m",   0x200000, 0x200000, CRC(fbd3cd90) SHA1(4813c25802ad71b77ca04fd8f3a86344f99f0d6a) )
+ROM_END
+
 ROM_START( vhuntjr1 )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "vphj.03c", 0x000000, 0x80000, CRC(606b682a) SHA1(dd5c1b90a050e344b4f29fc468cfbd92aa392edf) )
@@ -7064,6 +7095,67 @@
 	ROM_LOAD16_WORD_SWAP( "sfx.12m",   0x200000, 0x200000, CRC(a05e3aab) SHA1(d4eb9cae66c74e956569fea8b815156fbd420f83) )
 ROM_END
 
+// interesting version, yellow case (rental?), shows OP instead of AM on startup, uses a different (unique) key to the usual Japan set
+ROM_START( ssf2xjr )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "sfxo.03c", 0x000000, 0x80000, CRC(2ba33dc6) SHA1(ab31046c1604eae30e55eb0e03804c98765d578e) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.04a", 0x080000, 0x80000, CRC(ba663dd7) SHA1(46baf0a48e4fd807098aa48e34625964b279a223) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.05",  0x100000, 0x80000, CRC(1321625c) SHA1(af5bce813bc2d8d406c7cb30ba5cb61b17b74efd) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.06a", 0x180000, 0x80000, CRC(0cc490ed) SHA1(59c708ff3824964bddaa508e2aea2d6f26742d40) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.07",  0x200000, 0x80000, CRC(64b9015e) SHA1(1b22029e2c8304e5dcda01c2e48c24e89d93b13b) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.08",  0x280000, 0x80000, CRC(b60f4b58) SHA1(1db3876daef85713a22dbc42f76a26a47fa26079) )
+	ROM_LOAD16_WORD_SWAP( "sfxo.09",  0x300000, 0x80000, CRC(642fae3f) SHA1(746df99b826b9837bba267104132161153c1daff) )
+
+	ROM_REGION( 0x1000000, "gfx", 0 )  // identical content, different board layout
+	ROMX_LOAD( "ssf.69",   0x000000, 0x080000, CRC(e9123f9f) SHA1(a44ea524cf4fba9c27d47b404f9e5f8ef0894365) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.70",   0x200000, 0x080000, CRC(2f8201f3) SHA1(630beb3b5ca018582d77f2ecfb72451ef934de43) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.71",   0x400000, 0x080000, CRC(0fa334b4) SHA1(ae14a6be82e445c90af0ec6d439f0f0368dd0c56) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.72",   0x600000, 0x080000, CRC(b76740d3) SHA1(5d0e1624bc2b04483ad5ebc06dd10824d9f5599e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.73",   0x800000, 0x080000, CRC(14f058ec) SHA1(6c7f455e117f5419d7e2324cfd67f8f9c243be58) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.74",   0xa00000, 0x080000, CRC(800c3ae9) SHA1(e4e7679495665811c043ef6cd9c949d95902e33e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.75",   0xc00000, 0x080000, CRC(06cf540b) SHA1(b0e68c2d199dcc9c9ea1f1926ee2691cced434d4) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.76",   0xe00000, 0x080000, CRC(71084e42) SHA1(9b8755b4c5a0c36ebcf6b12801d21fb7ef011638) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.59",   0x000002, 0x080000, CRC(6eb3ee4d) SHA1(7bb3aa3dc1a6e2ddde985463185035f63cd1f9e3) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.60",   0x200002, 0x080000, CRC(2bcf1eda) SHA1(64da42c81d42031f90636bf223277973ac3869b3) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.61",   0x400002, 0x080000, CRC(3330cc11) SHA1(d118fee0962470954638921e27f31ef8c1190ea5) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.62",   0x600002, 0x080000, CRC(96e2ead3) SHA1(47dfeea824d607e610201c816a81be33ee037993) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.63",   0x800002, 0x080000, CRC(e356a275) SHA1(36b750e5b9e4a3ec6c19af5865d4d262e2b67188) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.64",   0xa00002, 0x080000, CRC(fec5698b) SHA1(53648953af987bcae5a9a5445c30f2ec594bfc30) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.65",   0xc00002, 0x080000, CRC(69da0751) SHA1(fbc92b06348a15eeffd2f122cb39ff05a8025023) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.66",   0xe00002, 0x080000, CRC(cc53ec15) SHA1(4caaa975fcc2fb4f5f63ff2c373a42a5e2dbd724) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.79",   0x000004, 0x080000, CRC(cf0d44a8) SHA1(02dc2ca7a7fed1af4f13298b5af7af986f085b60) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.80",   0x200004, 0x080000, CRC(56a153a4) SHA1(29b9d53ab0d86a1d0e72d33a7c7968cc54f3f90b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.81",   0x400004, 0x080000, CRC(5484e5f6) SHA1(70b085f280f562e624eb0b6ee22ba6c15b71cee9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.82",   0x600004, 0x080000, CRC(fce6b7f5) SHA1(1d323f8aa522d7646dd23d841f6e4c2b264e5b27) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.83",   0x800004, 0x080000, CRC(042d7970) SHA1(dd4fae1666ceca24545ea665ad5d906f9066b2d6) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.84",   0xa00004, 0x080000, CRC(88c472e6) SHA1(a4681364b2434e40a2c881bf0aafb8eff39d823b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.85",   0xc00004, 0x080000, CRC(a7d66348) SHA1(b9f8620106219bdb13cd7c497f1cac80514aa565) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.86",   0xe00004, 0x080000, CRC(cf9119c8) SHA1(dccd5931e21568ef69f71798b07b681f1933027b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.89",   0x000006, 0x080000, CRC(6d374ad9) SHA1(1070e829e20b11f02bd64b213b08bd8487602f29) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.90",   0x200006, 0x080000, CRC(34cf8bcf) SHA1(ad19cdc16ebedb6614d7fa4228f14f3c3d2ee166) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.91",   0x400006, 0x080000, CRC(d796ea3f) SHA1(96887ddfefa267ed7628df1aa742285c62c97b0d) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.92",   0x600006, 0x080000, CRC(c85fb7e3) SHA1(0440813b52704285a591e3152643967c2cde8c63) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.93",   0x800006, 0x080000, CRC(6c50c2b5) SHA1(027963231450e075f9b2b7136f6499baca96594d) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ssf.94",   0xa00006, 0x080000, CRC(59549f63) SHA1(019677eba92eb1cf463e15cd98383aab04de63bf) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.95",   0xc00006, 0x080000, CRC(86c97869) SHA1(179117e7c887685e322f97a21461eb05de44d1ee) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sfx.96",   0xe00006, 0x080000, CRC(1c0e1989) SHA1(fac63bae9129a656c12e5665dc0eaddc9017821f) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "sfx.01",   0x00000, 0x08000, CRC(b47b8835) SHA1(c8b2d50fe3a329bd0592ea160d505155d873dab1) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "sfx.02",   0x28000, 0x20000, CRC(0022633f) SHA1(cab3afc79da53e3887eb1ccd1f4d19790728e6cd) )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */ // identical content, different board layout
+	ROM_LOAD16_WORD_SWAP( "ssf.51a",   0x000000, 0x080000, CRC(9eda6954) SHA1(28e007e8dcea127ffd82fe243a4729fa765347d6) )
+	ROM_LOAD16_WORD_SWAP( "ssf.52a",   0x080000, 0x080000, CRC(355f6589) SHA1(86f7243bc8ed22760658779d0f8810b1e1f9cdd6) )
+	ROM_LOAD16_WORD_SWAP( "ssf.53a",   0x100000, 0x080000, CRC(d5d08a05) SHA1(78549077a105384c7b1b609dc2e9e115dea4a220) )
+	ROM_LOAD16_WORD_SWAP( "ssf.54a",   0x180000, 0x080000, CRC(930725eb) SHA1(5ff27e89f4c203207d2a762776fa014a31ab5409) )
+	ROM_LOAD16_WORD_SWAP( "ssf.55a",   0x200000, 0x080000, CRC(827abf3c) SHA1(51d9ed9b182bcf24b0ccc3e99a781750609fec58) )
+	ROM_LOAD16_WORD_SWAP( "ssf.56a",   0x280000, 0x080000, CRC(3919c0e5) SHA1(23b21b13775c62f0c8ee6b9db403196397981b27) )
+	ROM_LOAD16_WORD_SWAP( "ssf.57a",   0x300000, 0x080000, CRC(1ba9bfa6) SHA1(e010e66aea28b2688ccf6feaf678728bab89a852) )
+	ROM_LOAD16_WORD_SWAP( "ssf.58a",   0x380000, 0x080000, CRC(0c89a272) SHA1(55eb7322c8498e0897165a689feb0406caa09db6) )
+ROM_END
+
 ROM_START( vhunt2 )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "vh2j.03a", 0x000000, 0x80000, CRC(9ae8f186) SHA1(f4e3a1b6ae823737d3b18561469f206921b48587) )
@@ -8150,6 +8242,7 @@
 GAME( 1994, ssf2tu,     ssf2t,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Super Street Fighter II Turbo (USA 940323)", GAME_SUPPORTS_SAVE )
 GAME( 1994, ssf2tur1,   ssf2t,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Super Street Fighter II Turbo (USA 940223)", GAME_SUPPORTS_SAVE )
 GAME( 1994, ssf2xj,     ssf2t,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Super Street Fighter II X: Grand Master Challenge (Japan 940223)", GAME_SUPPORTS_SAVE )
+GAME( 1994, ssf2xjr,    ssf2t,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Super Street Fighter II X: Grand Master Challenge (Japan 940223 rent version)", GAME_SUPPORTS_SAVE )
 GAME( 1994, avsp,       0,        cps2, cps2_3p3b, cps2,     ROT0,   "Capcom", "Alien vs. Predator (Euro 940520)", GAME_SUPPORTS_SAVE )
 GAME( 1994, avspu,      avsp,     cps2, cps2_3p3b, cps2,     ROT0,   "Capcom", "Alien vs. Predator (USA 940520)", GAME_SUPPORTS_SAVE )
 GAME( 1994, avspj,      avsp,     cps2, cps2_3p3b, cps2,     ROT0,   "Capcom", "Alien vs. Predator (Japan 940520)", GAME_SUPPORTS_SAVE )
@@ -8191,6 +8284,7 @@
 GAME( 1995, nwarrb,     nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Night Warriors: Darkstalkers' Revenge (Brazil 950403)", GAME_SUPPORTS_SAVE )
 GAME( 1995, nwarra,     nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Night Warriors: Darkstalkers' Revenge (Asia 950302)", GAME_SUPPORTS_SAVE )
 GAME( 1995, vhuntj,     nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Vampire Hunter: Darkstalkers' Revenge (Japan 950316)", GAME_SUPPORTS_SAVE )
+GAME( 1995, vhuntjr1s,  nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Vampire Hunter: Darkstalkers' Revenge (Japan 950307 stop version)", GAME_SUPPORTS_SAVE )
 GAME( 1995, vhuntjr1,   nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Vampire Hunter: Darkstalkers' Revenge (Japan 950307)", GAME_SUPPORTS_SAVE )
 GAME( 1995, vhuntjr2,   nwarr,    cps2, cps2_2p6b, cps2,     ROT0,   "Capcom", "Vampire Hunter: Darkstalkers' Revenge (Japan 950302)", GAME_SUPPORTS_SAVE )
 GAME( 1995, cybots,     0,        cps2, cybots,    cps2,     ROT0,   "Capcom", "Cyberbots: Fullmetal Madness (Euro 950424)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/cps3.c src/mame/drivers/cps3.c
--- src-old/mame/drivers/cps3.c	2012-02-15 02:56:05.000000000 +0100
+++ src/mame/drivers/cps3.c	2012-02-28 14:12:48.000000000 +0100
@@ -88,13 +88,13 @@
 
 JoJo no Kimyouna Bouken                              1998  JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK000   CAP-JJK-140  981202
 JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK-2    CAP-JJK-160  990108
-JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  ?            ?            990128*
+JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK-3    CAP-JJK-161  990128
 JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            981202
 JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            990108
-JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            990128*
+JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            990128
 JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK000   CAP-JJK-140  981202
 JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK-2    CAP-JJK-160  990108
-JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  ?            ?            990128*
+JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK-3    CAP-JJK-161  990128
 
 Street Fighter III 3rd Strike: Fight for the Future  1999  33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-1    CAP-33S-1    990512
 Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-2    CAP-33S-2    990608
@@ -392,8 +392,6 @@
 
 #define MASTER_CLOCK	42954500
 
-/* load extracted cd content? */
-#define LOAD_CD_CONTENT 1
 #define DEBUG_PRINTF 0
 
 
@@ -2651,10 +2649,10 @@
 MACHINE_CONFIG_END
 
 #define REDEARTH_961121_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "redearth-simm1.0", 0x00000, 0x200000, CRC(cad468f8) SHA1(b3aa4f7d3fae84e8821417ccde9528d3eda2b7a6) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "redearth-simm1.1", 0x00000, 0x200000, CRC(e9721d89) SHA1(5c63d10bdbce52d50b6dde14d4a0f1369383d656) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "redearth-simm1.2", 0x00000, 0x200000, CRC(2889ec98) SHA1(a94310eb4777f908d87e9d90969db8504b4140ff) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "redearth-simm1.3", 0x00000, 0x200000, CRC(5a6cd148) SHA1(d65c6e8378a91828474a16a3bbcd13c4b3b15f13) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "redearth(__961121)-simm1.0", 0x00000, 0x200000, CRC(cad468f8) SHA1(b3aa4f7d3fae84e8821417ccde9528d3eda2b7a6) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "redearth(__961121)-simm1.1", 0x00000, 0x200000, CRC(e9721d89) SHA1(5c63d10bdbce52d50b6dde14d4a0f1369383d656) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "redearth(__961121)-simm1.2", 0x00000, 0x200000, CRC(2889ec98) SHA1(a94310eb4777f908d87e9d90969db8504b4140ff) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "redearth(__961121)-simm1.3", 0x00000, 0x200000, CRC(5a6cd148) SHA1(d65c6e8378a91828474a16a3bbcd13c4b3b15f13) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "redearth-simm3.0", 0x00000, 0x200000, CRC(83350cc5) SHA1(922b1abf80a4a89f35279b66311a7369d3965bd0) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "redearth-simm3.1", 0x00000, 0x200000, CRC(56734de6) SHA1(75699fa6efe5bec335e4b02e15b3c45726b68fa8) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "redearth-simm3.2", 0x00000, 0x200000, CRC(800ea0f1) SHA1(33871ab56dc1cd24441389d53e43fb8e43b149d9) ) \
@@ -2678,10 +2676,10 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-wzd-5", 0, SHA1(e5676752b08283dc4a98c3d7b759e8aa6dcd0679) ) \
 
 #define REDEARTH_961023_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "redeartha-simm1.0", 0x00000, 0x200000, CRC(65bac346) SHA1(6f4ba0c2cae91a37fc97bea5fc8a50aaf6ca6513) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "redeartha-simm1.1", 0x00000, 0x200000, CRC(a8ec4aae) SHA1(0012cb6ba630ddd74958f7759de34706bf919338) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "redeartha-simm1.2", 0x00000, 0x200000, CRC(2caf8995) SHA1(ca012b6dec0481b043edf9c7e931bd952ec74ebb) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "redeartha-simm1.3", 0x00000, 0x200000, CRC(13ebc21d) SHA1(465bdea0633526a8bf07b35495a5311c8bf213d5) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "redearth(__961023)-simm1.0", 0x00000, 0x200000, CRC(65bac346) SHA1(6f4ba0c2cae91a37fc97bea5fc8a50aaf6ca6513) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "redearth(__961023)-simm1.1", 0x00000, 0x200000, CRC(a8ec4aae) SHA1(0012cb6ba630ddd74958f7759de34706bf919338) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "redearth(__961023)-simm1.2", 0x00000, 0x200000, CRC(2caf8995) SHA1(ca012b6dec0481b043edf9c7e931bd952ec74ebb) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "redearth(__961023)-simm1.3", 0x00000, 0x200000, CRC(13ebc21d) SHA1(465bdea0633526a8bf07b35495a5311c8bf213d5) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "redearth-simm3.0",  0x00000, 0x200000, CRC(83350cc5) SHA1(922b1abf80a4a89f35279b66311a7369d3965bd0) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "redearth-simm3.1",  0x00000, 0x200000, CRC(56734de6) SHA1(75699fa6efe5bec335e4b02e15b3c45726b68fa8) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "redearth-simm3.2",  0x00000, 0x200000, CRC(800ea0f1) SHA1(33871ab56dc1cd24441389d53e43fb8e43b149d9) ) \
@@ -2768,15 +2766,46 @@
 #define SFIII2_970930_CDROM \
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-3ga000", 0, SHA1(4e162885b0b3265a56e0265037bcf247e820f027) ) \
 
+#define JOJO_990128_FLASH \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo(__990128)-simm1.0", 0x00000, 0x200000, CRC(9516948b) SHA1(4d7e6c1eb7d1bebff2a5069bcd186070a9105474) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojo(__990128)-simm1.1", 0x00000, 0x200000, CRC(a847848d) SHA1(4df70309395f1d2a2e8f85bc34e17453d4a76f81) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojo(__990128)-simm1.2", 0x00000, 0x200000, CRC(853e8846) SHA1(d120b7e2de9502e3261e8dd101f97589b2ed1c38) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojo(__990128)-simm1.3", 0x00000, 0x200000, CRC(c04fe00e) SHA1(d09409b77460d19b56aaaf4a64356f3d37a1ee41) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojo(__990128)-simm2.0", 0x00000, 0x200000, CRC(e1a4b3c8) SHA1(5dc298431644e1ca470aaab752a7d74f2f9dc7a1) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojo(__990128)-simm2.1", 0x00000, 0x200000, CRC(189cef95) SHA1(ebe42a019358461557f69fb17d65d84d0f733415) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojo(__990128)-simm2.2", 0x00000, 0x200000, CRC(47db5ec6) SHA1(e80271e4013e4391c2cc4229ff1fbd4a2b7c6f04) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojo(__990128)-simm2.3", 0x00000, 0x200000, CRC(e3d3a155) SHA1(75e9b5da93dd8894cf70fa4dac56f3958be4c766) ) \
+	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojo-simm3.0", 0x00000, 0x200000, CRC(de7fc9c1) SHA1(662b85a990b04c855773506c936317e62fab4a05) ) \
+	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojo-simm3.1", 0x00000, 0x200000, CRC(43d053d3) SHA1(54ff0e9c164e0d1649522c330ccc7e5d79e0bc85) ) \
+	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojo-simm3.2", 0x00000, 0x200000, CRC(2ffd7fa5) SHA1(9018c8e2b286a333ba606208e90caa764951ea3f) ) \
+	ROM_REGION( 0x200000, "simm3.3", 0 ) ROM_LOAD( "jojo-simm3.3", 0x00000, 0x200000, CRC(4da4985b) SHA1(2552b1730a21ce17d58b69a79ad212a6a5829439) ) \
+	ROM_REGION( 0x200000, "simm3.4", 0 ) ROM_LOAD( "jojo-simm3.4", 0x00000, 0x200000, CRC(fde98d72) SHA1(654563e12d033e8656dc74a268a08b15b171470d) ) \
+	ROM_REGION( 0x200000, "simm3.5", 0 ) ROM_LOAD( "jojo-simm3.5", 0x00000, 0x200000, CRC(edb2a266) SHA1(19ebada8422c7f4bf70d0c9ad42b84268967b316) ) \
+	ROM_REGION( 0x200000, "simm3.6", 0 ) ROM_LOAD( "jojo-simm3.6", 0x00000, 0x200000, CRC(be7cf319) SHA1(7893f5907992e6b903b2683980bba6d3d003bb06) ) \
+	ROM_REGION( 0x200000, "simm3.7", 0 ) ROM_LOAD( "jojo-simm3.7", 0x00000, 0x200000, CRC(56fe1a9f) SHA1(01741fe1256f4e682f687e94040f4e8bbb8bedb2) ) \
+	ROM_REGION( 0x200000, "simm4.0", 0 ) ROM_LOAD( "jojo-simm4.0", 0x00000, 0x200000, CRC(c4e7bf68) SHA1(a4d1ddea58a3d42db82a63a5e974cbf38d9b792a) ) \
+	ROM_REGION( 0x200000, "simm4.1", 0 ) ROM_LOAD( "jojo-simm4.1", 0x00000, 0x200000, CRC(b62b2719) SHA1(cb577b89e9e14fda67715716fefd47a782d518ab) ) \
+	ROM_REGION( 0x200000, "simm4.2", 0 ) ROM_LOAD( "jojo-simm4.2", 0x00000, 0x200000, CRC(18d15809) SHA1(2b406cd1aaa4799a436213dcaa65473eacb4c6d7) ) \
+	ROM_REGION( 0x200000, "simm4.3", 0 ) ROM_LOAD( "jojo-simm4.3", 0x00000, 0x200000, CRC(9af0ad79) SHA1(075ee048e17b50188876f25d7a6571d6ace84d7d) ) \
+	ROM_REGION( 0x200000, "simm4.4", 0 ) ROM_LOAD( "jojo-simm4.4", 0x00000, 0x200000, CRC(4124c1f0) SHA1(e4946a8029adc5d0bacead8d766521b4ccd1722b) ) \
+	ROM_REGION( 0x200000, "simm4.5", 0 ) ROM_LOAD( "jojo-simm4.5", 0x00000, 0x200000, CRC(5e001fd1) SHA1(6457a39f336381b46e587aa2f5f719810ee5bcf9) ) \
+	ROM_REGION( 0x200000, "simm4.6", 0 ) ROM_LOAD( "jojo-simm4.6", 0x00000, 0x200000, CRC(9affa23b) SHA1(e3d77e777c47277d841a9dadc1dd6e3157706a2e) ) \
+	ROM_REGION( 0x200000, "simm4.7", 0 ) ROM_LOAD( "jojo-simm4.7", 0x00000, 0x200000, CRC(2511572a) SHA1(725adcf71bcee5c8bb839d2d1c5e3456b8c6886b) ) \
+	ROM_REGION( 0x200000, "simm5.0", 0 ) ROM_LOAD( "jojo-simm5.0", 0x00000, 0x200000, CRC(797615fc) SHA1(29874be9f1da5515c90f5d601aa5924c263f8feb) ) \
+	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "jojo-simm5.1", 0x00000, 0x200000, CRC(734fd162) SHA1(16cdfac74d18a6c2216afb1ce6afbd7f15297c32) ) \
+
+#define JOJO_990128_CDROM \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk-3", 0, SHA1(dc6e74b5e02e13f62cb8c4e234dd6061501e49c1) ) \
+
 #define JOJO_990108_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo-simm1.0", 0x00000, 0x200000, CRC(cfbc38d6) SHA1(c33e3a51fe8ab54e0912a1d6e662fe1ade73cee7) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojo-simm1.1", 0x00000, 0x200000, CRC(42578d94) SHA1(fa46f92ac1a6716430adec9ab27214a11fa61749) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojo-simm1.2", 0x00000, 0x200000, CRC(1b40c566) SHA1(9833799e9b4fecf7f9ce14bca64936646b3fdbde) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojo-simm1.3", 0x00000, 0x200000, CRC(bba709b4) SHA1(0dd71e575f2193505f2ab960568ac1eccf40d53f) ) \
-	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojo-simm2.0", 0x00000, 0x200000, CRC(417e5dc1) SHA1(54ee9596c1c51811f3bdef7dbe77b44b34f230ca) ) \
-	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojo-simm2.1", 0x00000, 0x200000, CRC(d3b3267d) SHA1(eb2cff347880f1489fb5b1b8bd16df8f50c7f494) ) \
-	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojo-simm2.2", 0x00000, 0x200000, CRC(c66d96b1) SHA1(909d5aac165748b549b6056a6091c41df012f5df) ) \
-	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojo-simm2.3", 0x00000, 0x200000, CRC(aa34cc85) SHA1(7677cc6fa913755fc699691b350698bbe8904118) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo(__990108)-simm1.0", 0x00000, 0x200000, CRC(cfbc38d6) SHA1(c33e3a51fe8ab54e0912a1d6e662fe1ade73cee7) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojo(__990108)-simm1.1", 0x00000, 0x200000, CRC(42578d94) SHA1(fa46f92ac1a6716430adec9ab27214a11fa61749) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojo(__990108)-simm1.2", 0x00000, 0x200000, CRC(1b40c566) SHA1(9833799e9b4fecf7f9ce14bca64936646b3fdbde) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojo(__990108)-simm1.3", 0x00000, 0x200000, CRC(bba709b4) SHA1(0dd71e575f2193505f2ab960568ac1eccf40d53f) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojo(__990108)-simm2.0", 0x00000, 0x200000, CRC(417e5dc1) SHA1(54ee9596c1c51811f3bdef7dbe77b44b34f230ca) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojo(__990108)-simm2.1", 0x00000, 0x200000, CRC(d3b3267d) SHA1(eb2cff347880f1489fb5b1b8bd16df8f50c7f494) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojo(__990108)-simm2.2", 0x00000, 0x200000, CRC(c66d96b1) SHA1(909d5aac165748b549b6056a6091c41df012f5df) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojo(__990108)-simm2.3", 0x00000, 0x200000, CRC(aa34cc85) SHA1(7677cc6fa913755fc699691b350698bbe8904118) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojo-simm3.0", 0x00000, 0x200000, CRC(de7fc9c1) SHA1(662b85a990b04c855773506c936317e62fab4a05) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojo-simm3.1", 0x00000, 0x200000, CRC(43d053d3) SHA1(54ff0e9c164e0d1649522c330ccc7e5d79e0bc85) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojo-simm3.2", 0x00000, 0x200000, CRC(2ffd7fa5) SHA1(9018c8e2b286a333ba606208e90caa764951ea3f) ) \
@@ -2800,14 +2829,14 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk-2", 0, SHA1(0f5c09171409213e191a607ee89ca3a91fe9c96a) ) \
 
 #define JOJO_981202_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoa-simm1.0", 0x00000, 0x200000, CRC(e06ba886) SHA1(4defd5e8e1e6d0c439fed8a6454e89a59e24ea4c) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoa-simm1.1", 0x00000, 0x200000, CRC(6dd177c8) SHA1(c39db980f6fcca9c221e9be6f777eaf38f1b136b) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoa-simm1.2", 0x00000, 0x200000, CRC(d35a15e0) SHA1(576b92a94505764a10b9bcf82c02335e7ef62014) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoa-simm1.3", 0x00000, 0x200000, CRC(66d865ac) SHA1(5248c3f124af62b4a672d954ef15f86629feeacb) ) \
-	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoa-simm2.0", 0x00000, 0x200000, CRC(417e5dc1) SHA1(54ee9596c1c51811f3bdef7dbe77b44b34f230ca) ) \
-	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoa-simm2.1", 0x00000, 0x200000, CRC(c891c887) SHA1(42e84f774ee655e9a39b016a3cfe94262ed2e9f1) ) \
-	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoa-simm2.2", 0x00000, 0x200000, CRC(1e101f30) SHA1(56518c1646bb9452334856bb8bcc58892f9f93b9) ) \
-	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoa-simm2.3", 0x00000, 0x200000, CRC(1fd1d3e4) SHA1(bed2b77d58f1fdf7ba5ca7126d3db1dd0f8c80b4) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojo(__981202)-simm1.0", 0x00000, 0x200000, CRC(e06ba886) SHA1(4defd5e8e1e6d0c439fed8a6454e89a59e24ea4c) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojo(__981202)-simm1.1", 0x00000, 0x200000, CRC(6dd177c8) SHA1(c39db980f6fcca9c221e9be6f777eaf38f1b136b) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojo(__981202)-simm1.2", 0x00000, 0x200000, CRC(d35a15e0) SHA1(576b92a94505764a10b9bcf82c02335e7ef62014) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojo(__981202)-simm1.3", 0x00000, 0x200000, CRC(66d865ac) SHA1(5248c3f124af62b4a672d954ef15f86629feeacb) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojo(__981202)-simm2.0", 0x00000, 0x200000, CRC(417e5dc1) SHA1(54ee9596c1c51811f3bdef7dbe77b44b34f230ca) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojo(__981202)-simm2.1", 0x00000, 0x200000, CRC(c891c887) SHA1(42e84f774ee655e9a39b016a3cfe94262ed2e9f1) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojo(__981202)-simm2.2", 0x00000, 0x200000, CRC(1e101f30) SHA1(56518c1646bb9452334856bb8bcc58892f9f93b9) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojo(__981202)-simm2.3", 0x00000, 0x200000, CRC(1fd1d3e4) SHA1(bed2b77d58f1fdf7ba5ca7126d3db1dd0f8c80b4) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojo-simm3.0",  0x00000, 0x200000, CRC(de7fc9c1) SHA1(662b85a990b04c855773506c936317e62fab4a05) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojo-simm3.1",  0x00000, 0x200000, CRC(43d053d3) SHA1(54ff0e9c164e0d1649522c330ccc7e5d79e0bc85) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojo-simm3.2",  0x00000, 0x200000, CRC(2ffd7fa5) SHA1(9018c8e2b286a333ba606208e90caa764951ea3f) ) \
@@ -2831,10 +2860,10 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjk000", 0, SHA1(09869f6d8c032b527e02d815749dc8fab1289e86) ) \
 
 #define SFIII3_990608_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3-simm1.0", 0x00000, 0x200000, CRC(11dfd3cd) SHA1(dba1f77c46e80317e3279298411154dfb6db2309) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "sfiii3-simm1.1", 0x00000, 0x200000, CRC(c50585e6) SHA1(a289237957ea1c7f58b1c65e24c54ceb34cb1712) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "sfiii3-simm1.2", 0x00000, 0x200000, CRC(8e011d9b) SHA1(e0861bcd3c4f865474d7ce47aa9eeec7b3d28da6) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "sfiii3-simm1.3", 0x00000, 0x200000, CRC(dca8d92f) SHA1(7cd241641c943df446e2c75b88b5cf2d2ebf7b2e) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3(__990608)-simm1.0", 0x00000, 0x200000, CRC(11dfd3cd) SHA1(dba1f77c46e80317e3279298411154dfb6db2309) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "sfiii3(__990608)-simm1.1", 0x00000, 0x200000, CRC(c50585e6) SHA1(a289237957ea1c7f58b1c65e24c54ceb34cb1712) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "sfiii3(__990608)-simm1.2", 0x00000, 0x200000, CRC(8e011d9b) SHA1(e0861bcd3c4f865474d7ce47aa9eeec7b3d28da6) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "sfiii3(__990608)-simm1.3", 0x00000, 0x200000, CRC(dca8d92f) SHA1(7cd241641c943df446e2c75b88b5cf2d2ebf7b2e) ) \
 	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "sfiii3-simm2.0", 0x00000, 0x200000, CRC(06eb969e) SHA1(d89f6a6585b76692d57d337f0f8186398fb056da) ) \
 	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "sfiii3-simm2.1", 0x00000, 0x200000, CRC(e7039f82) SHA1(8e81e66b5a4f45ae14b070a491bde47a6a74499f) ) \
 	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "sfiii3-simm2.2", 0x00000, 0x200000, CRC(645c96f7) SHA1(06d5a54874d4bf100b776131ec9060da209ad037) ) \
@@ -2876,10 +2905,10 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-2", 0, SHA1(41b0e246db91cbfc3f8f0f62d981734feb4b4ab5) ) \
 
 #define SFIII3_990512_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3a-simm1.0", 0x00000, 0x200000, CRC(66e66235) SHA1(0a98038721d176458d4f85dbd76c5edb93a65322) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "sfiii3a-simm1.1", 0x00000, 0x200000, CRC(186e8c5f) SHA1(a63040201a660b56217a8cbab32f5c2c466ee5dd) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "sfiii3a-simm1.2", 0x00000, 0x200000, CRC(bce18cab) SHA1(a5c28063d98c22403756fc926a20631456fb7dcc) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "sfiii3a-simm1.3", 0x00000, 0x200000, CRC(129dc2c9) SHA1(c1e634d94b1c8f7f02a47703622de5cab3d0da3f) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "sfiii3(__990512)-simm1.0", 0x00000, 0x200000, CRC(66e66235) SHA1(0a98038721d176458d4f85dbd76c5edb93a65322) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "sfiii3(__990512)-simm1.1", 0x00000, 0x200000, CRC(186e8c5f) SHA1(a63040201a660b56217a8cbab32f5c2c466ee5dd) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "sfiii3(__990512)-simm1.2", 0x00000, 0x200000, CRC(bce18cab) SHA1(a5c28063d98c22403756fc926a20631456fb7dcc) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "sfiii3(__990512)-simm1.3", 0x00000, 0x200000, CRC(129dc2c9) SHA1(c1e634d94b1c8f7f02a47703622de5cab3d0da3f) ) \
 	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "sfiii3-simm2.0",  0x00000, 0x200000, CRC(06eb969e) SHA1(d89f6a6585b76692d57d337f0f8186398fb056da) ) \
 	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "sfiii3-simm2.1",  0x00000, 0x200000, CRC(e7039f82) SHA1(8e81e66b5a4f45ae14b070a491bde47a6a74499f) ) \
 	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "sfiii3-simm2.2",  0x00000, 0x200000, CRC(645c96f7) SHA1(06d5a54874d4bf100b776131ec9060da209ad037) ) \
@@ -2921,14 +2950,14 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-1", 0, SHA1(2f4a9006a31903114f9f9dc09465ae253e565c51) ) \
 
 #define JOJOBA_990927_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba-simm1.0", 0x00000, 0x200000, CRC(adcd8377) SHA1(f1aacbe061e3bcade5cca34435c3f86aec5f1499) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoba-simm1.1", 0x00000, 0x200000, CRC(d7590b59) SHA1(bfee627ebb7cb7b28216527b17e1b06a4e6f19f4) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoba-simm1.2", 0x00000, 0x200000, CRC(e62e240b) SHA1(70468cae67c009a80b45954c2a30794577343c77) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoba-simm1.3", 0x00000, 0x200000, CRC(c95450c3) SHA1(55616e009b007180d1ac6290c8da44b0d864a494) ) \
-	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoba-simm2.0", 0x00000, 0x200000, CRC(535f2eba) SHA1(167bec0dccfc2f91cb10cb1e2631ee619b3eb9fe) ) \
-	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoba-simm2.1", 0x00000, 0x200000, CRC(01dd3a01) SHA1(08c462219796baa3ec28d78d038a18187cd838bb) ) \
-	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoba-simm2.2", 0x00000, 0x200000, CRC(61432672) SHA1(d0416a75d395926041f90a3d34edb96a080acfd6) ) \
-	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoba-simm2.3", 0x00000, 0x200000, CRC(acdc9aca) SHA1(89f77ddd6286709182a676fd9bd6c333a3b16271) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba(__990927)-simm1.0", 0x00000, 0x200000, CRC(adcd8377) SHA1(f1aacbe061e3bcade5cca34435c3f86aec5f1499) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoba(__990927)-simm1.1", 0x00000, 0x200000, CRC(d7590b59) SHA1(bfee627ebb7cb7b28216527b17e1b06a4e6f19f4) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoba(__990927)-simm1.2", 0x00000, 0x200000, CRC(e62e240b) SHA1(70468cae67c009a80b45954c2a30794577343c77) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoba(__990927)-simm1.3", 0x00000, 0x200000, CRC(c95450c3) SHA1(55616e009b007180d1ac6290c8da44b0d864a494) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoba(__990927)-simm2.0", 0x00000, 0x200000, CRC(535f2eba) SHA1(167bec0dccfc2f91cb10cb1e2631ee619b3eb9fe) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoba(__990927)-simm2.1", 0x00000, 0x200000, CRC(01dd3a01) SHA1(08c462219796baa3ec28d78d038a18187cd838bb) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoba(__990927)-simm2.2", 0x00000, 0x200000, CRC(61432672) SHA1(d0416a75d395926041f90a3d34edb96a080acfd6) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoba(__990927)-simm2.3", 0x00000, 0x200000, CRC(acdc9aca) SHA1(89f77ddd6286709182a676fd9bd6c333a3b16271) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojoba-simm3.0", 0x00000, 0x200000, CRC(4d16e111) SHA1(f198007375be65e89856d64ee2b3857a18b4eab8) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojoba-simm3.1", 0x00000, 0x200000, CRC(9b3406d3) SHA1(54e90cd334d13e2c74305c6b87ebce1365ef3d59) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojoba-simm3.2", 0x00000, 0x200000, CRC(f2414997) SHA1(fb89d5784250538ad17fd527267b513afb6eca20) ) \
@@ -2958,14 +2987,14 @@
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjm-120", 0, SHA1(8628d3fa555fbd5f4121082e925c1834b76c5e65) ) \
 
 #define JOJOBA_990913_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojobaa-simm1.0", 0x00000, 0x200000, CRC(76976231) SHA1(90adde7e5983ec6a4e02789d5cefe9e85c9c52d5) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojobaa-simm1.1", 0x00000, 0x200000, CRC(cedd78e7) SHA1(964988b90a2f14c1da2cfc48d943e16e54da3fd3) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojobaa-simm1.2", 0x00000, 0x200000, CRC(2955b77f) SHA1(2a907a5cd91448bfc420c318584e5ef4bbe55a91) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojobaa-simm1.3", 0x00000, 0x200000, CRC(280139d7) SHA1(b7c28f6f0218688fb873a3106d2f95ea2e1e927c) ) \
-	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojobaa-simm2.0", 0x00000, 0x200000, CRC(305c4914) SHA1(c3a73ffe58f61ab8f1cd9e3f0891037638dc5a9b) ) \
-	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojobaa-simm2.1", 0x00000, 0x200000, CRC(18af4f3b) SHA1(04b8fdf23a782b10c203b111cc634a6d3474044a) ) \
-	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojobaa-simm2.2", 0x00000, 0x200000, CRC(397e5c9e) SHA1(021d86ee66bf951fb6a1dd90fb7007c6865cbb8b) ) \
-	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojobaa-simm2.3", 0x00000, 0x200000, CRC(a9d0a7d7) SHA1(b2cfc0661f8903ddbeea8a604ee8b42097e10ab8) ) \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba(__990913)-simm1.0", 0x00000, 0x200000, CRC(76976231) SHA1(90adde7e5983ec6a4e02789d5cefe9e85c9c52d5) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoba(__990913)-simm1.1", 0x00000, 0x200000, CRC(cedd78e7) SHA1(964988b90a2f14c1da2cfc48d943e16e54da3fd3) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoba(__990913)-simm1.2", 0x00000, 0x200000, CRC(2955b77f) SHA1(2a907a5cd91448bfc420c318584e5ef4bbe55a91) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoba(__990913)-simm1.3", 0x00000, 0x200000, CRC(280139d7) SHA1(b7c28f6f0218688fb873a3106d2f95ea2e1e927c) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoba(__990913)-simm2.0", 0x00000, 0x200000, CRC(305c4914) SHA1(c3a73ffe58f61ab8f1cd9e3f0891037638dc5a9b) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoba(__990913)-simm2.1", 0x00000, 0x200000, CRC(18af4f3b) SHA1(04b8fdf23a782b10c203b111cc634a6d3474044a) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoba(__990913)-simm2.2", 0x00000, 0x200000, CRC(397e5c9e) SHA1(021d86ee66bf951fb6a1dd90fb7007c6865cbb8b) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoba(__990913)-simm2.3", 0x00000, 0x200000, CRC(a9d0a7d7) SHA1(b2cfc0661f8903ddbeea8a604ee8b42097e10ab8) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojoba-simm3.0",  0x00000, 0x200000, CRC(4d16e111) SHA1(f198007375be65e89856d64ee2b3857a18b4eab8) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojoba-simm3.1",  0x00000, 0x200000, CRC(9b3406d3) SHA1(54e90cd334d13e2c74305c6b87ebce1365ef3d59) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojoba-simm3.2",  0x00000, 0x200000, CRC(f2414997) SHA1(fb89d5784250538ad17fd527267b513afb6eca20) ) \
@@ -3007,7 +3036,7 @@
 	REDEARTH_961121_CDROM
 ROM_END
 
-ROM_START( redeartha )
+ROM_START( redearthr1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "redearth_euro.29f400.u2", 0x000000, 0x080000, CRC(02e0f336) SHA1(acc37e830dfeb9674f5a0fb24f4cc23217ae4ff5) )
 
@@ -3023,7 +3052,7 @@
 	REDEARTH_961121_CDROM
 ROM_END
 
-ROM_START( warzarda )
+ROM_START( warzardr1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "warzard_japan.29f400.u2", 0x000000, 0x080000, CRC(f8e2f0c6) SHA1(93d6a986f44c211fff014e55681eca4d2a2774d6) )
 
@@ -3075,11 +3104,19 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_usa.29f400.u2", 0x000000, 0x080000, CRC(8d40f7be) SHA1(2a4bd83db2f959c33b071e517941aa55a0f919c0) )
 
+	JOJO_990128_FLASH
+	JOJO_990128_CDROM
+ROM_END
+
+ROM_START( jojor1 )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojo_usa.29f400.u2", 0x000000, 0x080000, CRC(8d40f7be) SHA1(2a4bd83db2f959c33b071e517941aa55a0f919c0) )
+
 	JOJO_990108_FLASH
 	JOJO_990108_CDROM
 ROM_END
 
-ROM_START( jojoa )
+ROM_START( jojor2 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_usa.29f400.u2", 0x000000, 0x080000, CRC(8d40f7be) SHA1(2a4bd83db2f959c33b071e517941aa55a0f919c0) )
 
@@ -3091,11 +3128,19 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_japan.29f400.u2", 0x000000, 0x080000, CRC(02778f60) SHA1(a167f9ebe030592a0cdb0c6a3c75835c6a43be4c) )
 
+	JOJO_990128_FLASH
+	JOJO_990128_CDROM
+ROM_END
+
+ROM_START( jojojr1 )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojo_japan.29f400.u2", 0x000000, 0x080000, CRC(02778f60) SHA1(a167f9ebe030592a0cdb0c6a3c75835c6a43be4c) )
+
 	JOJO_990108_FLASH
 	JOJO_990108_CDROM
 ROM_END
 
-ROM_START( jojoaj )
+ROM_START( jojojr2 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_japan.29f400.u2", 0x000000, 0x080000, CRC(02778f60) SHA1(a167f9ebe030592a0cdb0c6a3c75835c6a43be4c) )
 
@@ -3111,7 +3156,7 @@
 	SFIII3_990608_CDROM
 ROM_END
 
-ROM_START( sfiii3a )
+ROM_START( sfiii3r1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "sfiii3_euro.29f400.u2", 0x000000, 0x080000, CRC(30bbf293) SHA1(f094c2eeaf4f6709060197aca371a4532346bf78) )
 
@@ -3127,7 +3172,7 @@
 	SFIII3_990608_CDROM
 ROM_END
 
-ROM_START( sfiii3au )
+ROM_START( sfiii3ur1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "sfiii3_usa.29f400.u2", 0x000000, 0x080000, CRC(ecc545c1) SHA1(e39083820aae914fd8b80c9765129bedb745ceba) )
 
@@ -3143,7 +3188,7 @@
 	JOJOBA_990927_CDROM
 ROM_END
 
-ROM_START( jojobaa )
+ROM_START( jojobar1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_japan.29f400.u2", 0x000000, 0x080000, CRC(3085478c) SHA1(055eab1fc42816f370a44b17fd7e87ffcb10e8b7) )
 
@@ -3172,10 +3217,17 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_asia_nocd.29f400.u2", 0x000000, 0x080000, CRC(05b4f953) SHA1(c746c7bb5359acc9adced817cb4870b1912eaefd) )
 
+	JOJO_990128_FLASH
+ROM_END
+
+ROM_START( jojonr1 )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojo_asia_nocd.29f400.u2", 0x000000, 0x080000, CRC(05b4f953) SHA1(c746c7bb5359acc9adced817cb4870b1912eaefd) )
+
 	JOJO_990108_FLASH
 ROM_END
 
-ROM_START( jojoan )
+ROM_START( jojonr2 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojo_asia_nocd.29f400.u2", 0x000000, 0x080000, CRC(05b4f953) SHA1(c746c7bb5359acc9adced817cb4870b1912eaefd) )
 
@@ -3189,7 +3241,7 @@
 	SFIII3_990608_FLASH
 ROM_END
 
-ROM_START( sfiii3an )
+ROM_START( sfiii3nr1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "sfiii3_japan_nocd.29f400.u2", 0x000000, 0x080000, CRC(1edc6366) SHA1(60b4b9adeb030a33059d74fdf03873029e465b52) )
 
@@ -3203,7 +3255,7 @@
 	JOJOBA_990927_FLASH
 ROM_END
 
-ROM_START( jojobaan )
+ROM_START( jojobanr1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_japan_nocd.29f400.u2", 0x000000, 0x080000, CRC(4dab19f5) SHA1(ba07190e7662937fc267f07285c51e99a45c061e) )
 
@@ -3217,7 +3269,7 @@
 	JOJOBA_990927_FLASH
 ROM_END
 
-ROM_START( jojobaane )
+ROM_START( jojobaner1 )
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_euro_nocd.29f400.u2", 0x000000, 0x080000, CRC(1ee2d679) SHA1(9e129b454a376606b3f7e8aec64de425cf9c635c) )
 
@@ -3364,38 +3416,83 @@
 
 *****************************************************************************************/
 
+/* Red Earth / Warzard */
 
-/* todo: use BIOS for the bios roms, having clones only for CD / NO CD */
-
+// 961121
 GAME( 1996, redearth,  0,        redearth, cps3_re,   redearth, ROT0, "Capcom", "Red Earth (Euro 961121)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, redeartha, redearth, redearth, cps3_re,   redearth, ROT0, "Capcom", "Red Earth (Euro 961023)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, warzard,   redearth, redearth, cps3_re,   redearth, ROT0, "Capcom", "Warzard (Japan 961121)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, warzarda,  redearth, redearth, cps3_re,   redearth, ROT0, "Capcom", "Warzard (Japan 961023)", GAME_IMPERFECT_GRAPHICS )
+
+// 961023
+GAME( 1996, redearthr1,redearth, redearth, cps3_re,   redearth, ROT0, "Capcom", "Red Earth (Euro 961023)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, warzardr1, redearth, redearth, cps3_re,   redearth, ROT0, "Capcom", "Warzard (Japan 961023)", GAME_IMPERFECT_GRAPHICS )
+
+/* Street Fighter III: New Generation */
+
+// 970403
+// not dumped
+
+// 970312
+// not dumped
+
+// 970204
 GAME( 1997, sfiii,     0,        sfiii,    cps3,      sfiii,    ROT0, "Capcom", "Street Fighter III: New Generation (USA 970204)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, sfiiij,    sfiii,    sfiii,    cps3,      sfiii,    ROT0, "Capcom", "Street Fighter III: New Generation (Japan 970204)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, sfiiih,    sfiii,    sfiii,    cps3,      sfiii,    ROT0, "Capcom", "Street Fighter III: New Generation (Hispanic 970204)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1997, sfiiin,    sfiii,    sfiii,    cps3,      sfiii,    ROT0, "Capcom", "Street Fighter III: New Generation (Asia 970204, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+/* Street Fighter III 2nd Impact: Giant Attack */
+
+// 971016
+// not dumped
+
+// 970930
 GAME( 1997, sfiii2,    0,        sfiii2,   cps3,      sfiii2,   ROT0, "Capcom", "Street Fighter III 2nd Impact: Giant Attack (USA 970930)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, sfiii2j,   sfiii2,   sfiii2,   cps3,      sfiii2,   ROT0, "Capcom", "Street Fighter III 2nd Impact: Giant Attack (Japan 970930)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojo,      0,        jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (USA 990108)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojoa,     jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (USA 981202)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojoj,     jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo no Kimyouna Bouken (Japan 990108)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojoaj,    jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo no Kimyouna Bouken (Japan 981202)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1997, sfiii2n,   sfiii2,   sfiii2,   cps3,      sfiii2,   ROT0, "Capcom", "Street Fighter III 2nd Impact: Giant Attack (Asia 970930, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+/* JoJo's Venture / JoJo no Kimyouna Bouken */
+
+// 990128
+GAME( 1998, jojo,      0,        jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (USA 990128)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojoj,     jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo no Kimyouna Bouken (Japan 990128)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojon,     jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 990128, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+// 990108
+GAME( 1998, jojor1,    jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (USA 990108)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojojr1,   jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo no Kimyouna Bouken (Japan 990108)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojonr1,   jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 990108, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+// 981202
+GAME( 1998, jojor2,    jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (USA 981202)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojojr2,   jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo no Kimyouna Bouken (Japan 981202)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1998, jojonr2,   jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 981202, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+/* Street Fighter III 3rd Strike: Fight for the Future */
+
+// 990608
 GAME( 1999, sfiii3,    0,        sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Euro 990608)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, sfiii3a,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Euro 990512)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, sfiii3u,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (USA 990608)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, sfiii3au,  sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (USA 990512)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojoba,    0,        jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990927)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojobaa,   jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, sfiii3n,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990608, NO CD)", GAME_IMPERFECT_GRAPHICS )
 
-/* NO CD sets */
+// 990512
+GAME( 1999, sfiii3r1,  sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Euro 990512)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, sfiii3ur1, sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (USA 990512)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, sfiii3nr1, sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990512, NO CD)", GAME_IMPERFECT_GRAPHICS )
 
-GAME( 1997, sfiiin,    sfiii,    sfiii,    cps3,      sfiii,    ROT0, "Capcom", "Street Fighter III: New Generation (Asia 970204, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1997, sfiii2n,   sfiii2,   sfiii2,   cps3,      sfiii2,   ROT0, "Capcom", "Street Fighter III 2nd Impact: Giant Attack (Asia 970930, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojon,     jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 990108, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1998, jojoan,    jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 981202, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, sfiii3n,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990608, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, sfiii3an,  sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990512, NO CD)", GAME_IMPERFECT_GRAPHICS )
+/* JoJo's Bizarre Adventure / JoJo no Kimyouna Bouken: Miraie no Isan */
+
+// 990927
+GAME( 1999, jojoba,    0,        jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990927)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, jojoban,   jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990927, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojobaan,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, jojobane,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990927, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojobaane, jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+// 990913
+GAME( 1999, jojobar1,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobanr1, jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobaner1,jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
+
+
+
+
+
+
diff -Nru src-old/mame/drivers/crshrace.c src/mame/drivers/crshrace.c
--- src-old/mame/drivers/crshrace.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/crshrace.c	2012-03-11 18:17:00.000000000 +0100
@@ -127,7 +127,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "cpu/z80/z80.h"
 #include "cpu/m68000/m68000.h"
 #include "sound/2610intf.h"
 #include "video/konicdev.h"
@@ -168,7 +167,7 @@
 	{
 		state->m_pending_command = 1;
 		soundlatch_w(space, offset, data & 0xff);
-		device_set_input_line(state->m_audiocpu, INPUT_LINE_NMI, PULSE_LINE);
+		state->m_audiocpu->set_input_line(INPUT_LINE_NMI, PULSE_LINE);
 	}
 }
 
@@ -191,9 +190,9 @@
 	AM_RANGE(0x300000, 0x3fffff) AM_READ(extrarom1_r)
 	AM_RANGE(0x400000, 0x4fffff) AM_READ(extrarom2_r)
 	AM_RANGE(0x500000, 0x5fffff) AM_READ(extrarom2_r)	/* mirror */
-	AM_RANGE(0xa00000, 0xa0ffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0xa00000, 0xa0ffff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0xd00000, 0xd01fff) AM_RAM_WRITE(crshrace_videoram1_w) AM_BASE_MEMBER(crshrace_state, m_videoram1)
-	AM_RANGE(0xe00000, 0xe01fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe00000, 0xe01fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xfe0000, 0xfeffff) AM_RAM
 	AM_RANGE(0xffc000, 0xffc001) AM_WRITE(crshrace_roz_bank_w)
 	AM_RANGE(0xffd000, 0xffdfff) AM_RAM_WRITE(crshrace_videoram2_w) AM_BASE_MEMBER(crshrace_state, m_videoram2)
@@ -428,7 +427,7 @@
 static void irqhandler( device_t *device, int irq )
 {
 	crshrace_state *state = device->machine().driver_data<crshrace_state>();
-	device_set_input_line(state->m_audiocpu, 0, irq ? ASSERT_LINE : CLEAR_LINE);
+	state->m_audiocpu->set_input_line(0, irq ? ASSERT_LINE : CLEAR_LINE);
 }
 
 static const ym2610_interface ym2610_config =
@@ -448,9 +447,6 @@
 
 	memory_configure_bank(machine, "bank1", 0, 4, machine.region("audiocpu")->base() + 0x10000, 0x8000);
 
-	state->m_audiocpu = machine.device("audiocpu");
-	state->m_k053936 = machine.device("k053936");
-
 	state->save_item(NAME(state->m_roz_bank));
 	state->save_item(NAME(state->m_gfxctrl));
 	state->save_item(NAME(state->m_flipscreen));
@@ -482,8 +478,6 @@
 	MCFG_MACHINE_RESET(crshrace)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(64*8, 32*8)
@@ -494,6 +488,9 @@
 	MCFG_GFXDECODE(crshrace)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
+
 	MCFG_K053936_ADD("k053936", crshrace_k053936_intf)
 
 	MCFG_VIDEO_START(crshrace)
diff -Nru src-old/mame/drivers/darkseal.c src/mame/drivers/darkseal.c
--- src-old/mame/drivers/darkseal.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/darkseal.c	2012-03-11 18:17:00.000000000 +0100
@@ -2,7 +2,7 @@
 
     Dark Seal (Rev 3)    (c) 1990 Data East Corporation (World version)
     Dark Seal (Rev 1)    (c) 1990 Data East Corporation (World version)
-    Dark Seal            (c) 1990 Data East Corporation (Japanese version)
+    Dark Seal (Rev 4)    (c) 1990 Data East Corporation (Japanese version)
     Gate Of Doom (Rev 4) (c) 1990 Data East Corporation (USA version)
     Gate of Doom (Rev 1) (c) 1990 Data East Corporation (USA version)
 
@@ -27,9 +27,10 @@
 
 static WRITE16_HANDLER( darkseal_control_w )
 {
+	darkseal_state *state = space->machine().driver_data<darkseal_state>();
 	switch (offset<<1) {
     case 6: /* DMA flag */
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
+		state->m_spriteram->copy();
 		return;
     case 8: /* Sound CPU write */
 		soundlatch_w(space, 0, data & 0xff);
@@ -62,7 +63,7 @@
 static ADDRESS_MAP_START( darkseal_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_MEMBER(darkseal_state, m_ram)
-	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x140000, 0x140fff) AM_RAM_WRITE(darkseal_palette_24bit_rg_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x141000, 0x141fff) AM_RAM_WRITE(darkseal_palette_24bit_b_w) AM_BASE_GENERIC(paletteram2)
 	AM_RANGE(0x180000, 0x18000f) AM_READWRITE(darkseal_control_r, darkseal_control_w)
@@ -269,8 +270,6 @@
 	MCFG_CPU_PROGRAM_MAP(sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529))
@@ -281,6 +280,8 @@
 	MCFG_GFXDECODE(darkseal)
 	MCFG_PALETTE_LENGTH(2048)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+
 	MCFG_DECO16IC_ADD("tilegen1", darkseal_deco16ic_tilegen1_intf)
 
 	MCFG_DECO16IC_ADD("tilegen2", darkseal_deco16ic_tilegen2_intf)
@@ -314,160 +315,157 @@
 
 ROM_START( darkseal )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "ga04-3.rom",   0x00000, 0x20000, CRC(bafad556) SHA1(5bd8a787d41a33919701ced29212bc11301e31d9) )
-	ROM_LOAD16_BYTE( "ga01-3.rom",   0x00001, 0x20000, CRC(f409050e) SHA1(4653094aeb5dd7ba1e490c04897a23ba8990df3c) )
-	ROM_LOAD16_BYTE( "ga-00.rom",    0x40000, 0x20000, CRC(fbf3ac63) SHA1(51af581ee951eedeb4aa413ecbebe8bf4d30613b) )
-	ROM_LOAD16_BYTE( "ga-05.rom",    0x40001, 0x20000, CRC(d5e3ae3f) SHA1(12f6e92af115422c6ab6ef1d33675d1e1cd58e10) )
+	ROM_LOAD16_BYTE( "ga_04-3.j12", 0x00000, 0x20000, CRC(bafad556) SHA1(5bd8a787d41a33919701ced29212bc11301e31d9) )
+	ROM_LOAD16_BYTE( "ga_01-3.h14", 0x00001, 0x20000, CRC(f409050e) SHA1(4653094aeb5dd7ba1e490c04897a23ba8990df3c) )
+	ROM_LOAD16_BYTE( "ga_00.h12",   0x40000, 0x20000, CRC(fbf3ac63) SHA1(51af581ee951eedeb4aa413ecbebe8bf4d30613b) )
+	ROM_LOAD16_BYTE( "ga_05.j14",   0x40001, 0x20000, CRC(d5e3ae3f) SHA1(12f6e92af115422c6ab6ef1d33675d1e1cd58e10) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* Sound CPU */
-	ROM_LOAD( "fz-06.rom",    0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
+	ROM_LOAD( "fz_06-1.j15", 0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )
-	ROM_LOAD( "fz-02.rom",    0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
-	ROM_LOAD( "fz-03.rom",    0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
+	ROM_LOAD( "fz_02.j1", 0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
+	ROM_LOAD( "fz_03.j2", 0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
 
 	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "mac-03.rom",   0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
+	ROM_LOAD( "mac-03.h3", 0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
 
 	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "mac-02.rom",   0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
+	ROM_LOAD( "mac-02.e20", 0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
 
 	ROM_REGION( 0x100000, "gfx4", 0 )
-	ROM_LOAD( "mac-00.rom",   0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
-	ROM_LOAD( "mac-01.rom",   0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
+	ROM_LOAD( "mac-00.b1", 0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
+	ROM_LOAD( "mac-01.b3", 0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
 
 	ROM_REGION( 0x40000, "oki1", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-08.rom",    0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
+	ROM_LOAD( "fz_08.l17", 0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
 
 	ROM_REGION( 0x40000, "oki2", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-07.rom",    0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
+	ROM_LOAD( "fz_07.k14", 0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
 ROM_END
 
 ROM_START( darkseal1 )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "ga-04.rom",    0x00000, 0x20000, CRC(a1a985a9) SHA1(eac3f43ff4016dcc21fe34b6bfed36e0d4b86959) )
-	ROM_LOAD16_BYTE( "ga-01.rom",    0x00001, 0x20000, CRC(98bd2940) SHA1(88ac727c3797e646834266320a71aa159e2b2541) )
-	ROM_LOAD16_BYTE( "ga-00.rom",    0x40000, 0x20000, CRC(fbf3ac63) SHA1(51af581ee951eedeb4aa413ecbebe8bf4d30613b) )
-	ROM_LOAD16_BYTE( "ga-05.rom",    0x40001, 0x20000, CRC(d5e3ae3f) SHA1(12f6e92af115422c6ab6ef1d33675d1e1cd58e10) )
+	ROM_LOAD16_BYTE( "ga_04.j12", 0x00000, 0x20000, CRC(a1a985a9) SHA1(eac3f43ff4016dcc21fe34b6bfed36e0d4b86959) )
+	ROM_LOAD16_BYTE( "ga_01.h14", 0x00001, 0x20000, CRC(98bd2940) SHA1(88ac727c3797e646834266320a71aa159e2b2541) )
+	ROM_LOAD16_BYTE( "ga_00.h12", 0x40000, 0x20000, CRC(fbf3ac63) SHA1(51af581ee951eedeb4aa413ecbebe8bf4d30613b) )
+	ROM_LOAD16_BYTE( "ga_05.j14", 0x40001, 0x20000, CRC(d5e3ae3f) SHA1(12f6e92af115422c6ab6ef1d33675d1e1cd58e10) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* Sound CPU */
-	ROM_LOAD( "fz-06.rom",    0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
+	ROM_LOAD( "fz_06-1.j15", 0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )
-	ROM_LOAD( "fz-02.rom",    0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
-	ROM_LOAD( "fz-03.rom",    0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
+	ROM_LOAD( "fz_02.j1", 0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
+	ROM_LOAD( "fz_03.j2", 0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
 
 	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "mac-03.rom",   0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
+	ROM_LOAD( "mac-03.h3", 0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
 
 	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "mac-02.rom",   0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
+	ROM_LOAD( "mac-02.e20", 0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
 
 	ROM_REGION( 0x100000, "gfx4", 0 )
-	ROM_LOAD( "mac-00.rom",   0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
-	ROM_LOAD( "mac-01.rom",   0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
+	ROM_LOAD( "mac-00.b1", 0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
+	ROM_LOAD( "mac-01.b3", 0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
 
 	ROM_REGION( 0x40000, "oki1", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-08.rom",    0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
+	ROM_LOAD( "fz_08.l17", 0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
 
 	ROM_REGION( 0x40000, "oki2", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-07.rom",    0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
+	ROM_LOAD( "fz_07.k14", 0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
 ROM_END
 
 ROM_START( darksealj )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "fz-04.bin",    0x00000, 0x20000, CRC(817faa2c) SHA1(8a79703f0e3aeb2ceeb098466561ab604baef301) )
-	ROM_LOAD16_BYTE( "fz-01.bin",    0x00001, 0x20000, CRC(373caeee) SHA1(5cfa0c7672c439e9d011d9ec93da32c2377dce19) )
-	ROM_LOAD16_BYTE( "fz-00.bin",    0x40000, 0x20000, CRC(1ab99aa7) SHA1(1da51f3ee0d15094911d4090264b945090d51242) )
-	ROM_LOAD16_BYTE( "fz-05.bin",    0x40001, 0x20000, CRC(3374ef8c) SHA1(4144e71e452e281078bcd9b9a996db9f5dccc346) )
+	ROM_LOAD16_BYTE( "fz_04-4.j12", 0x00000, 0x20000, CRC(817faa2c) SHA1(8a79703f0e3aeb2ceeb098466561ab604baef301) )
+	ROM_LOAD16_BYTE( "fz_01-4.h14", 0x00001, 0x20000, CRC(373caeee) SHA1(5cfa0c7672c439e9d011d9ec93da32c2377dce19) )
+	ROM_LOAD16_BYTE( "fz_00-2.h12", 0x40000, 0x20000, CRC(1ab99aa7) SHA1(1da51f3ee0d15094911d4090264b945090d51242) )
+	ROM_LOAD16_BYTE( "fz_05-2.j14", 0x40001, 0x20000, CRC(3374ef8c) SHA1(4144e71e452e281078bcd9b9a996db9f5dccc346) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* Sound CPU */
-	ROM_LOAD( "fz-06.rom",    0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
+	ROM_LOAD( "fz_06-1.j15", 0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )
-	ROM_LOAD( "fz-02.rom",    0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
-	ROM_LOAD( "fz-03.rom",    0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
+	ROM_LOAD( "fz_02.j1", 0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
+	ROM_LOAD( "fz_03.j2", 0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
 
 	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "mac-03.rom",   0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
+	ROM_LOAD( "mac-03.h3", 0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
 
 	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "mac-02.rom",   0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
+	ROM_LOAD( "mac-02.e20", 0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
 
 	ROM_REGION( 0x100000, "gfx4", 0 )
-	ROM_LOAD( "mac-00.rom",   0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
-	ROM_LOAD( "mac-01.rom",   0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
+	ROM_LOAD( "mac-00.b1", 0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
+	ROM_LOAD( "mac-01.b3", 0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
 
 	ROM_REGION( 0x40000, "oki1", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-08.rom",    0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
+	ROM_LOAD( "fz_08.l17", 0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
 
 	ROM_REGION( 0x40000, "oki2", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-07.rom",    0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
+	ROM_LOAD( "fz_07.k14", 0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
 ROM_END
 
 ROM_START( gatedoom )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "gb04-4",       0x00000, 0x20000, CRC(8e3a0bfd) SHA1(1d20bd678a630e2006c7f50f4d13656136db3721) )
-	ROM_LOAD16_BYTE( "gb01-4",       0x00001, 0x20000, CRC(8d0fd383) SHA1(797e3cf43c9315b4195232eb1787a2292af4901b) )
-	ROM_LOAD16_BYTE( "ga-00.rom",    0x40000, 0x20000, CRC(fbf3ac63) SHA1(51af581ee951eedeb4aa413ecbebe8bf4d30613b) )
-	ROM_LOAD16_BYTE( "ga-05.rom",    0x40001, 0x20000, CRC(d5e3ae3f) SHA1(12f6e92af115422c6ab6ef1d33675d1e1cd58e10) )
+	ROM_LOAD16_BYTE( "gb_04-4.j12", 0x00000, 0x20000, CRC(8e3a0bfd) SHA1(1d20bd678a630e2006c7f50f4d13656136db3721) )
+	ROM_LOAD16_BYTE( "gb_01-4.h14", 0x00001, 0x20000, CRC(8d0fd383) SHA1(797e3cf43c9315b4195232eb1787a2292af4901b) )
+	ROM_LOAD16_BYTE( "gb_00.h12",   0x40000, 0x20000, CRC(a88c16a1) SHA1(e02d5470692f23afa658b9bda933bb20be64602f) )
+	ROM_LOAD16_BYTE( "gb_05.j14",   0x40001, 0x20000, CRC(252d7e14) SHA1(b2f27cd9686dfc697f3faca74d20b298a59efab2) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* Sound CPU */
-	ROM_LOAD( "fz-06.rom",    0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
+	ROM_LOAD( "fz_06-1.j15", 0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )
-	ROM_LOAD( "fz-02.rom",    0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
-	ROM_LOAD( "fz-03.rom",    0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
+	ROM_LOAD( "fz_02.j1", 0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
+	ROM_LOAD( "fz_03.j2", 0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
 
 	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "mac-03.rom",   0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
+	ROM_LOAD( "mac-03.h3", 0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
 
 	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "mac-02.rom",   0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
+	ROM_LOAD( "mac-02.e20", 0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
 
 	ROM_REGION( 0x100000, "gfx4", 0 )
-	ROM_LOAD( "mac-00.rom",   0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
-	ROM_LOAD( "mac-01.rom",   0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
+	ROM_LOAD( "mac-00.b1", 0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
+	ROM_LOAD( "mac-01.b3", 0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
 
 	ROM_REGION( 0x40000, "oki1", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-08.rom",    0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
+	ROM_LOAD( "fz_08.l17", 0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
 
 	ROM_REGION( 0x40000, "oki2", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-07.rom",    0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
+	ROM_LOAD( "fz_07.k14", 0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
 ROM_END
 
 ROM_START( gatedoom1 )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "gb04.bin",     0x00000, 0x20000, CRC(4c3bbd2b) SHA1(e74a532edd01a559d0c388b37a2ead98c19fe5de) )
-	ROM_LOAD16_BYTE( "gb01.bin",     0x00001, 0x20000, CRC(59e367f4) SHA1(f88fa23b8e91f312103eb8a1d9a91d8171ec3ad4) )
-	ROM_LOAD16_BYTE( "gb00.bin",     0x40000, 0x20000, CRC(a88c16a1) SHA1(e02d5470692f23afa658b9bda933bb20be64602f) )
-	ROM_LOAD16_BYTE( "gb05.bin",     0x40001, 0x20000, CRC(252d7e14) SHA1(b2f27cd9686dfc697f3faca74d20b298a59efab2) )
+	ROM_LOAD16_BYTE( "gb_04.j12", 0x00000, 0x20000, CRC(4c3bbd2b) SHA1(e74a532edd01a559d0c388b37a2ead98c19fe5de) )
+	ROM_LOAD16_BYTE( "gb_01.h14", 0x00001, 0x20000, CRC(59e367f4) SHA1(f88fa23b8e91f312103eb8a1d9a91d8171ec3ad4) )
+	ROM_LOAD16_BYTE( "gb_00.h12", 0x40000, 0x20000, CRC(a88c16a1) SHA1(e02d5470692f23afa658b9bda933bb20be64602f) )
+	ROM_LOAD16_BYTE( "gb_05.j14", 0x40001, 0x20000, CRC(252d7e14) SHA1(b2f27cd9686dfc697f3faca74d20b298a59efab2) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* Sound CPU */
-	ROM_LOAD( "fz-06.rom",    0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
+	ROM_LOAD( "fz_06-1.j15", 0x00000, 0x10000, CRC(c4828a6d) SHA1(fbfd0c85730bbe18401879cd68c19aaec9d482d8) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )
-	ROM_LOAD( "fz-02.rom",    0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
-	ROM_LOAD( "fz-03.rom",    0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
-
-	/* the following four have not been verified on a real Gate of Doom */
-	/* board - might be different from Dark Seal! */
+	ROM_LOAD( "fz_02.j1", 0x000000, 0x10000, CRC(3c9c3012) SHA1(086c2123725d4aa32838c0b6c82317d9c789c465) )	/* chars */
+	ROM_LOAD( "fz_03.j2", 0x010000, 0x10000, CRC(264b90ed) SHA1(0bb1557673107c2d732a9374d5601a6eaf229473) )
 
 	ROM_REGION( 0x080000, "gfx2", 0 )
-	ROM_LOAD( "mac-03.rom",   0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
+	ROM_LOAD( "mac-03.h3", 0x000000, 0x80000, CRC(9996f3dc) SHA1(fffd9ecfe142a0c7c3c9c521778ff9c55ea8b225) ) /* tiles 1 */
 
 	ROM_REGION( 0x080000, "gfx3", 0 )
-	ROM_LOAD( "mac-02.rom",   0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
+	ROM_LOAD( "mac-02.e20", 0x000000, 0x80000, CRC(49504e89) SHA1(6da4733a650b9040abb2a81a49476368b514b5ab) ) /* tiles 2 */
 
 	ROM_REGION( 0x100000, "gfx4", 0 )
-	ROM_LOAD( "mac-00.rom",   0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
-	ROM_LOAD( "mac-01.rom",   0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
+	ROM_LOAD( "mac-00.b1", 0x000000, 0x80000, CRC(52acf1d6) SHA1(a7b68782417baafc86371b106fd31c5317f5b3d8) ) /* sprites */
+	ROM_LOAD( "mac-01.b3", 0x080000, 0x80000, CRC(b28f7584) SHA1(e02ddd45130a7b50f80b6dd049059dba8071d768) )
 
 	ROM_REGION( 0x40000, "oki1", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-08.rom",    0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
+	ROM_LOAD( "fz_08.l17", 0x00000, 0x20000, CRC(c9bf68e1) SHA1(c81e2534a814fe44c8787946a9fbe18f1743c3b4) )
 
 	ROM_REGION( 0x40000, "oki2", 0 )	/* ADPCM samples */
-	ROM_LOAD( "fz-07.rom",    0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
+	ROM_LOAD( "fz_07.k14", 0x00000, 0x20000, CRC(588dd3cb) SHA1(16c4e7670a4967768ddbfd52939d4e6e42268441) )
 ROM_END
 
 /******************************************************************************/
@@ -486,6 +484,6 @@
 
 GAME( 1990, darkseal,  0,        darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Dark Seal (World revision 3)", 0 )
 GAME( 1990, darkseal1, darkseal, darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Dark Seal (World revision 1)", 0 )
-GAME( 1990, darksealj, darkseal, darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Dark Seal (Japan)", 0 )
+GAME( 1990, darksealj, darkseal, darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Dark Seal (Japan revision 4)", 0 )
 GAME( 1990, gatedoom,  darkseal, darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Gate of Doom (US revision 4)", 0 )
 GAME( 1990, gatedoom1, darkseal, darkseal, darkseal, darkseal, ROT0, "Data East Corporation", "Gate of Doom (US revision 1)", 0 )
diff -Nru src-old/mame/drivers/dassault.c src/mame/drivers/dassault.c
--- src-old/mame/drivers/dassault.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/dassault.c	2012-03-11 18:17:00.000000000 +0100
@@ -219,7 +219,7 @@
 
 	AM_RANGE(0x1c0000, 0x1c000f) AM_READ(dassault_control_r)
 	AM_RANGE(0x1c000a, 0x1c000b) AM_DEVWRITE("deco_common", decocomn_priority_w)
-	AM_RANGE(0x1c000c, 0x1c000d) AM_WRITE(buffer_spriteram16_2_w)
+	AM_RANGE(0x1c000c, 0x1c000d) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write)
 	AM_RANGE(0x1c000e, 0x1c000f) AM_WRITE(dassault_control_w)
 
 	AM_RANGE(0x200000, 0x201fff) AM_DEVREADWRITE("tilegen1", deco16ic_pf1_data_r, deco16ic_pf1_data_w)
@@ -233,7 +233,7 @@
 	AM_RANGE(0x260000, 0x26000f) AM_DEVWRITE("tilegen2", deco16ic_pf_control_w)
 
 	AM_RANGE(0x3f8000, 0x3fbfff) AM_RAM AM_BASE_MEMBER(dassault_state, m_ram) /* Main ram */
-	AM_RANGE(0x3fc000, 0x3fcfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2) /* Spriteram (2nd) */
+	AM_RANGE(0x3fc000, 0x3fcfff) AM_RAM AM_SHARE("spriteram2") /* Spriteram (2nd) */
 	AM_RANGE(0x3feffc, 0x3fefff) AM_READWRITE(dassault_irq_r, dassault_irq_w)
 	AM_RANGE(0x3fe000, 0x3fefff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(dassault_state, m_shared_ram) /* Shared ram */
 ADDRESS_MAP_END
@@ -241,12 +241,12 @@
 static ADDRESS_MAP_START( dassault_sub_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 
-	AM_RANGE(0x100000, 0x100001) AM_WRITE(buffer_spriteram16_w)
+	AM_RANGE(0x100000, 0x100001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write)
 	AM_RANGE(0x100002, 0x100007) AM_WRITENOP /* ? */
 	AM_RANGE(0x100004, 0x100005) AM_READ(dassault_sub_control_r)
 
 	AM_RANGE(0x3f8000, 0x3fbfff) AM_RAM AM_BASE_MEMBER(dassault_state, m_ram2) /* Sub cpu ram */
-	AM_RANGE(0x3fc000, 0x3fcfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Sprite ram */
+	AM_RANGE(0x3fc000, 0x3fcfff) AM_RAM AM_SHARE("spriteram") /* Sprite ram */
 	AM_RANGE(0x3feffc, 0x3fefff) AM_READWRITE(dassault_irq_r, dassault_irq_w)
 	AM_RANGE(0x3fe000, 0x3fefff) AM_READWRITE(shared_ram_r, shared_ram_w)
 ADDRESS_MAP_END
@@ -582,8 +582,6 @@
 	MCFG_QUANTUM_PERFECT_CPU("maincpu") // I was seeing random lockups.. let's see if this helps
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529))
@@ -596,6 +594,9 @@
 	MCFG_GFXDECODE(dassault)
 	MCFG_PALETTE_LENGTH(4096)
 
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
+
 	MCFG_DECOCOMN_ADD("deco_common", dassault_decocomn_intf)
 
 	MCFG_DECO16IC_ADD("tilegen1", dassault_deco16ic_tilegen1_intf)
diff -Nru src-old/mame/drivers/dec8.c src/mame/drivers/dec8.c
--- src-old/mame/drivers/dec8.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/dec8.c	2012-03-11 18:17:00.000000000 +0100
@@ -2,34 +2,36 @@
 
 Various Data East 8 bit games:
 
-    Cobra Command (World)       (c) 1988 Data East Corporation (6809)
-    Cobra Command (Japan)       (c) 1988 Data East Corporation (6809)
-    The Real Ghostbusters (2p)  (c) 1987 Data East USA (6809 + I8751)
-    The Real Ghostbusters (3p)  (c) 1987 Data East USA (6809 + I8751)
-    Meikyuu Hunter G            (c) 1987 Data East Corporation (6809 + I8751)
-    Super Real Darwin           (c) 1987 Data East Corporation (6809 + I8751)
-    Psycho-Nics Oscar           (c) 1988 Data East USA (2*6809 + I8751)
-    Psycho-Nics Oscar (Japan)   (c) 1987 Data East Corporation (2*6809 + I8751)
-    Gondomania                  (c) 1987 Data East USA (6809 + I8751)
-    Makyou Senshi               (c) 1987 Data East Corporation (6809 + I8751)
     Last Mission (rev 6)        (c) 1986 Data East USA (2*6809 + I8751)
     Last Mission (rev 5)        (c) 1986 Data East USA (2*6809 + I8751)
+    Last Mission (Japan)        (c) 1986 Data East Corporation (2*6809 + I8751)
     Shackled                    (c) 1986 Data East USA (2*6809 + I8751)
     Breywood                    (c) 1986 Data East Corporation (2*6809 + I8751)
+    Gondomania                  (c) 1987 Data East USA (6809 + I8751)
+    Makyou Senshi               (c) 1987 Data East Corporation (6809 + I8751)
+    Garyo Retsuden              (c) 1987 Data East Corporation (6809 + I8751)
+    The Real Ghostbusters (2p)  (c) 1987 Data East USA (6809 + I8751)
+    The Real Ghostbusters (3p)  (c) 1987 Data East USA (6809 + I8751)
+    Meikyuu Hunter G            (c) 1987 Data East Corporation (6809 + I8751)
     Captain Silver (World)      (c) 1987 Data East Corporation (2*6809 + I8751)
     Captain Silver (Japan)      (c) 1987 Data East Corporation (2*6809 + I8751)
-    Garyo Retsuden (Japan)      (c) 1987 Data East Corporation (6809 + I8751)
+    Psycho-Nics Oscar (World)   (c) 1987 Data East Corporation (2*6809 + I8751)
+    Psycho-Nics Oscar (US)      (c) 1988 Data East USA (2*6809 + I8751)
+    Psycho-Nics Oscar (Japan)   (c) 1987 Data East Corporation (2*6809 + I8751)
+    Super Real Darwin (World)   (c) 1987 Data East Corporation (6809 + I8751)
+    Super Real Darwin (Japan)   (c) 1987 Data East Corporation (6809 + I8751)
+    Cobra Command (World)       (c) 1988 Data East Corporation (6809)
+    Cobra Command (Japan)       (c) 1988 Data East Corporation (6809)
 
     All games use a 6502 for sound (some are encrypted), all games except Cobracom
-    use an Intel 8751 for protection & coinage.  For these games the coinage dip
-    switch is not currently supported, they are fixed at 1 coin 1 credit.
+    use an Intel 8751 for protection & coinage. For the games without (fake) MCU,
+    the coinage dip switch (sometimes based on the manual) is simulated.
 
     Meikyuu Hunter G was formerly known as Mazehunter.
 
     Emulation by Bryan McPhail, mish@tendril.co.uk
 
 To do:
-    Support coinage options for all i8751 emulations.
     Super Real Darwin 'Double' sprites appearing from the top of the screen are clipped
     Strangely coloured butterfly on Garyo Retsuden water levels!
 
@@ -56,7 +58,7 @@
 static WRITE8_HANDLER( dec8_mxc06_karn_buffer_spriteram_w)
 {
 	dec8_state *state = space->machine().driver_data<dec8_state>();
-	UINT8* spriteram = space->machine().generic.spriteram.u8;
+	UINT8* spriteram = state->m_spriteram->live();
 	// copy to a 16-bit region for the sprite chip
 	for (int i=0;i<0x800/2;i++)
 	{
@@ -162,81 +164,77 @@
 *
 ********************************/
 
-static WRITE8_HANDLER( srdarwin_i8751_w )
+static WRITE8_HANDLER( lastmisn_i8751_w )
 {
 	dec8_state *state = space->machine().driver_data<dec8_state>();
+
+	/* Japan coinage first, then World coinage - US coinage shall be the same as the Japan one */
+	int lneed1[2][4] = {{1, 1, 1, 2}, {1, 1, 1, 1}};   /* slot 1 : coins needed */
+	int lcred1[2][4] = {{1, 2, 3, 1}, {1, 2, 3, 5}};   /* slot 1 : credits awarded */
+	int lneed2[2][4] = {{1, 1, 1, 2}, {1, 2, 3, 4}};   /* slot 2 : coins needed */
+	int lcred2[2][4] = {{1, 2, 3, 1}, {1, 1, 1, 1}};   /* slot 2 : credits awarded */
+
 	state->m_i8751_return = 0;
 
 	switch (offset)
 	{
 	case 0: /* High byte */
 		state->m_i8751_value = (state->m_i8751_value & 0xff) | (data << 8);
+		device_set_input_line(state->m_maincpu, M6809_FIRQ_LINE, HOLD_LINE); /* Signal main cpu */
 		break;
 	case 1: /* Low byte */
 		state->m_i8751_value = (state->m_i8751_value & 0xff00) | data;
 		break;
 	}
 
-	if (state->m_i8751_value == 0x0000) {state->m_i8751_return = 0; state->m_coin1 = 0;}
-	if (state->m_i8751_value == 0x3063) state->m_i8751_return = 0x9c;				/* Protection - Japanese version */
-	if (state->m_i8751_value == 0x306b) state->m_i8751_return = 0x94;				/* Protection - World version */
-	if ((state->m_i8751_value & 0xff00) == 0x4000) state->m_i8751_return = state->m_i8751_value;	/* Coinage settings */
-	if (state->m_i8751_value == 0x5000) state->m_i8751_return = ((state->m_coin1 / 10) << 4) | (state->m_coin1 % 10);	/* Coin request */
-	if (state->m_i8751_value == 0x6000) {state->m_i8751_value = -1; state->m_coin1--; }	/* Coin clear */
-	/* Nb:  Command 0x4000 for setting coinage options is not sup3ed */
-	if ((input_port_read(space->machine(), "FAKE") & 1) == 1) state->m_latch = 1;
-	if ((input_port_read(space->machine(), "FAKE") & 1) != 1 && state->m_latch) {state->m_coin1++; state->m_latch = 0;}
-
-	/* This next value is the index to a series of tables,
-    each table controls the end of level bad guy, wrong values crash the
-    cpu right away via a bogus jump.
-
-    Level number requested is in low byte
-
-    Addresses on left hand side are from the protection vector table which is
-    stored at location 0xf580 in rom dy_01.rom
+	/* Coins are controlled by the i8751 */
+	if ((input_port_read(space->machine(), "IN2") & 3) == 3) state->m_latch = 1;
+	if ((input_port_read(space->machine(), "IN2") & 1) != 1 && state->m_latch)
+	{
+		state->m_coin1++;
+		state->m_latch = 0;
+		state->m_snd = 0x400;
+		state->m_i8751_return = 0x400;
+		if (state->m_coin1>=state->m_need1)
+		{
+			state->m_coin1-=state->m_need1;
+			state->m_credits+=state->m_cred1;
+		}
+	}
+	if ((input_port_read(space->machine(), "IN2") & 2) != 2 && state->m_latch)
+	{
+		state->m_coin2++;
+		state->m_latch = 0;
+		state->m_snd = 0x400;
+		state->m_i8751_return = 0x400;
+		if (state->m_coin2>=state->m_need2)
+		{
+			state->m_coin2-=state->m_need2;
+			state->m_credits+=state->m_cred2;
+		}
+	}
+	if (state->m_credits>99) state->m_credits=99; /* not handled by main CPU */
 
-ba5e (lda #00) = Level 0?
-ba82 (lda #01) = Pyramid boss, Level 1?
-baaa           = No boss appears, game hangs
-bacc (lda #04) = Killer Bee boss, Level 4?
-bae0 (lda #03) = Snake type boss, Level 3?
-baf9           = Double grey thing boss...!
-bb0a           = Single grey thing boss!
-bb18 (lda #00) = Hailstorm from top of screen.
-bb31 (lda #28) = Small hailstorm
-bb47 (ldb #05) = Small hailstorm
-bb5a (lda #08) = Weird square things..
-bb63           = Square things again
-(24)           = Another square things boss..
-(26)           = Clock boss! (level 3)
-(28)           = Big dragon boss, perhaps an end-of-game baddy
-(30)           = 4 things appear at corners, seems to fit with attract mode (level 1)
-(32)           = Grey things teleport onto screen..
-(34)           = Grey thing appears in middle of screen
-(36)           = As above
-(38)           = Circle thing with two pincers
-(40)           = Grey bird
-(42)           = Crash (end of table)
+	if (state->m_i8751_value == 0x0401) state->m_i8751_return = 0;    /* ??? */
 
-    The table below is hopefully correct thanks to Jose Miguel Morales Farreras,
-    but Boss #6 is uncomfirmed as correct.
+	if (state->m_i8751_value == 0x007a) { state->m_i8751_return = 0x85; state->m_coinage_id = 0; }  /* Japanese version ID */
+	if (state->m_i8751_value == 0x007b) { state->m_i8751_return = 0x84; state->m_coinage_id = 0; }  /* US version ID */
 
-*/
-	if (state->m_i8751_value == 0x8000) state->m_i8751_return = 0xf580 +  0; /* Boss #1: Snake + Bees */
-	if (state->m_i8751_value == 0x8001) state->m_i8751_return = 0xf580 + 30; /* Boss #2: 4 Corners */
-	if (state->m_i8751_value == 0x8002) state->m_i8751_return = 0xf580 + 26; /* Boss #3: Clock */
-	if (state->m_i8751_value == 0x8003) state->m_i8751_return = 0xf580 +  2; /* Boss #4: Pyramid */
-	if (state->m_i8751_value == 0x8004) state->m_i8751_return = 0xf580 +  6; /* Boss #5: Snake + Head Combo */
-	if (state->m_i8751_value == 0x8005) state->m_i8751_return = 0xf580 + 24; /* Boss #6: LED Panels */
-	if (state->m_i8751_value == 0x8006) state->m_i8751_return = 0xf580 + 28; /* Boss #7: Dragon */
-	if (state->m_i8751_value == 0x8007) state->m_i8751_return = 0xf580 + 32; /* Boss #8: Teleport */
-	if (state->m_i8751_value == 0x8008) state->m_i8751_return = 0xf580 + 38; /* Boss #9: Octopus (Pincer) */
-	if (state->m_i8751_value == 0x8009) state->m_i8751_return = 0xf580 + 40; /* Boss #10: Bird */
-	if (state->m_i8751_value == 0x800a) state->m_i8751_return = 0xf580 + 42; /* End Game(bad address?) */
+	if (offset == 0)
+	{
+		if ((state->m_i8751_value >> 8) == 0x01) /* Coinage settings */
+		{
+			state->m_i8751_return = state->m_i8751_value;
+			state->m_need1 = lneed1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+			state->m_need2 = lneed2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+			state->m_cred1 = lcred1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+			state->m_cred2 = lcred2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+		}
+		if ((state->m_i8751_value >> 8) == 0x02) { state->m_i8751_return = state->m_snd | ((state->m_credits / 10) << 4) | (state->m_credits % 10); state->m_snd = 0; }   /* Credits request */
+		if ((state->m_i8751_value >> 8) == 0x03 && state->m_credits) { state->m_i8751_return = 0; state->m_credits--; } /* Credits clear */
+	}
 }
 
-
 static WRITE8_HANDLER( shackled_i8751_w )
 {
 	dec8_state *state = space->machine().driver_data<dec8_state>();
@@ -246,7 +244,7 @@
 	{
 	case 0: /* High byte */
 		state->m_i8751_value = (state->m_i8751_value & 0xff) | (data << 8);
-		device_set_input_line(state->m_subcpu, M6809_FIRQ_LINE, HOLD_LINE); /* Signal main cpu */
+		device_set_input_line(state->m_subcpu, M6809_FIRQ_LINE, HOLD_LINE); /* Signal sub cpu */
 		break;
 	case 1: /* Low byte */
 		state->m_i8751_value = (state->m_i8751_value & 0xff00) | data;
@@ -254,21 +252,31 @@
 	}
 
 	/* Coins are controlled by the i8751 */
-	if (/*(input_port_read(space->machine(), "IN2") & 3) == 3*/!state->m_latch) {state->m_latch = 1; state->m_coin1 = state->m_coin2 = 0;}
-	if ((input_port_read(space->machine(), "IN2") & 1) != 1 && state->m_latch)  {state->m_coin1 = 1; state->m_latch = 0;}
-	if ((input_port_read(space->machine(), "IN2") & 2) != 2 && state->m_latch)  {state->m_coin2 = 1; state->m_latch = 0;}
-
-	if (state->m_i8751_value == 0x0050) state->m_i8751_return = 0; /* Breywood ID */
-	if (state->m_i8751_value == 0x0051) state->m_i8751_return = 0; /* Shackled ID */
-	if (state->m_i8751_value == 0x0102) state->m_i8751_return = 0; /* ?? */
-	if (state->m_i8751_value == 0x0101) state->m_i8751_return = 0; /* ?? */
-	if (state->m_i8751_value == 0x8101) state->m_i8751_return = ((state->m_coin2 / 10) << 4) | (state->m_coin2 % 10) |
-			((((state->m_coin1 / 10) << 4) | (state->m_coin1 % 10)) << 8); /* Coins */
+	if (/*(input_port_read(space->machine(), "IN2") & 3) == 3*/!state->m_latch) { state->m_latch = 1; state->m_coin1 = state->m_coin2 = 0; }
+	if ((input_port_read(space->machine(), "IN2") & 1) != 1 && state->m_latch)  { state->m_coin1 = 1; state->m_latch = 0; }
+	if ((input_port_read(space->machine(), "IN2") & 2) != 2 && state->m_latch)  { state->m_coin2 = 1; state->m_latch = 0; }
+
+	if (state->m_i8751_value == 0x0102) state->m_i8751_return = 0;    /* ??? */
+	if (state->m_i8751_value == 0x0101) state->m_i8751_return = 0;    /* ??? */
+	if (state->m_i8751_value == 0x0400) state->m_i8751_return = 0;    /* ??? */
+
+	if (state->m_i8751_value == 0x0050) state->m_i8751_return = 0; /* Japanese version (Breywood) ID */
+	if (state->m_i8751_value == 0x0051) state->m_i8751_return = 0; /* US version (Shackled) ID */
+
+	if (state->m_i8751_value == 0x8101) state->m_i8751_return = ((((state->m_coin2 / 10) << 4) | (state->m_coin2 % 10)) << 0) |
+																((((state->m_coin1 / 10) << 4) | (state->m_coin1 % 10)) << 8);    /* Coins */
 }
 
-static WRITE8_HANDLER( lastmisn_i8751_w )
+static WRITE8_HANDLER( csilver_i8751_w )
 {
 	dec8_state *state = space->machine().driver_data<dec8_state>();
+
+	/* Japan coinage first, then World coinage - US coinage shall be the same as the Japan one */
+	int lneed1[2][4] = {{1, 1, 1, 2}, {1, 1, 1, 1}};   /* slot 1 : coins needed */
+	int lcred1[2][4] = {{1, 2, 3, 1}, {2, 3, 4, 6}};   /* slot 1 : credits awarded */
+	int lneed2[2][4] = {{1, 1, 1, 2}, {1, 2, 3, 4}};   /* slot 2 : coins needed */
+	int lcred2[2][4] = {{1, 2, 3, 1}, {1, 1, 1, 1}};   /* slot 2 : credits awarded */
+
 	state->m_i8751_return = 0;
 
 	switch (offset)
@@ -282,55 +290,62 @@
 		break;
 	}
 
-	if (offset == 0)
+	/* Coins are controlled by the i8751 */
+	if ((input_port_read(space->machine(), "IN2") & 3) == 3) state->m_latch = 1;
+	if ((input_port_read(space->machine(), "IN2") & 1) != 1 && state->m_latch)
 	{
-		/* Coins are controlled by the i8751 */
-		if ((input_port_read(space->machine(), "IN2") & 3) == 3 && !state->m_latch) state->m_latch = 1;
-		if ((input_port_read(space->machine(), "IN2") & 3) != 3 && state->m_latch) {state->m_coin1++; state->m_latch = 0; state->m_snd = 0x400; state->m_i8751_return = 0x400; return;}
-		if (state->m_i8751_value == 0x007a) state->m_i8751_return = 0x0185; /* Japan ID code */
-		if (state->m_i8751_value == 0x007b) state->m_i8751_return = 0x0184; /* USA ID code */
-		if (state->m_i8751_value == 0x0001) {state->m_coin1 = state->m_snd = 0;}//???
-		if (state->m_i8751_value == 0x0000) {state->m_i8751_return = 0x0184;}//???
-		if (state->m_i8751_value == 0x0401) state->m_i8751_return = 0x0184; //???
-		if ((state->m_i8751_value >> 8) == 0x01) state->m_i8751_return = 0x0184; /* Coinage setup */
-		if ((state->m_i8751_value >> 8) == 0x02) {state->m_i8751_return = state->m_snd | ((state->m_coin1 / 10) << 4) | (state->m_coin1 % 10); state->m_snd = 0;} /* Coin return */
-		if ((state->m_i8751_value >> 8) == 0x03 && state->m_coin1) {state->m_i8751_return = 0; state->m_coin1--; } /* Coin clear */
+		state->m_coin1++;
+		state->m_latch = 0;
+		state->m_snd = 0x1200;
+		state->m_i8751_return = 0x1200;
+		if (state->m_coin1>=state->m_need1)
+		{
+			state->m_coin1-=state->m_need1;
+			state->m_credits+=state->m_cred1;
+		}
 	}
-}
-
-static WRITE8_HANDLER( csilver_i8751_w )
-{
-	dec8_state *state = space->machine().driver_data<dec8_state>();
-	state->m_i8751_return = 0;
-
-	switch (offset)
+	if ((input_port_read(space->machine(), "IN2") & 2) != 2 && state->m_latch)
 	{
-	case 0: /* High byte */
-		state->m_i8751_value = (state->m_i8751_value & 0xff) | (data << 8);
-		device_set_input_line(state->m_maincpu, M6809_FIRQ_LINE, HOLD_LINE); /* Signal main cpu */
-		break;
-	case 1: /* Low byte */
-		state->m_i8751_value = (state->m_i8751_value & 0xff00) | data;
-		break;
+		state->m_coin2++;
+		state->m_latch = 0;
+		state->m_snd = 0x1200;
+		state->m_i8751_return = 0x1200;
+		if (state->m_coin2>=state->m_need2)
+		{
+			state->m_coin2-=state->m_need2;
+			state->m_credits+=state->m_cred2;
+		}
 	}
+	if (state->m_credits>99) state->m_credits=99; /* not handled by main CPU */
+
+	if (state->m_i8751_value == 0x054a) { state->m_i8751_return = 0xb5; state->m_coinage_id = 0; }  /* Japanese version ID */
+	if (state->m_i8751_value == 0x054c) { state->m_i8751_return = 0xb3; state->m_coinage_id = 1; }  /* World version ID */
 
 	if (offset == 0)
 	{
-		/* Coins are controlled by the i8751 */
-		if ((input_port_read(space->machine(), "IN2") & 3) == 3 && !state->m_latch) state->m_latch = 1;
-		if ((input_port_read(space->machine(), "IN2") & 3) != 3 && state->m_latch) {state->m_coin1++; state->m_latch = 0; state->m_snd = 0x1200; state->m_i8751_return = 0x1200; return;}
-
-		if (state->m_i8751_value == 0x054a) {state->m_i8751_return = ~(0x4a); state->m_coin1 = 0; state->m_snd = 0;} /* Captain Silver (Japan) ID */
-		if (state->m_i8751_value == 0x054c) {state->m_i8751_return = ~(0x4c); state->m_coin1 = 0; state->m_snd = 0;} /* Captain Silver (World) ID */
-		if ((state->m_i8751_value >> 8) == 0x01) state->m_i8751_return = 0; /* Coinage - Not Supported */
-		if ((state->m_i8751_value >> 8) == 0x02) {state->m_i8751_return = state->m_snd | state->m_coin1; state->m_snd = 0; } /* Coin Return */
-		if ((state->m_i8751_value >> 8) == 0x03 && state->m_coin1) {state->m_i8751_return = 0; state->m_coin1--;} /* Coin Clear */
+		if ((state->m_i8751_value >> 8) == 0x01) /* Coinage settings */
+		{
+			state->m_i8751_return = state->m_i8751_value;
+			state->m_need1 = lneed1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+			state->m_need2 = lneed2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+			state->m_cred1 = lcred1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+			state->m_cred2 = lcred2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+		}
+		if ((state->m_i8751_value >> 8) == 0x02) { state->m_i8751_return = state->m_snd | state->m_credits; state->m_snd = 0; }   /* Credits request */
+		if ((state->m_i8751_value >> 8) == 0x03 && state->m_credits) { state->m_i8751_return = 0; state->m_credits--; } /* Credits clear */
 	}
 }
 
-static WRITE8_HANDLER( garyoret_i8751_w )
+static WRITE8_HANDLER( srdarwin_i8751_w )
 {
 	dec8_state *state = space->machine().driver_data<dec8_state>();
+
+	/* Japan coinage first, then World coinage - US coinage shall be the same as the Japan one */
+	int lneed1[2][4] = {{1, 1, 1, 2}, {1, 1, 1, 1}};   /* slot 1 : coins needed */
+	int lcred1[2][4] = {{1, 2, 3, 1}, {2, 3, 4, 6}};   /* slot 1 : credits awarded */
+	int lneed2[2][4] = {{1, 1, 1, 2}, {1, 2, 3, 4}};   /* slot 2 : coins needed */
+	int lcred2[2][4] = {{1, 2, 3, 1}, {1, 1, 1, 1}};   /* slot 2 : credits awarded */
+
 	state->m_i8751_return = 0;
 
 	switch (offset)
@@ -345,15 +360,91 @@
 
 	/* Coins are controlled by the i8751 */
 	if ((input_port_read(space->machine(), "I8751") & 3) == 3) state->m_latch = 1;
-	if ((input_port_read(space->machine(), "I8751") & 1) != 1 && state->m_latch) {state->m_coin1++; state->m_latch = 0;}
-	if ((input_port_read(space->machine(), "I8751") & 2) != 2 && state->m_latch) {state->m_coin2++; state->m_latch = 0;}
+	if ((input_port_read(space->machine(), "I8751") & 1) != 1 && state->m_latch)
+	{
+		state->m_coin1++;
+		state->m_latch = 0;
+		if (state->m_coin1>=state->m_need1)
+		{
+			state->m_coin1-=state->m_need1;
+			state->m_credits+=state->m_cred1;
+		}
+	}
+	if ((input_port_read(space->machine(), "I8751") & 2) != 2 && state->m_latch)
+	{
+		state->m_coin2++;
+		state->m_latch = 0;
+		if (state->m_coin2>=state->m_need2)
+		{
+			state->m_coin2-=state->m_need2;
+			state->m_credits+=state->m_cred2;
+		}
+	}
+	if (state->m_credits>99) state->m_credits=99; /* not handled by main CPU */
+
+	if (state->m_i8751_value == 0x0000) state->m_i8751_return = 0;    /* ??? */
+
+	if (state->m_i8751_value == 0x3063)	{ state->m_i8751_return = 0x9c; state->m_coinage_id = 0; }  /* Japanese version ID */
+	if (state->m_i8751_value == 0x306b)	{ state->m_i8751_return = 0x94; state->m_coinage_id = 1; }  /* World version ID */
+
+	if ((state->m_i8751_value >> 8) == 0x40) /* Coinage settings */
+	{
+		state->m_i8751_return = state->m_i8751_value;
+		state->m_need1 = lneed1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+		state->m_need2 = lneed2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+		state->m_cred1 = lcred1[state->m_coinage_id][(state->m_i8751_value & 0x03) >> 0];
+		state->m_cred2 = lcred2[state->m_coinage_id][(state->m_i8751_value & 0x0c) >> 2];
+	}
+	if (state->m_i8751_value == 0x5000) { state->m_i8751_return = ((state->m_credits / 10) << 4) | (state->m_credits % 10); } /* Credits request */
+	if (state->m_i8751_value == 0x6000 && state->m_credits) { state->m_i8751_value = -1; state->m_credits--; }     /* Credits clear */
+
+/*
+    This next value is the index to a series of tables,
+    each table controls the end of level bad guy,
+    wrong values crash the cpu right away via a bogus jump.
+
+    Level number requested is in low byte
+
+    Addresses on left hand side are from the protection vector table which is
+    stored at location 0xf580 in rom dy_01.rom
+
+ba5e (lda #00) = Level 0?
+ba82 (lda #01) = Pyramid boss, Level 1?
+baaa           = No boss appears, game hangs
+bacc (lda #04) = Killer Bee boss, Level 4?
+bae0 (lda #03) = Snake type boss, Level 3?
+baf9           = Double grey thing boss...!
+bb0a           = Single grey thing boss!
+bb18 (lda #00) = Hailstorm from top of screen.
+bb31 (lda #28) = Small hailstorm
+bb47 (ldb #05) = Small hailstorm
+bb5a (lda #08) = Weird square things..
+bb63           = Square things again
+(24)           = Another square things boss..
+(26)           = Clock boss! (level 3)
+(28)           = Big dragon boss, perhaps an end-of-game baddy
+(30)           = 4 things appear at corners, seems to fit with attract mode (level 1)
+(32)           = Grey things teleport onto screen..
+(34)           = Grey thing appears in middle of screen
+(36)           = As above
+(38)           = Circle thing with two pincers
+(40)           = Grey bird
+(42)           = Crash (end of table)
 
-	/* Work out return values */
-	if ((state->m_i8751_value >> 8) == 0x00) {state->m_i8751_return = 0; state->m_coin1 = state->m_coin2 = 0;}
-	if ((state->m_i8751_value >> 8) == 0x01)  state->m_i8751_return = 0x59a; /* ID */
-	if ((state->m_i8751_value >> 8) == 0x04)  state->m_i8751_return = state->m_i8751_value; /* Coinage settings (Not supported) */
-	if ((state->m_i8751_value >> 8) == 0x05) {state->m_i8751_return = 0x00 | ((state->m_coin1 / 10) << 4) | (state->m_coin1 % 10);  } /* Coin 1 */
-	if ((state->m_i8751_value >> 8) == 0x06 && state->m_coin1 && !offset) {state->m_i8751_return = 0x600; state->m_coin1--; } /* Coin 1 clear */
+    The table below is hopefully correct thanks to Jose Miguel Morales Farreras,
+    but Boss #6 is uncomfirmed as correct.
+*/
+	if (state->m_i8751_value == 0x8000) state->m_i8751_return = 0xf580 +  0; /* Boss #1: Snake + Bees */
+	if (state->m_i8751_value == 0x8001) state->m_i8751_return = 0xf580 + 30; /* Boss #2: 4 Corners */
+	if (state->m_i8751_value == 0x8002) state->m_i8751_return = 0xf580 + 26; /* Boss #3: Clock */
+	if (state->m_i8751_value == 0x8003) state->m_i8751_return = 0xf580 +  2; /* Boss #4: Pyramid */
+	if (state->m_i8751_value == 0x8004) state->m_i8751_return = 0xf580 +  6; /* Boss #5: Snake + Head Combo */
+	if (state->m_i8751_value == 0x8005) state->m_i8751_return = 0xf580 + 24; /* Boss #6: LED Panels */
+	if (state->m_i8751_value == 0x8006) state->m_i8751_return = 0xf580 + 28; /* Boss #7: Dragon */
+	if (state->m_i8751_value == 0x8007) state->m_i8751_return = 0xf580 + 32; /* Boss #8: Teleport */
+	if (state->m_i8751_value == 0x8008) state->m_i8751_return = 0xf580 + 38; /* Boss #9: Octopus (Pincer) */
+	if (state->m_i8751_value == 0x8009) state->m_i8751_return = 0xf580 + 40; /* Boss #10: Bird */
+	if (state->m_i8751_value == 0x800a) state->m_i8751_return = 0xf580 + 42; /* End Game(bad address?) */
 }
 
 /******************************************************************************/
@@ -498,84 +589,104 @@
 
 /******************************************************************************/
 
-static READ8_HANDLER( shackled_sprite_r ) { return space->machine().generic.spriteram.u8[offset]; }
-static WRITE8_HANDLER( shackled_sprite_w ) { space->machine().generic.spriteram.u8[offset] = data; }
 static WRITE8_HANDLER( flip_screen_w ) { flip_screen_set(space->machine(), data); }
 
 /******************************************************************************/
 
 
-
-static ADDRESS_MAP_START( cobra_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x07ff) AM_RAM
-	AM_RANGE(0x0800, 0x0fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
-	AM_RANGE(0x1000, 0x17ff) AM_DEVREADWRITE("tilegen2", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
-	AM_RANGE(0x1800, 0x1fff) AM_RAM
+static ADDRESS_MAP_START( lastmisn_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3") AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4") AM_BASE_GENERIC(paletteram2)
+	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
+	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
+	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
+	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")	/* Dip 2 */
+	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
+	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
+	AM_RANGE(0x1806, 0x1806) AM_READ(i8751_h_r)
+	AM_RANGE(0x1807, 0x1807) AM_READWRITE(i8751_l_r, flip_screen_w)
+	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
+	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
+	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x180d, 0x180d) AM_WRITE(lastmisn_control_w) /* Bank switch + Scroll MSB */
+	AM_RANGE(0x180e, 0x180f) AM_WRITE(lastmisn_i8751_w)
 	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x3000, 0x31ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_be_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x3200, 0x37ff) AM_WRITEONLY /* Unused */
-	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("IN0")	/* Player 1 */
-	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN1")	/* Player 2 */
-	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW1")	/* Dip 2 */
-	AM_RANGE(0x3800, 0x3807) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
-	AM_RANGE(0x3810, 0x381f) AM_DEVWRITE("tilegen1", deco_bac06_pf_control1_8bit_w)
-	AM_RANGE(0x3a00, 0x3a00) AM_READ_PORT("IN2")	/* VBL & coins */
-	AM_RANGE(0x3a00, 0x3a07) AM_DEVWRITE("tilegen2", deco_bac06_pf_control0_8bit_w)
-	AM_RANGE(0x3a10, 0x3a1f) AM_DEVWRITE("tilegen2", deco_bac06_pf_control1_8bit_w)
-	AM_RANGE(0x3c00, 0x3c00) AM_WRITE(dec8_bank_w)
-	AM_RANGE(0x3c02, 0x3c02) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x3e00, 0x3e00) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( meikyuh_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0fff) AM_RAM
-	AM_RANGE(0x1000, 0x17ff) AM_RAM
-	AM_RANGE(0x1800, 0x1fff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2000, 0x27ff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
-	AM_RANGE(0x2800, 0x2bff) AM_RAM // colscroll? mirror?
-	AM_RANGE(0x2c00, 0x2fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_rowscroll_8bit_r, deco_bac06_pf_rowscroll_8bit_w)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("IN0")	/* Player 1 */
-	AM_RANGE(0x3800, 0x3800) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN1")	/* Player 2 */
-	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("IN2")	/* Player 3 */
-	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW0")	/* Start buttons + VBL */
-	AM_RANGE(0x3820, 0x3820) AM_READ_PORT("DSW1")	/* Dip */
-	AM_RANGE(0x3820, 0x3827) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
-	AM_RANGE(0x3830, 0x383f) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_control1_8bit_r, deco_bac06_pf_control1_8bit_w)
-	AM_RANGE(0x3840, 0x3840) AM_READ(i8751_h_r)
-	AM_RANGE(0x3840, 0x3840) AM_WRITE(ghostb_bank_w)
-	AM_RANGE(0x3860, 0x3860) AM_READ(i8751_l_r)
-	AM_RANGE(0x3860, 0x3861) AM_WRITE(dec8_i8751_w)
+static ADDRESS_MAP_START( lastmisn_sub_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3")
+	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4")
+	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
+	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
+	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
+	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")	/* Dip 2 */
+	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
+	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
+	AM_RANGE(0x1807, 0x1807) AM_WRITE(flip_screen_w)
+	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w)
+	AM_RANGE(0x2800, 0x2fff) AM_WRITEONLY AM_SHARE("spriteram")
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w)
+	AM_RANGE(0x4000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( shackled_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3") AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4") AM_BASE_GENERIC(paletteram2)
+	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
+	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
+	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
+	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")
+	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")
+	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
+	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
+	AM_RANGE(0x1807, 0x1807) AM_WRITE(flip_screen_w)
+	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
+	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
+	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x180d, 0x180d) AM_WRITE(shackled_control_w) /* Bank switch + Scroll MSB */
+	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( srdarwin_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x05ff) AM_RAM
-	AM_RANGE(0x0600, 0x07ff) AM_RAM AM_BASE_GENERIC(spriteram)
-	AM_RANGE(0x0800, 0x0fff) AM_RAM_WRITE(srdarwin_videoram_w) AM_BASE_MEMBER(dec8_state, m_videoram) AM_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x1000, 0x13ff) AM_RAM
-	AM_RANGE(0x1400, 0x17ff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
-	AM_RANGE(0x1800, 0x1801) AM_WRITE(srdarwin_i8751_w)
-	AM_RANGE(0x1802, 0x1802) AM_WRITE(i8751_reset_w)		/* Maybe.. */
-	AM_RANGE(0x1803, 0x1803) AM_WRITENOP			/* NMI ack */
-	AM_RANGE(0x1804, 0x1804) AM_WRITE(buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x1805, 0x1806) AM_WRITE(srdarwin_control_w) /* Scroll & Bank */
-	AM_RANGE(0x2000, 0x2000) AM_READWRITE(i8751_h_r, dec8_sound_w)	/* Sound */
-	AM_RANGE(0x2001, 0x2001) AM_READWRITE(i8751_l_r, flip_screen_w)		/* Flipscreen */
-	AM_RANGE(0x2800, 0x288f) AM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x3000, 0x308f) AM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_BASE_GENERIC(paletteram2)
-	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN0")	/* Player 1 */
-	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("IN1")	/* Player 2 (cocktail) + VBL */
-	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW1")	/* Dip 2 */
-	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
-	AM_RANGE(0x8000, 0xffff) AM_ROM
+static ADDRESS_MAP_START( shackled_sub_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3")
+	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4")
+	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
+	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
+	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
+	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")
+	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")
+	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
+	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
+	AM_RANGE(0x1806, 0x1806) AM_READ(i8751_h_r)
+	AM_RANGE(0x1807, 0x1807) AM_READWRITE(i8751_l_r, flip_screen_w)
+	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
+	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
+	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x180d, 0x180d) AM_WRITE(shackled_control_w) /* Bank switch + Scroll MSB */
+	AM_RANGE(0x180e, 0x180f) AM_WRITE(shackled_i8751_w)
+	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w)
+	AM_RANGE(0x4000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( gondo_map, AS_PROGRAM, 8 )
@@ -584,7 +695,7 @@
 	AM_RANGE(0x2000, 0x27ff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
 	AM_RANGE(0x2800, 0x2bff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x2c00, 0x2fff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_BASE_GENERIC(paletteram2)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	/* Sprites */
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("spriteram")	/* Sprites */
 	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("DSW0")		/* Dip 1 */
 	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("DSW1")		/* Dip 2 */
 	AM_RANGE(0x380a, 0x380b) AM_READ(gondo_player_1_r)	/* Player 1 rotary */
@@ -601,133 +712,52 @@
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( oscar_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0eff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x0f00, 0x0fff) AM_RAM
-	AM_RANGE(0x1000, 0x1fff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2800, 0x2fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Sprites */
-	AM_RANGE(0x3800, 0x3bff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_be_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x3c00, 0x3c00) AM_READ_PORT("IN0")
-	AM_RANGE(0x3c01, 0x3c01) AM_READ_PORT("IN1")
-	AM_RANGE(0x3c02, 0x3c02) AM_READ_PORT("IN2")	/* VBL & coins */
-	AM_RANGE(0x3c03, 0x3c03) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x3c04, 0x3c04) AM_READ_PORT("DSW1")
-	AM_RANGE(0x3c00, 0x3c07) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
-	AM_RANGE(0x3c10, 0x3c1f) AM_DEVWRITE("tilegen1", deco_bac06_pf_control1_8bit_w)
-	AM_RANGE(0x3c80, 0x3c80) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w)	/* DMA */
-	AM_RANGE(0x3d00, 0x3d00) AM_WRITE(dec8_bank_w)  		/* BNKS */
-	AM_RANGE(0x3d80, 0x3d80) AM_WRITE(dec8_sound_w) 		/* SOUN */
-	AM_RANGE(0x3e00, 0x3e00) AM_WRITENOP			/* COINCL */
-	AM_RANGE(0x3e80, 0x3e83) AM_WRITE(oscar_int_w)
-	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
-	AM_RANGE(0x8000, 0xffff) AM_ROM
-ADDRESS_MAP_END
-
-static ADDRESS_MAP_START( oscar_sub_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0eff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x0f00, 0x0fff) AM_RAM
-	AM_RANGE(0x1000, 0x1fff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x3e80, 0x3e83) AM_WRITE(oscar_int_w)
-	AM_RANGE(0x4000, 0xffff) AM_ROM
-ADDRESS_MAP_END
-
-static ADDRESS_MAP_START( lastmisn_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3") AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4") AM_BASE_GENERIC(paletteram2)
-	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
-	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
-	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
-	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")	/* Dip 2 */
-	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
-	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x1806, 0x1806) AM_READ(i8751_h_r)
-	AM_RANGE(0x1807, 0x1807) AM_READWRITE(i8751_l_r, flip_screen_w)
-	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
-	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
-	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x180d, 0x180d) AM_WRITE(lastmisn_control_w) /* Bank switch + Scroll MSB */
-	AM_RANGE(0x180e, 0x180f) AM_WRITE(lastmisn_i8751_w)
-	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
+static ADDRESS_MAP_START( garyoret_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x17ff) AM_RAM
+	AM_RANGE(0x1800, 0x1fff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
+	AM_RANGE(0x2000, 0x27ff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
+	AM_RANGE(0x2800, 0x2bff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x2c00, 0x2fff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_BASE_GENERIC(paletteram2)
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("spriteram") /* Sprites */
+	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("DSW1")	/* Dip 2 */
+	AM_RANGE(0x3808, 0x3808) AM_READNOP		/* ? */
+	AM_RANGE(0x380a, 0x380a) AM_READ_PORT("IN1")	/* Player 2 + VBL */
+	AM_RANGE(0x380b, 0x380b) AM_READ_PORT("IN0")	/* Player 1 */
+	AM_RANGE(0x3810, 0x3810) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x3818, 0x382f) AM_WRITE(gondo_scroll_w)
+	AM_RANGE(0x3830, 0x3830) AM_WRITE(ghostb_bank_w) /* Bank + NMI enable */
+	AM_RANGE(0x3838, 0x3839) AM_WRITE(dec8_i8751_w)
+	AM_RANGE(0x383a, 0x383a) AM_READ(i8751_h_r)
+	AM_RANGE(0x383b, 0x383b) AM_READ(i8751_l_r)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( lastmisn_sub_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3")
-	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4")
-	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
-	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
-	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
-	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")	/* Dip 2 */
-	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
-	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x1807, 0x1807) AM_WRITE(flip_screen_w)
-	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w)
-	AM_RANGE(0x2800, 0x2fff) AM_WRITE(shackled_sprite_w)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w)
-	AM_RANGE(0x4000, 0xffff) AM_ROM
-ADDRESS_MAP_END
-
-static ADDRESS_MAP_START( shackled_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3") AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4") AM_BASE_GENERIC(paletteram2)
-	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
-	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
-	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
-	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")
-	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")
-	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
-	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x1807, 0x1807) AM_WRITE(flip_screen_w)
-	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
-	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
-	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x180d, 0x180d) AM_WRITE(shackled_control_w) /* Bank switch + Scroll MSB */
-	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w)
-	AM_RANGE(0x2800, 0x2fff) AM_READWRITE(shackled_sprite_r, shackled_sprite_w)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
+static ADDRESS_MAP_START( meikyuh_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0fff) AM_RAM
+	AM_RANGE(0x1000, 0x17ff) AM_RAM
+	AM_RANGE(0x1800, 0x1fff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
+	AM_RANGE(0x2000, 0x27ff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
+	AM_RANGE(0x2800, 0x2bff) AM_RAM // colscroll? mirror?
+	AM_RANGE(0x2c00, 0x2fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_rowscroll_8bit_r, deco_bac06_pf_rowscroll_8bit_w)
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("IN0")	/* Player 1 */
+	AM_RANGE(0x3800, 0x3800) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN1")	/* Player 2 */
+	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("IN2")	/* Player 3 */
+	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW0")	/* Start buttons + VBL */
+	AM_RANGE(0x3820, 0x3820) AM_READ_PORT("DSW1")	/* Dip */
+	AM_RANGE(0x3820, 0x3827) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
+	AM_RANGE(0x3830, 0x383f) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_control1_8bit_r, deco_bac06_pf_control1_8bit_w)
+	AM_RANGE(0x3840, 0x3840) AM_READ(i8751_h_r)
+	AM_RANGE(0x3840, 0x3840) AM_WRITE(ghostb_bank_w)
+	AM_RANGE(0x3860, 0x3860) AM_READ(i8751_l_r)
+	AM_RANGE(0x3860, 0x3861) AM_WRITE(dec8_i8751_w)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( shackled_sub_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3")
-	AM_RANGE(0x1400, 0x17ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_SHARE("share4")
-	AM_RANGE(0x1800, 0x1800) AM_READ_PORT("IN0")
-	AM_RANGE(0x1801, 0x1801) AM_READ_PORT("IN1")
-	AM_RANGE(0x1802, 0x1802) AM_READ_PORT("IN2")
-	AM_RANGE(0x1803, 0x1803) AM_READ_PORT("DSW0")
-	AM_RANGE(0x1804, 0x1804) AM_READ_PORT("DSW1")
-	AM_RANGE(0x1800, 0x1804) AM_WRITE(shackled_int_w)
-	AM_RANGE(0x1805, 0x1805) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
-	AM_RANGE(0x1806, 0x1806) AM_READ(i8751_h_r)
-	AM_RANGE(0x1807, 0x1807) AM_READWRITE(i8751_l_r, flip_screen_w)
-	AM_RANGE(0x1809, 0x1809) AM_WRITE(lastmisn_scrollx_w) /* Scroll LSB */
-	AM_RANGE(0x180b, 0x180b) AM_WRITE(lastmisn_scrolly_w) /* Scroll LSB */
-	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x180d, 0x180d) AM_WRITE(shackled_control_w) /* Bank switch + Scroll MSB */
-	AM_RANGE(0x180e, 0x180f) AM_WRITE(shackled_i8751_w)
-	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w)
-	AM_RANGE(0x4000, 0xffff) AM_ROM
-ADDRESS_MAP_END
-
 static ADDRESS_MAP_START( csilver_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x0fff) AM_RAM AM_SHARE("share1")
 	AM_RANGE(0x1000, 0x13ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_SHARE("share3") AM_BASE_GENERIC(paletteram)
@@ -746,7 +776,7 @@
 	AM_RANGE(0x1c00, 0x1c00) AM_READ(i8751_h_r)
 	AM_RANGE(0x1e00, 0x1e00) AM_READ(i8751_l_r)
 	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w)
-	AM_RANGE(0x2800, 0x2fff) AM_READWRITE(shackled_sprite_r, shackled_sprite_w)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
 	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
@@ -763,49 +793,107 @@
 	AM_RANGE(0x1805, 0x1805) AM_READ_PORT("DSW0") AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
 	AM_RANGE(0x180c, 0x180c) AM_WRITE(dec8_sound_w)
 	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("share2")
 	AM_RANGE(0x3800, 0x3fff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w)
 	AM_RANGE(0x4000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-static ADDRESS_MAP_START( garyoret_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x17ff) AM_RAM
-	AM_RANGE(0x1800, 0x1fff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
-	AM_RANGE(0x2000, 0x27ff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
-	AM_RANGE(0x2800, 0x2bff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x2c00, 0x2fff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_BASE_GENERIC(paletteram2)
-	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Sprites */
-	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("DSW0")	/* Dip 1 */
-	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("DSW1")	/* Dip 2 */
-	AM_RANGE(0x3808, 0x3808) AM_READNOP		/* ? */
-	AM_RANGE(0x380a, 0x380a) AM_READ_PORT("IN1")	/* Player 2 + VBL */
-	AM_RANGE(0x380b, 0x380b) AM_READ_PORT("IN0")	/* Player 1 */
-	AM_RANGE(0x3810, 0x3810) AM_WRITE(dec8_sound_w)
-	AM_RANGE(0x3818, 0x382f) AM_WRITE(gondo_scroll_w)
-	AM_RANGE(0x3830, 0x3830) AM_WRITE(ghostb_bank_w) /* Bank + NMI enable */
-	AM_RANGE(0x3838, 0x3839) AM_WRITE(garyoret_i8751_w)
-	AM_RANGE(0x383a, 0x383a) AM_READ(i8751_h_r)
-	AM_RANGE(0x383b, 0x383b) AM_READ(i8751_l_r)
+static ADDRESS_MAP_START( oscar_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0eff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x0f00, 0x0fff) AM_RAM
+	AM_RANGE(0x1000, 0x1fff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
+	AM_RANGE(0x2800, 0x2fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
+	AM_RANGE(0x3000, 0x37ff) AM_RAM AM_SHARE("spriteram") /* Sprites */
+	AM_RANGE(0x3800, 0x3bff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_be_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x3c00, 0x3c00) AM_READ_PORT("IN0")
+	AM_RANGE(0x3c01, 0x3c01) AM_READ_PORT("IN1")
+	AM_RANGE(0x3c02, 0x3c02) AM_READ_PORT("IN2")	/* VBL & coins */
+	AM_RANGE(0x3c03, 0x3c03) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x3c04, 0x3c04) AM_READ_PORT("DSW1")
+	AM_RANGE(0x3c00, 0x3c07) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
+	AM_RANGE(0x3c10, 0x3c1f) AM_DEVWRITE("tilegen1", deco_bac06_pf_control1_8bit_w)
+	AM_RANGE(0x3c80, 0x3c80) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w)	/* DMA */
+	AM_RANGE(0x3d00, 0x3d00) AM_WRITE(dec8_bank_w)  		/* BNKS */
+	AM_RANGE(0x3d80, 0x3d80) AM_WRITE(dec8_sound_w) 		/* SOUN */
+	AM_RANGE(0x3e00, 0x3e00) AM_WRITENOP			/* COINCL */
+	AM_RANGE(0x3e80, 0x3e83) AM_WRITE(oscar_int_w)
 	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-/******************************************************************************/
+static ADDRESS_MAP_START( oscar_sub_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x0eff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x0f00, 0x0fff) AM_RAM
+	AM_RANGE(0x1000, 0x1fff) AM_RAM AM_SHARE("share2")
+	AM_RANGE(0x3e80, 0x3e83) AM_WRITE(oscar_int_w)
+	AM_RANGE(0x4000, 0xffff) AM_ROM
+ADDRESS_MAP_END
 
-/* Used for Cobra Command, Maze Hunter, Super Real Darwin etc */
-static ADDRESS_MAP_START( dec8_s_map, AS_PROGRAM, 8 )
+static ADDRESS_MAP_START( srdarwin_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x05ff) AM_RAM
-	AM_RANGE(0x2000, 0x2001) AM_DEVWRITE("ym1", ym2203_w)
-	AM_RANGE(0x4000, 0x4001) AM_DEVWRITE("ym2", ym3812_w)
-	AM_RANGE(0x6000, 0x6000) AM_READ(soundlatch_r)
+	AM_RANGE(0x0600, 0x07ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x0800, 0x0fff) AM_RAM_WRITE(srdarwin_videoram_w) AM_BASE_MEMBER(dec8_state, m_videoram)
+	AM_RANGE(0x1000, 0x13ff) AM_RAM
+	AM_RANGE(0x1400, 0x17ff) AM_READWRITE(dec8_bg_data_r, dec8_bg_data_w) AM_BASE_MEMBER(dec8_state, m_bg_data)
+	AM_RANGE(0x1800, 0x1801) AM_WRITE(srdarwin_i8751_w)
+	AM_RANGE(0x1802, 0x1802) AM_WRITE(i8751_reset_w)		/* Maybe.. */
+	AM_RANGE(0x1803, 0x1803) AM_WRITENOP			/* NMI ack */
+	AM_RANGE(0x1804, 0x1804) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram8_device, write) /* DMA */
+	AM_RANGE(0x1805, 0x1806) AM_WRITE(srdarwin_control_w) /* Scroll & Bank */
+	AM_RANGE(0x2000, 0x2000) AM_READWRITE(i8751_h_r, dec8_sound_w)	/* Sound */
+	AM_RANGE(0x2001, 0x2001) AM_READWRITE(i8751_l_r, flip_screen_w)		/* Flipscreen */
+	AM_RANGE(0x2800, 0x288f) AM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split1_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x3000, 0x308f) AM_WRITE(paletteram_xxxxBBBBGGGGRRRR_split2_w) AM_BASE_GENERIC(paletteram2)
+	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN0")	/* Player 1 */
+	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("IN1")	/* Player 2 (cocktail) + VBL */
+	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW1")	/* Dip 2 */
+	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
-/* Used by Gondomania, Psycho-Nics Oscar & Garyo Retsuden */
-static ADDRESS_MAP_START( oscar_s_map, AS_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x05ff) AM_RAM
-	AM_RANGE(0x2000, 0x2001) AM_DEVWRITE("ym1", ym2203_w)
+static ADDRESS_MAP_START( cobra_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x07ff) AM_RAM
+	AM_RANGE(0x0800, 0x0fff) AM_DEVREADWRITE("tilegen1", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
+	AM_RANGE(0x1000, 0x17ff) AM_DEVREADWRITE("tilegen2", deco_bac06_pf_data_8bit_r, deco_bac06_pf_data_8bit_w)
+	AM_RANGE(0x1800, 0x1fff) AM_RAM
+	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(dec8_videoram_w) AM_BASE_SIZE_MEMBER(dec8_state, m_videoram, m_videoram_size)
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x3000, 0x31ff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_be_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x3200, 0x37ff) AM_WRITEONLY /* Unused */
+	AM_RANGE(0x3800, 0x3800) AM_READ_PORT("IN0")	/* Player 1 */
+	AM_RANGE(0x3801, 0x3801) AM_READ_PORT("IN1")	/* Player 2 */
+	AM_RANGE(0x3802, 0x3802) AM_READ_PORT("DSW0")	/* Dip 1 */
+	AM_RANGE(0x3803, 0x3803) AM_READ_PORT("DSW1")	/* Dip 2 */
+	AM_RANGE(0x3800, 0x3807) AM_DEVWRITE("tilegen1", deco_bac06_pf_control0_8bit_w)
+	AM_RANGE(0x3810, 0x381f) AM_DEVWRITE("tilegen1", deco_bac06_pf_control1_8bit_w)
+	AM_RANGE(0x3a00, 0x3a00) AM_READ_PORT("IN2")	/* VBL & coins */
+	AM_RANGE(0x3a00, 0x3a07) AM_DEVWRITE("tilegen2", deco_bac06_pf_control0_8bit_w)
+	AM_RANGE(0x3a10, 0x3a1f) AM_DEVWRITE("tilegen2", deco_bac06_pf_control1_8bit_w)
+	AM_RANGE(0x3c00, 0x3c00) AM_WRITE(dec8_bank_w)
+	AM_RANGE(0x3c02, 0x3c02) AM_WRITE(dec8_mxc06_karn_buffer_spriteram_w) /* DMA */
+	AM_RANGE(0x3e00, 0x3e00) AM_WRITE(dec8_sound_w)
+	AM_RANGE(0x4000, 0x7fff) AM_ROMBANK("bank1")
+	AM_RANGE(0x8000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
+/******************************************************************************/
+
+/* Used for Cobra Command, Maze Hunter, Super Real Darwin etc */
+static ADDRESS_MAP_START( dec8_s_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x05ff) AM_RAM
+	AM_RANGE(0x2000, 0x2001) AM_DEVWRITE("ym1", ym2203_w)
+	AM_RANGE(0x4000, 0x4001) AM_DEVWRITE("ym2", ym3812_w)
+	AM_RANGE(0x6000, 0x6000) AM_READ(soundlatch_r)
+	AM_RANGE(0x8000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
+/* Used by Gondomania, Psycho-Nics Oscar & Garyo Retsuden */
+static ADDRESS_MAP_START( oscar_s_map, AS_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x05ff) AM_RAM
+	AM_RANGE(0x2000, 0x2001) AM_DEVWRITE("ym1", ym2203_w)
 	AM_RANGE(0x4000, 0x4001) AM_DEVWRITE("ym2", ym3526_w)
 	AM_RANGE(0x6000, 0x6000) AM_READ(soundlatch_r)
 	AM_RANGE(0x8000, 0xffff) AM_ROM
@@ -896,376 +984,507 @@
 /******************************************************************************/
 
 #define PLAYER1_JOYSTICK /* Player 1 controls */ \
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY \
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY \
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY \
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY \
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY \
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY \
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
 
 #define PLAYER2_JOYSTICK /* Player 2 controls */ \
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL \
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL \
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL \
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_COCKTAIL \
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_COCKTAIL \
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_COCKTAIL \
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 
-static INPUT_PORTS_START( cobracom )
+
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( lastmisn )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )                 /* bomb */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )                 /* select */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL   /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL   /* bomb */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL   /* select */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
+	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Cabinet ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
+	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
+	PORT_DIPNAME( 0x80, 0x80, "Infinite Lives (Cheat)")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
 	PORT_START("DSW1")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x03, "3" )
-	PORT_DIPSETTING(    0x02, "4" )
-	PORT_DIPSETTING(    0x01, "5" )
-	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )       /* tables at 0x82c1 (4 words) and 0xde38 (3 words) in 'lastmisn', 0x82c1 and 0xde17 in 'lastmisno' */
+	PORT_DIPSETTING(    0x06, "30k 70k 70k+" )
+	PORT_DIPSETTING(    0x04, "40k 90k 90k+" )
+	PORT_DIPSETTING(    0x02, "40k and 80k" )
+	PORT_DIPSETTING(    0x00, "50k only" )
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0x18, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Yes ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x20, "50k, 150k" )
-	PORT_DIPSETTING(    0x00, "100k, 200k" )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Allow_Continue ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( No ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( ghostb )
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( lastmisnj )
+	PORT_INCLUDE(lastmisn)
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )       /* tables at 0x82b7 (4 words) and 0xdd29 (3 words) */
+	PORT_DIPSETTING(    0x06, "30k 50k 50k+" )
+	PORT_DIPSETTING(    0x04, "30k 70k 70k+" )
+	PORT_DIPSETTING(    0x02, "50k 100k 100k+" )
+	PORT_DIPSETTING(    0x00, "50k only" )
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Hard ) )             /* "difficult" */
+	PORT_DIPSETTING(    0x08, DEF_STR( Very_Hard ) )        /* "very difficult" */
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )          /* "top difficult" */
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )
+INPUT_PORTS_END
+
+
+/* verified from M6809 code */
+static INPUT_PORTS_START( shackled )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+
+	PORT_START("DSW0")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x02, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x04, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x08, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x10, 0x40, "Leave Off" )	                /* game doesn't boot when this is On - code at 0x401a - related to MCU - "dias" in Dip Switches page */
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x80, "Freeze" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW1")
+	/* tables in main CPU : 0x859b (Help), 0x85e9 (6-Help), 0x8fbe (Coin), 0x91b6 (Heart) */
+	PORT_DIPNAME( 0x07, 0x07, "Coin/Heart/Help/6-Help" )    /* name from Dip Switches page */
+	PORT_DIPSETTING( 0x00, "2/100/50/200" )
+	PORT_DIPSETTING( 0x01, "4/100/60/300" )
+	PORT_DIPSETTING( 0x02, "6/200/70/300" )
+	PORT_DIPSETTING( 0x03, "8/200/80/400" )
+	PORT_DIPSETTING( 0x07, "10/200/100/500" )
+	PORT_DIPSETTING( 0x06, "12/300/100/600" )
+	PORT_DIPSETTING( 0x05, "18/400/200/700" )
+	PORT_DIPSETTING( 0x04, "20/500/200/800" )
+	PORT_DIPUNUSED( 0x08, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0x30, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Very_Hard ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
+
+/* verified from M6809 code */
+static INPUT_PORTS_START( breywood )
+	PORT_INCLUDE(shackled)
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPNAME( 0x0f, 0x0f, "Power" )                     /* table at 0x41be in sub CPU */
+	PORT_DIPSETTING( 0x07, "200" )
+	PORT_DIPSETTING( 0x0b, "300" )
+	PORT_DIPSETTING( 0x03, "400" )
+	PORT_DIPSETTING( 0x0d, "500" )
+	PORT_DIPSETTING( 0x05, "600" )
+	PORT_DIPSETTING( 0x09, "700" )
+	PORT_DIPSETTING( 0x01, "800" )
+	PORT_DIPSETTING( 0x0e, "900" )
+	PORT_DIPSETTING( 0x0f, "1000" )
+	PORT_DIPSETTING( 0x06, "2000" )
+	PORT_DIPSETTING( 0x0a, "3000" )
+	PORT_DIPSETTING( 0x02, "4000" )
+	PORT_DIPSETTING( 0x0c, "5000" )
+	PORT_DIPSETTING( 0x04, "6000" )
+	PORT_DIPSETTING( 0x08, "7000" )
+	PORT_DIPSETTING( 0x00, "8000" )
+INPUT_PORTS_END
+
+
+/* verified from HD6309 code - 'makyosen' coinage needs further checking when its REAL MCU is available */
+static INPUT_PORTS_START( gondo )
+	PORT_START("IN0")
+	PLAYER1_JOYSTICK
+	/* Top 4 bits are rotary controller */
+
+	PORT_START("IN1")
+	PLAYER2_JOYSTICK
+	/* Top 4 bits are rotary controller */
+
+	PORT_START("IN2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
-	PORT_START("DSW0")
+	PORT_START("IN3")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+
+	PORT_START("I8751")	/* hooked up on the i8751 */
+	/* Low 4 bits not connected on schematics */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )              /* produces sound but gives 0 credits - coinage not initialised in the MCU */
+
+	PORT_START("AN0")	/* player 1 12-way rotary control */
+	PORT_BIT( 0x0f, 0x00, IPT_POSITIONAL ) PORT_POSITIONS(12) PORT_WRAPS PORT_SENSITIVITY(15) PORT_KEYDELTA(1) PORT_CODE_DEC(KEYCODE_Z) PORT_CODE_INC(KEYCODE_X) PORT_REVERSE PORT_FULL_TURN_COUNT(12)
+
+	PORT_START("AN1")	/* player 2 12-way rotary control */
+	PORT_BIT( 0x0f, 0x00, IPT_POSITIONAL ) PORT_POSITIONS(12) PORT_WRAPS PORT_SENSITIVITY(15) PORT_KEYDELTA(1) PORT_CODE_DEC(KEYCODE_N) PORT_CODE_INC(KEYCODE_M) PORT_PLAYER(2) PORT_REVERSE PORT_FULL_TURN_COUNT(12)
+
+	PORT_START("DSW0")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* table at 0x01b8 in MCU (4 bytes : coins in 4 MSbits and credits in 4 LSbits) */
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )           /* table at 0x01bc in MCU (4 bytes : coins in 4 MSbits and credits in 4 LSbits) */
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x80, "Swap buttons" )              /* code at 0x8a2b in 'gondo', 0x88c5 in 'makyosen' - undocumented in the manual */
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 
-	PORT_START("I8751")
-	/* Low 4 bits not connected on schematics */
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )
-
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
 	PORT_DIPSETTING(    0x01, "1" )
 	PORT_DIPSETTING(    0x03, "3" )
 	PORT_DIPSETTING(    0x02, "5" )
-	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")
+	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")           /* gives 99 lives */
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x30, 0x30, "Scene Time" )
-	PORT_DIPSETTING(    0x00, "4.00" )
-	PORT_DIPSETTING(    0x10, "4.30" )
-	PORT_DIPSETTING(    0x30, "5.00" )
-	PORT_DIPSETTING(    0x20, "6.00" )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( No ) )
+	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Allow_Continue ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
-	PORT_DIPNAME( 0x80, 0x80, "Beam Energy Pickup" ) /* Ghostb only */
-	PORT_DIPSETTING(    0x00, "Up 1.5%" )
-	PORT_DIPSETTING(    0x80, DEF_STR( Normal ) )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( ghostb3 )
-	PORT_INCLUDE(ghostb)
-
-	PORT_MODIFY("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(3)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(3)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(3)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(3)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(3)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(3)
 
-	PORT_MODIFY("DSW0")
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START3 )
-INPUT_PORTS_END
+/* verified from HD6309 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( garyoret )
+	PORT_START("IN0")
+	PLAYER1_JOYSTICK
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )                 /* bomb */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
-static INPUT_PORTS_START( meikyuh )
-	PORT_INCLUDE(ghostb)
+	PORT_START("IN1")
+	PLAYER2_JOYSTICK
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)  /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)  /* bomb */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
 
-	PORT_MODIFY("I8751")
+	PORT_START("I8751")	/* hooked up on the (fake) i8751 */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN3 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 )
-
-INPUT_PORTS_END
-
-
-static INPUT_PORTS_START( srdarwin )
-	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
-
-	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )              /* produces sound but gives 0 credits - coinage not initialised in the (fake) MCU */
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )                   /* not tested - no cocktail when simultaneous players anyway */
 
 	PORT_START("DSW1")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x01, "1" )
-	PORT_DIPSETTING(    0x03, "3" )
-	PORT_DIPSETTING(    0x02, "5" )
-	PORT_DIPSETTING(    0x00, "28 (Cheat)")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPUNUSED( 0x02, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Unknown ) )
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x40, 0x40, "Leave Off" )	                /* game doesn't boot when this is On - code at 0x807f and test at 0x819e */
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Continues ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
-
-	PORT_START("FAKE")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) /* Fake */
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( gondo )
+
+/* verified from HD6309 code */
+static INPUT_PORTS_START( ghostb )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
-	/* Top 4 bits are rotary controller */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)  /* "FIRE" */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)  /* beam / upgradable shot when out of energy */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
-	/* Top 4 bits are rotary controller */
-
-	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)  /* "FIRE" */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)  /* beam / upgradable shot when out of energy */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
-	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_START("IN2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
-	PORT_START("I8751")	/* hooked up on the i8751 */
+	PORT_START("I8751")
 	/* Low 4 bits not connected on schematics */
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )
-
-	PORT_START("AN0")	/* player 1 12-way rotary control */
-	PORT_BIT( 0x0f, 0x00, IPT_POSITIONAL ) PORT_POSITIONS(12) PORT_WRAPS PORT_SENSITIVITY(15) PORT_KEYDELTA(1) PORT_CODE_DEC(KEYCODE_Z) PORT_CODE_INC(KEYCODE_X) PORT_REVERSE PORT_FULL_TURN_COUNT(12)
-
-	PORT_START("AN1")	/* player 2 12-way rotary control */
-	PORT_BIT( 0x0f, 0x00, IPT_POSITIONAL ) PORT_POSITIONS(12) PORT_WRAPS PORT_SENSITIVITY(15) PORT_KEYDELTA(1) PORT_CODE_DEC(KEYCODE_N) PORT_CODE_INC(KEYCODE_M) PORT_PLAYER(2) PORT_REVERSE PORT_FULL_TURN_COUNT(12)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )              /* produce sound but gives 0 credits - "ANDA" instruction at 0x8a5a */
 
 	PORT_START("DSW0")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )                   /* not tested - no cocktail when simultaneous players anyway */
 
 	PORT_START("DSW1")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )            /* lives are added when STARTn is pressed */
 	PORT_DIPSETTING(    0x01, "1" )
 	PORT_DIPSETTING(    0x03, "3" )
 	PORT_DIPSETTING(    0x02, "5" )
-	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")
+	PORT_DIPSETTING(    0x00, "Invulnerability (Cheat)")    /* gives 1 life */
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( No ) )
+	PORT_DIPNAME( 0x30, 0x30, "Max Scene Time" )            /* 1:00 is added when STARTn is pressed until max scene time is reached */
+	PORT_DIPSETTING(    0x00, "4:00" )
+	PORT_DIPSETTING(    0x10, "4:30" )
+	PORT_DIPSETTING(    0x30, "5:00" )
+	PORT_DIPSETTING(    0x20, "6:00" )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Allow_Continue ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x80, "Energy Bonus" )              /* energy is set to value each new life */
+	PORT_DIPSETTING(    0x80, DEF_STR( None ) )             /* 0x0100 */
+	PORT_DIPSETTING(    0x00, "+25%" )                      /* 0x0140 */
+INPUT_PORTS_END
+
+/* verified from HD6309 code */
+static INPUT_PORTS_START( ghostb2a )
+	PORT_INCLUDE(ghostb)
+
+	/* BUTTON1 : upgradable shot - BUTTON2 : beam (provided you have energy) */
+
+	PORT_MODIFY("I8751")
+	/* Low 4 bits not connected on schematics */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )              /* produce sound but gives 0 lives - "ANDA" instruction at 0x8a20 */
+
+	PORT_MODIFY("DSW0")
+	/* NO start buttons - to start a game, press any button from any player */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_MODIFY("DSW1")
+	/* lives are added when COINn is pressed */
+	/* 1:00 is added when COINn is pressed until max scene time is reached */
+	PORT_DIPNAME( 0x80, 0x80, "Energy Bonus" )              /* energy is added when COINn is pressed */
+	PORT_DIPSETTING(    0x80, DEF_STR( None ) )             /* 0x0040 */
+	PORT_DIPSETTING(    0x00, "+50%" )                      /* 0x0060 */
+INPUT_PORTS_END
+
+/* verified from HD6309 code */
+static INPUT_PORTS_START( ghostb3 )
+	PORT_INCLUDE(ghostb2a)
+
+	PORT_MODIFY("IN2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_PLAYER(3)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_PLAYER(3)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_PLAYER(3)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(3)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(3)  /* upgradable shot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(3)  /* beam (provided you have energy) */
+
+	PORT_MODIFY("I8751")
+	/* Low 4 bits not connected on schematics */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN3 )
+INPUT_PORTS_END
+
+/* verified from HD6309 code */
+static INPUT_PORTS_START( meikyuh )
+	PORT_INCLUDE(ghostb)
+
+	PORT_MODIFY("I8751")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN3 )              /* gives 4 credits for 14 coins ! */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 )
+
+	/* BUTTON1 : upgradable shot - BUTTON2 : circular fire (provided you have energy) - BUTTON1 + BUTTON2 : beam (provided you have energy) */
+
+	PORT_MODIFY("DSW1")
+	/* lives are added when STARTn is pressed - 1 extra life is awarded on 2nd credit and after for the same player who gets then 2, 4 or 6 additional lives */
+	/* max time scene is always 6:00 at start - 0:30 is subed every 8 levels - 1:00 is added when STARTn is pressed until max scene time is reached */
+	PORT_DIPNAME( 0x10, 0x10, "Energy Bonus" )              /* energy is added when STARTn is pressed */
+	PORT_DIPSETTING(    0x10, DEF_STR( None ) )             /* 0x0020 */
+	PORT_DIPSETTING(    0x00, "+50%" )                      /* 0x0030 */
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x80, "Freeze" )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( oscar )
+
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( csilver )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* sword */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )                 /* jump */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL   /* sword */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL   /* jump */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1273,18 +1492,16 @@
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_4C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x10, 0x10, "Freeze Mode" )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
@@ -1300,44 +1517,60 @@
 	PORT_DIPSETTING(    0x01, "1" )
 	PORT_DIPSETTING(    0x03, "3" )
 	PORT_DIPSETTING(    0x02, "5" )
-	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")
+	PORT_DIPSETTING(    0x00, "255 (Cheat)")
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x30, "Every 40000" )
-	PORT_DIPSETTING(    0x20, "Every 60000" )
-	PORT_DIPSETTING(    0x10, "Every 90000" )
-	PORT_DIPSETTING(    0x00, "50000 only" )
-	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Allow_Continue ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Yes ) )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x40, 0x40, "No Key for Door (Cheat)")    /* code at 0x9816 in sub CPU */
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Yes ) )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )
+INPUT_PORTS_END
+
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( csilverj )
+	PORT_INCLUDE(csilver)
+
+	PORT_MODIFY("DSW0")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( oscaru )
+
+/* verified from HD6309 code */
+static INPUT_PORTS_START( oscar )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )                 /* jump */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )                 /* select */
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL   /* shoot */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL   /* jump */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL   /* select */
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN3 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )           /* always adds 1 credit */
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
@@ -1345,12 +1578,12 @@
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
 
 	PORT_START("DSW0")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* table at 0xf8e3 (4 * 2 bytes : coins then credits) */
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )           /* table at 0xf8eb (4 * 2 bytes : coins then credits) */
 	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 2C_1C ) )
@@ -1379,12 +1612,12 @@
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x30, "Every 40000" )
-	PORT_DIPSETTING(    0x20, "Every 60000" )
-	PORT_DIPSETTING(    0x10, "Every 90000" )
-	PORT_DIPSETTING(    0x00, "50000 only" )
-	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )       /* tables at 0x82d8 (4 words) and 0xf3fe (3 words) */
+	PORT_DIPSETTING(    0x30, "40k 100k 60k+" )
+	PORT_DIPSETTING(    0x20, "60k 160k 100k+" )
+	PORT_DIPSETTING(    0x10, "90k 240k 150k+" )
+	PORT_DIPSETTING(    0x00, "50k only" )
+	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")    /* not when falling into void or water - also gives infinite time */
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Allow_Continue ) )
@@ -1392,270 +1625,153 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( Yes ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( lastmisn )
+/* verified from HD6309 code */
+static INPUT_PORTS_START( oscarj )
+	PORT_INCLUDE(oscar)
+
+	PORT_MODIFY("DSW0")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* table at 0xf8d6 (4 * 2 bytes : coins then credits) in 'oscarj1', 0xf8e6 in 'oscarj2', 0xf8f2 in 'oscaru' */
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )           /* table at 0xf8de (4 * 2 bytes : coins then credits) in 'oscarj1', 0xf8ee in 'oscarj2', 0xf8fa in 'oscaru' */
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
+
+	/* bonus lives : tables at 0x82d8 (4 words) and 0xf3f1 (3 words) in 'oscarj1', 0x82de and 0xf401 in 'orscarj2', 0x82d8 and 0xf412 in 'orscaru' - same as in 'oscar' */
+INPUT_PORTS_END
+
+
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( srdarwin )
 	PORT_START("IN0")
-	PLAYER1_JOYSTICK
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
 	PORT_START("IN1")
-	PLAYER2_JOYSTICK
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_VBLANK )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
-	PORT_START("IN2")
+	PORT_START("I8751") /* Fake port for i8751 */
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( 1C_3C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_4C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_6C ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
-	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")
+	PORT_DIPUNUSED( 0x10, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "Infinite Lives (Cheat)")
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Cabinet ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Cocktail ) )
 
 	PORT_START("DSW1")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x06, "30k, 70k then every 70k" )
-	PORT_DIPSETTING(    0x04, "40k, 90k then every 90k" )
-	PORT_DIPSETTING(    0x02, "40k and 80k" )
-	PORT_DIPSETTING(    0x00, "50k only" )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x01, "1" )
+	PORT_DIPSETTING(    0x03, "3" )
+	PORT_DIPSETTING(    0x02, "5" )
+	PORT_DIPSETTING(    0x00, "28 (Cheat)")
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) ) /* Unused according to the manual */
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( No ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Bonus_Life ) )
+	PORT_DIPSETTING(    0x10, "Every 50k" )                 /* table at 0xab06 - last bonus life at 850k */
+	PORT_DIPSETTING(    0x00, "Every 100k" )                /* table at 0xab17 - last bonus life at 900k */
+	PORT_DIPNAME( 0x20, 0x20, "After Stage 10" )            /* code at 0xab94 */
+	PORT_DIPSETTING(    0x20, "Back to Stage 1" )
+	PORT_DIPSETTING(    0x00, "Game Over" )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Allow_Continue ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Yes ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( lastmisnj )
-	PORT_START("IN0")
-	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
-
-	PORT_START("IN1")
-	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_COCKTAIL
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
-
-	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+/* verified from M6809 code - coinage needs further checking when the MCU is available */
+static INPUT_PORTS_START( srdarwinj )
+	PORT_INCLUDE(srdarwin)
 
-	PORT_START("DSW0")
+	PORT_MODIFY("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
-	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)")
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "Infinite Lives (Cheat)")
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-
-	PORT_START("DSW1")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x06, "30k, 50k then every 50k" )
-	PORT_DIPSETTING(    0x04, "30k, 70k then every 70k" )
-	PORT_DIPSETTING(    0x02, "50k, 100k then every 100k" )
-	PORT_DIPSETTING(    0x00, "50k only" )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Hard ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) ) /* Unused according to the manual */
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( shackled )
-	PORT_START("IN0")
-	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
-
-	PORT_START("IN1")
-	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
-
-	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
-
-	PORT_START("DSW0")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unused ) ) /* All marked as unused in the manual */
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, "Leave Off" )	/* game doesn't boot when this is On */
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, "Freeze" )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-
-	PORT_START("DSW1")
-	PORT_DIPNAME( 0x0f, 0x0f, "Power" )
-	PORT_DIPSETTING( 0x07, "200" )
-	PORT_DIPSETTING( 0x0b, "300" )
-	PORT_DIPSETTING( 0x03, "400" )
-	PORT_DIPSETTING( 0x0d, "500" )
-	PORT_DIPSETTING( 0x05, "600" )
-	PORT_DIPSETTING( 0x09, "700" )
-	PORT_DIPSETTING( 0x01, "800" )
-	PORT_DIPSETTING( 0x0e, "900" )
-	PORT_DIPSETTING( 0x0f, "1000" )
-	PORT_DIPSETTING( 0x06, "2000" )
-	PORT_DIPSETTING( 0x0a, "3000" )
-	PORT_DIPSETTING( 0x02, "4000" )
-	PORT_DIPSETTING( 0x0c, "5000" )
-	PORT_DIPSETTING( 0x04, "6000" )
-	PORT_DIPSETTING( 0x08, "7000" )
-	PORT_DIPSETTING( 0x00, "8000" )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x30, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Hard ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Very_Hard ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-INPUT_PORTS_END
 
-static INPUT_PORTS_START( csilver )
+/* verified from M6809 code */
+static INPUT_PORTS_START( cobracom )
 	PORT_START("IN0")
 	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* fire */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )                 /* missile */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START1 )
 
 	PORT_START("IN1")
 	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)  /* fire */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)  /* missile */
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )           /* always adds 1 credit */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_VBLANK )
 
 	PORT_START("DSW0")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )           /* code at 0x88b7 in 'cobracom', 0x890e in 'cobracomj' */
 	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )           /* code at 0x889b in 'cobracom', 0x88f2 in 'cobracomj' */
 	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) ) /* Listed as "Unused" in the manual */
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
@@ -1670,121 +1786,48 @@
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x01, "1" )
 	PORT_DIPSETTING(    0x03, "3" )
-	PORT_DIPSETTING(    0x02, "5" )
-	PORT_DIPSETTING(    0x00, "Infinite (Cheat)")
+	PORT_DIPSETTING(    0x02, "4" )
+	PORT_DIPSETTING(    0x01, "5" )
+	PORT_DIPSETTING(    0x00, "99 (Cheat)")                 /* lose a life before getting 2nd bonus life ! */
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
 	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Allow_Continue ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Yes ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) ) /* Manual states dips 6-8 are "Unused" */
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Bonus_Life ) )       /* table at 0xa898 (2* 2 words) in 'cobracomj', 0xa8fe in 'cobracomj' */
+	PORT_DIPSETTING(    0x20, "50k and 150k" )
+	PORT_DIPSETTING(    0x00, "100k and 200k" )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )                   /* previously "Freeze" : code at 0x8849 in 'cobracomj', 0x88a0 in 'cobracomj' */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( garyoret )
-	PORT_START("IN0")
-	PLAYER1_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_START2 )
+/******************************************************************************/
 
-	PORT_START("IN1")
-	PLAYER2_JOYSTICK
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+static const gfx_layout charlayout_32k =
+{
+	8,8,
+	1024,
+	2,
+	{ 0x4000*8,0x0000*8 },
+	{ 0, 1, 2, 3, 4, 5, 6, 7 },
+	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
+	8*8	/* every sprite takes 8 consecutive bytes */
+};
 
-	PORT_START("I8751") /* Fake port for i8751 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
-
-	PORT_START("DSW0")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Flip_Screen ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-
-	PORT_START("DSW1")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x0c, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-INPUT_PORTS_END
-
-/******************************************************************************/
-
-static const gfx_layout charlayout_32k =
-{
-	8,8,
-	1024,
-	2,
-	{ 0x4000*8,0x0000*8 },
-	{ 0, 1, 2, 3, 4, 5, 6, 7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
-	8*8	/* every sprite takes 8 consecutive bytes */
-};
-
-static const gfx_layout chars_3bpp =
-{
-	8,8,
-	1024,
-	3,
-	{ 0x6000*8,0x4000*8,0x2000*8 },
-	{ 0, 1, 2, 3, 4, 5, 6, 7 },
-	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
-	8*8	/* every sprite takes 8 consecutive bytes */
-};
+static const gfx_layout chars_3bpp =
+{
+	8,8,
+	1024,
+	3,
+	{ 0x6000*8,0x4000*8,0x2000*8 },
+	{ 0, 1, 2, 3, 4, 5, 6, 7 },
+	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 },
+	8*8	/* every sprite takes 8 consecutive bytes */
+};
 
 /* SRDarwin characters - very unusual layout for Data East */
 static const gfx_layout charlayout_16k =
@@ -1911,7 +1954,7 @@
 
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6502_IRQ_LINE)
 };
 
 static const ym3812_interface ym3812_config =
@@ -1964,8 +2007,14 @@
 	state->save_item(NAME(state->m_i8751_port1));
 	state->save_item(NAME(state->m_i8751_return));
 	state->save_item(NAME(state->m_i8751_value));
+	state->save_item(NAME(state->m_coinage_id));
 	state->save_item(NAME(state->m_coin1));
 	state->save_item(NAME(state->m_coin2));
+	state->save_item(NAME(state->m_need1));
+	state->save_item(NAME(state->m_need2));
+	state->save_item(NAME(state->m_cred1));
+	state->save_item(NAME(state->m_cred2));
+	state->save_item(NAME(state->m_credits));
 	state->save_item(NAME(state->m_snd));
 	state->save_item(NAME(state->m_msm5205next));
 	state->save_item(NAME(state->m_toggle));
@@ -1982,7 +2031,9 @@
 
 	state->m_nmi_enable = state->m_i8751_port0 = state->m_i8751_port1 = 0;
 	state->m_i8751_return = state->m_i8751_value = 0;
-	state->m_coin1 = state->m_coin2 = state->m_snd = 0;
+	state->m_coinage_id = 0;
+	state->m_coin1 = state->m_coin2 = state->m_credits = state->m_snd = 0;
+	state->m_need1 = state->m_need2 = state->m_cred1 = state->m_cred2 = 1;
 	state->m_msm5205next = 0;
 	state->m_toggle = 0;
 
@@ -1995,80 +2046,74 @@
 }
 
 
-static MACHINE_CONFIG_START( cobracom, dec8_state )
+static MACHINE_CONFIG_START( lastmisn, dec8_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", M6809, 2000000)
-	MCFG_CPU_PROGRAM_MAP(cobra_map)
-	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
+	MCFG_CPU_PROGRAM_MAP(lastmisn_map)
+
+	MCFG_CPU_ADD("sub", M6809, 2000000)
+	MCFG_CPU_PROGRAM_MAP(lastmisn_sub_map)
 
 	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
+	MCFG_CPU_PROGRAM_MAP(ym3526_s_map)
 								/* NMIs are caused by the main CPU */
+	MCFG_QUANTUM_TIME(attotime::from_hz(12000))
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
-	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
-	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
-	MCFG_DEVICE_ADD("tilegen2", DECO_BAC06, 0)
-	deco_bac06_device::set_gfx_region_wide(*device, 3,3,0);
-
-	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
-	deco_mxc06_device::set_gfx_region(*device, 1);
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
+	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
+	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(cobracom)
+	MCFG_SCREEN_UPDATE_STATIC(lastmisn)
 
-	MCFG_GFXDECODE(cobracom)
-	MCFG_PALETTE_LENGTH(256)
+	MCFG_GFXDECODE(shackled)
+	MCFG_PALETTE_LENGTH(1024)
 
-	MCFG_VIDEO_START(cobracom)
+	MCFG_VIDEO_START(lastmisn)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
-	MCFG_SOUND_ROUTE(0, "mono", 0.53)
-	MCFG_SOUND_ROUTE(1, "mono", 0.53)
-	MCFG_SOUND_ROUTE(2, "mono", 0.53)
-	MCFG_SOUND_ROUTE(3, "mono", 0.50)
+	MCFG_SOUND_ROUTE(0, "mono", 0.23)
+	MCFG_SOUND_ROUTE(1, "mono", 0.23)
+	MCFG_SOUND_ROUTE(2, "mono", 0.23)
+	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
-	MCFG_SOUND_CONFIG(ym3812_config)
+	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
+	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( ghostb, dec8_state )
+static MACHINE_CONFIG_START( shackled, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", HD6309, 3000000*4)
-	MCFG_CPU_PROGRAM_MAP(meikyuh_map)
-	MCFG_CPU_VBLANK_INT("screen", gondo_interrupt)
+	MCFG_CPU_ADD("maincpu", M6809, 2000000)
+	MCFG_CPU_PROGRAM_MAP(shackled_map)
+
+	MCFG_CPU_ADD("sub", M6809, 2000000)
+	MCFG_CPU_PROGRAM_MAP(shackled_sub_map)
 
 	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
+	MCFG_CPU_PROGRAM_MAP(ym3526_s_map)
 								/* NMIs are caused by the main CPU */
-
-	MCFG_CPU_ADD("mcu", I8751, 3000000*4)
-	MCFG_CPU_IO_MAP(dec8_mcu_io_map)
+	MCFG_QUANTUM_TIME(attotime::from_hz(4800))
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
-	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
-	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
 	deco_karnovsprites_device::set_gfx_region(*device, 1);
@@ -2078,14 +2123,12 @@
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(ghostb)
-	MCFG_SCREEN_VBLANK_STATIC(dec8)
+	MCFG_SCREEN_UPDATE_STATIC(shackled)
 
-	MCFG_GFXDECODE(ghostb)
+	MCFG_GFXDECODE(shackled)
 	MCFG_PALETTE_LENGTH(1024)
 
-	MCFG_PALETTE_INIT(ghostb)
-	MCFG_VIDEO_START(ghostb)
+	MCFG_VIDEO_START(shackled)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
@@ -2096,94 +2139,96 @@
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
-	MCFG_SOUND_CONFIG(ym3812_config)
+	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
+	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-
-static MACHINE_CONFIG_START( oscar, dec8_state )
+static MACHINE_CONFIG_START( gondo, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", HD6309, XTAL_12MHz/2) /* verified on pcb */
-	MCFG_CPU_PROGRAM_MAP(oscar_map)
-	MCFG_CPU_VBLANK_INT("screen", oscar_interrupt)
-
-	MCFG_CPU_ADD("sub", HD6309, XTAL_12MHz/2) /* verified on pcb */
-	MCFG_CPU_PROGRAM_MAP(oscar_sub_map)
+	MCFG_CPU_ADD("maincpu", HD6309,3000000*4) /* HD63C09EP */
+	MCFG_CPU_PROGRAM_MAP(gondo_map)
+	MCFG_CPU_VBLANK_INT("screen", gondo_interrupt)
 
-	MCFG_CPU_ADD("audiocpu", M6502, XTAL_12MHz/8)
+	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
 	MCFG_CPU_PROGRAM_MAP(oscar_s_map)
 								/* NMIs are caused by the main CPU */
-	MCFG_QUANTUM_TIME(attotime::from_hz(2400)) /* 40 CPU slices per frame */
+
+	MCFG_CPU_ADD("mcu", I8751, XTAL_8MHz)
+	MCFG_CPU_IO_MAP(dec8_mcu_io_map)
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
-	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
-	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
-	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
-	deco_mxc06_device::set_gfx_region(*device, 1);
+	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
+	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(oscar)
+	MCFG_SCREEN_UPDATE_STATIC(gondo)
+	MCFG_SCREEN_VBLANK_STATIC(dec8)
 
-	MCFG_GFXDECODE(oscar)
-	MCFG_PALETTE_LENGTH(512)
+	MCFG_GFXDECODE(gondo)
+	MCFG_PALETTE_LENGTH(1024)
 
-	MCFG_VIDEO_START(oscar)
+	MCFG_VIDEO_START(gondo)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ym1", YM2203, XTAL_12MHz/8) /* verified on pcb */
+	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
 	MCFG_SOUND_ROUTE(0, "mono", 0.23)
 	MCFG_SOUND_ROUTE(1, "mono", 0.23)
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3526, XTAL_12MHz/4) /* verified on pcb */
+	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
 	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-
-static MACHINE_CONFIG_START( srdarwin, dec8_state )
+static MACHINE_CONFIG_START( garyoret, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M6809,2000000)  /* MC68A09EP */
-	MCFG_CPU_PROGRAM_MAP(srdarwin_map)
-	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
+	MCFG_CPU_ADD("maincpu", HD6309,3000000*4) /* HD63C09EP */
+	MCFG_CPU_PROGRAM_MAP(garyoret_map)
+	MCFG_CPU_VBLANK_INT("screen", gondo_interrupt)
 
 	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
+	MCFG_CPU_PROGRAM_MAP(oscar_s_map)
 								/* NMIs are caused by the main CPU */
 
+	MCFG_CPU_ADD("mcu", I8751, XTAL_8MHz)
+	MCFG_CPU_IO_MAP(dec8_mcu_io_map)
+
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+
+	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
+	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(srdarwin)
+	MCFG_SCREEN_UPDATE_STATIC(garyoret)
+	MCFG_SCREEN_VBLANK_STATIC(dec8)
 
-	MCFG_GFXDECODE(srdarwin)
-	MCFG_PALETTE_LENGTH(144)
+	MCFG_GFXDECODE(gondo)
+	MCFG_PALETTE_LENGTH(1024)
 
-	MCFG_VIDEO_START(srdarwin)
+	MCFG_VIDEO_START(garyoret)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
@@ -2194,46 +2239,50 @@
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
-	MCFG_SOUND_CONFIG(ym3812_config)
+	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
+	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( gondo, dec8_state )
+static MACHINE_CONFIG_START( ghostb, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", HD6309,3000000*4) /* HD63C09EP */
-	MCFG_CPU_PROGRAM_MAP(gondo_map)
+	MCFG_CPU_ADD("maincpu", HD6309, 3000000*4)
+	MCFG_CPU_PROGRAM_MAP(meikyuh_map)
 	MCFG_CPU_VBLANK_INT("screen", gondo_interrupt)
 
 	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(oscar_s_map)
+	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
 								/* NMIs are caused by the main CPU */
 
-	MCFG_CPU_ADD("mcu", I8751, XTAL_8MHz)
+	MCFG_CPU_ADD("mcu", I8751, 3000000*4)
 	MCFG_CPU_IO_MAP(dec8_mcu_io_map)
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+
+	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
 
 	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
 	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(gondo)
+	MCFG_SCREEN_UPDATE_STATIC(ghostb)
 	MCFG_SCREEN_VBLANK_STATIC(dec8)
 
-	MCFG_GFXDECODE(gondo)
+	MCFG_GFXDECODE(ghostb)
 	MCFG_PALETTE_LENGTH(1024)
 
-	MCFG_VIDEO_START(gondo)
+	MCFG_PALETTE_INIT(ghostb)
+	MCFG_VIDEO_START(ghostb)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
@@ -2244,37 +2293,38 @@
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
-	MCFG_SOUND_CONFIG(ym3526_config)
+	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
+	MCFG_SOUND_CONFIG(ym3812_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( lastmisn, dec8_state )
+static MACHINE_CONFIG_START( csilver, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M6809, 2000000)
-	MCFG_CPU_PROGRAM_MAP(lastmisn_map)
+	MCFG_CPU_ADD("maincpu", M6809, XTAL_12MHz/8) /* verified on pcb */
+	MCFG_CPU_PROGRAM_MAP(csilver_map)
 
-	MCFG_CPU_ADD("sub", M6809, 2000000)
-	MCFG_CPU_PROGRAM_MAP(lastmisn_sub_map)
+	MCFG_CPU_ADD("sub", M6809, XTAL_12MHz/8) /* verified on pcb */
+	MCFG_CPU_PROGRAM_MAP(csilver_sub_map)
+	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
 
-	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(ym3526_s_map)
+	MCFG_CPU_ADD("audiocpu", M6502, XTAL_12MHz/8) /* verified on pcb */
+	MCFG_CPU_PROGRAM_MAP(csilver_s_map)
 								/* NMIs are caused by the main CPU */
-	MCFG_QUANTUM_TIME(attotime::from_hz(12000))
+	MCFG_QUANTUM_TIME(attotime::from_hz(6000))
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
 	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
+	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(lastmisn)
@@ -2287,229 +2337,493 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
+	MCFG_SOUND_ADD("ym1", YM2203, XTAL_12MHz/8) /* verified on pcb */
 	MCFG_SOUND_ROUTE(0, "mono", 0.23)
 	MCFG_SOUND_ROUTE(1, "mono", 0.23)
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
+	MCFG_SOUND_ADD("ym2", YM3526, XTAL_12MHz/4) /* verified on pcb */
 	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
+
+	MCFG_SOUND_ADD("msm", MSM5205, XTAL_384kHz) /* verified on pcb */
+	MCFG_SOUND_CONFIG(msm5205_config)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.88)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( shackled, dec8_state )
+static MACHINE_CONFIG_START( oscar, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M6809, 2000000)
-	MCFG_CPU_PROGRAM_MAP(shackled_map)
-
-	MCFG_CPU_ADD("sub", M6809, 2000000)
-	MCFG_CPU_PROGRAM_MAP(shackled_sub_map)
+	MCFG_CPU_ADD("maincpu", HD6309, XTAL_12MHz/2) /* verified on pcb */
+	MCFG_CPU_PROGRAM_MAP(oscar_map)
+	MCFG_CPU_VBLANK_INT("screen", oscar_interrupt)
 
-	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(ym3526_s_map)
+	MCFG_CPU_ADD("sub", HD6309, XTAL_12MHz/2) /* verified on pcb */
+	MCFG_CPU_PROGRAM_MAP(oscar_sub_map)
+
+	MCFG_CPU_ADD("audiocpu", M6502, XTAL_12MHz/8)
+	MCFG_CPU_PROGRAM_MAP(oscar_s_map)
 								/* NMIs are caused by the main CPU */
-	MCFG_QUANTUM_TIME(attotime::from_hz(4800))
+	MCFG_QUANTUM_TIME(attotime::from_hz(2400)) /* 40 CPU slices per frame */
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
-	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
-	deco_karnovsprites_device::set_gfx_region(*device, 1);
+	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
+
+	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
+	deco_mxc06_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(shackled)
+	MCFG_SCREEN_UPDATE_STATIC(oscar)
 
-	MCFG_GFXDECODE(shackled)
-	MCFG_PALETTE_LENGTH(1024)
+	MCFG_GFXDECODE(oscar)
+	MCFG_PALETTE_LENGTH(512)
 
-	MCFG_VIDEO_START(shackled)
+	MCFG_VIDEO_START(oscar)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
+	MCFG_SOUND_ADD("ym1", YM2203, XTAL_12MHz/8) /* verified on pcb */
 	MCFG_SOUND_ROUTE(0, "mono", 0.23)
 	MCFG_SOUND_ROUTE(1, "mono", 0.23)
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
+	MCFG_SOUND_ADD("ym2", YM3526, XTAL_12MHz/4) /* verified on pcb */
 	MCFG_SOUND_CONFIG(ym3526_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( csilver, dec8_state )
+static MACHINE_CONFIG_START( srdarwin, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", M6809, XTAL_12MHz/8) /* verified on pcb */
-	MCFG_CPU_PROGRAM_MAP(csilver_map)
-
-	MCFG_CPU_ADD("sub", M6809, XTAL_12MHz/8) /* verified on pcb */
-	MCFG_CPU_PROGRAM_MAP(csilver_sub_map)
+	MCFG_CPU_ADD("maincpu", M6809,2000000)  /* MC68A09EP */
+	MCFG_CPU_PROGRAM_MAP(srdarwin_map)
 	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
 
-	MCFG_CPU_ADD("audiocpu", M6502, XTAL_12MHz/8) /* verified on pcb */
-	MCFG_CPU_PROGRAM_MAP(csilver_s_map)
+	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
+	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
 								/* NMIs are caused by the main CPU */
-	MCFG_QUANTUM_TIME(attotime::from_hz(6000))
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
-	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
-	deco_karnovsprites_device::set_gfx_region(*device, 1);
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(lastmisn)
+	MCFG_SCREEN_UPDATE_STATIC(srdarwin)
 
-	MCFG_GFXDECODE(shackled)
-	MCFG_PALETTE_LENGTH(1024)
+	MCFG_GFXDECODE(srdarwin)
+	MCFG_PALETTE_LENGTH(144)
 
-	MCFG_VIDEO_START(lastmisn)
+	MCFG_VIDEO_START(srdarwin)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("ym1", YM2203, XTAL_12MHz/8) /* verified on pcb */
+	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
 	MCFG_SOUND_ROUTE(0, "mono", 0.23)
 	MCFG_SOUND_ROUTE(1, "mono", 0.23)
 	MCFG_SOUND_ROUTE(2, "mono", 0.23)
 	MCFG_SOUND_ROUTE(3, "mono", 0.20)
 
-	MCFG_SOUND_ADD("ym2", YM3526, XTAL_12MHz/4) /* verified on pcb */
-	MCFG_SOUND_CONFIG(ym3526_config)
+	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
+	MCFG_SOUND_CONFIG(ym3812_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
-
-	MCFG_SOUND_ADD("msm", MSM5205, XTAL_384kHz) /* verified on pcb */
-	MCFG_SOUND_CONFIG(msm5205_config)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.88)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( garyoret, dec8_state )
+static MACHINE_CONFIG_START( cobracom, dec8_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", HD6309,3000000*4) /* HD63C09EP */
-	MCFG_CPU_PROGRAM_MAP(garyoret_map)
-	MCFG_CPU_VBLANK_INT("screen", gondo_interrupt)
+	MCFG_CPU_ADD("maincpu", M6809, 2000000)
+	MCFG_CPU_PROGRAM_MAP(cobra_map)
+	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
 
 	MCFG_CPU_ADD("audiocpu", M6502, 1500000)
-	MCFG_CPU_PROGRAM_MAP(oscar_s_map)
+	MCFG_CPU_PROGRAM_MAP(dec8_s_map)
 								/* NMIs are caused by the main CPU */
 
 	MCFG_MACHINE_START(dec8)
 	MCFG_MACHINE_RESET(dec8)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+
+	MCFG_DEVICE_ADD("tilegen1", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 2,2,0);
+	MCFG_DEVICE_ADD("tilegen2", DECO_BAC06, 0)
+	deco_bac06_device::set_gfx_region_wide(*device, 3,3,0);
+
+	MCFG_DEVICE_ADD("spritegen", DECO_MXC06, 0)
+	deco_mxc06_device::set_gfx_region(*device, 1);
 
-	MCFG_DEVICE_ADD("spritegen", DECO_KARNOVSPRITES, 0)
-	deco_karnovsprites_device::set_gfx_region(*device, 1);
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(529) /* 58Hz, 529ms Vblank duration */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(garyoret)
-	MCFG_SCREEN_VBLANK_STATIC(dec8)
+	MCFG_SCREEN_UPDATE_STATIC(cobracom)
 
-	MCFG_GFXDECODE(gondo)
-	MCFG_PALETTE_LENGTH(1024)
+	MCFG_GFXDECODE(cobracom)
+	MCFG_PALETTE_LENGTH(256)
 
-	MCFG_VIDEO_START(garyoret)
+	MCFG_VIDEO_START(cobracom)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 	MCFG_SOUND_ADD("ym1", YM2203, 1500000)
-	MCFG_SOUND_ROUTE(0, "mono", 0.23)
-	MCFG_SOUND_ROUTE(1, "mono", 0.23)
-	MCFG_SOUND_ROUTE(2, "mono", 0.23)
-	MCFG_SOUND_ROUTE(3, "mono", 0.20)
+	MCFG_SOUND_ROUTE(0, "mono", 0.53)
+	MCFG_SOUND_ROUTE(1, "mono", 0.53)
+	MCFG_SOUND_ROUTE(2, "mono", 0.53)
+	MCFG_SOUND_ROUTE(3, "mono", 0.50)
 
-	MCFG_SOUND_ADD("ym2", YM3526, 3000000)
-	MCFG_SOUND_CONFIG(ym3526_config)
+	MCFG_SOUND_ADD("ym2", YM3812, 3000000)
+	MCFG_SOUND_CONFIG(ym3812_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 MACHINE_CONFIG_END
 
 /******************************************************************************/
 
-ROM_START( cobracom )
-	ROM_REGION( 0x30000, "maincpu", 0 )
-	ROM_LOAD( "el11-5.bin",  0x08000, 0x08000, CRC(af0a8b05) SHA1(096e4e7f2785a20bfaec14277413ce4e20e90214) )
-	ROM_LOAD( "el12-4.bin",  0x10000, 0x10000, CRC(7a44ef38) SHA1(d7dc277dce08f9d073290e100be4a7ca2e2b82cb) )
-	ROM_LOAD( "el13.bin",    0x20000, 0x10000, CRC(04505acb) SHA1(2220efb277884588859375dab9960f04f07273a7) )
+ROM_START( lastmisn )
+	ROM_REGION( 0x20000, "maincpu", 0 )
+	ROM_LOAD( "dl03-6.13h",  0x08000, 0x08000, CRC(47751a5e) SHA1(190970a6eb849781e8853f2bed7b34ac44e569ca) ) /* Rev 6 roms */
+	ROM_LOAD( "lm_dl04.7h",  0x10000, 0x10000, CRC(7dea1552) SHA1(920684413e2ba4313111e79821c5714977b26b1a) )
+
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "lm_dl02.18h", 0x0000, 0x10000, CRC(ec9b5daf) SHA1(86d47bad123676abc82dd7c92943878c54c33075) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "el10-4.bin",  0x8000,  0x8000,  CRC(edfad118) SHA1(10de8805472346fead62460a3fdc09ae26a4e0d5) )
+	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
 
-	ROM_REGION( 0x08000, "gfx1", 0 )	/* characters */
-	ROM_LOAD( "el14.bin",    0x00000, 0x08000, CRC(47246177) SHA1(51b025740dc03b04009ac97d8d110ab521894386) )
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
 
-	ROM_REGION( 0x80000, "gfx2", 0 )	/* sprites */
-	ROM_LOAD( "el00-4.bin",  0x00000, 0x10000, CRC(122da2a8) SHA1(ce72f16abf7e5449c7d044d4b827e8735c3be0ff) )
-	ROM_LOAD( "el01-4.bin",  0x20000, 0x10000, CRC(27bf705b) SHA1(196c35aaf3816d3eef4c2af6d146a90a48365d33) )
-	ROM_LOAD( "el02-4.bin",  0x40000, 0x10000, CRC(c86fede6) SHA1(97584fa19591651fcfb39d1b2b6306165e93554c) )
-	ROM_LOAD( "el03-4.bin",  0x60000, 0x10000, CRC(1d8a855b) SHA1(429261c200dddc62a330be8aea150b2037133188) )
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
+	ROM_CONTINUE(             0x06000, 0x2000 )
+	ROM_CONTINUE(              0x04000, 0x2000 )
+	ROM_CONTINUE(              0x02000, 0x2000 )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )	/* tiles 1 */
-	ROM_LOAD( "el05.bin",    0x00000, 0x10000, CRC(1c4f6033) SHA1(4a7dece911166d1ff5f41df6ec5140596206d8d4) )
-	ROM_LOAD( "el06.bin",    0x20000, 0x10000, CRC(d24ba794) SHA1(b34b7bbaab4ebdd81c87d363f087cc92e27e8d1c) )
-	ROM_LOAD( "el04.bin",    0x40000, 0x10000, CRC(d80a49ce) SHA1(1a92413b5ab53f80e44a954433e69ec5fe2c0aa6) )
-	ROM_LOAD( "el07.bin",    0x60000, 0x10000, CRC(6d771fc3) SHA1(f29979f3aa07bdb544fb0c1d773c5558b4533390) )
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
+	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
+	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
+	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
 
-	ROM_REGION( 0x80000, "gfx4", 0 )    /* tiles 2 */
-	ROM_LOAD( "el08.bin",    0x00000, 0x08000, CRC(cb0dcf4c) SHA1(e14853f83ee9ba5cbf2eb1e085fee4e65af3cc25) )
-	ROM_CONTINUE(            0x40000, 0x08000 )
-	ROM_LOAD( "el09.bin",    0x20000, 0x08000, CRC(1fae5be7) SHA1(be6e090b0b82648b385d9b6d11775f3ff40f0af3) )
-	ROM_CONTINUE(            0x60000, 0x08000 )
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
+	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
+	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
+	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
+
+	ROM_REGION( 256, "proms", 0 )
+	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
 ROM_END
 
-ROM_START( cobracomj )
-	ROM_REGION( 0x30000, "maincpu", 0 )
-	ROM_LOAD( "eh-11.rom",    0x08000, 0x08000, CRC(868637e1) SHA1(8b1e3e045e341bb94b1f6c7d89198b22e6c19de7) )
-	ROM_LOAD( "eh-12.rom",    0x10000, 0x10000, CRC(7c878a83) SHA1(9b2a3083c6dae69626fdab16d97517d30eaa1859) )
-	ROM_LOAD( "el13.bin",     0x20000, 0x10000, CRC(04505acb) SHA1(2220efb277884588859375dab9960f04f07273a7) )
+ROM_START( lastmisno )
+	ROM_REGION( 0x20000, "maincpu", 0 )
+	ROM_LOAD( "lm_dl03.13h", 0x08000, 0x08000, CRC(357f5f6b) SHA1(a114aac50db62a6bcb943681e517ad7c88ec47f4) ) /* Rev 5 roms */
+	ROM_LOAD( "lm_dl04.7h",  0x10000, 0x10000, CRC(7dea1552) SHA1(920684413e2ba4313111e79821c5714977b26b1a) )
+
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "lm_dl02.18h", 0x0000, 0x10000, CRC(ec9b5daf) SHA1(86d47bad123676abc82dd7c92943878c54c33075) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "eh-10.rom",    0x8000,  0x8000,  CRC(62ca5e89) SHA1(b04acaccc58846e0d277868a873a440b7f8071b0) )
+	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
+	ROM_CONTINUE(             0x06000, 0x2000 )
+	ROM_CONTINUE(              0x04000, 0x2000 )
+	ROM_CONTINUE(              0x02000, 0x2000 )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
+	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
+	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
+	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
+	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
+	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
+	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
+
+	ROM_REGION( 256, "proms", 0 )
+	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
+ROM_END
+
+ROM_START( lastmisnj )
+	ROM_REGION( 0x20000, "maincpu", 0 )
+	ROM_LOAD( "dl03-.13h",   0x08000, 0x08000, CRC(4be5e7e1) SHA1(9f943658663da31947cebdcbcb5f4e2be0714c06) )
+	ROM_LOAD( "dl04-.7h",    0x10000, 0x10000, CRC(f026adf9) SHA1(4ccd0e714a6eb7cee388c93beee2d5510407c961) )
+
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "dl02-.18h",   0x0000, 0x10000, CRC(d0de2b5d) SHA1(e0bb34c2a2ef6fc6f05ab9a98bd23a39004c0c05) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
+	ROM_CONTINUE(             0x06000, 0x2000 )
+	ROM_CONTINUE(              0x04000, 0x2000 )
+	ROM_CONTINUE(              0x02000, 0x2000 )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
+	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
+	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
+	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
+	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
+	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
+	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
+
+	ROM_REGION( 256, "proms", 0 )
+	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
+ROM_END
+
+ROM_START( shackled )
+	ROM_REGION( 0x48000, "maincpu", 0 )
+	ROM_LOAD( "dk-02.rom", 0x08000, 0x08000, CRC(87f8fa85) SHA1(1cb93a60eefdb453a3cc6ec9c5cc2e367fb8aeb0) )
+	ROM_LOAD( "dk-06.rom", 0x10000, 0x10000, CRC(69ad62d1) SHA1(1aa23b12ab4f1908cddd25f091e1f9bd70a5113c) )
+	ROM_LOAD( "dk-05.rom", 0x20000, 0x10000, CRC(598dd128) SHA1(10843c5352eef03c8675df6abaf23c9c9c795aa3) )
+	ROM_LOAD( "dk-04.rom", 0x30000, 0x10000, CRC(36d305d4) SHA1(17586c316aff405cf20c1467d69c98fa2a3c2630) )
+	ROM_LOAD( "dk-03.rom", 0x40000, 0x08000, CRC(6fd90fd1) SHA1(2f8db17e5545c82d243a7e23e7bda2c2a9101360) )
+
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "dk-01.rom", 0x00000, 0x10000, CRC(71fe3bda) SHA1(959cce01362b2c670c2e15b03a78a1ff9cea4ee9) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "dk-07.rom", 0x08000, 0x08000, CRC(887e4bcc) SHA1(6427396080e9cd8647adff47c8ed04593a14268c) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dk-00.rom", 0x00000, 0x08000, CRC(69b975aa) SHA1(38cb96768c79ff1aa1b4b190e08ec9155baf698a) )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dk-12.rom", 0x00000, 0x10000, CRC(615c2371) SHA1(30b25dc27d34646d886a465c77622eaa894d83c3) )
+	ROM_LOAD( "dk-13.rom", 0x10000, 0x10000, CRC(479aa503) SHA1(1167f0d15439c95a1094f81855203e863ce0488d) )
+	ROM_LOAD( "dk-14.rom", 0x20000, 0x10000, CRC(cdc24246) SHA1(1a4189bc2b1fa99740dd7921608159936ba3bd07) )
+	ROM_LOAD( "dk-15.rom", 0x30000, 0x10000, CRC(88db811b) SHA1(7d3c4a80925f323efb589798b4a341d1a2ca95f9) )
+	ROM_LOAD( "dk-16.rom", 0x40000, 0x10000, CRC(061a76bd) SHA1(5bcb513e48bed9b7c4207d94531be691a85e295d) )
+	ROM_LOAD( "dk-17.rom", 0x50000, 0x10000, CRC(a6c5d8af) SHA1(58f3fece9a5ef8b39090a2f39610381b8e7cdbf7) )
+	ROM_LOAD( "dk-18.rom", 0x60000, 0x10000, CRC(4d466757) SHA1(701d79bebbba4f266e19080d16ff2f93ffa94287) )
+	ROM_LOAD( "dk-19.rom", 0x70000, 0x10000, CRC(1911e83e) SHA1(174e9db3f2211ecbbb93c6bda8f6185dbfdbc818) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dk-11.rom", 0x00000, 0x10000, CRC(5cf5719f) SHA1(8c7582ac19010421ec748391a193aa18e51b981f) )
+	ROM_LOAD( "dk-10.rom", 0x20000, 0x10000, CRC(408e6d08) SHA1(28cb76792e5f84bd101a91cb82597a5939804f84) )
+	ROM_LOAD( "dk-09.rom", 0x40000, 0x10000, CRC(c1557fac) SHA1(7d39ec793113a48baf45c2ea07abb07e2e48985a) )
+	ROM_LOAD( "dk-08.rom", 0x60000, 0x10000, CRC(5e54e9f5) SHA1(1ab41a3bde1f2c2be670e89cf402be28001c17d1) )
+ROM_END
+
+ROM_START( breywood )
+	ROM_REGION( 0x48000, "maincpu", 0 )
+	ROM_LOAD( "7.bin", 0x08000, 0x08000, CRC(c19856b9) SHA1(766994703bb59879c311675353d7231ad27c7c16) )
+	ROM_LOAD( "3.bin", 0x10000, 0x10000, CRC(2860ea02) SHA1(7ac090c3ae9d71baa6227ec9555f1c9f2d25ea0d) )
+	ROM_LOAD( "4.bin", 0x20000, 0x10000, CRC(0fdd915e) SHA1(262df956dfc727c710ade28af7f33fddaafd7ee2) )
+	ROM_LOAD( "5.bin", 0x30000, 0x10000, CRC(71036579) SHA1(c58ff3222b5bcd75d58c5f282554e92103e80916) )
+	ROM_LOAD( "6.bin", 0x40000, 0x08000, CRC(308f4893) SHA1(539c138ff01c5718cc8a982482b989468d532699) )
+
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "8.bin", 0x0000, 0x10000,  CRC(3d9fb623) SHA1(6e5eaad9bb0a432e2da5da5b18a2ed36617bdde2) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "2.bin", 0x8000, 0x8000,  CRC(4a471c38) SHA1(963ed7b6afeefdfc2cf0d65b0998f973330e6495) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "1.bin",  0x00000, 0x08000, CRC(815a891a) SHA1(e557d6a35821a8589d9e3df0f42131b58b08c8ca) )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "20.bin", 0x00000, 0x10000, CRC(2b7634f2) SHA1(56d963d4960d9b3e888c8107340763e176adfa9b) )
+	ROM_LOAD( "19.bin", 0x10000, 0x10000, CRC(4530a952) SHA1(99251a21347815cba465669e18df31262bcdaba1) )
+	ROM_LOAD( "18.bin", 0x20000, 0x10000, CRC(87c28833) SHA1(3f1a294065326389d304e540bc880844c6c7cb06) )
+	ROM_LOAD( "17.bin", 0x30000, 0x10000, CRC(bfb43a4d) SHA1(56092935147a3b643a9b39eb7cfc067a764644c5) )
+	ROM_LOAD( "16.bin", 0x40000, 0x10000, CRC(f9848cc4) SHA1(6d8e77b67ce4d418defba6f6979632f31d2307c6) )
+	ROM_LOAD( "15.bin", 0x50000, 0x10000, CRC(baa3d218) SHA1(3c31df23cc871cffd9a4dafae106e4a98f5af848) )
+	ROM_LOAD( "14.bin", 0x60000, 0x10000, CRC(12afe533) SHA1(6df3471c16a714d118717da549a7523aa388ddd3) )
+	ROM_LOAD( "13.bin", 0x70000, 0x10000, CRC(03373755) SHA1(d2541dd957803168f246d96b7cd74eae7fd43188) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "9.bin",  0x00000, 0x10000, CRC(067e2a43) SHA1(f1da7455aab21f94ed25a93b0ebfde69baa475d1) )
+	ROM_LOAD( "10.bin", 0x20000, 0x10000, CRC(c19733aa) SHA1(3dfcfd33c5c4f792bb941ac933301c03ddd72b03) )
+	ROM_LOAD( "11.bin", 0x40000, 0x10000, CRC(e37d5dbe) SHA1(ff79b4f6d8b0a3061e78d15480df0155650f347f) )
+	ROM_LOAD( "12.bin", 0x60000, 0x10000, CRC(beee880f) SHA1(9a818a75cbec425a13f629bda6d50aa341aa1896) )
+ROM_END
+
+ROM_START( gondo )
+	ROM_REGION( 0x40000, "maincpu", 0 )
+	ROM_LOAD( "dt-00.256", 0x08000, 0x08000, CRC(a8cf9118) SHA1(865744c9866957d686a31608d356e279fe58934e) )
+	ROM_LOAD( "dt-01.512", 0x10000, 0x10000, CRC(c39bb877) SHA1(9beb59ba19f38417c5d4d36e8f3c41f2b017d2d6) )
+	ROM_LOAD( "dt-02.512", 0x20000, 0x10000, CRC(bb5e674b) SHA1(8057dc7464a8b6987536f248d607957923b223cf) )
+	ROM_LOAD( "dt-03.512", 0x30000, 0x10000, CRC(99c32b13) SHA1(3d79f48e7d198cb2e519d592a89eda505044bce5) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "dt-05.256", 0x8000, 0x8000, CRC(ec08aa29) SHA1(ce83974ae095d9518d1ebf9f7e712f0cbc2c1b42) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_LOAD( "dt-a.1b", 0x0000, 0x1000, CRC(03abceeb) SHA1(a16b779d7cea1c1437f85fa6b6e08894a46a5674) )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dt-14.256", 0x00000, 0x08000, CRC(4bef16e1) SHA1(b8157a7a1b8f36cea1fd353267a4e03d920cb4aa) )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dt-19.512", 0x00000, 0x10000, CRC(da2abe4b) SHA1(d53e4769671f3fd437edcff7e7ea05156bbcb45d) )
+	ROM_LOAD( "dt-20.256", 0x10000, 0x08000, CRC(42d01002) SHA1(5a289ffdc83c05f21908a5d0b6247da5b51c1ddd) )
+	ROM_LOAD( "dt-16.512", 0x20000, 0x10000, CRC(e9955d8f) SHA1(aeef5e18f9d36c1bab3000e95205ce1b18cfbf0b) )
+	ROM_LOAD( "dt-18.256", 0x30000, 0x08000, CRC(c0c5df1c) SHA1(5b0f71f590434cdd0545ce098666798927727469) )
+	ROM_LOAD( "dt-15.512", 0x40000, 0x10000, CRC(a54b2eb6) SHA1(25cb61f67135672154f1ad8e0c49ec04655e91de) )
+	ROM_LOAD( "dt-17.256", 0x50000, 0x08000, CRC(3bbcff0d) SHA1(a8f7aa56ff49ed6b29240c3504d6c9945944953b) )
+	ROM_LOAD( "dt-21.512", 0x60000, 0x10000, CRC(1c5f682d) SHA1(4b7022cce930a9e9a0087c91e8344269fe7ed889) )
+	ROM_LOAD( "dt-22.256", 0x70000, 0x08000, CRC(c1876a5f) SHA1(66122ce765723765e20036bd4d461a210c8b94d3) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dt-08.512", 0x00000, 0x08000, CRC(aec483f5) SHA1(1d6de823ab0eeb9c89e9c227428ff278663627f3) )
+	ROM_CONTINUE(          0x10000, 0x08000 )
+	ROM_LOAD( "dt-09.256", 0x08000, 0x08000, CRC(446f0ce0) SHA1(072b88d6de5aa0ed6b1d60c266bcf170dea927d5) )
+	ROM_LOAD( "dt-06.512", 0x20000, 0x08000, CRC(3fe1527f) SHA1(b8df4bef2b1a879b65214025fc3b5998ef5c8886) )
+	ROM_CONTINUE(          0x30000, 0x08000 )
+	ROM_LOAD( "dt-07.256", 0x28000, 0x08000, CRC(61f9bce5) SHA1(ef8a5f5e4c66a143304bcab50ca87579f1507864) )
+	ROM_LOAD( "dt-12.512", 0x40000, 0x08000, CRC(1a72ca8d) SHA1(f412758452cb3417e85c355ccb8794fde7edf1cc) )
+	ROM_CONTINUE(          0x50000, 0x08000 )
+	ROM_LOAD( "dt-13.256", 0x48000, 0x08000, CRC(ccb81aec) SHA1(56e524ed4373b7bd1074a0d22ff75ede379f1696) )
+	ROM_LOAD( "dt-10.512", 0x60000, 0x08000, CRC(cfcfc9ed) SHA1(57f43d638cf864d68420f0203740be7bda9da5ca) )
+	ROM_CONTINUE(          0x70000, 0x08000 )
+	ROM_LOAD( "dt-11.256", 0x68000, 0x08000, CRC(53e9cf17) SHA1(8cbb45154a60f42f1b1e7299b12d2e92fc194df8) )
+
+	ROM_REGION( 1024, "proms", 0 )
+	ROM_LOAD( "mb7122e.10b", 0x00000,  0x400,  CRC(dcbfec4e) SHA1(a375caef4575746870e285d90ba991ea7daefad6) )    /* Priority (Not yet used) */
+ROM_END
+
+ROM_START( makyosen )
+	ROM_REGION( 0x40000, "maincpu", 0 )
+	ROM_LOAD( "ds00",      0x08000, 0x08000, CRC(33bb16fe) SHA1(5d3873b66e0d08b35d56a8b508c774b27368a100) )
+	ROM_LOAD( "dt-01.512", 0x10000, 0x10000, CRC(c39bb877) SHA1(9beb59ba19f38417c5d4d36e8f3c41f2b017d2d6) )
+	ROM_LOAD( "ds02",      0x20000, 0x10000, CRC(925307a4) SHA1(1e8b8eb21df1a11b14c981b343b34c6cc3676517) )
+	ROM_LOAD( "ds03",      0x30000, 0x10000, CRC(9c0fcbf6) SHA1(bfe42b5277fea111840a9f59b2cb8dfe44444029) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "ds05",      0x8000, 0x8000, CRC(e6e28ca9) SHA1(3b1f8219331db1910bfb428f8964f8fc1063df6f) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H (fake) MCU based on 'gondo' one */
+	ROM_LOAD( "ds-a.1b", 0x0000, 0x1000, BAD_DUMP CRC(f61b77cf) SHA1(2d3549876ea08623ce9da1d637853cb4c740300a))
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "ds14",      0x00000, 0x08000, CRC(00cbe9c8) SHA1(de7b640de8fd54ee79194945c96d5768d09f483b) )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dt-19.512", 0x00000, 0x10000, CRC(da2abe4b) SHA1(d53e4769671f3fd437edcff7e7ea05156bbcb45d) )
+	ROM_LOAD( "ds20",      0x10000, 0x08000, CRC(0eef7f56) SHA1(05c23aa6a598478cd4822634cff96055c585e9d2) )
+	ROM_LOAD( "dt-16.512", 0x20000, 0x10000, CRC(e9955d8f) SHA1(aeef5e18f9d36c1bab3000e95205ce1b18cfbf0b) )
+	ROM_LOAD( "ds18",      0x30000, 0x08000, CRC(2b2d1468) SHA1(a144ac1b367e1fec876156230e9ab1c99416962e) )
+	ROM_LOAD( "dt-15.512", 0x40000, 0x10000, CRC(a54b2eb6) SHA1(25cb61f67135672154f1ad8e0c49ec04655e91de) )
+	ROM_LOAD( "ds17",      0x50000, 0x08000, CRC(75ae349a) SHA1(15755a28925d5ed37fab4bd988716fcc5d20c290) )
+	ROM_LOAD( "dt-21.512", 0x60000, 0x10000, CRC(1c5f682d) SHA1(4b7022cce930a9e9a0087c91e8344269fe7ed889) )
+	ROM_LOAD( "ds22",      0x70000, 0x08000, CRC(c8ffb148) SHA1(ae1a8b3cd1f5e423dc1a3c7d05f9fe7c689432e3) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dt-08.512", 0x00000, 0x08000, CRC(aec483f5) SHA1(1d6de823ab0eeb9c89e9c227428ff278663627f3) )
+	ROM_CONTINUE(          0x10000, 0x08000 )
+	ROM_LOAD( "dt-09.256", 0x08000, 0x08000, CRC(446f0ce0) SHA1(072b88d6de5aa0ed6b1d60c266bcf170dea927d5) )
+	ROM_LOAD( "dt-06.512", 0x20000, 0x08000, CRC(3fe1527f) SHA1(b8df4bef2b1a879b65214025fc3b5998ef5c8886) )
+	ROM_CONTINUE(          0x30000, 0x08000 )
+	ROM_LOAD( "dt-07.256", 0x28000, 0x08000, CRC(61f9bce5) SHA1(ef8a5f5e4c66a143304bcab50ca87579f1507864) )
+	ROM_LOAD( "dt-12.512", 0x40000, 0x08000, CRC(1a72ca8d) SHA1(f412758452cb3417e85c355ccb8794fde7edf1cc) )
+	ROM_CONTINUE(          0x50000, 0x08000 )
+	ROM_LOAD( "dt-13.256", 0x48000, 0x08000, CRC(ccb81aec) SHA1(56e524ed4373b7bd1074a0d22ff75ede379f1696) )
+	ROM_LOAD( "dt-10.512", 0x60000, 0x08000, CRC(cfcfc9ed) SHA1(57f43d638cf864d68420f0203740be7bda9da5ca) )
+	ROM_CONTINUE(          0x70000, 0x08000 )
+	ROM_LOAD( "dt-11.256", 0x68000, 0x08000, CRC(53e9cf17) SHA1(8cbb45154a60f42f1b1e7299b12d2e92fc194df8) )
+
+	ROM_REGION( 1024, "proms", 0 )
+	ROM_LOAD( "mb7122e.10b", 0x00000,  0x400,  CRC(dcbfec4e) SHA1(a375caef4575746870e285d90ba991ea7daefad6) )    /* Priority (Not yet used) */
+
+	ROM_REGION( 0x0600, "plds", 0 )
+	ROM_LOAD( "pal16r4nc.10u", 0x0000, 0x0104, NO_DUMP ) /* PAL is read protected */
+	ROM_LOAD( "pal16r4nc.11g", 0x0200, 0x0104, NO_DUMP ) /* PAL is read protected */
+	ROM_LOAD( "pal16r4nc.1s",  0x0400, 0x0104, NO_DUMP ) /* PAL is read protected */
+ROM_END
+
+ROM_START( garyoret )
+	ROM_REGION( 0x50000, "maincpu", 0 )
+	ROM_LOAD( "dv00", 0x08000, 0x08000, CRC(cceaaf05) SHA1(b8f54638feab77d023e01ced947e1269f0d19fd8) )
+	ROM_LOAD( "dv01", 0x10000, 0x10000, CRC(c33fc18a) SHA1(0d9594b0e6c39aea5b9f15f6aa364b31604f1066) )
+	ROM_LOAD( "dv02", 0x20000, 0x10000, CRC(f9e26ce7) SHA1(8589594ebc7ae16942739382273a222dfa30b3b7) )
+	ROM_LOAD( "dv03", 0x30000, 0x10000, CRC(55d8d699) SHA1(da1519cd54d27cc406420ce0845e43f7228cfd4e) )
+	ROM_LOAD( "dv04", 0x40000, 0x10000, CRC(ed3d00ee) SHA1(6daa2ee509235ad03d3012a00382820279add620) )
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "dv05", 0x08000, 0x08000, CRC(c97c347f) SHA1(a1b22733dc15d524af97db3e608a82503a49b182) )
+
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H (fake) MCU based on 'gondo' one */
+	ROM_LOAD( "dv__.mcu", 0x0000, 0x1000, BAD_DUMP CRC(37cacec6) SHA1(d81fe36939ccac784a83a69dfc6898b22a4515ec) )
+
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "dv14", 0x00000, 0x08000, CRC(fb2bc581) SHA1(d597976c5ae586166c49051cc3de8cf0c2e5a5e1) )    /* Characters */
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dv22", 0x00000, 0x10000, CRC(cef0367e) SHA1(8beb3a6b91ec0a6ec052243c8f626a581d349f65) )
+	ROM_LOAD( "dv21", 0x10000, 0x08000, CRC(90042fb7) SHA1(f19bbf158c92030e8fddb5087b5b69b71956baf8) )
+	ROM_LOAD( "dv20", 0x20000, 0x10000, CRC(451a2d8c) SHA1(f4eea444b797d394edeb514ddc1c494fd7ccc2f2) )
+	ROM_LOAD( "dv19", 0x30000, 0x08000, CRC(14e1475b) SHA1(f0aec5b7b4be0da06a73ed382e7e851654e47e47) )
+	ROM_LOAD( "dv18", 0x40000, 0x10000, CRC(7043bead) SHA1(5d1be8b9cd56ae43d60406b05258d20de980096d) )
+	ROM_LOAD( "dv17", 0x50000, 0x08000, CRC(28f449d7) SHA1(cf1bc690b67910c42ad09531ab1d88461d00b944) )
+	ROM_LOAD( "dv16", 0x60000, 0x10000, CRC(37e4971e) SHA1(9442c315b7cdbcc046d9e6838cb793c1857174ed) )
+	ROM_LOAD( "dv15", 0x70000, 0x08000, CRC(ca41b6ac) SHA1(d7a9ef6c89741c1e8e17a668a9d39ea089f5c73f) )
 
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "el14.bin",    0x00000, 0x08000, CRC(47246177) SHA1(51b025740dc03b04009ac97d8d110ab521894386) )
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dv08", 0x00000, 0x08000, CRC(89c13e15) SHA1(6507e60de5cd78a5b46090e4825a44c2a23631d7) )
+	ROM_CONTINUE(     0x10000, 0x08000 )
+	ROM_LOAD( "dv09", 0x08000, 0x08000, CRC(6a345a23) SHA1(b86f81b9fe25acd833ca3e2cff6cfa853c02280a) )
+	ROM_CONTINUE(     0x18000, 0x08000 )
 
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "eh-00.rom",    0x00000, 0x10000, CRC(d96b6797) SHA1(01c4a9f2bebb13cba14636690cd5356db73f045e) )
-	ROM_LOAD( "eh-01.rom",    0x20000, 0x10000, CRC(3fef9c02) SHA1(e4b731faf6a2f4e5fed8ba9bd07e0f203981ffec) )
-	ROM_LOAD( "eh-02.rom",    0x40000, 0x10000, CRC(bfae6c34) SHA1(9503a120e11e9466cd9a2931fd44a631d72ca5f0) )
-	ROM_LOAD( "eh-03.rom",    0x60000, 0x10000, CRC(d56790f8) SHA1(1cc7cb9f7102158de14a737e9317a54f01790ba8) )
+	ROM_LOAD( "dv06", 0x20000, 0x08000, CRC(1eb52a20) SHA1(46670ed973f794be9c2c7e6bf5d97db51211e9a9) )
+	ROM_CONTINUE(     0x30000, 0x08000 )
+	ROM_LOAD( "dv07", 0x28000, 0x08000, CRC(e7346ef8) SHA1(8083a7a182e8ed904daf2f692115d01b3d0830eb) )
+	ROM_CONTINUE(     0x38000, 0x08000 )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles 1 */
-	ROM_LOAD( "el05.bin",    0x00000, 0x10000, CRC(1c4f6033) SHA1(4a7dece911166d1ff5f41df6ec5140596206d8d4) )
-	ROM_LOAD( "el06.bin",    0x20000, 0x10000, CRC(d24ba794) SHA1(b34b7bbaab4ebdd81c87d363f087cc92e27e8d1c) )
-	ROM_LOAD( "el04.bin",    0x40000, 0x10000, CRC(d80a49ce) SHA1(1a92413b5ab53f80e44a954433e69ec5fe2c0aa6) )
-	ROM_LOAD( "el07.bin",    0x60000, 0x10000, CRC(6d771fc3) SHA1(f29979f3aa07bdb544fb0c1d773c5558b4533390) )
+	ROM_LOAD( "dv12", 0x40000, 0x08000, CRC(46ba5af4) SHA1(a1c13e7e3c85060202120b64e3cee32c1f733270) )
+	ROM_CONTINUE(     0x50000, 0x08000 )
+	ROM_LOAD( "dv13", 0x48000, 0x08000, CRC(a7af6dfd) SHA1(fa41bdafb64c79bd9769903fd37d4d5172b66a52) )
+	ROM_CONTINUE(     0x58000, 0x08000 )
 
-	ROM_REGION( 0x80000, "gfx4", 0 )    /* tiles 2 */
-	ROM_LOAD( "el08.bin",    0x00000, 0x08000, CRC(cb0dcf4c) SHA1(e14853f83ee9ba5cbf2eb1e085fee4e65af3cc25) )
-	ROM_CONTINUE(            0x40000, 0x08000 )
-	ROM_LOAD( "el09.bin",    0x20000, 0x08000, CRC(1fae5be7) SHA1(be6e090b0b82648b385d9b6d11775f3ff40f0af3) )
-	ROM_CONTINUE(            0x60000, 0x08000 )
+	ROM_LOAD( "dv10", 0x60000, 0x08000, CRC(68b6d75c) SHA1(ac719ef6b30ac9e63fab13cb359e6114493f274d) )
+	ROM_CONTINUE(     0x70000, 0x08000 )
+	ROM_LOAD( "dv11", 0x68000, 0x08000, CRC(b5948aee) SHA1(587afbfeda985bede9e4b5f57dad6763f4294962) )
+	ROM_CONTINUE(     0x78000, 0x08000 )
 ROM_END
 
 ROM_START( ghostb )
@@ -2523,7 +2837,7 @@
 	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
 	ROM_LOAD( "dz06.5f", 0x8000, 0x8000, CRC(798f56df) SHA1(aee33cd0c102015114e17f6cb98945e7cc806f55) )
 
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H (fake) MCU */
 	ROM_LOAD( "dz-1.1b", 0x0000, 0x1000, BAD_DUMP CRC(18b7e1e6) SHA1(46b6d914ecee5e743ac805be1545ca44fb016d7d) ) /* Verfied label, but is it different the other DZ */
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
@@ -2561,7 +2875,7 @@
 	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
 	ROM_LOAD( "dz06.5f", 0x8000, 0x8000, CRC(798f56df) SHA1(aee33cd0c102015114e17f6cb98945e7cc806f55) )
 
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H (fake) MCU */
 	ROM_LOAD( "dz.1b", 0x0000, 0x1000, BAD_DUMP CRC(18b7e1e6) SHA1(46b6d914ecee5e743ac805be1545ca44fb016d7d) )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
@@ -2599,7 +2913,7 @@
 	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
 	ROM_LOAD( "dz06.5f", 0x8000, 0x8000, CRC(798f56df) SHA1(aee33cd0c102015114e17f6cb98945e7cc806f55) )
 
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
+	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H (fake) MCU */
 	ROM_LOAD( "dz.1b", 0x0000, 0x1000, BAD_DUMP CRC(18b7e1e6) SHA1(46b6d914ecee5e743ac805be1545ca44fb016d7d) )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
@@ -2844,171 +3158,126 @@
 	ROM_LOAD( "dw19.10d", 0x0400, 0x0400, CRC(cc16f3fa) SHA1(4562106ff752f5fc5ae00ff098141e5d74fe4700)  )
 ROM_END
 
-ROM_START( srdarwin )
-	ROM_REGION( 0x28000, "maincpu", 0 )
-	ROM_LOAD( "dy01-e.b14", 0x20000, 0x08000, CRC(176e9299) SHA1(20cd44ab610e384ab4f0172054c9adc432b12e9c) )
-	ROM_CONTINUE(           0x08000, 0x08000 )
-	ROM_LOAD( "dy00.b16", 0x10000, 0x10000, CRC(2bf6b461) SHA1(435d922c7b9df7f2b2f774346caed81d330be8a0) )
-
-	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
-	ROM_LOAD( "dy04.d7", 0x8000, 0x8000, CRC(2ae3591c) SHA1(f21b06d84e2c3d3895be0812024641fd006e45cf) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dy05.b6", 0x00000, 0x4000, CRC(8780e8a3) SHA1(03ea91fdc5aba8e139201604fb3bf9b69f71f056) )
+/*
+Main Compoennts
+---------------
 
-	ROM_REGION( 0x30000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dy07.h16", 0x00000, 0x8000, CRC(97eaba60) SHA1(e3252b67bad7babcf4ece39f46ae4aeb950eb92b) )
-	ROM_LOAD( "dy06.h14", 0x08000, 0x8000, CRC(c279541b) SHA1(eb3737413499d07b6c2af99a95b27b2590e670c5) )
-	ROM_LOAD( "dy09.k13", 0x10000, 0x8000, CRC(d30d1745) SHA1(647b6121ab6fa812368da45e1295cc41f73be89d) )
-	ROM_LOAD( "dy08.k11", 0x18000, 0x8000, CRC(71d645fd) SHA1(a74a9b9697fc39b4e675e732a9d7d82976cc95dd) )
-	ROM_LOAD( "dy11.k16", 0x20000, 0x8000, CRC(fd9ccc5b) SHA1(b38c44c01acdc455d4192e4c8be1d68d9eb0c7b6) )
-	ROM_LOAD( "dy10.k14", 0x28000, 0x8000, CRC(88770ab8) SHA1(0a4a807a8d3b0653864bd984872d5567836f8cf8) )
+Top board (DATA EAST DE-0250-3):
+2x MC68B09EP (18e,19e)(main)
+1x RP65C02A (3f)(sound)
+1x YM3812 (1e)(sound)
+1x YM2203 (1f)(sound)
+2x Y30148 (1j,2j)(sound)
+1x OKI M5205 (3j)(sound)
+1x NEC PC3403C (1j)(sound)
+1x C4558C (2j)(sound)
+1x oscillator 8.000 (x1)
+1x ID8751H (read protected)
 
-	ROM_REGION( 0x40000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dy03.b4",  0x00000, 0x4000, CRC(44f2a4f9) SHA1(97368dd112451cd630f2fa5ba54679e84e7d4d97) )
-	ROM_CONTINUE(         0x10000, 0x4000 )
-	ROM_CONTINUE(         0x20000, 0x4000 )
-	ROM_CONTINUE(         0x30000, 0x4000 )
-	ROM_LOAD( "dy02.b5",  0x08000, 0x4000, CRC(522d9a9e) SHA1(248274ed6df604357cad386fcf0521b26810aa0e) )
-	ROM_CONTINUE(         0x18000, 0x4000 )
-	ROM_CONTINUE(         0x28000, 0x4000 )
-	ROM_CONTINUE(         0x38000, 0x4000 )
+Lower board (DATA EAST DE-0251-2):
+1x DECO TC15G032AY-0013-8644a-DSPC10 (square component, with 135 pass-through pins)(14h)
+1x DECO VSC30-M60348-6102 (DIL40)(9a)
+1x DECO HMC20-M60232-6902 (DIL28)(14a)
+1x oscillator 12.000 (x1)
 
-	ROM_REGION( 256, "proms", 0 )
-	ROM_LOAD( "dy12.f4",  0x00000,  0x100,  CRC(ebfaaed9) SHA1(5723dbfa3eb3fc4df8c8975b320a5c49848309d8) )    /* Priority (Not yet used) */
-ROM_END
+ROMs
+----
 
-ROM_START( srdarwinj )
-	ROM_REGION( 0x28000, "maincpu", 0 )
-	ROM_LOAD( "dy_01.rom", 0x20000, 0x08000, CRC(1eeee4ff) SHA1(89a70de8bd61c671582b11773ce69b2edcd9c2f8) )
-	ROM_CONTINUE(          0x08000, 0x08000 )
-	ROM_LOAD( "dy00.b16", 0x10000, 0x10000, CRC(2bf6b461) SHA1(435d922c7b9df7f2b2f774346caed81d330be8a0) )
+Top board (DATA EAST DE-0250-3):
+2x MBM27256 (00,03)
+10x MBM27C512 (01,02,04,05,06,07,08,09,10,11)
+1x MB7122 (DIL18) (15)
 
-	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
-	ROM_LOAD( "dy04.d7", 0x8000, 0x8000, CRC(2ae3591c) SHA1(f21b06d84e2c3d3895be0812024641fd006e45cf) )
+Lower board (DATA EAST DE-0251-2):
+3x MBM27C512
 
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+Notes
+-----
 
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dy05.b6", 0x00000, 0x4000, CRC(8780e8a3) SHA1(03ea91fdc5aba8e139201604fb3bf9b69f71f056) )
+Top board (DATA EAST DE-0250-3):
+1x JAMMA edge connector
+2x 25x2 legs connectors to lower board (cn1,cn2)
+1x trimmer (volume)
+2x 8 switches dip (7k,16k)
 
-	ROM_REGION( 0x30000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dy07.h16", 0x00000, 0x8000, CRC(97eaba60) SHA1(e3252b67bad7babcf4ece39f46ae4aeb950eb92b) )
-	ROM_LOAD( "dy06.h14", 0x08000, 0x8000, CRC(c279541b) SHA1(eb3737413499d07b6c2af99a95b27b2590e670c5) )
-	ROM_LOAD( "dy09.k13", 0x10000, 0x8000, CRC(d30d1745) SHA1(647b6121ab6fa812368da45e1295cc41f73be89d) )
-	ROM_LOAD( "dy08.k11", 0x18000, 0x8000, CRC(71d645fd) SHA1(a74a9b9697fc39b4e675e732a9d7d82976cc95dd) )
-	ROM_LOAD( "dy11.k16", 0x20000, 0x8000, CRC(fd9ccc5b) SHA1(b38c44c01acdc455d4192e4c8be1d68d9eb0c7b6) )
-	ROM_LOAD( "dy10.k14", 0x28000, 0x8000, CRC(88770ab8) SHA1(0a4a807a8d3b0653864bd984872d5567836f8cf8) )
+Lower board (DATA EAST DE-0251-2):
+2x 25x2 legs connectors to top board (cn1,cn2)
 
-	ROM_REGION( 0x40000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dy03.b4",  0x00000, 0x4000, CRC(44f2a4f9) SHA1(97368dd112451cd630f2fa5ba54679e84e7d4d97) )
-	ROM_CONTINUE(         0x10000, 0x4000 )
-	ROM_CONTINUE(         0x20000, 0x4000 )
-	ROM_CONTINUE(         0x30000, 0x4000 )
-	ROM_LOAD( "dy02.b5",  0x08000, 0x4000, CRC(522d9a9e) SHA1(248274ed6df604357cad386fcf0521b26810aa0e) )
-	ROM_CONTINUE(         0x18000, 0x4000 )
-	ROM_CONTINUE(         0x28000, 0x4000 )
-	ROM_CONTINUE(         0x38000, 0x4000 )
+*/
 
-	ROM_REGION( 256, "proms", 0 )
-	ROM_LOAD( "dy12.f4",  0x00000,  0x100,  CRC(ebfaaed9) SHA1(5723dbfa3eb3fc4df8c8975b320a5c49848309d8) )    /* Priority (Not yet used) */
-ROM_END
+ROM_START( csilver )
+	ROM_REGION( 0x48000, "maincpu", 0 )
+	ROM_LOAD( "dx03-12.18d", 0x08000, 0x08000, CRC(2d926e7c) SHA1(cf38e92904edb1870b0a4965f9049d67efe8cf6a) )
+	ROM_LOAD( "dx01.12d", 0x10000, 0x10000, CRC(570fb50c) SHA1(3002f53182834a060fc282be1bc5767906e19ba2) )
+	ROM_LOAD( "dx02.13d", 0x20000, 0x10000, CRC(58625890) SHA1(503a969085f6dcb16687217c48136ea22d07c89f) )
 
-ROM_START( gondo )
-	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD( "dt-00.256", 0x08000, 0x08000, CRC(a8cf9118) SHA1(865744c9866957d686a31608d356e279fe58934e) )
-	ROM_LOAD( "dt-01.512", 0x10000, 0x10000, CRC(c39bb877) SHA1(9beb59ba19f38417c5d4d36e8f3c41f2b017d2d6) )
-	ROM_LOAD( "dt-02.512", 0x20000, 0x10000, CRC(bb5e674b) SHA1(8057dc7464a8b6987536f248d607957923b223cf) )
-	ROM_LOAD( "dt-03.512", 0x30000, 0x10000, CRC(99c32b13) SHA1(3d79f48e7d198cb2e519d592a89eda505044bce5) )
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "dx04-1.19d", 0x0000, 0x10000,  CRC(29432691) SHA1(a76ecd27d217c66a0e43f93e29efe83c657925c3) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dt-05.256", 0x8000, 0x8000, CRC(ec08aa29) SHA1(ce83974ae095d9518d1ebf9f7e712f0cbc2c1b42) )
+	ROM_REGION( 0x18000, "audiocpu", 0 )
+	ROM_LOAD( "dx05.3f", 0x10000, 0x08000,  CRC(eb32cf25) SHA1(9390c88033259c65eb15320e31f5d696970987cc) )
+	ROM_CONTINUE(   0x08000, 0x08000 )
 
 	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "dt-a.1b", 0x0000, 0x1000, CRC(03abceeb) SHA1(a16b779d7cea1c1437f85fa6b6e08894a46a5674) )
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP ) // dx-8.19a ?
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dt-14.256", 0x00000, 0x08000, CRC(4bef16e1) SHA1(b8157a7a1b8f36cea1fd353267a4e03d920cb4aa) )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dt-19.512", 0x00000, 0x10000, CRC(da2abe4b) SHA1(d53e4769671f3fd437edcff7e7ea05156bbcb45d) )
-	ROM_LOAD( "dt-20.256", 0x10000, 0x08000, CRC(42d01002) SHA1(5a289ffdc83c05f21908a5d0b6247da5b51c1ddd) )
-	ROM_LOAD( "dt-16.512", 0x20000, 0x10000, CRC(e9955d8f) SHA1(aeef5e18f9d36c1bab3000e95205ce1b18cfbf0b) )
-	ROM_LOAD( "dt-18.256", 0x30000, 0x08000, CRC(c0c5df1c) SHA1(5b0f71f590434cdd0545ce098666798927727469) )
-	ROM_LOAD( "dt-15.512", 0x40000, 0x10000, CRC(a54b2eb6) SHA1(25cb61f67135672154f1ad8e0c49ec04655e91de) )
-	ROM_LOAD( "dt-17.256", 0x50000, 0x08000, CRC(3bbcff0d) SHA1(a8f7aa56ff49ed6b29240c3504d6c9945944953b) )
-	ROM_LOAD( "dt-21.512", 0x60000, 0x10000, CRC(1c5f682d) SHA1(4b7022cce930a9e9a0087c91e8344269fe7ed889) )
-	ROM_LOAD( "dt-22.256", 0x70000, 0x08000, CRC(c1876a5f) SHA1(66122ce765723765e20036bd4d461a210c8b94d3) )
+	ROM_LOAD( "dx00.3d",  0x00000, 0x08000, CRC(f01ef985) SHA1(d5b823bd7c0efcf3137f8643c5d99a260bed5675) )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dt-08.512", 0x00000, 0x08000, CRC(aec483f5) SHA1(1d6de823ab0eeb9c89e9c227428ff278663627f3) )
-	ROM_CONTINUE(          0x10000, 0x08000 )
-	ROM_LOAD( "dt-09.256", 0x08000, 0x08000, CRC(446f0ce0) SHA1(072b88d6de5aa0ed6b1d60c266bcf170dea927d5) )
-	ROM_LOAD( "dt-06.512", 0x20000, 0x08000, CRC(3fe1527f) SHA1(b8df4bef2b1a879b65214025fc3b5998ef5c8886) )
-	ROM_CONTINUE(          0x30000, 0x08000 )
-	ROM_LOAD( "dt-07.256", 0x28000, 0x08000, CRC(61f9bce5) SHA1(ef8a5f5e4c66a143304bcab50ca87579f1507864) )
-	ROM_LOAD( "dt-12.512", 0x40000, 0x08000, CRC(1a72ca8d) SHA1(f412758452cb3417e85c355ccb8794fde7edf1cc) )
-	ROM_CONTINUE(          0x50000, 0x08000 )
-	ROM_LOAD( "dt-13.256", 0x48000, 0x08000, CRC(ccb81aec) SHA1(56e524ed4373b7bd1074a0d22ff75ede379f1696) )
-	ROM_LOAD( "dt-10.512", 0x60000, 0x08000, CRC(cfcfc9ed) SHA1(57f43d638cf864d68420f0203740be7bda9da5ca) )
-	ROM_CONTINUE(          0x70000, 0x08000 )
-	ROM_LOAD( "dt-11.256", 0x68000, 0x08000, CRC(53e9cf17) SHA1(8cbb45154a60f42f1b1e7299b12d2e92fc194df8) )
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites (3bpp) */
+	ROM_LOAD( "dx14.15k",  0x00000, 0x10000, CRC(80f07915) SHA1(ea100f12ef3a68110af911fa9beeb73b388f069d) )
+    /* 0x10000-0x1ffff empy */
+	ROM_LOAD( "dx13.13k",  0x20000, 0x10000, CRC(d32c02e7) SHA1(d0518ec31e9e3f7b4e76fba5d7c05c33c61a9c72) )
+    /* 0x30000-0x3ffff empy */
+	ROM_LOAD( "dx12.10k",  0x40000, 0x10000, CRC(ac78b76b) SHA1(c2be347fd950894401123ada8b27bfcfce53e66b) )
+    /* 0x50000-0x5ffff empy */
+    /* 0x60000-0x7ffff empy (no 4th plane) */
 
-	ROM_REGION( 1024, "proms", 0 )
-	ROM_LOAD( "mb7122e.10b", 0x00000,  0x400,  CRC(dcbfec4e) SHA1(a375caef4575746870e285d90ba991ea7daefad6) )    /* Priority (Not yet used) */
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles (3bpp) */
+	ROM_LOAD( "dx06.5f",  0x00000, 0x10000, CRC(b6fb208c) SHA1(027d33f0b5feb6f0433134213cfcef96790eaace) )
+	ROM_LOAD( "dx07.7f",  0x10000, 0x10000, CRC(ee3e1817) SHA1(013496976a9ffacf1587b3a6fc0f548becb1ab0e) )
+	ROM_LOAD( "dx08.8f",  0x20000, 0x10000, CRC(705900fe) SHA1(53b9d09f9780a3bf3545bc27a2855ebee3884124) )
+	ROM_LOAD( "dx09.10f", 0x30000, 0x10000, CRC(3192571d) SHA1(240c6c099f1e6edbf0be7d5a4ec396b056c9f70f) )
+	ROM_LOAD( "dx10.12f",  0x40000, 0x10000, CRC(3ef77a32) SHA1(97b97c35a6ca994d2e7a6e7a63101eda9709bcb1) )
+	ROM_LOAD( "dx11.13f",  0x50000, 0x10000, CRC(9cf3d5b8) SHA1(df4974f8412ab1cf65871b8e4e3dbee478bf4d21) )
 ROM_END
 
-ROM_START( makyosen )
-	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD( "ds00",      0x08000, 0x08000, CRC(33bb16fe) SHA1(5d3873b66e0d08b35d56a8b508c774b27368a100) )
-	ROM_LOAD( "dt-01.512", 0x10000, 0x10000, CRC(c39bb877) SHA1(9beb59ba19f38417c5d4d36e8f3c41f2b017d2d6) )
-	ROM_LOAD( "ds02",      0x20000, 0x10000, CRC(925307a4) SHA1(1e8b8eb21df1a11b14c981b343b34c6cc3676517) )
-	ROM_LOAD( "ds03",      0x30000, 0x10000, CRC(9c0fcbf6) SHA1(bfe42b5277fea111840a9f59b2cb8dfe44444029) )
+/* Different IC positions to World set? */
+ROM_START( csilverj )
+	ROM_REGION( 0x48000, "maincpu", 0 )
+	ROM_LOAD( "dx03-3.a4", 0x08000, 0x08000, CRC(02dd8cfc) SHA1(f29c0d9dd03e8c52672c0f3dbee44a93c5b4261d) )
+	ROM_LOAD( "dx01.a2", 0x10000, 0x10000, CRC(570fb50c) SHA1(3002f53182834a060fc282be1bc5767906e19ba2) )
+	ROM_LOAD( "dx02.a3", 0x20000, 0x10000, CRC(58625890) SHA1(503a969085f6dcb16687217c48136ea22d07c89f) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "ds05",      0x8000, 0x8000, CRC(e6e28ca9) SHA1(3b1f8219331db1910bfb428f8964f8fc1063df6f) )
+	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
+	ROM_LOAD( "dx04-1.a5", 0x0000, 0x10000,  CRC(29432691) SHA1(a76ecd27d217c66a0e43f93e29efe83c657925c3) )
+
+	ROM_REGION( 0x18000, "audiocpu", 0 )
+	ROM_LOAD( "dx05.a6", 0x10000, 0x08000,  CRC(eb32cf25) SHA1(9390c88033259c65eb15320e31f5d696970987cc) )
+	ROM_CONTINUE(   0x08000, 0x08000 )
 
 	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "ds-a.1b", 0x0000, 0x1000, BAD_DUMP CRC(8bb25edc) SHA1(7073b06747e55e4ac5b60b68a64ffbc7e18cb593) )
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "ds14",      0x00000, 0x08000, CRC(00cbe9c8) SHA1(de7b640de8fd54ee79194945c96d5768d09f483b) )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dt-19.512", 0x00000, 0x10000, CRC(da2abe4b) SHA1(d53e4769671f3fd437edcff7e7ea05156bbcb45d) )
-	ROM_LOAD( "ds20",      0x10000, 0x08000, CRC(0eef7f56) SHA1(05c23aa6a598478cd4822634cff96055c585e9d2) )
-	ROM_LOAD( "dt-16.512", 0x20000, 0x10000, CRC(e9955d8f) SHA1(aeef5e18f9d36c1bab3000e95205ce1b18cfbf0b) )
-	ROM_LOAD( "ds18",      0x30000, 0x08000, CRC(2b2d1468) SHA1(a144ac1b367e1fec876156230e9ab1c99416962e) )
-	ROM_LOAD( "dt-15.512", 0x40000, 0x10000, CRC(a54b2eb6) SHA1(25cb61f67135672154f1ad8e0c49ec04655e91de) )
-	ROM_LOAD( "ds17",      0x50000, 0x08000, CRC(75ae349a) SHA1(15755a28925d5ed37fab4bd988716fcc5d20c290) )
-	ROM_LOAD( "dt-21.512", 0x60000, 0x10000, CRC(1c5f682d) SHA1(4b7022cce930a9e9a0087c91e8344269fe7ed889) )
-	ROM_LOAD( "ds22",      0x70000, 0x08000, CRC(c8ffb148) SHA1(ae1a8b3cd1f5e423dc1a3c7d05f9fe7c689432e3) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dt-08.512", 0x00000, 0x08000, CRC(aec483f5) SHA1(1d6de823ab0eeb9c89e9c227428ff278663627f3) )
-	ROM_CONTINUE(          0x10000, 0x08000 )
-	ROM_LOAD( "dt-09.256", 0x08000, 0x08000, CRC(446f0ce0) SHA1(072b88d6de5aa0ed6b1d60c266bcf170dea927d5) )
-	ROM_LOAD( "dt-06.512", 0x20000, 0x08000, CRC(3fe1527f) SHA1(b8df4bef2b1a879b65214025fc3b5998ef5c8886) )
-	ROM_CONTINUE(          0x30000, 0x08000 )
-	ROM_LOAD( "dt-07.256", 0x28000, 0x08000, CRC(61f9bce5) SHA1(ef8a5f5e4c66a143304bcab50ca87579f1507864) )
-	ROM_LOAD( "dt-12.512", 0x40000, 0x08000, CRC(1a72ca8d) SHA1(f412758452cb3417e85c355ccb8794fde7edf1cc) )
-	ROM_CONTINUE(          0x50000, 0x08000 )
-	ROM_LOAD( "dt-13.256", 0x48000, 0x08000, CRC(ccb81aec) SHA1(56e524ed4373b7bd1074a0d22ff75ede379f1696) )
-	ROM_LOAD( "dt-10.512", 0x60000, 0x08000, CRC(cfcfc9ed) SHA1(57f43d638cf864d68420f0203740be7bda9da5ca) )
-	ROM_CONTINUE(          0x70000, 0x08000 )
-	ROM_LOAD( "dt-11.256", 0x68000, 0x08000, CRC(53e9cf17) SHA1(8cbb45154a60f42f1b1e7299b12d2e92fc194df8) )
+	ROM_LOAD( "dx00.a1",  0x00000, 0x08000, CRC(f01ef985) SHA1(d5b823bd7c0efcf3137f8643c5d99a260bed5675) )
 
-	ROM_REGION( 1024, "proms", 0 )
-	ROM_LOAD( "mb7122e.10b", 0x00000,  0x400,  CRC(dcbfec4e) SHA1(a375caef4575746870e285d90ba991ea7daefad6) )    /* Priority (Not yet used) */
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites (3bpp) */
+	ROM_LOAD( "dx14.b5",  0x00000, 0x10000, CRC(80f07915) SHA1(ea100f12ef3a68110af911fa9beeb73b388f069d) )
+    /* 0x10000-0x1ffff empy */
+	ROM_LOAD( "dx13.b4",  0x20000, 0x10000, CRC(d32c02e7) SHA1(d0518ec31e9e3f7b4e76fba5d7c05c33c61a9c72) )
+    /* 0x30000-0x3ffff empy */
+	ROM_LOAD( "dx12.b3",  0x40000, 0x10000, CRC(ac78b76b) SHA1(c2be347fd950894401123ada8b27bfcfce53e66b) )
+    /* 0x50000-0x5ffff empy */
+    /* 0x60000-0x7ffff empy (no 4th plane) */
 
-	ROM_REGION( 0x0600, "plds", 0 )
-	ROM_LOAD( "pal16r4nc.10u", 0x0000, 0x0104, NO_DUMP ) /* PAL is read protected */
-	ROM_LOAD( "pal16r4nc.11g", 0x0200, 0x0104, NO_DUMP ) /* PAL is read protected */
-	ROM_LOAD( "pal16r4nc.1s",  0x0400, 0x0104, NO_DUMP ) /* PAL is read protected */
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles (3bpp) */
+	ROM_LOAD( "dx06.a7",  0x00000, 0x10000, CRC(b6fb208c) SHA1(027d33f0b5feb6f0433134213cfcef96790eaace) )
+	ROM_LOAD( "dx07.a8",  0x10000, 0x10000, CRC(ee3e1817) SHA1(013496976a9ffacf1587b3a6fc0f548becb1ab0e) )
+	ROM_LOAD( "dx08.a9",  0x20000, 0x10000, CRC(705900fe) SHA1(53b9d09f9780a3bf3545bc27a2855ebee3884124) )
+	ROM_LOAD( "dx09.a10", 0x30000, 0x10000, CRC(3192571d) SHA1(240c6c099f1e6edbf0be7d5a4ec396b056c9f70f) )
+	ROM_LOAD( "dx10.b1",  0x40000, 0x10000, CRC(3ef77a32) SHA1(97b97c35a6ca994d2e7a6e7a63101eda9709bcb1) )
+	ROM_LOAD( "dx11.b2",  0x50000, 0x10000, CRC(9cf3d5b8) SHA1(df4974f8412ab1cf65871b8e4e3dbee478bf4d21) )
 ROM_END
 
 ROM_START( oscar )
@@ -3140,357 +3409,140 @@
 	ROM_LOAD( "du-13.bin", 0x00000,  0x200,  CRC(bea1f87e) SHA1(f5215992e4b53c9cd4c7e0b20ff5cfdce3ab6d02) )    /* Priority (Not yet used) */
 ROM_END
 
-ROM_START( lastmisn )
-	ROM_REGION( 0x20000, "maincpu", 0 )
-	ROM_LOAD( "dl03-6.13h",  0x08000, 0x08000, CRC(47751a5e) SHA1(190970a6eb849781e8853f2bed7b34ac44e569ca) ) /* Rev 6 roms */
-	ROM_LOAD( "lm_dl04.7h",  0x10000, 0x10000, CRC(7dea1552) SHA1(920684413e2ba4313111e79821c5714977b26b1a) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "lm_dl02.18h", 0x0000, 0x10000, CRC(ec9b5daf) SHA1(86d47bad123676abc82dd7c92943878c54c33075) )
-
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
-	ROM_CONTINUE(             0x06000, 0x2000 )
-	ROM_CONTINUE(              0x04000, 0x2000 )
-	ROM_CONTINUE(              0x02000, 0x2000 )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
-	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
-	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
-	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
-	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
-	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
-	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
-
-	ROM_REGION( 256, "proms", 0 )
-	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
-ROM_END
-
-ROM_START( lastmisno )
-	ROM_REGION( 0x20000, "maincpu", 0 )
-	ROM_LOAD( "lm_dl03.13h", 0x08000, 0x08000, CRC(357f5f6b) SHA1(a114aac50db62a6bcb943681e517ad7c88ec47f4) ) /* Rev 5 roms */
-	ROM_LOAD( "lm_dl04.7h",  0x10000, 0x10000, CRC(7dea1552) SHA1(920684413e2ba4313111e79821c5714977b26b1a) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "lm_dl02.18h", 0x0000, 0x10000, CRC(ec9b5daf) SHA1(86d47bad123676abc82dd7c92943878c54c33075) )
-
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
-	ROM_CONTINUE(             0x06000, 0x2000 )
-	ROM_CONTINUE(              0x04000, 0x2000 )
-	ROM_CONTINUE(              0x02000, 0x2000 )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
-	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
-	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
-	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
-	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
-	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
-	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
-
-	ROM_REGION( 256, "proms", 0 )
-	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
-ROM_END
-
-ROM_START( lastmisnj )
-	ROM_REGION( 0x20000, "maincpu", 0 )
-	ROM_LOAD( "dl03-.13h",   0x08000, 0x08000, CRC(4be5e7e1) SHA1(9f943658663da31947cebdcbcb5f4e2be0714c06) )
-	ROM_LOAD( "dl04-.7h",    0x10000, 0x10000, CRC(f026adf9) SHA1(4ccd0e714a6eb7cee388c93beee2d5510407c961) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "dl02-.18h",   0x0000, 0x10000, CRC(d0de2b5d) SHA1(e0bb34c2a2ef6fc6f05ab9a98bd23a39004c0c05) )
-
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dl05-.5h",    0x8000, 0x8000, CRC(1a5df8c0) SHA1(83d36b1d5fb87f50c44f3110804d6bbdbbc0da99) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dl01-.2a",    0x00000, 0x2000, CRC(f3787a5d) SHA1(3701df42cb2aca951963703e72c6c7b272eed82b) )
-	ROM_CONTINUE(             0x06000, 0x2000 )
-	ROM_CONTINUE(              0x04000, 0x2000 )
-	ROM_CONTINUE(              0x02000, 0x2000 )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dl11-.13f",   0x00000, 0x08000, CRC(36579d3b) SHA1(8edf952dafcd5bc66e08074687f0bec809fd4c2f) )
-	ROM_LOAD( "dl12-.9f",    0x20000, 0x08000, CRC(2ba6737e) SHA1(c5e4c27726bf14e9cd60d62e2f17ea5be8093c37) )
-	ROM_LOAD( "dl13-.8f",    0x40000, 0x08000, CRC(39a7dc93) SHA1(3b7968fd06ac0379525c1d3e73f8bbe18ea36439) )
-	ROM_LOAD( "dl10-.16f",   0x60000, 0x08000, CRC(fe275ea8) SHA1(2f089f96583235f1f5226ef2a64b430d84efbeee) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dl09-.12k",   0x00000, 0x10000, CRC(6a5a0c5d) SHA1(0106cf693c284be5faf96e56b651fab92a410915) )
-	ROM_LOAD( "dl08-.14k",   0x20000, 0x10000, CRC(3b38cfce) SHA1(d6829bed6916fb301c08031bd466ee4dcc05b275) )
-	ROM_LOAD( "dl07-.15k",   0x40000, 0x10000, CRC(1b60604d) SHA1(1ee15cfdac87f7eeb92050766293b894cfad1466) )
-	ROM_LOAD( "dl06-.17k",   0x60000, 0x10000, CRC(c43c26a7) SHA1(896e278935b100edc12cd970469f2e8293eb96cc) )
-
-	ROM_REGION( 256, "proms", 0 )
-	ROM_LOAD( "dl-14.9c",    0x00000,  0x100,  CRC(2e55aa12) SHA1(c0f2b9649467eb9d2c1e47589b5990f5c5e8cc93) )    /* Priority (Not yet used) */
-ROM_END
-
-ROM_START( shackled )
-	ROM_REGION( 0x48000, "maincpu", 0 )
-	ROM_LOAD( "dk-02.rom", 0x08000, 0x08000, CRC(87f8fa85) SHA1(1cb93a60eefdb453a3cc6ec9c5cc2e367fb8aeb0) )
-	ROM_LOAD( "dk-06.rom", 0x10000, 0x10000, CRC(69ad62d1) SHA1(1aa23b12ab4f1908cddd25f091e1f9bd70a5113c) )
-	ROM_LOAD( "dk-05.rom", 0x20000, 0x10000, CRC(598dd128) SHA1(10843c5352eef03c8675df6abaf23c9c9c795aa3) )
-	ROM_LOAD( "dk-04.rom", 0x30000, 0x10000, CRC(36d305d4) SHA1(17586c316aff405cf20c1467d69c98fa2a3c2630) )
-	ROM_LOAD( "dk-03.rom", 0x40000, 0x08000, CRC(6fd90fd1) SHA1(2f8db17e5545c82d243a7e23e7bda2c2a9101360) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "dk-01.rom", 0x00000, 0x10000, CRC(71fe3bda) SHA1(959cce01362b2c670c2e15b03a78a1ff9cea4ee9) )
-
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dk-07.rom", 0x08000, 0x08000, CRC(887e4bcc) SHA1(6427396080e9cd8647adff47c8ed04593a14268c) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dk-00.rom", 0x00000, 0x08000, CRC(69b975aa) SHA1(38cb96768c79ff1aa1b4b190e08ec9155baf698a) )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dk-12.rom", 0x00000, 0x10000, CRC(615c2371) SHA1(30b25dc27d34646d886a465c77622eaa894d83c3) )
-	ROM_LOAD( "dk-13.rom", 0x10000, 0x10000, CRC(479aa503) SHA1(1167f0d15439c95a1094f81855203e863ce0488d) )
-	ROM_LOAD( "dk-14.rom", 0x20000, 0x10000, CRC(cdc24246) SHA1(1a4189bc2b1fa99740dd7921608159936ba3bd07) )
-	ROM_LOAD( "dk-15.rom", 0x30000, 0x10000, CRC(88db811b) SHA1(7d3c4a80925f323efb589798b4a341d1a2ca95f9) )
-	ROM_LOAD( "dk-16.rom", 0x40000, 0x10000, CRC(061a76bd) SHA1(5bcb513e48bed9b7c4207d94531be691a85e295d) )
-	ROM_LOAD( "dk-17.rom", 0x50000, 0x10000, CRC(a6c5d8af) SHA1(58f3fece9a5ef8b39090a2f39610381b8e7cdbf7) )
-	ROM_LOAD( "dk-18.rom", 0x60000, 0x10000, CRC(4d466757) SHA1(701d79bebbba4f266e19080d16ff2f93ffa94287) )
-	ROM_LOAD( "dk-19.rom", 0x70000, 0x10000, CRC(1911e83e) SHA1(174e9db3f2211ecbbb93c6bda8f6185dbfdbc818) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dk-11.rom", 0x00000, 0x10000, CRC(5cf5719f) SHA1(8c7582ac19010421ec748391a193aa18e51b981f) )
-	ROM_LOAD( "dk-10.rom", 0x20000, 0x10000, CRC(408e6d08) SHA1(28cb76792e5f84bd101a91cb82597a5939804f84) )
-	ROM_LOAD( "dk-09.rom", 0x40000, 0x10000, CRC(c1557fac) SHA1(7d39ec793113a48baf45c2ea07abb07e2e48985a) )
-	ROM_LOAD( "dk-08.rom", 0x60000, 0x10000, CRC(5e54e9f5) SHA1(1ab41a3bde1f2c2be670e89cf402be28001c17d1) )
-ROM_END
-
-ROM_START( breywood )
-	ROM_REGION( 0x48000, "maincpu", 0 )
-	ROM_LOAD( "7.bin", 0x08000, 0x08000, CRC(c19856b9) SHA1(766994703bb59879c311675353d7231ad27c7c16) )
-	ROM_LOAD( "3.bin", 0x10000, 0x10000, CRC(2860ea02) SHA1(7ac090c3ae9d71baa6227ec9555f1c9f2d25ea0d) )
-	ROM_LOAD( "4.bin", 0x20000, 0x10000, CRC(0fdd915e) SHA1(262df956dfc727c710ade28af7f33fddaafd7ee2) )
-	ROM_LOAD( "5.bin", 0x30000, 0x10000, CRC(71036579) SHA1(c58ff3222b5bcd75d58c5f282554e92103e80916) )
-	ROM_LOAD( "6.bin", 0x40000, 0x08000, CRC(308f4893) SHA1(539c138ff01c5718cc8a982482b989468d532699) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "8.bin", 0x0000, 0x10000,  CRC(3d9fb623) SHA1(6e5eaad9bb0a432e2da5da5b18a2ed36617bdde2) )
-
-	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "2.bin", 0x8000, 0x8000,  CRC(4a471c38) SHA1(963ed7b6afeefdfc2cf0d65b0998f973330e6495) )
-
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "1.bin",  0x00000, 0x08000, CRC(815a891a) SHA1(e557d6a35821a8589d9e3df0f42131b58b08c8ca) )
-
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "20.bin", 0x00000, 0x10000, CRC(2b7634f2) SHA1(56d963d4960d9b3e888c8107340763e176adfa9b) )
-	ROM_LOAD( "19.bin", 0x10000, 0x10000, CRC(4530a952) SHA1(99251a21347815cba465669e18df31262bcdaba1) )
-	ROM_LOAD( "18.bin", 0x20000, 0x10000, CRC(87c28833) SHA1(3f1a294065326389d304e540bc880844c6c7cb06) )
-	ROM_LOAD( "17.bin", 0x30000, 0x10000, CRC(bfb43a4d) SHA1(56092935147a3b643a9b39eb7cfc067a764644c5) )
-	ROM_LOAD( "16.bin", 0x40000, 0x10000, CRC(f9848cc4) SHA1(6d8e77b67ce4d418defba6f6979632f31d2307c6) )
-	ROM_LOAD( "15.bin", 0x50000, 0x10000, CRC(baa3d218) SHA1(3c31df23cc871cffd9a4dafae106e4a98f5af848) )
-	ROM_LOAD( "14.bin", 0x60000, 0x10000, CRC(12afe533) SHA1(6df3471c16a714d118717da549a7523aa388ddd3) )
-	ROM_LOAD( "13.bin", 0x70000, 0x10000, CRC(03373755) SHA1(d2541dd957803168f246d96b7cd74eae7fd43188) )
-
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "9.bin",  0x00000, 0x10000, CRC(067e2a43) SHA1(f1da7455aab21f94ed25a93b0ebfde69baa475d1) )
-	ROM_LOAD( "10.bin", 0x20000, 0x10000, CRC(c19733aa) SHA1(3dfcfd33c5c4f792bb941ac933301c03ddd72b03) )
-	ROM_LOAD( "11.bin", 0x40000, 0x10000, CRC(e37d5dbe) SHA1(ff79b4f6d8b0a3061e78d15480df0155650f347f) )
-	ROM_LOAD( "12.bin", 0x60000, 0x10000, CRC(beee880f) SHA1(9a818a75cbec425a13f629bda6d50aa341aa1896) )
-ROM_END
-
-/*
-Main Compoennts
----------------
-
-Top board (DATA EAST DE-0250-3):
-2x MC68B09EP (18e,19e)(main)
-1x RP65C02A (3f)(sound)
-1x YM3812 (1e)(sound)
-1x YM2203 (1f)(sound)
-2x Y30148 (1j,2j)(sound)
-1x OKI M5205 (3j)(sound)
-1x NEC PC3403C (1j)(sound)
-1x C4558C (2j)(sound)
-1x oscillator 8.000 (x1)
-1x ID8751H (read protected)
-
-Lower board (DATA EAST DE-0251-2):
-1x DECO TC15G032AY-0013-8644a-DSPC10 (square component, with 135 pass-through pins)(14h)
-1x DECO VSC30-M60348-6102 (DIL40)(9a)
-1x DECO HMC20-M60232-6902 (DIL28)(14a)
-1x oscillator 12.000 (x1)
-
-ROMs
-----
-
-Top board (DATA EAST DE-0250-3):
-2x MBM27256 (00,03)
-10x MBM27C512 (01,02,04,05,06,07,08,09,10,11)
-1x MB7122 (DIL18) (15)
-
-Lower board (DATA EAST DE-0251-2):
-3x MBM27C512
-
-Notes
------
-
-Top board (DATA EAST DE-0250-3):
-1x JAMMA edge connector
-2x 25x2 legs connectors to lower board (cn1,cn2)
-1x trimmer (volume)
-2x 8 switches dip (7k,16k)
-
-Lower board (DATA EAST DE-0251-2):
-2x 25x2 legs connectors to top board (cn1,cn2)
-
-*/
-
-ROM_START( csilver )
-	ROM_REGION( 0x48000, "maincpu", 0 )
-	ROM_LOAD( "dx03-12.18d", 0x08000, 0x08000, CRC(2d926e7c) SHA1(cf38e92904edb1870b0a4965f9049d67efe8cf6a) )
-	ROM_LOAD( "dx01.12d", 0x10000, 0x10000, CRC(570fb50c) SHA1(3002f53182834a060fc282be1bc5767906e19ba2) )
-	ROM_LOAD( "dx02.13d", 0x20000, 0x10000, CRC(58625890) SHA1(503a969085f6dcb16687217c48136ea22d07c89f) )
-
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "dx04-1.19d", 0x0000, 0x10000,  CRC(29432691) SHA1(a76ecd27d217c66a0e43f93e29efe83c657925c3) )
+ROM_START( srdarwin )
+	ROM_REGION( 0x28000, "maincpu", 0 )
+	ROM_LOAD( "dy01-e.b14", 0x20000, 0x08000, CRC(176e9299) SHA1(20cd44ab610e384ab4f0172054c9adc432b12e9c) )
+	ROM_CONTINUE(           0x08000, 0x08000 )
+	ROM_LOAD( "dy00.b16", 0x10000, 0x10000, CRC(2bf6b461) SHA1(435d922c7b9df7f2b2f774346caed81d330be8a0) )
 
-	ROM_REGION( 0x18000, "audiocpu", 0 )
-	ROM_LOAD( "dx05.3f", 0x10000, 0x08000,  CRC(eb32cf25) SHA1(9390c88033259c65eb15320e31f5d696970987cc) )
-	ROM_CONTINUE(   0x08000, 0x08000 )
+	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
+	ROM_LOAD( "dy04.d7", 0x8000, 0x8000, CRC(2ae3591c) SHA1(f21b06d84e2c3d3895be0812024641fd006e45cf) )
 
 	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP ) // dx-8.19a ?
+	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dx00.3d",  0x00000, 0x08000, CRC(f01ef985) SHA1(d5b823bd7c0efcf3137f8643c5d99a260bed5675) )
+	ROM_LOAD( "dy05.b6", 0x00000, 0x4000, CRC(8780e8a3) SHA1(03ea91fdc5aba8e139201604fb3bf9b69f71f056) )
 
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites (3bpp) */
-	ROM_LOAD( "dx14.15k",  0x00000, 0x10000, CRC(80f07915) SHA1(ea100f12ef3a68110af911fa9beeb73b388f069d) )
-    /* 0x10000-0x1ffff empy */
-	ROM_LOAD( "dx13.13k",  0x20000, 0x10000, CRC(d32c02e7) SHA1(d0518ec31e9e3f7b4e76fba5d7c05c33c61a9c72) )
-    /* 0x30000-0x3ffff empy */
-	ROM_LOAD( "dx12.10k",  0x40000, 0x10000, CRC(ac78b76b) SHA1(c2be347fd950894401123ada8b27bfcfce53e66b) )
-    /* 0x50000-0x5ffff empy */
-    /* 0x60000-0x7ffff empy (no 4th plane) */
+	ROM_REGION( 0x30000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dy07.h16", 0x00000, 0x8000, CRC(97eaba60) SHA1(e3252b67bad7babcf4ece39f46ae4aeb950eb92b) )
+	ROM_LOAD( "dy06.h14", 0x08000, 0x8000, CRC(c279541b) SHA1(eb3737413499d07b6c2af99a95b27b2590e670c5) )
+	ROM_LOAD( "dy09.k13", 0x10000, 0x8000, CRC(d30d1745) SHA1(647b6121ab6fa812368da45e1295cc41f73be89d) )
+	ROM_LOAD( "dy08.k11", 0x18000, 0x8000, CRC(71d645fd) SHA1(a74a9b9697fc39b4e675e732a9d7d82976cc95dd) )
+	ROM_LOAD( "dy11.k16", 0x20000, 0x8000, CRC(fd9ccc5b) SHA1(b38c44c01acdc455d4192e4c8be1d68d9eb0c7b6) )
+	ROM_LOAD( "dy10.k14", 0x28000, 0x8000, CRC(88770ab8) SHA1(0a4a807a8d3b0653864bd984872d5567836f8cf8) )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles (3bpp) */
-	ROM_LOAD( "dx06.5f",  0x00000, 0x10000, CRC(b6fb208c) SHA1(027d33f0b5feb6f0433134213cfcef96790eaace) )
-	ROM_LOAD( "dx07.7f",  0x10000, 0x10000, CRC(ee3e1817) SHA1(013496976a9ffacf1587b3a6fc0f548becb1ab0e) )
-	ROM_LOAD( "dx08.8f",  0x20000, 0x10000, CRC(705900fe) SHA1(53b9d09f9780a3bf3545bc27a2855ebee3884124) )
-	ROM_LOAD( "dx09.10f", 0x30000, 0x10000, CRC(3192571d) SHA1(240c6c099f1e6edbf0be7d5a4ec396b056c9f70f) )
-	ROM_LOAD( "dx10.12f",  0x40000, 0x10000, CRC(3ef77a32) SHA1(97b97c35a6ca994d2e7a6e7a63101eda9709bcb1) )
-	ROM_LOAD( "dx11.13f",  0x50000, 0x10000, CRC(9cf3d5b8) SHA1(df4974f8412ab1cf65871b8e4e3dbee478bf4d21) )
-ROM_END
+	ROM_REGION( 0x40000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dy03.b4",  0x00000, 0x4000, CRC(44f2a4f9) SHA1(97368dd112451cd630f2fa5ba54679e84e7d4d97) )
+	ROM_CONTINUE(         0x10000, 0x4000 )
+	ROM_CONTINUE(         0x20000, 0x4000 )
+	ROM_CONTINUE(         0x30000, 0x4000 )
+	ROM_LOAD( "dy02.b5",  0x08000, 0x4000, CRC(522d9a9e) SHA1(248274ed6df604357cad386fcf0521b26810aa0e) )
+	ROM_CONTINUE(         0x18000, 0x4000 )
+	ROM_CONTINUE(         0x28000, 0x4000 )
+	ROM_CONTINUE(         0x38000, 0x4000 )
 
-/* Different IC positions to World set? */
-ROM_START( csilverj )
-	ROM_REGION( 0x48000, "maincpu", 0 )
-	ROM_LOAD( "dx03-3.a4", 0x08000, 0x08000, CRC(02dd8cfc) SHA1(f29c0d9dd03e8c52672c0f3dbee44a93c5b4261d) )
-	ROM_LOAD( "dx01.a2", 0x10000, 0x10000, CRC(570fb50c) SHA1(3002f53182834a060fc282be1bc5767906e19ba2) )
-	ROM_LOAD( "dx02.a3", 0x20000, 0x10000, CRC(58625890) SHA1(503a969085f6dcb16687217c48136ea22d07c89f) )
+	ROM_REGION( 256, "proms", 0 )
+	ROM_LOAD( "dy12.f4",  0x00000,  0x100,  CRC(ebfaaed9) SHA1(5723dbfa3eb3fc4df8c8975b320a5c49848309d8) )    /* Priority (Not yet used) */
+ROM_END
 
-	ROM_REGION( 0x10000, "sub", 0 )    /* CPU 2, 1st 16k is empty */
-	ROM_LOAD( "dx04-1.a5", 0x0000, 0x10000,  CRC(29432691) SHA1(a76ecd27d217c66a0e43f93e29efe83c657925c3) )
+ROM_START( srdarwinj )
+	ROM_REGION( 0x28000, "maincpu", 0 )
+	ROM_LOAD( "dy_01.rom", 0x20000, 0x08000, CRC(1eeee4ff) SHA1(89a70de8bd61c671582b11773ce69b2edcd9c2f8) )
+	ROM_CONTINUE(          0x08000, 0x08000 )
+	ROM_LOAD( "dy00.b16", 0x10000, 0x10000, CRC(2bf6b461) SHA1(435d922c7b9df7f2b2f774346caed81d330be8a0) )
 
-	ROM_REGION( 0x18000, "audiocpu", 0 )
-	ROM_LOAD( "dx05.a6", 0x10000, 0x08000,  CRC(eb32cf25) SHA1(9390c88033259c65eb15320e31f5d696970987cc) )
-	ROM_CONTINUE(   0x08000, 0x08000 )
+	ROM_REGION( 2*0x10000, "audiocpu", 0 )    /* 64K for sound CPU + 64k for decrypted opcodes */
+	ROM_LOAD( "dy04.d7", 0x8000, 0x8000, CRC(2ae3591c) SHA1(f21b06d84e2c3d3895be0812024641fd006e45cf) )
 
 	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
 	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dx00.a1",  0x00000, 0x08000, CRC(f01ef985) SHA1(d5b823bd7c0efcf3137f8643c5d99a260bed5675) )
+	ROM_LOAD( "dy05.b6", 0x00000, 0x4000, CRC(8780e8a3) SHA1(03ea91fdc5aba8e139201604fb3bf9b69f71f056) )
 
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites (3bpp) */
-	ROM_LOAD( "dx14.b5",  0x00000, 0x10000, CRC(80f07915) SHA1(ea100f12ef3a68110af911fa9beeb73b388f069d) )
-    /* 0x10000-0x1ffff empy */
-	ROM_LOAD( "dx13.b4",  0x20000, 0x10000, CRC(d32c02e7) SHA1(d0518ec31e9e3f7b4e76fba5d7c05c33c61a9c72) )
-    /* 0x30000-0x3ffff empy */
-	ROM_LOAD( "dx12.b3",  0x40000, 0x10000, CRC(ac78b76b) SHA1(c2be347fd950894401123ada8b27bfcfce53e66b) )
-    /* 0x50000-0x5ffff empy */
-    /* 0x60000-0x7ffff empy (no 4th plane) */
+	ROM_REGION( 0x30000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "dy07.h16", 0x00000, 0x8000, CRC(97eaba60) SHA1(e3252b67bad7babcf4ece39f46ae4aeb950eb92b) )
+	ROM_LOAD( "dy06.h14", 0x08000, 0x8000, CRC(c279541b) SHA1(eb3737413499d07b6c2af99a95b27b2590e670c5) )
+	ROM_LOAD( "dy09.k13", 0x10000, 0x8000, CRC(d30d1745) SHA1(647b6121ab6fa812368da45e1295cc41f73be89d) )
+	ROM_LOAD( "dy08.k11", 0x18000, 0x8000, CRC(71d645fd) SHA1(a74a9b9697fc39b4e675e732a9d7d82976cc95dd) )
+	ROM_LOAD( "dy11.k16", 0x20000, 0x8000, CRC(fd9ccc5b) SHA1(b38c44c01acdc455d4192e4c8be1d68d9eb0c7b6) )
+	ROM_LOAD( "dy10.k14", 0x28000, 0x8000, CRC(88770ab8) SHA1(0a4a807a8d3b0653864bd984872d5567836f8cf8) )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles (3bpp) */
-	ROM_LOAD( "dx06.a7",  0x00000, 0x10000, CRC(b6fb208c) SHA1(027d33f0b5feb6f0433134213cfcef96790eaace) )
-	ROM_LOAD( "dx07.a8",  0x10000, 0x10000, CRC(ee3e1817) SHA1(013496976a9ffacf1587b3a6fc0f548becb1ab0e) )
-	ROM_LOAD( "dx08.a9",  0x20000, 0x10000, CRC(705900fe) SHA1(53b9d09f9780a3bf3545bc27a2855ebee3884124) )
-	ROM_LOAD( "dx09.a10", 0x30000, 0x10000, CRC(3192571d) SHA1(240c6c099f1e6edbf0be7d5a4ec396b056c9f70f) )
-	ROM_LOAD( "dx10.b1",  0x40000, 0x10000, CRC(3ef77a32) SHA1(97b97c35a6ca994d2e7a6e7a63101eda9709bcb1) )
-	ROM_LOAD( "dx11.b2",  0x50000, 0x10000, CRC(9cf3d5b8) SHA1(df4974f8412ab1cf65871b8e4e3dbee478bf4d21) )
+	ROM_REGION( 0x40000, "gfx3", 0 )    /* tiles */
+	ROM_LOAD( "dy03.b4",  0x00000, 0x4000, CRC(44f2a4f9) SHA1(97368dd112451cd630f2fa5ba54679e84e7d4d97) )
+	ROM_CONTINUE(         0x10000, 0x4000 )
+	ROM_CONTINUE(         0x20000, 0x4000 )
+	ROM_CONTINUE(         0x30000, 0x4000 )
+	ROM_LOAD( "dy02.b5",  0x08000, 0x4000, CRC(522d9a9e) SHA1(248274ed6df604357cad386fcf0521b26810aa0e) )
+	ROM_CONTINUE(         0x18000, 0x4000 )
+	ROM_CONTINUE(         0x28000, 0x4000 )
+	ROM_CONTINUE(         0x38000, 0x4000 )
+
+	ROM_REGION( 256, "proms", 0 )
+	ROM_LOAD( "dy12.f4",  0x00000,  0x100,  CRC(ebfaaed9) SHA1(5723dbfa3eb3fc4df8c8975b320a5c49848309d8) )    /* Priority (Not yet used) */
 ROM_END
 
-ROM_START( garyoret )
-	ROM_REGION( 0x50000, "maincpu", 0 )
-	ROM_LOAD( "dv00", 0x08000, 0x08000, CRC(cceaaf05) SHA1(b8f54638feab77d023e01ced947e1269f0d19fd8) )
-	ROM_LOAD( "dv01", 0x10000, 0x10000, CRC(c33fc18a) SHA1(0d9594b0e6c39aea5b9f15f6aa364b31604f1066) )
-	ROM_LOAD( "dv02", 0x20000, 0x10000, CRC(f9e26ce7) SHA1(8589594ebc7ae16942739382273a222dfa30b3b7) )
-	ROM_LOAD( "dv03", 0x30000, 0x10000, CRC(55d8d699) SHA1(da1519cd54d27cc406420ce0845e43f7228cfd4e) )
-	ROM_LOAD( "dv04", 0x40000, 0x10000, CRC(ed3d00ee) SHA1(6daa2ee509235ad03d3012a00382820279add620) )
+ROM_START( cobracom )
+	ROM_REGION( 0x30000, "maincpu", 0 )
+	ROM_LOAD( "el11-5.bin",  0x08000, 0x08000, CRC(af0a8b05) SHA1(096e4e7f2785a20bfaec14277413ce4e20e90214) )
+	ROM_LOAD( "el12-4.bin",  0x10000, 0x10000, CRC(7a44ef38) SHA1(d7dc277dce08f9d073290e100be4a7ca2e2b82cb) )
+	ROM_LOAD( "el13.bin",    0x20000, 0x10000, CRC(04505acb) SHA1(2220efb277884588859375dab9960f04f07273a7) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "dv05", 0x08000, 0x08000, CRC(c97c347f) SHA1(a1b22733dc15d524af97db3e608a82503a49b182) )
+	ROM_LOAD( "el10-4.bin",  0x8000,  0x8000,  CRC(edfad118) SHA1(10de8805472346fead62460a3fdc09ae26a4e0d5) )
 
-	ROM_REGION( 0x1000, "mcu", 0 )    /* ID8751H MCU */
-	ROM_LOAD( "id8751h.mcu", 0x0000, 0x1000, NO_DUMP )
+	ROM_REGION( 0x08000, "gfx1", 0 )	/* characters */
+	ROM_LOAD( "el14.bin",    0x00000, 0x08000, CRC(47246177) SHA1(51b025740dc03b04009ac97d8d110ab521894386) )
 
-	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
-	ROM_LOAD( "dv14", 0x00000, 0x08000, CRC(fb2bc581) SHA1(d597976c5ae586166c49051cc3de8cf0c2e5a5e1) )    /* Characters */
+	ROM_REGION( 0x80000, "gfx2", 0 )	/* sprites */
+	ROM_LOAD( "el00-4.bin",  0x00000, 0x10000, CRC(122da2a8) SHA1(ce72f16abf7e5449c7d044d4b827e8735c3be0ff) )
+	ROM_LOAD( "el01-4.bin",  0x20000, 0x10000, CRC(27bf705b) SHA1(196c35aaf3816d3eef4c2af6d146a90a48365d33) )
+	ROM_LOAD( "el02-4.bin",  0x40000, 0x10000, CRC(c86fede6) SHA1(97584fa19591651fcfb39d1b2b6306165e93554c) )
+	ROM_LOAD( "el03-4.bin",  0x60000, 0x10000, CRC(1d8a855b) SHA1(429261c200dddc62a330be8aea150b2037133188) )
 
-	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
-	ROM_LOAD( "dv22", 0x00000, 0x10000, CRC(cef0367e) SHA1(8beb3a6b91ec0a6ec052243c8f626a581d349f65) )
-	ROM_LOAD( "dv21", 0x10000, 0x08000, CRC(90042fb7) SHA1(f19bbf158c92030e8fddb5087b5b69b71956baf8) )
-	ROM_LOAD( "dv20", 0x20000, 0x10000, CRC(451a2d8c) SHA1(f4eea444b797d394edeb514ddc1c494fd7ccc2f2) )
-	ROM_LOAD( "dv19", 0x30000, 0x08000, CRC(14e1475b) SHA1(f0aec5b7b4be0da06a73ed382e7e851654e47e47) )
-	ROM_LOAD( "dv18", 0x40000, 0x10000, CRC(7043bead) SHA1(5d1be8b9cd56ae43d60406b05258d20de980096d) )
-	ROM_LOAD( "dv17", 0x50000, 0x08000, CRC(28f449d7) SHA1(cf1bc690b67910c42ad09531ab1d88461d00b944) )
-	ROM_LOAD( "dv16", 0x60000, 0x10000, CRC(37e4971e) SHA1(9442c315b7cdbcc046d9e6838cb793c1857174ed) )
-	ROM_LOAD( "dv15", 0x70000, 0x08000, CRC(ca41b6ac) SHA1(d7a9ef6c89741c1e8e17a668a9d39ea089f5c73f) )
+	ROM_REGION( 0x80000, "gfx3", 0 )	/* tiles 1 */
+	ROM_LOAD( "el05.bin",    0x00000, 0x10000, CRC(1c4f6033) SHA1(4a7dece911166d1ff5f41df6ec5140596206d8d4) )
+	ROM_LOAD( "el06.bin",    0x20000, 0x10000, CRC(d24ba794) SHA1(b34b7bbaab4ebdd81c87d363f087cc92e27e8d1c) )
+	ROM_LOAD( "el04.bin",    0x40000, 0x10000, CRC(d80a49ce) SHA1(1a92413b5ab53f80e44a954433e69ec5fe2c0aa6) )
+	ROM_LOAD( "el07.bin",    0x60000, 0x10000, CRC(6d771fc3) SHA1(f29979f3aa07bdb544fb0c1d773c5558b4533390) )
 
-	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles */
-	ROM_LOAD( "dv08", 0x00000, 0x08000, CRC(89c13e15) SHA1(6507e60de5cd78a5b46090e4825a44c2a23631d7) )
-	ROM_CONTINUE(     0x10000, 0x08000 )
-	ROM_LOAD( "dv09", 0x08000, 0x08000, CRC(6a345a23) SHA1(b86f81b9fe25acd833ca3e2cff6cfa853c02280a) )
-	ROM_CONTINUE(     0x18000, 0x08000 )
+	ROM_REGION( 0x80000, "gfx4", 0 )    /* tiles 2 */
+	ROM_LOAD( "el08.bin",    0x00000, 0x08000, CRC(cb0dcf4c) SHA1(e14853f83ee9ba5cbf2eb1e085fee4e65af3cc25) )
+	ROM_CONTINUE(            0x40000, 0x08000 )
+	ROM_LOAD( "el09.bin",    0x20000, 0x08000, CRC(1fae5be7) SHA1(be6e090b0b82648b385d9b6d11775f3ff40f0af3) )
+	ROM_CONTINUE(            0x60000, 0x08000 )
+ROM_END
 
-	ROM_LOAD( "dv06", 0x20000, 0x08000, CRC(1eb52a20) SHA1(46670ed973f794be9c2c7e6bf5d97db51211e9a9) )
-	ROM_CONTINUE(     0x30000, 0x08000 )
-	ROM_LOAD( "dv07", 0x28000, 0x08000, CRC(e7346ef8) SHA1(8083a7a182e8ed904daf2f692115d01b3d0830eb) )
-	ROM_CONTINUE(     0x38000, 0x08000 )
+ROM_START( cobracomj )
+	ROM_REGION( 0x30000, "maincpu", 0 )
+	ROM_LOAD( "eh-11.rom",    0x08000, 0x08000, CRC(868637e1) SHA1(8b1e3e045e341bb94b1f6c7d89198b22e6c19de7) )
+	ROM_LOAD( "eh-12.rom",    0x10000, 0x10000, CRC(7c878a83) SHA1(9b2a3083c6dae69626fdab16d97517d30eaa1859) )
+	ROM_LOAD( "el13.bin",     0x20000, 0x10000, CRC(04505acb) SHA1(2220efb277884588859375dab9960f04f07273a7) )
 
-	ROM_LOAD( "dv12", 0x40000, 0x08000, CRC(46ba5af4) SHA1(a1c13e7e3c85060202120b64e3cee32c1f733270) )
-	ROM_CONTINUE(     0x50000, 0x08000 )
-	ROM_LOAD( "dv13", 0x48000, 0x08000, CRC(a7af6dfd) SHA1(fa41bdafb64c79bd9769903fd37d4d5172b66a52) )
-	ROM_CONTINUE(     0x58000, 0x08000 )
+	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_LOAD( "eh-10.rom",    0x8000,  0x8000,  CRC(62ca5e89) SHA1(b04acaccc58846e0d277868a873a440b7f8071b0) )
 
-	ROM_LOAD( "dv10", 0x60000, 0x08000, CRC(68b6d75c) SHA1(ac719ef6b30ac9e63fab13cb359e6114493f274d) )
-	ROM_CONTINUE(     0x70000, 0x08000 )
-	ROM_LOAD( "dv11", 0x68000, 0x08000, CRC(b5948aee) SHA1(587afbfeda985bede9e4b5f57dad6763f4294962) )
-	ROM_CONTINUE(     0x78000, 0x08000 )
+	ROM_REGION( 0x08000, "gfx1", 0 )    /* characters */
+	ROM_LOAD( "el14.bin",    0x00000, 0x08000, CRC(47246177) SHA1(51b025740dc03b04009ac97d8d110ab521894386) )
+
+	ROM_REGION( 0x80000, "gfx2", 0 )    /* sprites */
+	ROM_LOAD( "eh-00.rom",    0x00000, 0x10000, CRC(d96b6797) SHA1(01c4a9f2bebb13cba14636690cd5356db73f045e) )
+	ROM_LOAD( "eh-01.rom",    0x20000, 0x10000, CRC(3fef9c02) SHA1(e4b731faf6a2f4e5fed8ba9bd07e0f203981ffec) )
+	ROM_LOAD( "eh-02.rom",    0x40000, 0x10000, CRC(bfae6c34) SHA1(9503a120e11e9466cd9a2931fd44a631d72ca5f0) )
+	ROM_LOAD( "eh-03.rom",    0x60000, 0x10000, CRC(d56790f8) SHA1(1cc7cb9f7102158de14a737e9317a54f01790ba8) )
+
+	ROM_REGION( 0x80000, "gfx3", 0 )    /* tiles 1 */
+	ROM_LOAD( "el05.bin",    0x00000, 0x10000, CRC(1c4f6033) SHA1(4a7dece911166d1ff5f41df6ec5140596206d8d4) )
+	ROM_LOAD( "el06.bin",    0x20000, 0x10000, CRC(d24ba794) SHA1(b34b7bbaab4ebdd81c87d363f087cc92e27e8d1c) )
+	ROM_LOAD( "el04.bin",    0x40000, 0x10000, CRC(d80a49ce) SHA1(1a92413b5ab53f80e44a954433e69ec5fe2c0aa6) )
+	ROM_LOAD( "el07.bin",    0x60000, 0x10000, CRC(6d771fc3) SHA1(f29979f3aa07bdb544fb0c1d773c5558b4533390) )
+
+	ROM_REGION( 0x80000, "gfx4", 0 )    /* tiles 2 */
+	ROM_LOAD( "el08.bin",    0x00000, 0x08000, CRC(cb0dcf4c) SHA1(e14853f83ee9ba5cbf2eb1e085fee4e65af3cc25) )
+	ROM_CONTINUE(            0x40000, 0x08000 )
+	ROM_LOAD( "el09.bin",    0x20000, 0x08000, CRC(1fae5be7) SHA1(be6e090b0b82648b385d9b6d11775f3ff40f0af3) )
+	ROM_CONTINUE(            0x60000, 0x08000 )
 ROM_END
 
 /******************************************************************************/
@@ -3523,55 +3575,55 @@
 }
 
 /* Below, I set up the correct number of banks depending on the "maincpu" region size */
-static DRIVER_INIT( ghostb )
+static DRIVER_INIT( lastmisn )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	UINT8 *RAM = machine.region("proms")->base();
-
-	/* Blank out unused garbage in colour prom to avoid colour overflow */
-	memset(RAM + 0x20, 0, 0xe0);
-
-	memory_configure_bank(machine, "bank1", 0, 16, &ROM[0x10000], 0x4000);
-	DRIVER_INIT_CALL(deco222);
+	memory_configure_bank(machine, "bank1", 0, 4, &ROM[0x10000], 0x4000);
+	DRIVER_INIT_CALL( dec8 );
 }
 
-static DRIVER_INIT( meikyuh )
+static DRIVER_INIT( shackled )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	UINT8 *RAM = machine.region("proms")->base();
-
-	/* Blank out unused garbage in colour prom to avoid colour overflow */
-	memset(RAM + 0x20, 0, 0xe0);
-
-	memory_configure_bank(machine, "bank1", 0, 12, &ROM[0x10000], 0x4000);
+	memory_configure_bank(machine, "bank1", 0, 14, &ROM[0x10000], 0x4000);
 	DRIVER_INIT_CALL( dec8 );
 }
 
-static DRIVER_INIT( cobracom )
+static DRIVER_INIT( gondo )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	memory_configure_bank(machine, "bank1", 0, 8, &ROM[0x10000], 0x4000);
+	memory_configure_bank(machine, "bank1", 0, 12, &ROM[0x10000], 0x4000);
 	DRIVER_INIT_CALL( dec8 );
 }
 
-static DRIVER_INIT( oscar )
+static DRIVER_INIT( garyoret )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	memory_configure_bank(machine, "bank1", 0, 4, &ROM[0x10000], 0x4000);
-	DRIVER_INIT_CALL( deco222 );
+	memory_configure_bank(machine, "bank1", 0, 16, &ROM[0x10000], 0x4000);
+	DRIVER_INIT_CALL( dec8 );
 }
 
-static DRIVER_INIT( gondo )
+static DRIVER_INIT( ghostb )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	memory_configure_bank(machine, "bank1", 0, 12, &ROM[0x10000], 0x4000);
-	DRIVER_INIT_CALL( dec8 );
+	UINT8 *RAM = machine.region("proms")->base();
+
+	/* Blank out unused garbage in colour prom to avoid colour overflow */
+	memset(RAM + 0x20, 0, 0xe0);
+
+	memory_configure_bank(machine, "bank1", 0, 16, &ROM[0x10000], 0x4000);
+	DRIVER_INIT_CALL(deco222);
 }
 
-static DRIVER_INIT( garyoret )
+static DRIVER_INIT( meikyuh )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
-	memory_configure_bank(machine, "bank1", 0, 16, &ROM[0x10000], 0x4000);
+	UINT8 *RAM = machine.region("proms")->base();
+
+	/* Blank out unused garbage in colour prom to avoid colour overflow */
+	memset(RAM + 0x20, 0, 0xe0);
+
+	memory_configure_bank(machine, "bank1", 0, 12, &ROM[0x10000], 0x4000);
 	DRIVER_INIT_CALL( dec8 );
 }
 
@@ -3585,18 +3637,11 @@
 	DRIVER_INIT_CALL( dec8 );
 }
 
-static DRIVER_INIT( shackled )
-{
-	UINT8 *ROM = machine.region("maincpu")->base();
-	memory_configure_bank(machine, "bank1", 0, 14, &ROM[0x10000], 0x4000);
-	DRIVER_INIT_CALL( dec8 );
-}
-
-static DRIVER_INIT( lastmisn )
+static DRIVER_INIT( oscar )
 {
 	UINT8 *ROM = machine.region("maincpu")->base();
 	memory_configure_bank(machine, "bank1", 0, 4, &ROM[0x10000], 0x4000);
-	DRIVER_INIT_CALL( dec8 );
+	DRIVER_INIT_CALL( deco222 );
 }
 
 static DRIVER_INIT( srdarwin )
@@ -3606,29 +3651,36 @@
 	DRIVER_INIT_CALL( deco222 );
 }
 
+static DRIVER_INIT( cobracom )
+{
+	UINT8 *ROM = machine.region("maincpu")->base();
+	memory_configure_bank(machine, "bank1", 0, 8, &ROM[0x10000], 0x4000);
+	DRIVER_INIT_CALL( dec8 );
+}
+
 
 /******************************************************************************/
 
-GAME( 1988, cobracom, 0,        cobracom, cobracom, cobracom,    ROT0,   "Data East Corporation", "Cobra-Command (World revision 5)", GAME_SUPPORTS_SAVE )
-GAME( 1988, cobracomj,cobracom, cobracom, cobracom, cobracom,    ROT0,   "Data East Corporation", "Cobra-Command (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1987, ghostb,   0,        ghostb,   ghostb,   ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 2 Players, revision 2)", GAME_SUPPORTS_SAVE )
-GAME( 1987, ghostb2a, ghostb,   ghostb,   ghostb,   ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 2 Players)", GAME_SUPPORTS_SAVE )
-GAME( 1987, ghostb3,  ghostb,   ghostb,   ghostb3,  ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 3 Players)", GAME_SUPPORTS_SAVE )
-GAME( 1987, meikyuh,  ghostb,   ghostb,   meikyuh,  meikyuh,     ROT0,   "Data East Corporation", "Meikyuu Hunter G (Japan, set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1987, meikyuha, ghostb,   ghostb,   meikyuh,  meikyuh,     ROT0,   "Data East Corporation", "Meikyuu Hunter G (Japan, set 2)", GAME_SUPPORTS_SAVE )
-GAME( 1987, srdarwin, 0,        srdarwin, srdarwin, srdarwin,    ROT270, "Data East Corporation", "Super Real Darwin (World)", GAME_SUPPORTS_SAVE )
-GAME( 1987, srdarwinj,srdarwin, srdarwin, srdarwin, srdarwin,    ROT270, "Data East Corporation", "Super Real Darwin (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1987, gondo,    0,        gondo,    gondo,    gondo,       ROT270, "Data East USA", "Gondomania (US)", GAME_SUPPORTS_SAVE )
-GAME( 1987, makyosen, gondo,    gondo,    gondo,    gondo,       ROT270, "Data East Corporation", "Makyou Senshi (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1988, oscar,    0,        oscar,    oscar,    oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (World revision 0)", GAME_SUPPORTS_SAVE )
-GAME( 1987, oscaru,   oscar,    oscar,    oscaru,   oscar,       ROT0,   "Data East USA", "Psycho-Nics Oscar (US)", GAME_SUPPORTS_SAVE )
-GAME( 1987, oscarj1,  oscar,    oscar,    oscaru,   oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (Japan revision 1)", GAME_SUPPORTS_SAVE )
-GAME( 1987, oscarj2,  oscar,    oscar,    oscaru,   oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (Japan revision 2)", GAME_SUPPORTS_SAVE )
-GAME( 1986, lastmisn, 0,        lastmisn, lastmisn, lastmisn,    ROT270, "Data East USA", "Last Mission (US revision 6)", GAME_SUPPORTS_SAVE )
-GAME( 1986, lastmisno,lastmisn, lastmisn, lastmisn, lastmisn,    ROT270, "Data East USA", "Last Mission (US revision 5)", GAME_SUPPORTS_SAVE )
-GAME( 1986, lastmisnj,lastmisn, lastmisn, lastmisnj, lastmisn,   ROT270, "Data East Corporation", "Last Mission (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1986, shackled, 0,        shackled, shackled, shackled,    ROT0,   "Data East USA", "Shackled (US)", GAME_SUPPORTS_SAVE )
-GAME( 1986, breywood, shackled, shackled, shackled, shackled,    ROT0,   "Data East Corporation", "Breywood (Japan revision 2)", GAME_SUPPORTS_SAVE )
-GAME( 1987, csilver,  0,        csilver,  csilver,  csilver,     ROT0,   "Data East Corporation", "Captain Silver (World)", GAME_SUPPORTS_SAVE )
-GAME( 1987, csilverj, csilver,  csilver,  csilver,  csilver,     ROT0,   "Data East Corporation", "Captain Silver (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1987, garyoret, 0,        garyoret, garyoret, garyoret,    ROT0,   "Data East Corporation", "Garyo Retsuden (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1986, lastmisn, 0,        lastmisn, lastmisn,  lastmisn,    ROT270, "Data East USA", "Last Mission (US revision 6)", GAME_SUPPORTS_SAVE )
+GAME( 1986, lastmisno,lastmisn, lastmisn, lastmisn,  lastmisn,    ROT270, "Data East USA", "Last Mission (US revision 5)", GAME_SUPPORTS_SAVE )
+GAME( 1986, lastmisnj,lastmisn, lastmisn, lastmisnj, lastmisn,    ROT270, "Data East Corporation", "Last Mission (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1986, shackled, 0,        shackled, shackled,  shackled,    ROT0,   "Data East USA", "Shackled (US)", GAME_SUPPORTS_SAVE )
+GAME( 1986, breywood, shackled, shackled, breywood,  shackled,    ROT0,   "Data East Corporation", "Breywood (Japan revision 2)", GAME_SUPPORTS_SAVE )
+GAME( 1987, gondo,    0,        gondo,    gondo,     gondo,       ROT270, "Data East USA", "Gondomania (US)", GAME_SUPPORTS_SAVE )
+GAME( 1987, makyosen, gondo,    gondo,    gondo,     gondo,       ROT270, "Data East Corporation", "Makyou Senshi (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1987, garyoret, 0,        garyoret, garyoret,  garyoret,    ROT0,   "Data East Corporation", "Garyo Retsuden (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1987, ghostb,   0,        ghostb,   ghostb,    ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 2 Players, revision 2)", GAME_SUPPORTS_SAVE )
+GAME( 1987, ghostb2a, ghostb,   ghostb,   ghostb2a,  ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 2 Players)", GAME_SUPPORTS_SAVE )
+GAME( 1987, ghostb3,  ghostb,   ghostb,   ghostb3,   ghostb,      ROT0,   "Data East USA", "The Real Ghostbusters (US 3 Players)", GAME_SUPPORTS_SAVE )
+GAME( 1987, meikyuh,  ghostb,   ghostb,   meikyuh,   meikyuh,     ROT0,   "Data East Corporation", "Meikyuu Hunter G (Japan, set 1)", GAME_SUPPORTS_SAVE )
+GAME( 1987, meikyuha, ghostb,   ghostb,   meikyuh,   meikyuh,     ROT0,   "Data East Corporation", "Meikyuu Hunter G (Japan, set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1987, csilver,  0,        csilver,  csilver,   csilver,     ROT0,   "Data East Corporation", "Captain Silver (World)", GAME_SUPPORTS_SAVE )
+GAME( 1987, csilverj, csilver,  csilver,  csilverj,  csilver,     ROT0,   "Data East Corporation", "Captain Silver (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1987, oscar,    0,        oscar,    oscar,     oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (World revision 0)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1988, oscaru,   oscar,    oscar,    oscarj,    oscar,       ROT0,   "Data East USA", "Psycho-Nics Oscar (US)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1987, oscarj1,  oscar,    oscar,    oscarj,    oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (Japan revision 1)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1987, oscarj2,  oscar,    oscar,    oscarj,    oscar,       ROT0,   "Data East Corporation", "Psycho-Nics Oscar (Japan revision 2)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1987, srdarwin, 0,        srdarwin, srdarwin,  srdarwin,    ROT270, "Data East Corporation", "Super Real Darwin (World)", GAME_SUPPORTS_SAVE )
+GAME( 1987, srdarwinj,srdarwin, srdarwin, srdarwinj, srdarwin,    ROT270, "Data East Corporation", "Super Real Darwin (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1988, cobracom, 0,        cobracom, cobracom,  cobracom,    ROT0,   "Data East Corporation", "Cobra-Command (World revision 5)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1988, cobracomj,cobracom, cobracom, cobracom,  cobracom,    ROT0,   "Data East Corporation", "Cobra-Command (Japan)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
diff -Nru src-old/mame/drivers/deco32.c src/mame/drivers/deco32.c
--- src-old/mame/drivers/deco32.c	2012-02-26 15:31:24.000000000 +0100
+++ src/mame/drivers/deco32.c	2012-03-11 18:17:00.000000000 +0100
@@ -862,7 +862,7 @@
 	AM_RANGE(0x20c000, 0x20cfff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_layout_1_ram)
 	AM_RANGE(0x210000, 0x217fff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_lookup_0_ram)
 	AM_RANGE(0x218000, 0x21ffff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_lookup_1_ram)
-	AM_RANGE(0x220000, 0x221fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Main spriteram */
+	AM_RANGE(0x220000, 0x221fff) AM_RAM AM_SHARE("spriteram") /* Main spriteram */
 
 	AM_RANGE(0x228000, 0x2283ff) AM_RAM //0x10 byte increments only
 
@@ -911,7 +911,7 @@
 	AM_RANGE(0x20c000, 0x20cfff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_layout_1_ram)
 	AM_RANGE(0x210000, 0x217fff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_lookup_0_ram)
 	AM_RANGE(0x218000, 0x21ffff) AM_RAM AM_BASE_MEMBER(dragngun_state, m_dragngun_sprite_lookup_1_ram)
-	AM_RANGE(0x220000, 0x221fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* Main spriteram */
+	AM_RANGE(0x220000, 0x221fff) AM_RAM AM_SHARE("spriteram") /* Main spriteram */
 
 	AM_RANGE(0x228000, 0x2283ff) AM_RAM				//0x10 byte increments only
 	AM_RANGE(0x230000, 0x230003) AM_WRITE(dragngun_spriteram_dma_w)
@@ -1959,8 +1959,6 @@
 	MCFG_TIMER_ADD("int_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(42*8, 32*8)
@@ -1968,6 +1966,8 @@
 	MCFG_SCREEN_UPDATE_STATIC(dragngun)
 	MCFG_SCREEN_VBLANK_STATIC(dragngun)
 
+	MCFG_BUFFERED_SPRITERAM32_ADD("spriteram")
+
 	MCFG_DECO16IC_ADD("tilegen1", dragngun_deco16ic_tilegen1_intf)
 	MCFG_DECO16IC_ADD("tilegen2", dragngun_deco16ic_tilegen2_intf)
 
@@ -2032,8 +2032,6 @@
 	MCFG_TIMER_ADD("int_timer", interrupt_gen)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(42*8, 32*8+22)
@@ -2041,6 +2039,8 @@
 	MCFG_SCREEN_UPDATE_STATIC(dragngun)
 	MCFG_SCREEN_VBLANK_STATIC(dragngun)
 
+	MCFG_BUFFERED_SPRITERAM32_ADD("spriteram")
+
 	MCFG_DECO16IC_ADD("tilegen1", lockload_deco16ic_tilegen1_intf)
 	MCFG_DECO16IC_ADD("tilegen2", lockload_deco16ic_tilegen2_intf)
 
diff -Nru src-old/mame/drivers/decocass.c src/mame/drivers/decocass.c
--- src-old/mame/drivers/decocass.c	2012-02-13 20:29:50.000000000 +0100
+++ src/mame/drivers/decocass.c	2012-03-10 05:05:23.000000000 +0100
@@ -221,22 +221,22 @@
 	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_MINMAX(0x10,0xf0) PORT_SENSITIVITY(100) PORT_KEYDELTA(10) PORT_PLAYER(2)
 
 	PORT_START("DSW1")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )		PORT_DIPLOCATION("SW1:1,2")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coin_A ) )						PORT_DIPLOCATION("SW1:1,2")
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x01, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )		PORT_DIPLOCATION("SW1:3,4")
+	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Coin_B ) )						PORT_DIPLOCATION("SW1:3,4")
 	PORT_DIPSETTING(    0x00, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x30, 0x30, "Type of Tape" )		PORT_DIPLOCATION("SW1:5,6")   /* Used by the "bios" */
+	PORT_DIPNAME( 0x30, 0x30, "Type of Tape" )							PORT_DIPLOCATION("SW1:5,6")   /* Used by the "bios" */
 	PORT_DIPSETTING(    0x00, "MT (Big)" )			/* Was listed as "Board Type" with this being "OLD" */
 	PORT_DIPSETTING(    0x10, "invalid?" )
 	PORT_DIPSETTING(    0x20, "invalid?" )
 	PORT_DIPSETTING(    0x30, "MD (Small)" )		/* Was listed as "Board Type" with this being "NEW" */
-	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )		PORT_DIPLOCATION("SW1:7")
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Cabinet ) )						PORT_DIPLOCATION("SW1:7")
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Cocktail ) )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK)
@@ -247,7 +247,7 @@
 	PORT_DIPUNKNOWN_DIPLOC( 0x04, 0x04, "SW2:3")
 	PORT_DIPUNKNOWN_DIPLOC( 0x08, 0x08, "SW2:4")		/* Most Dipswitch Settings sheets show 4 (with/without 5) as some form of Diffculty */
 	PORT_DIPUNKNOWN_DIPLOC( 0x10, 0x10, "SW2:5")
-	PORT_DIPNAME( 0xe0, 0xe0, "Country Code" )		PORT_DIPLOCATION("SW2:6,7,8") /* Always Listed as "DON'T CHANGE" */
+	PORT_DIPNAME( 0xe0, 0xe0, "Country Code" )							PORT_DIPLOCATION("SW2:6,7,8") /* Always Listed as "DON'T CHANGE" */
 	PORT_DIPSETTING(    0xe0, "A" )
 	PORT_DIPSETTING(    0xc0, "B" )
 	PORT_DIPSETTING(    0xa0, "C" )
@@ -256,280 +256,324 @@
 	PORT_DIPSETTING(    0x40, "F" )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cbtime )
+static INPUT_PORTS_START( cterrani )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
+	PORT_DIPSETTING(    0x06, "3000" )
+	PORT_DIPSETTING(    0x04, "5000" )
+	PORT_DIPSETTING(    0x02, "7000" )
+	PORT_DIPNAME( 0x08, 0x08, "Player's Rocket Movement" )				PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	PORT_DIPNAME( 0x10, 0x10, "Alien Craft Movement" )					PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	/* Switches 6, 7 & 8 are shown as completly blank */
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( csuperas )
+	PORT_INCLUDE( decocass )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
 	PORT_DIPSETTING(    0x06, "20000" )
 	PORT_DIPSETTING(    0x04, "30000" )
 	PORT_DIPSETTING(    0x02, "40000" )
-	PORT_DIPSETTING(    0x00, "50000" )
-	PORT_DIPNAME( 0x08, 0x08, "Enemies" )			PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(    0x08, "4" )
-	PORT_DIPSETTING(    0x00, "6" )
-	PORT_DIPNAME( 0x10, 0x10, "End of Level Pepper" )	PORT_DIPLOCATION("SW2:5")
-	PORT_DIPSETTING(    0x10, DEF_STR( No ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
+	PORT_DIPNAME( 0x08, 0x08, "Alien Craft Movement" )					PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cnightst )
+static INPUT_PORTS_START( clocknch )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
-	PORT_DIPSETTING(    0x06, "When Night Star Completed (First 2 Times)" )
-	PORT_DIPSETTING(    0x04, "When Night Star Completed (First Time Only)" )
-	PORT_DIPSETTING(    0x02, "Every 70000"  )
-	PORT_DIPSETTING(    0x00, "30000 Only"  )
-	PORT_DIPNAME( 0x08, 0x08, "Number of Missles" )		PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(    0x08, "Few" )
-	PORT_DIPSETTING(    0x00, "Many" )
-	PORT_DIPNAME( 0x10, 0x10, "Enemy's Speed" )		PORT_DIPLOCATION("SW2:5")
-	PORT_DIPSETTING(    0x10, "Slow" )
-	PORT_DIPSETTING(    0x00, "Fast" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
+	PORT_DIPSETTING(    0x06, "15000" )
+	PORT_DIPSETTING(    0x04, "20000" )
+	PORT_DIPSETTING(    0x02, "30000" )
+	/* Switches 4, 5, 6, 7 & 8 are listed as "Not Used" and "Don't Change" */
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( cprogolf )
+	PORT_INCLUDE( decocass )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "2" )
+	PORT_DIPSETTING(    0x00, "3" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3") /* You must shoot equal to or under the listed value for a bonus */
+	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
+	PORT_DIPSETTING(    0x02, "6 Under" )
+	PORT_DIPSETTING(    0x04, "3 Under" )
+	PORT_DIPSETTING(    0x06, "1 Under" )
+	PORT_DIPNAME( 0x08, 0x08, "Number of Strokes" )						PORT_DIPLOCATION("SW2:4") /* You must shoot equal to or under to continue, else you lose a life */
+	PORT_DIPSETTING(    0x00, "Par +2" )
+	PORT_DIPSETTING(    0x08, "Par +3" )
+	PORT_DIPNAME( 0x10, 0x10, "Show Stroke Power/Ball Direction" )		PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( cexplore )
+	PORT_INCLUDE( decocass )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
+	PORT_DIPSETTING(    0x06, "10000" )
+	PORT_DIPSETTING(    0x04, "1500000" )
+	PORT_DIPSETTING(    0x02, "30000" )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Difficulty ) )					PORT_DIPLOCATION("SW2:4") /* Listed as "Missle" */
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	PORT_DIPNAME( 0x10, 0x10, "Number of UFOs" )						PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, "Few" )
+	PORT_DIPSETTING(    0x00, "Many" )
+	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
+INPUT_PORTS_END
 static INPUT_PORTS_START( ctornado )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
 	PORT_DIPSETTING(    0x06, "10000" )
 	PORT_DIPSETTING(    0x04, "20000" )
 	PORT_DIPSETTING(    0x02, "30000" )
-	PORT_DIPNAME( 0x08, 0x08, "Crash Bombs" )		PORT_DIPLOCATION("SW2:4") /* Printed English translation "Hero Destructor" */
+	PORT_DIPNAME( 0x08, 0x08, "Crash Bombs" )							PORT_DIPLOCATION("SW2:4") /* Printed English translation "Hero Destructor" */
 	PORT_DIPSETTING(    0x08, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x10, 0x10, "Alens' Speed" )		PORT_DIPLOCATION("SW2:5")
+	PORT_DIPNAME( 0x10, 0x10, "Alens' Speed" )							PORT_DIPLOCATION("SW2:5")
 	PORT_DIPSETTING(    0x10, "Slow" )
 	PORT_DIPSETTING(    0x00, "Fast" )
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cbdash )
+static INPUT_PORTS_START( cmissnx )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "20000" )
-	PORT_DIPSETTING(    0x04, "30000" )
-	PORT_DIPSETTING(    0x02, "40000" )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:4,5")
-	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )		/* Number of Diamonds Little, Timer: Long */
-	PORT_DIPSETTING(    0x10, DEF_STR( Hard ) )		/* Number of Diamonds Little, Timer: Long */
-	PORT_DIPSETTING(    0x08, DEF_STR( Harder ) )		/* Number of Diamonds Many, Timer: Short */
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )		/* Number of Diamonds Many, Timer: Short */
+	PORT_DIPSETTING(    0x06, "5000" )
+	PORT_DIPSETTING(    0x04, "10000" )
+	PORT_DIPSETTING(    0x02, "15000" )
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )					PORT_DIPLOCATION("SW2:4,5") /* Listed as "Game Level" */
+	PORT_DIPSETTING(    0x18, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cprogolf )
+static INPUT_PORTS_START( cbtime )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "2" )
-	PORT_DIPSETTING(    0x00, "3" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3") /* You must shoot equal to or under the listed value for a bonus */
-	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x02, "6 Under" )
-	PORT_DIPSETTING(    0x04, "3 Under" )
-	PORT_DIPSETTING(    0x06, "1 Under" )
-	PORT_DIPNAME( 0x08, 0x08, "Number of Strokes" )		PORT_DIPLOCATION("SW2:4") /* You must shoot equal to or under to continue, else you lose a life */
-	PORT_DIPSETTING(    0x00, "Par +2" )
-	PORT_DIPSETTING(    0x08, "Par +3" )
-	PORT_DIPNAME( 0x10, 0x10, "Show Stroke Power/Ball Direction" )		PORT_DIPLOCATION("SW2:5")
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x06, "20000" )
+	PORT_DIPSETTING(    0x04, "30000" )
+	PORT_DIPSETTING(    0x02, "40000" )
+	PORT_DIPSETTING(    0x00, "50000" )
+	PORT_DIPNAME( 0x08, 0x08, "Enemies" )								PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, "4" )
+	PORT_DIPSETTING(    0x00, "6" )
+	PORT_DIPNAME( 0x10, 0x10, "End of Level Pepper" )					PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( No ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( csuperas )
+static INPUT_PORTS_START( cgraplop )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
 	PORT_DIPSETTING(    0x06, "20000" )
-	PORT_DIPSETTING(    0x04, "30000" )
-	PORT_DIPSETTING(    0x02, "40000" )
-	PORT_DIPNAME( 0x08, 0x08, "Alien Craft Movement" )	PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x04, "50000" )
+	PORT_DIPSETTING(    0x02, "70000" )
+	PORT_DIPNAME( 0x08, 0x08, "Number of Up Sign" )						PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, "Few" )
+	PORT_DIPSETTING(    0x00, "Many" )
+	PORT_DIPNAME( 0x10, 0x10, "Falling Speed" )							PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	/* Switches 6, 7 & 8 are listed as "Not Used" and "Don't Change" */
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( cnightst )
+	PORT_INCLUDE( decocass )
+
+	PORT_MODIFY("DSW2")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x06, "When Night Star Completed (First 2 Times)" )
+	PORT_DIPSETTING(    0x04, "When Night Star Completed (First Time Only)" )
+	PORT_DIPSETTING(    0x02, "Every 70000"  )
+	PORT_DIPSETTING(    0x00, "30000 Only"  )
+	PORT_DIPNAME( 0x08, 0x08, "Number of Missles" )						PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, "Few" )
+	PORT_DIPSETTING(    0x00, "Many" )
+	PORT_DIPNAME( 0x10, 0x10, "Enemy's Speed" )							PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, "Slow" )
+	PORT_DIPSETTING(    0x00, "Fast" )
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cscrtry )
+static INPUT_PORTS_START( cskater )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "2" )
-	PORT_DIPSETTING(    0x00, "4" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
-	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "30000" )
-	PORT_DIPSETTING(    0x04, "50000" )
-	PORT_DIPSETTING(    0x02, "70000" )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:4")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1") /* Listed as "Number of Balls" */
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPSETTING(    0x00, "60000" )
+	PORT_DIPSETTING(    0x06, "20000" )
+	PORT_DIPSETTING(    0x04, "30000" )
+	PORT_DIPSETTING(    0x02, "40000" )
+	PORT_DIPNAME( 0x08, 0x08, "Enemy's Speed" )							PORT_DIPLOCATION("SW2:4")
 	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
-	/* Switches 5, 6, 7 & 8 are listed as "Special Purpose" and "Don't Change" */
+	PORT_DIPNAME( 0x10, 0x10, "Number of Skates" )						PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, "Small" )
+	PORT_DIPSETTING(    0x00, "Large" )
+	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( cpsoccer )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1") /* Listed as "Number of Balls" */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1") /* Listed as "Number of Balls" */
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, "Number of Nice Goal" )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, "Number of Nice Goal" )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
 	PORT_DIPSETTING(    0x06, "5" )
 	PORT_DIPSETTING(    0x04, "10" )
 	PORT_DIPSETTING(    0x02, "20" )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Demo_Sounds ) )	PORT_DIPLOCATION("SW2:4")
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Demo_Sounds ) )					PORT_DIPLOCATION("SW2:4")
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:4") /* Listed as "Class" */
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Difficulty ) )					PORT_DIPLOCATION("SW2:4") /* Listed as "Class" */
 	PORT_DIPSETTING(    0x10, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cterrani )
+static INPUT_PORTS_START( csdtenis )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1") /* Listed as "Number of Balls" */
+	PORT_DIPSETTING(    0x01, "2" )
+	PORT_DIPSETTING(    0x00, "1" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "3000" )
-	PORT_DIPSETTING(    0x04, "5000" )
-	PORT_DIPSETTING(    0x02, "7000" )
-	PORT_DIPNAME( 0x08, 0x08, "Player's Rocket Movement" )	PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
-	PORT_DIPNAME( 0x10, 0x10, "Alien Craft Movement" )	PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x06, "Every 1set" )
+	PORT_DIPSETTING(    0x04, "Every 2set" )
+	PORT_DIPSETTING(    0x02, "Every 3set" )
+	PORT_DIPNAME( 0x08, 0x08, "Speed Level" )							PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, "Low Speed" )
+	PORT_DIPSETTING(    0x00, "High Speed" )
+	PORT_DIPNAME( 0x10, 0x10, "Attack Level" )							PORT_DIPLOCATION("SW2:5")
 	PORT_DIPSETTING(    0x10, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
-	/* Switches 6, 7 & 8 are shown as completly blank */
+	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( cmissnx )
+static INPUT_PORTS_START( cscrtry )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, "2" )
+	PORT_DIPSETTING(    0x00, "4" )
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "5000" )
-	PORT_DIPSETTING(    0x04, "10000" )
-	PORT_DIPSETTING(    0x02, "15000" )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:4,5") /* Listed as "Game Level" */
-	PORT_DIPSETTING(    0x18, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Hard ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
+	PORT_DIPSETTING(    0x06, "30000" )
+	PORT_DIPSETTING(    0x04, "50000" )
+	PORT_DIPSETTING(    0x02, "70000" )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Difficulty ) )					PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
+	PORT_DIPNAME( 0x10, 0x10, "Timer(Don't Change)" )					PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, "Timer decrease" )
+	PORT_DIPSETTING(    0x00, "Timer infinity" )
+	/* Switches 6, 7 & 8 are listed as "Special Purpose" and "Don't Change" */
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( cfghtice )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Very_Difficult ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Very_Difficult ) )				PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x04, DEF_STR( Very_Easy )  )
 	PORT_DIPSETTING(    0x06, DEF_STR( Easy ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( Very_Difficult ) )
-	PORT_DIPNAME( 0x08, 0x08, "Enemy's Speed" )		PORT_DIPLOCATION("SW2:4")
+	PORT_DIPNAME( 0x08, 0x08, "Enemy's Speed" )							PORT_DIPLOCATION("SW2:4")
 	PORT_DIPSETTING(    0x08, DEF_STR( Normal ) )
 	PORT_DIPSETTING(    0x00, "Fast" )
 	PORT_SERVICE_DIPLOC(  0x10, IP_ACTIVE_LOW, "SW2:5" )	/* Listed as Test Mode, but doesn't seem to work??? */
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( clocknch )
-	PORT_INCLUDE( decocass )
-
-	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
-	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "15000" )
-	PORT_DIPSETTING(    0x04, "20000" )
-	PORT_DIPSETTING(    0x02, "30000" )
-	/* Switches 4, 5, 6, 7 & 8 are listed as "Not Used" and "Don't Change" */
-INPUT_PORTS_END
-
-static INPUT_PORTS_START( cgraplop )
+static INPUT_PORTS_START( cbdash )
 	PORT_INCLUDE( decocass )
 
 	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )						PORT_DIPLOCATION("SW2:1")
 	PORT_DIPSETTING(    0x01, "3" )
 	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
+	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )					PORT_DIPLOCATION("SW2:2,3")
 	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
 	PORT_DIPSETTING(    0x06, "20000" )
-	PORT_DIPSETTING(    0x04, "50000" )
-	PORT_DIPSETTING(    0x02, "70000" )
-	PORT_DIPNAME( 0x08, 0x08, "Number of UPs" )		PORT_DIPLOCATION("SW2:4")
-	PORT_DIPSETTING(    0x08, "Few" )
-	PORT_DIPSETTING(    0x00, "Many" )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:5") /* Listed as "Falling Speed" */
-	PORT_DIPSETTING(    0x10, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
-	/* Switches 6, 7 & 8 are listed as "Not Used" and "Don't Change" */
-INPUT_PORTS_END
-
-static INPUT_PORTS_START( cexplore )
-	PORT_INCLUDE( decocass )
-
-	PORT_MODIFY("DSW2")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Lives ) )		PORT_DIPLOCATION("SW2:1")
-	PORT_DIPSETTING(    0x01, "3" )
-	PORT_DIPSETTING(    0x00, "5" )
-	PORT_DIPNAME( 0x06, 0x06, DEF_STR( Bonus_Life ) )	PORT_DIPLOCATION("SW2:2,3")
-	PORT_DIPSETTING(    0x00, DEF_STR( None )  )
-	PORT_DIPSETTING(    0x06, "10000" )
-	PORT_DIPSETTING(    0x04, "1500000" )
-	PORT_DIPSETTING(    0x02, "30000" )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Difficulty ) )	PORT_DIPLOCATION("SW2:4") /* Listed as "Missle" */
-	PORT_DIPSETTING(    0x08, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Difficult ) )
-	PORT_DIPNAME( 0x10, 0x10, "Number of UFOs" )		PORT_DIPLOCATION("SW2:5")
-	PORT_DIPSETTING(    0x10, "Few" )
-	PORT_DIPSETTING(    0x00, "Many" )
+	PORT_DIPSETTING(    0x04, "30000" )
+	PORT_DIPSETTING(    0x02, "40000" )
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Difficulty ) )					PORT_DIPLOCATION("SW2:4,5")
+	PORT_DIPSETTING(    0x18, DEF_STR( Normal ) )		/* Number of Diamonds Little, Timer: Long */
+	PORT_DIPSETTING(    0x10, DEF_STR( Hard ) )		/* Number of Diamonds Little, Timer: Long */
+	PORT_DIPSETTING(    0x08, DEF_STR( Harder ) )		/* Number of Diamonds Many, Timer: Short */
+	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )		/* Number of Diamonds Many, Timer: Short */
 	/* Switches 6, 7 & 8 are listed as "Country Code" A through F and "Don't Change" */
 INPUT_PORTS_END
 
@@ -650,7 +694,7 @@
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_RAW_PARAMS(HCLK, 384, 8, 248, 272, 8, 248)
+	MCFG_SCREEN_RAW_PARAMS(HCLK, 384, 0*8, 256, 272, 1*8, 248)
 	MCFG_SCREEN_UPDATE_STATIC(decocass)
 
 	MCFG_GFXDECODE(decocass)
@@ -684,17 +728,17 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( clocknch, decocass )
+static MACHINE_CONFIG_DERIVED( cterrani, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(clocknch)
+	MCFG_MACHINE_RESET(cterrani)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( ctisland, decocass )
+static MACHINE_CONFIG_DERIVED( castfant, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(ctisland)
+	MCFG_MACHINE_RESET(castfant)
 MACHINE_CONFIG_END
 
 
@@ -705,10 +749,17 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( castfant, decocass )
+static MACHINE_CONFIG_DERIVED( clocknch, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(castfant)
+	MCFG_MACHINE_RESET(clocknch)
+MACHINE_CONFIG_END
+
+
+static MACHINE_CONFIG_DERIVED( cprogolf, decocass )
+
+	/* basic machine hardware */
+	MCFG_MACHINE_RESET(cprogolf)
 MACHINE_CONFIG_END
 
 
@@ -719,10 +770,10 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cterrani, decocass )
+static MACHINE_CONFIG_DERIVED( ctisland, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cterrani)
+	MCFG_MACHINE_RESET(ctisland)
 MACHINE_CONFIG_END
 
 
@@ -733,24 +784,24 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cprogolf, decocass )
+static MACHINE_CONFIG_DERIVED( cdiscon1, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cprogolf)
+	MCFG_MACHINE_RESET(cdiscon1)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cmissnx, decocass )
+static MACHINE_CONFIG_DERIVED( ctornado, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cmissnx)
+	MCFG_MACHINE_RESET(ctornado)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cdiscon1, decocass )
+static MACHINE_CONFIG_DERIVED( cmissnx, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cdiscon1)
+	MCFG_MACHINE_RESET(cmissnx)
 MACHINE_CONFIG_END
 
 
@@ -761,17 +812,10 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( ctornado, decocass )
-
-	/* basic machine hardware */
-	MCFG_MACHINE_RESET(ctornado)
-MACHINE_CONFIG_END
-
-
-static MACHINE_CONFIG_DERIVED( cbnj, decocass )
+static MACHINE_CONFIG_DERIVED( cbtime, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cbnj)
+	MCFG_MACHINE_RESET(cbtime)
 MACHINE_CONFIG_END
 
 
@@ -782,13 +826,6 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cbtime, decocass )
-
-	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cbtime)
-MACHINE_CONFIG_END
-
-
 static MACHINE_CONFIG_DERIVED( cgraplop, decocass )
 
 	/* basic machine hardware */
@@ -810,10 +847,10 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cfghtice, decocass )
+static MACHINE_CONFIG_DERIVED( cskater, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cfghtice)
+	MCFG_MACHINE_RESET(cskater)
 MACHINE_CONFIG_END
 
 
@@ -838,6 +875,20 @@
 MACHINE_CONFIG_END
 
 
+static MACHINE_CONFIG_DERIVED( csdtenis, decocass )
+
+	/* basic machine hardware */
+	MCFG_MACHINE_RESET(csdtenis)
+MACHINE_CONFIG_END
+
+
+static MACHINE_CONFIG_DERIVED( czeroize, decocass )
+
+	/* basic machine hardware */
+	MCFG_MACHINE_RESET(czeroize)
+MACHINE_CONFIG_END
+
+
 static MACHINE_CONFIG_DERIVED( cppicf, decocass )
 
 	/* basic machine hardware */
@@ -845,42 +896,40 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cbdash, decocass )
+static MACHINE_CONFIG_DERIVED( cfghtice, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cbdash)
+	MCFG_MACHINE_RESET(cfghtice)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cscrtry, decocass )
+static MACHINE_CONFIG_DERIVED( type4, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cscrtry)
+	MCFG_MACHINE_RESET(type4)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( cflyball, decocass )
+static MACHINE_CONFIG_DERIVED( cbdash, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(cflyball)
+	MCFG_MACHINE_RESET(cbdash)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_DERIVED( czeroize, decocass )
+static MACHINE_CONFIG_DERIVED( cflyball, decocass )
 
 	/* basic machine hardware */
-	MCFG_MACHINE_RESET(czeroize)
-	MCFG_SCREEN_MODIFY("screen")
-	MCFG_SCREEN_VISIBLE_AREA(1*8, 32*8-1, 1*8, 31*8-1)
+	MCFG_MACHINE_RESET(cflyball)
 MACHINE_CONFIG_END
 
 
 #define DECOCASS_COMMON_ROMS	\
 	ROM_REGION( 0x10000, "audiocpu", 0 )	  \
-	ROM_LOAD( "v1.5a",     0xf800, 0x0800, CRC(b66b2c2a) SHA1(0097f38beb4872e735e560148052e258a26b08fd) ) /* from RMS-8 board: 2716 eprom @5A w/V1 label,  contains audio cpu code */ \
+	ROM_LOAD( "v1-.5a",     0xf800, 0x0800, CRC(b66b2c2a) SHA1(0097f38beb4872e735e560148052e258a26b08fd) ) /* from RMS-8 board: 2716 eprom @5A w/V1- label,  contains audio cpu code */ \
 \
 	ROM_REGION( 0x10000, "mcu", 0 )	  /* 4k for the 8041 MCU (actually 1K ROM + 64 bytes RAM @ 0x800) */ \
-	ROM_LOAD( "cassmcu.1c", 0x0000, 0x0400, CRC(a6df18fd) SHA1(1f9ea47e372d31767c936c15852b43df2b0ee8ff) )  /* from B10-B board: "NEC // JAPAN // X1202D-108 // D8041C 535" 8041 MCU @1C, handles cassette and other stuff; This info needs additional verification, as the d8041-535 mcu has not been dumped yet to prove code is the same. */ \
+	ROM_LOAD( "cassmcu.1c", 0x0000, 0x0400, CRC(a6df18fd) SHA1(1f9ea47e372d31767c936c15852b43df2b0ee8ff) ) /* from B10-B board: "NEC // JAPAN // X1202D-108 // D8041C 535" 8041 MCU @1C, handles cassette and other stuff; This info needs additional verification, as the d8041-535 mcu has not been dumped yet to prove code is the same. */ \
 \
 	ROM_REGION( 0x00060, "proms", 0 )	  /* PROMS */ \
 	ROM_LOAD( "v2.3m",      0x0000, 0x0020, CRC(238fdb40) SHA1(b88e8fabb82092105c3828154608ea067acbf2e5) ) /* from DSP-8 board: M3-7603-5 (82s123 equiv, 32x8 TS) PROM @3M w/'V2' stamp, unknown purpose (gfx related: row/interrupt/vblank related? vertical counter related) */ \
@@ -892,7 +941,7 @@
 	/* v0a.7e, New boardset bios, revision A */ \
 \
 	ROM_REGION( 0x10000, "maincpu", 0 ) \
-	ROM_LOAD( "v0a.7e", 0xf000, 0x1000, CRC(3D33AC34) SHA1(909D59E7A993AFFD10224402B4370E82A5F5545C) ) /* from RMS-8 board: 2732 EPROM @7E w/'V0A' label (has HDRA01HDR string inside it), bios code */ \
+	ROM_LOAD( "v0a-.7e",    0xf000, 0x1000, CRC(3D33AC34) SHA1(909D59E7A993AFFD10224402B4370E82A5F5545C) ) /* from RMS-8 board: 2732 EPROM @7E w/'V0A-' label (has HDRA01HDR string inside it), bios code */ \
 \
 	DECOCASS_COMMON_ROMS \
 
@@ -901,7 +950,7 @@
 	/* rms8.7e, New boardset bios, revision B */ \
 \
 	ROM_REGION( 0x10000, "maincpu", 0 ) \
-	ROM_LOAD( "rms8.7e", 0xf000, 0x1000, CRC(23d929b7) SHA1(063f83020ba3d6f43ab8471f95ca919767b93aa4) ) /* from RMS-8 board: 2732 EPROM @7E w/unknown label (probably 'V0B', needs checking; has HDRB01HDR string in it), bios code */ \
+	ROM_LOAD( "v0b-.7e",    0xf000, 0x1000, CRC(23d929b7) SHA1(063f83020ba3d6f43ab8471f95ca919767b93aa4) ) /* from RMS-8 board: 2732 EPROM @7E w/'V0B-' label (has HDRB01HDR string inside it), bios code */ \
 \
 	DECOCASS_COMMON_ROMS \
 
@@ -910,8 +959,8 @@
 	/* dsp3.p0b/p1b, Old boardset bios, revision B?; from DSP-3 board? has HDRB01x string in it, 2x 2716 EPROM? */ \
 \
 	ROM_REGION( 0x10000, "maincpu", 0 ) \
-	ROM_LOAD( "dsp3.p0b",  0xf000, 0x0800, CRC(b67a91d9) SHA1(681c040be0f0ed1ba0a50161b36d0ad8e1c8c5cb) ) \
-	ROM_LOAD( "dsp3.p1b",  0xf800, 0x0800, CRC(3bfff5f3) SHA1(4e9437cb1b76d64da6b37f01bd6e879fb399e8ce) ) \
+	ROM_LOAD( "dsp3.p0b",   0xf000, 0x0800, CRC(b67a91d9) SHA1(681c040be0f0ed1ba0a50161b36d0ad8e1c8c5cb) ) \
+	ROM_LOAD( "dsp3.p1b",   0xf800, 0x0800, CRC(3bfff5f3) SHA1(4e9437cb1b76d64da6b37f01bd6e879fb399e8ce) ) \
 \
 	DECOCASS_COMMON_ROMS \
 
@@ -934,6 +983,7 @@
 	ROM_LOAD( "testtape.cas", 0x0000, 0x2000, CRC(4f9d8efb) SHA1(5b77747dad1033e5703f06c0870441b54b4256c5) )
 ROM_END
 
+/* 01 Highway Chase */
 ROM_START( chwy )
 	DECOCASS_BIOS_B_ROMS
 
@@ -945,141 +995,140 @@
 	ROM_LOAD( "chwy.cas",   0x0000, 0x8000, CRC(68a48064) SHA1(7e389737972fd0c54f398d296159c561f5ec3a93) )
 ROM_END
 
-ROM_START( clocknch )
+/* 04 Terranean */
+ROM_START( cterrani )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "clocknch.cas", 0x0000, 0x8000, CRC(c9d163a4) SHA1(3ef55a8d8f603059e263776c08eb81f2cf18b75c) )
+	ROM_LOAD( "cterrani.cas", 0x0000, 0x8000, CRC(eb71adbc) SHA1(67becfde39c034d4b8edc2eb100050de102773da) )
 ROM_END
 
-ROM_START( ctisland )
+/* 07 Astro Fantasia */
+ROM_START( castfant )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "ctisland.cas", 0x0000, 0x8000, CRC(3f63b8f8) SHA1(2fd0679ef9750a228ebb098672ab6091fda75804) )
-
-	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
-	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
-	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
-	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
-	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
+	ROM_LOAD( "castfant.cas", 0x0000, 0x8000, CRC(6d77d1b5) SHA1(821bd65fbe887cbeac9281a2ad3f88595918f886) )
 ROM_END
 
-ROM_START( ctisland2 )
+/* 09 Super Astro Fighter */
+ROM_START( csuperas )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "ctislnd2.cas", 0x0000, 0x8000, CRC(2854b4c0) SHA1(d3b4e0031dbb2340fbbe396a1ff9b8fbfd63663e) )
-
-	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
-	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
-	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
-	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
-	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
+	ROM_LOAD( "csuperas.cas", 0x0000, 0x8000, CRC(fabcd07f) SHA1(4070c668ad6725f0710cf7fe6df0d5f80272a449) )
 ROM_END
 
-ROM_START( ctisland3 )
+/* 11 Lock'n'Chase */
+ROM_START( clocknch )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "ctislnd3.cas", 0x0000, 0x8000, CRC(45464e1e) SHA1(03275694d963c7ab0e0f5525e248e69da5f9b591) )
-
-	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
-	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
-	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
-	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
-	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
+	ROM_LOAD( "clocknch.cas", 0x0000, 0x8000, CRC(c9d163a4) SHA1(3ef55a8d8f603059e263776c08eb81f2cf18b75c) )
 ROM_END
 
-ROM_START( csuperas )
+/* 13 */
+ROM_START( cprogolf )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "csuperas.cas", 0x0000, 0x8000, CRC(fabcd07f) SHA1(4070c668ad6725f0710cf7fe6df0d5f80272a449) )
+	ROM_LOAD( "cprogolf.cas", 0x0000, 0x8000, CRC(02123cd1) SHA1(e4c630ed293725f23d539cb43beb97953558dabd) )
 ROM_END
 
-ROM_START( castfant )
+/* 15 Lucky Poker */
+ROM_START( cluckypo )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "castfant.cas", 0x0000, 0x8000, CRC(6d77d1b5) SHA1(821bd65fbe887cbeac9281a2ad3f88595918f886) )
+	ROM_LOAD( "cluckypo.cas", 0x0000, 0x8000, CRC(2070c243) SHA1(cd3af309af8eb27937756c1fe6fd0504be5aaaf5) )
 ROM_END
 
-ROM_START( cluckypo )
+/* 16 Treasure Island */
+ROM_START( ctisland )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cluckypo.cas", 0x0000, 0x8000, CRC(2070c243) SHA1(cd3af309af8eb27937756c1fe6fd0504be5aaaf5) )
+	ROM_LOAD( "ctisland.cas", 0x0000, 0x8000, CRC(3f63b8f8) SHA1(2fd0679ef9750a228ebb098672ab6091fda75804) )
+
+	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
+	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
+	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
+	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
+	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
 ROM_END
 
-ROM_START( cterrani )
+ROM_START( ctisland2 )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cterrani.cas", 0x0000, 0x8000, CRC(eb71adbc) SHA1(67becfde39c034d4b8edc2eb100050de102773da) )
+	ROM_LOAD( "ctislnd2.cas", 0x0000, 0x8000, CRC(2854b4c0) SHA1(d3b4e0031dbb2340fbbe396a1ff9b8fbfd63663e) )
+
+	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
+	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
+	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
+	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
+	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
 ROM_END
 
-ROM_START( cexplore )
+ROM_START( ctisland3 )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
-	/* The dongle data is reverse engineered by table analysis */
-	ROM_LOAD( "cexplore.pro", 0x0000, 0x0020, BAD_DUMP CRC(c7a9ac8f) SHA1(b0a566d948f71a4eddcde0dd5e9e69ca96f71c36) )
+	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cexplore.cas", 0x0000, 0x8000, CRC(fae49c66) SHA1(4ae69e2f706fdf30204f0aa1277619395cacc21b) )
+	ROM_LOAD( "ctislnd3.cas", 0x0000, 0x8000, CRC(45464e1e) SHA1(03275694d963c7ab0e0f5525e248e69da5f9b591) )
 
 	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
-	ROM_LOAD( "cexplore_overlay_roms", 0x0000, 0x4000, NO_DUMP )
+	ROM_LOAD( "deco-ti.x1",   0x0000, 0x1000, CRC(a7f8aeba) SHA1(0c9ba1a46d0636b36f40fad31638db89f374f778) )
+	ROM_LOAD( "deco-ti.x2",   0x1000, 0x1000, CRC(2a0d3c91) SHA1(552d08fcddddbea5b52fa1e8decd188ae49c86ea) )
+	ROM_LOAD( "deco-ti.x3",   0x2000, 0x1000, CRC(3a26b97c) SHA1(f57e76077806e149a9e455c85e5431eac2d42bc3) )
+	ROM_LOAD( "deco-ti.x4",   0x3000, 0x1000, CRC(1cbe43de) SHA1(8f26ad224e96c87da810c60d3dd88d415400b9fc) )
 ROM_END
 
-ROM_START( cprogolf )
+/* 18 Explorer */
+ROM_START( cexplore )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00020, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "de-0061.pro", 0x0000, 0x0020, CRC(e09ae5de) SHA1(7dec067d0739a6dad2607132641b66880a5b7751) )
+	/* The dongle data is reverse engineered by table analysis */
+	ROM_LOAD( "cexplore.pro", 0x0000, 0x0020, BAD_DUMP CRC(c7a9ac8f) SHA1(b0a566d948f71a4eddcde0dd5e9e69ca96f71c36) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cprogolf.cas", 0x0000, 0x8000, CRC(02123cd1) SHA1(e4c630ed293725f23d539cb43beb97953558dabd) )
+	ROM_LOAD( "cexplore.cas", 0x0000, 0x8000, CRC(fae49c66) SHA1(4ae69e2f706fdf30204f0aa1277619395cacc21b) )
+
+	ROM_REGION( 0x4000, "user3", 0 )	  /* roms from the overlay pcb */
+	ROM_LOAD( "cexplore_overlay_roms", 0x0000, 0x4000, NO_DUMP )
 ROM_END
 
 /* The Following use Dongle Type 2 (CS82-007)
     (dongle data differs for each game)      */
 
-ROM_START( cmissnx )
-	DECOCASS_BIOS_B_ROMS
-
-	ROM_REGION( 0x00800, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "cmissnx.pro",  0x0000, 0x0800, CRC(8a41c071) SHA1(7b16d933707bf21d25dcd11db6a6c28834b11c5b) )
-
-	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cmissnx.cas",  0x0000, 0x8000, CRC(3a094e11) SHA1(c355fe14838187cbde19a799e5c60083c82615ac) )
-ROM_END
-
+/* 19 Disco No.1 / Sweet Heart */
 ROM_START( cdiscon1 )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1100,69 +1149,86 @@
 	ROM_LOAD( "csweetht.cas", 0x0000, 0x8000, CRC(175ef706) SHA1(49b86233f69d0daf54a6e59b86e69b8159e8f6cc) )
 ROM_END
 
-ROM_START( cptennis )
+/* 20 Tornado */
+ROM_START( ctornado )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00800, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "cptennis.pro", 0x0000, 0x0800, CRC(59b8cede) SHA1(514861a652b5256a11477fc357bc01dfd87f712b) )
+	ROM_LOAD( "ctornado.pro", 0x0000, 0x0800, CRC(c9a91697) SHA1(3f7163291edbdf1a596e3cd2b7a16bbb140ffb36) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cptennis.cas", 0x0000, 0x8000, CRC(6bb257fe) SHA1(7554bf1996bc9e9c04a276aab050708d70103f54) )
+	ROM_LOAD( "ctornado.cas", 0x0000, 0x8000, CRC(e4e36ce0) SHA1(48a11823121fb2e3de31ae08e453c0124fc4f7f3) )
 ROM_END
 
-ROM_START( ctornado )
+/* 21 Mission-X */
+ROM_START( cmissnx )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x00800, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "ctornado.pro", 0x0000, 0x0800, CRC(c9a91697) SHA1(3f7163291edbdf1a596e3cd2b7a16bbb140ffb36) )
+	ROM_LOAD( "cmissnx.pro",  0x0000, 0x0800, CRC(8a41c071) SHA1(7b16d933707bf21d25dcd11db6a6c28834b11c5b) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "ctornado.cas", 0x0000, 0x8000, CRC(e4e36ce0) SHA1(48a11823121fb2e3de31ae08e453c0124fc4f7f3) )
+	ROM_LOAD( "cmissnx.cas",  0x0000, 0x8000, CRC(3a094e11) SHA1(c355fe14838187cbde19a799e5c60083c82615ac) )
 ROM_END
 
+/* 22 Pro Tennis */
+ROM_START( cptennis )
+	DECOCASS_BIOS_B_ROMS
+
+	ROM_REGION( 0x00800, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "cptennis.pro", 0x0000, 0x0800, CRC(59b8cede) SHA1(514861a652b5256a11477fc357bc01dfd87f712b) )
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "cptennis.cas", 0x0000, 0x8000, CRC(6bb257fe) SHA1(7554bf1996bc9e9c04a276aab050708d70103f54) )
+ROM_END
+
+
 /* The Following use Dongle Type 3 (unknown part number?)
     (dongle data differs for each game)      */
 
-ROM_START( cburnrub )
+/* 26 Hamburger / Burger Time */
+ROM_START( cbtime )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "cburnrub.pro",   0x0000, 0x1000, CRC(9f396832) SHA1(0e302fd094474ac792882948a018c73ce76e0759) )
+	ROM_LOAD( "cbtime.pro",   0x0000, 0x1000, CRC(25bec0f0) SHA1(9fb1f9699f37937421e26d4fb8fdbcd21a5ddc5c) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cburnrub.cas",   0x0000, 0x8000, CRC(4528ac22) SHA1(dc0fcc5e5fd21c1c858a90f43c175e36a24b3c3d) )
+	ROM_LOAD( "cbtime.cas",   0x0000, 0x8000, CRC(56d7dc58) SHA1(34b2513c9ca7ab40f532b6d6d911aa3012113632) )
 ROM_END
 
-ROM_START( cburnrub2 )
+/* 27 Burnin' Rubber / Bump 'n' Jump */
+ROM_START( cburnrub )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "cburnrub.pro",   0x0000, 0x1000, CRC(9f396832) SHA1(0e302fd094474ac792882948a018c73ce76e0759) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cburnrb2.cas",   0x0000, 0x8000, CRC(84a9ed66) SHA1(a9c536e46b89fc6b9c6271776292fed1241d2f3f) )
+	ROM_LOAD( "cburnrub.cas",   0x0000, 0x8000, CRC(4528ac22) SHA1(dc0fcc5e5fd21c1c858a90f43c175e36a24b3c3d) )
 ROM_END
 
-ROM_START( cbnj )
+ROM_START( cburnrub2 )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
 	ROM_LOAD( "cburnrub.pro",   0x0000, 0x1000, CRC(9f396832) SHA1(0e302fd094474ac792882948a018c73ce76e0759) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cbnj.cas",       0x0000, 0x8000, CRC(eed41560) SHA1(85d5df76efac33cd10427f659c4259afabb3daaf) )
+	ROM_LOAD( "cburnrb2.cas",   0x0000, 0x8000, CRC(84a9ed66) SHA1(a9c536e46b89fc6b9c6271776292fed1241d2f3f) )
 ROM_END
 
-ROM_START( cbtime )
+ROM_START( cbnj )
 	DECOCASS_BIOS_B_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "cbtime.pro",   0x0000, 0x1000, CRC(25bec0f0) SHA1(9fb1f9699f37937421e26d4fb8fdbcd21a5ddc5c) )
+	ROM_LOAD( "cburnrub.pro",   0x0000, 0x1000, CRC(9f396832) SHA1(0e302fd094474ac792882948a018c73ce76e0759) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cbtime.cas",   0x0000, 0x8000, CRC(56d7dc58) SHA1(34b2513c9ca7ab40f532b6d6d911aa3012113632) )
+	ROM_LOAD( "cbnj.cas",       0x0000, 0x8000, CRC(eed41560) SHA1(85d5df76efac33cd10427f659c4259afabb3daaf) )
 ROM_END
 
+/* 28 Graplop / Cluster Buster */
 ROM_START( cgraplop )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1183,6 +1249,7 @@
 	ROM_LOAD( "cgraplop2.cas", 0x0000, 0x8000, CRC(2e728981) SHA1(83ba90d95858d647315a1c311b8643672afea5f7) )
 ROM_END
 
+/* 29 La-Pa-Pa / Rootin' Tootin' */
 ROM_START( clapapa )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1203,16 +1270,18 @@
 	ROM_LOAD( "clapapa2.cas",  0x0000, 0x8000, CRC(069dd3c4) SHA1(5a19392c7ac5aea979187c96267e73bf5126307e) )
 ROM_END
 
-ROM_START( cfghtice )
-	DECOCASS_BIOS_B_ROMS
+/* 30 Skater */
+ROM_START( cskater )
+	DECOCASS_BIOS_A_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "cfghtice.pro", 0x0000, 0x1000, CRC(5abd27b5) SHA1(2ab1c171adffd491759036d6ce2433706654aad2) )
+	ROM_LOAD( "dp-130 a.dgl",   0x0000, 0x1000,  CRC(469e80a8) SHA1(f581cd534ce6faba010c6616538cdf9d96d787da) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "cfghtice.cas", 0x0000, 0x10000, CRC(906dd7fb) SHA1(894a7970d5476ed035edd15656e5cf10d6ddcf57) )
+	ROM_LOAD( "dt-130 a.bin",   0x0000, 0x8000,  CRC(1722e5e1) SHA1(e94066ead608df85d3f7310d4a81ba291da4bee6) )
 ROM_END
 
+/* 31 Pro Bowling */
 ROM_START( cprobowl )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1223,6 +1292,7 @@
 	ROM_LOAD( "cprobowl.cas", 0x0000, 0x8000, CRC(cb86c5e1) SHA1(66c467418cff2ed6d7c121a8b1650ee97ae48fe9) )
 ROM_END
 
+/* 32 Night Star */
 ROM_START( cnightst )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1243,6 +1313,7 @@
 	ROM_LOAD( "cnights2.cas", 0x0000, 0x8000, CRC(1a28128c) SHA1(4b620a1919d02814f734aba995115c09dc2db930) )
 ROM_END
 
+/* 33 Pro Soccer */
 ROM_START( cpsoccer )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1257,12 +1328,35 @@
 	DECOCASS_BIOS_A_ROMS
 
 	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "dp-133a.dgl", 0x0000, 0x1000,  CRC(919fabb2) SHA1(3d6a0676cea7b0be0fe69d06e04ca08c36b2851a) )
+	ROM_LOAD( "dp-133 a.dgl",   0x0000, 0x1000,  CRC(919fabb2) SHA1(3d6a0676cea7b0be0fe69d06e04ca08c36b2851a) )
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "dt-133 a.bin",   0x0000, 0x10000, CRC(de682a29) SHA1(2ee0dd8cb7fb595020d730a9da5d9cccda3f1264) )
+ROM_END
+
+/* 34 Super Doubles Tennis */
+ROM_START( csdtenis )
+	DECOCASS_BIOS_A_ROMS
+
+	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "dp-134 a.dgl",   0x0000, 0x1000,  CRC(e484d2f5) SHA1(ee4e4c221933d391aeed8ff7182fa931a4e01466) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "dt-133a.cas", 0x0000, 0x10000, CRC(de682a29) SHA1(2ee0dd8cb7fb595020d730a9da5d9cccda3f1264) )
+	ROM_LOAD( "dt-134 a.bin",   0x0000, 0x10000, CRC(9a69d961) SHA1(f88e267815ca0697708aca0ac9fa6f7664a0519c) )
 ROM_END
 
+/* 37 Zeroize */
+ROM_START( czeroize )
+	DECOCASS_BIOS_B_ROMS
+
+	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "czeroize.pro",  0x0000, 0x1000, NO_DUMP ) /* The Following have unknown Dongles (dongle data not read) */
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "czeroize.cas",   0x0000, 0x10000, CRC(3ef0a406) SHA1(645b34cd477e0bb5539c8fe937a7a2dbd8369003) )
+ROM_END
+
+/* 39 Peter Pepper's Ice Cream Factory */
 ROM_START( cppicf )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1283,9 +1377,21 @@
 	ROM_LOAD( "cppicf2.cas",   0x0000, 0x8000, CRC(78ffa1bc) SHA1(d15f2a240ae7b45885d32b5f507243f82e820d4b) )
 ROM_END
 
+/* 40 Fighting Ice Hockey */
+ROM_START( cfghtice )
+	DECOCASS_BIOS_B_ROMS
+
+	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "cfghtice.pro", 0x0000, 0x1000, CRC(5abd27b5) SHA1(2ab1c171adffd491759036d6ce2433706654aad2) )
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "cfghtice.cas", 0x0000, 0x10000, CRC(906dd7fb) SHA1(894a7970d5476ed035edd15656e5cf10d6ddcf57) )
+ROM_END
+
 /* The Following use Dongle Type 4 (unknown part number?)
     (dongle data is used for most of the graphics) */
 
+/* 38 Scrum Try */
 ROM_START( cscrtry )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1306,19 +1412,18 @@
 	ROM_LOAD( "cscrtry2.cas",  0x0000, 0x8000, CRC(04597842) SHA1(7f1fc3e06b61df880debe9056bdfbbb8600af739) )
 ROM_END
 
-ROM_START( cgsumo )
+/* 41 Oozumou - The Grand Sumo */
+ROM_START( coozumou )
 	DECOCASS_BIOS_A_ROMS
 
 	ROM_REGION( 0x08000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "dp-141a.pro",  0x0000, 0x8000, CRC(bc379d2c) SHA1(bab19dcb6d68fdbd547ebab1598353f436321157) )
+	ROM_LOAD( "dp-141 a.dgl",   0x0000, 0x8000,  CRC(bc379d2c) SHA1(bab19dcb6d68fdbd547ebab1598353f436321157) )
 
 	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "dt-141[1a]ext.bin",  0x0000, 0x10000, CRC(20c2e86a) SHA1(a18248ba00b847a09df0bea7752a21162af8af76) )
+	ROM_LOAD( "dt-141 1a.bin",  0x0000, 0x10000, CRC(20c2e86a) SHA1(a18248ba00b847a09df0bea7752a21162af8af76) )
 ROM_END
 
-/* The Following use Dongle Type 5 (unknown part number?)
-    (dongle data not read)       */
-
+/* 44 Boulder Dash */
 ROM_START( cbdash )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1331,6 +1436,7 @@
 
 /* The Following have no Dongles at all */
 
+/* 35 Flying Ball*/
 ROM_START( cflyball )
 	DECOCASS_BIOS_B_ROMS
 
@@ -1340,19 +1446,6 @@
 	ROM_LOAD( "cflyball.cas",   0x0000, 0x10000, CRC(cb40d043) SHA1(57698bac7e0d552167efa99d08116bf19a3b29c9) )
 ROM_END
 
-/* The Following have unknown Dongles
-    (dongle data not read)       */
-
-ROM_START( czeroize )
-	DECOCASS_BIOS_B_ROMS
-
-	ROM_REGION( 0x01000, "dongle", 0 )	  /* dongle data */
-	ROM_LOAD( "czeroize.pro",  0x0000, 0x1000, NO_DUMP )
-
-	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
-	ROM_LOAD( "czeroize.cas",   0x0000, 0x10000, CRC(3ef0a406) SHA1(645b34cd477e0bb5539c8fe937a7a2dbd8369003) )
-ROM_END
-
 
 static DRIVER_INIT( decocass )
 {
@@ -1443,27 +1536,27 @@
 /* 26 */ GAME( 1983, cbtime,   decocass, cbtime,   cbtime,   decocass, ROT270, "Data East Corporation", "Burger Time (DECO Cassette)", 0 )
 /* 27 */ GAME( 1982, cburnrub, decocass, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (DECO Cassette, set 1)", 0 )
 		 GAME( 1982, cburnrub2,cburnrub, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (DECO Cassette, set 2)", 0 )
-		 GAME( 1982, cbnj,     cburnrub, cbnj,     decocass, decocass, ROT270, "Data East Corporation", "Bump 'n' Jump (DECO Cassette)", 0 )
+		 GAME( 1982, cbnj,     cburnrub, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Bump 'n' Jump (DECO Cassette)", 0 )
 /* 28 */ GAME( 1983, cgraplop, decocass, cgraplop, cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (DECO Cassette, set 1)", 0 )
 		 GAME( 1983, cgraplop2,cgraplop, cgraplop2,cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (DECO Cassette, set 2)", GAME_NOT_WORKING )
 /* 29 */ GAME( 1983, clapapa,  decocass, clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' / La-Pa-Pa (DECO Cassette)" , 0) /* Displays 'La-Pa-Pa during attract */
 	     GAME( 1983, clapapa2, clapapa,  clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' (DECO Cassette)" , 0) /* Displays 'Rootin' Tootin' during attract */
-/* 30 */ // 1983.03 Skater
+/* 30 */ GAME( 1983, cskater,  decocass, cskater,  cskater,  decocass, ROT270, "Data East Corporation", "Skater (DECO Cassette, Japan)", 0 )
 /* 31 */ GAME( 1983, cprobowl, decocass, cprobowl, decocass, decocass, ROT270, "Data East Corporation", "Pro Bowling (DECO Cassette)", 0 )
 /* 32 */ GAME( 1983, cnightst, decocass, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (DECO Cassette, set 1)", 0 )
 		 GAME( 1983, cnightst2,cnightst, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (DECO Cassette, set 2)", 0 )
 /* 33 */ GAME( 1983, cpsoccer, decocass, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (DECO Cassette)", 0 )
 		 GAME( 1983, cpsoccerj,cpsoccer, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (DECO Cassette, Japan)", 0 )
-/* 34 */ // 1983.09 Super Doubles Tennis
+/* 34 */ GAME( 1983, csdtenis, decocass, csdtenis, csdtenis, decocass, ROT270, "Data East Corporation", "Super Doubles Tennis (DECO Cassette, Japan)", GAME_WRONG_COLORS )
 /* 35 */ GAME( 1985, cflyball, decocass, cflyball, decocass, decocass, ROT270, "Data East Corporation", "Flying Ball (DECO Cassette)", 0 )
 /* 36 */ // 1984.04 Genesis/Boomer Rang'r
 /* 37 */ GAME( 1983, czeroize, decocass, czeroize, decocass, decocass, ROT270, "Data East Corporation", "Zeroize (DECO Cassette)", 0 )
-/* 38 */ GAME( 1984, cscrtry,  decocass, cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 1)", 0 )
-		 GAME( 1984, cscrtry2, cscrtry,  cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 2)", 0 )
+/* 38 */ GAME( 1984, cscrtry,  decocass, type4,    cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 1)", 0 )
+		 GAME( 1984, cscrtry2, cscrtry,  type4,    cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 2)", 0 )
 /* 39 */ GAME( 1984, cppicf,   decocass, cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (DECO Cassette, set 1)", 0 )
 		 GAME( 1984, cppicf2,  cppicf,   cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (DECO Cassette, set 2)", 0 )
 /* 40 */ GAME( 1984, cfghtice, decocass, cfghtice, cfghtice, decocass, ROT270, "Data East Corporation", "Fighting Ice Hockey (DECO Cassette)", 0 )
-/* 41 */ GAME( 1984, cgsumo,   decocass, cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Oozumou - The Grand Sumo (DECO Cassette)", 0 )
+/* 41 */ GAME( 1984, coozumou, decocass, type4,    cscrtry,  decocass, ROT270, "Data East Corporation", "Oozumou - The Grand Sumo (DECO Cassette, Japan)", 0 )
 /* 42 */ // 1984.08 Hellow Gateball // not a typo, this is official spelling
 /* 43 */ // 1984.08 Yellow Cab
 /* 44 */ GAME( 1985, cbdash,   decocass, cbdash,   cbdash,   decocass, ROT270, "Data East Corporation", "Boulder Dash (DECO Cassette)", 0 )
diff -Nru src-old/mame/drivers/djmain.c src/mame/drivers/djmain.c
--- src-old/mame/drivers/djmain.c	2012-02-09 11:27:12.000000000 +0100
+++ src/mame/drivers/djmain.c	2012-03-04 18:26:17.000000000 +0100
@@ -156,29 +156,6 @@
 
 //---------
 
-static READ16_HANDLER( dual539_r )
-{
-	UINT16 ret = 0;
-
-	if (ACCESSING_BITS_0_7)
-		ret |= k054539_r(space->machine().device("konami2"), offset);
-	if (ACCESSING_BITS_8_15)
-		ret |= k054539_r(space->machine().device("konami1"), offset)<<8;
-
-	return ret;
-}
-
-static WRITE16_HANDLER( dual539_w )
-{
-	if (ACCESSING_BITS_0_7)
-		k054539_w(space->machine().device("konami2"), offset, data);
-	if (ACCESSING_BITS_8_15)
-		k054539_w(space->machine().device("konami1"), offset, data>>8);
-}
-
-
-//---------
-
 static READ32_HANDLER( obj_ctrl_r )
 {
 	djmain_state *state = space->machine().driver_data<djmain_state>();
@@ -473,7 +450,8 @@
 	AM_RANGE(0x580000, 0x58003f) AM_DEVREADWRITE("k056832", k056832_long_r, k056832_long_w)		// VIDEO REG (tilemap)
 	AM_RANGE(0x590000, 0x590007) AM_WRITE(unknown590000_w)					// ??
 	AM_RANGE(0x5a0000, 0x5a005f) AM_DEVWRITE("k055555", k055555_long_w)					// 055555: priority encoder
-	AM_RANGE(0x5b0000, 0x5b04ff) AM_READWRITE16(dual539_r, dual539_w, 0xffffffff)				// SOUND regs
+	AM_RANGE(0x5b0000, 0x5b04ff) AM_DEVREADWRITE8_MODERN("konami1", k054539_device, read, write, 0xff00ff00)
+	AM_RANGE(0x5b0000, 0x5b04ff) AM_DEVREADWRITE8_MODERN("konami2", k054539_device, read, write, 0x00ff00ff)
 	AM_RANGE(0x5c0000, 0x5c0003) AM_READ8(inp1_r, 0xffffffff)  //  DSW3,BTN3,BTN2,BTN1  // input port control (buttons and DIP switches)
 	AM_RANGE(0x5c8000, 0x5c8003) AM_READ8(inp2_r, 0xffffffff)  //  DSW1,DSW2,UNK2,UNK1  // input port control (DIP switches)
 	AM_RANGE(0x5d0000, 0x5d0003) AM_WRITE(light_ctrl_1_w)					// light/coin blocker control
@@ -1508,12 +1486,12 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_CONFIG(k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_CONFIG(k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
diff -Nru src-old/mame/drivers/dooyong.c src/mame/drivers/dooyong.c
--- src-old/mame/drivers/dooyong.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/dooyong.c	2012-03-08 08:39:27.000000000 +0100
@@ -131,14 +131,14 @@
 	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(paletteram_xxxxBBBBGGGGRRRR_le_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xd000, 0xdfff) AM_RAM_WRITE(dooyong_txvideoram8_w) AM_BASE_MEMBER(dooyong_state, m_txvideoram)
 	AM_RANGE(0xe000, 0xefff) AM_RAM
-	AM_RANGE(0xf000, 0xffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf000, 0xffff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( pollux_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xcfff) AM_RAM
-	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(dooyong_txvideoram8_w) AM_BASE_MEMBER(dooyong_state, m_txvideoram)
 	AM_RANGE(0xf000, 0xf000) AM_READ_PORT("DSWA") AM_WRITE(lastday_bankswitch_w)
 	AM_RANGE(0xf001, 0xf001) AM_READ_PORT("DSWB")
@@ -156,7 +156,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xcfff) AM_RAM
-	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(dooyong_txvideoram8_w) AM_BASE_MEMBER(dooyong_state, m_txvideoram)
 	AM_RANGE(0xf000, 0xf000) AM_READ_PORT("DSWA")
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(lastday_bankswitch_w)
@@ -187,14 +187,14 @@
 	AM_RANGE(0xc048, 0xc04f) AM_WRITE(dooyong_fgscroll8_w)
 	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(paletteram_xRRRRRGGGGGBBBBB_le_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xd000, 0xdfff) AM_RAM_WRITE(dooyong_txvideoram8_w) AM_BASE_MEMBER(dooyong_state, m_txvideoram)
-	AM_RANGE(0xe000, 0xefff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe000, 0xefff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xf000, 0xffff) AM_RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( flytiger_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
-	AM_RANGE(0xc000, 0xcfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xc000, 0xcfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xd000, 0xdfff) AM_RAM
 	AM_RANGE(0xe000, 0xe000) AM_READ_PORT("P1")
 	AM_RANGE(0xe000, 0xe000) AM_WRITE(lastday_bankswitch_w)
@@ -232,7 +232,7 @@
 	ADDRESS_MAP_GLOBAL_MASK(0xfffff)	/* super-x needs this and is similar */
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x040000, 0x04cfff) AM_RAM
-	AM_RANGE(0x04d000, 0x04dfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x04d000, 0x04dfff) AM_RAM AM_SHARE("spriteram16")
 	AM_RANGE(0x04e000, 0x04ffff) AM_RAM
 	AM_RANGE(0x0c0002, 0x0c0003) AM_READ_PORT("DSW")
 	AM_RANGE(0x0c0004, 0x0c0005) AM_READ_PORT("P1_P2")
@@ -250,7 +250,7 @@
 	ADDRESS_MAP_GLOBAL_MASK(0xfffff)
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x0d0000, 0x0dcfff) AM_RAM
-	AM_RANGE(0x0dd000, 0x0ddfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x0dd000, 0x0ddfff) AM_RAM AM_SHARE("spriteram16")
 	AM_RANGE(0x0de000, 0x0dffff) AM_RAM
 	AM_RANGE(0x080002, 0x080003) AM_READ_PORT("DSW")
 	AM_RANGE(0x080004, 0x080005) AM_READ_PORT("P1_P2")
@@ -268,7 +268,7 @@
 	ADDRESS_MAP_GLOBAL_MASK(0xfffff)
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x040000, 0x04cfff) AM_RAM
-	AM_RANGE(0x04d000, 0x04dfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x04d000, 0x04dfff) AM_RAM AM_SHARE("spriteram16")
 	AM_RANGE(0x04e000, 0x04ffff) AM_RAM
 	AM_RANGE(0x0c0002, 0x0c0003) AM_READ_PORT("DSW")
 	AM_RANGE(0x0c0004, 0x0c0005) AM_READ_PORT("P1_P2")
@@ -876,7 +876,7 @@
 
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -884,7 +884,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(lastday)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(lastday)
 	MCFG_PALETTE_LENGTH(1024)
@@ -918,7 +918,7 @@
 	MCFG_MACHINE_RESET(sound_ym2203)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -926,7 +926,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(gulfstrm)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(lastday)
 	MCFG_PALETTE_LENGTH(1024)
@@ -951,7 +951,7 @@
 	MCFG_MACHINE_RESET(sound_ym2203)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -959,7 +959,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(pollux)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(lastday)
 	MCFG_PALETTE_LENGTH(1024)
@@ -983,7 +983,7 @@
 	MCFG_MACHINE_START(lastday)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -991,7 +991,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(bluehawk)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(bluehawk)
 	MCFG_PALETTE_LENGTH(1024)
@@ -1015,7 +1015,7 @@
 	MCFG_MACHINE_START(lastday)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -1023,7 +1023,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(flytiger)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(flytiger)
 	MCFG_PALETTE_LENGTH(1024)
@@ -1053,7 +1053,6 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 0*8, 32*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(primella)
-	MCFG_SCREEN_VBLANK_STATIC(dooyong)
 
 	MCFG_GFXDECODE(primella)
 	MCFG_PALETTE_LENGTH(1024)
@@ -1087,7 +1086,7 @@
 	MCFG_CPU_PROGRAM_MAP(bluehawk_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram16")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -1095,7 +1094,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(rshark)
-	MCFG_SCREEN_VBLANK_STATIC(rshark)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram16", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(rshark)
 	MCFG_PALETTE_LENGTH(2048)
@@ -1117,7 +1116,7 @@
 	MCFG_CPU_PROGRAM_MAP(bluehawk_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram16")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -1125,7 +1124,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(rshark)
-	MCFG_SCREEN_VBLANK_STATIC(rshark)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram16", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(rshark)
 	MCFG_PALETTE_LENGTH(2048)
@@ -1147,7 +1146,7 @@
 	MCFG_CPU_PROGRAM_MAP(bluehawk_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram16")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -1155,7 +1154,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(popbingo)
-	MCFG_SCREEN_VBLANK_STATIC(rshark)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram16", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(popbingo)
 	MCFG_PALETTE_LENGTH(2048)
diff -Nru src-old/mame/drivers/dynduke.c src/mame/drivers/dynduke.c
--- src-old/mame/drivers/dynduke.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/dynduke.c	2012-03-08 08:39:27.000000000 +0100
@@ -74,7 +74,7 @@
 
 static ADDRESS_MAP_START( master_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x00000, 0x06fff) AM_RAM
-	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x08000, 0x080ff) AM_RAM AM_BASE_MEMBER(dynduke_state, m_scroll_ram)
 	AM_RANGE(0x0a000, 0x0afff) AM_RAM AM_SHARE("share1")
 	AM_RANGE(0x0b000, 0x0b001) AM_READ_PORT("P1_P2")
@@ -100,7 +100,7 @@
 /* Memory map used by DlbDyn - probably an addressing PAL is different */
 static ADDRESS_MAP_START( masterj_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x00000, 0x06fff) AM_RAM
-	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x08000, 0x087ff) AM_RAM_WRITE(dynduke_text_w) AM_BASE_MEMBER(dynduke_state, m_videoram)
 	AM_RANGE(0x09000, 0x0900d) AM_READWRITE(seibu_main_word_r, seibu_main_word_w)
 	AM_RANGE(0x0c000, 0x0c0ff) AM_RAM AM_BASE_MEMBER(dynduke_state, m_scroll_ram)
@@ -287,7 +287,7 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	// video hardware
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -295,7 +295,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(dynduke)
-	MCFG_SCREEN_VBLANK_STATIC(dynduke)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(dynduke)
 	MCFG_PALETTE_LENGTH(2048)
diff -Nru src-old/mame/drivers/exedexes.c src/mame/drivers/exedexes.c
--- src-old/mame/drivers/exedexes.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/exedexes.c	2012-03-08 08:39:27.000000000 +0100
@@ -45,7 +45,7 @@
 	AM_RANGE(0xd804, 0xd805) AM_WRITEONLY AM_BASE_MEMBER(exedexes_state, m_bg_scroll)
 	AM_RANGE(0xd807, 0xd807) AM_WRITE(exedexes_gfxctrl_w)							/* layer enables */
 	AM_RANGE(0xe000, 0xefff) AM_RAM													/* Work RAM */
-	AM_RANGE(0xf000, 0xffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	/* Sprite RAM */
+	AM_RANGE(0xf000, 0xffff) AM_RAM AM_SHARE("spriteram")	/* Sprite RAM */
 ADDRESS_MAP_END
 
 
@@ -231,7 +231,7 @@
 	MCFG_MACHINE_RESET(exedexes)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -239,7 +239,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(exedexes)
-	MCFG_SCREEN_VBLANK_STATIC(exedexes)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(exedexes)
 	MCFG_PALETTE_LENGTH(64*4+64*4+16*16+16*16)
diff -Nru src-old/mame/drivers/expro02.c src/mame/drivers/expro02.c
--- src-old/mame/drivers/expro02.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/expro02.c	2012-03-08 10:54:00.000000000 +0100
@@ -161,8 +161,6 @@
 
 	UINT16 m_vram_0_bank_num;
 	UINT16 m_vram_1_bank_num;
-	//UINT8 *m_spriteram;
-	//size_t m_spriteram_size;
 };
 
 
@@ -389,7 +387,7 @@
 
 	AM_RANGE(0x680000, 0x68001f) AM_RAM_WRITE(kaneko16_layers_0_regs_w) AM_BASE_MEMBER(expro02_state, m_layers_0_regs) // sprite regs? tileregs?
 
-	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	 // sprites? 0x72f words tested
+	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_SHARE("spriteram")	 // sprites? 0x72f words tested
 
 	AM_RANGE(0x780000, 0x78001f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(expro02_state, m_sprites_regs) // sprite regs? tileregs?
 
@@ -423,7 +421,7 @@
 	AM_RANGE(0x583000, 0x583fff) AM_RAM AM_BASE_MEMBER(expro02_state, m_vscroll[0])									//
 	AM_RANGE(0x600000, 0x600fff) AM_RAM_WRITE(galsnew_paletteram_w) AM_BASE_GENERIC(paletteram) // palette?
 	AM_RANGE(0x680000, 0x68001f) AM_RAM_WRITE(kaneko16_layers_0_regs_w) AM_BASE_MEMBER(expro02_state, m_layers_0_regs) // sprite regs? tileregs?
-	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	 // sprites? 0x72f words tested
+	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_SHARE("spriteram")	 // sprites? 0x72f words tested
 	AM_RANGE(0x780000, 0x78001f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(expro02_state, m_sprites_regs) // sprite regs? tileregs?
 	AM_RANGE(0x800000, 0x800001) AM_READ_PORT("DSW1")
 	AM_RANGE(0x800002, 0x800003) AM_READ_PORT("DSW2")
diff -Nru src-old/mame/drivers/exprraid.c src/mame/drivers/exprraid.c
--- src-old/mame/drivers/exprraid.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/exprraid.c	2012-03-07 19:42:58.000000000 +0100
@@ -439,15 +439,15 @@
 
 
 /* handler called by the 3812 emulator when the internal timers cause an IRQ */
-static void irqhandler( device_t *device, int linestate )
+static WRITE_LINE_DEVICE_HANDLER( irqhandler )
 {
-	exprraid_state *state = device->machine().driver_data<exprraid_state>();
-	device_set_input_line_and_vector(state->m_slave, 0, linestate, 0xff);
+	exprraid_state *driver_state = device->machine().driver_data<exprraid_state>();
+	device_set_input_line_and_vector(driver_state->m_slave, 0, state, 0xff);
 }
 
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_LINE(irqhandler)
 };
 
 #if 0
diff -Nru src-old/mame/drivers/fantland.c src/mame/drivers/fantland.c
--- src-old/mame/drivers/fantland.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/fantland.c	2012-03-07 19:42:58.000000000 +0100
@@ -1047,16 +1047,9 @@
 MACHINE_CONFIG_END
 
 
-
-static void wheelrun_ym3526_irqhandler( device_t *device, int state )
-{
-	fantland_state *driver = device->machine().driver_data<fantland_state>();
-	device_set_input_line(driver->m_audio_cpu, INPUT_LINE_IRQ0, state);
-}
-
 static const ym3526_interface wheelrun_ym3526_interface =
 {
-	wheelrun_ym3526_irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", INPUT_LINE_IRQ0)
 };
 
 static MACHINE_CONFIG_START( wheelrun, fantland_state )
diff -Nru src-old/mame/drivers/fuukifg3.c src/mame/drivers/fuukifg3.c
--- src-old/mame/drivers/fuukifg3.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/fuukifg3.c	2012-03-08 08:39:27.000000000 +0100
@@ -611,8 +611,6 @@
 	MCFG_MACHINE_RESET(fuuki32)
 
 	/* video hardware */
-	//MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM) // Buffered by 2 frames
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(64*8, 32*8)
diff -Nru src-old/mame/drivers/gaelco2.c src/mame/drivers/gaelco2.c
--- src-old/mame/drivers/gaelco2.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/gaelco2.c	2012-03-08 08:39:27.000000000 +0100
@@ -20,7 +20,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "cpu/m68000/m68000.h"
 #include "machine/eeprom.h"
 #include "sound/gaelco.h"
 #include "rendlay.h"
@@ -58,7 +57,7 @@
 static ADDRESS_MAP_START( maniacsq_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM																				/* ROM */
 	AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)		/* Sound Registers */
-	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)		/* Video RAM */
+	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")		/* Video RAM */
 	AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)								/* Palette */
 	AM_RANGE(0x218004, 0x218009) AM_RAM AM_BASE_MEMBER(gaelco2_state, m_vregs)														/* Video Registers */
 	AM_RANGE(0x300000, 0x300001) AM_READ_PORT("IN0")																/* DSW #1 + Input 1P */
@@ -161,7 +160,7 @@
 	MCFG_CPU_VBLANK_INT("screen", irq6_line_hold)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.1)
@@ -169,7 +168,7 @@
 	MCFG_SCREEN_SIZE(64*16, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 320-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(0x0080000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
@@ -215,7 +214,7 @@
 static ADDRESS_MAP_START( bang_map, AS_PROGRAM, 16 )
     AM_RANGE(0x000000, 0x0fffff) AM_ROM																			/* ROM */
     AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)	/* Sound Registers */
-    AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)	/* Video RAM */
+    AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")	/* Video RAM */
     AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)							/* Palette */
     AM_RANGE(0x218004, 0x218009) AM_READONLY																/* Video Registers */
 	AM_RANGE(0x218004, 0x218007) AM_WRITEONLY AM_BASE_MEMBER(gaelco2_state, m_vregs)										/* Video Registers */
@@ -294,7 +293,7 @@
 	MCFG_EEPROM_ADD("eeprom", gaelco2_eeprom_interface)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.1)
@@ -302,7 +301,7 @@
 	MCFG_SCREEN_SIZE(64*16, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 320-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(0x0200000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
@@ -433,7 +432,7 @@
 static ADDRESS_MAP_START( alighunt_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM																				/* ROM */
 	AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)		/* Sound Registers */
-	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)		/* Video RAM */
+	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")		/* Video RAM */
 	AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)								/* Palette */
 	AM_RANGE(0x218004, 0x218009) AM_RAM AM_BASE_MEMBER(gaelco2_state, m_vregs)														/* Video Registers */
 	AM_RANGE(0x300000, 0x300001) AM_READ_PORT("IN0")																/* DSW #1 + Input 1P */
@@ -535,7 +534,7 @@
 	MCFG_CPU_VBLANK_INT("screen", irq6_line_hold)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.1)
@@ -543,7 +542,7 @@
 	MCFG_SCREEN_SIZE(64*16, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 320-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(0x0400000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
@@ -644,7 +643,7 @@
 static ADDRESS_MAP_START( touchgo_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM																					/* ROM */
 	AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)			/* Sound Registers */
-	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)			/* Video RAM */
+	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")			/* Video RAM */
 	AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)									/* Palette */
 	AM_RANGE(0x218004, 0x218009) AM_RAM AM_BASE_MEMBER(gaelco2_state, m_vregs)															/* Video Registers */
 	AM_RANGE(0x300000, 0x300001) AM_READ_PORT("IN0")																	/* DSW #1 + Input 1P */
@@ -777,7 +776,7 @@
 	MCFG_CPU_VBLANK_INT("lscreen", irq6_line_hold)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 	MCFG_GFXDECODE(0x0400000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
 	MCFG_DEFAULT_LAYOUT(layout_dualhsxs)
@@ -795,7 +794,7 @@
 	MCFG_SCREEN_SIZE(64*16, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 480-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2_right)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_VIDEO_START(gaelco2_dual)
 
@@ -908,7 +907,7 @@
 static ADDRESS_MAP_START( snowboar_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM																						/* ROM */
 	AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)				/* Sound Registers */
-	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)				/* Video RAM */
+	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")				/* Video RAM */
 	AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)										/* Palette */
 	AM_RANGE(0x212000, 0x213fff) AM_RAM																						/* Extra RAM */
 	AM_RANGE(0x218004, 0x218009) AM_RAM AM_BASE_MEMBER(gaelco2_state, m_vregs)																/* Video Registers */
@@ -971,7 +970,7 @@
 	MCFG_EEPROM_ADD("eeprom", gaelco2_eeprom_interface)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.1)
@@ -979,7 +978,7 @@
 	MCFG_SCREEN_SIZE(64*16, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 384-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(0x0400000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
@@ -1093,7 +1092,7 @@
 static ADDRESS_MAP_START( wrally2_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM																			/* ROM */
 	AM_RANGE(0x202890, 0x2028ff) AM_DEVREADWRITE("gaelco", gaelcosnd_r, gaelcosnd_w)	/* Sound Registers */
-	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_BASE_SIZE_GENERIC(spriteram)	/* Video RAM */
+	AM_RANGE(0x200000, 0x20ffff) AM_RAM_WRITE(gaelco2_vram_w) AM_SHARE("spriteram")	/* Video RAM */
 	AM_RANGE(0x210000, 0x211fff) AM_RAM_WRITE(gaelco2_palette_w) AM_BASE_GENERIC(paletteram)							/* Palette */
 	AM_RANGE(0x212000, 0x213fff) AM_RAM																			/* Extra RAM */
 	AM_RANGE(0x218004, 0x218009) AM_RAM AM_BASE_MEMBER(gaelco2_state, m_vregs)													/* Video Registers */
@@ -1212,7 +1211,7 @@
 	MCFG_EEPROM_ADD("eeprom", gaelco2_eeprom_interface)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 	MCFG_GFXDECODE(0x0200000)
 	MCFG_PALETTE_LENGTH(4096*16 - 16)	/* game's palette is 4096 but we allocate 15 more for shadows & highlights */
 	MCFG_DEFAULT_LAYOUT(layout_dualhsxs)
@@ -1230,7 +1229,7 @@
 	MCFG_SCREEN_SIZE(384, 32*16)
 	MCFG_SCREEN_VISIBLE_AREA(0, 384-1, 16, 256-1)
 	MCFG_SCREEN_UPDATE_STATIC(gaelco2_right)
-	MCFG_SCREEN_VBLANK_STATIC(gaelco2)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 
 	MCFG_VIDEO_START(gaelco2_dual)
diff -Nru src-old/mame/drivers/galaxian.c src/mame/drivers/galaxian.c
--- src-old/mame/drivers/galaxian.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/galaxian.c	2012-03-11 05:21:49.000000000 +0100
@@ -1362,7 +1362,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0x0400) AM_RAM
 	AM_RANGE(0x5000, 0x53ff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x5800, 0x58ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x5800, 0x58ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x6000, 0x6000) AM_MIRROR(0x07ff) AM_READ_PORT("IN0")
 	AM_RANGE(0x6000, 0x6001) AM_MIRROR(0x07f8) AM_WRITE(start_lamp_w)
 	AM_RANGE(0x6002, 0x6002) AM_MIRROR(0x07f8) AM_WRITE(coin_lock_w)
@@ -1397,7 +1397,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x8000, 0x83ff) AM_MIRROR(0x0400) AM_RAM
 	AM_RANGE(0x9000, 0x93ff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xa000, 0xa000) AM_MIRROR(0x07ff) AM_READ_PORT("IN0")
 	AM_RANGE(0xa000, 0xa002) AM_MIRROR(0x07f8) AM_WRITE(galaxian_gfxbank_w)
 	AM_RANGE(0xa003, 0xa003) AM_MIRROR(0x07f8) AM_WRITE(coin_count_0_w)
@@ -1419,6 +1419,24 @@
 ADDRESS_MAP_END
 
 
+static ADDRESS_MAP_START( fantastc_map, AS_PROGRAM, 8 )
+	ADDRESS_MAP_UNMAP_HIGH
+	AM_RANGE(0x0000, 0x7fff) AM_ROM
+	AM_RANGE(0x8000, 0x87ff) AM_RAM
+	AM_RANGE(0x8803, 0x8803) AM_DEVWRITE("8910.0", ay8910_address_w)
+	AM_RANGE(0x880b, 0x880b) AM_DEVWRITE("8910.0", ay8910_data_w)
+	AM_RANGE(0x880c, 0x880c) AM_DEVWRITE("8910.1", ay8910_address_w)
+	AM_RANGE(0x880e, 0x880e) AM_DEVWRITE("8910.1", ay8910_data_w)
+	AM_RANGE(0x9000, 0x93ff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
+	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
+	AM_RANGE(0xa000, 0xa000) AM_MIRROR(0x07ff) AM_READ_PORT("IN0")
+	AM_RANGE(0xa800, 0xa800) AM_MIRROR(0x07ff) AM_READ_PORT("IN1")
+	AM_RANGE(0xb000, 0xb000) AM_MIRROR(0x07ff) AM_READ_PORT("IN2")
+	AM_RANGE(0xb000, 0xb000) AM_MIRROR(0x07f8) AM_WRITE(irq_enable_w)
+	AM_RANGE(0xb800, 0xb800) AM_MIRROR(0x07ff) AM_READ(watchdog_reset_r)
+	AM_RANGE(0xfffe, 0xfffe) AM_NOP //?
+ADDRESS_MAP_END
+
 
 /* map derived from schematics */
 #if 0
@@ -1429,7 +1447,7 @@
 //  AM_RANGE(0x8001, 0x8001) AM_WRITE(dambustr_bg_split_line_w)
 	AM_RANGE(0xc000, 0xc3ff) AM_MIRROR(0x0400) AM_RAM
 	AM_RANGE(0xd000, 0xd3ff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0xd800, 0xd8ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0xd800, 0xd8ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xe000, 0xe000) AM_MIRROR(0x07ff) AM_READ_PORT("IN0")
 	AM_RANGE(0xe004, 0xe007) AM_MIRROR(0x07f8) AM_WRITE(galaxian_lfo_freq_w)
 	AM_RANGE(0xe800, 0xe800) AM_MIRROR(0x07ff) AM_READ_PORT("IN1")
@@ -1451,7 +1469,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x47ff) AM_RAM
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x6801, 0x6801) AM_MIRROR(0x07f8) AM_WRITE(irq_enable_w)
 	AM_RANGE(0x6802, 0x6802) AM_MIRROR(0x07f8) AM_WRITE(coin_count_0_w)
 	AM_RANGE(0x6803, 0x6803) AM_MIRROR(0x07f8) AM_WRITE(scramble_background_enable_w)
@@ -1470,7 +1488,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x87ff) AM_MIRROR(0x4000) AM_RAM
 	AM_RANGE(0x8800, 0x8bff) AM_MIRROR(0x4400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x9000, 0x90ff) AM_MIRROR(0x4700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x9000, 0x90ff) AM_MIRROR(0x4700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x9800, 0x9803) AM_MIRROR(0x47fc) AM_DEVREADWRITE("ppi8255_0", ppi8255_r, ppi8255_w)
 	AM_RANGE(0xa000, 0xa003) AM_MIRROR(0x47fc) AM_DEVREADWRITE("ppi8255_1", ppi8255_r, ppi8255_w)
 	AM_RANGE(0xa801, 0xa801) AM_MIRROR(0x47f8) AM_WRITE(irq_enable_w)
@@ -1496,7 +1514,7 @@
 	AM_RANGE(0x1005, 0x1005) AM_MIRROR(0x01f8) //POUT2
 	AM_RANGE(0x1006, 0x1006) AM_MIRROR(0x01f8) AM_WRITE(galaxian_flip_screen_x_w)
 	AM_RANGE(0x1007, 0x1007) AM_MIRROR(0x01f8) AM_WRITE(galaxian_flip_screen_y_w)
-	AM_RANGE(0x1200, 0x12ff) AM_MIRROR(0x0100) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x1200, 0x12ff) AM_MIRROR(0x0100) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x1400, 0x1400) AM_MIRROR(0x03ff) AM_READ(watchdog_reset_r)
 	AM_RANGE(0x4000, 0xbfff) AM_ROM
 	AM_RANGE(0xc000, 0xc003) AM_MIRROR(0x3efc) AM_DEVREADWRITE("ppi8255_1", ppi8255_r, ppi8255_w)
@@ -1509,7 +1527,7 @@
 	AM_RANGE(0x0000, 0x03ff) AM_ROM
 	AM_RANGE(0x0400, 0x0bff) AM_RAM
 	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x2000, 0x20ff) AM_MIRROR(0x0300) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x2000, 0x20ff) AM_MIRROR(0x0300) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x2400, 0x2403) AM_MIRROR(0x01fc) AM_DEVREADWRITE("ppi8255_1", ppi8255_r, ppi8255_w)
 	AM_RANGE(0x2601, 0x2601) AM_MIRROR(0x01f8) AM_WRITE(irq_enable_w)
 	AM_RANGE(0x2602, 0x2602) AM_MIRROR(0x01f8) AM_WRITE(coin_count_0_w)
@@ -1532,7 +1550,7 @@
 	AM_RANGE(0x8000, 0x87ff) AM_RAM
 	AM_RANGE(0x8800, 0x8800) AM_MIRROR(0x07ff) AM_READ(watchdog_reset_r)
 	AM_RANGE(0xa800, 0xabff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0xb000, 0xb0ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0xb000, 0xb0ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xb808, 0xb808) AM_MIRROR(0x07e3) AM_WRITE(irq_enable_w)
 	AM_RANGE(0xb80c, 0xb80c) AM_MIRROR(0x07e3) AM_WRITE(galaxian_flip_screen_y_w)
 	AM_RANGE(0xb810, 0xb810) AM_MIRROR(0x07e3) AM_WRITE(galaxian_flip_screen_x_w)
@@ -1548,7 +1566,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x87ff) AM_MIRROR(0x4000) AM_RAM
 	AM_RANGE(0x9000, 0x93ff) AM_MIRROR(0x4400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x4700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x4700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xa000, 0xa000) AM_MIRROR(0x47c7) AM_WRITE(scramble_background_red_w)
 	AM_RANGE(0xa008, 0xa008) AM_MIRROR(0x47c7) AM_WRITE(irq_enable_w)
 	AM_RANGE(0xa010, 0xa010) AM_MIRROR(0x47c7) AM_WRITE(galaxian_flip_screen_y_w)
@@ -1569,7 +1587,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x47ff) AM_RAM
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x6800, 0x6800) AM_MIRROR(0x07f8) AM_WRITE(scramble_background_red_w)
 	AM_RANGE(0x6801, 0x6801) AM_MIRROR(0x07f8) AM_WRITE(irq_enable_w)
 	AM_RANGE(0x6802, 0x6802) AM_MIRROR(0x07f8) AM_WRITE(coin_count_0_w)
@@ -1598,7 +1616,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x47ff) AM_RAM
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x5000, 0x50ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0x5800, 0x5800) AM_MIRROR(0x00ff) AM_DEVWRITE("aysnd", ay8910_data_w)
 	AM_RANGE(0x5900, 0x5900) AM_MIRROR(0x00ff) AM_DEVWRITE("aysnd", ay8910_address_w)
 	AM_RANGE(0x6000, 0x6000) AM_MIRROR(0x07ff) AM_READ_PORT("IN0")
@@ -1620,7 +1638,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x8000, 0x87ff) AM_RAM
 	AM_RANGE(0x8800, 0x8bff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x9000, 0x90ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x9000, 0x90ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xa802, 0xa802) AM_MIRROR(0x07f1) AM_WRITE(galaxian_flip_screen_x_w)
 	AM_RANGE(0xa804, 0xa804) AM_MIRROR(0x07f1) AM_WRITE(irq_enable_w)
 	AM_RANGE(0xa806, 0xa806) AM_MIRROR(0x07f1) AM_WRITE(galaxian_flip_screen_y_w)
@@ -1637,7 +1655,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x83ff) AM_RAM
 	AM_RANGE(0x9000, 0x93ff) AM_MIRROR(0x0400) AM_RAM_WRITE(galaxian_videoram_w) AM_BASE_MEMBER(galaxian_state, m_videoram)
-	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x9800, 0x98ff) AM_MIRROR(0x0700) AM_RAM_WRITE(galaxian_objram_w) AM_SHARE("spriteram")
 	AM_RANGE(0xa000, 0xa000) AM_READ_PORT("IN0")
 	AM_RANGE(0xa000, 0xa000) AM_WRITE(irq_enable_w)
 	AM_RANGE(0xa001, 0xa001) AM_WRITE(galaxian_stars_enable_w)
@@ -2147,6 +2165,21 @@
 MACHINE_CONFIG_END
 
 
+static MACHINE_CONFIG_DERIVED( fantastc, galaxian_base )
+
+	/* alternate memory map */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(fantastc_map)
+
+	/* sound hardware */
+	MCFG_SOUND_ADD("8910.0", AY8910, 1789750)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+
+	MCFG_SOUND_ADD("8910.1", AY8910, 1789750)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+MACHINE_CONFIG_END
+
+
 static MACHINE_CONFIG_DERIVED( jumpbug, galaxian_base )
 
 	MCFG_WATCHDOG_VBLANK_INIT(0)
@@ -3096,6 +3129,33 @@
 }
 
 
+static DRIVER_INIT( fantastc )
+{
+	/* video extensions */
+	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, NULL, upper_extend_sprite_info);
+
+	/* decode code */
+	static const UINT16 lut_am_unscramble[32] = {
+		0, 2, 4, 6,	// ok!
+		7, 3, 5, 1,	// ok!
+		6, 0, 2, 4,	// ok!
+		1, 5, 3, 0,	// ok!
+		2, 4, 6, 3,	// good, good?, guess, guess
+		5, 6, 0, 2,	// good, good?, good?, guess
+		4, 1, 1, 5,	// good, good, guess, good
+		3, 7, 7, 7	// ok!
+	};
+
+	UINT8* romdata = machine.region("maincpu")->base();
+	assert(machine.region("maincpu")->bytes() == 0x8000);
+	UINT8 buf[0x8000];
+	memcpy(buf, romdata, 0x8000);
+
+	for (int i = 0; i < 32; i++)
+		memcpy(romdata + i * 0x400, buf + lut_am_unscramble[i] * 0x1000 + (i & 3) * 0x400, 0x400);
+}
+
+
 static DRIVER_INIT( kingball )
 {
 	galaxian_state *state = machine.driver_data<galaxian_state>();
diff -Nru src-old/mame/drivers/galdrvr.c src/mame/drivers/galdrvr.c
--- src-old/mame/drivers/galdrvr.c	2012-02-22 00:51:07.000000000 +0100
+++ src/mame/drivers/galdrvr.c	2012-03-11 05:21:49.000000000 +0100
@@ -1159,6 +1159,71 @@
 INPUT_PORTS_END
 
 
+static INPUT_PORTS_START( fantastc )
+	PORT_START("IN0")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN1 )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_2WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_2WAY
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )
+	PORT_SERVICE( 0x20, IP_ACTIVE_HIGH )
+	PORT_DIPNAME( 0x40, 0x40, "Extended Bonus Life" )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("IN1")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x00, DEF_STR( Coinage ) ) // no effect?
+	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x00, "3" )
+	PORT_DIPSETTING(    0x80, "5" )
+
+	PORT_START("IN2")
+	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Medium ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Hard ) )
+	PORT_DIPSETTING(    0x03, DEF_STR( Hardest ) )
+	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Bonus_Life ) )
+	PORT_DIPSETTING(    0x00, "20000 80000" )
+	PORT_DIPSETTING(    0x04, "30000 80000" )
+	PORT_DIPSETTING(    0x08, "20000 120000" )
+	PORT_DIPSETTING(    0x0c, "30000 120000" )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
+
+
 static INPUT_PORTS_START( tdpgal )
 	PORT_START("IN0")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
@@ -4363,6 +4428,25 @@
 	ROM_LOAD( "mmi6331.6l", 0x0000, 0x0020, CRC(6a0c7d87) SHA1(140335d85c67c75b65689d4e76d29863c209cf32) ) /* Compatible with 82s123 prom */
 ROM_END
 
+ROM_START( fantastc )
+	ROM_REGION( 0x8000, "maincpu", 0 )
+	ROM_LOAD( "f1",           0x0000, 0x1000, CRC(8019f0b7) SHA1(b0a611d1cbb92874a6534fd27c6ac57141668913) )
+	ROM_LOAD( "f2",           0x1000, 0x1000, CRC(988a9bc6) SHA1(468d483f285ed587f3be81431f22fdbaa3c221cc) )
+	ROM_LOAD( "f3",           0x2000, 0x1000, CRC(a3c0cc0b) SHA1(a1b12f1c4187d8db1b267a992db6cd297aeea1bc) )
+	ROM_LOAD( "f4",           0x3000, 0x1000, CRC(c1361be8) SHA1(5c8512747927096dd75e6095deb12dfe637f9096) )
+	ROM_LOAD( "f5",           0x4000, 0x1000, CRC(6787e93f) SHA1(4ed784ce600fc88efc4865a361f5427027d3419a) )
+	ROM_LOAD( "f6",           0x5000, 0x1000, CRC(597029ae) SHA1(38ea1348ac35bd1e6190f395ccb22f16cc30133d) )
+	ROM_LOAD( "f7",           0x6000, 0x1000, CRC(8de08d9a) SHA1(ba48a23236f2b26aa17b509daddc4b3e75424d06) )
+	ROM_LOAD( "f8",           0x7000, 0x1000, CRC(489e2fb7) SHA1(f7f641c3c6874eae0c9bb3920aa916f8b99a9285) )
+
+	ROM_REGION( 0x2000, "gfx1", 0 )
+	ROM_LOAD( "37",           0x0000, 0x1000, CRC(3a54f749) SHA1(41e3c479b268de21ae0fd4f7986eb666ee58ad83) )
+	ROM_LOAD( "38",           0x1000, 0x1000, CRC(88b71264) SHA1(60c2eb49f16b94b27625045c78c864e299b60d6b) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "prom-74g138", 0x0000, 0x0020, BAD_DUMP CRC(b7cbbc1f) SHA1(ba7c496091a3e5701a6d01423446ee89a42edcd3) ) // or different wiring?
+ROM_END
+
 ROM_START( mooncmw )
 	ROM_REGION( 0x8000, "maincpu", 0 )
 	ROM_LOAD( "60.1x",      0x0000, 0x0800, CRC(322859e6) SHA1(292dccb66c38c8de837ec3ac10928d092494958e) )
@@ -6261,6 +6345,9 @@
 /* other games on basic mooncrst hardware */
 GAME( 1982, skybase,  0,        mooncrst, skybase,  skybase,  ROT90,  "Omori Electric Co., Ltd.", "Sky Base", GAME_SUPPORTS_SAVE )
 
+/* larger romspace, 2*AY8910, based on Super Star Crest board? */
+GAME( 198?, fantastc, 0,        fantastc, fantastc, fantastc, ROT90,  "Taito do Brasil", "Fantastic", GAME_SUPPORTS_SAVE | GAME_NOT_WORKING )
+
 /* extra ROMs, protection, and sound hardware replaced with AY8910 */
 GAME( 1981, jumpbug,  0,        jumpbug,  jumpbug,  jumpbug,  ROT90,  "Hoei (Rock-Ola license)", "Jump Bug", GAME_SUPPORTS_SAVE ) // or by Alpha Denshi Co. under contract from Hoei?
 GAME( 1981, jumpbugb, jumpbug,  jumpbug,  jumpbug,  jumpbug,  ROT90,  "bootleg", "Jump Bug (bootleg)", GAME_SUPPORTS_SAVE ) // bootleg of Sega license
diff -Nru src-old/mame/drivers/galpani2.c src/mame/drivers/galpani2.c
--- src-old/mame/drivers/galpani2.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/galpani2.c	2012-03-08 10:54:00.000000000 +0100
@@ -296,7 +296,7 @@
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM AM_BASE_MEMBER(galpani2_state, m_ram)		// Work RAM
 	AM_RANGE(0x110000, 0x11000f) AM_RAM												// ? corrupted? stack dumper on POST failure, pc+sr on gp2se
 	AM_RANGE(0x300000, 0x301fff) AM_RAM												// ?
-	AM_RANGE(0x302000, 0x303fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	// Sprites
+	AM_RANGE(0x302000, 0x303fff) AM_RAM AM_SHARE("spriteram")	// Sprites
 	AM_RANGE(0x304000, 0x30401f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(galpani2_state, m_sprites_regs)	// Sprites Regs
 	AM_RANGE(0x308000, 0x308001) AM_WRITENOP										// ? 0 at startup
 	AM_RANGE(0x30c000, 0x30c001) AM_WRITENOP										// ? hblank effect ?
diff -Nru src-old/mame/drivers/galpani3.c src/mame/drivers/galpani3.c
--- src-old/mame/drivers/galpani3.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/galpani3.c	2012-03-08 10:54:00.000000000 +0100
@@ -72,6 +72,7 @@
 public:
 	galpani3_state(const machine_config &mconfig, device_type type, const char *tag)
 		: kaneko16_state(mconfig, type, tag),
+		m_sprite_bitmap_1(1024, 1024),
 		m_maincpu(*this,"maincpu")
 		{ }
 
@@ -103,10 +104,9 @@
 	UINT16* m_framebuffer1_bright1;
 	UINT16* m_framebuffer1_bright2;
 	UINT16 *m_sprregs;
-	UINT16 *m_spriteram;
-	UINT32 *m_spriteram32;
-	UINT32 *m_spc_regs;
-	bitmap_ind16 *m_sprite_bitmap_1;
+	UINT32 m_spriteram32[0x4000/4];
+	UINT32 m_spc_regs[0x40/4];
+	bitmap_ind16 m_sprite_bitmap_1;
 	UINT16 *m_mcu_ram;
 	UINT16 m_mcu_com[4];
 	int m_regs1_i;
@@ -151,11 +151,6 @@
 {
 	galpani3_state *state = machine.driver_data<galpani3_state>();
 	/* so we can use suprnova.c */
-	state->m_spriteram32 = auto_alloc_array(machine, UINT32, 0x4000/4);
-	machine.generic.spriteram_size = 0x4000;
-	state->m_spc_regs = auto_alloc_array(machine, UINT32, 0x40/4);
-
-	state->m_sprite_bitmap_1 = auto_bitmap_ind16_alloc(machine,1024,1024);
 
 	state->m_spritegen = machine.device<sknsspr_device>("spritegen");
 	state->m_spritegen->skns_sprite_kludge(0,0);
@@ -352,14 +347,14 @@
 		}
 	}
 
-	state->m_sprite_bitmap_1->fill(0x0000, cliprect);
+	state->m_sprite_bitmap_1.fill(0x0000, cliprect);
 
-	state->m_spritegen->skns_draw_sprites(screen.machine(), *state->m_sprite_bitmap_1, cliprect, state->m_spriteram32, screen.machine().generic.spriteram_size, screen.machine().region("gfx1")->base(), screen.machine().region ("gfx1")->bytes(), state->m_spc_regs );
+	state->m_spritegen->skns_draw_sprites(screen.machine(), state->m_sprite_bitmap_1, cliprect, &state->m_spriteram32[0], 0x4000, screen.machine().region("gfx1")->base(), screen.machine().region ("gfx1")->bytes(), state->m_spc_regs );
 
 	// ignoring priority bits for now..
 	for (y=0;y<240;y++)
 	{
-		src1 = &state->m_sprite_bitmap_1->pix16(y);
+		src1 = &state->m_sprite_bitmap_1.pix16(y);
 		dst =  &bitmap.pix32(y);
 
 		for (x=0;x<320;x++)
@@ -874,7 +869,7 @@
 	AM_RANGE(0x200000, 0x20ffff) AM_RAM // area [B] - Work RAM
 	AM_RANGE(0x280000, 0x287fff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w)   AM_BASE_GENERIC(paletteram) // area [A] - palette for sprites
 
-	AM_RANGE(0x300000, 0x303fff) AM_RAM_WRITE(galpani3_suprnova_sprite32_w) AM_BASE_MEMBER(galpani3_state, m_spriteram)
+	AM_RANGE(0x300000, 0x303fff) AM_RAM_WRITE(galpani3_suprnova_sprite32_w) AM_SHARE("spriteram")
 	AM_RANGE(0x380000, 0x38003f) AM_RAM_WRITE(galpani3_suprnova_sprite32regs_w) AM_BASE_MEMBER(galpani3_state, m_sprregs)
 
 	AM_RANGE(0x400000, 0x40ffff) AM_RAM AM_BASE_MEMBER(galpani3_state, m_mcu_ram) // area [C]
diff -Nru src-old/mame/drivers/gijoe.c src/mame/drivers/gijoe.c
--- src-old/mame/drivers/gijoe.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/gijoe.c	2012-03-04 18:26:17.000000000 +0100
@@ -199,7 +199,7 @@
 static ADDRESS_MAP_START( sound_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0xebff) AM_ROM
 	AM_RANGE(0xf000, 0xf7ff) AM_RAM
-	AM_RANGE(0xf800, 0xfa2f) AM_DEVREADWRITE("k054539", k054539_r, k054539_w)
+	AM_RANGE(0xf800, 0xfa2f) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
 	AM_RANGE(0xfc00, 0xfc00) AM_WRITE(soundlatch2_w)
 	AM_RANGE(0xfc02, 0xfc02) AM_READ(soundlatch_r)
 ADDRESS_MAP_END
@@ -332,8 +332,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/gng.c src/mame/drivers/gng.c
--- src-old/mame/drivers/gng.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/gng.c	2012-03-08 08:39:27.000000000 +0100
@@ -42,7 +42,7 @@
 
 static ADDRESS_MAP_START( gng_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x1dff) AM_RAM
-	AM_RANGE(0x1e00, 0x1fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x1e00, 0x1fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x2000, 0x27ff) AM_RAM_WRITE(gng_fgvideoram_w) AM_BASE_MEMBER(gng_state, m_fgvideoram)
 	AM_RANGE(0x2800, 0x2fff) AM_RAM_WRITE(gng_bgvideoram_w) AM_BASE_MEMBER(gng_state, m_bgvideoram)
 	AM_RANGE(0x3000, 0x3000) AM_READ_PORT("SYSTEM")
@@ -355,7 +355,7 @@
 	MCFG_MACHINE_RESET(gng)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.59)    /* verified on pcb */
@@ -363,7 +363,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(gng)
-	MCFG_SCREEN_VBLANK_STATIC(gng)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(gng)
 	MCFG_PALETTE_LENGTH(256)
diff -Nru src-old/mame/drivers/gottlieb.c src/mame/drivers/gottlieb.c
--- src-old/mame/drivers/gottlieb.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/gottlieb.c	2012-03-11 18:17:00.000000000 +0100
@@ -194,7 +194,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "cpu/i86/i86.h"
 #include "machine/6532riot.h"
 #include "sound/ay8910.h"
 #include "sound/dac.h"
@@ -694,6 +693,15 @@
  *
  *************************************/
 
+static WRITE8_HANDLER( gottlieb_sh_w )
+{
+	gottlieb_state *state = space->machine().driver_data<gottlieb_state>();
+	if (state->m_r1_sound != NULL)
+		state->m_r1_sound->write(*space, offset, data);
+	if (state->m_r2_sound != NULL)
+		state->m_r2_sound->write(*space, offset, data);
+}
+
 static ADDRESS_MAP_START( reactor_map, AS_PROGRAM, 8 )
 	ADDRESS_MAP_GLOBAL_MASK(0xffff)
 	AM_RANGE(0x0000, 0x1fff) AM_RAM
@@ -791,8 +799,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
 	PORT_BIT( 0xc0, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 
-	PORT_INCLUDE(gottlieb1_sound)
-
 	PORT_START("TRACKX")	/* trackball H */
 	PORT_BIT( 0xff, 0, IPT_TRACKBALL_X ) PORT_SENSITIVITY(15) PORT_KEYDELTA(20)
 
@@ -848,8 +854,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -904,8 +908,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -957,8 +959,6 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1014,8 +1014,6 @@
 
 	PORT_START("TRACKY")
 	PORT_BIT( 0xff, 0, IPT_TRACKBALL_Y ) PORT_SENSITIVITY(15) PORT_KEYDELTA(20)
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1069,8 +1067,6 @@
 
 	PORT_START("TRACKY")
 	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(5) PORT_KEYDELTA(10) PORT_CODE_DEC(KEYCODE_Z) PORT_CODE_INC(KEYCODE_X)
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1124,8 +1120,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_RIGHT ) PORT_8WAY
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_DOWN ) PORT_8WAY
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_LEFT ) PORT_8WAY
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1170,8 +1164,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 )
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1232,8 +1224,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1293,8 +1283,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT(0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_NAME("Bunt") PORT_PLAYER(1)
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb1_sound)
 INPUT_PORTS_END
 
 
@@ -1349,8 +1337,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_NAME("Start 1P") PORT_PLAYER(1)
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1405,8 +1391,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( cobram3 )
@@ -1460,8 +1444,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1507,8 +1489,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON3 )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1575,8 +1555,6 @@
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(3)
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(3)
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(3)
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1628,8 +1606,6 @@
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1682,8 +1658,6 @@
 
 	PORT_START("TRACKY")
 	PORT_BIT( 0xff, 0x00, IPT_DIAL ) PORT_SENSITIVITY(15) PORT_KEYDELTA(15) PORT_CODE_DEC(KEYCODE_Z) PORT_CODE_INC(KEYCODE_X)
-
-	PORT_INCLUDE(gottlieb2_sound)
 INPUT_PORTS_END
 
 
@@ -1739,103 +1713,6 @@
 
 /*************************************
  *
- *  Sound interfaces
- *
- *************************************/
-
-static const char *const reactor_sample_names[] =
-{
-	"*reactor",
-	"fx_53", /* "8 left" */
-	"fx_54", /* "16 left" */
-	"fx_55", /* "24 left" */
-	"fx_56", /* "32 left" */
-	"fx_57", /* "40 left" */
-	"fx_58", /* "warning, core unstable" */
-	"fx_59", /* "bonus" */
-	"fx_31", /* "chamber activated" */
-	"fx_39a", /* "2000" */
-	"fx_39b", /* "5000" */
-	"fx_39c", /* "10000" */
-	"fx_39d", /* "15000" */
-	"fx_39e", /* "20000" */
-	"fx_39f", /* "25000" */
-	"fx_39g", /* "30000" */
-	"fx_39h", /* "35000" */
-	"fx_39i", /* "40000" */
-	"fx_39j", /* "45000" */
-	"fx_39k", /* "50000" */
-	"fx_39l", /* "55000" */
-     0	/* end of array */
-};
-
-static const char *const qbert_sample_names[] =
-{
-	"*qbert",
-	"fx_17a", /* random speech, voice clock 255 */
-	"fx_17b", /* random speech, voice clock 255 */
-	"fx_17c", /* random speech, voice clock 255 */
-	"fx_17d", /* random speech, voice clock 255 */
-	"fx_17e", /* random speech, voice clock 255 */
-	"fx_17f", /* random speech, voice clock 255 */
-	"fx_17g", /* random speech, voice clock 255 */
-	"fx_17h", /* random speech, voice clock 255 */
-	"fx_18a", /* random speech, voice clock 176 */
-	"fx_18b", /* random speech, voice clock 176 */
-	"fx_18c", /* random speech, voice clock 176 */
-	"fx_18d", /* random speech, voice clock 176 */
-	"fx_18e", /* random speech, voice clock 176 */
-	"fx_18f", /* random speech, voice clock 176 */
-	"fx_18g", /* random speech, voice clock 176 */
-	"fx_18h", /* random speech, voice clock 176 */
-	"fx_19a", /* random speech, voice clock 128 */
-	"fx_19b", /* random speech, voice clock 128 */
-	"fx_19c", /* random speech, voice clock 128 */
-	"fx_19d", /* random speech, voice clock 128 */
-	"fx_19e", /* random speech, voice clock 128 */
-	"fx_19f", /* random speech, voice clock 128 */
-	"fx_19g", /* random speech, voice clock 128 */
-	"fx_19h", /* random speech, voice clock 128 */
-	"fx_20a", /* random speech, voice clock 96 */
-	"fx_20b", /* random speech, voice clock 96 */
-	"fx_20c", /* random speech, voice clock 96 */
-	"fx_20d", /* random speech, voice clock 96 */
-	"fx_20e", /* random speech, voice clock 96 */
-	"fx_20f", /* random speech, voice clock 96 */
-	"fx_20g", /* random speech, voice clock 96 */
-	"fx_20h", /* random speech, voice clock 96 */
-	"fx_21a", /* random speech, voice clock 62 */
-	"fx_21b", /* random speech, voice clock 62 */
-	"fx_21c", /* random speech, voice clock 62 */
-	"fx_21d", /* random speech, voice clock 62 */
-	"fx_21e", /* random speech, voice clock 62 */
-	"fx_21f", /* random speech, voice clock 62 */
-	"fx_21g", /* random speech, voice clock 62 */
-	"fx_21h", /* random speech, voice clock 62 */
-	"fx_22", /* EH2 with decreasing voice clock */
-	"fx_23", /* O1 with varying voice clock */
-	"fx_28",
-	"fx_36",
-	"knocker",
-	0	/* end of array */
-};
-
-static const samples_interface qbert_samples_interface =
-{
-	1,	/* one channel */
-	qbert_sample_names
-};
-
-static const samples_interface reactor_samples_interface =
-{
-	1,	/* one channel */
-	reactor_sample_names
-};
-
-
-
-/*************************************
- *
  *  Core machine drivers
  *
  *************************************/
@@ -1862,23 +1739,32 @@
 
 	MCFG_VIDEO_START(gottlieb)
 
-	/* sound hardware */
+	// basic speaker configuration
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 MACHINE_CONFIG_END
 
 
 static MACHINE_CONFIG_DERIVED( gottlieb1, gottlieb_core )
-	MCFG_FRAGMENT_ADD(gottlieb_soundrev1)
+	MCFG_GOTTLIEB_SOUND_R1_ADD("r1sound")
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_CONFIG_END
+
+
+static MACHINE_CONFIG_DERIVED( gottlieb1_votrax, gottlieb_core )
+	MCFG_GOTTLIEB_SOUND_R1_ADD_VOTRAX("r1sound")
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
 
 static MACHINE_CONFIG_DERIVED( gottlieb2, gottlieb_core )
-	MCFG_FRAGMENT_ADD(gottlieb_soundrev2)
+	MCFG_GOTTLIEB_SOUND_R2_ADD("r2sound")
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
 
 static MACHINE_CONFIG_DERIVED( g2laser, gottlieb_core )
-	MCFG_FRAGMENT_ADD(gottlieb_soundrev2)
+	MCFG_GOTTLIEB_SOUND_R2_ADD("r2sound")
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 	MCFG_LASERDISC_PR8210_ADD("laserdisc")
 	MCFG_LASERDISC_AUDIO(laserdisc_audio_delegate(FUNC(laserdisc_audio_process), device))
@@ -1892,12 +1778,15 @@
 MACHINE_CONFIG_END
 
 
+
 /*************************************
  *
  *  Specific machine drivers
  *
  *************************************/
 
+#if USE_FAKE_VOTRAX
+
 static MACHINE_CONFIG_DERIVED( reactor, gottlieb1 )
 
 	/* basic machine hardware */
@@ -1905,20 +1794,31 @@
 	MCFG_CPU_PROGRAM_MAP(reactor_map)
 
 	MCFG_DEVICE_REMOVE("nvram")
-
-	/* sound hardware */
-	MCFG_SAMPLES_ADD("samples", reactor_samples_interface)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+	MCFG_FRAGMENT_ADD(reactor_samples)
 MACHINE_CONFIG_END
 
 
 static MACHINE_CONFIG_DERIVED( qbert, gottlieb1 )
+	MCFG_FRAGMENT_ADD(qbert_samples)
+MACHINE_CONFIG_END
 
-	/* video hardware */
-	MCFG_SAMPLES_ADD("samples", qbert_samples_interface)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+#else
+
+static MACHINE_CONFIG_DERIVED( reactor, gottlieb1_votrax )
+
+	/* basic machine hardware */
+	MCFG_CPU_MODIFY("maincpu")
+	MCFG_CPU_PROGRAM_MAP(reactor_map)
+
+	MCFG_DEVICE_REMOVE("nvram")
+MACHINE_CONFIG_END
+
+
+static MACHINE_CONFIG_DERIVED( qbert, gottlieb1_votrax )
 MACHINE_CONFIG_END
 
+#endif
+
 
 static MACHINE_CONFIG_DERIVED( screwloo, gottlieb2 )
 
@@ -1926,7 +1826,8 @@
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_DERIVED( cobram3, gottlieb_core )
-	MCFG_FRAGMENT_ADD(gottlieb_cobram3_soundrev2)
+	MCFG_GOTTLIEB_SOUND_R2_ADD_COBRAM3("r2sound")
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 	MCFG_LASERDISC_PR8210_ADD("laserdisc")
 	MCFG_LASERDISC_AUDIO(laserdisc_audio_delegate(FUNC(laserdisc_audio_process), device))
@@ -1939,9 +1840,9 @@
 	MCFG_LASERDISC_SCREEN_ADD_NTSC("screen", "laserdisc")
 
 	/* sound hardware */
-	MCFG_SOUND_MODIFY("dac1")
+	MCFG_SOUND_MODIFY("r2sound:dac")
 	MCFG_SOUND_ROUTES_RESET()
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.00)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, DEVICE_SELF_OWNER, 1.00)
 MACHINE_CONFIG_END
 
 
@@ -1962,7 +1863,7 @@
 	ROM_LOAD( "rom1",         0xe000, 0x1000, CRC(944e1ddf) SHA1(6b487f1cb405e2ba9345190e8ab6022c790882c1) )
 	ROM_LOAD( "rom0",         0xf000, 0x1000, CRC(55930aed) SHA1(37ed60386935741e8cc0b8750bfcdf6f54c1bf9e) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "snd1",         0x7000, 0x800, CRC(d958a0fd) SHA1(3c383076c68a929f96d844e89b09f3075f331906) )
 	ROM_LOAD( "snd2",         0x7800, 0x800, CRC(5dc86942) SHA1(a449fcfb25521a0e7523184518b5204dac56e5f8) )
 
@@ -1983,7 +1884,7 @@
 	ROM_LOAD( "qb-rom1.bin",  0xc000, 0x2000, CRC(55635447) SHA1(ca6acdef1c9e06b33efe1f0a2df2dfb03723cfbe) )
 	ROM_LOAD( "qb-rom0.bin",  0xe000, 0x2000, CRC(8e318641) SHA1(7f8f66d1e6a7905e93cce07fc92e8801370b7194) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2004,7 +1905,7 @@
 	ROM_LOAD( "qrom_1.bin",  0xc000, 0x2000, CRC(19d924e3) SHA1(af55ecb5b650e7b069d8be67eb9a9d0f3e69e3f1) )
 	ROM_LOAD( "qrom_0.bin",  0xe000, 0x2000, CRC(2e7fad1b) SHA1(5c1feafe00c21ddddde67ab0093e847a5fc9ec2d) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2025,7 +1926,7 @@
 	ROM_LOAD( "qbj-rom1.bin", 0xc000, 0x2000, CRC(c61216e7) SHA1(e727b85dddc2963e33af6c02b675243f6fbe2710) )
 	ROM_LOAD( "qbj-rom0.bin", 0xe000, 0x2000, CRC(69679d5c) SHA1(996d45517d0c01a1952fead05dbe201dbb7dca35) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2046,7 +1947,7 @@
 	ROM_LOAD( "mqb-rom1.bin",  0xc000, 0x2000, CRC(11f0a4e4) SHA1(a805e51c40042fae209ace277abd9b35a990905b) )
 	ROM_LOAD( "mqb-rom0.bin",  0xe000, 0x2000, CRC(12a90cb2) SHA1(a33203aea79fe43d1233a16e3fdddaceac6e4a20) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "mqb-snd1.bin",  0x7000, 0x800, CRC(495ffcd2) SHA1(b2c16fffbd6af1c17fdb1a99844819e6ee0550ee) )
 	ROM_LOAD( "mqb-snd2.bin",  0x7800, 0x800, CRC(9bbaa945) SHA1(13791b69cd6f426ad77a7d0537b10012feb0bc87) )
 
@@ -2067,7 +1968,7 @@
 	ROM_LOAD( "qbtst1.bin",   0xc000, 0x2000, CRC(e97fdd78) SHA1(98dd07043a72273240c593650aa9947199347870) )
 	ROM_LOAD( "qbtst0.bin",   0xe000, 0x2000, CRC(94c9f588) SHA1(f586bcd8e6762614bed634a007508abea071754c) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2089,7 +1990,7 @@
 	ROM_LOAD( "qb-rom1.bin",  0xc000, 0x2000, CRC(55635447) SHA1(ca6acdef1c9e06b33efe1f0a2df2dfb03723cfbe) )
 	ROM_LOAD( "gv103_t-ball-test_rom0_2764.c11c12",  0xe000, 0x2000, CRC(5d390cd2) SHA1(9031926a6f6179e340b67c3a7949062b4a75e3cf) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2112,7 +2013,7 @@
 	ROM_LOAD( "rom1",         0xc000, 0x2000, CRC(706962af) SHA1(e40b567fdf6a3f7c6485808b4db45cea322c7724) )
 	ROM_LOAD( "rom0",         0xe000, 0x2000, CRC(31cee24b) SHA1(3d21f5d530cc022f9633ad487e13a664848dd3e6) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "gv106s.bin",   0x7000, 0x1000, CRC(25bcc8bc) SHA1(adf401901f1479a5bffaed85135669b1133334b4) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2134,7 +2035,7 @@
 	ROM_LOAD( "tylz.r4",         0xc000, 0x2000, CRC(657c3d2e) SHA1(9908a2dd5109e632dff38b8b4b56160615355200) )
 	ROM_LOAD( "tylz.n4",         0xe000, 0x2000, CRC(b2a15510) SHA1(15db4d1a2fb70d8111940246cd7a8ae06403cac5) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "tylz.f2",   0x7000, 0x1000, CRC(ebcedba9) SHA1(94aee8e32bdc80bbc5dc1423ca97597bdb9d808c) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2159,7 +2060,7 @@
 	ROM_LOAD( "arg_rom1_2764.c12c13",     0xc000, 0x2000, CRC(733d3d44) SHA1(03c11e89ed6906c0383dc19c0db2d21ebe69b128) )
 	ROM_LOAD( "arg_rom0_2764.c11c12",     0xe000, 0x2000, CRC(e1906355) SHA1(4735370ff0dfe381358dfa41d82fab455ec3c016) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "arg_snd1_2716.u5",  0x7000, 0x800, CRC(3a6cf455) SHA1(0c701aa4d956947a101212b494b030cd2df5a2d6) )
 	ROM_LOAD( "arg_snd2_2716.u6",  0x7800, 0x800, CRC(ddf32040) SHA1(61ae22faa013b29a5fbd9520073f172a98ca38ec) )
 
@@ -2184,7 +2085,7 @@
 
 	/* note from f205v: my original Gottlieb PCB only sports one 2732 sound EPROM labeled "snd.3h"
     It contains the two joint roms you can find herefollowing, therefore the sound is identical */
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "snd1",         0x7000, 0x0800, CRC(453193a1) SHA1(317ec81f71661eaa92624c0304a52b635dcd5613) )
 	ROM_LOAD( "snd2",         0x7800, 0x0800, CRC(f5ffc98f) SHA1(516e895df94942fc51f1b51eb9316d4296df82e7) )
 
@@ -2207,7 +2108,7 @@
 	ROM_LOAD( "mpt_rom1.bin", 0xc000, 0x2000, CRC(94d67b87) SHA1(2cbf09f0ba3b6769de90d8f61913fec3010553e2) )
 	ROM_LOAD( "mpt_rom0.bin", 0xe000, 0x2000, CRC(a9e30ad2) SHA1(39d830dda92ab5a6dbb44943be92bca0464e64e0) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "mpt_snd1.bin", 0x7000, 0x800, CRC(453193a1) SHA1(317ec81f71661eaa92624c0304a52b635dcd5613) )
 	ROM_LOAD( "mpt_snd2.bin", 0x7800, 0x800, CRC(f5ffc98f) SHA1(516e895df94942fc51f1b51eb9316d4296df82e7) )
 
@@ -2233,7 +2134,7 @@
 	ROM_LOAD( "rom1.bin",     0xc000, 0x2000, CRC(1ad956a3) SHA1(f5b74b196fe1bd9ab48336e0051cbf29c650cfc1) )
 	ROM_LOAD( "rom0.bin",     0xe000, 0x2000, CRC(a466afae) SHA1(d691cbb46e8c3b71f9b1688d7fcef36df82aa854) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "snd1.bin",     0x6000, 0x1000, CRC(dd2b30b4) SHA1(f01cb64932493bf69d4fc75a7fa809ff6f6e4263) )
 	ROM_LOAD( "snd2.bin",     0x7000, 0x1000, CRC(8cab901b) SHA1(b886532828efc8cf442e2ee4ebbfe37acd489f62) )
 
@@ -2255,7 +2156,7 @@
 	ROM_LOAD( "gv112_rom1_2764.c12c13", 0xc000, 0x2000, CRC(5b340640) SHA1(8ccad017d5b9b748327baf22ff51d30ee96cb25e) )
 	ROM_LOAD( "gv112_rom0_2764.c11c12", 0xe000, 0x2000, CRC(620dc629) SHA1(0d94b7c50ef499eb9bb3f4986a8d29547181f7ea) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "gv112_snd",              0x7000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2276,7 +2177,7 @@
 	ROM_LOAD( "qb-rom1.bin",  0xc000, 0x2000, CRC(eaf3076c) SHA1(749a87b3c40ba0a2ecd2ca962786e066daf63e30) )
 	ROM_LOAD( "qb-rom0.bin",  0xe000, 0x2000, CRC(61260a7e) SHA1(e2028a453aa34aaffa2c465f64a963504315df3c) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qb-snd1.bin",  0x7000, 0x800, CRC(15787c07) SHA1(8b7d03fbf2ebaa71b3a7e2f636a0d1bb9b796e43) )
 	ROM_LOAD( "qb-snd2.bin",  0x7800, 0x800, CRC(58437508) SHA1(09d8053e7e99679b602dcda230d64db7fe6cb7f5) )
 
@@ -2299,7 +2200,7 @@
 	ROM_LOAD( "qq-rom1.bin",  0xc000, 0x2000, CRC(63e6c43d) SHA1(9435eb06dc069e5bf1c439f0c772fef3183745b0) )
 	ROM_LOAD( "qq-rom0.bin",  0xe000, 0x2000, CRC(8ddbe438) SHA1(31112d711af5d4039491e99a0be0c088b3272482) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "qq-snd1.bin",  0x7000, 0x800, CRC(e704b450) SHA1(d509f54658e9f0264b9ab865a6f36e5423a28904) )
 	ROM_LOAD( "qq-snd2.bin",  0x7800, 0x800, CRC(c6a98bf8) SHA1(cc5b5bb5966f5d79226f1f665a3f9fc934f4ef7f) )
 
@@ -2322,7 +2223,7 @@
 	ROM_LOAD( "cb-rom-1.chp", 0xc000, 0x2000, CRC(eb1e08bd) SHA1(f558664df12e4e15ef2779a0bdf99538f8c43ca3) )
 	ROM_LOAD( "cb-rom-0.chp", 0xe000, 0x2000, CRC(401fc7e3) SHA1(86ca53cb6f1d88d5a95baa9524c6b42a1f7fc9c2) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r1sound:audiocpu", 0 )
 	ROM_LOAD( "yrom.sbd",     0x6000, 0x1000, CRC(4c313d9b) SHA1(c61a8c827f4b199fdfb6ffc0bc6cca396c73625e) )
 	ROM_LOAD( "drom.sbd",     0x7000, 0x1000, CRC(cecece88) SHA1(4c6639f6f89f80b04b6ffbb5004ea2121e71f504) )
 
@@ -2346,10 +2247,10 @@
 	ROM_LOAD( "rom1",         0xc000, 0x2000, CRC(571b65ca) SHA1(75077f4fab296b3802271fa77af588003570cde6) )
 	ROM_LOAD( "rom0",         0xe000, 0x2000, CRC(6447fe54) SHA1(6391c841cafd35dd315d9fac99ed5d8304018747) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "drom1",        0xc000, 0x2000, CRC(ae965ade) SHA1(84a690cba8990fe6406b7cfbd6ea643a48446567) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "yrom1",        0xe000, 0x2000, CRC(3719b0b5) SHA1(4f215ca2f15956374c4cd9484b6798f1c4d60fc7) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2372,10 +2273,10 @@
 	ROM_LOAD( "m3rom1.bin",   0xc000, 0x2000, CRC(3b0ba80b) SHA1(bc7e961311b40f05f2998f10f0a68f2e515c8e66) )
 	ROM_LOAD( "m3rom0.bin",   0xe000, 0x2000, CRC(70c12bf4) SHA1(c26127b6e2a16791b3be8abac93be6af4f30fb3b) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "m3drom1.bin",  0xd000, 0x1000, CRC(a6e29212) SHA1(a73aafc2efa99e9ae0aecbb6075a10f7178ac938) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "m3yrom1.bin",  0xf000, 0x1000, CRC(eddf8872) SHA1(29ed0d1828639849bab826b3e2ab4eefac45fd85) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2400,10 +2301,10 @@
 	ROM_LOAD( "bh01",   0xc000, 0x2000, CRC(7d86ab08) SHA1(26b7eb089ca3fe3f8b1531316ce8f95e33b380e5) )
 	ROM_LOAD( "bh00",   0xe000, 0x2000, CRC(c19ad038) SHA1(4d20ae70d8ad1eaa61cb91d7a0cff6932fce30d2) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "m3drom1.bin",  0xd000, 0x1000, CRC(a6e29212) SHA1(a73aafc2efa99e9ae0aecbb6075a10f7178ac938) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "bh04",   0xe000, 0x2000, CRC(c3f61bc9) SHA1(d02374e6e29238def0cfb01c96c78b206f24d77e) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2429,10 +2330,10 @@
 	ROM_LOAD( "usvs.rm1",     0xc000, 0x2000, CRC(697bc989) SHA1(ebfc0868f949e5aba1efb8fbce06f795888d8e00) )
 	ROM_LOAD( "usvs.rm0",     0xe000, 0x2000, CRC(30cf6bd9) SHA1(527ad3b96ea4a77f6d6f8a89a9215da490292297) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "usvsdrom.1",   0xc000, 0x2000, CRC(c0b5cab0) SHA1(b18e8fd9837bb52d6b3d86f2b652f6573c7cd3b3) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "usvsyrom.1",   0xe000, 0x2000, CRC(c3d245ca) SHA1(d281b139ae6c58e855b2914a24ca4bc5f8800681) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2459,10 +2360,10 @@
 	ROM_LOAD( "gv113rom.1",   0xc000, 0x2000, CRC(34ab051e) SHA1(df416aaf34d6bbbdd79ae633842355a292ed935d) )
 	ROM_LOAD( "gv113rom.0",   0xe000, 0x2000, CRC(ab124329) SHA1(de1bc721eea74426035eec10a389f77b435aa9b9) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "drom1",        0xc000, 0x2000, CRC(87a9fa10) SHA1(9c07837dce1384d6b51b716aa8ceeb5bc247a911) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "yrom2",        0xc000, 0x2000, CRC(90f9c940) SHA1(646dacc902cf235948ac9c064c92390e2764370b) )
 	ROM_LOAD( "yrom1",        0xe000, 0x2000, CRC(55f8ab30) SHA1(a6b6318f12fd4a1fab61b82cde33759da615d5b2) )
 
@@ -2486,10 +2387,10 @@
 	ROM_LOAD( "gv132_rom1_2764.c12c13",  0xc000, 0x2000, CRC(a5bf40b7) SHA1(a5a193173fa7b764706bf8d3eaaaf18c6812e436) )
 	ROM_LOAD( "gv132_rom0_2764.c11c12",  0xe000, 0x2000, CRC(2c02b598) SHA1(0c214f6625d6ef88bf89d96776683e15cf4a85c4) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "gv132_drom_snd_2764.k2",        0xc000, 0x2000, CRC(18d9d72f) SHA1(985007f49885621eb96e86dc51812983bd113550) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "gv132_yrom2_snd_2764.k3",        0xc000, 0x2000, CRC(ff59f618) SHA1(c8b2cb1ab3b69f94dd6be87da8bdfc85c6ed8707) )
 	ROM_LOAD( "gv132_yrom1_snd_2764.n3",        0xe000, 0x2000, CRC(befa4b97) SHA1(424b40844629631a3f31cc12c61ac7000b5f3eb9) )
 
@@ -2513,10 +2414,10 @@
 	ROM_LOAD( "gv110_rom1_2764.c12c13", 0xc000, 0x2000, CRC(358895b5) SHA1(38a4a27849ab491a6e3dd3415fe684d1c71c392d) )
 	ROM_LOAD( "gv110_rom0_2764.c11c12", 0xe000, 0x2000, CRC(f7157e17) SHA1(1b155602557ad173d74d4d5cf953b206b262987b) )
 
-	ROM_REGION( 0x10000, "audiocpu", 0 )
+	ROM_REGION( 0x10000, "r2sound:audiocpu", 0 )
 	ROM_LOAD( "gv110_drom1_snd_2732.k2",0xd000, 0x1000, CRC(05ca79da) SHA1(f9e9b0de02d618aeb73f7218a49b41d7b94c24a4) )
 
-	ROM_REGION( 0x10000, "speech", 0 )
+	ROM_REGION( 0x10000, "r2sound:speechcpu", 0 )
 	ROM_LOAD( "gv110_yrom1_snd_2732.n3",0xf000, 0x1000, CRC(1e3de643) SHA1(7717547c6c5b1ff178595c67f19265dc59130d90) )
 
 	ROM_REGION( 0x2000, "bgtiles", 0 )
@@ -2583,23 +2484,23 @@
  *************************************/
 
 /* games using rev 1 sound board */
-GAME( 1982, reactor,   0,        reactor,   reactor,  ramtiles, ROT0,   "Gottlieb", "Reactor", GAME_IMPERFECT_SOUND )
-GAME( 1982, qbert,     0,        qbert,     qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (US set 1)", GAME_IMPERFECT_SOUND )
-GAME( 1982, qberta,    qbert,    qbert,     qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (US set 2)", GAME_IMPERFECT_SOUND )
-GAME( 1982, qbertj,    qbert,    qbert,     qbert,    romtiles, ROT270, "Gottlieb (Konami license)", "Q*bert (Japan)", GAME_IMPERFECT_SOUND )
-GAME( 1982, myqbert,   qbert,    qbert,     qbert,    romtiles, ROT270, "Gottlieb", "Mello Yello Q*bert", GAME_IMPERFECT_SOUND )
-GAME( 1982, qberttst,  qbert,    qbert,     qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (early test version)", GAME_IMPERFECT_SOUND )
-GAME( 1982, qbtrktst,  qbert,    qbert,     qbert,    romtiles, ROT270, "Gottlieb", "Q*bert Board Input Test Rom", GAME_IMPERFECT_SOUND )
-GAME( 1982, insector,  0,        gottlieb1, insector, romtiles, ROT0,   "Gottlieb", "Insector (prototype)", 0 )
-GAME( 1982, tylz,      0,        qbert,     tylz,     romtiles, ROT0,   "Mylstar",  "Tylz (prototype)", GAME_IMPERFECT_SOUND ) // modified sound hw?
-GAME( 1984, argusg,    0,        gottlieb1, argusg,   ramtiles, ROT0,   "Gottlieb", "Argus (Gottlieb, prototype)" , 0) // aka Guardian / Protector?
-GAME( 1983, mplanets,  0,        gottlieb1, mplanets, romtiles, ROT270, "Gottlieb", "Mad Planets", 0 )
-GAME( 1983, mplanetsuk,mplanets, gottlieb1, mplanets, romtiles, ROT270, "Gottlieb (Taitel license)", "Mad Planets (UK)", 0 )
-GAME( 1983, krull,     0,        gottlieb1, krull,    ramtiles, ROT270, "Gottlieb", "Krull", 0 )
-GAME( 1983, kngtmare,  0,        gottlieb1, kngtmare, romtiles, ROT0,   "Gottlieb", "Knightmare (prototype)", GAME_NO_SOUND )
-GAME( 1983, sqbert,    0,        qbert,     qbert,    romtiles, ROT270, "Mylstar", "Faster, Harder, More Challenging Q*bert (prototype)", GAME_IMPERFECT_SOUND )
-GAME( 1983, qbertqub,  0,        qbert,     qbertqub, romtiles, ROT270, "Mylstar", "Q*bert's Qubes", GAME_IMPERFECT_SOUND )
-GAME( 1984, curvebal,  0,        gottlieb1, curvebal, romtiles, ROT270, "Mylstar", "Curve Ball", 0 )
+GAME( 1982, reactor,   0,        reactor,   		reactor,  ramtiles, ROT0,   "Gottlieb", "Reactor", GAME_IMPERFECT_SOUND )
+GAME( 1982, qbert,     0,        qbert, 			qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (US set 1)", GAME_IMPERFECT_SOUND )
+GAME( 1982, qberta,    qbert,    qbert, 			qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (US set 2)", GAME_IMPERFECT_SOUND )
+GAME( 1982, qbertj,    qbert,    qbert, 			qbert,    romtiles, ROT270, "Gottlieb (Konami license)", "Q*bert (Japan)", GAME_IMPERFECT_SOUND )
+GAME( 1982, myqbert,   qbert,    qbert, 			qbert,    romtiles, ROT270, "Gottlieb", "Mello Yello Q*bert", GAME_IMPERFECT_SOUND )
+GAME( 1982, qberttst,  qbert,    qbert, 			qbert,    romtiles, ROT270, "Gottlieb", "Q*bert (early test version)", GAME_IMPERFECT_SOUND )
+GAME( 1982, qbtrktst,  qbert,    qbert, 			qbert,    romtiles, ROT270, "Gottlieb", "Q*bert Board Input Test Rom", GAME_IMPERFECT_SOUND )
+GAME( 1982, insector,  0,        gottlieb1, 		insector, romtiles, ROT0,   "Gottlieb", "Insector (prototype)", 0 )
+GAME( 1982, tylz,      0,        gottlieb1_votrax,	tylz,     romtiles, ROT0,   "Mylstar",  "Tylz (prototype)", GAME_IMPERFECT_SOUND ) // modified sound hw?
+GAME( 1984, argusg,    0,        gottlieb1, 		argusg,   ramtiles, ROT0,   "Gottlieb", "Argus (Gottlieb, prototype)" , 0) // aka Guardian / Protector?
+GAME( 1983, mplanets,  0,        gottlieb1, 		mplanets, romtiles, ROT270, "Gottlieb", "Mad Planets", 0 )
+GAME( 1983, mplanetsuk,mplanets, gottlieb1, 		mplanets, romtiles, ROT270, "Gottlieb (Taitel license)", "Mad Planets (UK)", 0 )
+GAME( 1983, krull,     0,        gottlieb1, 		krull,    ramtiles, ROT270, "Gottlieb", "Krull", 0 )
+GAME( 1983, kngtmare,  0,        gottlieb1, 		kngtmare, romtiles, ROT0,   "Gottlieb", "Knightmare (prototype)", GAME_NO_SOUND )
+GAME( 1983, sqbert,    0,        qbert, 			qbert,    romtiles, ROT270, "Mylstar", "Faster, Harder, More Challenging Q*bert (prototype)", GAME_IMPERFECT_SOUND )
+GAME( 1983, qbertqub,  0,        qbert, 			qbertqub, romtiles, ROT270, "Mylstar", "Q*bert's Qubes", GAME_IMPERFECT_SOUND )
+GAME( 1984, curvebal,  0,        gottlieb1, 		curvebal, romtiles, ROT270, "Mylstar", "Curve Ball", 0 )
 
 /* games using rev 2 sound board */
 GAME( 1983, screwloo, 0,        screwloo,  screwloo, screwloo, ROT0,   "Mylstar", "Screw Loose (prototype)", 0 )
diff -Nru src-old/mame/drivers/hcastle.c src/mame/drivers/hcastle.c
--- src-old/mame/drivers/hcastle.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/hcastle.c	2012-03-08 08:39:27.000000000 +0100
@@ -55,9 +55,9 @@
 	AM_RANGE(0x0600, 0x06ff) AM_RAM AM_BASE_MEMBER(hcastle_state, m_paletteram)
 	AM_RANGE(0x0700, 0x1fff) AM_RAM
 	AM_RANGE(0x2000, 0x2fff) AM_RAM_WRITE(hcastle_pf1_video_w) AM_BASE_MEMBER(hcastle_state, m_pf1_videoram)
-	AM_RANGE(0x3000, 0x3fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x3000, 0x3fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x4000, 0x4fff) AM_RAM_WRITE(hcastle_pf2_video_w) AM_BASE_MEMBER(hcastle_state, m_pf2_videoram)
-	AM_RANGE(0x5000, 0x5fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0x5000, 0x5fff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0x6000, 0x7fff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
@@ -220,7 +220,8 @@
 	MCFG_MACHINE_RESET(hcastle)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram2")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59)
diff -Nru src-old/mame/drivers/hornet.c src/mame/drivers/hornet.c
--- src-old/mame/drivers/hornet.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/hornet.c	2012-03-07 21:23:54.000000000 +0100
@@ -409,7 +409,7 @@
 static SCREEN_UPDATE_RGB32( hornet_2board )
 {
 	hornet_state *state = screen.machine().driver_data<hornet_state>();
-	if (strcmp(screen.tag(), "lscreen") == 0)
+	if (strcmp(screen.tag(), ":lscreen") == 0)
 	{
 		device_t *k037122 = screen.machine().device("k037122_1");
 		device_t *voodoo = screen.machine().device("voodoo0");
@@ -418,7 +418,7 @@
 		/* TODO: tilemaps per screen */
 		k037122_tile_draw(k037122, bitmap, cliprect);
 	}
-	else if (strcmp(screen.tag(), "rscreen") == 0)
+	else if (strcmp(screen.tag(), ":rscreen") == 0)
 	{
 		device_t *k037122 = screen.machine().device("k037122_2");
 		device_t *voodoo = screen.machine().device("voodoo1");
diff -Nru src-old/mame/drivers/jchan.c src/mame/drivers/jchan.c
--- src-old/mame/drivers/jchan.c	2012-01-27 15:57:03.000000000 +0100
+++ src/mame/drivers/jchan.c	2012-03-08 10:54:00.000000000 +0100
@@ -335,7 +335,6 @@
 	state->m_sprite_ram32_1 = auto_alloc_array(machine, UINT32, 0x4000/4);
 	state->m_sprite_ram32_2 = auto_alloc_array(machine, UINT32, 0x4000/4);
 
-	machine.generic.spriteram_size = 0x4000;
 	state->m_sprite_regs32_1 = auto_alloc_array(machine, UINT32, 0x40/4);
 	state->m_sprite_regs32_2 = auto_alloc_array(machine, UINT32, 0x40/4);
 
diff -Nru src-old/mame/drivers/jrpacman.c src/mame/drivers/jrpacman.c
--- src-old/mame/drivers/jrpacman.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/jrpacman.c	2012-03-08 10:54:00.000000000 +0100
@@ -136,14 +136,14 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x47ff) AM_RAM_WRITE(jrpacman_videoram_w) AM_BASE_MEMBER(jrpacman_state, m_videoram)
 	AM_RANGE(0x4800, 0x4fef) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x503f) AM_READ_PORT("P1")
 	AM_RANGE(0x5000, 0x5000) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5003, 0x5003) AM_WRITE(pacman_flipscreen_w)
 	AM_RANGE(0x5040, 0x507f) AM_READ_PORT("P2")
 	AM_RANGE(0x5040, 0x505f) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x5070) AM_WRITE(pengo_palettebank_w)
 	AM_RANGE(0x5071, 0x5071) AM_WRITE(pengo_colortablebank_w)
 	AM_RANGE(0x5073, 0x5073) AM_WRITE(jrpacman_bgpriority_w)
diff -Nru src-old/mame/drivers/kaneko16.c src/mame/drivers/kaneko16.c
--- src-old/mame/drivers/kaneko16.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/kaneko16.c	2012-03-08 10:54:00.000000000 +0100
@@ -371,7 +371,7 @@
 static ADDRESS_MAP_START( berlwall, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM		// ROM
 	AM_RANGE(0x200000, 0x20ffff) AM_RAM		// Work RAM
-	AM_RANGE(0x30e000, 0x30ffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)		// Sprites
+	AM_RANGE(0x30e000, 0x30ffff) AM_RAM AM_SHARE("spriteram")		// Sprites
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 //  AM_RANGE(0x480000, 0x480001) AM_RAM     // ?
 	AM_RANGE(0x500000, 0x500001) AM_READWRITE(kaneko16_bg15_reg_r, kaneko16_bg15_reg_w) AM_BASE_MEMBER(kaneko16_state, m_bg15_reg)	// High Color Background
@@ -428,7 +428,7 @@
 	AM_RANGE(0x581000, 0x581fff) AM_RAM_WRITE(kaneko16_vram_2_w) AM_BASE_MEMBER(kaneko16_state, m_vram[2])	//
 	AM_RANGE(0x582000, 0x582fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[3])									//
 	AM_RANGE(0x583000, 0x583fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[2])									//
-	AM_RANGE(0x600000, 0x601fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x600000, 0x601fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x700000, 0x700fff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0x800000, 0x80001f) AM_RAM_WRITE(kaneko16_layers_0_regs_w) AM_BASE_MEMBER(kaneko16_state, m_layers_0_regs)	// Layers 0 Regs
 	AM_RANGE(0x900000, 0x90001f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(kaneko16_state, m_sprites_regs	)	// Sprites Regs
@@ -454,7 +454,7 @@
 	AM_RANGE(0x601000, 0x601fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])	//
 	AM_RANGE(0x602000, 0x602fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[1])									//
 	AM_RANGE(0x603000, 0x603fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[0])									//
-	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x700000, 0x700fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x800000, 0x80001f) AM_RAM_WRITE(kaneko16_layers_0_regs_w) AM_BASE_MEMBER(kaneko16_state, m_layers_0_regs)	// Layers 0 Regs
 	AM_RANGE(0x900000, 0x90001f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(kaneko16_state, m_sprites_regs)	// Sprites Regs #1
 	AM_RANGE(0x980000, 0x98001f) AM_RAM																				// Sprites Regs #2
@@ -514,7 +514,7 @@
 	AM_RANGE(0x2c0000, 0x2c0001) AM_WRITE(toybox_mcu_com2_w)
 	AM_RANGE(0x2d0000, 0x2d0001) AM_WRITE(toybox_mcu_com3_w)
 	AM_RANGE(0x300000, 0x30ffff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
-	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x500000, 0x500fff) AM_RAM_WRITE(kaneko16_vram_1_w) AM_BASE_MEMBER(kaneko16_state, m_vram[1])	// Layers 0
 	AM_RANGE(0x501000, 0x501fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])	//
 	AM_RANGE(0x502000, 0x502fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[1])									//
@@ -576,7 +576,7 @@
 	AM_RANGE(0x2c0000, 0x2c0001) AM_WRITE(toybox_mcu_com2_w)
 	AM_RANGE(0x2d0000, 0x2d0001) AM_WRITE(toybox_mcu_com3_w)
 	AM_RANGE(0x300000, 0x30ffff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
-	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x500000, 0x500fff) AM_RAM_WRITE(kaneko16_vram_1_w) AM_BASE_MEMBER(kaneko16_state, m_vram[1])	// Layers 0
 	AM_RANGE(0x501000, 0x501fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])	//
 	AM_RANGE(0x502000, 0x502fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[1])									//
@@ -657,7 +657,7 @@
 
 	AM_RANGE(0x300000, 0x30ffff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0x310000, 0x327fff) AM_RAM																		//
-	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)						// Sprites
+	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_SHARE("spriteram")						// Sprites
 
 	AM_RANGE(0x500000, 0x500fff) AM_RAM_WRITE(kaneko16_vram_1_w) AM_BASE_MEMBER(kaneko16_state, m_vram[1])					// Layers 0
 	AM_RANGE(0x501000, 0x501fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])					//
@@ -733,7 +733,7 @@
 
 	AM_RANGE(0x300000, 0x30ffff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0x310000, 0x327fff) AM_RAM //
-	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) // Sprites
+	AM_RANGE(0x400000, 0x401fff) AM_RAM AM_SHARE("spriteram") // Sprites
 
 	AM_RANGE(0x500000, 0x500fff) AM_RAM_WRITE(kaneko16_vram_1_w) AM_BASE_MEMBER(kaneko16_state, m_vram[1])	// Layers 0
 	AM_RANGE(0x501000, 0x501fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])	//
@@ -787,7 +787,7 @@
 	AM_RANGE(0x681000, 0x681fff) AM_RAM_WRITE(kaneko16_vram_2_w) AM_BASE_MEMBER(kaneko16_state, m_vram[2])	//
 	AM_RANGE(0x682000, 0x682fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[3])									//
 	AM_RANGE(0x683000, 0x683fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[2])									//
-	AM_RANGE(0x700000, 0x701fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x700000, 0x701fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x800000, 0x80001f) AM_RAM_WRITE(kaneko16_layers_0_regs_w) AM_BASE_MEMBER(kaneko16_state, m_layers_0_regs)	// Layers 0 Regs
 	AM_RANGE(0x900000, 0x90001f) AM_RAM_WRITE(kaneko16_sprites_regs_w) AM_BASE_MEMBER(kaneko16_state, m_sprites_regs)	// Sprites Regs
 	AM_RANGE(0xb00000, 0xb0001f) AM_RAM_WRITE(kaneko16_layers_1_regs_w) AM_BASE_MEMBER(kaneko16_state, m_layers_1_regs)	// Layers 1 Regs
@@ -849,7 +849,7 @@
 	AM_RANGE(0x380000, 0x380fff) AM_RAM_WRITE(paletteram16_xGGGGGRRRRRBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0x400000, 0x400001) AM_DEVREADWRITE8_MODERN("oki1", okim6295_device, read, write, 0x00ff)	// Samples
 	AM_RANGE(0x480000, 0x480001) AM_DEVREADWRITE8_MODERN("oki2", okim6295_device, read, write, 0x00ff)
-	AM_RANGE(0x580000, 0x581fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)					// Sprites
+	AM_RANGE(0x580000, 0x581fff) AM_RAM AM_SHARE("spriteram")					// Sprites
 	AM_RANGE(0x600000, 0x600fff) AM_RAM_WRITE(kaneko16_vram_1_w) AM_BASE_MEMBER(kaneko16_state, m_vram[1])	// Layers 0
 	AM_RANGE(0x601000, 0x601fff) AM_RAM_WRITE(kaneko16_vram_0_w) AM_BASE_MEMBER(kaneko16_state, m_vram[0])
 	AM_RANGE(0x602000, 0x602fff) AM_RAM AM_BASE_MEMBER(kaneko16_state, m_vscroll[1])
diff -Nru src-old/mame/drivers/karnov.c src/mame/drivers/karnov.c
--- src-old/mame/drivers/karnov.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/karnov.c	2012-03-08 08:39:27.000000000 +0100
@@ -367,7 +367,7 @@
 			break;
 
 		case 4: /* DM (DMA to buffer spriteram) */
-			buffer_spriteram16_w(space, 0, 0, 0xffff);
+			state->m_spriteram->copy();
 			break;
 
 		case 6: /* SECREQ (Interrupt & Data to i8751) */
@@ -430,7 +430,7 @@
 static ADDRESS_MAP_START( karnov_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
 	AM_RANGE(0x060000, 0x063fff) AM_RAM AM_BASE_MEMBER(karnov_state, m_ram)
-	AM_RANGE(0x080000, 0x080fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x080000, 0x080fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x0a0000, 0x0a07ff) AM_RAM_WRITE(karnov_videoram_w) AM_BASE_MEMBER(karnov_state, m_videoram)
 	AM_RANGE(0x0a0800, 0x0a0fff) AM_WRITE(karnov_videoram_w) /* Wndrplnt Mirror */
 	AM_RANGE(0x0a1000, 0x0a17ff) AM_WRITEONLY AM_BASE_MEMBER(karnov_state, m_pf_data)
@@ -756,15 +756,9 @@
 	device_set_input_line(device, 7, HOLD_LINE);	/* VBL */
 }
 
-static void sound_irq( device_t *device, int linestate )
-{
-	karnov_state *state = device->machine().driver_data<karnov_state>();
-	device_set_input_line(state->m_audiocpu, 0, linestate); /* IRQ */
-}
-
 static const ym3526_interface ym3526_config =
 {
-	sound_irq
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6502_IRQ_LINE)
 };
 
 /*************************************
@@ -825,7 +819,7 @@
 	MCFG_MACHINE_RESET(karnov)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -869,7 +863,7 @@
 	MCFG_MACHINE_RESET(karnov)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
diff -Nru src-old/mame/drivers/konamigq.c src/mame/drivers/konamigq.c
--- src-old/mame/drivers/konamigq.c	2012-01-28 20:33:37.000000000 +0100
+++ src/mame/drivers/konamigq.c	2012-03-04 18:26:17.000000000 +0100
@@ -191,34 +191,6 @@
 
 /* SOUND CPU */
 
-static READ16_HANDLER( dual539_r )
-{
-	UINT16 data;
-
-	data = 0;
-	if( ACCESSING_BITS_0_7 )
-	{
-		data |= k054539_r( space->machine().device("konami2"), offset );
-	}
-	if( ACCESSING_BITS_8_15 )
-	{
-		data |= k054539_r( space->machine().device("konami1"), offset ) << 8;
-	}
-	return data;
-}
-
-static WRITE16_HANDLER( dual539_w )
-{
-	if( ACCESSING_BITS_0_7 )
-	{
-		k054539_w( space->machine().device("konami2"), offset, data );
-	}
-	if( ACCESSING_BITS_8_15 )
-	{
-		k054539_w( space->machine().device("konami1"), offset, data >> 8 );
-	}
-}
-
 static READ16_HANDLER( sndcomm68k_r )
 {
 	konamigq_state *state = space->machine().driver_data<konamigq_state>();
@@ -255,7 +227,8 @@
 static ADDRESS_MAP_START( konamigq_sound_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
-	AM_RANGE(0x200000, 0x2004ff) AM_READWRITE(dual539_r,dual539_w)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami1", k054539_device, read, write, 0xff00)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami2", k054539_device, read, write, 0x00ff)
 	AM_RANGE(0x300000, 0x300001) AM_READWRITE(tms57002_data_word_r,tms57002_data_word_w)
 	AM_RANGE(0x400000, 0x40000f) AM_WRITE(sndcomm68k_w)
 	AM_RANGE(0x400010, 0x40001f) AM_READ(sndcomm68k_r)
@@ -384,13 +357,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/konamigx.c src/mame/drivers/konamigx.c
--- src-old/mame/drivers/konamigx.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/konamigx.c	2012-03-09 19:50:18.000000000 +0100
@@ -1244,26 +1244,6 @@
 /**********************************************************************************/
 /* Sound handling */
 
-static READ16_HANDLER( dual539_r )
-{
-	UINT16 ret = 0;
-
-	if (ACCESSING_BITS_0_7)
-		ret |= k054539_r(space->machine().device("konami2"), offset);
-	if (ACCESSING_BITS_8_15)
-		ret |= k054539_r(space->machine().device("konami1"), offset)<<8;
-
-	return ret;
-}
-
-static WRITE16_HANDLER( dual539_w )
-{
-	if (ACCESSING_BITS_0_7)
-		k054539_w(space->machine().device("konami2"), offset, data);
-	if (ACCESSING_BITS_8_15)
-		k054539_w(space->machine().device("konami1"), offset, data>>8);
-}
-
 static READ16_HANDLER( sndcomm68k_r )
 {
 	return sndto000[offset];
@@ -1277,32 +1257,32 @@
 
 static INTERRUPT_GEN(tms_sync)
 {
-	tms57002_sync(device);
+	downcast<tms57002_device *>(device)->sync();
 }
 
 static READ16_HANDLER(tms57002_data_word_r)
 {
-	return tms57002_data_r(space->machine().device("dasp"), 0);
+	return space->machine().device<tms57002_device>("dasp")->data_r(*space, 0);
 }
 
 static WRITE16_HANDLER(tms57002_data_word_w)
 {
 	if (ACCESSING_BITS_0_7)
-		tms57002_data_w(space->machine().device("dasp"), 0, data);
+		space->machine().device<tms57002_device>("dasp")->data_w(*space, 0, data);
 }
 
 static READ16_HANDLER(tms57002_status_word_r)
 {
-	return (tms57002_dready_r(space->machine().device("dasp"), 0) ? 4 : 0) |
-		(tms57002_empty_r(space->machine().device("dasp"), 0) ? 1 : 0);
+	return (space->machine().device<tms57002_device>("dasp")->dready_r(*space, 0) ? 4 : 0) |
+		(space->machine().device<tms57002_device>("dasp")->empty_r(*space, 0) ? 1 : 0);
 }
 
 static WRITE16_HANDLER(tms57002_control_word_w)
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		tms57002_pload_w(space->machine().device("dasp"), 0, data & 4);
-		tms57002_cload_w(space->machine().device("dasp"), 0, data & 8);
+		space->machine().device<tms57002_device>("dasp")->pload_w(*space, 0, data & 4);
+		space->machine().device<tms57002_device>("dasp")->cload_w(*space, 0, data & 8);
 		cputag_set_input_line(space->machine(), "dasp", INPUT_LINE_RESET, !(data & 16) ? ASSERT_LINE : CLEAR_LINE);
 	}
 }
@@ -1311,7 +1291,8 @@
 static ADDRESS_MAP_START( gxsndmap, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM AM_BASE(&gx_sndram)
-	AM_RANGE(0x200000, 0x2004ff) AM_READWRITE(dual539_r, dual539_w)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami1", k054539_device, read, write, 0xff00)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami2", k054539_device, read, write, 0x00ff)
 	AM_RANGE(0x300000, 0x300001) AM_READWRITE(tms57002_data_word_r, tms57002_data_word_w)
 	AM_RANGE(0x400000, 0x40000f) AM_WRITE(sndcomm68k_w)
 	AM_RANGE(0x400010, 0x40001f) AM_READ(sndcomm68k_r)
@@ -1821,13 +1802,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
@@ -3647,7 +3626,7 @@
 
 static MACHINE_RESET(konamigx)
 {
-	device_t *k054539_2 = machine.device("konami2");
+	k054539_device *k054539_2 = machine.device<k054539_device>("konami2");
 	int i;
 
 	konamigx_wrport1_0 = konamigx_wrport1_1 = 0;
@@ -3672,15 +3651,15 @@
 	if (!strcmp(machine.system().name, "tkmmpzdm"))
 	{
 		// boost voice(chip 1 channel 3-7)
-		for (i=3; i<=7; i++) k054539_set_gain(k054539_2, i, 2.0);
+		for (i=3; i<=7; i++) k054539_2->set_gain(i, 2.0);
 	}
 	else if ((!strcmp(machine.system().name, "dragoonj")) || (!strcmp(machine.system().name, "dragoona")))
 	{
 		// soften percussions(chip 1 channel 0-3), boost voice(chip 1 channel 4-7)
 		for (i=0; i<=3; i++)
 		{
-			k054539_set_gain(k054539_2, i, 0.8);
-			k054539_set_gain(k054539_2, i+4, 2.0);
+			k054539_2->set_gain(i, 0.8);
+			k054539_2->set_gain(i+4, 2.0);
 		}
 	}
 }
diff -Nru src-old/mame/drivers/ladybug.c src/mame/drivers/ladybug.c
--- src-old/mame/drivers/ladybug.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/ladybug.c	2012-03-03 22:00:34.000000000 +0100
@@ -244,10 +244,7 @@
 	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_UNUSED
-	PORT_BIT( 0x0e, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
@@ -309,14 +306,14 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_UNUSED
+	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START(LADYBUG_P2_CONTROL_PORT_TAG)
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_UNUSED PORT_COCKTAIL
+	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( snapjack )
@@ -325,7 +322,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_UNUSED
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_TILT )
@@ -335,7 +332,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	/* This should be connected to the 4V clock. I don't think the game uses it. */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
@@ -344,10 +341,7 @@
 	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2  ) PORT_UNUSED
-	PORT_BIT( 0x0e, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
@@ -433,9 +427,8 @@
 
 	PORT_START("IN2")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2 )
-	PORT_BIT( 0x0e, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
+	PORT_BIT( 0xfc, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
@@ -497,7 +490,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_UNUSED
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_TILT )
@@ -507,7 +500,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
 	/* This should be connected to the 4V clock. I don't think the game uses it. */
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	/* Note that there are TWO VBlank inputs, one is active low, the other active */
@@ -516,10 +509,7 @@
 	PORT_BIT( 0xc0, 0x40, IPT_VBLANK )
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON2 ) /* unused */
-	PORT_BIT( 0x0e, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
-	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW0")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
diff -Nru src-old/mame/drivers/lastduel.c src/mame/drivers/lastduel.c
--- src-old/mame/drivers/lastduel.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/lastduel.c	2012-03-11 18:17:00.000000000 +0100
@@ -135,7 +135,7 @@
 static ADDRESS_MAP_START( lastduel_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
 	AM_RANGE(0xfc0000, 0xfc0003) AM_WRITENOP /* Written rarely */
-	AM_RANGE(0xfc0800, 0xfc0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfc0800, 0xfc0fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xfc4000, 0xfc4001) AM_READ_PORT("P1_P2") AM_WRITE(lastduel_flip_w)
 	AM_RANGE(0xfc4002, 0xfc4003) AM_READ_PORT("SYSTEM") AM_WRITE(lastduel_sound_w)
 	AM_RANGE(0xfc4004, 0xfc4005) AM_READ_PORT("DSW1")
@@ -150,7 +150,7 @@
 
 static ADDRESS_MAP_START( madgear_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
-	AM_RANGE(0xfc1800, 0xfc1fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfc1800, 0xfc1fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xfc4000, 0xfc4001) AM_READ_PORT("DSW1") AM_WRITE(lastduel_flip_w)
 	AM_RANGE(0xfc4002, 0xfc4003) AM_READ_PORT("DSW2") AM_WRITE(lastduel_sound_w)
 	AM_RANGE(0xfc4004, 0xfc4005) AM_READ_PORT("P1_P2")
@@ -512,7 +512,7 @@
 	MCFG_MACHINE_RESET(lastduel)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -520,7 +520,9 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(lastduel)
-	MCFG_SCREEN_VBLANK_STATIC(lastduel)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
+
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_GFXDECODE(lastduel)
 	MCFG_PALETTE_LENGTH(1024)
@@ -554,7 +556,7 @@
 	MCFG_MACHINE_RESET(lastduel)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -562,7 +564,9 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(madgear)
-	MCFG_SCREEN_VBLANK_STATIC(lastduel)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
+
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_GFXDECODE(madgear)
 	MCFG_PALETTE_LENGTH(1024)
diff -Nru src-old/mame/drivers/legionna.c src/mame/drivers/legionna.c
--- src-old/mame/drivers/legionna.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/legionna.c	2012-03-08 08:39:27.000000000 +0100
@@ -88,7 +88,7 @@
 	AM_RANGE(0x102000, 0x1027ff) AM_RAM_WRITE(legionna_midground_w) AM_BASE_MEMBER(legionna_state, m_mid_data)
 	AM_RANGE(0x102800, 0x1037ff) AM_RAM_WRITE(legionna_text_w) AM_BASE_MEMBER(legionna_state, m_textram)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)	/* palette xRRRRxGGGGxBBBBx ? */
-	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x106000, 0x107fff) AM_RAM
 	AM_RANGE(0x108000, 0x11ffff) AM_RAM /* main ram */
 ADDRESS_MAP_END
@@ -102,7 +102,7 @@
 	AM_RANGE(0x101000, 0x1017ff) AM_RAM_WRITE(legionna_foreground_w) AM_BASE_MEMBER(legionna_state, m_fore_data)
 	AM_RANGE(0x101800, 0x101fff) AM_RAM_WRITE(legionna_midground_w) AM_BASE_MEMBER(legionna_state, m_mid_data)
 	AM_RANGE(0x102000, 0x102fff) AM_RAM_WRITE(legionna_text_w) AM_BASE_MEMBER(legionna_state, m_textram)
-	AM_RANGE(0x103000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x103000, 0x103fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x104000, 0x104fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x108000, 0x11ffff) AM_RAM
 ADDRESS_MAP_END
@@ -117,7 +117,7 @@
 	AM_RANGE(0x102800, 0x1037ff) AM_RAM_WRITE(legionna_text_w) AM_BASE_MEMBER(legionna_state, m_textram)
 	AM_RANGE(0x103800, 0x103fff) AM_RAM_WRITE(legionna_foreground_w) AM_BASE_MEMBER(legionna_state, m_fore_data)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x106000, 0x1067ff) AM_RAM
 	AM_RANGE(0x106800, 0x106fff) AM_RAM
 	AM_RANGE(0x107000, 0x107fff) AM_RAM /*Ani-DSP ram*/
@@ -142,7 +142,7 @@
 	AM_RANGE(0x102000, 0x1027ff) AM_RAM_WRITE(legionna_midground_w) AM_BASE_MEMBER(legionna_state, m_mid_data)
 	AM_RANGE(0x102800, 0x103fff) AM_RAM_WRITE(legionna_text_w) AM_BASE_MEMBER(legionna_state, m_textram)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM_WRITE(denjin_paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x105000, 0x105fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x106000, 0x107fff) AM_RAM
 	AM_RANGE(0x108000, 0x11dfff) AM_RAM
 	AM_RANGE(0x11e000, 0x11efff) AM_RAM
@@ -161,7 +161,7 @@
 	AM_RANGE(0x104000, 0x104fff) AM_RAM//_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x105000, 0x105fff) AM_RAM
 	AM_RANGE(0x106000, 0x106fff) AM_RAM
-	AM_RANGE(0x107000, 0x107fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x107000, 0x107fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x108000, 0x11ffff) AM_RAM
 ADDRESS_MAP_END
 
@@ -176,7 +176,7 @@
 	AM_RANGE(0x103000, 0x103fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM
 	AM_RANGE(0x105000, 0x106fff) AM_RAM
-	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x107800, 0x107fff) AM_RAM /*Ani Dsp(?) Ram*/
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM
 	AM_RANGE(0x110000, 0x119fff) AM_RAM
@@ -195,7 +195,7 @@
 	AM_RANGE(0x103000, 0x103fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM
 	AM_RANGE(0x105000, 0x106fff) AM_RAM
-	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x107800, 0x107fff) AM_RAM /*Ani Dsp(?) Ram*/
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM
 	AM_RANGE(0x110000, 0x119fff) AM_RAM
@@ -214,7 +214,7 @@
 	AM_RANGE(0x103000, 0x103fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x104000, 0x104fff) AM_RAM
 	AM_RANGE(0x105000, 0x106fff) AM_RAM
-	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x107000, 0x1077ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x107800, 0x107fff) AM_RAM /*Ani Dsp(?) Ram*/
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM
 	AM_RANGE(0x110000, 0x119fff) AM_RAM
@@ -1058,8 +1058,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -1090,8 +1088,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -1121,8 +1117,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(61)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -1152,8 +1146,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_SIZE(40*8, 32*8)
 	MCFG_SCREEN_REFRESH_RATE(61)
@@ -1183,8 +1175,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -1215,8 +1205,6 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
@@ -1255,8 +1243,6 @@
 	//MCFG_MACHINE_INIT(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
-
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
diff -Nru src-old/mame/drivers/lemmings.c src/mame/drivers/lemmings.c
--- src-old/mame/drivers/lemmings.c	2012-01-25 22:40:14.000000000 +0100
+++ src/mame/drivers/lemmings.c	2012-03-08 08:39:27.000000000 +0100
@@ -97,15 +97,15 @@
 static ADDRESS_MAP_START( lemmings_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
-	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x140000, 0x1407ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
+	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x140000, 0x1407ff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0x160000, 0x160fff) AM_RAM_WRITE(lemmings_palette_24bit_w) AM_BASE_MEMBER(lemmings_state, m_paletteram)
 	AM_RANGE(0x170000, 0x17000f) AM_RAM_WRITE(lemmings_control_w) AM_BASE_MEMBER(lemmings_state, m_control_data)
 	AM_RANGE(0x190000, 0x19000f) AM_READ(lemmings_trackball_r)
 	AM_RANGE(0x1a0000, 0x1a07ff) AM_READ(lemmings_prot_r)
 	AM_RANGE(0x1a0064, 0x1a0065) AM_WRITE(lemmings_sound_w)
-	AM_RANGE(0x1c0000, 0x1c0001) AM_WRITE(buffer_spriteram16_w) /* 1 written once a frame */
-	AM_RANGE(0x1e0000, 0x1e0001) AM_WRITE(buffer_spriteram16_2_w) /* 1 written once a frame */
+	AM_RANGE(0x1c0000, 0x1c0001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* 1 written once a frame */
+	AM_RANGE(0x1e0000, 0x1e0001) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write) /* 1 written once a frame */
 	AM_RANGE(0x200000, 0x201fff) AM_RAM_WRITE(lemmings_vram_w) AM_BASE_MEMBER(lemmings_state, m_vram_data)
 	AM_RANGE(0x202000, 0x202fff) AM_RAM
 	AM_RANGE(0x300000, 0x37ffff) AM_RAM_WRITE(lemmings_pixel_0_w) AM_BASE_MEMBER(lemmings_state, m_pixel_0_data)
@@ -276,7 +276,8 @@
 	MCFG_MACHINE_START(lemmings)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
diff -Nru src-old/mame/drivers/lethal.c src/mame/drivers/lethal.c
--- src-old/mame/drivers/lethal.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/lethal.c	2012-03-04 18:26:17.000000000 +0100
@@ -482,7 +482,7 @@
 static ADDRESS_MAP_START( le_sound, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0xefff) AM_ROM
 	AM_RANGE(0xf000, 0xf7ff) AM_RAM
-	AM_RANGE(0xf800, 0xfa2f) AM_DEVREADWRITE("k054539", k054539_r, k054539_w)
+	AM_RANGE(0xf800, 0xfa2f) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
 	AM_RANGE(0xfc00, 0xfc00) AM_WRITE(soundlatch2_w)
 	AM_RANGE(0xfc02, 0xfc02) AM_READ(soundlatch_r)
 	AM_RANGE(0xfc03, 0xfc03) AM_READNOP
@@ -686,8 +686,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/lwings.c src/mame/drivers/lwings.c
--- src-old/mame/drivers/lwings.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/lwings.c	2012-03-08 08:39:27.000000000 +0100
@@ -291,7 +291,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xddff) AM_RAM
-	AM_RANGE(0xde00, 0xdf7f) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xde00, 0xdf7f) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xdf80, 0xdfff) AM_RAM
 	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(lwings_fgvideoram_w) AM_BASE_MEMBER(lwings_state, m_fgvideoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM_WRITE(lwings_bg1videoram_w) AM_BASE_MEMBER(lwings_state, m_bg1videoram)
@@ -315,7 +315,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xddff) AM_RAM
-	AM_RANGE(0xde00, 0xdfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xde00, 0xdfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(lwings_fgvideoram_w) AM_BASE_MEMBER(lwings_state, m_fgvideoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM_WRITE(lwings_bg1videoram_w) AM_BASE_MEMBER(lwings_state, m_bg1videoram)
 	AM_RANGE(0xf000, 0xf3ff) AM_RAM_WRITE(paletteram_RRRRGGGGBBBBxxxx_split2_w) AM_BASE_GENERIC(paletteram2)
@@ -336,7 +336,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xddff) AM_RAM
-	AM_RANGE(0xde00, 0xdf7f) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xde00, 0xdf7f) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xdf80, 0xdfff) AM_RAM
 	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(lwings_fgvideoram_w) AM_BASE_MEMBER(lwings_state, m_fgvideoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM_WRITE(lwings_bg1videoram_w) AM_BASE_MEMBER(lwings_state, m_bg1videoram)
@@ -801,7 +801,7 @@
 	MCFG_MACHINE_RESET(lwings)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -809,7 +809,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 1*8, 31*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(lwings)
-	MCFG_SCREEN_VBLANK_STATIC(lwings)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(lwings)
 	MCFG_PALETTE_LENGTH(1024)
diff -Nru src-old/mame/drivers/m90.c src/mame/drivers/m90.c
--- src-old/mame/drivers/m90.c	2012-02-11 11:01:01.000000000 +0100
+++ src/mame/drivers/m90.c	2012-03-11 18:17:00.000000000 +0100
@@ -948,6 +948,24 @@
 	/* the samples are in the Z80 ROM in this bootleg */
 ROM_END
 
+ROM_START( dynablstb2 )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )
+    ROM_LOAD16_BYTE( "2.bin", 0x000001, 0x020000, CRC(9c3e996a) SHA1(9244f6a8b498d0f488bbfc68465916ea0560f3be) )
+    ROM_LOAD16_BYTE( "3.bin", 0x000000, 0x020000, CRC(697a2ed9) SHA1(d329987f7a0321414347b8e6a6dfc4304fbe4987) )
+    ROM_COPY( "maincpu", 0x3fff0,  0xffff0, 0x10 )	/* start vector */
+
+	ROM_REGION( 0x10000, "soundcpu", 0 )
+	ROM_LOAD( "db1-17.bin",    0x0000, 0x10000, CRC(e693c32f) SHA1(b6f228d26318718eedae765de9479706a3e4c38d) )
+
+	ROM_REGION( 0x100000, "gfx1", 0 )
+	ROM_LOAD( "bbm-c0.66",    0x000000, 0x40000, CRC(695d2019) SHA1(3537e9fb0e7dc13d6113b4af71cba3c73392335a) )
+	ROM_LOAD( "bbm-c1.67",    0x040000, 0x40000, CRC(4c7c8bbc) SHA1(31ab5557d96c4184a9c02ed1c309f3070d148e25) )
+	ROM_LOAD( "bbm-c2.68",    0x080000, 0x40000, CRC(0700d406) SHA1(0d43a31a726b0de0004beef41307de2508106b69) )
+	ROM_LOAD( "bbm-c3.69",    0x0c0000, 0x40000, CRC(3c3613af) SHA1(f9554a73e95102333e449f6e81f2bb817ec00881) )
+
+	ROM_REGION( 0x20000, "samples", ROMREGION_ERASE00 )	/* samples */
+	/* the samples are in the Z80 ROM in this bootleg */
+ROM_END
 
 /*
 New Dyna Blaster Global Quest
@@ -1192,7 +1210,8 @@
 GAME( 1991, dynablst, 0,        bombrman, dynablst, 0,        ROT0, "Irem (licensed from Hudson Soft)", "Dynablaster / Bomber Man", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1991, bombrman, dynablst, bombrman, bombrman, 0,        ROT0, "Irem (licensed from Hudson Soft)", "Bomber Man (Japan)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1991, atompunk, dynablst, bombrman, atompunk, 0,        ROT0, "Irem America (licensed from Hudson Soft)", "Atomic Punk (US)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
-GAME( 1991, dynablstb,dynablst, dynablsb, dynablsb, 0,        ROT0, "bootleg", "Dynablaster / Bomber Man (bootleg)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1991, dynablstb,dynablst, dynablsb, dynablsb, 0,        ROT0, "bootleg (Seitu)", "Dynablaster / Bomber Man (bootleg)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1991, dynablstb2,dynablst,dynablsb, dynablsb, 0,        ROT0, "bootleg (Seitu)", "Dynablaster / Bomber Man (bootleg, alt)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1992, bbmanw,   0,        bbmanw,   bbmanw,   0,        ROT0, "Irem", "Bomber Man World / New Dyna Blaster - Global Quest", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1992, bbmanwj,  bbmanw,   bbmanwj,  bbmanwj,  0,        ROT0, "Irem", "Bomber Man World (Japan)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1992, newapunk, bbmanw,   bbmanw,   bbmanwj,  0,        ROT0, "Irem America", "New Atomic Punk - Global Quest (US)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/m92.c src/mame/drivers/m92.c
--- src-old/mame/drivers/m92.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/m92.c	2012-03-08 08:39:27.000000000 +0100
@@ -338,7 +338,7 @@
 	AM_RANGE(0x00000, 0x7ffff) AM_ROM
 	AM_RANGE(0x80000, 0x8ffff) AM_RAM_WRITE(m92_vram_w) AM_BASE_MEMBER(m92_state, m_vram_data)
 	AM_RANGE(0xe0000, 0xeffff) AM_RAM /* System ram */
-	AM_RANGE(0xf8000, 0xf87ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf8000, 0xf87ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xf8800, 0xf8fff) AM_READWRITE(m92_paletteram_r, m92_paletteram_w)
 	AM_RANGE(0xf9000, 0xf900f) AM_WRITE(m92_spritecontrol_w) AM_BASE_MEMBER(m92_state, m_spritecontrol)
 	AM_RANGE(0xf9800, 0xf9801) AM_WRITE(m92_videocontrol_w)
@@ -351,7 +351,7 @@
 	AM_RANGE(0xc0000, 0xcffff) AM_ROM AM_REGION("maincpu", 0x00000)	/* Mirror used by In The Hunt as protection */
 	AM_RANGE(0xd0000, 0xdffff) AM_RAM_WRITE(m92_vram_w) AM_BASE_MEMBER(m92_state, m_vram_data)
 	AM_RANGE(0xe0000, 0xeffff) AM_RAM /* System ram */
-	AM_RANGE(0xf8000, 0xf87ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf8000, 0xf87ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xf8800, 0xf8fff) AM_READWRITE(m92_paletteram_r, m92_paletteram_w)
 	AM_RANGE(0xf9000, 0xf900f) AM_WRITE(m92_spritecontrol_w) AM_BASE_MEMBER(m92_state, m_spritecontrol)
 	AM_RANGE(0xf9800, 0xf9801) AM_WRITE(m92_videocontrol_w)
@@ -912,7 +912,7 @@
 	MCFG_TIMER_ADD_SCANLINE("scantimer", m92_scanline_interrupt, "screen", 0, 1)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -998,7 +998,7 @@
 	MCFG_TIMER_ADD_SCANLINE("scantimer", m92_scanline_interrupt, "screen", 0, 1)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM) // not really...
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram") // not really...
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
diff -Nru src-old/mame/drivers/mainevt.c src/mame/drivers/mainevt.c
--- src-old/mame/drivers/mainevt.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/mainevt.c	2012-03-05 15:02:18.000000000 +0100
@@ -446,7 +446,7 @@
 	mainevt_state *state = device->machine().driver_data<mainevt_state>();
 
 	if(state->m_sound_irq_mask)
-		device_set_input_line(device, 0, HOLD_LINE);
+		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
 }
 
 static INTERRUPT_GEN( devstors_sound_timer_irq )
@@ -454,7 +454,7 @@
 	mainevt_state *state = device->machine().driver_data<mainevt_state>();
 
 	if(state->m_sound_irq_mask)
-		device_set_input_line(device, INPUT_LINE_NMI, PULSE_LINE);
+		device_set_input_line(device, 0, HOLD_LINE);
 }
 
 static MACHINE_CONFIG_START( mainevt, mainevt_state )
diff -Nru src-old/mame/drivers/matmania.c src/mame/drivers/matmania.c
--- src-old/mame/drivers/matmania.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/matmania.c	2012-03-07 19:42:58.000000000 +0100
@@ -350,17 +350,9 @@
 MACHINE_CONFIG_END
 
 
-
-/* handler called by the 3526 emulator when the internal timers cause an IRQ */
-static void irqhandler(device_t *device, int linestate)
-{
-	matmania_state *state = device->machine().driver_data<matmania_state>();
-	device_set_input_line(state->m_audiocpu, 1, linestate);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6809_FIRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/mcr.c src/mame/drivers/mcr.c
--- src-old/mame/drivers/mcr.c	2012-02-22 00:51:07.000000000 +0100
+++ src/mame/drivers/mcr.c	2012-03-08 10:54:00.000000000 +0100
@@ -283,10 +283,6 @@
 
 
 #include "emu.h"
-#include "cpu/z80/z80.h"
-#include "machine/z80ctc.h"
-#include "machine/z80pio.h"
-#include "machine/z80sio.h"
 #include "audio/mcr.h"
 #include "sound/samples.h"
 #include "machine/nvram.h"
@@ -644,7 +640,7 @@
 	ADDRESS_MAP_UNMAP_HIGH
 	AM_RANGE(0x0000, 0x6fff) AM_ROM
 	AM_RANGE(0x7000, 0x77ff) AM_MIRROR(0x0800) AM_RAM AM_SHARE("nvram")
-	AM_RANGE(0xf000, 0xf1ff) AM_MIRROR(0x0200) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf000, 0xf1ff) AM_MIRROR(0x0200) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xf400, 0xf41f) AM_MIRROR(0x03e0) AM_WRITE(paletteram_xxxxRRRRBBBBGGGG_split1_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xf800, 0xf81f) AM_MIRROR(0x03e0) AM_WRITE(paletteram_xxxxRRRRBBBBGGGG_split2_w) AM_BASE_GENERIC(paletteram2)
 	AM_RANGE(0xfc00, 0xffff) AM_RAM_WRITE(mcr_90009_videoram_w) AM_BASE_MEMBER(mcr_state, m_videoram)
@@ -673,7 +669,7 @@
 	ADDRESS_MAP_UNMAP_HIGH
 	AM_RANGE(0x0000, 0xbfff) AM_ROM
 	AM_RANGE(0xc000, 0xc7ff) AM_MIRROR(0x1800) AM_RAM AM_SHARE("nvram")
-	AM_RANGE(0xe000, 0xe1ff) AM_MIRROR(0x1600) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe000, 0xe1ff) AM_MIRROR(0x1600) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe800, 0xefff) AM_MIRROR(0x1000) AM_RAM_WRITE(mcr_90010_videoram_w) AM_BASE_MEMBER(mcr_state, m_videoram)
 ADDRESS_MAP_END
 
@@ -700,7 +696,7 @@
 	ADDRESS_MAP_UNMAP_HIGH
 	AM_RANGE(0x0000, 0xdfff) AM_ROM
 	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("nvram")
-	AM_RANGE(0xe800, 0xe9ff) AM_MIRROR(0x0200) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe800, 0xe9ff) AM_MIRROR(0x0200) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(mcr_91490_videoram_w) AM_BASE_MEMBER(mcr_state, m_videoram)
 	AM_RANGE(0xf800, 0xf87f) AM_MIRROR(0x0780) AM_WRITE(mcr_91490_paletteram_w) AM_BASE_GENERIC(paletteram)
 ADDRESS_MAP_END
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2012-02-23 05:39:44.000000000 +0100
+++ src/mame/drivers/mediagx.c	2012-02-29 18:52:13.000000000 +0100
@@ -62,33 +62,6 @@
     74F244 (x2, SOIC20)
     ST ULN2064B (DIP16)
 
-Notes related to Area 51: Site 4 from:
-http://www.mameworld.info/ubbthreads/showthreaded.php?Cat=&Number=276606
-
-Regarding the (a51site4a.chd)
-
-I own a dedicated cab and have sold HD replacements that use an SD card and
-IDE adapter.  So I have done some research and have purchased enough board sets
-and HD's that I have some idea what I'm talking about.  Anyhoo, The currently
-supported image is Rev. 2.01 as is still sold by happ.  The only difference
-between the current MAME chd and a fresh Happ HD is that the MAME chd has had
-it's serial # cleared, but it STILL has statistical data saved. IE. credits
-inserted, games played, play times, etc...  I know it's that version by the size
-of the CHD. I have compressed several STOCK HD's including my own and they all are
-the same size.  The only HD that I have compressed that was the same as the currently
-supported chd was a happ replacement HD.  So in conclusion, There are two different
-versions of the Area 51 Site 4 HD one that was shipped in dedicated cabs dated
-Sep. 11 1998 and another Rev. 2.01 dated Sep. 7 1998 for whatever reason I cannot say.
-
-I do have clean copies of both in chd format, stripped of ALL statistical info. but
-they still retain their serial #'s.  BTW: I did use chdman to copy the currently
-supported chd to a card and put it in my cab just to clear all the stats and make a clean
-copy as it should be.  Also, Just to be clear the size of the chd is not determined by
-the original HD as I'm talking about their size after using chdman to put them onto a
-SD card and then using chdman to make a chd from the SD card. They are different sizes!
-
--ninjakid
-
 */
 
 #include "emu.h"
@@ -1358,7 +1331,7 @@
 	DISK_IMAGE( "a51site4", 0, SHA1(48496666d1613700ae9274f9a5361ea5bbaebea0) )
 ROM_END
 
-ROM_START( a51site4a )
+ROM_START( a51site4a ) /* When dumped connected straight to IDE the cylinders were 4968 and heads were 16 */
 	ROM_REGION32_LE(0x40000, "bios", 0)
 	ROM_SYSTEM_BIOS(0, "new", "v1.0h" )
 	ROMX_LOAD("a51s4_bios_09-15-98.u1", 0x00000, 0x40000, CRC(f8cd6a6b) SHA1(75f851ae21517b729a5596ce5e042ebfaac51778), ROM_BIOS(1)) /* Build date 09/15/98 string stored at 0x3fff5 */
@@ -1369,8 +1342,7 @@
 	ROM_LOAD("cga.chr",     0x00000, 0x01000, CRC(42009069) SHA1(ed08559ce2d7f97f68b9f540bddad5b6295294dd))
 
 	DISK_REGION( "drive_0" )
-// Not sure why this does not boot.  Information (at the top of the driver) might indicate this as an SD Card bootleg of the original HD.
-	DISK_IMAGE( "a51site4a", 0, SHA1(a0962b35c265154e571f973a819efdd06109e543) )
+	DISK_IMAGE( "a51site4a", 0, SHA1(4de421e4d1708ecbdfb50730000814a1ea36a044) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/megatech.c src/mame/drivers/megatech.c
--- src-old/mame/drivers/megatech.c	2012-02-09 13:08:07.000000000 +0100
+++ src/mame/drivers/megatech.c	2012-03-11 18:17:00.000000000 +0100
@@ -314,10 +314,17 @@
 static WRITE8_HANDLER( bios_ctrl_w )
 {
 	mtech_state *state = space->machine().driver_data<mtech_state>();
+
 	if (offset == 1)
 	{
+		output_set_value("Alarm_sound", data>>7 & 0x01);
 		state->m_bios_ctrl_inputs = data & 0x04;  // Genesis/SMS input ports disable bit
 	}
+	else if (offset == 2)
+	{
+		output_set_value("Flash_screen", data>>1 & 0x01);
+	}
+
 	state->m_bios_ctrl[offset] = data;
 }
 
diff -Nru src-old/mame/drivers/mephisto.c src/mame/drivers/mephisto.c
--- src-old/mame/drivers/mephisto.c	2011-12-23 18:29:55.000000000 +0100
+++ src/mame/drivers/mephisto.c	2012-02-27 18:48:43.000000000 +0100
@@ -3,10 +3,11 @@
 #include "emu.h"
 #include "cpu/i86/i86.h"
 
-class mephisto_state : public driver_device
+// mephisto_state was also defined in mess/drivers/mephisto.c
+class mephisto_pinball_state : public driver_device
 {
 public:
-	mephisto_state(const machine_config &mconfig, device_type type, const char *tag)
+	mephisto_pinball_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		  m_maincpu(*this, "maincpu")
 	{ }
@@ -21,7 +22,7 @@
 };
 
 
-static ADDRESS_MAP_START( mephisto_map, AS_PROGRAM, 8, mephisto_state )
+static ADDRESS_MAP_START( mephisto_map, AS_PROGRAM, 8, mephisto_pinball_state )
 	AM_RANGE(0x0000, 0xffff) AM_NOP
 	AM_RANGE(0x00000, 0x0ffff) AM_ROM
 	AM_RANGE(0x10000, 0x1ffff) AM_RAM
@@ -31,7 +32,7 @@
 static INPUT_PORTS_START( mephisto )
 INPUT_PORTS_END
 
-void mephisto_state::machine_reset()
+void mephisto_pinball_state::machine_reset()
 {
 }
 
@@ -39,7 +40,7 @@
 {
 }
 
-static MACHINE_CONFIG_START( mephisto, mephisto_state )
+static MACHINE_CONFIG_START( mephisto, mephisto_pinball_state )
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", I8088, 8000000)
 	MCFG_CPU_PROGRAM_MAP(mephisto_map)
diff -Nru src-old/mame/drivers/meritm.c src/mame/drivers/meritm.c
--- src-old/mame/drivers/meritm.c	2012-02-22 00:51:07.000000000 +0100
+++ src/mame/drivers/meritm.c	2012-02-28 05:30:38.000000000 +0100
@@ -1424,6 +1424,18 @@
 	ROM_RELOAD(                        0x380000, 0x080000)
 ROM_END
 
+ROM_START( megat2caa ) /* Dallas DS1204U-3 security key labeled 9255-10-01-U5-R0 */
+	ROM_REGION( 0x400000, "maincpu", 0 )
+	ROM_LOAD( "qs9235-01_u5oru32-r0b", 0x000000, 0x080000, CRC(f7ecd49b) SHA1(34c1293da7304e8a46a96f1dbd7add3291afe3fc) ) /* Location U32 */
+	ROM_RELOAD(                        0x080000, 0x080000)
+	ROM_LOAD( "qs9235-01_u6oru36-r0",  0x100000, 0x080000, CRC(0a358743) SHA1(cc7c1b75e391204a7bdae2e1cecd9b55b572f8d5) ) /* Location U36 */
+	ROM_RELOAD(                        0x180000, 0x080000)
+	ROM_LOAD( "qs9235-01_u7oru37-r0",  0x200000, 0x080000, CRC(16643f83) SHA1(347af99f535a8b473c8780067d5132add7fa0d8c) ) /* Location U37 */
+	ROM_RELOAD(                        0x280000, 0x080000)
+	ROM_LOAD( "9255-10-06_u38-r0e",    0x300000, 0x080000, CRC(b3c0e60a) SHA1(a633fec476f44ec7964329bd80257b9070043209) ) /* Location U38, 11/29/1994 11:23:00 - California version */
+	ROM_RELOAD(                        0x380000, 0x080000)
+ROM_END
+
 ROM_START( megat3 ) /* Dallas DS1204V security key at U5 labeled 9255-20-01 U5-RO1 C1995 MII */
 	ROM_REGION( 0x400000, "maincpu", 0 )
 	ROM_LOAD( "9255-20-01_u32-r0d", 0x000000, 0x080000, CRC(ac969296) SHA1(7e09e9141637339b83c21f2488560cdf8a460069) ) /* Location U32 */
@@ -1566,7 +1578,24 @@
 	ROM_RELOAD(                     0x180000, 0x80000)
 	ROM_LOAD( "qs9255-02_u37-r0",   0x200000, 0x80000,  CRC(f2e8bb4e) SHA1(5c5475b3c176a6aca9b2c6aa4aee422675d20bd1) ) /* Location U37 */
 	ROM_RELOAD(                     0x280000, 0x80000)
-	ROM_LOAD( "9255-40-01_u38-rob", 0x300000, 0x80000,  CRC(0a16c846) SHA1(f0dcddb155f5e23a8dcf6bd8018cf6dc20c6bd34) ) /* Location U38, 05/03/1996 15:12 - Standard Version */
+	ROM_LOAD( "9255-40-01_u38-r0b", 0x300000, 0x80000,  CRC(0a16c846) SHA1(f0dcddb155f5e23a8dcf6bd8018cf6dc20c6bd34) ) /* Location U38, 05/03/1996 15:12 - Standard Version */
+	ROM_RELOAD(                     0x380000, 0x80000)
+
+	ROM_REGION( 0x1000, "user2", 0 ) // PALs
+	ROM_LOAD( "sc3943.u20",     0x000, 0x117, CRC(5a72fe78) SHA1(4b1a36904eb7048518507fe14bdade5c2589dbd7) )
+	ROM_LOAD( "sc3944-0a.u19",  0x000, 0x2dd, CRC(4cc46c5e) SHA1(0bab970df1539ce905f43603ad13171b05449a01) )
+	ROM_LOAD( "sc3980.u40",     0x000, 0x117, CRC(ee0cdab5) SHA1(216fef50a8a0f6a33b704d3501a4c5c3cbac2bad) )
+	ROM_LOAD( "sc3981-0a.u51",  0x000, 0x117, CRC(4fc750d0) SHA1(d09ff7a8c66aeb5c49e9fec84bd1521e3f5d8d0a) )
+ROM_END
+
+ROM_START( megat4c ) /* Dallas DS1204V security key at U5 labeled 9255-40-01 U5-B-RO1 C1996 MII */
+	ROM_REGION( 0x400000, "maincpu", 0 )
+	ROM_LOAD( "9255-40-01_u32-r0",  0x000000, 0x100000, CRC(08b1b8fe) SHA1(c562f2e065d6d7f753f6fd1d0b8355b01cb089ec) ) /* Location U32 */
+	ROM_LOAD( "qs9255-02_u36-r0",   0x100000, 0x80000,  CRC(57322328) SHA1(12bc604c9d34cde431ef7cd2aa33c7b12ac01833) ) /* Location U36 */
+	ROM_RELOAD(                     0x180000, 0x80000)
+	ROM_LOAD( "qs9255-02_u37-r0",   0x200000, 0x80000,  CRC(f2e8bb4e) SHA1(5c5475b3c176a6aca9b2c6aa4aee422675d20bd1) ) /* Location U37 */
+	ROM_RELOAD(                     0x280000, 0x80000)
+	ROM_LOAD( "9255-40-01_u38-r0",  0x300000, 0x80000,  CRC(ec96813d) SHA1(f93bb08ae89ab5ec1c6b33d5b1040c50d3db9ef5) ) /* Location U38, 04/03/1996 14:01 - Standard Version */
 	ROM_RELOAD(                     0x380000, 0x80000)
 
 	ROM_REGION( 0x1000, "user2", 0 ) // PALs
@@ -1860,6 +1889,17 @@
 	ds1204_init(machine, 0, megat4_ds1204_nvram);
 }
 
+static DRIVER_INIT(megat4c) /* First version of MegaTouch IV requires "key" like previous MegaTouch versions */
+{
+	static const UINT8 megat4c_ds1204_key[8] =
+		{ 0xf0, 0xaa, 0x0f, 0x0f, 0x55, 0x55, 0xff, 0xab };
+
+	static const UINT8 megat4_ds1204_nvram[16] =
+		{ 0xe3, 0x08, 0x39, 0xd8, 0x4c, 0xbb, 0xc4, 0xf8, 0xf0, 0xe2, 0xd8, 0x77, 0xa8, 0x3d, 0x95, 0x02 };
+
+	ds1204_init(machine, megat4c_ds1204_key, megat4_ds1204_nvram);
+}
+
 static DRIVER_INIT(megat4te)
 {
 	static const UINT8 megat4te_ds1204_nvram[16] =
@@ -1929,6 +1969,7 @@
 GAME( 1994, megat2,    0,      meritm_crt260, meritm_crt260, megat2,   ROT0, "Merit", "Pit Boss Megatouch II (9255-10-01 ROE, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1994, megat2a ,  megat2, meritm_crt260, meritm_crt260, megat2,   ROT0, "Merit", "Pit Boss Megatouch II (9255-10-01 ROD, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1994, megat2ca,  megat2, meritm_crt260, meritm_crt260, megat2,   ROT0, "Merit", "Pit Boss Megatouch II (9255-10-06 ROG, California version)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1994, megat2caa, megat2, meritm_crt260, meritm_crt260, megat2,   ROT0, "Merit", "Pit Boss Megatouch II (9255-10-06 ROE, California version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat3,    0,      meritm_crt260, meritm_crt260, megat3,   ROT0, "Merit", "Megatouch III (9255-20-01 RON, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1995, megat3a,   megat3, meritm_crt260, meritm_crt260, megat3,   ROT0, "Merit", "Megatouch III (9255-20-01 ROF, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat3ca,  megat3, meritm_crt260, meritm_crt260, megat3,   ROT0, "Merit", "Megatouch III (9255-20-06 RON, California version)", GAME_IMPERFECT_GRAPHICS )
@@ -1938,6 +1979,7 @@
 GAME( 1996, megat4,    0,      meritm_crt260, meritm_crt260, megat4,   ROT0, "Merit", "Megatouch IV (9255-40-01 ROE, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat4a,   megat4, meritm_crt260, meritm_crt260, megat4,   ROT0, "Merit", "Megatouch IV (9255-40-01 ROD, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat4b,   megat4, meritm_crt260, meritm_crt260, megat4,   ROT0, "Merit", "Megatouch IV (9255-40-01 ROB, Standard version)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, megat4c,   megat4, meritm_crt260, meritm_crt260, megat4c,  ROT0, "Merit", "Megatouch IV (9255-40-01 RO, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat4s,   megat4, meritm_crt260, meritm_crt260, megat4,   ROT0, "Merit", "Super Megatouch IV (9255-41-01 ROG, Standard version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat4sn,  megat4, meritm_crt260, meritm_crt260, megat4,   ROT0, "Merit", "Super Megatouch IV (9255-41-07 ROG, New Jersey version)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, megat4te,  megat4, meritm_crt260, meritm_crt260, megat4te, ROT0, "Merit", "Megatouch IV Tournament Edition (9255-50-01 ROD, Standard version)", GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/metlclsh.c src/mame/drivers/metlclsh.c
--- src-old/mame/drivers/metlclsh.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/metlclsh.c	2012-03-07 19:42:58.000000000 +0100
@@ -259,15 +259,9 @@
 
 ***************************************************************************/
 
-static void metlclsh_irqhandler(device_t *device, int linestate)
-{
-	metlclsh_state *state = device->machine().driver_data<metlclsh_state>();
-	device_set_input_line(state->m_maincpu, M6809_IRQ_LINE, linestate);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	metlclsh_irqhandler
+	DEVCB_CPU_INPUT_LINE("maincpu", M6809_IRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/mirage.c src/mame/drivers/mirage.c
--- src-old/mame/drivers/mirage.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/mirage.c	2012-03-08 08:39:27.000000000 +0100
@@ -38,24 +38,25 @@
 #include "includes/decoprot.h"
 #include "video/deco16ic.h"
 #include "sound/okim6295.h"
+#include "video/bufsprite.h"
 #include "video/decospr.h"
 
-class mirage_state : public driver_device
+// mirage_state was also defined in mess/drivers/mirage.c
+class miragemi_state : public driver_device
 {
 public:
-	mirage_state(const machine_config &mconfig, device_type type, const char *tag)
+	miragemi_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		  m_maincpu(*this, "maincpu"),
 		  m_deco_tilegen1(*this, "tilegen1"),
 		  m_oki_sfx(*this, "oki_sfx"),
-		  m_oki_bgm(*this, "oki_bgm") { }
+		  m_oki_bgm(*this, "oki_bgm"),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT16 *  m_pf1_rowscroll;
 	UINT16 *  m_pf2_rowscroll;
-//  UINT16 *  m_spriteram;
 //  UINT16 *  m_paletteram;    // currently this uses generic palette handling (in decocomn.c)
-//  size_t    m_spriteram_size;
 
 	/* misc */
 	UINT8 m_mux_data;
@@ -65,6 +66,7 @@
 	required_device<deco16ic_device> m_deco_tilegen1;
 	required_device<okim6295_device> m_oki_sfx;
 	required_device<okim6295_device> m_oki_bgm;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 static VIDEO_START( mirage )
@@ -74,12 +76,12 @@
 
 static SCREEN_UPDATE_RGB32( mirage )
 {
-	mirage_state *state = screen.machine().driver_data<mirage_state>();
+	miragemi_state *state = screen.machine().driver_data<miragemi_state>();
 	UINT16 flip = deco16ic_pf_control_r(state->m_deco_tilegen1, 0, 0xffff);
 
 	flip_screen_set(screen.machine(), BIT(flip, 7));
 
-	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400);
+	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400);
 
 	deco16ic_pf_update(state->m_deco_tilegen1, state->m_pf1_rowscroll, state->m_pf2_rowscroll);
 
@@ -93,26 +95,16 @@
 	return 0;
 }
 
-static SCREEN_VBLANK( mirage )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-		buffer_spriteram16_w(space,0,0,0xffff);
-	}
-}
-
 
 static WRITE16_HANDLER( mirage_mux_w )
 {
-	mirage_state *state = space->machine().driver_data<mirage_state>();
+	miragemi_state *state = space->machine().driver_data<miragemi_state>();
 	state->m_mux_data = data & 0x1f;
 }
 
 static READ16_HANDLER( mirage_input_r )
 {
-	mirage_state *state = space->machine().driver_data<mirage_state>();
+	miragemi_state *state = space->machine().driver_data<miragemi_state>();
 	switch (state->m_mux_data & 0x1f)
 	{
 		case 0x01: return input_port_read(space->machine(), "KEY0");
@@ -127,13 +119,13 @@
 
 static WRITE16_HANDLER( okim1_rombank_w )
 {
-	mirage_state *state = space->machine().driver_data<mirage_state>();
+	miragemi_state *state = space->machine().driver_data<miragemi_state>();
 	state->m_oki_sfx->set_bank_base(0x40000 * (data & 0x3));
 }
 
 static WRITE16_HANDLER( okim0_rombank_w )
 {
-	mirage_state *state = space->machine().driver_data<mirage_state>();
+	miragemi_state *state = space->machine().driver_data<miragemi_state>();
 
 	/*bits 4-6 used on POST? */
 	state->m_oki_bgm->set_bank_base(0x40000 * (data & 0x7));
@@ -145,9 +137,9 @@
 	AM_RANGE(0x100000, 0x101fff) AM_DEVREADWRITE("tilegen1", deco16ic_pf1_data_r, deco16ic_pf1_data_w) // 0x100000 - 0x101fff tested
 	AM_RANGE(0x102000, 0x103fff) AM_DEVREADWRITE("tilegen1", deco16ic_pf2_data_r, deco16ic_pf2_data_w) // 0x102000 - 0x102fff tested
 	/* linescroll */
-	AM_RANGE(0x110000, 0x110bff) AM_RAM AM_BASE_MEMBER(mirage_state, m_pf1_rowscroll)
-	AM_RANGE(0x112000, 0x112bff) AM_RAM AM_BASE_MEMBER(mirage_state, m_pf2_rowscroll)
-	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x110000, 0x110bff) AM_RAM AM_BASE_MEMBER(miragemi_state, m_pf1_rowscroll)
+	AM_RANGE(0x112000, 0x112bff) AM_RAM AM_BASE_MEMBER(miragemi_state, m_pf2_rowscroll)
+	AM_RANGE(0x120000, 0x1207ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x130000, 0x1307ff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x140000, 0x14000f) AM_DEVREADWRITE8_MODERN("oki_sfx", okim6295_device, read, write, 0x00ff)
 	AM_RANGE(0x150000, 0x15000f) AM_DEVREADWRITE8_MODERN("oki_bgm", okim6295_device, read, write, 0x00ff)
@@ -306,19 +298,19 @@
 
 static MACHINE_START( mirage )
 {
-	mirage_state *state = machine.driver_data<mirage_state>();
+	miragemi_state *state = machine.driver_data<miragemi_state>();
 
 	state->save_item(NAME(state->m_mux_data));
 }
 
 static MACHINE_RESET( mirage )
 {
-	mirage_state *state = machine.driver_data<mirage_state>();
+	miragemi_state *state = machine.driver_data<miragemi_state>();
 
 	state->m_mux_data = 0;
 }
 
-static MACHINE_CONFIG_START( mirage, mirage_state )
+static MACHINE_CONFIG_START( mirage, miragemi_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", M68000, 28000000/2)
@@ -329,7 +321,7 @@
 	MCFG_MACHINE_RESET(mirage)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
@@ -337,7 +329,7 @@
 	MCFG_SCREEN_SIZE(40*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 40*8-1, 1*8, 31*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(mirage)
-	MCFG_SCREEN_VBLANK_STATIC(mirage)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_VIDEO_START(mirage)
 
diff -Nru src-old/mame/drivers/missb2.c src/mame/drivers/missb2.c
--- src-old/mame/drivers/missb2.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/missb2.c	2012-03-07 19:42:58.000000000 +0100
@@ -407,7 +407,7 @@
 /* Sound Interfaces */
 
 // Handler called by the 3526 emulator when the internal timers cause an IRQ
-static void irqhandler(device_t *device, int irq)
+static WRITE_LINE_DEVICE_HANDLER( irqhandler )
 {
 	logerror("YM3526 firing an IRQ\n");
 //  cputag_set_input_line(device->machine(), "audiocpu", 0, irq ? ASSERT_LINE : CLEAR_LINE);
@@ -415,7 +415,7 @@
 
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_LINE(irqhandler)
 };
 
 /* Interrupt Generator */
diff -Nru src-old/mame/drivers/model2.c src/mame/drivers/model2.c
--- src-old/mame/drivers/model2.c	2012-02-14 02:30:42.000000000 +0100
+++ src/mame/drivers/model2.c	2012-03-05 23:01:57.000000000 +0100
@@ -4413,7 +4413,7 @@
 	ROM_LOAD("mpr-19154.32", 0x000000, 0x400000, CRC(7cd9e679) SHA1(b9812c4f3042f95febc96bcdd46e3b0724ad4b4f) )
 ROM_END
 
-ROM_START( von ) /* Virtual On Cyber Troopers Revision B (US), Model 2B */
+ROM_START( von ) /* Virtual On Cyber Troopers Revision B (US), Model 2B, Sega ID# 834-12346-01 */
 	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
 	ROM_LOAD32_WORD("epr-18828b.15", 0x000000, 0x080000, CRC(6499cc59) SHA1(8289be295f021acbf0c903513ba97ae7de50dedb) )
 	ROM_LOAD32_WORD("epr-18829b.16", 0x000002, 0x080000, CRC(0053b10f) SHA1(b89cc814b02b4ab5e37c75ee1a9cf57b88b63053) )
@@ -4942,7 +4942,6 @@
 	ROM_LOAD("epr-14869c.25", 0x000000, 0x010000, CRC(24b68e64) SHA1(c19d044d4c2fe551474492aa51922587394dd371) )
 ROM_END
 
-
 /*
 Daytona "To The MAXX" upgrade.
 Unofficial Sega hack for Model 2 Daytona machines
@@ -5017,43 +5016,86 @@
 
 ROM_START( vcop ) /* Virtua Cop Revision B, Model 2 */
 	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
-	ROM_LOAD32_WORD( "epr-17166b.012", 0x000000, 0x020000, CRC(a5647c59) SHA1(0a9e0be447d3591e82efd40ef4acbfe7ae211579) )
-	ROM_LOAD32_WORD( "epr-17167b.013", 0x000002, 0x020000, CRC(f5dde26a) SHA1(95db029bc4206a44ea216afbcd1c19689f79115a) )
-	ROM_LOAD32_WORD( "epr-17160a.014", 0x040000, 0x020000, CRC(267f3242) SHA1(40ec09cda984bb80969bfae2278432153137c213) )
-	ROM_LOAD32_WORD( "epr-17161a.015", 0x040002, 0x020000, CRC(f7126876) SHA1(b0ceb1206edaa507ec15723497fcd447a511f423) )
+	ROM_LOAD32_WORD( "epr-17166b.12", 0x000000, 0x020000, CRC(a5647c59) SHA1(0a9e0be447d3591e82efd40ef4acbfe7ae211579) )
+	ROM_LOAD32_WORD( "epr-17167b.13", 0x000002, 0x020000, CRC(f5dde26a) SHA1(95db029bc4206a44ea216afbcd1c19689f79115a) )
+	ROM_LOAD32_WORD( "epr-17160a.14", 0x040000, 0x020000, CRC(267f3242) SHA1(40ec09cda984bb80969bfae2278432153137c213) )
+	ROM_LOAD32_WORD( "epr-17161a.15", 0x040002, 0x020000, CRC(f7126876) SHA1(b0ceb1206edaa507ec15723497fcd447a511f423) )
+
+	ROM_REGION32_LE( 0x2000000, "user1", 0 ) // Data
+	ROM_LOAD32_WORD( "mpr-17164.10", 0x000000, 0x200000, CRC(ac5fc501) SHA1(e60deec1e79d207d37d3f4ddd83a1b2125c411ac) )
+	ROM_LOAD32_WORD( "mpr-17165.11", 0x000002, 0x200000, CRC(82296d00) SHA1(23327137b36c98dfb9175ea9d36478e7385dfac2) )
+	ROM_LOAD32_WORD( "mpr-17162.8",  0x400000, 0x200000, CRC(60ddd41e) SHA1(0894c9bcdedeb09f921419a309858e242cb8db3a) )
+	ROM_LOAD32_WORD( "mpr-17163.9",  0x400002, 0x200000, CRC(8c1f9dc8) SHA1(cf99a5bb4f343d59c8d6f5716287b6e16bef6412) )
+	ROM_LOAD32_WORD( "epr-17168a.6", 0x800000, 0x080000, CRC(59091a37) SHA1(14591c7015aaf126755be584aa94c04e6de222fa) )
+	ROM_LOAD32_WORD( "epr-17169a.7", 0x800002, 0x080000, CRC(0495808d) SHA1(5b86a9a68c2b52f942aa8d858ee7a491f546a921) )
+
+	ROM_REGION( 0x800000, "tgp", ROMREGION_ERASE00 ) // TGP program
+
+	ROM_REGION( 0x1000000, "user2", 0 ) // Models
+	ROM_LOAD32_WORD( "mpr-17159.16", 0x000000, 0x200000, CRC(e218727d) SHA1(1458d01d49936a0b8d497b62ff9ea940ca753b37) )
+	ROM_LOAD32_WORD( "mpr-17156.20", 0x000002, 0x200000, CRC(c4f4aabf) SHA1(8814cd329609cc8a188fedd770230bb9a5d00361) )
+
+	ROM_REGION( 0x1000000, "user3", 0 ) // Textures
+	ROM_LOAD32_WORD( "mpr-17158.25", 0x000000, 0x200000, CRC(1108d1ec) SHA1(e95d4166bd4b26c5f21b85821b410f53045f4309) )
+	ROM_LOAD32_WORD( "mpr-17157.24", 0x000002, 0x200000, CRC(cf31e33d) SHA1(0cb62d4f28b5ad8a7e4c82b0ca8aea3037b05455) )
+
+	ROM_REGION( 0x20000, "cpu4", 0) // Communication program
+	ROM_LOAD32_WORD( "epr-17181.6", 0x000000, 0x010000, CRC(1add2b82) SHA1(81892251d466f630a96af25bde652c20e47d7ede) )
+
+	ROM_REGION( 0x80000, "audiocpu", 0 ) // Sound program
+	ROM_LOAD16_WORD_SWAP( "epr-17170.7", 0x000000, 0x020000, CRC(06a38ae2) SHA1(a2c3d14d9266449ebfc6d976a956e0a8a602cfb0) )
+	ROM_LOAD16_WORD_SWAP( "epr-17171.8", 0x020000, 0x020000, CRC(b5e436f8) SHA1(1da3cb52d64f52d03a8de9954afffbc6e1549a5b) )
+
+	ROM_REGION( 0x400000, "sega1", 0 ) // Samples
+	ROM_LOAD( "mpr-17172.32", 0x000000, 0x100000, CRC(ab22cac3) SHA1(0e872158faeb8c0404b10cdf0a3fa36f89a5093e) )
+	ROM_LOAD( "mpr-17173.33", 0x200000, 0x100000, CRC(3cb4005c) SHA1(a56f436ea6dfe0968b73ae7bc92bb2f4c612460d) )
+
+	ROM_REGION( 0x400000, "sega2", 0 ) // Samples
+	ROM_LOAD( "mpr-17174.4", 0x000000, 0x200000, CRC(a50369cc) SHA1(69807157baf6e3679adc95633c82b0236db01247) )
+	ROM_LOAD( "mpr-17175.5", 0x200000, 0x200000, CRC(9136d43c) SHA1(741f80a8ff8165ffe171dc568e0da4ad0bde4809) )
+
+	MODEL2_CPU_BOARD
+ROM_END
+
+ROM_START( vcopa ) /* Virtua Cop Revision A, Model 2 */
+	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
+	ROM_LOAD32_WORD( "epr-17166a.12", 0x000000, 0x020000, CRC(702566e6) SHA1(478eec1e1d51a2ff63e8fd591528f0ca70df9310) )
+	ROM_LOAD32_WORD( "epr-17167a.13", 0x000002, 0x020000, CRC(9b8e05a8) SHA1(5e95f3f901d7f87f8c9cbeb3a65cd1b74e9cc09b) )
+	ROM_LOAD32_WORD( "epr-17160a.14", 0x040000, 0x020000, CRC(267f3242) SHA1(40ec09cda984bb80969bfae2278432153137c213) )
+	ROM_LOAD32_WORD( "epr-17161a.15", 0x040002, 0x020000, CRC(f7126876) SHA1(b0ceb1206edaa507ec15723497fcd447a511f423) )
 
 	ROM_REGION32_LE( 0x2000000, "user1", 0 ) // Data
-	ROM_LOAD32_WORD( "mpr-17164.010",  0x000000, 0x200000, CRC(ac5fc501) SHA1(e60deec1e79d207d37d3f4ddd83a1b2125c411ac) )
-	ROM_LOAD32_WORD( "mpr-17165.011",  0x000002, 0x200000, CRC(82296d00) SHA1(23327137b36c98dfb9175ea9d36478e7385dfac2) )
-	ROM_LOAD32_WORD( "mpr-17162.008",  0x400000, 0x200000, CRC(60ddd41e) SHA1(0894c9bcdedeb09f921419a309858e242cb8db3a) )
-	ROM_LOAD32_WORD( "mpr-17163.009",  0x400002, 0x200000, CRC(8c1f9dc8) SHA1(cf99a5bb4f343d59c8d6f5716287b6e16bef6412) )
-	ROM_LOAD32_WORD( "epr-17168a.006", 0x800000, 0x080000, CRC(59091a37) SHA1(14591c7015aaf126755be584aa94c04e6de222fa) )
-	ROM_LOAD32_WORD( "epr-17169a.007", 0x800002, 0x080000, CRC(0495808d) SHA1(5b86a9a68c2b52f942aa8d858ee7a491f546a921) )
+	ROM_LOAD32_WORD( "mpr-17164.10", 0x000000, 0x200000, CRC(ac5fc501) SHA1(e60deec1e79d207d37d3f4ddd83a1b2125c411ac) )
+	ROM_LOAD32_WORD( "mpr-17165.11", 0x000002, 0x200000, CRC(82296d00) SHA1(23327137b36c98dfb9175ea9d36478e7385dfac2) )
+	ROM_LOAD32_WORD( "mpr-17162.8",  0x400000, 0x200000, CRC(60ddd41e) SHA1(0894c9bcdedeb09f921419a309858e242cb8db3a) )
+	ROM_LOAD32_WORD( "mpr-17163.9",  0x400002, 0x200000, CRC(8c1f9dc8) SHA1(cf99a5bb4f343d59c8d6f5716287b6e16bef6412) )
+	ROM_LOAD32_WORD( "epr-17168a.6", 0x800000, 0x080000, CRC(59091a37) SHA1(14591c7015aaf126755be584aa94c04e6de222fa) )
+	ROM_LOAD32_WORD( "epr-17169a.7", 0x800002, 0x080000, CRC(0495808d) SHA1(5b86a9a68c2b52f942aa8d858ee7a491f546a921) )
 
 	ROM_REGION( 0x800000, "tgp", ROMREGION_ERASE00 ) // TGP program
 
 	ROM_REGION( 0x1000000, "user2", 0 ) // Models
-	ROM_LOAD32_WORD( "mpr-17159.016", 0x000000, 0x200000, CRC(e218727d) SHA1(1458d01d49936a0b8d497b62ff9ea940ca753b37) )
-	ROM_LOAD32_WORD( "mpr-17156.020", 0x000002, 0x200000, CRC(c4f4aabf) SHA1(8814cd329609cc8a188fedd770230bb9a5d00361) )
+	ROM_LOAD32_WORD( "mpr-17159.16", 0x000000, 0x200000, CRC(e218727d) SHA1(1458d01d49936a0b8d497b62ff9ea940ca753b37) )
+	ROM_LOAD32_WORD( "mpr-17156.20", 0x000002, 0x200000, CRC(c4f4aabf) SHA1(8814cd329609cc8a188fedd770230bb9a5d00361) )
 
 	ROM_REGION( 0x1000000, "user3", 0 ) // Textures
-	ROM_LOAD32_WORD( "mpr-17158.025", 0x000000, 0x200000, CRC(1108d1ec) SHA1(e95d4166bd4b26c5f21b85821b410f53045f4309) )
-	ROM_LOAD32_WORD( "mpr-17157.024", 0x000002, 0x200000, CRC(cf31e33d) SHA1(0cb62d4f28b5ad8a7e4c82b0ca8aea3037b05455) )
+	ROM_LOAD32_WORD( "mpr-17158.25", 0x000000, 0x200000, CRC(1108d1ec) SHA1(e95d4166bd4b26c5f21b85821b410f53045f4309) )
+	ROM_LOAD32_WORD( "mpr-17157.24", 0x000002, 0x200000, CRC(cf31e33d) SHA1(0cb62d4f28b5ad8a7e4c82b0ca8aea3037b05455) )
 
 	ROM_REGION( 0x20000, "cpu4", 0) // Communication program
-	ROM_LOAD32_WORD( "epr-17181.006", 0x000000, 0x010000, CRC(1add2b82) SHA1(81892251d466f630a96af25bde652c20e47d7ede) )
+	ROM_LOAD32_WORD( "epr-17181.6", 0x000000, 0x010000, CRC(1add2b82) SHA1(81892251d466f630a96af25bde652c20e47d7ede) )
 
 	ROM_REGION( 0x80000, "audiocpu", 0 ) // Sound program
-	ROM_LOAD16_WORD_SWAP( "epr-17170.007", 0x000000, 0x020000, CRC(06a38ae2) SHA1(a2c3d14d9266449ebfc6d976a956e0a8a602cfb0) )
-	ROM_LOAD16_WORD_SWAP( "epr-17171.008", 0x020000, 0x020000, CRC(b5e436f8) SHA1(1da3cb52d64f52d03a8de9954afffbc6e1549a5b) )
+	ROM_LOAD16_WORD_SWAP( "epr-17170.7", 0x000000, 0x020000, CRC(06a38ae2) SHA1(a2c3d14d9266449ebfc6d976a956e0a8a602cfb0) )
+	ROM_LOAD16_WORD_SWAP( "epr-17171.8", 0x020000, 0x020000, CRC(b5e436f8) SHA1(1da3cb52d64f52d03a8de9954afffbc6e1549a5b) )
 
 	ROM_REGION( 0x400000, "sega1", 0 ) // Samples
-	ROM_LOAD( "mpr-17172.032", 0x000000, 0x100000, CRC(ab22cac3) SHA1(0e872158faeb8c0404b10cdf0a3fa36f89a5093e) )
-	ROM_LOAD( "mpr-17173.033", 0x200000, 0x100000, CRC(3cb4005c) SHA1(a56f436ea6dfe0968b73ae7bc92bb2f4c612460d) )
+	ROM_LOAD( "mpr-17172.32", 0x000000, 0x100000, CRC(ab22cac3) SHA1(0e872158faeb8c0404b10cdf0a3fa36f89a5093e) )
+	ROM_LOAD( "mpr-17173.33", 0x200000, 0x100000, CRC(3cb4005c) SHA1(a56f436ea6dfe0968b73ae7bc92bb2f4c612460d) )
 
 	ROM_REGION( 0x400000, "sega2", 0 ) // Samples
-	ROM_LOAD( "mpr-17174.004", 0x000000, 0x200000, CRC(a50369cc) SHA1(69807157baf6e3679adc95633c82b0236db01247) )
-	ROM_LOAD( "mpr-17175.005", 0x200000, 0x200000, CRC(9136d43c) SHA1(741f80a8ff8165ffe171dc568e0da4ad0bde4809) )
+	ROM_LOAD( "mpr-17174.4", 0x000000, 0x200000, CRC(a50369cc) SHA1(69807157baf6e3679adc95633c82b0236db01247) )
+	ROM_LOAD( "mpr-17175.5", 0x200000, 0x200000, CRC(9136d43c) SHA1(741f80a8ff8165ffe171dc568e0da4ad0bde4809) )
 
 	MODEL2_CPU_BOARD
 ROM_END
@@ -5090,7 +5132,7 @@
 	ROM_REGION( 0x20000, "cpu4", ROMREGION_ERASE00 ) // Communication program
 
 	ROM_REGION( 0x80000, "audiocpu", 0 ) // Sound program
-	ROM_LOAD16_WORD_SWAP("epr-16985.7", 0x000000,  0x20000, CRC(8c4d9056) SHA1(785752d761c648d1177c5f0cfa3e9fa44135d6dc) )
+	ROM_LOAD16_WORD_SWAP("epr-16985.7", 0x000000, 0x20000, CRC(8c4d9056) SHA1(785752d761c648d1177c5f0cfa3e9fa44135d6dc) )
 
 	ROM_REGION( 0x400000, "sega1", 0 ) // Samples
 	ROM_LOAD("mpr-16986.32", 0x000000, 0x200000, CRC(559612f9) SHA1(33bcaddfc7d8fe899707e663299e8f04e9004d51) )
@@ -5219,6 +5261,7 @@
 GAME( 1993, daytonam,  daytona, model2o, daytona, daytonam, ROT0, "Sega", "Daytona USA (Japan, To The MAXX)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1994, desert,          0, model2o, desert,  0,        ROT0, "Sega / Martin Marietta", "Desert Tank", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1994, vcop,            0, model2o, daytona, 0,        ROT0, "Sega", "Virtua Cop (Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1994, vcopa,           0, model2o, daytona, 0,        ROT0, "Sega", "Virtua Cop (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 
 // Model 2A-CRX (TGPs, SCSP sound board)
 GAME( 1995, manxtt,          0, model2a, model2, 0,       ROT0, "Sega", "Manx TT Superbike (Revision C)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
@@ -5246,15 +5289,15 @@
 GAME( 1995, indy500,         0, model2b, srallyc,0,       ROT0, "Sega", "INDY 500 Twin (Revision A, Newer)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1995, indy500d,  indy500, model2b, srallyc,0,       ROT0, "Sega", "INDY 500 Deluxe (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1995, indy500to, indy500, model2b, srallyc,0,       ROT0, "Sega", "INDY 500 Twin (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, schamp,          0, model2b, model2, 0,       ROT0, "Sega", "Sonic Championship", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, sfight,     schamp, model2b, model2, 0,       ROT0, "Sega", "Sonic The Fighters", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, schamp,          0, model2b, model2, 0,       ROT0, "Sega", "Sonic Championship (USA)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, sfight,     schamp, model2b, model2, 0,       ROT0, "Sega", "Sonic the Fighters (Japan)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, lastbrnx,        0, model2b, model2, 0,       ROT0, "Sega", "Last Bronx (Export, Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, lastbrnxu,lastbrnx, model2b, model2, 0,       ROT0, "Sega", "Last Bronx (USA, Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, lastbrnxj,lastbrnx, model2b, model2, 0,       ROT0, "Sega", "Last Bronx (Japan, Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, doa,             0, model2b, model2, doa,     ROT0, "Sega", "Dead or Alive (Model 2B, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, sgt24h,          0, model2b, srallyc, sgt24h, ROT0, "Jaleco", "Super GT 24h", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, von,             0, model2b, model2, 0,       ROT0, "Sega", "Virtual On Cyber Troopers (US, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1996, vonj,          von, model2b, model2, 0,       ROT0, "Sega", "Virtual On Cyber Troopers (Japan, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, von,             0, model2b, model2, 0,       ROT0, "Sega", "Cyber Troopers Virtual-On (USA, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, vonj,          von, model2b, model2, 0,       ROT0, "Sega", "Cyber Troopers Virtual-On (Japan, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, dynabb,          0, model2b, model2, 0,       ROT0, "Sega", "Dynamite Baseball", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, dynabb97,        0, model2b, model2, 0,       ROT0, "Sega", "Dynamite Baseball 97 (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, zerogun,         0, model2b, model2, zerogun, ROT0, "Psikyo", "Zero Gunner (Export, Model 2B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/moo.c src/mame/drivers/moo.c
--- src-old/mame/drivers/moo.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/moo.c	2012-03-04 18:26:17.000000000 +0100
@@ -365,7 +365,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("k054539", k054539_r,k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
 	AM_RANGE(0xec00, 0xec01) AM_DEVREADWRITE("ymsnd", ym2151_r,ym2151_w)
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch3_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -515,6 +515,8 @@
 	40, 16
 };
 
+static k054539_interface k054539_config;
+
 static MACHINE_CONFIG_START( moo, moo_state )
 
 	/* basic machine hardware */
@@ -558,7 +560,7 @@
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.50)
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.75)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.75)
 MACHINE_CONFIG_END
@@ -617,161 +619,160 @@
 MACHINE_CONFIG_END
 
 
-
-ROM_START( moomesa ) /* Version EA - Euro Ver A */
+ROM_START( moomesa ) /* Version EA */
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "151_b01",    0x000000,  0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) )
-	ROM_LOAD16_BYTE( "151_ea_b02", 0x000001,  0x40000, CRC(37b30c01) SHA1(cb91739097a4a36f8f8d92998d822ffc851e1279) )
+	ROM_LOAD16_BYTE( "151b01.q5",   0x000000, 0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) )	/* B */
+	ROM_LOAD16_BYTE( "151eab02.q6", 0x000001, 0x40000, CRC(37b30c01) SHA1(cb91739097a4a36f8f8d92998d822ffc851e1279) )	/* EAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "151a03", 0x100000,  0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
-	ROM_LOAD16_BYTE( "151a04", 0x100001,  0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
+	ROM_LOAD16_BYTE( "151a03.t5", 0x100000, 0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
+	ROM_LOAD16_BYTE( "151a04.t6", 0x100001, 0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD( "151a07", 0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "151a07.f5",  0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
-	ROM_LOAD( "151a05", 0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
-	ROM_LOAD( "151a06", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
+	ROM_LOAD( "151a05.t8",  0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
+	ROM_LOAD( "151a06.t10", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
 
 	ROM_REGION( 0x800000, "gfx2", 0 )
 	/* sprites */
-	ROM_LOAD( "151a10", 0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
-	ROM_LOAD( "151a11", 0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
-	ROM_LOAD( "151a12", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
-	ROM_LOAD( "151a13", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
+	ROM_LOAD( "151a10.b8",  0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
+	ROM_LOAD( "151a11.a8",  0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
+	ROM_LOAD( "151a12.b10", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
+	ROM_LOAD( "151a13.a10", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
 
 	ROM_REGION( 0x200000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD( "151a08", 0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
+	ROM_LOAD( "151a08.b6",  0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "moo.nv", 0x0000, 0x080, CRC(7bd904a8) SHA1(8747c5c62d1832e290be8ace73c61b1f228c0bec) )
+	ROM_LOAD( "moomesa.nv", 0x0000, 0x080, CRC(7bd904a8) SHA1(8747c5c62d1832e290be8ace73c61b1f228c0bec) )
 ROM_END
 
-ROM_START( moomesau ) /* Version UA - USA Ver A */
+ROM_START( moomesauac ) /* Version UA */
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "151_c01",    0x000000,  0x40000, CRC(10555732) SHA1(b67cb756c250ddd6f3291683b3f3449e13a2ee83) ) /* Version UAC? */
-	ROM_LOAD16_BYTE( "151_ua_c02", 0x000001,  0x40000, CRC(52ae87b0) SHA1(552d41a2ddd040f92c6a3cfdc07f9d6e751ac9c1) )
+	ROM_LOAD16_BYTE( "151c01.q5",   0x000000, 0x40000, CRC(10555732) SHA1(b67cb756c250ddd6f3291683b3f3449e13a2ee83) )	/* C */
+	ROM_LOAD16_BYTE( "151uac02.q6", 0x000001, 0x40000, CRC(52ae87b0) SHA1(552d41a2ddd040f92c6a3cfdc07f9d6e751ac9c1) )	/* UAC */
 
 	/* data */
-	ROM_LOAD16_BYTE( "151a03", 0x100000,  0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
-	ROM_LOAD16_BYTE( "151a04", 0x100001,  0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
+	ROM_LOAD16_BYTE( "151a03.t5", 0x100000, 0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
+	ROM_LOAD16_BYTE( "151a04.t6", 0x100001, 0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD( "151a07", 0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "151a07.f5",  0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
-	ROM_LOAD( "151a05", 0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
-	ROM_LOAD( "151a06", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
+	ROM_LOAD( "151a05.t8",  0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
+	ROM_LOAD( "151a06.t10", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
 
 	ROM_REGION( 0x800000, "gfx2", 0 )
 	/* sprites */
-	ROM_LOAD( "151a10", 0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
-	ROM_LOAD( "151a11", 0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
-	ROM_LOAD( "151a12", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
-	ROM_LOAD( "151a13", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
+	ROM_LOAD( "151a10.b8",  0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
+	ROM_LOAD( "151a11.a8",  0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
+	ROM_LOAD( "151a12.b10", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
+	ROM_LOAD( "151a13.a10", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
 
 	ROM_REGION( 0x200000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD( "151a08", 0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
+	ROM_LOAD( "151a08.b6",  0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "moou.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
+	ROM_LOAD( "moomesauac.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
 ROM_END
 
-ROM_START( moomesaua ) /* Version UA - USA Ver A */
+ROM_START( moomesauab ) /* Version UA */
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "151_b01",    0x000000,  0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) ) /* Version UAB? */
-	ROM_LOAD16_BYTE( "151_uaa_b02", 0x000001,  0x40000, CRC(3d9f4d59) SHA1(db47044bd4935fce94ec659242c9819c30eb6d0f) )
+	ROM_LOAD16_BYTE( "151b01.q5",   0x000000, 0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) )	/* B */
+	ROM_LOAD16_BYTE( "151uab02.q6", 0x000001, 0x40000, CRC(3d9f4d59) SHA1(db47044bd4935fce94ec659242c9819c30eb6d0f) )	/* UAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "151a03", 0x100000,  0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
-	ROM_LOAD16_BYTE( "151a04", 0x100001,  0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
+	ROM_LOAD16_BYTE( "151a03.t5", 0x100000, 0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
+	ROM_LOAD16_BYTE( "151a04.t6", 0x100001, 0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD( "151a07", 0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "151a07.f5",  0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
-	ROM_LOAD( "151a05", 0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
-	ROM_LOAD( "151a06", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
+	ROM_LOAD( "151a05.t8",  0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
+	ROM_LOAD( "151a06.t10", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
 
 	ROM_REGION( 0x800000, "gfx2", 0 )
 	/* sprites */
-	ROM_LOAD( "151a10", 0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
-	ROM_LOAD( "151a11", 0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
-	ROM_LOAD( "151a12", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
-	ROM_LOAD( "151a13", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
+	ROM_LOAD( "151a10.b8",  0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
+	ROM_LOAD( "151a11.a8",  0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
+	ROM_LOAD( "151a12.b10", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
+	ROM_LOAD( "151a13.a10", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
 
 	ROM_REGION( 0x200000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD( "151a08", 0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
+	ROM_LOAD( "151a08.b6",  0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "moou.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
+	ROM_LOAD( "moomesauab.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
 ROM_END
 
-ROM_START( moomesaa ) /* Version AA - Asia Ver A */
+ROM_START( moomesaaab ) /* Version AA */
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "151_b01",    0x000000,  0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) )
-	ROM_LOAD16_BYTE( "151_ua_b02", 0x000001,  0x40000, CRC(2162d593) SHA1(a6cfe4a57b3f22b2aa0f04f91acefe3b7bea9e76) )
+	ROM_LOAD16_BYTE( "151b01.q5",   0x000000, 0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) )	/* B */
+	ROM_LOAD16_BYTE( "151aab02.q6", 0x000001, 0x40000, CRC(2162d593) SHA1(a6cfe4a57b3f22b2aa0f04f91acefe3b7bea9e76) )	/* AAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "151a03", 0x100000,  0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
-	ROM_LOAD16_BYTE( "151a04", 0x100001,  0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
+	ROM_LOAD16_BYTE( "151a03.t5", 0x100000, 0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
+	ROM_LOAD16_BYTE( "151a04.t6", 0x100001, 0x40000, CRC(3b24706a) SHA1(c2a77944284e35ff57f0774fa7b67e53d3b63e1f) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD( "151a07", 0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "151a07.f5",  0x000000, 0x040000, CRC(cde247fc) SHA1(cdee0228db55d53ae43d7cd2d9001dadd20c2c61) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
-	ROM_LOAD( "151a05", 0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
-	ROM_LOAD( "151a06", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
+	ROM_LOAD( "151a05.t8",  0x000000, 0x100000, CRC(bc616249) SHA1(58c1f1a03ce9bead8f79d12ce4b2d342432b24b5) )
+	ROM_LOAD( "151a06.t10", 0x100000, 0x100000, CRC(38dbcac1) SHA1(c357779733921695b20ac586db5b475f5b2b8f4c) )
 
 	ROM_REGION( 0x800000, "gfx2", 0 )
 	/* sprites */
-	ROM_LOAD( "151a10", 0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
-	ROM_LOAD( "151a11", 0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
-	ROM_LOAD( "151a12", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
-	ROM_LOAD( "151a13", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
+	ROM_LOAD( "151a10.b8",  0x000000, 0x200000, CRC(376c64f1) SHA1(eb69c5a27f9795e28f04a503955132f0a9e4de12) )
+	ROM_LOAD( "151a11.a8",  0x200000, 0x200000, CRC(e7f49225) SHA1(1255b214f29b6507540dad5892c60a7ae2aafc5c) )
+	ROM_LOAD( "151a12.b10", 0x400000, 0x200000, CRC(4978555f) SHA1(d9871f21d0c8a512b408e137e2e80e9392c2bf6f) )
+	ROM_LOAD( "151a13.a10", 0x600000, 0x200000, CRC(4771f525) SHA1(218d86b6230919b5db0304dac00513eb6b27ba9a) )
 
 	ROM_REGION( 0x200000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD( "151a08", 0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
+	ROM_LOAD( "151a08.b6",  0x000000, 0x200000, CRC(962251d7) SHA1(32dccf515d2ca8eeffb45cada3dcc60089991b77) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "moo.nv", 0x0000, 0x080, CRC(7bd904a8) SHA1(8747c5c62d1832e290be8ace73c61b1f228c0bec) )
+	ROM_LOAD( "moomesaaab.nv", 0x0000, 0x080, CRC(7bd904a8) SHA1(8747c5c62d1832e290be8ace73c61b1f228c0bec) )
 ROM_END
 
-ROM_START( bucky )
+ROM_START( bucky ) /* Version EA */
 	ROM_REGION( 0x240000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "173_ea_b01.q5", 0x000000,  0x40000, CRC(7785ac8a) SHA1(ef78d14f54d3a0b724b9702a18c67891e2d366a7) )
-	ROM_LOAD16_BYTE( "173_ea_b02.q6", 0x000001,  0x40000, CRC(9b45f122) SHA1(325af1612e6f90ef9ae9353c43dc645be1f3465c) )
+	ROM_LOAD16_BYTE( "173eab01.q5", 0x000000, 0x40000, CRC(7785ac8a) SHA1(ef78d14f54d3a0b724b9702a18c67891e2d366a7) )	/* EAB */
+	ROM_LOAD16_BYTE( "173eab02.q6", 0x000001, 0x40000, CRC(9b45f122) SHA1(325af1612e6f90ef9ae9353c43dc645be1f3465c) )	/* EAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "t5", 0x200000,  0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
-	ROM_LOAD16_BYTE( "t6", 0x200001,  0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
+	ROM_LOAD16_BYTE( "173a03.t5", 0x200000, 0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
+	ROM_LOAD16_BYTE( "173a04.t6", 0x200001, 0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD("173.a07", 0x000000, 0x40000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "173a07.f5",  0x000000, 0x040000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
@@ -787,27 +788,27 @@
 
 	ROM_REGION( 0x400000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD("173a08.b6", 0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
-	ROM_LOAD("173a09.a6", 0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
+	ROM_LOAD( "173a08.b6",  0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
+	ROM_LOAD( "173a09.a6",  0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
 	ROM_LOAD( "bucky.nv", 0x0000, 0x080, CRC(6a5986f3) SHA1(3efddeed261b09031c582e12318f00c2cbb214ea) )
 ROM_END
 
-ROM_START( buckyua )
+ROM_START( buckyuab ) /* Version UA */
 	ROM_REGION( 0x240000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "173_ua_b01.q5", 0x000000,  0x40000, CRC(dcaecca0) SHA1(c41847c9d89cdaf7cfa81ad9cc018c32592a882f) )
-	ROM_LOAD16_BYTE( "173_ua_b02.q6", 0x000001,  0x40000, CRC(e3c856a6) SHA1(33cc8a29643e44b31ee280015c0c994bed72a0e3) )
+	ROM_LOAD16_BYTE( "173uab01.q5", 0x000000, 0x40000, CRC(dcaecca0) SHA1(c41847c9d89cdaf7cfa81ad9cc018c32592a882f) )	/* UAB */
+	ROM_LOAD16_BYTE( "173uab02.q6", 0x000001, 0x40000, CRC(e3c856a6) SHA1(33cc8a29643e44b31ee280015c0c994bed72a0e3) )	/* UAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "t5", 0x200000,  0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
-	ROM_LOAD16_BYTE( "t6", 0x200001,  0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
+	ROM_LOAD16_BYTE( "173a03.t5", 0x200000, 0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
+	ROM_LOAD16_BYTE( "173a04.t6", 0x200001, 0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD("173.a07", 0x000000, 0x40000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "173a07.f5",  0x000000, 0x040000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
@@ -823,27 +824,27 @@
 
 	ROM_REGION( 0x400000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD("173a08.b6", 0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
-	ROM_LOAD("173a09.a6", 0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
+	ROM_LOAD( "173a08.b6",  0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
+	ROM_LOAD( "173a09.a6",  0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "buckyu.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
+	ROM_LOAD( "buckyuab.nv", 0x0000, 0x080, CRC(a5cb137a) SHA1(119df859d6b5c366481305b1433eea0deadc3fa9) )
 ROM_END
 
-ROM_START( buckyaa )
+ROM_START( buckyaab ) /* Version AA */
 	ROM_REGION( 0x240000, "maincpu", 0 )
 	/* main program */
-	ROM_LOAD16_BYTE( "173_aa_b01.q5", 0x000000,  0x40000, CRC(9193e89f) SHA1(574d6eb4097cd10c3dea99060ee09f220d41f1dc) )
-	ROM_LOAD16_BYTE( "173_aa_b02.q6", 0x000001,  0x40000, CRC(2567f3eb) SHA1(ccdb2a4b3ad1464f70d1442df8a3a7a7e34f6cd7) )
+	ROM_LOAD16_BYTE( "173aab01.q5", 0x000000, 0x40000, CRC(9193e89f) SHA1(574d6eb4097cd10c3dea99060ee09f220d41f1dc) )	/* AAB */
+	ROM_LOAD16_BYTE( "173aab02.q6", 0x000001, 0x40000, CRC(2567f3eb) SHA1(ccdb2a4b3ad1464f70d1442df8a3a7a7e34f6cd7) )	/* AAB */
 
 	/* data */
-	ROM_LOAD16_BYTE( "t5", 0x200000,  0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
-	ROM_LOAD16_BYTE( "t6", 0x200001,  0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
+	ROM_LOAD16_BYTE( "173a03.t5", 0x200000, 0x20000, CRC(cd724026) SHA1(525445499604b713da4d8bc0a88e428654ceab95) )
+	ROM_LOAD16_BYTE( "173a04.t6", 0x200001, 0x20000, CRC(7dd54d6f) SHA1(b0ee8ec445b92254bca881eefd4449972fed506a) )
 
 	ROM_REGION( 0x050000, "soundcpu", 0 )
 	/* Z80 sound program */
-	ROM_LOAD("173.a07", 0x000000, 0x40000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
-	ROM_RELOAD(         0x010000, 0x040000 )
+	ROM_LOAD( "173a07.f5",  0x000000, 0x040000, CRC(4cdaee71) SHA1(bdc05d4475415f6fac65d7cdbc48df398e57845e) )
+	ROM_RELOAD(             0x010000, 0x040000 )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
 	/* tilemaps */
@@ -855,15 +856,15 @@
 	ROM_LOAD( "173a10.b8",  0x000000, 0x200000, CRC(42fb0a0c) SHA1(d68c932cfabdec7896698b433525fe47ef4698d0) )
 	ROM_LOAD( "173a11.a8",  0x200000, 0x200000, CRC(b0d747c4) SHA1(0cf1ee1b9a35ded31a81c321df2a076f7b588971) )
 	ROM_LOAD( "173a12.b10", 0x400000, 0x200000, CRC(0fc2ad24) SHA1(6eda1043ee1266b8ba938a03a90bc7787210a936) )
-	ROM_LOAD(	 "173a13.a10", 0x600000, 0x200000, CRC(4cf85439) SHA1(8c298bf0e659a830a1830a1180f4ce71215ade45) )
+	ROM_LOAD( "173a13.a10", 0x600000, 0x200000, CRC(4cf85439) SHA1(8c298bf0e659a830a1830a1180f4ce71215ade45) )
 
 	ROM_REGION( 0x400000, "k054539", 0 )
 	/* K054539 samples */
-	ROM_LOAD("173a08.b6", 0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
-	ROM_LOAD("173a09.a6", 0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
+	ROM_LOAD( "173a08.b6",  0x000000, 0x200000, CRC(dcdded95) SHA1(8eeb546a0b60a35a6dce36c5ee872e6c93c577c9) )
+	ROM_LOAD( "173a09.a6",  0x200000, 0x200000, CRC(c93697c4) SHA1(0528a604868267a30d281b822c187df118566691) )
 
 	ROM_REGION( 0x80, "eeprom", 0 ) // default eeprom to prevent game booting upside down with error
-	ROM_LOAD( "bucky.nv", 0x0000, 0x080, CRC(6a5986f3) SHA1(3efddeed261b09031c582e12318f00c2cbb214ea) )
+	ROM_LOAD( "buckyaab.nv", 0x0000, 0x080, CRC(6a5986f3) SHA1(3efddeed261b09031c582e12318f00c2cbb214ea) )
 ROM_END
 
 
@@ -928,11 +929,11 @@
 }
 
 
-GAME( 1992, moomesa,  0,       moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver EA)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
-GAME( 1992, moomesau, moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver UA, set 1)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
-GAME( 1992, moomesaua,moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver UA, set 2)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
-GAME( 1992, moomesaa, moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver AA)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
-GAME( 1992, moomesabl,moomesa, moobl,   moo,     moo,      ROT0, "bootleg", "Wild West C.O.W.-Boys of Moo Mesa (bootleg ver AA)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
-GAME( 1992, bucky,    0,       bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver EA)", GAME_SUPPORTS_SAVE )
-GAME( 1992, buckyua,  bucky,   bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver UA)", GAME_SUPPORTS_SAVE )
-GAME( 1992, buckyaa,  bucky,   bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver AA)", GAME_SUPPORTS_SAVE )
+GAME( 1992, moomesa,    0,       moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver EAB)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1992, moomesauac, moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver UAC)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1992, moomesauab, moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver UAB)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1992, moomesaaab, moomesa, moo,     moo,     moo,      ROT0, "Konami", "Wild West C.O.W.-Boys of Moo Mesa (ver AAB)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1992, moomesabl,  moomesa, moobl,   moo,     moo,      ROT0, "bootleg", "Wild West C.O.W.-Boys of Moo Mesa (bootleg)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )	// based on Version AA
+GAME( 1992, bucky,      0,       bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver EAB)", GAME_SUPPORTS_SAVE )
+GAME( 1992, buckyuab,   bucky,   bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver UAB)", GAME_SUPPORTS_SAVE )
+GAME( 1992, buckyaab,   bucky,   bucky,   bucky,   moo,      ROT0, "Konami", "Bucky O'Hare (ver AAB)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/mystwarr.c src/mame/drivers/mystwarr.c
--- src-old/mame/drivers/mystwarr.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/mystwarr.c	2012-03-04 18:26:17.000000000 +0100
@@ -587,9 +587,9 @@
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank2")
 	AM_RANGE(0x0000, 0xbfff) AM_WRITENOP
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("konami1", k054539_r,k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("konami1", k054539_device, read, write)
 	AM_RANGE(0xe230, 0xe3ff) AM_RAM
-	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE("konami2", k054539_r,k054539_w)
+	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE_MODERN("konami2", k054539_device, read, write)
 	AM_RANGE(0xe630, 0xe7ff) AM_RAM
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch3_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -861,73 +861,73 @@
 
 static MACHINE_RESET(mystwarr)
 {
-	device_t *k054539_1 = machine.device("konami1");
-	device_t *k054539_2 = machine.device("konami2");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
+	k054539_device *k054539_2 = machine.device<k054539_device>("konami2");
 	int i;
 
 	// soften chorus(chip 0 channel 0-3), boost voice(chip 0 channel 4-7)
 	for (i=0; i<=3; i++)
 	{
-		k054539_set_gain(k054539_1, i, 0.8);
-		k054539_set_gain(k054539_1, i+4, 2.0);
+		k054539_1->set_gain(i, 0.8);
+		k054539_1->set_gain(i+4, 2.0);
 	}
 
 	// soften percussions(chip 1 channel 0-7)
-	for (i=0; i<=7; i++) k054539_set_gain(k054539_2, i, 0.5);
+	for (i=0; i<=7; i++) k054539_2->set_gain(i, 0.5);
 }
 
 static MACHINE_RESET(dadandrn)
 {
-	device_t *k054539_1 = machine.device("konami1");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
 	int i;
 
 	// boost voice(chip 0 channel 4-7)
-	for (i=4; i<=7; i++) k054539_set_gain(k054539_1, i, 2.0);
+	for (i=4; i<=7; i++) k054539_1->set_gain(i, 2.0);
 }
 
 static MACHINE_RESET(viostorm)
 {
-	device_t *k054539_1 = machine.device("konami1");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
 	int i;
 
 	// boost voice(chip 0 channel 4-7)
-	for (i=4; i<=7; i++) k054539_set_gain(k054539_1, i, 2.0);
+	for (i=4; i<=7; i++) k054539_1->set_gain(i, 2.0);
 }
 
 static MACHINE_RESET(metamrph)
 {
-	device_t *k054539_1 = machine.device("konami1");
-	device_t *k054539_2 = machine.device("konami2");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
+	k054539_device *k054539_2 = machine.device<k054539_device>("konami2");
 	int i;
 
 	// boost voice(chip 0 channel 4-7) and soften other channels
 	for (i=0; i<=3; i++)
 	{
-		k054539_set_gain(k054539_1, i,   0.8);
-		k054539_set_gain(k054539_1, i+4, 1.8);
-		k054539_set_gain(k054539_2, i,   0.8);
-		k054539_set_gain(k054539_2, i+4, 0.8);
+		k054539_1->set_gain(i,   0.8);
+		k054539_1->set_gain(i+4, 1.8);
+		k054539_2->set_gain(i,   0.8);
+		k054539_2->set_gain(i+4, 0.8);
 	}
 }
 
 static MACHINE_RESET(martchmp)
 {
-	device_t *k054539_1 = machine.device("konami1");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
 	int i;
 
-	k054539_init_flags(k054539_1, K054539_REVERSE_STEREO);
+	k054539_1->init_flags(k054539_device::REVERSE_STEREO);
 
 	// boost voice(chip 0 channel 4-7)
-	for (i=4; i<=7; i++) k054539_set_gain(k054539_1, i, 1.4);
+	for (i=4; i<=7; i++) k054539_1->set_gain(i, 1.4);
 }
 
 static MACHINE_RESET(gaiapols)
 {
-	device_t *k054539_1 = machine.device("konami1");
+	k054539_device *k054539_1 = machine.device<k054539_device>("konami1");
 	int i;
 
 	// boost voice(chip 0 channel 5-7)
-	for (i=5; i<=7; i++) k054539_set_gain(k054539_1, i, 2.0);
+	for (i=5; i<=7; i++) k054539_1->set_gain(i, 2.0);
 }
 
 static const k053252_interface mystwarr_k053252_intf =
@@ -1027,13 +1027,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "rspeaker", 1.0)	/* stereo channels are inverted */
 	MCFG_SOUND_ROUTE(1, "lspeaker", 1.0)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "rspeaker", 1.0)	/* stereo channels are inverted */
 	MCFG_SOUND_ROUTE(1, "lspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/namcoic.c src/mame/drivers/namcoic.c
--- src-old/mame/drivers/namcoic.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/namcoic.c	2012-03-08 10:54:00.000000000 +0100
@@ -620,6 +620,7 @@
 /**************************************************************************************/
 
 static UINT16 mSpritePos[4];
+static UINT16 *m_spriteram;
 
 WRITE16_HANDLER( namco_spritepos16_w )
 {
@@ -715,7 +716,7 @@
 static void
 draw_spriteC355(running_machine &machine, _BitmapClass &bitmap, const rectangle &cliprect, const UINT16 *pSource, int pri, int zpos )
 {
-	UINT16 *spriteram16 = machine.generic.spriteram.u16;
+	UINT16 *spriteram16 = m_spriteram;
 	unsigned screen_height_remaining, screen_width_remaining;
 	unsigned source_height_remaining, source_width_remaining;
 	int hpos,vpos;
@@ -908,8 +909,8 @@
 	{
 		mpCodeToTile = DefaultCodeToTile;
 	}
-	machine.generic.spriteram.u16 = auto_alloc_array(machine, UINT16, 0x20000/2);
-	memset( machine.generic.spriteram.u16, 0, 0x20000 ); /* needed for Nebulas Ray */
+	m_spriteram = auto_alloc_array(machine, UINT16, 0x20000/2);
+	memset( m_spriteram, 0, 0x20000 ); /* needed for Nebulas Ray */
 	memset( mSpritePos,0x00,sizeof(mSpritePos) );
 } /* namcosC355_init */
 
@@ -942,11 +943,11 @@
 	}
 //  if( offs==0 )
 	{ /* boot */
-		DrawObjectList(machine, bitmap,cliprect,pri,&machine.generic.spriteram.u16[0x02000/2], &machine.generic.spriteram.u16[0x00000/2] );
+		DrawObjectList(machine, bitmap,cliprect,pri,&m_spriteram[0x02000/2], &m_spriteram[0x00000/2] );
 	}
 //  else
 	{
-		DrawObjectList(machine, bitmap,cliprect,pri,&machine.generic.spriteram.u16[0x14000/2], &machine.generic.spriteram.u16[0x10000/2] );
+		DrawObjectList(machine, bitmap,cliprect,pri,&m_spriteram[0x14000/2], &m_spriteram[0x10000/2] );
 	}
 } /* namco_obj_draw */
 
@@ -960,27 +961,27 @@
 	}
 //  if( offs==0 )
 	{ /* boot */
-		DrawObjectList(machine, bitmap,cliprect,pri,&machine.generic.spriteram.u16[0x02000/2], &machine.generic.spriteram.u16[0x00000/2] );
+		DrawObjectList(machine, bitmap,cliprect,pri,&m_spriteram[0x02000/2], &m_spriteram[0x00000/2] );
 	}
 //  else
 	{
-		DrawObjectList(machine, bitmap,cliprect,pri,&machine.generic.spriteram.u16[0x14000/2], &machine.generic.spriteram.u16[0x10000/2] );
+		DrawObjectList(machine, bitmap,cliprect,pri,&m_spriteram[0x14000/2], &m_spriteram[0x10000/2] );
 	}
 } /* namco_obj_draw */
 
 WRITE16_HANDLER( namco_obj16_w )
 {
-	COMBINE_DATA( &space->machine().generic.spriteram.u16[offset] );
+	COMBINE_DATA( &m_spriteram[offset] );
 } /* namco_obj16_w */
 
 READ16_HANDLER( namco_obj16_r )
 {
-	return space->machine().generic.spriteram.u16[offset];
+	return m_spriteram[offset];
 } /* namco_obj16_r */
 
 WRITE32_HANDLER( namco_obj32_w )
 {
-	UINT16 *spriteram16 = space->machine().generic.spriteram.u16;
+	UINT16 *spriteram16 = m_spriteram;
 	UINT32 v;
 	offset *= 2;
 	v = (spriteram16[offset]<<16)|spriteram16[offset+1];
@@ -991,14 +992,14 @@
 
 READ32_HANDLER( namco_obj32_r )
 {
-	UINT16 *spriteram16 = space->machine().generic.spriteram.u16;
+	UINT16 *spriteram16 = m_spriteram;
 	offset *= 2;
 	return (spriteram16[offset]<<16)|spriteram16[offset+1];
 } /* namco_obj32_r */
 
 WRITE32_HANDLER( namco_obj32_le_w )
 {
-	UINT16 *spriteram16 = space->machine().generic.spriteram.u16;
+	UINT16 *spriteram16 = m_spriteram;
 	UINT32 v;
 	offset *= 2;
 	v = (spriteram16[offset+1]<<16)|spriteram16[offset];
@@ -1009,7 +1010,7 @@
 
 READ32_HANDLER( namco_obj32_le_r )
 {
-	UINT16 *spriteram16 = space->machine().generic.spriteram.u16;
+	UINT16 *spriteram16 = m_spriteram;
 	offset *= 2;
 	return (spriteram16[offset+1]<<16)|spriteram16[offset];
 } /* namco_obj32_r */
diff -Nru src-old/mame/drivers/namcops2.c src/mame/drivers/namcops2.c
--- src-old/mame/drivers/namcops2.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/namcops2.c	2012-03-11 18:17:00.000000000 +0100
@@ -192,15 +192,26 @@
 ROM_END
 
 ROM_START( soulclb3 )
-	ROM_REGION(0x200000, "bios", 0)
-	SYSTEM246_BIOS
+    ROM_REGION(0x200000, "bios", 0)
+    SYSTEM246_BIOS
 
-	ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
-        ROM_LOAD( "sc31001-na-a.ic002", 0x000000, 0x800000, CRC(ddbe9774) SHA1(6bb2d31cb669336345b5508bcca56936ea97c04a) )
-        ROM_LOAD( "sc31001-na-a_spr.ic002", 0x800000, 0x040000, CRC(18c6f56d) SHA1(13bc6a3688985c0cd9900b063824a4af691a1b31) )
+    ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+    ROM_LOAD( "sc31001-na-a.ic002", 0x000000, 0x800000, CRC(ddbe9774) SHA1(6bb2d31cb669336345b5508bcca56936ea97c04a) )
+    ROM_LOAD( "sc31001-na-a_spr.ic002", 0x800000, 0x040000, CRC(18c6f56d) SHA1(13bc6a3688985c0cd9900b063824a4af691a1b31) )
 
-	DISK_REGION("dvd")
-	DISK_IMAGE_READONLY( "sc31001-na-dvd0-b", 0, SHA1(b46ee35083f8fcc091ce562951c55fbdbb929e4b) )
+    DISK_REGION("dvd")
+    DISK_IMAGE_READONLY( "sc31001-na-dvd0-b", 0, SHA1(b46ee35083f8fcc091ce562951c55fbdbb929e4b) )
+ROM_END
+
+ROM_START( soulclb3a )
+    ROM_REGION(0x200000, "bios", 0)
+    SYSTEM246_BIOS
+
+    ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+    ROM_LOAD( "sc31002-na-a.ic002", 0x000000, 0x840000, CRC(2ebf91ff) SHA1(01e628344b2cde2edbda9ffea53af6a63e3bddf1) )
+
+    DISK_REGION("dvd")
+    DISK_IMAGE_READONLY( "sc31001-na-dvd0-b", 0, SHA1(b46ee35083f8fcc091ce562951c55fbdbb929e4b) )
 ROM_END
 
 ROM_START( sukuinuf )
@@ -275,6 +286,17 @@
 	DISK_IMAGE_READONLY( "tef1dvd0", 0, SHA1(f39aa37156245f622a6e19e8a0e081418e247b36) )
 ROM_END
 
+ROM_START( tekken4c )
+	ROM_REGION(0x200000, "bios", 0)
+	SYSTEM246_BIOS
+
+	ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+    ROM_LOAD( "tef1verc.ic002", 0x000000, 0x840000, CRC(92697a2b) SHA1(e9ec254d52187f5be0d9be58b25821c1e63bba8e) )
+
+	DISK_REGION("dvd")
+	DISK_IMAGE_READONLY( "tef1dvd0", 0, SHA1(f39aa37156245f622a6e19e8a0e081418e247b36) )
+ROM_END
+
 ROM_START( tekken51 )
 	ROM_REGION(0x200000, "bios", 0)
 	SYSTEM256_BIOS
@@ -370,6 +392,7 @@
 GAME(2002, tekken4,    sys246, system246, system246, 0, ROT0, "Namco", "Tekken 4 (TEF3 Ver. C)", GAME_IS_SKELETON)
 GAME(2002, tekken4a,  tekken4, system246, system246, 0, ROT0, "Namco", "Tekken 4 (TEF2 Ver. A)", GAME_IS_SKELETON)
 GAME(2002, tekken4b,  tekken4, system246, system246, 0, ROT0, "Namco", "Tekken 4 (TEF1 Ver. A)", GAME_IS_SKELETON)
+GAME(2002, tekken4c,  tekken4, system246, system246, 0, ROT0, "Namco", "Tekken 4 (TEF1 Ver. C)", GAME_IS_SKELETON)
 GAME(2003, timecrs3,   sys246, system246, system246, 0, ROT0, "Namco", "Time Crisis 3 (TST1)", GAME_IS_SKELETON)
 GAME(2003, zgundm,     sys246, system246, system246, 0, ROT0, "Capcom / Banpresto", "Mobile Suit Z-Gundam: A.E.U.G. vs Titans (ZGA1 Ver. A)", GAME_IS_SKELETON)
 GAME(2004, fghtjam,    sys246, system246, system246, 0, ROT0, "Capcom / Namco", "Capcom Fighting Jam (JAM1 Ver. A)", GAME_IS_SKELETON)
@@ -377,6 +400,7 @@
 GAME(2004, zgundmdx,   sys246, system246, system246, 0, ROT0, "Capcom / Banpresto", "Mobile Suit Z-Gundam: A.E.U.G. vs Titans DX (ZDX1 Ver. A)", GAME_IS_SKELETON)
 GAME(2005, gundzaft,   sys246, system246, system246, 0, ROT0, "Capcom / Banpresto", "Gundam Seed: Federation vs. Z.A.F.T. (SED1 Ver. A)", GAME_IS_SKELETON)
 GAME(2005, soulclb3,   sys246, system246, system246, 0, ROT0, "Namco", "Soul Calibur III (SC31001-NA-A)", GAME_IS_SKELETON)
+GAME(2005, soulclb3a,soulclb3, system246, system246, 0, ROT0, "Namco", "Soul Calibur III (SC31002-NA-A)", GAME_IS_SKELETON)
 
 GAME(2004, sys256,          0, system256, system246, 0, ROT0, "Namco", "System 256 BIOS", GAME_IS_SKELETON|GAME_IS_BIOS_ROOT)
 GAME(2005, tekken51,   sys256, system256, system246, 0, ROT0, "Namco", "Tekken 5.1 (TE51 Ver. B)", GAME_IS_SKELETON)
diff -Nru src-old/mame/drivers/namcos10.c src/mame/drivers/namcos10.c
--- src-old/mame/drivers/namcos10.c	2012-02-23 02:02:10.000000000 +0100
+++ src/mame/drivers/namcos10.c	2012-03-06 13:57:27.000000000 +0100
@@ -468,12 +468,10 @@
 	decrypt_bios( machine, 0x6, 0x4, 0x7, 0x5, 0x0, 0x1, 0x2, 0x3, 0xc, 0xf, 0xe, 0xd, 0x9, 0x8, 0xb, 0xa );
 }
 
-
-//  This is not the actual decrpyt for NFL Classic Football.  This still needs to be divined.
 static DRIVER_INIT( nflclsfb )
 {
 	memn_driver_init(machine);
-	decrypt_bios( machine, 0x6, 0x4, 0x7, 0x5, 0x0, 0x1, 0x2, 0x3, 0xc, 0xf, 0xe, 0xd, 0x9, 0x8, 0xb, 0xa );
+	decrypt_bios( machine, 0x6, 0x5, 0x4, 0x7, 0x1, 0x3, 0x0, 0x2, 0xc, 0xd, 0xe, 0xf, 0x8, 0xb, 0xa, 0x9 );
 }
 
 
diff -Nru src-old/mame/drivers/namcos23.c src/mame/drivers/namcos23.c
--- src-old/mame/drivers/namcos23.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/drivers/namcos23.c	2012-02-29 15:39:45.000000000 +0100
@@ -2380,7 +2380,7 @@
 	{
 		state->m_bgtilemap->set_scrolldx(860, 860);
 	}
-	state->m_render.polymgr = poly_alloc(machine, 10000, sizeof(namcos23_render_data), POLYFLAG_NO_WORK_QUEUE);
+	state->m_render.polymgr = poly_alloc(machine, 10000, sizeof(namcos23_render_data), 0);
 }
 
 static SCREEN_UPDATE_RGB32( ss23 )
diff -Nru src-old/mame/drivers/naomi.c src/mame/drivers/naomi.c
--- src-old/mame/drivers/naomi.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/drivers/naomi.c	2012-03-11 18:17:00.000000000 +0100
@@ -5473,19 +5473,19 @@
 	NAOMI_DEFAULT_EEPROM
 
 	ROM_REGION( 0xb000000, "rom_board", ROMREGION_ERASEFF)
-	ROM_LOAD( "wk1-fl1.2d",   0x0400000, 0x0400000, CRC(f833a543) SHA1(328b64f2790bfd0b63168a8a3175227e083b995d) )
-	ROM_LOAD( "wk1-fl2.2c",   0x0c00000, 0x0400000, CRC(20ee71b0) SHA1(074e0c531e8770b0efd6464193bce7a284a3c057) )
-	ROM_LOAD( "wk1-ma2.4m",   0x1000000, 0x1000000, CRC(650590ec) SHA1(bb9d5d5df2321df24ee0fb9e8bf2757d5277f8ea) )
+	ROM_LOAD( "wk1fl1.2d",   0x0400000, 0x0400000, CRC(f833a543) SHA1(328b64f2790bfd0b63168a8a3175227e083b995d) )
+	ROM_LOAD( "wk1fl2.2c",   0x0c00000, 0x0400000, CRC(20ee71b0) SHA1(074e0c531e8770b0efd6464193bce7a284a3c057) )
+	ROM_LOAD( "wk1ma2.4m",   0x1000000, 0x1000000, CRC(650590ec) SHA1(bb9d5d5df2321df24ee0fb9e8bf2757d5277f8ea) )
 	ROM_RELOAD( 0x800000, 0x400000)
-	ROM_LOAD( "wk1-ma3.4l",   0x2000000, 0x1000000, CRC(3b340dc0) SHA1(2412e41d5bd74d1233fb91f8ce2276a318bfc53d) )
-	ROM_LOAD( "wk1-ma4.4k",   0x3000000, 0x1000000, CRC(263fbb16) SHA1(b5d3a3d085f9623d70030ca3c49afb84e25549e3) )
-	ROM_LOAD( "wk1-ma5.4j",   0x4000000, 0x1000000, CRC(9697db68) SHA1(7926e2acff0519403afcba9bdb5f68de28b06c79) )
-	ROM_LOAD( "wk1-ma6.4h",   0x5000000, 0x1000000, CRC(65017db3) SHA1(a66cd73cdfc9355df63da781a46aa832889f583a) )
-	ROM_LOAD( "wk1-ma7.4f",   0x6000000, 0x1000000, CRC(902eea85) SHA1(aa7964eb85b468d4fe112f9f0faaf2fa3f1aa96b) )
-	ROM_LOAD( "wk1-ma8.4e",   0x7000000, 0x1000000, CRC(90e917ed) SHA1(53d32ce0ae2b05fa55a95b8697927045d07f4e8a) )
-	ROM_LOAD( "wk1-ma9.4d",   0x8000000, 0x1000000, CRC(1d227a05) SHA1(9f816bcdf0279785e0b37ab2f3c5eb5912114dd5) )
-	ROM_LOAD( "wk1-ma10.4c",  0x9000000, 0x1000000, CRC(29635a54) SHA1(a3109d0f8f271e2183316846df2a6a819f6a9b20) )
-	ROM_LOAD( "wk1-ma11.4b",  0xa000000, 0x1000000, CRC(e96f312c) SHA1(0a92640277111aef5c6e9dab4218a8ae2196ce61) )
+	ROM_LOAD( "wk1ma3.4l",   0x2000000, 0x1000000, CRC(3b340dc0) SHA1(2412e41d5bd74d1233fb91f8ce2276a318bfc53d) )
+	ROM_LOAD( "wk1ma4.4k",   0x3000000, 0x1000000, CRC(263fbb16) SHA1(b5d3a3d085f9623d70030ca3c49afb84e25549e3) )
+	ROM_LOAD( "wk1ma5.4j",   0x4000000, 0x1000000, CRC(9697db68) SHA1(7926e2acff0519403afcba9bdb5f68de28b06c79) )
+	ROM_LOAD( "wk1ma6.4h",   0x5000000, 0x1000000, CRC(65017db3) SHA1(a66cd73cdfc9355df63da781a46aa832889f583a) )
+	ROM_LOAD( "wk1ma7.4f",   0x6000000, 0x1000000, CRC(902eea85) SHA1(aa7964eb85b468d4fe112f9f0faaf2fa3f1aa96b) )
+	ROM_LOAD( "wk1ma8.4e",   0x7000000, 0x1000000, CRC(90e917ed) SHA1(53d32ce0ae2b05fa55a95b8697927045d07f4e8a) )
+	ROM_LOAD( "wk1ma9.4d",   0x8000000, 0x1000000, CRC(1d227a05) SHA1(9f816bcdf0279785e0b37ab2f3c5eb5912114dd5) )
+	ROM_LOAD( "wk1ma10.4c",  0x9000000, 0x1000000, CRC(29635a54) SHA1(a3109d0f8f271e2183316846df2a6a819f6a9b20) )
+	ROM_LOAD( "wk1ma11.4b",  0xa000000, 0x1000000, CRC(e96f312c) SHA1(0a92640277111aef5c6e9dab4218a8ae2196ce61) )
 
 	ROM_REGION( 4, "rom_key", 0 )
 	ROM_LOAD( "wldkicks-key.bin", 0, 4, CRC(c1e3000b) SHA1(36c2546833effe9452e2b3f7d31335fc5e349f49) )
@@ -5496,28 +5496,49 @@
     NAOMI_DEFAULT_EEPROM
 
     ROM_REGION( 0x10000000, "rom_board", ROMREGION_ERASEFF)
-    ROM_LOAD( "trf1_fl0.2f",  0x0000000, 0x0800000, CRC(862e673d) SHA1(f2c90932ba4abe31d02e86f80ef3e2689342c384) )
-    ROM_LOAD( "trf1_fl1.2d",  0x0800000, 0x0800000, CRC(59a935c9) SHA1(7298d83a27eac74bad18d716a791ab2016fe028f) )
-    ROM_LOAD( "trf1_ma1.4n",  0x1000000, 0x1000000, CRC(b1b3ab96) SHA1(3dc4bcf796583a0fb51359a86a46d7883df54fad) )
-    ROM_LOAD( "trf1_ma2.4m",  0x2000000, 0x1000000, CRC(a27d3dda) SHA1(b9ec4be5845cbe91fd7bc537669e96716513a5f0) )
-    ROM_LOAD( "trf1_ma3.4l",  0x3000000, 0x1000000, CRC(345ec434) SHA1(986d9930e7de46b88936c898ba8b05d950262a1f) )
-    ROM_LOAD( "trf1_ma4.4k",  0x4000000, 0x1000000, CRC(fc47a104) SHA1(07ced58c1b17719ac36db1589771e67ce16d912e) )
-    ROM_LOAD( "trf1_ma5.4j",  0x5000000, 0x1000000, CRC(e1bb077d) SHA1(6b70d8103bf067319e9022742fc1dd843d7e5076) )
-    ROM_LOAD( "trf1_ma6.4h",  0x6000000, 0x1000000, CRC(abae4d06) SHA1(56da2ca3551287942afabf37e7fd1b884bd3cac8) )
-    ROM_LOAD( "trf1_ma7.4f",  0x7000000, 0x1000000, CRC(19d0092a) SHA1(2ae2dbf2f3958da9f69b3a8636c6837e4243bb67) )
-    ROM_LOAD( "trf1_ma8.4e",  0x8000000, 0x1000000, CRC(6fbf34ab) SHA1(f4747d1a1c02e22502e68d72a4f0c152fa69d778) )
-    ROM_LOAD( "trf1_ma9.4d",  0x9000000, 0x1000000, CRC(2fa36c5d) SHA1(6478687c91484141521ae79a997cecbcfbb7beae) )
-    ROM_LOAD( "trf1_ma10.4c", 0xa000000, 0x1000000, CRC(bc866a37) SHA1(d4d12f285a3bc9136cf3fc2a59dba5ad557cc7d7) )
-    ROM_LOAD( "trf1_ma11.4b", 0xb000000, 0x1000000, CRC(68d11482) SHA1(fe991ba5664d6ccf0aac5167f05c5a780f851ae9) )
-    ROM_LOAD( "trf1_ma12.6p", 0xc000000, 0x1000000, CRC(a7c3bd3c) SHA1(ed5a24e4c47f686120577dae4550fb9378209cf8) )
-    ROM_LOAD( "trf1_ma13.6n", 0xd000000, 0x1000000, CRC(e52d41fe) SHA1(e1769d42d6048f9621ca289af3ddeca7c14cee00) )
-    ROM_LOAD( "trf1_ma14.6m", 0xe000000, 0x1000000, CRC(87cb31a0) SHA1(27aef9ac571a0b5e3a76e4ee22f5bc5d0ae962f2) )
-    ROM_LOAD( "trf1_ma15.6l", 0xf000000, 0x1000000, CRC(42d318c5) SHA1(f9fe82ffbfc51fcb52333f94c55a7092e7124fb4) )
+    ROM_LOAD( "trf1fl0.2f",  0x0000000, 0x0800000, CRC(862e673d) SHA1(f2c90932ba4abe31d02e86f80ef3e2689342c384) )
+    ROM_LOAD( "trf1fl1.2d",  0x0800000, 0x0800000, CRC(59a935c9) SHA1(7298d83a27eac74bad18d716a791ab2016fe028f) )
+    ROM_LOAD( "trf1ma1.4n",  0x1000000, 0x1000000, CRC(b1b3ab96) SHA1(3dc4bcf796583a0fb51359a86a46d7883df54fad) )
+    ROM_LOAD( "trf1ma2.4m",  0x2000000, 0x1000000, CRC(a27d3dda) SHA1(b9ec4be5845cbe91fd7bc537669e96716513a5f0) )
+    ROM_LOAD( "trf1ma3.4l",  0x3000000, 0x1000000, CRC(345ec434) SHA1(986d9930e7de46b88936c898ba8b05d950262a1f) )
+    ROM_LOAD( "trf1ma4.4k",  0x4000000, 0x1000000, CRC(fc47a104) SHA1(07ced58c1b17719ac36db1589771e67ce16d912e) )
+    ROM_LOAD( "trf1ma5.4j",  0x5000000, 0x1000000, CRC(e1bb077d) SHA1(6b70d8103bf067319e9022742fc1dd843d7e5076) )
+    ROM_LOAD( "trf1ma6.4h",  0x6000000, 0x1000000, CRC(abae4d06) SHA1(56da2ca3551287942afabf37e7fd1b884bd3cac8) )
+    ROM_LOAD( "trf1ma7.4f",  0x7000000, 0x1000000, CRC(19d0092a) SHA1(2ae2dbf2f3958da9f69b3a8636c6837e4243bb67) )
+    ROM_LOAD( "trf1ma8.4e",  0x8000000, 0x1000000, CRC(6fbf34ab) SHA1(f4747d1a1c02e22502e68d72a4f0c152fa69d778) )
+    ROM_LOAD( "trf1ma9.4d",  0x9000000, 0x1000000, CRC(2fa36c5d) SHA1(6478687c91484141521ae79a997cecbcfbb7beae) )
+    ROM_LOAD( "trf1ma10.4c", 0xa000000, 0x1000000, CRC(bc866a37) SHA1(d4d12f285a3bc9136cf3fc2a59dba5ad557cc7d7) )
+    ROM_LOAD( "trf1ma11.4b", 0xb000000, 0x1000000, CRC(68d11482) SHA1(fe991ba5664d6ccf0aac5167f05c5a780f851ae9) )
+    ROM_LOAD( "trf1ma12.6p", 0xc000000, 0x1000000, CRC(a7c3bd3c) SHA1(ed5a24e4c47f686120577dae4550fb9378209cf8) )
+    ROM_LOAD( "trf1ma13.6n", 0xd000000, 0x1000000, CRC(e52d41fe) SHA1(e1769d42d6048f9621ca289af3ddeca7c14cee00) )
+    ROM_LOAD( "trf1ma14.6m", 0xe000000, 0x1000000, CRC(87cb31a0) SHA1(27aef9ac571a0b5e3a76e4ee22f5bc5d0ae962f2) )
+    ROM_LOAD( "trf1ma15.6l", 0xf000000, 0x1000000, CRC(42d318c5) SHA1(f9fe82ffbfc51fcb52333f94c55a7092e7124fb4) )
 
     ROM_REGION( 4, "rom_key", 0 )
     ROM_LOAD( "tr4ae-key.bin", 0x000000, 0x000004, CRC(986a7cee) SHA1(70c3ff80f86de6a0655251658c66a156fb644995) )
 ROM_END
 
+// this one's weird: the rom test checksum for IC 1 matches a screenshot from h/w, but on h/w it says ---- instead of BAD.
+ROM_START( mazan )
+    NAOMI_BIOS
+    NAOMI_DEFAULT_EEPROM
+
+    ROM_REGION( 0x10000000, "rom_board", ROMREGION_ERASEFF)
+    ROM_LOAD( "maz1fl1.2d",  0x0000000, 0x0800000, CRC(620cdbb6) SHA1(95e9d0858e1d3060b3c1c41adfff0539185fb03d) )
+	ROM_RELOAD( 0x800000, 0x800000 )
+    ROM_LOAD( "maz1ma1.4m",  0x1000000, 0x1000000, CRC(68e12189) SHA1(5a434bd0305189620a62c785c5ac2812dae033d6) )
+    ROM_LOAD( "maz1ma2.4l",  0x2000000, 0x1000000, CRC(c7a05b44) SHA1(dfbeb3be5adfdf3d4f1d330f3654a5532eb28cc2) )
+    ROM_LOAD( "maz1ma3.4k",  0x3000000, 0x1000000, CRC(48e1a8a5) SHA1(8b0d83c02ab576d90c95aad297c7447326154c0e) )
+    ROM_LOAD( "maz1ma4.4j",  0x4000000, 0x1000000, CRC(0187cdab) SHA1(aaa9fd208103426eb0eee58ae0a64a191abcd126) )
+    ROM_LOAD( "maz1ma5.4h",  0x5000000, 0x1000000, CRC(c6885ee7) SHA1(14e7e017438adcbe0136d7d863af95fe65bd15d8) )
+    ROM_LOAD( "maz1ma6.4f",  0x6000000, 0x1000000, CRC(a6593c36) SHA1(627bf19d960037ea92b673b786a9da7208acd447) )
+    ROM_LOAD( "maz1ma7.4e",  0x7000000, 0x1000000, CRC(6103ad9c) SHA1(e4abbb5867cae6a9bf9067ab3a091ef7b18fa0cd) )
+    ROM_LOAD( "maz1ma8.4d",  0x8000000, 0x1000000, CRC(d46c9f40) SHA1(45eec7fa3d4261f12438e841254fa75d572331b3) )
+
+    ROM_REGION( 4, "rom_key", 0 )
+    ROM_LOAD( "maz1-key.bin", 0x000000, 0x000004, CRC(79ebd41a) SHA1(3545dacdeac66b46e8706565f0eca784291040d1) )
+ROM_END
+
 ROM_START( vtenis2c )
 	NAOMI_BIOS
 	NAOMI_DEFAULT_EEPROM
@@ -5930,16 +5951,10 @@
 	DISK_REGION( "gdrom" )
 	DISK_IMAGE_READONLY( "gdl-0005", 0, SHA1(f5513c88528741798ee49f936b9b69480360f103) )
 
-	/*
-    Note:
-    There was no sticker or silk screen markings on this PIC.
-    I have used the product number as a label instead.
-
-    PIC16C621A-20 (317-0005-JPN)
-    Sticker: 253-5509-0005J
-    */
 	ROM_REGION( 0x4000, "pic", ROMREGION_ERASEFF)
-	ROM_LOAD("317-0005-jpn.pic", 0x00, 0x4000, CRC(19f8d4d0) SHA1(d256f26f757d7019cab7950d81992902cdb65e07) )
+    //PIC16C621A-20 (317-5077-JPN)
+    //(sticker: 253-5509-5077J)
+	ROM_LOAD("317-5077-jpn.pic", 0x00, 0x4000, CRC(19f8d4d0) SHA1(d256f26f757d7019cab7950d81992902cdb65e07) )
 ROM_END
 
 
@@ -6341,7 +6356,7 @@
 	ROM_LOAD("undefeat-default-eeprom.bin", 0, 0x80, CRC(9d2b071c) SHA1(88d90c23b9c2a6aa61bdf318d074a9cfa5c145e5))
 
 	DISK_REGION( "gdrom" )
-	DISK_IMAGE_READONLY( "gdl-0035", 0, SHA1(91da482a6a082e48bee5b3bd20d9c92d23936965) )
+	DISK_IMAGE_READONLY( "gdl-0035", 0, SHA1(3beade0a544b549ee06be5b51536950e3eaabe71) )
 
 	ROM_REGION( 0x4000, "pic", ROMREGION_ERASEFF)
 	//PIC16C622A (317-5117-JPN)
@@ -7888,11 +7903,11 @@
 /* HMG016007 */ GAME( 2001, hmgeo, naomi,   naomim2, naomi,    naomi,    ROT0, "Capcom",          "Heavy Metal Geomatrix (JPN, USA, EUR, ASI, AUS) (Rev A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 
 /* Cart games on Namco custom ROM board */
-/* 25209801 */ GAME( 2000, wldkicks, naomi, naomim2, naomi,    naomi,    ROT0, "Capcom / Namco", "World Kicks", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
-/* 25349801 */ GAME( 2000, toukon4,  naomi, naomim2, naomi,    naomi,    ROT0, "Capcom / Namco", "Shin Nihon Pro Wrestling Toukon Retsuden 4 Arcade Edition", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
+/* 25209801 */ GAME( 2000, wldkicks, naomi, naomim2, naomi,    naomi,    ROT0, "Capcom / Namco", "World Kicks (WK1 Ver. A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
+/* 25349801 */ GAME( 2000, toukon4,  naomi, naomim2, naomi,    naomi,    ROT0, "Capcom / Namco", "Shin Nihon Pro Wrestling Toukon Retsuden 4 Arcade Edition (TRF1 Ver. A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 // 25469801 Ninja Assault
-/* 25709801 */ GAME( 2001, gunsur2,  naomi, naomi,   naomi,    naomi,    ROT0, "Capcom / Namco", "Gun Survivor 2 Biohazard Code: Veronica", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
-// 25869812 Mazan : Flash of the Blade
+/* 25709801 */ GAME( 2001, gunsur2,  naomi, naomi,   naomi,    naomi,    ROT0, "Capcom / Namco", "Gun Survivor 2 Biohazard Code: Veronica (BHF1 Ver. A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
+/* 25869812 */ GAME( 2002, mazan,    naomi, naomim2, naomi,    naomi,    ROT0, "Capcom / Namco", "Mazan: Flash of the Blade (MAZ1 Ver. A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 
 /* GDS-xxxx (Sega GD-ROM games) */
 /* 0001  */ GAME( 2000, confmiss,  naomigd,  naomigd, hotd2,    naomigd,    ROT0, "Sega", "Confidential Mission (GDS-0001)", GAME_FLAGS )
diff -Nru src-old/mame/drivers/neodrvr.c src/mame/drivers/neodrvr.c
--- src-old/mame/drivers/neodrvr.c	2012-02-19 16:23:23.000000000 +0100
+++ src/mame/drivers/neodrvr.c	2012-03-11 18:17:00.000000000 +0100
@@ -427,6 +427,9 @@
     -- SNKPLAYMORE --
     . NEO-MVS CHAFIO (2003.7.24) - used only with NEO-CMC 90G06C7050
 
+    -- SNK development boards --
+    . NEO-MVS CHAMC2
+
     MVS PROG:
     -- SNK --
     . NEO-MVS PROG-NAM
@@ -460,6 +463,9 @@
     . NEO-MVS PROGBK3S (2003.10.1)
     . NEO-MVS PROGBK2S (2003.10.18)
 
+    -- SNK development boards --
+    . NEO-MVS PROGMC2
+
 
     AES CHA:
     -- SNK --
@@ -1609,7 +1615,6 @@
 	ROM_LOAD16_BYTE( "018-c4.c4", 0x200001, 0x100000, CRC(e2e0aff7) SHA1(1c691c092a6e2787de4f433b0eb9252bfdaa7e16) ) /* Plane 2,3 */ /* HN62408 */
 ROM_END
 
-
 ROM_START( burningfp ) /* early prototype - all roms were hand labeled with CRCs, dumps verified against them */
 	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_BYTE( "proto_018-p1.p1", 0x000001, 0x080000, CRC(5b4032e7) SHA1(55df91dad6f484d3d49c28ab5972700bf71a8662) )
@@ -1638,7 +1643,6 @@
 	ROM_LOAD32_BYTE( "proto_018-c8.c8", 0x200003, 0x80000, CRC(67cc9e34) SHA1(dc72a464c1456a4d2f7b992b416a984fb7885e99) ) /* Plane 3 */
 ROM_END
 
-
 /****************************************
  ID-0019
  . NGM-019
@@ -2353,7 +2357,7 @@
 	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "040-p1.p1", 0x000000, 0x100000, CRC(6dde02c2) SHA1(e432e63feb88c71629ec96aa84650dcfe356a551) )
 
-	NEO_SFIX_128K( "040-s1.s1", CRC(cd9802a3) SHA1(f685d4638f4f68e7e3f101c0c39128454536721b) )
+	NEO_SFIX_128K( "040-s1.s1", CRC(cd9802a3) SHA1(f685d4638f4f68e7e3f101c0c39128454536721b) ) /* TC531000 */
 
 	NEO_BIOS_AUDIO_128K( "040-m1.m1", CRC(d4de4bca) SHA1(ecf604d06f01d40b04e285facef66a6ae2d35661) )
 
@@ -3468,7 +3472,7 @@
 
 ROM_START( zupapa ) /* Original Version - Encrypted GFX */ /* MVS ONLY RELEASE */
 	ROM_REGION( 0x100000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "070-p1.p1", 0x000000, 0x100000, CRC(5a96203e) SHA1(49cddec9ca6cc51e5ecf8a34e447a23e1f8a15a1) )
+	ROM_LOAD16_WORD_SWAP( "070-p1.p1", 0x000000, 0x100000, CRC(5a96203e) SHA1(49cddec9ca6cc51e5ecf8a34e447a23e1f8a15a1) ) /* mask rom TC538200 */
 
 	ROM_Y_ZOOM
 
@@ -3478,17 +3482,18 @@
 	ROM_REGION( 0x20000, "fixedbios", 0 )
 	ROM_LOAD( "sfix.sfix", 0x000000, 0x20000, CRC(c2ea0cfd) SHA1(fd4a618cdcdbf849374f0a50dd8efe9dbab706c3) )
 
-	NEO_BIOS_AUDIO_128K( "070-m1.m1", CRC(5a3b3191) SHA1(fa9a9930e18c64e598841fb344c4471d3d2c1964) )
+	NEO_BIOS_AUDIO_128K( "070-epr.m1", CRC(5a3b3191) SHA1(fa9a9930e18c64e598841fb344c4471d3d2c1964) ) /* M27C1001 */
+	/* M1 on eprom, correct chip label unknown */
 
 	ROM_REGION( 0x0200000, "ymsnd", 0 )
-	ROM_LOAD( "070-v1.v1", 0x000000, 0x200000, CRC(d3a7e1ff) SHA1(4a4a227e10f4af58168f6c26011ea1d414253f92) )
+	ROM_LOAD( "070-v1.v1", 0x000000, 0x200000, CRC(d3a7e1ff) SHA1(4a4a227e10f4af58168f6c26011ea1d414253f92) ) /* mask rom TC5316200 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0x1000000, "sprites", 0 )
 	/* Encrypted */
-	ROM_LOAD16_BYTE( "070-c1.c1", 0x0000000, 0x800000, CRC(f8ad02d8) SHA1(9be54532332a8e963ec35ff1e518947bb11ebade) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "070-c2.c2", 0x0000001, 0x800000, CRC(70156dde) SHA1(06286bf043d50199b47df9a76ca91f39cb28cb90) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "070-c1.c1", 0x0000000, 0x800000, CRC(f8ad02d8) SHA1(9be54532332a8e963ec35ff1e518947bb11ebade) ) /* Plane 0,1 */ /* mask rom TC5364205 */
+	ROM_LOAD16_BYTE( "070-c2.c2", 0x0000001, 0x800000, CRC(70156dde) SHA1(06286bf043d50199b47df9a76ca91f39cb28cb90) ) /* Plane 2,3 */ /* mask rom TC5364205 */
 ROM_END
 
 /****************************************
@@ -4457,24 +4462,24 @@
 
 ROM_START( mslug )
 	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "201-p1.p1", 0x100000, 0x100000, CRC(08d8daa5) SHA1(b888993dbb7e9f0a28a01d7d2e1da00ef9cf6f38) )
+	ROM_LOAD16_WORD_SWAP( "201-p1.p1", 0x100000, 0x100000, CRC(08d8daa5) SHA1(b888993dbb7e9f0a28a01d7d2e1da00ef9cf6f38) ) /* TC5316200 */
 	ROM_CONTINUE( 0x000000, 0x100000 )
 
-	NEO_SFIX_128K( "201-s1.s1", CRC(2f55958d) SHA1(550b53628daec9f1e1e11a398854092d90f9505a) )
+	NEO_SFIX_128K( "201-s1.s1", CRC(2f55958d) SHA1(550b53628daec9f1e1e11a398854092d90f9505a) ) /* TC531000 */
 
-	NEO_BIOS_AUDIO_128K( "201-m1.m1", CRC(c28b3253) SHA1(fd75bd15aed30266a8b3775f276f997af57d1c06) )
+	NEO_BIOS_AUDIO_128K( "201-m1.m1", CRC(c28b3253) SHA1(fd75bd15aed30266a8b3775f276f997af57d1c06) ) /* TC531001 */
 
 	ROM_REGION( 0x800000, "ymsnd", 0 )
-	ROM_LOAD( "201-v1.v1", 0x000000, 0x400000, CRC(23d22ed1) SHA1(cd076928468ad6bcc5f19f88cb843ecb5e660681) )
-	ROM_LOAD( "201-v2.v2", 0x400000, 0x400000, CRC(472cf9db) SHA1(5f79ea9286d22ed208128f9c31ca75552ce08b57) )
+	ROM_LOAD( "201-v1.v1", 0x000000, 0x400000, CRC(23d22ed1) SHA1(cd076928468ad6bcc5f19f88cb843ecb5e660681) ) /* TC5332204 */
+	ROM_LOAD( "201-v2.v2", 0x400000, 0x400000, CRC(472cf9db) SHA1(5f79ea9286d22ed208128f9c31ca75552ce08b57) ) /* TC5332204 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0x1000000, "sprites", 0 )
-	ROM_LOAD16_BYTE( "201-c1.c1", 0x000000, 0x400000, CRC(72813676) SHA1(7b045d1a48980cb1a140699011cb1a3d4acdc4d1) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "201-c2.c2", 0x000001, 0x400000, CRC(96f62574) SHA1(cb7254b885989223bba597b8ff0972dfa5957816) ) /* Plane 2,3 */
-	ROM_LOAD16_BYTE( "201-c3.c3", 0x800000, 0x400000, CRC(5121456a) SHA1(0a7a27d603d1bb2520b5570ebf5b34a106e255a6) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "201-c4.c4", 0x800001, 0x400000, CRC(f4ad59a3) SHA1(4e94fda8ee63abf0f92afe08060a488546e5c280) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "201-c1.c1", 0x000000, 0x400000, CRC(72813676) SHA1(7b045d1a48980cb1a140699011cb1a3d4acdc4d1) ) /* Plane 0,1 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "201-c2.c2", 0x000001, 0x400000, CRC(96f62574) SHA1(cb7254b885989223bba597b8ff0972dfa5957816) ) /* Plane 2,3 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "201-c3.c3", 0x800000, 0x400000, CRC(5121456a) SHA1(0a7a27d603d1bb2520b5570ebf5b34a106e255a6) ) /* Plane 0,1 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "201-c4.c4", 0x800001, 0x400000, CRC(f4ad59a3) SHA1(4e94fda8ee63abf0f92afe08060a488546e5c280) ) /* Plane 2,3 */ /* TC5332205 */
 ROM_END
 
 /****************************************
@@ -4693,7 +4698,7 @@
 	ROM_LOAD16_WORD_SWAP( "213-p1.p1", 0x100000, 0x100000, CRC(e397d798) SHA1(10f459111db4bab7aaa63ca47e83304a84300812) )
 	ROM_CONTINUE( 0x000000, 0x100000)
 
-	NEO_SFIX_128K( "213-s1.s1", CRC(b76b61bc) SHA1(5fdb407d16ab9e33c4f26ee09ff70891ae1d2bd0) )
+	NEO_SFIX_128K( "213-s1.s1", CRC(b76b61bc) SHA1(5fdb407d16ab9e33c4f26ee09ff70891ae1d2bd0) )  /* TC531000 */
 
 	NEO_BIOS_AUDIO_128K( "213-m1.m1", CRC(200045f1) SHA1(7a6cd1c8d4447ea260d7ff4520c676b8d685f2e4) )
 
@@ -6072,23 +6077,23 @@
 
 ROM_START( pbobbl2n ) /* MVS ONLY RELEASE */
 	ROM_REGION( 0x100000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "248-p1.p1", 0x000000, 0x100000, CRC(9d6c0754) SHA1(95c70c2d51fc4de01e768e03cc800a850aaad5dc) )
+	ROM_LOAD16_WORD_SWAP( "248-p1.p1", 0x000000, 0x100000, CRC(9d6c0754) SHA1(95c70c2d51fc4de01e768e03cc800a850aaad5dc) ) /* TC538200 */
 
-	NEO_SFIX_128K( "248-s1.s1", CRC(0a3fee41) SHA1(0ab2120e462086be942efcf6ffb37f58ea966ca3) )
+	NEO_SFIX_128K( "248-s1.s1", CRC(0a3fee41) SHA1(0ab2120e462086be942efcf6ffb37f58ea966ca3) ) /* TC531000DP */
 
-	NEO_BIOS_AUDIO_128K( "248-m1.m1", CRC(883097a9) SHA1(677bf9684c0c7977a9a3f0c1288e430040a53b49) )
+	NEO_BIOS_AUDIO_128K( "248-m1.m1", CRC(883097a9) SHA1(677bf9684c0c7977a9a3f0c1288e430040a53b49) ) /* TC531001 */
 
 	ROM_REGION( 0x800000, "ymsnd", 0 )
-	ROM_LOAD( "248-v1.v1", 0x000000, 0x400000, CRC(57fde1fa) SHA1(af39bc141fc35b78dcacfd42b3abb29d7e5c2c89) )
-	ROM_LOAD( "248-v2.v2", 0x400000, 0x400000, CRC(4b966ef3) SHA1(083c0e9fd7b8e506087648cdd8ec4206103984cd) )
+	ROM_LOAD( "248-v1.v1", 0x000000, 0x400000, CRC(57fde1fa) SHA1(af39bc141fc35b78dcacfd42b3abb29d7e5c2c89) ) /* TC5332204 */
+	ROM_LOAD( "248-v2.v2", 0x400000, 0x400000, CRC(4b966ef3) SHA1(083c0e9fd7b8e506087648cdd8ec4206103984cd) ) /* TC5332204 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0xa00000, "sprites", 0 )
-	ROM_LOAD16_BYTE( "248-c1.c1", 0x000000, 0x400000, CRC(d9115327) SHA1(a49aa836a902326cfe785428e1699fefcf8566d4) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "248-c2.c2", 0x000001, 0x400000, CRC(77f9fdac) SHA1(4642d71d32b6a05dc8bfa0f95c936a77c7cef05e) ) /* Plane 2,3 */
-	ROM_LOAD16_BYTE( "248-c3.c3", 0x800000, 0x100000, CRC(8890bf7c) SHA1(a52f6bafd60e72003bfe38c80c1dde24b4983b2a) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "248-c4.c4", 0x800001, 0x100000, CRC(8efead3f) SHA1(f577d2f7c6f850b3d100c36947ad15e33dfa0bed) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "248-c1.c1", 0x000000, 0x400000, CRC(d9115327) SHA1(a49aa836a902326cfe785428e1699fefcf8566d4) ) /* Plane 0,1 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "248-c2.c2", 0x000001, 0x400000, CRC(77f9fdac) SHA1(4642d71d32b6a05dc8bfa0f95c936a77c7cef05e) ) /* Plane 2,3 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "248-c3.c3", 0x800000, 0x100000, CRC(8890bf7c) SHA1(a52f6bafd60e72003bfe38c80c1dde24b4983b2a) ) /* Plane 0,1 */ /* TC538200 */
+	ROM_LOAD16_BYTE( "248-c4.c4", 0x800001, 0x100000, CRC(8efead3f) SHA1(f577d2f7c6f850b3d100c36947ad15e33dfa0bed) ) /* Plane 2,3 */ /* TC538200 */
 ROM_END
 
 /****************************************
@@ -6100,22 +6105,22 @@
 
 ROM_START( ctomaday ) /* MVS ONLY RELEASE */
 	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "249-p1.p1", 0x100000, 0x100000, CRC(c9386118) SHA1(5554662c7bc8605889cac4a67fee05bbb4eb786f) )
+	ROM_LOAD16_WORD_SWAP( "249-p1.p1", 0x100000, 0x100000, CRC(c9386118) SHA1(5554662c7bc8605889cac4a67fee05bbb4eb786f) ) /* TC5316200 */
 	ROM_CONTINUE( 0x000000, 0x100000 )
 
-	NEO_SFIX_128K( "249-s1.s1", CRC(dc9eb372) SHA1(b8aa142243ba303799554479bfc88eb49260f3b1) )
+	NEO_SFIX_128K( "249-s1.s1", CRC(dc9eb372) SHA1(b8aa142243ba303799554479bfc88eb49260f3b1) ) /* TC531000DP */
 
-	NEO_BIOS_AUDIO_128K( "249-m1.m1", CRC(80328a47) SHA1(34b6b1a81eab1cf38834b2eea55454ce1b6100e2) )
+	NEO_BIOS_AUDIO_128K( "249-m1.m1", CRC(80328a47) SHA1(34b6b1a81eab1cf38834b2eea55454ce1b6100e2) ) /* TC531001 */
 
 	ROM_REGION( 0x500000, "ymsnd", 0 )
-	ROM_LOAD( "249-v1.v1", 0x000000, 0x400000, CRC(de7c8f27) SHA1(3681a68a702ab5da8f509b8301d6cada75959332) )
-	ROM_LOAD( "249-v2.v2", 0x400000, 0x100000, CRC(c8e40119) SHA1(738f525c381ed68c0b8a89318a3e4d0089473c45) )
+	ROM_LOAD( "249-v1.v1", 0x000000, 0x400000, CRC(de7c8f27) SHA1(3681a68a702ab5da8f509b8301d6cada75959332) ) /* TC5332204 */
+	ROM_LOAD( "249-v2.v2", 0x400000, 0x100000, CRC(c8e40119) SHA1(738f525c381ed68c0b8a89318a3e4d0089473c45) ) /* TC538200 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0x800000, "sprites", 0 )
-	ROM_LOAD16_BYTE( "249-c1.c1", 0x000000, 0x400000, CRC(041fb8ee) SHA1(dacc84d713d76818d89a26358374afaa22fa82a2) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "249-c2.c2", 0x000001, 0x400000, CRC(74f3cdf4) SHA1(55ddabaf77f4d575f4deb24fe63e4bdc2c6f31e1) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "249-c1.c1", 0x000000, 0x400000, CRC(041fb8ee) SHA1(dacc84d713d76818d89a26358374afaa22fa82a2) ) /* Plane 0,1 */ /* TC5332205 */
+	ROM_LOAD16_BYTE( "249-c2.c2", 0x000001, 0x400000, CRC(74f3cdf4) SHA1(55ddabaf77f4d575f4deb24fe63e4bdc2c6f31e1) ) /* Plane 2,3 */ /* TC5332205 */
 ROM_END
 
 /****************************************
@@ -7569,7 +7574,7 @@
 
 
 /****************************************
- ID-0008 (official?)
+ B-J-02
  . ???-????
  MVS PROGV (2000.11.17) / NEO-MVS CHAFIO (1999.6.14)
 ****************************************/
@@ -7577,7 +7582,7 @@
 ROM_START( jockeygp ) /* MVS ONLY RELEASE */
 	/* Officially licensed? Cart has a holographic 'SNK' sticker applied */
 	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "008-epr.p1", 0x000000, 0x100000, CRC(2fb7f388) SHA1(e3c9b03944b4c10cf5081caaf9c8be1f08c06493) ) /* M27C160 */
+	ROM_LOAD16_WORD_SWAP( "008-epr.p1", 0x000000, 0x100000, CRC(2fb7f388) SHA1(e3c9b03944b4c10cf5081caaf9c8be1f08c06493) )
 	/* P on eprom, correct chip label unknown */
 	ROM_FILL( 0x100000, 0x100000, 0xff )
 
@@ -7590,17 +7595,17 @@
 	ROM_LOAD( "sfix.sfix", 0x000000, 0x20000, CRC(c2ea0cfd) SHA1(fd4a618cdcdbf849374f0a50dd8efe9dbab706c3) )
 
 	/* Encrypted */
-	NEO_BIOS_AUDIO_ENCRYPTED_512K( "008-mg1.m1", CRC(d163c690) SHA1(1dfd04d20c5985037f07cd01000d0b04f3a8f4f4) )
+	NEO_BIOS_AUDIO_ENCRYPTED_512K( "008-mg1.m1", CRC(d163c690) SHA1(1dfd04d20c5985037f07cd01000d0b04f3a8f4f4) ) /* M27C4001 */
 
 	ROM_REGION( 0x0200000, "ymsnd", 0 )
-	ROM_LOAD( "008-v1.v1", 0x000000, 0x200000, CRC(443eadba) SHA1(3def3c22f0e276bc4c2fc7ff70ce473c08b0d2df) )
+	ROM_LOAD( "008-v1.v1", 0x000000, 0x200000, CRC(443eadba) SHA1(3def3c22f0e276bc4c2fc7ff70ce473c08b0d2df) ) /* mask rom TC5316200 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0x1000000, "sprites", 0 )
 	/* Encrypted */
-	ROM_LOAD16_BYTE( "008-c1.c1", 0x0000000, 0x800000, CRC(a9acbf18) SHA1(d55122c70cbe78c2679598dc07863e1d1d1a31df) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "008-c2.c2", 0x0000001, 0x800000, CRC(6289eef9) SHA1(a2ede77bb2468a2e1486d74745a22a5451026039) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "008-c1.c1", 0x0000000, 0x800000, CRC(a9acbf18) SHA1(d55122c70cbe78c2679598dc07863e1d1d1a31df) ) /* Plane 0,1 */ /* mask rom TC5364205 */
+	ROM_LOAD16_BYTE( "008-c2.c2", 0x0000001, 0x800000, CRC(6289eef9) SHA1(a2ede77bb2468a2e1486d74745a22a5451026039) ) /* Plane 2,3 */ /* mask rom TC5364205 */
 ROM_END
 
 ROM_START( jockeygpa ) /* MVS ONLY RELEASE */
@@ -7618,21 +7623,21 @@
 	ROM_LOAD( "sfix.sfix", 0x000000, 0x20000, CRC(c2ea0cfd) SHA1(fd4a618cdcdbf849374f0a50dd8efe9dbab706c3) )
 
 	/* Encrypted */
-	NEO_BIOS_AUDIO_ENCRYPTED_512K( "008-mg1.m1", CRC(d163c690) SHA1(1dfd04d20c5985037f07cd01000d0b04f3a8f4f4) )
+	NEO_BIOS_AUDIO_ENCRYPTED_512K( "008-mg1.m1", CRC(d163c690) SHA1(1dfd04d20c5985037f07cd01000d0b04f3a8f4f4) ) /* M27C4001 */
 
 	ROM_REGION( 0x0200000, "ymsnd", 0 )
-	ROM_LOAD( "008-v1.v1", 0x000000, 0x200000, CRC(443eadba) SHA1(3def3c22f0e276bc4c2fc7ff70ce473c08b0d2df) )
+	ROM_LOAD( "008-v1.v1", 0x000000, 0x200000, CRC(443eadba) SHA1(3def3c22f0e276bc4c2fc7ff70ce473c08b0d2df) ) /* mask rom TC5316200 */
 
 	NO_DELTAT_REGION
 
 	ROM_REGION( 0x1000000, "sprites", 0 )
 	/* Encrypted */
-	ROM_LOAD16_BYTE( "008-c1.c1", 0x0000000, 0x800000, CRC(a9acbf18) SHA1(d55122c70cbe78c2679598dc07863e1d1d1a31df) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "008-c2.c2", 0x0000001, 0x800000, CRC(6289eef9) SHA1(a2ede77bb2468a2e1486d74745a22a5451026039) ) /* Plane 2,3 */
+	ROM_LOAD16_BYTE( "008-c1.c1", 0x0000000, 0x800000, CRC(a9acbf18) SHA1(d55122c70cbe78c2679598dc07863e1d1d1a31df) ) /* Plane 0,1 */ /* mask rom TC5364205 */
+	ROM_LOAD16_BYTE( "008-c2.c2", 0x0000001, 0x800000, CRC(6289eef9) SHA1(a2ede77bb2468a2e1486d74745a22a5451026039) ) /* Plane 2,3 */ /* mask rom TC5364205 */
 ROM_END
 
 /****************************************
- ID-03E7 (incorrect ID-code)
+ B-V-01
  . ???-????
  MVS PROGV (2000.11.17) / MVS CHAV (2000.10.26)
 ****************************************/
@@ -7685,11 +7690,10 @@
  NEO-MVH MVOBR 2003.8.4
 ****************************************/
 
-/* complete redump required */
 ROM_START( ms5pcb ) /* Encrypted Set */
 	ROM_REGION( 0x800000, "maincpu", 0 )
-	ROM_LOAD32_WORD_SWAP( "268-p1r.p1", 0x000000, 0x400000, NO_DUMP )
-	ROM_LOAD32_WORD_SWAP( "268-p2r.p2", 0x000002, 0x400000, NO_DUMP )
+	ROM_LOAD32_WORD_SWAP( "268-p1r.p1", 0x000000, 0x400000, CRC(d0466792) SHA1(880819933d997fab398f91061e9dbccb959ae8a1) )
+	ROM_LOAD32_WORD_SWAP( "268-p2r.p2", 0x000002, 0x400000, CRC(fbf6b61e) SHA1(9ec743d5988b5e3183f37f8edf45c72a8c0c893e) )
 
 	ROM_REGION( 0x20000, "fixed", 0 )
 	ROM_FILL( 0x000000, 0x20000, 0 )
@@ -10090,7 +10094,7 @@
 GAME( 2004, kof2k4se,  kof2002,  neogeo,   neogeo,   kof2k4se, ROT0, "bootleg", "The King of Fighters Special Edition 2004 (The King of Fighters 2002 bootleg)", GAME_SUPPORTS_SAVE ) /* Hack / Bootleg of kof2002 */
 GAME( 2003, mslug5,    neogeo,   neogeo,   neogeo,   mslug5,   ROT0, "SNK Playmore", "Metal Slug 5 (NGM-2680)", GAME_SUPPORTS_SAVE )
 GAME( 2003, mslug5h,   mslug5,   neogeo,   neogeo,   mslug5,   ROT0, "SNK Playmore", "Metal Slug 5 (NGH-2680)", GAME_SUPPORTS_SAVE ) /* Also found in later MVS carts */
-GAME( 2003, ms5pcb,    0,        neogeo,   ms5pcb,   ms5pcb,   ROT0, "SNK Playmore", "Metal Slug 5 (JAMMA PCB)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
+GAME( 2003, ms5pcb,    0,        neogeo,   ms5pcb,   ms5pcb,   ROT0, "SNK Playmore", "Metal Slug 5 (JAMMA PCB)", GAME_SUPPORTS_SAVE )
 GAME( 2003, ms5plus,   mslug5,   neogeo,   neogeo,   ms5plus,  ROT0, "bootleg", "Metal Slug 5 Plus (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2003, svcpcb,    0,        neogeo,   svcpcb,   svcpcb,   ROT0, "SNK Playmore", "SNK vs. Capcom - SVC Chaos (JAMMA PCB, set 1)", GAME_SUPPORTS_SAVE ) // not a clone of neogeo because it's NOT a neogeo cart.
 GAME( 2003, svcpcba,   svcpcb,   neogeo,   svcpcb,   svcpcb,   ROT0, "SNK Playmore", "SNK vs. Capcom - SVC Chaos (JAMMA PCB, set 2)" , GAME_SUPPORTS_SAVE ) /* Encrypted Code */
diff -Nru src-old/mame/drivers/neogeo.c src/mame/drivers/neogeo.c
--- src-old/mame/drivers/neogeo.c	2012-01-31 09:12:07.000000000 +0100
+++ src/mame/drivers/neogeo.c	2012-03-11 11:27:24.000000000 +0100
@@ -36,10 +36,13 @@
 
     1 Slot:
     NEO-MVH MV1
+    NEO-MVH MV1-1
     NEO-MVH MV1A
-    NEO-MVH MV1B
-    NEO-MVH MV1B CHX
-    NEO-MVH MV1C
+     . NEO-MVH MV1A CHX ??
+    NEO-MVH MV1B (1996.1.19)
+     . NEO-MVH MV1B CHX (1996.1.19) ??
+    NEO-MVH MV1B1 (1998.6.17)
+    NEO-MVH MV1C (1999.4.30)
     NEO-MVH MV1F
     NEO-MVH MV1FS
     NEO-MVH MV1FT
diff -Nru src-old/mame/drivers/nwk-tr.c src/mame/drivers/nwk-tr.c
--- src-old/mame/drivers/nwk-tr.c	2012-02-22 21:55:18.000000000 +0100
+++ src/mame/drivers/nwk-tr.c	2012-03-05 23:09:42.000000000 +0100
@@ -748,22 +748,22 @@
 
 ROM_START(racingj)
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
-	ROM_LOAD16_WORD_SWAP("676nc01.bin", 0x000000, 0x200000, CRC(690346b5) SHA1(157ab6788382ef4f5a8772f08819f54d0856fcc8) )
+	ROM_LOAD16_WORD_SWAP("676gnc01.27p", 0x000000, 0x200000, CRC(690346b5) SHA1(157ab6788382ef4f5a8772f08819f54d0856fcc8) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
-	ROM_LOAD32_WORD_SWAP("676a04.bin", 0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
-	ROM_LOAD32_WORD_SWAP("676a05.bin", 0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
+	ROM_REGION32_BE(0x800000, "user2", 0)	/* Data roms */
+	ROM_LOAD32_WORD_SWAP("676a04.16t", 0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
+	ROM_LOAD32_WORD_SWAP("676a05.14t", 0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
 
 	ROM_REGION32_BE(0x800000, "user5", 0)	/* CG Board texture roms */
-	ROM_LOAD32_WORD_SWAP( "676a13.8x",    0x000000, 0x400000, CRC(29077763) SHA1(ee087ca0d41966ca0fd10727055bb1dcd05a0873) )
-	ROM_LOAD32_WORD_SWAP( "676a14.16x",   0x000002, 0x400000, CRC(50a7e3c0) SHA1(7468a66111a3ddf7c043cd400fa175cae5f65632) )
+	ROM_LOAD32_WORD_SWAP( "676a13.8x",  0x000000, 0x400000, CRC(29077763) SHA1(ee087ca0d41966ca0fd10727055bb1dcd05a0873) )
+	ROM_LOAD32_WORD_SWAP( "676a14.16x", 0x000002, 0x400000, CRC(50a7e3c0) SHA1(7468a66111a3ddf7c043cd400fa175cae5f65632) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
 	ROM_LOAD16_WORD_SWAP( "676gna08.7s", 0x000000, 0x080000, CRC(8973f6f2) SHA1(f5648a7e0205f7e979ccacbb52936809ce14a184) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* other roms (textures?) */
-	ROM_LOAD( "676a09.16p",   0x000000, 0x400000, CRC(f85c8dc6) SHA1(8b302c80be309b5cc68b75945fcd7b87a56a4c9b) )
-	ROM_LOAD( "676a10.14p",   0x400000, 0x400000, CRC(7b5b7828) SHA1(aec224d62e4b1e8fdb929d7947ce70d84ba676cf) )
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
+	ROM_LOAD( "676a09.16p", 0x000000, 0x400000, CRC(f85c8dc6) SHA1(8b302c80be309b5cc68b75945fcd7b87a56a4c9b) )
+	ROM_LOAD( "676a10.14p", 0x400000, 0x400000, CRC(7b5b7828) SHA1(aec224d62e4b1e8fdb929d7947ce70d84ba676cf) )
 
 	ROM_REGION(0x2000, "m48t58",0)
 	ROM_LOAD( "676jac_m48t58y.35d", 0x000000, 0x002000, CRC(47e1628c) SHA1(7c42d06ae2f2cd24d083890f333552cbf4f1d3c9) )
@@ -773,19 +773,19 @@
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
 	ROM_LOAD16_WORD_SWAP("888a01.27p", 0x000000, 0x200000, CRC(d077890a) SHA1(08b252324cf46fbcdb95e8f9312287920cd87c5d) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
-	ROM_LOAD32_WORD_SWAP( "676a04.bin",	0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
-	ROM_LOAD32_WORD_SWAP( "676a05.bin",	0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
-	ROM_LOAD32_WORD_SWAP( "888a06.12t",	0x400000, 0x200000, CRC(00cbec4d) SHA1(1ce7807d86e90edbf4eecba462a27c725f5ad862) )
+	ROM_REGION32_BE(0x800000, "user2", 0)	/* Data roms */
+	ROM_LOAD32_WORD_SWAP( "676a04.16t", 0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
+	ROM_LOAD32_WORD_SWAP( "676a05.14t", 0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
+	ROM_LOAD32_WORD_SWAP( "888a06.12t", 0x400000, 0x200000, CRC(00cbec4d) SHA1(1ce7807d86e90edbf4eecba462a27c725f5ad862) )
 
 	ROM_REGION32_BE(0x800000, "user5", 0)	/* CG Board Texture roms */
-	ROM_LOAD32_WORD_SWAP( "888a13.8x",    0x000000, 0x400000, CRC(2292f530) SHA1(0f4d1332708fd5366a065e0a928cc9610558b42d) )
-	ROM_LOAD32_WORD_SWAP( "888a14.16x",   0x000002, 0x400000, CRC(6a834a26) SHA1(d1fbd7ae6afd05f0edac4efde12a5a45aa2bc7df) )
+	ROM_LOAD32_WORD_SWAP( "888a13.8x",  0x000000, 0x400000, CRC(2292f530) SHA1(0f4d1332708fd5366a065e0a928cc9610558b42d) )
+	ROM_LOAD32_WORD_SWAP( "888a14.16x", 0x000002, 0x400000, CRC(6a834a26) SHA1(d1fbd7ae6afd05f0edac4efde12a5a45aa2bc7df) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
-	ROM_LOAD16_WORD_SWAP( "888a08.7s",    0x000000, 0x080000, CRC(55fbea65) SHA1(ad953f758181731efccadcabc4326e6634c359e8) )
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
+	ROM_LOAD16_WORD_SWAP( "888a08.7s", 0x000000, 0x080000, CRC(55fbea65) SHA1(ad953f758181731efccadcabc4326e6634c359e8) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* PCM sample roms */
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
 	ROM_LOAD( "888a09.16p",   0x000000, 0x400000, CRC(11e2fed2) SHA1(24b8a367b59fedb62c56f066342f2fa87b135fc5) )
 	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
@@ -797,21 +797,21 @@
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
 	ROM_LOAD16_WORD_SWAP("888a01.27p", 0x000000, 0x200000, CRC(d077890a) SHA1(08b252324cf46fbcdb95e8f9312287920cd87c5d) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
-	ROM_LOAD32_WORD_SWAP( "676a04.bin",	0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
-	ROM_LOAD32_WORD_SWAP( "676a05.bin",	0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
-	ROM_LOAD32_WORD_SWAP( "888a06.12t",	0x400000, 0x200000, CRC(00cbec4d) SHA1(1ce7807d86e90edbf4eecba462a27c725f5ad862) )
+	ROM_REGION32_BE(0x800000, "user2", 0) /* Data roms */
+	ROM_LOAD32_WORD_SWAP( "676a04.16t", 0x000000, 0x200000, CRC(d7808cb6) SHA1(0668fae5bb94cc120fe196d4b18200f7b512317f) )
+	ROM_LOAD32_WORD_SWAP( "676a05.14t", 0x000002, 0x200000, CRC(fb4de1ad) SHA1(f6aa4eb1b5d22901a2aaf899ed3237a9dfdc55b5) )
+	ROM_LOAD32_WORD_SWAP( "888a06.12t", 0x400000, 0x200000, CRC(00cbec4d) SHA1(1ce7807d86e90edbf4eecba462a27c725f5ad862) )
 
 	ROM_REGION32_BE(0x800000, "user5", 0)	/* CG Board Texture roms */
-	ROM_LOAD32_WORD_SWAP( "888a13.8x",    0x000000, 0x400000, CRC(2292f530) SHA1(0f4d1332708fd5366a065e0a928cc9610558b42d) )
-	ROM_LOAD32_WORD_SWAP( "888a14.16x",   0x000002, 0x400000, CRC(6a834a26) SHA1(d1fbd7ae6afd05f0edac4efde12a5a45aa2bc7df) )
+	ROM_LOAD32_WORD_SWAP( "888a13.8x",  0x000000, 0x400000, CRC(2292f530) SHA1(0f4d1332708fd5366a065e0a928cc9610558b42d) )
+	ROM_LOAD32_WORD_SWAP( "888a14.16x", 0x000002, 0x400000, CRC(6a834a26) SHA1(d1fbd7ae6afd05f0edac4efde12a5a45aa2bc7df) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
-	ROM_LOAD16_WORD_SWAP( "888a08.7s",    0x000000, 0x080000, CRC(55fbea65) SHA1(ad953f758181731efccadcabc4326e6634c359e8) )
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
+	ROM_LOAD16_WORD_SWAP( "888a08.7s", 0x000000, 0x080000, CRC(55fbea65) SHA1(ad953f758181731efccadcabc4326e6634c359e8) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* PCM sample roms */
-	ROM_LOAD( "888a09.16p",   0x000000, 0x400000, CRC(11e2fed2) SHA1(24b8a367b59fedb62c56f066342f2fa87b135fc5) )
-	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
+	ROM_LOAD( "888a09.16p", 0x000000, 0x400000, CRC(11e2fed2) SHA1(24b8a367b59fedb62c56f066342f2fa87b135fc5) )
+	ROM_LOAD( "888a10.14p", 0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
 	ROM_REGION(0x2000, "m48t58",0)
 	ROM_LOAD( "676jae_m48t58y.35d", 0x000000, 0x002000, CRC(1aa43a1f) SHA1(814b691b8a358bf1545a13d595d17070e612e9a4) )
@@ -821,7 +821,7 @@
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
 	ROM_LOAD16_WORD_SWAP("713be01.27p", 0x000000, 0x200000, CRC(d84a7723) SHA1(f4e9e08591b7e5e8419266dbe744d56a185384ed) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
+	ROM_REGION32_BE(0x800000, "user2", 0)	/* Data roms */
 	ROM_LOAD32_WORD_SWAP("713a04.16t", 0x000000, 0x200000, CRC(c994aaa8) SHA1(d82b9930a11e5384ad583684a27c95beec03cd5a) )
 	ROM_LOAD32_WORD_SWAP("713a05.14t", 0x000002, 0x200000, CRC(6f1e6802) SHA1(91f8a170327e9b4ee6a64aee0c106b981a317e69) )
 
@@ -829,12 +829,12 @@
 	ROM_LOAD32_WORD_SWAP( "713a13.8x",    0x000000, 0x400000, CRC(b795c66b) SHA1(6e50de0d5cc444ffaa0fec7ada8c07f643374bb2) )
 	ROM_LOAD32_WORD_SWAP( "713a14.16x",   0x000002, 0x400000, CRC(5275a629) SHA1(16fadef06975f0f3625cac8f84e2e77ed7d75e15) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
-	ROM_LOAD16_WORD_SWAP( "713a08.7s",    0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
+	ROM_LOAD16_WORD_SWAP( "713a08.7s", 0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* PCM sample roms */
-	ROM_LOAD( "713a09.16p",   0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
-	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
+	ROM_LOAD( "713a09.16p", 0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
+	ROM_LOAD( "713a10.14p", 0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
 	ROM_LOAD( "713jae_m48t58y.35d", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
@@ -844,20 +844,20 @@
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
 	ROM_LOAD16_WORD_SWAP("713bb01.27p", 0x000000, 0x200000, CRC(535fe4e8) SHA1(acd8194a4dafce289dbdfd874f0b799f25aeb73f) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
+	ROM_REGION32_BE(0x800000, "user2", 0)	/* Data roms */
 	ROM_LOAD32_WORD_SWAP("713a04.16t", 0x000000, 0x200000, CRC(c994aaa8) SHA1(d82b9930a11e5384ad583684a27c95beec03cd5a) )
 	ROM_LOAD32_WORD_SWAP("713a05.14t", 0x000002, 0x200000, CRC(6f1e6802) SHA1(91f8a170327e9b4ee6a64aee0c106b981a317e69) )
 
 	ROM_REGION32_BE(0x800000, "user5", 0)	/* CG Board Texture roms */
-	ROM_LOAD32_WORD_SWAP( "713a13.8x",    0x000000, 0x400000, CRC(b795c66b) SHA1(6e50de0d5cc444ffaa0fec7ada8c07f643374bb2) )
-	ROM_LOAD32_WORD_SWAP( "713a14.16x",   0x000002, 0x400000, CRC(5275a629) SHA1(16fadef06975f0f3625cac8f84e2e77ed7d75e15) )
+	ROM_LOAD32_WORD_SWAP( "713a13.8x",  0x000000, 0x400000, CRC(b795c66b) SHA1(6e50de0d5cc444ffaa0fec7ada8c07f643374bb2) )
+	ROM_LOAD32_WORD_SWAP( "713a14.16x", 0x000002, 0x400000, CRC(5275a629) SHA1(16fadef06975f0f3625cac8f84e2e77ed7d75e15) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
-	ROM_LOAD16_WORD_SWAP( "713a08.7s",    0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
+	ROM_LOAD16_WORD_SWAP( "713a08.7s", 0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* PCM sample roms */
-	ROM_LOAD( "713a09.16p",   0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
-	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
+	ROM_LOAD( "713a09.16p", 0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
+	ROM_LOAD( "713a10.14p", 0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
 	ROM_LOAD( "713jab_m48t58y.35d", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
@@ -867,20 +867,20 @@
 	ROM_REGION32_BE(0x200000, "user1", 0)	/* PowerPC program roms */
 	ROM_LOAD16_WORD_SWAP("713bb01.27p", 0x000000, 0x200000, CRC(535fe4e8) SHA1(acd8194a4dafce289dbdfd874f0b799f25aeb73f) )
 
-	ROM_REGION32_BE(0x800000, "user2", 0)		/* Data roms */
+	ROM_REGION32_BE(0x800000, "user2", 0)	/* Data roms */
 	ROM_LOAD32_WORD_SWAP("713a04.16t", 0x000000, 0x200000, CRC(c994aaa8) SHA1(d82b9930a11e5384ad583684a27c95beec03cd5a) )
 	ROM_LOAD32_WORD_SWAP("713a05.14t", 0x000002, 0x200000, CRC(6f1e6802) SHA1(91f8a170327e9b4ee6a64aee0c106b981a317e69) )
 
 	ROM_REGION32_BE(0x800000, "user5", 0)	/* CG Board Texture roms */
-	ROM_LOAD32_WORD_SWAP( "713a13.8x",    0x000000, 0x400000, CRC(b795c66b) SHA1(6e50de0d5cc444ffaa0fec7ada8c07f643374bb2) )
-	ROM_LOAD32_WORD_SWAP( "713a14.16x",   0x000002, 0x400000, CRC(5275a629) SHA1(16fadef06975f0f3625cac8f84e2e77ed7d75e15) )
+	ROM_LOAD32_WORD_SWAP( "713a13.8x",  0x000000, 0x400000, CRC(b795c66b) SHA1(6e50de0d5cc444ffaa0fec7ada8c07f643374bb2) )
+	ROM_LOAD32_WORD_SWAP( "713a14.16x", 0x000002, 0x400000, CRC(5275a629) SHA1(16fadef06975f0f3625cac8f84e2e77ed7d75e15) )
 
-	ROM_REGION(0x80000, "audiocpu", 0)		/* 68k program roms */
-	ROM_LOAD16_WORD_SWAP( "713a08.7s",    0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
+	ROM_REGION(0x80000, "audiocpu", 0)	/* 68k program roms */
+	ROM_LOAD16_WORD_SWAP( "713a08.7s", 0x000000, 0x080000, CRC(6a72a825) SHA1(abeac99c5343efacabcb0cdff6d34f9f967024db) )
 
-	ROM_REGION(0x1000000, "rfsnd", 0)		/* PCM sample roms */
-	ROM_LOAD( "713a09.16p",   0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
-	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
+	ROM_REGION(0x1000000, "rfsnd", 0)	/* PCM sample roms */
+	ROM_LOAD( "713a09.16p", 0x000000, 0x400000, CRC(058f250a) SHA1(63b8e60004ec49009633e86b4992c00083def9a8) )
+	ROM_LOAD( "713a10.14p", 0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
 	ROM_LOAD( "713eaa_m48t58y.35d", 0x000000, 0x002000, CRC(056ea8fa) SHA1(23574e0c1d011dab8644f3d98763d4a2d11a05b3)  )
diff -Nru src-old/mame/drivers/opwolf.c src/mame/drivers/opwolf.c
--- src-old/mame/drivers/opwolf.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/opwolf.c	2012-03-07 21:23:54.000000000 +0100
@@ -469,7 +469,7 @@
 static void opwolf_msm5205_vck( device_t *device )
 {
 	opwolf_state *state = device->machine().driver_data<opwolf_state>();
-	int chip = (strcmp(device->tag(), "msm1") == 0) ? 0 : 1;
+	int chip = (strcmp(device->tag(), ":msm1") == 0) ? 0 : 1;
 	if (state->m_adpcm_data[chip] != -1)
 	{
 		msm5205_data_w(device, state->m_adpcm_data[chip] & 0x0f);
diff -Nru src-old/mame/drivers/pacman.c src/mame/drivers/pacman.c
--- src-old/mame/drivers/pacman.c	2012-02-19 01:27:36.000000000 +0100
+++ src/mame/drivers/pacman.c	2012-03-08 10:54:00.000000000 +0100
@@ -506,10 +506,11 @@
 {
 	/* since the sound region in Ali Baba is not contiguous, translate the
        offset into the 0-0x1f range */
+	pacman_state *state = space->machine().driver_data<pacman_state>();
 	if (offset < 0x10)
 		pacman_sound_w(space->machine().device("namco"), offset, data);
 	else if (offset < 0x20)
-		space->machine().generic.spriteram2.u8[offset - 0x10] = data;
+		state->m_spriteram2[offset - 0x10] = data;
 	else
 		pacman_sound_w(space->machine().device("namco"), offset - 0x10, data);
 }
@@ -889,7 +890,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -898,7 +899,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -916,7 +917,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 //  AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 //  AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 //  AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -925,7 +926,7 @@
 //  AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5080, 0x509f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x50a0, 0x50af) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x50a0, 0x50af) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 //  AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 //  AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -940,7 +941,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -949,7 +950,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -980,7 +981,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -989,7 +990,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -1007,14 +1008,14 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4eef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ef0, 0x4eff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ef0, 0x4eff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x4f00, 0x4fff) AM_MIRROR(0xa000) AM_RAM
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(watchdog_reset_w)
 	AM_RANGE(0x5004, 0x5005) AM_MIRROR(0xaf38) AM_WRITE(pacman_leds_w)
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x506f) AM_MIRROR(0xaf00) AM_WRITE(alibaba_sound_w)  /* the sound region is not contiguous */
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2) /* actually at 5050-505f, here to point to free RAM */
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2") /* actually at 5050-505f, here to point to free RAM */
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_enable_w)
@@ -1038,7 +1039,7 @@
 	AM_RANGE(0x4000, 0x43ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_videoram_w) AM_BASE_MEMBER(pacman_state, m_videoram)
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 //  AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP /* unknown */
@@ -1047,7 +1048,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 //  AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -1069,7 +1070,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -1078,7 +1079,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -1094,7 +1095,7 @@
 	AM_RANGE(0x1000, 0x13ff) AM_MIRROR(0xe000) AM_WRITE(s2650games_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x1400, 0x141f) AM_MIRROR(0xe000) AM_WRITE(s2650games_scroll_w)
 	AM_RANGE(0x1420, 0x148f) AM_MIRROR(0xe000) AM_WRITEONLY
-	AM_RANGE(0x1490, 0x149f) AM_MIRROR(0xe000) AM_WRITEONLY AM_BASE_MEMBER(pacman_state, m_s2650games_spriteram)
+	AM_RANGE(0x1490, 0x149f) AM_MIRROR(0xe000) AM_WRITEONLY AM_SHARE("s2650_spriteram")
 	AM_RANGE(0x14a0, 0x14bf) AM_MIRROR(0xe000) AM_WRITE(s2650games_tilesbank_w) AM_BASE_MEMBER(pacman_state, m_s2650games_tileram)
 	AM_RANGE(0x14c0, 0x14ff) AM_MIRROR(0xe000) AM_WRITEONLY
 	AM_RANGE(0x1500, 0x1502) AM_MIRROR(0xe000) AM_WRITENOP
@@ -1102,7 +1103,7 @@
 	AM_RANGE(0x1504, 0x1506) AM_MIRROR(0xe000) AM_WRITENOP
 	AM_RANGE(0x1507, 0x1507) AM_MIRROR(0xe000) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x1508, 0x155f) AM_MIRROR(0xe000) AM_WRITEONLY
-	AM_RANGE(0x1560, 0x156f) AM_MIRROR(0xe000) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x1560, 0x156f) AM_MIRROR(0xe000) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x1570, 0x157f) AM_MIRROR(0xe000) AM_WRITEONLY
 	AM_RANGE(0x1586, 0x1587) AM_MIRROR(0xe000) AM_WRITENOP
 	AM_RANGE(0x15c0, 0x15c0) AM_MIRROR(0xe000) AM_WRITE(watchdog_reset_w)
@@ -1112,7 +1113,7 @@
 	AM_RANGE(0x1580, 0x1580) AM_MIRROR(0xe000) AM_READ_PORT("DSW0")
 	AM_RANGE(0x1800, 0x1bff) AM_MIRROR(0xe000) AM_WRITE(s2650games_videoram_w) AM_BASE_MEMBER(pacman_state, m_videoram)
 	AM_RANGE(0x1c00, 0x1fef) AM_MIRROR(0xe000) AM_RAM
-	AM_RANGE(0x1ff0, 0x1fff) AM_MIRROR(0xe000) AM_WRITEONLY AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x1ff0, 0x1fff) AM_MIRROR(0xe000) AM_WRITEONLY AM_SHARE("spriteram")
 	AM_RANGE(0x2000, 0x2fff) AM_MIRROR(0x8000) AM_ROMBANK("bank2")
 	AM_RANGE(0x4000, 0x4fff) AM_MIRROR(0x8000) AM_ROMBANK("bank3")
 	AM_RANGE(0x6000, 0x6fff) AM_MIRROR(0x8000) AM_ROMBANK("bank4")
@@ -1173,7 +1174,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -1182,7 +1183,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
@@ -1200,7 +1201,7 @@
 	AM_RANGE(0x4400, 0x47ff) AM_MIRROR(0xa000) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pacman_state, m_colorram)
 	AM_RANGE(0x4800, 0x4bff) AM_MIRROR(0xa000) AM_READ(pacman_read_nop) AM_WRITENOP
 	AM_RANGE(0x4c00, 0x4fef) AM_MIRROR(0xa000) AM_RAM
-	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x4ff0, 0x4fff) AM_MIRROR(0xa000) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x5000, 0x5000) AM_MIRROR(0xaf38) AM_WRITE(irq_mask_w)
 	AM_RANGE(0x5001, 0x5001) AM_MIRROR(0xaf38) AM_DEVWRITE("namco", pacman_sound_enable_w)
 	AM_RANGE(0x5002, 0x5002) AM_MIRROR(0xaf38) AM_WRITENOP
@@ -1209,7 +1210,7 @@
 	AM_RANGE(0x5006, 0x5006) AM_MIRROR(0xaf38) AM_WRITENOP // AM_WRITE(pacman_coin_lockout_global_w)
 	AM_RANGE(0x5007, 0x5007) AM_MIRROR(0xaf38) AM_WRITE(pacman_coin_counter_w)
 	AM_RANGE(0x5040, 0x505f) AM_MIRROR(0xaf00) AM_WRITENOP // doesn't use pacman sound hw
-	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x5060, 0x506f) AM_MIRROR(0xaf00) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x5070, 0x507f) AM_MIRROR(0xaf00) AM_WRITENOP
 	AM_RANGE(0x5080, 0x5080) AM_MIRROR(0xaf3f) AM_WRITENOP
 	AM_RANGE(0x50c0, 0x50c0) AM_MIRROR(0xaf3f) AM_WRITE(watchdog_reset_w)
diff -Nru src-old/mame/drivers/pengo.c src/mame/drivers/pengo.c
--- src-old/mame/drivers/pengo.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/pengo.c	2012-03-08 10:54:00.000000000 +0100
@@ -122,9 +122,9 @@
 	AM_RANGE(0x8000, 0x83ff) AM_RAM_WRITE(pacman_videoram_w) AM_BASE_MEMBER(pengo_state, m_videoram) /* video and color RAM, scratchpad RAM, sprite codes */
 	AM_RANGE(0x8400, 0x87ff) AM_RAM_WRITE(pacman_colorram_w) AM_BASE_MEMBER(pengo_state, m_colorram)
 	AM_RANGE(0x8800, 0x8fef) AM_RAM
-	AM_RANGE(0x8ff0, 0x8fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x8ff0, 0x8fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x9000, 0x901f) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x9020, 0x902f) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x9020, 0x902f) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x9000, 0x903f) AM_READ_PORT("DSW1")
 	AM_RANGE(0x9040, 0x907f) AM_READ_PORT("DSW0")
 	AM_RANGE(0x9040, 0x9040) AM_WRITE(irq_mask_w)
@@ -144,9 +144,9 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x87ff) AM_RAM_WRITE(jrpacman_videoram_w) AM_BASE_MEMBER(pengo_state, m_videoram)
 	AM_RANGE(0x8800, 0x8fef) AM_RAM
-	AM_RANGE(0x8ff0, 0x8fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x8ff0, 0x8fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x9000, 0x901f) AM_DEVWRITE("namco", pacman_sound_w)
-	AM_RANGE(0x9020, 0x902f) AM_WRITEONLY AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x9020, 0x902f) AM_WRITEONLY AM_SHARE("spriteram2")
 	AM_RANGE(0x9030, 0x9030) AM_WRITE(jrpacman_scroll_w)
 	AM_RANGE(0x9040, 0x904f) AM_READ_PORT("DSW")
 	AM_RANGE(0x9040, 0x9040) AM_WRITE(irq_mask_w)
diff -Nru src-old/mame/drivers/plygonet.c src/mame/drivers/plygonet.c
--- src-old/mame/drivers/plygonet.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/plygonet.c	2012-03-04 18:26:17.000000000 +0100
@@ -578,9 +578,9 @@
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank2")
 	AM_RANGE(0x0000, 0xbfff) AM_WRITENOP
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("konami1", k054539_r, k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("konami1", k054539_device, read, write)
 	AM_RANGE(0xe230, 0xe3ff) AM_RAM
-	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE("konami2", k054539_r, k054539_w)
+	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE_MODERN("konami2", k054539_device, read, write)
 	AM_RANGE(0xe630, 0xe7ff) AM_RAM
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch3_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -671,13 +671,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.75)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.75)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.75)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.75)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/popobear.c src/mame/drivers/popobear.c
--- src-old/mame/drivers/popobear.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/popobear.c	2012-03-11 18:17:00.000000000 +0100
@@ -1,4 +1,20 @@
-/* Popo Bear - BMC-A00211
+/*******************************************************************************************
+
+    Popo Bear (c) 2000 BMC
+
+    preliminary driver by Angelo Salese
+
+    TODO:
+    - auto-animation speed is erratic (way too fast);
+    - sprites;
+    - tilemap effects (scrolling, colscroll, linescroll);
+    - BGM seems quite off, YM2413 core bug?
+    - I/Os;
+    - IRQ generation;
+    - Port 0x620000 is quite a mystery, some silly protection?
+
+============================================================================================
+Popo Bear - BMC-A00211
 (c) 2000 - Bao Ma Technology Co., LTD
 
 |-----------------------------------------|
@@ -54,10 +70,8 @@
                 26   26
            GND  27   27  GND
            GND  28   28  GND
-*/
+*******************************************************************************************/
 
-// looks like some kind of blitter
-// IGS-like?
 
 #include "emu.h"
 #include "cpu/m68000/m68000.h"
@@ -72,69 +86,233 @@
 		m_maincpu(*this,"maincpu")
 		{ }
 
-
-	UINT16 *popobear_vram;
+	UINT16 *m_vregs;
+	UINT16 *m_vram;
+	UINT16 *m_spr;
 	required_device<cpu_device> m_maincpu;
 };
 
-/* stub read handlers */
+VIDEO_START(popobear)
+{
+
+}
 
-static READ16_HANDLER( popo_480001_r ) { static int i = 0x00;i ^=0xff;return i;}
-static READ16_HANDLER( popo_48001c_r ) { static int i = 0x00;i ^=0xff;return i;}
-static READ16_HANDLER( popo_480020_r ) { static int i = 0x00;i ^=0xff;return i;}
-static READ16_HANDLER( popo_48003a_r ) { static int i = 0x00;i ^=0xff;return i;}
-
-static READ16_HANDLER( popo_500000_r ) { static int i = 0x00;i ^=0xff;return i;}
-static READ16_HANDLER( popo_520000_r ) { static int i = 0x00;i ^=0xff;return i;}
-
-static READ16_HANDLER( popo_620000_r ) { static int i = 0x00;i ^=0xff;return i;}
-
-/* stub write handlers */
-
-static WRITE16_HANDLER( popo_480001_w ) { }
-static WRITE16_HANDLER( popo_480018_w ) { }
-static WRITE16_HANDLER( popo_48001a_w ) { }
-static WRITE16_HANDLER( popo_48001c_w ) { }
-static WRITE16_HANDLER( popo_480020_w ) { }
-static WRITE16_HANDLER( popo_480028_w ) { }
-static WRITE16_HANDLER( popo_48002c_w ) { }
-static WRITE16_HANDLER( popo_480030_w ) { }
-static WRITE16_HANDLER( popo_48003a_w ) { }
+static void draw_layer(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect, UINT8 layer_n)
+{
+	popobear_state *state = machine.driver_data<popobear_state>();
+	UINT8* vram = (UINT8 *)state->m_vram;
+	UINT16* vreg = (UINT16 *)state->m_vregs;
+	int count;
+	const UINT8 vreg_base[] = { 0x10/2, 0x14/2 };
+	int xscroll,yscroll;
+
+//  count = (state->m_vregs[vreg_base[layer_n]]<<5);
+//  count &= 0xfc000;
+	count = (0xf0000+layer_n*0x4000);
+	if(layer_n & 2)
+	{
+		xscroll = vreg[vreg_base[(layer_n & 1) ^ 1]+2/2] & 0x1ff;
+		yscroll = vreg[vreg_base[(layer_n & 1) ^ 1]+0/2] & 0x1ff;
+	}
+	else
+	{
+		xscroll = 0;
+		yscroll = 0;
+	}
 
-static WRITE16_HANDLER( popo_550000_w ) { }
-static WRITE16_HANDLER( popo_550002_w ) { }
+	popmessage("%04x %04x",vreg[vreg_base[0]+0/2],vreg[vreg_base[1]+0/2]);
 
-static WRITE16_HANDLER( popo_600000_w ) { }
-static WRITE16_HANDLER( popo_620000_w ) { }
+	for(int y=0;y<64;y++)
+	{
+		for(int x=0;x<128;x++)
+		{
+			int tile,xtile,ytile;
 
+			tile = vram[count+0]|(vram[count+1]<<8);
+			xtile = tile & 0x7f;
+			xtile *= 8;
+			ytile = tile >> 7;
+			ytile *= 1024*8;
+
+			for(int yi=0;yi<8;yi++)
+			{
+				for(int xi=0;xi<8;xi+=2)
+				{
+					UINT8 color;
+					int xoffs,yoffs;
+
+					xoffs = x*8+xi - xscroll;
+					yoffs = y*8+yi - yscroll;
+
+					color = (vram[((xi+yi*1024)+xtile+ytile) & 0xfffff] & 0xff);
+
+					if(cliprect.contains(xoffs+1, yoffs) && color)
+						bitmap.pix16(yoffs, xoffs+1) = machine.pens[color];
+
+					if(cliprect.contains(xoffs+1, yoffs+512) && color)
+						bitmap.pix16(yoffs+512, xoffs+1) = machine.pens[color];
+
+					//if(cliprect.contains(xoffs+1, yoffs+256) && color)
+					//  bitmap.pix16(yoffs+512, xoffs+1) = machine.pens[color];
+
+					color = (vram[((xi+1+yi*1024)+xtile+ytile) & 0xfffff] & 0xff);
+
+					if(cliprect.contains(xoffs, yoffs) && color)
+						bitmap.pix16(yoffs, xoffs) = machine.pens[color];
+
+					if(cliprect.contains(xoffs, yoffs+512) && color)
+						bitmap.pix16(yoffs+512, xoffs) = machine.pens[color];
+				}
+			}
+
+			count+=2;
+		}
+	}
+}
+
+static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect)
+{
+	popobear_state *state = machine.driver_data<popobear_state>();
+	UINT8* vram = (UINT8 *)state->m_spr;
+	int i;
+	#if 0
+	static int bank_test = 1;
+
+	if(machine.input().code_pressed_once(KEYCODE_Z))
+		bank_test<<=1;
+
+	if(machine.input().code_pressed_once(KEYCODE_X))
+		bank_test>>=1;
+
+	popmessage("%02x",bank_test);
+	#endif
+
+	/*
+    ???? ---- ---- ---- unused?
+    ---- xxxx ---- ---- priority?
+    ---- ---- x--- ---- Y direction
+    ---- ---- -x-- ---- X direction
+    ---- ---- --xx ---- width
+    ---- ---- ---- xx-- color bank
+    ---- ---- ---- --xx height?
+    */
+
+	/* 0x106 = 8 x 8 */
+	/* 0x*29 = 32 x 32 */
+	for(i = 0x800-8;i >= 0; i-=8)
+	{
+		int y = vram[i+0x7f800+2]|(vram[i+0x7f800+3]<<8);
+		int x = vram[i+0x7f800+4]|(vram[i+0x7f800+5]<<8);
+		int spr_num = vram[i+0x7f800+6]|(vram[i+0x7f800+7]<<8);
+		int param = vram[i+0x7f800+0]|(vram[i+0x7f800+1]<<8);
+		int width = 8 << ((param & 0x30)>>4);
+		int height = 32;
+		int color_bank = ((param & 0xc)<<4);
+		int x_dir = param & 0x40;
+		int y_dir = param & 0x80;
+
+		if((param & 0x3) == 3) // actually sprite mode?
+			color_bank |= 0x20;
+
+		if(param == 0)
+			continue;
+
+		//if(param & bank_test)
+		//  continue;
+
+		spr_num <<= 3;
+
+		for(int yi=0;yi<height;yi++)
+		{
+			for(int xi=0;xi<width;xi+=2)
+			{
+				UINT8 color;
+				int x_res,y_res;
+
+				color = (vram[spr_num] & 0xff);
+				x_res = (x_dir) ? x+0+(width - xi) : x+1+xi;
+				y_res = (y_dir) ? y+(height - yi) : y+yi;
+
+				if(cliprect.contains(x_res, y_res) && color)
+					bitmap.pix16(y_res, x_res) = machine.pens[color+0x100+color_bank];
+
+				color = (vram[spr_num+1] & 0xff);
+				x_res = (x_dir) ? x+1+(width - xi) : x+0+xi;
+				y_res = (y_dir) ? y+(height - yi) : y+yi;
+
+				if(cliprect.contains(x_res, y_res) && color)
+					bitmap.pix16(y_res, x_res) = machine.pens[color+0x100+color_bank];
+
+				spr_num+=2;
+			}
+		}
+	}
+}
+
+SCREEN_UPDATE_IND16( popobear )
+{
+//  popobear_state *state = screen.machine().driver_data<popobear_state>();
+
+	bitmap.fill(0, cliprect);
+
+	//popmessage("%04x",state->m_vregs[0/2]);
+
+	draw_layer(screen.machine(),bitmap,cliprect,3);
+	draw_layer(screen.machine(),bitmap,cliprect,2);
+	draw_layer(screen.machine(),bitmap,cliprect,1);
+	draw_layer(screen.machine(),bitmap,cliprect,0);
+	draw_sprites(screen.machine(),bitmap,cliprect);
+
+	return 0;
+}
+
+/* ??? */
+static READ8_HANDLER( popo_620000_r )
+{
+	return 9;
+}
+
+static WRITE8_HANDLER( popobear_irq_ack_w )
+{
+	popobear_state *state = space->machine().driver_data<popobear_state>();
+	int i;
+
+	for(i=0;i<8;i++)
+	{
+		if(data & 1 << i)
+			device_set_input_line(state->m_maincpu, i, CLEAR_LINE);
+	}
+}
 
 static ADDRESS_MAP_START( popobear_mem, AS_PROGRAM, 16 )
+	ADDRESS_MAP_UNMAP_HIGH
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x210000, 0x21ffff) AM_RAM
-	AM_RANGE(0x3E0000, 0x3EFFFF) AM_RAM  AM_BASE_MEMBER(popobear_state, popobear_vram)
+	AM_RANGE(0x280000, 0x2fffff) AM_RAM AM_BASE_MEMBER(popobear_state, m_spr) // unknown boundaries, 0x2ff800 contains a sprite list
+	AM_RANGE(0x300000, 0x3fffff) AM_RAM AM_BASE_MEMBER(popobear_state, m_vram)
 
-	/* Blitter stuff? */
-	AM_RANGE(0x480000, 0x480001) AM_READ(popo_480001_r) AM_WRITE(popo_480001_w)
-	AM_RANGE(0x480018, 0x480019) AM_WRITE(popo_480018_w)
-	AM_RANGE(0x48001a, 0x48001b) AM_WRITE(popo_48001a_w)
-	AM_RANGE(0x48001c, 0x48001d) AM_READ(popo_48001c_r) AM_WRITE(popo_48001c_w)
-	AM_RANGE(0x480020, 0x480021) AM_READ(popo_480020_r) AM_WRITE(popo_480020_w)
-	AM_RANGE(0x480028, 0x480029) AM_WRITE(popo_480028_w)
-	AM_RANGE(0x48002c, 0x48002d) AM_WRITE(popo_48002c_w)
-	AM_RANGE(0x480030, 0x480031) AM_WRITE(popo_480030_w)
-	AM_RANGE(0x48003a, 0x48003b) AM_READ(popo_48003a_r) AM_WRITE(popo_48003a_w)
-
-	AM_RANGE(0x480400, 0x48041f) AM_RAM AM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram) // looks palette like at least
-
-	/* I/O maybe? */
-	AM_RANGE(0x500000, 0x500001) AM_READ(popo_500000_r)
-	AM_RANGE(0x520000, 0x520001) AM_READ(popo_520000_r)
-	AM_RANGE(0x550000, 0x550001) AM_WRITE(popo_550000_w)
-	AM_RANGE(0x550002, 0x550003) AM_WRITE(popo_550002_w)
-
-	/* these could be where the OKI hooks up? */
-	AM_RANGE(0x600000, 0x600001) AM_WRITE(popo_600000_w)
-	AM_RANGE(0x620000, 0x620001) AM_READ(popo_620000_r) AM_WRITE(popo_620000_w)
+	/* Most if not all of these are vregs */
+	AM_RANGE(0x480000, 0x48001f) AM_RAM AM_BASE_MEMBER(popobear_state, m_vregs)
+	AM_RANGE(0x480020, 0x480023) AM_RAM
+	AM_RANGE(0x480028, 0x48002d) AM_RAM
+//  AM_RANGE(0x480020, 0x480021) AM_NOP //AM_READ(popo_480020_r) AM_WRITE(popo_480020_w)
+//  AM_RANGE(0x480028, 0x480029) AM_NOP //AM_WRITE(popo_480028_w)
+//  AM_RANGE(0x48002c, 0x48002d) AM_NOP //AM_WRITE(popo_48002c_w)
+	AM_RANGE(0x480030, 0x480031) AM_WRITE8(popobear_irq_ack_w, 0x00ff)
+	AM_RANGE(0x480034, 0x480035) AM_RAM // coin counter or coin lockout
+	AM_RANGE(0x48003a, 0x48003b) AM_RAM //AM_READ(popo_48003a_r) AM_WRITE(popo_48003a_w)
+
+	AM_RANGE(0x480400, 0x4807ff) AM_RAM AM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
+
+	AM_RANGE(0x500000, 0x500001) AM_READ_PORT("IN0")
+	AM_RANGE(0x520000, 0x520001) AM_READ_PORT("IN1")
+	AM_RANGE(0x540000, 0x540001) AM_DEVREADWRITE8_MODERN("oki", okim6295_device, read, write, 0x00ff)
+	AM_RANGE(0x550000, 0x550003) AM_DEVWRITE8( "ymsnd", ym2413_w, 0x00ff )
+
+	AM_RANGE(0x600000, 0x600001) AM_WRITENOP
+	AM_RANGE(0x620000, 0x620001) AM_READ8(popo_620000_r,0xff00) AM_WRITENOP
+	AM_RANGE(0x800000, 0x9fffff) AM_ROM AM_REGION("gfx1", 0) // u5 & u6
+	AM_RANGE(0xa00000, 0xbfffff) AM_ROM AM_REGION("gfx2", 0) // u7 & u8
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( popobear )
@@ -189,135 +367,93 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 
-	PORT_START("DSW3")
-	PORT_DIPNAME( 0x01, 0x00, "DSW3:1" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x00, "DSW3:2" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x00, "DSW3:3" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x00, "DSW3:4" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, "DSW3:5" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, "DSW3:6" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x00, "DSW3:7" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "DSW3:8" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
-
-	PORT_START("DSW4")
-	PORT_DIPNAME( 0x01, 0x00, "DSW4:1" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x00, "DSW4:2" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x00, "DSW4:3" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x00, "DSW4:4" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x00, "DSW4:5" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x00, "DSW4:6" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x00, "DSW4:7" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x00, "DSW4:8" )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
-
+	PORT_START("IN0")
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
+	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(2)
+	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(1)
+	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
+	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_PLAYER(1)
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN1")
+	PORT_DIPNAME( 0x01, 0x01, "DSWA" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2)
+	PORT_DIPNAME( 0x0200, 0x0200, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x0200, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0400, 0x0400, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x0400, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0800, 0x0800, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x0800, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x1000, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
+	PORT_DIPNAME( 0x2000, 0x2000, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x2000, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x0000, DEF_STR( On ) )
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x8000, IP_ACTIVE_LOW, IPT_START1 )
 INPUT_PORTS_END
 
 
-static const gfx_layout tilelayout =
-{
-	4,8,
-	RGN_FRAC(1,1),
-	8,
-	{ 0,1,2,3,4,5,6,7 },
-	{ 24, 16, 8, 0 },
-	{ 0*32, 1*32, 2*32, 3*32, 4*32, 5*32, 6*32, 7*32 },
-	8*32
-};
-
-// gfx don't seem to be tiles..
-static GFXDECODE_START( popobear )
-	GFXDECODE_ENTRY( "gfx1", 0, tilelayout,  0, 1 )
-	GFXDECODE_ENTRY( "gfx2", 0, tilelayout,  0, 1 )
-GFXDECODE_END
-
-
-SCREEN_UPDATE_IND16( popobear )
-{
-	popobear_state *state = screen.machine().driver_data<popobear_state>();
-	bitmap.fill(0, cliprect);
-
-	UINT16* popobear_vram = state->popobear_vram;
-	int count = 0;
-	for (int y=0;y<256;y++)
-	{
-		for (int x=0;x<128;x++)
-		{
-			UINT8 dat;
-			dat = (popobear_vram[count]&0xf000)>>12;
-			bitmap.pix16(y, (x*4)+0) =dat;
-
-			dat = (popobear_vram[count]&0x0f00)>>8;
-			bitmap.pix16(y, (x*4)+1) =dat;
-
-			dat = (popobear_vram[count]&0x00f0)>>4;
-			bitmap.pix16(y, (x*4)+2) =dat;
-
-			dat = (popobear_vram[count]&0x000f)>>0;
-			bitmap.pix16(y, (x*4)+3) =dat;
-
-			count++;
-		}
-	}
-
-	return 0;
-}
-
-VIDEO_START(popobear)
-{
-
-}
-
 static TIMER_DEVICE_CALLBACK( popobear_irq )
 {
 	popobear_state *state = timer.machine().driver_data<popobear_state>();
 	int scanline = param;
 
+	/* Order is trusted (5 as vblank-out makes the title screen logo spinning to behave wrongly) */
 	if(scanline == 240)
-		device_set_input_line(state->m_maincpu, 2, HOLD_LINE);
+		device_set_input_line(state->m_maincpu, 3, ASSERT_LINE);
 
-	if(scanline == 128)
-		device_set_input_line(state->m_maincpu, 3, HOLD_LINE);
+	if(scanline == 0)
+		device_set_input_line(state->m_maincpu, 5, ASSERT_LINE);
 
-	if(scanline == 32)
-		device_set_input_line(state->m_maincpu, 5, HOLD_LINE);
+	/* TODO: actually a timer irq, tied with YM2413 sound chip (controls BGM tempo) */
+	if(scanline == 64 || scanline == 192)
+		device_set_input_line(state->m_maincpu, 2, ASSERT_LINE);
 }
 
 static MACHINE_CONFIG_START( popobear, popobear_state )
 	MCFG_CPU_ADD("maincpu", M68000, XTAL_42MHz/4)  // XTAL CORRECT, DIVISOR GUESSED
 	MCFG_CPU_PROGRAM_MAP(popobear_mem)
 	// levels 2,3,5 look interesting
-	//MCFG_CPU_VBLANK_INT("screen",irq3_line_hold)
+	//MCFG_CPU_VBLANK_INT("screen",irq5_line_assert)
+	//MCFG_CPU_PERIODIC_INT(irq2_line_assert,120)
 	MCFG_TIMER_ADD_SCANLINE("scantimer", popobear_irq, "screen", 0, 1)
 
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -325,23 +461,21 @@
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500)) /* not accurate */
 	MCFG_SCREEN_UPDATE_STATIC(popobear)
 
-	MCFG_GFXDECODE(popobear)
+//  MCFG_GFXDECODE(popobear)
 
-	MCFG_SCREEN_SIZE(64*8, 32*8)
+	MCFG_SCREEN_SIZE(128*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 64*8-1, 0*8, 32*8-1)
-	MCFG_PALETTE_LENGTH(256)
+	MCFG_PALETTE_LENGTH(256*2)
 
 	MCFG_VIDEO_START(popobear)
 
-	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
+	MCFG_SPEAKER_STANDARD_MONO("mono")
+
+	MCFG_SOUND_ADD("ymsnd", YM2413, XTAL_42MHz/16)  // XTAL CORRECT, DIVISOR GUESSED
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("ym2413", YM2413, XTAL_42MHz/10)  // XTAL CORRECT, DIVISOR GUESSED
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 1.00)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 1.00)
-
-	MCFG_OKIM6295_ADD("oki", XTAL_42MHz/10/4, OKIM6295_PIN7_LOW)  // XTAL CORRECT, DIVISOR GUESSED
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
+	MCFG_OKIM6295_ADD("oki", XTAL_42MHz/32, OKIM6295_PIN7_LOW)  // XTAL CORRECT, DIVISOR GUESSED
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
 
@@ -351,15 +485,15 @@
 	ROM_LOAD16_BYTE( "popobear_en-a-401_1.6.u4", 0x000000, 0x20000, CRC(0568af9c) SHA1(920531dbc4bbde2d1db062bd5c48b97dd50b7185) )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
-	ROM_LOAD16_BYTE(	"popobear_en-a-501.u5", 0x000000, 0x100000, CRC(185901a9) SHA1(7ff82b5751645df53435eaa66edce589684cc5c7) )
-	ROM_LOAD16_BYTE(	"popobear_en-a-601.u6", 0x000001, 0x100000, CRC(84fa9f3f) SHA1(34dd7873f88b0dae5fb81fe84e82d2b6b49f7332) )
+	ROM_LOAD16_BYTE( "popobear_en-a-501.u5", 0x000000, 0x100000, CRC(185901a9) SHA1(7ff82b5751645df53435eaa66edce589684cc5c7) )
+	ROM_LOAD16_BYTE( "popobear_en-a-601.u6", 0x000001, 0x100000, CRC(84fa9f3f) SHA1(34dd7873f88b0dae5fb81fe84e82d2b6b49f7332) )
 
 	ROM_REGION( 0x200000, "gfx2", 0 )
-	ROM_LOAD16_BYTE(	"popobear_en-a-701.u7", 0x000000, 0x100000, CRC(45eba6d0) SHA1(0278602ed57ac45040619d590e6cc85e2cfeed31) )
-	ROM_LOAD16_BYTE(	"popobear_en-a-801.u8", 0x000001, 0x100000, CRC(2760f2e6) SHA1(58af59f486c9df930f7c124f89154f8f389a5bd7) )
+	ROM_LOAD16_BYTE( "popobear_en-a-701.u7", 0x000000, 0x100000, CRC(45eba6d0) SHA1(0278602ed57ac45040619d590e6cc85e2cfeed31) )
+	ROM_LOAD16_BYTE( "popobear_en-a-801.u8", 0x000001, 0x100000, CRC(2760f2e6) SHA1(58af59f486c9df930f7c124f89154f8f389a5bd7) )
 
 	ROM_REGION( 0x040000, "oki", 0 ) /* Samples */
 	ROM_LOAD( "popobear_ta-a-901.u9", 0x00000, 0x40000,  CRC(f1e94926) SHA1(f4d6f5b5811d90d0069f6efbb44d725ff0d07e1c) )
 ROM_END
 
-GAME( 2000, popobear,    0, popobear,    popobear,    0, ROT0,  "BMC", "PoPo Bear", GAME_NOT_WORKING | GAME_IS_SKELETON )
+GAME( 2000, popobear,    0, popobear,    popobear,    0, ROT0,  "BMC", "PoPo Bear", GAME_NOT_WORKING | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/psikyosh.c src/mame/drivers/psikyosh.c
--- src-old/mame/drivers/psikyosh.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/psikyosh.c	2012-03-08 08:39:27.000000000 +0100
@@ -516,7 +516,7 @@
 	AM_RANGE(0x00000000, 0x000fffff) AM_ROM // program ROM (1 meg)
 	AM_RANGE(0x02000000, 0x021fffff) AM_ROMBANK("bank1") // data ROM
 // video chip
-	AM_RANGE(0x03000000, 0x03003fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) // video banks0-7 (sprites and sprite list)
+	AM_RANGE(0x03000000, 0x03003fff) AM_RAM AM_SHARE("spriteram") // video banks0-7 (sprites and sprite list)
 	AM_RANGE(0x03004000, 0x0300ffff) AM_RAM AM_BASE_MEMBER(psikyosh_state, m_bgram) // video banks 7-0x1f (backgrounds and other effects)
 	AM_RANGE(0x03040000, 0x03044fff) AM_RAM_WRITE(paletteram32_RRRRRRRRGGGGGGGGBBBBBBBBxxxxxxxx_dword_w) AM_BASE_MEMBER(psikyosh_state, m_paletteram) // palette..
 	AM_RANGE(0x03050000, 0x030501ff) AM_RAM AM_BASE_MEMBER(psikyosh_state, m_zoomram) // sprite zoom lookup table
@@ -544,7 +544,7 @@
 // sound chip
 	AM_RANGE(0x03100000, 0x03100007) AM_DEVREADWRITE8("ymf", ymf278b_r, ymf278b_w, 0xffffffff)
 // video chip
-	AM_RANGE(0x04000000, 0x04003fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) // video banks0-7 (sprites and sprite list)
+	AM_RANGE(0x04000000, 0x04003fff) AM_RAM AM_SHARE("spriteram") // video banks0-7 (sprites and sprite list)
 	AM_RANGE(0x04004000, 0x0400ffff) AM_RAM AM_BASE_MEMBER(psikyosh_state, m_bgram) // video banks 7-0x1f (backgrounds and other effects)
 	AM_RANGE(0x04040000, 0x04044fff) AM_RAM_WRITE(paletteram32_RRRRRRRRGGGGGGGGBBBBBBBBxxxxxxxx_dword_w) AM_BASE_MEMBER(psikyosh_state, m_paletteram)
 	AM_RANGE(0x04050000, 0x040501ff) AM_RAM AM_BASE_MEMBER(psikyosh_state, m_zoomram) // sprite zoom lookup table
@@ -819,7 +819,7 @@
 	MCFG_EEPROM_DEFAULT_VALUE(0)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM ) /* If using alpha */
+	MCFG_BUFFERED_SPRITERAM32_ADD("spriteram") /* If using alpha */
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -827,7 +827,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0, 40*8-1, 0, 28*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(psikyosh)
-	MCFG_SCREEN_VBLANK_STATIC(psikyosh)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram32_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(psikyosh)
 	MCFG_PALETTE_LENGTH(0x5000/4)
diff -Nru src-old/mame/drivers/pyson.c src/mame/drivers/pyson.c
--- src-old/mame/drivers/pyson.c	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/drivers/pyson.c	2012-03-11 18:17:00.000000000 +0100
@@ -0,0 +1,261 @@
+/***************************************************************************
+
+Konami Pyson Hardware Overview
+Konami 2001-2005
+
+This system uses a standard GH-006 PS2 main board (the older Playstation 2 square type) with a
+Sony-supplied PS2 power supply which bolts onto the top of the main board. This power supply
+has a single 12 volt power input and creates all of the voltages for the PS2. The same 12 volt input
+extends via a splitter to the Konami interface PCB into CN3. The PS2 main board is connected to the
+custom Konami interface PCB via the PS2 main board AV connector and the IEEE 1394 'i.LINK' connector.
+A security dongle with no label on the top which looks like a PS2 memory card is plugged into the left
+PS2 memory card slot. This card is identical to the dongles used in Namco System 246/256. Note that the
+two games dumped so far have the same label on the security dongle (KN00002) but the ROM inside is not
+identical. So far all the Konami game software resides on a 128M CF card. However there are probably
+HDD/CDROM/DVDROM-based games too since the Konami interface board has connectors for IDE drives.
+
+Games known to run on this system include....                      DIN5
+                                                       CF Card     Dongle                 PS2 Cart
+Game Title                                             Label       Label                  Label (bottom)
+---------------------------------------------------------------------------------------------------------
+*Baseball Heroes 2005
+*Battle Climaxx!
+*Battle Climaxx! 2
+*Dog Station
+*Dog Station Deluxe
+*Hawaiian De Golf
+*Monster Gate Online
+*Monster Gate Online 2
+*Nice Smash!
+*Paintball Mania
+*Perfect Pool
+*Pool Pocket Fortunes
+*R.P.M. Red
+World Soccer Winning Eleven Arcade Game Style          C18JAA03    DIN5 dongle GCC27JA    KN00002
+World Soccer Winning Eleven Arcade Game Style 2003     C27JAA03    not used               KN00002
+---------------------------------------------------------------------------------------------------------
+
+* denotes not dumped. If you can help with the remaining undumped games
+please contact us via http://mamedev.org or http://guru.mameworld.info
+
+
+Konami PCB Layout
+-----------------
+
+PWB0000106626
+KONAMI 2001
+  |-----------------------------------------|
+  |          CN5  CN7  CN2               CN3|
+|-|                                         |
+|   TD62064        LM358   |------|  BA7078 |
+|               3793       |VS218 |  25MHz  |
+|      056879      LM358   |      |      CN9|
+|J                         |------|     LED3|
+|A                                      LED4|
+|M                 LM358       D72872GC LED5|
+|M                                 24MHz    |
+|A     ADC0838     6379                 CN12|
+|        LM358                              |
+|                                           |
+|  LED6-13                              CN13|
+|-|                                         |
+  |                    |--------|           |
+  |                    |TOSHIBA |           |
+|-|                    |TMPR3927|           |
+|    DS14C232          |        |           |
+|                      |--------|           |
+|                  8.4MHz                   |
+|C                                          |
+|N               48LC2M32B2                 |
+|1                                  CN16    |
+|5       XC9536   B22A01.U42            CN17|
+|                           XCS10XL         |
+|                M48T58Y.U48                |
+|                            DS2430         |
+|       DS14C232                            |
+|-|                                         |
+  |SW4   CN19     CN20           CN21       |
+  |-----------------------------------------|
+Notes:
+      LM358      - National LM358 Dual Operational Amplifier (SOIC8)
+      6379       - NEC uPD6379A 2-Channel 16-bit D/A Cconverter (SOIC8)
+      3793       - Fujitsu MB3793-A Power Voltage Monitoring IC with Watchdog Timer (SOIC8)
+      TD62064    - Toshiba TDA62064 Darlington Transistor Array
+      BA7078     - ROHM BA7078 Sync Separator / Sync Detection IC (SOIC18)
+      VS218      - National VS218ALC4 (video-related?) (TQFP144)
+      D72872GC   - NEC D72872GC IEEE 1394 controller (TQFP120)
+      056879     - Konami custom 056879 (QFP120)
+      ADC0838    - National ADC0838 8-Bit Serial I/O A/D Converter with Multiplexer Option (SOIC20)
+      DS14C232   - National DS14C232 Low Power +5V Powered TIA/EIA-232 Dual Driver/Receiver (SOIC16)
+      TMPR3927   - Toshiba TMPR3927 32-bit R3000A-based RISC micro-controller (QFP240)
+      48LC2M32B2 - Micron 48LC2M32B2 512k x32-bit x4-banks (64MBit) SDRAM (TSOP86)
+      XC9536     - Xilinx XC9536XL CPLD stamped 'QB22A1' (PLCC44)
+      B22A01.U42 - Fujitsu MBM29F400 512k x8-bit flash ROM stamped 'B22A01' (TSOP48). This is probably
+                   the common-to-all-games Pyson BIOS for the TMPR3927
+      XCS10XL    - Xilinx Spartan XCS10XL FPGA (TQFP144)
+      M48T58Y    - ST Microelectronics M48T58Y 8k Timekeeper/NVRAM (DIP28). As well as being used for protection
+                   with the Konami game code/year etc (the usual first 16 bytes) it also seems to contain code
+                   or other data in some of the games, meaning it's not possible to hand-create the NVRAMs.
+                   The same 'extended usage' of this chip is also present on Konami Viper PCBs.
+      DS2430     - Dallas DS2430 256-bit EEPROM and silicon serial number (3 pin TO-92 package)
+      CN2        - RJ45 network connector
+      CN3        - 5 pin power input connector (12 volts only)
+      CN5/7      - RCA jacks for unamplified stereo audio output
+      CN9        - 13 pin audio/video connector joined with a cable to the PS2 main board AV connector
+      CN12       - IEEE 1394 connector joined with a cable to the PS2 main board 'i.LINK' connector
+      CN13       - 4 pin power connector (unused)
+      CN15       - 28 way edge connector which connects to the filter board along with the JAMMA edge connector
+      CN16       - 40 pin standard IDE connector (for CDROM/DVDROM or 3.5" IDE HDD)
+      CN17       - 44 pin standard IDE connector (for 2.5" IDE HDD)
+      CN19       - DIN5 connector for plug-in security module. The module contains a Dallas DS2430 which
+                   effectively replaces the common-to-most-games one on the main board (same a Viper h/w)
+      CN20       - 4 pin connector
+      CN21       - Standard Compact Flash card slot
+      SW4        - 4 position DIP switch
+
+
+Filter Board
+------------
+
+This plugs into the Konami interface board at 90 degrees via the 2x 28-way female connectors
+All components face the Konami interface PCB. Only the JVS power connectors, JAMMA and CN* are externally accessible.
+
+PWB0000121667 2002 KONAMI
+|----------------------------|      |------------------------------|
+|   CN4   CN5  CN7     CN14  |------|            JAMMA             |------|
+|                                                                         |
+|               LMH6643 DS485                                     8PIN_JVS|
+|   HD64F3664   XC9536                                                    |
+|CN1  14MHz                                                               |
+|               LMH6643                                 TPC8013   6PIN_JVS|
+|                                                                         |
+|         28-WAY-FEMALE                      28-WAY-FEMALE                |
+|-------------------------------------------------------------------------|
+Notes:
+      CN4      - 8-pin mini-DIN connector
+      CN5/7    - 15-pin VGA connectors
+      CN14     - Standard USB connector. This connects to a standard JVS I/O board. It was tested with
+                 a common Sega JVS I/O and works fine however Konami probably have their own JVS I/O board
+                 for use with this system
+     HD64F3664 - Hitachi HD64F3664 H8/3664 micro-controller stamped 'C18B6' or 'C18A6' (QFP64)
+     XC9536    - Xilinx XC9536 CPLD stamped 'EC18B1' (PLCC44)
+     DS485     - National DS485 Low-Power Transceiver for RS-485 and RS-422 Communication (SOIC8)
+     LMH6643   - National LMH6643 3V, Low Power, 130MHz, 75mA Rail-to-Rail Output Amplifier (SOIC8)
+     TPC8013   - Toshiba TPC8013 Silicon N Channel MOS Type Field Effect Transistor (SOIC8)
+     28-WAY*   - 28-Way Female connectors. These both plug into the Konami interface board
+     JAMMA     - Standard Jamma Edge Connector (not used)
+     8PIN_JVS  - Common JVS Power Connectors (on other side of the PCB)
+     6PIN_JVS  /
+
+***************************************************************************/
+
+#define ADDRESS_MAP_MODERN
+
+#include "emu.h"
+#include "cpu/mips/mips3.h"
+#include "cpu/mips/r3000.h"
+
+
+class pyson_state : public driver_device
+{
+public:
+	pyson_state(const machine_config &mconfig, device_type type, const char *tag)
+		: driver_device(mconfig, type, tag),
+		  m_maincpu(*this, "maincpu")
+	{ }
+
+	UINT32 screen_update(screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect);
+
+protected:
+
+	// devices
+	required_device<cpu_device> m_maincpu;
+
+	// driver_device overrides
+	virtual void video_start();
+};
+
+
+void pyson_state::video_start()
+{
+}
+
+UINT32 pyson_state::screen_update(screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect)
+{
+	return 0;
+}
+
+static ADDRESS_MAP_START(ps2_map, AS_PROGRAM, 32, pyson_state)
+	AM_RANGE(0x00000000, 0x01ffffff) AM_RAM	// 32 MB RAM in consumer PS2s, do these have more?
+	AM_RANGE(0x1fc00000, 0x1fdfffff) AM_ROM AM_REGION("bios", 0)
+ADDRESS_MAP_END
+
+static INPUT_PORTS_START( pyson )
+INPUT_PORTS_END
+
+static const mips3_config r5000_config =
+{
+	16384,				/* code cache size - probably wrong */
+	16384				/* data cache size */
+};
+
+static MACHINE_CONFIG_START( pyson, pyson_state )
+	MCFG_CPU_ADD("maincpu", R5000LE, 294000000)	// imported from namcops2.c driver
+	MCFG_CPU_PROGRAM_MAP(ps2_map)
+	MCFG_CPU_CONFIG(r5000_config)
+
+	/* video hardware */
+	MCFG_SCREEN_ADD("screen", RASTER)
+	MCFG_SCREEN_REFRESH_RATE(60)
+	MCFG_SCREEN_UPDATE_DRIVER(pyson_state, screen_update)
+	MCFG_SCREEN_SIZE(640, 480)
+	MCFG_SCREEN_VISIBLE_AREA(0, 639, 0, 479)
+
+	MCFG_PALETTE_LENGTH(65536)
+MACHINE_CONFIG_END
+
+#define PYSON_BIOS	\
+        ROM_LOAD( "b22a01.u42", 0x000000, 0x080000, CRC(98de405e) SHA1(4bc268a996825c1bdf6ae277d331fe7bdc0cc00c) )
+
+ROM_START( pyson )
+	ROM_REGION(0x200000, "bios", 0)
+	PYSON_BIOS
+
+	ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+	DISK_REGION("drive_0")
+ROM_END
+
+ROM_START( wswe )
+	ROM_REGION(0x200000, "bios", 0)
+	PYSON_BIOS
+
+	ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+        ROM_LOAD( "kn00002.ic002",     0x000000, 0x800000, CRC(bd1770aa) SHA1(be217d6d7648e529953ea25caad904394919644c) )
+        ROM_LOAD( "kn00002_spr.ic002", 0x800000, 0x040000, CRC(296c8436) SHA1(c0da440b50dba4ca8eb2b1ee7b6de681769fcf65) )
+
+	ROM_REGION(0x2000, "timekeeper", ROMREGION_ERASE00)
+        ROM_LOAD( "m48t58y.u48",       0x000000, 0x002000, CRC(d4181cb5) SHA1(c5560d1ac043bfe2527fac3fb1989fa8fc53cf8a) )
+
+	DISK_REGION("drive_0")
+	DISK_IMAGE_READONLY( "c18jaa03", 0, SHA1(b47190aa38f1f3a499b817758e3f29fac54391bd) )
+ROM_END
+
+ROM_START( wswe2k3 )
+	ROM_REGION(0x200000, "bios", 0)
+	PYSON_BIOS
+
+	ROM_REGION(0x840000, "key", ROMREGION_ERASE00)
+        ROM_LOAD( "kn00002.ic002",     0x000000, 0x800000, CRC(6f5b7309) SHA1(5e9d75497c3a3a92af41b20e41991c9c5837d50a) )
+        ROM_LOAD( "kn00002_spr.ic002", 0x800000, 0x040000, CRC(433f7ad9) SHA1(4fd05124d59cdbedd781580e49ff940c5df67d94) )
+
+	ROM_REGION(0x2000, "timekeeper", ROMREGION_ERASE00)
+        ROM_LOAD( "m48t58y.u48",       0x000000, 0x002000, CRC(76068de0) SHA1(5f75b88ad04871fb3799fe904658c87524bad94f) )
+
+	DISK_REGION("drive_0")
+	DISK_IMAGE_READONLY( "c27jaa03", 0, SHA1(9b2aa900711d88cf5effb3ba6be18726ea006ac4) )
+ROM_END
+
+
+GAME(2002, pyson,          0,   pyson,   pyson,       0, ROT0, "Konami", "Konami Psyon BIOS", GAME_IS_SKELETON|GAME_IS_BIOS_ROOT)
+GAME(2002, wswe,       pyson,   pyson,   pyson,       0, ROT0, "Konami", "World Soccer Winning Eleven Arcade Game Style", GAME_IS_SKELETON)
+GAME(2003, wswe2k3,    pyson,   pyson,   pyson,       0, ROT0, "Konami", "World Soccer Winning Eleven Arcade Game 2003", GAME_IS_SKELETON)
diff -Nru src-old/mame/drivers/qdrmfgp.c src/mame/drivers/qdrmfgp.c
--- src-old/mame/drivers/qdrmfgp.c	2012-02-09 11:27:12.000000000 +0100
+++ src/mame/drivers/qdrmfgp.c	2012-03-04 18:26:17.000000000 +0100
@@ -77,12 +77,12 @@
 		int vol = state->m_nvram[0x10] & 0xff;
 		if (vol)
 		{
-			device_t *k054539 = space->machine().device("konami");
+			k054539_device *k054539 = space->machine().device<k054539_device>("konami");
 			int i;
 			double gain = vol / 90.0;
 
 			for (i=0; i<8; i++)
-				k054539_set_gain(k054539, i, gain);
+				k054539->set_gain(i, gain);
 		}
 	}
 }
@@ -110,12 +110,12 @@
 		int vol = state->m_nvram[0x8] & 0xff;
 		if (vol)
 		{
-			device_t *k054539 = space->machine().device("konami");
+			k054539_device *k054539 = space->machine().device<k054539_device>("konami");
 			int i;
 			double gain = vol / 90.0;
 
 			for (i=0; i<8; i++)
-				k054539_set_gain(k054539, i, gain);
+				k054539->set_gain(i, gain);
 		}
 	}
 }
@@ -352,7 +352,7 @@
 	AM_RANGE(0x360000, 0x360001) AM_WRITENOP													/* unknown */
 	AM_RANGE(0x370000, 0x370001) AM_WRITE(gp_control_w)											/* control reg */
 	AM_RANGE(0x380000, 0x380001) AM_WRITENOP													/* Watchdog */
-	AM_RANGE(0x800000, 0x80045f) AM_DEVREADWRITE8("konami", k054539_r, k054539_w, 0x00ff)		/* sound regs */
+	AM_RANGE(0x800000, 0x80045f) AM_DEVREADWRITE8_MODERN("konami", k054539_device, read, write, 0x00ff)		/* sound regs */
 	AM_RANGE(0x880000, 0x881fff) AM_DEVREADWRITE("k056832", k056832_ram_word_r, k056832_ram_word_w)			/* vram */
 	AM_RANGE(0x882000, 0x883fff) AM_DEVREADWRITE("k056832", k056832_ram_word_r, k056832_ram_word_w)			/* vram (mirror) */
 	AM_RANGE(0x900000, 0x901fff) AM_READ(v_rom_r)												/* gfxrom through */
@@ -375,7 +375,7 @@
 	AM_RANGE(0x360000, 0x360001) AM_WRITENOP													/* unknown */
 	AM_RANGE(0x370000, 0x370001) AM_WRITE(gp2_control_w)										/* control reg */
 	AM_RANGE(0x380000, 0x380001) AM_WRITENOP													/* Watchdog */
-	AM_RANGE(0x800000, 0x80045f) AM_DEVREADWRITE8("konami", k054539_r,k054539_w, 0x00ff)		/* sound regs */
+	AM_RANGE(0x800000, 0x80045f) AM_DEVREADWRITE8_MODERN("konami", k054539_device, read, write, 0x00ff)		/* sound regs */
 	AM_RANGE(0x880000, 0x881fff) AM_READWRITE(gp2_vram_r, gp2_vram_w)							/* vram */
 	AM_RANGE(0x89f000, 0x8a0fff) AM_READWRITE(gp2_vram_mirror_r, gp2_vram_mirror_w)				/* vram (mirror) */
 	AM_RANGE(0x900000, 0x901fff) AM_READ(v_rom_r)												/* gfxrom through */
@@ -704,8 +704,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami", K054539, 18432000/384)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
@@ -741,7 +740,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami", K054539, 18432000/384)
+	MCFG_K054539_ADD("konami", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/raiden.c src/mame/drivers/raiden.c
--- src-old/mame/drivers/raiden.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/raiden.c	2012-03-08 08:39:27.000000000 +0100
@@ -48,7 +48,7 @@
 
 static ADDRESS_MAP_START( main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x00000, 0x06fff) AM_RAM
-	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x0a000, 0x0afff) AM_RAM AM_SHARE("share1") AM_BASE_MEMBER(raiden_state, m_shared_ram)
 	AM_RANGE(0x0b000, 0x0b001) AM_READ_PORT("P1_P2")
 	AM_RANGE(0x0b002, 0x0b003) AM_READ_PORT("DSW")
@@ -73,7 +73,7 @@
 
 static ADDRESS_MAP_START( alt_main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x00000, 0x06fff) AM_RAM
-	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x08000, 0x08fff) AM_RAM AM_SHARE("share1") AM_BASE_MEMBER(raiden_state, m_shared_ram)
 	AM_RANGE(0x0a000, 0x0a00d) AM_READWRITE(seibu_main_word_r, seibu_main_word_w)
 	AM_RANGE(0x0c000, 0x0c7ff) AM_WRITE(raiden_text_w) AM_BASE_MEMBER(raiden_state, m_videoram)
@@ -88,7 +88,7 @@
 
 static ADDRESS_MAP_START( raidenu_main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x00000, 0x06fff) AM_RAM
-	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07000, 0x07fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x08000, 0x08035) AM_WRITEONLY AM_BASE_MEMBER(raiden_state, m_scroll_ram)
 	AM_RANGE(0x0a000, 0x0afff) AM_RAM AM_SHARE("share1") AM_BASE_MEMBER(raiden_state, m_shared_ram)
 	AM_RANGE(0x0b000, 0x0b001) AM_READ_PORT("P1_P2")
@@ -242,16 +242,6 @@
 	device_set_input_line_and_vector(device, 0, HOLD_LINE, 0xc8/4);	/* VBL */
 }
 
-static SCREEN_VBLANK( raiden )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-		buffer_spriteram16_w(space,0,0,0xffff); /* Could be a memory location instead */
-	}
-}
-
 static MACHINE_CONFIG_START( raiden, raiden_state )
 
 	/* basic machine hardware */
@@ -270,7 +260,7 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.60)    /* verified on pcb */
@@ -278,7 +268,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(raiden)
-	MCFG_SCREEN_VBLANK_STATIC(raiden)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(raiden)
 	MCFG_PALETTE_LENGTH(2048)
diff -Nru src-old/mame/drivers/renegade.c src/mame/drivers/renegade.c
--- src-old/mame/drivers/renegade.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/renegade.c	2012-03-07 19:42:58.000000000 +0100
@@ -890,16 +890,9 @@
 GFXDECODE_END
 
 
-
-/* handler called by the 3526 emulator when the internal timers cause an IRQ */
-static void irqhandler(device_t *device, int linestate)
-{
-	cputag_set_input_line(device->machine(), "audiocpu", M6809_FIRQ_LINE, linestate);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6809_FIRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/rohga.c src/mame/drivers/rohga.c
--- src-old/mame/drivers/rohga.c	2012-01-28 19:15:10.000000000 +0100
+++ src/mame/drivers/rohga.c	2012-03-08 08:39:27.000000000 +0100
@@ -161,7 +161,7 @@
 	AM_RANGE(0x3cc000, 0x3ccfff) AM_MIRROR(0x1000) AM_RAM AM_BASE_MEMBER(rohga_state, m_pf3_rowscroll)
 	AM_RANGE(0x3ce000, 0x3cefff) AM_MIRROR(0x1000) AM_RAM AM_BASE_MEMBER(rohga_state, m_pf4_rowscroll)
 
-	AM_RANGE(0x3d0000, 0x3d07ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x3d0000, 0x3d07ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x3e0000, 0x3e1fff) AM_RAM_DEVWRITE("deco_common", decocomn_buffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x3f0000, 0x3f3fff) AM_RAM /* Main ram */
 ADDRESS_MAP_END
@@ -185,10 +185,10 @@
 	AM_RANGE(0x320002, 0x320003) AM_WRITENOP /* ? */
 	AM_RANGE(0x320004, 0x320005) AM_WRITE(wizdfire_irq_ack_w) /* VBL IRQ ack */
 
-	AM_RANGE(0x340000, 0x3407ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x350000, 0x350001) AM_WRITE(buffer_spriteram16_w) /* Triggers DMA for spriteram */
-	AM_RANGE(0x360000, 0x3607ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
-	AM_RANGE(0x370000, 0x370001) AM_WRITE(buffer_spriteram16_2_w) /* Triggers DMA for spriteram */
+	AM_RANGE(0x340000, 0x3407ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x350000, 0x350001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* Triggers DMA for spriteram */
+	AM_RANGE(0x360000, 0x3607ff) AM_RAM AM_SHARE("spriteram2")
+	AM_RANGE(0x370000, 0x370001) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write) /* Triggers DMA for spriteram */
 
 	AM_RANGE(0x380000, 0x381fff) AM_RAM_DEVWRITE("deco_common", decocomn_buffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x390008, 0x390009) AM_DEVWRITE("deco_common", decocomn_palette_dma_w)
@@ -217,10 +217,10 @@
 	AM_RANGE(0x320002, 0x320003) AM_WRITENOP /* ? */
 	AM_RANGE(0x320004, 0x320005) AM_WRITE(wizdfire_irq_ack_w) /* VBL IRQ ack */
 
-	AM_RANGE(0x340000, 0x3407ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
-	AM_RANGE(0x350000, 0x350001) AM_WRITE(buffer_spriteram16_w) /* Triggers DMA for spriteram */
-	AM_RANGE(0x360000, 0x3607ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
-	AM_RANGE(0x370000, 0x370001) AM_WRITE(buffer_spriteram16_2_w) /* Triggers DMA for spriteram */
+	AM_RANGE(0x340000, 0x3407ff) AM_RAM AM_SHARE("spriteram")
+	AM_RANGE(0x350000, 0x350001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write) /* Triggers DMA for spriteram */
+	AM_RANGE(0x360000, 0x3607ff) AM_RAM AM_SHARE("spriteram2")
+	AM_RANGE(0x370000, 0x370001) AM_DEVWRITE_MODERN("spriteram2", buffered_spriteram16_device, write) /* Triggers DMA for spriteram */
 
 	AM_RANGE(0x380000, 0x381fff) AM_RAM_DEVWRITE("deco_common", decocomn_buffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x390008, 0x390009) AM_DEVWRITE("deco_common", decocomn_palette_dma_w)
@@ -254,7 +254,7 @@
 	AM_RANGE(0x3cc000, 0x3ccfff) AM_MIRROR(0x1000) AM_RAM AM_BASE_MEMBER(rohga_state, m_pf3_rowscroll)
 	AM_RANGE(0x3ce000, 0x3cefff) AM_MIRROR(0x1000) AM_RAM AM_BASE_MEMBER(rohga_state, m_pf4_rowscroll)
 
-	AM_RANGE(0x3d0000, 0x3d07ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x3d0000, 0x3d07ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x3e0000, 0x3e1fff) AM_MIRROR(0x2000) AM_RAM_DEVWRITE("deco_common", decocomn_buffered_palette_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xff0000, 0xff7fff) AM_RAM /* Main ram */
 ADDRESS_MAP_END
@@ -809,7 +809,7 @@
 	MCFG_CPU_PROGRAM_MAP(rohga_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
@@ -859,7 +859,8 @@
 	MCFG_CPU_PROGRAM_MAP(rohga_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
@@ -912,7 +913,8 @@
 	MCFG_CPU_PROGRAM_MAP(rohga_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM )
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram2")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
@@ -965,7 +967,7 @@
 	MCFG_CPU_PROGRAM_MAP(rohga_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
diff -Nru src-old/mame/drivers/rungun.c src/mame/drivers/rungun.c
--- src-old/mame/drivers/rungun.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/rungun.c	2012-03-04 18:26:17.000000000 +0100
@@ -248,9 +248,9 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank2")
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("k054539_1", k054539_r, k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("k054539_1", k054539_device, read, write)
 	AM_RANGE(0xe230, 0xe3ff) AM_RAM
-	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE("k054539_2", k054539_r, k054539_w)
+	AM_RANGE(0xe400, 0xe62f) AM_DEVREADWRITE_MODERN("k054539_1", k054539_device, read, write)
 	AM_RANGE(0xe630, 0xe7ff) AM_RAM
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(sound_status_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -394,7 +394,7 @@
 {
 	rungun_state *state = machine.driver_data<rungun_state>();
 
-	k054539_init_flags(machine.device("k054539_1"), K054539_REVERSE_STEREO);
+	machine.device<k054539_device>("k054539_1")->init_flags(k054539_device::REVERSE_STEREO);
 
 	memset(state->m_sysreg, 0, 0x20);
 	memset(state->m_ttl_vram, 0, 0x1000);
@@ -444,13 +444,11 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("k054539_1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539_1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 
-	MCFG_SOUND_ADD("k054539_2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539_2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/s3.c src/mame/drivers/s3.c
--- src-old/mame/drivers/s3.c	2011-12-23 18:12:19.000000000 +0100
+++ src/mame/drivers/s3.c	2012-03-06 19:48:12.000000000 +0100
@@ -127,4 +127,4 @@
 GAME( 1977, lucky_l1, 0, williams_s3, williams_s3, williams_s3, ROT0, "Williams", "Lucky Seven (L-1)",		GAME_IS_SKELETON_MECHANICAL)
 GAME( 1978, wldcp_l1, 0, williams_s3, williams_s3, williams_s3, ROT0, "Williams", "World Cup Soccer (L-1)", 	GAME_IS_SKELETON_MECHANICAL)
 GAME( 1978, cntct_l1, 0, williams_s3, williams_s3, williams_s3, ROT0, "Williams", "Contact (L-1)",			GAME_IS_SKELETON_MECHANICAL)
-GAME( 1978, disco_l1, 0, williams_s3, williams_s3, williams_s3, ROT0, "Williams", "Disco Fever (L-1",		GAME_IS_SKELETON_MECHANICAL)
+GAME( 1978, disco_l1, 0, williams_s3, williams_s3, williams_s3, ROT0, "Williams", "Disco Fever (L-1)",		GAME_IS_SKELETON_MECHANICAL)
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2012-02-20 01:12:44.000000000 +0100
+++ src/mame/drivers/segas16b.c	2012-03-08 21:19:55.000000000 +0100
@@ -3469,7 +3469,7 @@
  **************************************************************************************************************************
     Ace Attacker, Sega System 16B
     CPU: FD1094 (317-0059, also 317-0061 version known to be exist)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( aceattac )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -3510,7 +3510,7 @@
  **************************************************************************************************************************
     Alien Syndrome, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( aliensyn )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -3546,7 +3546,10 @@
 /**************************************************************************************************************************
     Alien Syndrome, Sega System 16B
     CPU: FD1089A (317-0033)
-    ROM Board: 171-5358?
+    ROM Board type: 171-5358
+    Sega game ID: 833-6308-03
+      Main board: 837-6312
+       Rom board: 834-6311-03
 */
 ROM_START( aliensyn3 )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -3586,7 +3589,7 @@
 /**************************************************************************************************************************
     Alien Syndrome, Sega System 16B
     CPU: FD1089A (317-0033)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
     Sega game ID: 833-6308
       Main board: 837-6312
        Rom board: 834-6311
@@ -3631,7 +3634,7 @@
  **************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: 68000 + i8751 (317-0078)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
     Sega ID# for ROM board: 834-6661-10
 */
 ROM_START( altbeast )
@@ -3666,7 +3669,7 @@
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: 68000 + i8751 (317-0077)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( altbeastj )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -3709,7 +3712,7 @@
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: 68000 + i8751 (317-0076)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( altbeast6 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -3752,8 +3755,10 @@
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: FD1094 (317-0069)
-    ROM Board: 171-5521
-    Sega ID# for ROM board: 834-6661-07
+    ROM Board type: 171-5521
+    Sega game ID: 833-6660-07
+      Main board: 837-6662-05
+       ROM board: 834-6661-07
 */
 ROM_START( altbeast5 )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -3796,7 +3801,7 @@
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: 68000 + MC-8123B 317-0066
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
     Sega ID# for ROM board: 834-6661-06
 */
 ROM_START( altbeast4 )
@@ -3840,7 +3845,7 @@
 /**************************************************************************************************************************
     Jyuohki (Altered Beast), Sega System 16B
     CPU: FD1094 (317-0068)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( altbeastj3 )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -3883,7 +3888,7 @@
 /**************************************************************************************************************************
     Altered Beast, Sega System 16B
     CPU: 68000 + MC8123B (317-0066)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
     Sega ID# for ROM board: 834-6661-02
 */
 ROM_START( altbeast2 )
@@ -3918,7 +3923,7 @@
 /**************************************************************************************************************************
     Jyuohki (Altered Beast), Sega System 16B
     CPU: FD1094 (317-0065)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( altbeastj1 )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -4001,7 +4006,7 @@
  **************************************************************************************************************************
     Aurail, Sega System 16B
     CPU: 68000
-    ROM Board: 171-????
+    ROM Board type: 171-????
 */
 ROM_START( aurail )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -4045,7 +4050,7 @@
 /**************************************************************************************************************************
     Aurail, Sega System 16B
     CPU: FD1089B (317-0168)
-    ROM Board: 171-????
+    ROM Board type: 171-????
 */
 ROM_START( aurail1 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -4093,7 +4098,7 @@
 /**************************************************************************************************************************
     Aurail, Sega System 16B
     CPU: FD1089A (317-0167)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 
     S1  - -
     S2  ---
@@ -4164,7 +4169,7 @@
  **************************************************************************************************************************
     Bay Route, Sega System 16B
     CPU: FD1094 (317-0116)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( bayroute )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -4197,7 +4202,7 @@
 /**************************************************************************************************************************
     Bay Route, Sega System 16B
     CPU: FD1094 (317-0115)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( bayroutej )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -4230,7 +4235,7 @@
 /**************************************************************************************************************************
     Bay Route, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( bayroute1 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -4320,7 +4325,7 @@
  **************************************************************************************************************************
     Cotton, Sega System 16B
     CPU: FD1094 (317-0181A)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( cotton )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* 68000 code */
@@ -4367,7 +4372,7 @@
 /**************************************************************************************************************************
     Cotton, Sega System 16B
     CPU: FD1094 (317-0180T) // T could be wrong, it was handwritten
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( cottonu )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* 68000 code */
@@ -4414,7 +4419,7 @@
 /**************************************************************************************************************************
     Cotton (Japan), Sega System 16B
     CPU: FD1094 (317-0179A)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( cottonj )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* 68000 code */
@@ -4464,7 +4469,7 @@
  **************************************************************************************************************************
     Dunk Shot, Sega System 16B
     CPU: FD1089A (317-0022)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( dunkshot )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -4514,7 +4519,7 @@
  **************************************************************************************************************************
     Dynamite Dux, Sega System 16B
     CPU: FD1094 (317-0096, version uses 317-0094 known to be exist)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 
     Pos.   Silk        Type        Part         Pos.   Silk        Type        Part
 
@@ -4603,7 +4608,7 @@
  **************************************************************************************************************************
     E-Swat (World), Sega System 16B
     CPU: FD1094 (317-0130)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
 */
 ROM_START( eswat )
 	ROM_REGION( 0x080000, "maincpu", 0 ) /* 68000 code */
@@ -4640,7 +4645,7 @@
 /**************************************************************************************************************************
     E-Swat (US), Sega System 16B
     CPU: FD1094 (317-0129)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
     Sega ID# for ROM board: 834-7165-01
 */
 ROM_START( eswatu )
@@ -4677,9 +4682,11 @@
 
 /**************************************************************************************************************************
     E-Swat (Japan), Sega System 16B
-    Game board : 837-7166/833-7164/834-7165
     CPU: FD1094 (317-0128)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
+    Sega game ID: 833-7164
+      Main board: 837-7166
+       ROM board: 834-7165
 */
 ROM_START( eswatj )
 	ROM_REGION( 0x080000, "maincpu", 0 ) /* 68000 code */
@@ -4719,7 +4726,7 @@
  **************************************************************************************************************************
     Excite League, Sega System 16B
     CPU: FD1094 (317-0079)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( exctleag )
 	ROM_REGION( 0x60000, "maincpu", 0 ) /* 68000 code */
@@ -4762,7 +4769,7 @@
  **************************************************************************************************************************
     Flash Point, Sega System 16B
     CPU: FD1094 (317-0127A)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 
     171-5358        834-6764
     ROW A       171-5358
@@ -4814,7 +4821,7 @@
 /**************************************************************************************************************************
     Flash Point, Sega System 16B
     CPU: FD1094 (317-0127A)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
     Sega ID# for ROM board: 834-7122-03
 
     Pos.   Silk        Type        Part         Pos.   Silk        Type        Part
@@ -4862,7 +4869,7 @@
  **************************************************************************************************************************
     Golden Axe, Sega System 16B
     CPU: 68000 + i8751 (317-123A)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
     Sega ID# for ROM board: 834-7002-07
 */
 ROM_START( goldnaxe )
@@ -4900,7 +4907,7 @@
 /**************************************************************************************************************************
     Golden Axe, Sega System 16B
     CPU: FD1094 (317-0122)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
     Sega ID# for ROM board: 834-7002-06
 */
 ROM_START( goldnaxeu )
@@ -4938,7 +4945,7 @@
 /**************************************************************************************************************************
     Golden Axe (Japan), Sega System 16B
     CPU: FD1094 (317-0121)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
     Sega ID# for ROM board: 834-7002-04
 */
 ROM_START( goldnaxej )
@@ -4980,7 +4987,7 @@
 /**************************************************************************************************************************
     Golden Axe (World), Sega System 16B
     CPU: FD1094 (317-0120)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
     Sega ID# for ROM board: 834-7002-11
 */
 ROM_START( goldnaxe3 )
@@ -5022,7 +5029,7 @@
 /**************************************************************************************************************************
     Golden Axe (Japan), Sega System 16B
     CPU: 68000 + i8751 (317-0112)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
     Sega ID# for ROM board: 834-7002-02
 */
 ROM_START( goldnaxe2 )
@@ -5063,7 +5070,7 @@
 /**************************************************************************************************************************
     Golden Axe, Sega System 16B
     CPU: FD1094 (317-0110)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
     Sega ID# for ROM board: 834-7002
 */
 ROM_START( goldnaxe1 )
@@ -5104,7 +5111,7 @@
  **************************************************************************************************************************
     Heavyweight Champ, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
     Filter Board: 834-6383 (takes input from controls and routes through the CN5 connector on the mainboard)
     Sega ID# for ROM board: 834-6398-02
 */
@@ -5151,7 +5158,7 @@
 /**************************************************************************************************************************
     Heavyweight Champ (Japan), Sega System 16B
     CPU: FD1094 (317-0046)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( hwchampj )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -5202,7 +5209,7 @@
  **************************************************************************************************************************
     MVP, Sega System 16B
     CPU: FD1094 (317-0143)
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
 */
 ROM_START( mvp )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* 68000 code */
@@ -5414,7 +5421,7 @@
  **************************************************************************************************************************
     Riot City, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( riotcity )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -5457,7 +5464,7 @@
  **************************************************************************************************************************
     Ryukyu, Sega System 16B
     CPU: FD1094 8J2 (317-5023)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( ryukyu )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* 68000 code */
@@ -5488,7 +5495,7 @@
  **************************************************************************************************************************
     Defense, Sega System 16B
     CPU: FD1089A 317-0028
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 
 ROM_START( defense )
@@ -5525,7 +5532,7 @@
  **************************************************************************************************************************
     SDI, Sega System 16B
     CPU: FD1089A 317-0028
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 
 ROM_START( sdib )
@@ -5563,7 +5570,7 @@
  **************************************************************************************************************************
     SDI, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
     Note: decrypted bootleg
 */
 ROM_START( sdibl )
@@ -5599,7 +5606,7 @@
 
     Shinobi, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
 */
 ROM_START( shinobi5 )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -5627,7 +5634,7 @@
 
     Shinobi, Sega System 16B
     CPU: 68000 + MC8123B (317-0054)
-    ROM Board: 171-5521
+    ROM Board type: 171-5521
  Game Nunmber: 834-6496-04
     ROM board: 834-6499-03
 */
@@ -5658,7 +5665,7 @@
 /**************************************************************************************************************************
     Shinobi, Sega System 16B
     CPU: 68000 + MC8123B (317-0054)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
  Game Nunmber: 834-6496-04
     ROM board: 834-6499-02
 */
@@ -5696,7 +5703,8 @@
 /**************************************************************************************************************************
     Shinobi, Sega System 16B
     CPU: FD1094 (317-0049)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
+    ROM board: 834-6499
 */
 ROM_START( shinobi2 )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -5735,7 +5743,7 @@
  **************************************************************************************************************************
     Sonic Boom, Sega System 16B
     CPU: FD1094 (317-0053)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 
     Pos.   Silk        Type        Part                Pos.   Silk        Type        Part
 
@@ -5788,7 +5796,7 @@
  **************************************************************************************************************************
     Sukeban Jansi Ryuko (JPN Ver.)
     CPU: FD1089B 317-5021 (16A/16B) (version uses i8751(317-5019) known to be exist)
-    ROM Board: 171-???
+    ROM Board type: 171-???
 
     (c)1988 White Board
 
@@ -5838,7 +5846,7 @@
  **************************************************************************************************************************
     Super League, Sega System 16B
     CPU: FD1094 (317-0045)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 */
 ROM_START( suprleag )
 	ROM_REGION( 0x060000, "maincpu", 0 ) /* 68000 code */
@@ -5881,7 +5889,7 @@
  **************************************************************************************************************************
     Tetris, Sega System 16B
     CPU: FD1094 (317-0092)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( tetris2 )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -5907,7 +5915,7 @@
 /**************************************************************************************************************************
     Tetris, Sega System 16B
     CPU: FD1094 (317-0091)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 
     Pos.   Silk        Type        Part                Pos.   Silk        Type        Part
     A1     EPR-12163   27C256      68000 program       B1     EPR-12169   27C256      Sprite data
@@ -5949,7 +5957,7 @@
  **************************************************************************************************************************
     Time Scanner, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
  */
 ROM_START( timescan )
 	ROM_REGION( 0x040000, "maincpu", 0 ) /* 68000 code */
@@ -5986,7 +5994,7 @@
  **************************************************************************************************************************
     Toryumon, Sega System 16B
     CPU: 68000
-    ROM Board: 171-5797
+    ROM Board type: 171-5797
  */
 ROM_START( toryumon )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -6019,7 +6027,7 @@
  **************************************************************************************************************************
     Tough Turf, Sega System 16B
     CPU: 68000 + i8751 (317-0104, 317-0100 also known to be exist)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
  */
 ROM_START( tturf )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -6053,7 +6061,7 @@
 /**************************************************************************************************************************
     Tough Turf, Sega System 16B
     CPU: 68000 + i8751 (317-0099)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
     Sega ID# for ROM board: 834-6949
  */
 ROM_START( tturfu )
@@ -6095,7 +6103,7 @@
  **************************************************************************************************************************
     Wonder Boy III, Sega System 16B
     CPU: 68000 + i8751 (317-0098)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
  */
 ROM_START( wb3 )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -6128,7 +6136,7 @@
 /**************************************************************************************************************************
     Wonder Boy III, Sega System 16B
     CPU: FD1094 (317-0087)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
  */
 ROM_START( wb34 )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -6160,7 +6168,7 @@
 /**************************************************************************************************************************
     Wonder Boy III, Sega System 16B
     CPU: FD1094 (317-0089)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
  */
 ROM_START( wb33 )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
@@ -6192,7 +6200,7 @@
 /**************************************************************************************************************************
     Wonder Boy III, Sega System 16B
     CPU: FD1094 (317-0085)
-    ROM Board: 171-5358
+    ROM Board type: 171-5358
 
     Pos.   Silk        Type        Part                Pos.   Silk        Type        Part
     A1     EPR-12198   27C512      68000 program       B1     EPR-12190   27C512      Sprite data
@@ -6242,7 +6250,7 @@
  **************************************************************************************************************************
     Wrestle War, Sega System 16B
     CPU: 68000 + i8751 (317-0103)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
     GAME NUMBER: 837-6889-02 (MB:833-6887-07, ROM:834-6888-07)
 
     LOC   NAME         LOC   NAME
@@ -6302,7 +6310,7 @@
 /**************************************************************************************************************************
     Wrestle War, Sega System 16B
     CPU: FD1094 (317-0102)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( wrestwar2 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
@@ -6343,7 +6351,7 @@
 /**************************************************************************************************************************
     Wrestle War, Sega System 16B
     CPU: FD1094 (317-0090)
-    ROM Board: 171-5704
+    ROM Board type: 171-5704
 */
 ROM_START( wrestwar1 )
 	ROM_REGION( 0xc0000, "maincpu", 0 ) /* 68000 code */
diff -Nru src-old/mame/drivers/segas18.c src/mame/drivers/segas18.c
--- src-old/mame/drivers/segas18.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/segas18.c	2012-03-07 04:56:39.000000000 +0100
@@ -2095,6 +2095,10 @@
     Shadow Dancer, Sega System 18
     CPU: 68000
     ROM Board: 171-5873B
+
+    game No. 833-7246-01
+    pcb  No. 837-7248
+    rom  No. 834-7247-01
 */
 ROM_START( shdancer1 )
 	ROM_REGION( 0x080000, "maincpu", 0 ) /* 68000 code */
diff -Nru src-old/mame/drivers/segas24.c src/mame/drivers/segas24.c
--- src-old/mame/drivers/segas24.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/segas24.c	2012-02-29 10:13:22.000000000 +0100
@@ -821,7 +821,7 @@
 		break;
 	}
 	case 2: {
-		abort();
+		fatalerror("egas24_state::irq_timer_sync - case 2");
 	}
 	case 3: {
 		int ppos = floor((irq_synctime - irq_vsynctime).as_double() * TIMER_CLOCK);
@@ -852,7 +852,7 @@
 		break;
 	}
 	case 2:
-		abort();
+		fatalerror("egas24_state::irq_timer_start - case 2");
 		break;
 	case 3: {
 		int count = 0x1000 - irq_tval;
diff -Nru src-old/mame/drivers/seibuspi.c src/mame/drivers/seibuspi.c
--- src-old/mame/drivers/seibuspi.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/seibuspi.c	2012-03-11 18:17:00.000000000 +0100
@@ -3400,6 +3400,35 @@
 	ROM_LOAD16_WORD( "93c46-rfjets.bin", 0x0000, 0x0080, CRC(8fe8063b) SHA1(afb0141580e1b2bd149092a9cc9e8b4072b1ef10) )
 ROM_END
 
+ROM_START( rfjett ) /* SPI Cart, Taiwan */
+	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
+    ROM_LOAD32_BYTE( "prg0.u0211",   0x000000, 0x080000, CRC(a4734579) SHA1(dfbd8e2a3178c7cfd7bd3698999f14bc80f5212f) )
+    ROM_LOAD32_BYTE( "prg1.u0212",   0x000001, 0x080000, CRC(5e4ad3a4) SHA1(ff66e16f48978b88b298c78e21309208ccb3ff15) )
+    ROM_LOAD32_BYTE( "prg2.u0221",   0x000002, 0x080000, CRC(21c9942e) SHA1(ededa05a4b5dae2dec5c4409f22e9a66d2c8e98e) )
+    ROM_LOAD32_BYTE( "prg3.u0220",   0x000003, 0x080000, CRC(ea3657f4) SHA1(2291e31243af7d2e79ae727d9b5484e8d49cc7d9) )
+
+	ROM_REGION( 0x30000, "gfx1", ROMREGION_ERASEFF)
+	ROM_LOAD24_BYTE("fix0.u0524", 0x000001, 0x10000, CRC(8bc080be) SHA1(ad296fb98242c963072346a8de289e704b445ad4) )
+	ROM_LOAD24_BYTE("fix1.u0518", 0x000000, 0x10000, CRC(bded85e7) SHA1(ccb8c438ce6b9a742e3ab15be970b1e636783626) )
+	ROM_LOAD24_BYTE("fixp.u0514", 0x000002, 0x10000, CRC(015d0748) SHA1(b1e8eaeba63a7914f1dc27d7e3ca5d0b6db202ed) )
+
+	ROM_REGION( 0x900000, "gfx2", 0)	/* background layer roms */
+	ROM_LOAD24_WORD("bg-1d.u0543", 0x000000, 0x400000, CRC(edfd96da) SHA1(4813267f104619f569e5777e75b75304321abb49) )
+	ROM_LOAD24_BYTE("bg-1p.u0544", 0x000002, 0x200000, CRC(a4cc4631) SHA1(cc1c4f4de8a078ca774f5a328a9a58291949b1fb) )
+	ROM_LOAD24_WORD("bg-2d.u0545", 0x600000, 0x200000, CRC(731fbb59) SHA1(13cd29ec4d4c73582c5fb363218e737886826e5f) )
+	ROM_LOAD24_BYTE("bg-2p.u0546", 0x600002, 0x100000, CRC(03652c25) SHA1(c0d77285111bc84e008362981ac02a246678ed0a) )
+
+	ROM_REGION( 0x1800000, "gfx3", 0)	/* sprites */
+	ROM_LOAD("obj-1.u0442", 0x0000000, 0x800000, CRC(58a59896) SHA1(edeaaa69987bd5d08c47ed9bf47a3901e2dcc892) )
+	ROM_LOAD("obj-2.u0443", 0x0800000, 0x800000, CRC(a121d1e3) SHA1(1851ae81f2ae9d3404aadd9fbc0ed7f9230290b9) )
+	ROM_LOAD("obj-3.u0444", 0x1000000, 0x800000, CRC(bc2c0c63) SHA1(c8d395722f7012c3be366a0fc9b224c537afabae) )
+
+	ROM_REGION(0x200000, "ymf", ROMREGION_ERASE00)
+
+	ROM_REGION(0x280000, "user2", ROMREGION_ERASE00)	/* sound roms */
+	ROM_LOAD("pcm-d.u0227",  0x000000, 0x200000, CRC(8ee3ff45) SHA1(2801b23495866c91c8f8bebd37d5fcae7a625838) )
+	ROM_LOAD("sound1.u0222", 0x200000, 0x080000, CRC(d4fc3da1) SHA1(a03bd97e36a21d27a834b9691b27a7eb7ac51ff2) )
+ROM_END
 
 
 /*******************************************************************/
@@ -3663,6 +3692,7 @@
 GAME( 1998, rfjetu,    rfjet,   spi,      spi_2button, rfjet,  ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden Fighters Jet (US)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1998, rfjeta,    rfjet,   spi,      spi_2button, rfjet,  ROT270, "Seibu Kaihatsu (Dream Island license)", "Raiden Fighters Jet (Asia)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1998, rfjetj,    rfjet,   spi,      spi_2button, rfjet,  ROT270, "Seibu Kaihatsu", "Raiden Fighters Jet (Japan)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
+GAME( 1998, rfjett,    rfjet,   spi,      spi_2button, rfjet,  ROT270, "Seibu Kaihatsu", "Raiden Fighters Jet (Taiwan)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 
 /* there is another rf dump rf_spi_asia.zip but it seems strange, 1 program rom, cart pic seems to show others as a different type of rom */
 
diff -Nru src-old/mame/drivers/senjyo.c src/mame/drivers/senjyo.c
--- src-old/mame/drivers/senjyo.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/senjyo.c	2012-02-27 20:52:09.000000000 +0100
@@ -5,7 +5,8 @@
 driver by Mirko Buffoni
 
 TODO:
-- wrong background colors in baluba, intermissions after round 13
+- wrong background colors in baluba, intermissions after round 13 (btanb or
+  fixed at some point)
 
 
 This board was obviously born to run Senjyo. Four scrolling layers, gradient
@@ -68,6 +69,8 @@
 
 ***************************************************************************/
 
+/* 26.February 2012 Tsuyoshi Hasegawa fixed palette intensity */
+
 #include "emu.h"
 #include "cpu/z80/z80.h"
 #include "sound/sn76496.h"
@@ -109,13 +112,28 @@
 	z80pio_astb_w(device, 1);
 }
 
+static WRITE8_HANDLER( senjyo_paletteram_w )
+{
+	int r = (data << 2) & 0xC;
+	int g = (data     ) & 0xC;
+	int b = (data >> 2) & 0xC;
+	int i = (data >> 6) & 0x3;
+
+	int rr = r|((r!=0)?i:0);
+	int gg = g|((g!=0)?i:0);
+	int bb = b|((b!=0)?i:0);
+
+	space->machine().generic.paletteram.u8[offset] = data;
+	palette_set_color_rgb(space->machine(), offset, pal4bit(rr), pal4bit(gg), pal4bit(bb) );
+}
+
 static ADDRESS_MAP_START( senjyo_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x8fff) AM_RAM
 	AM_RANGE(0x9000, 0x93ff) AM_RAM_WRITE(senjyo_fgvideoram_w) AM_BASE_MEMBER(senjyo_state, m_fgvideoram)
 	AM_RANGE(0x9400, 0x97ff) AM_RAM_WRITE(senjyo_fgcolorram_w) AM_BASE_MEMBER(senjyo_state, m_fgcolorram)
 	AM_RANGE(0x9800, 0x987f) AM_RAM AM_BASE_SIZE_MEMBER(senjyo_state, m_spriteram, m_spriteram_size)
-	AM_RANGE(0x9c00, 0x9dff) AM_RAM_WRITE(paletteram_IIBBGGRR_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x9c00, 0x9dff) AM_RAM_WRITE(senjyo_paletteram_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x9e00, 0x9e1f) AM_RAM AM_BASE_MEMBER(senjyo_state, m_fgscroll)
 	AM_RANGE(0x9e20, 0x9e21) AM_RAM AM_BASE_MEMBER(senjyo_state, m_scrolly3)
 /*  AM_RANGE(0x9e22, 0x9e23) height of the layer (Senjyo only, fixed at 0x380) */
@@ -185,7 +203,7 @@
 	AM_RANGE(0x9000, 0x93ff) AM_RAM_WRITE(senjyo_fgvideoram_w) AM_BASE_MEMBER(senjyo_state, m_fgvideoram)
 	AM_RANGE(0x9400, 0x97ff) AM_RAM_WRITE(senjyo_fgcolorram_w) AM_BASE_MEMBER(senjyo_state, m_fgcolorram)
 	AM_RANGE(0x9800, 0x987f) AM_RAM AM_BASE_SIZE_MEMBER(senjyo_state, m_spriteram, m_spriteram_size)
-	AM_RANGE(0x9c00, 0x9dff) AM_RAM_WRITE(paletteram_IIBBGGRR_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x9c00, 0x9dff) AM_RAM_WRITE(senjyo_paletteram_w) AM_BASE_GENERIC(paletteram)
 	/* The format / use of the ram here is different on the bootleg */
 	AM_RANGE(0x9e20, 0x9e21) AM_RAM AM_BASE_MEMBER(senjyo_state, m_scrolly3)
 	AM_RANGE(0x9e25, 0x9e25) AM_RAM AM_BASE_MEMBER(senjyo_state, m_scrollx3)
@@ -930,5 +948,5 @@
 GAME( 1984, starforcb,starforc, starforb,starforc, starfore, ROT90, "bootleg", "Star Force (encrypted, bootleg)", 0 )
 GAME( 1984, starforca,starforc, senjyo,  starforc, starfora, ROT90, "Tehkan", "Star Force (encrypted, set 2)", 0 )
 GAME( 1985, megaforc, starforc, senjyo,  starforc, starforc, ROT90, "Tehkan (Video Ware license)", "Mega Force", 0 )
-GAME( 1986, baluba,   0,        senjyo,  baluba,   starforc, ROT90, "Able Corp, Ltd.", "Baluba-louk no Densetsu", GAME_IMPERFECT_COLORS )
+GAME( 1986, baluba,   0,        senjyo,  baluba,   starforc, ROT90, "Able Corp, Ltd.", "Baluba-louk no Densetsu (Japan)", 0 )
 
diff -Nru src-old/mame/drivers/seta2.c src/mame/drivers/seta2.c
--- src-old/mame/drivers/seta2.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/seta2.c	2012-03-09 00:48:28.000000000 +0100
@@ -2018,7 +2018,7 @@
 };
 
 static MACHINE_CONFIG_START( seta2, seta2_state )
-	MCFG_CPU_ADD("maincpu", M68000, XTAL_50MHz/3)	// !! TMP68301 !!
+	MCFG_CPU_ADD("maincpu", M68301, XTAL_50MHz/3)	// !! TMP68301 !!
 	MCFG_CPU_PROGRAM_MAP(mj4simai_map)
 	MCFG_CPU_VBLANK_INT("screen", seta2_interrupt)
 
@@ -2250,7 +2250,7 @@
 MACHINE_CONFIG_END
 
 static MACHINE_CONFIG_START( namcostr, seta2_state )
-	MCFG_CPU_ADD("maincpu", M68000, XTAL_50MHz/3)	// !! TMP68301 !!
+	MCFG_CPU_ADD("maincpu", M68301, XTAL_50MHz/3)	// !! TMP68301 !!
 	MCFG_CPU_PROGRAM_MAP(namcostr_map)
 	MCFG_CPU_VBLANK_INT("screen", seta2_interrupt)
 
@@ -3195,9 +3195,25 @@
 	ROM_LOAD( "as0905m01.u18", 0x100000, 0x400000, CRC(8d8165bb) SHA1(aca7051613d260734ee787b4c3db552c336bd600) )
 ROM_END
 
-	/* There are known versions 3.x of Deer Hunting USA.... just none are currently dumped.  roms should be "AS0906 E03 U06" & "AS0907 E03 U07" */
+	/* Are there versions 3.x of Deer Hunting USA with labels "AS0906 E03 U06" & "AS0907 E03 U07" ?? */
 
-ROM_START( deerhuntc ) /* Deer Hunting USA V2.x - No version number is printed to screen but "E02" in EPROM label signifies V2 */
+ROM_START( deerhuntc ) /* These rom labels break label conventions but is correct & verified. Version in program code is listed as 0.00 */
+	ROM_REGION( 0x200000, "maincpu", 0 )	// TMP68301 Code
+	ROM_LOAD16_BYTE( "as0937e01.u06", 0x000000, 0x100000, CRC(8d74088e) SHA1(cb11ffaf4c0267cc8cbe01accc3daeed910a3af3) ) /* SUM16 = C2CD */
+	ROM_LOAD16_BYTE( "as0938e01.u07", 0x000001, 0x100000, CRC(c7657889) SHA1(4cc707c8abbc0862457375a9a910d3c338859193) ) /* SUM16 = 27D7 */
+
+	ROM_REGION( 0x2000000, "sprites", 0 )	// Sprites
+	ROM_LOAD( "as0901m01.u38", 0x0000000, 0x800000, CRC(1d6acf8f) SHA1(6f61fe21bebb7c87e8e6c3ef3ba73b8cf327dde9) )
+	ROM_LOAD( "as0902m01.u39", 0x0800000, 0x800000, CRC(c7ca2128) SHA1(86be3a3ec2f86f61acfa3d4d261faea3c27dc378) )
+	ROM_LOAD( "as0903m01.u40", 0x1000000, 0x800000, CRC(e8ef81b3) SHA1(97666942ca6cca5b8ea6451314a2aaabad9e06ba) )
+	ROM_LOAD( "as0904m01.u41", 0x1800000, 0x800000, CRC(d0f97fdc) SHA1(776c9d42d03a9f61155521212305e1ed696eaf47) )
+
+	ROM_REGION( 0x500000, "x1snd", 0 )	// Samples
+	// Leave 1MB empty (addressable by the chip)
+	ROM_LOAD( "as0905m01.u18", 0x100000, 0x400000, CRC(8d8165bb) SHA1(aca7051613d260734ee787b4c3db552c336bd600) )
+ROM_END
+
+ROM_START( deerhuntd ) /* Deer Hunting USA V2.x - No version number is printed to screen but "E02" in EPROM label signifies V2 */
 	ROM_REGION( 0x200000, "maincpu", 0 )	// TMP68301 Code
 	ROM_LOAD16_BYTE( "as0906e02.u06", 0x000000, 0x100000, CRC(190cca42) SHA1(aef63f5e8c71ed0156b8b0104c5d23872c119167) ) /* Version in program code is listed as 0.00 */
 	ROM_LOAD16_BYTE( "as0907e02.u07", 0x000001, 0x100000, CRC(9de2b901) SHA1(d271bc54c41e30c0d9962eedd22f3ef2b7b8c9e5) ) /* Verified with two different sets of chips */
@@ -3289,7 +3305,8 @@
 GAME( 2000, deerhunt, 0,        samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V4.3",                        GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
 GAME( 2000, deerhunta,deerhunt, samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V4.2",                        GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
 GAME( 2000, deerhuntb,deerhunt, samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V4.0",                        GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
-GAME( 2000, deerhuntc,deerhunt, samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V2",                          GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
+GAME( 2000, deerhuntc,deerhunt, samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V3",                          GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
+GAME( 2000, deerhuntd,deerhunt, samshoot, deerhunt, 0,        ROT0, "Sammy USA Corporation", "Deer Hunting USA V2",                          GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
 GAME( 2001, turkhunt, 0,        samshoot, turkhunt, 0,        ROT0, "Sammy USA Corporation", "Turkey Hunting USA V1.0",                      GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
 GAME( 2001, wschamp,  0,        samshoot, wschamp,  0,        ROT0, "Sammy USA Corporation", "Wing Shooting Championship V2.00",             GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
 GAME( 2001, wschampa, wschamp,  samshoot, wschamp,  0,        ROT0, "Sammy USA Corporation", "Wing Shooting Championship V1.01",             GAME_NO_COCKTAIL | GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/sidearms.c src/mame/drivers/sidearms.c
--- src-old/mame/drivers/sidearms.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/sidearms.c	2012-03-08 08:39:27.000000000 +0100
@@ -87,14 +87,14 @@
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(sidearms_videoram_w) AM_BASE_MEMBER(sidearms_state,m_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM_WRITE(sidearms_colorram_w) AM_BASE_MEMBER(sidearms_state,m_colorram)
 	AM_RANGE(0xe000, 0xefff) AM_RAM
-	AM_RANGE(0xf000, 0xffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf000, 0xffff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( turtship_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xcfff) AM_RAM
-	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xd000, 0xdfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe000, 0xe3ff) AM_RAM_WRITE(paletteram_xxxxBBBBRRRRGGGG_split1_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xe400, 0xe7ff) AM_RAM_WRITE(paletteram_xxxxBBBBRRRRGGGG_split2_w) AM_BASE_GENERIC(paletteram2)
 	AM_RANGE(0xe800, 0xe807) AM_READ(turtship_ports_r)
@@ -160,7 +160,7 @@
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(sidearms_videoram_w) AM_BASE_MEMBER(sidearms_state,m_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM_WRITE(sidearms_colorram_w) AM_BASE_MEMBER(sidearms_state,m_colorram)
 	AM_RANGE(0xe000, 0xefff) AM_RAM
-	AM_RANGE(0xf000, 0xffff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xf000, 0xffff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( whizz_sound_map, AS_PROGRAM, 8 )
@@ -663,7 +663,7 @@
 	MCFG_CPU_PROGRAM_MAP(sidearms_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -671,7 +671,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 2*8, 30*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(sidearms)
-	MCFG_SCREEN_VBLANK_STATIC(sidearms)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(sidearms)
 	MCFG_PALETTE_LENGTH(1024)
@@ -707,14 +707,14 @@
 	MCFG_CPU_PROGRAM_MAP(sidearms_sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 2*8, 30*8-1 )
-	MCFG_SCREEN_VBLANK_STATIC(sidearms)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 	MCFG_SCREEN_UPDATE_STATIC(sidearms)
 
 	MCFG_GFXDECODE(turtship)
@@ -754,7 +754,7 @@
 	MCFG_QUANTUM_TIME(attotime::from_hz(60000))
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -762,7 +762,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(8*8, (64-8)*8-1, 2*8, 30*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(sidearms)
-	MCFG_SCREEN_VBLANK_STATIC(sidearms)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(turtship)
 	MCFG_PALETTE_LENGTH(1024)
diff -Nru src-old/mame/drivers/sidepckt.c src/mame/drivers/sidepckt.c
--- src-old/mame/drivers/sidepckt.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/sidepckt.c	2012-03-07 19:42:58.000000000 +0100
@@ -245,16 +245,9 @@
 GFXDECODE_END
 
 
-
-/* handler called by the 3526 emulator when the internal timers cause an IRQ */
-static void irqhandler(device_t *device, int linestate)
-{
-	cputag_set_input_line(device->machine(), "audiocpu", 0, linestate);
-}
-
 static const ym3526_interface ym3526_config =
 {
-	irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", M6502_IRQ_LINE)
 };
 
 
diff -Nru src-old/mame/drivers/slapfght.c src/mame/drivers/slapfght.c
--- src-old/mame/drivers/slapfght.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/slapfght.c	2012-03-08 08:39:27.000000000 +0100
@@ -276,7 +276,7 @@
 	AM_RANGE(0x8810, 0x8fff) AM_RAMBANK("bank1") /* Shared RAM with sound CPU */
 	AM_RANGE(0x9000, 0x97ff) AM_RAM_WRITE(slapfight_videoram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_videoram)
 	AM_RANGE(0x9800, 0x9fff) AM_RAM_WRITE(slapfight_colorram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_colorram)
-	AM_RANGE(0xa000, 0xa7ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xa000, 0xa7ff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( tigerh_map, AS_PROGRAM, 8 )
@@ -286,7 +286,7 @@
 	AM_RANGE(0xc810, 0xcfff) AM_RAM
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(slapfight_videoram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM_WRITE(slapfight_colorram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_colorram)
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe800, 0xe800) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_lo)
 	AM_RANGE(0xe801, 0xe801) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_hi)
 	AM_RANGE(0xe802, 0xe802) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrolly)
@@ -302,7 +302,7 @@
 	AM_RANGE(0xc810, 0xcfff) AM_RAM
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(slapfight_videoram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM_WRITE(slapfight_colorram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_colorram)
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe800, 0xe800) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_lo)
 	AM_RANGE(0xe801, 0xe801) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_hi)
 	AM_RANGE(0xe802, 0xe802) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrolly)
@@ -319,7 +319,7 @@
 	AM_RANGE(0xc810, 0xcfff) AM_RAM
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(slapfight_videoram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM_WRITE(slapfight_colorram_w) AM_BASE_MEMBER(slapfght_state, m_slapfight_colorram)
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xe800, 0xe800) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_hi)
 	AM_RANGE(0xe802, 0xe802) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrolly)
 	AM_RANGE(0xe803, 0xe803) AM_WRITEONLY AM_BASE_MEMBER(slapfght_state, m_slapfight_scrollx_lo)
@@ -734,16 +734,6 @@
 	DEVCB_NULL
 };
 
-static SCREEN_VBLANK( perfrman )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
-
 static INTERRUPT_GEN( vblank_irq )
 {
 	slapfght_state *state = device->machine().driver_data<slapfght_state>();
@@ -770,7 +760,7 @@
 	MCFG_MACHINE_RESET(slapfight)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -778,7 +768,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(1*8, 34*8-1, 2*8, 32*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(perfrman)
-	MCFG_SCREEN_VBLANK_STATIC(perfrman)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(perfrman)
 	MCFG_PALETTE_LENGTH(256)
@@ -816,7 +806,7 @@
 	MCFG_MACHINE_RESET(slapfight)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -824,7 +814,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(1*8, 36*8-1, 2*8, 32*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(slapfight)
-	MCFG_SCREEN_VBLANK_STATIC(perfrman)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(slapfght)
 	MCFG_PALETTE_LENGTH(256)
@@ -864,7 +854,7 @@
 	MCFG_MACHINE_RESET(slapfight)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -872,7 +862,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(1*8, 36*8-1, 2*8, 32*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(slapfight)
-	MCFG_SCREEN_VBLANK_STATIC(perfrman)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(slapfght)
 	MCFG_PALETTE_LENGTH(256)
@@ -913,7 +903,7 @@
 	MCFG_MACHINE_RESET(slapfight)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -921,7 +911,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(1*8, 36*8-1, 2*8, 32*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(slapfight)
-	MCFG_SCREEN_VBLANK_STATIC(perfrman)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(slapfght)
 	MCFG_PALETTE_LENGTH(256)
diff -Nru src-old/mame/drivers/snk.c src/mame/drivers/snk.c
--- src-old/mame/drivers/snk.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/snk.c	2012-03-07 19:42:58.000000000 +0100
@@ -457,27 +457,27 @@
 
 
 
-static void ymirq_callback_1(device_t *device, int irq)
+static WRITE_LINE_DEVICE_HANDLER( ymirq_callback_1 )
 {
-	if (irq)
+	if (state)
 		device->machine().scheduler().synchronize(FUNC(sndirq_update_callback), YM1IRQ_ASSERT);
 }
 
-static void ymirq_callback_2(device_t *device, int irq)
+static WRITE_LINE_DEVICE_HANDLER( ymirq_callback_2 )
 {
-	if (irq)
+	if (state)
 		device->machine().scheduler().synchronize(FUNC(sndirq_update_callback), YM2IRQ_ASSERT);
 }
 
 
 static const ym3526_interface ym3526_config_1 =
 {
-	ymirq_callback_1
+	DEVCB_LINE(ymirq_callback_1)
 };
 
 static const ym3526_interface ym3526_config_2 =
 {
-	ymirq_callback_2
+	DEVCB_LINE(ymirq_callback_2)
 };
 
 static const ym3812_interface ym3812_config_1 =
diff -Nru src-old/mame/drivers/spdodgeb.c src/mame/drivers/spdodgeb.c
--- src-old/mame/drivers/spdodgeb.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/spdodgeb.c	2012-03-07 21:23:54.000000000 +0100
@@ -66,7 +66,7 @@
 static void spd_adpcm_int(device_t *device)
 {
 	spdodgeb_state *state = device->machine().driver_data<spdodgeb_state>();
-	int chip = (strcmp(device->tag(), "msm1") == 0) ? 0 : 1;
+	int chip = (strcmp(device->tag(), ":msm1") == 0) ? 0 : 1;
 	if (state->m_adpcm_pos[chip] >= state->m_adpcm_end[chip] || state->m_adpcm_pos[chip] >= 0x10000)
 	{
 		state->m_adpcm_idle[chip] = 1;
diff -Nru src-old/mame/drivers/srumbler.c src/mame/drivers/srumbler.c
--- src-old/mame/drivers/srumbler.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/srumbler.c	2012-03-08 08:39:27.000000000 +0100
@@ -74,7 +74,7 @@
 
 static ADDRESS_MAP_START( srumbler_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x1dff) AM_RAM  /* RAM (of 1 sort or another) */
-	AM_RANGE(0x1e00, 0x1fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x1e00, 0x1fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x2000, 0x3fff) AM_RAM_WRITE(srumbler_background_w) AM_BASE_MEMBER(srumbler_state, m_backgroundram)
 	AM_RANGE(0x4008, 0x4008) AM_READ_PORT("SYSTEM") AM_WRITE(srumbler_bankswitch_w)
 	AM_RANGE(0x4009, 0x4009) AM_READ_PORT("P1") AM_WRITE(srumbler_4009_w)
@@ -248,7 +248,7 @@
 	MCFG_MACHINE_START(srumbler)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM8_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
@@ -256,7 +256,7 @@
 	MCFG_SCREEN_SIZE(64*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(10*8, (64-10)*8-1, 1*8, 31*8-1 )
 	MCFG_SCREEN_UPDATE_STATIC(srumbler)
-	MCFG_SCREEN_VBLANK_STATIC(srumbler)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram8_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(srumbler)
 	MCFG_PALETTE_LENGTH(512)
diff -Nru src-old/mame/drivers/sshangha.c src/mame/drivers/sshangha.c
--- src-old/mame/drivers/sshangha.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/sshangha.c	2012-03-08 10:54:00.000000000 +0100
@@ -173,10 +173,10 @@
 	AM_RANGE(0x320002, 0x320005) AM_WRITENOP
 	AM_RANGE(0x320006, 0x320007) AM_READNOP //irq ack
 
-	AM_RANGE(0x340000, 0x340fff) AM_RAM AM_BASE_GENERIC(spriteram)
+	AM_RANGE(0x340000, 0x340fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x350000, 0x350001) AM_READ(deco_71_r)
 	AM_RANGE(0x350000, 0x350007) AM_WRITENOP
-	AM_RANGE(0x360000, 0x360fff) AM_RAM AM_BASE_GENERIC(spriteram2)
+	AM_RANGE(0x360000, 0x360fff) AM_RAM AM_SHARE("spriteram2")
 	AM_RANGE(0x370000, 0x370001) AM_READ(deco_71_r)
 	AM_RANGE(0x370000, 0x370007) AM_WRITENOP
 
@@ -213,7 +213,7 @@
 	AM_RANGE(0x380c00, 0x380fff) AM_RAM_WRITE(paletteram16_xbgr_word_be_tilelow_w) AM_BASE_MEMBER(sshangha_state, m_tile_paletteram1)
 	AM_RANGE(0x381000, 0x383fff) AM_RAM // unused palette area
 
-	AM_RANGE(0x3c0000, 0x3c0fff) AM_RAM AM_BASE_GENERIC(spriteram) // bootleg spriteram
+	AM_RANGE(0x3c0000, 0x3c0fff) AM_RAM AM_SHARE("spriteram") // bootleg spriteram
 	AM_RANGE(0xfec000, 0xff3fff) AM_RAM
 	AM_RANGE(0xff4000, 0xff47ff) AM_RAM
 ADDRESS_MAP_END
diff -Nru src-old/mame/drivers/stepstag.c src/mame/drivers/stepstag.c
--- src-old/mame/drivers/stepstag.c	2012-01-17 07:16:20.000000000 +0100
+++ src/mame/drivers/stepstag.c	2012-03-08 10:54:00.000000000 +0100
@@ -59,7 +59,7 @@
 
 static ADDRESS_MAP_START( stepstag_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")			// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_READWRITE8(tetrisp2_priority_r, rockn_priority_w, 0x00ff)		// Priority
diff -Nru src-old/mame/drivers/suna16.c src/mame/drivers/suna16.c
--- src-old/mame/drivers/suna16.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/suna16.c	2012-03-07 19:42:58.000000000 +0100
@@ -910,14 +910,9 @@
                             Best Of Best
 ***************************************************************************/
 
-static void bestbest_ym3526_irqhandler(device_t *device, int state)
-{
-	cputag_set_input_line(device->machine(), "audiocpu", INPUT_LINE_IRQ0, state);
-}
-
 static const ym3526_interface bestbest_ym3526_interface =
 {
-	bestbest_ym3526_irqhandler
+	DEVCB_CPU_INPUT_LINE("audiocpu", INPUT_LINE_IRQ0)
 };
 
 static WRITE8_DEVICE_HANDLER( bestbest_ay8910_port_a_w )
diff -Nru src-old/mame/drivers/superchs.c src/mame/drivers/superchs.c
--- src-old/mame/drivers/superchs.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/superchs.c	2012-03-04 17:11:56.000000000 +0100
@@ -405,37 +405,75 @@
 
 ROM_START( superchs )
 	ROM_REGION( 0x100000, "maincpu", 0 )	/* 1024K for 68020 code (CPU A) */
-	ROM_LOAD32_BYTE( "d46-35.27", 0x00000, 0x40000, CRC(1575c9a7) SHA1(e3441d6018ed3315c62c5e5c4534d8712b025ae2) )
-	ROM_LOAD32_BYTE( "d46-34.25", 0x00001, 0x40000, CRC(c72a4d2b) SHA1(6ef64de15e52007406ce3255071a1f856e0e8b49) )
-	ROM_LOAD32_BYTE( "d46-33.23", 0x00002, 0x40000, CRC(3094bcd0) SHA1(b6779b81a3ebec440a9359868dc43fc3a631ee11) )
-	ROM_LOAD32_BYTE( "d46-31.21", 0x00003, 0x40000, CRC(38b983a3) SHA1(c4859cecc2f3506b7090c462cecd3e4eaabe85aa) )
+	ROM_LOAD32_BYTE( "d46-35.ic27", 0x00000, 0x40000, CRC(1575c9a7) SHA1(e3441d6018ed3315c62c5e5c4534d8712b025ae2) )
+	ROM_LOAD32_BYTE( "d46-34.ic25", 0x00001, 0x40000, CRC(c72a4d2b) SHA1(6ef64de15e52007406ce3255071a1f856e0e8b49) )
+	ROM_LOAD32_BYTE( "d46-33.ic23", 0x00002, 0x40000, CRC(3094bcd0) SHA1(b6779b81a3ebec440a9359868dc43fc3a631ee11) )
+	ROM_LOAD32_BYTE( "d46-31.ic21", 0x00003, 0x40000, CRC(38b983a3) SHA1(c4859cecc2f3506b7090c462cecd3e4eaabe85aa) )
 
 	ROM_REGION( 0x140000, "audiocpu", 0 )	/* Sound cpu */
-	ROM_LOAD16_BYTE( "d46-37.8up", 0x100000, 0x20000, CRC(60b51b91) SHA1(0d0b017808e0a3bdabe8ef5a726bbe16428db06b) )
-	ROM_LOAD16_BYTE( "d46-36.7lo", 0x100001, 0x20000, CRC(8f7aa276) SHA1(b3e330e33099d3cbf4cdc43063119b041e9eea3a) )
+	ROM_LOAD16_BYTE( "d46-37.ic8", 0x100000, 0x20000, CRC(60b51b91) SHA1(0d0b017808e0a3bdabe8ef5a726bbe16428db06b) )
+	ROM_LOAD16_BYTE( "d46-36.ic7", 0x100001, 0x20000, CRC(8f7aa276) SHA1(b3e330e33099d3cbf4cdc43063119b041e9eea3a) )
 
 	ROM_REGION( 0x40000, "sub", 0 )	/* 256K for 68000 code (CPU B) */
-	ROM_LOAD16_BYTE( "d46-24.127", 0x00000, 0x20000, CRC(a006baa1) SHA1(e691ddab6cb79444bd6c3fc870e0dff3051d8cf9) )
-	ROM_LOAD16_BYTE( "d46-23.112", 0x00001, 0x20000, CRC(9a69dbd0) SHA1(13eca492f1db834c599656750864e7003514f3d4) )
+	ROM_LOAD16_BYTE( "d46-24.ic127", 0x00000, 0x20000, CRC(a006baa1) SHA1(e691ddab6cb79444bd6c3fc870e0dff3051d8cf9) )
+	ROM_LOAD16_BYTE( "d46-23.ic112", 0x00001, 0x20000, CRC(9a69dbd0) SHA1(13eca492f1db834c599656750864e7003514f3d4) )
 
 	ROM_REGION( 0x200000, "gfx1", 0 )
-	ROM_LOAD16_BYTE( "d46-05.87", 0x00000, 0x100000, CRC(150d0e4c) SHA1(9240b32900be733b8f44868ed5d64f5f1aaadb47) )	/* SCR 16x16 tiles */
-	ROM_LOAD16_BYTE( "d46-06.88", 0x00001, 0x100000, CRC(321308be) SHA1(17e724cce39b1331650c1f08d693d057dcd43a3f) )
+	ROM_LOAD16_BYTE( "d46-05.ic87", 0x00000, 0x100000, CRC(150d0e4c) SHA1(9240b32900be733b8f44868ed5d64f5f1aaadb47) )	/* SCR 16x16 tiles */
+	ROM_LOAD16_BYTE( "d46-06.ic88", 0x00001, 0x100000, CRC(321308be) SHA1(17e724cce39b1331650c1f08d693d057dcd43a3f) )
 
 	ROM_REGION( 0x800000, "gfx2", 0 )
-	ROM_LOAD32_BYTE( "d46-01.64", 0x000003, 0x200000, CRC(5c2ae92d) SHA1(bee2caed4729a27fa0569d952d6d12170c2aa2a8) )	/* OBJ 16x16 tiles: each rom has 1 bitplane */
-	ROM_LOAD32_BYTE( "d46-02.65", 0x000002, 0x200000, CRC(a83ca82e) SHA1(03759be87a8d62c0044e8a44e90c47308e32d3e5) )
-	ROM_LOAD32_BYTE( "d46-03.66", 0x000001, 0x200000, CRC(e0e9cbfd) SHA1(b7deb2c58320af9d1b4273ad2758ce927d2e279c) )
-	ROM_LOAD32_BYTE( "d46-04.67", 0x000000, 0x200000, CRC(832769a9) SHA1(136ead19edeee90b5be91a6e2f434193dc670fd8) )
+	ROM_LOAD32_BYTE( "d46-01.ic64", 0x000003, 0x200000, CRC(5c2ae92d) SHA1(bee2caed4729a27fa0569d952d6d12170c2aa2a8) )	/* OBJ 16x16 tiles: each rom has 1 bitplane */
+	ROM_LOAD32_BYTE( "d46-02.ic65", 0x000002, 0x200000, CRC(a83ca82e) SHA1(03759be87a8d62c0044e8a44e90c47308e32d3e5) )
+	ROM_LOAD32_BYTE( "d46-03.ic66", 0x000001, 0x200000, CRC(e0e9cbfd) SHA1(b7deb2c58320af9d1b4273ad2758ce927d2e279c) )
+	ROM_LOAD32_BYTE( "d46-04.ic67", 0x000000, 0x200000, CRC(832769a9) SHA1(136ead19edeee90b5be91a6e2f434193dc670fd8) )
 
 	ROM_REGION16_LE( 0x80000, "user1", 0 )
-	ROM_LOAD16_WORD( "d46-07.34", 0x00000, 0x80000, CRC(c3b8b093) SHA1(f34364248ca7fdaaa1a0f8f6f795f9b4bc935fb9) )	/* STY, used to create big sprites on the fly */
+	ROM_LOAD16_WORD( "d46-07.ic34", 0x00000, 0x80000, CRC(c3b8b093) SHA1(f34364248ca7fdaaa1a0f8f6f795f9b4bc935fb9) )	/* STY, used to create big sprites on the fly */
 
 	ROM_REGION16_BE( 0x1000000, "ensoniq.0" , ROMREGION_ERASE00 )
-	ROM_LOAD16_BYTE( "d46-10.2", 0xc00000, 0x200000, CRC(306256be) SHA1(e6e5d4a4c0b98470f2aff2e94624dd19af73ec5d) )
-	ROM_LOAD16_BYTE( "d46-12.4", 0x000000, 0x200000, CRC(a24a53a8) SHA1(5d5fb87a94ceabda89360064d7d9b6d23c4c606b) )
+	ROM_LOAD16_BYTE( "d46-10.ic2", 0xc00000, 0x200000, CRC(306256be) SHA1(e6e5d4a4c0b98470f2aff2e94624dd19af73ec5d) )
+	ROM_LOAD16_BYTE( "d46-12.ic4", 0x000000, 0x200000, CRC(a24a53a8) SHA1(5d5fb87a94ceabda89360064d7d9b6d23c4c606b) )
 	ROM_RELOAD     (             0x400000, 0x200000 )
-	ROM_LOAD16_BYTE( "d46-11.5", 0x800000, 0x200000, CRC(d4ea0f56) SHA1(dc8d2ed3c11d0b6f9ebdfde805188884320235e6) )
+	ROM_LOAD16_BYTE( "d46-11.ic5", 0x800000, 0x200000, CRC(d4ea0f56) SHA1(dc8d2ed3c11d0b6f9ebdfde805188884320235e6) )
+
+	ROM_REGION16_BE( 0x80, "eeprom", 0 )
+	ROM_LOAD( "eeprom-superchs.bin", 0x0000, 0x0080, CRC(230f0753) SHA1(4c692b35083da71ed866b233c7c9b152a914c95c) )
+ROM_END
+
+ROM_START( superchsj )
+	ROM_REGION( 0x100000, "maincpu", 0 )	/* 1024K for 68020 code (CPU A) */
+	ROM_LOAD32_BYTE( "d46-28+.ic27", 0x00000, 0x40000, CRC(5c33784f) SHA1(cb3b3bae4fe8f83809c1f437635b3efc1fb4206a) ) /* Actually labeled D46 28* */
+	ROM_LOAD32_BYTE( "d46-27+.ic25", 0x00001, 0x40000, CRC(e81125b8) SHA1(a5c9731eb255217861cda0dfad1ee5003f087b81) ) /* Actually labeled D46 27* */
+	ROM_LOAD32_BYTE( "d46-26+.ic23", 0x00002, 0x40000, CRC(2aaba1b0) SHA1(13ceaa678bd671c5c88cac35e8a021a180728a69) ) /* Actually labeled D46 26* */
+	ROM_LOAD32_BYTE( "d46-25+.ic21", 0x00003, 0x40000, CRC(4241e97a) SHA1(e3e361080e3ebc098805310d41b3afe7f14ff8b4) ) /* Actually labeled D46 25* */
+
+	ROM_REGION( 0x140000, "audiocpu", 0 )	/* Sound cpu */
+	ROM_LOAD16_BYTE( "d46-30.ic8", 0x100000, 0x20000, CRC(88f8a421) SHA1(4fd0885d398b1b0e127d7462926d1630a635e305) )
+	ROM_LOAD16_BYTE( "d46-29.ic7", 0x100001, 0x20000, CRC(04501fa5) SHA1(dfbafc34df8ab0fcaefb5ca4c3143977020b7e58) )
+
+	ROM_REGION( 0x40000, "sub", 0 )	/* 256K for 68000 code (CPU B) */
+	ROM_LOAD16_BYTE( "d46-24.ic127", 0x00000, 0x20000, CRC(a006baa1) SHA1(e691ddab6cb79444bd6c3fc870e0dff3051d8cf9) )
+	ROM_LOAD16_BYTE( "d46-23.ic112", 0x00001, 0x20000, CRC(9a69dbd0) SHA1(13eca492f1db834c599656750864e7003514f3d4) )
+
+	ROM_REGION( 0x200000, "gfx1", 0 )
+	ROM_LOAD16_BYTE( "d46-05.ic87", 0x00000, 0x100000, CRC(150d0e4c) SHA1(9240b32900be733b8f44868ed5d64f5f1aaadb47) )	/* SCR 16x16 tiles */
+	ROM_LOAD16_BYTE( "d46-06.ic88", 0x00001, 0x100000, CRC(321308be) SHA1(17e724cce39b1331650c1f08d693d057dcd43a3f) )
+
+	ROM_REGION( 0x800000, "gfx2", 0 )
+	ROM_LOAD32_BYTE( "d46-01.ic64", 0x000003, 0x200000, CRC(5c2ae92d) SHA1(bee2caed4729a27fa0569d952d6d12170c2aa2a8) )	/* OBJ 16x16 tiles: each rom has 1 bitplane */
+	ROM_LOAD32_BYTE( "d46-02.ic65", 0x000002, 0x200000, CRC(a83ca82e) SHA1(03759be87a8d62c0044e8a44e90c47308e32d3e5) )
+	ROM_LOAD32_BYTE( "d46-03.ic66", 0x000001, 0x200000, CRC(e0e9cbfd) SHA1(b7deb2c58320af9d1b4273ad2758ce927d2e279c) )
+	ROM_LOAD32_BYTE( "d46-04.ic67", 0x000000, 0x200000, CRC(832769a9) SHA1(136ead19edeee90b5be91a6e2f434193dc670fd8) )
+
+	ROM_REGION16_LE( 0x80000, "user1", 0 )
+	ROM_LOAD16_WORD( "d46-07.ic34", 0x00000, 0x80000, CRC(c3b8b093) SHA1(f34364248ca7fdaaa1a0f8f6f795f9b4bc935fb9) )	/* STY, used to create big sprites on the fly */
+
+	ROM_REGION16_BE( 0x1000000, "ensoniq.0" , ROMREGION_ERASE00 )
+	ROM_LOAD16_BYTE( "d46-10.ic2", 0xc00000, 0x200000, CRC(306256be) SHA1(e6e5d4a4c0b98470f2aff2e94624dd19af73ec5d) )
+	ROM_LOAD16_BYTE( "d46-09.ic4", 0x000000, 0x200000, CRC(0acb8bc7) SHA1(62d66925f0eee4cee282c4e0972e08d12acf331c) )
+	ROM_RELOAD     (             0x400000, 0x200000 )
+	ROM_LOAD16_BYTE( "d46-08.ic5", 0x800000, 0x200000, CRC(4677e820) SHA1(d6427844b08438e45af4c671589a270e46e6dead) )
 
 	ROM_REGION16_BE( 0x80, "eeprom", 0 )
 	ROM_LOAD( "eeprom-superchs.bin", 0x0000, 0x0080, CRC(230f0753) SHA1(4c692b35083da71ed866b233c7c9b152a914c95c) )
@@ -466,4 +504,5 @@
 	machine.device("sub")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x80000a, 0x80000b, FUNC(sub_cycle_r));
 }
 
-GAMEL( 1992, superchs, 0, superchs, superchs, superchs, ROT0, "Taito America Corporation", "Super Chase - Criminal Termination (US)", 0, layout_superchs )
+GAMEL( 1992, superchs,         0, superchs, superchs, superchs, ROT0, "Taito America Corporation", "Super Chase - Criminal Termination (US)", 0, layout_superchs )
+GAMEL( 1992, superchsj, superchs, superchs, superchs, superchs, ROT0, "Taito Corporation", "Super Chase - Criminal Termination (Japan)", 0, layout_superchs )
diff -Nru src-old/mame/drivers/suprnova.c src/mame/drivers/suprnova.c
--- src-old/mame/drivers/suprnova.c	2012-01-17 19:39:55.000000000 +0100
+++ src/mame/drivers/suprnova.c	2012-03-08 10:54:00.000000000 +0100
@@ -695,7 +695,7 @@
 	AM_RANGE(0x00c00000, 0x00c00003) AM_DEVREADWRITE8("ymz", ymz280b_r, ymz280b_w, 0xffff0000) /* ymz280_w (sound) */
 	AM_RANGE(0x01000000, 0x0100000f) AM_DEVREADWRITE8_MODERN("rtc", msm6242_device, read, write, 0xffffffff)
 	AM_RANGE(0x01800000, 0x01800003) AM_WRITE(skns_hit2_w)
-	AM_RANGE(0x02000000, 0x02003fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram) /* sprite ram */
+	AM_RANGE(0x02000000, 0x02003fff) AM_RAM AM_SHARE("spriteram") /* sprite ram */
 	AM_RANGE(0x02100000, 0x0210003f) AM_RAM AM_BASE_MEMBER(skns_state, m_spc_regs) /* sprite registers */
 	AM_RANGE(0x02400000, 0x0240007f) AM_RAM_WRITE(skns_v3_regs_w) AM_BASE_MEMBER(skns_state, m_v3_regs) /* tilemap registers */
 	AM_RANGE(0x02500000, 0x02503fff) AM_RAM_WRITE(skns_tilemapA_w) AM_BASE_MEMBER(skns_state, m_tilemapA_ram) /* tilemap A */
diff -Nru src-old/mame/drivers/taitotz.c src/mame/drivers/taitotz.c
--- src-old/mame/drivers/taitotz.c	2012-01-15 02:13:13.000000000 +0100
+++ src/mame/drivers/taitotz.c	2012-03-11 18:17:00.000000000 +0100
@@ -500,8 +500,40 @@
 	DISK_IMAGE( "bg2_204j", 0, SHA1(7ac100fba39ae0b93980c0af2f0212a731106912) )
 ROM_END
 
+ROM_START( batlgr2a )
+	ROM_REGION64_BE( 0x100000, "user1", 0 )
+	TAITOTZ_BIOS
+
+	ROM_REGION( 0x40000, "io_cpu", 0 )
+	ROM_LOAD16_BYTE( "e87-03.ic14",  0x000000, 0x020000, CRC(49ae7cd0) SHA1(15f07a6bb2044a85a2139481f1dc95a44520c929) )
+	ROM_LOAD16_BYTE( "e87-04.ic15",  0x000001, 0x020000, CRC(59f8f75f) SHA1(f5595751b10c0033f460114c43f5e2c192fe61f1) )
+
+	ROM_REGION( 0x10000, "sound_cpu", 0 ) /* Internal ROM :( */
+	ROM_LOAD( "e68-01.ic7", 0x000000, 0x010000, NO_DUMP )
+
+	DISK_REGION( "ide" )
+	DISK_IMAGE( "bg2_201j", 0, SHA1(542d12682bd0f95143368578461c6a4fcc492fcc) )
+ROM_END
+
+ROM_START( pwrshovl )
+	ROM_REGION64_BE( 0x100000, "user1", 0 )
+	TAITOTZ_BIOS
+
+	ROM_REGION( 0x40000, "io_cpu", 0 )
+    ROM_LOAD16_BYTE( "e74-04.ic14",   0x000000, 0x020000, CRC(ef21a261) SHA1(7398826dbf48014b9c7e9454f978f3e419ebc64b) )
+    ROM_LOAD16_BYTE( "e74-05.ic15",   0x000001, 0x020000, CRC(2466217d) SHA1(dc814da3a1679cff001f179d3c1641af985a6490) )
+
+	ROM_REGION( 0x10000, "sound_cpu", 0 ) /* Internal ROM :( */
+	ROM_LOAD( "e68-01.ic7", 0x000000, 0x010000, NO_DUMP )
+
+	DISK_REGION( "ide" )
+	DISK_IMAGE( "pwrshovl", 0, SHA1(360f63b39f645851c513b4644fb40601b9ba1412) )
+ROM_END
+
 GAME( 1999, taitotz,  0, taitotz, taitotz, 0, ROT0, "Taito", "Type Zero BIOS", GAME_NO_SOUND|GAME_NOT_WORKING|GAME_IS_BIOS_ROOT)
 GAME( 1999, landhigh, taitotz, taitotz, taitotz, 0, ROT0, "Taito", "Landing High Japan", GAME_NOT_WORKING | GAME_NO_SOUND )
 GAME( 1999, batlgear, taitotz, taitotz, taitotz, 0, ROT0, "Taito", "Battle Gear", GAME_NOT_WORKING | GAME_NO_SOUND )
+GAME( 1999, pwrshovl, taitotz, taitotz, taitotz, 0, ROT0, "Taito", "Power Shovel ni Norou!! - Power Shovel Simulator", GAME_NOT_WORKING | GAME_NO_SOUND )
 GAME( 2000, batlgr2,  taitotz, taitotz, taitotz, 0, ROT0, "Taito", "Battle Gear 2 (v2.04J)", GAME_NOT_WORKING | GAME_NO_SOUND )
+GAME( 2000, batlgr2a, batlgr2, taitotz, taitotz, 0, ROT0, "Taito", "Battle Gear 2 (v2.01J)", GAME_NOT_WORKING | GAME_NO_SOUND )
 
diff -Nru src-old/mame/drivers/tbowl.c src/mame/drivers/tbowl.c
--- src-old/mame/drivers/tbowl.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/tbowl.c	2012-03-07 21:23:54.000000000 +0100
@@ -168,7 +168,7 @@
 static void tbowl_adpcm_int(device_t *device)
 {
 	tbowl_state *state = device->machine().driver_data<tbowl_state>();
-	int num = (strcmp(device->tag(), "msm1") == 0) ? 0 : 1;
+	int num = (strcmp(device->tag(), ":msm1") == 0) ? 0 : 1;
 	if (state->m_adpcm_pos[num] >= state->m_adpcm_end[num] ||
 				state->m_adpcm_pos[num] >= device->machine().region("adpcm")->bytes()/2)
 		msm5205_reset_w(device,1);
diff -Nru src-old/mame/drivers/tetrisp2.c src/mame/drivers/tetrisp2.c
--- src-old/mame/drivers/tetrisp2.c	2012-01-17 07:16:20.000000000 +0100
+++ src/mame/drivers/tetrisp2.c	2012-03-08 10:54:00.000000000 +0100
@@ -296,7 +296,7 @@
 
 static ADDRESS_MAP_START( tetrisp2_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM															// ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")			// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_READWRITE8(tetrisp2_priority_r, tetrisp2_priority_w, 0x00ff)
@@ -353,7 +353,7 @@
 
 static ADDRESS_MAP_START( nndmseal_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)	// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")	// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM	// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM	// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_WRITE8(tetrisp2_priority_w, 0x00ff)	// Priority
@@ -399,7 +399,7 @@
 
 static ADDRESS_MAP_START( rockn1_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM															// ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")			// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_READWRITE8(tetrisp2_priority_r, rockn_priority_w, 0x00ff)		// Priority
@@ -433,7 +433,7 @@
 
 static ADDRESS_MAP_START( rockn2_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM															// ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")			// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_READWRITE8(tetrisp2_priority_r, rockn_priority_w, 0x00ff)	// Priority
@@ -467,7 +467,7 @@
 
 static ADDRESS_MAP_START( rocknms_main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM															// ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)			// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram")			// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_READWRITE8(tetrisp2_priority_r, rockn_priority_w, 0x00ff)		// Priority
@@ -502,7 +502,7 @@
 
 static ADDRESS_MAP_START( rocknms_sub_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM															// ROM
-	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)		// Object RAM
+	AM_RANGE(0x100000, 0x103fff) AM_RAM AM_SHARE("spriteram2")		// Object RAM
 	AM_RANGE(0x104000, 0x107fff) AM_RAM															// Spare Object RAM
 	AM_RANGE(0x108000, 0x10ffff) AM_RAM															// Work RAM
 	AM_RANGE(0x200000, 0x23ffff) AM_RAM_WRITE(rocknms_sub_priority_w) AM_BASE_MEMBER(tetrisp2_state, m_rocknms_sub_priority) // Priority
diff -Nru src-old/mame/drivers/tigeroad.c src/mame/drivers/tigeroad.c
--- src-old/mame/drivers/tigeroad.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/tigeroad.c	2012-03-08 08:39:27.000000000 +0100
@@ -169,7 +169,7 @@
 
 static ADDRESS_MAP_START( main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
-	AM_RANGE(0xfe0800, 0xfe0cff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0xfe0800, 0xfe0cff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xfe0d00, 0xfe1807) AM_RAM		/* still part of OBJ RAM */
 	AM_RANGE(0xfe4000, 0xfe4001) AM_READ_PORT("P1_P2") AM_WRITE(tigeroad_videoctrl_w)	/* char bank, coin counters, + ? */
 	AM_RANGE(0xfe4002, 0xfe4003) AM_READ_PORT("SYSTEM")
@@ -529,7 +529,7 @@
 	/* IRQs are triggered by the YM2203 */
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60.08)   /* verified on pcb */
@@ -537,7 +537,7 @@
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
 	MCFG_SCREEN_UPDATE_STATIC(tigeroad)
-	MCFG_SCREEN_VBLANK_STATIC(tigeroad)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(tigeroad)
 	MCFG_PALETTE_LENGTH(576)
diff -Nru src-old/mame/drivers/tmnt.c src/mame/drivers/tmnt.c
--- src-old/mame/drivers/tmnt.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/tmnt.c	2012-03-04 18:26:17.000000000 +0100
@@ -1183,22 +1183,22 @@
 ADDRESS_MAP_END
 
 
-static READ8_DEVICE_HANDLER( k054539_ctrl_r )
+static READ8_HANDLER( k054539_ctrl_r )
 {
-	return k054539_r(device, 0x200 + offset);
+	return space->machine().device<k054539_device>("k054539")->read(*space, 0x200 + offset, 0xff);
 }
 
-static WRITE8_DEVICE_HANDLER( k054539_ctrl_w )
+static WRITE8_HANDLER( k054539_ctrl_w )
 {
-	k054539_w(device, 0x200 + offset, data);
+	space->machine().device<k054539_device>("k054539")->write(*space, 0x200 + offset, data, 0xff);
 }
 
 static ADDRESS_MAP_START( prmrsocr_audio_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe0ff) AM_DEVREADWRITE("k054539", k054539_r, k054539_w)
-	AM_RANGE(0xe100, 0xe12f) AM_DEVREADWRITE("k054539", k054539_ctrl_r, k054539_ctrl_w)
+	AM_RANGE(0xe000, 0xe0ff) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
+	AM_RANGE(0xe100, 0xe12f) AM_READWRITE(k054539_ctrl_r, k054539_ctrl_w)
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch3_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
 	AM_RANGE(0xf003, 0xf003) AM_READ(soundlatch2_r)
@@ -2672,8 +2672,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/tnzs.c src/mame/drivers/tnzs.c
--- src-old/mame/drivers/tnzs.c	2012-02-19 02:53:16.000000000 +0100
+++ src/mame/drivers/tnzs.c	2012-03-11 18:17:00.000000000 +0100
@@ -2136,6 +2136,30 @@
 	ROM_LOAD( "b08-07.16f",	0x00200, 0x200, CRC(ea34d9f7) SHA1(9a46edc64f961bd96908419cabd92445d300fc19) )	/* lo bytes, AM27S29 or compatible like MB7124 */
 ROM_END
 
+ROM_START( arknoid2b )
+	ROM_REGION( 0x30000, "maincpu", 0 )				/* Region 0 - main cpu */
+    ROM_LOAD( "boot.11c",  0x00000, 0x08000, CRC(3847dfb0) SHA1(993c8af3df7a4d5a2523f0e31a6df1c07ba13c7d) )
+	ROM_CONTINUE(           0x18000, 0x08000 )			/* banked at 8000-bfff */
+	/* 20000-2ffff empty */
+
+	ROM_REGION( 0x18000, "sub", 0 )				/* Region 2 - sound cpu */
+	ROM_LOAD( "b08_13.3e", 0x00000, 0x08000, CRC(e8035ef1) SHA1(9a54e952cff0036c4b6affd9ffb1097cdccbe255) )
+	ROM_CONTINUE(          0x10000, 0x08000 )			/* banked at 8000-9fff */
+
+	ROM_REGION( 0x10000, "audiocpu", 0 )	/* M-Chip (i8742 internal ROM) */
+	ROM_LOAD( "ark28742.3g", 0x0000, 0x0800, NO_DUMP )
+
+	ROM_REGION( 0x80000, "gfx1", 0 )
+	ROM_LOAD( "b08-01.13a",	0x00000, 0x20000, CRC(2ccc86b4) SHA1(eced1d7e687db0331507726946b6a19a690a7604) )
+	ROM_LOAD( "b08-02.10a",	0x20000, 0x20000, CRC(056a985f) SHA1(6333b71c631d3307929aae633760870451830e10) )
+	ROM_LOAD( "b08-03.7a",	0x40000, 0x20000, CRC(274a795f) SHA1(49353590e1a418843f57c715185e407a20021936) )
+	ROM_LOAD( "b08-04.4a",	0x60000, 0x20000, CRC(9754f703) SHA1(0018ebf7da3f501345f3f5085d98d7614f8ce1b6) )
+
+	ROM_REGION( 0x0400, "proms", 0 )
+	ROM_LOAD( "b08-08.15f",	0x00000, 0x200, CRC(a4f7ebd9) SHA1(094eb63c18898c6ee8d722492bdfd28091c61773) )	/* hi bytes, AM27S29 or compatible like MB7124 */
+	ROM_LOAD( "b08-07.16f",	0x00200, 0x200, CRC(ea34d9f7) SHA1(9a46edc64f961bd96908419cabd92445d300fc19) )	/* lo bytes, AM27S29 or compatible like MB7124 */
+ROM_END
+
 ROM_START( drtoppel )
 	ROM_REGION( 0x30000, "maincpu", 0 )	/* 64k + bankswitch areas for the first CPU */
 	ROM_LOAD( "b19-09.11c", 0x00000, 0x08000, CRC(3e654f82) SHA1(d9e351d82546b08eb7887ea1d976fa97a259db6e) )
@@ -2724,6 +2748,7 @@
 GAME( 1987, arknoid2,  0,        arknoid2, arknoid2, arknoid2, ROT270, "Taito Corporation Japan", "Arkanoid - Revenge of DOH (World)", 0 )
 GAME( 1987, arknoid2u, arknoid2, arknoid2, arknid2u, arknoid2, ROT270, "Taito America Corporation (Romstar license)", "Arkanoid - Revenge of DOH (US)", 0 )
 GAME( 1987, arknoid2j, arknoid2, arknoid2, arknid2u, arknoid2, ROT270, "Taito Corporation", "Arkanoid - Revenge of DOH (Japan)", 0 )
+GAME( 1987, arknoid2b, arknoid2, arknoid2, arknid2u, arknoid2, ROT270, "bootleg", "Arkanoid - Revenge of DOH (Japan bootleg)", 0 )
 GAME( 1987, drtoppel,  0,        drtoppel, drtoppel, drtoppel, ROT90,  "Kaneko / Taito Corporation Japan", "Dr. Toppel's Adventure (World)", 0 ) /* Possible region hack */
 GAME( 1987, drtoppelu, drtoppel, drtoppel, drtopplu, drtoppel, ROT90,  "Kaneko / Taito America Corporation", "Dr. Toppel's Adventure (US)", 0 ) /* Possible region hack */
 GAME( 1987, drtoppelj, drtoppel, drtoppel, drtopplu, drtoppel, ROT90,  "Kaneko / Taito Corporation", "Dr. Toppel's Tankentai (Japan)", 0 )
diff -Nru src-old/mame/drivers/toki.c src/mame/drivers/toki.c
--- src-old/mame/drivers/toki.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/toki.c	2012-03-08 08:39:27.000000000 +0100
@@ -93,7 +93,7 @@
 static ADDRESS_MAP_START( toki_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x05ffff) AM_ROM
 	AM_RANGE(0x060000, 0x06d7ff) AM_RAM
-	AM_RANGE(0x06d800, 0x06dfff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x06d800, 0x06dfff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x06e000, 0x06e7ff) AM_RAM_WRITE(paletteram16_xxxxBBBBGGGGRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x06e800, 0x06efff) AM_RAM_WRITE(toki_background1_videoram16_w) AM_BASE_MEMBER(toki_state, m_background1_videoram16)
 	AM_RANGE(0x06f000, 0x06f7ff) AM_RAM_WRITE(toki_background2_videoram16_w) AM_BASE_MEMBER(toki_state, m_background2_videoram16)
@@ -116,7 +116,7 @@
 	AM_RANGE(0x071000, 0x071001) AM_WRITENOP	/* sprite related? seems another scroll register */
 				/* gets written the same value as 75000a (bg2 scrollx) */
 	AM_RANGE(0x071804, 0x071807) AM_WRITENOP	/* sprite related, always 01be0100 */
-	AM_RANGE(0x07180e, 0x071e45) AM_WRITEONLY AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x07180e, 0x071e45) AM_WRITEONLY AM_SHARE("spriteram")
 	AM_RANGE(0x072000, 0x072001) AM_READ(watchdog_reset16_r)   /* probably */
 	AM_RANGE(0x075000, 0x075001) AM_WRITE(tokib_soundcommand16_w)
 	AM_RANGE(0x075004, 0x07500b) AM_WRITEONLY AM_BASE_MEMBER(toki_state, m_scrollram16)
@@ -425,14 +425,14 @@
 	MCFG_MACHINE_RESET(seibu_sound)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(59.61)    /* verified on pcb */
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)	/* verified */
 	MCFG_SCREEN_UPDATE_STATIC(toki)
-	MCFG_SCREEN_VBLANK_STATIC(toki)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(toki)
 	MCFG_PALETTE_LENGTH(1024)
@@ -455,14 +455,14 @@
 	MCFG_CPU_PROGRAM_MAP(tokib_audio_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)	/* verified */
 	MCFG_SCREEN_UPDATE_STATIC(tokib)
-	MCFG_SCREEN_VBLANK_STATIC(tokib)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(tokib)
 	MCFG_PALETTE_LENGTH(1024)
diff -Nru src-old/mame/drivers/twin16.c src/mame/drivers/twin16.c
--- src-old/mame/drivers/twin16.c	2012-01-28 01:55:17.000000000 +0100
+++ src/mame/drivers/twin16.c	2012-03-08 08:39:27.000000000 +0100
@@ -261,7 +261,7 @@
 	AM_RANGE(0x100000, 0x103fff) AM_RAM_WRITE(twin16_text_ram_w) AM_BASE_MEMBER(twin16_state, m_text_ram)
 //  AM_RANGE(0x104000, 0x105fff) AM_NOP             // miaj
 	AM_RANGE(0x120000, 0x123fff) AM_RAM AM_BASE_MEMBER(twin16_state, m_videoram)
-	AM_RANGE(0x140000, 0x143fff) AM_RAM AM_SHARE("share1") AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x140000, 0x143fff) AM_RAM AM_SHARE("spriteram")
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( sub_map, AS_PROGRAM, 16 )
@@ -271,7 +271,7 @@
 	AM_RANGE(0x060000, 0x063fff) AM_RAM
 	AM_RANGE(0x080000, 0x09ffff) AM_READ(extra_rom_r)
 	AM_RANGE(0x0a0000, 0x0a0001) AM_WRITE(twin16_CPUB_register_w)
-	AM_RANGE(0x400000, 0x403fff) AM_RAM AM_SHARE("share1")
+	AM_RANGE(0x400000, 0x403fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x480000, 0x483fff) AM_READWRITE(videoram16_r, videoram16_w)
 	AM_RANGE(0x500000, 0x53ffff) AM_RAM AM_BASE_MEMBER(twin16_state, m_tile_gfx_ram)
 	AM_RANGE(0x600000, 0x6fffff) AM_READ(twin16_gfx_rom1_r)
@@ -293,7 +293,7 @@
 	AM_RANGE(0x0e0000, 0x0e0001) AM_WRITE(fround_gfx_bank_w)
 	AM_RANGE(0x100000, 0x103fff) AM_RAM_WRITE(twin16_text_ram_w) AM_BASE_MEMBER(twin16_state, m_text_ram)
 	AM_RANGE(0x120000, 0x123fff) AM_RAM AM_BASE_MEMBER(twin16_state, m_videoram)
-	AM_RANGE(0x140000, 0x143fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x140000, 0x143fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x500000, 0x6fffff) AM_READ(twin16_gfx_rom1_r)
 ADDRESS_MAP_END
 
@@ -746,7 +746,8 @@
 	MCFG_MACHINE_RESET(twin16)
 
 	// video hardware
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(((double)XTAL_18_432MHz / 2) / (576 * 264))
@@ -799,7 +800,8 @@
 	MCFG_MACHINE_RESET(twin16)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_HAS_SHADOWS)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(60)
diff -Nru src-old/mame/drivers/twincobr.c src/mame/drivers/twincobr.c
--- src-old/mame/drivers/twincobr.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/twincobr.c	2012-03-08 08:39:27.000000000 +0100
@@ -277,7 +277,7 @@
 static ADDRESS_MAP_START( main_program_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x02ffff) AM_ROM
 	AM_RANGE(0x030000, 0x033fff) AM_RAM		/* 68K and DSP shared RAM */
-	AM_RANGE(0x040000, 0x040fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x040000, 0x040fff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0x050000, 0x050dff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x060000, 0x060001) AM_DEVWRITE8_MODERN("crtc", mc6845_device, address_w, 0x00ff)
 	AM_RANGE(0x060002, 0x060003) AM_DEVWRITE8_MODERN("crtc", mc6845_device, register_w, 0x00ff)
@@ -582,12 +582,13 @@
 	/* video hardware */
 	MCFG_MC6845_ADD("crtc", HD6845, XTAL_28MHz/8, twincobr_mc6845_intf)	/* 3.5MHz measured on CLKin */
 
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_RAW_PARAMS(XTAL_28MHz/4, 446, 0, 320, 286, 0, 240)
 	MCFG_SCREEN_UPDATE_STATIC(toaplan0)
-	MCFG_SCREEN_VBLANK_STATIC(toaplan0)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(twincobr)
 	MCFG_PALETTE_LENGTH(1792)
diff -Nru src-old/mame/drivers/ultrsprt.c src/mame/drivers/ultrsprt.c
--- src-old/mame/drivers/ultrsprt.c	2012-02-11 11:01:01.000000000 +0100
+++ src/mame/drivers/ultrsprt.c	2012-03-04 18:26:17.000000000 +0100
@@ -151,7 +151,7 @@
 	AM_RANGE(0x00100000, 0x00101fff) AM_RAM
 	AM_RANGE(0x00200000, 0x00200007) AM_WRITE(K056800_68k_w)
 	AM_RANGE(0x00200008, 0x0020000f) AM_READ(K056800_68k_r)
-	AM_RANGE(0x00400000, 0x004002ff) AM_DEVREADWRITE8("konami", k054539_r, k054539_w, 0xffff)
+	AM_RANGE(0x00400000, 0x004002ff) AM_DEVREADWRITE8_MODERN("konami", k054539_device, read, write, 0xffff)
 ADDRESS_MAP_END
 
 /*****************************************************************************/
@@ -212,6 +212,7 @@
 	sound_irq_callback
 };
 
+static k054539_interface k054539_config;
 
 static MACHINE_CONFIG_START( ultrsprt, ultrsprt_state )
 	/* basic machine hardware */
@@ -243,7 +244,7 @@
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami", K054539, 48000)
+	MCFG_K054539_ADD("konami", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/undrfire.c src/mame/drivers/undrfire.c
--- src-old/mame/drivers/undrfire.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/undrfire.c	2012-03-11 18:17:00.000000000 +0100
@@ -434,6 +434,14 @@
     ........ .x......   P1 gun vibration
     ........ x.......   P2 gun vibration
 */
+
+	if (ACCESSING_BITS_8_15)
+	{
+		output_set_value("P1_lamp_start", (data >> 12) & 1 ); //p1 start
+		output_set_value("P2_lamp_start", (data >> 13) & 1 ); //p2 start
+		output_set_value("P1_gun_recoil", (data >> 14) & 1 ); //p1 recoil
+		output_set_value("P2_gun_recoil", (data >> 15) & 1 ); //p2 recoil
+	}
 }
 
 static WRITE32_HANDLER( cbombers_cpua_ctrl_w )
@@ -442,6 +450,13 @@
     ........ ..xxxxxx   Lamp 1-6 enables
     ........ .x......   Vibration
 */
+	output_set_value("Lamp_1", data & 1 );
+	output_set_value("Lamp_2", (data >> 1) & 1 );
+	output_set_value("Lamp_3", (data >> 2) & 1 );
+	output_set_value("Lamp_4", (data >> 3) & 1 );
+	output_set_value("Lamp_5", (data >> 4) & 1 );
+	output_set_value("Lamp_6", (data >> 5) & 1 );
+	output_set_value("Wheel_vibration", (data >> 6) & 1 );
 
 	cputag_set_input_line(space->machine(), "sub", INPUT_LINE_RESET, (data & 0x1000) ? CLEAR_LINE : ASSERT_LINE);
 }
diff -Nru src-old/mame/drivers/vaportra.c src/mame/drivers/vaportra.c
--- src-old/mame/drivers/vaportra.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/vaportra.c	2012-03-08 08:39:27.000000000 +0100
@@ -62,8 +62,8 @@
 	AM_RANGE(0x300000, 0x3009ff) AM_RAM_WRITE(vaportra_palette_24bit_rg_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x304000, 0x3049ff) AM_RAM_WRITE(vaportra_palette_24bit_b_w) AM_BASE_GENERIC(paletteram2)
 	AM_RANGE(0x308000, 0x308001) AM_NOP
-	AM_RANGE(0x30c000, 0x30c001) AM_WRITE(buffer_spriteram16_w)
-	AM_RANGE(0xff8000, 0xff87ff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x30c000, 0x30c001) AM_DEVWRITE_MODERN("spriteram", buffered_spriteram16_device, write)
+	AM_RANGE(0xff8000, 0xff87ff) AM_RAM AM_SHARE("spriteram")
 	AM_RANGE(0xffc000, 0xffffff) AM_RAM
 ADDRESS_MAP_END
 
@@ -277,7 +277,7 @@
 	MCFG_MACHINE_RESET(vaportra)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_REFRESH_RATE(58)
diff -Nru src-old/mame/drivers/vicdual.c src/mame/drivers/vicdual.c
--- src-old/mame/drivers/vicdual.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/vicdual.c	2012-03-05 15:37:41.000000000 +0100
@@ -2958,7 +2958,7 @@
 	ROM_LOAD( "318a.uxx",     0x2000, 0x0400, CRC(0780721d) SHA1(580aefb382702babdf8248e36330c4b22e8579c8) )
 
 	ROM_REGION( 0x0020, "proms", 0 )
-	ROM_LOAD( "316-246.u44",  0x0000, 0x0020, CRC(fe4406cb) SHA1(92e2459420a7f7412f02cfaf68604fc233b0a245) )
+	ROM_LOAD( "316-0246.u44", 0x0000, 0x0020, CRC(fe4406cb) SHA1(92e2459420a7f7412f02cfaf68604fc233b0a245) )	/* color PROM */
 ROM_END
 
 ROM_START( invds )
@@ -2981,7 +2981,7 @@
 	ROM_LOAD( "382.u1",       0x3c00, 0x0400, CRC(8d195c24) SHA1(5c314947ba13112b4154d3be069892cca4f5da42) )
 
 	ROM_REGION( 0x0020, "proms", 0 )
-	ROM_LOAD( "316-246",      0x0000, 0x0020, CRC(fe4406cb) SHA1(92e2459420a7f7412f02cfaf68604fc233b0a245) )
+	ROM_LOAD( "316-0246.u44", 0x0000, 0x0020, CRC(fe4406cb) SHA1(92e2459420a7f7412f02cfaf68604fc233b0a245) )	/* color PROM */
 
 	ROM_REGION( 0x0020, "user1", 0 )	/* misc PROM */
 	ROM_LOAD( "316-0206.u14", 0x0000, 0x0020, CRC(9617d796) SHA1(7cff2741866095ff42eadd8022bea349ec8d2f39) )	/* control PROM */
diff -Nru src-old/mame/drivers/viper.c src/mame/drivers/viper.c
--- src-old/mame/drivers/viper.c	2012-02-18 03:48:45.000000000 +0100
+++ src/mame/drivers/viper.c	2012-02-29 01:47:20.000000000 +0100
@@ -191,18 +191,8 @@
 
     Driver by Ville Linde
 
-    DASM code snippets:
 
-    00FE0B8C: addi      r31,r3,0x0000
-    00FE0B90: lwz       r3,0x0040(r1)
-    00FE0B94: cmpi      r31,0x0000 ;offending check, understand where r3 comes from!
-    00FE0B98: lwz       r4,0x0044(r1)
-    00FE0B9C: addic     r5,r1,0x0058
-    00FE0BA0: bne       0x00FE0C00
 
-*/
-
-/*
     Software notes (as per Police 911)
     -- VL - 01.06.2011
 
@@ -268,63 +258,6 @@
     0x00009d00:     LoadProgram(): R3 = ptr to filename
 
 
-    Inf loop at 0x00071014 -> 0x00093e14 -> 0x00093f6c
-
-    0x24dcc(): (R3=0x21, R4=0xffffff, R5=0xff, R6=0x10, R7=0x10, R8=0xab50c, R9=0xab520)
-               0xab50c = "G*%s BOOT SYSTEM"
-               0xab520 = "A00"
-
-               (R3=0x21, R4=0xffffff, R5=0xff, R6=0x10, R7=0x20, R8=0xab524, R9=0x7d0)
-               0xab524 = "(C) %d KONAMI ALL RIGHTS RESERVED."
-
-               (R3=0x30021, R4=0xffffff, R5=0xff, R6=0xc0, R7=0x60, R8=0xab610, R9=0xa8)
-               0xab610 = "DEVICE CHECK"
-
-               (R3=0x30021, R4=0xffffff, R5=0xff, R6=0xc0, R7=0x100, R8=0xab620, R9=0x10)
-               0xab620 = "U13    ";
-
-               (R3=0x30021, R4=0xff0000, R5=0xff, R6=0xc0, R7=0x100, R8=0xab628, R9=0xab4dc)
-               0xab628 = "    %s";
-               0xab4dc = "BAD";
-
-    VOODOO.0.REG:fbzColorPath(3) write = 1C482405
-        RGB = TREX color output
-        Alpha = TREX alpha output
-
-    VOODOO.0.REG:textureMode(3) write = 102414C0
-        No perspective correction, point-sampling, clamp S/T.
-        Texture format AI44
-        tc_add_local
-        tca_add_alocal
-
-    VOODOO.0.REG:tLOD(3) write = 01B821C6
-
-    VOODOO.0.REG:texBaseAddr(3) write = 00000000
-    VOODOO.0.REG:texBaseAddr_1(3) write = 000C3100
-    VOODOO.0.REG:texBaseAddr_2(3) write = FFFF8000
-    VOODOO.0.REG:texBaseAddr_3_8(3) write = FFFFE000
-
-    VOODOO.0.REG:textureMode(2) write = 000004C0
-        No perspective correction, point-sampling, clamp S/T.
-        Texture format AI44
-
-    VOODOO.0.REG:tLOD(0) write = 01BC21C6
-
-    VOODOO.0.REG:texBaseAddr_3_8(2) write = FFFF7800
-
-    VOODOO.0.REG:fbzMode(3) write = 0002166B
-
-
-
-    PPP2nd requires the following in idectrl.c:
-    //ide->features[51*2+0] = 0;
-    //ide->features[51*2+1] = 2;
-    //ide->features[67*2+0] = 0xf0;
-    //ide->features[67*2+1] = 0x00;
-
-    MPC8240 requires: 603MMU
-
-
 
     Game status:
         ppp2nd              POST: "DIP SWITCH ERROR", "NO SECURITY ERROR"
@@ -1609,9 +1542,7 @@
 static int ds2430_reset = 0;
 static int ds2430_state;
 static UINT8 ds2430_cmd;
-//static UINT8 ds2430_rom[8] = { 0x14, 0x5c, 0xaa, 0xee, 0x00, 0x00, 0x00, 0x8e };
-//static UINT8 ds2430_rom[8] = { 0x14, 0x41, 0x31, 0x34, 0x41, 0x41, 0x41, 0x9f };
-static UINT8 ds2430_rom[8] = { 0x14, 0x41, 0x41, 0x41, 0x41, 0x31, 0x34, 0xaa};
+static UINT8 *ds2430_rom;
 static UINT8 ds2430_addr;
 
 
@@ -1756,7 +1687,7 @@
 
 		case DS2430_STATE_READ_ROM:
 		{
-			int rombit = (ds2430_rom[(ds2430_data_count/8)] >> (ds2430_data_count%8)) & 1;
+			int rombit = (ds2430_rom[0x20 + (ds2430_data_count/8)] >> (ds2430_data_count%8)) & 1;
 			ds2430_data_count++;
 			printf("DS2430_w: read rom %d, bit = %d\n", ds2430_data_count, rombit);
 
@@ -1981,12 +1912,22 @@
 
 	/* configure fast RAM regions for DRC */
 	ppcdrc_add_fastram(machine.device("maincpu"), 0x00000000, 0x00ffffff, FALSE, workram);
+
+	ds2430_rom = (UINT8*)machine.region("ds2430")->base();
 }
 
 static MACHINE_RESET(viper)
 {
 	devtag_reset(machine, "ide");
 	mpc8240_epic_reset();
+
+	UINT8 *ide_features = ide_get_features(machine.device("ide"), 0);
+
+	// Viper expects these settings or the BIOS fails
+	ide_features[51*2+0] = 0;			/* 51: PIO data transfer cycle timing mode */
+	ide_features[51*2+1] = 2;
+	ide_features[67*2+0] = 0xf0;		/* 67: minimum PIO transfer cycle time without flow control */
+	ide_features[67*2+1] = 0x00;
 }
 
 static MACHINE_CONFIG_START( viper, viper_state )
@@ -2061,6 +2002,9 @@
 ROM_START(kviper)
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 ROM_END
 
@@ -2069,6 +2013,9 @@
 ROM_START(ppp2nd)
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 
 	DISK_REGION( "drive_0" )
@@ -2079,6 +2026,9 @@
 ROM_START(boxingm) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a45jaa_nvram.u39", 0x00000, 0x2000, CRC(c24e29fc) SHA1(efb6ecaf25cbdf9d8dfcafa85e38a195fa5ff6c4))
 
@@ -2089,6 +2039,9 @@
 ROM_START(code1d) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(fada04dd) SHA1(49bd4e87d48f0404a091a79354bbc09cde739f5c))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
@@ -2099,6 +2052,9 @@
 ROM_START(code1db) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(fada04dd) SHA1(49bd4e87d48f0404a091a79354bbc09cde739f5c))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
@@ -2109,6 +2065,9 @@
 ROM_START(gticlub2) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(d0604e84) SHA1(18d1183f1331af3e655a56692eb7ab877b4bc239)) //old dump, probably has non-default settings.
 	ROM_LOAD("941jab_nvram.u39", 0x00000, 0x2000, CRC(6c4a852f) SHA1(2753dda42cdd81af22dc6780678f1ddeb3c62013))
@@ -2130,6 +2089,9 @@
 ROM_START(jpark3) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b41ebc_nvram.u39", 0x00000, 0x2000, CRC(55d1681d) SHA1(26868cf0d14f23f06b81f2df0b4186924439bb43))
 
@@ -2141,6 +2103,9 @@
 ROM_START(mocapglf) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b33uaa_nvram.u39", 0x00000, 0x1ff8, BAD_DUMP CRC(0f0ba988) SHA1(5618c03b21fc2ba14b2e159cee3aab7f53c2c34d)) //data looks plain bad (compared to the other games)
 
@@ -2151,6 +2116,9 @@
 ROM_START(mocapb) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a29aaa_nvram.u39", 0x000000, 0x2000, CRC(14b9fe68) SHA1(3c59e6df1bb46bc1835c13fd182b1bb092c08759)) //supposed to be aab version?
 
@@ -2161,6 +2129,9 @@
 ROM_START(mocapbj) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a29jaa_nvram.u39", 0x000000, 0x2000, CRC(2f7cdf27) SHA1(0b69d8728be12909e235268268a312982f81d46a))
 
@@ -2171,6 +2142,9 @@
 ROM_START(p911) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00uad_nvram.u39", 0x000000, 0x2000, CRC(cca056ca) SHA1(de1a00d84c1311d48bbe6d24f5b36e22ecf5e85a))
 
@@ -2181,6 +2155,9 @@
 ROM_START(p911uc) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00uac_nvram.u39", 0x000000, 0x2000,  NO_DUMP )
 
@@ -2191,6 +2168,9 @@
 ROM_START(p911kc) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00kac_nvram.u39", 0x000000, 0x2000,  CRC(8ddc921c) SHA1(901538da237679fc74966a301278b36d1335671f) )
 
@@ -2201,6 +2181,9 @@
 ROM_START(p911e) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00eaa_nvram.u39", 0x000000, 0x2000,  CRC(4f3497b6) SHA1(3045c54f98dff92cdf3a1fc0cd4c76ba82d632d7) )
 
@@ -2211,6 +2194,9 @@
 ROM_START(p911j) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00jaa_nvram.u39", 0x000000, 0x2000, CRC(9ecf70dc) SHA1(4769a99b0cc28563e219860b8d480f32d1e21f60))
 
@@ -2221,6 +2207,9 @@
 ROM_START(p9112) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, NO_DUMP )
 
@@ -2231,6 +2220,9 @@
 ROM_START(popn9) //Note: this is actually a Konami Pyson HW! (PlayStation 2-based) move out of here.
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, NO_DUMP )
 
@@ -2241,6 +2233,9 @@
 ROM_START(sscopex)
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a13uaa_nvram.u39", 0x000000, 0x2000, CRC(7b0e1ac8) SHA1(1ea549964539e27f87370e9986bfa44eeed037cd))
 
@@ -2253,6 +2248,9 @@
 ROM_START(sogeki) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, CRC(2f325c55) SHA1(0bc44f40f981a815c8ce64eae95ae55db510c565))
 
@@ -2263,6 +2261,9 @@
 ROM_START(thrild2) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a41ebb_nvram.u39", 0x00000, 0x2000, CRC(22f59ac0) SHA1(e14ea2ba95b72edf0a3331ab82c192760bfdbce3))
 //  a41eba_nvram == a41ebb_nvram
@@ -2274,6 +2275,9 @@
 ROM_START(thrild2a) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a41aaa_nvram.u39", 0x00000, 0x2000, CRC(d5de9b8e) SHA1(768bcd46a6ad20948f60f5e0ecd2f7b9c2901061))
 
@@ -2285,6 +2289,9 @@
 ROM_START(thrild2c) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("941eaa_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
@@ -2295,6 +2302,9 @@
 ROM_START(tsurugi) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a30eab_nvram.u39", 0x00000, 0x2000, CRC(c123342c) SHA1(55416767608fe0311a362854a16b214b04435a31))
 
@@ -2305,6 +2315,9 @@
 ROM_START(tsurugij) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a30jac_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
@@ -2316,6 +2329,9 @@
 ROM_START(wcombat) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("wcombat_nvram.u39", 0x00000, 0x2000, CRC(4f8b5858) SHA1(68066241c6f9db7f45e55b3c5da101987f4ce53c))
 
@@ -2336,6 +2352,9 @@
 ROM_START(wcombatj) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("wcombatj_nvram.u39", 0x00000, 0x2000, CRC(bd8a6640) SHA1(2d409197ef3fb07d984d27fa943f29c7a711d715))
 
@@ -2346,6 +2365,9 @@
 ROM_START(xtrial) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b4xjab_nvram.u39", 0x00000, 0x2000, CRC(33708a93) SHA1(715968e3c9c15edf628fa6ac655dc0864e336c6c))
 
@@ -2404,6 +2426,9 @@
 ROM_START(mfightc) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(9fb551a5) SHA1(a33d185e186d404c3bf62277d7e34e5ad0000b09)) //likely non-default settings
 	ROM_LOAD("c09jad_nvram.u39", 0x00000, 0x2000, CRC(33e960b7) SHA1(a9a249e68c89b18d4685f1859fe35dc21df18e14))
@@ -2416,6 +2441,9 @@
 ROM_START(mfightcc) //*
 	VIPER_BIOS
 
+	ROM_REGION(0x28, "ds2430", ROMREGION_ERASE00)		/* DS2430 */
+		ROM_LOAD("ds2430.u3", 0x00, 0x28, CRC(f1511505) SHA1(ed7cd9b2763b3e377df9663943160f9871f65105))
+
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("c09jac_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
diff -Nru src-old/mame/drivers/vmetal.c src/mame/drivers/vmetal.c
--- src-old/mame/drivers/vmetal.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/vmetal.c	2012-03-05 16:52:06.000000000 +0100
@@ -403,6 +403,20 @@
 	SET_TILE_INFO(0, tile, color, TILE_FLIPYX(0x0));
 }
 
+static void expand_gfx1(running_machine &machine)
+{
+	metro_state *state = machine.driver_data<metro_state>();
+	UINT8 *base_gfx = machine.region("gfx1")->base();
+	UINT32 length = 2 * machine.region("gfx1")->bytes();
+	state->m_expanded_gfx1 = auto_alloc_array(machine, UINT8, length);
+	for (int i = 0; i < length; i += 2)
+	{
+		UINT8 src = base_gfx[i / 2];
+		state->m_expanded_gfx1[i+0] = src & 15;
+		state->m_expanded_gfx1[i+1] = src >> 4;
+	}
+}
+
 static VIDEO_START(varia)
 {
 	vmetal_state *state = machine.driver_data<vmetal_state>();
@@ -414,6 +428,8 @@
 	state->m_texttilemap->set_transparent_pen(15);
 	state->m_mid1tilemap->set_transparent_pen(15);
 	state->m_mid2tilemap->set_transparent_pen(15);
+
+	expand_gfx1(machine);
 }
 
 static SCREEN_UPDATE_IND16(varia)
diff -Nru src-old/mame/drivers/wardner.c src/mame/drivers/wardner.c
--- src-old/mame/drivers/wardner.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/wardner.c	2012-03-08 08:39:27.000000000 +0100
@@ -203,7 +203,7 @@
 
 	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1") /* Overlapped RAM/Banked ROM - See below */
 
-	AM_RANGE(0x8000, 0x8fff) AM_WRITE(wardner_sprite_w) AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x8000, 0x8fff) AM_WRITE(wardner_sprite_w) AM_SHARE("spriteram")
 	AM_RANGE(0x9000, 0x9fff) AM_ROM
 	AM_RANGE(0xa000, 0xadff) AM_WRITE(paletteram_xBBBBBGGGGGRRRRR_le_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0xae00, 0xafff) AM_RAM AM_BASE_MEMBER(wardner_state, m_rambase_ae00)
@@ -427,12 +427,13 @@
 	/* video hardware */
 	MCFG_MC6845_ADD("crtc", HD6845, XTAL_14MHz/4, twincobr_mc6845_intf)	/* 3.5MHz measured on CLKin */
 
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK | VIDEO_BUFFERS_SPRITERAM)
+	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_RAW_PARAMS(XTAL_14MHz/2, 446, 0, 320, 286, 0, 240)
 	MCFG_SCREEN_UPDATE_STATIC(toaplan0)
-	MCFG_SCREEN_VBLANK_STATIC(toaplan0)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(wardner)
 	MCFG_PALETTE_LENGTH(1792)
diff -Nru src-old/mame/drivers/wwfwfest.c src/mame/drivers/wwfwfest.c
--- src-old/mame/drivers/wwfwfest.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/drivers/wwfwfest.c	2012-03-08 08:39:27.000000000 +0100
@@ -69,7 +69,7 @@
 static ADDRESS_MAP_START( main_map, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x0c0000, 0x0c1fff) AM_RAM_WRITE(wwfwfest_fg0_videoram_w) AM_BASE_MEMBER(wwfwfest_state, m_fg0_videoram)	/* FG0 Ram - 4 bytes per tile */
-	AM_RANGE(0x0c2000, 0x0c3fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)						/* SPR Ram */
+	AM_RANGE(0x0c2000, 0x0c3fff) AM_RAM AM_SHARE("spriteram")						/* SPR Ram */
 	AM_RANGE(0x080000, 0x080fff) AM_RAM_WRITE(wwfwfest_bg0_videoram_w) AM_BASE_MEMBER(wwfwfest_state, m_bg0_videoram)	/* BG0 Ram - 4 bytes per tile */
 	AM_RANGE(0x082000, 0x082fff) AM_RAM_WRITE(wwfwfest_bg1_videoram_w) AM_BASE_MEMBER(wwfwfest_state, m_bg1_videoram)	/* BG1 Ram - 2 bytes per tile */
 	AM_RANGE(0x100000, 0x100007) AM_WRITE(wwfwfest_scroll_write)
@@ -381,17 +381,6 @@
 	dd3_ymirq_handler
 };
 
-static SCREEN_VBLANK( wwfwfest )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space,0,0,0xffff);
-	}
-}
-
 /*******************************************************************************
  Machine Driver(s)
 *******************************************************************************/
@@ -407,12 +396,12 @@
 	MCFG_CPU_PROGRAM_MAP(sound_map)
 
 	/* video hardware */
-	MCFG_VIDEO_ATTRIBUTES(VIDEO_BUFFERS_SPRITERAM)
+	MCFG_BUFFERED_SPRITERAM16_ADD("spriteram")
 
 	MCFG_SCREEN_ADD("screen", RASTER)
 	MCFG_SCREEN_RAW_PARAMS(PIXEL_CLOCK, 384, 0, 320, 272, 8, 248)	/* HTOTAL and VTOTAL are guessed */
 	MCFG_SCREEN_UPDATE_STATIC(wwfwfest)
-	MCFG_SCREEN_VBLANK_STATIC(wwfwfest)
+	MCFG_SCREEN_VBLANK_DEVICE("spriteram", buffered_spriteram16_device, vblank_copy_rising)
 
 	MCFG_GFXDECODE(wwfwfest)
 	MCFG_PALETTE_LENGTH(8192)
diff -Nru src-old/mame/drivers/xexex.c src/mame/drivers/xexex.c
--- src-old/mame/drivers/xexex.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/xexex.c	2012-03-04 18:26:17.000000000 +0100
@@ -373,7 +373,7 @@
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank2")
 	AM_RANGE(0x0000, 0xbfff) AM_ROM
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("k054539", k054539_r, k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
 	AM_RANGE(0xec00, 0xec01) AM_DEVREADWRITE("ymsnd", ym2151_r, ym2151_w)
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch3_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -518,7 +518,7 @@
 	state->m_suspension_active = 0;
 	state->m_resume_trigger = 1000;
 	state->m_frame = -1;
-	k054539_init_flags(machine.device("k054539"), K054539_REVERSE_STEREO);
+	machine.device<k054539_device>("k054539")->init_flags(k054539_device::REVERSE_STEREO);
 }
 
 static MACHINE_CONFIG_START( xexex, xexex_state )
@@ -571,8 +571,7 @@
 	MCFG_SOUND_ROUTE(1, "filter2l", 0.50)
 	MCFG_SOUND_ROUTE(1, "filter2r", 0.50)
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 1.0)
 	MCFG_SOUND_ROUTE(0, "rspeaker", 1.0)
 	MCFG_SOUND_ROUTE(1, "lspeaker", 1.0)
diff -Nru src-old/mame/drivers/xmen.c src/mame/drivers/xmen.c
--- src-old/mame/drivers/xmen.c	2012-02-04 19:56:04.000000000 +0100
+++ src/mame/drivers/xmen.c	2012-03-04 18:26:17.000000000 +0100
@@ -136,7 +136,7 @@
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank4")
 	AM_RANGE(0xc000, 0xdfff) AM_RAM
-	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE("k054539", k054539_r, k054539_w)
+	AM_RANGE(0xe000, 0xe22f) AM_DEVREADWRITE_MODERN("k054539", k054539_device, read, write)
 	AM_RANGE(0xe800, 0xe801) AM_MIRROR(0x0400) AM_DEVREADWRITE("ymsnd", ym2151_r, ym2151_w)
 	AM_RANGE(0xf000, 0xf000) AM_WRITE(soundlatch2_w)
 	AM_RANGE(0xf002, 0xf002) AM_READ(soundlatch_r)
@@ -369,6 +369,7 @@
 
 }
 
+static k054539_interface k054539_config;
 
 static MACHINE_CONFIG_START( xmen, xmen_state )
 
@@ -407,7 +408,7 @@
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.80)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.80)
 
-	MCFG_SOUND_ADD("k054539", K054539, 48000)
+	MCFG_K054539_ADD("k054539", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.80)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.80)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/zr107.c src/mame/drivers/zr107.c
--- src-old/mame/drivers/zr107.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/zr107.c	2012-03-04 18:26:17.000000000 +0100
@@ -455,30 +455,11 @@
 
 /**********************************************************************/
 
-static READ16_HANDLER( dual539_r )
-{
-	UINT16 ret = 0;
-
-	if (ACCESSING_BITS_0_7)
-		ret |= k054539_r(space->machine().device("konami2"), offset);
-	if (ACCESSING_BITS_8_15)
-		ret |= k054539_r(space->machine().device("konami1"), offset)<<8;
-
-	return ret;
-}
-
-static WRITE16_HANDLER( dual539_w )
-{
-	if (ACCESSING_BITS_0_7)
-		k054539_w(space->machine().device("konami2"), offset, data);
-	if (ACCESSING_BITS_8_15)
-		k054539_w(space->machine().device("konami1"), offset, data>>8);
-}
-
 static ADDRESS_MAP_START( sound_memmap, AS_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x01ffff) AM_ROM
 	AM_RANGE(0x100000, 0x103fff) AM_RAM		/* Work RAM */
-	AM_RANGE(0x200000, 0x2004ff) AM_READWRITE(dual539_r, dual539_w)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami1", k054539_device, read, write, 0xff00)
+	AM_RANGE(0x200000, 0x2004ff) AM_DEVREADWRITE8_MODERN("konami2", k054539_device, read, write, 0x00ff)
 	AM_RANGE(0x400000, 0x40000f) AM_DEVWRITE("k056800", k056800_sound_w)
 	AM_RANGE(0x400010, 0x40001f) AM_DEVREAD("k056800", k056800_sound_r)
 	AM_RANGE(0x580000, 0x580001) AM_WRITENOP
@@ -774,13 +755,11 @@
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("konami1", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami1", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.75)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.75)
 
-	MCFG_SOUND_ADD("konami2", K054539, 48000)
-	MCFG_SOUND_CONFIG(k054539_config)
+	MCFG_K054539_ADD("konami2", 48000, k054539_config)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.75)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.75)
 
diff -Nru src-old/mame/includes/actfancr.h src/mame/includes/actfancr.h
--- src-old/mame/includes/actfancr.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/actfancr.h	2012-03-11 18:17:00.000000000 +0100
@@ -12,12 +12,10 @@
 
 	/* memory pointers */
 	UINT8 *        m_main_ram;
-//  UINT8 *        m_spriteram;   // currently this uses buffered_spriteram
-//  UINT8 *        m_paletteram;  // currently this uses generic palette handling
 	UINT16 m_spriteram16[0x800/2]; // a 16-bit copy of spriteram for use with the MXC06 code
 
 	/* video-related */
-	int            m_flipscreen;
+	int         		m_flipscreen;
 
 	/* misc */
 	int            m_trio_control_select;
diff -Nru src-old/mame/includes/armedf.h src/mame/includes/armedf.h
--- src-old/mame/includes/armedf.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/armedf.h	2012-03-11 18:17:00.000000000 +0100
@@ -1,9 +1,11 @@
+#include "video/bufsprite.h"
 
 class armedf_state : public driver_device
 {
 public:
 	armedf_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8  *  m_text_videoram;
@@ -11,7 +13,6 @@
 	UINT16 *  m_fg_videoram;
 	UINT16 *  m_spr_pal_clut;
 	UINT16 m_legion_cmd[4];	// legiono only!
-//  UINT16 *  m_spriteram;    // currently this uses generic buffered_spriteram
 //  UINT16 *  m_paletteram;   // currently this uses generic palette handling
 
 	/* video-related */
@@ -28,6 +29,8 @@
 	int      m_sprite_offy;
 	int      m_old_mcu_mode;
 	int      m_waiting_msb;
+
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 class bigfghtr_state : public armedf_state
@@ -47,7 +50,6 @@
 /*----------- defined in video/armedf.c -----------*/
 
 SCREEN_UPDATE_IND16( armedf );
-SCREEN_VBLANK( armedf );
 VIDEO_START( armedf );
 VIDEO_START( terraf );
 
diff -Nru src-old/mame/includes/astrocde.h src/mame/includes/astrocde.h
--- src-old/mame/includes/astrocde.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/astrocde.h	2012-03-01 09:36:39.000000000 +0100
@@ -11,6 +11,8 @@
 #define AC_STARS			(0x04)
 #define AC_MONITOR_BW		(0x08)
 
+#define USE_FAKE_VOTRAX		(1)
+
 
 class astrocde_state : public driver_device
 {
diff -Nru src-old/mame/includes/bbusters.h src/mame/includes/bbusters.h
--- src-old/mame/includes/bbusters.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/bbusters.h	2012-03-11 18:17:00.000000000 +0100
@@ -1,9 +1,13 @@
+#include "video/bufsprite.h"
+
 class bbusters_state : public driver_device
 {
 public:
 	bbusters_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		  m_eprom_data(*this, "eeprom") { }
+		  m_eprom_data(*this, "eeprom"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	UINT16 *m_videoram;
 	UINT16 *m_ram;
@@ -21,6 +25,9 @@
 	UINT16 *m_pf2_data;
 	UINT16 *m_pf1_scroll_data;
 	UINT16 *m_pf2_scroll_data;
+
+	required_device<buffered_spriteram16_device> m_spriteram;
+	optional_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/bionicc.h src/mame/includes/bionicc.h
--- src-old/mame/includes/bionicc.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/bionicc.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,18 +4,20 @@
 
 ***************************************************************************/
 
+#include "video/bufsprite.h"
+
 class bionicc_state : public driver_device
 {
 public:
 	bionicc_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT16 *  m_bgvideoram;
 	UINT16 *  m_fgvideoram;
 	UINT16 *  m_txvideoram;
 	UINT16 *  m_paletteram;
-//  UINT16 *  m_spriteram;  // needed for EOF, but currently handled through buffer_spriteram16
 
 	/* video-related */
 	tilemap_t   *m_tx_tilemap;
@@ -25,6 +27,8 @@
 
 	UINT16    m_inp[3];
 	UINT16    m_soundcommand;
+
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
@@ -39,4 +43,3 @@
 
 VIDEO_START( bionicc );
 SCREEN_UPDATE_IND16( bionicc );
-SCREEN_VBLANK( bionicc );
diff -Nru src-old/mame/includes/blktiger.h src/mame/includes/blktiger.h
--- src-old/mame/includes/blktiger.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/blktiger.h	2012-03-08 08:39:27.000000000 +0100
@@ -4,15 +4,17 @@
 
 ***************************************************************************/
 
+#include "video/bufsprite.h"
+
 class blktiger_state : public driver_device
 {
 public:
 	blktiger_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 * m_txvideoram;
-//  UINT8 * m_spriteram;  // currently this uses generic buffer_spriteram_w
 //  UINT8 * m_paletteram; // currently this uses generic palette handling
 //  UINT8 * m_paletteram2;    // currently this uses generic palette handling
 
@@ -36,6 +38,7 @@
 	/* devices */
 	device_t *m_mcu;
 	device_t *m_audiocpu;
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
@@ -54,4 +57,3 @@
 
 VIDEO_START( blktiger );
 SCREEN_UPDATE_IND16( blktiger );
-SCREEN_VBLANK( blktiger );
diff -Nru src-old/mame/includes/boogwing.h src/mame/includes/boogwing.h
--- src-old/mame/includes/boogwing.h	2012-01-29 15:04:52.000000000 +0100
+++ src/mame/includes/boogwing.h	2012-03-08 08:39:27.000000000 +0100
@@ -7,6 +7,7 @@
 #include "sound/okim6295.h"
 #include "video/deco16ic.h"
 #include "video/decocomn.h"
+#include "video/bufsprite.h"
 
 class boogwing_state : public driver_device
 {
@@ -19,7 +20,9 @@
 		  m_deco_tilegen1(*this, "tilegen1"),
 		  m_deco_tilegen2(*this, "tilegen2"),
 		  m_oki1(*this, "oki1"),
-		  m_oki2(*this, "oki2") { }
+		  m_oki2(*this, "oki2"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *  m_pf1_rowscroll;
@@ -35,6 +38,8 @@
 	required_device<deco16ic_device> m_deco_tilegen2;
 	required_device<okim6295_device> m_oki1;
 	required_device<okim6295_device> m_oki2;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	required_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/cninja.h src/mame/includes/cninja.h
--- src-old/mame/includes/cninja.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/cninja.h	2012-03-08 08:39:27.000000000 +0100
@@ -7,6 +7,7 @@
 #include "sound/okim6295.h"
 #include "video/deco16ic.h"
 #include "video/decocomn.h"
+#include "video/bufsprite.h"
 
 class cninja_state : public driver_device
 {
@@ -19,7 +20,9 @@
 		  m_deco_tilegen1(*this, "tilegen1"),
 		  m_deco_tilegen2(*this, "tilegen2"),
 		  m_raster_irq_timer(*this, "raster_timer"),
-		  m_oki2(*this, "oki2") { }
+		  m_oki2(*this, "oki2"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *   m_ram;
@@ -40,6 +43,8 @@
 	required_device<deco16ic_device> m_deco_tilegen2;
 	optional_device<timer_device> m_raster_irq_timer;
 	optional_device<okim6295_device> m_oki2;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	optional_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 /*----------- defined in video/cninja.c -----------*/
diff -Nru src-old/mame/includes/commando.h src/mame/includes/commando.h
--- src-old/mame/includes/commando.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/commando.h	2012-03-08 10:54:00.000000000 +0100
@@ -4,18 +4,20 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class commando_state : public driver_device
 {
 public:
 	commando_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 *  m_videoram;
 	UINT8 *  m_colorram;
 	UINT8 *  m_videoram2;
 	UINT8 *  m_colorram2;
-//  UINT8 *  m_spriteram; // currently this uses generic buffered_spriteram
 
 	/* video-related */
 	tilemap_t  *m_bg_tilemap;
@@ -25,6 +27,7 @@
 
 	/* devices */
 	device_t *m_audiocpu;
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
@@ -41,4 +44,3 @@
 
 VIDEO_START( commando );
 SCREEN_UPDATE_IND16( commando );
-SCREEN_VBLANK( commando );
diff -Nru src-old/mame/includes/contra.h src/mame/includes/contra.h
--- src-old/mame/includes/contra.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/contra.h	2012-03-08 10:54:00.000000000 +0100
@@ -21,7 +21,6 @@
 	UINT8 *        m_fg_cram;
 	UINT8 *        m_tx_vram;
 	UINT8 *        m_tx_cram;
-	// this driver also uses a large generic spriteram region...
 
 	/* video-related */
 	tilemap_t *m_bg_tilemap;
diff -Nru src-old/mame/includes/crshrace.h src/mame/includes/crshrace.h
--- src-old/mame/includes/crshrace.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/crshrace.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,15 +1,19 @@
+#include "cpu/z80/z80.h"
+#include "video/bufsprite.h"
 
 class crshrace_state : public driver_device
 {
 public:
 	crshrace_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_audiocpu(*this, "audiocpu"),
+		  m_k053936(*this, "k053936"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *  m_videoram1;
 	UINT16 *  m_videoram2;
-//  UINT16 *  m_spriteram1;   // currently this uses generic buffered spriteram
-//  UINT16 *  m_spriteram2;   // currently this uses generic buffered spriteram
 //      UINT16 *  m_paletteram;   // currently this uses generic palette handling
 
 	/* video-related */
@@ -23,8 +27,10 @@
 	int m_pending_command;
 
 	/* devices */
-	device_t *m_audiocpu;
-	device_t *m_k053936;
+	required_device<z80_device> m_audiocpu;
+	required_device<k053936_device> m_k053936;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	required_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 /*----------- defined in video/crshrace.c -----------*/
diff -Nru src-old/mame/includes/darkseal.h src/mame/includes/darkseal.h
--- src-old/mame/includes/darkseal.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/darkseal.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,4 +1,5 @@
 #include "video/deco16ic.h"
+#include "video/bufsprite.h"
 
 class darkseal_state : public driver_device
 {
@@ -6,7 +7,8 @@
 	darkseal_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 	      m_deco_tilegen1(*this, "tilegen1"),
-		  m_deco_tilegen2(*this, "tilegen2") { }
+		  m_deco_tilegen2(*this, "tilegen2"),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_ram;
 	UINT16 *m_pf1_rowscroll;
@@ -16,6 +18,7 @@
 
 	required_device<deco16ic_device> m_deco_tilegen1;
 	required_device<deco16ic_device> m_deco_tilegen2;
+	required_device<buffered_spriteram16_device> m_spriteram;
 
 	int m_flipscreen;
 };
diff -Nru src-old/mame/includes/dassault.h src/mame/includes/dassault.h
--- src-old/mame/includes/dassault.h	2012-01-29 15:04:52.000000000 +0100
+++ src/mame/includes/dassault.h	2012-03-08 08:39:27.000000000 +0100
@@ -7,6 +7,7 @@
 #include "sound/okim6295.h"
 #include "video/deco16ic.h"
 #include "video/decocomn.h"
+#include "video/bufsprite.h"
 
 class dassault_state : public driver_device
 {
@@ -19,7 +20,9 @@
 		  m_decocomn(*this, "deco_common"),
 		  m_deco_tilegen1(*this, "tilegen1"),
 		  m_deco_tilegen2(*this, "tilegen2"),
-		  m_oki2(*this, "oki2") { }
+		  m_oki2(*this, "oki2"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *  m_pf2_rowscroll;
@@ -36,6 +39,8 @@
 	required_device<deco16ic_device> m_deco_tilegen1;
 	required_device<deco16ic_device> m_deco_tilegen2;
 	required_device<okim6295_device> m_oki2;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	required_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/dec8.h src/mame/includes/dec8.h
--- src-old/mame/includes/dec8.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/dec8.h	2012-03-11 13:03:30.000000000 +0100
@@ -1,9 +1,11 @@
+#include "video/bufsprite.h"
 
 class dec8_state : public driver_device
 {
 public:
 	dec8_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 *  m_videoram;
@@ -12,7 +14,6 @@
 	UINT8 *  m_row;
 //  UINT8 *  m_paletteram;    // currently this uses generic palette handling
 //  UINT8 *  m_paletteram_2;  // currently this uses generic palette handling
-//  UINT8 *  m_spriteram; // currently this uses buffered_spriteram in some games
 	size_t   m_videoram_size;
 	UINT16   m_buffered_spriteram16[0x800/2]; // for the mxc06 sprite chip emulation (oscar, cobra)
 
@@ -32,8 +33,14 @@
 	int      m_nmi_enable;
 	int      m_i8751_return;
 	int      m_i8751_value;
+	int      m_coinage_id;
 	int      m_coin1;
 	int      m_coin2;
+	int      m_need1;
+	int      m_need2;
+	int      m_cred1;
+	int      m_cred2;
+	int      m_credits;
 	int      m_latch;
 	int      m_snd;
 	int      m_msm5205next;
@@ -44,6 +51,7 @@
 	device_t *m_subcpu;
 	device_t *m_audiocpu;
 	device_t *m_mcu;
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 /*----------- defined in video/dec8.c -----------*/
diff -Nru src-old/mame/includes/deco32.h src/mame/includes/deco32.h
--- src-old/mame/includes/deco32.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/deco32.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,4 +1,5 @@
 #include "audio/decobsmt.h"
+#include "video/bufsprite.h"
 
 class deco32_state : public driver_device
 {
@@ -6,11 +7,13 @@
 	deco32_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		m_maincpu(*this, "maincpu"),
-		m_decobsmt(*this, "decobsmt")
+		m_decobsmt(*this, "decobsmt"),
+		m_spriteram(*this, "spriteram")
     { }
 
 	required_device<cpu_device> m_maincpu;
 	optional_device<decobsmt_device> m_decobsmt;
+	optional_device<buffered_spriteram32_device> m_spriteram;
 
 	UINT32 *m_ram;
 	int m_raster_enable;
diff -Nru src-old/mame/includes/dooyong.h src/mame/includes/dooyong.h
--- src-old/mame/includes/dooyong.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/dooyong.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,12 @@
+#include "video/bufsprite.h"
+
 class dooyong_state : public driver_device
 {
 public:
 	dooyong_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram16(*this, "spriteram16") { }
 
 	UINT8 *m_txvideoram;
 	UINT8 *m_paletteram_flytiger;
@@ -36,6 +40,8 @@
 
 	int m_interrupt_line_1;
 	int m_interrupt_line_2;
+	optional_device<buffered_spriteram8_device> m_spriteram;
+	optional_device<buffered_spriteram16_device> m_spriteram16;
 };
 
 
@@ -76,6 +82,3 @@
 VIDEO_START( primella );
 VIDEO_START( rshark );
 VIDEO_START( popbingo );
-
-SCREEN_VBLANK( dooyong );
-SCREEN_VBLANK( rshark );
diff -Nru src-old/mame/includes/dynduke.h src/mame/includes/dynduke.h
--- src-old/mame/includes/dynduke.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/dynduke.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class dynduke_state : public driver_device
 {
 public:
 	dynduke_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_videoram;
 	UINT16 *m_back_data;
@@ -19,6 +22,7 @@
 	int m_txt_enable;
 	int m_old_back;
 	int m_old_fore;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
@@ -32,4 +36,3 @@
 WRITE16_HANDLER( dynduke_paletteram_w );
 VIDEO_START( dynduke );
 SCREEN_UPDATE_IND16( dynduke );
-SCREEN_VBLANK( dynduke );
diff -Nru src-old/mame/includes/exedexes.h src/mame/includes/exedexes.h
--- src-old/mame/includes/exedexes.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/exedexes.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,12 +4,14 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
 
 class exedexes_state : public driver_device
 {
 public:
 	exedexes_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 *        m_videoram;
@@ -17,7 +19,6 @@
 	UINT8 *        m_bg_scroll;
 	UINT8 *        m_nbg_yscroll;
 	UINT8 *        m_nbg_xscroll;
-//  UINT8 *        m_spriteram;   // currently this uses generic buffered_spriteram
 
 	/* video-related */
 	tilemap_t        *m_bg_tilemap;
@@ -27,6 +28,8 @@
 	int            m_objon;
 	int            m_sc1on;
 	int            m_sc2on;
+
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
@@ -41,4 +44,3 @@
 extern PALETTE_INIT( exedexes );
 extern VIDEO_START( exedexes );
 extern SCREEN_UPDATE_IND16( exedexes );
-extern SCREEN_VBLANK( exedexes );
diff -Nru src-old/mame/includes/gaelco2.h src/mame/includes/gaelco2.h
--- src-old/mame/includes/gaelco2.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/gaelco2.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,9 +1,13 @@
+#include "cpu/m68000/m68000.h"
+#include "video/bufsprite.h"
+
 class gaelco2_state : public driver_device
 {
 public:
 	gaelco2_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this,"maincpu"),
+		m_spriteram(*this,"spriteram")
 		{ }
 
 	UINT16 *m_snowboar_protection;
@@ -14,7 +18,8 @@
 	tilemap_t *m_pant[2];
 	int m_dual_monitor;
 
-	required_device<cpu_device> m_maincpu;
+	required_device<m68000_device> m_maincpu;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
@@ -44,7 +49,6 @@
 WRITE16_HANDLER( gaelco2_vram_w );
 WRITE16_HANDLER( gaelco2_palette_w );
 SCREEN_UPDATE_IND16( gaelco2 );
-SCREEN_VBLANK( gaelco2 );
 VIDEO_START( gaelco2 );
 SCREEN_UPDATE_IND16( gaelco2_left );
 SCREEN_UPDATE_IND16( gaelco2_right );
diff -Nru src-old/mame/includes/galaga.h src/mame/includes/galaga.h
--- src-old/mame/includes/galaga.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/galaga.h	2012-03-11 18:17:00.000000000 +0100
@@ -65,6 +65,10 @@
 
 	UINT8 *m_bosco_radarx;
 	UINT8 *m_bosco_radary;
+
+	UINT8 *m_spriteram;
+	UINT8 *m_spriteram2;
+	UINT32 m_spriteram_size;
 };
 
 class digdug_state : public galaga_state
diff -Nru src-old/mame/includes/galaxian.h src/mame/includes/galaxian.h
--- src-old/mame/includes/galaxian.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/galaxian.h	2012-03-08 10:54:00.000000000 +0100
@@ -36,7 +36,8 @@
 {
 public:
 	galaxian_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT8 *m_videoram;
 	int m_counter_74ls161[2];
@@ -75,6 +76,7 @@
 	UINT8 m_stars_blink_state;
 	rgb_t m_bullet_color[8];
 	UINT8 m_gfxbank[5];
+	required_shared_ptr<UINT8> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/gng.h src/mame/includes/gng.h
--- src-old/mame/includes/gng.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/gng.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,24 +4,28 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class gng_state : public driver_device
 {
 public:
 	gng_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 *    m_bgvideoram;
 	UINT8 *    m_fgvideoram;
 //  UINT8 *    m_paletteram;  // currently this uses generic palette handling
 //  UINT8 *    m_paletteram2; // currently this uses generic palette handling
-//  UINT8 *    m_spriteram;   // currently this uses generic buffered spriteram
 
 	/* video-related */
 	tilemap_t    *m_bg_tilemap;
 	tilemap_t    *m_fg_tilemap;
 	UINT8      m_scrollx[2];
 	UINT8      m_scrolly[2];
+
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
@@ -35,4 +39,3 @@
 
 VIDEO_START( gng );
 SCREEN_UPDATE_IND16( gng );
-SCREEN_VBLANK( gng );
diff -Nru src-old/mame/includes/gottlieb.h src/mame/includes/gottlieb.h
--- src-old/mame/includes/gottlieb.h	2012-01-27 07:54:34.000000000 +0100
+++ src/mame/includes/gottlieb.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,41 +4,220 @@
 
 ***************************************************************************/
 
+#include "cpu/i86/i86.h"
+#include "cpu/m6502/m6502.h"
 #include "machine/6532riot.h"
+#include "sound/dac.h"
+#include "sound/ay8910.h"
+#include "sound/sp0250.h"
+#include "sound/samples.h"
+#include "sound/votrax.h"
 #include "machine/ldpr8210.h"
 
 
+// set to 0 to enable Votrax device and disable samples
+#define USE_FAKE_VOTRAX			(1)
+
+
 #define GOTTLIEB_VIDEO_HCOUNT	318
 #define GOTTLIEB_VIDEO_HBLANK	256
 #define GOTTLIEB_VIDEO_VCOUNT	256
 #define GOTTLIEB_VIDEO_VBLANK	240
 
 
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+extern const device_type GOTTLIEB_SOUND_REV1;
+extern const device_type GOTTLIEB_SOUND_REV1_WITH_VOTRAX;
+extern const device_type GOTTLIEB_SOUND_REV2;
+
+
+
+//**************************************************************************
+//  DEVICE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MCFG_GOTTLIEB_SOUND_R1_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, GOTTLIEB_SOUND_REV1, 0) \
+
+#define MCFG_GOTTLIEB_SOUND_R1_ADD_VOTRAX(_tag) \
+	MCFG_DEVICE_ADD(_tag, GOTTLIEB_SOUND_REV1_WITH_VOTRAX, 0) \
+
+
+#define MCFG_GOTTLIEB_SOUND_R2_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, GOTTLIEB_SOUND_REV2, 0) \
+
+#define MCFG_GOTTLIEB_SOUND_R2_ADD_COBRAM3(_tag) \
+	MCFG_DEVICE_ADD(_tag, GOTTLIEB_SOUND_REV2, 0) \
+	gottlieb_sound_r2_device::static_enable_cobram3_mods(*device); \
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> gottlieb_sound_r1_device
+
+// rev 1 sound board, with unpopulated VOTRAX
+class gottlieb_sound_r1_device :	public device_t,
+									public device_mixer_interface
+{
+public:
+	// construction/destruction
+	gottlieb_sound_r1_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	gottlieb_sound_r1_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock, bool populate_votrax);
+
+	// read/write
+	DECLARE_WRITE8_MEMBER( write );
+
+	// internal communications
+	DECLARE_WRITE_LINE_MEMBER( snd_interrupt );
+	DECLARE_WRITE8_MEMBER( r6532_portb_w );
+	DECLARE_WRITE8_MEMBER( votrax_data_w );
+	DECLARE_WRITE8_MEMBER( speech_clock_dac_w );
+	DECLARE_WRITE_LINE_MEMBER( votrax_request );
+
+protected:
+	// device-level overrides
+	virtual machine_config_constructor device_mconfig_additions() const;
+	virtual ioport_constructor device_input_ports() const;
+	virtual void device_start();
+
+private:
+	// devices
+	required_device<m6502_device>		m_audiocpu;
+	required_device<riot6532_device>	m_riot;
+	required_device<dac_device> 		m_dac;
+	optional_device<votrax_sc01_device>	m_votrax;
+
+	// internal state
+	bool			m_populate_votrax;
+	UINT8			m_last_speech_clock;
+
+#if USE_FAKE_VOTRAX
+protected:
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+private:
+	void fake_votrax_data_w(UINT8 data);
+	void trigger_sample(UINT8 data);
+	optional_device<samples_device> m_samples;
+	UINT8 m_score_sample;
+	UINT8 m_random_offset;
+	UINT8 m_votrax_queue[100];
+	UINT8 m_votrax_queuepos;
+#endif
+};
+
+// fully populated rev 1 sound board
+class gottlieb_sound_r1_with_votrax_device : public gottlieb_sound_r1_device
+{
+public:
+	// construction/destruction
+	gottlieb_sound_r1_with_votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+protected:
+	// device-level overrides
+	virtual machine_config_constructor device_mconfig_additions() const;
+	virtual ioport_constructor device_input_ports() const;
+};
+
+
+// ======================> gottlieb_sound_r2_device
+
+// fully populated rev 2 sound board
+class gottlieb_sound_r2_device :	public device_t,
+									public device_mixer_interface
+{
+public:
+	// construction/destruction
+	gottlieb_sound_r2_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	// static configuration helpers
+	static void static_enable_cobram3_mods(device_t &device);
+
+	// read/write
+	DECLARE_WRITE8_MEMBER( write );
+
+	// internal communications
+	DECLARE_READ8_MEMBER( speech_data_r );
+	DECLARE_READ8_MEMBER( audio_data_r );
+	DECLARE_WRITE8_MEMBER( signal_audio_nmi_w );
+	DECLARE_WRITE8_MEMBER( nmi_rate_w );
+	CUSTOM_INPUT_MEMBER( speech_drq_custom_r );
+	DECLARE_WRITE8_MEMBER( dac_w );
+	DECLARE_WRITE8_MEMBER( speech_control_w );
+	DECLARE_WRITE8_MEMBER( sp0250_latch_w );
+	DECLARE_WRITE8_MEMBER( psg_latch_w );
+
+protected:
+	// device-level overrides
+	virtual machine_config_constructor device_mconfig_additions() const;
+	virtual ioport_constructor device_input_ports() const;
+	virtual void device_start();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+private:
+	// internal helpers
+	void nmi_timer_adjust();
+	void nmi_state_update();
+
+	// timer IDs
+	enum
+	{
+		TID_NMI_GENERATE,
+		TID_NMI_CLEAR,
+		TID_SOUND_LATCH_WRITE
+	};
+
+	// devices
+	required_device<m6502_device>	m_audiocpu;
+	required_device<m6502_device>	m_speechcpu;
+	required_device<dac_device> 	m_dac;
+	required_device<ay8913_device>	m_ay1;
+	required_device<ay8913_device>	m_ay2;
+	optional_device<sp0250_device>	m_sp0250;
+
+	// internal state
+	bool		m_cobram3_mod;
+	emu_timer *	m_nmi_timer;
+	UINT8		m_nmi_rate;
+	UINT8		m_nmi_state;
+	UINT8		m_audiocpu_latch;
+	UINT8		m_speechcpu_latch;
+	UINT8		m_speech_control;
+	UINT8		m_last_command;
+	UINT8		m_dac_data[2];
+	UINT8		m_psg_latch;
+	UINT8		m_psg_data_latch;
+	UINT8		m_sp0250_latch;
+};
+
+
+// ======================> gottlieb_state
+
+// shared driver state
 class gottlieb_state : public driver_device
 {
 public:
 	gottlieb_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		  m_laserdisc(*this, "laserdisc") { }
+		  m_maincpu(*this, "maincpu"),
+		  m_laserdisc(*this, "laserdisc"),
+		  m_r1_sound(*this, "r1sound"),
+		  m_r2_sound(*this, "r2sound") { }
+
+	// devices
+	required_device<i8088_device> m_maincpu;
+	optional_device<pioneer_pr8210_device> m_laserdisc;
+	optional_device<gottlieb_sound_r1_device> m_r1_sound;
+	optional_device<gottlieb_sound_r2_device> m_r2_sound;
 
 	UINT8 *m_videoram;
-	UINT8 m_votrax_queue[100];
-	UINT8 m_votrax_queuepos;
-	emu_timer *m_nmi_timer;
-	UINT8 m_nmi_rate;
-	UINT8 m_nmi_state;
-	UINT8 m_speech_control;
-	UINT8 m_last_command;
-	UINT8 *m_dac_data;
-	UINT8 *m_psg_latch;
-	UINT8 m_psg_data_latch;
-	UINT8 *m_sp0250_latch;
-	int m_score_sample;
-	int m_random_offset;
-	int m_last;
 	UINT8 m_joystick_select;
 	UINT8 m_track[2];
-	optional_device<pioneer_pr8210_device> m_laserdisc;
 	emu_timer *m_laserdisc_bit_timer;
 	emu_timer *m_laserdisc_philips_timer;
 	UINT8 m_laserdisc_select;
@@ -64,18 +243,6 @@
 };
 
 
-/*----------- defined in audio/gottlieb.c -----------*/
-
-WRITE8_HANDLER( gottlieb_sh_w );
-
-MACHINE_CONFIG_EXTERN( gottlieb_soundrev1 );
-MACHINE_CONFIG_EXTERN( gottlieb_soundrev2 );
-MACHINE_CONFIG_EXTERN( gottlieb_cobram3_soundrev2 );
-
-INPUT_PORTS_EXTERN( gottlieb1_sound );
-INPUT_PORTS_EXTERN( gottlieb2_sound );
-
-
 /*----------- defined in video/gottlieb.c -----------*/
 
 extern WRITE8_HANDLER( gottlieb_videoram_w );
@@ -87,3 +254,8 @@
 VIDEO_START( gottlieb );
 VIDEO_START( screwloo );
 SCREEN_UPDATE_RGB32( gottlieb );
+
+#if USE_FAKE_VOTRAX
+MACHINE_CONFIG_EXTERN( reactor_samples );
+MACHINE_CONFIG_EXTERN( qbert_samples );
+#endif
diff -Nru src-old/mame/includes/hcastle.h src/mame/includes/hcastle.h
--- src-old/mame/includes/hcastle.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/hcastle.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,18 +4,20 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class hcastle_state : public driver_device
 {
 public:
 	hcastle_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT8 *    m_pf1_videoram;
 	UINT8 *    m_pf2_videoram;
 	UINT8 *    m_paletteram;
-//  UINT8 *    m_spriteram;
-//  UINT8 *    m_spriteram2;
 
 	/* video-related */
 	tilemap_t    *m_fg_tilemap;
@@ -30,6 +32,9 @@
 	device_t *m_audiocpu;
 	device_t *m_k007121_1;
 	device_t *m_k007121_2;
+
+	required_device<buffered_spriteram8_device> m_spriteram;
+	required_device<buffered_spriteram8_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/kaneko16.h src/mame/includes/kaneko16.h
--- src-old/mame/includes/kaneko16.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/kaneko16.h	2012-03-08 10:54:00.000000000 +0100
@@ -73,7 +73,8 @@
 public:
 	kaneko16_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this, "maincpu"),
+		m_spriteram(*this, "spriteram")
 		{ }
 
 	UINT16 *m_mcu_ram;
@@ -108,6 +109,7 @@
 	bitmap_ind16 m_sprites_bitmap;
 
 	required_device<cpu_device> m_maincpu;
+	optional_shared_ptr<UINT16> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/karnov.h src/mame/includes/karnov.h
--- src-old/mame/includes/karnov.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/karnov.h	2012-03-08 08:39:27.000000000 +0100
@@ -4,17 +4,19 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class karnov_state : public driver_device
 {
 public:
 	karnov_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT16 *    m_videoram;
 	UINT16 *    m_ram;
 	UINT16 *    m_pf_data;
-//  UINT16 *    m_spriteram;  // currently this uses generic buffered spriteram
 
 	/* video-related */
 	bitmap_ind16    *m_bitmap_f;
@@ -35,6 +37,7 @@
 	/* devices */
 	device_t *m_maincpu;
 	device_t *m_audiocpu;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 enum {
diff -Nru src-old/mame/includes/lastduel.h src/mame/includes/lastduel.h
--- src-old/mame/includes/lastduel.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/lastduel.h	2012-03-08 10:54:00.000000000 +0100
@@ -4,20 +4,22 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class lastduel_state : public driver_device
 {
 public:
 	lastduel_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		m_maincpu(*this, "maincpu"),
-		m_audiocpu(*this, "audiocpu")
+		m_audiocpu(*this, "audiocpu"),
+		m_spriteram(*this, "spriteram")
 		{ }
 
 	/* memory pointers */
 	UINT16 *    m_vram;
 	UINT16 *    m_scroll1;
 	UINT16 *    m_scroll2;
-//  UINT16 *    m_spriteram;  // this currently uses generic buffered spriteram
 	UINT16 *    m_paletteram;
 
 	/* video-related */
@@ -32,6 +34,7 @@
 	/* devices */
 	required_device<cpu_device> m_maincpu;
 	required_device<cpu_device> m_audiocpu;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 /*----------- defined in video/lastduel.c -----------*/
@@ -49,4 +52,3 @@
 VIDEO_START( madgear );
 SCREEN_UPDATE_IND16( lastduel );
 SCREEN_UPDATE_IND16( madgear );
-SCREEN_VBLANK( lastduel );
diff -Nru src-old/mame/includes/legionna.h src/mame/includes/legionna.h
--- src-old/mame/includes/legionna.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/legionna.h	2012-03-08 08:39:27.000000000 +0100
@@ -2,7 +2,8 @@
 {
 public:
 	legionna_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_back_data;
 	UINT16 *m_fore_data;
@@ -21,6 +22,7 @@
 	UINT16 m_back_gfx_bank;
 	UINT16 m_fore_gfx_bank;
 	UINT16 m_mid_gfx_bank;
+	required_shared_ptr<UINT16> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/lemmings.h src/mame/includes/lemmings.h
--- src-old/mame/includes/lemmings.h	2012-01-25 22:40:14.000000000 +0100
+++ src/mame/includes/lemmings.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,9 +1,13 @@
+#include "video/bufsprite.h"
 
 class lemmings_state : public driver_device
 {
 public:
 	lemmings_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_bitmap0(2048, 256),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *  m_pixel_0_data;
@@ -11,18 +15,18 @@
 	UINT16 *  m_vram_data;
 	UINT16 *  m_control_data;
 	UINT16 *  m_paletteram;
-//  UINT16 *  m_spriteram;    // this currently uses generic buffered spriteram
-//  UINT16 *  m_spriteram2;   // this currently uses generic buffered spriteram
 
 	/* video-related */
-	bitmap_ind16 *m_bitmap0;
+	bitmap_ind16 m_bitmap0;
 	tilemap_t *m_vram_tilemap;
-	UINT16 *m_sprite_triple_buffer_0;
-	UINT16 *m_sprite_triple_buffer_1;
-	UINT8 *m_vram_buffer;
+	UINT16 m_sprite_triple_buffer_0[0x800];
+	UINT16 m_sprite_triple_buffer_1[0x800];
+	UINT8 m_vram_buffer[2048 * 64];	// 64 bytes per VRAM character
 
 	/* devices */
 	device_t *m_audiocpu;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	required_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/lwings.h src/mame/includes/lwings.h
--- src-old/mame/includes/lwings.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/lwings.h	2012-03-11 18:17:00.000000000 +0100
@@ -1,15 +1,16 @@
+#include "video/bufsprite.h"
 
 class lwings_state : public driver_device
 {
 public:
 	lwings_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT8 *  m_fgvideoram;
 	UINT8 *  m_bg1videoram;
 	UINT8 *  m_soundlatch2;
-//      UINT8 *  m_spriteram; // currently this uses generic buffered spriteram
 //      UINT8 *  m_paletteram;    // currently this uses generic palette handling
 //      UINT8 *  m_paletteram2;   // currently this uses generic palette handling
 
@@ -28,6 +29,8 @@
 	UINT8    m_soundstate;
 	UINT8    m_adpcm;
 	UINT8    m_nmi_mask;
+
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
@@ -45,4 +48,3 @@
 VIDEO_START( avengers );
 SCREEN_UPDATE_IND16( lwings );
 SCREEN_UPDATE_IND16( trojan );
-SCREEN_VBLANK( lwings );
diff -Nru src-old/mame/includes/m92.h src/mame/includes/m92.h
--- src-old/mame/includes/m92.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/m92.h	2012-03-11 18:17:00.000000000 +0100
@@ -4,8 +4,9 @@
 
 *************************************************************************/
 
-typedef struct _pf_layer_info pf_layer_info;
-struct _pf_layer_info
+#include "video/bufsprite.h"
+
+struct pf_layer_info
 {
 	tilemap_t *		tmap;
 	tilemap_t *		wide_tmap;
@@ -17,7 +18,8 @@
 {
 public:
 	m92_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 m_sound_status;
 	UINT8 m_irq_vectorbase;
@@ -31,6 +33,8 @@
 	UINT16 m_pf_master_control[4];
 	INT32 m_sprite_list;
 	UINT8 m_palette_bank;
+
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/mcr.h src/mame/includes/mcr.h
--- src-old/mame/includes/mcr.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/mcr.h	2012-03-08 10:54:00.000000000 +0100
@@ -4,6 +4,7 @@
 
 **************************************************************************/
 
+#include "cpu/z80/z80.h"
 #include "cpu/z80/z80daisy.h"
 #include "machine/z80ctc.h"
 #include "machine/z80pio.h"
@@ -18,12 +19,13 @@
 public:
 	mcr_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
-		{ }
+		  m_maincpu(*this, "maincpu"),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT8 *m_videoram;
 
-	required_device<cpu_device> m_maincpu;
+	required_device<z80_device> m_maincpu;
+	required_shared_ptr<UINT8> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/pacman.h src/mame/includes/pacman.h
--- src-old/mame/includes/pacman.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/pacman.h	2012-03-08 10:54:00.000000000 +0100
@@ -8,7 +8,10 @@
 {
 public:
 	pacman_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2"),
+		  m_s2650_spriteram(*this, "s2650_spriteram") { }
 
 	UINT8 m_cannonb_bit_to_read;
 	int m_mystery;
@@ -18,7 +21,6 @@
 	UINT8 m_rocktrv2_question_bank;
 	UINT8 *m_videoram;
 	UINT8 *m_colorram;
-	UINT8 *m_s2650games_spriteram;
 	UINT8 *m_s2650games_tileram;
 	tilemap_t *m_bg_tilemap;
 	UINT8 m_charbank;
@@ -30,6 +32,9 @@
 	int m_xoffsethack;
 	UINT8 m_inv_spr;
 	UINT8 m_irq_mask;
+	optional_shared_ptr<UINT8> m_spriteram;
+	optional_shared_ptr<UINT8> m_spriteram2;
+	optional_shared_ptr<UINT8> m_s2650_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/psikyo.h src/mame/includes/psikyo.h
--- src-old/mame/includes/psikyo.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/psikyo.h	2012-03-08 10:54:00.000000000 +0100
@@ -18,8 +18,6 @@
 	UINT32 *       m_spritebuf2;
 	UINT32 *       m_bootleg_spritebuffer;
 //      UINT32 *       m_paletteram;  // currently this uses generic palette handling
-//  UINT32 *       m_spriteram;   // currently this uses generic buffered spriteram
-//  size_t         m_spriteram_size;
 
 	/* video-related */
 	tilemap_t        *m_tilemap_0_size0;
diff -Nru src-old/mame/includes/psikyosh.h src/mame/includes/psikyosh.h
--- src-old/mame/includes/psikyosh.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/psikyosh.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,3 +1,4 @@
+#include "video/bufsprite.h"
 
 #define MASTER_CLOCK 57272700	// main oscillator frequency
 
@@ -20,7 +21,8 @@
 {
 public:
 	psikyosh_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT32 *       m_bgram;
@@ -28,8 +30,6 @@
 	UINT32 *       m_vidregs;
 	UINT32 *       m_ram;
 	UINT32 *       m_paletteram;
-//  UINT32 *       m_spriteram;   // currently this uses generic buffered spriteram
-//  size_t         m_spriteram_size;
 
 	/* video-related */
 	bitmap_ind8 m_zoom_bitmap;
@@ -40,6 +40,7 @@
 
 	/* devices */
 	device_t *m_maincpu;
+	required_device<buffered_spriteram32_device> m_spriteram;
 };
 
 /*----------- defined in video/psikyosh.c -----------*/
diff -Nru src-old/mame/includes/raiden.h src/mame/includes/raiden.h
--- src-old/mame/includes/raiden.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/raiden.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class raiden_state : public driver_device
 {
 public:
 	raiden_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_videoram;
 	UINT16 *m_shared_ram;
@@ -14,6 +17,7 @@
 	tilemap_t *m_tx_layer;
 	int m_flipscreen;
 	int m_alternate;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/rohga.h src/mame/includes/rohga.h
--- src-old/mame/includes/rohga.h	2012-01-28 19:15:10.000000000 +0100
+++ src/mame/includes/rohga.h	2012-03-08 08:39:27.000000000 +0100
@@ -7,6 +7,7 @@
 #include "sound/okim6295.h"
 #include "video/deco16ic.h"
 #include "video/decocomn.h"
+#include "video/bufsprite.h"
 
 class rohga_state : public driver_device
 {
@@ -19,14 +20,15 @@
 		  m_deco_tilegen1(*this, "tilegen1"),
 		  m_deco_tilegen2(*this, "tilegen2"),
 		  m_oki1(*this, "oki1"),
-		  m_oki2(*this, "oki2") { }
+		  m_oki2(*this, "oki2"),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	/* memory pointers */
 	UINT16 *  m_pf1_rowscroll;
 	UINT16 *  m_pf2_rowscroll;
 	UINT16 *  m_pf3_rowscroll;
 	UINT16 *  m_pf4_rowscroll;
-	UINT16 *  m_spriteram;
 
 	/* devices */
 	required_device<cpu_device> m_maincpu;
@@ -36,6 +38,8 @@
 	required_device<deco16ic_device> m_deco_tilegen2;
 	required_device<okim6295_device> m_oki1;
 	required_device<okim6295_device> m_oki2;
+	required_device<buffered_spriteram16_device> m_spriteram;
+	optional_device<buffered_spriteram16_device> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/sidearms.h src/mame/includes/sidearms.h
--- src-old/mame/includes/sidearms.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/sidearms.h	2012-03-11 18:17:00.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class sidearms_state : public driver_device
 {
 public:
 	sidearms_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	int m_gameid;
 
@@ -24,6 +27,8 @@
 	UINT32 m_hcount_191;
 	UINT32 m_vcount_191;
 	UINT32 m_latch_374;
+
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 /*----------- defined in video/sidearms.c -----------*/
@@ -37,4 +42,3 @@
 
 VIDEO_START( sidearms );
 SCREEN_UPDATE_IND16( sidearms );
-SCREEN_VBLANK( sidearms );
diff -Nru src-old/mame/includes/slapfght.h src/mame/includes/slapfght.h
--- src-old/mame/includes/slapfght.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/slapfght.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,4 +1,5 @@
 #include "cpu/z80/z80.h"
+#include "video/bufsprite.h"
 
 
 /* This it the best way to allow game specific kludges until the system is fully understood */
@@ -15,7 +16,8 @@
 {
 public:
 	slapfght_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	int m_getstar_id;
 	UINT8 *m_slapfight_videoram;
@@ -53,6 +55,7 @@
 	tilemap_t *m_pf1_tilemap;
 	tilemap_t *m_fix_tilemap;
 	UINT8 m_irq_mask;
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/srumbler.h src/mame/includes/srumbler.h
--- src-old/mame/includes/srumbler.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/srumbler.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,9 +1,12 @@
+#include "video/bufsprite.h"
+
 class srumbler_state : public driver_device
 {
 public:
 	srumbler_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this,"maincpu"),
+		m_spriteram(*this,"spriteram")
 		{ }
 
 	UINT8 *m_backgroundram;
@@ -13,6 +16,7 @@
 	int m_scroll[4];
 
 	required_device<cpu_device> m_maincpu;
+	required_device<buffered_spriteram8_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/sshangha.h src/mame/includes/sshangha.h
--- src-old/mame/includes/sshangha.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/sshangha.h	2012-03-08 10:54:00.000000000 +0100
@@ -5,7 +5,9 @@
 public:
 	sshangha_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		 m_deco_tilegen1(*this, "tilegen1")
+		 m_deco_tilegen1(*this, "tilegen1"),
+		 m_spriteram(*this, "spriteram"),
+		 m_spriteram2(*this, "spriteram2")
 		{ }
 
 	UINT16 *m_prot_data;
@@ -21,6 +23,8 @@
 	UINT16* m_tile_paletteram2;
 
 	required_device<deco16ic_device> m_deco_tilegen1;
+	required_shared_ptr<UINT16> m_spriteram;
+	optional_shared_ptr<UINT16> m_spriteram2;
 };
 
 
diff -Nru src-old/mame/includes/suprnova.h src/mame/includes/suprnova.h
--- src-old/mame/includes/suprnova.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/suprnova.h	2012-03-08 10:54:00.000000000 +0100
@@ -19,7 +19,8 @@
 public:
 	skns_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
-		m_maincpu(*this,"maincpu")
+		m_maincpu(*this,"maincpu"),
+		m_spriteram(*this,"spriteram")
 		{ }
 
 	sknsspr_device* m_spritegen;
@@ -67,6 +68,7 @@
 	UINT8 m_region;
 
 	required_device<cpu_device> m_maincpu;
+	required_shared_ptr<UINT32> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/tetrisp2.h src/mame/includes/tetrisp2.h
--- src-old/mame/includes/tetrisp2.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/tetrisp2.h	2012-03-08 10:54:00.000000000 +0100
@@ -2,7 +2,9 @@
 {
 public:
 	tetrisp2_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram"),
+		  m_spriteram2(*this, "spriteram2") { }
 
 	UINT16 m_systemregs[0x10];
 	UINT16 *m_vram_bg;
@@ -37,6 +39,8 @@
 	tilemap_t *m_tilemap_sub_bg;
 	tilemap_t *m_tilemap_sub_fg;
 	tilemap_t *m_tilemap_sub_rot;
+	required_shared_ptr<UINT16> m_spriteram;
+	optional_shared_ptr<UINT16> m_spriteram2;
 };
 
 WRITE16_HANDLER( tetrisp2_systemregs_w );
diff -Nru src-old/mame/includes/tigeroad.h src/mame/includes/tigeroad.h
--- src-old/mame/includes/tigeroad.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/tigeroad.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,14 +1,18 @@
+#include "video/bufsprite.h"
+
 class tigeroad_state : public driver_device
 {
 public:
 	tigeroad_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_videoram;
 	UINT16 *m_ram16;
 	int m_bgcharbank;
 	tilemap_t *m_bg_tilemap;
 	tilemap_t *m_fg_tilemap;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
@@ -19,4 +23,3 @@
 WRITE16_HANDLER( tigeroad_scroll_w );
 VIDEO_START( tigeroad );
 SCREEN_UPDATE_IND16( tigeroad );
-SCREEN_VBLANK( tigeroad );
diff -Nru src-old/mame/includes/toki.h src/mame/includes/toki.h
--- src-old/mame/includes/toki.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/toki.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class toki_state : public driver_device
 {
 public:
 	toki_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_videoram;
 	int m_msm5205next;
@@ -13,14 +16,13 @@
 	tilemap_t *m_background_layer;
 	tilemap_t *m_foreground_layer;
 	tilemap_t *m_text_layer;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
 /*----------- defined in video/toki.c -----------*/
 
 VIDEO_START( toki );
-SCREEN_VBLANK( toki );
-SCREEN_VBLANK( tokib );
 SCREEN_UPDATE_IND16( toki );
 SCREEN_UPDATE_IND16( tokib );
 WRITE16_HANDLER( toki_background1_videoram16_w );
diff -Nru src-old/mame/includes/twin16.h src/mame/includes/twin16.h
--- src-old/mame/includes/twin16.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/twin16.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class twin16_state : public driver_device
 {
 public:
 	twin16_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_videoram;
 	UINT16 m_CPUA_register;
@@ -24,6 +27,7 @@
 	UINT16 m_scrolly[3];
 	UINT16 m_video_register;
 	tilemap_t *m_text_tilemap;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/twincobr.h src/mame/includes/twincobr.h
--- src-old/mame/includes/twincobr.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/twincobr.h	2012-03-08 08:39:27.000000000 +0100
@@ -5,13 +5,15 @@
 
 
 #include "video/mc6845.h"
+#include "video/bufsprite.h"
 
 
 class twincobr_state : public driver_device
 {
 public:
 	twincobr_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	int m_toaplan_main_cpu;
 	int m_wardner_membank;
@@ -48,6 +50,7 @@
 	tilemap_t *m_bg_tilemap;
 	tilemap_t *m_fg_tilemap;
 	tilemap_t *m_tx_tilemap;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
@@ -122,4 +125,3 @@
 
 VIDEO_START( toaplan0 );
 SCREEN_UPDATE_IND16( toaplan0 );
-SCREEN_VBLANK( toaplan0 );
diff -Nru src-old/mame/includes/vaportra.h src/mame/includes/vaportra.h
--- src-old/mame/includes/vaportra.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/vaportra.h	2012-03-08 08:39:27.000000000 +0100
@@ -4,11 +4,14 @@
 
 *************************************************************************/
 
+#include "video/bufsprite.h"
+
 class vaportra_state : public driver_device
 {
 public:
 	vaportra_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	/* memory pointers */
 	UINT16 *  m_pf1_rowscroll;
@@ -24,6 +27,7 @@
 	device_t *m_audiocpu;
 	device_t *m_deco_tilegen1;
 	device_t *m_deco_tilegen2;
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/wwfwfest.h src/mame/includes/wwfwfest.h
--- src-old/mame/includes/wwfwfest.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/wwfwfest.h	2012-03-08 08:39:27.000000000 +0100
@@ -1,8 +1,11 @@
+#include "video/bufsprite.h"
+
 class wwfwfest_state : public driver_device
 {
 public:
 	wwfwfest_state(const machine_config &mconfig, device_type type, const char *tag)
-		: driver_device(mconfig, type, tag) { }
+		: driver_device(mconfig, type, tag),
+		  m_spriteram(*this, "spriteram") { }
 
 	UINT16 *m_fg0_videoram;
 	UINT16 *m_bg0_videoram;
@@ -18,6 +21,7 @@
 	UINT16 m_sprite_xoff;
 	UINT16 m_bg0_dx;
 	UINT16 m_bg1_dx[2];
+	required_device<buffered_spriteram16_device> m_spriteram;
 };
 
 
diff -Nru src-old/mame/includes/zerozone.h src/mame/includes/zerozone.h
--- src-old/mame/includes/zerozone.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/zerozone.h	2012-03-08 08:39:27.000000000 +0100
@@ -14,8 +14,7 @@
 		: driver_device(mconfig, type, tag),
 		  m_maincpu(*this, "maincpu"),
 		  m_audiocpu(*this, "audiocpu"),
-		  m_vram(*this, "videoram"),
-		  m_vram_size(*this, "videoram")
+		  m_vram(*this, "videoram")
 	{ }
 
 	// in drivers/zerozone.c
@@ -31,7 +30,6 @@
 
 	// shared pointers
 	required_shared_ptr<UINT16> m_vram;
-	required_shared_size m_vram_size;
 	// currently this driver uses generic palette handling
 
 	// state
diff -Nru src-old/mame/includes/zodiack.h src/mame/includes/zodiack.h
--- src-old/mame/includes/zodiack.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/zodiack.h	2012-03-08 08:39:27.000000000 +0100
@@ -13,10 +13,7 @@
 		  m_videoram_2(*this, "videoram_2"),
 		  m_attributeram(*this, "attributeram"),
 		  m_spriteram(*this, "spriteram"),
-		  m_bulletsram(*this, "bulletsram"),
-		  m_videoram_size(*this, "videoram"),
-		  m_spriteram_size(*this, "spriteram"),
-		  m_bulletsram_size(*this, "bulletsram")
+		  m_bulletsram(*this, "bulletsram")
 	{ m_percuss_hardware = 0; }
 
 	// in drivers/zodiack.c
@@ -44,9 +41,6 @@
 	required_shared_ptr<UINT8> m_attributeram;
 	required_shared_ptr<UINT8> m_spriteram;
 	required_shared_ptr<UINT8> m_bulletsram;
-	required_shared_size m_videoram_size;
-	required_shared_size m_spriteram_size;
-	required_shared_size m_bulletsram_size;
 	// currently this driver uses generic palette handling
 
 	// state
diff -Nru src-old/mame/machine/atarigen.h src/mame/machine/atarigen.h
--- src-old/mame/machine/atarigen.h	2011-04-27 06:11:18.000000000 +0200
+++ src/mame/machine/atarigen.h	2012-03-08 08:39:27.000000000 +0100
@@ -97,8 +97,7 @@
 	atarigen_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
 		  m_earom(*this, "earom"),
-		  m_eeprom(*this, "eeprom"),
-		  m_eeprom_size(*this, "eeprom") { }
+		  m_eeprom(*this, "eeprom") { }
 
 	// users must call through to these
 	virtual void machine_start();
@@ -115,7 +114,6 @@
 	UINT8				m_earom_control;
 
 	optional_shared_ptr<UINT16> m_eeprom;
-	optional_shared_size m_eeprom_size;
 
 	UINT8				m_scanline_int_state;
 	UINT8				m_sound_int_state;
diff -Nru src-old/mame/machine/cps2crpt.c src/mame/machine/cps2crpt.c
--- src-old/mame/machine/cps2crpt.c	2011-03-29 16:50:04.000000000 +0200
+++ src/mame/machine/cps2crpt.c	2012-02-28 01:04:12.000000000 +0100
@@ -783,6 +783,7 @@
 	{ "ssf2tu",   { 0x94fa8902,0x4c77143f }, 0x400000 },	// 0838 0007 2000  btst    #7,$2000
 	{ "ssf2tur1", { 0x94fa8902,0x4c77143f }, 0x400000 },	// 0838 0007 2000  btst    #7,$2000
 	{ "ssf2xj",   { 0x942a5702,0x05ac140e }, 0x400000 },	// 0838 0007 2000  btst    #7,$2000
+	{ "ssf2xjr",  { 0x943c2b02,0x7acd1422 }, 0x400000 },	// 0838 0007 2000  btst    #7,$2000 // curious, not the usual Japan key on the rent version
 	{ "xmcota",   { 0x3bc6eda4,0x97f80251 }, 0x100000 },	// 0C80 1972 0301  cmpi.l  #$19720301,D0
 	{ "xmcotau",  { 0x32a57ecd,0x98016f4b }, 0x100000 },	// 0C80 1972 0301  cmpi.l  #$19720301,D0
 	{ "xmcotah",  { 0xf5e8dc34,0xa096b217 }, 0x100000 },	// 0C80 1972 0301  cmpi.l  #$19720301,D0
@@ -834,6 +835,7 @@
 	{ "nwarrb",   { 0x17c67109,0xb7362a20 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
 	{ "nwarra",   { 0x4e940d0c,0x39b861a4 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
 	{ "vhuntj",   { 0x1135b2c3,0xa4e9d7f2 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
+	{ "vhuntjr1s",{ 0x1135b2c3,0xa4e9d7f2 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
 	{ "vhuntjr1", { 0x1135b2c3,0xa4e9d7f2 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
 	{ "vhuntjr2", { 0x1135b2c3,0xa4e9d7f2 }, 0x180000 },	// 0838 0000 6160  btst    #0,$6160
 	{ "sfa",      { 0x0f895d6e,0xc4273a1b }, 0x080000 },	// 0C80 0564 2194  cmpi.l  #$05642194,D0
diff -Nru src-old/mame/machine/decocass.c src/mame/machine/decocass.c
--- src-old/mame/machine/decocass.c	2011-11-14 11:45:36.000000000 +0100
+++ src/mame/machine/decocass.c	2012-03-10 05:05:23.000000000 +0100
@@ -40,6 +40,7 @@
 	TYPE3_SWAP_25,
 	TYPE3_SWAP_34_0,
 	TYPE3_SWAP_34_7,
+	TYPE3_SWAP_45,
 	TYPE3_SWAP_23_56,
 	TYPE3_SWAP_56,
 	TYPE3_SWAP_67
@@ -260,13 +261,12 @@
 /***************************************************************************
  *
  *  TYPE1 DONGLE (DE-0061)
- *  - Lock 'n Chase
- *  - Treasure Island
- *  - Super Astro Fighter
- *  - Lucky Poker
  *  - Terranian
- *  - Explorer
+ *  - Super Astro Fighter
+ *  - Lock 'n Chase
  *  - Pro Golf
+ *  - Lucky Poker
+ *  - Treasure Island
  *
  * Latch bits 2 and 6, pass bit 3, invert bit 2.
  * Lookup PROM DE-0061 using bits 0, 1, 4, 5, and 7 as the
@@ -671,10 +671,10 @@
 /***************************************************************************
  *
  *  TYPE2 DONGLE (CS82-007)
- *  - Mission X
  *  - Disco No 1
- *  - Pro Tennis
  *  - Tornado
+ *  - Mission X
+ *  - Pro Tennis
  *
  ***************************************************************************/
 static READ8_HANDLER( decocass_type2_r )
@@ -746,17 +746,19 @@
 /***************************************************************************
  *
  *  TYPE3 DONGLE
+ *  - Burger Time
  *  - Bump 'n Jump
  *  - Burnin' Rubber
- *  - Burger Time
  *  - Graplop
  *  - Cluster Buster
  *  - LaPaPa
- *  - Fighting Ice Hockey
+ *  - Skater
  *  - Pro Bowling
  *  - Night Star
  *  - Pro Soccer
+ *  - Super Doubles Tennis
  *  - Peter Pepper's Ice Cream Factory
+ *  - Fighting Ice Hockey
  *
  ***************************************************************************/
 static READ8_HANDLER( decocass_type3_r )
@@ -879,6 +881,17 @@
 						(BIT(save, 6) << 6) |
 						(state->m_type3_d0_latch << 7);
 					break;
+				case TYPE3_SWAP_45:
+					data =
+						state->m_type3_d0_latch |
+						(BIT(save, 1) << 1) |
+						(BIT(save, 2) << 2) |
+						(BIT(save, 3) << 3) |
+						(BIT(save, 5) << 4) |
+						(BIT(save, 4) << 5) |
+						(BIT(save, 6) << 6) |
+						(BIT(save, 7) << 7);
+					break;
 				case TYPE3_SWAP_23_56:
 					data =
 						(state->m_type3_d0_latch << 0) |
@@ -979,6 +992,7 @@
  *
  *  TYPE4 DONGLE
  *  - Scrum Try
+ *  - Oozumou/The Grand Sumo
  *  Contains a 32K (EP)ROM that can be read from any byte
  *  boundary sequentially. The EPROM is enable after writing
  *  1100xxxx to E5x1 once. Then an address is written LSB
@@ -1065,7 +1079,7 @@
 
 /***************************************************************************
  *
- *  TYPE5 DONGLE
+ *  TYPE4 DONGLE
  *  - Boulder Dash
  *  Actually a NOP dongle returning 0x55 after triggering a latch
  *  by writing 1100xxxx to E5x1
@@ -1418,24 +1432,22 @@
 	state->m_dongle_r = decocass_type1_latch_27_pass_3_inv_2_r;
 }
 
-MACHINE_RESET( clocknch )
+MACHINE_RESET( cterrani )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
-	LOG(0,("dongle type #1 (DE-0061 flip 2-3)\n"));
+	LOG(0,("dongle type #1 (DE-0061 straight)\n"));
 	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
-	state->m_type1_inmap = MAKE_MAP(0,1,3,2,4,5,6,7);
-	state->m_type1_outmap = MAKE_MAP(0,1,3,2,4,5,6,7);
+	state->m_type1_inmap = MAKE_MAP(0,1,2,3,4,5,6,7);
+	state->m_type1_outmap = MAKE_MAP(0,1,2,3,4,5,6,7);
 }
 
-MACHINE_RESET( ctisland )
+MACHINE_RESET( castfant )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
-	LOG(0,("dongle type #1 (DE-0061 flip 0-2)\n"));
-	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
-	state->m_type1_inmap = MAKE_MAP(2,1,0,3,4,5,6,7);
-	state->m_type1_outmap = MAKE_MAP(2,1,0,3,4,5,6,7);
+	LOG(0,("dongle type #1 (DE-0061)\n"));
+	state->m_dongle_r = decocass_type1_latch_16_pass_3_inv_1_r;
 }
 
 MACHINE_RESET( csuperas )
@@ -1448,12 +1460,24 @@
 	state->m_type1_outmap = MAKE_MAP(0,1,2,3,5,4,6,7);
 }
 
-MACHINE_RESET( castfant )
+MACHINE_RESET( clocknch )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
-	LOG(0,("dongle type #1 (DE-0061)\n"));
-	state->m_dongle_r = decocass_type1_latch_16_pass_3_inv_1_r;
+	LOG(0,("dongle type #1 (DE-0061 flip 2-3)\n"));
+	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
+	state->m_type1_inmap = MAKE_MAP(0,1,3,2,4,5,6,7);
+	state->m_type1_outmap = MAKE_MAP(0,1,3,2,4,5,6,7);
+}
+
+MACHINE_RESET( cprogolf )
+{
+	decocass_state *state = machine.driver_data<decocass_state>();
+	decocass_reset_common(machine);
+	LOG(0,("dongle type #1 (DE-0061 flip 0-1)\n"));
+	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
+	state->m_type1_inmap = MAKE_MAP(1,0,2,3,4,5,6,7);
+	state->m_type1_outmap = MAKE_MAP(1,0,2,3,4,5,6,7);
 }
 
 MACHINE_RESET( cluckypo )
@@ -1466,14 +1490,14 @@
 	state->m_type1_outmap = MAKE_MAP(0,3,2,1,4,5,6,7);
 }
 
-MACHINE_RESET( cterrani )
+MACHINE_RESET( ctisland )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
-	LOG(0,("dongle type #1 (DE-0061 straight)\n"));
+	LOG(0,("dongle type #1 (DE-0061 flip 0-2)\n"));
 	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
-	state->m_type1_inmap = MAKE_MAP(0,1,2,3,4,5,6,7);
-	state->m_type1_outmap = MAKE_MAP(0,1,2,3,4,5,6,7);
+	state->m_type1_inmap = MAKE_MAP(2,1,0,3,4,5,6,7);
+	state->m_type1_outmap = MAKE_MAP(2,1,0,3,4,5,6,7);
 }
 
 MACHINE_RESET( cexplore )
@@ -1484,17 +1508,7 @@
 	state->m_dongle_r = decocass_type1_latch_26_pass_5_inv_2_r;
 }
 
-MACHINE_RESET( cprogolf )
-{
-	decocass_state *state = machine.driver_data<decocass_state>();
-	decocass_reset_common(machine);
-	LOG(0,("dongle type #1 (DE-0061 flip 0-1)\n"));
-	state->m_dongle_r = decocass_type1_latch_26_pass_3_inv_2_r;
-	state->m_type1_inmap = MAKE_MAP(1,0,2,3,4,5,6,7);
-	state->m_type1_outmap = MAKE_MAP(1,0,2,3,4,5,6,7);
-}
-
-MACHINE_RESET( cmissnx )
+MACHINE_RESET( cdiscon1 )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
@@ -1503,7 +1517,7 @@
 	state->m_dongle_w = decocass_type2_w;
 }
 
-MACHINE_RESET( cdiscon1 )
+MACHINE_RESET( ctornado )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
@@ -1512,7 +1526,7 @@
 	state->m_dongle_w = decocass_type2_w;
 }
 
-MACHINE_RESET( cptennis )
+MACHINE_RESET( cmissnx )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
@@ -1521,7 +1535,7 @@
 	state->m_dongle_w = decocass_type2_w;
 }
 
-MACHINE_RESET( ctornado )
+MACHINE_RESET( cptennis )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
@@ -1530,14 +1544,14 @@
 	state->m_dongle_w = decocass_type2_w;
 }
 
-MACHINE_RESET( cbnj )
+MACHINE_RESET( cbtime )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
 	LOG(0,("dongle type #3 (PAL)\n"));
 	state->m_dongle_r = decocass_type3_r;
 	state->m_dongle_w = decocass_type3_w;
-	state->m_type3_swap = TYPE3_SWAP_67;
+	state->m_type3_swap = TYPE3_SWAP_12;
 }
 
 MACHINE_RESET( cburnrub )
@@ -1550,16 +1564,6 @@
 	state->m_type3_swap = TYPE3_SWAP_67;
 }
 
-MACHINE_RESET( cbtime )
-{
-	decocass_state *state = machine.driver_data<decocass_state>();
-	decocass_reset_common(machine);
-	LOG(0,("dongle type #3 (PAL)\n"));
-	state->m_dongle_r = decocass_type3_r;
-	state->m_dongle_w = decocass_type3_w;
-	state->m_type3_swap = TYPE3_SWAP_12;
-}
-
 MACHINE_RESET( cgraplop )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
@@ -1590,14 +1594,14 @@
 	state->m_type3_swap = TYPE3_SWAP_34_7;
 }
 
-MACHINE_RESET( cfghtice )
+MACHINE_RESET( cskater )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
 	LOG(0,("dongle type #3 (PAL)\n"));
 	state->m_dongle_r = decocass_type3_r;
 	state->m_dongle_w = decocass_type3_w;
-	state->m_type3_swap = TYPE3_SWAP_25;
+	state->m_type3_swap = TYPE3_SWAP_45;
 }
 
 MACHINE_RESET( cprobowl )
@@ -1630,6 +1634,40 @@
 	state->m_type3_swap = TYPE3_SWAP_24;
 }
 
+MACHINE_RESET( csdtenis )
+{
+	decocass_state *state = machine.driver_data<decocass_state>();
+	decocass_reset_common(machine);
+	LOG(0,("dongle type #3 (PAL)\n"));
+	state->m_dongle_r = decocass_type3_r;
+	state->m_dongle_w = decocass_type3_w;
+	state->m_type3_swap = TYPE3_SWAP_23_56;
+}
+
+MACHINE_RESET( czeroize )
+{
+	decocass_state *state = machine.driver_data<decocass_state>();
+	UINT8 *mem = machine.region("dongle")->base();
+	decocass_reset_common(machine);
+	LOG(0,("dongle type #3 (PAL)\n"));
+	state->m_dongle_r = decocass_type3_r;
+	state->m_dongle_w = decocass_type3_w;
+	state->m_type3_swap = TYPE3_SWAP_23_56;
+
+	/*
+     * FIXME: remove if the original ROM is available.
+     * The Zeroize 6502 code at 0x3707 issues LODCTRS with 0x8a,
+     * and expects to read 0x18 from 0x08a0 ff. within 7 bytes
+     * and 0xf7 from 0x8a1 (which 0xd is subtracted from presumably in order
+     * to form a NOP of 0xea).
+     * This hack seems to be sufficient to get around
+     * the missing dongle ROM contents and play the game.
+     */
+	memset(mem, 0x00, 0x1000);
+	mem[0x08a0] = 0x18;
+	mem[0x08a1] = 0xf7;
+}
+
 MACHINE_RESET( cppicf )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
@@ -1640,7 +1678,17 @@
 	state->m_type3_swap = TYPE3_SWAP_01;
 }
 
-MACHINE_RESET( cscrtry )
+MACHINE_RESET( cfghtice )
+{
+	decocass_state *state = machine.driver_data<decocass_state>();
+	decocass_reset_common(machine);
+	LOG(0,("dongle type #3 (PAL)\n"));
+	state->m_dongle_r = decocass_type3_r;
+	state->m_dongle_w = decocass_type3_w;
+	state->m_type3_swap = TYPE3_SWAP_25;
+}
+
+MACHINE_RESET( type4 )
 {
 	decocass_state *state = machine.driver_data<decocass_state>();
 	decocass_reset_common(machine);
@@ -1666,30 +1714,6 @@
 	state->m_dongle_r = decocass_nodong_r;
 }
 
-MACHINE_RESET( czeroize )
-{
-	decocass_state *state = machine.driver_data<decocass_state>();
-	UINT8 *mem = machine.region("dongle")->base();
-	decocass_reset_common(machine);
-	LOG(0,("dongle type #3 (PAL)\n"));
-	state->m_dongle_r = decocass_type3_r;
-	state->m_dongle_w = decocass_type3_w;
-	state->m_type3_swap = TYPE3_SWAP_23_56;
-
-	/*
-     * FIXME: remove if the original ROM is available.
-     * The Zeroize 6502 code at 0x3707 issues LODCTRS with 0x8a,
-     * and expects to read 0x18 from 0x08a0 ff. within 7 bytes
-     * and 0xf7 from 0x8a1 (which 0xd is subtracted from presumably in order
-     * to form a NOP of 0xea).
-     * This hack seems to be sufficient to get around
-     * the missing dongle ROM contents and play the game.
-     */
-	memset(mem, 0x00, 0x1000);
-	mem[0x08a0] = 0x18;
-	mem[0x08a1] = 0xf7;
-}
-
 /***************************************************************************
  *
  *  8041 port handlers
diff -Nru src-old/mame/machine/decocass.h src/mame/machine/decocass.h
--- src-old/mame/machine/decocass.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/machine/decocass.h	2012-03-10 05:05:23.000000000 +0100
@@ -141,33 +141,34 @@
 MACHINE_RESET( decocass );
 MACHINE_RESET( ctsttape );
 MACHINE_RESET( chwy );
-MACHINE_RESET( clocknch );
-MACHINE_RESET( ctisland );
-MACHINE_RESET( csuperas );
+MACHINE_RESET( cterrani );
 MACHINE_RESET( castfant );
+MACHINE_RESET( csuperas );
+MACHINE_RESET( clocknch );
+MACHINE_RESET( cprogolf );
 MACHINE_RESET( cluckypo );
-MACHINE_RESET( cterrani );
+MACHINE_RESET( ctisland );
 MACHINE_RESET( cexplore );
-MACHINE_RESET( cprogolf );
-MACHINE_RESET( cmissnx );
 MACHINE_RESET( cdiscon1 );
-MACHINE_RESET( cptennis );
 MACHINE_RESET( ctornado );
-MACHINE_RESET( cbnj );
-MACHINE_RESET( cburnrub );
+MACHINE_RESET( cmissnx );
+MACHINE_RESET( cptennis );
 MACHINE_RESET( cbtime );
+MACHINE_RESET( cburnrub );
 MACHINE_RESET( cgraplop );
 MACHINE_RESET( cgraplop2 );
+MACHINE_RESET( cskater );
 MACHINE_RESET( clapapa );
-MACHINE_RESET( cfghtice );
 MACHINE_RESET( cprobowl );
 MACHINE_RESET( cnightst );
 MACHINE_RESET( cpsoccer );
+MACHINE_RESET( csdtenis );
+MACHINE_RESET( czeroize );
 MACHINE_RESET( cppicf );
-MACHINE_RESET( cscrtry );
+MACHINE_RESET( cfghtice );
+MACHINE_RESET( type4 );
 MACHINE_RESET( cflyball );
 MACHINE_RESET( cbdash );
-MACHINE_RESET( czeroize );
 
 WRITE8_HANDLER( i8041_p1_w );
 READ8_HANDLER( i8041_p1_r );
diff -Nru src-old/mame/machine/maple-dc.c src/mame/machine/maple-dc.c
--- src-old/mame/machine/maple-dc.c	2011-08-23 19:47:49.000000000 +0200
+++ src/mame/machine/maple-dc.c	2012-02-29 10:13:22.000000000 +0100
@@ -39,7 +39,7 @@
 
 void maple_dc_device::device_start()
 {
-	fprintf(stderr, "Device started\n");
+	logerror("maple_dc_device started\n");
 	cpu = machine().device<sh4_device>(maincpu_tag);
 	timer = timer_alloc(0);
 
diff -Nru src-old/mame/machine/n64.c src/mame/machine/n64.c
--- src-old/mame/machine/n64.c	2012-02-26 15:31:24.000000000 +0100
+++ src/mame/machine/n64.c	2012-03-11 11:36:13.000000000 +0100
@@ -22,6 +22,7 @@
 
 n64_periphs::n64_periphs(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
     : device_t(mconfig, N64PERIPH, "N64 Periphal Chips", tag, owner, clock)
+    , m_nvram_image(NULL)
 {
 }
 
@@ -1299,7 +1300,7 @@
     ai_status |= 0x40000000;
 
    // adjust the timer
-   period = attotime::from_hz(DACRATE_NTSC) * ((ai_dacrate + 1) * (current->length / 8));
+   period = attotime::from_hz(DACRATE_NTSC) * ((ai_dacrate + 1) * (current->length / 4));
    ai_timer->adjust(period);
 }
 
@@ -1339,7 +1340,7 @@
             {
                 double secs_left = (ai_timer->expire() - machine().time()).as_double();
                 unsigned int samples_left = (UINT32)(secs_left * (double)DACRATE_NTSC / (double)(ai_dacrate + 1));
-                ret = samples_left * 8;
+                ret = samples_left * 4;
             }
             else
             {
@@ -2388,6 +2389,9 @@
 {
 	n64_periphs *periphs = machine.device<n64_periphs>("rcp");
 
+	if( periphs->m_nvram_image == NULL )
+		return;
+
 	device_image_interface *image = dynamic_cast<device_image_interface *>(periphs->m_nvram_image);
 	//printf("Saving stuff\n");
 	UINT8 data[0x30800];
diff -Nru src-old/mame/machine/r2crypt.c src/mame/machine/r2crypt.c
--- src-old/mame/machine/r2crypt.c	2011-03-29 16:50:04.000000000 +0200
+++ src/mame/machine/r2crypt.c	2012-03-03 02:05:33.000000000 +0100
@@ -87,7 +87,7 @@
 static const UINT32 zmap_2[32] = {
   0x1b301017, 0x02310910, 0x04404644, 0x08042024, 0x050a3aa4, 0xb6087024, 0xa2204208, 0x1c9d9228,
   0x00c04200, 0xe0821041, 0x0018a803, 0x6402d208, 0x3a104109, 0x005082c0, 0x00920910, 0x20404007,
-  0xc006a0c0, 0x1c48e006, 0xf8871010, 0x83510440, 0x80600410, 0x00040c0a, 0x510590e6, 0x40200910,
+  0xc006a4c0, 0x1c48e006, 0xf8871010, 0x83510440, 0x80600410, 0x00040c0a, 0x510590e6, 0x40200910,
   0x24090928, 0x010406a8, 0x032001a8, 0x10a80993, 0x40858042, 0x49a30111, 0x0c482401, 0x830224c0
 };
 
diff -Nru src-old/mame/mame.lst src/mame/mame.lst
--- src-old/mame/mame.lst	2012-02-26 15:05:46.000000000 +0100
+++ src/mame/mame.lst	2012-03-11 18:17:00.000000000 +0100
@@ -39,8 +39,6 @@
 ******************************************************************************/
 
 
-
-
 // "Pacman hardware" games
 puckman			// (c) 1980 Namco
 puckmana		// (c) 1980 Namco
@@ -229,6 +227,7 @@
 eagle2			// [1980] Centuri
 eagle3			// [1980] Centuri
 spctbird		// (c) Fortrek
+fantastc		// (c) Taito (Brazil)
 skybase			// (c) 1982 Omori Electric Co., Ltd.
 checkman		// (c) 1982 Zilec-Zenitone
 checkmanj		// (c) 1982 Jaleco (Zenitone/Zilec in ROM CM4, and the programmer names)
@@ -1014,6 +1013,7 @@
 tekken4
 tekken4a
 tekken4b
+tekken4c
 timecrs3
 zgundm
 fghtjam
@@ -1021,6 +1021,7 @@
 zgundmdx
 gundzaft
 soulclb3
+soulclb3a
 
 // Namco System 256
 sys256
@@ -1687,6 +1688,7 @@
 hasamu			// (c) 1991 Irem (Japan)
 dynablst		// (c) 1991 Irem (World)
 dynablstb		// bootleg
+dynablstb2		// bootleg (alt)
 bombrman		// (c) 1991 Irem (Japan)
 atompunk		// (c) 1991 Irem America (licensed from Hudson Soft)
 // M97
@@ -2034,6 +2036,7 @@
 arknoid2		// B08 (c) 1987 Taito Corporation Japan (World)
 arknoid2u		// B08 (c) 1987 Taito America Corporation + Romstar license (US)
 arknoid2j		// B08 (c) 1987 Taito Corporation (Japan)
+arknoid2b		// B08 (c) 1987 (bootleg)
 drtoppel		// B19 (c) 1987 Taito Corporation Japan (World)
 drtoppelu		// B19 (c) 1987 Taito Corporation (US)
 drtoppelj		// B19 (c) 1987 Taito Corporation (Japan)
@@ -2170,6 +2173,7 @@
 gunbustru		// D27 (c) 1992 Taito America Corporation (US)
 gunbustrj		// D27 (c) 1992 Taito Corporation (Japan)
 superchs		// D46 (c) 1992 Taito America Corporation (US)
+superchsj		// D46 (c) 1992 Taito Corporation (Japan)
 groundfx		// D51 (c) 1992 Taito Coporation
 undrfire		// D67 (c) 1993 Taito Coporation Japan (World)
 undrfireu		// D67 (c) 1993 Taito America Corporation (US)
@@ -2349,8 +2353,10 @@
 // Taito Type-Zero System
 taitotz
 batlgear		// E68 (c) 1999 Taito
+pwrshovl        // E74 (c) 1999 Taito
 landhigh		// E82 (c) 1999 Taito
-batlgr2			// E87 (c) 2000 Taito
+batlgr2			// E87 (c) 2000 Taito (2.04J)
+batlgr2a		// E87 (c) 2000 Taito (2.01J)
 
 // Toaplan games
 perfrman		// (c) 1985 Data East Corporation (Japan)
@@ -2771,6 +2777,7 @@
 // Capcom CPS1 games
 forgottn		//  7/1988 (c) 1988 (World)
 forgottnu		//  7/1988 (c) 1988 (USA)
+forgottnu1		//  7/1988 (c) 1988 (USA)
 forgottnua		//  7/1988 (c) 1988 (USA)
 lostwrld		//  7/1988 (c) 1988 (Japan)
 lostwrldo		//  7/1988 (c) 1988 (Japan)
@@ -2793,6 +2800,7 @@
 area88			//  8/1989 (c) 1989 (Japan)
 area88r			//  8/1989 (c) 1989 (Japan)
 ffight			// 12/1989 (c) 1989 (World)
+ffighta			// 12/1989 (c) 1989 (World)
 ffightu			// 12/1989 (c) 1989 (USA)
 ffightu1		// 12/1989 (c) 1989 (USA)
 ffightua		// 12/01/1990 (c) 1989 (USA)
@@ -2821,7 +2829,7 @@
 cawingbl
 nemo			// 30/11/1990 (c) 1990 (World)
 nemoj			// 20/11/1990 (c) 1990 (Japan)
-sf2				// 22/05/1991 (c) 1991 (World)
+sf2			// 22/05/1991 (c) 1991 (World)
 sf2eb			// 14/02/1991 (c) 1991 (World)
 sf2ee			// 28/02/1991 (c) 1991 (World)
 sf2ebbl			// 14/02/1991 (c) 1991 (World, bootleg)
@@ -2831,7 +2839,8 @@
 sf2ud			// 18/03/1991 (c) 1991 (USA)
 sf2ue			// 28/02/1991 (c) 1991 (USA)
 sf2uf			// 11/04/1991 (c) 1991 (USA)
-sf2ui			// 22/05/1991 (c) 1991 (USA)
+sf2ug			// 22/05/1991 (c) 1991 (USA, Rev. G)
+sf2ui			// 22/05/1991 (c) 1991 (USA, Rev. I)
 sf2uk			// 01/11/1991 (c) 1991 (USA)
 sf2j			// 10/12/1991 (c) 1991 (Japan)
 sf2ja			// 14/02/1991 (c) 1991 (Japan)
@@ -2842,7 +2851,7 @@
 3wondersu		// 20/05/1991 (c) 1991 (USA)
 wonder3			// 20/05/1991 (c) 1991 (Japan)
 3wondersh		// hack
-kod				// 05/08/1991 (c) 1991 (World)
+kod			// 05/08/1991 (c) 1991 (World)
 kodr1			// 11/07/1991 (c) 1991 (World)
 kodu			// 10/09/1991 (c) 1991 (USA)
 kodj			// 05/08/1991 (c) 1991 (Japan)
@@ -2864,8 +2873,9 @@
 sf2ceua			// 13/03/1992 (c) 1992 (USA)
 sf2ceub			// 13/05/1992 (c) 1992 (USA)
 sf2ceuc			// 03/08/1992 (c) 1992 (USA)
-sf2cej			// 13/05/1992 (c) 1992 (Japan)
 sf2ceja			// 22/03/1992 (c) 1992 (Japan)
+sf2cejb			// 13/05/1992 (c) 1992 (Japan)
+sf2cejc			// 03/08/1992 (c) 1992 (Japan)
 sf2rb			// hack
 sf2rb2			// hack
 sf2rb3			// hack
@@ -2969,6 +2979,7 @@
 ssf2ta			// 23/02/1994 (c) 1994 (Asia)
 ssf2xj			// 23/02/1994 (c) 1994 (Japan)
 avsp			// 20/05/1994 (c) 1994 (Euro)
+ssf2xjr			// 23/02/1994 (c) 1994 (Japan)
 avspu			// 20/05/1994 (c) 1994 (USA)
 avspj			// 20/05/1994 (c) 1994 (Japan)
 avspa			// 20/05/1994 (c) 1994 (Asia)
@@ -3010,6 +3021,7 @@
 nwarrb			// 03/04/1995 (c) 1995 (Brazil)
 nwarra			// 02/03/1995 (c) 1995 (Asia)
 vhuntj			// 02/03/1995 (c) 1995 (Japan)
+vhuntjr1s		// 07/03/1995 (c) 1995 (Japan)
 vhuntjr1		// 07/03/1995 (c) 1995 (Japan)
 vhuntjr2		// 02/03/1995 (c) 1995 (Japan)
 cybots			// 24/04/1995 (c) 1995 (Euro)
@@ -3215,35 +3227,38 @@
 
 // Capcom CPS3 games
 redearth		// 21/11/1996 (c) 1996 (Euro)
-redeartha		// 23/10/1996 (c) 1996 (Euro)
+redearthr1		// 23/10/1996 (c) 1996 (Euro)
 warzard			// 21/11/1996 (c) 1996 (Japan)
-warzarda		// 23/10/1996 (c) 1996 (Japan)
+warzardr1		// 23/10/1996 (c) 1996 (Japan)
 sfiii			// 04/02/1997 (c) 1997 (USA)
 sfiiij			// 04/02/1997 (c) 1997 (Japan)
 sfiiih			// 04/02/1997 (c) 1997 (Hispanic)
 sfiii2			// 30/09/1997 (c) 1997 (USA)
 sfiii2j			// 30/09/1997 (c) 1997 (Japan)
-jojo			// 08/01/1999 (c) 1998 (USA)
-jojoa			// 02/12/1998 (c) 1998 (USA)
-jojoj			// 08/01/1999 (c) 1998 (Japan)
-jojoaj			// 02/12/1998 (c) 1998 (Japan)
+jojo			// 28/01/1999 (c) 1998 (USA)
+jojor1			// 08/01/1999 (c) 1998 (USA)
+jojor2			// 02/12/1998 (c) 1998 (USA)
+jojoj			// 28/01/1999 (c) 1998 (Japan)
+jojojr1			// 08/01/1999 (c) 1998 (Japan)
+jojojr2			// 02/12/1998 (c) 1998 (Japan)
 sfiii3			// 08/06/1999 (c) 1999 (Euro)
-sfiii3a			// 12/05/1999 (c) 1999 (Euro)
+sfiii3r1		// 12/05/1999 (c) 1999 (Euro)
 sfiii3u			// 08/06/1999 (c) 1999 (USA)
-sfiii3au		// 12/05/1999 (c) 1999 (USA)
+sfiii3ur1		// 12/05/1999 (c) 1999 (USA)
 jojoba			// 27/09/1999 (c) 1999 (Japan)
-jojobaa			// 13/09/1999 (c) 1999 (Japan)
+jojobar1		// 13/09/1999 (c) 1999 (Japan)
 
 sfiiin			// 04/02/1997 (c) 1997 (Asia)
 sfiii2n			// 30/09/1997 (c) 1997 (Asia)
-jojon			// 08/01/1999 (c) 1998 (Asia)
-jojoan			// 02/12/1998 (c) 1998 (Asia)
+jojon			// 28/01/1999 (c) 1998 (Asia)
+jojonr1			// 08/01/1999 (c) 1998 (Asia)
+jojonr2			// 02/12/1998 (c) 1998 (Asia)
 sfiii3n			// 08/06/1999 (c) 1999 (Japan)
-sfiii3an		// 12/05/1999 (c) 1999 (Japan)
+sfiii3nr1		// 12/05/1999 (c) 1999 (Japan)
 jojoban			// 27/09/1999 (c) 1999 (Japan)
-jojobaan		// 13/09/1999 (c) 1999 (Japan)
+jojobanr1		// 13/09/1999 (c) 1999 (Japan)
 jojobane		// 27/09/1999 (c) 1999 (Euro)
-jojobaane		// 13/09/1999 (c) 1999 (Euro)
+jojobaner1		// 13/09/1999 (c) 1999 (Euro)
 
 // Capcom ZN1
 cpzn1
@@ -4510,71 +4525,72 @@
 // Sega Model 2 Games
 
 // Model 2 (TGPs, Model 1 sound board)
-daytona			// 1994.03 Daytona USA
+daytona			// 1994.03 Daytona USA (Japan, Revision A)
 daytona93
 daytonas
 daytonat		// 1993, hack
 daytonam		// 1993, hack
 desert			// 1994.07 Desert Tank
-vcop			// 1994.09 Virtua Cop
+vcop			// 1994.09 Virtua Cop (Revision B)
+vcopa			// 1994.09 Virtua Cop (Revision A)
 
 // Model 2A-CRX (TGPs, SCSP sound board)
 vf2o			// 1994.11 Virtua Fighter 2
-vf2a			// 1995.??
-vf2b			// 1995.??
-srallyc			// 1995.02 Sega Rally Championship - Rev C
-srallycb		// 1995.02 Sega Rally Championship - Rev B
+vf2a			// 1995.?? Virtua Fighter 2 (Revision A)
+vf2b			// 1995.?? Virtua Fighter 2 (Revision B)
+srallyc			// 1995.02 Sega Rally Championship (Revision C)
+srallycb		// 1995.02 Sega Rally Championship (Revision B)
 vcop2			// 1995.09 Virtua Cop 2
-vf2			// 1995.09 Virtua Fighter 2.1
+vf2			// 1995.09 Virtua Fighter (Version 2.1)
 skytargt		// 1995.10 Sky Target
-manxtt			// 1995.11 Manx T.T.
-doaa			// 1996.11 Dead or Alive
+manxtt			// 1995.11 Manx T.T. (Revision C)
+doaa			// 1996.11 Dead or Alive (Revision A)
 motoraid		// 1997.10 Motor Raid
-zeroguna		// 1997.12 Zero Gunner
+zeroguna		// 1997.12 Zero Gunner (Export)
 zerogunaj		// 1997.12 Zero Gunner (Japan)
-dyndeka2		// 1998.05 Dynamite Deka 2
-dynamcop		// 1998.09 Dynamic Cop
+dyndeka2		// 1998.05 Dynamite Deka 2 (Japan)
+dynamcop		// 1998.09 Dynamic Cop (Export)
 pltkidsa		// 1999.03 Pilot Kids
 
 // Model 2B-CRX (SHARC, SCSP sound board)
-vstriker		// 1995.05 Virtua Striker
+vstriker		// 1995.05 Virtua Striker (Revision A)
 vstrikero		// 1995.05 Virtua Striker
-rchase2			// 1995.06 Rail Chase 2 (Arcade TV Game List - P.104, Left, 12 from top)
-indy500			// 1995.07 Indy 500
-indy500d		// 1995.07 Indy 500
-indy500to		// 1995.07 Indy 500
-fvipers			// 1995.11 Fighting Vipers
-von			// 1996.01 Dennou Senki Virtual-On (USA)
-vonj			// 1996.01 Dennou Senki Virtual-On (Japan)
-gunblade		// 1996.04 Gunblade N.Y.
-schamp			// 1996.05 Sonic Championship
-sfight			// 1996.05 Sonic the Fighters
-lastbrnx		// 1996.06 Last Bronx
-lastbrnxu		// 1996.06 Last Bronx (USA)
-lastbrnxj		// 1996.06 Last Bronx (Japan)
+rchase2			// 1995.06 Rail Chase 2 (Revision A)
+indy500			// 1995.07 Indy 500 (Revision A, Newer)
+indy500d		// 1995.07 Indy 500 Deluxe (Revision A)
+indy500to		// 1995.07 Indy 500 Twin (Revision A)
+fvipers			// 1995.11 Fighting Vipers (Revision D)
+von			// 1996.01 Cyber Troopers Virtual-On (USA, Revision B)
+vonj			// 1996.01 Cyber Troopers Virtual-On (Japan, Revision B)
+gunblade		// 1996.04 Gunblade N.Y. (Revision A)
+schamp			// 1996.05 Sonic Championship (USA)
+sfight			// 1996.05 Sonic the Fighters (Japan)
+lastbrnx		// 1996.06 Last Bronx (Export, Revision A)
+lastbrnxu		// 1996.06 Last Bronx (USA, Revision A)
+lastbrnxj		// 1996.06 Last Bronx (Japan, Revision A)
 sgt24h			// 1996.07 Super GT 24h
 dynabb			// 1996.08 Dynamite Baseball
-doa			// 1996.11 Dead or Alive
-dynabb97		// 1997.04 Dynamite Baseball 97
-zerogun			// 1997.12 Zero Gunner
+doa			// 1996.11 Dead or Alive (Revision B)
+dynabb97		// 1997.04 Dynamite Baseball 97 (Revision A)
+zerogun			// 1997.12 Zero Gunner (Export)
 zerogunj		// 1997.12 Zero Gunner (Japan)
-dyndeka2b		// 1998.05 Dynamite Deka 2
-dynamcopb		// 1998.09 Dynamite Cop
-pltkids			// 1999.03 Pilot Kids
+dyndeka2b		// 1998.05 Dynamite Deka 2 (Japan)
+dynamcopb		// 1998.09 Dynamite Cop (Export)
+pltkids			// 1999.03 Pilot Kids (Revision A)
 
 // Model 2C-CRX (TGPx4, SCSP sound board)
 skisuprg		// 1996.12 Sega Ski Super G
 stcc			// 1996.09 Sega Touring Car Championship
-stcca			// 1996.09 Sega Touring Car Championship
+stcca			// 1996.09 Sega Touring Car Championship (Revision A)
 stccb			// 1996.09 Sega Touring Car Championship
-waverunr		// 1996.10 Wave Runner
+waverunr		// 1996.10 Wave Runner (Japan, Revision A)
 hotd			// 1997.03 The House of the Dead
-topskatr		// 1997.05 Top Skater
-topskatru		// 1997.05 Top Skater (USA)
+topskatr		// 1997.05 Top Skater (Export, Revision A)
+topskatru		// 1997.05 Top Skater (USA, Revision A)
 topskatrj		// 1997.05 Top Skater (Japan)
-overrev			// 1997.09 Over Rev
-segawski		// 1997.09 Sega Water Ski
-dynamcopc		// 1998.09 Dynamite Cop
+overrev			// 1997.09 Over Rev (Revision A)
+segawski		// 1997.09 Sega Water Ski (Japan, Revision A)
+dynamcopc		// 1998.09 Dynamite Cop (USA)
 bel			// 1998.12 Behind Enemy Lines
 
 // Sega Model 3 Games
@@ -4904,7 +4920,7 @@
 ggxx			// 2002.05 Guilty Gear XX
 mok				// 2002.05 The Maze of the Kings
 chocomk			// 2002.06 Musapey's Choco Marker (Rev A)
-				// 2002.07 Mazan : Flash of the Blade
+mazan			// 2002.07 Mazan : Flash of the Blade
 				// 2002.09 Yonin Uchi Mahjong MJ
 azumanga		// 2002.12 Azumanga Daiou Puzzle Bobble
 moeru			// 2002.12 Moeru Casinyo
@@ -5208,13 +5224,13 @@
 cgraplop2		// 28
 clapapa			// 29 1982.11 La-Pa-Pa
 clapapa2		// 29         Rootin' Tootin'  // this one doesn't display lapapa anywhere
-				// 30 1983.03 Skater
+cskater			// 30 1983.03 Skater
 cprobowl		// 31 1983.03 Pro Bowling
 cnightst		// 32 1983.04 Night Star
 cnightst2		// 32
 cpsoccer		// 33 1982.08 Pro Soccer
 cpsoccerj		// 33 1982.08 Pro Soccer (Japan)
-				// 34 1983.09 Super Doubles Tennis
+csdtenis		// 34 1983.09 Super Doubles Tennis
 cflyball		// 35 1983.?? Flying Ball/Bampoline
 				// 36 1984.04 Genesis/Boomer Rang'r
 czeroize		// 37 1983.10 Zeroize
@@ -5223,7 +5239,7 @@
 cppicf			// 39 1984.02 Peter Pepper's Ice Cream Factory
 cppicf2			// 39
 cfghtice		// 40 1984.04 Fighting Ice Hockey
-cgsumo			// 41 1984.05 Oozumou/The Grand Sumo
+coozumou		// 41 1984.05 Oozumou/The Grand Sumo
 				// 42 1984.08 Hellow Gateball // not a typo, this is official spelling
 				// 43 1984.08 Yellow Cab
 cbdash			// 44 1985.08 Boulder Dash
@@ -5410,6 +5426,7 @@
 cninja			// MAG (c) 1991 Data East Corporation (World)
 cninja1			// MAG (c) 1991 Data East Corporation (World)
 cninjau			// MAG (c) 1991 Data East Corporation (US)
+cninjaa			// MAG (c) 1991 Data East Corporation (US)
 joemac			// MAG (c) 1991 Data East Corporation (Japan)
 cninjabl		// bootleg
 stoneage		// bootleg
@@ -5913,13 +5930,13 @@
 prmrsocrj		// GX101 (c) 1993 (Japan)
 qgakumon		// GX248 (c) 1993 (Japan)
 moomesa			// GX151 (c) 1992 (World)
-moomesau		// GX151 (c) 1992 (US)
-moomesaua		// GX151 (c) 1992 (US)
-moomesaa		// GX151 (c) 1992 (Asia)
+moomesauac		// GX151 (c) 1992 (US)
+moomesauab		// GX151 (c) 1992 (US)
+moomesaaab		// GX151 (c) 1992 (Asia)
 moomesabl		// bootleg
 bucky			// GX173 (c) 1992 (World)
-buckyua			// GX173 (c) 1992 (US)
-buckyaa			// GX173 (c) 1992 (Asia)
+buckyuab		// GX173 (c) 1992 (US)
+buckyaab		// GX173 (c) 1992 (Asia)
 gaiapols		// GX123 (c) 1993 (Europe)
 gaiapolsu		// GX123 (c) 1993 (US)
 gaiapolsj		// GX123 (c) 1993 (Japan)
@@ -6122,6 +6139,11 @@
 evilngte		// GX810 (c)1998
 hellngt			// GX810 (c)1998
 
+// Konami Pyson
+pyson			// Konami Pyson Bios
+wswe			// World Soccer Winning Eleven
+wswe2k3			// World Soccer Winning Eleven 2003
+
 // Exidy games
 carpolo			// (c) 1977
 sidetrac		// (c) 1979
@@ -7729,6 +7751,7 @@
 rfjeta			// (c) 1998 Seibu Kaihatsu (Dream Island license)
 rfjetj			// (c) 1998 Seibu Kaihatsu
 rfjets			// (c) 1998 Seibu Kaihatsu
+rfjett			// (c) 1998 Seibu Kaihatsu (Taiwan license)
 rfjet2kc		// (c) 2000 Seibu Kaihatsu
 
 ejsakura		// (c) 1999 Seibu Kaihatsu
@@ -8270,6 +8293,7 @@
 deerhunta		// (c) 2000 Sammy USA Corporation
 deerhuntb		// (c) 2000 Sammy USA Corporation
 deerhuntc		// (c) 2000 Sammy USA Corporation
+deerhuntd		// (c) 2000 Sammy USA Corporation
 turkhunt		// (c) 2001 Sammy USA Corporation
 wschamp			// (c) 2001 Sammy USA Corporation
 wschampa		// (c) 2001 Sammy USA Corporation
@@ -10258,6 +10282,7 @@
 megat2			// (c) 1994 Merit
 megat2a			// (c) 1994 Merit
 megat2ca		// (c) 1994 Merit
+megat2caa		// (c) 1994 Merit
 megat3			// (c) 1996 Merit
 megat3a			// (c) 1996 Merit
 megat3ca		// (c) 1996 Merit
@@ -10267,6 +10292,7 @@
 megat4			// (c) 1996 Merit
 megat4a			// (c) 1996 Merit
 megat4b			// (c) 1996 Merit
+megat4c			// (c) 1996 Merit
 megat4s			// (c) 1996 Merit
 megat4sn		// (c) 1996 Merit
 megat4te		// (c) 1996 Merit
@@ -11863,7 +11889,8 @@
 
 // Scorpion 1 games
 
-sc1lotus		// (c) 198? BFM Dutch ROMS, prelim
+sc1lotus		// (c) 198? BFM Dutch ROMS
+sc1lotusa
 sc1roul		// (c) 198? BFM Dutch ROMS, prelim
 sc1clatt		// (c) 1990 BFM,     Game Card 39-370-196
 sc1clatta
@@ -11871,51 +11898,93 @@
 sc1armad
 sc1bartk
 sc1barcd
+sc1barcda
 sc1bigmt
+sc1btclka
+sc1btclkb
 sc1calyp
 sc1carro
+sc1cdmp
 sc1cshat
+sc1cshata
+sc1cshatb
+sc1cshatc
 sc1cshcd
 sc1cshcda
 sc1cshcdb
 sc1ccoin
-sc1cexpd	// Cash Explosion (Bellfruit) [Dutch]
+sc1cexpd	// Cash Explosion (Bellfruit) (Dutch)
 sc1cexpl	// Cash Explosion (Bellfruit)
+sc1cexpla
+sc1cexplb
+sc1cexplc
+sc1cexpld
 sc1cshwz	// Cash Wise (Bellfruit)
-sc1cshin	// Cashino (Bellfruit) [Dutch]
+sc1cshwza
+sc1cshwzb
+sc1cshwzc
+sc1cshin	// Cashino (Bellfruit) (Dutch)
 sc1china	// China Town Club (Bellfruit)
+sc1chinap
+sc1chinaa
+sc1chinaap
+sc1chinab
+sc1chinabp
 sc1class	// Classic (Bellfruit)
 sc1cwcl		// Clockwise Club (Bellfruit)
 sc1clown	// Clown Around (Bellfruit)
 sc1cl2k		// Club 2000 (Bellfruit)
 sc1cl2k1	// Club 2001 (Bellfruit)
 sc1cl65		// Club 65 Special (Bellfruit)
+sc1cl65a
+sc1cl65ap
+sc1cl65b
+sc1cl65bp
+sc1cl65c
+sc1cl65d
+sc1cl65dp
 sc1clbdm	// Club Diamond (Bellfruit)
 sc1clbxp	// Club Explosion (Bellfruit)
 sc1clbrn	// Club Runner (Bellfruit)
 sc1clbsp	// Club Spinner (Bellfruit)
 sc1clbtm	// Club Temptation (Bellfruit)
+sc1clbtma
 sc1clbw		// Club Wise (Bellfruit)
+sc1clbwa
+sc1clbwb
 sc1copdd	// Cops 'n' Robbers Deluxe (Bellfruit) [Dutch]
 sc1copdx	// Cops 'n' Robbers Deluxe (Bellfruit)
 sc1count	// Count Cash Club (Bellfruit)
+sc1countp
+sc1counta
+sc1countap
+sc1countb
 sc1dago		// Dagobert's Vault (Bellfruit)
 sc1disc		// Discovey (Bellfruit)
+sc1disca
 sc1dblch	// Double Chance (Bellfruit)
+sc1dblcha
 sc1dream	// Dream Machine (Bellfruit)
 sc1final	// Final Touch (Bellfruit)
 sc1flash	// Flash (Bellfruit)
+sc1frpusa
 sc1fruit	// Fruit Lines (Bellfruit)
 sc1frtln	// Fruitlines (Bellfruit)
 sc1funh		// Fun House Club (Bellfruit)
+sc1funhp
+sc1funha
+sc1funhb
 sc1gtime	// Good Times (Bellfruit)
 sc1tiara	// Tiara (Elam)
 sc1gprix	// Grand Prix (Bellfruit)
-sc1gslam	// Grand Slam (Bellfruit) [Dutch]
+sc1gslam	// Grand Slam (Bellfruit) (Dutch)
 sc1happy	// Happy Hour (Bellfruit - Elam)
+sc1hfccp
 sc1impc		// Impact (Bellfruit)
 sc1kings	// Kings Club (Bellfruit)
 sc1linx		// Linx (Bellfruit)
+sc1linxa
+sc1linxp
 sc1magc		// Magic Circle (Bellfruit)
 sc1manha	// Manhattan (Bellfruit)
 sc1mast		// Master Club (Bellfruit)
@@ -11924,36 +11993,67 @@
 sc1olym		// Olympia (Bellfruit)
 sc1orac		// Oracle (Bellfruit)
 sc1pwrl		// Power Lines (Bellfruit)
+sc1pwrla
 sc1rain		// Rainbow (Bellfruit)
 sc1re		// Reel Cash (Bellfruit)
 sc1rese		// Reel Cash SE (Bellfruit)
-sc1revo		// Revolution (Bellfruit) [Dutch]
+sc1revo		// Revolution (Bellfruit) (Dutch)
 sc1rose		// Rose 'n' Crown (Bellfruit)
 sc1sant		// Santana (Bellfruit)
 sc1sat		// Satellite (Bellfruit)
 sc1shan		// Shanghai (Bellfruit)
 sc1spct		// Spectre (Bellfruit)
+sc1spcta
 sc1spit		// Spitfire (Elam)
 sc1ster		// Sterling (Bellfruit)
 sc1str4		// Strike 4 (Bellfruit)
 sc1str4a	//
 sc1sir		// Strike It Rich (Bellfruit)
-sc1sups		// Superstar (Bellfruit) [Dutch]
+sc1sira
+sc1sirb
+sc1sirc
+sc1sups		// Superstar (Bellfruit) (Dutch)
 sc1torn		// Tornado (Bellfruit)
+sc1torna
 sc1tri		// Tri Star (Bellfruit)
+sc1tria
+sc1triap
+sc1trib
+sc1tribp
 sc1typ		// Typhoon Club (Bellfruit)
+sc1typp
 sc1ult		// Ultimate (Bellfruit)
 sc1vent		// Ventura (Bellfruit)
 sc1vict		// Victory (Bellfruit)
 sc1voy		// Voyager (Bellfruit)
-sc1voya		//
+sc1voya
 sc1winfl	// Winfalls (Bellfruit)
 sc1winst	// Winning Streak (Bellfruit)
+sc1winstp
+sc1winsta
+sc1winstb
+sc1winstbp
+sc1winstc
+sc1winstcp
+sc1winstd
+sc1winstdp
+sc1winste
+sc1winstep
+sc1winstf
+sc1winstfp
+sc1winstg
 sc1zep		// Zeppelin (Bellfruit)
 sc1wthn		// Wild Thing (Eurocoin)
 sc1days		// All In A Days Work (Global)
+sc1daysa
 sc1cscl		// Cash Classic (Global)
+sc1cscla
+sc1csclb	//Maygay?
+sc1csclc	//Maygay?
 sc1driv		// Driving School (Global)
+sc1driva
+sc1drivb
+sc1drivc
 sc1vsd		// Vegas Super Deal (Global)
 sc1moonl	// Moon Lite (Bwb)
 sc1ltdv		// Little Devil (Pcp)
@@ -11961,10 +12061,14 @@
 sc1dip		// Diplomat (Eurocoin)
 sc1lamb		// Lambada (Eurocoin)
 sc1reply	// Replay (Eurocoin)
-sc1smoke	//
-sc1ccroc	//
-sc1crocr	//
-sc1btclk	//
+sc1smoke	// Smokey Vs The Bandit (Mdm)
+sc1smokea
+sc1ccroc	// Crazy Crocs (Mdm)
+sc1ccroca
+sc1ccrocb
+sc1ccrocc
+sc1crocr	// Croc And Roll (Mdm)
+sc1btclk	// Beat The Clock (Mdm)
 sc1btbc		// Beat The Bank Club (Bellfruit)
 sc1boncl	// Bonanza Club (Bellfruit)
 sc1clins	// Cash Lines (Bellfruit)
@@ -11983,21 +12087,23 @@
 sc1supfl	// Super Flush (Bellfruit)
 sc1ofs56	// zzz_unk ofs56cp (Bellfruit)
 sc1frpus	// Fruit Pursuit (Bellfruit)
-sc1wof		//
+sc1wof		// Wheel Of Fortune (Global)
 sc1wofa		//
 sc1wofb		//
-sc1crzyc	//
+sc1crzyc	// Crazy Cash (Global)
 sc1crzyca	//
-sc1clbdy	//
+sc1clbdy	// Club Dynamite (Global)
 sc1clbdya	//
-sc1chqfl	//
-sc1s1000	//
+sc1chqfl	// Chequered Flag (Global)
+sc1s1000	// Super 1000 (Deltasoft)
 sc1cdm		// Club Diamond (Crystal)
 sc1hfcc		// Hi-Flyer Club (Crystal)
-sc1twice	//
-sc1chain	//
-sc1potp		//
-sc1potpa	//
+sc1twice	// Twice As Nice (Associated Leisure)
+sc1chain	// Chain Reaction (Bellfruit)
+sc1chainp
+sc1chaina
+sc1potp		// Pick Of The Pack (Bellfruit)
+sc1potpa	// Double Dealer (Bellfruit)?
 sc1scunk	//
 
 // Scorpion 1 + Adder Video board
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2012-02-24 04:31:09.000000000 +0100
+++ src/mame/mame.mak	2012-03-06 04:37:05.000000000 +0100
@@ -892,6 +892,7 @@
 	$(DRIVERS)/pingpong.o $(VIDEO)/pingpong.o \
 	$(DRIVERS)/plygonet.o $(VIDEO)/plygonet.o \
 	$(DRIVERS)/pooyan.o $(VIDEO)/pooyan.o \
+	$(DRIVERS)/pyson.o \
 	$(DRIVERS)/qdrmfgp.o $(VIDEO)/qdrmfgp.o \
 	$(DRIVERS)/rockrage.o $(VIDEO)/rockrage.o \
 	$(DRIVERS)/rocnrope.o $(VIDEO)/rocnrope.o \
diff -Nru src-old/mame/video/armedf.c src/mame/video/armedf.c
--- src-old/mame/video/armedf.c	2012-01-30 15:13:49.000000000 +0100
+++ src/mame/video/armedf.c	2012-03-08 08:39:27.000000000 +0100
@@ -352,11 +352,11 @@
 
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority )
 {
-	UINT16 *buffered_spriteram = machine.generic.buffered_spriteram.u16;
 	armedf_state *state = machine.driver_data<armedf_state>();
+	UINT16 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = 0; offs < machine.generic.spriteram_size / 2; offs += 4)
+	for (offs = 0; offs < state->m_spriteram->bytes() / 2; offs += 4)
 	{
 		int code = buffered_spriteram[offs + 1]; /* ??YX?TTTTTTTTTTT */
 		int flipx = code & 0x2000;
@@ -431,15 +431,3 @@
 
 	return 0;
 }
-
-
-SCREEN_VBLANK( armedf )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/bbusters.c src/mame/video/bbusters.c
--- src-old/mame/video/bbusters.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/bbusters.c	2012-03-08 08:39:27.000000000 +0100
@@ -289,10 +289,10 @@
 	state->m_pf2_tilemap->set_scrolly(0, state->m_pf2_scroll_data[1]);
 
 	state->m_pf2_tilemap->draw(bitmap, cliprect, 0, 0);
-	//draw_sprites(screen.machine(), bitmap, screen.machine().generic.buffered_spriteram2.u16, 2, 0x8, 0x8);
+	//draw_sprites(screen.machine(), bitmap, state->m_spriteram2->buffer(), 2, 0x8, 0x8);
 	state->m_pf1_tilemap->draw(bitmap, cliprect, 0, 0);
-	draw_sprites(screen.machine(), bitmap, screen.machine().generic.buffered_spriteram2.u16, 2, 0, 0);
-	draw_sprites(screen.machine(), bitmap, screen.machine().generic.buffered_spriteram.u16, 1, 0, 0);
+	draw_sprites(screen.machine(), bitmap, state->m_spriteram2->buffer(), 2, 0, 0);
+	draw_sprites(screen.machine(), bitmap, state->m_spriteram->buffer(), 1, 0, 0);
 	state->m_fix_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
@@ -308,7 +308,7 @@
 
 	state->m_pf2_tilemap->draw(bitmap, cliprect, 0, 0);
 	state->m_pf1_tilemap->draw(bitmap, cliprect, 0, 0);
-	draw_sprites(screen.machine(), bitmap, screen.machine().generic.buffered_spriteram.u16, 1, 0, 0);
+	draw_sprites(screen.machine(), bitmap, state->m_spriteram->buffer(), 1, 0, 0);
 	state->m_fix_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/bionicc.c src/mame/video/bionicc.c
--- src-old/mame/video/bionicc.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/bionicc.c	2012-03-08 08:39:27.000000000 +0100
@@ -209,12 +209,12 @@
 
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT16 *buffered_spriteram = machine.generic.buffered_spriteram.u16;
-//  bionicc_state *state = machine.driver_data<bionicc_state>();
+	bionicc_state *state = machine.driver_data<bionicc_state>();
+	UINT16 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 	const gfx_element *gfx = machine.gfx[3];
 
-	for (offs = (machine.generic.spriteram_size - 8) / 2; offs >= 0; offs -= 4)
+	for (offs = (state->m_spriteram->bytes() - 8) / 2; offs >= 0; offs -= 4)
 	{
 		int tile_number = buffered_spriteram[offs] & 0x7ff;
 		if( tile_number != 0x7ff )
@@ -259,14 +259,3 @@
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( bionicc )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/blktiger.c src/mame/video/blktiger.c
--- src-old/mame/video/blktiger.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/blktiger.c	2012-03-08 08:39:27.000000000 +0100
@@ -201,12 +201,12 @@
 
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-//  blktiger_state *state = machine.driver_data<blktiger_state>();
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	blktiger_state *state = machine.driver_data<blktiger_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
 	/* Draw the sprites. */
-	for (offs = machine.generic.spriteram_size - 4;offs >= 0;offs -= 4)
+	for (offs = state->m_spriteram->bytes() - 4;offs >= 0;offs -= 4)
 	{
 		int attr = buffered_spriteram[offs+1];
 		int sx = buffered_spriteram[offs + 3] - ((attr & 0x10) << 4);
@@ -250,14 +250,3 @@
 
 	return 0;
 }
-
-SCREEN_VBLANK( blktiger )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/boogwing.c src/mame/video/boogwing.c
--- src-old/mame/video/boogwing.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/video/boogwing.c	2012-03-08 08:39:27.000000000 +0100
@@ -184,8 +184,8 @@
 	UINT16 priority = decocomn_priority_r(state->m_decocomn, 0, 0xffff);
 
 	/* Draw sprite planes to bitmaps for later mixing */
-	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u16, 0x400, true);
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, true);
+	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2->buffer(), 0x400, true);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, true);
 
 	flip_screen_set(screen.machine(), BIT(flip, 7));
 	deco16ic_pf_update(state->m_deco_tilegen1, state->m_pf1_rowscroll, state->m_pf2_rowscroll);
diff -Nru src-old/mame/video/bosco.c src/mame/video/bosco.c
--- src-old/mame/video/bosco.c	2012-01-21 23:07:28.000000000 +0100
+++ src/mame/video/bosco.c	2012-03-08 10:54:00.000000000 +0100
@@ -135,9 +135,9 @@
 
 	state->m_bg_tilemap->set_scrolldx(3,3);
 
-	machine.generic.spriteram_size = 0x0c;
-	machine.generic.spriteram.u8 = state->m_videoram + 0x03d4;
-	machine.generic.spriteram2.u8 = machine.generic.spriteram.u8 + 0x0800;
+	state->m_spriteram = state->m_videoram + 0x03d4;
+	state->m_spriteram_size = 0x0c;
+	state->m_spriteram2 = state->m_spriteram + 0x0800;
 	state->m_bosco_radarx = state->m_videoram + 0x03f0;
 	state->m_bosco_radary = state->m_bosco_radarx + 0x0800;
 
@@ -191,11 +191,12 @@
 
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT8 *spriteram = machine.generic.spriteram.u8;
-	UINT8 *spriteram_2 = machine.generic.spriteram2.u8;
+	bosco_state *state =  machine.driver_data<bosco_state>();
+	UINT8 *spriteram = state->m_spriteram;
+	UINT8 *spriteram_2 = state->m_spriteram2;
 	int offs;
 
-	for (offs = 0;offs < machine.generic.spriteram_size;offs += 2)
+	for (offs = 0;offs < state->m_spriteram_size;offs += 2)
 	{
 		int sx = spriteram[offs + 1] - 1;
 		int sy = 240 - spriteram_2[offs];
diff -Nru src-old/mame/video/cninja.c src/mame/video/cninja.c
--- src-old/mame/video/cninja.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/cninja.c	2012-03-08 08:39:27.000000000 +0100
@@ -28,7 +28,8 @@
 /* The bootleg sprites are in a different format! */
 static void cninjabl_draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT16 *buffered_spriteram = machine.generic.buffered_spriteram.u16;
+	cninja_state *state = machine.driver_data<cninja_state>();
+	UINT16 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 	int endoffs;
 
@@ -140,7 +141,7 @@
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 2);
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, TILEMAP_DRAW_LAYER1, 2);
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, TILEMAP_DRAW_LAYER0, 4);
-	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400);
+	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	return 0;
 }
@@ -184,7 +185,7 @@
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, TILEMAP_DRAW_OPAQUE, 1);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 2);
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 4);
-	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400);
+	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	return 0;
 }
@@ -235,7 +236,7 @@
 			break;
 	}
 
-	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400);
+	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	return 0;
 }
@@ -262,8 +263,8 @@
 
 	screen.machine().device<decospr_device>("spritegen1")->set_alt_format(true);
 	screen.machine().device<decospr_device>("spritegen2")->set_alt_format(true);
-	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u16, 0x400, true);
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, true);
+	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2->buffer(), 0x400, true);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, true);
 
 
 	/* There is no priority prom on this board, but there is a
diff -Nru src-old/mame/video/commando.c src/mame/video/commando.c
--- src-old/mame/video/commando.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/commando.c	2012-03-08 08:39:27.000000000 +0100
@@ -107,10 +107,11 @@
 
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	commando_state *state = machine.driver_data<commando_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = machine.generic.spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram->bytes() - 4; offs >= 0; offs -= 4)
 	{
 		// bit 1 of attr is not used
 		int attr = buffered_spriteram[offs + 1];
@@ -144,14 +145,3 @@
 	state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( commando )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/cps1.c src/mame/video/cps1.c
--- src-old/mame/video/cps1.c	2012-02-21 19:11:26.000000000 +0100
+++ src/mame/video/cps1.c	2012-03-11 00:51:30.000000000 +0100
@@ -18,162 +18,167 @@
 89626A-4
 89626A-4 DASH
 
-Game                                                     Year  B-board #       B-board PALs      C-board #            CPS-B #          C-board PALs
--------------------------------------------------------  ----  ---------  ---------------------  -----------  -----------------------  ------------
-Forgotten Worlds (World)                                 1988  88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Forgotten Worlds (USA, B-Board 88618B-2)                       88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Forgotten Worlds (USA, B-Board 88621B-2)                       88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Lost Worlds (Japan Old Ver.)                                   88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Lost Worlds (Japan)                                            88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-
-Ghouls'n Ghosts (World)                                  1988  88620-B-?  DM620            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Ghouls'n Ghosts (USA)                                          88620-B-2  DM620            LWIO  None         CPS-B-01  DL-0411-10001  N/A
-Daimakaimura (Japan)                                           88622B-2   DM22A            LWIO  88622-C-1    CPS-B-01  DL-0411-10001  None
-Daimakaimura (Japan Resale Ver.)                               91634B-2   DAM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Strider (USA, B-Board 89624B-2)                          1989  89624B-2   ST24M1           LWIO  88622-C-1/2  CPS-B-01  DL-0411-10001  None
-Strider (USA, B-Board 89624B-3)                                89624B-3   ST24B2           LWIO  88622-C-2    CPS-B-01  DL-0411-10001  None
-Strider Hiryu (Japan)                                          ?          ST22B            ?     ?            CPS-B-01  DL-0411-10001
-Strider Hiryu (Japan Resale Ver.)                              91634B-2   STH63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Dynasty Wars (USA, B-Board 88622B-3)                     1989  88622B-3   TK22B            LWIO  88622-C-2    CPS-B-02  DL-0411-10002  None
-Dynasty Wars (USA, B-Board 89624B-?)                           89624B-?   TK24B1           LWIO? ?            CPS-B-02  DL-0411-10002
-Tenchi wo Kurau (Japan)                                        88622B-3   TK22B            LWIO  88622-C-2    CPS-B-02  DL-0411-10002  None
-Tenchi wo Kurau (Japan Resale Ver.)                            91634B-2   TK163B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Willow (USA Old Ver.)                                    1989  89624B-3   WL24B            LWIO  88622-C-2    CPS-B-03  DL-0411-10003  None
-Willow (USA)                                                   89624B-3   WL24B            LWIO  88622-C-4    CPS-B-03  DL-0411-10003  None
-Willow (Japan)                                                 88622B-3   WL22B            LWIO  88622-C-2    CPS-B-03  DL-0411-10003  None
-
-U.N. Squadron (USA)                                      1989  89624B-3   AR24B            LWIO  88622-C-4    CPS-B-11  DL-0411-10004  None
-Area 88 (Japan)                                                88622B-3   AR22B            LWIO  88622-C-4    CPS-B-11  DL-0411-10004  None
-Area 88 (Japan Resale Ver.)                                    91634B-2   ARA63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Final Fight (World)                                      1989  89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
-Final Fight (USA, set 1)                                       89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
-Final Fight (USA, set 2)                                       89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
-Final Fight (USA 900112)                                       89624B-3   S224B            IOB1  88622-C-5    CPS-B-04@ DL-0411-10001  None
-Final Fight (USA 900613)                                       89624B-3   S224B            IOB1  88622-C-5    CPS-B-05  DL-0411-10006  None
-Final Fight (Japan)                                            ?          S222B            ?     ?            CPS-B-04  DL-0411-10005
-Final Fight (Japan 900112)                                     89625B-1   S222B            LWIO  88622-C-5    CPS-B-01  DL-0411-10001  None
-Final Fight (Japan 900305)                                     ?          S222B            ?     ?            CPS-B-02  DL-0411-10002
-
-1941: Counter Attack (World)                             1990  89624B-?   YI24B            ?     ?            CPS-B-05  DL-0411-10006
-1941: Counter Attack (USA 900227)                              89624B-3   YI24B            IOB1  88622-C-5    CPS-B-05  DL-0411-10006  None
-1941: Counter Attack (Japan)                                   89625B-1   YI22B            LWIO? 88622-C-5    CPS-B-05  DL-0411-10006  None
-
-Mercs (World 900302)                                     1990  89624B-3   O224B            IOB1  90628-C-1    CPS-B-12  DL-0411-10007  C628
-Mercs (USA 900302)                                             89624B-3   O224B            IOB1  90628-C-1    CPS-B-12  DL-0411-10007  C628
-Mercs (USA 900608)                                             89624B-3   O224B            IOB1  90628-C-1    CPS-B-12  DL-0411-10007  C628
-Senjou no Ookami II (Japan 900302)                             89625B-1   O222B            LWIO? 90628-C-1    CPS-B-12  DL-0411-10007  C628
-
-Mega Twins (World 900619)                                1990  89624B-3   CK24B            IOB1  88622-C-5    CPS-B-14  DL-0411-10009  None
-Chiki Chiki Boys (Japan 900619)                                89625B-1   CK22B            ?     ?            CPS-B-14  DL-0411-10009  None
-
-Magic Sword: Heroic Fantasy (World 900623)               1990  89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
-Magic Sword: Heroic Fantasy (World 900725)                     89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
-Magic Sword: Heroic Fantasy (USA 900725)                       89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
-Magic Sword: Heroic Fantasy (Japan 900623)                     89625B-1   MS22B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
-
-Carrier Air Wing (World 901009)                          1990  89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
-Carrier Air Wing (World 901012)                                89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
-Carrier Air Wing (USA 901012)                                  89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
-U.S. Navy (Japan 901012)                                       89625B-1   CA22B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
-
-Nemo (World 901130)                                      1990  89624B-3   NM24B            IOB1  88622-C-5    CPS-B-15  DL-0411-10010  None
-Nemo (Japan 901120)                                            89625B-1   NM22B            ?     ?            CPS-B-15  DL-0411-10010
-
-Street Fighter II: The World Warrior (World 910214)      1991  90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
-Street Fighter II: The World Warrior (World 910228)            90629B-3   STF29            IOB2  90632C-1     CPS-B-18  DL-0411-10013  C632B
-Street Fighter II: The World Warrior (World 910522)            90629B-3   STF29            IOB1  90632C-1     CPS-B-11  DL-0411-10004  C632
-Street Fighter II: The World Warrior (USA 910206)              90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
-Street Fighter II: The World Warrior (USA 910214)              90629B-3   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
-Street Fighter II: The World Warrior (USA 910228)              90629B-3   STF29            IOB2  90632C-1     CPS-B-18  DL-0411-10013  C632B
-Street Fighter II: The World Warrior (USA 910306)              90629B-3   STF29            IOB1  90632C-1     CPS-B-12  DL-0411-10007  C632
-Street Fighter II: The World Warrior (USA 910318)              90629B-?   STF29            IOB1  ?            CPS-B-05  DL-0411-10006  C632
-Street Fighter II: The World Warrior (USA 910411)              90629B-3   STF29            IOB1  90632C-1     CPS-B-15  DL-0411-10010  C632
-Street Fighter II: The World Warrior (USA 910522)              90629B-3   STF29            IOB1  90632C-1     CPS-B-14  DL-0411-10009  C632
-Street Fighter II: The World Warrior (USA 911101)              90629B-3   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
-Street Fighter II: The World Warrior (Japan 910214)            90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
-Street Fighter II: The World Warrior (Japan 910306)            90629B-3   STF29            IOB1  90632C-1     CPS-B-12  DL-0411-10007  C632
-Street Fighter II: The World Warrior (Japan 911210)            90629B-?   STF29            IOB1  ?            CPS-B-13  DL-0411-10008  C632
-
-Three Wonders* (World 910520)                            1991  89624B-3   RT24B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
-Three Wonders* (USA 910520)                                    89624B-3   RT24B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
-Wonder 3* (Japan 910520)                                       89625B-1   RT22B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
-
-The King of Dragons* (World 910711)                      1991  90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-The King of Dragons* (World 910805)                            90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-The King of Dragons* (USA 910910)                              90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-The King of Dragons* (Japan 910805, B-Board 89625B-1)          89625B-1   KD22B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-The King of Dragons* (Japan 910805, B-Board 90629B-3)          90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Captain Commando* (World 911014)                         1991  91635B-2   CC63B    CCPRG   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Captain Commando* (World 911202)                               91635B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632B   IOC1
-Captain Commando* (USA 910928)                                 91635B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Captain Commando* (Japan 910928)                               91634B-2   CC63B    CCPRG   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Captain Commando* (Japan 911202)                               91634B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632B   IOC1
-
-Knights of the Round* (World 911127)                     1991  91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Knights of the Round* (USA 911127)                             91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Knights of the Round* (Japan 911127, B-Board 89625B-1)         89625B-1   KR22B            LWIO  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Knights of the Round* (Japan 911127, B-Board 91634B-2)         91634B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Street Fighter II': Champion Edition (World 920313)      1992  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Champion Edition (World 920513)            91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Champion Edition (USA 920313)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Champion Edition (USA 920513)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Champion Edition (USA 920803)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Champion Edition (Japan 920513)            91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Adventure Quiz Capcom World 2* (Japan 920611)            1992  89625B-1   Q522B            LWIO  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-
-Varth: Operation Thunderstorm (World 920612)             1992  89624B-?   VA24B            IOB1  ?            CPS-B-04  DL-0411-10005
-Varth: Operation Thunderstorm (World 920714)                   89624B-3   VA24B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
-Varth: Operation Thunderstorm (USA 920612)                     91635B-2   VA63B    BPRG1   IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
-Varth: Operation Thunderstorm* (Japan 920714)                  88622B-3   VA22B            LWIO  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-
-Quiz & Dragons: Capcom Quiz Game* (USA 920701)           1992  89625B-1   QD22B            IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Quiz & Dragons: Capcom Quiz Game* (Japan 940921)         1994  91634B-2   QD63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Warriors of Fate* (World 921002)                         1992  91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Warriors of Fate* (World 921031)                               91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Warriors of Fate* (USA 921031)                                 91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Sangokushi II* (Asia 921005)                                   91634B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Tenchi wo Kurau II: Sekiheki no Tatakai* (Japan 921031)        91634B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-
-Street Fighter II': Hyper Fighting (World 921209)        1992  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II': Hyper Fighting (USA 921209)                91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Street Fighter II' Turbo: Hyper Fighting (Japan 921209)        91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Cadillacs and Dinosaurs* (World 930201)                  1993  91635B-2   CD63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Cadillacs and Dinosaurs* (USA 930201)                          91635B-2   CD63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Cadillacs: Kyouryuu Shin Seiki* (Japan 930201)                 91634B-?   CD63B    BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
-
-The Punisher* (World 930422)                             1993  91635B-2   PS63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-The Punisher* (USA 930422)                                     91635B-2   PS63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-The Punisher* (Japan 930422)                                   91634B-?   PS63B    BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
-
-Saturday Night Slam Masters* (World 930713)              1993  91635B-2   MB63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Saturday Night Slam Masters* (USA 930713)                      91635B-2   MB63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Muscle Bomber: The Body Explosion* (Japan 930713)              91634B-?   MB63B    BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
-
-Muscle Bomber Duo: Ultimate Team Battle* (World 931206)  1993  91635B-?   MB63B?   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
-Muscle Bomber Duo: Heat Up Warriors* (Japan 931206)            91634B-?   MB63B?   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
-
-Ken Sei Mogura (Japan ??????)                            1994  ?          ?                ?     ?            ?         ?
-
-Pnickies (Japan 940608)                                  1994  89625B-1   PKB10B           IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Quiz Tonosama no Yabou 2: Zenkoku-ban (Japan 950123)     1995  90629B-3   ?                IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Pang! 3 (Euro 950511)                                    1995  94916-10   CP1B1F,CP1B8K,CP1B9K   92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Pang! 3 (Euro 950601)                                          94916-10   CP1B1F,CP1B8K,CP1B9KA  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Pang! 3: Kaitou Tachi no Karei na Gogo (Japan 950511)          94916-10   CP1B1F,CP1B8K,CP1B9K   92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-
-Mega Man: The Power Battle (CPS1, USA 951006)            1995  91635B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Mega Man: The Power Battle (CPS1, Asia 951006)                 91634B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
-Rockman: The Power Battle (CPS1, Japan 950922)                 91634B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Game                                                       Year  B-board #       B-board PALs       C-board #           CPS-B #          C-board PALs
+---------------------------------------------------------  ----  ---------  ---------------------  -----------  -----------------------  ------------
+Forgotten Worlds (World)                                   1988  88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Forgotten Worlds (USA, B-Board 88618B-2, Rev. A)                 88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Forgotten Worlds (USA, B-Board 88618B-2, Rev. C)                 88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Forgotten Worlds (USA, B-Board 88621B-2, Rev. C)                 88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Lost Worlds (Japan Old Ver.)                                     88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Lost Worlds (Japan)                                              88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+
+Ghouls'n Ghosts (World)                                    1988  88620-B-?  DM620            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Ghouls'n Ghosts (USA)                                            88620-B-2  DM620            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Daimakaimura (Japan)                                             88622B-2   DM22A            LWIO  88622-C-1    CPS-B-01  DL-0411-10001  None
+Daimakaimura (Japan Resale Ver.)                                 91634B-2   DAM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Strider (USA, B-Board 89624B-2)                            1989  89624B-2   ST24M1           LWIO  88622-C-1/2  CPS-B-01  DL-0411-10001  None
+Strider (USA, B-Board 89624B-3)                                  89624B-3   ST24B2           LWIO  88622-C-2    CPS-B-01  DL-0411-10001  None
+Strider Hiryu (Japan)                                            ?          ST22B            ?     ?            CPS-B-01  DL-0411-10001
+Strider Hiryu (Japan Resale Ver.)                                91634B-2   STH63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Dynasty Wars (USA, B-Board 88622B-3)                       1989  88622B-3   TK22B            LWIO  88622-C-2    CPS-B-02  DL-0411-10002  None
+Dynasty Wars (USA, B-Board 89624B-?)                             89624B-?   TK24B1           LWIO? ?            CPS-B-02  DL-0411-10002
+Tenchi wo Kurau (Japan)                                          88622B-3   TK22B            LWIO  88622-C-2    CPS-B-02  DL-0411-10002  None
+Tenchi wo Kurau (Japan Resale Ver.)                              91634B-2   TK163B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Willow (USA Old Ver.)                                      1989  89624B-3   WL24B            LWIO  88622-C-2    CPS-B-03  DL-0411-10003  None
+Willow (USA)                                                     89624B-3   WL24B            LWIO  88622-C-2/4  CPS-B-03  DL-0411-10003  None
+Willow (Japan)                                                   88622B-3   WL22B            LWIO  88622-C-2    CPS-B-03  DL-0411-10003  None
+
+U.N. Squadron (USA)                                        1989  89624B-2   AR24B            LWIO  88622-C-4    CPS-B-11  DL-0411-10004  None
+Area 88 (Japan)                                                  88622B-3   AR22B            LWIO  88622-C-4    CPS-B-11  DL-0411-10004  None
+Area 88 (Japan Resale Ver.)                                      91634B-2   ARA63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Final Fight (World, set 1)                                 1989  89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
+Final Fight (World, set 2)                                       89624B-3   S224B            LWIO  88622-C-5    CPS-B-04  DL-0411-10005  None
+Final Fight (USA, set 1)                                         89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
+Final Fight (USA, set 2)                                         89624B-3   S224B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
+Final Fight (USA 900112)                                         89624B-3   S224B            IOB1  88622-C-5    CPS-B-04@ DL-0411-10001  None
+Final Fight (USA 900613)                                         89624B-3   S224B            IOB1  88622-C-5    CPS-B-05  DL-0411-10006  None
+Final Fight (Japan)                                              ?          S222B            ?     ?            CPS-B-04  DL-0411-10005
+Final Fight (Japan 900112)                                       89625B-1   S222B            LWIO  88622-C-5    CPS-B-01  DL-0411-10001  None
+Final Fight (Japan 900305)                                       ?          S222B            ?     ?            CPS-B-02  DL-0411-10002
+
+1941: Counter Attack (World)                               1990  89624B-?   YI24B            ?     ?            CPS-B-05  DL-0411-10006
+1941: Counter Attack (USA 900227)                                89624B-3   YI24B            IOB1  88622-C-5    CPS-B-05  DL-0411-10006  None
+1941: Counter Attack (Japan)                                     89625B-1   YI22B            LWIO? 88622-C-5    CPS-B-05  DL-0411-10006  None
+
+Mercs (World 900302)                                       1990  89624B-3   O224B            IOB1  90628-C-1    CPS-B-12  DL-0411-10007  C628
+Mercs (USA 900302)                                               89624B-3   O224B            IOB1  90628-C-1/2  CPS-B-12  DL-0411-10007  C628
+Mercs (USA 900608)                                               89624B-3   O224B            IOB1  90628-C-1    CPS-B-12  DL-0411-10007  C628
+Senjou no Ookami II (Japan 900302)                               89625B-1   O222B            LWIO? 90628-C-1    CPS-B-12  DL-0411-10007  C628
+
+Mega Twins (World 900619)                                  1990  89624B-3   CK24B            IOB1  88622-C-5    CPS-B-14  DL-0411-10009  None
+Chiki Chiki Boys (Japan 900619)                                  89625B-1   CK22B            ?     ?            CPS-B-14  DL-0411-10009  None
+
+Magic Sword: Heroic Fantasy (World 900623)                 1990  89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
+Magic Sword: Heroic Fantasy (World 900725)                       89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
+Magic Sword: Heroic Fantasy (USA 900725)                         89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
+Magic Sword: Heroic Fantasy (Japan 900623)                       89625B-1   MS22B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
+
+Carrier Air Wing (World 901009)                            1990  89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
+Carrier Air Wing (World 901012)                                  89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
+Carrier Air Wing (USA 901012)                                    89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
+U.S. Navy (Japan 901012)                                         89625B-1   CA22B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
+
+Nemo (World 901130)                                        1990  89624B-3   NM24B            IOB1  88622-C-5    CPS-B-15  DL-0411-10010  None
+Nemo (Japan 901120)                                              89625B-1   NM22B            ?     ?            CPS-B-15  DL-0411-10010
+
+Street Fighter II: The World Warrior (World 910214)        1991  90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (World 910228)              90629B-3   STF29            IOB2  90632C-1     CPS-B-18  DL-0411-10013  C632B
+Street Fighter II: The World Warrior (World 910522)              90629B-3   STF29            IOB1  90632C-1     CPS-B-11  DL-0411-10004  C632
+Street Fighter II: The World Warrior (USA 910206)                90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (USA 910214)                90629B-3   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (USA 910228)                90629B-3   STF29            IOB2  90632C-1     CPS-B-18  DL-0411-10013  C632B
+Street Fighter II: The World Warrior (USA 910306)                90629B-3   STF29            IOB1  90632C-1     CPS-B-12  DL-0411-10007  C632
+Street Fighter II: The World Warrior (USA 910318)                90629B-3   STF29            IOB1  90632C-1     CPS-B-05  DL-0411-10006  C632
+Street Fighter II: The World Warrior (USA 910411)                90629B-3   STF29            IOB1  90632C-1     CPS-B-15  DL-0411-10010  C632
+Street Fighter II: The World Warrior (USA 910522, Rev. G)        90629B-3   STF29            IOB1  90632C-1     CPS-B-11  DL-0411-10004  C632
+Street Fighter II: The World Warrior (USA 910522, Rev. I)        90629B-3   STF29            IOB1  90632C-1     CPS-B-14  DL-0411-10009  C632
+Street Fighter II: The World Warrior (USA 911101)                90629B-3   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (Japan 910214)              90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (Japan 910306)              90629B-3   STF29            IOB1  90632C-1     CPS-B-12  DL-0411-10007  C632
+Street Fighter II: The World Warrior (Japan 911210)              90629B-?   STF29            IOB1  ?            CPS-B-13  DL-0411-10008  C632
+
+Three Wonders* (World 910520)                              1991  89624B-3   RT24B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
+Three Wonders* (USA 910520)                                      89624B-3   RT24B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
+Wonder 3* (Japan 910520)                                         89625B-1   RT22B            IOB1  90630C-4     CPS-B-21  DL-0921-10014          IOC1
+
+The King of Dragons* (World 910711)                        1991  90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (World 910805)                              90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (USA 910910)                                90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (Japan 910805, B-Board 89625B-1)            89625B-1   KD22B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (Japan 910805, B-Board 90629B-3)            90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Captain Commando* (World 911014)                           1991  91635B-2   CC63B    CCPRG   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Captain Commando* (World 911202)                                 91635B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632B   IOC1
+Captain Commando* (USA 910928)                                   91635B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Captain Commando* (Japan 910928)                                 91634B-2   CC63B    CCPRG   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Captain Commando* (Japan 911202)                                 91634B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632B   IOC1
+
+Knights of the Round* (World 911127)                       1991  91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Knights of the Round* (USA 911127)                               91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Knights of the Round* (Japan 911127, B-Board 89625B-1)           89625B-1   KR22B            LWIO  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Knights of the Round* (Japan 911127, B-Board 91634B-2)           91634B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Street Fighter II': Champion Edition (World 920313)        1992  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (World 920513)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (USA 920313)                91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (USA 920513)                91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (USA 920803)                91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (Japan 920322)              91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (Japan 920513)              91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (Japan 920803)              91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Adventure Quiz Capcom World 2* (Japan 920611)              1992  89625B-1   Q522B            LWIO  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+
+Varth: Operation Thunderstorm (World 920612)               1992  89624B-?   VA24B            IOB1  ?            CPS-B-04  DL-0411-10005
+Varth: Operation Thunderstorm (World 920714)                     89624B-3   VA24B            IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
+Varth: Operation Thunderstorm (USA 920612)                       91635B-2   VA63B    BPRG1   IOB1  88622-C-5    CPS-B-04  DL-0411-10005  None
+Varth: Operation Thunderstorm* (Japan 920714)                    88622B-3   VA22B            LWIO  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+
+Quiz & Dragons: Capcom Quiz Game* (USA 920701)             1992  89625B-1   QD22B            IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Quiz & Dragons: Capcom Quiz Game* (Japan 940921)           1994  91634B-2   QD63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Warriors of Fate* (World 921002)                           1992  91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Warriors of Fate* (World 921031)                                 91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Warriors of Fate* (USA 921031)                                   91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Sangokushi II* (Asia 921005)                                     91634B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Tenchi wo Kurau II: Sekiheki no Tatakai* (Japan 921031)          91634B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+
+Street Fighter II': Hyper Fighting (World 921209)          1992  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Hyper Fighting (USA 921209)                  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II' Turbo: Hyper Fighting (Japan 921209)          91634B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Cadillacs and Dinosaurs* (World 930201)                    1993  91635B-2   CD63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Cadillacs and Dinosaurs* (USA 930201)                            91635B-2   CD63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Cadillacs: Kyouryuu Shin Seiki* (Japan 930201)                   91634B-?   CD63B    BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
+
+The Punisher* (World 930422)                               1993  91635B-2   PS63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+The Punisher* (USA 930422)                                       91635B-2   PS63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+The Punisher* (Japan 930422)                                     91634B-2   PS63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+
+Saturday Night Slam Masters* (World 930713)                1993  91635B-2   MB63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Saturday Night Slam Masters* (USA 930713)                        91635B-2   MB63B    BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
+Muscle Bomber: The Body Explosion* (Japan 930713)                91634B-?   MB63B    BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
+
+Muscle Bomber Duo: Ultimate Team Battle* (World 931206)    1993  91635B-?   MB63B?   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
+Muscle Bomber Duo: Heat Up Warriors* (Japan 931206)              91634B-?   MB63B?   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014          IOC1
+
+Ken Sei Mogura (Japan ??????)                              1994  ?          ?                ?     ?            ?         ?
+
+Pnickies (Japan 940608)                                    1994  89625B-1   PKB10B           IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Quiz Tonosama no Yabou 2: Zenkoku-ban (Japan 950123)       1995  90629B-3   ?                IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Pang! 3 (Euro 950511)                                      1995  94916-10   CP1B1F,CP1B8K,CP1B9K   92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Pang! 3 (Euro 950601)                                            94916-10   CP1B1F,CP1B8K,CP1B9KA  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Pang! 3: Kaitou Tachi no Karei na Gogo (Japan 950511)            94916-10   CP1B1F,CP1B8K,CP1B9K   92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+
+Mega Man: The Power Battle (CPS1, USA 951006)              1995  91635B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Mega Man: The Power Battle (CPS1, Asia 951006)                   91634B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Rockman: The Power Battle (CPS1, Japan 950922)                   91634B-2   RCM63B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
 
 
 @the original number (CPS-B-01) was scratched out and "04" stamped over it.
@@ -1257,6 +1262,7 @@
 	/* name         CPSB          gfx mapper   in2  in3  out2   kludge */
 	{"forgottn",    CPS_B_01,     mapper_LW621 },
 	{"forgottnu",   CPS_B_01,     mapper_LW621 },
+	{"forgottnu1",  CPS_B_01,     mapper_LWCHR },
 	{"forgottnua",  CPS_B_01,     mapper_LWCHR },
 	{"lostwrld",    CPS_B_01,     mapper_LWCHR },
 	{"lostwrldo",   CPS_B_01,     mapper_LWCHR },
@@ -1276,6 +1282,7 @@
 	{"willowo",     CPS_B_03,     mapper_WL24B },
 	{"willowj",     CPS_B_03,     mapper_WL24B },	// wrong, this set uses WL22B, still not dumped
 	{"ffight",      CPS_B_04,     mapper_S224B },
+	{"ffighta",     CPS_B_04,     mapper_S224B },
 	{"ffightu",     CPS_B_04,     mapper_S224B },
 	{"ffightu1",    CPS_B_04,     mapper_S224B },
 	{"ffightua",    CPS_B_01,     mapper_S224B },
@@ -1317,6 +1324,7 @@
 	{"sf2ud",       CPS_B_05,     mapper_STF29,  0x36 },
 	{"sf2ue",       CPS_B_18,     mapper_STF29,  0x3c },
 	{"sf2uf",       CPS_B_15,     mapper_STF29,  0x36 },
+	{"sf2ug",       CPS_B_11,     mapper_STF29,  0x36 },
 	{"sf2ui",       CPS_B_14,     mapper_STF29,  0x36 },
 	{"sf2uk",       CPS_B_17,     mapper_STF29,  0x36 },
 	{"sf2j",        CPS_B_13,     mapper_STF29,  0x36 },
@@ -1353,8 +1361,9 @@
 	{"sf2ceua",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2ceub",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2ceuc",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2cej",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2ceja",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2cejb",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2cejc",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb2",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
 	{"sf2rb3",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
diff -Nru src-old/mame/video/crshrace.c src/mame/video/crshrace.c
--- src-old/mame/video/crshrace.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/crshrace.c	2012-03-08 08:39:27.000000000 +0100
@@ -102,8 +102,8 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect)
 {
 	crshrace_state *state = machine.driver_data<crshrace_state>();
-	UINT16 *buffered_spriteram = machine.generic.buffered_spriteram.u16;
-	UINT16 *buffered_spriteram_2 = machine.generic.buffered_spriteram2.u16;
+	UINT16 *buffered_spriteram = state->m_spriteram->buffer();
+	UINT16 *buffered_spriteram_2 = state->m_spriteram2->buffer();
 	int offs;
 
 	offs = 0;
@@ -219,12 +219,7 @@
 
 SCREEN_VBLANK( crshrace )
 {
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-		buffer_spriteram16_2_w(space, 0, 0, 0xffff);
-	}
+	crshrace_state *state = screen.machine().driver_data<crshrace_state>();
+	state->m_spriteram->vblank_copy_rising(screen, vblank_on);
+	state->m_spriteram2->vblank_copy_rising(screen, vblank_on);
 }
diff -Nru src-old/mame/video/darkseal.c src/mame/video/darkseal.c
--- src-old/mame/video/darkseal.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/darkseal.c	2012-03-08 08:39:27.000000000 +0100
@@ -73,7 +73,7 @@
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 0);
 
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
-	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400);
+	screen.machine().device<decospr_device>("spritegen")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400);
 	deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 
 	return 0;
diff -Nru src-old/mame/video/dassault.c src/mame/video/dassault.c
--- src-old/mame/video/dassault.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/video/dassault.c	2012-03-08 08:39:27.000000000 +0100
@@ -80,8 +80,8 @@
 	UINT16 flip = deco16ic_pf_control_r(state->m_deco_tilegen1, 0, 0xffff);
 	UINT16 priority = decocomn_priority_r(state->m_decocomn, 0, 0xffff);
 
-	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u16, 0x400, false);
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, false);
+	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2->buffer(), 0x400, false);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, false);
 	bitmap_ind16* sprite_bitmap1 = &screen.machine().device<decospr_device>("spritegen1")->get_sprite_temp_bitmap();
 	bitmap_ind16* sprite_bitmap2 = &screen.machine().device<decospr_device>("spritegen2")->get_sprite_temp_bitmap();
 
diff -Nru src-old/mame/video/dec8.c src/mame/video/dec8.c
--- src-old/mame/video/dec8.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/dec8.c	2012-03-08 08:39:27.000000000 +0100
@@ -224,7 +224,8 @@
 
 static void srdarwin_draw_sprites( running_machine& machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int pri )
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	dec8_state *state = machine.driver_data<dec8_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
 	/* Sprites */
diff -Nru src-old/mame/video/deco32.c src/mame/video/deco32.c
--- src-old/mame/video/deco32.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/deco32.c	2012-03-08 08:39:27.000000000 +0100
@@ -20,8 +20,9 @@
 WRITE32_HANDLER( dragngun_spriteram_dma_w )
 {
 	/* DMA spriteram to private sprite chip area, and clear cpu ram */
-	memcpy(space->machine().generic.buffered_spriteram.u32,space->machine().generic.spriteram.u32,space->machine().generic.spriteram_size);
-	memset(space->machine().generic.spriteram.u32,0,0x2000);
+	deco32_state *state = space->machine().driver_data<deco32_state>();
+	state->m_spriteram->copy();
+	memset(state->m_spriteram->live(),0,0x2000);
 }
 
 WRITE32_HANDLER( deco32_ace_ram_w )
@@ -649,7 +650,7 @@
 	{
 		rectangle clip(cliprect.min_x, cliprect.max_x, 8, 247);
 
-		dragngun_draw_sprites(screen.machine(),bitmap,clip,screen.machine().generic.buffered_spriteram.u32);
+		dragngun_draw_sprites(screen.machine(),bitmap,clip,state->m_spriteram->buffer());
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, clip, 0, 0);
 
 	}
diff -Nru src-old/mame/video/dooyong.c src/mame/video/dooyong.c
--- src-old/mame/video/dooyong.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/dooyong.c	2012-03-08 08:39:27.000000000 +0100
@@ -375,10 +375,11 @@
        height only used by pollux, bluehawk and flytiger
        x flip and y flip only used by pollux and flytiger */
 
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	dooyong_state *state = machine.driver_data<dooyong_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = 0; offs < machine.generic.spriteram_size; offs += 32)
+	for (offs = 0; offs < state->m_spriteram->bytes(); offs += 32)
 	{
 		int sx, sy, code, color, pri;
 		int flipx = 0, flipy = 0, height = 0, y;
@@ -442,7 +443,8 @@
 
 static void rshark_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect)
 {
-	UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+	dooyong_state *state = machine.driver_data<dooyong_state>();
+	UINT16 *buffered_spriteram16 = state->m_spriteram16->buffer();
 
 	/* Sprites take 8 16-bit words each in memory:
                   MSB             LSB
@@ -465,7 +467,7 @@
 
 	int offs;
 
-	for (offs = (machine.generic.spriteram_size / 2) - 8; offs >= 0; offs -= 8)
+	for (offs = (state->m_spriteram16->bytes() / 2) - 8; offs >= 0; offs -= 8)
 	{
 		if (buffered_spriteram16[offs] & 0x0001)	/* enable */
 		{
@@ -929,26 +931,3 @@
 	state_save_register_global_array(machine, state->m_fg2scroll8);	// Not used atm
 	state_save_register_global(machine, state->m_rshark_pri);
 }
-
-
-SCREEN_VBLANK( dooyong )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
-
-SCREEN_VBLANK( rshark )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/dynduke.c src/mame/video/dynduke.c
--- src-old/mame/video/dynduke.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/dynduke.c	2012-03-08 08:39:27.000000000 +0100
@@ -140,7 +140,7 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect,int pri)
 {
 	dynduke_state *state = machine.driver_data<dynduke_state>();
-	UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+	UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 	int offs,fx,fy,x,y,color,sprite;
 
 	if (!state->m_sprite_enable) return;
@@ -250,14 +250,3 @@
 
 	return 0;
 }
-
-SCREEN_VBLANK( dynduke )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff); // Could be a memory location instead
-	}
-}
diff -Nru src-old/mame/video/exedexes.c src/mame/video/exedexes.c
--- src-old/mame/video/exedexes.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/exedexes.c	2012-03-08 08:39:27.000000000 +0100
@@ -187,7 +187,7 @@
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority )
 {
 	exedexes_state *state = machine.driver_data<exedexes_state>();
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
 	if (!state->m_objon)
@@ -195,7 +195,7 @@
 
 	priority = priority ? 0x40 : 0x00;
 
-	for (offs = machine.generic.spriteram_size - 32;offs >= 0;offs -= 32)
+	for (offs = state->m_spriteram->bytes() - 32;offs >= 0;offs -= 32)
 	{
 		if ((buffered_spriteram[offs + 1] & 0x40) == priority)
 		{
@@ -244,14 +244,3 @@
 
 	return 0;
 }
-
-SCREEN_VBLANK( exedexes )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/gaelco2.c src/mame/video/gaelco2.c
--- src-old/mame/video/gaelco2.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/gaelco2.c	2012-03-08 08:39:27.000000000 +0100
@@ -264,7 +264,7 @@
 VIDEO_START( gaelco2 )
 {
 	gaelco2_state *state = machine.driver_data<gaelco2_state>();
-	state->m_videoram = machine.generic.spriteram.u16;
+	state->m_videoram = state->m_spriteram->live();
 
 	/* create tilemaps */
 	state->m_pant[0] = tilemap_create(machine, get_tile_info_gaelco2_screen0,tilemap_scan_rows,16,16,64,32);
@@ -285,7 +285,7 @@
 VIDEO_START( gaelco2_dual )
 {
 	gaelco2_state *state = machine.driver_data<gaelco2_state>();
-	state->m_videoram = machine.generic.spriteram.u16;
+	state->m_videoram = state->m_spriteram->live();
 
 	/* create tilemaps */
 	state->m_pant[0] = tilemap_create(machine, get_tile_info_gaelco2_screen0_dual,tilemap_scan_rows,16,16,64,32);
@@ -342,7 +342,7 @@
 static void draw_sprites(screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect, int mask, int xoffs)
 {
 	gaelco2_state *state = screen.machine().driver_data<gaelco2_state>();
-	UINT16 *buffered_spriteram16 = screen.machine().generic.buffered_spriteram.u16;
+	UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 	int j, x, y, ex, ey, px, py;
 	const gfx_element *gfx = screen.machine().gfx[0];
 
@@ -498,17 +498,3 @@
 
 SCREEN_UPDATE_IND16( gaelco2_left ) { return dual_update(screen, bitmap, cliprect, 0); }
 SCREEN_UPDATE_IND16( gaelco2_right ) { return dual_update(screen, bitmap, cliprect, 1); }
-
-
-
-SCREEN_VBLANK( gaelco2 )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		/* sprites are one frame ahead */
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/galaxian.c src/mame/video/galaxian.c
--- src-old/mame/video/galaxian.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/galaxian.c	2012-03-08 10:54:00.000000000 +0100
@@ -462,11 +462,11 @@
 	state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
 
 	/* render the sprites next */
-	sprites_draw(screen.machine(), bitmap, cliprect, &screen.machine().generic.spriteram.u8[0x40]);
+	sprites_draw(screen.machine(), bitmap, cliprect, &state->m_spriteram[0x40]);
 
 	/* if we have bullets to draw, render them following */
 	if (state->m_draw_bullet_ptr != NULL)
-		bullets_draw(screen.machine(), bitmap, cliprect, &screen.machine().generic.spriteram.u8[0x60]);
+		bullets_draw(screen.machine(), bitmap, cliprect, &state->m_spriteram[0x60]);
 
 	return 0;
 }
@@ -477,7 +477,8 @@
 	SCREEN_UPDATE32_CALL(galaxian);
 
 	/* zigzag has an extra sprite generator instead of bullets (note: ideally, this should be rendered in parallel) */
-	sprites_draw(screen.machine(), bitmap, cliprect, &screen.machine().generic.spriteram.u8[0x60]);
+	galaxian_state *state = screen.machine().driver_data<galaxian_state>();
+	sprites_draw(screen.machine(), bitmap, cliprect, &state->m_spriteram[0x60]);
 
 	return 0;
 }
@@ -497,7 +498,7 @@
 	UINT8 x = tile_index & 0x1f;
 
 	UINT16 code = videoram[tile_index];
-	UINT8 attrib = machine.generic.spriteram.u8[x*2+1];
+	UINT8 attrib = state->m_spriteram[x*2+1];
 	UINT8 color = attrib & 7;
 
 	if (state->m_extend_tile_info_ptr != NULL)
@@ -527,7 +528,7 @@
 	space->machine().primary_screen->update_now();
 
 	/* store the data */
-	space->machine().generic.spriteram.u8[offset] = data;
+	state->m_spriteram[offset] = data;
 
 	/* the first $40 bytes affect the tilemap */
 	if (offset < 0x40)
diff -Nru src-old/mame/video/gng.c src/mame/video/gng.c
--- src-old/mame/video/gng.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/gng.c	2012-03-08 08:39:27.000000000 +0100
@@ -110,12 +110,13 @@
 
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	gng_state *state = machine.driver_data<gng_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	const gfx_element *gfx = machine.gfx[2];
 	int offs;
 
 
-	for (offs = machine.generic.spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram->bytes() - 4; offs >= 0; offs -= 4)
 	{
 		UINT8 attributes = buffered_spriteram[offs + 1];
 		int sx = buffered_spriteram[offs + 3] - 0x100 * (attributes & 0x01);
@@ -149,14 +150,3 @@
 	state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( gng )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/gticlub.c src/mame/video/gticlub.c
--- src-old/mame/video/gticlub.c	2012-02-26 15:31:24.000000000 +0100
+++ src/mame/video/gticlub.c	2012-03-07 21:23:54.000000000 +0100
@@ -1567,7 +1567,7 @@
 {
 	bitmap.fill(screen.machine().pens[0], cliprect);
 
-	if (strcmp(screen.tag(), "lscreen") == 0)
+	if (strcmp(screen.tag(), ":lscreen") == 0)
 	{
 		device_t *k001604 = screen.machine().device("k001604_1");
 		device_t *voodoo = screen.machine().device("voodoo0");
@@ -1578,7 +1578,7 @@
 
 		k001604_draw_front_layer(k001604, bitmap, cliprect);
 	}
-	else if (strcmp(screen.tag(), "rscreen") == 0)
+	else if (strcmp(screen.tag(), ":rscreen") == 0)
 	{
 		device_t *k001604 = screen.machine().device("k001604_2");
 		device_t *voodoo = screen.machine().device("voodoo1");
diff -Nru src-old/mame/video/hcastle.c src/mame/video/hcastle.c
--- src-old/mame/video/hcastle.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/hcastle.c	2012-03-08 08:39:27.000000000 +0100
@@ -179,9 +179,9 @@
 	if (offset == 3)
 	{
 		if ((data & 0x8) == 0)
-			buffer_spriteram(space->machine(), space->machine().generic.spriteram.u8 + 0x800, 0x800);
+			state->m_spriteram->copy(0x800, 0x800);
 		else
-			buffer_spriteram(space->machine(), space->machine().generic.spriteram.u8, 0x800);
+			state->m_spriteram->copy(0x000, 0x800);
 	}
 	else if (offset == 7)
 	{
@@ -197,9 +197,9 @@
 	if (offset == 3)
 	{
 		if ((data & 0x8) == 0)
-			buffer_spriteram_2(space->machine(), space->machine().generic.spriteram2.u8 + 0x800, 0x800);
+			state->m_spriteram2->copy(0x800, 0x800);
 		else
-			buffer_spriteram_2(space->machine(), space->machine().generic.spriteram2.u8, 0x800);
+			state->m_spriteram2->copy(0x000, 0x800);
 	}
 	else if (offset == 7)
 	{
@@ -264,16 +264,16 @@
 	if ((state->m_gfx_bank & 0x04) == 0)
 	{
 		state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
-		draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u8, 0);
-		draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u8, 1);
+		draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0);
+		draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram2->buffer(), 1);
 		state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
 	}
 	else
 	{
 		state->m_bg_tilemap->draw(bitmap, cliprect, 0, 0);
 		state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
-		draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u8, 0);
-		draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u8, 1);
+		draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0);
+		draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram2->buffer(), 1);
 	}
 	return 0;
 }
diff -Nru src-old/mame/video/kaneko16.c src/mame/video/kaneko16.c
--- src-old/mame/video/kaneko16.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/kaneko16.c	2012-03-08 10:54:00.000000000 +0100
@@ -371,13 +371,13 @@
 static int kaneko16_parse_sprite_type012(running_machine &machine, int i, struct tempsprite *s)
 {
 	kaneko16_state *state = machine.driver_data<kaneko16_state>();
-	UINT16 *spriteram16 = machine.generic.spriteram.u16;
+	UINT16 *spriteram16 = state->m_spriteram;
 	int attr, xoffs, offs;
 
 	if (state->m_sprite_type == 2)	offs = i * 16/2 + 0x8/2;
 	else							offs = i * 8/2;
 
-	if (offs >= (machine.generic.spriteram_size/2))	return -1;
+	if (offs >= (state->m_spriteram.bytes()/2))	return -1;
 
 	attr			=		spriteram16[offs + 0];
 	s->code			=		spriteram16[offs + 1];
diff -Nru src-old/mame/video/karnov.c src/mame/video/karnov.c
--- src-old/mame/video/karnov.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/karnov.c	2012-03-08 08:39:27.000000000 +0100
@@ -127,7 +127,7 @@
 {
 	karnov_state *state = screen.machine().driver_data<karnov_state>();
 	draw_background(screen.machine(), bitmap, cliprect);
-	screen.machine().device<deco_karnovsprites_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect,  screen.machine().generic.buffered_spriteram.u16, 0x800, 0);
+	screen.machine().device<deco_karnovsprites_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0x800, 0);
 	state->m_fix_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/lastduel.c src/mame/video/lastduel.c
--- src-old/mame/video/lastduel.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/lastduel.c	2012-03-08 08:39:27.000000000 +0100
@@ -222,7 +222,7 @@
 {
 	lastduel_state *state = machine.driver_data<lastduel_state>();
 
-	UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+	UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 	int offs;
 
 	if (!state->m_sprite_pri_mask)
@@ -305,17 +305,3 @@
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( lastduel )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		/* Spriteram is always 1 frame ahead, suggesting buffering.  I can't find
-            a register to control this so I assume it happens automatically
-            every frame at the end of vblank */
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/legionna.c src/mame/video/legionna.c
--- src-old/mame/video/legionna.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/legionna.c	2012-03-08 08:39:27.000000000 +0100
@@ -254,7 +254,7 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect)
 {
 	legionna_state *state = machine.driver_data<legionna_state>();
-	UINT16 *spriteram16 = machine.generic.spriteram.u16;
+	UINT16 *spriteram16 = state->m_spriteram;
 	int offs,fx,fy,x,y,color,sprite,cur_pri;
 	int dx,dy,ax,ay;
 	int pri_mask;
diff -Nru src-old/mame/video/lemmings.c src/mame/video/lemmings.c
--- src-old/mame/video/lemmings.c	2012-01-25 22:40:14.000000000 +0100
+++ src/mame/video/lemmings.c	2012-03-08 08:39:27.000000000 +0100
@@ -33,25 +33,20 @@
 VIDEO_START( lemmings )
 {
 	lemmings_state *state = machine.driver_data<lemmings_state>();
-	state->m_bitmap0 = auto_bitmap_ind16_alloc(machine, 2048, 256);
 	state->m_vram_tilemap = tilemap_create(machine, get_tile_info, tilemap_scan_cols, 8, 8, 64, 32);
 
-	state->m_vram_buffer = auto_alloc_array(machine, UINT8, 2048 * 64); /* 64 bytes per VRAM character */
-	state->m_sprite_triple_buffer_0 = auto_alloc_array(machine, UINT16, 0x800 / 2);
-	state->m_sprite_triple_buffer_1 = auto_alloc_array(machine, UINT16, 0x800 / 2);
-
 	state->m_vram_tilemap->set_transparent_pen(0);
-	state->m_bitmap0->fill(0x100);
+	state->m_bitmap0.fill(0x100);
 
 	gfx_element_set_source(machine.gfx[2], state->m_vram_buffer);
 
 	machine.device<decospr_device>("spritegen")->alloc_sprite_bitmap();
 	machine.device<decospr_device>("spritegen2")->alloc_sprite_bitmap();
 
-	state->save_item(NAME(*state->m_bitmap0));
-	state->save_pointer(NAME(state->m_vram_buffer), 2048 * 64);
-	state->save_pointer(NAME(state->m_sprite_triple_buffer_0), 0x800 / 2);
-	state->save_pointer(NAME(state->m_sprite_triple_buffer_1), 0x800 / 2);
+	state->save_item(NAME(state->m_bitmap0));
+	state->save_item(NAME(state->m_vram_buffer));
+	state->save_item(NAME(state->m_sprite_triple_buffer_0));
+	state->save_item(NAME(state->m_sprite_triple_buffer_1));
 }
 
 SCREEN_VBLANK( lemmings )
@@ -60,9 +55,8 @@
 	if (vblank_on)
 	{
 		lemmings_state *state = screen.machine().driver_data<lemmings_state>();
-
-		memcpy(state->m_sprite_triple_buffer_0, screen.machine().generic.buffered_spriteram.u16, 0x800);
-		memcpy(state->m_sprite_triple_buffer_1, screen.machine().generic.buffered_spriteram2.u16, 0x800);
+		memcpy(state->m_sprite_triple_buffer_0, state->m_spriteram->buffer(), 0x800);
+		memcpy(state->m_sprite_triple_buffer_1, state->m_spriteram2->buffer(), 0x800);
 	}
 }
 
@@ -87,8 +81,8 @@
 	if (sx > 2047 || sy > 255)
 		return;
 
-	state->m_bitmap0->pix16(sy, sx + 0) = ((src >> 8) & 0xf) | 0x100;
-	state->m_bitmap0->pix16(sy, sx + 1) = ((src >> 0) & 0xf) | 0x100;
+	state->m_bitmap0.pix16(sy, sx + 0) = ((src >> 8) & 0xf) | 0x100;
+	state->m_bitmap0.pix16(sy, sx + 1) = ((src >> 0) & 0xf) | 0x100;
 }
 
 // RAM based tiles for the FG tilemap
@@ -158,17 +152,17 @@
 	/* Pixel layer can be windowed in hardware (two player mode) */
 	if ((state->m_control_data[6] & 2) == 0)
 	{
-		lemmings_copy_bitmap(screen.machine(), bitmap, *state->m_bitmap0, &x1, &y, cliprect);
+		lemmings_copy_bitmap(screen.machine(), bitmap, state->m_bitmap0, &x1, &y, cliprect);
 	}
 	else
 	{
 		rect.max_x = 159;
 		rect.min_x = 0;
-		lemmings_copy_bitmap(screen.machine(), bitmap, *state->m_bitmap0, &x0, &y, rect);
+		lemmings_copy_bitmap(screen.machine(), bitmap, state->m_bitmap0, &x0, &y, rect);
 
 		rect.max_x = 319;
 		rect.min_x = 160;
-		lemmings_copy_bitmap(screen.machine(), bitmap, *state->m_bitmap0, &x1, &y, rect);
+		lemmings_copy_bitmap(screen.machine(), bitmap, state->m_bitmap0, &x1, &y, rect);
 	}
 
 	screen.machine().device<decospr_device>("spritegen2")->inefficient_copy_sprite_bitmap(bitmap, cliprect, 0x0800, 0x0800, 0x200, 0xff);
diff -Nru src-old/mame/video/lwings.c src/mame/video/lwings.c
--- src-old/mame/video/lwings.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/lwings.c	2012-03-08 08:39:27.000000000 +0100
@@ -186,10 +186,11 @@
 
 static void lwings_draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	lwings_state *state = machine.driver_data<lwings_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = machine.generic.spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram->bytes() - 4; offs >= 0; offs -= 4)
 	{
 		if (is_sprite_on(buffered_spriteram, offs))
 		{
@@ -223,10 +224,10 @@
 static void trojan_draw_sprites( running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
 	lwings_state *state = machine.driver_data<lwings_state>();
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = machine.generic.spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram->bytes() - 4; offs >= 0; offs -= 4)
 	{
 		if (is_sprite_on(buffered_spriteram, offs))
 		{
@@ -290,14 +291,3 @@
 	state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( lwings )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/m92.c src/mame/video/m92.c
--- src-old/mame/video/m92.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/m92.c	2012-03-08 08:39:27.000000000 +0100
@@ -78,7 +78,7 @@
 	if (offset==4)
 	{
 		/* this implementation is not accurate: still some delayed sprites in gunforc2 (might be another issue?) */
-		buffer_spriteram16_w(space,0,0,0xffff);
+		state->m_spriteram->copy();
 		state->m_sprite_buffer_busy = 0;
 
 		/* Pixel clock is 26.6666MHz (some boards 27MHz??), we have 0x800 bytes, or 0x400 words to copy from
@@ -289,8 +289,8 @@
 
 	machine.generic.paletteram.u16 = auto_alloc_array(machine, UINT16, 0x1000/2);
 
-	memset(machine.generic.spriteram.u16,0,0x800);
-	memset(machine.generic.buffered_spriteram.u16,0,0x800);
+	memset(state->m_spriteram->live(),0,0x800);
+	memset(state->m_spriteram->buffer(),0,0x800);
 
 	state->save_item(NAME(state->m_pf_master_control));
 	state->save_item(NAME(state->m_videocontrol));
@@ -326,7 +326,7 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect)
 {
 	m92_state *state = machine.driver_data<m92_state>();
-	UINT16 *source = machine.generic.buffered_spriteram.u16;
+	UINT16 *source = state->m_spriteram->buffer();
 	int offs, layer;
 
 	for (layer = 0; layer < 8; layer++)
@@ -400,7 +400,7 @@
 static void ppan_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect)
 {
 	m92_state *state = machine.driver_data<m92_state>();
-	UINT16 *source = machine.generic.spriteram.u16; // sprite buffer control is never triggered
+	UINT16 *source = state->m_spriteram->buffer(); // sprite buffer control is never triggered
 	int offs, layer;
 
 	for (layer = 0; layer < 8; layer++)
diff -Nru src-old/mame/video/mcr.c src/mame/video/mcr.c
--- src-old/mame/video/mcr.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/mcr.c	2012-03-08 10:54:00.000000000 +0100
@@ -257,12 +257,13 @@
 
 static void render_sprites_91399(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect)
 {
-	UINT8 *spriteram = machine.generic.spriteram.u8;
+	mcr_state *state = machine.driver_data<mcr_state>();
+	UINT8 *spriteram = state->m_spriteram;
 	const gfx_element *gfx = machine.gfx[1];
 	int offs;
 
 	/* render the sprites into the bitmap, ORing together */
-	for (offs = 0; offs < machine.generic.spriteram_size; offs += 4)
+	for (offs = 0; offs < state->m_spriteram.bytes(); offs += 4)
 	{
 		int code, x, y, sx, sy, hflip, vflip;
 
@@ -329,12 +330,13 @@
 
 static void render_sprites_91464(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int primask, int sprmask, int colormask)
 {
-	UINT8 *spriteram = machine.generic.spriteram.u8;
+	mcr_state *state = machine.driver_data<mcr_state>();
+	UINT8 *spriteram = state->m_spriteram;
 	const gfx_element *gfx = machine.gfx[1];
 	int offs;
 
 	/* render the sprites into the bitmap, working from topmost to bottommost */
-	for (offs = machine.generic.spriteram_size - 4; offs >= 0; offs -= 4)
+	for (offs = state->m_spriteram.bytes() - 4; offs >= 0; offs -= 4)
 	{
 		int code, color, x, y, sx, sy, hflip, vflip;
 
diff -Nru src-old/mame/video/pacman.c src/mame/video/pacman.c
--- src-old/mame/video/pacman.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/pacman.c	2012-03-08 10:54:00.000000000 +0100
@@ -221,10 +221,10 @@
 	else
 		state->m_bg_tilemap->draw(bitmap, cliprect, TILEMAP_DRAW_OPAQUE,0);
 
-	if( screen.machine().generic.spriteram_size )
+	if( state->m_spriteram != NULL )
 	{
-		UINT8 *spriteram = screen.machine().generic.spriteram.u8;
-		UINT8 *spriteram_2 = screen.machine().generic.spriteram2.u8;
+		UINT8 *spriteram = state->m_spriteram;
+		UINT8 *spriteram_2 = state->m_spriteram2;
 		int offs;
 
 		rectangle spriteclip(2*8, 34*8-1, 0*8, 28*8-1);
@@ -232,7 +232,7 @@
 
 		/* Draw the sprites. Note that it is important to draw them exactly in this */
 		/* order, to have the correct priorities. */
-		for (offs = screen.machine().generic.spriteram_size - 2;offs > 2*2;offs -= 2)
+		for (offs = state->m_spriteram.bytes() - 2;offs > 2*2;offs -= 2)
 		{
 			int color;
 			int sx,sy;
@@ -414,13 +414,13 @@
 SCREEN_UPDATE_IND16( s2650games )
 {
 	pacman_state *state = screen.machine().driver_data<pacman_state>();
-	UINT8 *spriteram = screen.machine().generic.spriteram.u8;
-	UINT8 *spriteram_2 = screen.machine().generic.spriteram2.u8;
+	UINT8 *spriteram = state->m_spriteram;
+	UINT8 *spriteram_2 = state->m_spriteram2;
 	int offs;
 
 	state->m_bg_tilemap->draw(bitmap, cliprect, 0,0);
 
-	for (offs = screen.machine().generic.spriteram_size - 2;offs > 2*2;offs -= 2)
+	for (offs = state->m_spriteram.bytes() - 2;offs > 2*2;offs -= 2)
 	{
 		int color;
 		int sx,sy;
@@ -432,7 +432,7 @@
 
 		/* TODO: ?? */
 		drawgfx_transmask(bitmap,cliprect,screen.machine().gfx[1],
-				(spriteram[offs] >> 2) | ((state->m_s2650games_spriteram[offs] & 3) << 6),
+				(spriteram[offs] >> 2) | ((state->m_s2650_spriteram[offs] & 3) << 6),
 				color,
 				spriteram[offs] & 1,spriteram[offs] & 2,
 				sx,sy,
@@ -452,7 +452,7 @@
 
 		/* TODO: ?? */
 		drawgfx_transmask(bitmap,cliprect,screen.machine().gfx[1],
-				(spriteram[offs] >> 2) | ((state->m_s2650games_spriteram[offs] & 3)<<6),
+				(spriteram[offs] >> 2) | ((state->m_s2650_spriteram[offs] & 3)<<6),
 				color,
 				spriteram[offs] & 1,spriteram[offs] & 2,
 				sx,sy + state->m_xoffsethack,
diff -Nru src-old/mame/video/psikyosh.c src/mame/video/psikyosh.c
--- src-old/mame/video/psikyosh.c	2012-02-06 02:30:22.000000000 +0100
+++ src/mame/video/psikyosh.c	2012-03-08 08:39:27.000000000 +0100
@@ -1085,7 +1085,7 @@
 
 	psikyosh_state *state = machine.driver_data<psikyosh_state>();
 	const gfx_element *gfx;
-	UINT32 *src = machine.generic.buffered_spriteram.u32; /* Use buffered spriteram */
+	UINT32 *src = state->m_spriteram->buffer(); /* Use buffered spriteram */
 	UINT16 *list = (UINT16 *)src + 0x3800 / 2;
 	UINT16 listlen = 0x800/2;
 	UINT16 *zoom_table = (UINT16 *)state->m_zoomram;
@@ -1306,14 +1306,3 @@
 	}
 	return 0;
 }
-
-SCREEN_VBLANK( psikyosh )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-		buffer_spriteram32_w(space, 0, 0, 0xffffffff);
-	}
-}
-
diff -Nru src-old/mame/video/raiden.c src/mame/video/raiden.c
--- src-old/mame/video/raiden.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/raiden.c	2012-03-08 08:39:27.000000000 +0100
@@ -122,7 +122,7 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect,int pri_mask)
 {
 	raiden_state *state = machine.driver_data<raiden_state>();
-	UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+	UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 	int offs,fx,fy,x,y,color,sprite;
 
 	for (offs = 0x1000/2-4;offs >= 0;offs -= 4)
diff -Nru src-old/mame/video/rdpblend.h src/mame/video/rdpblend.h
--- src-old/mame/video/rdpblend.h	2012-02-11 17:05:10.000000000 +0100
+++ src/mame/video/rdpblend.h	2012-02-29 10:13:22.000000000 +0100
@@ -3,10 +3,10 @@
 
 #include "emu.h"
 
-class OtherModesT;
-class MiscStateT;
+struct OtherModesT;
+struct MiscStateT;
 class n64_rdp;
-class rdp_span_aux;
+struct rdp_span_aux;
 class Color;
 struct rdp_poly_state;
 
diff -Nru src-old/mame/video/rdptpipe.h src/mame/video/rdptpipe.h
--- src-old/mame/video/rdptpipe.h	2012-02-19 12:21:36.000000000 +0100
+++ src/mame/video/rdptpipe.h	2012-02-29 10:13:22.000000000 +0100
@@ -3,10 +3,10 @@
 
 #include "emu.h"
 
-class OtherModesT;
-class MiscStateT;
+struct OtherModesT;
+struct MiscStateT;
 class Color;
-class rdp_span_aux;
+struct rdp_span_aux;
 struct rdp_poly_state;
 
 class N64TexturePipeT
diff -Nru src-old/mame/video/rohga.c src/mame/video/rohga.c
--- src-old/mame/video/rohga.c	2012-02-01 20:38:44.000000000 +0100
+++ src/mame/video/rohga.c	2012-03-08 08:39:27.000000000 +0100
@@ -14,15 +14,11 @@
 	// Spriteram seems to be triple buffered (no sprite lag on real pcb, but there
 	// is on driver with only double buffering)
 	rohga_state *state = space->machine().driver_data<rohga_state>();
-	memcpy(state->m_spriteram, space->machine().generic.buffered_spriteram.u16, 0x800);
-	memcpy(space->machine().generic.buffered_spriteram.u16, space->machine().generic.spriteram.u16, 0x800);
+	state->m_spriteram->copy();
 }
 
 VIDEO_START( rohga )
 {
-	rohga_state *state = machine.driver_data<rohga_state>();
-	state->m_spriteram = auto_alloc_array(machine, UINT16, 0x800/2);
-	state->save_pointer(NAME(state->m_spriteram), 0x800/2);
 	machine.device<decospr_device>("spritegen1")->set_col_callback(rohga_col_callback);
 	machine.device<decospr_device>("spritegen1")->set_pri_callback(rohga_pri_callback);
 }
@@ -109,7 +105,7 @@
 		break;
 	}
 
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, true);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, true);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 
 	return 0;
@@ -176,8 +172,8 @@
 	UINT16 priority = decocomn_priority_r(state->m_decocomn, 0, 0xffff);
 
 	/* draw sprite gfx to temp bitmaps */
-	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u16, 0x400, true);
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, true);
+	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2->buffer(), 0x400, true);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, true);
 
 	/* Update playfields */
 	flip_screen_set(screen.machine(), BIT(flip, 7));
@@ -213,8 +209,8 @@
 	/* draw sprite gfx to temp bitmaps */
 	screen.machine().device<decospr_device>("spritegen1")->set_alt_format(true);
 	screen.machine().device<decospr_device>("spritegen2")->set_alt_format(true);
-	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram2.u16, 0x400, false);
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0x400, false);
+	screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2->buffer(), 0x400, false);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram->buffer(), 0x400, false);
 
 	/* Update playfields */
 	flip_screen_set(screen.machine(), BIT(flip, 7));
diff -Nru src-old/mame/video/sidearms.c src/mame/video/sidearms.c
--- src-old/mame/video/sidearms.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/sidearms.c	2012-03-08 08:39:27.000000000 +0100
@@ -176,10 +176,10 @@
 
 static void draw_sprites_region(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int start_offset, int end_offset )
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	sidearms_state *state = machine.driver_data<sidearms_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	const gfx_element *gfx = machine.gfx[2];
 	int offs, attr, color, code, x, y, flipx, flipy;
-	sidearms_state *state = machine.driver_data<sidearms_state>();
 
 	flipy = flipx = state->m_flipon;
 
@@ -365,14 +365,3 @@
 		state->m_fg_tilemap->draw(bitmap, cliprect, 0, 0);
 	return 0;
 }
-
-SCREEN_VBLANK( sidearms )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space, 0, 0);
-	}
-}
diff -Nru src-old/mame/video/slapfght.c src/mame/video/slapfght.c
--- src-old/mame/video/slapfght.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/slapfght.c	2012-03-08 08:39:27.000000000 +0100
@@ -142,7 +142,7 @@
 		int i;
 		for (i=0; i<0x800; i++)
 		{
-			logerror("Offset:%03x   TileRAM:%02x   AttribRAM:%02x   SpriteRAM:%02x\n",i, state->m_slapfight_videoram[i],state->m_slapfight_colorram[i],machine.generic.spriteram.u8[i]);
+			logerror("Offset:%03x   TileRAM:%02x   AttribRAM:%02x   SpriteRAM:%02x\n",i, state->m_slapfight_videoram[i],state->m_slapfight_colorram[i],state->m_spriteram->live()[i]);
 		}
 	}
 #endif
@@ -156,10 +156,10 @@
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority_to_display )
 {
 	slapfght_state *state = machine.driver_data<slapfght_state>();
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
-	for (offs = 0;offs < machine.generic.spriteram_size;offs += 4)
+	for (offs = 0;offs < state->m_spriteram->bytes();offs += 4)
 	{
 		int sx, sy;
 
@@ -212,7 +212,7 @@
 SCREEN_UPDATE_IND16( slapfight )
 {
 	slapfght_state *state = screen.machine().driver_data<slapfght_state>();
-	UINT8 *buffered_spriteram = screen.machine().generic.buffered_spriteram.u8;
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
 	screen.machine().tilemap().set_flip_all(state->m_flipscreen ? (TILEMAP_FLIPY | TILEMAP_FLIPX) : 0);
@@ -232,7 +232,7 @@
 	state->m_pf1_tilemap->draw(bitmap, cliprect, 0,0);
 
 	/* Draw the sprites */
-	for (offs = 0;offs < screen.machine().generic.spriteram_size;offs += 4)
+	for (offs = 0;offs < state->m_spriteram->bytes();offs += 4)
 	{
 		if (state->m_flipscreen)
 			drawgfx_transpen(bitmap,cliprect,screen.machine().gfx[2],
diff -Nru src-old/mame/video/srumbler.c src/mame/video/srumbler.c
--- src-old/mame/video/srumbler.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/srumbler.c	2012-03-08 08:39:27.000000000 +0100
@@ -115,11 +115,12 @@
 
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect)
 {
-	UINT8 *buffered_spriteram = machine.generic.buffered_spriteram.u8;
+	srumbler_state *state = machine.driver_data<srumbler_state>();
+	UINT8 *buffered_spriteram = state->m_spriteram->buffer();
 	int offs;
 
 	/* Draw the sprites. */
-	for (offs = machine.generic.spriteram_size-4; offs>=0;offs -= 4)
+	for (offs = state->m_spriteram->bytes()-4; offs>=0;offs -= 4)
 	{
 		/* SPRITES
         =====
@@ -169,14 +170,3 @@
 	state->m_fg_tilemap->draw(bitmap, cliprect, 0,0);
 	return 0;
 }
-
-SCREEN_VBLANK( srumbler )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram_w(space,0,0);
-	}
-}
diff -Nru src-old/mame/video/sshangha.c src/mame/video/sshangha.c
--- src-old/mame/video/sshangha.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/sshangha.c	2012-03-08 10:54:00.000000000 +0100
@@ -33,11 +33,11 @@
 {
 	sshangha_state *state = screen.machine().driver_data<sshangha_state>();
 
-	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, screen.machine().generic.spriteram.u16, 0x800, true);
+	screen.machine().device<decospr_device>("spritegen1")->draw_sprites(bitmap, cliprect, state->m_spriteram, 0x800, true);
 
 	// I'm pretty sure only the original has the 2nd spriteram, used for the Japanese text on the 2nd scene (non-scrolling text) in the intro of the quest (3rd in JPN) mode
-	if (screen.machine().generic.spriteram2.u16)
-		screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, screen.machine().generic.spriteram2.u16, 0x800, true);
+	if (state->m_spriteram2 != NULL)
+		screen.machine().device<decospr_device>("spritegen2")->draw_sprites(bitmap, cliprect, state->m_spriteram2, 0x800, true);
 
 	screen.machine().tilemap().set_flip_all(flip_screen_x_get(screen.machine()) ? (TILEMAP_FLIPY | TILEMAP_FLIPX) : 0);
 
@@ -57,7 +57,7 @@
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	}
 
-	if (screen.machine().generic.spriteram2.u16)
+	if (state->m_spriteram2 != NULL)
 		screen.machine().device<decospr_device>("spritegen2")->inefficient_copy_sprite_bitmap(bitmap, cliprect, 0x0000, 0x0000, 0, 0x1ff);
 
 	screen.machine().device<decospr_device>("spritegen1")->inefficient_copy_sprite_bitmap(bitmap, cliprect, 0x0000, 0x0200, 0, 0x1ff);
diff -Nru src-old/mame/video/suprnova.c src/mame/video/suprnova.c
--- src-old/mame/video/suprnova.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/suprnova.c	2012-03-08 10:54:00.000000000 +0100
@@ -631,7 +631,7 @@
 	state->m_sprite_bitmap.fill(0x0000, cliprect);
 
 	if (state->m_alt_enable_sprites)
-		state->m_spritegen->skns_draw_sprites(screen.machine(), state->m_sprite_bitmap, cliprect, screen.machine().generic.spriteram.u32, screen.machine().generic.spriteram_size, screen.machine().region("gfx1")->base(), screen.machine().region ("gfx1")->bytes(), state->m_spc_regs );
+		state->m_spritegen->skns_draw_sprites(screen.machine(), state->m_sprite_bitmap, cliprect, state->m_spriteram, state->m_spriteram.bytes(), screen.machine().region("gfx1")->base(), screen.machine().region ("gfx1")->bytes(), state->m_spc_regs );
 
 
 	return 0;
diff -Nru src-old/mame/video/tetrisp2.c src/mame/video/tetrisp2.c
--- src-old/mame/video/tetrisp2.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/tetrisp2.c	2012-03-08 10:54:00.000000000 +0100
@@ -541,7 +541,7 @@
 	else if (asc_pri == 2)
 		state->m_tilemap_fg->draw(bitmap, cliprect, 0, 1 << 2);
 
-	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap, cliprect, state->m_priority, screen.machine().generic.spriteram.u16, screen.machine().generic.spriteram_size, 0, (state->m_systemregs[0x00] & 0x02));
+	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap, cliprect, state->m_priority, state->m_spriteram, state->m_spriteram.bytes(), 0, (state->m_systemregs[0x00] & 0x02));
 	return 0;
 }
 
@@ -626,7 +626,7 @@
 	else if (asc_pri == 2)
 		state->m_tilemap_fg->draw(bitmap, cliprect, 0, 1 << 2);
 
-	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, screen.machine().generic.spriteram.u16, screen.machine().generic.spriteram_size, 0, (state->m_systemregs[0x00] & 0x02));
+	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, state->m_spriteram, state->m_spriteram.bytes(), 0, (state->m_systemregs[0x00] & 0x02));
 	return 0;
 }
 
@@ -688,7 +688,7 @@
 	else if (asc_pri == 2)
 		state->m_tilemap_sub_fg->draw(bitmap, cliprect, 0, 1 << 2);
 
-	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, screen.machine().generic.spriteram2.u16, screen.machine().generic.spriteram2_size, 4, (state->m_systemregs[0x00] & 0x02));
+	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, state->m_spriteram2, state->m_spriteram2.bytes(), 4, (state->m_systemregs[0x00] & 0x02));
 
 	return 0;
 }
@@ -749,7 +749,7 @@
 	else if (asc_pri == 2)
 		state->m_tilemap_fg->draw(bitmap, cliprect, 0, 1 << 2);
 
-	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, screen.machine().generic.spriteram.u16, screen.machine().generic.spriteram_size, 0, (state->m_systemregs[0x00] & 0x02));
+	tetrisp2_draw_sprites(screen.machine(), bitmap, screen.machine().priority_bitmap,cliprect, state->m_priority, state->m_spriteram, state->m_spriteram.bytes(), 0, (state->m_systemregs[0x00] & 0x02));
 
 	return 0;
 }
diff -Nru src-old/mame/video/tigeroad.c src/mame/video/tigeroad.c
--- src-old/mame/video/tigeroad.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/tigeroad.c	2012-03-08 08:39:27.000000000 +0100
@@ -69,8 +69,9 @@
 
 static void draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority )
 {
-	UINT16 *source = &machine.generic.buffered_spriteram.u16[machine.generic.spriteram_size/2] - 4;
-	UINT16 *finish = machine.generic.buffered_spriteram.u16;
+	tigeroad_state *state = machine.driver_data<tigeroad_state>();
+	UINT16 *source = &state->m_spriteram->buffer()[state->m_spriteram->bytes()/2] - 4;
+	UINT16 *finish = state->m_spriteram->buffer();
 
 	// TODO: The Track Map should probably be drawn on top of the background tilemap...
 	//       Also convert the below into a for loop!
@@ -170,14 +171,3 @@
 	state->m_fg_tilemap->draw(bitmap, cliprect, 0, 2);
 	return 0;
 }
-
-SCREEN_VBLANK( tigeroad )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		buffer_spriteram16_w(space, 0, 0, 0xffff);
-	}
-}
diff -Nru src-old/mame/video/toki.c src/mame/video/toki.c
--- src-old/mame/video/toki.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/toki.c	2012-03-08 08:39:27.000000000 +0100
@@ -33,20 +33,6 @@
 	COMBINE_DATA(&state->m_scrollram16[offset]);
 }
 
-SCREEN_VBLANK( toki )
-{
-	// rising edge
-	if (vblank_on)
-		buffer_spriteram16_w(screen.machine().device("maincpu")->memory().space(AS_PROGRAM), 0, 0, 0xffff);
-}
-
-SCREEN_VBLANK( tokib )
-{
-	// rising edge
-	if (vblank_on)
-		buffer_spriteram16_w(screen.machine().device("maincpu")->memory().space(AS_PROGRAM), 0, 0, 0xffff);
-}
-
 static TILE_GET_INFO( get_text_tile_info )
 {
 	toki_state *state = machine.driver_data<toki_state>();
@@ -187,12 +173,13 @@
 
 static void toki_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect)
 {
+	toki_state *state = machine.driver_data<toki_state>();
 	int x,y,xoffs,yoffs,tile,flipx,flipy,color,offs;
 	UINT16 *sprite_word;
 
-	for (offs = (machine.generic.spriteram_size/2)-4;offs >= 0;offs -= 4)
+	for (offs = (state->m_spriteram->bytes()/2)-4;offs >= 0;offs -= 4)
 	{
-		sprite_word = &machine.generic.buffered_spriteram.u16[offs];
+		sprite_word = &state->m_spriteram->buffer()[offs];
 
 		if ((sprite_word[2] != 0xf000) && (sprite_word[0] != 0xffff))
 		{
@@ -230,12 +217,13 @@
 
 static void tokib_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap,const rectangle &cliprect)
 {
+	toki_state *state = machine.driver_data<toki_state>();
 	int x,y,tile,flipx,color,offs;
 	UINT16 *sprite_word;
 
-	for (offs = 0;offs < machine.generic.spriteram_size / 2;offs += 4)
+	for (offs = 0;offs < state->m_spriteram->bytes() / 2;offs += 4)
 	{
-		sprite_word = &machine.generic.buffered_spriteram.u16[offs];
+		sprite_word = &state->m_spriteram->buffer()[offs];
 
 		if (sprite_word[0] == 0xf100)
 			break;
diff -Nru src-old/mame/video/twin16.c src/mame/video/twin16.c
--- src-old/mame/video/twin16.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/twin16.c	2012-03-08 08:39:27.000000000 +0100
@@ -162,7 +162,7 @@
 void twin16_spriteram_process( running_machine &machine )
 {
 	twin16_state *state = machine.driver_data<twin16_state>();
-	UINT16 *spriteram16 = machine.generic.spriteram.u16;
+	UINT16 *spriteram16 = state->m_spriteram->live();
 	UINT16 dx = state->m_scrollx[0];
 	UINT16 dy = state->m_scrolly[0];
 
@@ -224,8 +224,8 @@
 static void draw_sprites( running_machine &machine, bitmap_ind16 &bitmap )
 {
 	twin16_state *state = machine.driver_data<twin16_state>();
-	const UINT16 *source = 0x1800+machine.generic.buffered_spriteram.u16 + 0x800 - 4;
-	const UINT16 *finish = 0x1800+machine.generic.buffered_spriteram.u16;
+	const UINT16 *source = 0x1800+state->m_spriteram->buffer() + 0x800 - 4;
+	const UINT16 *finish = 0x1800+state->m_spriteram->buffer();
 
 	for (; source >= finish; source -= 4)
 	{
@@ -552,12 +552,11 @@
 			/* if the sprite preprocessor is used, sprite ram is copied to an external buffer first,
             as evidenced by 1-frame sprite lag in gradius2 and devilw otherwise, though there's probably
             more to it than that */
-			memcpy(&screen.machine().generic.buffered_spriteram.u16[0x1800],state->m_sprite_buffer,0x800*sizeof(UINT16));
-			memcpy(state->m_sprite_buffer,&screen.machine().generic.spriteram.u16[0x1800],0x800*sizeof(UINT16));
+			memcpy(&state->m_spriteram->buffer()[0x1800],state->m_sprite_buffer,0x800*sizeof(UINT16));
+			memcpy(state->m_sprite_buffer,&state->m_spriteram->live()[0x1800],0x800*sizeof(UINT16));
 		}
 		else {
-			address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-			buffer_spriteram16_w(space,0,0,0xffff);
+			state->m_spriteram->copy();
 		}
 	}
 }
diff -Nru src-old/mame/video/twincobr.c src/mame/video/twincobr.c
--- src-old/mame/video/twincobr.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/twincobr.c	2012-03-08 08:39:27.000000000 +0100
@@ -364,13 +364,15 @@
 
 READ8_HANDLER( wardner_sprite_r )
 {
+	twincobr_state *state = space->machine().driver_data<twincobr_state>();
 	int shift = (offset & 1) * 8;
-	return space->machine().generic.spriteram.u16[offset/2] >> shift;
+	return state->m_spriteram->live()[offset/2] >> shift;
 }
 
 WRITE8_HANDLER( wardner_sprite_w )
 {
-	UINT16 *spriteram16 = space->machine().generic.spriteram.u16;
+	twincobr_state *state = space->machine().driver_data<twincobr_state>();
+	UINT16 *spriteram16 = state->m_spriteram->live();
 	if (offset & 1)
 		spriteram16[offset/2] = (spriteram16[offset/2] & 0x00ff) | (data << 8);
 	else
@@ -388,7 +390,7 @@
 	twincobr_state *state = machine.driver_data<twincobr_state>();
 
 	if (state->m_fgscrollx != state->m_bgscrollx) {
-		UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+		UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 		if ((state->m_fgscrollx==0x1c9) || (state->m_flip_screen && (state->m_fgscrollx==0x17a))) {	/* in the shop ? */
 			int wardner_hack = buffered_spriteram16[0x0b04/2];
 		/* sprite position 0x6300 to 0x8700 -- hero on shop keeper (normal) */
@@ -465,8 +467,8 @@
 
 	if (state->m_display_on)
 	{
-		UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
-		for (offs = 0;offs < machine.generic.spriteram_size/2;offs += 4)
+		UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
+		for (offs = 0;offs < state->m_spriteram->bytes()/2;offs += 4)
 		{
 			int attribute,sx,sy,flipx,flipy;
 			int sprite, color;
@@ -515,17 +517,6 @@
 	return 0;
 }
 
-
-SCREEN_VBLANK( toaplan0 )
-{
-	// rising edge
-	if (vblank_on)
-	{
-		address_space *space = screen.machine().device("maincpu")->memory().space(AS_PROGRAM);
-
-		/* Spriteram is always 1 frame ahead, suggesting spriteram buffering.
-            There are no CPU output registers that control this so we
-            assume it happens automatically every frame, at the end of vblank */
-		buffer_spriteram16_w(space,0,0,0xffff);
-	}
-}
+/* Spriteram is always 1 frame ahead, suggesting spriteram buffering.
+  There are no CPU output registers that control this so we
+  assume it happens automatically every frame, at the end of vblank */
diff -Nru src-old/mame/video/vaportra.c src/mame/video/vaportra.c
--- src-old/mame/video/vaportra.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/vaportra.c	2012-03-08 08:39:27.000000000 +0100
@@ -67,32 +67,32 @@
 	{
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, TILEMAP_DRAW_OPAQUE, 0);
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 0);
-		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0, state->m_priority[1], 0x0f);
+		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0, state->m_priority[1], 0x0f);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	}
 	else if (pri == 1)
 	{
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, TILEMAP_DRAW_OPAQUE, 0);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 0);
-		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0, state->m_priority[1], 0x0f);
+		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0, state->m_priority[1], 0x0f);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	}
 	else if (pri == 2)
 	{
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, TILEMAP_DRAW_OPAQUE, 0);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
-		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0, state->m_priority[1], 0x0f);
+		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0, state->m_priority[1], 0x0f);
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 0);
 	}
 	else
 	{
 		deco16ic_tilemap_1_draw(state->m_deco_tilegen2, bitmap, cliprect, TILEMAP_DRAW_OPAQUE, 0);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
-		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 0, state->m_priority[1], 0x0f);
+		screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 0, state->m_priority[1], 0x0f);
 		deco16ic_tilemap_2_draw(state->m_deco_tilegen2, bitmap, cliprect, 0, 0);
 	}
 
-	screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, screen.machine().generic.buffered_spriteram.u16, 1, state->m_priority[1], 0x0f);
+	screen.machine().device<deco_mxc06_device>("spritegen")->draw_sprites(screen.machine(), bitmap, cliprect, state->m_spriteram->buffer(), 1, state->m_priority[1], 0x0f);
 	deco16ic_tilemap_1_draw(state->m_deco_tilegen1, bitmap, cliprect, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/wwfwfest.c src/mame/video/wwfwfest.c
--- src-old/mame/video/wwfwfest.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/wwfwfest.c	2012-03-08 08:39:27.000000000 +0100
@@ -167,7 +167,7 @@
 
     **- End of Comments -*/
 
-	UINT16 *buffered_spriteram16 = machine.generic.buffered_spriteram.u16;
+	UINT16 *buffered_spriteram16 = state->m_spriteram->buffer();
 	const gfx_element *gfx = machine.gfx[1];
 	UINT16 *source = buffered_spriteram16;
 	UINT16 *finish = source + 0x2000/2;
diff -Nru src-old/mame/video/zodiack.c src/mame/video/zodiack.c
--- src-old/mame/video/zodiack.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/zodiack.c	2012-03-08 08:39:27.000000000 +0100
@@ -27,7 +27,7 @@
 	{
 		int i;
 
-		for (i = offset / 2; i < m_videoram_size; i += 32)
+		for (i = offset / 2; i < m_videoram.bytes(); i += 32)
 		{
 			m_bg_tilemap->mark_tile_dirty(i);
 			m_fg_tilemap->mark_tile_dirty(i);
@@ -132,7 +132,7 @@
 
 void zodiack_state::draw_bullets( bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	for (int offs = 0; offs < m_bulletsram_size; offs += 4)
+	for (int offs = 0; offs < m_bulletsram.bytes(); offs += 4)
 	{
 		int x, y;
 
@@ -156,7 +156,7 @@
 
 void zodiack_state::draw_sprites( bitmap_ind16 &bitmap, const rectangle &cliprect )
 {
-	for (int offs = m_spriteram_size - 4; offs >= 0; offs -= 4)
+	for (int offs = m_spriteram.bytes() - 4; offs >= 0; offs -= 4)
 	{
 		int flipx, flipy, sx, sy, spritecode;
 
diff -Nru src-old/osd/sdl/debugosx.m src/osd/sdl/debugosx.m
--- src-old/osd/sdl/debugosx.m	2011-03-30 21:29:36.000000000 +0200
+++ src/osd/sdl/debugosx.m	2012-03-07 20:46:01.000000000 +0100
@@ -1781,7 +1781,7 @@
 
 
 - (IBAction)debugNewErrorLogWindow:(id)sender {
-	MAMEDisassemblyViewer *win = [[MAMEErrorLogViewer alloc] initWithMachine:*machine console:self];
+	MAMEErrorLogViewer *win = [[MAMEErrorLogViewer alloc] initWithMachine:*machine console:self];
 	[auxiliaryWindows addObject:win];
 	[win release];
 	[win activate];
diff -Nru src-old/osd/sdl/osdsdl.h src/osd/sdl/osdsdl.h
--- src-old/osd/sdl/osdsdl.h	2012-02-12 21:59:24.000000000 +0100
+++ src/osd/sdl/osdsdl.h	2012-02-26 23:55:18.000000000 +0100
@@ -269,6 +269,6 @@
 //  sdlwork.c
 //============================================================
 
-extern int sdl_num_processors;
+extern int osd_num_processors;
 
 #endif
diff -Nru src-old/osd/sdl/sdlmain.c src/osd/sdl/sdlmain.c
--- src-old/osd/sdl/sdlmain.c	2012-02-14 00:38:49.000000000 +0100
+++ src/osd/sdl/sdlmain.c	2012-02-26 23:55:18.000000000 +0100
@@ -609,15 +609,15 @@
 	/* get number of processors */
 	stemp = options.numprocessors();
 
-	sdl_num_processors = 0;
+    osd_num_processors = 0;
 
 	if (strcmp(stemp, "auto") != 0)
 	{
-		sdl_num_processors = atoi(stemp);
-		if (sdl_num_processors < 1)
+		osd_num_processors = atoi(stemp);
+		if (osd_num_processors < 1)
 		{
 			mame_printf_warning("Warning: numprocessors < 1 doesn't make much sense. Assuming auto ...\n");
-			sdl_num_processors = 0;
+			osd_num_processors = 0;
 		}
 	}
 
diff -Nru src-old/osd/sdl/sdlos.h src/osd/sdl/sdlos.h
--- src-old/osd/sdl/sdlos.h	2010-01-21 23:54:49.000000000 +0100
+++ src/osd/sdl/sdlos.h	2012-02-26 23:55:18.000000000 +0100
@@ -23,7 +23,7 @@
 
         Number of processors
 -----------------------------------------------------------------------------*/
-int osd_num_processors(void);
+int osd_get_num_processors(void);
 
 
 /*-----------------------------------------------------------------------------
diff -Nru src-old/osd/sdl/sdlos_macosx.c src/osd/sdl/sdlos_macosx.c
--- src-old/osd/sdl/sdlos_macosx.c	2012-02-14 00:23:41.000000000 +0100
+++ src/osd/sdl/sdlos_macosx.c	2012-02-26 23:55:18.000000000 +0100
@@ -142,7 +142,7 @@
 //  osd_num_processors
 //============================================================
 
-int osd_num_processors(void)
+int osd_get_num_processors(void)
 {
 	int processors = 1;
 
diff -Nru src-old/osd/sdl/sdlos_os2.c src/osd/sdl/sdlos_os2.c
--- src-old/osd/sdl/sdlos_os2.c	2012-02-12 21:59:24.000000000 +0100
+++ src/osd/sdl/sdlos_os2.c	2012-02-26 23:55:18.000000000 +0100
@@ -175,7 +175,7 @@
 //  osd_num_processors
 //============================================================
 
-int osd_num_processors(void)
+int osd_get_num_processors(void)
 {
     ULONG numprocs = 1;
 
diff -Nru src-old/osd/sdl/sdlos_unix.c src/osd/sdl/sdlos_unix.c
--- src-old/osd/sdl/sdlos_unix.c	2012-02-12 21:59:24.000000000 +0100
+++ src/osd/sdl/sdlos_unix.c	2012-02-26 23:55:18.000000000 +0100
@@ -67,7 +67,7 @@
 //  osd_num_processors
 //============================================================
 
-int osd_num_processors(void)
+int osd_get_num_processors(void)
 {
 	int processors = 1;
 
diff -Nru src-old/osd/sdl/sdlos_win32.c src/osd/sdl/sdlos_win32.c
--- src-old/osd/sdl/sdlos_win32.c	2012-02-12 21:59:24.000000000 +0100
+++ src/osd/sdl/sdlos_win32.c	2012-02-26 23:55:18.000000000 +0100
@@ -160,7 +160,7 @@
 //  osd_num_processors
 //============================================================
 
-int osd_num_processors(void)
+int osd_get_num_processors(void)
 {
 	SYSTEM_INFO info;
 
diff -Nru src-old/osd/sdl/sdlwork.c src/osd/sdl/sdlwork.c
--- src-old/osd/sdl/sdlwork.c	2011-07-18 23:37:20.000000000 +0200
+++ src/osd/sdl/sdlwork.c	2012-02-26 23:55:18.000000000 +0100
@@ -16,7 +16,7 @@
  *        This is not really a sound solution.
  */
 
-int sdl_num_processors = 0;
+int osd_num_processors = 0;
 
 #include "../osdmini/miniwork.c"
 
@@ -131,7 +131,7 @@
 //  GLOBAL VARIABLES
 //============================================================
 
-int sdl_num_processors = 0;
+int osd_num_processors = 0;
 
 //============================================================
 //  FUNCTION PROTOTYPES
@@ -567,10 +567,11 @@
 {
 	char *procsoverride;
 	int numprocs = 0;
-	int physprocs = osd_num_processors();
+	int physprocs = osd_get_num_processors();
 
-	if (sdl_num_processors > 0)
-		return MIN(4 * physprocs, sdl_num_processors);
+    // osd_num_processors == 0 for 'auto'
+	if (osd_num_processors > 0)
+		return MIN(4 * physprocs, osd_num_processors);
 	else
 	{
 		// if the OSDPROCESSORS environment variable is set, use that value if valid
@@ -601,7 +602,7 @@
 			if (index<2)
 				mask = 0x01; /* main thread and io threads on cpu #0 */
 			else
-				mask = (1 << (((index - 1) % (osd_num_processors() - 1)) + 1));
+				mask = (1 << (((index - 1) % (osd_get_num_processors() - 1)) + 1));
 		}
 		else
 		{
diff -Nru src-old/tools/chdman.c src/tools/chdman.c
--- src-old/tools/chdman.c	2012-02-26 19:23:18.000000000 +0100
+++ src/tools/chdman.c	2012-03-06 18:58:12.000000000 +0100
@@ -52,11 +52,6 @@
 #include <ctype.h>
 #include <new>
 
-#ifdef _WIN32
-#define NUM_PROCESSORS_SUPPORTED 1
-#else
-#define NUM_PROCESSORS_SUPPORTED 0
-#endif
 
 
 //**************************************************************************
@@ -69,6 +64,11 @@
 // temporary input buffer size
 const UINT32 TEMP_BUFFER_SIZE = 32 * 1024 * 1024;
 
+// modes
+const int MODE_NORMAL = 0;
+const int MODE_CUEBIN = 1;
+const int MODE_GDI = 2;
+
 // command modifier
 #define REQUIRED "~"
 
@@ -118,7 +118,6 @@
 #define OPTION_NUMPROCESSORS "numprocessors"
 
 
-
 //**************************************************************************
 //  FUNCTION PROTOTYPES
 //**************************************************************************
@@ -323,17 +322,25 @@
 				UINT32 bytesperframe = trackinfo.datasize + trackinfo.subsize;
 				UINT64 src_track_start = m_info.track[tracknum].offset;
 				UINT64 src_track_end = src_track_start + bytesperframe * trackinfo.frames;
-				while (length_remaining != 0 && offset < endoffs)
+                UINT64 pad_track_start = src_track_end - (m_toc.tracks[tracknum].padframes * bytesperframe);
+                while (length_remaining != 0 && offset < endoffs)
 				{
 					// determine start of current frame
 					UINT64 src_frame_start = src_track_start + ((offset - startoffs) / CD_FRAME_SIZE) * bytesperframe;
 					if (src_frame_start < src_track_end)
 					{
-						// read it in
-						core_fseek(m_file, src_frame_start, SEEK_SET);
-						UINT32 count = core_fread(m_file, dest, bytesperframe);
-						if (count != bytesperframe)
-							report_error(1, "Error reading input file (%s)'", m_lastfile.cstr());
+						// read it in, or pad if we're into the padframes
+                        if (src_frame_start >= pad_track_start)
+                        {
+                            memset(dest, 0, bytesperframe);
+                        }
+                        else
+                        {
+                            core_fseek(m_file, src_frame_start, SEEK_SET);
+                            UINT32 count = core_fread(m_file, dest, bytesperframe);
+                            if (count != bytesperframe)
+                                report_error(1, "Error reading input file (%s)'", m_lastfile.cstr());
+                        }
 
 						// swap if appropriate
 						if (m_info.track[tracknum].swap)
@@ -512,9 +519,7 @@
 	{ OPTION_INDEX,					"ix",	true, " <index>: indexed instance of this metadata tag" },
 	{ OPTION_VALUE_TEXT,			"vt",	true, " <text>: text for the metadata" },
 	{ OPTION_VALUE_FILE,			"vf",	true, " <file>: file containing data to add" },
-#if NUM_PROCESSORS_SUPPORTED
 	{ OPTION_NUMPROCESSORS,			"np",	true, " <processors>: limit the number of processors to use during compression" },
-#endif
 	{ OPTION_NO_CHECKSUM,			"nocs",	false, ": do not include this metadata information in the overall SHA-1" },
 	{ OPTION_FIX,					"f",	false, ": fix the SHA-1 if it is incorrect" },
 	{ OPTION_VERBOSE,				"v",	false, ": output additional information" },
@@ -551,9 +556,7 @@
 			REQUIRED OPTION_HUNK_SIZE,
 			REQUIRED OPTION_UNIT_SIZE,
 			OPTION_COMPRESSION,
-#if NUM_PROCESSORS_SUPPORTED
 			OPTION_NUMPROCESSORS
-#endif
 		}
 	},
 
@@ -572,9 +575,7 @@
 			OPTION_IDENT,
 			OPTION_CHS,
 			OPTION_SECTOR_SIZE,
-#if NUM_PROCESSORS_SUPPORTED
 			OPTION_NUMPROCESSORS
-#endif
 		}
 	},
 
@@ -586,9 +587,7 @@
 			REQUIRED OPTION_INPUT,
 			OPTION_HUNK_SIZE,
 			OPTION_COMPRESSION,
-#if NUM_PROCESSORS_SUPPORTED
 			OPTION_NUMPROCESSORS
-#endif
 		}
 	},
 
@@ -602,9 +601,7 @@
 			OPTION_INPUT_LENGTH_FRAMES,
 			OPTION_HUNK_SIZE,
 			OPTION_COMPRESSION,
-#if NUM_PROCESSORS_SUPPORTED
 			OPTION_NUMPROCESSORS
-#endif
 		}
 	},
 
@@ -668,9 +665,7 @@
 			OPTION_INPUT_LENGTH_HUNKS,
 			OPTION_HUNK_SIZE,
 			OPTION_COMPRESSION,
-#if NUM_PROCESSORS_SUPPORTED
 			OPTION_NUMPROCESSORS
-#endif
 		}
 	},
 
@@ -1101,7 +1096,6 @@
 
 static void parse_numprocessors(const parameters_t &params)
 {
-#if NUM_PROCESSORS_SUPPORTED
 	astring *numprocessors_str = params.find(OPTION_NUMPROCESSORS);
 	if (numprocessors_str == NULL)
 		return;
@@ -1112,7 +1106,6 @@
 		extern int osd_num_processors;
 		osd_num_processors = count;
 	}
-#endif
 }
 
 
@@ -1175,93 +1168,139 @@
 //  to a CUE file
 //-------------------------------------------------
 
-void output_track_metadata(bool cuemode, core_file *file, int tracknum, const cdrom_track_info &info, const char *filename, UINT32 frameoffs, UINT64 discoffs)
+void output_track_metadata(int mode, core_file *file, int tracknum, const cdrom_track_info &info, const char *filename, UINT32 frameoffs, UINT64 discoffs)
 {
-	// CUE mode?
-	if (cuemode)
+	if (mode == MODE_GDI)
 	{
-		// first track specifies the file
-		if (tracknum == 0)
-			core_fprintf(file, "FILE \"%s\" BINARY\n", filename);
-
-		// determine submode
-		astring tempstr;
-		switch (info.trktype)
-		{
-			case CD_TRACK_MODE1:
-			case CD_TRACK_MODE1_RAW:
-				tempstr.format("MODE1/%04d", info.datasize);
-				break;
-
-			case CD_TRACK_MODE2:
-			case CD_TRACK_MODE2_FORM1:
-			case CD_TRACK_MODE2_FORM2:
-			case CD_TRACK_MODE2_FORM_MIX:
-			case CD_TRACK_MODE2_RAW:
-				tempstr.format("MODE2/%04d", info.datasize);
-				break;
-
-			case CD_TRACK_AUDIO:
-				tempstr.cpy("AUDIO");
-				break;
-		}
-
-		// output TRACK entry
-		core_fprintf(file, "  TRACK %02d %s\n", tracknum + 1, tempstr.cstr());
-
-		// output PREGAP
-		if (info.pregap > 0)
-			core_fprintf(file, "    PREGAP %s\n", msf_string_from_frames(tempstr, info.pregap));
-
-		// output track data
-		core_fprintf(file, "    INDEX 01 %s\n", msf_string_from_frames(tempstr, frameoffs));
-
-		// output POSTGAP
-		if (info.postgap > 0)
-			core_fprintf(file, "    POSTGAP %s\n", msf_string_from_frames(tempstr, info.postgap));
-	}
-
-	// non-CUE mode
-	else
-	{
-		// header on the first track
-		if (tracknum == 0)
-			core_fprintf(file, "CD_ROM\n\n\n");
-		core_fprintf(file, "// Track %d\n", tracknum + 1);
-
-		// write out the track type
-		astring modesubmode;
-		if (info.subtype != CD_SUB_NONE)
-			modesubmode.format("%s %s", cdrom_get_type_string(info.trktype), cdrom_get_subtype_string(info.subtype));
-		else
-			modesubmode.format("%s", cdrom_get_type_string(info.trktype));
-		core_fprintf(file, "TRACK %s\n", modesubmode.cstr());
-
-		// write out the attributes
-		core_fprintf(file, "NO COPY\n");
-		if (info.trktype == CD_TRACK_AUDIO)
-		{
-			core_fprintf(file, "NO PRE_EMPHASIS\n");
-			core_fprintf(file, "TWO_CHANNEL_AUDIO\n");
-		}
-
-		// output pregap
-		astring tempstr;
-		if (info.pregap > 0)
-			core_fprintf(file, "ZERO %s %s\n", modesubmode.cstr(), msf_string_from_frames(tempstr, info.pregap));
-
-		// all tracks but the first one have a file offset
-		if (tracknum > 0)
-			core_fprintf(file, "DATAFILE \"%s\" #%d %s // length in bytes: %d\n", filename, UINT32(discoffs), msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
-		else
-			core_fprintf(file, "DATAFILE \"%s\" %s // length in bytes: %d\n", filename, msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
+        int mode = 0, size = 2048;
 
-		// tracks with pregaps get a START marker too
-		if (info.pregap > 0)
-			core_fprintf(file, "START %s\n", msf_string_from_frames(tempstr, info.pregap));
+        switch (info.trktype)
+        {
+            case CD_TRACK_MODE1:
+                mode = 0;
+                size = 2048;
+                break;
+
+            case CD_TRACK_MODE1_RAW:
+                mode = 4;
+                size = 2352;
+                break;
+
+            case CD_TRACK_MODE2:
+                mode = 4;
+                size = 2336;
+                break;
+
+            case CD_TRACK_MODE2_FORM1:
+                mode = 4;
+                size = 2048;
+                break;
+
+            case CD_TRACK_MODE2_FORM2:
+                mode = 4;
+                size = 2324;
+                break;
+
+            case CD_TRACK_MODE2_FORM_MIX:
+                mode = 4;
+                size = 2336;
+                break;
+
+            case CD_TRACK_MODE2_RAW:
+                mode = 4;
+                size = 2352;
+                break;
+
+            case CD_TRACK_AUDIO:
+                mode = 0;
+                size = 2352;
+                break;
+        }
+		core_fprintf(file, "%d %d %d %d %s %" I64FMT "d\n", tracknum+1, frameoffs, mode, size, filename, discoffs);
+	}
+	else if (mode == MODE_CUEBIN)
+    {
+        // first track specifies the file
+        if (tracknum == 0)
+            core_fprintf(file, "FILE \"%s\" BINARY\n", filename);
+
+        // determine submode
+        astring tempstr;
+        switch (info.trktype)
+        {
+            case CD_TRACK_MODE1:
+            case CD_TRACK_MODE1_RAW:
+                tempstr.format("MODE1/%04d", info.datasize);
+                break;
+
+            case CD_TRACK_MODE2:
+            case CD_TRACK_MODE2_FORM1:
+            case CD_TRACK_MODE2_FORM2:
+            case CD_TRACK_MODE2_FORM_MIX:
+            case CD_TRACK_MODE2_RAW:
+                tempstr.format("MODE2/%04d", info.datasize);
+                break;
+
+            case CD_TRACK_AUDIO:
+                tempstr.cpy("AUDIO");
+                break;
+        }
+
+        // output TRACK entry
+        core_fprintf(file, "  TRACK %02d %s\n", tracknum + 1, tempstr.cstr());
+
+        // output PREGAP
+        if (info.pregap > 0)
+            core_fprintf(file, "    PREGAP %s\n", msf_string_from_frames(tempstr, info.pregap));
+
+        // output track data
+        core_fprintf(file, "    INDEX 01 %s\n", msf_string_from_frames(tempstr, frameoffs));
+
+        // output POSTGAP
+        if (info.postgap > 0)
+            core_fprintf(file, "    POSTGAP %s\n", msf_string_from_frames(tempstr, info.postgap));
+    }
+    // non-CUE mode
+    else if (mode == MODE_NORMAL)
+    {
+        // header on the first track
+        if (tracknum == 0)
+            core_fprintf(file, "CD_ROM\n\n\n");
+        core_fprintf(file, "// Track %d\n", tracknum + 1);
+
+        // write out the track type
+        astring modesubmode;
+        if (info.subtype != CD_SUB_NONE)
+            modesubmode.format("%s %s", cdrom_get_type_string(info.trktype), cdrom_get_subtype_string(info.subtype));
+        else
+            modesubmode.format("%s", cdrom_get_type_string(info.trktype));
+        core_fprintf(file, "TRACK %s\n", modesubmode.cstr());
+
+        // write out the attributes
+        core_fprintf(file, "NO COPY\n");
+        if (info.trktype == CD_TRACK_AUDIO)
+        {
+            core_fprintf(file, "NO PRE_EMPHASIS\n");
+            core_fprintf(file, "TWO_CHANNEL_AUDIO\n");
+        }
+
+        // output pregap
+        astring tempstr;
+        if (info.pregap > 0)
+            core_fprintf(file, "ZERO %s %s\n", modesubmode.cstr(), msf_string_from_frames(tempstr, info.pregap));
+
+        // all tracks but the first one have a file offset
+        if (tracknum > 0)
+            core_fprintf(file, "DATAFILE \"%s\" #%d %s // length in bytes: %d\n", filename, UINT32(discoffs), msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
+        else
+            core_fprintf(file, "DATAFILE \"%s\" %s // length in bytes: %d\n", filename, msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
+
+        // tracks with pregaps get a START marker too
+        if (info.pregap > 0)
+            core_fprintf(file, "START %s\n", msf_string_from_frames(tempstr, info.pregap));
 
-		core_fprintf(file, "\n\n");
-	}
+        core_fprintf(file, "\n\n");
+    }
 }
 
 
@@ -1557,24 +1596,26 @@
 	printf("Logical size: %s\n", big_int_string(tempstr, input_end - input_start));
 
 	// catch errors so we can close & delete the output file
+	chd_rawfile_compressor *chd = NULL;
 	try
 	{
 		// create the new CHD
-		chd_rawfile_compressor chd(input_file, input_start, input_end);
+		chd = new chd_rawfile_compressor(input_file, input_start, input_end);
 		chd_error err;
 		if (output_parent.opened())
-			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
+			err = chd->create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
 		else
-			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, unit_size, compression);
+			err = chd->create(*output_chd_str, input_end - input_start, hunk_size, unit_size, compression);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
 		// if we have a parent, copy forward all the metadata
 		if (output_parent.opened())
-			chd.clone_all_metadata(output_parent);
+			chd->clone_all_metadata(output_parent);
 
 		// compress it generically
-		compress_common(chd);
+		compress_common(*chd);
+		delete chd;
 	}
 	catch (...)
 	{
@@ -1582,6 +1623,7 @@
 		astring *output_chd_str = params.find(OPTION_OUTPUT);
 		if (output_chd_str != NULL)
 			osd_rmfile(*output_chd_str);
+		delete chd;
 		throw;
 	}
 }
@@ -1715,36 +1757,38 @@
 	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(totalsectors) * UINT64(sector_size)));
 
 	// catch errors so we can close & delete the output file
+	chd_rawfile_compressor *chd = NULL;
 	try
 	{
 		// create the new hard drive
-		chd_rawfile_compressor chd(input_file, input_start, input_end);
+		chd = new chd_rawfile_compressor(input_file, input_start, input_end);
 		chd_error err;
 		if (output_parent.opened())
-			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, compression, output_parent);
+			err = chd->create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, compression, output_parent);
 		else
-			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, sector_size, compression);
+			err = chd->create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, sector_size, compression);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
 		// add the standard hard disk metadata
 		astring metadata;
 		metadata.format(HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sector_size);
-		err = chd.write_metadata(HARD_DISK_METADATA_TAG, 0, metadata);
+		err = chd->write_metadata(HARD_DISK_METADATA_TAG, 0, metadata);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error adding hard disk metadata: %s", chd_file::error_string(err));
 
 		// write the ident if present
 		if (identdata.count() > 0)
 		{
-			err = chd.write_metadata(HARD_DISK_IDENT_METADATA_TAG, 0, identdata);
+			err = chd->write_metadata(HARD_DISK_IDENT_METADATA_TAG, 0, identdata);
 			if (err != CHDERR_NONE)
 				report_error(1, "Error adding hard disk metadata: %s", chd_file::error_string(err));
 		}
 
 		// compress it generically
 		if (input_file != NULL)
-			compress_common(chd);
+			compress_common(*chd);
+		delete chd;
 	}
 	catch (...)
 	{
@@ -1752,6 +1796,7 @@
 		astring *output_chd_str = params.find(OPTION_OUTPUT);
 		if (output_chd_str != NULL)
 			osd_rmfile(*output_chd_str);
+		delete chd;
 		throw;
 	}
 }
@@ -1815,25 +1860,27 @@
 	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(totalsectors) * CD_FRAME_SIZE));
 
 	// catch errors so we can close & delete the output file
+	chd_cd_compressor *chd = NULL;
 	try
 	{
-		// create the new hard drive
-		chd_cd_compressor chd(toc, track_info);
+		// create the new CD
+		chd = new chd_cd_compressor(toc, track_info);
 		chd_error err;
 		if (output_parent.opened())
-			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, compression, output_parent);
+			err = chd->create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, compression, output_parent);
 		else
-			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, CD_FRAME_SIZE, compression);
+			err = chd->create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, CD_FRAME_SIZE, compression);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
 		// add the standard CD metadata; we do this even if we have a parent because it might be different
-		err = cdrom_write_metadata(&chd, &toc);
+		err = cdrom_write_metadata(chd, &toc);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error adding CD metadata: %s", chd_file::error_string(err));
 
 		// compress it generically
-		compress_common(chd);
+		compress_common(*chd);
+		delete chd;
 	}
 	catch (...)
 	{
@@ -1841,6 +1888,7 @@
 		astring *output_chd_str = params.find(OPTION_OUTPUT);
 		if (output_chd_str != NULL)
 			osd_rmfile(*output_chd_str);
+		delete chd;
 		throw;
 	}
 }
@@ -1927,35 +1975,37 @@
 	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(input_end - input_start) * hunk_size));
 
 	// catch errors so we can close & delete the output file
+	chd_avi_compressor *chd = NULL;
 	try
 	{
 		// create the new CHD
-		chd_avi_compressor chd(*input_file, info, input_start, input_end);
+		chd = new chd_avi_compressor(*input_file, info, input_start, input_end);
 		chd_error err;
 		if (output_parent.opened())
-			err = chd.create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, compression, output_parent);
+			err = chd->create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, compression, output_parent);
 		else
-			err = chd.create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, info.bytes_per_frame, compression);
+			err = chd->create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, info.bytes_per_frame, compression);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
 		// write the core A/V metadata
 		astring metadata;
 		metadata.format(AV_METADATA_FORMAT, info.fps_times_1million / 1000000, info.fps_times_1million % 1000000, info.width, info.height, info.interlaced, info.channels, info.rate);
-		err = chd.write_metadata(AV_METADATA_TAG, 0, metadata);
+		err = chd->write_metadata(AV_METADATA_TAG, 0, metadata);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error adding AV metadata: %s\n", chd_file::error_string(err));
 
 		// create the compressor and then run it generically
-		compress_common(chd);
+		compress_common(*chd);
 
 		// write the final LD metadata
 		if (info.height == 524/2 || info.height == 624/2)
 		{
-			err = chd.write_metadata(AV_LD_METADATA_TAG, 0, chd.ldframedata());
+			err = chd->write_metadata(AV_LD_METADATA_TAG, 0, chd->ldframedata(), 0);
 			if (err != CHDERR_NONE)
 				report_error(1, "Error adding AVLD metadata: %s\n", chd_file::error_string(err));
 		}
+		delete chd;
 	}
 	catch (...)
 	{
@@ -1963,6 +2013,7 @@
 		astring *output_chd_str = params.find(OPTION_OUTPUT);
 		if (output_chd_str != NULL)
 			osd_rmfile(*output_chd_str);
+		delete chd;
 		throw;
 	}
 }
@@ -2031,15 +2082,16 @@
 	printf("Logical size: %s\n", big_int_string(tempstr, input_end - input_start));
 
 	// catch errors so we can close & delete the output file
+	chd_chdfile_compressor *chd = NULL;
 	try
 	{
 		// create the new CHD
-		chd_chdfile_compressor chd(input_chd, input_start, input_end);
+		chd = new chd_chdfile_compressor(input_chd, input_start, input_end);
 		chd_error err;
 		if (output_parent.opened())
-			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
+			err = chd->create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
 		else
-			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, input_chd.unit_bytes(), compression);
+			err = chd->create(*output_chd_str, input_end - input_start, hunk_size, input_chd.unit_bytes(), compression);
 		if (err != CHDERR_NONE)
 			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
@@ -2059,7 +2111,7 @@
 			}
 
 			// otherwise, clone it
-			err = chd.write_metadata(metatag, CHDMETAINDEX_APPEND, metadata);
+			err = chd->write_metadata(metatag, CHDMETAINDEX_APPEND, metadata, metaflags);
 			if (err != CHDERR_NONE)
 				report_error(1, "Error writing cloned metadata: %s", chd_file::error_string(err));
 		}
@@ -2071,13 +2123,14 @@
 			if (cdrom == NULL)
 				report_error(1, "Error upgrading CD metadata");
 			const cdrom_toc *toc = cdrom_get_toc(cdrom);
-			err = cdrom_write_metadata(&chd, toc);
+			err = cdrom_write_metadata(chd, toc);
 			if (err != CHDERR_NONE)
 				report_error(1, "Error writing upgraded CD metadata: %s", chd_file::error_string(err));
 		}
 
 		// compress it generically
-		compress_common(chd);
+		compress_common(*chd);
+		delete chd;
 	}
 	catch (...)
 	{
@@ -2085,6 +2138,7 @@
 		astring *output_chd_str = params.find(OPTION_OUTPUT);
 		if (output_chd_str != NULL)
 			osd_rmfile(*output_chd_str);
+		delete chd;
 		throw;
 	}
 }
@@ -2198,6 +2252,8 @@
 	int chop = default_name.rchr(0, '.');
 	if (chop != -1)
 		default_name.substr(0, chop);
+    char basename[128];
+    strncpy(basename, default_name.cstr(), 127);
 	default_name.cat(".bin");
 	if (output_bin_file_str == NULL)
 		output_bin_file_str = &default_name;
@@ -2214,54 +2270,97 @@
 	core_file *output_toc_file = NULL;
 	try
 	{
-		// process output file
-		file_error filerr = core_fopen(*output_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_NO_BOM, &output_toc_file);
-		if (filerr != FILERR_NONE)
-			report_error(1, "Unable to open file (%s)", output_file_str->cstr());
-		bool cuemode = (output_file_str->find(".cue") != -1);
+        int mode = MODE_NORMAL;
+
+		if (output_file_str->find(".cue") != -1)
+        {
+            mode = MODE_CUEBIN;
+        }
+        else if (output_file_str->find(".gdi") != -1)
+        {
+            mode = MODE_GDI;
+        }
+
+        // process output file
+        file_error filerr = core_fopen(*output_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_NO_BOM, &output_toc_file);
+        if (filerr != FILERR_NONE)
+            report_error(1, "Unable to open file (%s)", output_file_str->cstr());
 
 		// process output BIN file
-		filerr = core_fopen(*output_bin_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_bin_file);
-		if (filerr != FILERR_NONE)
-			report_error(1, "Unable to open file (%s)", output_bin_file_str->cstr());
+        if (mode != MODE_GDI)
+        {
+            filerr = core_fopen(*output_bin_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_bin_file);
+            if (filerr != FILERR_NONE)
+                report_error(1, "Unable to open file (%s)", output_bin_file_str->cstr());
+        }
 
 		// determine total frames
 		UINT64 total_bytes = 0;
 		for (int tracknum = 0; tracknum < toc->numtrks; tracknum++)
 			total_bytes += toc->tracks[tracknum].frames * (toc->tracks[tracknum].datasize + toc->tracks[tracknum].subsize);
 
+		// GDI must start with the # of tracks
+		if (mode == MODE_GDI)
+		{
+			core_fprintf(output_toc_file, "%d\n", toc->numtrks);
+		}
+
 		// iterate over tracks and copy all data
 		UINT64 outputoffs = 0;
 		UINT32 discoffs = 0;
 		dynamic_buffer buffer;
 		for (int tracknum = 0; tracknum < toc->numtrks; tracknum++)
 		{
+            astring trackbin_name(basename);
+
+            if (mode == MODE_GDI)
+            {
+                char temp[8];
+                sprintf(temp, "%02d", tracknum+1);
+                trackbin_name.cat(temp);
+                trackbin_name.cat(".bin");
+
+                if (output_bin_file)
+                {
+                    core_fclose(output_bin_file);
+                    output_bin_file = NULL;
+                }
+
+                filerr = core_fopen(trackbin_name, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_bin_file);
+                if (filerr != FILERR_NONE)
+                    report_error(1, "Unable to open file (%s)", trackbin_name.cstr());
+
+                outputoffs = 0;
+            }
+
 			// output the metadata about the track to the TOC file
 			const cdrom_track_info &trackinfo = toc->tracks[tracknum];
-			output_track_metadata(cuemode, output_toc_file, tracknum, trackinfo, *output_bin_file_str, discoffs, outputoffs);
-
-			UINT32 output_frame_size;
+            if (mode == MODE_GDI)
+            {
+                output_track_metadata(mode, output_toc_file, tracknum, trackinfo, trackbin_name, discoffs, outputoffs);
+            }
+            else
+            {
+                output_track_metadata(mode, output_toc_file, tracknum, trackinfo, *output_bin_file_str, discoffs, outputoffs);
+            }
 
             // If this is bin/cue output and the CHD contains subdata, warn the user and don't include
             // the subdata size in the buffer calculation.
-            if ((trackinfo.subtype != CD_SUB_NONE) && (cuemode))
+			UINT32 output_frame_size = trackinfo.datasize + ((trackinfo.subtype != CD_SUB_NONE) ? trackinfo.subsize : 0);
+            if (trackinfo.subtype != CD_SUB_NONE && ((mode == MODE_CUEBIN) || (mode == MODE_GDI)))
             {
-                printf("Warning: Track %d has subcode data.  bin/cue format cannot contain subcode data and it will be omitted.\n", tracknum+1);
+                printf("Warning: Track %d has subcode data.  bin/cue and gdi formats cannot contain subcode data and it will be omitted.\n", tracknum+1);
                 printf("       : This may affect usage of the output image.  Use bin/toc output to keep all data.\n");
-
                 output_frame_size = trackinfo.datasize;
             }
-            else
-            {
-                output_frame_size = trackinfo.datasize + ((trackinfo.subtype != CD_SUB_NONE) ? trackinfo.subsize : 0);
-            }
 
 			// resize the buffer for the track
 			buffer.resize((TEMP_BUFFER_SIZE / output_frame_size) * output_frame_size);
 
 			// now read and output the actual data
 			UINT32 bufferoffs = 0;
-			for (int frame = 0; frame < trackinfo.frames; frame++)
+            UINT32 actualframes = trackinfo.frames - trackinfo.padframes;
+			for (UINT32 frame = 0; frame < actualframes; frame++)
 			{
 				progress(false, "Extracting, %.1f%% complete... \r", 100.0 * double(outputoffs) / double(total_bytes));
 
@@ -2269,7 +2368,7 @@
 				cdrom_read_data(cdrom, cdrom_get_track_start(cdrom, tracknum) + frame, &buffer[bufferoffs], trackinfo.trktype);
 
 				// for CDRWin, audio tracks must be reversed
-				if (cuemode && (trackinfo.trktype == CD_TRACK_AUDIO))
+				if ((mode == MODE_CUEBIN) && (trackinfo.trktype == CD_TRACK_AUDIO))
 					for (int swapindex = 0; swapindex < trackinfo.datasize; swapindex += 2)
 					{
 						UINT8 swaptemp = buffer[bufferoffs + swapindex];
@@ -2280,14 +2379,14 @@
 				discoffs++;
 
 				// read the subcode data
-				if ((trackinfo.subtype != CD_SUB_NONE) && (!cuemode))
+				if (trackinfo.subtype != CD_SUB_NONE && (mode == MODE_NORMAL))
 				{
                     cdrom_read_subcode(cdrom, cdrom_get_track_start(cdrom, tracknum) + frame, &buffer[bufferoffs]);
                     bufferoffs += trackinfo.subsize;
 				}
 
 				// write it out if we need to
-				if (bufferoffs == buffer.count() || frame == trackinfo.frames - 1)
+				if (bufferoffs == buffer.count() || frame == actualframes - 1)
 				{
 					core_fseek(output_bin_file, outputoffs, SEEK_SET);
 					UINT32 byteswritten = core_fwrite(output_bin_file, buffer, bufferoffs);
@@ -2297,10 +2396,12 @@
 					bufferoffs = 0;
 				}
 			}
+
+            discoffs += trackinfo.padframes;
 		}
 
 		// finish up
-		core_fclose(output_bin_file);
+        core_fclose(output_bin_file);
 		core_fclose(output_toc_file);
 		printf("Extraction complete                                    \n");
 	}
diff -Nru src-old/tools/src2html.c src/tools/src2html.c
--- src-old/tools/src2html.c	2012-01-08 15:41:35.000000000 +0100
+++ src/tools/src2html.c	2012-02-29 10:13:22.000000000 +0100
@@ -585,6 +585,7 @@
 		bool last_token_was_include = false;
 		bool last_was_token = false;
 		bool quotes_are_linked = false;
+		UINT8 curquote = 0;
 		int curcol = 0;
 		for (char *srcptr = srcline; *srcptr != 0; )
 		{
@@ -673,7 +674,8 @@
 						dstline.catprintf("<span class=\"string\">%c", ch);
 					else
 						dstline.cat(ch);
-					in_quotes = ch;
+					in_quotes = true;
+					curquote = ch;
 
 					// handle includes
 					if (last_token_was_include)
@@ -693,7 +695,7 @@
 				}
 
 				// track closing quotes
-				else if (!in_comment && !in_inline_comment && in_quotes && ch == in_quotes && !escape)
+				else if (!in_comment && !in_inline_comment && in_quotes && (ch == curquote) && !escape)
 				{
 					if (quotes_are_linked)
 						dstline.catprintf("</a>");
@@ -701,7 +703,8 @@
 						dstline.catprintf("%c</span>", ch);
 					else
 						dstline.cat(ch);
-					in_quotes = 0;
+					in_quotes = false;
+					curquote = 0;
 					quotes_are_linked = false;
 				}
 
@@ -719,7 +722,7 @@
 
 			// Update escape state
 			if (in_quotes)
-				escape = (ch == '\\' && type == FILE_TYPE_C) ? !escape : 0;
+				escape = (ch == '\\' && type == FILE_TYPE_C) ? !escape : false;
 		}
 
 		// finish inline comments
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2012-02-26 20:51:00.000000000 +0100
+++ src/version.c	2012-03-11 18:13:42.000000000 +0100
@@ -38,4 +38,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.145u3 ("__DATE__")";
+const char build_version[] = "0.145u4 ("__DATE__")";
