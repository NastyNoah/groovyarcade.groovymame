--- makefile-old	2012-02-05 17:54:00.000000000 +0100
+++ makefile	2012-02-16 10:47:18.000000000 +0100
@@ -643,6 +643,8 @@
 # $(OBJ)/libflac++.a
 
 
+7Z_LIB = $(OBJ)/lib7z.a 
+
 #-------------------------------------------------
 # defines needed by multiple make files 
 #-------------------------------------------------
@@ -731,10 +733,8 @@
 
 ifndef EXECUTABLE_DEFINED
 
-# always recompile the version string
-$(VERSIONOBJ): $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(ZLIB) $(SOFTFLOAT) $(FORMATS_LIB) $(LIBOCORE) $(RESFILE)
-
-$(EMULATOR): $(VERSIONOBJ) $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DEVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
+$(EMULATOR): $(VERSIONOBJ) $(EMUINFOOBJ) $(DRIVLISTOBJ) $(DEVLISTOBJ) $(DRVLIBS) $(LIBOSD) $(LIBCPU) $(LIBEMU) $(LIBDASM) $(LIBSOUND) $(LIBUTIL) $(EXPAT) $(SOFTFLOAT) $(JPEG_LIB) $(FLAC_LIB) $(7Z_LIB) $(FORMATS_LIB) $(ZLIB) $(LIBOCORE) $(RESFILE)
+	$(CC) $(CDEFS) $(CFLAGS) -c $(SRC)/version.c -o $(VERSIONOBJ)
 	@echo Linking $@...
 	$(LD) $(LDFLAGS) $(LDFLAGSEMULATOR) $^ $(LIBS) -o $@
 ifeq ($(TARGETOS),win32)
diff -Nru src-old/emu/audit.c src/emu/audit.c
--- src-old/emu/audit.c	2012-02-04 21:30:08.000000000 +0100
+++ src/emu/audit.c	2012-02-19 02:53:16.000000000 +0100
@@ -39,7 +39,6 @@
 
 #include "emu.h"
 #include "emuopts.h"
-#include "hash.h"
 #include "audit.h"
 #include "harddisk.h"
 #include "sound/samples.h"
@@ -237,54 +236,40 @@
 	samples_device_iterator iter(m_enumerator.config().root_device());
 	for (samples_device *device = iter.first(); device != NULL; device = iter.next())
 	{
-		const samples_interface *intf = reinterpret_cast<const samples_interface *>(device->static_config());
-		if (intf->samplenames != NULL)
-		{
-			// by default we just search using the driver name
-			astring searchpath(m_enumerator.driver().name);
+		// by default we just search using the driver name
+		astring searchpath(m_enumerator.driver().name);
 
-			// iterate over samples in this entry
-			for (int sampnum = 0; intf->samplenames[sampnum] != NULL; sampnum++)
-			{
-				// starred entries indicate an additional searchpath
-				if (intf->samplenames[sampnum][0] == '*')
-				{
-					searchpath.cat(";").cat(&intf->samplenames[sampnum][1]);
-					continue;
-				}
+		// add the alternate path if present
+		samples_iterator iter(*device);
+		if (iter.altbasename() != NULL)
+			searchpath.cat(";").cat(iter.altbasename());
 
-				required++;
-
-				// create a new record
-				audit_record &record = m_record_list.append(*global_alloc(audit_record(intf->samplenames[sampnum], audit_record::MEDIA_SAMPLE)));
-
-				// look for the files
-				emu_file file(m_enumerator.options().sample_path(), OPEN_FLAG_READ | OPEN_FLAG_NO_PRELOAD);
-				path_iterator path(searchpath);
-				astring curpath;
-				while (path.next(curpath, intf->samplenames[sampnum]))
-				{
-					astring wholepath;
-					wholepath = curpath + ".flac";
+		// iterate over samples in this entry
+		for (const char *samplename = iter.first(); samplename != NULL; samplename = iter.next())
+		{
+			required++;
 
-					// attempt to access the file (.flac)
-					file_error filerr = file.open(wholepath);
+			// create a new record
+			audit_record &record = m_record_list.append(*global_alloc(audit_record(samplename, audit_record::MEDIA_SAMPLE)));
 
-					if (filerr != FILERR_NONE)
-					{
-						wholepath = curpath + ".wav";
-						// try again with .wav
-						filerr = file.open(wholepath);
-					}
+			// look for the files
+			emu_file file(m_enumerator.options().sample_path(), OPEN_FLAG_READ | OPEN_FLAG_NO_PRELOAD);
+			path_iterator path(searchpath);
+			astring curpath;
+			while (path.next(curpath, samplename))
+			{
+				// attempt to access the file (.flac) or (.wav)
+				file_error filerr = file.open(curpath, ".flac");
+				if (filerr != FILERR_NONE)
+					filerr = file.open(curpath, ".wav");
 
-					if (filerr == FILERR_NONE)
-					{
-						record.set_status(audit_record::STATUS_GOOD, audit_record::SUBSTATUS_GOOD);
-						found++;
-					}
-					else
-						record.set_status(audit_record::STATUS_NOT_FOUND, audit_record::SUBSTATUS_NOT_FOUND);
+				if (filerr == FILERR_NONE)
+				{
+					record.set_status(audit_record::STATUS_GOOD, audit_record::SUBSTATUS_GOOD);
+					found++;
 				}
+				else
+					record.set_status(audit_record::STATUS_NOT_FOUND, audit_record::SUBSTATUS_NOT_FOUND);
 			}
 		}
 	}
@@ -437,27 +422,20 @@
 	audit_record &record = m_record_list.append(*global_alloc(audit_record(*rom, audit_record::MEDIA_DISK)));
 
 	// open the disk
-	emu_file *source_file;
-	chd_file *source;
-	chd_error err = open_disk_image(m_enumerator.options(), &m_enumerator.driver(), rom, &source_file, &source, NULL);
+	chd_file source;
+	chd_error err = chd_error(open_disk_image(m_enumerator.options(), &m_enumerator.driver(), rom, source, NULL));
 
 	// if we succeeded, get the hashes
 	if (err == CHDERR_NONE)
 	{
-		static const UINT8 nullhash[20] = { 0 };
-		chd_header header = *chd_get_header(source);
 		hash_collection hashes;
 
 		// if there's a SHA1 hash, add them to the output hash
-		if (memcmp(nullhash, header.sha1, sizeof(header.sha1)) != 0)
-			hashes.add_from_buffer(hash_collection::HASH_SHA1, header.sha1, sizeof(header.sha1));
+		if (source.sha1() != sha1_t::null)
+			hashes.add_sha1(source.sha1());
 
 		// update the actual values
 		record.set_actual(hashes);
-
-		// close the file and release the source
-		chd_close(source);
-		global_free(source_file);
 	}
 
 	// compute the final status
diff -Nru src-old/emu/cheat.c src/emu/cheat.c
--- src-old/emu/cheat.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/cheat.c	2012-02-06 02:30:22.000000000 +0100
@@ -105,7 +105,6 @@
 #include "emuopts.h"
 #include "xmlfile.h"
 #include "ui.h"
-#include "uimenu.h"
 #include "cheat.h"
 #include "debug/debugcpu.h"
 
diff -Nru src-old/emu/clifront.c src/emu/clifront.c
--- src-old/emu/clifront.c	2012-01-25 16:20:11.000000000 +0100
+++ src/emu/clifront.c	2012-02-19 16:23:23.000000000 +0100
@@ -38,12 +38,13 @@
 ***************************************************************************/
 
 #include "emu.h"
+#include "chd.h"
 #include "emuopts.h"
-#include "hash.h"
 #include "jedparse.h"
 #include "audit.h"
 #include "info.h"
 #include "unzip.h"
+#include "un7z.h"
 #include "validity.h"
 #include "sound/samples.h"
 #include "clifront.h"
@@ -150,8 +151,76 @@
 	m_result = MAMERR_NONE;
 	try
 	{
-		// parse the command line, adding any system-specific options
+		// first parse options to be able to get software from it
 		astring option_errors;
+		m_options.parse_command_line(argc, argv, option_errors);
+		if (strlen(m_options.software_name()) > 0)
+		{
+			const game_driver *system = m_options.system();
+			if (system == NULL && strlen(m_options.system_name()) > 0)
+				throw emu_fatalerror(MAMERR_NO_SUCH_GAME, "Unknown system '%s'", m_options.system_name());
+
+			machine_config config(*system, m_options);
+			software_list_device_iterator iter(config.root_device());
+			if (iter.first() == NULL)
+				throw emu_fatalerror(MAMERR_FATALERROR, "Error: unknown option: %s\n", m_options.software_name());
+
+			bool found = FALSE;
+			for (software_list_device *swlist = iter.first(); swlist != NULL; swlist = iter.next())
+			{
+				software_list *list = software_list_open(m_options, swlist->list_name(), FALSE, NULL);
+				if (list)
+				{
+					software_info *swinfo = software_list_find(list, m_options.software_name(), NULL);
+					if (swinfo != NULL)
+					{
+						// loop through all parts
+						for (software_part *swpart = software_find_part(swinfo, NULL, NULL); swpart != NULL; swpart = software_part_next(swpart))
+						{
+							const char *mount = software_part_get_feature(swpart, "automount");
+							if (is_software_compatible(swpart, swlist))
+							{
+								if (mount == NULL || strcmp(mount,"no") != 0)
+								{
+									// search for an image device with the right interface
+									image_interface_iterator imgiter(config.root_device());
+									for (device_image_interface *image = imgiter.first(); image != NULL; image = imgiter.next())
+									{
+										const char *interface = image->image_interface();
+										if (interface != NULL)
+										{
+											if (!strcmp(interface, swpart->interface_))
+											{
+												const char *option = m_options.value(image->brief_instance_name());
+												// mount only if not already mounted
+												if (strlen(option) == 0)
+												{
+													astring val;
+													val.printf("%s:%s:%s",swlist->list_name(),m_options.software_name(),swpart->name);
+													// call this in order to set slot devices according to mounting
+													m_options.parse_slot_devices(argc, argv, option_errors, image->instance_name(), val.cstr());
+													break;
+												}
+											}
+										}
+									}
+								}
+								found = TRUE;
+							}
+						}
+					}
+					software_list_close(list);
+				}
+
+				if (found) break;
+			}
+			if (!found)
+			{
+				software_display_matches(config,m_options, NULL,m_options.software_name());
+				throw emu_fatalerror(MAMERR_FATALERROR, "");
+			}
+		}
+		// parse the command line, adding any system-specific options
 		if (!m_options.parse_command_line(argc, argv, option_errors))
 		{
 			// if we failed, check for no command and a system name first; in that case error on the name
@@ -179,69 +248,6 @@
 			const game_driver *system = m_options.system();
 			if (system == NULL && strlen(m_options.system_name()) > 0)
 				throw emu_fatalerror(MAMERR_NO_SUCH_GAME, "Unknown system '%s'", m_options.system_name());
-
-			if (strlen(m_options.software_name()) > 0)
-			{
-				machine_config config(*system, m_options);
-				software_list_device_iterator iter(config.root_device());
-				if (iter.first() == NULL)
-					throw emu_fatalerror(MAMERR_FATALERROR, "Error: unknown option: %s\n", m_options.software_name());
-
-				bool found = FALSE;
-				for (software_list_device *swlist = iter.first(); swlist != NULL; swlist = iter.next())
-				{
-					software_list *list = software_list_open(m_options, swlist->list_name(), FALSE, NULL);
-					if (list)
-					{
-						software_info *swinfo = software_list_find(list, m_options.software_name(), NULL);
-						if (swinfo != NULL)
-						{
-							// loop through all parts
-							for (software_part *swpart = software_find_part(swinfo, NULL, NULL); swpart != NULL; swpart = software_part_next(swpart))
-							{
-								const char *mount = software_part_get_feature(swpart, "automount");
-								if (is_software_compatible(swpart, swlist))
-								{
-									if (mount == NULL || strcmp(mount,"no") != 0)
-									{
-										// search for an image device with the right interface
-										image_interface_iterator imgiter(config.root_device());
-										for (device_image_interface *image = imgiter.first(); image != NULL; image = imgiter.next())
-										{
-											const char *interface = image->image_interface();
-											if (interface != NULL)
-											{
-												if (!strcmp(interface, swpart->interface_))
-												{
-													const char *option = m_options.value(image->brief_instance_name());
-													// mount only if not already mounted
-													if (strlen(option) == 0)
-													{
-														astring val;
-														val.printf("%s:%s:%s",swlist->list_name(),m_options.software_name(),swpart->name);
-														// call this in order to set slot devices according to mounting
-														m_options.parse_slot_devices(argc, argv, option_errors, image->instance_name(), val.cstr());
-														break;
-													}
-												}
-											}
-										}
-									}
-									found = TRUE;
-								}
-							}
-						}
-						software_list_close(list);
-					}
-
-					if (found) break;
-				}
-				if (!found)
-				{
-					software_display_matches(config,m_options, NULL,m_options.software_name());
-					throw emu_fatalerror(MAMERR_FATALERROR, "");
-				}
-			}
 			// otherwise just run the game
 			m_result = mame_execute(m_options, m_osd);
 		}
@@ -561,15 +567,12 @@
 		first = false;
 		mame_printf_info("Samples required for driver \"%s\".\n", drivlist.driver().name);
 
-		// iterate over samples devices
+		// iterate over samples devices and print the samples from each one
 		for (samples_device *device = iter.first(); device != NULL; device = iter.next())
 		{
-			// if the list is legit, walk it and print the sample info
-			const char *const *samplenames = reinterpret_cast<const samples_interface *>(device->static_config())->samplenames;
-			if (samplenames != NULL)
-				for (int sampnum = 0; samplenames[sampnum] != NULL; sampnum++)
-					if (samplenames[sampnum][0] != '*')
-						mame_printf_info("%s\n", samplenames[sampnum]);
+			samples_iterator sampiter(*device);
+			for (const char *samplename = sampiter.first(); samplename != NULL; samplename = sampiter.next())
+				mame_printf_info("%s\n", samplename);
 		}
 	}
 }
@@ -648,7 +651,7 @@
 
 			// get the options and print them
 			const slot_interface* intf = slot->get_slot_interfaces();
-			for (int i = 0; intf[i].name != NULL; i++)
+			for (int i = 0; intf && intf[i].name != NULL; i++)
 			{
 				device_t *dev = (*intf[i].devtype)(drivlist.config(), "dummy", &drivlist.config().root_device(), 0);
 				dev->config_complete();
@@ -1075,6 +1078,7 @@
 
 	drivlist.reset();
 	list_count = 0;
+	astring tempstr;
 	while (drivlist.next())
 	{
 		software_list_device_iterator iter(drivlist.config().root_device());
@@ -1153,19 +1157,9 @@
 
 											/* dump checksum information only if there is a known dump */
 											hash_collection hashes(ROM_GETHASHDATA(rom));
-											if (!hashes.flag(hash_collection::FLAG_NO_DUMP))
-											{
-												astring tempstr;
-												for (hash_base *hash = hashes.first(); hash != NULL; hash = hash->next())
-													fprintf(out, " %s=\"%s\"", hash->name(), hash->string(tempstr));
-											}
-
-											if (!is_disk)
-												fprintf( out, " offset=\"0x%x\"", ROM_GETOFFSET(rom) );
-
-											if ( hashes.flag(hash_collection::FLAG_BAD_DUMP) )
-												fprintf( out, " status=\"baddump\"" );
-											if ( hashes.flag(hash_collection::FLAG_NO_DUMP) )
+											if ( !hashes.flag(hash_collection::FLAG_NO_DUMP) )
+												fprintf( out, " %s", hashes.attribute_string(tempstr) );
+											else
 												fprintf( out, " status=\"nodump\"" );
 
 											if (is_disk)
@@ -1442,6 +1436,54 @@
 	}
 
 	// if that failed, and the filename ends with .zip, identify as a ZIP file
+	if (core_filename_ends_with(filename, ".7z"))
+	{
+		// first attempt to examine it as a valid _7Z file
+		_7z_file *_7z = NULL;
+		_7z_error _7zerr = _7z_file_open(filename, &_7z);
+		if (_7zerr == _7ZERR_NONE && _7z != NULL)
+		{
+			// loop over entries in the .7z, skipping empty files and directories
+			for (int i = 0; i < _7z->db.db.NumFiles; i++)
+			{
+				const CSzFileItem *f = _7z->db.db.Files + i;
+				_7z->curr_file_idx = i;
+				int namelen = SzArEx_GetFileNameUtf16(&_7z->db, i, NULL);
+				UINT16* temp = (UINT16 *)malloc(namelen * sizeof(UINT16));
+				void* temp2 = malloc((namelen+1) * sizeof(UINT8));
+				UINT8* temp3 = (UINT8*)temp2;
+				memset(temp3, 0x00, namelen);
+				SzArEx_GetFileNameUtf16(&_7z->db, i, temp);
+				// crude, need real UTF16->UTF8 conversion ideally
+				for (int j=0;j<namelen;j++)
+				{
+					temp3[j] = (UINT8)temp[j];
+				}
+
+				if (!(f->IsDir) && (f->Size != 0))
+				{
+					UINT8 *data = global_alloc_array(UINT8, f->Size);
+					if (data != NULL)
+					{
+						// decompress data into RAM and identify it
+						_7zerr = _7z_file_decompress(_7z, data, f->Size);
+						if (_7zerr == _7ZERR_NONE)
+							identify_data((const char*)temp2, data, f->Size);
+						global_free(data);
+					}
+				}
+
+				free(temp);
+				free(temp2);
+			}
+
+			// close up
+			_7z_file_close(_7z);
+		}
+
+		// clear out any cached files
+		_7z_file_cache_clear();
+	}
 	else if (core_filename_ends_with(filename, ".zip"))
 	{
 		// first attempt to examine it as a valid ZIP file
@@ -1493,8 +1535,8 @@
 		m_total++;
 
 		// attempt to open as a CHD; fail if not
-		chd_file *chd;
-		chd_error err = chd_open(name, CHD_OPEN_READ, NULL, &chd);
+		chd_file chd;
+		chd_error err = chd.open(name);
 		if (err != CHDERR_NONE)
 		{
 			mame_printf_info("NOT A CHD\n");
@@ -1502,26 +1544,20 @@
 			return;
 		}
 
-		// fetch the header and close the file
-		chd_header header = *chd_get_header(chd);
-		chd_close(chd);
-
 		// error on writable CHDs
-		if (header.flags & CHDFLAGS_IS_WRITEABLE)
+		if (!chd.compressed())
 		{
 			mame_printf_info("is a writeable CHD\n");
 			return;
 		}
 
 		// otherwise, get the hash collection for this CHD
-		static const UINT8 nullhash[20] = { 0 };
 		hash_collection hashes;
-
-		if (memcmp(nullhash, header.sha1, sizeof(header.sha1)) != 0)
-			hashes.add_from_buffer(hash_collection::HASH_SHA1, header.sha1, sizeof(header.sha1));
+		if (chd.sha1() != sha1_t::null)
+			hashes.add_sha1(chd.sha1());
 
 		// determine whether this file exists
-		int found = find_by_hash(hashes, header.logicalbytes);
+		int found = find_by_hash(hashes, chd.logical_bytes());
 		if (found == 0)
 			mame_printf_info("NO MATCH\n");
 		else
diff -Nru src-old/emu/cpu/i386/i386.c src/emu/cpu/i386/i386.c
--- src-old/emu/cpu/i386/i386.c	2012-02-02 15:58:18.000000000 +0100
+++ src/emu/cpu/i386/i386.c	2012-02-08 22:26:25.000000000 +0100
@@ -588,7 +588,6 @@
 		UINT16 flags;
 		I386_SREG desc;
 		UINT8 CPL = cpustate->CPL, DPL = 0; //, RPL = 0;
-		I386_CALL_GATE gate;
 
 		/* 32-bit */
 		v1 = READ32(cpustate, cpustate->idtr.base + entry );
@@ -691,11 +690,8 @@
 		if(type == 0x05)
 		{
 			/* Task gate */
-			memset(&gate, 0, sizeof(gate));
-			gate.segment = segment;
-			i386_load_call_gate(cpustate,&gate);
 			memset(&desc, 0, sizeof(desc));
-			desc.selector = gate.selector;
+			desc.selector = segment;
 			i386_load_protected_mode_segment(cpustate,&desc);
 			if(segment & 0x04)
 			{
@@ -720,10 +716,12 @@
 				logerror("IRQ: Task gate: TSS is not present.\n");
 				FAULT_EXP(FAULT_NP,segment & ~0x07);
 			}
+			if(!(irq == 3 || irq == 4 || irq == 9 || irq_gate == 1))
+				cpustate->eip = cpustate->prev_eip;
 			if(desc.flags & 0x08)
-				i386_task_switch(cpustate,desc.selector,0);
+				i386_task_switch(cpustate,desc.selector,1);
 			else
-				i286_task_switch(cpustate,desc.selector,0);
+				i286_task_switch(cpustate,desc.selector,1);
 			return;
 		}
 		else
@@ -949,6 +947,12 @@
 			UINT32 v2,type;
 			v2 = READ32(cpustate, cpustate->idtr.base + entry + 4 );
 			type = (v2>>8) & 0x1F;
+			if(type == 5)
+			{
+				v2 = READ32(cpustate, cpustate->idtr.base + entry);
+				v2 = READ32(cpustate, cpustate->gdtr.base + ((v2 >> 16) & 0xfff8) + 4);
+				type = (v2>>8) & 0x1F;
+			}
 			if(type >= 9)
 				PUSH32(cpustate,error);
 			else
@@ -1915,9 +1919,10 @@
 	I386_SREG desc;
 	UINT8 CPL, RPL, DPL;
 
+	UINT32 ea = i386_translate(cpustate, SS, (STACK_32BIT)?REG32(ESP):REG16(SP), 0);
+
 	if(operand32 == 0)
 	{
-		UINT32 ea = i386_translate(cpustate, SS, REG16(SP), 0);
 		newEIP = READ16(cpustate, ea) & 0xffff;
 		newCS = READ16(cpustate, ea+2) & 0xffff;
 		ea += count+4;
@@ -1926,7 +1931,6 @@
 	}
 	else
 	{
-		UINT32 ea = i386_translate(cpustate, SS, REG32(ESP), 0);
 		newEIP = READ32(cpustate, ea);
 		newCS = READ32(cpustate, ea+4) & 0xffff;
 		ea += count+8;
@@ -2181,9 +2185,9 @@
 	UINT32 newflags;
 
 	CPL = cpustate->CPL;
+	UINT32 ea = i386_translate(cpustate, SS, (STACK_32BIT)?REG32(ESP):REG16(SP), 0);
 	if(operand32 == 0)
 	{
-		UINT32 ea = i386_translate(cpustate, SS, REG16(SP), 0);
 		newEIP = READ16(cpustate, ea) & 0xffff;
 		newCS = READ16(cpustate, ea+2) & 0xffff;
 		newflags = READ16(cpustate, ea+4) & 0xffff;
@@ -2192,7 +2196,6 @@
 	}
 	else
 	{
-		UINT32 ea = i386_translate(cpustate, SS, REG32(ESP), 0);
 		newEIP = READ32(cpustate, ea);
 		newCS = READ32(cpustate, ea+4) & 0xffff;
 		newflags = READ32(cpustate, ea+8);
@@ -3096,6 +3099,7 @@
 		cpustate->address_prefix = 0;
 
 		cpustate->ext = 1;
+		cpustate->old_tf = cpustate->TF;
 
 		cpustate->segment_prefix = 0;
 		cpustate->prev_eip = cpustate->eip;
@@ -3110,6 +3114,13 @@
 		try
 		{
 			I386OP(decode_opcode)(cpustate);
+			if(cpustate->TF && cpustate->old_tf)
+			{
+				cpustate->prev_eip = cpustate->eip;
+				cpustate->ext = 0;
+				i386_trap(cpustate,1,0,0);
+			}
+
 		}
 		catch(UINT64 e)
 		{
diff -Nru src-old/emu/cpu/i386/i386priv.h src/emu/cpu/i386/i386priv.h
--- src-old/emu/cpu/i386/i386priv.h	2012-02-02 15:58:18.000000000 +0100
+++ src/emu/cpu/i386/i386priv.h	2012-02-08 22:26:25.000000000 +0100
@@ -240,6 +240,7 @@
 
 	UINT8 performed_intersegment_jump;
 	UINT8 delayed_interrupt_enable;
+	UINT8 old_tf;
 
 	UINT32 cr[5];		// Control registers
 	UINT32 dr[8];		// Debug registers
diff -Nru src-old/emu/cpu/i386/x87ops.c src/emu/cpu/i386/x87ops.c
--- src-old/emu/cpu/i386/x87ops.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/cpu/i386/x87ops.c	2012-02-11 09:13:49.000000000 +0100
@@ -4566,10 +4566,11 @@
 			switch (modrm)
 			{
 				case 0xc0: case 0xc1: case 0xc2: case 0xc3: case 0xc4: case 0xc5: case 0xc6: case 0xc7: ptr = x87_ffree;		break;
+				case 0xc8: case 0xc9: case 0xca: case 0xcb: case 0xcc: case 0xcd: case 0xce: case 0xcf: ptr = x87_fxch_sti;		break;
 				case 0xd0: case 0xd1: case 0xd2: case 0xd3: case 0xd4: case 0xd5: case 0xd6: case 0xd7: ptr = x87_fst_sti;		break;
 				case 0xd8: case 0xd9: case 0xda: case 0xdb: case 0xdc: case 0xdd: case 0xde: case 0xdf: ptr = x87_fstp_sti;		break;
 				case 0xe0: case 0xe1: case 0xe2: case 0xe3: case 0xe4: case 0xe5: case 0xe6: case 0xe7: ptr = x87_fucom_sti;	break;
-				case 0xf0: case 0xf1: case 0xf2: case 0xf3: case 0xf4: case 0xf5: case 0xf6: case 0xf7: ptr = x87_fucomp_sti;	break;
+				case 0xe8: case 0xe9: case 0xea: case 0xeb: case 0xec: case 0xed: case 0xee: case 0xef: ptr = x87_fucomp_sti;	break;
 			}
 		}
 
diff -Nru src-old/emu/cpu/m68000/m68k_in.c src/emu/cpu/m68000/m68k_in.c
--- src-old/emu/cpu/m68000/m68k_in.c	2011-11-02 23:18:24.000000000 +0100
+++ src/emu/cpu/m68000/m68k_in.c	2012-02-19 16:23:23.000000000 +0100
@@ -760,6 +760,7 @@
 pack      16  mm    .     1000...101001...  ..........  . . U U U U U   .   .  13  13  13  13  13
 pea       32  .     .     0100100001......  A..DXWLdx.  U U U U U U U   6   6   5   5   5   5   5
 pflush    32  .     .     1111010100011000  ..........  . . . . S S .   .   .   .   .   4   4   4 TODO: correct timing
+pflushan  32  .     .     1111010100010000  ..........  . . . . S S .   .   .   .   .   4   4   4 TODO: correct timing
 pmmu      32  .     .     1111000.........  ..........  . . S S S S S   .   .   8   8   8   8   8
 ptest     32  .     .     1111010101.01...  ..........  . . . . S . .   .   .   .   .   8   .   .
 reset      0  .     .     0100111001110000  ..........  S S S S S S S   0   0   0   0   0   0   0
@@ -8214,6 +8215,16 @@
 	m68ki_exception_1111(mc68kcpu);
 }
 
+M68KMAKE_OP(pflushan, 32, ., .)
+{
+	if ((CPU_TYPE_IS_EC020_PLUS((mc68kcpu)->cpu_type)) && ((mc68kcpu)->has_pmmu))
+	{
+		logerror("68040: unhandled PFLUSHAN\n");
+		return;
+	}
+	m68ki_exception_1111(mc68kcpu);
+}
+
 M68KMAKE_OP(pmmu, 32, ., .)
 {
 	if ((CPU_TYPE_IS_EC020_PLUS((mc68kcpu)->cpu_type)) && ((mc68kcpu)->has_pmmu))
@@ -9017,6 +9028,31 @@
 				(mc68kcpu)->instr_mode = INSTRUCTION_YES;
 				(mc68kcpu)->run_mode = RUN_MODE_NORMAL;
 				return;
+			case 7: /* 68040 access error */
+				new_sr = m68ki_pull_16(mc68kcpu);
+				new_pc = m68ki_pull_32(mc68kcpu);
+				m68ki_fake_pull_16(mc68kcpu);	/* $06: format word */
+				m68ki_fake_pull_32(mc68kcpu);	/* $08: effective address */
+				m68ki_fake_pull_16(mc68kcpu);	/* $0c: special status word */
+				m68ki_fake_pull_16(mc68kcpu);	/* $0e: wb3s */
+				m68ki_fake_pull_16(mc68kcpu);	/* $10: wb2s */
+				m68ki_fake_pull_16(mc68kcpu);	/* $12: wb1s */
+				m68ki_fake_pull_32(mc68kcpu);	/* $14: data fault address */
+				m68ki_fake_pull_32(mc68kcpu);	/* $18: wb3a */
+				m68ki_fake_pull_32(mc68kcpu);	/* $1c: wb3d */
+				m68ki_fake_pull_32(mc68kcpu);	/* $20: wb2a */
+				m68ki_fake_pull_32(mc68kcpu);	/* $24: wb2d */
+				m68ki_fake_pull_32(mc68kcpu);	/* $28: wb1a */
+				m68ki_fake_pull_32(mc68kcpu);	/* $2c: wb1d/pd0 */
+				m68ki_fake_pull_32(mc68kcpu);	/* $30: pd1 */
+				m68ki_fake_pull_32(mc68kcpu);	/* $34: pd2 */
+				m68ki_fake_pull_32(mc68kcpu);	/* $38: pd3 */
+				m68ki_jump((mc68kcpu), new_pc);
+				m68ki_set_sr((mc68kcpu), new_sr);
+				(mc68kcpu)->instr_mode = INSTRUCTION_YES;
+				(mc68kcpu)->run_mode = RUN_MODE_NORMAL;
+				return;
+
 			case 0x0a: /* Bus Error at instruction boundary */
 				new_sr = m68ki_pull_16(mc68kcpu);
 				new_pc = m68ki_pull_32(mc68kcpu);
@@ -10447,8 +10483,17 @@
 {
 	if(CPU_TYPE_IS_040_PLUS((mc68kcpu)->cpu_type))
 	{
-		logerror("%s at %08x: called unimplemented instruction %04x (cinv)\n",
-					 (mc68kcpu)->device->tag(), REG_PC(mc68kcpu) - 2, (mc68kcpu)->ir);
+		UINT16 ir = mc68kcpu->ir;
+		UINT8 cache = (ir >> 6) & 3;
+//      UINT8 scope = (ir >> 3) & 3;
+//      logerror("68040 %s: pc=%08x ir=%04x cache=%d scope=%d register=%d\n", ir & 0x0020 ? "cpush" : "cinv", REG_PPC(mc68kcpu), ir, cache, scope, ir & 7);
+		switch (cache)
+		{
+		case 2:
+		case 3:
+			// we invalidate/push the whole instruction cache
+			m68ki_ic_clear(mc68kcpu);
+		}
 		return;
 	}
 	m68ki_exception_1111(mc68kcpu);
diff -Nru src-old/emu/cpu/m68000/m68kcpu.c src/emu/cpu/m68000/m68kcpu.c
--- src-old/emu/cpu/m68000/m68kcpu.c	2011-12-12 15:20:12.000000000 +0100
+++ src/emu/cpu/m68000/m68kcpu.c	2012-02-16 15:02:34.000000000 +0100
@@ -741,15 +741,16 @@
 		{
 			// FIXME: mmu_tmp_sr will be overwritten in pmmu_translate_addr_with_fc
 			UINT16 mmu_tmp_sr = m68k->mmu_tmp_sr;
+			int mode = m68k->s_flag ? FUNCTION_CODE_SUPERVISOR_PROGRAM : FUNCTION_CODE_USER_PROGRAM;
 //          UINT32 va=*address;
 
 			if (CPU_TYPE_IS_040_PLUS(m68k->cpu_type))
 			{
-				*address = pmmu_translate_addr_with_fc_040(m68k, *address, FUNCTION_CODE_SUPERVISOR_PROGRAM, 1);
+				*address = pmmu_translate_addr_with_fc_040(m68k, *address, mode, 1);
 			}
 			else
 			{
-				*address = pmmu_translate_addr_with_fc(m68k, *address, FUNCTION_CODE_SUPERVISOR_PROGRAM, 1);
+				*address = pmmu_translate_addr_with_fc(m68k, *address, mode, 1);
 			}
 
 			if ((m68k->mmu_tmp_sr & M68K_MMU_SR_INVALID) != 0) {
@@ -801,7 +802,7 @@
 	/* Make sure we're not stopped */
 	if(!m68k->stopped)
 	{
-		/* Return point if we had an address error */
+        /* Return point if we had an address error */
 		m68ki_set_address_error_trap(m68k); /* auto-disable (see m68kcpu.h) */
 
 		/* Main loop.  Keep going until we run out of clock cycles */
@@ -877,13 +878,19 @@
 						/* Note: This is implemented for 68000 only! */
 						m68ki_stack_frame_buserr(m68k, sr);
 					}
-					else if (m68k->mmu_tmp_buserror_address == REG_PPC(m68k))
-					{
-						m68ki_stack_frame_1010(m68k, sr, EXCEPTION_BUS_ERROR, REG_PPC(m68k), m68k->mmu_tmp_buserror_address);
+					else if(!CPU_TYPE_IS_040_PLUS(m68k->cpu_type)) {
+						if (m68k->mmu_tmp_buserror_address == REG_PPC(m68k))
+						{
+							m68ki_stack_frame_1010(m68k, sr, EXCEPTION_BUS_ERROR, REG_PPC(m68k), m68k->mmu_tmp_buserror_address);
+						}
+						else
+						{
+							m68ki_stack_frame_1011(m68k, sr, EXCEPTION_BUS_ERROR, REG_PPC(m68k), m68k->mmu_tmp_buserror_address);
+						}
 					}
 					else
 					{
-						m68ki_stack_frame_1011(m68k, sr, EXCEPTION_BUS_ERROR, REG_PPC(m68k), m68k->mmu_tmp_buserror_address);
+						m68ki_stack_frame_0111(m68k, sr, EXCEPTION_BUS_ERROR, REG_PPC(m68k), m68k->mmu_tmp_buserror_address, true);
 					}
 
 					m68ki_jump_vector(m68k, EXCEPTION_BUS_ERROR);
diff -Nru src-old/emu/cpu/m68000/m68kcpu.h src/emu/cpu/m68000/m68kcpu.h
--- src-old/emu/cpu/m68000/m68kcpu.h	2011-10-14 14:09:09.000000000 +0200
+++ src/emu/cpu/m68000/m68kcpu.h	2012-02-14 10:27:58.000000000 +0100
@@ -828,6 +828,7 @@
 INLINE void m68ki_stack_frame_1000(m68ki_cpu_core *m68k, UINT32 pc, UINT32 sr, UINT32 vector);
 INLINE void m68ki_stack_frame_1010(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address);
 INLINE void m68ki_stack_frame_1011(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address);
+INLINE void m68ki_stack_frame_0111(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address, bool in_mmu);
 
 INLINE void m68ki_exception_trap(m68ki_cpu_core *m68k, UINT32 vector);
 INLINE void m68ki_exception_trapN(m68ki_cpu_core *m68k, UINT32 vector);
@@ -1571,6 +1572,7 @@
 void m68ki_stack_frame_1010(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
 	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_fc;
 
 	/* INTERNAL REGISTER */
 	m68ki_push_16(m68k, 0);
@@ -1599,7 +1601,7 @@
 	/* SPECIAL STATUS REGISTER */
 	// set bit for: Rerun Faulted bus Cycle, or run pending prefetch
 	// set FC
-	m68ki_push_16(m68k, 0x0100 | m68k->mmu_tmp_fc | orig_rw<<6);
+	m68ki_push_16(m68k, 0x0100 | orig_fc | orig_rw<<6);
 
 	/* INTERNAL REGISTER */
 	m68ki_push_16(m68k, 0);
@@ -1622,6 +1624,7 @@
 void m68ki_stack_frame_1011(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address)
 {
 	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_fc;
 
 	/* INTERNAL REGISTERS (18 words) */
 	m68ki_push_32(m68k, 0);
@@ -1673,7 +1676,7 @@
 	m68ki_push_16(m68k, 0);
 
 	/* SPECIAL STATUS REGISTER */
-	m68ki_push_16(m68k, 0x0100 | m68k->mmu_tmp_fc | orig_rw<<6);
+	m68ki_push_16(m68k, 0x0100 | orig_fc | orig_rw<<6);
 
 	/* INTERNAL REGISTER */
 	m68ki_push_16(m68k, 0);
@@ -1688,6 +1691,49 @@
 	m68ki_push_16(m68k, sr);
 }
 
+/* Type 7 stack frame (access fault).
+ * This is used by the 68040 for bus fault and mmu trap
+ * 30 words
+ */
+void m68ki_stack_frame_0111(m68ki_cpu_core *m68k, UINT32 sr, UINT32 vector, UINT32 pc, UINT32 fault_address, bool in_mmu)
+{
+	int orig_rw = m68k->mmu_tmp_rw;	// this gets splatted by the following pushes, so save it now
+	int orig_fc = m68k->mmu_tmp_fc;
+
+	/* INTERNAL REGISTERS (18 words) */
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+	m68ki_push_32(m68k, 0);
+
+	/* FAULT ADDRESS (2 words) */
+	m68ki_push_32(m68k, fault_address);
+
+	/* INTERNAL REGISTERS (3 words) */
+	m68ki_push_32(m68k, 0);
+	m68ki_push_16(m68k, 0);
+
+	/* SPECIAL STATUS REGISTER (1 word) */
+	m68ki_push_16(m68k, (in_mmu ? 0x400 : 0) | orig_fc | (orig_rw<<8));
+
+	/* EFFECTIVE ADDRESS (2 words) */
+	m68ki_push_32(m68k, fault_address);
+
+	/* 0111, VECTOR OFFSET (1 word) */
+	m68ki_push_16(m68k, 0x7000 | (vector<<2));
+
+	/* PROGRAM COUNTER (2 words) */
+	m68ki_push_32(m68k, pc);
+
+	/* STATUS REGISTER (1 word) */
+	m68ki_push_16(m68k, sr);
+}
+
 
 /* Used for Group 2 exceptions.
  * These stack a type 2 frame on the 020.
diff -Nru src-old/emu/cpu/m68000/m68kfpu.c src/emu/cpu/m68000/m68kfpu.c
--- src-old/emu/cpu/m68000/m68kfpu.c	2012-01-23 22:49:46.000000000 +0100
+++ src/emu/cpu/m68000/m68kfpu.c	2012-02-18 11:58:12.000000000 +0100
@@ -5,6 +5,9 @@
 #define FPCC_I			0x02000000
 #define FPCC_NAN		0x01000000
 
+#define FPES_OE			0x00002000
+#define FPAE_IOP		0x00000080
+
 #define DOUBLE_INFINITY					U64(0x7ff0000000000000)
 #define DOUBLE_EXPONENT					U64(0x7ff0000000000000)
 #define DOUBLE_MANTISSA					U64(0x000fffffffffffff)
@@ -1390,7 +1393,9 @@
 		}
 		case 0x24:		// FSGLDIV
 		{
-			REG_FP(m68k)[dst] = floatx80_div(REG_FP(m68k)[dst], source);
+			float32 a = floatx80_to_float32( REG_FP(m68k)[dst] );
+			float32 b = floatx80_to_float32( source );
+			REG_FP(m68k)[dst] = float32_to_floatx80( float32_div(a, b) );
 			m68k->remaining_cycles -= 43; //  // ? (value is from FDIV)
 			break;
 		}
@@ -1403,7 +1408,9 @@
 		}
 		case 0x27:		// FSGLMUL
 		{
-			REG_FP(m68k)[dst] = floatx80_mul(REG_FP(m68k)[dst], source);
+			float32 a = floatx80_to_float32( REG_FP(m68k)[dst] );
+			float32 b = floatx80_to_float32( source );
+			REG_FP(m68k)[dst] = float32_to_floatx80( float32_mul(a, b) );
 			SET_CONDITION_CODES(m68k, REG_FP(m68k)[dst]);
 			m68k->remaining_cycles -= 11; // ? (value is from FMUL)
 			break;
@@ -1471,7 +1478,12 @@
 		}
 		case 4:		// Word Integer
 		{
-			WRITE_EA_16(m68k, ea, (INT16)floatx80_to_int32(REG_FP(m68k)[src]));
+			int32 value = floatx80_to_int32(REG_FP(m68k)[src]);
+			if (value > 0x7fff || value < -0x8000 )
+			{
+				REG_FPSR(m68k) |= FPES_OE | FPAE_IOP;
+			}
+			WRITE_EA_16(m68k, ea, (INT16)value);
 			break;
 		}
 		case 5:		// Double-precision Real
@@ -1485,7 +1497,12 @@
 		}
 		case 6:		// Byte Integer
 		{
-			WRITE_EA_8(m68k, ea, (INT8)floatx80_to_int32(REG_FP(m68k)[src]));
+			int32 value = floatx80_to_int32(REG_FP(m68k)[src]);
+			if (value > 127 || value < -128)
+			{
+				REG_FPSR(m68k) |= FPES_OE | FPAE_IOP;
+			}
+			WRITE_EA_8(m68k, ea, (INT8) value);
 			break;
 		}
 		case 7:		// Packed-decimal Real with Dynamic K-factor
@@ -1547,6 +1564,56 @@
 		}
 	}
 
+#if 0
+	// FIXME: (2011-12-18 ost)
+	// rounding_mode and rounding_precision of softfloat.c should be set according to current fpcr
+	// but:  with this code on Apollo the following programs in /systest/fptest will fail:
+	// 1. Single Precision Whetstone will return wrong results never the less
+	// 2. Vector Test will fault with 00040004: reference to illegal address
+
+	if ((regsel & 4) && dir == 0)
+	{
+		int rnd = (REG_FPCR(m68k) >> 4) & 3;
+		int prec = (REG_FPCR(m68k) >> 6) & 3;
+
+		logerror("m68k_fpsp:fmove_fpcr fpcr=%04x prec=%d rnd=%d\n", REG_FPCR(m68k), prec, rnd);
+
+#ifdef FLOATX80
+		switch (prec)
+		{
+		case 0: // Extend (X)
+			floatx80_rounding_precision = 80;
+			break;
+		case 1: // Single (S)
+			floatx80_rounding_precision = 32;
+			break;
+		case 2: // Double (D)
+			floatx80_rounding_precision = 64;
+			break;
+		case 3: // Undefined
+			floatx80_rounding_precision = 80;
+			break;
+		}
+#endif
+
+		switch (rnd)
+		{
+		case 0: // To Nearest (RN)
+			float_rounding_mode = float_round_nearest_even;
+			break;
+		case 1: // To Zero (RZ)
+			float_rounding_mode = float_round_to_zero;
+			break;
+		case 2: // To Minus Infinitiy (RM)
+			float_rounding_mode = float_round_down;
+			break;
+		case 3: // To Plus Infinitiy (RP)
+			float_rounding_mode = float_round_up;
+			break;
+		}
+	}
+#endif
+
 	m68k->remaining_cycles -= 10;
 }
 
@@ -1779,8 +1846,22 @@
 	}
 }
 
-static void perform_fsave(m68ki_cpu_core *m68k, UINT32 addr, int inc)
+static int perform_fsave(m68ki_cpu_core *m68k, UINT32 addr, int inc)
 {
+	if(m68k->cpu_type & CPU_TYPE_040)
+	{
+		if(inc)
+		{
+			m68ki_write_32(m68k, addr, 0x41000000);
+			return 4;
+		}
+		else
+		{
+			m68ki_write_32(m68k, addr-4, 0x41000000);
+			return -4;
+		}
+	}
+
 	if (inc)
 	{
 		// 68881 IDLE, version 0x1f
@@ -1791,16 +1872,18 @@
 		m68ki_write_32(m68k, addr+16, 0);
 		m68ki_write_32(m68k, addr+20, 0);
 		m68ki_write_32(m68k, addr+24, 0x70000000);
+		return 7*4;
 	}
 	else
 	{
-		m68ki_write_32(m68k, addr, 0x70000000);
-		m68ki_write_32(m68k, addr-4, 0);
+		m68ki_write_32(m68k, addr-4, 0x70000000);
 		m68ki_write_32(m68k, addr-8, 0);
 		m68ki_write_32(m68k, addr-12, 0);
 		m68ki_write_32(m68k, addr-16, 0);
 		m68ki_write_32(m68k, addr-20, 0);
-		m68ki_write_32(m68k, addr-24, 0x1f180000);
+		m68ki_write_32(m68k, addr-24, 0);
+		m68ki_write_32(m68k, addr-28, 0x1f180000);
+		return -7*4;
 	}
 }
 
@@ -1832,14 +1915,15 @@
 	else
 	{
 		// we normally generate an IDLE frame
+		int delta = perform_fsave(m68k, addr, inc);
 		if(reg != -1)
-			REG_A(m68k)[reg] += inc ? 6*4 : -6*4;
-		perform_fsave(m68k, addr, inc);
+			REG_A(m68k)[reg] += delta;
 	}
 }
 
 static void m68040_do_frestore(m68ki_cpu_core *m68k, UINT32 addr, int reg)
 {
+	bool m40 = m68k->cpu_type & CPU_TYPE_040;
 	UINT32 temp = m68ki_read_32(m68k, addr);
 
 	// check for NULL frame
@@ -1851,9 +1935,13 @@
 		if (reg != -1)
 		{
 			// how about an IDLE frame?
-			if ((temp & 0x00ff0000) == 0x00180000)
+			if (!m40 && ((temp & 0x00ff0000) == 0x00180000))
+			{
+				REG_A(m68k)[reg] += 7*4;
+			}
+			else if (m40 && ((temp & 0xffff0000) == 0x41000000))
 			{
-				REG_A(m68k)[reg] += 6*4;
+				REG_A(m68k)[reg] += 4;
 			} // check UNIMP
 			else if ((temp & 0x00ff0000) == 0x00380000)
 			{
@@ -1901,7 +1989,7 @@
 
 			case 5: // (D16, An)
 				addr = EA_AY_DI_16(m68k);
-				m68040_do_fsave(m68k, addr, -1, 0);
+				m68040_do_fsave(m68k, addr, -1, 1);
 				break;
 
 			case 7: //
diff -Nru src-old/emu/cpu/m68000/m68kmmu.h src/emu/cpu/m68000/m68kmmu.h
--- src-old/emu/cpu/m68000/m68kmmu.h	2012-01-02 07:38:21.000000000 +0100
+++ src/emu/cpu/m68000/m68kmmu.h	2012-02-19 16:23:23.000000000 +0100
@@ -260,6 +260,18 @@
 		}
 	}
 
+	if (m68k->mmu_tt1 & 0x8000)
+	{
+		// transparent translation register 1 enabled
+		UINT32 address_base = m68k->mmu_tt1 & 0xff000000;
+		UINT32 address_mask = ((m68k->mmu_tt1 << 8) & 0xff000000) ^ 0xff000000;
+		if ((addr_in & address_mask) == address_base)
+		{
+//          printf("PMMU: pc=%x TT1 fc=%x addr_in=%08x address_mask=%08x address_base=%08x\n", m68k->ppc, fc, addr_in, address_mask, address_base);
+			return addr_in;
+		}
+	}
+
 //  if ((++pmmu_access_count % 10000000) == 0) {
 //      printf("pmmu_translate_addr_with_fc: atc usage = %d%%\n", pmmu_atc_count*100/pmmu_access_count);
 //      pmmu_atc_count = pmmu_access_count = 0;
@@ -541,7 +553,7 @@
 
 		if ((addr_in & mask) == (tt0 & mask))
 		{
-//          printf("TT0 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt0, mask);
+			//          fprintf(stderr, "TT0 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt0, mask);
 			if ((tt0 & 4) && !m68k->mmu_tmp_rw && !ptest)	// write protect?
 			{
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
@@ -562,7 +574,7 @@
 
 		if ((addr_in & mask) == (tt1 & mask))
 		{
-//          printf("TT1 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt1, mask);
+			//          fprintf(stderr, "TT1 match on address %08x (TT0 = %08x, mask = %08x)\n", addr_in, tt1, mask);
 			if ((tt1 & 4) && !m68k->mmu_tmp_rw && !ptest)	// write protect?
 			{
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
@@ -595,7 +607,15 @@
 
 		// get the root entry
 		root_entry = m68k->program->read_dword(root_ptr);
-//      printf("root entry = %08x\n", root_entry);
+		static UINT32 psrp = 0, purp=0;
+		if(psrp != m68k->mmu_srp_aptr) {
+			psrp = m68k->mmu_srp_aptr;
+//          fprintf(stderr, "srp = %08x\n", psrp);
+		}
+		if(purp != m68k->mmu_urp_aptr) {
+			purp = m68k->mmu_urp_aptr;
+//          fprintf(stderr, "urp = %08x\n", purp);
+		}
 
 		// is UDT marked valid?
 		if (root_entry & 2)
@@ -603,7 +623,7 @@
 			pointer_ptr = (root_entry & ~0x1ff) + (ptr_idx<<2);
 			pointer_entry = m68k->program->read_dword(pointer_ptr);
 
-//          printf("pointer entry = %08x\n", pointer_entry);
+			//          fprintf(stderr, "pointer entry = %08x\n", pointer_entry);
 
 			// write protected by the root or pointer entries?
 			if ((((root_entry & 4) && !m68k->mmu_tmp_rw) || ((pointer_entry & 4) && !m68k->mmu_tmp_rw)) && !ptest)
@@ -619,7 +639,7 @@
 			// is UDT valid on the pointer entry?
 			if (!(pointer_entry & 2) && !ptest)
 			{
-//              printf("Invalid pointer entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+              fprintf(stderr, "Invalid pointer entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
 				{
 					m68k->mmu_tmp_buserror_address = addr_in;
@@ -632,7 +652,7 @@
 		}
 		else // throw an error
 		{
-//          printf("Invalid root entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+          fprintf(stderr, "Invalid root entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
 			if (!ptest)
 			{
 				if (++m68k->mmu_tmp_buserror_occurred == 1)
@@ -651,7 +671,7 @@
 			page = addr_in & 0x1fff;
 			pointer_entry &= ~0x7f;
 
-//          printf("8k pages: index %x page %x\n", page_idx, page);
+			//          fprintf(stderr, "8k pages: index %x page %x\n", page_idx, page);
 		}
 		else	// 4k pages
 		{
@@ -659,13 +679,13 @@
 			page = addr_in & 0xfff;
 			pointer_entry &= ~0xff;
 
-//          printf("4k pages: index %x page %x\n", page_idx, page);
+			//          fprintf(stderr, "4k pages: index %x page %x\n", page_idx, page);
 		}
 
 		page_ptr = pointer_entry + (page_idx<<2);
 		page_entry = m68k->program->read_dword(page_ptr);
 
-//      printf("page_entry = %08x\n", page_entry);
+		//      fprintf(stderr, "page_entry = %08x\n", page_entry);
 
 		// resolve indirect page pointers
 		while ((page_entry & 3) == 2)
@@ -687,7 +707,7 @@
 		switch (page_entry & 3)
 		{
 			case 0:	// invalid
-//              printf("Invalid page entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
+              fprintf(stderr, "Invalid page entry!  PC=%x, addr=%x\n", m68k->ppc, addr_in);
 				if (!ptest)
 				{
 					if (++m68k->mmu_tmp_buserror_occurred == 1)
@@ -716,7 +736,7 @@
 				fatalerror("68040: got indirect final page pointer, shouldn't be possible\n");
 				break;
 		}
-//      if (addr_in != addr_out) printf("040MMU: [%08x] => [%08x]\n", addr_in, addr_out);
+		//      if (addr_in != addr_out) fprintf(stderr, "040MMU: [%08x] => [%08x]\n", addr_in, addr_out);
 	}
 
 	return addr_out;
@@ -769,6 +789,11 @@
 		printf("680x0: unhandled PBcc\n");
 		return;
 	}
+	else if ((m68k->ir & 0xffe0) == 0xf500)
+	{
+//      logerror("68040 pflush: pc=%08x ir=%04x opmode=%d register=%d\n", REG_PPC(m68k), m68k->ir, (m68k->ir >> 3) & 3, m68k->ir & 7);
+		pmmu_atc_flush(m68k);
+	}
 	else	// the rest are 1111000xxxXXXXXX where xxx is the instruction family
 	{
 		switch ((m68k->ir>>9) & 0x7)
@@ -964,6 +989,20 @@
 												}
 												break;
 
+												case 7: // MC68851 Access Control Register
+													if (m68k->cpu_type == CPU_TYPE_020)
+													{
+														// DomainOS on Apollo DN3000 will only reset this to 0
+														UINT16 mmu_ac = READ_EA_16(m68k, ea);
+														if (mmu_ac != 0)
+														{
+															printf("680x0 PMMU: pc=%x PMOVE to mmu_ac=%08x\n",
+																	m68k->ppc, mmu_ac);
+														}
+														break;
+													}
+													// fall through; unknown PMOVE mode unless MC68020 with MC68851
+
 											default:
 												printf("680x0: PMOVE to unknown MMU register %x, PC %x\n", (modes>>10) & 7, m68k->pc);
 												break;
diff -Nru src-old/emu/cpu/mips/mips3.c src/emu/cpu/mips/mips3.c
--- src-old/emu/cpu/mips/mips3.c	2011-01-02 10:32:13.000000000 +0100
+++ src/emu/cpu/mips/mips3.c	2012-02-06 02:30:22.000000000 +0100
@@ -11,7 +11,6 @@
 
 #include "emu.h"
 #include "debugger.h"
-#include "profiler.h"
 #include "mips3.h"
 #include "mips3com.h"
 
diff -Nru src-old/emu/cpu/mips/mips3drc.c src/emu/cpu/mips/mips3drc.c
--- src-old/emu/cpu/mips/mips3drc.c	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/cpu/mips/mips3drc.c	2012-02-06 02:30:22.000000000 +0100
@@ -54,7 +54,6 @@
 
 #include "emu.h"
 #include "debugger.h"
-#include "profiler.h"
 #include "mips3com.h"
 #include "mips3fe.h"
 #include "cpu/drcfe.h"
diff -Nru src-old/emu/cpu/powerpc/ppcdrc.c src/emu/cpu/powerpc/ppcdrc.c
--- src-old/emu/cpu/powerpc/ppcdrc.c	2011-07-18 05:04:03.000000000 +0200
+++ src/emu/cpu/powerpc/ppcdrc.c	2012-02-06 02:30:22.000000000 +0100
@@ -18,7 +18,6 @@
 
 #include "emu.h"
 #include "debugger.h"
-#include "profiler.h"
 #include "ppccom.h"
 #include "ppcfe.h"
 #include "cpu/drcfe.h"
diff -Nru src-old/emu/cpu/rsp/rspdrc.c src/emu/cpu/rsp/rspdrc.c
--- src-old/emu/cpu/rsp/rspdrc.c	2012-02-03 22:06:10.000000000 +0100
+++ src/emu/cpu/rsp/rspdrc.c	2012-02-06 02:30:22.000000000 +0100
@@ -20,7 +20,6 @@
 
 #include "emu.h"
 #include "debugger.h"
-#include "profiler.h"
 #include "rsp.h"
 #include "rspdiv.h"
 #include "rspfe.h"
diff -Nru src-old/emu/cpu/sh2/sh2drc.c src/emu/cpu/sh2/sh2drc.c
--- src-old/emu/cpu/sh2/sh2drc.c	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/cpu/sh2/sh2drc.c	2012-02-06 02:30:22.000000000 +0100
@@ -19,7 +19,6 @@
 #include "debugger.h"
 #include "sh2.h"
 #include "sh2comn.h"
-#include "profiler.h"
 
 CPU_DISASSEMBLE( sh2 );
 extern unsigned DasmSH2(char *buffer, unsigned pc, UINT16 opcode);
diff -Nru src-old/emu/debugint/debugint.c src/emu/debugint/debugint.c
--- src-old/emu/debugint/debugint.c	2012-01-16 12:06:28.000000000 +0100
+++ src/emu/debugint/debugint.c	2012-02-06 02:30:22.000000000 +0100
@@ -12,9 +12,7 @@
 #include "emu.h"
 #include "ui.h"
 #include "rendfont.h"
-#include "uimenu.h"
 #include "uiinput.h"
-#include "video.h"
 #include "osdepend.h"
 
 #include "debug/debugvw.h"
diff -Nru src-old/emu/diexec.c src/emu/diexec.c
--- src-old/emu/diexec.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/diexec.c	2012-02-06 02:30:22.000000000 +0100
@@ -38,7 +38,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "debugger.h"
 
 
diff -Nru src-old/emu/diimage.c src/emu/diimage.c
--- src-old/emu/diimage.c	2012-02-05 16:14:28.000000000 +0100
+++ src/emu/diimage.c	2012-02-16 22:53:30.000000000 +0100
@@ -40,7 +40,6 @@
 #include "emu.h"
 #include "ui.h"
 #include "zippath.h"
-#include "uimenu.h"
 #include "uiimage.h"
 #include "uiswlist.h"
 
@@ -498,7 +497,8 @@
     device_image_partialhash_func partialhash;
 
     /* only calculate CRC if it hasn't been calculated, and the open_mode is read only */
-    if (m_hash.first() == NULL && m_readonly && !m_created)
+    UINT32 crcval;
+    if (!m_hash.crc(crcval) && m_readonly && !m_created)
     {
         /* do not cause a linear read of 600 megs please */
         /* TODO: use SHA1 in the CHD header as the hash */
diff -Nru src-old/emu/dislot.c src/emu/dislot.c
--- src-old/emu/dislot.c	2012-01-25 16:20:11.000000000 +0100
+++ src/emu/dislot.c	2012-02-11 17:15:39.000000000 +0100
@@ -10,6 +10,9 @@
 device_slot_interface::device_slot_interface(const machine_config &mconfig, device_t &device)
 	: device_interface(device)
 {
+	m_default_card = 0;
+	m_input_defaults = 0;
+	m_slot_interfaces = 0;
 }
 
 device_slot_interface::~device_slot_interface()
diff -Nru src-old/emu/dislot.h src/emu/dislot.h
--- src-old/emu/dislot.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/dislot.h	2012-02-19 15:09:07.000000000 +0100
@@ -49,7 +49,7 @@
 	static void static_set_slot_info(device_t &device, const slot_interface *slots_info, const char *default_card,const input_device_default *default_input);
 	const slot_interface* get_slot_interfaces() const { return m_slot_interfaces; };
 	const char * get_default_card(const machine_config &config, emu_options &options) const { return m_default_card; };
-	virtual const char * get_default_card_software(const machine_config &config, emu_options &options) const { return NULL; };
+	virtual const char * get_default_card_software(const machine_config &config, emu_options &options) { return NULL; };
 	const input_device_default *input_ports_defaults() const { return m_input_defaults; }
 	device_t* get_card_device();
 protected:
diff -Nru src-old/emu/drivers/empty.c src/emu/drivers/empty.c
--- src-old/emu/drivers/empty.c	2012-01-15 22:40:54.000000000 +0100
+++ src/emu/drivers/empty.c	2012-02-06 02:30:22.000000000 +0100
@@ -39,7 +39,6 @@
 
 #include "emu.h"
 #include "render.h"
-#include "uimenu.h"
 #include "uimain.h"
 
 
diff -Nru src-old/emu/drivers/xtal.h src/emu/drivers/xtal.h
--- src-old/emu/drivers/xtal.h	2012-01-21 00:53:27.000000000 +0100
+++ src/emu/drivers/xtal.h	2012-02-09 06:06:33.000000000 +0100
@@ -105,6 +105,7 @@
 	XTAL_11_2MHz		= 11200000,		/* New York, New York */
 	XTAL_11_289MHz  	= 11289000,		/* Vanguard */
 	XTAL_11_6688MHz 	= 11668800,		/* Gameplan pixel clock */
+	XTAL_11_8MHz		= 11800000,		/* IBM PC Music Feature Card */
 	XTAL_12MHz  		= 12000000,		/* Extremely common, used on 100's of PCBs */
 	XTAL_12_096MHz		= 12096000,		/* Some early 80's Atari games */
 	XTAL_12_288MHz  	= 12288000,		/* Sega Model 3 digital audio board */
@@ -176,7 +177,7 @@
 	XTAL_36MHz  		= 36000000,		/* Sega Model 1 video board */
 	XTAL_38_76922MHz	= 38769220,		/* Namco System 21 video board */
 	XTAL_40MHz  		= 40000000,
-        XTAL_42MHz  		= 42000000,		/* BMC A-00211 - Popo Bear */
+	XTAL_42MHz			= 42000000,		/* BMC A-00211 - Popo Bear */
 	XTAL_42_9545MHz 	= 42954545,		/* CPS3 */
 	XTAL_44_1MHz		= 44100000,		/* Subsino's Bishou Jan */
 	XTAL_45MHz  		= 45000000,		/* Eolith with Hyperstone CPUs */
@@ -197,9 +198,9 @@
 	XTAL_67_7376MHz 	= 67737600,		/* PSX-based h/w, Sony ZN1-2-based */
 	XTAL_72_576MHz  	= 72576000,		/* Centipede, Millipede, Missile Command, Let's Go Bowling "Multipede" */
 	XTAL_73_728MHz  	= 73728000,		/* Ms. Pac-Man/Galaga 20th Anniversary */
-	XTAL_100MHz 		= 100000000,		/* PSX-based Namco System 12, Vegas, Sony ZN1-2-based */
-	XTAL_101_4912MHz	= 101491200,		/* PSX-based Namco System 10 */
-	XTAL_200MHz			= 200000000,		/* Base SH4 CPU (Naomi, Hikaru etc.) */
+	XTAL_100MHz 		= 100000000,	/* PSX-based Namco System 12, Vegas, Sony ZN1-2-based */
+	XTAL_101_4912MHz	= 101491200,	/* PSX-based Namco System 10 */
+	XTAL_200MHz			= 200000000,	/* Base SH4 CPU (Naomi, Hikaru etc.) */
 
 /* Resonators (There are probably more. Almost always used for driving OKI sound chips) */
 
diff -Nru src-old/emu/emu.h src/emu/emu.h
--- src-old/emu/emu.h	2012-01-23 22:49:30.000000000 +0100
+++ src/emu/emu.h	2012-02-19 02:53:16.000000000 +0100
@@ -59,7 +59,6 @@
 #include "profiler.h"
 
 // commonly-referenecd utilities imported from lib/util
-#include "chd.h"
 #include "palette.h"
 #include "unicode.h"
 
@@ -68,7 +67,6 @@
 #include "hash.h"
 #include "fileio.h" // remove me once NVRAM is implemented as device
 #include "delegate.h"
-//#include "cothread.h"
 
 // memory and address spaces
 #include "memory.h"
diff -Nru src-old/emu/emu.mak src/emu/emu.mak
--- src-old/emu/emu.mak	2012-02-05 16:49:34.000000000 +0100
+++ src/emu/emu.mak	2012-02-09 04:41:36.000000000 +0100
@@ -220,6 +220,9 @@
 	$(EMUMACHINE)/msm6242.o		\
 	$(EMUMACHINE)/ncr539x.o 	\
 	$(EMUMACHINE)/nmc9306.o		\
+    $(EMUMACHINE)/nscsi_bus.o   \
+    $(EMUMACHINE)/nscsi_cd.o    \
+    $(EMUMACHINE)/nscsi_hd.o    \
 	$(EMUMACHINE)/nvram.o		\
 	$(EMUMACHINE)/pc16552d.o	\
 	$(EMUMACHINE)/pci.o			\
diff -Nru src-old/emu/emualloc.c src/emu/emualloc.c
--- src-old/emu/emualloc.c	2012-01-26 21:35:51.000000000 +0100
+++ src/emu/emualloc.c	2012-02-19 03:01:54.000000000 +0100
@@ -191,6 +191,10 @@
 
 void free_file_line(void *memory, const char *file, int line)
 {
+	// ignore NULL frees/deletes
+	if (memory == NULL)
+		return;
+
 	// find the memory entry
 	memory_entry *entry = memory_entry::find(memory);
 
diff -Nru src-old/emu/emuopts.c src/emu/emuopts.c
--- src-old/emu/emuopts.c	2012-01-25 16:20:11.000000000 +0100
+++ src/emu/emuopts.c	2012-02-19 16:23:23.000000000 +0100
@@ -275,7 +275,7 @@
 	// create the configuration
 	machine_config config(*cursystem, *this);
 	slot_interface_iterator iter(config.root_device());
-	for (const device_slot_interface *slot = iter.first(); slot != NULL; slot = iter.next())
+	for (device_slot_interface *slot = iter.first(); slot != NULL; slot = iter.next())
 	{
 		// retrieve info about the device instance
 		if (exists(slot->device().tag()+1)) {
@@ -320,7 +320,9 @@
 		// retrieve info about the device instance
 		astring option_name;
 		option_name.printf("%s;%s", image->instance_name(), image->brief_instance_name());
-
+		if (strcmp(image->device_typename(image->image_type()),image->instance_name())==0){
+			option_name.printf("%s;%s;%s1;%s1", image->instance_name(), image->brief_instance_name(), image->instance_name(), image->brief_instance_name());
+		}
 		// add the option
 		if (!exists(image->instance_name())) {
 			entry[0].name = option_name;
@@ -372,6 +374,9 @@
 	}
 	result = core_options::parse_command_line(argc, argv, OPTION_PRIORITY_CMDLINE, error_string);
 	update_slot_options();
+	while (add_slot_options(false));
+	add_device_options(true);
+	result = core_options::parse_command_line(argc, argv, OPTION_PRIORITY_CMDLINE, error_string);
 	return result;
 }
 
@@ -500,6 +505,8 @@
 		// then add the options
 		add_device_options(true);
 		update_slot_options();
+		while (add_slot_options(false));
+		add_device_options(true);
 	}
 }
 
diff -Nru src-old/emu/fileio.c src/emu/fileio.c
--- src-old/emu/fileio.c	2011-03-25 17:14:09.000000000 +0100
+++ src/emu/fileio.c	2012-02-16 22:53:30.000000000 +0100
@@ -37,9 +37,12 @@
 
 ***************************************************************************/
 
+
+
+
 #include "emu.h"
-#include "hash.h"
 #include "unzip.h"
+#include "un7z.h"
 #include "fileio.h"
 
 
@@ -175,6 +178,9 @@
 	  m_zipfile(NULL),
 	  m_zipdata(NULL),
 	  m_ziplength(0),
+	  m__7zfile(NULL),
+	  m__7zdata(NULL),
+	  m__7zlength(0),
 	  m_remove_on_close(false)
 {
 	// sanity check the open flags
@@ -190,6 +196,9 @@
 	  m_zipfile(NULL),
 	  m_zipdata(NULL),
 	  m_ziplength(0),
+	  m__7zfile(NULL),
+	  m__7zdata(NULL),
+	  m__7zlength(0),
 	  m_remove_on_close(false)
 {
 	// sanity check the open flags
@@ -217,7 +226,7 @@
 emu_file::operator core_file *()
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return NULL;
 
 	// return the core file
@@ -227,7 +236,7 @@
 emu_file::operator core_file &()
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		throw emu_fatalerror("operator core_file & used on invalid file");
 
 	// return the core file
@@ -241,10 +250,14 @@
 
 hash_collection &emu_file::hashes(const char *types)
 {
+	// determine the hashes we already have
+	astring already_have;
+	m_hashes.hash_types(already_have);
+
 	// determine which hashes we need
 	astring needed;
 	for (const char *scan = types; *scan != 0; scan++)
-		if (m_hashes.hash(*scan) == NULL)
+		if (already_have.chr(0, *scan) == -1)
 			needed.cat(*scan);
 
 	// if we need nothing, skip it
@@ -252,12 +265,18 @@
 		return m_hashes;
 
 	// load the ZIP file if needed
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return m_hashes;
 	if (m_file == NULL)
 		return m_hashes;
 
 	// if we have ZIP data, just hash that directly
+	if (m__7zdata != NULL)
+	{
+		m_hashes.compute(m__7zdata, m__7zlength, needed);
+		return m_hashes;
+	}
+
 	if (m_zipdata != NULL)
 	{
 		m_hashes.compute(m_zipdata, m_ziplength, needed);
@@ -369,9 +388,19 @@
 		// if we're opening for read-only we have other options
 		if ((m_openflags & (OPEN_FLAG_READ | OPEN_FLAG_WRITE)) == OPEN_FLAG_READ)
 		{
+			astring tempfullpath = m_fullpath;
+
+			filerr = attempt__7zped();
+			if (filerr == FILERR_NONE)
+				break;
+
+			m_fullpath = tempfullpath;
+
 			filerr = attempt_zipped();
 			if (filerr == FILERR_NONE)
 				break;
+
+
 		}
 	}
 	return filerr;
@@ -402,6 +431,10 @@
 void emu_file::close()
 {
 	// close files and free memory
+	if (m__7zfile != NULL)
+		_7z_file_close(m__7zfile);
+	m__7zfile = NULL;
+
 	if (m_zipfile != NULL)
 		zip_file_close(m_zipfile);
 	m_zipfile = NULL;
@@ -410,6 +443,10 @@
 		core_fclose(m_file);
 	m_file = NULL;
 
+	if (m__7zdata != NULL)
+		global_free(m__7zdata);
+	m__7zdata = NULL;
+
 	if (m_zipdata != NULL)
 		global_free(m_zipdata);
 	m_zipdata = NULL;
@@ -437,13 +474,30 @@
 
 
 //-------------------------------------------------
+//  compressed_file_ready - ensure our zip is ready
+//   loading if needed
+//-------------------------------------------------
+
+bool emu_file::compressed_file_ready(void)
+{
+	// load the ZIP file now if we haven't yet
+	if (m__7zfile != NULL && load__7zped_file() != FILERR_NONE)
+		return true;
+
+	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+		return true;
+
+	return false;
+}
+
+//-------------------------------------------------
 //  seek - seek within a file
 //-------------------------------------------------
 
 int emu_file::seek(INT64 offset, int whence)
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return 1;
 
 	// seek if we can
@@ -461,7 +515,7 @@
 UINT64 emu_file::tell()
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return 0;
 
 	// tell if we can
@@ -479,7 +533,7 @@
 bool emu_file::eof()
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return 0;
 
 	// return EOF if we can
@@ -497,6 +551,9 @@
 UINT64 emu_file::size()
 {
 	// use the ZIP length if present
+	if (m__7zfile != NULL)
+		return m__7zlength;
+
 	if (m_zipfile != NULL)
 		return m_ziplength;
 
@@ -515,7 +572,7 @@
 UINT32 emu_file::read(void *buffer, UINT32 length)
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return 0;
 
 	// read the data if we can
@@ -533,7 +590,7 @@
 int emu_file::getc()
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return EOF;
 
 	// read the data if we can
@@ -551,7 +608,7 @@
 int emu_file::ungetc(int c)
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return 1;
 
 	// read the data if we can
@@ -569,7 +626,7 @@
 char *emu_file::gets(char *s, int n)
 {
 	// load the ZIP file now if we haven't yet
-	if (m_zipfile != NULL && load_zipped_file() != FILERR_NONE)
+	if (compressed_file_ready())
 		return NULL;
 
 	// read the data if we can
@@ -767,3 +824,106 @@
 	const char *zipfile = header.filename + header.filename_length - 1;
 	return (zipfile >= header.filename && zipfile[0] == '/');
 }
+
+//-------------------------------------------------
+//  attempt__7zped - attempt to open a .7z file
+//-------------------------------------------------
+
+file_error emu_file::attempt__7zped()
+{
+	astring filename;
+
+	// loop over directory parts up to the start of filename
+	while (1)
+	{
+		// find the final path separator
+		int dirsep = m_fullpath.rchr(0, PATH_SEPARATOR[0]);
+		if (dirsep == -1)
+			return FILERR_NOT_FOUND;
+
+		// insert the part from the right of the separator into the head of the filename
+		if (filename.len() > 0)
+			filename.ins(0, "/");
+		filename.inssubstr(0, m_fullpath, dirsep + 1, -1);
+
+		// remove this part of the filename and append a .7z extension
+		m_fullpath.substr(0, dirsep).cat(".7z");
+
+		// attempt to open the _7Z file
+		_7z_file *_7z;
+		_7z_error _7zerr = _7z_file_open(m_fullpath, &_7z);
+
+		// chop the ._7z back off the filename before continuing
+		m_fullpath.substr(0, dirsep);
+
+		// if we failed to open this file, continue scanning
+		if (_7zerr != _7ZERR_NONE)
+			continue;
+
+		int fileno = -1;
+
+		// see if we can find a file with the right name and (if available) crc
+		if (m_openflags & OPEN_FLAG_HAS_CRC) fileno = _7z_search_crc_match(_7z, m_crc, filename.cstr(), filename.len(), true, true);
+
+		// if that failed, look for a file with the right crc, but the wrong filename
+		if (fileno==-1)
+			if (m_openflags & OPEN_FLAG_HAS_CRC) fileno = _7z_search_crc_match(_7z, m_crc, filename.cstr(), filename.len(), true, false);
+
+		// if that failed, look for a file with the right name; reporting a bad checksum
+		// is more helpful and less confusing than reporting "rom not found"
+		if (fileno==-1)
+			fileno = _7z_search_crc_match(_7z, m_crc, filename.cstr(), filename.len(), false, true);
+
+		if (fileno != -1)
+		{
+			m__7zfile = _7z;
+			m__7zlength = _7z->uncompressed_length;
+
+			// build a hash with just the CRC
+			m_hashes.reset();
+			m_hashes.add_crc(_7z->crc);
+			return (m_openflags & OPEN_FLAG_NO_PRELOAD) ? FILERR_NONE : load__7zped_file();
+		}
+
+		// close up the _7Z file and try the next level
+		_7z_file_close(_7z);
+	}
+}
+
+
+//-------------------------------------------------
+//  load__7zped_file - load a _7Zped file
+//-------------------------------------------------
+
+file_error emu_file::load__7zped_file()
+{
+	assert(m_file == NULL);
+	assert(m__7zdata == NULL);
+	assert(m__7zfile != NULL);
+
+	// allocate some memory
+	m__7zdata = global_alloc_array(UINT8, m__7zlength);
+
+	// read the data into our buffer and return
+	_7z_error _7zerr = _7z_file_decompress(m__7zfile, m__7zdata, m__7zlength);
+	if (_7zerr != _7ZERR_NONE)
+	{
+		global_free(m__7zdata);
+		m__7zdata = NULL;
+		return FILERR_FAILURE;
+	}
+
+	// convert to RAM file
+	file_error filerr = core_fopen_ram(m__7zdata, m__7zlength, m_openflags, &m_file);
+	if (filerr != FILERR_NONE)
+	{
+		global_free(m__7zdata);
+		m__7zdata = NULL;
+		return FILERR_FAILURE;
+	}
+
+	// close out the _7Z file
+	_7z_file_close(m__7zfile);
+	m__7zfile = NULL;
+	return FILERR_NONE;
+}
diff -Nru src-old/emu/fileio.h src/emu/fileio.h
--- src-old/emu/fileio.h	2011-09-25 15:46:07.000000000 +0200
+++ src/emu/fileio.h	2012-02-12 18:55:51.000000000 +0100
@@ -58,6 +58,8 @@
 typedef struct _zip_file_header zip_file_header;
 typedef struct _zip_file zip_file;
 
+typedef struct __7z_file_header _7z_file_header;
+typedef struct __7z_file _7z_file;
 
 // ======================> path_iterator
 
@@ -162,12 +164,17 @@
 	int printf(const char *fmt, ...);
 
 private:
+	bool compressed_file_ready(void);
+
 	// internal helpers
 	file_error attempt_zipped();
 	file_error load_zipped_file();
 	bool zip_filename_match(const zip_file_header &header, const astring &filename);
 	bool zip_header_is_path(const zip_file_header &header);
 
+	file_error attempt__7zped();
+	file_error load__7zped_file();
+
 	// internal state
 	astring			m_filename;						// original filename provided
 	astring			m_fullpath;						// full filename
@@ -176,9 +183,15 @@
 	UINT32			m_crc;							// iterator for paths
 	UINT32			m_openflags;					// flags we used for the open
 	hash_collection m_hashes;						// collection of hashes
+
 	zip_file *		m_zipfile;						// ZIP file pointer
 	UINT8 *			m_zipdata;						// ZIP file data
 	UINT64			m_ziplength;					// ZIP file length
+
+	_7z_file *		m__7zfile;						// 7Z file pointer
+	UINT8 *			m__7zdata;						// 7Z file data
+	UINT64			m__7zlength;					// 7Z file length
+
 	bool			m_remove_on_close;				// flag: remove the file when closing
 };
 
diff -Nru src-old/emu/hash.c src/emu/hash.c
--- src-old/emu/hash.c	2012-01-03 01:21:13.000000000 +0100
+++ src/emu/hash.c	2012-02-19 16:23:23.000000000 +0100
@@ -40,62 +40,11 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "zlib.h"
-#include "sha1.h"
+#include "hashing.h"
 #include <ctype.h>
 
 
 //**************************************************************************
-//  TYPE DEFINITIONS
-//**************************************************************************
-
-// ======================> hash_crc
-
-// CRC-32 hash implementation
-class hash_crc : public hash_base
-{
-public:
-	// construction/destruction
-    hash_crc();
-
-	// operators
-    operator UINT32() const { return (m_buffer[0] << 24) | (m_buffer[1] << 16) | (m_buffer[2] << 8) | m_buffer[3]; }
-
-	// creation
-    virtual void begin();
-    virtual void buffer(const UINT8 *data, UINT32 length);
-    virtual void end();
-
-private:
-    // internal state
-    UINT8   m_buffer[4];
-};
-
-
-
-// ======================> hash_sha1
-
-// SHA1 hash implementation
-class hash_sha1 : public hash_base
-{
-public:
-	// construction/destruction
-    hash_sha1();
-
-	// creation
-    virtual void begin();
-    virtual void buffer(const UINT8 *data, UINT32 length);
-    virtual void end();
-
-private:
-    // internal state
-    UINT8   m_buffer[20];
-    struct sha1_ctx m_context;
-};
-
-
-
-//**************************************************************************
 //  GLOBAL VARIABLES
 //**************************************************************************
 
@@ -106,220 +55,6 @@
 
 
 //**************************************************************************
-//  HASH BASE
-//**************************************************************************
-
-//-------------------------------------------------
-//  hash_base - constructor
-//-------------------------------------------------
-
-hash_base::hash_base(char id, const char *name, UINT8 length, UINT8 *bufptr)
-	: m_next(NULL),
-	  m_name(name),
-	  m_in_progress(false),
-	  m_parse_error(false),
-	  m_id(id),
-	  m_length(length),
-	  m_bufptr(bufptr)
-{
-	memset(m_bufptr, 0, length);
-}
-
-
-//-------------------------------------------------
-//  fromhex - convert a character to a hex value
-//-------------------------------------------------
-
-int hash_base::fromhex(char c)
-{
-	if (c >= '0' && c <= '9')
-		return c - '0';
-	else if (c >= 'A' && c <= 'F')
-		return c - 'A' + 10;
-	else if (c >= 'a' && c <= 'f')
-		return (c - 'a' + 10);
-	else
-		return -1;
-}
-
-
-//-------------------------------------------------
-//  from_buffer - copy a raw buffer into the
-//  current hash
-//-------------------------------------------------
-
-bool hash_base::from_buffer(const UINT8 *buffer, int buflen)
-{
-	// fail if we're too small
-	if (buflen < m_length)
-		return false;
-	memcpy(m_bufptr, buffer, m_length);
-	return true;
-}
-
-
-//-------------------------------------------------
-//  string - output a string for the current hash
-//-------------------------------------------------
-
-const char *hash_base::string(astring &buffer)
-{
-	buffer.reset();
-	for (int index = 0; index < m_length; index++)
-		buffer.catprintf("%02x", m_bufptr[index]);
-	return buffer;
-}
-
-
-//-------------------------------------------------
-//  from_string - parse a string into the current
-//  hash
-//-------------------------------------------------
-
-bool hash_base::from_string(const char *&string, int length)
-{
-	// reset the error and our buffer
-	m_parse_error = false;
-	memset(m_bufptr, 0, m_length);
-
-	// special case for idiom HASH(1) to map to a dummy (0) hash
-	if (string[0] == '1' && fromhex(string[1]) == -1)
-	{
-		string++;
-		return true;
-	}
-
-	// fail if we're too short
-	if (length < 2 * m_length)
-		return false;
-
-	// loop over bytes
-	for (int index = 0; index < m_length; index++)
-	{
-		// parse the upper digit
-		int upper = fromhex(string[0]);
-		if (upper == -1)
-		{
-			m_parse_error = true;
-			return false;
-		}
-
-		// parse the lower digit
-		int lower = fromhex(string[1]);
-		if (lower == -1)
-		{
-			m_parse_error = true;
-			return false;
-		}
-
-		// set the byte and advance
-		m_bufptr[index] = (upper << 4) | lower;
-		string += 2;
-	}
-	return true;
-}
-
-
-
-//**************************************************************************
-//  HASH CRC
-//**************************************************************************
-
-//-------------------------------------------------
-//  hash_crc - constructor
-//-------------------------------------------------
-
-hash_crc::hash_crc()
-	: hash_base(hash_collection::HASH_CRC, "crc", sizeof(m_buffer), m_buffer)
-{
-}
-
-
-//-------------------------------------------------
-//  begin - initialize state for hash computation
-//-------------------------------------------------
-
-void hash_crc::begin()
-{
-	m_in_progress = true;
-	memset(m_buffer, 0, sizeof(m_buffer));
-}
-
-
-//-------------------------------------------------
-//  buffer - hash a buffer's worth of data
-//-------------------------------------------------
-
-void hash_crc::buffer(const UINT8 *data, UINT32 length)
-{
-	UINT32 crc = crc32(*this, data, length);
-	m_buffer[0] = crc >> 24;
-	m_buffer[1] = crc >> 16;
-	m_buffer[2] = crc >> 8;
-	m_buffer[3] = crc >> 0;
-}
-
-
-//-------------------------------------------------
-//  end - finish hash computation
-//-------------------------------------------------
-
-void hash_crc::end()
-{
-	m_in_progress = false;
-}
-
-
-
-//**************************************************************************
-//  HASH SHA1
-//**************************************************************************
-
-//-------------------------------------------------
-//  hash_sha1 - constructor
-//-------------------------------------------------
-
-hash_sha1::hash_sha1()
-	: hash_base(hash_collection::HASH_SHA1, "sha1", sizeof(m_buffer), m_buffer)
-{
-}
-
-
-//-------------------------------------------------
-//  begin - initialize state for hash computation
-//-------------------------------------------------
-
-void hash_sha1::begin()
-{
-	m_in_progress = true;
-	sha1_init(&m_context);
-}
-
-
-//-------------------------------------------------
-//  buffer - hash a buffer's worth of data
-//-------------------------------------------------
-
-void hash_sha1::buffer(const UINT8 *data, UINT32 length)
-{
-	sha1_update(&m_context, length, data);
-}
-
-
-//-------------------------------------------------
-//  end - finish hash computation
-//-------------------------------------------------
-
-void hash_sha1::end()
-{
-	sha1_final(&m_context);
-	sha1_digest(&m_context, sizeof(m_buffer), m_buffer);
-	m_in_progress = false;
-}
-
-
-
-//**************************************************************************
 //  HASH COLLECTION
 //**************************************************************************
 
@@ -328,17 +63,26 @@
 //-------------------------------------------------
 
 hash_collection::hash_collection()
+	: m_has_crc32(false),
+	  m_has_sha1(false),
+	  m_creator(NULL)
 {
 }
 
 
 hash_collection::hash_collection(const char *string)
+	: m_has_crc32(false),
+	  m_has_sha1(false),
+	  m_creator(NULL)
 {
 	from_internal_string(string);
 }
 
 
 hash_collection::hash_collection(const hash_collection &src)
+	: m_has_crc32(false),
+	  m_has_sha1(false),
+	  m_creator(NULL)
 {
 	copyfrom(src);
 }
@@ -350,6 +94,7 @@
 
 hash_collection::~hash_collection()
 {
+	delete m_creator;
 }
 
 
@@ -372,17 +117,21 @@
 
 bool hash_collection::operator==(const hash_collection &rhs) const
 {
-	// look for a mismatch in any hash; do not fail if one is missing
+	// match CRCs
 	int matches = 0;
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
+	if (m_has_crc32 && rhs.m_has_crc32)
 	{
-		hash_base *rhs_hash = rhs.hash(hash->id());
-		if (rhs_hash != NULL)
-		{
-			if (*hash != *rhs_hash)
-				return false;
-			matches++;
-		}
+		if (m_crc32 != rhs.m_crc32)
+			return false;
+		matches++;
+	}
+
+	// match SHA1s
+	if (m_has_sha1 && rhs.m_has_sha1)
+	{
+		if (m_sha1 != rhs.m_sha1)
+			return false;
+		matches++;
 	}
 
 	// if all shared hashes match, return true
@@ -391,20 +140,6 @@
 
 
 //-------------------------------------------------
-//  hash - return a hash of the given type
-//-------------------------------------------------
-
-hash_base *hash_collection::hash(char type) const
-{
-	// look for a mismatch in any hash; do not fail if one is missing
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		if (hash->id() == type)
-			return hash;
-	return NULL;
-}
-
-
-//-------------------------------------------------
 //  hash_types - return a list of hash types as
 //  a string
 //-------------------------------------------------
@@ -412,8 +147,10 @@
 const char *hash_collection::hash_types(astring &buffer) const
 {
 	buffer.reset();
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		buffer.cat(hash->id());
+	if (m_has_crc32)
+		buffer.cat(HASH_CRC);
+	if (m_has_sha1)
+		buffer.cat(HASH_SHA1);
 	return buffer;
 }
 
@@ -423,53 +160,12 @@
 //  set of hashes and flags
 //-------------------------------------------------
 
-bool hash_collection::parse_errors() const
-{
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		if (hash->parse_error())
-			return true;
-	return false;
-}
-
-
-//-------------------------------------------------
-//  reset - reset the hash collection to an empty
-//  set of hashes and flags
-//-------------------------------------------------
-
 void hash_collection::reset()
 {
-	m_hashlist.reset();
 	m_flags.reset();
-}
-
-
-//-------------------------------------------------
-//  add_from_buffer - add a new hash, importing
-//  from a buffer
-//-------------------------------------------------
-
-hash_base *hash_collection::add_from_buffer(char type, const UINT8 *buffer, int bufflen)
-{
-	// nuke any existing hash with the same ID
-	hash_base *existing = hash(type);
-	if (existing != NULL)
-		m_hashlist.remove(*existing);
-
-	// first allocate by ID
-	hash_base *newhash = alloc_by_id(type);
-	if (newhash == NULL)
-		return NULL;
-
-	// then import
-	if (!newhash->from_buffer(buffer, bufflen))
-	{
-		global_free(newhash);
-		return NULL;
-	}
-
-	// and append to our list
-	return &m_hashlist.append(*newhash);
+	m_has_crc32 = m_has_sha1 = false;
+	delete m_creator;
+	m_creator = NULL;
 }
 
 
@@ -478,27 +174,17 @@
 //  from a string
 //-------------------------------------------------
 
-hash_base *hash_collection::add_from_string(char type, const char *buffer, int length)
+bool hash_collection::add_from_string(char type, const char *buffer, int length)
 {
-	// nuke any existing hash with the same ID
-	hash_base *existing = hash(type);
-	if (existing != NULL)
-		m_hashlist.remove(*existing);
-
-	// first allocate by ID
-	hash_base *newhash = alloc_by_id(type);
-	if (newhash == NULL)
-		return NULL;
+	// handle CRCs
+	if (type == HASH_CRC)
+		return m_has_crc32 = m_crc32.from_string(buffer, length);
+
+	// handle SHA1s
+	else if (type == HASH_SHA1)
+		return m_has_sha1 = m_sha1.from_string(buffer, length);
 
-	// then import
-	if (!newhash->from_string(buffer, length))
-	{
-		global_free(newhash);
-		return NULL;
-	}
-
-	// and append to our list
-	return &m_hashlist.append(*newhash);
+	return false;
 }
 
 
@@ -508,51 +194,22 @@
 
 bool hash_collection::remove(char type)
 {
-	// scan the list of hashes for a match
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		if (hash->id() == type)
-		{
-			m_hashlist.remove(*hash);
-			return true;
-		}
-
-	// didn't find it
-	return false;
-}
-
-
-//-------------------------------------------------
-//  crc - return the CRC hash if present
-//-------------------------------------------------
-
-bool hash_collection::crc(UINT32 &result) const
-{
-	// attempt to find the CRC hash; if we fail, return false
-	hash_base *crchash = hash(HASH_CRC);
-	if (crchash == NULL)
-		return false;
-
-	// downcast to a hash_crc and convert to a UINT32
-	result = *downcast<const hash_crc *>(crchash);
-	return true;
-}
-
-
-//-------------------------------------------------
-//  add_crc - add a CRC hash
-//-------------------------------------------------
+	bool result = false;
 
-hash_base *hash_collection::add_crc(UINT32 crc)
-{
-	// expand to a buffer
-	UINT8 buffer[4];
-	buffer[0] = crc >> 24;
-	buffer[1] = crc >> 16;
-	buffer[2] = crc >> 8;
-	buffer[3] = crc >> 0;
+	// handle CRCs
+	if (type == HASH_CRC)
+	{
+		result = m_has_crc32;
+		m_has_crc32 = false;
+	}
 
-	// add it the standard way
-	return add_from_buffer(HASH_CRC, buffer, sizeof(buffer));
+	// handle SHA1s
+	else if (type == HASH_SHA1)
+	{
+		result = m_has_sha1;
+		m_has_sha1 = false;
+	}
+	return result;
 }
 
 
@@ -564,16 +221,19 @@
 
 const char *hash_collection::internal_string(astring &buffer) const
 {
+	buffer.reset();
+
+	// handle CRCs
 	astring temp;
+	if (m_has_crc32)
+		buffer.cat(HASH_CRC).cat(m_crc32.as_string(temp));
 
-	// output hashes first
-	buffer.reset();
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		buffer.cat(hash->id()).cat(hash->string(temp));
+	// handle SHA1s
+	if (m_has_sha1)
+		buffer.cat(HASH_SHA1).cat(m_sha1.as_string(temp));
 
 	// append flags
-	buffer.cat(m_flags);
-	return buffer;
+	return buffer.cat(m_flags);
 }
 
 
@@ -584,15 +244,16 @@
 
 const char *hash_collection::macro_string(astring &buffer) const
 {
+	buffer.reset();
+
+	// handle CRCs
 	astring temp;
+	if (m_has_crc32)
+		buffer.cat("CRC(").cat(m_crc32.as_string(temp)).cat(") ");
 
-	// output hashes first
-	buffer.reset();
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-	{
-		buffer.cat(temp.cpy(hash->name()).makeupper());
-		buffer.cat("(").cat(hash->string(temp)).cat(") ");
-	}
+	// handle SHA1s
+	if (m_has_sha1)
+		buffer.cat("SHA1(").cat(m_sha1.as_string(temp)).cat(") ");
 
 	// append flags
 	if (flag(FLAG_NO_DUMP))
@@ -604,6 +265,33 @@
 
 
 //-------------------------------------------------
+//  attribute_string - convert set of hashes and
+//  flags to a string in XML attribute format
+//-------------------------------------------------
+
+const char *hash_collection::attribute_string(astring &buffer) const
+{
+	buffer.reset();
+
+	// handle CRCs
+	astring temp;
+	if (m_has_crc32)
+		buffer.cat("crc=\"").cat(m_crc32.as_string(temp)).cat("\" ");
+
+	// handle SHA1s
+	if (m_has_sha1)
+		buffer.cat("sha1=\"").cat(m_sha1.as_string(temp)).cat("\" ");
+
+	// append flags
+	if (flag(FLAG_NO_DUMP))
+		buffer.cat("status=\"nodump\"" );
+	if (flag(FLAG_BAD_DUMP))
+		buffer.cat("status=\"baddump\"" );
+	return buffer.trimspace();
+}
+
+
+//-------------------------------------------------
 //  from_internal_string - convert an internal
 //  compact string to set of hashes and flags
 //-------------------------------------------------
@@ -619,28 +307,29 @@
 
 	// loop until we hit it
 	bool errors = false;
+	bool skip_digits = false;
 	while (ptr < stringend)
 	{
 		char c = *ptr++;
-		char lc = tolower(c);
+		char uc = toupper(c);
 
 		// non-hex alpha values specify a hash type
-		if (lc >= 'g' && lc <= 'z')
+		if (uc >= 'G' && uc <= 'Z')
 		{
-			hash_base *hash = alloc_by_id(c);
-			if (hash != NULL)
-			{
-				if (!hash->from_string(ptr, stringend - ptr))
-					errors = true;
-				m_hashlist.append(*hash);
-			}
+			if (uc == HASH_CRC)
+				skip_digits = m_has_crc32 = m_crc32.from_string(ptr, stringend - ptr);
+			else if (uc == HASH_SHA1)
+				skip_digits = m_has_sha1 = m_sha1.from_string(ptr, stringend - ptr);
 			else
 				errors = true;
 		}
 
 		// hex values are ignored, though unexpected
-		else if ((lc >= '0' && lc <= '9') || (lc >= 'a' && lc <= 'f'))
-			errors = true;
+		else if ((uc >= '0' && uc <= '9') || (uc >= 'A' && uc <= 'F'))
+		{
+			if (!skip_digits)
+				errors = true;
+		}
 
 		// anything else is a flag
 		else
@@ -656,26 +345,19 @@
 
 void hash_collection::begin(const char *types)
 {
+	// nuke previous creator and make a new one
+	delete m_creator;
+	m_creator = new hash_creator;
+
 	// by default use all types
 	if (types == NULL)
-	{
-		m_hashlist.append(*alloc_by_id(HASH_CRC)).begin();
-		m_hashlist.append(*alloc_by_id(HASH_SHA1)).begin();
-	}
+		m_creator->m_doing_crc32 = m_creator->m_doing_sha1 = true;
 
 	// otherwise, just allocate the ones that are specified
 	else
 	{
-		for (const char *scan = types; *scan != 0; scan++)
-		{
-			// nuke any existing hash of this type
-			hash_base *existing = hash(*scan);
-			if (existing != NULL)
-				m_hashlist.remove(*existing);
-
-			// append a new one
-			m_hashlist.append(*alloc_by_id(*scan)).begin();
-		}
+		m_creator->m_doing_crc32 = (strchr(types, HASH_CRC) != NULL);
+		m_creator->m_doing_sha1 = (strchr(types, HASH_SHA1) != NULL);
 	}
 }
 
@@ -686,10 +368,13 @@
 
 void hash_collection::buffer(const UINT8 *data, UINT32 length)
 {
-	// buffer each hash appropriately
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		if (hash->in_progress())
-			hash->buffer(data, length);
+	assert(m_creator != NULL);
+
+	// append to each active hash
+	if (m_creator->m_doing_crc32)
+		m_creator->m_crc32_creator.append(data, length);
+	if (m_creator->m_doing_sha1)
+		m_creator->m_sha1_creator.append(data, length);
 }
 
 
@@ -699,26 +384,28 @@
 
 void hash_collection::end()
 {
-	// end each hash
-	for (hash_base *hash = m_hashlist.first(); hash != NULL; hash = hash->next())
-		if (hash->in_progress())
-			hash->end();
-}
+	assert(m_creator != NULL);
 
+	// default to getting nothing
+	m_has_crc32 = m_has_sha1 = false;
 
-//-------------------------------------------------
-//  alloc_by_id - based on the ID character,
-//  allocate a new hash
-//-------------------------------------------------
+	// finish up the CRC32
+	if (m_creator->m_doing_crc32)
+	{
+		m_has_crc32 = true;
+		m_crc32 = m_creator->m_crc32_creator.finish();
+	}
 
-hash_base *hash_collection::alloc_by_id(char id)
-{
-	switch (id)
+	// finish up the SHA1
+	if (m_creator->m_doing_sha1)
 	{
-		case HASH_CRC:	return global_alloc(hash_crc);
-		case HASH_SHA1:	return global_alloc(hash_sha1);
-		default:		return NULL;
+		m_has_sha1 = true;
+		m_sha1 = m_creator->m_sha1_creator.finish();
 	}
+
+	// nuke the creator
+	delete m_creator;
+	m_creator = NULL;
 }
 
 
@@ -732,8 +419,12 @@
 	// copy flags directly
 	m_flags = src.m_flags;
 
-	// rebuild the hashlist by copying from the source
-	m_hashlist.reset();
-	for (hash_base *hash = src.first(); hash != NULL; hash = hash->next())
-		add_from_buffer(hash->id(), hash->buffer(), hash->length());
+	// copy hashes
+	m_has_crc32 = src.m_has_crc32;
+	m_crc32 = src.m_crc32;
+	m_has_sha1 = src.m_has_sha1;
+	m_sha1 = src.m_sha1;
+
+	// don't copy creators
+	m_creator = NULL;
 }
diff -Nru src-old/emu/hash.h src/emu/hash.h
--- src-old/emu/hash.h	2011-07-31 16:46:18.000000000 +0200
+++ src/emu/hash.h	2012-02-16 22:53:30.000000000 +0100
@@ -44,6 +44,8 @@
 #ifndef __HASH_H__
 #define __HASH_H__
 
+#include "hashing.h"
+
 
 //**************************************************************************
 //  MACROS
@@ -62,59 +64,6 @@
 //**************************************************************************
 
 
-// ======================> hash_base
-
-// base class for all hash types, which does most of the heavy lifting
-class hash_base
-{
-	friend class simple_list<hash_base>;
-
-public:
-    // construction/destruction
-    hash_base(char id, const char *name, UINT8 length, UINT8 *bufptr);
-    virtual ~hash_base() { }
-
-    // operators
-    bool operator==(const hash_base &rhs) const { return (m_length == rhs.m_length && memcmp(m_bufptr, rhs.m_bufptr, m_length) == 0); }
-    bool operator!=(const hash_base &rhs) const { return (m_length != rhs.m_length || memcmp(m_bufptr, rhs.m_bufptr, m_length) != 0); }
-
-    // getters
-    hash_base *next() const { return m_next; }
-    char id() const { return m_id; }
-    const char *name() const { return m_name; }
-    int length() const { return m_length; }
-    bool in_progress() const { return m_in_progress; }
-    bool parse_error() const { return m_parse_error; }
-    UINT8 byte(int index) const { return (index >= 0 && index < m_length) ? m_bufptr[index] : 0; }
-
-    // buffer conversion
-    const UINT8 *buffer() { return m_bufptr; }
-    bool from_buffer(const UINT8 *buffer, int buflen);
-
-    // string conversion
-    const char *string(astring &buffer);
-    bool from_string(const char *&string,  int length);
-
-    // creation
-    virtual void begin() = 0;
-    virtual void buffer(const UINT8 *data, UINT32 length) = 0;
-    virtual void end() = 0;
-
-protected:
-	// internal helpers
-    int fromhex(char c);
-
-    // internal state
-    hash_base *		m_next;
-    const char *	m_name;
-    bool			m_in_progress;
-    bool			m_parse_error;
-    char			m_id;
-    UINT8			m_length;
-    UINT8 *     	m_bufptr;
-};
-
-
 // ======================> hash_collection
 
 // a collection of the various supported hashes and flags
@@ -147,24 +96,25 @@
 
 	// getters
     bool flag(char flag) const { return (m_flags.chr(0, flag) != -1); }
-    hash_base *hash(char type) const;
-    hash_base *first() const { return m_hashlist.first(); }
     const char *hash_types(astring &buffer) const;
-    bool parse_errors() const;
 
 	// hash manipulators
 	void reset();
-	hash_base *add_from_buffer(char type, const UINT8 *buffer, int bufflen);
-	hash_base *add_from_string(char type, const char *buffer, int length);
+	bool add_from_string(char type, const char *buffer, int length = -1);
 	bool remove(char type);
 
 	// CRC-specific helpers
-	bool crc(UINT32 &result) const;
-	hash_base *add_crc(UINT32 crc);
+	bool crc(UINT32 &result) const { result = m_crc32; return m_has_crc32; }
+	void add_crc(UINT32 crc) { m_crc32 = crc; m_has_crc32 = true; }
+
+	// SHA1-specific helpers
+	bool sha1(sha1_t &result) const { result = m_sha1; return m_has_sha1; }
+	void add_sha1(sha1_t sha1) { m_has_sha1 = true; m_sha1 = sha1; }
 
 	// string conversion
     const char *internal_string(astring &buffer) const;
     const char *macro_string(astring &buffer) const;
+    const char *attribute_string(astring &buffer) const;
     bool from_internal_string(const char *string);
 
 	// creation
@@ -175,12 +125,24 @@
 
 private:
 	// internal helpers
-    static hash_base *alloc_by_id(char id);
     void copyfrom(const hash_collection &src);
 
 	// internal state
 	astring					m_flags;
-    simple_list<hash_base>	m_hashlist;
+	bool					m_has_crc32;
+	crc32_t					m_crc32;
+	bool					m_has_sha1;
+	sha1_t					m_sha1;
+
+	// creators
+	struct hash_creator
+	{
+		bool					m_doing_crc32;
+		crc32_creator			m_crc32_creator;
+		bool					m_doing_sha1;
+		sha1_creator			m_sha1_creator;
+	};
+	hash_creator *			m_creator;
 };
 
 
diff -Nru src-old/emu/imagedev/cassette.c src/emu/imagedev/cassette.c
--- src-old/emu/imagedev/cassette.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/imagedev/cassette.c	2012-02-15 12:34:49.000000000 +0100
@@ -256,7 +256,7 @@
 	device_image_interface *image = NULL;
 	interface(image);
 
-	if (has_been_created())
+	if ((has_been_created()) || (length() == 0))
 	{
 		/* creating an image */
 		err = cassette_create((void *)image, &image_ioprocs, &wavfile_format, m_create_opts, CASSETTE_FLAG_READWRITE|CASSETTE_FLAG_SAVEONEXIT, &m_cassette);
@@ -384,4 +384,17 @@
 
 	/* draw the cassette */
 	ui_draw_text_box(&device().machine().render().ui_container(), buf, JUSTIFY_LEFT, x, y, UI_BACKGROUND_COLOR);
+
+	// make sure tape stops at end when playing
+	if ((m_state & CASSETTE_MASK_UISTATE) == CASSETTE_PLAY)
+	{
+		if ( m_cassette )
+		{
+			if (position > length)
+			{
+				m_state = (cassette_state)(( m_state & ~CASSETTE_MASK_UISTATE ) | CASSETTE_STOPPED);
+				position = length;
+			}
+		}
+	}
 }
diff -Nru src-old/emu/imagedev/chd_cd.c src/emu/imagedev/chd_cd.c
--- src-old/emu/imagedev/chd_cd.c	2011-08-20 07:47:40.000000000 +0200
+++ src/emu/imagedev/chd_cd.c	2012-02-19 02:59:23.000000000 +0100
@@ -11,40 +11,6 @@
 #include "chd_cd.h"
 
 
-static const char *const error_strings[] =
-{
-	"no error",
-	"no drive interface",
-	"out of memory",
-	"invalid file",
-	"invalid parameter",
-	"invalid data",
-	"file not found",
-	"requires parent",
-	"file not writeable",
-	"read error",
-	"write error",
-	"codec error",
-	"invalid parent",
-	"hunk out of range",
-	"decompression error",
-	"compression error",
-	"can't create file",
-	"can't verify file"
-	"operation not supported",
-	"can't find metadata",
-	"invalid metadata size",
-	"unsupported CHD version"
-};
-
-static const char *chd_get_error_string(int chderr)
-{
-	if ((chderr < 0 ) || (chderr >= ARRAY_LENGTH(error_strings)))
-		return NULL;
-	return error_strings[chderr];
-}
-
-
 static OPTION_GUIDE_START(cd_option_guide)
 	OPTION_INT('K', "hunksize",			"Hunk Bytes")
 OPTION_GUIDE_END
@@ -129,10 +95,11 @@
 
 	if (software_entry() == NULL)
 	{
-		if (strstr(m_image_name,".chd")) {
-			err = chd_open_file( image_core_file(), CHD_OPEN_READ, NULL, &chd );	/* CDs are never writeable */
+		if (strstr(m_image_name,".chd") && is_loaded()) {
+			err = m_self_chd.open( *image_core_file() );	/* CDs are never writeable */
 			if ( err )
 				goto error;
+			chd = &m_self_chd;
 		}
 	} else {
 		chd  = get_disk_handle(device().machine(), device().subtag(tempstring,"cdrom"));
@@ -150,10 +117,10 @@
 	return IMAGE_INIT_PASS;
 
 error:
-	if ( chd )
-		chd_close( chd );
+	if ( chd && chd == &m_self_chd )
+		m_self_chd.close( );
 	if ( err )
-		seterror( IMAGE_ERROR_UNSPECIFIED, chd_get_error_string( err ) );
+		seterror( IMAGE_ERROR_UNSPECIFIED, chd_file::error_string( err ) );
 	return IMAGE_INIT_FAIL;
 }
 
diff -Nru src-old/emu/imagedev/chd_cd.h src/emu/imagedev/chd_cd.h
--- src-old/emu/imagedev/chd_cd.h	2011-06-25 16:24:10.000000000 +0200
+++ src/emu/imagedev/chd_cd.h	2012-02-16 10:47:18.000000000 +0100
@@ -57,6 +57,7 @@
     virtual void device_config_complete();
 	virtual void device_start();
 
+	chd_file	m_self_chd;
 	cdrom_file	*m_cdrom_handle;
 	image_device_format m_format;
 };
diff -Nru src-old/emu/imagedev/floppy.c src/emu/imagedev/floppy.c
--- src-old/emu/imagedev/floppy.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/imagedev/floppy.c	2012-02-13 09:12:24.000000000 +0100
@@ -603,6 +603,16 @@
 	}
 }
 
+UINT32 floppy_image_device::get_form_factor() const
+{
+	return form_factor;
+}
+
+UINT32 floppy_image_device::get_variant() const
+{
+	return image ? image->get_variant() : 0;
+}
+
 ui_menu *floppy_image_device::get_selection_menu(running_machine &machine, render_container *container)
 {
 	return auto_alloc_clear(machine, ui_menu_control_floppy_image(machine, container, this));
diff -Nru src-old/emu/imagedev/harddriv.c src/emu/imagedev/harddriv.c
--- src-old/emu/imagedev/harddriv.c	2012-01-16 13:55:29.000000000 +0100
+++ src/emu/imagedev/harddriv.c	2012-02-19 02:59:23.000000000 +0100
@@ -20,41 +20,6 @@
 #include "harddriv.h"
 
 
-static const char *const error_strings[] =
-{
-	"no error",
-	"no drive interface",
-	"out of memory",
-	"invalid file",
-	"invalid parameter",
-	"invalid data",
-	"file not found",
-	"requires parent",
-	"file not writeable",
-	"read error",
-	"write error",
-	"codec error",
-	"invalid parent",
-	"hunk out of range",
-	"decompression error",
-	"compression error",
-	"can't create file",
-	"can't verify file"
-	"operation not supported",
-	"can't find metadata",
-	"invalid metadata size",
-	"unsupported CHD version"
-};
-
-static const char *chd_get_error_string(int chderr)
-{
-	if ((chderr < 0 ) || (chderr >= ARRAY_LENGTH(error_strings)))
-		return NULL;
-	return error_strings[chderr];
-}
-
-
-
 static OPTION_GUIDE_START(hd_option_guide)
 	OPTION_INT('C', "cylinders",		"Cylinders")
 	OPTION_INT('H', "heads",			"Heads")
@@ -146,7 +111,7 @@
 {
 	int our_result;
 
-	our_result = internal_load_hd(NULL);
+	our_result = internal_load_hd();
 
 	/* Check if there is an image_load callback defined */
 	if ( m_device_image_load )
@@ -161,9 +126,9 @@
 bool harddisk_image_device::call_create(int create_format, option_resolution *create_args)
 {
 	int err;
-	char metadata[256];
 	UINT32 sectorsize, hunksize;
 	UINT32 cylinders, heads, sectors, totalsectors;
+	astring metadata;
 
 	cylinders	= option_resolution_lookup_int(create_args, 'C');
 	heads		= option_resolution_lookup_int(create_args, 'H');
@@ -174,12 +139,20 @@
 	totalsectors = cylinders * heads * sectors;
 
 	/* create the CHD file */
-	err = chd_create_file(image_core_file(), (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_NONE, NULL);
+	chd_codec_type compression[4] = { CHD_CODEC_NONE };
+	err = m_self_chd.create(*image_core_file(), (UINT64)totalsectors * (UINT64)sectorsize, hunksize, sectorsize, compression);
+	if (err != CHDERR_NONE)
+		goto error;
+
+	/* if we created the image and hence, have metadata to set, set the metadata */
+	metadata.format(HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sectorsize);
+	err = m_self_chd.write_metadata(HARD_DISK_METADATA_TAG, 0, metadata);
+	m_self_chd.close();
+
 	if (err != CHDERR_NONE)
 		goto error;
 
-	sprintf(metadata, HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sectorsize);
-	return internal_load_hd(metadata);
+	return internal_load_hd();
 
 error:
 	return IMAGE_INIT_FAIL;
@@ -201,12 +174,13 @@
 
 	if (m_chd != NULL)
 	{
-		chd_close(m_chd);
+		if (m_self_chd.opened())
+			m_self_chd.close();
 		m_chd = NULL;
 	}
 }
 
-int harddisk_image_device::internal_load_hd(const char *metadata)
+int harddisk_image_device::internal_load_hd()
 {
 	chd_error		err = (chd_error)0;
 	int				is_writeable;
@@ -220,8 +194,10 @@
 		do
 		{
 			is_writeable = !is_readonly();
-			m_chd = NULL;
-			err = chd_open_file(image_core_file(), is_writeable ? CHD_OPEN_READWRITE : CHD_OPEN_READ, NULL, &m_chd);
+			err = m_self_chd.open(*image_core_file(), is_writeable);
+			printf("%d\n",err);
+			if (err == CHDERR_NONE)
+				m_chd = &m_self_chd;
 
 			/* special case; if we get CHDERR_FILE_NOT_WRITEABLE, make the
              * image read only and repeat */
@@ -233,14 +209,6 @@
 	if (!m_chd)
 		goto done;
 
-	/* if we created the image and hence, have metadata to set, set the metadata */
-	if (metadata)
-	{
-		err = chd_set_metadata(m_chd, HARD_DISK_METADATA_TAG, 0, metadata, strlen(metadata) + 1, 0);
-		if (err != CHDERR_NONE)
-			goto done;
-	}
-
 	/* open the hard disk file */
 	m_hard_disk_handle = hard_disk_open(m_chd);
 	if (!m_hard_disk_handle)
@@ -252,11 +220,13 @@
 		/* if we had an error, close out the CHD */
 		if (m_chd != NULL)
 		{
-			chd_close(m_chd);
+			if (m_self_chd.opened())
+				m_self_chd.close();
 			m_chd = NULL;
 		}
-
-		seterror(IMAGE_ERROR_UNSPECIFIED, chd_get_error_string(err));
+		printf("%d\n",err);
+		seterror(IMAGE_ERROR_UNSPECIFIED, chd_file::error_string(err));
+		printf("%s\n",chd_file::error_string(err));
 	}
 	return err ? IMAGE_INIT_FAIL : IMAGE_INIT_PASS;
 }
diff -Nru src-old/emu/imagedev/harddriv.h src/emu/imagedev/harddriv.h
--- src-old/emu/imagedev/harddriv.h	2011-11-27 15:06:49.000000000 +0100
+++ src/emu/imagedev/harddriv.h	2012-02-16 10:47:18.000000000 +0100
@@ -64,9 +64,10 @@
     virtual void device_config_complete();
 	virtual void device_start();
 
-	int internal_load_hd(const char *metadata);
+	int internal_load_hd();
 
 	chd_file		*m_chd;
+	chd_file		m_self_chd;
 	hard_disk_file	*m_hard_disk_handle;
 
 	image_device_format m_format;
diff -Nru src-old/emu/info.c src/emu/info.c
--- src-old/emu/info.c	2012-01-25 16:20:11.000000000 +0100
+++ src/emu/info.c	2012-02-19 02:53:16.000000000 +0100
@@ -43,7 +43,6 @@
 #include "sound/samples.h"
 #include "info.h"
 #include "xmlfile.h"
-#include "hash.h"
 #include "config.h"
 
 #include <ctype.h>
@@ -411,20 +410,14 @@
 	samples_device_iterator iter(m_drivlist.config().root_device());
 	for (samples_device *device = iter.first(); device != NULL; device = iter.next())
 	{
-		const char *const *samplenames = ((const samples_interface *)device->static_config())->samplenames;
-		if (samplenames != NULL)
-
-			// iterate over sample names
-			for (int sampnum = 0; samplenames[sampnum] != NULL; sampnum++)
-			{
-				// only output sampleof if different from the game name
-				const char *cursampname = samplenames[sampnum];
-				if (cursampname[0] == '*' && strcmp(cursampname + 1, m_drivlist.driver().name) != 0)
-					fprintf(m_output, " sampleof=\"%s\"", xml_normalize_string(cursampname + 1));
+		samples_iterator sampiter(*device);
+		if (sampiter.altbasename() != NULL)
+		{
+			fprintf(m_output, " sampleof=\"%s\"", xml_normalize_string(sampiter.altbasename()));
 
-				// must stop here, as there can only be one attribute of the same name
-				return;
-			}
+			// must stop here, as there can only be one attribute of the same name
+			return;
+		}
 	}
 }
 
@@ -525,19 +518,14 @@
 					{
 						// iterate over hash function types and print m_output their values
 						astring tempstr;
-						for (hash_base *hash = hashes.first(); hash != NULL; hash = hash->next())
-							fprintf(m_output, " %s=\"%s\"", hash->name(), hash->string(tempstr));
+						fprintf(m_output, " %s", hashes.attribute_string(tempstr));
 					}
+					else
+						fprintf(m_output, " status=\"nodump\"");
 
 					// append a region name
 					fprintf(m_output, " region=\"%s\"", ROMREGION_GETTAG(region));
 
-					// add nodump/baddump flags
-					if (hashes.flag(hash_collection::FLAG_NO_DUMP))
-						fprintf(m_output, " status=\"nodump\"");
-					if (hashes.flag(hash_collection::FLAG_BAD_DUMP))
-						fprintf(m_output, " status=\"baddump\"");
-
 					// for non-disk entries, print offset
 					if (!is_disk)
 						fprintf(m_output, " offset=\"%x\"", offset);
@@ -569,30 +557,19 @@
 {
 	// iterate over sample devices
 	samples_device_iterator iter(m_drivlist.config().root_device());
-	for (const device_t *device = iter.first(); device != NULL; device = iter.next())
+	for (samples_device *device = iter.first(); device != NULL; device = iter.next())
 	{
-		const char *const *samplenames = ((const samples_interface *)device->static_config())->samplenames;
-		if (samplenames != NULL)
-
-			// iterate over sample names
-			for (int sampnum = 0; samplenames[sampnum] != NULL; sampnum++)
-			{
-				// ignore the special '*' samplename
-				const char *cursampname = samplenames[sampnum];
-				if (sampnum == 0 && cursampname[0] == '*')
-					continue;
-
-				// filter m_output duplicates
-				int dupnum;
-				for (dupnum = 0; dupnum < sampnum; dupnum++)
-					if (strcmp(samplenames[dupnum], cursampname) == 0)
-						break;
-				if (dupnum < sampnum)
-					continue;
+		samples_iterator sampiter(*device);
+		tagmap_t<int> already_printed;
+		for (const char *samplename = sampiter.first(); samplename != NULL; samplename = sampiter.next())
+		{
+			// filter out duplicates
+			if (already_printed.add(samplename, 1) == TMERR_DUPLICATE)
+				continue;
 
-				// output the sample name
-				fprintf(m_output, "\t\t<sample name=\"%s\"/>\n", xml_normalize_string(cursampname));
-			}
+			// output the sample name
+			fprintf(m_output, "\t\t<sample name=\"%s\"/>\n", xml_normalize_string(samplename));
+		}
 	}
 }
 
@@ -1211,17 +1188,18 @@
          */
 
 		const slot_interface* intf = slot->get_slot_interfaces();
-		for (int i = 0; intf[i].name != NULL; i++)
-		{
-			fprintf(m_output, "\t\t\t<slotoption");
-			fprintf(m_output, " name=\"%s\"", xml_normalize_string(intf[i].name));
-			if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()))
+		if (intf)
+			for (int i = 0; intf[i].name != NULL; i++)
 			{
-				if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()) == intf[i].name)
-					fprintf(m_output, " default=\"yes\"");
+				fprintf(m_output, "\t\t\t<slotoption");
+				fprintf(m_output, " name=\"%s\"", xml_normalize_string(intf[i].name));
+				if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()))
+				{
+					if (slot->get_default_card(m_drivlist.config(), m_drivlist.options()) == intf[i].name)
+						fprintf(m_output, " default=\"yes\"");
+				}
+				fprintf(m_output, "/>\n");
 			}
-			fprintf(m_output, "/>\n");
-		}
 
 		fprintf(m_output, "\t\t</slot>\n");
 	}
diff -Nru src-old/emu/input.c src/emu/input.c
--- src-old/emu/input.c	2012-01-03 01:21:13.000000000 +0100
+++ src/emu/input.c	2012-02-06 02:30:22.000000000 +0100
@@ -48,7 +48,6 @@
 
 #include "emu.h"
 #include "emuopts.h"
-#include "profiler.h"
 
 
 
diff -Nru src-old/emu/ioport.c src/emu/ioport.c
--- src-old/emu/ioport.c	2012-02-05 06:15:21.000000000 +0100
+++ src/emu/ioport.c	2012-02-06 21:18:33.000000000 +0100
@@ -242,13 +242,16 @@
 	const input_field_config * field[NUM_SIMUL_KEYS];
 };
 
+#define KEY_BUFFER_SIZE	4096
+
 typedef struct _key_buffer key_buffer;
 struct _key_buffer
 {
 	int begin_pos;
 	int end_pos;
 	unsigned int status_keydown : 1;
-	unicode_char buffer[4096];
+	int size;
+	unicode_char *buffer;
 };
 
 typedef struct _char_info char_info;
@@ -285,7 +288,7 @@
 
 	/* inputx */
 	inputx_code *codes;
-	key_buffer *keybuffer;
+	key_buffer keybuffer;
 	emu_timer *inputx_timer;
 	int (*queue_chars)(running_machine &machine, const unicode_char *text, size_t text_len);
 	int (*accept_char)(running_machine &machine, unicode_char ch);
@@ -2331,7 +2334,7 @@
 {
 	input_port_private *portdata = machine.input_port_data;
 	assert(inputx_can_post(machine));
-	return (key_buffer *)portdata->keybuffer;
+	return (key_buffer *)&portdata->keybuffer;
 }
 
 
@@ -4176,7 +4179,7 @@
 static void clear_keybuffer(running_machine &machine)
 {
 	input_port_private *portdata = machine.input_port_data;
-	portdata->keybuffer = NULL;
+	portdata->keybuffer.buffer = NULL;
 	portdata->queue_chars = NULL;
 	portdata->codes = NULL;
 }
@@ -4187,7 +4190,11 @@
 {
 	input_port_private *portdata = machine.input_port_data;
 	portdata->inputx_timer = machine.scheduler().timer_alloc(FUNC(inputx_timerproc));
-	portdata->keybuffer = auto_alloc_clear(machine, key_buffer);
+	portdata->keybuffer.begin_pos = 0;
+	portdata->keybuffer.end_pos = 0;
+	portdata->keybuffer.status_keydown = 0;
+	portdata->keybuffer.size = KEY_BUFFER_SIZE;
+	portdata->keybuffer.buffer = auto_alloc_array(machine, unicode_char, portdata->keybuffer.size);
 	machine.add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(clear_keybuffer), &machine));
 }
 
@@ -4196,12 +4203,10 @@
 void inputx_init(running_machine &machine)
 {
 	input_port_private *portdata = machine.input_port_data;
-	portdata->codes = NULL;
 	portdata->inputx_timer = NULL;
-	portdata->queue_chars = NULL;
 	portdata->accept_char = NULL;
 	portdata->charqueue_empty = NULL;
-	portdata->keybuffer = NULL;
+	clear_keybuffer(machine);
 
 	if (machine.debug_flags & DEBUG_FLAG_ENABLED)
 	{
@@ -4326,7 +4331,19 @@
 	}
 
 	keybuf->buffer[keybuf->end_pos++] = ch;
-	keybuf->end_pos %= ARRAY_LENGTH(keybuf->buffer);
+	if ((keybuf->end_pos+1) % keybuf->size == keybuf->begin_pos)
+	{
+		// Buffer full
+		unicode_char *old_buffer = keybuf->buffer;
+		keybuf->size = keybuf->size + KEY_BUFFER_SIZE;
+		keybuf->buffer = auto_alloc_array(machine, unicode_char, keybuf->size);
+		for( int i = keybuf->begin_pos; i <= keybuf->end_pos; i++ )
+		{
+			keybuf->buffer[i] = old_buffer[i];
+		}
+		auto_free(machine, old_buffer);
+	}
+	keybuf->end_pos %= keybuf->size;
 }
 
 
@@ -4335,7 +4352,7 @@
 {
 	key_buffer *keybuf;
 	keybuf = get_buffer(machine);
-	return ((keybuf->end_pos + 1) % ARRAY_LENGTH(keybuf->buffer)) == keybuf->begin_pos;
+	return ((keybuf->end_pos + 1) % keybuf->size) == keybuf->begin_pos;
 }
 
 
@@ -4414,7 +4431,7 @@
 		while((keybuf->begin_pos != keybuf->end_pos) && (*portdata->queue_chars)(machine, &keybuf->buffer[keybuf->begin_pos], 1))
 		{
 			keybuf->begin_pos++;
-			keybuf->begin_pos %= ARRAY_LENGTH(keybuf->buffer);
+			keybuf->begin_pos %= keybuf->size;
 
 			if (portdata->current_rate != attotime::zero)
 				break;
@@ -4427,7 +4444,7 @@
 		{
 			keybuf->status_keydown = FALSE;
 			keybuf->begin_pos++;
-			keybuf->begin_pos %= ARRAY_LENGTH(keybuf->buffer);
+			keybuf->begin_pos %= keybuf->size;
 		}
 		else
 		{
diff -Nru src-old/emu/machine/6525tpi.c src/emu/machine/6525tpi.c
--- src-old/emu/machine/6525tpi.c	2011-05-06 18:13:14.000000000 +0200
+++ src/emu/machine/6525tpi.c	2012-02-13 08:58:10.000000000 +0100
@@ -535,37 +535,36 @@
 	{
 	case 0:
 		tpi6525->port_a = data;
-		tpi6525->out_pa_func(0, tpi6525->port_a & tpi6525->ddr_a);
+		tpi6525->out_pa_func(0, (tpi6525->port_a & tpi6525->ddr_a) | (tpi6525->ddr_a ^ 0xff));
 		break;
 
 	case 1:
 		tpi6525->port_b = data;
-		tpi6525->out_pb_func(0, tpi6525->port_b & tpi6525->ddr_b);
+		tpi6525->out_pb_func(0, (tpi6525->port_b & tpi6525->ddr_b) | (tpi6525->ddr_b ^ 0xff));
 		break;
 
 	case 2:
 		tpi6525->port_c = data;
 
 		if (!INTERRUPT_MODE)
-			tpi6525->out_pc_func(0, tpi6525->port_c & tpi6525->ddr_c);
+			tpi6525->out_pc_func(0, (tpi6525->port_c & tpi6525->ddr_c) | (tpi6525->ddr_c ^ 0xff));
 		break;
 
 	case 3:
 		tpi6525->ddr_a = data;
-		tpi6525->out_pa_func(0, tpi6525->port_a & tpi6525->ddr_a);
-
+		tpi6525->out_pa_func(0, (tpi6525->port_a & tpi6525->ddr_a) | (tpi6525->ddr_a ^ 0xff));
 		break;
 
 	case 4:
 		tpi6525->ddr_b = data;
-		tpi6525->out_pb_func(0, tpi6525->port_b & tpi6525->ddr_b);
+		tpi6525->out_pb_func(0, (tpi6525->port_b & tpi6525->ddr_b) | (tpi6525->ddr_b ^ 0xff));
 		break;
 
 	case 5:
 		tpi6525->ddr_c = data;
 
 		if (!INTERRUPT_MODE)
-			tpi6525->out_pc_func(0, tpi6525->port_c & tpi6525->ddr_c);
+			tpi6525->out_pc_func(0, (tpi6525->port_c & tpi6525->ddr_c) | (tpi6525->ddr_c ^ 0xff));
 		break;
 
 	case 6:
diff -Nru src-old/emu/machine/8237dma.c src/emu/machine/8237dma.c
--- src-old/emu/machine/8237dma.c	2011-05-02 04:32:58.000000000 +0200
+++ src/emu/machine/8237dma.c	2012-02-18 11:58:12.000000000 +0100
@@ -131,6 +131,7 @@
 	m_eop = 1;
 	m_state = DMA8237_SI;
 	m_last_service_channel = 3;
+    m_service_channel = 0;
 
 	m_command = 0;
 	m_drq = 0;
diff -Nru src-old/emu/machine/generic.c src/emu/machine/generic.c
--- src-old/emu/machine/generic.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/machine/generic.c	2012-02-11 11:01:01.000000000 +0100
@@ -583,17 +583,17 @@
 
 /*-------------------------------------------------
     generic_pulse_irq_line - "pulse" an IRQ line by
-    asserting it and then clearing it 1 cycle
+    asserting it and then clearing it x cycle(s)
     later
 -------------------------------------------------*/
 
-void generic_pulse_irq_line(device_t *device, int irqline)
+void generic_pulse_irq_line(device_t *device, int irqline, int cycles)
 {
-	assert(irqline != INPUT_LINE_NMI && irqline != INPUT_LINE_RESET);
+	assert(irqline != INPUT_LINE_NMI && irqline != INPUT_LINE_RESET && cycles > 0);
 	device_set_input_line(device, irqline, ASSERT_LINE);
 
 	cpu_device *cpudevice = downcast<cpu_device *>(device);
-	attotime target_time = cpudevice->local_time() + cpudevice->cycles_to_attotime(cpudevice->min_cycles());
+	attotime target_time = cpudevice->local_time() + cpudevice->cycles_to_attotime(cycles * cpudevice->min_cycles());
 	device->machine().scheduler().timer_set(target_time - device->machine().time(), FUNC(irq_pulse_clear), irqline, (void *)device);
 }
 
@@ -601,16 +601,16 @@
 /*-------------------------------------------------
     generic_pulse_irq_line_and_vector - "pulse" an
     IRQ line by asserting it and then clearing it
-    1 cycle later, specifying a vector
+    x cycle(s) later, specifying a vector
 -------------------------------------------------*/
 
-void generic_pulse_irq_line_and_vector(device_t *device, int irqline, int vector)
+void generic_pulse_irq_line_and_vector(device_t *device, int irqline, int vector, int cycles)
 {
-	assert(irqline != INPUT_LINE_NMI && irqline != INPUT_LINE_RESET);
+	assert(irqline != INPUT_LINE_NMI && irqline != INPUT_LINE_RESET && cycles > 0);
 	device_set_input_line_and_vector(device, irqline, ASSERT_LINE, vector);
 
 	cpu_device *cpudevice = downcast<cpu_device *>(device);
-	attotime target_time = cpudevice->local_time() + cpudevice->cycles_to_attotime(cpudevice->min_cycles());
+	attotime target_time = cpudevice->local_time() + cpudevice->cycles_to_attotime(cycles * cpudevice->min_cycles());
 	device->machine().scheduler().timer_set(target_time - device->machine().time(), FUNC(irq_pulse_clear), irqline, (void *)device);
 }
 
@@ -633,35 +633,35 @@
 -------------------------------------------------*/
 
 INTERRUPT_GEN( irq0_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 0, HOLD_LINE); }
-INTERRUPT_GEN( irq0_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 0); }
+INTERRUPT_GEN( irq0_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 0, 1); }
 INTERRUPT_GEN( irq0_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 0, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq1_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 1, HOLD_LINE); }
-INTERRUPT_GEN( irq1_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 1); }
+INTERRUPT_GEN( irq1_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 1, 1); }
 INTERRUPT_GEN( irq1_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 1, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq2_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 2, HOLD_LINE); }
-INTERRUPT_GEN( irq2_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 2); }
+INTERRUPT_GEN( irq2_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 2, 1); }
 INTERRUPT_GEN( irq2_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 2, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq3_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 3, HOLD_LINE); }
-INTERRUPT_GEN( irq3_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 3); }
+INTERRUPT_GEN( irq3_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 3, 1); }
 INTERRUPT_GEN( irq3_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 3, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq4_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 4, HOLD_LINE); }
-INTERRUPT_GEN( irq4_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 4); }
+INTERRUPT_GEN( irq4_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 4, 1); }
 INTERRUPT_GEN( irq4_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 4, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq5_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 5, HOLD_LINE); }
-INTERRUPT_GEN( irq5_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 5); }
+INTERRUPT_GEN( irq5_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 5, 1); }
 INTERRUPT_GEN( irq5_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 5, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq6_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 6, HOLD_LINE); }
-INTERRUPT_GEN( irq6_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 6); }
+INTERRUPT_GEN( irq6_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 6, 1); }
 INTERRUPT_GEN( irq6_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 6, ASSERT_LINE); }
 
 INTERRUPT_GEN( irq7_line_hold )		{ if (interrupt_enabled(device)) device_set_input_line(device, 7, HOLD_LINE); }
-INTERRUPT_GEN( irq7_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 7); }
+INTERRUPT_GEN( irq7_line_pulse )	{ if (interrupt_enabled(device)) generic_pulse_irq_line(device, 7, 1); }
 INTERRUPT_GEN( irq7_line_assert )	{ if (interrupt_enabled(device)) device_set_input_line(device, 7, ASSERT_LINE); }
 
 
diff -Nru src-old/emu/machine/generic.h src/emu/machine/generic.h
--- src-old/emu/machine/generic.h	2011-11-30 17:51:09.000000000 +0100
+++ src/emu/machine/generic.h	2012-02-11 11:01:01.000000000 +0100
@@ -106,8 +106,8 @@
 
 /* ----- interrupt enable and vector helpers ----- */
 
-void generic_pulse_irq_line(device_t *device, int irqline);
-void generic_pulse_irq_line_and_vector(device_t *device, int irqline, int vector);
+void generic_pulse_irq_line(device_t *device, int irqline, int cycles);
+void generic_pulse_irq_line_and_vector(device_t *device, int irqline, int vector, int cycles);
 
 
 
diff -Nru src-old/emu/machine/i8251.c src/emu/machine/i8251.c
--- src-old/emu/machine/i8251.c	2011-12-30 09:57:43.000000000 +0100
+++ src/emu/machine/i8251.c	2012-02-05 23:25:32.000000000 +0100
@@ -101,6 +101,7 @@
 	// resolve callbacks
 	m_in_rxd_func.resolve(m_in_rxd_cb,*this);
 	m_out_txd_func.resolve(m_out_txd_cb,*this);
+	m_in_dsr_func.resolve(m_in_dsr_cb,*this);
 	m_out_rxrdy_func.resolve(m_out_rxrdy_cb, *this);
 	m_out_txrdy_func.resolve(m_out_txrdy_cb, *this);
 	m_out_txempty_func.resolve(m_out_txempty_cb, *this);
@@ -641,8 +642,11 @@
 
 READ8_MEMBER(i8251_device::status_r)
 {
-	LOG(("status: %02x\n", m_status));
-	return m_status;
+	UINT8 dsr = !(m_in_dsr_func.isnull() ? 0 : m_in_dsr_func() != 0);
+	UINT8 status = (dsr << 7) | m_status;
+
+	LOG(("status: %02x\n", status));
+	return status;
 }
 
 
diff -Nru src-old/emu/machine/idectrl.c src/emu/machine/idectrl.c
--- src-old/emu/machine/idectrl.c	2012-01-26 16:19:53.000000000 +0100
+++ src/emu/machine/idectrl.c	2012-02-19 16:23:23.000000000 +0100
@@ -7,7 +7,6 @@
 #include "emu.h"
 #include "idectrl.h"
 #include "debugger.h"
-#include "imagedev/harddriv.h"
 
 /***************************************************************************
     DEBUGGING
@@ -27,8 +26,6 @@
     CONSTANTS
 ***************************************************************************/
 
-#define IDE_DISK_SECTOR_SIZE			512
-
 #define MINIMUM_COMMAND_TIME			(attotime::from_usec(10))
 
 #define TIME_PER_SECTOR					(attotime::from_usec(100))
@@ -108,22 +105,12 @@
 typedef struct _ide_device ide_device;
 struct _ide_device
 {
-	UINT8			features[IDE_DISK_SECTOR_SIZE];
-
 	UINT16			cur_cylinder;
 	UINT8			cur_sector;
 	UINT8			cur_head;
 	UINT8			cur_head_reg;
-
 	UINT32			cur_lba;
-
-	UINT16			num_cylinders;
-	UINT8			num_sectors;
-	UINT8			num_heads;
-
-	chd_file       *handle;
-	hard_disk_file *disk;
-	bool			is_image_device;
+	ide_slot_device *slot;
 };
 
 
@@ -172,7 +159,6 @@
 	const UINT8 *	user_password;
 
 	UINT8			gnetreadlock;
-	ide_hardware *	hardware;
 
 	UINT8			cur_drive;
 	ide_device		drive[2];
@@ -186,8 +172,6 @@
 
 static TIMER_CALLBACK( reset_callback );
 
-static void ide_build_features(ide_state *ide, int drive);
-
 static void continue_read(ide_state *ide);
 static void read_sector_done(ide_state *ide);
 static TIMER_CALLBACK( read_sector_done_callback );
@@ -288,7 +272,7 @@
 UINT8 *ide_get_features(device_t *device, int drive)
 {
 	ide_state *ide = get_safe_token(device);
-	return ide->drive[drive].features;
+	return ide->drive[drive].slot->get_features();
 }
 
 void ide_set_gnet_readlock(device_t *device, const UINT8 onoff)
@@ -388,7 +372,7 @@
 
 	/* standard CHS */
 	else
-		return (ide->drive[ide->cur_drive].cur_cylinder * ide->drive[ide->cur_drive].num_heads + ide->drive[ide->cur_drive].cur_head) * ide->drive[ide->cur_drive].num_sectors + ide->drive[ide->cur_drive].cur_sector - 1;
+		return (ide->drive[ide->cur_drive].cur_cylinder * ide->drive[ide->cur_drive].slot->get_heads() + ide->drive[ide->cur_drive].cur_head) * ide->drive[ide->cur_drive].slot->get_sectors() + ide->drive[ide->cur_drive].cur_sector - 1;
 }
 
 
@@ -418,12 +402,12 @@
 	{
 		/* sectors are 1-based */
 		ide->drive[ide->cur_drive].cur_sector++;
-		if (ide->drive[ide->cur_drive].cur_sector > ide->drive[ide->cur_drive].num_sectors)
+		if (ide->drive[ide->cur_drive].cur_sector > ide->drive[ide->cur_drive].slot->get_sectors())
 		{
 			/* heads are 0 based */
 			ide->drive[ide->cur_drive].cur_sector = 1;
 			ide->drive[ide->cur_drive].cur_head++;
-			if (ide->drive[ide->cur_drive].cur_head >= ide->drive[ide->cur_drive].num_heads)
+			if (ide->drive[ide->cur_drive].cur_head >= ide->drive[ide->cur_drive].slot->get_heads())
 			{
 				ide->drive[ide->cur_drive].cur_head = 0;
 				ide->drive[ide->cur_drive].cur_cylinder++;
@@ -455,168 +439,161 @@
 }
 
 
-static void ide_generate_features(ide_state *ide,int drive)
+void ide_hdd_device::ide_build_features()
 {
-	int total_sectors = ide->drive[drive].num_cylinders * ide->drive[drive].num_heads * ide->drive[drive].num_sectors;
-	int sectors_per_track = ide->drive[drive].num_heads * ide->drive[drive].num_sectors;
+	memset(m_features, 0, IDE_DISK_SECTOR_SIZE);
+	int total_sectors = m_num_cylinders * m_num_heads * m_num_sectors;
+	int sectors_per_track = m_num_heads * m_num_sectors;
 
 	/* basic geometry */
-	ide->drive[drive].features[ 0*2+0] = 0x5a;						/*  0: configuration bits */
-	ide->drive[drive].features[ 0*2+1] = 0x04;
-	ide->drive[drive].features[ 1*2+0] = ide->drive[drive].num_cylinders & 0xff;	/*  1: logical cylinders */
-	ide->drive[drive].features[ 1*2+1] = ide->drive[drive].num_cylinders >> 8;
-	ide->drive[drive].features[ 2*2+0] = 0;							/*  2: reserved */
-	ide->drive[drive].features[ 2*2+1] = 0;
-	ide->drive[drive].features[ 3*2+0] = ide->drive[drive].num_heads & 0xff;		/*  3: logical heads */
-	ide->drive[drive].features[ 3*2+1] = 0;/*ide->num_heads >> 8;*/
-	ide->drive[drive].features[ 4*2+0] = 0;							/*  4: vendor specific (obsolete) */
-	ide->drive[drive].features[ 4*2+1] = 0;
-	ide->drive[drive].features[ 5*2+0] = 0;							/*  5: vendor specific (obsolete) */
-	ide->drive[drive].features[ 5*2+1] = 0;
-	ide->drive[drive].features[ 6*2+0] = ide->drive[drive].num_sectors & 0xff;	/*  6: logical sectors per logical track */
-	ide->drive[drive].features[ 6*2+1] = 0;/*ide->num_sectors >> 8;*/
-	ide->drive[drive].features[ 7*2+0] = 0;							/*  7: vendor-specific */
-	ide->drive[drive].features[ 7*2+1] = 0;
-	ide->drive[drive].features[ 8*2+0] = 0;							/*  8: vendor-specific */
-	ide->drive[drive].features[ 8*2+1] = 0;
-	ide->drive[drive].features[ 9*2+0] = 0;							/*  9: vendor-specific */
-	ide->drive[drive].features[ 9*2+1] = 0;
-	swap_strncpy(&ide->drive[drive].features[10*2+0],				/* 10-19: serial number */
+	m_features[ 0*2+0] = 0x5a;						/*  0: configuration bits */
+	m_features[ 0*2+1] = 0x04;
+	m_features[ 1*2+0] = m_num_cylinders & 0xff;	/*  1: logical cylinders */
+	m_features[ 1*2+1] = m_num_cylinders >> 8;
+	m_features[ 2*2+0] = 0;							/*  2: reserved */
+	m_features[ 2*2+1] = 0;
+	m_features[ 3*2+0] = m_num_heads & 0xff;		/*  3: logical heads */
+	m_features[ 3*2+1] = 0;/*ide->num_heads >> 8;*/
+	m_features[ 4*2+0] = 0;							/*  4: vendor specific (obsolete) */
+	m_features[ 4*2+1] = 0;
+	m_features[ 5*2+0] = 0;							/*  5: vendor specific (obsolete) */
+	m_features[ 5*2+1] = 0;
+	m_features[ 6*2+0] = m_num_sectors & 0xff;	/*  6: logical sectors per logical track */
+	m_features[ 6*2+1] = 0;/*ide->num_sectors >> 8;*/
+	m_features[ 7*2+0] = 0;							/*  7: vendor-specific */
+	m_features[ 7*2+1] = 0;
+	m_features[ 8*2+0] = 0;							/*  8: vendor-specific */
+	m_features[ 8*2+1] = 0;
+	m_features[ 9*2+0] = 0;							/*  9: vendor-specific */
+	m_features[ 9*2+1] = 0;
+	swap_strncpy(&m_features[10*2+0],				/* 10-19: serial number */
 			"00000000000000000000", 10);
-	ide->drive[drive].features[20*2+0] = 0;							/* 20: vendor-specific */
-	ide->drive[drive].features[20*2+1] = 0;
-	ide->drive[drive].features[21*2+0] = 0;							/* 21: vendor-specific */
-	ide->drive[drive].features[21*2+1] = 0;
-	ide->drive[drive].features[22*2+0] = 4;							/* 22: # of vendor-specific bytes on read/write long commands */
-	ide->drive[drive].features[22*2+1] = 0;
-	swap_strncpy(&ide->drive[drive].features[23*2+0],				/* 23-26: firmware revision */
+	m_features[20*2+0] = 0;							/* 20: vendor-specific */
+	m_features[20*2+1] = 0;
+	m_features[21*2+0] = 0;							/* 21: vendor-specific */
+	m_features[21*2+1] = 0;
+	m_features[22*2+0] = 4;							/* 22: # of vendor-specific bytes on read/write long commands */
+	m_features[22*2+1] = 0;
+	swap_strncpy(&m_features[23*2+0],				/* 23-26: firmware revision */
 			"1.0", 4);
-	swap_strncpy(&ide->drive[drive].features[27*2+0],				/* 27-46: model number */
+	swap_strncpy(&m_features[27*2+0],				/* 27-46: model number */
 			"MAME Compressed Hard Disk", 20);
-	ide->drive[drive].features[47*2+0] = 0x01;						/* 47: read/write multiple support */
-	ide->drive[drive].features[47*2+1] = 0x80;
-	ide->drive[drive].features[48*2+0] = 0;							/* 48: reserved */
-	ide->drive[drive].features[48*2+1] = 0;
-	ide->drive[drive].features[49*2+0] = 0x03;						/* 49: capabilities */
-	ide->drive[drive].features[49*2+1] = 0x0f;
-	ide->drive[drive].features[50*2+0] = 0;							/* 50: reserved */
-	ide->drive[drive].features[50*2+1] = 0;
-	ide->drive[drive].features[51*2+0] = 2;							/* 51: PIO data transfer cycle timing mode */
-	ide->drive[drive].features[51*2+1] = 0;
-	ide->drive[drive].features[52*2+0] = 2;							/* 52: single word DMA transfer cycle timing mode */
-	ide->drive[drive].features[52*2+1] = 0;
-	ide->drive[drive].features[53*2+0] = 3;							/* 53: field validity */
-	ide->drive[drive].features[53*2+1] = 0;
-	ide->drive[drive].features[54*2+0] = ide->drive[drive].num_cylinders & 0xff;	/* 54: number of current logical cylinders */
-	ide->drive[drive].features[54*2+1] = ide->drive[drive].num_cylinders >> 8;
-	ide->drive[drive].features[55*2+0] = ide->drive[drive].num_heads & 0xff;		/* 55: number of current logical heads */
-	ide->drive[drive].features[55*2+1] = 0;/*ide->num_heads >> 8;*/
-	ide->drive[drive].features[56*2+0] = ide->drive[drive].num_sectors & 0xff;	/* 56: number of current logical sectors per track */
-	ide->drive[drive].features[56*2+1] = 0;/*ide->num_sectors >> 8;*/
-	ide->drive[drive].features[57*2+0] = sectors_per_track & 0xff;	/* 57-58: number of current logical sectors per track */
-	ide->drive[drive].features[57*2+1] = sectors_per_track >> 8;
-	ide->drive[drive].features[58*2+0] = sectors_per_track >> 16;
-	ide->drive[drive].features[58*2+1] = sectors_per_track >> 24;
-	ide->drive[drive].features[59*2+0] = 0;							/* 59: multiple sector timing */
-	ide->drive[drive].features[59*2+1] = 0;
-	ide->drive[drive].features[60*2+0] = total_sectors & 0xff;		/* 60-61: total user addressable sectors */
-	ide->drive[drive].features[60*2+1] = total_sectors >> 8;
-	ide->drive[drive].features[61*2+0] = total_sectors >> 16;
-	ide->drive[drive].features[61*2+1] = total_sectors >> 24;
-	ide->drive[drive].features[62*2+0] = 0x07;						/* 62: single word dma transfer */
-	ide->drive[drive].features[62*2+1] = 0x00;
-	ide->drive[drive].features[63*2+0] = 0x07;						/* 63: multiword DMA transfer */
-	ide->drive[drive].features[63*2+1] = 0x04;
-	ide->drive[drive].features[64*2+0] = 0x03;						/* 64: flow control PIO transfer modes supported */
-	ide->drive[drive].features[64*2+1] = 0x00;
-	ide->drive[drive].features[65*2+0] = 0x78;						/* 65: minimum multiword DMA transfer cycle time per word */
-	ide->drive[drive].features[65*2+1] = 0x00;
-	ide->drive[drive].features[66*2+0] = 0x78;						/* 66: mfr's recommended multiword DMA transfer cycle time */
-	ide->drive[drive].features[66*2+1] = 0x00;
-	ide->drive[drive].features[67*2+0] = 0x4d;						/* 67: minimum PIO transfer cycle time without flow control */
-	ide->drive[drive].features[67*2+1] = 0x01;
-	ide->drive[drive].features[68*2+0] = 0x78;						/* 68: minimum PIO transfer cycle time with IORDY */
-	ide->drive[drive].features[68*2+1] = 0x00;
-	ide->drive[drive].features[69*2+0] = 0x00;						/* 69-70: reserved */
-	ide->drive[drive].features[69*2+1] = 0x00;
-	ide->drive[drive].features[71*2+0] = 0x00;						/* 71: reserved for IDENTIFY PACKET command */
-	ide->drive[drive].features[71*2+1] = 0x00;
-	ide->drive[drive].features[72*2+0] = 0x00;						/* 72: reserved for IDENTIFY PACKET command */
-	ide->drive[drive].features[72*2+1] = 0x00;
-	ide->drive[drive].features[73*2+0] = 0x00;						/* 73: reserved for IDENTIFY PACKET command */
-	ide->drive[drive].features[73*2+1] = 0x00;
-	ide->drive[drive].features[74*2+0] = 0x00;						/* 74: reserved for IDENTIFY PACKET command */
-	ide->drive[drive].features[74*2+1] = 0x00;
-	ide->drive[drive].features[75*2+0] = 0x00;						/* 75: queue depth */
-	ide->drive[drive].features[75*2+1] = 0x00;
-	ide->drive[drive].features[76*2+0] = 0x00;						/* 76-79: reserved */
-	ide->drive[drive].features[76*2+1] = 0x00;
-	ide->drive[drive].features[80*2+0] = 0x00;						/* 80: major version number */
-	ide->drive[drive].features[80*2+1] = 0x00;
-	ide->drive[drive].features[81*2+0] = 0x00;						/* 81: minor version number */
-	ide->drive[drive].features[81*2+1] = 0x00;
-	ide->drive[drive].features[82*2+0] = 0x00;						/* 82: command set supported */
-	ide->drive[drive].features[82*2+1] = 0x00;
-	ide->drive[drive].features[83*2+0] = 0x00;						/* 83: command sets supported */
-	ide->drive[drive].features[83*2+1] = 0x00;
-	ide->drive[drive].features[84*2+0] = 0x00;						/* 84: command set/feature supported extension */
-	ide->drive[drive].features[84*2+1] = 0x00;
-	ide->drive[drive].features[85*2+0] = 0x00;						/* 85: command set/feature enabled */
-	ide->drive[drive].features[85*2+1] = 0x00;
-	ide->drive[drive].features[86*2+0] = 0x00;						/* 86: command set/feature enabled */
-	ide->drive[drive].features[86*2+1] = 0x00;
-	ide->drive[drive].features[87*2+0] = 0x00;						/* 87: command set/feature default */
-	ide->drive[drive].features[87*2+1] = 0x00;
-	ide->drive[drive].features[88*2+0] = 0x00;						/* 88: additional DMA modes */
-	ide->drive[drive].features[88*2+1] = 0x00;
-	ide->drive[drive].features[89*2+0] = 0x00;						/* 89: time required for security erase unit completion */
-	ide->drive[drive].features[89*2+1] = 0x00;
-	ide->drive[drive].features[90*2+0] = 0x00;						/* 90: time required for enhanced security erase unit completion */
-	ide->drive[drive].features[90*2+1] = 0x00;
-	ide->drive[drive].features[91*2+0] = 0x00;						/* 91: current advanced power management value */
-	ide->drive[drive].features[91*2+1] = 0x00;
-	ide->drive[drive].features[92*2+0] = 0x00;						/* 92: master password revision code */
-	ide->drive[drive].features[92*2+1] = 0x00;
-	ide->drive[drive].features[93*2+0] = 0x00;						/* 93: hardware reset result */
-	ide->drive[drive].features[93*2+1] = 0x00;
-	ide->drive[drive].features[94*2+0] = 0x00;						/* 94: acoustic management values */
-	ide->drive[drive].features[94*2+1] = 0x00;
-	ide->drive[drive].features[95*2+0] = 0x00;						/* 95-99: reserved */
-	ide->drive[drive].features[95*2+1] = 0x00;
-	ide->drive[drive].features[100*2+0] = total_sectors & 0xff;		/* 100-103: maximum 48-bit LBA */
-	ide->drive[drive].features[100*2+1] = total_sectors >> 8;
-	ide->drive[drive].features[101*2+0] = total_sectors >> 16;
-	ide->drive[drive].features[101*2+1] = total_sectors >> 24;
-	ide->drive[drive].features[102*2+0] = 0x00;
-	ide->drive[drive].features[102*2+1] = 0x00;
-	ide->drive[drive].features[103*2+0] = 0x00;
-	ide->drive[drive].features[103*2+1] = 0x00;
-	ide->drive[drive].features[104*2+0] = 0x00;						/* 104-126: reserved */
-	ide->drive[drive].features[104*2+1] = 0x00;
-	ide->drive[drive].features[127*2+0] = 0x00;						/* 127: removable media status notification */
-	ide->drive[drive].features[127*2+1] = 0x00;
-	ide->drive[drive].features[128*2+0] = 0x00;						/* 128: security status */
-	ide->drive[drive].features[128*2+1] = 0x00;
-	ide->drive[drive].features[129*2+0] = 0x00;						/* 129-159: vendor specific */
-	ide->drive[drive].features[129*2+1] = 0x00;
-	ide->drive[drive].features[160*2+0] = 0x00;						/* 160: CFA power mode 1 */
-	ide->drive[drive].features[160*2+1] = 0x00;
-	ide->drive[drive].features[161*2+0] = 0x00;						/* 161-175: reserved for CompactFlash */
-	ide->drive[drive].features[161*2+1] = 0x00;
-	ide->drive[drive].features[176*2+0] = 0x00;						/* 176-205: current media serial number */
-	ide->drive[drive].features[176*2+1] = 0x00;
-	ide->drive[drive].features[206*2+0] = 0x00;						/* 206-254: reserved */
-	ide->drive[drive].features[206*2+1] = 0x00;
-	ide->drive[drive].features[255*2+0] = 0x00;						/* 255: integrity word */
-	ide->drive[drive].features[255*2+1] = 0x00;
-}
-
-
-static void ide_build_features(ide_state *ide, int drive)
-{
-	memset(ide->drive[drive].features, 0, IDE_DISK_SECTOR_SIZE);
-	if (chd_get_metadata (ide->drive[drive].handle, HARD_DISK_IDENT_METADATA_TAG, 0, ide->drive[drive].features, IDE_DISK_SECTOR_SIZE, 0, 0, 0) != CHDERR_NONE)
-		ide_generate_features (ide,drive);
+	m_features[47*2+0] = 0x01;						/* 47: read/write multiple support */
+	m_features[47*2+1] = 0x80;
+	m_features[48*2+0] = 0;							/* 48: reserved */
+	m_features[48*2+1] = 0;
+	m_features[49*2+0] = 0x03;						/* 49: capabilities */
+	m_features[49*2+1] = 0x0f;
+	m_features[50*2+0] = 0;							/* 50: reserved */
+	m_features[50*2+1] = 0;
+	m_features[51*2+0] = 2;							/* 51: PIO data transfer cycle timing mode */
+	m_features[51*2+1] = 0;
+	m_features[52*2+0] = 2;							/* 52: single word DMA transfer cycle timing mode */
+	m_features[52*2+1] = 0;
+	m_features[53*2+0] = 3;							/* 53: field validity */
+	m_features[53*2+1] = 0;
+	m_features[54*2+0] = m_num_cylinders & 0xff;	/* 54: number of current logical cylinders */
+	m_features[54*2+1] = m_num_cylinders >> 8;
+	m_features[55*2+0] = m_num_heads & 0xff;		/* 55: number of current logical heads */
+	m_features[55*2+1] = 0;/*ide->num_heads >> 8;*/
+	m_features[56*2+0] = m_num_sectors & 0xff;	/* 56: number of current logical sectors per track */
+	m_features[56*2+1] = 0;/*ide->num_sectors >> 8;*/
+	m_features[57*2+0] = sectors_per_track & 0xff;	/* 57-58: number of current logical sectors per track */
+	m_features[57*2+1] = sectors_per_track >> 8;
+	m_features[58*2+0] = sectors_per_track >> 16;
+	m_features[58*2+1] = sectors_per_track >> 24;
+	m_features[59*2+0] = 0;							/* 59: multiple sector timing */
+	m_features[59*2+1] = 0;
+	m_features[60*2+0] = total_sectors & 0xff;		/* 60-61: total user addressable sectors */
+	m_features[60*2+1] = total_sectors >> 8;
+	m_features[61*2+0] = total_sectors >> 16;
+	m_features[61*2+1] = total_sectors >> 24;
+	m_features[62*2+0] = 0x07;						/* 62: single word dma transfer */
+	m_features[62*2+1] = 0x00;
+	m_features[63*2+0] = 0x07;						/* 63: multiword DMA transfer */
+	m_features[63*2+1] = 0x04;
+	m_features[64*2+0] = 0x03;						/* 64: flow control PIO transfer modes supported */
+	m_features[64*2+1] = 0x00;
+	m_features[65*2+0] = 0x78;						/* 65: minimum multiword DMA transfer cycle time per word */
+	m_features[65*2+1] = 0x00;
+	m_features[66*2+0] = 0x78;						/* 66: mfr's recommended multiword DMA transfer cycle time */
+	m_features[66*2+1] = 0x00;
+	m_features[67*2+0] = 0x4d;						/* 67: minimum PIO transfer cycle time without flow control */
+	m_features[67*2+1] = 0x01;
+	m_features[68*2+0] = 0x78;						/* 68: minimum PIO transfer cycle time with IORDY */
+	m_features[68*2+1] = 0x00;
+	m_features[69*2+0] = 0x00;						/* 69-70: reserved */
+	m_features[69*2+1] = 0x00;
+	m_features[71*2+0] = 0x00;						/* 71: reserved for IDENTIFY PACKET command */
+	m_features[71*2+1] = 0x00;
+	m_features[72*2+0] = 0x00;						/* 72: reserved for IDENTIFY PACKET command */
+	m_features[72*2+1] = 0x00;
+	m_features[73*2+0] = 0x00;						/* 73: reserved for IDENTIFY PACKET command */
+	m_features[73*2+1] = 0x00;
+	m_features[74*2+0] = 0x00;						/* 74: reserved for IDENTIFY PACKET command */
+	m_features[74*2+1] = 0x00;
+	m_features[75*2+0] = 0x00;						/* 75: queue depth */
+	m_features[75*2+1] = 0x00;
+	m_features[76*2+0] = 0x00;						/* 76-79: reserved */
+	m_features[76*2+1] = 0x00;
+	m_features[80*2+0] = 0x00;						/* 80: major version number */
+	m_features[80*2+1] = 0x00;
+	m_features[81*2+0] = 0x00;						/* 81: minor version number */
+	m_features[81*2+1] = 0x00;
+	m_features[82*2+0] = 0x00;						/* 82: command set supported */
+	m_features[82*2+1] = 0x00;
+	m_features[83*2+0] = 0x00;						/* 83: command sets supported */
+	m_features[83*2+1] = 0x00;
+	m_features[84*2+0] = 0x00;						/* 84: command set/feature supported extension */
+	m_features[84*2+1] = 0x00;
+	m_features[85*2+0] = 0x00;						/* 85: command set/feature enabled */
+	m_features[85*2+1] = 0x00;
+	m_features[86*2+0] = 0x00;						/* 86: command set/feature enabled */
+	m_features[86*2+1] = 0x00;
+	m_features[87*2+0] = 0x00;						/* 87: command set/feature default */
+	m_features[87*2+1] = 0x00;
+	m_features[88*2+0] = 0x00;						/* 88: additional DMA modes */
+	m_features[88*2+1] = 0x00;
+	m_features[89*2+0] = 0x00;						/* 89: time required for security erase unit completion */
+	m_features[89*2+1] = 0x00;
+	m_features[90*2+0] = 0x00;						/* 90: time required for enhanced security erase unit completion */
+	m_features[90*2+1] = 0x00;
+	m_features[91*2+0] = 0x00;						/* 91: current advanced power management value */
+	m_features[91*2+1] = 0x00;
+	m_features[92*2+0] = 0x00;						/* 92: master password revision code */
+	m_features[92*2+1] = 0x00;
+	m_features[93*2+0] = 0x00;						/* 93: hardware reset result */
+	m_features[93*2+1] = 0x00;
+	m_features[94*2+0] = 0x00;						/* 94: acoustic management values */
+	m_features[94*2+1] = 0x00;
+	m_features[95*2+0] = 0x00;						/* 95-99: reserved */
+	m_features[95*2+1] = 0x00;
+	m_features[100*2+0] = total_sectors & 0xff;		/* 100-103: maximum 48-bit LBA */
+	m_features[100*2+1] = total_sectors >> 8;
+	m_features[101*2+0] = total_sectors >> 16;
+	m_features[101*2+1] = total_sectors >> 24;
+	m_features[102*2+0] = 0x00;
+	m_features[102*2+1] = 0x00;
+	m_features[103*2+0] = 0x00;
+	m_features[103*2+1] = 0x00;
+	m_features[104*2+0] = 0x00;						/* 104-126: reserved */
+	m_features[104*2+1] = 0x00;
+	m_features[127*2+0] = 0x00;						/* 127: removable media status notification */
+	m_features[127*2+1] = 0x00;
+	m_features[128*2+0] = 0x00;						/* 128: security status */
+	m_features[128*2+1] = 0x00;
+	m_features[129*2+0] = 0x00;						/* 129-159: vendor specific */
+	m_features[129*2+1] = 0x00;
+	m_features[160*2+0] = 0x00;						/* 160: CFA power mode 1 */
+	m_features[160*2+1] = 0x00;
+	m_features[161*2+0] = 0x00;						/* 161-175: reserved for CompactFlash */
+	m_features[161*2+1] = 0x00;
+	m_features[176*2+0] = 0x00;						/* 176-205: current media serial number */
+	m_features[176*2+1] = 0x00;
+	m_features[206*2+0] = 0x00;						/* 206-254: reserved */
+	m_features[206*2+1] = 0x00;
+	m_features[255*2+0] = 0x00;						/* 255: integrity word */
+	m_features[255*2+1] = 0x00;
 }
 
 /*************************************
@@ -743,10 +720,8 @@
 		return;
 	}
 	/* now do the read */
-	if (ide->drive[ide->cur_drive].disk)
-		count = hard_disk_read(ide->drive[ide->cur_drive].disk, lba, ide->buffer);
-	else if (ide->hardware != NULL) {
-		count = ide->hardware->read_sector(ide->device, lba, ide->buffer);
+	if (ide->drive[ide->cur_drive].slot) {
+		count = ide->drive[ide->cur_drive].slot->read_sector(lba, ide->buffer);
 	}
 
 	/* by default, mark the buffer ready and the seek complete */
@@ -944,10 +919,8 @@
 	int lba = lba_address(ide), count = 0;
 
 	/* now do the write */
-	if (ide->drive[ide->cur_drive].disk)
-		count = hard_disk_write(ide->drive[ide->cur_drive].disk, lba, ide->buffer);
-	else if (ide->hardware != NULL) {
-		count = ide->hardware->write_sector(ide->device, lba, ide->buffer);
+	if (ide->drive[ide->cur_drive].slot) {
+		count = ide->drive[ide->cur_drive].slot->write_sector(lba, ide->buffer);
 	}
 
 	/* by default, mark the buffer ready and the seek complete */
@@ -1152,7 +1125,9 @@
 			ide->sector_count = 1;
 
 			/* build the features page */
-			memcpy(ide->buffer, ide->drive[ide->cur_drive].features, sizeof(ide->buffer));
+			if (ide->drive[ide->cur_drive].slot->get_features()) {
+				memcpy(ide->buffer, ide->drive[ide->cur_drive].slot->get_features(), sizeof(ide->buffer));
+			}
 
 			/* indicate everything is ready */
 			ide->status |= IDE_STATUS_BUFFER_READY;
@@ -1198,9 +1173,7 @@
 			LOGPRINT(("IDE Set configuration (%d heads, %d sectors)\n", ide->drive[ide->cur_drive].cur_head + 1, ide->sector_count));
 			ide->status &= ~IDE_STATUS_ERROR;
 			ide->error = IDE_ERROR_NONE;
-
-			ide->drive[ide->cur_drive].num_sectors = ide->sector_count;
-			ide->drive[ide->cur_drive].num_heads = ide->drive[ide->cur_drive].cur_head + 1;
+			ide->drive[ide->cur_drive].slot->set_geometry(ide->sector_count,ide->drive[ide->cur_drive].cur_head + 1);
 
 			/* signal an interrupt */
 			signal_delayed_interrupt(ide, MINIMUM_COMMAND_TIME, 0);
@@ -1258,7 +1231,7 @@
 			LOGPRINT(("IDE GNET Unlock 3\n"));
 
 			/* key check */
-			chd_get_metadata (ide->drive[ide->cur_drive].handle, HARD_DISK_KEY_METADATA_TAG, 0, key, 5, 0, 0, 0);
+			ide->drive[ide->cur_drive].slot->read_key(key);
 			if ((ide->precomp_offset == key[0]) && (ide->sector_count == key[1]) && (ide->drive[ide->cur_drive].cur_sector == key[2]) && (ide->drive[ide->cur_drive].cur_cylinder == (((UINT16)key[4]<<8)|key[3])))
 			{
 				ide->gnetreadlock= 0;
@@ -1313,7 +1286,7 @@
 //  if (BANK(bank, offset) != IDE_BANK0_DATA && BANK(bank, offset) != IDE_BANK0_STATUS_COMMAND && BANK(bank, offset) != IDE_BANK1_STATUS_CONTROL)
 		LOG(("%s:IDE read at %d:%X, size=%d\n", device->machine().describe_context(), bank, offset, size));
 
-	if (ide->drive[ide->cur_drive].disk) {
+	if (ide->drive[ide->cur_drive].slot->is_ready()) {
 		ide->status |= IDE_STATUS_DRIVE_READY;
 	} else {
 		ide->status &= ~IDE_STATUS_DRIVE_READY;
@@ -1503,9 +1476,9 @@
 					}
 					else if (ide->command == IDE_COMMAND_TAITO_GNET_UNLOCK_2)
 					{
-						UINT8 key[5] = { 0, 0, 0, 0, 0 };
+						UINT8 key[5] = { 0 };
 						int i, bad = 0;
-						chd_get_metadata (ide->drive[ide->cur_drive].handle, HARD_DISK_KEY_METADATA_TAG, 0, key, 5, 0, 0, 0);
+						ide->drive[ide->cur_drive].slot->read_key(key);
 
 						for (i=0; !bad && i<512; i++)
 							bad = ((i < 2 || i >= 7) && ide->buffer[i]) || ((i >= 2 && i < 7) && ide->buffer[i] != key[i-2]);
@@ -1859,7 +1832,6 @@
 static DEVICE_START( ide_controller )
 {
 	ide_state *ide = get_safe_token(device);
-	const hard_disk_info *hdinfo;
 	const ide_config *config;
 
 	/* validate some basic stuff */
@@ -1873,17 +1845,8 @@
 	/* set MAME harddisk handle */
 	config = (const ide_config *)downcast<const legacy_device_base *>(device)->inline_config();
 
-	ide->drive[0].handle = get_disk_handle(device->machine(), (config->master != NULL) ? config->master : device->tag());
-	ide->drive[0].disk = hard_disk_open(ide->drive[0].handle);
-	ide->drive[0].is_image_device = false;
-
-	if (config->slave) {
-		ide->drive[1].handle = get_disk_handle(device->machine(), config->slave);
-		ide->drive[1].disk = hard_disk_open(ide->drive[1].handle);
-		ide->drive[1].is_image_device = false;
-	}
-
-	//assert_always(config->slave == NULL, "IDE controller does not yet support slave drives\n");
+	ide->drive[0].slot = device->owner()->subdevice<ide_slot_device>("drive_0");
+	ide->drive[1].slot = device->owner()->subdevice<ide_slot_device>("drive_1");
 
 	/* find the bus master space */
 	if (config->bmcpu != NULL)
@@ -1900,41 +1863,6 @@
 		ide->dma_address_xor = (ide->dma_space->endianness() == ENDIANNESS_LITTLE) ? 0 : 3;
 	}
 
-	/* get and copy the geometry */
-	if (ide->drive[0].disk != NULL)
-	{
-		hdinfo = hard_disk_get_info(ide->drive[0].disk);
-		if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
-		{
-			ide->drive[0].num_cylinders = hdinfo->cylinders;
-			ide->drive[0].num_sectors = hdinfo->sectors;
-			ide->drive[0].num_heads = hdinfo->heads;
-			if (PRINTF_IDE_COMMANDS) mame_printf_debug("CHS: %d %d %d\n", ide->drive[0].num_cylinders, ide->drive[0].num_heads, ide->drive[0].num_sectors);
-		}
-
-		/* build the features page */
-		ide_build_features(ide,0);
-	}
-	if (ide->drive[1].disk != NULL)
-	{
-		hdinfo = hard_disk_get_info(ide->drive[1].disk);
-		if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
-		{
-			ide->drive[1].num_cylinders = hdinfo->cylinders;
-			ide->drive[1].num_sectors = hdinfo->sectors;
-			ide->drive[1].num_heads = hdinfo->heads;
-			if (PRINTF_IDE_COMMANDS) mame_printf_debug("CHS: %d %d %d\n", ide->drive[1].num_cylinders, ide->drive[1].num_heads, ide->drive[1].num_sectors);
-		}
-
-		/* build the features page */
-		ide_build_features(ide,1);
-	}
-	if (config->hardware != NULL) {
-		ide->hardware = (ide_hardware *)config->hardware;
-		ide->hardware->get_info(ide->device, ide->drive[0].features, ide->drive[0].num_cylinders, ide->drive[0].num_sectors, ide->drive[0].num_heads);
-		ide_generate_features (ide,0);
-	}
-
 	/* create a timer for timing status */
 	ide->last_status_timer = device->machine().scheduler().timer_alloc(FUNC_NULL);
 	ide->reset_timer = device->machine().scheduler().timer_alloc(FUNC(reset_callback), (void *)device);
@@ -1986,27 +1914,6 @@
 	device->save_item(NAME(ide->gnetreadlock));
 }
 
-
-/*-------------------------------------------------
-    device exit callback
--------------------------------------------------*/
-
-static DEVICE_STOP( ide_controller )
-{
-	ide_state *ide = get_safe_token(device);
-	if (!ide->drive[0].is_image_device) {
-		/* close the hard disk */
-		if (ide->drive[0].disk != NULL)
-			hard_disk_close(ide->drive[0].disk);
-	}
-	if (!ide->drive[1].is_image_device) {
-		/* close the hard disk */
-		if (ide->drive[1].disk != NULL)
-			hard_disk_close(ide->drive[1].disk);
-	}
-}
-
-
 /*-------------------------------------------------
     device reset callback
 -------------------------------------------------*/
@@ -2014,78 +1921,9 @@
 static DEVICE_RESET( ide_controller )
 {
 	ide_state *ide = get_safe_token(device);
-	const ide_config *config = (const ide_config *)downcast<const legacy_device_base *>(device)->inline_config();
-
-	ide->cur_drive = 0;
 	LOG(("IDE controller reset performed\n"));
-	if (config->master) {
-		astring hardtag_master;
-		device->siblingtag(hardtag_master, config->master);
-		if (!ide->drive[0].disk)
-		{
-			ide->drive[0].handle = device->machine().device<harddisk_image_device>(hardtag_master.cstr())->get_chd_file();	// should be config->master
-
-			if (ide->drive[0].handle)
-			{
-				ide->drive[0].disk = device->machine().device<harddisk_image_device>(hardtag_master.cstr())->get_hard_disk_file();	// should be config->master
-				ide->drive[0].is_image_device = true;
-
-				if (ide->drive[0].disk != NULL)
-				{
-					const hard_disk_info *hdinfo;
-
-					hdinfo = hard_disk_get_info(ide->drive[0].disk);
-					if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
-					{
-						ide->drive[0].num_cylinders = hdinfo->cylinders;
-						ide->drive[0].num_sectors = hdinfo->sectors;
-						ide->drive[0].num_heads = hdinfo->heads;
-						if (PRINTF_IDE_COMMANDS) printf("CHS: %d %d %d\n", ide->drive[0].num_cylinders, ide->drive[0].num_heads, ide->drive[0].num_sectors);
-					}
-
-					/* build the features page */
-					ide_build_features(ide,0);
-				}
-			}
-		}
-	}
-	if (config->slave) {
-		astring hardtag_slave;
-		device->siblingtag(hardtag_slave, config->slave);
-		if (!ide->drive[1].disk)
-		{
-			ide->drive[1].handle = device->machine().device<harddisk_image_device>(hardtag_slave.cstr())->get_chd_file();	// should be config->master
-
-			if (ide->drive[1].handle)
-			{
-				ide->drive[1].disk = device->machine().device<harddisk_image_device>(hardtag_slave.cstr())->get_hard_disk_file();	// should be config->master
-				ide->drive[1].is_image_device = true;
-
-				if (ide->drive[1].disk != NULL)
-				{
-					const hard_disk_info *hdinfo;
-
-					hdinfo = hard_disk_get_info(ide->drive[1].disk);
-					if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
-					{
-						ide->drive[1].num_cylinders = hdinfo->cylinders;
-						ide->drive[1].num_sectors = hdinfo->sectors;
-						ide->drive[1].num_heads = hdinfo->heads;
-						if (PRINTF_IDE_COMMANDS) printf("CHS: %d %d %d\n", ide->drive[1].num_cylinders, ide->drive[1].num_heads, ide->drive[1].num_sectors);
-					}
-
-					/* build the features page */
-					ide_build_features(ide,1);
-				}
-			}
-		}
-	}
-	if (ide->hardware != NULL) {
-		ide->hardware->get_info(ide->device, ide->drive[0].features, ide->drive[0].num_cylinders, ide->drive[0].num_sectors, ide->drive[0].num_heads);
-		ide_generate_features (ide,0);
-	}
-
 	/* reset the drive state */
+	ide->cur_drive = 0;
 	ide->status = IDE_STATUS_DRIVE_READY | IDE_STATUS_SEEK_COMPLETE;
 	ide->error = IDE_ERROR_DEFAULT;
 	ide->buffer_offset = 0;
@@ -2095,6 +1933,13 @@
 	clear_interrupt(ide);
 }
 
+SLOT_INTERFACE_START(ide_image_devices)
+	SLOT_INTERFACE("hdd", IDE_HARDDISK_IMAGE)
+SLOT_INTERFACE_END
+
+SLOT_INTERFACE_START(ide_devices)
+	SLOT_INTERFACE("hdd", IDE_HARDDISK)
+SLOT_INTERFACE_END
 
 /*-------------------------------------------------
     device get info callback
@@ -2110,7 +1955,6 @@
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case DEVINFO_FCT_START:					info->start = DEVICE_START_NAME(ide_controller); break;
-		case DEVINFO_FCT_STOP:					info->stop = DEVICE_STOP_NAME(ide_controller); break;
 		case DEVINFO_FCT_RESET:					info->reset = DEVICE_RESET_NAME(ide_controller);break;
 
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
@@ -2124,3 +1968,194 @@
 
 
 DEFINE_LEGACY_DEVICE(IDE_CONTROLLER, ide_controller);
+
+//**************************************************************************
+//  IDE SLOT DEVICE
+//**************************************************************************
+
+// device type definition
+const device_type IDE_SLOT = &device_creator<ide_slot_device>;
+
+//-------------------------------------------------
+//  ide_slot_device - constructor
+//-------------------------------------------------
+
+ide_slot_device::ide_slot_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+    : device_t(mconfig, IDE_SLOT, "IDE Connector", tag, owner, clock),
+	  device_slot_interface(mconfig, *this),
+	  m_dev(NULL)
+{
+
+}
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void ide_slot_device::device_config_complete()
+{
+	m_dev = dynamic_cast<ide_device_interface *>(get_card_device());
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ide_slot_device::device_start()
+{
+}
+
+//**************************************************************************
+//  IDE DEVICE INTERFACE
+//**************************************************************************
+
+//-------------------------------------------------
+//  ide_device_interface - constructor
+//-------------------------------------------------
+
+ide_device_interface::ide_device_interface(const machine_config &mconfig, device_t &device)
+	: device_slot_card_interface(mconfig, device)
+{
+}
+
+
+//**************************************************************************
+//  IDE HARD DISK DEVICE
+//**************************************************************************
+
+// device type definition
+const device_type IDE_HARDDISK = &device_creator<ide_hdd_device>;
+
+//-------------------------------------------------
+//  ide_hdd_device - constructor
+//-------------------------------------------------
+
+ide_hdd_device::ide_hdd_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+    : device_t(mconfig, IDE_HARDDISK, "IDE Hard Disk", tag, owner, clock),
+	  ide_device_interface( mconfig, *this )
+{
+}
+
+ide_hdd_device::ide_hdd_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock) :
+        device_t(mconfig, type, name, tag, owner, clock),
+		ide_device_interface(mconfig, *this)
+{
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ide_hdd_device::device_start()
+{
+}
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ide_hdd_device::device_reset()
+{
+	m_handle = get_disk_handle(machine(), owner()->tag());
+	m_disk = hard_disk_open(m_handle);
+
+	if (m_disk != NULL)
+	{
+		const hard_disk_info *hdinfo = hard_disk_get_info(m_disk);
+		if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
+		{
+			m_num_cylinders = hdinfo->cylinders;
+			m_num_sectors = hdinfo->sectors;
+			m_num_heads = hdinfo->heads;
+			if (PRINTF_IDE_COMMANDS) mame_printf_debug("CHS: %d %d %d\n", m_num_cylinders, m_num_heads, m_num_sectors);
+			mame_printf_debug("CHS: %d %d %d\n", m_num_cylinders, m_num_heads, m_num_sectors);
+		}
+		// build the features page
+		UINT32 metalength;
+		if (m_handle->read_metadata (HARD_DISK_IDENT_METADATA_TAG, 0, m_features, IDE_DISK_SECTOR_SIZE, metalength) != CHDERR_NONE)
+			ide_build_features();
+	}
+}
+
+//-------------------------------------------------
+//  read device key
+//-------------------------------------------------
+
+void ide_hdd_device::read_key(UINT8 key[])
+{
+	UINT32 metalength;
+	m_handle->read_metadata(HARD_DISK_KEY_METADATA_TAG, 0, key, 5, metalength);
+}
+
+//**************************************************************************
+//  IDE HARD DISK IMAGE DEVICE
+//**************************************************************************
+
+// device type definition
+const device_type IDE_HARDDISK_IMAGE = &device_creator<ide_hdd_image_device>;
+
+//-------------------------------------------------
+//  ide_hdd_image_device - constructor
+//-------------------------------------------------
+
+ide_hdd_image_device::ide_hdd_image_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+    : ide_hdd_device(mconfig, IDE_HARDDISK_IMAGE, "IDE Hard Disk Image", tag, owner, clock)
+{
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ide_hdd_image_device::device_start()
+{
+}
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ide_hdd_image_device::device_reset()
+{
+	m_handle = subdevice<harddisk_image_device>("harddisk")->get_chd_file();
+
+	if (m_handle)
+	{
+		m_disk = subdevice<harddisk_image_device>("harddisk")->get_hard_disk_file();
+
+		if (m_disk != NULL)
+		{
+			const hard_disk_info *hdinfo;
+
+			hdinfo = hard_disk_get_info(m_disk);
+			if (hdinfo->sectorbytes == IDE_DISK_SECTOR_SIZE)
+			{
+				m_num_cylinders = hdinfo->cylinders;
+				m_num_sectors = hdinfo->sectors;
+				m_num_heads = hdinfo->heads;
+				if (PRINTF_IDE_COMMANDS) printf("CHS: %d %d %d\n", m_num_cylinders, m_num_heads, m_num_sectors);
+			}
+			// build the features page
+			UINT32 metalength;
+			if (m_handle->read_metadata (HARD_DISK_IDENT_METADATA_TAG, 0, m_features, IDE_DISK_SECTOR_SIZE, metalength) != CHDERR_NONE)
+				ide_build_features();
+		}
+	}
+
+}
+
+//-------------------------------------------------
+//  machine_config_additions - device-specific
+//  machine configurations
+//-------------------------------------------------
+static MACHINE_CONFIG_FRAGMENT( hdd_image )
+	MCFG_HARDDISK_ADD( "harddisk" )
+MACHINE_CONFIG_END
+
+machine_config_constructor ide_hdd_image_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME( hdd_image );
+}
+
diff -Nru src-old/emu/machine/idectrl.h src/emu/machine/idectrl.h
--- src-old/emu/machine/idectrl.h	2012-01-12 16:49:24.000000000 +0100
+++ src/emu/machine/idectrl.h	2012-02-19 16:23:23.000000000 +0100
@@ -17,51 +17,146 @@
 #include "devlegcy.h"
 
 #include "harddisk.h"
+#include "imagedev/harddriv.h"
 
+#define IDE_DISK_SECTOR_SIZE			512
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
-typedef struct _ide_hardware ide_hardware;
-struct _ide_hardware
+// ======================> ide_device_interface
+
+class ide_device_interface : public device_slot_card_interface
+{
+public:
+	ide_device_interface(const machine_config &mconfig, device_t &device);
+public:
+	virtual int	 read_sector(UINT32 lba, void *buffer) = 0;
+	virtual int	 write_sector(UINT32 lba, const void *buffer) = 0;
+
+	UINT8 *get_features() { return m_features;}
+
+	UINT16 get_cylinders() { return m_num_cylinders; }
+	UINT16 get_sectors() { return m_num_sectors; }
+	UINT16 get_heads() { return m_num_heads; }
+	void set_geometry(UINT8 sectors, UINT8 heads) { m_num_sectors= sectors; m_num_heads=heads; }
+	virtual bool is_ready() { return true; }
+	virtual void read_key(UINT8 key[]) { }
+protected:
+	UINT8			m_features[IDE_DISK_SECTOR_SIZE];
+	UINT16			m_num_cylinders;
+	UINT8			m_num_sectors;
+	UINT8			m_num_heads;
+};
+
+// ======================> ide_slot_device
+
+class ide_slot_device :	public device_t,
+						public device_slot_interface
+{
+public:
+	// construction/destruction
+	ide_slot_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	int	 read_sector(UINT32 lba, void *buffer) { return (m_dev) ? m_dev->read_sector(lba,buffer) : 0; }
+	int	 write_sector(UINT32 lba, const void *buffer) { return (m_dev) ? m_dev->write_sector(lba,buffer) : 0; }
+	UINT8 *get_features() { return (m_dev) ? m_dev->get_features() : NULL;}
+
+	UINT16 get_cylinders() { return (m_dev) ? m_dev->get_cylinders() : 0; }
+	UINT16 get_sectors() { return (m_dev) ? m_dev->get_sectors() : 0; }
+	UINT16 get_heads() { return (m_dev) ? m_dev->get_heads() : 0; }
+	void set_geometry(UINT8 sectors, UINT8 heads) { if (m_dev) m_dev->set_geometry(sectors,heads); }
+	bool is_ready() { return (m_dev) ? m_dev->is_ready() : false; }
+	void read_key(UINT8 key[]) { if (m_dev) m_dev->read_key(key); }
+protected:
+	// device-level overrides
+	virtual void device_start();
+	virtual void device_config_complete();
+private:
+	ide_device_interface *m_dev;
+};
+
+// device type definition
+extern const device_type IDE_SLOT;
+
+// ======================> ide_hdd_device
+
+class ide_hdd_device : public device_t,
+					   public ide_device_interface
 {
-	void	(*get_info)(device_t *device, UINT8 *buffer, UINT16 &cylinders, UINT8 &sectors, UINT8 &heads);
-	int		(*read_sector)(device_t *device, UINT32 lba, void *buffer);
-	int		(*write_sector)(device_t *device, UINT32 lba, const void *buffer);
+public:
+    // construction/destruction
+    ide_hdd_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	ide_hdd_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
+
+	virtual int	 read_sector(UINT32 lba, void *buffer) { return hard_disk_read(m_disk, lba, buffer); }
+	virtual int	 write_sector(UINT32 lba, const void *buffer) { return hard_disk_write(m_disk, lba, buffer); }
+	virtual void read_key(UINT8 key[]);
+protected:
+    // device-level overrides
+    virtual void device_start();
+	virtual void device_reset();
+
+	void ide_build_features();
+	virtual bool is_ready() { return (m_disk != NULL); }
+protected:
+	chd_file       *m_handle;
+	hard_disk_file *m_disk;
 };
+// device type definition
+extern const device_type IDE_HARDDISK;
+
+// ======================> ide_hdd_image_device
+
+class ide_hdd_image_device : public ide_hdd_device
+{
+public:
+    // construction/destruction
+    ide_hdd_image_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+protected:
+    // device-level overrides
+    virtual void device_start();
+	virtual void device_reset();
+	// optional information overrides
+	virtual machine_config_constructor device_mconfig_additions() const;
+};
+// device type definition
+extern const device_type IDE_HARDDISK_IMAGE;
+
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
 
 typedef struct _ide_config ide_config;
 struct _ide_config
 {
 	void	(*interrupt)(device_t *device, int state);
-	const char *master;		/* name of master region (defaults to device tag) */
-	const char *slave;		/* name of slave region (defaults to NULL) */
 	const char *bmcpu;		/* name of bus master CPU */
 	UINT32 bmspace;			/* address space of bus master transfer */
-	const ide_hardware *hardware;	/* connected to hardware that is not an hard disk */
 };
 
 
+SLOT_INTERFACE_EXTERN(ide_devices);
+SLOT_INTERFACE_EXTERN(ide_image_devices);
 
 /***************************************************************************
     DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-#define MCFG_IDE_CONTROLLER_ADD(_tag, _callback) \
+#define MCFG_IDE_CONTROLLER_ADD(_tag, _callback, _slotintf, _master, _slave) \
 	MCFG_DEVICE_ADD(_tag, IDE_CONTROLLER, 0) \
-	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, interrupt, _callback)
+	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, interrupt, _callback) \
+	MCFG_IDE_SLOT_ADD("drive_0", _slotintf, _master, NULL) \
+	MCFG_IDE_SLOT_ADD("drive_1", _slotintf, _slave, NULL) \
 
-#define MCFG_IDE_CONTROLLER_REGIONS(_master, _slave) \
-	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, master, _master) \
-	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, slave,  _slave)
-
-#define MCFG_IDE_BUS_MASTER_SPACE(_cpu, _space) \
+#define MCFG_IDE_BUS_MASTER_SPACE(_tag, _cpu, _space) \
+	MCFG_DEVICE_MODIFY(_tag) \
 	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, bmcpu, _cpu) \
 	MCFG_DEVICE_CONFIG_DATA32(ide_config, bmspace, AS_##_space)
 
-#define MCFG_IDE_CONNECTED_TO(_hardware) \
-	MCFG_DEVICE_CONFIG_DATAPTR(ide_config, hardware, _hardware) \
-
+#define MCFG_IDE_SLOT_ADD(_tag, _slot_intf, _def_slot, _def_inp) \
+	MCFG_DEVICE_ADD(_tag, IDE_SLOT, 0) \
+	MCFG_DEVICE_SLOT_INTERFACE(_slot_intf, _def_slot, _def_inp) \
 
 /***************************************************************************
     FUNCTION PROTOTYPES
diff -Nru src-old/emu/machine/intelfsh.c src/emu/machine/intelfsh.c
--- src-old/emu/machine/intelfsh.c	2011-10-10 21:37:17.000000000 +0200
+++ src/emu/machine/intelfsh.c	2012-02-16 15:02:34.000000000 +0100
@@ -47,6 +47,7 @@
 // device type definition
 const device_type INTEL_28F016S5 = &device_creator<intel_28f016s5_device>;
 const device_type SHARP_LH28F016S = &device_creator<sharp_lh28f016s_device>;
+const device_type AMD_29F040 = &device_creator<amd_29f040_device>;
 const device_type AMD_29F080 = &device_creator<amd_29f080_device>;
 const device_type FUJITSU_29F016A = &device_creator<fujitsu_29f016a_device>;
 const device_type FUJITSU_29DL16X = &device_creator<fujitsu_29dl16x_device>;
@@ -68,6 +69,10 @@
 	AM_RANGE(0x00000, 0x01ffff) AM_RAM
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( memory_map8_4Mb, AS_PROGRAM, 8 )
+	AM_RANGE(0x00000, 0x07ffff) AM_RAM
+ADDRESS_MAP_END
+
 static ADDRESS_MAP_START( memory_map8_8Mb, AS_PROGRAM, 8 )
 	AM_RANGE(0x00000, 0x0fffff) AM_RAM
 ADDRESS_MAP_END
@@ -128,6 +133,13 @@
 		m_device_id = 0xaa;
 		map = ADDRESS_MAP_NAME( memory_map8_16Mb );
 		break;
+	case FLASH_AMD_29F040:
+		m_bits = 8;
+		m_size = 0x80000;
+		m_maker_id = 0x01;
+		m_device_id = 0xa4;
+		map = ADDRESS_MAP_NAME( memory_map8_4Mb );
+		break;
 	case FLASH_AMD_29F080:
 		m_bits = 8;
 		m_size = 0x100000;
@@ -230,6 +242,9 @@
 sharp_lh28f016s_device::sharp_lh28f016s_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
 	: intelfsh8_device(mconfig, SHARP_LH28F016S, "Sharp LH28F016S Flash", tag, owner, clock, FLASH_SHARP_LH28F016S) { }
 
+amd_29f040_device::amd_29f040_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: intelfsh8_device(mconfig, AMD_29F040, "AMD 29F040 Flash", tag, owner, clock, FLASH_AMD_29F040) { }
+
 amd_29f080_device::amd_29f080_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
 	: intelfsh8_device(mconfig, AMD_29F080, "AMD 29F080 Flash", tag, owner, clock, FLASH_AMD_29F080) { }
 
diff -Nru src-old/emu/machine/intelfsh.h src/emu/machine/intelfsh.h
--- src-old/emu/machine/intelfsh.h	2011-10-10 21:37:17.000000000 +0200
+++ src/emu/machine/intelfsh.h	2012-02-16 15:02:34.000000000 +0100
@@ -16,6 +16,9 @@
 #define MCFG_SHARP_LH28F016S_ADD(_tag) \
 	MCFG_DEVICE_ADD(_tag, SHARP_LH28F016S, 0)
 
+#define MCFG_AMD_29F040_ADD(_tag) \
+	MCFG_DEVICE_ADD(_tag, AMD_29F040, 0)
+
 #define MCFG_AMD_29F080_ADD(_tag) \
 	MCFG_DEVICE_ADD(_tag, AMD_29F080, 0)
 
@@ -71,6 +74,7 @@
 		FLASH_INTEL_28F016S5 = 0x0800,
 		FLASH_FUJITSU_29F016A,
 		FLASH_FUJITSU_29DL16X,
+		FLASH_AMD_29F040,
 		FLASH_AMD_29F080,
 		FLASH_SHARP_LH28F016S,
 		FLASH_INTEL_E28F008SA,
@@ -182,6 +186,12 @@
 	fujitsu_29dl16x_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
 };
 
+class amd_29f040_device : public intelfsh8_device
+{
+public:
+	amd_29f040_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+};
+
 class amd_29f080_device : public intelfsh8_device
 {
 public:
@@ -249,6 +259,7 @@
 // device type definition
 extern const device_type INTEL_28F016S5;
 extern const device_type SHARP_LH28F016S;
+extern const device_type AMD_29F040;
 extern const device_type AMD_29F080;
 extern const device_type FUJITSU_29F016A;
 extern const device_type FUJITSU_29DL16X;
diff -Nru src-old/emu/machine/laserdsc.c src/emu/machine/laserdsc.c
--- src-old/emu/machine/laserdsc.c	2012-01-15 22:40:54.000000000 +0100
+++ src/emu/machine/laserdsc.c	2012-02-16 10:47:18.000000000 +0100
@@ -39,10 +39,11 @@
 
 #include "emu.h"
 #include "laserdsc.h"
-#include "avcomp.h"
+#include "avhuff.h"
 #include "vbiparse.h"
 #include "config.h"
 #include "render.h"
+#include "chd.h"
 
 
 
@@ -93,13 +94,13 @@
 	  m_overheight(0),
 	  m_overclip(0, -1, 0, -1),
 	  m_disc(NULL),
-	  m_vbidata(NULL),
 	  m_width(0),
 	  m_height(0),
 	  m_fps_times_1million(0),
 	  m_samplerate(0),
 	  m_readresult(CHDERR_NONE),
 	  m_chdtracks(0),
+	  m_work_queue(osd_work_queue_alloc(WORK_QUEUE_FLAG_IO)),
 	  m_audiosquelch(0),
 	  m_videosquelch(0),
 	  m_fieldnum(0),
@@ -134,6 +135,7 @@
 
 laserdisc_device::~laserdisc_device()
 {
+	osd_work_queue_free(m_work_queue);
 }
 
 
@@ -362,7 +364,7 @@
 {
 	// make sure all async operations have completed
 	if (m_disc != NULL)
-		chd_async_complete(m_disc);
+		osd_work_queue_wait(m_work_queue, osd_ticks_per_second() * 10);
 
 	// free any textures and palettes
 	if (m_videotex != NULL)
@@ -767,13 +769,13 @@
 	m_maxtrack = VIRTUAL_LEAD_IN_TRACKS + MAX_TOTAL_TRACKS + VIRTUAL_LEAD_OUT_TRACKS;
 	if (m_disc != NULL)
 	{
-		// require the A/V codec
-		if (chd_get_header(m_disc)->compression != CHDCOMPRESSION_AV)
+		// require the A/V codec and nothing else
+		if (m_disc->compression(0) != CHD_CODEC_AVHUFF || m_disc->compression(1) != CHD_CODEC_NONE)
 			throw emu_fatalerror("Laserdisc video must be compressed with the A/V codec!");
 
 		// read the metadata
-		char metadata[256];
-		chd_error err = chd_get_metadata(m_disc, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
+		astring metadata;
+		chd_error err = m_disc->read_metadata(AV_METADATA_TAG, 0, metadata);
 		if (err != CHDERR_NONE)
 			throw emu_fatalerror("Non-A/V CHD file specified");
 
@@ -789,14 +791,12 @@
 			throw emu_fatalerror("Laserdisc video must be interlaced!");
 
 		// determine the maximum track and allocate a frame buffer
-		UINT32 totalhunks = chd_get_header(m_disc)->totalhunks;
+		UINT32 totalhunks = m_disc->hunk_count();
 		m_chdtracks = totalhunks / 2;
 
 		// allocate memory for the precomputed per-frame metadata
-		m_vbidata = auto_alloc_array(machine(), UINT8, totalhunks * VBI_PACKED_BYTES);
-		UINT32 vbilength;
-		err = chd_get_metadata(m_disc, AV_LD_METADATA_TAG, 0, m_vbidata, totalhunks * VBI_PACKED_BYTES, &vbilength, NULL, NULL);
-		if (err != CHDERR_NONE || vbilength != totalhunks * VBI_PACKED_BYTES)
+		err = m_disc->read_metadata(AV_LD_METADATA_TAG, 0, m_vbidata);
+		if (err != CHDERR_NONE || m_vbidata.count() != totalhunks * VBI_PACKED_BYTES)
 			throw emu_fatalerror("Precomputed VBI metadata missing or incorrect size");
 	}
 	m_maxtrack = MAX(m_maxtrack, VIRTUAL_LEAD_IN_TRACKS + VIRTUAL_LEAD_OUT_TRACKS + m_chdtracks);
@@ -1011,7 +1011,7 @@
 
 	// cheat and look up the metadata we are about to retrieve
 	vbi_metadata vbidata = { 0 };
-	if (m_vbidata != NULL)
+	if (m_vbidata.count() != 0)
 		vbi_metadata_unpack(&vbidata, NULL, &m_vbidata[readhunk * VBI_PACKED_BYTES]);
 
 	// if we're in the lead-in area, force the VBI data to be standard lead-in
@@ -1040,29 +1040,29 @@
 	frame->m_lastfield = m_curtrack * 2 + m_fieldnum;
 
 	// set the video target information
-	m_avconfig.video.wrap(&frame->m_bitmap.pix16(m_fieldnum), frame->m_bitmap.width(), frame->m_bitmap.height() / 2, frame->m_bitmap.rowpixels() * 2);
+	m_avhuff_config.video.wrap(&frame->m_bitmap.pix16(m_fieldnum), frame->m_bitmap.width(), frame->m_bitmap.height() / 2, frame->m_bitmap.rowpixels() * 2);
 
 	// set the audio target information
 	if (m_audiobufin + m_audiomaxsamples <= m_audiobufsize)
 	{
 		// if we can fit without wrapping, just read the data directly
-		m_avconfig.audio[0] = &m_audiobuffer[0][m_audiobufin];
-		m_avconfig.audio[1] = &m_audiobuffer[1][m_audiobufin];
+		m_avhuff_config.audio[0] = &m_audiobuffer[0][m_audiobufin];
+		m_avhuff_config.audio[1] = &m_audiobuffer[1][m_audiobufin];
 	}
 	else
 	{
 		// otherwise, read to the beginning of the buffer
-		m_avconfig.audio[0] = &m_audiobuffer[0][0];
-		m_avconfig.audio[1] = &m_audiobuffer[1][0];
+		m_avhuff_config.audio[0] = &m_audiobuffer[0][0];
+		m_avhuff_config.audio[1] = &m_audiobuffer[1][0];
 	}
 
 	// override if we're not decoding
-	m_avconfig.maxsamples = m_audiomaxsamples;
-	m_avconfig.actsamples = &m_audiocursamples;
+	m_avhuff_config.maxsamples = m_audiomaxsamples;
+	m_avhuff_config.actsamples = &m_audiocursamples;
 	m_audiocursamples = 0;
 
 	// set the VBI data for the new field from our precomputed data
-	if (m_vbidata != NULL)
+	if (m_vbidata.count() != 0)
 	{
 		UINT32 vbiframe;
 		vbi_metadata_unpack(&m_metadata[m_fieldnum], &vbiframe, &m_vbidata[readhunk * VBI_PACKED_BYTES]);
@@ -1079,14 +1079,31 @@
 	m_readresult = CHDERR_FILE_NOT_FOUND;
 	if (m_disc != NULL && !m_videosquelch)
 	{
-		m_readresult = chd_codec_config(m_disc, AV_CODEC_DECOMPRESS_CONFIG, &m_avconfig);
+		m_readresult = m_disc->codec_configure(CHD_CODEC_AVHUFF, AVHUFF_CODEC_DECOMPRESS_CONFIG, &m_avhuff_config);
 		if (m_readresult == CHDERR_NONE)
-			m_readresult = chd_read_async(m_disc, readhunk, NULL);
+		{
+			m_queued_hunknum = readhunk;
+			m_readresult = CHDERR_OPERATION_PENDING;
+			osd_work_item_queue(m_work_queue, read_async_static, this, WORK_ITEM_FLAG_AUTO_RELEASE);
+		}
 	}
 }
 
 
 //-------------------------------------------------
+//  read_async_static - work item callback for
+//  asynchronous reads
+//-------------------------------------------------
+
+void *laserdisc_device::read_async_static(void *param, int threadid)
+{
+	laserdisc_device &ld = *reinterpret_cast<laserdisc_device *>(param);
+	ld.m_readresult = ld.m_disc->read_hunk(ld.m_queued_hunknum, NULL);
+	return NULL;
+}
+
+
+//-------------------------------------------------
 //  process_track_data - process data from a
 //  track after it has been read
 //-------------------------------------------------
@@ -1095,27 +1112,28 @@
 {
 	// wait for the async operation to complete
 	if (m_readresult == CHDERR_OPERATION_PENDING)
-		m_readresult = chd_async_complete(m_disc);
+		osd_work_queue_wait(m_work_queue, osd_ticks_per_second() * 10);
+	assert(m_readresult != CHDERR_OPERATION_PENDING);
 
 	// remove the video if we had an error
 	if (m_readresult != CHDERR_NONE)
-		m_avconfig.video.reset();
+		m_avhuff_config.video.reset();
 
 	// count the field as read if we are successful
-	if (m_avconfig.video.valid())
+	if (m_avhuff_config.video.valid())
 	{
 		m_frame[m_videoindex].m_numfields++;
-		player_overlay(m_avconfig.video);
+		player_overlay(m_avhuff_config.video);
 	}
 
 	// pass the audio to the callback
 	if (!m_audio_callback.isnull())
-		m_audio_callback(*this, m_samplerate, m_audiocursamples, m_avconfig.audio[0], m_avconfig.audio[1]);
+		m_audio_callback(*this, m_samplerate, m_audiocursamples, m_avhuff_config.audio[0], m_avhuff_config.audio[1]);
 
 	// shift audio data if we read it into the beginning of the buffer
 	if (m_audiocursamples != 0 && m_audiobufin != 0)
 		for (int chnum = 0; chnum < 2; chnum++)
-			if (m_avconfig.audio[chnum] == &m_audiobuffer[chnum][0])
+			if (m_avhuff_config.audio[chnum] == &m_audiobuffer[chnum][0])
 			{
 				// move data to the end
 				int samplesleft = m_audiobufsize - m_audiobufin;
diff -Nru src-old/emu/machine/laserdsc.h src/emu/machine/laserdsc.h
--- src-old/emu/machine/laserdsc.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/machine/laserdsc.h	2012-02-16 10:47:18.000000000 +0100
@@ -43,6 +43,7 @@
 #define __LASERDSC_H__
 
 #include "vbiparse.h"
+#include "avhuff.h"
 
 
 //**************************************************************************
@@ -315,6 +316,7 @@
 	void vblank_state_changed(screen_device &screen, bool vblank_state);
 	frame_data &current_frame();
 	void read_track_data();
+	static void *read_async_static(void *param, int threadid);
 	void process_track_data();
 	void config_load(int config_type, xml_data_node *parentnode);
 	void config_save(int config_type, xml_data_node *parentnode);
@@ -332,14 +334,18 @@
 
 	// disc parameters
 	chd_file *			m_disc;					// handle to the disc itself
-	UINT8 *				m_vbidata;				// pointer to precomputed VBI data
+	dynamic_buffer		m_vbidata;				// pointer to precomputed VBI data
 	int					m_width;				// width of video
 	int					m_height;				// height of video
 	UINT32				m_fps_times_1million;	// frame rate of video
 	int					m_samplerate;			// audio samplerate
-	chd_error			m_readresult;			// result of the most recent read
+	int					m_readresult;			// result of the most recent read
 	UINT32				m_chdtracks;			// number of tracks in the CHD
-	av_codec_decompress_config m_avconfig;		// decompression configuration
+	avhuff_decompress_config m_avhuff_config;	// decompression configuration
+
+	// async operations
+	osd_work_queue *	m_work_queue;			// work queue
+	UINT32				m_queued_hunknum;		// queued hunk
 
 	// core states
 	UINT8				m_audiosquelch;			// audio squelch state: bit 0 = audio 1, bit 1 = audio 2
diff -Nru src-old/emu/machine/mc146818.c src/emu/machine/mc146818.c
--- src-old/emu/machine/mc146818.c	2011-08-13 22:00:35.000000000 +0200
+++ src/emu/machine/mc146818.c	2012-02-18 11:58:12.000000000 +0100
@@ -147,12 +147,7 @@
 
 	memset(m_data, 0, sizeof(m_data));
 
-	if (m_type == MC146818_UTC) {
-		// hack: for apollo we increase the update frequency to stay in sync with real time
-		m_clock_timer->adjust(attotime::from_hz(2), 0, attotime::from_hz(2));
-	} else {
-		m_clock_timer->adjust(attotime::from_hz(1), 0, attotime::from_hz(1));
-	}
+	m_clock_timer->adjust(attotime::from_hz(1), 0, attotime::from_hz(1));
 
 	m_periodic_timer->adjust(attotime::never);
 	m_period = attotime::never;
@@ -422,7 +417,8 @@
 		switch (m_index % MC146818_DATA_SIZE) {
 		case 0xa:
 			data = m_data[m_index  % MC146818_DATA_SIZE];
-			if ((space.machine().time() - m_last_refresh) < attotime::from_hz(32768))
+			// Update In Progress (UIP) time for 32768 Hz is 244+1984usec
+			if ((space.machine().time() - m_last_refresh) < attotime::from_usec(244+1984))
 				data |= 0x80;
 #if 0
 			/* for pc1512 bios realtime clock test */
diff -Nru src-old/emu/machine/mccs1850.c src/emu/machine/mccs1850.c
--- src-old/emu/machine/mccs1850.c	2012-01-23 22:49:46.000000000 +0100
+++ src/emu/machine/mccs1850.c	2012-02-12 10:45:38.000000000 +0100
@@ -294,7 +294,7 @@
 {
 }
 
-void mccs1850_device::set_cb(cb_t _int_cb, cb_t _pse_cb, cb_t _nuc_cb)
+void mccs1850_device::set_cb(line_cb_t _int_cb, line_cb_t _pse_cb, line_cb_t _nuc_cb)
 {
 	int_cb = _int_cb;
 	pse_cb = _pse_cb;
diff -Nru src-old/emu/machine/mccs1850.h src/emu/machine/mccs1850.h
--- src-old/emu/machine/mccs1850.h	2012-01-23 22:49:46.000000000 +0100
+++ src/emu/machine/mccs1850.h	2012-02-12 10:45:38.000000000 +0100
@@ -47,11 +47,9 @@
 						public device_nvram_interface
 {
 public:
-	typedef delegate<void (bool state)> cb_t;
-
     // construction/destruction
     mccs1850_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
-	void set_cb(cb_t int_cb, cb_t pse_cb, cb_t nuc_cb);
+	void set_cb(line_cb_t int_cb, line_cb_t pse_cb, line_cb_t nuc_cb);
 
 	DECLARE_WRITE_LINE_MEMBER( ce_w );
 	DECLARE_WRITE_LINE_MEMBER( sck_w );
@@ -85,7 +83,7 @@
 
 	static const device_timer_id TIMER_CLOCK = 0;
 
-	cb_t int_cb, pse_cb, nuc_cb;
+	line_cb_t int_cb, pse_cb, nuc_cb;
 
 	UINT8 m_ram[0x80];			// RAM
 
diff -Nru src-old/emu/machine/nscsi_bus.c src/emu/machine/nscsi_bus.c
--- src-old/emu/machine/nscsi_bus.c	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_bus.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,656 @@
+#include "nscsi_bus.h"
+
+const device_type NSCSI_BUS = &device_creator<nscsi_bus_device>;
+const device_type NSCSI_CONNECTOR = &device_creator<nscsi_connector>;
+
+nscsi_bus_device::nscsi_bus_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+	device_t(mconfig, NSCSI_BUS, "SCSI Bus", tag, owner, clock)
+{
+	devcnt = 0;
+	memset(dev, 0, sizeof(dev));
+}
+
+void nscsi_bus_device::device_start()
+{
+	data = 0;
+	ctrl = 0;
+}
+
+void nscsi_bus_device::device_reset()
+{
+}
+
+void nscsi_bus_device::regen_data()
+{
+	data = 0;
+	for(int i=0; i<devcnt; i++)
+		data |= dev[i].data;
+}
+
+void nscsi_bus_device::regen_ctrl(int refid)
+{
+	static const char *phase[8] = {
+		"dout", "din ", "cmd ", "stat", "4   ", "5   ", "mout", "min "
+	};
+
+	UINT32 octrl = ctrl;
+	ctrl = 0;
+	for(int i=0; i<devcnt; i++)
+		ctrl |= dev[i].ctrl;
+
+	if(0) {
+		logerror("%s: ctrl %c%c%c%c%c%c%c%c%c %s %04x -",
+				 tag(),
+				 ctrl & nscsi_device::S_RST ? 'R' : '.',
+				 ctrl & nscsi_device::S_ATN ? 'A' : '.',
+				 ctrl & nscsi_device::S_ACK ? 'K' : '.',
+				 ctrl & nscsi_device::S_REQ ? 'Q' : '.',
+				 ctrl & nscsi_device::S_SEL ? 'S' : '.',
+				 ctrl & nscsi_device::S_BSY ? 'B' : '.',
+				 ctrl & nscsi_device::S_MSG ? 'M' : '.',
+				 ctrl & nscsi_device::S_CTL ? 'C' : '.',
+				 ctrl & nscsi_device::S_INP ? 'I' : '.',
+				 phase[ctrl & 7],
+				 data);
+		for(int i=0; i<devcnt; i++)
+			if(dev[i].ctrl) {
+				logerror(" %d=", i);
+				logerror("%s%s%s%s%s%s%s%s%s",
+						 dev[i].ctrl & nscsi_device::S_RST ? "R" : "",
+						 dev[i].ctrl & nscsi_device::S_ATN ? "A" : "",
+						 dev[i].ctrl & nscsi_device::S_ACK ? "K" : "",
+						 dev[i].ctrl & nscsi_device::S_REQ ? "Q" : "",
+						 dev[i].ctrl & nscsi_device::S_MSG ? "M" : "",
+						 dev[i].ctrl & nscsi_device::S_INP ? "I" : "",
+						 dev[i].ctrl & nscsi_device::S_CTL ? "C" : "",
+						 dev[i].ctrl & nscsi_device::S_SEL ? "S" : "",
+						 dev[i].ctrl & nscsi_device::S_BSY ? "B" : "");
+			}
+		logerror("\n");
+	}
+
+	octrl = octrl ^ ctrl;
+	if(octrl)
+		for(int i=0; i<devcnt; i++)
+			if(i != refid && (dev[i].wait_ctrl & octrl))
+				dev[i].dev->scsi_ctrl_changed();
+}
+
+UINT32 nscsi_bus_device::data_r() const
+{
+	return data;
+}
+
+UINT32 nscsi_bus_device::ctrl_r() const
+{
+	return ctrl;
+}
+
+void nscsi_bus_device::ctrl_w(int refid, UINT32 lines, UINT32 mask)
+{
+	UINT32 c = dev[refid].ctrl;
+	dev[refid].ctrl = (c & ~mask) | (lines & mask);
+	regen_ctrl(refid);
+}
+
+void nscsi_bus_device::data_w(int refid, UINT32 lines)
+{
+	dev[refid].data = lines;
+	regen_data();
+}
+
+void nscsi_bus_device::ctrl_wait(int refid, UINT32 lines, UINT32 mask)
+{
+	UINT32 w = dev[refid].wait_ctrl;
+	dev[refid].wait_ctrl = (w & ~mask) | (lines & mask);
+}
+
+void nscsi_bus_device::device_config_complete()
+{
+	char id[3];
+	for(int i=0; i<16; i++) {
+		sprintf(id, "%d", i);
+		nscsi_connector *conn = downcast<nscsi_connector *>(subdevice(id));
+		if(conn) {
+			nscsi_device *sdev = conn->get_device();
+			if(sdev) {
+				int rid = devcnt++;
+				dev[rid].dev = sdev;
+				sdev->connect_to_bus(this, rid, i);
+			}
+		}
+	}
+}
+
+
+nscsi_connector::nscsi_connector(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+	device_t(mconfig, NSCSI_CONNECTOR, "NSCSI device connector abstraction", tag, owner, clock),
+	device_slot_interface(mconfig, *this)
+{
+	fixed_subtag = 0;
+}
+
+nscsi_connector::~nscsi_connector()
+{
+}
+
+void nscsi_connector::device_start()
+{
+}
+
+nscsi_device *nscsi_connector::get_device()
+{
+	return dynamic_cast<nscsi_device *>(fixed_subtag ? subdevice(fixed_subtag) : get_card_device());
+}
+
+void nscsi_connector::set_fixed_device(const char *subtag)
+{
+	fixed_subtag = subtag;
+}
+
+
+nscsi_device::nscsi_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock) :
+	device_t(mconfig, type, name, tag, owner, clock),
+	device_slot_card_interface(mconfig, *this)
+{
+	scsi_id = scsi_refid = -1;
+	scsi_bus = 0;
+}
+
+void nscsi_device::connect_to_bus(nscsi_bus_device *bus, int refid, int default_scsi_id)
+{
+	scsi_bus = bus;
+	scsi_refid = refid;
+	scsi_id = default_scsi_id;
+}
+
+void nscsi_device::scsi_ctrl_changed()
+{
+}
+
+nscsi_full_device::nscsi_full_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock) :
+	nscsi_device(mconfig, type, name, tag, owner, clock)
+{
+}
+
+void nscsi_full_device::device_start()
+{
+	scsi_timer = timer_alloc(SCSI_TIMER);
+}
+
+void nscsi_full_device::device_reset()
+{
+	scsi_state = scsi_substate = IDLE;
+	buf_control_rpos = buf_control_wpos = 0;
+	scsi_identify = 0;
+	scsi_bus->data_w(scsi_refid, 0);
+	scsi_bus->ctrl_w(scsi_refid, 0, S_ALL);
+	scsi_bus->ctrl_wait(scsi_refid, S_SEL|S_BSY|S_RST, S_ALL);
+}
+
+void nscsi_full_device::device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr)
+{
+	if(id != SCSI_TIMER)
+		return;
+
+	step(true);
+
+}
+
+void nscsi_full_device::scsi_ctrl_changed()
+{
+	step(false);
+}
+
+void nscsi_full_device::step(bool timeout)
+{
+	UINT32 ctrl = scsi_bus->ctrl_r();
+	UINT32 data = scsi_bus->data_r();
+	if(ctrl & S_RST) {
+		scsi_bus->data_w(scsi_refid, 0);
+		scsi_bus->ctrl_w(scsi_refid, 0, S_ALL);
+		scsi_state = IDLE;
+		logerror("%s: scsi bus reset\n", tag());
+		return;
+	}
+
+	if(0)
+		logerror("%s: state=%d.%d %s\n",
+				 tag(), scsi_state & STATE_MASK, (scsi_state & SUB_MASK) >> SUB_SHIFT,
+				 timeout ? "timeout" : "change");
+
+	switch(scsi_state & SUB_MASK ? scsi_state & SUB_MASK : scsi_state & STATE_MASK) {
+	case IDLE:
+		if(((ctrl & (S_SEL|S_BSY)) == S_SEL) && (scsi_id != -1) && ((data & (1 << scsi_id)) != 0)) {
+			for(scsi_initiator_id = 0; scsi_initiator_id != 16 && (scsi_initiator_id == scsi_id || (data & (1 << scsi_initiator_id))); scsi_initiator_id++);
+			if(scsi_initiator_id == 16)
+				scsi_initiator_id = -1;
+			scsi_state = TARGET_SELECT_WAIT_BUS_SETTLE;
+			scsi_timer->adjust(scsi_bus_settle_delay());
+		}
+		break;
+
+	case TARGET_SELECT_WAIT_BUS_SETTLE:
+		if((ctrl & (S_SEL|S_BSY)) == S_SEL) {
+			scsi_state = TARGET_SELECT_WAIT_SEL_0;
+			scsi_bus->ctrl_w(scsi_refid, S_BSY, S_BSY);
+		} else
+			scsi_state = IDLE;
+		break;
+
+	case TARGET_SELECT_WAIT_SEL_0:
+		if(ctrl & S_SEL)
+			break;
+		buf_control_push()->action = BC_MSG_OR_COMMAND;
+		scsi_state = TARGET_NEXT_CONTROL;
+		step(false);
+		break;
+
+	case RECV_BYTE_T_WAIT_ACK_1 << SUB_SHIFT:
+		if(ctrl & S_ACK) {
+			received(scsi_bus->data_r());
+			scsi_state = (scsi_state & STATE_MASK) | (RECV_BYTE_T_WAIT_ACK_0 << SUB_SHIFT);
+			scsi_bus->ctrl_w(scsi_refid, 0, S_REQ);
+		}
+		break;
+
+	case RECV_BYTE_T_WAIT_ACK_0 << SUB_SHIFT:
+		if(!(ctrl & S_ACK)) {
+			scsi_state &= STATE_MASK;
+			scsi_bus->ctrl_wait(scsi_refid, 0, S_ACK);
+			step(false);
+		}
+		break;
+
+	case SEND_BYTE_T_WAIT_ACK_1 << SUB_SHIFT:
+		if(ctrl & S_ACK) {
+			scsi_state = (scsi_state & STATE_MASK) | (SEND_BYTE_T_WAIT_ACK_0 << SUB_SHIFT);
+			scsi_bus->data_w(scsi_refid, 0);
+			scsi_bus->ctrl_w(scsi_refid, 0, S_REQ);
+		}
+		break;
+
+	case SEND_BYTE_T_WAIT_ACK_0 << SUB_SHIFT:
+		if(!(ctrl & S_ACK)) {
+			scsi_state &= STATE_MASK;
+			scsi_bus->ctrl_wait(scsi_refid, 0, S_ACK);
+			step(false);
+		}
+		break;
+
+	case TARGET_NEXT_CONTROL: {
+		control *ctl = buf_control_pop();
+		switch(ctl->action) {
+		case BC_MSG_OR_COMMAND:
+			if(ctrl & S_ATN) {
+				scsi_state = TARGET_WAIT_MSG_BYTE;
+				scsi_bus->ctrl_w(scsi_refid, S_PHASE_MSG_OUT, S_PHASE_MASK);
+			} else {
+				scsi_state = TARGET_WAIT_CMD_BYTE;
+				scsi_bus->ctrl_w(scsi_refid, S_PHASE_COMMAND, S_PHASE_MASK);
+			}
+			scsi_cmdsize = 0;
+			target_recv_byte();
+			break;
+
+		case BC_STATUS:
+			scsi_bus->ctrl_w(scsi_refid, S_PHASE_STATUS, S_PHASE_MASK);
+			target_send_byte(ctl->param1);
+			break;
+
+		case BC_DATA_IN:
+			scsi_bus->ctrl_w(scsi_refid, S_PHASE_DATA_IN, S_PHASE_MASK);
+			data_buffer_id = ctl->param1;
+			data_buffer_size = ctl->param2;
+			data_buffer_pos = 0;
+			scsi_state = TARGET_WAIT_DATA_IN_BYTE;
+			target_send_buffer_byte();
+			break;
+
+		case BC_MESSAGE_1:
+			scsi_bus->ctrl_w(scsi_refid, S_PHASE_MSG_IN, S_PHASE_MASK);
+			target_send_byte(ctl->param1);
+			break;
+
+		case BC_BUS_FREE:
+			scsi_bus->data_w(scsi_refid, 0);
+			scsi_bus->ctrl_wait(scsi_refid, S_BSY|S_SEL|S_RST, S_ALL);
+			scsi_bus->ctrl_w(scsi_refid, 0, S_ALL);
+			scsi_state = IDLE;
+			break;
+		};
+		break;
+	}
+
+	case TARGET_WAIT_DATA_IN_BYTE:
+		if(data_buffer_pos == data_buffer_size-1)
+			scsi_state = TARGET_NEXT_CONTROL;
+		target_send_buffer_byte();
+		break;
+
+	case TARGET_WAIT_MSG_BYTE:
+		if(ctrl & S_SEL)
+			return;
+		if(!(ctrl & S_ATN)) {
+			scsi_message();
+			scsi_cmdsize = 0;
+			scsi_state = TARGET_WAIT_CMD_BYTE;
+			scsi_bus->ctrl_w(scsi_refid, S_PHASE_COMMAND, S_PHASE_MASK);
+		}
+		target_recv_byte();
+		break;
+
+	case TARGET_WAIT_CMD_BYTE:
+		if(ctrl & S_SEL)
+			return;
+		if(ctrl & S_ATN) {
+			logerror("%s: Parity error? Say what?\n", tag());
+			scsi_state = IDLE;
+			break;
+		}
+
+		if(command_done()) {
+			scsi_bus->ctrl_wait(scsi_refid, 0, S_ACK);
+			scsi_command();
+			scsi_state = TARGET_NEXT_CONTROL;
+			step(false);
+		} else
+			target_recv_byte();
+		break;
+
+	default:
+		logerror("%s: step() unexpected state %d.%d\n",
+				 tag(),
+				 scsi_state & STATE_MASK, (scsi_state & SUB_MASK) >> SUB_SHIFT);
+		exit(0);
+	}
+}
+
+void nscsi_full_device::target_recv_byte()
+{
+	scsi_bus->ctrl_wait(scsi_refid, S_ACK, S_ACK);
+	scsi_state = (scsi_state & STATE_MASK) | (RECV_BYTE_T_WAIT_ACK_1 << SUB_SHIFT);
+	scsi_bus->ctrl_w(scsi_refid, S_REQ, S_REQ);
+	step(false);
+}
+
+void nscsi_full_device::target_send_byte(UINT8 val)
+{
+	scsi_bus->ctrl_wait(scsi_refid, S_ACK, S_ACK);
+	scsi_state = (scsi_state & STATE_MASK) | (SEND_BYTE_T_WAIT_ACK_1 << SUB_SHIFT);
+	scsi_bus->data_w(scsi_refid, val);
+	scsi_bus->ctrl_w(scsi_refid, S_REQ, S_REQ);
+	step(false);
+}
+
+void nscsi_full_device::received(UINT8 val)
+{
+	scsi_cmdbuf[scsi_cmdsize++] = val;
+}
+
+UINT8 nscsi_full_device::scsi_get_data(int id, int pos)
+{
+	switch(id) {
+	case SBUF_MAIN:
+		return scsi_cmdbuf[pos];
+	case SBUF_SENSE:
+		return scsi_sense_buffer[pos];
+	default:
+		abort();
+	}
+}
+
+void nscsi_full_device::target_send_buffer_byte()
+{
+	target_send_byte(scsi_get_data(data_buffer_id, data_buffer_pos++));
+}
+
+bool nscsi_full_device::command_done()
+{
+	if(!scsi_cmdsize)
+		return false;
+	UINT8 h = scsi_cmdbuf[0];
+	switch(h >> 5) {
+	case 0: return scsi_cmdsize == 6;
+	case 1: return scsi_cmdsize == 10;
+	case 2: return scsi_cmdsize == 10;
+	case 3: return true;
+	case 4: return true;
+	case 5: return scsi_cmdsize == 12;
+	case 6: return true;
+	case 7: return true;
+	}
+	return true;
+}
+
+nscsi_full_device::control *nscsi_full_device::buf_control_push()
+{
+	if(buf_control_wpos == int(sizeof(buf_control)/sizeof(buf_control[0])))
+		throw emu_fatalerror("%s: buf_control overflow\n", tag());
+
+	control *c = buf_control + buf_control_wpos;
+	buf_control_wpos++;
+	return c;
+}
+
+nscsi_full_device::control *nscsi_full_device::buf_control_pop()
+{
+	if(buf_control_rpos == buf_control_wpos)
+		throw emu_fatalerror("%s: buf_control underflow\n", tag());
+
+	control *c = buf_control + buf_control_rpos;
+	buf_control_rpos++;
+	if(buf_control_rpos == buf_control_wpos)
+		buf_control_rpos = buf_control_wpos = 0;
+	return c;
+}
+
+void nscsi_full_device::scsi_status_complete(UINT8 st)
+{
+	control *c;
+	c = buf_control_push();
+	c->action = BC_STATUS;
+	c->param1 = st;
+	c = buf_control_push();
+	c->action = BC_MESSAGE_1;
+	c->param1 = SM_COMMAND_COMPLETE;
+	c = buf_control_push();
+	c->action = BC_BUS_FREE;
+}
+
+void nscsi_full_device::scsi_data_in(int buf, int size)
+{
+	control *c;
+	c = buf_control_push();
+	c->action = BC_DATA_IN;
+	c->param1 = buf;
+	c->param2 = size;
+}
+
+void nscsi_full_device::scsi_data_out(int buf, int size)
+{
+	control *c;
+	c = buf_control_push();
+	c->action = BC_DATA_OUT;
+	c->param1 = buf;
+	c->param2 = size;
+}
+
+void nscsi_full_device::sense(bool deferred, UINT8 key)
+{
+	memset(scsi_sense_buffer, 0, sizeof(scsi_sense_buffer));
+	scsi_sense_buffer[0] = deferred ? 0x71 : 0x70;
+	scsi_sense_buffer[2] = key;
+}
+
+void nscsi_full_device::scsi_unknown_command()
+{
+	logerror("%s: Unknown command", tag());
+	for(int i=0; i != scsi_cmdsize; i++)
+		logerror(" %02x", scsi_cmdbuf[i]);
+	logerror("\n");
+
+	scsi_status_complete(SS_CHECK_CONDITION);
+	sense(false, 5);
+}
+
+void nscsi_full_device::scsi_command()
+{
+	switch(scsi_cmdbuf[0]) {
+	case SC_REQUEST_SENSE:
+		logerror("%s: command REQUEST SENSE\n", tag());
+		scsi_data_in(SBUF_SENSE, 8);
+		scsi_status_complete(SS_GOOD);
+		break;
+	default:
+		scsi_unknown_command();
+		break;
+	}
+}
+
+void nscsi_full_device::scsi_message()
+{
+	if(scsi_cmdbuf[0] & 0x80) {
+		scsi_identify = scsi_cmdbuf[0];
+		return;
+	}
+
+	logerror("%s: Unknown message", tag());
+	for(int i=0; i != scsi_cmdsize; i++)
+		logerror(" %02x", scsi_cmdbuf[i]);
+	logerror("\n");
+}
+
+int nscsi_full_device::get_lun(int def)
+{
+	if(scsi_identify & 0x80)
+		return scsi_identify & 0x7f;
+	return def;
+}
+
+void nscsi_full_device::bad_lun()
+{
+	scsi_status_complete(SS_CHECK_CONDITION);
+	sense(false, 2);
+}
+
+// Arbitration delay (2.4us)
+attotime nscsi_full_device::scsi_arbitation_delay()
+{
+	return attotime::from_nsec(2400);
+}
+
+// Assertion period (90ns)
+attotime nscsi_full_device::scsi_assertion_period()
+{
+	return attotime::from_nsec(90);
+}
+
+// Bus clear delay (800ns)
+attotime nscsi_full_device::scsi_bus_clear_delay()
+{
+	return attotime::from_nsec(800);
+}
+
+// Bus free delay (800ns)
+attotime nscsi_full_device::scsi_bus_free_delay()
+{
+	return attotime::from_nsec(800);
+}
+
+// Bus set delay (1.8us)
+attotime nscsi_full_device::scsi_bus_set_delay()
+{
+	return attotime::from_nsec(1800);
+}
+
+// Bus settle delay (400ns)
+attotime nscsi_full_device::scsi_bus_settle_delay()
+{
+	return attotime::from_nsec(400);
+}
+
+// Cable skew delay (10ns)
+attotime nscsi_full_device::scsi_cable_skew_delay()
+{
+	return attotime::from_nsec(10);
+}
+
+// Data release delay (400ns)
+attotime nscsi_full_device::scsi_data_release_delay()
+{
+	return attotime::from_nsec(40);
+}
+
+// Deskew delay (45ns)
+attotime nscsi_full_device::scsi_deskew_delay()
+{
+	return attotime::from_nsec(45);
+}
+
+// Disconnection delay (200us)
+attotime nscsi_full_device::scsi_disconnection_delay()
+{
+	return attotime::from_usec(200);
+}
+
+// Hold time (45ns)
+attotime nscsi_full_device::scsi_hold_time()
+{
+	return attotime::from_nsec(45);
+}
+
+// Negation period (90ns)
+attotime nscsi_full_device::scsi_negation_period()
+{
+	return attotime::from_nsec(90);
+}
+
+// Reset hold time (25us)
+attotime nscsi_full_device::scsi_reset_hold_time()
+{
+	return attotime::from_usec(25);
+}
+
+// Selection abort time (200us)
+attotime nscsi_full_device::scsi_selection_abort_time()
+{
+	return attotime::from_usec(200);
+}
+
+// Selection timeout delay (250ms)
+attotime nscsi_full_device::scsi_selection_timeout_delay()
+{
+	return attotime::from_msec(250);
+}
+
+// Fast assertion period (30ns)
+attotime nscsi_full_device::scsi_fast_assertion_period()
+{
+	return attotime::from_nsec(30);
+}
+
+// Fast cable skew delay (5ns)
+attotime nscsi_full_device::scsi_fast_cable_skew_delay()
+{
+	return attotime::from_nsec(5);
+}
+
+// Fast deskew delay (20ns)
+attotime nscsi_full_device::scsi_fast_deskew_delay()
+{
+	return attotime::from_nsec(20);
+}
+
+// Fast hold time (10ns)
+attotime nscsi_full_device::scsi_fast_hold_time()
+{
+	return attotime::from_nsec(10);
+}
+
+// Fast negation period (30ns)
+attotime nscsi_full_device::scsi_fast_negation_period()
+{
+	return attotime::from_nsec(30);
+}
+
diff -Nru src-old/emu/machine/nscsi_bus.h src/emu/machine/nscsi_bus.h
--- src-old/emu/machine/nscsi_bus.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_bus.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,353 @@
+#ifndef __NSCSI_BUS_H__
+#define __NSCSI_BUS_H__
+
+#include "emu.h"
+
+#define MCFG_NSCSI_BUS_ADD(_tag)		\
+	MCFG_DEVICE_ADD(_tag, NSCSI_BUS, 0)
+
+#define MCFG_NSCSI_DEVICE_ADD(_tag, _subtag, _type, _clock)			\
+	MCFG_DEVICE_ADD(_tag, NSCSI_CONNECTOR, 0)						\
+	downcast<nscsi_connector *>(device)->set_fixed_device(_subtag);	\
+	MCFG_DEVICE_ADD(_tag ":" _subtag, _type, _clock)
+
+#define MCFG_NSCSI_FULL_DEVICE_ADD(_tag, _subtag, _type, _clock)	\
+	MCFG_NSCSI_DEVICE_ADD(_tag, _subtag, _type, _clock)
+
+#define MCFG_NSCSI_ADD(_tag, _slot_intf, _def_slot, _def_inp)	\
+	MCFG_DEVICE_ADD(_tag, NSCSI_CONNECTOR, 0)					\
+	MCFG_DEVICE_SLOT_INTERFACE(_slot_intf, _def_slot, _def_inp)
+
+class nscsi_device;
+
+class nscsi_bus_device : public device_t
+{
+public:
+	nscsi_bus_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	void ctrl_w(int refid, UINT32 lines, UINT32 mask);
+	void data_w(int refid, UINT32 lines);
+	void ctrl_wait(int refid, UINT32 lines, UINT32 mask);
+
+	UINT32 ctrl_r() const;
+	UINT32 data_r() const;
+
+protected:
+	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_config_complete();
+
+private:
+	struct dev_t {
+		nscsi_device *dev;
+		UINT32 ctrl, wait_ctrl;
+		UINT32 data;
+	};
+
+	dev_t dev[16];
+	int devcnt;
+
+	UINT32 data, ctrl;
+
+	void regen_data();
+	void regen_ctrl(int refid);
+};
+
+class nscsi_connector: public device_t,
+					   public device_slot_interface
+{
+public:
+	nscsi_connector(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	virtual ~nscsi_connector();
+
+	nscsi_device *get_device();
+	void set_fixed_device(const char *subtag);
+
+protected:
+	virtual void device_start();
+
+private:
+	const char *fixed_subtag;
+};
+
+class nscsi_device : public device_t,
+					 public device_slot_card_interface
+{
+public:
+	// Here because the biggest users are the devices, not the bus
+	enum {
+		S_INP = 0x0001,
+		S_CTL = 0x0002,
+		S_MSG = 0x0004,
+		S_BSY = 0x0008,
+		S_SEL = 0x0010,
+		S_REQ = 0x0020,
+		S_ACK = 0x0040,
+		S_ATN = 0x0080,
+		S_RST = 0x0100,
+		S_ALL = 0x01ff,
+
+		S_PHASE_DATA_OUT = 0,
+		S_PHASE_DATA_IN  = S_INP,
+		S_PHASE_COMMAND  = S_CTL,
+		S_PHASE_STATUS   = S_CTL|S_INP,
+		S_PHASE_MSG_OUT  = S_MSG|S_CTL,
+		S_PHASE_MSG_IN   = S_MSG|S_CTL|S_INP,
+		S_PHASE_MASK     = S_MSG|S_CTL|S_INP,
+	};
+
+	nscsi_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
+
+	void connect_to_bus(nscsi_bus_device *bus, int refid, int default_scsi_id);
+	virtual void scsi_ctrl_changed();
+protected:
+	int scsi_id;
+	int scsi_refid;
+	nscsi_bus_device *scsi_bus;
+};
+
+class nscsi_full_device : public nscsi_device
+{
+public:
+	nscsi_full_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
+
+	virtual void scsi_ctrl_changed();
+protected:
+	enum { SCSI_TIMER = 100 };
+
+	// SCSI status returns
+	enum {
+		SS_GOOD              = 0x00,
+		SS_CHECK_CONDITION   = 0x02,
+		SS_CONDITION_MET     = 0x04,
+		SS_BUSY              = 0x08,
+		SS_INT_GOOD          = 0x10,
+		SS_INT_CONDITION_MET = 0x14,
+		SS_RESV_CONFLICT     = 0x18,
+		SS_TERMINATED        = 0x22,
+		SS_QUEUE_FULL        = 0x28,
+	};
+
+	// SCSI commands
+	enum {
+		SC_TEST_UNIT_READY   = 0x00,
+		SC_REZERO            = 0x01,
+		SC_REQUEST_SENSE     = 0x03,
+		SC_FORMAT_UNIT       = 0x04,
+		SC_REASSIGN_BLOCKS   = 0x07,
+		SC_READ              = 0x08,
+		SC_WRITE             = 0x0a,
+		SC_SEEK              = 0x0b,
+		SC_INQUIRY           = 0x12,
+		SC_MODE_SELECT_6     = 0x15,
+		SC_RESERVE_6         = 0x16,
+		SC_RELEASE_6         = 0x17,
+		SC_MODE_SENSE_6      = 0x1a,
+		SC_START_STOP_UNIT   = 0x1b,
+		SC_RECIEVE_DIAG_RES  = 0x1c,
+		SC_SEND_DIAGNOSTICS  = 0x1d,
+		SC_READ_CAPACITY     = 0x25,
+		SC_READ_EXTENDED     = 0x28,
+		SC_WRITE_EXTENDED    = 0x2a,
+		SC_SEEK_EXTENDED     = 0x2b,
+		SC_WRITE_VERIFY      = 0x2e,
+		SC_VERIFY            = 0x2f,
+		SC_SYNC_CACHE        = 0x35,
+		SC_READ_DEFECT_DATA  = 0x37,
+		SC_READ_DATA_BUFFER  = 0x3c,
+		SC_READ_LONG         = 0x3e,
+		SC_WRITE_LONG        = 0x3f,
+		SC_CHANGE_DEFINITION = 0x40,
+		SC_LOG_SELECT        = 0x4c,
+		SC_LOG_SENSE         = 0x4d,
+		SC_MODE_SELECT_10    = 0x55,
+		SC_RESERVE_10        = 0x56,
+		SC_RELEASE_10        = 0x57,
+		SC_MODE_SENSE_10     = 0x5a,
+	};
+
+	// SCSI Messages
+	enum {
+		SM_COMMAND_COMPLETE  = 0x00,
+		SM_EXTENDED_MSG      = 0x01,
+		SM_SAVE_DATA_PTR     = 0x02,
+		SM_RESTORE_PTR       = 0x03,
+		SM_DISCONNECT        = 0x04,
+		SM_INITIATOR_ERROR   = 0x05,
+		SM_ABORT             = 0x06,
+		SM_MSG_REJECT        = 0x07,
+		SM_NOP               = 0x08,
+		SM_MSG_PARITY        = 0x09,
+		SM_LCMD_COMPLETE     = 0x0a,
+		SM_LCMD_COMPLETE_F   = 0x0b,
+		SM_BUS_DEVICE_RESET  = 0x0c,
+		SM_ABORT_TAG         = 0x0d,
+		SM_CLEAR_QUEUE       = 0x0e,
+		SM_INIT_RECOVERY     = 0x0f,
+		SM_RELEASE_RECOVERY  = 0x10,
+		SM_TERMINATE_IO      = 0x11,
+		SM_SIMPLE_QUEUE      = 0x20,
+		SM_HEAD_QUEUE        = 0x21,
+		SM_ORDERED_QUEUE     = 0x22,
+		SM_IGNORE_WIDE_RES   = 0x23,
+	};
+
+	enum {
+		SBUF_MAIN,
+		SBUF_SENSE,
+	};
+
+	UINT8 scsi_cmdbuf[4096], scsi_sense_buffer[8];
+	int scsi_cmdsize;
+	UINT8 scsi_identify;
+
+	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr);
+
+	virtual void scsi_message();
+	virtual void scsi_command();
+
+	void scsi_unknown_command();
+	void scsi_status_complete(UINT8 st);
+	void scsi_data_in(int buf, int size);
+	void scsi_data_out(int buf, int size);
+
+	void sense(bool deferred, UINT8 key);
+	int get_lun(int def = 0);
+	void bad_lun();
+
+	virtual UINT8 scsi_get_data(int buf, int offset);
+
+	// Default delays:
+
+	// Arbitration delay (2.4us)
+	virtual attotime scsi_arbitation_delay();
+
+	// Assertion period (90ns)
+	virtual attotime scsi_assertion_period();
+
+	// Bus clear delay (800ns)
+	virtual attotime scsi_bus_clear_delay();
+
+	// Bus free delay (800ns)
+	virtual attotime scsi_bus_free_delay();
+
+	// Bus set delay (1.8us)
+	virtual attotime scsi_bus_set_delay();
+
+	// Bus settle delay (400ns)
+	virtual attotime scsi_bus_settle_delay();
+
+	// Cable skew delay (10ns)
+	virtual attotime scsi_cable_skew_delay();
+
+	// Data release delay (400ns)
+	virtual attotime scsi_data_release_delay();
+
+	// Deskew delay (45ns)
+	virtual attotime scsi_deskew_delay();
+
+	// Disconnection delay (200us)
+	virtual attotime scsi_disconnection_delay();
+
+	// Hold time (45ns)
+	virtual attotime scsi_hold_time();
+
+	// Negation period (90ns)
+	virtual attotime scsi_negation_period();
+
+	// Reset hold time (25us)
+	virtual attotime scsi_reset_hold_time();
+
+	// Selection abort time (200us)
+	virtual attotime scsi_selection_abort_time();
+
+	// Selection timeout delay (250ms)
+	virtual attotime scsi_selection_timeout_delay();
+
+	// Fast assertion period (30ns)
+	virtual attotime scsi_fast_assertion_period();
+
+	// Fast cable skew delay (5ns)
+	virtual attotime scsi_fast_cable_skew_delay();
+
+	// Fast deskew delay (20ns)
+	virtual attotime scsi_fast_deskew_delay();
+
+	// Fast hold time (10ns)
+	virtual attotime scsi_fast_hold_time();
+
+	// Fast negation period (30ns)
+	virtual attotime scsi_fast_negation_period();
+
+private:
+	enum {
+		IDLE,
+	};
+
+	enum {
+		TARGET_SELECT_WAIT_BUS_SETTLE = 1,
+		TARGET_SELECT_WAIT_SEL_0,
+
+		TARGET_NEXT_CONTROL,
+		TARGET_WAIT_MSG_BYTE,
+		TARGET_WAIT_CMD_BYTE,
+		TARGET_WAIT_DATA_IN_BYTE,
+	};
+
+	enum {
+		RECV_BYTE_T_WAIT_ACK_0 = 1,
+		RECV_BYTE_T_WAIT_ACK_1,
+		SEND_BYTE_T_WAIT_ACK_0,
+		SEND_BYTE_T_WAIT_ACK_1,
+	};
+
+	enum {
+		STATE_MASK = 0x00ff,
+		SUB_SHIFT  = 8,
+		SUB_MASK   = 0xff00,
+	};
+
+	enum {
+		BC_MSG_OR_COMMAND,
+		BC_STATUS,
+		BC_MESSAGE_1,
+		BC_MESSAGE_2,
+		BC_DATA_IN,
+		BC_DATA_OUT,
+		BC_BUS_FREE,
+	};
+
+	struct control {
+		int action;
+		int param1, param2;
+	};
+
+	emu_timer *scsi_timer;
+
+	int scsi_state, scsi_substate;
+	int scsi_initiator_id;
+	int data_buffer_id, data_buffer_size, data_buffer_pos;
+
+	control buf_control[32];
+	int buf_control_rpos;
+	int buf_control_wpos;
+
+	control *buf_control_push();
+	control *buf_control_pop();
+
+	void step(bool timeout);
+	void target_recv_byte();
+	void target_send_byte(UINT8 val);
+	void received(UINT8 val);
+	void target_send_buffer_byte();
+	bool command_done();
+};
+
+
+extern const device_type NSCSI_BUS;
+extern const device_type NSCSI_CONNECTOR;
+
+#endif
+
diff -Nru src-old/emu/machine/nscsi_cd.c src/emu/machine/nscsi_cd.c
--- src-old/emu/machine/nscsi_cd.c	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_cd.c	2012-02-09 04:41:36.000000000 +0100
@@ -0,0 +1,146 @@
+#include "machine/nscsi_cd.h"
+#include "imagedev/chd_cd.h"
+
+const device_type NSCSI_CDROM = &device_creator<nscsi_cdrom_device>;
+
+nscsi_cdrom_device::nscsi_cdrom_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+	nscsi_full_device(mconfig, NSCSI_CDROM, "SCSI CDROM", tag, owner, clock)
+{
+}
+
+void nscsi_cdrom_device::device_start()
+{
+	nscsi_full_device::device_start();
+	bytes_per_sector = 2048;
+}
+
+void nscsi_cdrom_device::device_reset()
+{
+	nscsi_full_device::device_reset();
+	cdrom = subdevice<cdrom_image_device>("image")->get_cdrom_file();
+	lba = 0;
+	blocks = 0;
+	cur_lba = -1;
+}
+
+cdrom_interface nscsi_cdrom_device::cd_intf = { 0, 0 };
+
+static MACHINE_CONFIG_FRAGMENT(scsi_cdrom)
+	MCFG_CDROM_ADD("image", nscsi_cdrom_device::cd_intf)
+MACHINE_CONFIG_END
+
+machine_config_constructor nscsi_cdrom_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME(scsi_cdrom);
+}
+
+UINT8 nscsi_cdrom_device::scsi_get_data(int id, int pos)
+{
+	if(id != 2)
+		return nscsi_full_device::scsi_get_data(id, pos);
+	int clba = lba + pos / bytes_per_sector;
+	if(clba != cur_lba) {
+		cur_lba = clba;
+		if(!cdrom_read_data(cdrom, cur_lba, block, CD_TRACK_MODE1)) {
+			logerror("%s: CD READ ERROR !\n", tag());
+			memset(block, 0, sizeof(block));
+		}
+	}
+	return block[pos & (bytes_per_sector - 1)];
+}
+
+void nscsi_cdrom_device::scsi_command()
+{
+	switch(scsi_cmdbuf[0]) {
+	case SC_TEST_UNIT_READY:
+		logerror("%s: command TEST UNIT READY\n", tag());
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_READ:
+		lba = ((scsi_cmdbuf[1] & 0x1f)<<16) | (scsi_cmdbuf[2]<<8) | scsi_cmdbuf[3];
+		blocks = scsi_cmdbuf[4];
+		if(!blocks)
+			blocks = 256;
+
+		logerror("%s: command READ start=%08x blocks=%04x\n",
+				 tag(), lba, blocks);
+
+		scsi_data_in(2, blocks*bytes_per_sector);
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_INQUIRY: {
+		int lun = get_lun(scsi_cmdbuf[1] >> 5);
+		logerror("%s: command INQUIRY lun=%d EVPD=%d page=%d alloc=%02x link=%02x\n",
+				 tag(),
+				 lun, scsi_cmdbuf[1] & 1, scsi_cmdbuf[2], scsi_cmdbuf[4], scsi_cmdbuf[5]);
+		if(lun) {
+			bad_lun();
+			return;
+		}
+
+		int page = scsi_cmdbuf[2];
+		int size = scsi_cmdbuf[4];
+		switch(page) {
+		case 0:
+			memset(scsi_cmdbuf, 0, 148);
+			scsi_cmdbuf[0] = 0x05; // device is present, device is CD/DVD (MMC-3)
+			scsi_cmdbuf[1] = 0x80; // media is removable
+			scsi_cmdbuf[2] = 0x05; // device complies with SPC-3 standard
+			scsi_cmdbuf[3] = 0x02; // response data format = SPC-3 standard
+			// some Konami games freak out if this isn't "Sony", so we'll lie
+			// this is the actual drive on my Nagano '98 board
+			strcpy((char *)&scsi_cmdbuf[8], "Sony");
+			strcpy((char *)&scsi_cmdbuf[16], "CDU-76S");
+			strcpy((char *)&scsi_cmdbuf[32], "1.0");
+			if(size > 148)
+				size = 148;
+			scsi_data_in(SBUF_MAIN, size);
+			break;
+		}
+		scsi_status_complete(SS_GOOD);
+		break;
+	}
+
+	case SC_START_STOP_UNIT:
+		logerror("%s: command START STOP UNIT\n", tag());
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_READ_CAPACITY: {
+		logerror("%s: command READ CAPACITY\n", tag());
+
+		UINT32 temp = cdrom_get_track_start(cdrom, 0xaa);
+		temp--;	// return the last used block on the disc
+
+		scsi_cmdbuf[0] = (temp>>24) & 0xff;
+		scsi_cmdbuf[1] = (temp>>16) & 0xff;
+		scsi_cmdbuf[2] = (temp>>8) & 0xff;
+		scsi_cmdbuf[3] = (temp & 0xff);
+		scsi_cmdbuf[4] = 0;
+		scsi_cmdbuf[5] = 0;
+		scsi_cmdbuf[6] = (bytes_per_sector>>8)&0xff;
+		scsi_cmdbuf[7] = (bytes_per_sector & 0xff);
+
+		scsi_data_in(SBUF_MAIN, 8);
+		scsi_status_complete(SS_GOOD);
+		break;
+	}
+
+	case SC_READ_EXTENDED:
+		lba = (scsi_cmdbuf[2]<<24) | (scsi_cmdbuf[3]<<16) | (scsi_cmdbuf[4]<<8) | scsi_cmdbuf[5];
+		blocks = (scsi_cmdbuf[7] << 8) | scsi_cmdbuf[8];
+
+		logerror("%s: command READ EXTENDED start=%08x blocks=%04x\n",
+				 tag(), lba, blocks);
+
+		scsi_data_in(2, blocks*bytes_per_sector);
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	default:
+		nscsi_full_device::scsi_command();
+		break;
+	}
+}
diff -Nru src-old/emu/machine/nscsi_cd.h src/emu/machine/nscsi_cd.h
--- src-old/emu/machine/nscsi_cd.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_cd.h	2012-02-09 04:41:36.000000000 +0100
@@ -0,0 +1,34 @@
+#ifndef __NSCSI_CD_H__
+#define __NSCSI_CD_H__
+
+#include "machine/nscsi_bus.h"
+#include "cdrom.h"
+
+#define MCFG_NSCSI_CDROM_ADD(_tag, _subtag)						\
+	MCFG_NSCSI_FULL_DEVICE_ADD(_tag, _subtag, NSCSI_CDROM, 0)
+
+class nscsi_cdrom_device : public nscsi_full_device
+{
+public:
+	nscsi_cdrom_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+	virtual machine_config_constructor device_mconfig_additions() const;
+
+	static struct cdrom_interface cd_intf;
+
+protected:
+	virtual void device_start();
+	virtual void device_reset();
+
+	virtual void scsi_command();
+	virtual UINT8 scsi_get_data(int id, int pos);
+
+private:
+	UINT8 block[2048];
+	cdrom_file *cdrom;
+	int bytes_per_sector;
+	int lba, cur_lba, blocks;
+};
+
+extern const device_type NSCSI_CDROM;
+
+#endif
diff -Nru src-old/emu/machine/nscsi_hd.c src/emu/machine/nscsi_hd.c
--- src-old/emu/machine/nscsi_hd.c	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_hd.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,155 @@
+#include "machine/nscsi_hd.h"
+#include "imagedev/harddriv.h"
+
+const device_type NSCSI_HARDDISK = &device_creator<nscsi_harddisk_device>;
+
+nscsi_harddisk_device::nscsi_harddisk_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock) :
+	nscsi_full_device(mconfig, NSCSI_HARDDISK, "SCSI HARDDISK", tag, owner, clock)
+{
+}
+
+void nscsi_harddisk_device::device_start()
+{
+	nscsi_full_device::device_start();
+}
+
+void nscsi_harddisk_device::device_reset()
+{
+	nscsi_full_device::device_reset();
+	harddisk_image_device *hd = subdevice<harddisk_image_device>("image");
+	harddisk = hd->get_hard_disk_file();
+	if(!harddisk) {
+		scsi_id = -1;
+		bytes_per_sector = 0;
+	} else {
+		const hard_disk_info *hdinfo = hard_disk_get_info(harddisk);
+		bytes_per_sector = hdinfo->sectorbytes;
+	}
+}
+
+harddisk_interface nscsi_harddisk_device::hd_intf = { 0, 0 };
+
+static MACHINE_CONFIG_FRAGMENT(scsi_harddisk)
+	MCFG_HARDDISK_CONFIG_ADD("image", nscsi_harddisk_device::hd_intf)
+MACHINE_CONFIG_END
+
+machine_config_constructor nscsi_harddisk_device::device_mconfig_additions() const
+{
+	return MACHINE_CONFIG_NAME(scsi_harddisk);
+}
+
+UINT8 nscsi_harddisk_device::scsi_get_data(int id, int pos)
+{
+	if(id != 2)
+		return nscsi_full_device::scsi_get_data(id, pos);
+	int clba = lba + pos / bytes_per_sector;
+	if(clba != cur_lba) {
+		cur_lba = clba;
+		if(!hard_disk_read(harddisk, cur_lba, block)) {
+			logerror("%s: HD READ ERROR !\n", tag());
+			memset(block, 0, sizeof(block));
+		}
+	}
+	return block[pos & (bytes_per_sector - 1)];
+}
+
+void nscsi_harddisk_device::scsi_command()
+{
+	switch(scsi_cmdbuf[0]) {
+	case SC_TEST_UNIT_READY:
+		logerror("%s: command TEST UNIT READY\n", tag());
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_READ:
+		lba = ((scsi_cmdbuf[1] & 0x1f)<<16) | (scsi_cmdbuf[2]<<8) | scsi_cmdbuf[3];
+		blocks = scsi_cmdbuf[4];
+		if(!blocks)
+			blocks = 256;
+
+		logerror("%s: command READ start=%08x blocks=%04x\n",
+				 tag(), lba, blocks);
+
+		scsi_data_in(2, blocks*bytes_per_sector);
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_INQUIRY: {
+		int lun = get_lun(scsi_cmdbuf[1] >> 5);
+		logerror("%s: INQUIRY lun=%d EVPD=%d page=%d alloc=%02x link=%02x\n",
+				 tag(),
+				 lun, scsi_cmdbuf[1] & 1, scsi_cmdbuf[2], scsi_cmdbuf[4], scsi_cmdbuf[5]);
+		if(lun) {
+			bad_lun();
+			return;
+		}
+
+		int page = scsi_cmdbuf[2];
+		int size = scsi_cmdbuf[4];
+		switch(page) {
+		case 0:
+			memset(scsi_cmdbuf, 0, 148);
+			scsi_cmdbuf[0] = 0x00; // device is direct-access (e.g. hard disk)
+			scsi_cmdbuf[1] = 0x00; // media is not removable
+			scsi_cmdbuf[2] = 0x05; // device complies with SPC-3 standard
+			scsi_cmdbuf[3] = 0x02; // response data format = SPC-3 standard
+			// Apple HD SC setup utility needs to see this
+			strcpy((char *)&scsi_cmdbuf[8], " SEAGATE");
+			strcpy((char *)&scsi_cmdbuf[16], "          ST225N");
+			strcpy((char *)&scsi_cmdbuf[32], "1.0");
+			if(size > 148)
+				size = 148;
+			scsi_data_in(0, size);
+			break;
+		}
+		scsi_status_complete(SS_GOOD);
+		break;
+	}
+
+	case SC_START_STOP_UNIT:
+		logerror("%s: command START STOP UNIT\n", tag());
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	case SC_READ_CAPACITY: {
+		logerror("%s: command READ CAPACITY\n", tag());
+
+		hard_disk_info *info;
+		UINT32 temp;
+
+		info = hard_disk_get_info(harddisk);
+
+		// get # of sectors
+		temp = info->cylinders * info->heads * info->sectors;
+		temp--;
+
+		scsi_cmdbuf[0] = (temp>>24) & 0xff;
+		scsi_cmdbuf[1] = (temp>>16) & 0xff;
+		scsi_cmdbuf[2] = (temp>>8) & 0xff;
+		scsi_cmdbuf[3] = (temp & 0xff);
+		scsi_cmdbuf[4] = (info->sectorbytes>>24)&0xff;
+		scsi_cmdbuf[5] = (info->sectorbytes>>16)&0xff;
+		scsi_cmdbuf[6] = (info->sectorbytes>>8)&0xff;
+		scsi_cmdbuf[7] = (info->sectorbytes & 0xff);
+
+		scsi_data_in(0, 8);
+		scsi_status_complete(SS_GOOD);
+		break;
+	}
+
+	case SC_READ_EXTENDED:
+		lba = (scsi_cmdbuf[2]<<24) | (scsi_cmdbuf[3]<<16) | (scsi_cmdbuf[4]<<8) | scsi_cmdbuf[5];
+		blocks = (scsi_cmdbuf[7] << 8) | scsi_cmdbuf[8];
+
+		logerror("%s: command READ EXTENDED start=%08x blocks=%04x\n",
+				 tag(), lba, blocks);
+
+		scsi_data_in(2, blocks*bytes_per_sector);
+		scsi_status_complete(SS_GOOD);
+		break;
+
+	default:
+		nscsi_full_device::scsi_command();
+		break;
+	}
+}
diff -Nru src-old/emu/machine/nscsi_hd.h src/emu/machine/nscsi_hd.h
--- src-old/emu/machine/nscsi_hd.h	1970-01-01 01:00:00.000000000 +0100
+++ src/emu/machine/nscsi_hd.h	2012-02-09 04:41:36.000000000 +0100
@@ -0,0 +1,34 @@
+#ifndef __NSCSI_HD_H__
+#define __NSCSI_HD_H__
+
+#include "machine/nscsi_bus.h"
+#include "harddisk.h"
+
+#define MCFG_NSCSI_HARDDISK_ADD(_tag, _subtag)						\
+	MCFG_NSCSI_FULL_DEVICE_ADD(_tag, _subtag, NSCSI_HARDDISK, 0)
+
+class nscsi_harddisk_device : public nscsi_full_device
+{
+public:
+	nscsi_harddisk_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	virtual machine_config_constructor device_mconfig_additions() const;
+
+	static struct harddisk_interface hd_intf;
+protected:
+	virtual void device_start();
+	virtual void device_reset();
+
+	virtual void scsi_command();
+	virtual UINT8 scsi_get_data(int id, int pos);
+
+private:
+	UINT8 block[512];
+	hard_disk_file *harddisk;
+	int lba, cur_lba, blocks;
+	int bytes_per_sector;
+};
+
+extern const device_type NSCSI_HARDDISK;
+
+#endif
diff -Nru src-old/emu/machine/pic8259.c src/emu/machine/pic8259.c
--- src-old/emu/machine/pic8259.c	2011-07-05 15:50:28.000000000 +0200
+++ src/emu/machine/pic8259.c	2012-02-14 11:57:29.000000000 +0100
@@ -146,7 +146,6 @@
 		pic8259->irq_lines &= ~mask;
 		pic8259->irr &= ~mask;
 	}
-	if (pic8259->mode & 0x02) pic8259->irr = pic8259->irq_lines;
 	pic8259_set_timer(pic8259);
 }
 
@@ -309,6 +308,8 @@
 								if (pic8259->isr & mask)
 								{
 									pic8259->isr &= ~mask;
+									if (pic8259->level_trig_mode)
+										pic8259->irr = pic8259->irq_lines;
 									pic8259->irr &= ~mask;
 									break;
 								}
@@ -343,6 +344,8 @@
 							if( pic8259->isr & mask )
 							{
 								pic8259->isr &= ~mask;
+								if (pic8259->level_trig_mode)
+									pic8259->irr = pic8259->irq_lines;
 								pic8259->irr &= ~mask;
 								pic8259->prio = (pic8259->prio + 1) & 7;
 							}
diff -Nru src-old/emu/machine/pls100.c src/emu/machine/pls100.c
--- src-old/emu/machine/pls100.c	2012-02-05 17:12:48.000000000 +0100
+++ src/emu/machine/pls100.c	2012-02-06 18:41:05.000000000 +0100
@@ -1,6 +1,6 @@
 /**********************************************************************
 
-    PLS100 16xPAL_TERMSx8 Programmable Logic Array emulation
+    PLS100 16x48x8 Programmable Logic Array emulation
 
     Copyright MESS Team.
     Visit http://mamedev.org for licensing and usage restrictions.
diff -Nru src-old/emu/machine/pls100.h src/emu/machine/pls100.h
--- src-old/emu/machine/pls100.h	2012-02-05 17:12:48.000000000 +0100
+++ src/emu/machine/pls100.h	2012-02-06 18:41:05.000000000 +0100
@@ -19,12 +19,11 @@
                     F7  10 |             | 19  _CE
                     F6  11 |             | 18  F0
                     F5  12 |             | 17  F1
-                    F4  13 |             | PAL_OUTPUTS  F2
+                    F4  13 |             | 16  F2
                    GND  14 |_____________| 15  F3
 
 **********************************************************************/
 
-
 #pragma once
 
 #ifndef __PLS100__
diff -Nru src-old/emu/machine.c src/emu/machine.c
--- src-old/emu/machine.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/machine.c	2012-02-06 02:30:22.000000000 +0100
@@ -105,12 +105,8 @@
 #include "osdepend.h"
 #include "config.h"
 #include "debugger.h"
-#include "image.h"
-#include "profiler.h"
 #include "render.h"
 #include "cheat.h"
-#include "ui.h"
-#include "uimenu.h"
 #include "uimain.h"
 #include "uiinput.h"
 #include "crsshair.h"
diff -Nru src-old/emu/mame.c src/emu/mame.c
--- src-old/emu/mame.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/mame.c	2012-02-06 02:30:22.000000000 +0100
@@ -77,12 +77,9 @@
 #include "osdepend.h"
 #include "config.h"
 #include "debugger.h"
-#include "image.h"
-#include "profiler.h"
 #include "render.h"
 #include "cheat.h"
 #include "ui.h"
-#include "uimenu.h"
 #include "uiinput.h"
 #include "crsshair.h"
 #include "validity.h"
diff -Nru src-old/emu/mconfig.c src/emu/mconfig.c
--- src-old/emu/mconfig.c	2012-02-05 08:00:09.000000000 +0100
+++ src/emu/mconfig.c	2012-02-11 17:15:39.000000000 +0100
@@ -141,6 +141,33 @@
 
 device_t *machine_config::device_add(device_t *owner, const char *tag, device_type type, UINT32 clock)
 {
+	const char *orig_tag = tag;
+
+	// if the device path is absolute, start from the root
+	if (tag[0] == ':')
+	{
+		tag++;
+		owner = m_root_device;
+	}
+
+	// go down the path until we're done with it
+	while (strchr(tag, ':'))
+	{
+		const char *next = strchr(tag, ':');
+		assert(next != tag);
+		astring part(tag, next-tag);
+		device_t *curdevice;
+		for (curdevice = owner->m_subdevice_list.first(); curdevice != NULL; curdevice = curdevice->next())
+			if (part == curdevice->m_basetag)
+				break;
+		if (!curdevice)
+			throw emu_fatalerror("Could not find %s when looking up path for device %s\n",
+								 part.cstr(), orig_tag);
+		owner = curdevice;
+		tag = next+1;
+	}
+	assert(tag[0]);
+
 	// if there's an owner, let the owner do the work
 	if (owner != NULL)
 		return owner->add_subdevice(type, tag, clock);
diff -Nru src-old/emu/mconfig.h src/emu/mconfig.h
--- src-old/emu/mconfig.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/mconfig.h	2012-02-11 17:15:39.000000000 +0100
@@ -51,8 +51,8 @@
 //  CONSTANTS
 //**************************************************************************
 
-// by convention, tags should all lowercase and between 2-15 characters
-#define MIN_TAG_LENGTH			2
+// by convention, tags should all lowercase and between 1-15 characters
+#define MIN_TAG_LENGTH			1
 #define MAX_TAG_LENGTH			15
 
 
diff -Nru src-old/emu/memory.c src/emu/memory.c
--- src-old/emu/memory.c	2012-01-29 17:34:26.000000000 +0100
+++ src/emu/memory.c	2012-02-06 02:30:22.000000000 +0100
@@ -204,7 +204,6 @@
 #include <map>
 
 #include "emu.h"
-#include "profiler.h"
 #include "debug/debugcpu.h"
 
 
diff -Nru src-old/emu/rendlay.c src/emu/rendlay.c
--- src-old/emu/rendlay.c	2012-02-05 06:15:21.000000000 +0100
+++ src/emu/rendlay.c	2012-02-11 17:53:30.000000000 +0100
@@ -81,7 +81,6 @@
 #include "rendfont.h"
 #include "rendlay.h"
 #include "rendutil.h"
-#include "output.h"
 #include "xmlfile.h"
 #include "png.h"
 
@@ -626,6 +625,7 @@
 	{
 		m_type = CTYPE_TEXT;
 		m_string = xml_get_attribute_string_with_subst(machine, compnode, "string", "");
+		m_textalign = xml_get_attribute_int_with_subst(machine, compnode, "align", 0);
 	}
 
 	// dotmatrix nodes
@@ -847,7 +847,26 @@
 			break;
 		aspect *= 0.9f;
 	}
-	INT32 curx = bounds.min_x + (bounds.width() - width) / 2;
+
+	// get alignment
+	INT32 curx;
+	switch (m_textalign)
+	{
+		// left
+		case 1:
+			curx = bounds.min_x;
+			break;
+
+		// right
+		case 2:
+			curx = bounds.max_x - width;
+			break;
+
+		// default to center
+		default:
+			curx = bounds.min_x + (bounds.width() - width) / 2;
+			break;
+	}
 
 	// allocate a temporary bitmap
 	bitmap_argb32 tempbitmap(dest.width(), dest.height());
diff -Nru src-old/emu/rendlay.h src/emu/rendlay.h
--- src-old/emu/rendlay.h	2012-01-12 22:19:49.000000000 +0100
+++ src/emu/rendlay.h	2012-02-11 17:53:30.000000000 +0100
@@ -152,6 +152,7 @@
 		render_bounds		m_bounds;		// bounds of the element
 		render_color		m_color;		// color of the element
 		astring				m_string;		// string for text components
+		int					m_textalign;	// text alignment to box
 		bitmap_argb32		m_bitmap;		// source bitmap for images
 		astring				m_dirname;		// directory name of image file (for lazy loading)
 		emu_file *			m_file;			// file object for reading image/alpha files
diff -Nru src-old/emu/romload.c src/emu/romload.c
--- src-old/emu/romload.c	2012-01-30 15:32:31.000000000 +0100
+++ src/emu/romload.c	2012-02-19 16:23:23.000000000 +0100
@@ -11,7 +11,6 @@
 
 #include "emu.h"
 #include "emuopts.h"
-#include "hash.h"
 #include "png.h"
 #include "harddisk.h"
 #include "config.h"
@@ -39,33 +38,21 @@
 	friend class simple_list<open_chd>;
 
 public:
-	open_chd(const char *region, emu_file &file, chd_file &chdfile, emu_file *difffile = NULL, chd_file *diffchd = NULL)
+	open_chd(const char *region)
 		: m_next(NULL),
-		  m_region(region),
-		  m_origchd(&chdfile),
-		  m_origfile(&file),
-		  m_diffchd(diffchd),
-		  m_difffile(difffile) { }
-
-	~open_chd()
-	{
-		if (m_diffchd != NULL) chd_close(m_diffchd);
-		global_free(m_difffile);
-		chd_close(m_origchd);
-		global_free(m_origfile);
-	}
+		  m_region(region) { }
 
 	open_chd *next() const { return m_next; }
 	const char *region() const { return m_region; }
-	chd_file *chd() const { return (m_diffchd != NULL) ? m_diffchd : m_origchd; }
+	chd_file &chd() { return m_diffchd.opened() ? m_diffchd : m_origchd; }
+	chd_file &orig_chd() { return m_origchd; }
+	chd_file &diff_chd() { return m_diffchd; }
 
 private:
 	open_chd *			m_next;					/* pointer to next in the list */
 	astring				m_region;				/* disk region we came from */
-	chd_file *			m_origchd;				/* handle to the original CHD */
-	emu_file *			m_origfile;				/* file handle to the original CHD file */
-	chd_file *			m_diffchd;				/* handle to the diff CHD */
-	emu_file *			m_difffile;				/* file handle to the diff CHD file */
+	chd_file			m_origchd;				/* handle to the original CHD */
+	chd_file			m_diffchd;				/* handle to the diff CHD */
 };
 
 
@@ -106,21 +93,15 @@
     HELPERS (also used by devimage.c)
  ***************************************************************************/
 
-file_error common_process_file(emu_options &options, const char *location, const char *ext, const rom_entry *romp, emu_file **image_file)
+file_error common_process_file(emu_options &options, const char *location, const char *ext, const rom_entry *romp, emu_file &image_file)
 {
-	*image_file = global_alloc(emu_file(options.media_path(), OPEN_FLAG_READ));
 	file_error filerr;
 
 	if (location != NULL && strcmp(location, "") != 0)
-		filerr = (*image_file)->open(location, PATH_SEPARATOR, ROM_GETNAME(romp), ext);
+		filerr = image_file.open(location, PATH_SEPARATOR, ROM_GETNAME(romp), ext);
 	else
-		filerr = (*image_file)->open(ROM_GETNAME(romp), ext);
+		filerr = image_file.open(ROM_GETNAME(romp), ext);
 
-	if (filerr != FILERR_NONE)
-	{
-		global_free(*image_file);
-		*image_file = NULL;
-	}
 	return filerr;
 }
 
@@ -156,7 +137,7 @@
 {
 	for (open_chd *curdisk = machine.romload_data->chd_list.first(); curdisk != NULL; curdisk = curdisk->next())
 		if (strcmp(curdisk->region(), region) == 0)
-			return curdisk->chd();
+			return &curdisk->chd();
 	return NULL;
 }
 
@@ -166,9 +147,15 @@
     file associated with the given region
 -------------------------------------------------*/
 
-void set_disk_handle(running_machine &machine, const char *region, emu_file &file, chd_file &chdfile)
+int set_disk_handle(running_machine &machine, const char *region, const char *fullpath)
 {
-	machine.romload_data->chd_list.append(*global_alloc(open_chd(region, file, chdfile)));
+	open_chd *chd = global_alloc(open_chd(region));
+	chd_error err = chd->orig_chd().open(fullpath);
+	if (err == CHDERR_NONE)
+		machine.romload_data->chd_list.append(*chd);
+	else
+		global_free(chd);
+	return err;
 }
 
 
@@ -468,14 +455,15 @@
 	astring tempstr;
 	romdata->errorstring.catprintf("    EXPECTED: %s\n", hashes.macro_string(tempstr));
 	romdata->errorstring.catprintf("       FOUND: %s\n", acthashes.macro_string(tempstr));
-
-	// warn about any ill-formed hashes
-	for (hash_base *hash = hashes.first(); hash != NULL; hash = hash->next())
-		if (hash->parse_error())
-		{
-			romdata->errorstring.catprintf("\tInvalid %s checksum treated as 0 (check leading zeros)\n", hash->name());
-			romdata->warnings++;
-		}
+/*
+    // warn about any ill-formed hashes
+    for (hash_base *hash = hashes.first(); hash != NULL; hash = hash->next())
+        if (hash->parse_error())
+        {
+            romdata->errorstring.catprintf("\tInvalid %s checksum treated as 0 (check leading zeros)\n", hash->name());
+            romdata->warnings++;
+        }
+*/
 }
 
 
@@ -1011,16 +999,14 @@
     checksum
 -------------------------------------------------*/
 
-chd_error open_disk_image(emu_options &options, const game_driver *gamedrv, const rom_entry *romp, emu_file **image_file, chd_file **image_chd, const char *locationtag)
+int open_disk_image(emu_options &options, const game_driver *gamedrv, const rom_entry *romp, chd_file &image_chd, const char *locationtag)
 {
+	emu_file image_file(options.media_path(), OPEN_FLAG_READ);
 	const rom_entry *region, *rom;
 	const rom_source *source;
 	file_error filerr;
 	chd_error err;
 
-	*image_file = NULL;
-	*image_chd = NULL;
-
 	/* attempt to open the properly named file, scanning up through parent directories */
 	filerr = FILERR_NOT_FOUND;
 	for (int searchdrv = driver_list::find(*gamedrv); searchdrv != -1 && filerr != FILERR_NONE; searchdrv = driver_list::clone(searchdrv))
@@ -1104,14 +1090,13 @@
 	/* did the file open succeed? */
 	if (filerr == FILERR_NONE)
 	{
+		astring fullpath(image_file.fullpath());
+		image_file.close();
+
 		/* try to open the CHD */
-		err = chd_open_file(**image_file, CHD_OPEN_READ, NULL, image_chd);
+		err = image_chd.open(fullpath);
 		if (err == CHDERR_NONE)
 			return err;
-
-		/* close the file on failure */
-		global_free(*image_file);
-		*image_file = NULL;
 	}
 	else
 		err = CHDERR_FILE_NOT_FOUND;
@@ -1142,18 +1127,16 @@
 							/* did the file open succeed? */
 							if (filerr == FILERR_NONE)
 							{
+								astring fullpath(image_file.fullpath());
+								image_file.close();
+
 								/* try to open the CHD */
-								err = chd_open_file(**image_file, CHD_OPEN_READ, NULL, image_chd);
+								err = image_chd.open(fullpath);
 								if (err == CHDERR_NONE)
 									return err;
-
-								/* close the file on failure */
-								global_free(*image_file);
-								*image_file = NULL;
 							}
 						}
 	}
-
 	return err;
 }
 
@@ -1162,48 +1145,43 @@
     open_disk_diff - open a DISK diff file
 -------------------------------------------------*/
 
-static chd_error open_disk_diff(emu_options &options, const rom_entry *romp, chd_file *source, emu_file **diff_file, chd_file **diff_chd)
+static chd_error open_disk_diff(emu_options &options, const rom_entry *romp, chd_file &source, chd_file &diff_chd)
 {
 	astring fname(ROM_GETNAME(romp), ".dif");
-	chd_error err;
-
-	*diff_file = NULL;
-	*diff_chd = NULL;
 
 	/* try to open the diff */
 	LOG(("Opening differencing image file: %s\n", fname.cstr()));
-	*diff_file = global_alloc(emu_file(options.diff_directory(), OPEN_FLAG_READ | OPEN_FLAG_WRITE));
-	file_error filerr = (*diff_file)->open(fname);
-	if (filerr != FILERR_NONE)
+	emu_file diff_file(options.diff_directory(), OPEN_FLAG_READ | OPEN_FLAG_WRITE);
+	file_error filerr = diff_file.open(fname);
+	if (filerr == FILERR_NONE)
 	{
-		/* didn't work; try creating it instead */
-		LOG(("Creating differencing image: %s\n", fname.cstr()));
-		(*diff_file)->set_openflags(OPEN_FLAG_READ | OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
-		filerr = (*diff_file)->open(fname);
-		if (filerr != FILERR_NONE)
-		{
-			err = CHDERR_FILE_NOT_FOUND;
-			goto done;
-		}
+		astring fullpath(diff_file.fullpath());
+		diff_file.close();
 
-		/* create the CHD */
-		err = chd_create_file(**diff_file, 0, 0, CHDCOMPRESSION_NONE, source);
-		if (err != CHDERR_NONE)
-			goto done;
+		LOG(("Opening differencing image file: %s\n", fullpath.cstr()));
+		return diff_chd.open(fullpath, true, &source);
 	}
 
-	LOG(("Opening differencing image file: %s\n", fname.cstr()));
-	err = chd_open_file(**diff_file, CHD_OPEN_READWRITE, source, diff_chd);
-	if (err != CHDERR_NONE)
-		goto done;
-
-done:
-	if ((err != CHDERR_NONE) && (*diff_file != NULL))
+	/* didn't work; try creating it instead */
+	LOG(("Creating differencing image: %s\n", fname.cstr()));
+	diff_file.set_openflags(OPEN_FLAG_READ | OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
+	filerr = diff_file.open(fname);
+	if (filerr == FILERR_NONE)
 	{
-		global_free(*diff_file);
-		*diff_file = NULL;
+		astring fullpath(diff_file.fullpath());
+		diff_file.close();
+
+		/* create the CHD */
+		LOG(("Creating differencing image file: %s\n", fullpath.cstr()));
+		chd_codec_type compression[4] = { CHD_CODEC_NONE };
+		chd_error err = diff_chd.create(fullpath, source.logical_bytes(), source.hunk_bytes(), compression, source);
+		if (err != CHDERR_NONE)
+			return err;
+
+		return diff_chd.clone_all_metadata(source);
 	}
-	return err;
+
+	return CHDERR_FILE_NOT_FOUND;
 }
 
 
@@ -1220,24 +1198,23 @@
 		/* handle files */
 		if (ROMENTRY_ISFILE(romp))
 		{
+			open_chd *chd = global_alloc(open_chd(regiontag));
+
 			hash_collection hashes(ROM_GETHASHDATA(romp));
-			chd_header header;
 			chd_error err;
 
 			/* make the filename of the source */
 			astring filename(ROM_GETNAME(romp), ".chd");
 
 			/* first open the source drive */
-			chd_file *origchd;
-			emu_file *origfile;
 			LOG(("Opening disk image: %s\n", filename.cstr()));
-			err = open_disk_image(romdata->machine().options(), &romdata->machine().system(), romp, &origfile, &origchd, locationtag);
+			err = chd_error(open_disk_image(romdata->machine().options(), &romdata->machine().system(), romp, chd->orig_chd(), locationtag));
 			if (err != CHDERR_NONE)
 			{
 				if (err == CHDERR_FILE_NOT_FOUND)
 					romdata->errorstring.catprintf("%s NOT FOUND\n", filename.cstr());
 				else
-					romdata->errorstring.catprintf("%s CHD ERROR: %s\n", filename.cstr(), chd_error_string(err));
+					romdata->errorstring.catprintf("%s CHD ERROR: %s\n", filename.cstr(), chd_file::error_string(err));
 
 				/* if this is NO_DUMP, keep going, though the system may not be able to handle it */
 				if (hashes.flag(hash_collection::FLAG_NO_DUMP))
@@ -1246,13 +1223,13 @@
 					romdata->warnings++;
 				else
 					romdata->errors++;
+				global_free(chd);
 				continue;
 			}
 
 			/* get the header and extract the SHA1 */
-			header = *chd_get_header(origchd);
 			hash_collection acthashes;
-			acthashes.add_from_buffer(hash_collection::HASH_SHA1, header.sha1, sizeof(header.sha1));
+			acthashes.add_sha1(chd->orig_chd().sha1());
 
 			/* verify the hash */
 			if (hashes != acthashes)
@@ -1268,23 +1245,22 @@
 			}
 
 			/* if not read-only, make the diff file */
-			chd_file *diffchd = NULL;
-			emu_file *difffile = NULL;
 			if (!DISK_ISREADONLY(romp))
 			{
 				/* try to open or create the diff */
-				err = open_disk_diff(romdata->machine().options(), romp, origchd, &difffile, &diffchd);
+				err = open_disk_diff(romdata->machine().options(), romp, chd->orig_chd(), chd->diff_chd());
 				if (err != CHDERR_NONE)
 				{
-					romdata->errorstring.catprintf("%s DIFF CHD ERROR: %s\n", filename.cstr(), chd_error_string(err));
+					romdata->errorstring.catprintf("%s DIFF CHD ERROR: %s\n", filename.cstr(), chd_file::error_string(err));
 					romdata->errors++;
+					global_free(chd);
 					continue;
 				}
 			}
 
 			/* we're okay, add to the list of disks */
 			LOG(("Assigning to handle %d\n", DISK_GETINDEX(romp)));
-			romdata->machine().romload_data->chd_list.append(*global_alloc(open_chd(regiontag, *origfile, *origchd, difffile, diffchd)));
+			romdata->machine().romload_data->chd_list.append(*chd);
 		}
 	}
 }
diff -Nru src-old/emu/romload.h src/emu/romload.h
--- src-old/emu/romload.h	2011-08-02 16:09:21.000000000 +0200
+++ src/emu/romload.h	2012-02-16 10:47:18.000000000 +0100
@@ -121,6 +121,7 @@
 
 class machine_config;
 class emu_options;
+class chd_file;
 
 typedef device_t rom_source;
 
@@ -315,13 +316,13 @@
 /* ----- disk handling ----- */
 
 /* open a disk image, searching up the parent and loading by checksum */
-chd_error open_disk_image(emu_options &options, const game_driver *gamedrv, const rom_entry *romp, emu_file **image_file, chd_file **image_chd,const char *locationtag);
+int open_disk_image(emu_options &options, const game_driver *gamedrv, const rom_entry *romp, chd_file &image_chd, const char *locationtag);
 
 /* return a pointer to the CHD file associated with the given region */
 chd_file *get_disk_handle(running_machine &machine, const char *region);
 
 /* set a pointer to the CHD file associated with the given region */
-void set_disk_handle(running_machine &machine, const char *region, emu_file &file, chd_file &chdfile);
+int set_disk_handle(running_machine &machine, const char *region, const char *fullpath);
 
 void load_software_part_region(device_t *device, char *swlist, char *swname, rom_entry *start_region);
 
diff -Nru src-old/emu/schedule.c src/emu/schedule.c
--- src-old/emu/schedule.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/schedule.c	2012-02-06 02:30:22.000000000 +0100
@@ -38,7 +38,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "debugger.h"
 
 
diff -Nru src-old/emu/softlist.c src/emu/softlist.c
--- src-old/emu/softlist.c	2012-02-05 10:15:57.000000000 +0100
+++ src/emu/softlist.c	2012-02-06 02:30:22.000000000 +0100
@@ -10,7 +10,6 @@
 #include "emu.h"
 #include "pool.h"
 #include "emuopts.h"
-#include "hash.h"
 #include "softlist.h"
 #include "clifront.h"
 
diff -Nru src-old/emu/sound/samples.c src/emu/sound/samples.c
--- src-old/emu/sound/samples.c	2012-02-05 16:14:28.000000000 +0100
+++ src/emu/sound/samples.c	2012-02-19 16:23:23.000000000 +0100
@@ -1,755 +1,650 @@
-/* samples.c
+/***************************************************************************
 
- Playback of pre-recorded samples. Used for high-level simulation of discrete sound circuits
- where proper low-level simulation isn't available.  Also used for tape loops and similar.
+    samples.c
 
- Current limitations
-  - Only supports single channel samples!
+    Sound device for sample playback.
 
- Considerations
-  - Maybe this should be part of the presentation layer (artwork etc.) with samples specified
-    in .lay files instead of in drivers?
+****************************************************************************
 
-*/
+    Playback of pre-recorded samples. Used for high-level simulation of
+    discrete sound circuits where proper low-level simulation isn't
+    available.  Also used for tape loops and similar.
+
+    Current limitations
+      - Only supports single channel samples!
+
+    Considerations
+      - Maybe this should be part of the presentation layer
+        (artwork etc.) with samples specified in .lay files instead of
+        in drivers?
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
+***************************************************************************/
 
 #include "emu.h"
 #include "emuopts.h"
 #include "samples.h"
-#include "../../lib/libflac/include/flac/all.h"
-
-typedef struct _sample_channel sample_channel;
-struct _sample_channel
-{
-	sound_stream *stream;
-	const INT16 *source;
-	INT32		source_length;
-	INT32		source_num;
-	UINT32		pos;
-	UINT32		frac;
-	UINT32		step;
-	UINT32		basefreq;
-	UINT8		loop;
-	UINT8		paused;
-};
-
-
-typedef struct _samples_info samples_info;
-struct _samples_info
-{
-	device_t *device;
-	int			numchannels;	/* how many channels */
-	sample_channel *channel;/* array of channels */
-	loaded_samples *samples;/* array of samples */
-};
+#include "flac.h"
 
 
-INLINE samples_info *get_safe_token(device_t *device)
-{
-	assert(device != NULL);
-	assert(device->type() == SAMPLES);
-	return (samples_info *)downcast<legacy_device_base *>(device)->token();
-}
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
+// device type definition
+const device_type SAMPLES = &device_creator<samples_device>;
 
 
-#define FRAC_BITS		24
-#define FRAC_ONE		(1 << FRAC_BITS)
-#define FRAC_MASK		(FRAC_ONE - 1)
-#define MAX_CHANNELS    100
 
-struct flac_reader
-{
-	UINT8* rawdata;
-	INT16* write_data;
-	int position;
-	int length;
-	int decoded_size;
-	int sample_rate;
-	int channels;
-	int bits_per_sample;
-	int total_samples;
-	int write_position;
-} flacread;
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
 
-static flac_reader* flacreadptr;
+//-------------------------------------------------
+//  samples_device - constructors
+//-------------------------------------------------
 
-void my_error_callback(const FLAC__StreamDecoder * decoder, FLAC__StreamDecoderErrorStatus status, void * client_data)
+samples_device::samples_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, SAMPLES, "Samples", tag, owner, clock),
+	  device_sound_interface(mconfig, *this)
 {
-	fatalerror("FLAC error Callback\n");
 }
 
-void my_metadata_callback(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)
+samples_device::samples_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock)
+	: device_t(mconfig, type, name, tag, owner, clock),
+	  device_sound_interface(mconfig, *this)
 {
+}
 
-	flac_reader* flacrd =  ((flac_reader*)client_data);
 
-	if (metadata->type==0)
-	{
-		const FLAC__StreamMetadata_StreamInfo *streaminfo = &(metadata->data.stream_info);
+//-------------------------------------------------
+//  static_set_interface - configuration helper
+//  to set the interface
+//-------------------------------------------------
 
-		flacrd->sample_rate = streaminfo->sample_rate;
-		flacrd->channels = streaminfo->channels;
-		flacrd->bits_per_sample = streaminfo->bits_per_sample;
-		flacrd->total_samples = streaminfo->total_samples;
-	}
+void samples_device::static_set_interface(device_t &device, const samples_interface &interface)
+{
+	samples_device &samples = downcast<samples_device &>(device);
+	static_cast<samples_interface &>(samples) = interface;
 }
 
 
 
+//**************************************************************************
+//  PUBLIC INTERFACE
+//**************************************************************************
 
-FLAC__StreamDecoderReadStatus my_read_callback(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
-{
-	flac_reader* flacrd =  ((flac_reader*)client_data);
-
-	if(*bytes > 0)
-	{
-		if (*bytes <=  flacrd->length)
-		{
-			memcpy(buffer, flacrd->rawdata+flacrd->position, *bytes);
-			flacrd->position+=*bytes;
-			flacrd->length-=*bytes;
-			return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
-		}
-		else
-		{
-			memcpy(buffer, flacrd->rawdata+flacrd->position,  flacrd->length);
-		    flacrd->position+= flacrd->length;
-			flacrd->length = 0;
+//-------------------------------------------------
+//  start - start playing a loaded sample
+//-------------------------------------------------
 
-			return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
-		}
-	}
-	else
-	{
-		return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
-	}
+void samples_device::start(UINT8 channel, UINT32 samplenum, bool loop)
+{
+	// if samples are disabled, just return quietly
+	if (m_sample.count() == 0)
+		return;
 
-	if ( flacrd->length==0)
-	{
-		return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
-	}
+    assert(samplenum < m_sample.count());
+    assert(channel < m_channels);
 
-	return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+	chan.stream->update();
 
+	// update the parameters
+	loaded_sample &sample = m_sample[samplenum];
+	chan.source = sample.data;
+	chan.source_length = sample.length;
+	chan.source_num = (sample.data.count() > 0) ? samplenum : -1;
+	chan.pos = 0;
+	chan.frac = 0;
+	chan.basefreq = sample.frequency;
+	chan.step = (INT64(chan.basefreq) << FRAC_BITS) / machine().sample_rate();
+	chan.loop = loop;
 }
 
-FLAC__StreamDecoderWriteStatus my_write_callback(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 *const buffer[], void *client_data)
-{
-	flac_reader* flacrd =  ((flac_reader*)client_data);
 
-	flacrd->decoded_size += frame->header.blocksize;
+//-------------------------------------------------
+//  start_raw - start playing an externally
+//  provided sample
+//-------------------------------------------------
 
-	for (int i=0;i<frame->header.blocksize;i++)
-	{
-		flacrd->write_data[i+flacrd->write_position] = buffer[0][i];
-	}
+void samples_device::start_raw(UINT8 channel, const INT16 *sampledata, UINT32 samples, UINT32 frequency, bool loop)
+{
+    assert(channel < m_channels);
 
-	flacrd->write_position +=  frame->header.blocksize;
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+	chan.stream->update();
 
-	return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+	// update the parameters
+	chan.source = sampledata;
+	chan.source_length = samples;
+	chan.source_num = -1;
+	chan.pos = 0;
+	chan.frac = 0;
+	chan.basefreq = frequency;
+	chan.step = (INT64(chan.basefreq) << FRAC_BITS) / machine().sample_rate();
+	chan.loop = loop;
 }
 
 
+//-------------------------------------------------
+//  set_frequency - set the playback frequency of
+//  a sample
+//-------------------------------------------------
 
+void samples_device::set_frequency(UINT8 channel, UINT32 freq)
+{
+    assert(channel < m_channels);
 
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+	chan.stream->update();
+	chan.step = (INT64(freq) << FRAC_BITS) / machine().sample_rate();
+}
 
 
-/*-------------------------------------------------
-    read_wav_sample - read a WAV file as a sample
--------------------------------------------------*/
+//-------------------------------------------------
+//  set_volume - set the playback volume of a
+//  sample
+//-------------------------------------------------
 
-static int read_wav_sample(running_machine &machine, emu_file &file, loaded_sample *sample, char* filename)
+void samples_device::set_volume(UINT8 channel, float volume)
 {
-	unsigned long offset = 0;
-	UINT32 length, rate, filesize;
-	UINT16 bits, temp16;
-	char buf[32];
-	UINT32 sindex;
-	int type = 0;
+    assert(channel < m_channels);
 
-	/* read the core header and make sure it's a WAVE file */
-	offset += file.read(buf, 4);
-	if (offset < 4)
-	{
-		mame_printf_warning("unable to read %s, 0-byte file?\n", filename);
-		return 0;
-	}
-	if (memcmp(&buf[0], "RIFF", 4) == 0)
-		type = 1;
-	else if (memcmp(&buf[0], "fLaC", 4) == 0)
-		type = 2;
-	else
-	{
-		mame_printf_warning("unable to read %s, corrupt file?\n", filename);
-		return 0;
-	}
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+	chan.stream->set_output_gain(0, volume);
+}
 
-	if (type==1)
-	{
-		/* get the total size */
-		offset += file.read(&filesize, 4);
-		if (offset < 8)
-			return 0;
-		filesize = LITTLE_ENDIANIZE_INT32(filesize);
 
-		/* read the RIFF file type and make sure it's a WAVE file */
-		offset += file.read(buf, 4);
-		if (offset < 12)
-			return 0;
-		if (memcmp(&buf[0], "WAVE", 4) != 0)
-			return 0;
+//-------------------------------------------------
+//  pause - pause playback on a channel
+//-------------------------------------------------
 
-		/* seek until we find a format tag */
-		while (1)
-		{
-			offset += file.read(buf, 4);
-			offset += file.read(&length, 4);
-			length = LITTLE_ENDIANIZE_INT32(length);
-			if (memcmp(&buf[0], "fmt ", 4) == 0)
-				break;
-
-			/* seek to the next block */
-			file.seek(length, SEEK_CUR);
-			offset += length;
-			if (offset >= filesize)
-				return 0;
-		}
-
-		/* read the format -- make sure it is PCM */
-		offset += file.read(&temp16, 2);
-		temp16 = LITTLE_ENDIANIZE_INT16(temp16);
-		if (temp16 != 1)
-			return 0;
-
-		/* number of channels -- only mono is supported */
-		offset += file.read(&temp16, 2);
-		temp16 = LITTLE_ENDIANIZE_INT16(temp16);
-		if (temp16 != 1)
-			return 0;
-
-		/* sample rate */
-		offset += file.read(&rate, 4);
-		rate = LITTLE_ENDIANIZE_INT32(rate);
-
-		/* bytes/second and block alignment are ignored */
-		offset += file.read(buf, 6);
-
-		/* bits/sample */
-		offset += file.read(&bits, 2);
-		bits = LITTLE_ENDIANIZE_INT16(bits);
-		if (bits != 8 && bits != 16)
-			return 0;
-
-		/* seek past any extra data */
-		file.seek(length - 16, SEEK_CUR);
-		offset += length - 16;
+void samples_device::pause(UINT8 channel, bool pause)
+{
+    assert(channel < m_channels);
 
-		/* seek until we find a data tag */
-		while (1)
-		{
-			offset += file.read(buf, 4);
-			offset += file.read(&length, 4);
-			length = LITTLE_ENDIANIZE_INT32(length);
-			if (memcmp(&buf[0], "data", 4) == 0)
-				break;
-
-			/* seek to the next block */
-			file.seek(length, SEEK_CUR);
-			offset += length;
-			if (offset >= filesize)
-				return 0;
-		}
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+	chan.paused = pause;
+}
 
-		/* if there was a 0 length data block, we're done */
-		if (length == 0)
-			return 0;
-
-		/* fill in the sample data */
-		sample->length = length;
-		sample->frequency = rate;
 
-		/* read the data in */
-		if (bits == 8)
-		{
-			unsigned char *tempptr;
-			int sindex;
+//-------------------------------------------------
+//  stop - stop playback on a channel
+//-------------------------------------------------
 
-			sample->data = auto_alloc_array(machine, INT16, length);
-			file.read(sample->data, length);
+void samples_device::stop(UINT8 channel)
+{
+    assert(channel < m_channels);
 
-			/* convert 8-bit data to signed samples */
-			tempptr = (unsigned char *)sample->data;
-			for (sindex = length - 1; sindex >= 0; sindex--)
-				sample->data[sindex] = (INT8)(tempptr[sindex] ^ 0x80) * 256;
+	// force an update before we start
+    channel_t &chan = m_channel[channel];
+    chan.source = NULL;
+    chan.source_num = -1;
+}
 
-		}
-		else
-		{
-			/* 16-bit data is fine as-is */
-			sample->data = auto_alloc_array(machine, INT16, length/2);
-			file.read(sample->data, length);
-
-				sample->length /= 2;
-			if (ENDIANNESS_NATIVE != ENDIANNESS_LITTLE)
-				for (sindex = 0; sindex < sample->length; sindex++)
-					sample->data[sindex] = LITTLE_ENDIANIZE_INT16(sample->data[sindex]);
-		}
-	}
-	else
-	{
-		int length;
 
-		file.seek(0, SEEK_END);
-		length = file.tell();
-		file.seek(0, 0);
+//-------------------------------------------------
+//  stop_all - stop playback on all channels
+//-------------------------------------------------
 
-		flacread.rawdata = auto_alloc_array(machine, UINT8, length);
-		flacread.length = length;
-		flacread.position = 0;
-		flacread.decoded_size = 0;
+void samples_device::stop_all()
+{
+	// just iterate over channels and stop them
+	for (UINT8 channel = 0; channel < m_channels; channel++)
+		stop(channel);
+}
 
-		flacreadptr = &flacread;
 
-		file.read(flacread.rawdata, length);
+//-------------------------------------------------
+//  base_frequency - return the base frequency of
+//  a channel being played
+//-------------------------------------------------
 
-		FLAC__StreamDecoder *decoder = FLAC__stream_decoder_new();
+UINT32 samples_device::base_frequency(UINT8 channel) const
+{
+    assert(channel < m_channels);
 
-		if (!decoder)
-			fatalerror("Fail FLAC__stream_decoder_new\n");
+	// force an update before we start
+    const channel_t &chan = m_channel[channel];
+	chan.stream->update();
+	return chan.basefreq;
+}
 
-		if(FLAC__stream_decoder_init_stream(
-			decoder,
-			my_read_callback,
-			NULL, //my_seek_callback,      // or NULL
-			NULL, //my_tell_callback,      // or NULL
-			NULL, //my_length_callback,    // or NULL
-			NULL, //my_eof_callback,       // or NULL
-			my_write_callback,
-			my_metadata_callback, //my_metadata_callback,  // or NULL
-			my_error_callback,
-			(void*)flacreadptr /*my_client_data*/ ) != FLAC__STREAM_DECODER_INIT_STATUS_OK)
-			fatalerror("Fail FLAC__stream_decoder_init_stream\n");
 
-		if (FLAC__stream_decoder_process_until_end_of_metadata(decoder) != FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM)
-			fatalerror("Fail FLAC__stream_decoder_process_until_end_of_metadata\n");
+//-------------------------------------------------
+//  playing - return true if a sample is still
+//  playing on the given channel
+//-------------------------------------------------
 
-		if (flacread.channels != 1) // only Mono supported
-			fatalerror("Only MONO samples are supported\n");
+bool samples_device::playing(UINT8 channel) const
+{
+    assert(channel < m_channels);
 
+	// force an update before we start
+    const channel_t &chan = m_channel[channel];
+	chan.stream->update();
+	return (chan.source != NULL);
+}
 
-		sample->data = auto_alloc_array(machine, INT16, flacread.total_samples*2);
-		flacread.write_position = 0;
-		flacread.write_data = sample->data;
 
-		if (FLAC__stream_decoder_process_until_end_of_stream (decoder) != FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM)
-		{
-			fatalerror("Fail FLAC__stream_decoder_process_until_end_of_stream\n");
-		}
 
-		if (FLAC__stream_decoder_finish (decoder) != true)
-			fatalerror("Fail FLAC__stream_decoder_finish\n");
+//**************************************************************************
+//  DEVICE INTERFACE
+//**************************************************************************
 
-		FLAC__stream_decoder_delete(decoder);
+//-------------------------------------------------
+//  device_start - handle device startup
+//-------------------------------------------------
 
-		/* fill in the sample data */
+void samples_device::device_start()
+{
+	// read audio samples
+	load_samples();
 
-		sample->frequency = flacread.sample_rate;
-		sample->length = flacread.total_samples * (flacread.bits_per_sample/8);
+	// allocate channels
+	m_channel.resize(m_channels);
+	for (int channel = 0; channel < m_channels; channel++)
+	{
+		// initialize channel
+		channel_t &chan = m_channel[channel];
+	    chan.stream = stream_alloc(0, 1, machine().sample_rate());
+		chan.source = NULL;
+		chan.source_num = -1;
+		chan.step = 0;
+		chan.loop = 0;
+		chan.paused = 0;
 
-		if (flacread.bits_per_sample == 8)
-		{
-			for (sindex = 0; sindex <= sample->length; sindex++)
-				sample->data[sindex] = ((sample->data[sindex])&0xff)*256;
-		}
-		else // don't need to process 16-bit samples?
-		{
-			sample->length = sample->length /2; //??
-		}
+		// register with the save state system
+        save_item(NAME(chan.source_length), channel);
+        save_item(NAME(chan.source_num), channel);
+        save_item(NAME(chan.pos), channel);
+        save_item(NAME(chan.frac), channel);
+        save_item(NAME(chan.step), channel);
+        save_item(NAME(chan.loop), channel);
+        save_item(NAME(chan.paused), channel);
 	}
 
-	return 1;
+	// initialize any custom handlers
+	if (m_start != NULL)
+		(*m_start)(*this);
 }
 
 
-/*-------------------------------------------------
-    readsamples - load all samples
--------------------------------------------------*/
+//-------------------------------------------------
+//  device_reset - handle device reset
+//-------------------------------------------------
 
-loaded_samples *readsamples(running_machine &machine, const char *const *samplenames, const char *basename)
+void samples_device::device_reset()
 {
-	loaded_samples *samples;
-	int skipfirst = 0;
-	int i;
-
-	/* if the user doesn't want to use samples, bail */
-	if (!machine.options().samples())
-		return NULL;
-	if (samplenames == 0 || samplenames[0] == 0)
-		return NULL;
-
-	/* if a name begins with '*', we will also look under that as an alternate basename */
-	if (samplenames[0][0] == '*')
-		skipfirst = 1;
+	stop_all();
+}
 
-	/* count the samples */
-	for (i = 0; samplenames[i+skipfirst] != 0; i++) ;
-	if (i == 0)
-		return NULL;
 
-	/* allocate the array */
-	samples = (loaded_samples *)auto_alloc_array_clear(machine, UINT8, sizeof(loaded_samples) + (i-1) * sizeof(loaded_sample));
-	samples->total = i;
+//-------------------------------------------------
+//  device_post_load - handle updating after a
+//  restore
+//-------------------------------------------------
 
-	/* load the samples */
-	for (i = 0; i < samples->total; i++)
-		if (samplenames[i+skipfirst][0])
+void samples_device::device_post_load()
+{
+	// loop over channels
+	for (int channel = 0; channel < m_channels; channel++)
+	{
+		// attach any samples that were loaded and playing
+		channel_t &chan = m_channel[channel];
+		if (chan.source_num >= 0 && chan.source_num < m_sample.count())
 		{
-			emu_file file(machine.options().sample_path(), OPEN_FLAG_READ);
-			file_error filerr = FILERR_NOT_FOUND;
-
-			char filename[512];
-
-			if (filerr != FILERR_NONE)
-			{
-				// first try opening samples as .flac
-				sprintf(filename, "%s.flac", samplenames[i+skipfirst]);
-
-				filerr = file.open(basename, PATH_SEPARATOR, filename);
-				// try parent sample set
-				if (filerr != FILERR_NONE && skipfirst)
-					filerr = file.open(samplenames[0] + 1, PATH_SEPARATOR, filename);
-			}
+			loaded_sample &sample = m_sample[chan.source_num];
+			chan.source = sample.data;
+			chan.source_length = sample.length;
+			if (sample.data == NULL)
+				chan.source_num = -1;
+		}
 
-			if (filerr != FILERR_NONE)
+		// validate the position against the length in case the sample is smaller
+		if (chan.source != NULL && chan.pos >= chan.source_length)
+		{
+			if (chan.loop)
+				chan.pos %= chan.source_length;
+			else
 			{
-				// .wav fallback
-				sprintf(filename, "%s.wav", samplenames[i+skipfirst]);
-
-				filerr = file.open(basename, PATH_SEPARATOR, filename);
-				// try parent sample set
-				if (filerr != FILERR_NONE && skipfirst)
-					filerr = file.open(samplenames[0] + 1, PATH_SEPARATOR, filename);
+				chan.source = NULL;
+				chan.source_num = -1;
 			}
-
-
-			if (filerr == FILERR_NONE)
-				read_wav_sample(machine, file, &samples->sample[i], filename);
-
-			if (filerr == FILERR_NOT_FOUND)
-				mame_printf_warning("sample '%s' NOT FOUND\n", samplenames[i+skipfirst]);
-
 		}
-
-	return samples;
-}
-
-
-
-
-/* Start one of the samples loaded from disk. Note: channel must be in the range */
-/* 0 .. Samplesinterface->channels-1. It is NOT the discrete channel to pass to */
-/* mixer_play_sample() */
-void sample_start(device_t *device,int channel,int samplenum,int loop)
-{
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-    loaded_sample *sample;
-
-	/* if samples are disabled, just return quietly */
-	if (info->samples == NULL)
-		return;
-
-    assert( samplenum < info->samples->total );
-    assert( channel < info->numchannels );
-
-    chan = &info->channel[channel];
-
-	/* force an update before we start */
-	chan->stream->update();
-
-	/* update the parameters */
-	sample = &info->samples->sample[samplenum];
-	chan->source = sample->data;
-	chan->source_length = sample->length;
-	chan->source_num = sample->data ? samplenum : -1;
-	chan->pos = 0;
-	chan->frac = 0;
-	chan->basefreq = sample->frequency;
-	chan->step = ((INT64)chan->basefreq << FRAC_BITS) / info->device->machine().sample_rate();
-	chan->loop = loop;
+	}
 }
 
 
-void sample_start_raw(device_t *device,int channel,const INT16 *sampledata,int samples,int frequency,int loop)
-{
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-
-    assert( channel < info->numchannels );
-
-    chan = &info->channel[channel];
-
-	/* force an update before we start */
-	chan->stream->update();
-
-	/* update the parameters */
-	chan->source = sampledata;
-	chan->source_length = samples;
-	chan->source_num = -1;
-	chan->pos = 0;
-	chan->frac = 0;
-	chan->basefreq = frequency;
-	chan->step = ((INT64)chan->basefreq << FRAC_BITS) / info->device->machine().sample_rate();
-	chan->loop = loop;
-}
-
+//-------------------------------------------------
+//  sound_stream_update - update a sound stream
+//-------------------------------------------------
 
-void sample_set_freq(device_t *device,int channel,int freq)
+void samples_device::sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples)
 {
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-
-    assert( channel < info->numchannels );
-
-    chan = &info->channel[channel];
-
-	/* force an update before we start */
-	chan->stream->update();
-
-	chan->step = ((INT64)freq << FRAC_BITS) / info->device->machine().sample_rate();
-}
-
-
-void sample_set_volume(device_t *device,int channel,float volume)
-{
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
+	// find the channel with this stream
+	for (int channel = 0; channel < m_channels; channel++)
+		if (&stream == m_channel[channel].stream)
+		{
+			channel_t &chan = m_channel[channel];
+			stream_sample_t *buffer = outputs[0];
 
-    assert( channel < info->numchannels );
+			// process if we still have a source and we're not paused
+			if (chan.source != NULL && !chan.paused)
+			{
+				// load some info locally
+				UINT32 pos = chan.pos;
+				UINT32 frac = chan.frac;
+				UINT32 step = chan.step;
+				const INT16 *sample = chan.source;
+				UINT32 sample_length = chan.source_length;
 
-    chan = &info->channel[channel];
+				while (samples--)
+				{
+					// do a linear interp on the sample
+					INT32 sample1 = sample[pos];
+					INT32 sample2 = sample[(pos + 1) % sample_length];
+					INT32 fracmult = frac >> (FRAC_BITS - 14);
+					*buffer++ = ((0x4000 - fracmult) * sample1 + fracmult * sample2) >> 14;
+
+					// advance
+					frac += step;
+					pos += frac >> FRAC_BITS;
+					frac = frac & ((1 << FRAC_BITS) - 1);
+
+					// handle looping/ending
+					if (pos >= sample_length)
+					{
+						if (chan.loop)
+							pos %= sample_length;
+						else
+						{
+							chan.source = NULL;
+							chan.source_num = -1;
+							if (samples > 0)
+								memset(buffer, 0, samples * sizeof(*buffer));
+							samples = 0;
+							break;
+						}
+					}
+				}
 
-	chan->stream->set_output_gain(0, volume);
+				// push position back out
+				chan.pos = pos;
+				chan.frac = frac;
+			}
+			else
+				memset(buffer, 0, samples * sizeof(*buffer));
+			break;
+		}
 }
 
 
-void sample_set_pause(device_t *device,int channel,int pause)
-{
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
 
-    assert( channel < info->numchannels );
+//**************************************************************************
+//  INTERNAL HELPERS
+//**************************************************************************
 
-    chan = &info->channel[channel];
+//-------------------------------------------------
+//  read_sample - read a WAV or FLAC file as a
+//  sample
+//-------------------------------------------------
 
-	/* force an update before we start */
-	chan->stream->update();
-
-	chan->paused = pause;
-}
-
-
-void sample_stop(device_t *device,int channel)
+bool samples_device::read_sample(emu_file &file, loaded_sample &sample)
 {
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-
-    assert( channel < info->numchannels );
+	// read the core header and make sure it's a proper file
+	UINT8 buf[4];
+	UINT32 offset = file.read(buf, 4);
+	if (offset < 4)
+	{
+		mame_printf_warning("Unable to read %s, 0-byte file?\n", file.filename());
+		return false;
+	}
 
-    chan = &info->channel[channel];
+	// look for the appropriate RIFF tag
+	if (memcmp(&buf[0], "RIFF", 4) == 0)
+		return read_wav_sample(file, sample);
+	else if (memcmp(&buf[0], "fLaC", 4) == 0)
+		return read_flac_sample(file, sample);
 
-    /* force an update before we start */
-    chan->stream->update();
-    chan->source = NULL;
-    chan->source_num = -1;
+	// if nothing appropriate, emit a warning
+	mame_printf_warning("Unable to read %s, corrupt file?\n", file.filename());
+	return false;
 }
 
 
-int sample_get_base_freq(device_t *device,int channel)
-{
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-
-    assert( channel < info->numchannels );
-
-    chan = &info->channel[channel];
-
-	/* force an update before we start */
-	chan->stream->update();
-	return chan->basefreq;
-}
-
+//-------------------------------------------------
+//  read_wav_sample - read a WAV file as a sample
+//-------------------------------------------------
 
-int sample_playing(device_t *device,int channel)
+bool samples_device::read_wav_sample(emu_file &file, loaded_sample &sample)
 {
-    samples_info *info = get_safe_token(device);
-    sample_channel *chan;
-
-    assert( channel < info->numchannels );
+printf("Reading %s as WAV\n", file.filename());
+	// we already read the opening 'WAVE' header
+	UINT32 offset = 4;
 
-    chan = &info->channel[channel];
+	// get the total size
+	UINT32 filesize;
+	offset += file.read(&filesize, 4);
+	if (offset < 8)
+		return false;
+	filesize = LITTLE_ENDIANIZE_INT32(filesize);
 
-	/* force an update before we start */
-	chan->stream->update();
-	return (chan->source != NULL);
-}
-
-
-static STREAM_UPDATE( sample_update_sound )
-{
-	sample_channel *chan = (sample_channel *)param;
-	stream_sample_t *buffer = outputs[0];
-
-	if (chan->source && !chan->paused)
+	// read the RIFF file type and make sure it's a WAVE file
+	char buf[32];
+	offset += file.read(buf, 4);
+	if (offset < 12)
+		return false;
+	if (memcmp(&buf[0], "WAVE", 4) != 0)
+		return false;
+
+	// seek until we find a format tag
+	UINT32 length;
+	while (1)
 	{
-		/* load some info locally */
-		UINT32 pos = chan->pos;
-		UINT32 frac = chan->frac;
-		UINT32 step = chan->step;
-		const INT16 *sample = chan->source;
-		UINT32 sample_length = chan->source_length;
-
-		while (samples--)
-		{
-			/* do a linear interp on the sample */
-			INT32 sample1 = sample[pos];
-			INT32 sample2 = sample[(pos + 1) % sample_length];
-			INT32 fracmult = frac >> (FRAC_BITS - 14);
-			*buffer++ = ((0x4000 - fracmult) * sample1 + fracmult * sample2) >> 14;
-
-			/* advance */
-			frac += step;
-			pos += frac >> FRAC_BITS;
-			frac = frac & ((1 << FRAC_BITS) - 1);
-
-			/* handle looping/ending */
-			if (pos >= sample_length)
-			{
-				if (chan->loop)
-					pos %= sample_length;
-				else
-				{
-					chan->source = NULL;
-					chan->source_num = -1;
-					if (samples > 0)
-						memset(buffer, 0, samples * sizeof(*buffer));
-					break;
-				}
-			}
-		}
+		offset += file.read(buf, 4);
+		offset += file.read(&length, 4);
+		length = LITTLE_ENDIANIZE_INT32(length);
+		if (memcmp(&buf[0], "fmt ", 4) == 0)
+			break;
+
+		// seek to the next block
+		file.seek(length, SEEK_CUR);
+		offset += length;
+		if (offset >= filesize)
+			return false;
+	}
+
+	// read the format -- make sure it is PCM
+	UINT16 temp16;
+	offset += file.read(&temp16, 2);
+	temp16 = LITTLE_ENDIANIZE_INT16(temp16);
+	if (temp16 != 1)
+		return false;
+
+	// number of channels -- only mono is supported
+	offset += file.read(&temp16, 2);
+	temp16 = LITTLE_ENDIANIZE_INT16(temp16);
+	if (temp16 != 1)
+		return false;
+
+	// sample rate
+	UINT32 rate;
+	offset += file.read(&rate, 4);
+	rate = LITTLE_ENDIANIZE_INT32(rate);
+
+	// bytes/second and block alignment are ignored
+	offset += file.read(buf, 6);
+
+	// bits/sample
+	UINT16 bits;
+	offset += file.read(&bits, 2);
+	bits = LITTLE_ENDIANIZE_INT16(bits);
+	if (bits != 8 && bits != 16)
+		return false;
+
+	// seek past any extra data
+	file.seek(length - 16, SEEK_CUR);
+	offset += length - 16;
 
-		/* push position back out */
-		chan->pos = pos;
-		chan->frac = frac;
+	// seek until we find a data tag
+	while (1)
+	{
+		offset += file.read(buf, 4);
+		offset += file.read(&length, 4);
+		length = LITTLE_ENDIANIZE_INT32(length);
+		if (memcmp(&buf[0], "data", 4) == 0)
+			break;
+
+		// seek to the next block
+		file.seek(length, SEEK_CUR);
+		offset += length;
+		if (offset >= filesize)
+			return false;
+	}
+
+	// if there was a 0 length data block, we're done
+	if (length == 0)
+		return false;
+
+	// fill in the sample data
+	sample.length = length / 2;
+	sample.frequency = rate;
+
+	// read the data in
+	if (bits == 8)
+	{
+		sample.data.resize(length);
+		file.read(sample.data, length);
+
+		// convert 8-bit data to signed samples
+		UINT8 *tempptr = reinterpret_cast<UINT8 *>(&sample.data[0]);
+		for (UINT32 sindex = length - 1; sindex >= 0; sindex--)
+			sample.data[sindex] = INT8(tempptr[sindex] ^ 0x80) * 256;
 	}
 	else
-		memset(buffer, 0, samples * sizeof(*buffer));
-}
-
-
-static void samples_postload(samples_info *info)
-{
-	int i;
-
-	/* loop over channels */
-	for (i = 0; i < info->numchannels; i++)
 	{
-		sample_channel *chan = &info->channel[i];
-
-		/* attach any samples that were loaded and playing */
-		if (chan->source_num >= 0 && chan->source_num < info->samples->total)
-		{
-			loaded_sample *sample = &info->samples->sample[chan->source_num];
-			chan->source = sample->data;
-			chan->source_length = sample->length;
-			if (!sample->data)
-				chan->source_num = -1;
-		}
+		// 16-bit data is fine as-is
+		sample.data.resize(length / 2);
+		file.read(sample.data, length);
 
-		/* validate the position against the length in case the sample is smaller */
-		if (chan->source && chan->pos >= chan->source_length)
-		{
-			if (chan->loop)
-				chan->pos %= chan->source_length;
-			else
-			{
-				chan->source = NULL;
-				chan->source_num = -1;
-			}
-		}
+		// swap high/low on big-endian systems
+		if (ENDIANNESS_NATIVE != ENDIANNESS_LITTLE)
+			for (UINT32 sindex = 0; sindex < sample.length; sindex++)
+				sample.data[sindex] = LITTLE_ENDIANIZE_INT16(sample.data[sindex]);
 	}
+	return true;
 }
 
 
-static DEVICE_START( samples )
+//-------------------------------------------------
+//  read_flac_sample - read a FLAC file as a sample
+//-------------------------------------------------
+
+bool samples_device::read_flac_sample(emu_file &file, loaded_sample &sample)
 {
-	int i;
-	const samples_interface *intf = (const samples_interface *)device->static_config();
-	samples_info *info = get_safe_token(device);
-
-	info->device = device;
-
-	/* read audio samples */
-	if (intf->samplenames)
-		info->samples = readsamples(device->machine(), intf->samplenames,device->machine().system().name);
-
-	/* allocate channels */
-	info->numchannels = intf->channels;
-	assert(info->numchannels < MAX_CHANNELS);
-	info->channel = auto_alloc_array(device->machine(), sample_channel, info->numchannels);
-	for (i = 0; i < info->numchannels; i++)
-	{
-	    info->channel[i].stream = device->machine().sound().stream_alloc(*device, 0, 1, device->machine().sample_rate(), &info->channel[i], sample_update_sound);
+printf("Reading %s as FLAC\n", file.filename());
+	// seek back to the start of the file
+	file.seek(0, SEEK_SET);
 
-		info->channel[i].source = NULL;
-		info->channel[i].source_num = -1;
-		info->channel[i].step = 0;
-		info->channel[i].loop = 0;
-		info->channel[i].paused = 0;
-
-		/* register with the save state system */
-        device->save_item(NAME(info->channel[i].source_length), i);
-        device->save_item(NAME(info->channel[i].source_num), i);
-        device->save_item(NAME(info->channel[i].pos), i);
-        device->save_item(NAME(info->channel[i].frac), i);
-        device->save_item(NAME(info->channel[i].step), i);
-        device->save_item(NAME(info->channel[i].loop), i);
-        device->save_item(NAME(info->channel[i].paused), i);
-	}
-	device->machine().save().register_postload(save_prepost_delegate(FUNC(samples_postload), info));
+	// create the FLAC decoder and fill in the sample data
+	flac_decoder decoder(file);
+	sample.length = decoder.total_samples();
+	sample.frequency = decoder.sample_rate();
 
-	/* initialize any custom handlers */
-	if (intf->start)
-		(*intf->start)(device);
-}
+	// error if more than 1 channel or not 16bpp
+	if (decoder.channels() != 1)
+		return false;
+	if (decoder.bits_per_sample() != 16)
+		return false;
 
+	// resize the array and read
+	sample.data.resize(sample.length);
+	if (!decoder.decode_interleaved(sample.data, sample.length))
+		return false;
 
+	// finish up and clean up
+	decoder.finish();
+	return true;
+}
 
-/**************************************************************************
- * Generic get_info
- **************************************************************************/
 
-DEVICE_GET_INFO( samples )
+//-------------------------------------------------
+//  load_samples - load all the samples in our
+//  attached interface
+//-------------------------------------------------
+
+void samples_device::load_samples()
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(samples_info);			break;
+	// if the user doesn't want to use samples, bail
+	if (!machine().options().samples())
+		return;
 
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-        case DEVINFO_FCT_START:                         info->start = DEVICE_START_NAME( samples );		break;
-        case DEVINFO_FCT_STOP:                          /* Nothing */                           		break;
-        case DEVINFO_FCT_RESET:                         /* Nothing */                           		break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-        case DEVINFO_STR_NAME:                          strcpy(info->s, "Samples");                 	break;
-        case DEVINFO_STR_FAMILY:                   strcpy(info->s, "Big Hack");                 	break;
-        case DEVINFO_STR_VERSION:                  strcpy(info->s, "1.1");                      	break;
-        case DEVINFO_STR_SOURCE_FILE:                     strcpy(info->s, __FILE__);                    		break;
-        case DEVINFO_STR_CREDITS:                  strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
+	// iterate over ourself
+	const char *basename = machine().basename();
+	samples_iterator iter(*this);
+	const char *altbasename = iter.altbasename();
+
+	// pre-size the array
+	m_sample.resize(iter.count());
+
+	// load the samples
+	int index = 0;
+	for (const char *samplename = iter.first(); samplename != NULL; index++, samplename = iter.next())
+	{
+printf("Sample %d = %s\n", index, samplename);
+		// attempt to open as FLAC first
+		emu_file file(machine().options().sample_path(), OPEN_FLAG_READ);
+		file_error filerr = file.open(basename, PATH_SEPARATOR, samplename, ".flac");
+		if (filerr != FILERR_NONE && altbasename != NULL)
+			filerr = file.open(altbasename, PATH_SEPARATOR, samplename, ".flac");
+
+		// if not, try as WAV
+		if (filerr != FILERR_NONE)
+			filerr = file.open(basename, PATH_SEPARATOR, samplename, ".wav");
+		if (filerr != FILERR_NONE && altbasename != NULL)
+			filerr = file.open(altbasename, PATH_SEPARATOR, samplename, ".wav");
+
+		// if opened, read it
+		if (filerr == FILERR_NONE)
+			read_sample(file, m_sample[index]);
+		else if (filerr == FILERR_NOT_FOUND)
+			mame_printf_warning("Sample '%s' NOT FOUND\n", samplename);
 	}
 }
-
-
-DEFINE_LEGACY_SOUND_DEVICE(SAMPLES, samples);
diff -Nru src-old/emu/sound/samples.h src/emu/sound/samples.h
--- src-old/emu/sound/samples.h	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/sound/samples.h	2012-02-19 16:23:23.000000000 +0100
@@ -1,51 +1,224 @@
+/***************************************************************************
+
+    samples.h
+
+    Sound device for sample playback.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
 #pragma once
 
 #ifndef __SAMPLES_H__
 #define __SAMPLES_H__
 
-#include "devlegcy.h"
 
-typedef struct _loaded_sample loaded_sample;
-struct _loaded_sample
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MCFG_SAMPLES_ADD(_tag, _interface) \
+	MCFG_DEVICE_ADD(_tag, SAMPLES, 0) \
+	samples_device::static_set_interface(*device, _interface);
+
+#define MCFG_SAMPLES_REPLACE(_tag, _interface) \
+	MCFG_DEVICE_REPLACE(_tag, SAMPLES, 0) \
+	samples_device::static_set_interface(*device, _interface);
+
+
+#define SAMPLES_START(name) void name(samples_device &device)
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+class samples_device;
+
+
+// ======================> samples_interface sample
+
+struct samples_interface
 {
-    int         length;         /* length in samples */
-    int         frequency;      /* frequency of the sample */
-    INT16 *     data;           /* 16-bit signed data */
+    UINT8		m_channels;			// number of discrete audio channels needed
+    const char *const *m_names;		// array of sample names
+    void        (*m_start)(samples_device &device); // optional callback
 };
 
-typedef struct _loaded_samples loaded_samples;
-struct _loaded_samples
+
+// ======================> samples_device
+
+class samples_device :	public device_t,
+						public device_sound_interface,
+						public samples_interface
 {
-    int         total;          /* number of samples */
-    loaded_sample sample[1]; /* array of samples */
+public:
+	// construction/destruction
+	samples_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	// static configuration helpers
+	static void static_set_interface(device_t &device, const samples_interface &interface);
+
+	// getters
+	bool playing(UINT8 channel) const;
+	UINT32 base_frequency(UINT8 channel) const;
+
+	// start/stop helpers
+	void start(UINT8 channel, UINT32 samplenum, bool loop = false);
+	void start_raw(UINT8 channel, const INT16 *sampledata, UINT32 samples, UINT32 frequency, bool loop = false);
+	void pause(UINT8 channel, bool pause = true);
+	void stop(UINT8 channel);
+	void stop_all();
+
+	// dynamic control
+	void set_frequency(UINT8 channel, UINT32 frequency);
+	void set_volume(UINT8 channel, float volume);
+
+protected:
+	// subclasses can do it this way
+	samples_device(const machine_config &mconfig, device_type type, const char *name, const char *tag, device_t *owner, UINT32 clock);
+
+	// device-level overrides
+	virtual void device_start();
+	virtual void device_reset();
+	virtual void device_post_load();
+
+	// device_sound_interface overrides
+	virtual void sound_stream_update(sound_stream &stream, stream_sample_t **inputs, stream_sample_t **outputs, int samples);
+
+private:
+	// internal classes
+	struct loaded_sample
+	{
+		// shouldn't need a copy, but in case it happens, catch it here
+		loaded_sample &operator=(const loaded_sample &rhs) { assert(false); return *this; }
+
+	    UINT32			length;			// length in samples
+	    UINT32			frequency;		// frequency of the sample
+	    dynamic_array<INT16> data;		// 16-bit signed data
+	};
+
+	struct channel_t
+	{
+		sound_stream *	stream;
+		const INT16 *	source;
+		INT32			source_length;
+		INT32			source_num;
+		UINT32			pos;
+		UINT32			frac;
+		UINT32			step;
+		UINT32			basefreq;
+		bool			loop;
+		bool			paused;
+	};
+
+	// internal helpers
+	bool read_sample(emu_file &file, loaded_sample &sample);
+	bool read_wav_sample(emu_file &file, loaded_sample &sample);
+	bool read_flac_sample(emu_file &file, loaded_sample &sample);
+	void load_samples();
+
+	// internal state
+	dynamic_array<channel_t>		m_channel;
+	dynamic_array<loaded_sample>	m_sample;
+
+	// internal constants
+	static const UINT8 FRAC_BITS = 24;
+	static const UINT32 FRAC_ONE = 1 << FRAC_BITS;
+	static const UINT32 FRAC_MASK = FRAC_ONE - 1;
 };
 
-typedef struct _samples_interface samples_interface;
-struct _samples_interface
+// iterator, since lots of people are interested in these devices
+typedef device_type_iterator<&device_creator<samples_device>, samples_device> samples_device_iterator;
+
+
+// ======================> samples_iterator
+
+class samples_iterator
 {
-    int         channels;   /* number of discrete audio channels needed */
-    const char *const *samplenames;
-    void        (*start)(device_t *device);
+public:
+	// construction/destruction
+	samples_iterator(samples_interface &intf)
+		: m_intf(intf),
+		  m_current(-1) { }
+
+	// getters
+	const char *altbasename() const { return (m_intf.m_names != NULL && m_intf.m_names[0] != NULL && m_intf.m_names[0][0] == '*') ? &m_intf.m_names[0][1] : NULL; }
+
+	// iteration
+	const char *first()
+	{
+		if (m_intf.m_names == NULL || m_intf.m_names[0] == NULL)
+			return NULL;
+		m_current = 0;
+		if (m_intf.m_names[0][0] == '*')
+			m_current++;
+		return m_intf.m_names[m_current++];
+	}
+
+	const char *next()
+	{
+		if (m_current == -1 || m_intf.m_names[m_current] == NULL)
+			return NULL;
+		return m_intf.m_names[m_current++];
+	}
+
+	// counting
+	int count()
+	{
+		int save = m_current;
+		int result = 0;
+		for (const char *scan = first(); scan != NULL; scan = next())
+			result++;
+		m_current = save;
+		return result;
+	}
+
+private:
+	// internal state
+	samples_interface &		m_intf;
+	int						m_current;
 };
 
-#define SAMPLES_START(name) void name(device_t *device)
-
 
-void sample_start(device_t *device,int channel,int samplenum,int loop);
-void sample_start_raw(device_t *device,int channel,const INT16 *sampledata,int samples,int frequency,int loop);
-void sample_set_freq(device_t *device,int channel,int freq);
-void sample_set_volume(device_t *device,int channel,float volume);
-void sample_set_pause(device_t *device,int channel,int pause);
-void sample_stop(device_t *device,int channel);
-int sample_get_base_freq(device_t *device,int channel);
-int sample_playing(device_t *device,int channel);
 
-/* helper function that reads samples from disk - this can be used by other */
-/* drivers as well (e.g. a sound chip emulator needing drum samples) */
-loaded_samples *readsamples(running_machine &machine, const char *const *samplenames, const char *name);
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-DECLARE_LEGACY_SOUND_DEVICE(SAMPLES, samples);
+// device type definition
+extern const device_type SAMPLES;
 
-typedef device_type_iterator<&legacy_device_creator<samples_device>, samples_device> samples_device_iterator;
 
-#endif /* __SAMPLES_H__ */
+#endif
diff -Nru src-old/emu/sound/votrax.c src/emu/sound/votrax.c
--- src-old/emu/sound/votrax.c	2011-03-29 16:50:04.000000000 +0200
+++ src/emu/sound/votrax.c	2012-02-19 16:23:23.000000000 +0100
@@ -1,187 +1,163 @@
-/**************************************************************************
+/***************************************************************************
 
-    Votrax SC-01 Emulator
+    votrax.c
 
-    Mike@Dissfulfils.co.uk
+    Hacked up votrax simulator that maps to samples, until a real one
+    is written.
 
-**************************************************************************
+****************************************************************************
 
-DEVICE_START(votrax)- Start emulation, load samples from Votrax subdirectory
-votrax_w         - Write data to votrax port
-votrax_status_r  - Return busy status (-1 = busy)
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
-If you need to alter the base frequency (i.e. Qbert) then just alter
-the variable VotraxBaseFrequency, this is defaulted to 8000
-
-**************************************************************************/
+***************************************************************************/
 
 #include "emu.h"
-#include "samples.h"
 #include "votrax.h"
 
 
-typedef struct _votrax_state votrax_state;
-struct _votrax_state
-{
-	device_t *device;
-	int		stream;
-	int		frequency;		/* Some games (Qbert) change this */
-	int 	volume;
-	sound_stream *	channel;
-
-	loaded_sample *sample;
-	UINT32		pos;
-	UINT32		frac;
-	UINT32		step;
-
-	loaded_samples *samples;
-};
-
-INLINE votrax_state *get_safe_token(device_t *device)
-{
-	assert(device != NULL);
-	assert(device->type() == VOTRAX);
-	return (votrax_state *)downcast<legacy_device_base *>(device)->token();
-}
 
-#define FRAC_BITS		24
-#define FRAC_ONE		(1 << FRAC_BITS)
-#define FRAC_MASK		(FRAC_ONE - 1)
-
-
-/****************************************************************************
- * 64 Phonemes - currently 1 sample per phoneme, will be combined sometime!
- ****************************************************************************/
-
-static const char *const VotraxTable[65] =
-{
- "EH3","EH2","EH1","PA0","DT" ,"A1" ,"A2" ,"ZH",
- "AH2","I3" ,"I2" ,"I1" ,"M"  ,"N"  ,"B"  ,"V",
- "CH" ,"SH" ,"Z"  ,"AW1","NG" ,"AH1","OO1","OO",
- "L"  ,"K"  ,"J"  ,"H"  ,"G"  ,"F"  ,"D"  ,"S",
- "A"  ,"AY" ,"Y1" ,"UH3","AH" ,"P"  ,"O"  ,"I",
- "U"  ,"Y"  ,"T"  ,"R"  ,"E"  ,"W"  ,"AE" ,"AE1",
- "AW2","UH2","UH1","UH" ,"O2" ,"O1" ,"IU" ,"U1",
- "THV","TH" ,"ER" ,"EH" ,"E1" ,"AW" ,"PA1","STOP",
- 0
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+// device type definition
+const device_type VOTRAX = &device_creator<votrax_device>;
+
+const char *const votrax_device::s_phoneme_table[64] =
+{
+	"EH3",	"EH2",	"EH1",	" "/*PA0*/"DT",	"A1",	"A2",	"ZH",
+	"AH2",	"I3",	"I2",	"I1",	"M",	"N",	"B",	"V",
+	"CH",	"SH",	"Z",	"AW1",	"NG",	"AH1",	"OO1",	"OO",
+	"L",	"K",	"J",	"H",	"G",	"F",	"D",	"S",
+	"A",	"AY",	"Y1",	"UH3",	"AH",	"P",	"O",	"I",
+	"U",	"Y",	"T",	"R",	"E",	"W",	"AE",	"AE1",
+	"AW2",	"UH2",	"UH1",	"UH",	"O2",	"O1",	"IU",	"U1",
+	"THV",	"TH",	"ER",	"EH",	"E1",	"AW",	" "/*PA1*/, "."/*STOP*/
 };
 
-static STREAM_UPDATE( votrax_update_sound )
-{
-	votrax_state *info = (votrax_state*) param;
-	stream_sample_t *buffer = outputs[0];
 
-	if (info->sample)
-	{
-		/* load some info locally */
-		UINT32 pos = info->pos;
-		UINT32 frac = info->frac;
-		UINT32 step = info->step;
-		UINT32 length = info->sample->length;
-		INT16 *sample = info->sample->data;
 
-		while (length--)
-		{
-			/* do a linear interp on the sample */
-			INT32 sample1 = sample[pos];
-			INT32 sample2 = sample[(pos + 1) % length];
-			INT32 fracmult = frac >> (FRAC_BITS - 14);
-			*buffer++ = ((0x4000 - fracmult) * sample1 + fracmult * sample2) >> 14;
-
-			/* advance */
-			frac += step;
-			pos += frac >> FRAC_BITS;
-			frac = frac & ((1 << FRAC_BITS) - 1);
-
-			/* handle looping/ending */
-			if (pos >= length)
-			{
-				info->sample = NULL;
-				break;
-			}
-		}
-
-		/* push position back out */
-		info->pos = pos;
-		info->frac = frac;
-	}
-}
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
 
+//-------------------------------------------------
+//  votrax_device - constructor
+//-------------------------------------------------
 
-static DEVICE_START( votrax )
+votrax_device::votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+	: samples_device(mconfig, VOTRAX, "VOTRAX SC-01", tag, owner, clock)
 {
-	votrax_state *votrax = get_safe_token(device);
+}
 
-	votrax->device = device;
-	votrax->samples = readsamples(device->machine(),VotraxTable,"votrax");
-	votrax->frequency = 8000;
-	votrax->volume = 230;
 
-	votrax->channel = device->machine().sound().stream_alloc(*device, 0, 1, device->machine().sample_rate(), votrax, votrax_update_sound);
+//-------------------------------------------------
+//  static_set_interface - configuration helper
+//  to set the interface
+//-------------------------------------------------
 
-	votrax->sample = NULL;
-	votrax->step = 0;
+void votrax_device::static_set_interface(device_t &device, const votrax_interface &interface)
+{
+	votrax_device &samples = downcast<votrax_device &>(device);
+	static_cast<votrax_interface &>(samples) = interface;
 }
 
 
-WRITE8_DEVICE_HANDLER( votrax_w )
-{
-	votrax_state *info = get_safe_token(device);
-	int Phoneme,Intonation;
 
-	info->channel->update();
+//**************************************************************************
+//  READ/WRITE HANDLERS
+//**************************************************************************
 
-    Phoneme = data & 0x3F;
-    Intonation = data >> 6;
+//-------------------------------------------------
+//  write - handle a write to the control register
+//-------------------------------------------------
 
-	logerror("Speech : %s at intonation %d\n",VotraxTable[Phoneme],Intonation);
+WRITE8_MEMBER( votrax_device::write )
+{
+	// append to the current string
+	m_current.cat(s_phoneme_table[data & 0x3f]);
 
-    if(Phoneme==63)
-    	info->sample = NULL;
+	// look for a match in our sample table
+	for (int index = 0; m_votrax_map[index].phoneme != NULL; index++)
+		if (m_current.find(m_votrax_map[index].phoneme) != -1)
+		{
+			// if we found it, play the corresponding sample and flush the buffer
+			start(0, index);
+			m_current.replace(m_votrax_map[index].phoneme, "");
+			m_current.trimspace();
+			if (m_current.len() > 0)
+				mame_printf_warning("Votrax missed partial match: %s\n", m_current.cstr());
+			m_current.reset();
+			return;
+		}
 
-    if(info->samples->sample[Phoneme].data)
+	// if we got a stop and didn't find a match, print it
+	if ((data & 0x3f) == 0x3f)
 	{
-		info->sample = &info->samples->sample[Phoneme];
-		info->pos = 0;
-		info->frac = 0;
-		info->step = ((INT64)(info->sample->frequency + (256*Intonation)) << FRAC_BITS) / info->device->machine().sample_rate();
-		info->channel->set_output_gain(0, (info->volume + (8*Intonation)*100/255) / 100.0);
+		mame_printf_warning("Votrax missed match: %s\n", m_current.cstr());
+		m_current.reset();
 	}
 }
 
-int votrax_status_r(device_t *device)
+
+//-------------------------------------------------
+//  status - read the status line
+//-------------------------------------------------
+
+READ_LINE_MEMBER( votrax_device::status )
 {
-	votrax_state *info = get_safe_token(device);
-	info->channel->update();
-    return (info->sample != NULL);
+	// is this correct, or is it really a ready line and should be inverted?
+	return (m_current.len() > 0 || playing(0)) ? ASSERT_LINE : CLEAR_LINE;
 }
 
 
 
-/**************************************************************************
- * Generic get_info
- **************************************************************************/
+//**************************************************************************
+//  DEVICE INTERFACE
+//**************************************************************************
 
-DEVICE_GET_INFO( votrax )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(votrax_state); 			break;
+//-------------------------------------------------
+//  device_start - handle device startup
+//-------------------------------------------------
 
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME( votrax );			break;
-		case DEVINFO_FCT_STOP:							/* Nothing */									break;
-		case DEVINFO_FCT_RESET:							/* Nothing */									break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "Votrax SC-01");				break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Votrax speech");				break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.0");							break;
-		case DEVINFO_STR_SOURCE_FILE:						strcpy(info->s, __FILE__);						break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
-}
+void votrax_device::device_start()
+{
+	// build up a samples list
+	for (const votrax_map *curmap = m_votrax_map; curmap->phoneme != NULL; curmap++)
+		m_sample_list.append((curmap->samplename != NULL) ? curmap->samplename : "");
 
+	// create the samples interface
+	m_channels = 1;
+	m_names = m_sample_list;
+	m_start = NULL;
 
-DEFINE_LEGACY_SOUND_DEVICE(VOTRAX, votrax);
+	// let the samples device do the rest
+	samples_device::device_start();
+}
diff -Nru src-old/emu/sound/votrax.h src/emu/sound/votrax.h
--- src-old/emu/sound/votrax.h	2010-12-31 22:42:55.000000000 +0100
+++ src/emu/sound/votrax.h	2012-02-19 16:23:23.000000000 +0100
@@ -1,13 +1,115 @@
+/***************************************************************************
+
+    votrax.h
+
+    Hacked up votrax simulator that maps to samples, until a real one
+    is written.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
 #pragma once
 
 #ifndef __VOTRAX_H__
 #define __VOTRAX_H__
 
-#include "devlegcy.h"
+#include "sound/samples.h"
+
+
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MCFG_VOTRAX_ADD(_tag, _clock, _interface) \
+	MCFG_DEVICE_ADD(_tag, VOTRAX, 0) \
+	votrax_device::static_set_interface(*device, _interface);
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> votrax_interface sample
+
+struct votrax_map
+{
+	const char *phoneme;
+	const char *samplename;
+};
+
+struct votrax_interface
+{
+	votrax_map const *m_votrax_map;		// array of map entries
+};
+
+
+// ======================> votrax_device
+
+class votrax_device :	public samples_device,
+						public votrax_interface
+{
+public:
+	// construction/destruction
+	votrax_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	// static configuration helpers
+	static void static_set_interface(device_t &device, const votrax_interface &interface);
+
+	// writers
+	DECLARE_WRITE8_MEMBER( write );
+	DECLARE_READ_LINE_MEMBER( status );
+
+protected:
+	// device-level overrides
+	virtual void device_start();
+
+private:
+	// internal state
+	astring						m_current;
+	dynamic_array<const char *>	m_sample_list;
+
+	static const char *const s_phoneme_table[64];
+};
+
+
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-WRITE8_DEVICE_HANDLER( votrax_w );
-int votrax_status_r(device_t *device);
+// device type definition
+extern const device_type VOTRAX;
 
-DECLARE_LEGACY_SOUND_DEVICE(VOTRAX, votrax);
 
 #endif /* __VOTRAX_H__ */
diff -Nru src-old/emu/sound.c src/emu/sound.c
--- src-old/emu/sound.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/sound.c	2012-02-06 02:30:22.000000000 +0100
@@ -41,7 +41,6 @@
 #include "emuopts.h"
 #include "osdepend.h"
 #include "config.h"
-#include "profiler.h"
 #include "sound/wavwrite.h"
 
 
diff -Nru src-old/emu/speaker.c src/emu/speaker.c
--- src-old/emu/speaker.c	2011-04-27 06:11:18.000000000 +0200
+++ src/emu/speaker.c	2012-02-06 02:30:22.000000000 +0100
@@ -41,7 +41,6 @@
 #include "emuopts.h"
 #include "osdepend.h"
 #include "config.h"
-#include "profiler.h"
 #include "sound/wavwrite.h"
 
 
diff -Nru src-old/emu/tilemap.c src/emu/tilemap.c
--- src-old/emu/tilemap.c	2012-02-04 20:24:25.000000000 +0100
+++ src/emu/tilemap.c	2012-02-06 02:30:22.000000000 +0100
@@ -38,7 +38,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 
 
 //**************************************************************************
diff -Nru src-old/emu/timer.c src/emu/timer.c
--- src-old/emu/timer.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/timer.c	2012-02-06 02:30:22.000000000 +0100
@@ -38,7 +38,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 
 
 /***************************************************************************
diff -Nru src-old/emu/ui.c src/emu/ui.c
--- src-old/emu/ui.c	2012-01-30 11:42:47.000000000 +0100
+++ src/emu/ui.c	2012-02-06 02:30:22.000000000 +0100
@@ -13,13 +13,11 @@
 #include "emuopts.h"
 #include "video/vector.h"
 #include "machine/laserdsc.h"
-#include "profiler.h"
 #include "render.h"
 #include "cheat.h"
 #include "rendfont.h"
 #include "ui.h"
 #include "uiinput.h"
-#include "uimenu.h"
 #include "uimain.h"
 #include "uigfx.h"
 #include <ctype.h>
diff -Nru src-old/emu/uiimage.c src/emu/uiimage.c
--- src-old/emu/uiimage.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/uiimage.c	2012-02-06 02:30:22.000000000 +0100
@@ -18,13 +18,10 @@
 #include <stdlib.h>
 
 #include "emu.h"
-#include "image.h"
 #include "ui.h"
-#include "uimenu.h"
 #include "uiswlist.h"
 #include "uiimage.h"
 #include "zippath.h"
-#include "unicode.h"
 #include "imagedev/floppy.h"
 #include "imagedev/cassette.h"
 #include "imagedev/bitbngr.h"
diff -Nru src-old/emu/uiinput.c src/emu/uiinput.c
--- src-old/emu/uiinput.c	2011-05-30 20:07:19.000000000 +0200
+++ src/emu/uiinput.c	2012-02-06 02:30:22.000000000 +0100
@@ -11,7 +11,6 @@
 
 #include "emu.h"
 #include "uiinput.h"
-#include "profiler.h"
 #include "render.h"
 
 
diff -Nru src-old/emu/uimain.c src/emu/uimain.c
--- src-old/emu/uimain.c	2012-01-25 16:20:11.000000000 +0100
+++ src/emu/uimain.c	2012-02-06 02:30:22.000000000 +0100
@@ -17,7 +17,6 @@
 #include "cheat.h"
 #include "uiimage.h"
 #include "uiinput.h"
-#include "uimenu.h"
 #include "uimain.h"
 #include "audit.h"
 #include "crsshair.h"
diff -Nru src-old/emu/uiswlist.c src/emu/uiswlist.c
--- src-old/emu/uiswlist.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/uiswlist.c	2012-02-06 02:30:22.000000000 +0100
@@ -11,9 +11,7 @@
 
 #include "emu.h"
 #include "ui.h"
-#include "uimenu.h"
 #include "uiswlist.h"
-#include "softlist.h"
 
 
 /***************************************************************************
diff -Nru src-old/emu/validity.c src/emu/validity.c
--- src-old/emu/validity.c	2012-02-05 08:00:09.000000000 +0100
+++ src/emu/validity.c	2012-02-11 17:15:39.000000000 +0100
@@ -38,10 +38,8 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "hash.h"
 #include "validity.h"
 #include "emuopts.h"
-#include "softlist.h"
 #include <ctype.h>
 
 
@@ -1141,7 +1139,7 @@
 	{
 		// iterate over interfaces
 		const slot_interface *intf = slot->get_slot_interfaces();
-		for (int j = 0; intf[j].name != NULL; j++)
+		for (int j = 0; intf && intf[j].name != NULL; j++)
 		{
 			// instantiate the device
 			device_t *dev = (*intf[j].devtype)(*m_current_config, "dummy", &m_current_config->root_device(), 0);
diff -Nru src-old/emu/video/pc_vga.c src/emu/video/pc_vga.c
--- src-old/emu/video/pc_vga.c	2012-02-05 16:14:28.000000000 +0100
+++ src/emu/video/pc_vga.c	2012-02-19 16:23:23.000000000 +0100
@@ -18,20 +18,17 @@
 
     TODO:
     - modernize
-    - add emulated mc6845 hook-up
-    - fix video update.
+    - fix video update, still need to get that choosevideomode() out of it.
     - rewrite video drawing functions (they are horrible)
-    - add VESA etc.
-    - "System Information" UI currently crashes the emulation
+    - add per-gfx card VESA functions;
     - (and many more ...)
 
     per-game issues:
     - The Incredible Machine: fix partial updates
     - MAME 0.01: fix 92 Hz refresh rate bug (uses VESA register?).
-    - Bio Menace: jerky H scrolling (uses EGA mode)
+    - Alien Breed, Bio Menace: jerky H scrolling (uses VGA/EGA mode with pel shift)
     - Virtual Pool: ET4k unrecognized;
-    - California Chase (calchase): init bug causes messed up chars at POST
-      (gfxs works if you soft reset).
+    - California Chase (calchase): various gfx bugs, CPU related?
 
     ROM declarations:
 
@@ -46,6 +43,7 @@
 
 #include "emu.h"
 #include "pc_vga.h"
+#include "debugger.h"
 
 /***************************************************************************
 
@@ -53,8 +51,6 @@
 
 ***************************************************************************/
 
-static UINT8 color_bitplane_to_packed[4/*plane*/][8/*pixel*/][256];
-
 static struct
 {
 	read8_space_func read_dipswitch;
@@ -106,7 +102,7 @@
 /**/	UINT8 cursor_scan_start;
 /**/	UINT8 cursor_skew;
 /**/	UINT8 cursor_scan_end;
-/**/	UINT16 start_addr;
+		UINT32 start_addr;
 /**/	UINT8 protect_enable;
 /**/	UINT8 bandwidth;
 /**/	UINT8 offset;
@@ -126,19 +122,30 @@
 	struct
 	{
 		UINT8 index;
-		UINT8 *data;
 		UINT8 latch[4];
+		UINT8 set_reset;
+		UINT8 enable_set_reset;
 		UINT8 color_compare;
+		UINT8 logical_op;
+		UINT8 rotate_count;
+		UINT8 shift256;
+		UINT8 shift_reg;
 		UINT8 read_map_sel;
 		UINT8 read_mode;
 		UINT8 write_mode;
 		UINT8 color_dont_care;
+		UINT8 bit_mask;
+		UINT8 alpha_dis;
+		UINT8 memory_map_sel;
+		UINT8 host_oe;
+		UINT8 chain_oe;
 	} gc;
 
 	struct
 	{
 		UINT8 index, data[0x15]; int state;
 		UINT8 prot_bit;
+		UINT8 pel_shift;
 	} attribute;
 
 
@@ -163,18 +170,30 @@
 	UINT8 bank_r,bank_w;
 	UINT8 rgb8_en;
 	UINT8 rgb15_en;
+	UINT8 rgb16_en;
+	UINT8 rgb24_en;
+	UINT8 rgb32_en;
 	UINT8 id;
 }svga;
 
-#define REG(x) vga.crtc.data[x]
+static struct
+{
+	UINT8 reg_3d8;
+	UINT8 dac_ctrl;
+	UINT8 dac_state;
+	UINT8 horz_overflow;
+	UINT8 aux_ctrl;
+	bool ext_reg_ena;
+}et4k;
 
-#define CRTC_CHAR_HEIGHT ((REG(9)&0x1f)+1)
-#define CRTC_CURSOR_MODE (REG(0xa)&0x60)
-#define CRTC_CURSOR_OFF 0x20
-#define CRTC_SKEW	(REG(8)&15)
-#define CRTC_CURSOR_POS ((REG(0xe)<<8)|REG(0xf))
-#define CRTC_CURSOR_TOP	(REG(0xa)&0x1f)
-#define CRTC_CURSOR_BOTTOM REG(0xb)
+static struct
+{
+	UINT8 memory_config;
+	UINT8 ext_misc_ctrl_2;
+	UINT8 crt_reg_lock;
+	UINT8 reg_lock1;
+	UINT8 reg_lock2;
+}s3;
 
 #define CRTC_PORT_ADDR ((vga.miscellaneous_output&1)?0x3d0:0x3b0)
 
@@ -182,7 +201,7 @@
 #define LINES (vga.crtc.vert_disp_end+1)
 #define TEXT_LINES (vga.crtc.vert_disp_end+1)
 
-#define GRAPHIC_MODE (vga.gc.data[6]&1) /* else text mode */
+#define GRAPHIC_MODE (vga.gc.alpha_dis) /* else text mode */
 
 #define EGA_COLUMNS (vga.crtc.horz_disp_end+1)
 #define EGA_START_ADDRESS (vga.crtc.start_addr)
@@ -238,7 +257,7 @@
 	UINT8 bits;
 	UINT32 font_base;
 	UINT32 *bitmapline;
-	int width=CHAR_WIDTH, height=CRTC_CHAR_HEIGHT * (vga.crtc.scan_doubling + 1);
+	int width=CHAR_WIDTH, height = (vga.crtc.maximum_scan_line) * (vga.crtc.scan_doubling + 1);
 	int pos, line, column, mask, w, h, addr;
 	UINT8 blink_en,fore_col,back_col;
 	pen_t pen;
@@ -248,14 +267,14 @@
 	else
 		vga.cursor.visible = 0;
 
-	for (addr = vga.crtc.start_addr, line = -CRTC_SKEW; line < TEXT_LINES;
+	for (addr = vga.crtc.start_addr, line = -vga.crtc.preset_row_scan; line < TEXT_LINES;
 		 line += height, addr += TEXT_LINE_LENGTH)
 	{
 		for (pos = addr, column=0; column<TEXT_COLUMNS; column++, pos++)
 		{
 			ch   = vga.memory[(pos<<1) + 0];
 			attr = vga.memory[(pos<<1) + 1];
-			font_base = 0x40000+(ch<<5);
+			font_base = 0x20000+(ch<<5);
 			font_base += ((attr & 8) ? vga.sequencer.char_sel.B : vga.sequencer.char_sel.A)*0x2000;
 			blink_en = (vga.attribute.data[0x10]&8&&machine.primary_screen->frame_number() & 0x20) ? attr & 0x80 : 0;
 
@@ -293,11 +312,10 @@
 					bitmapline[column*width+w] = pen;
 				}
 			}
-			if ((CRTC_CURSOR_MODE!=CRTC_CURSOR_OFF)
-				&&vga.cursor.visible&&(pos==CRTC_CURSOR_POS))
+			if (vga.cursor.visible&&(pos==vga.crtc.cursor_addr))
 			{
-				for (h=CRTC_CURSOR_TOP;
-					 (h<=CRTC_CURSOR_BOTTOM)&&(h<height)&&(line+h<TEXT_LINES);
+				for (h=vga.crtc.cursor_scan_start;
+					 (h<=vga.crtc.cursor_scan_end)&&(h<height)&&(line+h<TEXT_LINES);
 					 h++)
 				{
 					if(!machine.primary_screen->visible_area().contains(column*width, line+h))
@@ -316,6 +334,7 @@
 	UINT32 *bitmapline;
 	pen_t pen;
 
+	/**/
 	for (addr=EGA_START_ADDRESS, pos=0, line=0; line<LINES;
 		 line += height, addr += EGA_LINE_LENGTH)
 	{
@@ -328,9 +347,9 @@
 				int data[4];
 
 				data[0]=vga.memory[(pos & 0xffff)];
-				data[1]=vga.memory[(pos & 0xffff)+0x20000]<<1;
-				data[2]=vga.memory[(pos & 0xffff)+0x40000]<<2;
-				data[3]=vga.memory[(pos & 0xffff)+0x60000]<<3;
+				data[1]=vga.memory[(pos & 0xffff)+0x10000]<<1;
+				data[2]=vga.memory[(pos & 0xffff)+0x20000]<<2;
+				data[3]=vga.memory[(pos & 0xffff)+0x30000]<<3;
 
 				for (i = 7; i >= 0; i--)
 				{
@@ -358,9 +377,10 @@
 	int height = vga.crtc.maximum_scan_line * (vga.crtc.scan_doubling + 1);
 	int yi;
 	int xi;
+	int pel_shift = 0;//vga.attribute.pel_shift; /* TODO: timing bug with this */
 
 	/* line compare is screen sensitive */
-	mask_comp = 0x0ff | (LINES & 0x300);
+	mask_comp = 0x3ff; //| (LINES & 0x300);
 
 	curr_addr = 0;
 	if(!(vga.sequencer.data[4] & 0x08))
@@ -374,7 +394,6 @@
 				if((line + yi) == (vga.crtc.line_compare & mask_comp))
 					curr_addr = 0;
 				bitmapline = &bitmap.pix32(line + yi);
-				addr %= vga.svga_intf.vram_size;
 				for (pos=curr_addr, c=0, column=0; column<VGA_COLUMNS; column++, c+=8, pos++)
 				{
 					if(pos > 0x80000/4)
@@ -382,9 +401,9 @@
 
 					for(xi=0;xi<8;xi++)
 					{
-						if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+						if(!machine.primary_screen->visible_area().contains(c+xi-pel_shift, line + yi))
 							continue;
-						bitmapline[c+xi] = machine.pens[vga.memory[pos+((xi >> 1)*0x20000)]];
+						bitmapline[c+xi-pel_shift] = machine.pens[vga.memory[(pos & 0xffff)+((xi >> 1)*0x10000)]];
 					}
 				}
 			}
@@ -401,7 +420,7 @@
 				if((line + yi) == (vga.crtc.line_compare & mask_comp))
 					curr_addr = 0;
 				bitmapline = &bitmap.pix32(line + yi);
-				addr %= vga.svga_intf.vram_size;
+				//addr %= 0x80000;
 				for (pos=curr_addr, c=0, column=0; column<VGA_COLUMNS; column++, c+=0x10, pos+=0x8)
 				{
 					if(pos + 0x08 > 0x80000)
@@ -409,9 +428,9 @@
 
 					for(xi=0;xi<0x10;xi++)
 					{
-						if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+						if(!machine.primary_screen->visible_area().contains(c+xi-pel_shift, line + yi))
 							continue;
-						bitmapline[c+xi] = machine.pens[vga.memory[pos+(xi >> 1)]];
+						bitmapline[c+xi-pel_shift] = machine.pens[vga.memory[(pos+(xi >> 1)) & 0xffff]];
 					}
 				}
 			}
@@ -499,31 +518,36 @@
 	int height = vga.crtc.maximum_scan_line * (vga.crtc.scan_doubling + 1);
 	int yi;
 	int xi;
+	UINT8 start_shift;
 
 	/* line compare is screen sensitive */
 	mask_comp = 0x3ff;
-
 	curr_addr = 0;
-	for (addr = VGA_START_ADDRESS, line=0; line<LINES; line+=height, addr+=VGA_LINE_LENGTH, curr_addr+=VGA_LINE_LENGTH)
+
+	start_shift = (!(vga.sequencer.data[4] & 0x08)) ? 2 : 0;
+
 	{
-		for(yi = 0;yi < height; yi++)
+		for (addr = VGA_START_ADDRESS << start_shift, line=0; line<LINES; line+=height, addr+=VGA_LINE_LENGTH, curr_addr+=VGA_LINE_LENGTH)
 		{
-			if((line + yi) < (vga.crtc.line_compare & mask_comp))
-				curr_addr = addr;
-			if((line + yi) == (vga.crtc.line_compare & mask_comp))
-				curr_addr = 0;
-			bitmapline = &bitmap.pix32(line + yi);
-			addr %= vga.svga_intf.vram_size;
-			for (pos=curr_addr, c=0, column=0; column<VGA_COLUMNS; column++, c+=8, pos+=0x8)
+			for(yi = 0;yi < height; yi++)
 			{
-				if(pos + 0x08 > 0x100000)
-					return;
-
-				for(xi=0;xi<8;xi++)
+				if((line + yi) < (vga.crtc.line_compare & mask_comp))
+					curr_addr = addr;
+				if((line + yi) == (vga.crtc.line_compare & mask_comp))
+					curr_addr = 0;
+				bitmapline = &bitmap.pix32(line + yi);
+				addr %= vga.svga_intf.vram_size;
+				for (pos=curr_addr, c=0, column=0; column<VGA_COLUMNS; column++, c+=8, pos+=0x8)
 				{
-					if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
-						continue;
-					bitmapline[c+xi] = machine.pens[vga.memory[(pos+(xi))]];
+					if(pos + 0x08 > 0x100000)
+						return;
+
+					for(xi=0;xi<8;xi++)
+					{
+						if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+							continue;
+						bitmapline[c+xi] = machine.pens[vga.memory[(pos+(xi))]];
+					}
 				}
 			}
 		}
@@ -538,7 +562,50 @@
 	int xi;
 	int yi;
 	int xm;
+	int pos, line, column, c, addr, curr_addr;
+
+	UINT32 *bitmapline;
+//  UINT16 mask_comp;
+
+	/* line compare is screen sensitive */
+//  mask_comp = 0xff | (TLINES & 0x300);
+	curr_addr = 0;
+	yi=0;
+	for (addr = TGA_START_ADDRESS, line=0; line<TLINES; line+=height, addr+=TGA_LINE_LENGTH, curr_addr+=TGA_LINE_LENGTH)
+	{
+		bitmapline = &bitmap.pix32(line);
+		addr %= vga.svga_intf.vram_size;
+		for (pos=addr, c=0, column=0; column<TGA_COLUMNS; column++, c+=8, pos+=0x10)
+		{
+			if(pos + 0x10 > 0x100000)
+				return;
+			for(xi=0,xm=0;xi<8;xi++,xm+=2)
+			{
+				int r,g,b;
+
+				if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+					continue;
+
+				r = (MV(pos+xm)&0x7c00)>>10;
+				g = (MV(pos+xm)&0x03e0)>>5;
+				b = (MV(pos+xm)&0x001f)>>0;
+				r = (r << 3) | (r & 0x7);
+				g = (g << 3) | (g & 0x7);
+				b = (b << 3) | (b & 0x7);
+				bitmapline[c+xi] = IV|(r<<16)|(g<<8)|(b<<0);
+			}
+		}
+	}
+}
 
+static void svga_vh_rgb16(running_machine &machine, bitmap_rgb32 &bitmap, const rectangle &cliprect)
+{
+	#define MV(x) (vga.memory[x]+(vga.memory[x+1]<<8))
+	#define IV 0xff000000
+	int height = vga.crtc.maximum_scan_line * (vga.crtc.scan_doubling + 1);
+	int xi;
+	int yi;
+	int xm;
 	int pos, line, column, c, addr, curr_addr;
 
 	UINT32 *bitmapline;
@@ -550,18 +617,108 @@
 	yi=0;
 	for (addr = TGA_START_ADDRESS, line=0; line<TLINES; line+=height, addr+=TGA_LINE_LENGTH, curr_addr+=TGA_LINE_LENGTH)
 	{
-		if(line>500) return;
 		bitmapline = &bitmap.pix32(line);
 		addr %= vga.svga_intf.vram_size;
 		for (pos=addr, c=0, column=0; column<TGA_COLUMNS; column++, c+=8, pos+=0x10)
 		{
-			if(pos + 0x10 > vga.svga_intf.vram_size)
+			if(pos + 0x10 > 0x100000)
 				return;
 			for(xi=0,xm=0;xi<8;xi++,xm+=2)
 			{
+				int r,g,b;
+
+				if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+					continue;
+
+				r = (MV(pos+xm)&0xf800)>>11;
+				g = (MV(pos+xm)&0x07e0)>>5;
+				b = (MV(pos+xm)&0x001f)>>0;
+				r = (r << 3) | (r & 0x7);
+				g = (g << 2) | (g & 0x3);
+				b = (b << 3) | (b & 0x7);
+				bitmapline[c+xi] = IV|(r<<16)|(g<<8)|(b<<0);
+			}
+		}
+	}
+}
+
+static void svga_vh_rgb24(running_machine &machine, bitmap_rgb32 &bitmap, const rectangle &cliprect)
+{
+	#define MD(x) (vga.memory[x]+(vga.memory[x+1]<<8)+(vga.memory[x+2]<<16))
+	#define ID 0xff000000
+	int height = vga.crtc.maximum_scan_line * (vga.crtc.scan_doubling + 1);
+	int xi;
+	int yi;
+	int xm;
+	int pos, line, column, c, addr, curr_addr;
+	UINT32 *bitmapline;
+
+//  UINT16 mask_comp;
+
+	/* line compare is screen sensitive */
+//  mask_comp = 0xff | (TLINES & 0x300);
+	curr_addr = 0;
+	yi=0;
+	for (addr = TGA_START_ADDRESS<<1, line=0; line<TLINES; line+=height, addr+=TGA_LINE_LENGTH, curr_addr+=TGA_LINE_LENGTH)
+	{
+		bitmapline = &bitmap.pix32(line);
+		addr %= vga.svga_intf.vram_size;
+		for (pos=addr, c=0, column=0; column<TGA_COLUMNS; column++, c+=8, pos+=24)
+		{
+			if(pos + 24 > 0x100000)
+				return;
+			for(xi=0,xm=0;xi<8;xi++,xm+=3)
+			{
+				int r,g,b;
+
+				if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
+					continue;
+
+				r = (MD(pos+xm)&0xff0000)>>16;
+				g = (MD(pos+xm)&0x00ff00)>>8;
+				b = (MD(pos+xm)&0x0000ff)>>0;
+				bitmapline[c+xi] = IV|(r<<16)|(g<<8)|(b<<0);
+			}
+		}
+	}
+}
+
+static void svga_vh_rgb32(running_machine &machine, bitmap_rgb32 &bitmap, const rectangle &cliprect)
+{
+	#define MD(x) (vga.memory[x]+(vga.memory[x+1]<<8)+(vga.memory[x+2]<<16))
+	#define ID 0xff000000
+	int height = vga.crtc.maximum_scan_line * (vga.crtc.scan_doubling + 1);
+	int xi;
+	int yi;
+	int xm;
+	int pos, line, column, c, addr, curr_addr;
+	UINT32 *bitmapline;
+
+//  UINT16 mask_comp;
+
+	/* line compare is screen sensitive */
+//  mask_comp = 0xff | (TLINES & 0x300);
+	curr_addr = 0;
+	yi=0;
+	for (addr = TGA_START_ADDRESS, line=0; line<TLINES; line+=height, addr+=(vga.crtc.offset * 4), curr_addr+=(vga.crtc.offset * 4))
+	{
+		bitmapline = &bitmap.pix32(line);
+		addr %= vga.svga_intf.vram_size;
+		for (pos=addr, c=0, column=0; column<TGA_COLUMNS; column++, c+=8, pos+=0x20)
+		{
+			if(pos + 0x20 > 0x100000)
+				return;
+			for(xi=0,xm=0;xi<8;xi++,xm+=4)
+			{
+				int r,g,b;
+
 				if(!machine.primary_screen->visible_area().contains(c+xi, line + yi))
 					continue;
-				bitmapline[c+xi] = IV|(MV(pos+xm)&0x7c00)<<9 |(MV(pos+xm)&0x3e0)<<6|(MV(pos+xm)&0x1f)<<3;
+
+				r = (MD(pos+xm)&0xff0000)>>16;
+				g = (MD(pos+xm)&0x00ff00)>>8;
+				b = (MD(pos+xm)&0x0000ff)>>0;
+				bitmapline[c+xi] = IV|(r<<16)|(g<<8)|(b<<0);
 			}
 		}
 	}
@@ -577,6 +734,9 @@
 	MONO_MODE,
 	RGB8_MODE,
 	RGB15_MODE,
+	RGB16_MODE,
+	RGB24_MODE,
+	RGB32_MODE,
 	SVGA_HACK
 };
 
@@ -619,14 +779,26 @@
 		{
 			return SVGA_HACK;
 		}
-		else if (svga.rgb8_en)
+		else if (svga.rgb32_en)
 		{
-			return RGB8_MODE;
+			return RGB32_MODE;
+		}
+		else if (svga.rgb24_en)
+		{
+			return RGB24_MODE;
+		}
+		else if (svga.rgb16_en)
+		{
+			return RGB16_MODE;
 		}
-		else if (svga.rgb15_en&0x30)
+		else if (svga.rgb15_en)
 		{
 			return RGB15_MODE;
 		}
+		else if (svga.rgb8_en)
+		{
+			return RGB8_MODE;
+		}
 		else if (!GRAPHIC_MODE)
 		{
 			//proc = vga_vh_text;
@@ -635,19 +807,19 @@
 
 			return TEXT_MODE;
 		}
-		else if (vga.gc.data[5]&0x40)
+		else if (vga.gc.shift256)
 		{
 			//proc = vga_vh_vga;
 			//*height = LINES;
 			//*width = VGA_COLUMNS * 8;
 			return VGA_MODE;
 		}
-		else if (vga.gc.data[5]&0x20)
+		else if (vga.gc.shift_reg)
 		{
 			// cga
 			return CGA_MODE;
 		}
-		else if ((vga.gc.data[6]&0x0c) == 0x0c)
+		else if (vga.gc.memory_map_sel == 0x03)
 		{
 			// mono
 			return MONO_MODE;
@@ -671,86 +843,85 @@
 
 	cur_mode = pc_vga_choosevideomode(screen.machine());
 
-	//popmessage("%02x",cur_mode);
+	//popmessage("%02x %02x",cur_mode,vga.attribute.data[0x13]);
+	//popmessage("%d",vga.attribute.pel_shift);
+	//popmessage("%d %d %d",vga.crtc.vert_blank_start,vga.crtc.vert_blank_end,vga.crtc.vert_total);
 
 	switch(cur_mode)
 	{
-		case SCREEN_OFF:   bitmap.fill(get_black_pen(screen.machine()), cliprect);break;
-		case TEXT_MODE:    vga_vh_text(screen.machine(), bitmap, cliprect); break;
-		case VGA_MODE:     vga_vh_vga (screen.machine(), bitmap, cliprect); break;
-		case EGA_MODE:     vga_vh_ega (screen.machine(), bitmap, cliprect); break;
-		case CGA_MODE:     vga_vh_cga (screen.machine(), bitmap, cliprect); break;
-		case MONO_MODE:    vga_vh_mono(screen.machine(), bitmap, cliprect); break;
-		case RGB8_MODE:    svga_vh_rgb8(screen.machine(), bitmap, cliprect); break;
+		case SCREEN_OFF:   bitmap.fill  (get_black_pen(screen.machine()), cliprect);break;
+		case TEXT_MODE:    vga_vh_text  (screen.machine(), bitmap, cliprect); break;
+		case VGA_MODE:     vga_vh_vga   (screen.machine(), bitmap, cliprect); break;
+		case EGA_MODE:     vga_vh_ega   (screen.machine(), bitmap, cliprect); break;
+		case CGA_MODE:     vga_vh_cga   (screen.machine(), bitmap, cliprect); break;
+		case MONO_MODE:    vga_vh_mono  (screen.machine(), bitmap, cliprect); break;
+		case RGB8_MODE:    svga_vh_rgb8 (screen.machine(), bitmap, cliprect); break;
 		case RGB15_MODE:   svga_vh_rgb15(screen.machine(), bitmap, cliprect); break;
-		case SVGA_HACK:    vga.svga_intf.choosevideomode(screen.machine(), bitmap, cliprect, vga.sequencer.data, vga.crtc.data, vga.gc.data, &w, &h); break;
+		case RGB16_MODE:   svga_vh_rgb16(screen.machine(), bitmap, cliprect); break;
+		case RGB24_MODE:   svga_vh_rgb24(screen.machine(), bitmap, cliprect); break;
+		case RGB32_MODE:   svga_vh_rgb32(screen.machine(), bitmap, cliprect); break;
+		case SVGA_HACK:    vga.svga_intf.choosevideomode(screen.machine(), bitmap, cliprect, vga.sequencer.data, vga.crtc.data, &w, &h); break;
 	}
 
 	return 0;
 }
 /***************************************************************************/
 
-INLINE UINT8 rotate_right(UINT8 val, UINT8 rot)
+INLINE UINT8 rotate_right(UINT8 val)
 {
-	return (val >> rot) | (val << (8 - rot));
+	return (val >> vga.gc.rotate_count) | (val << (8 - vga.gc.rotate_count));
 }
 
-INLINE UINT8 ega_bitplane_to_packed(UINT8 *latch, int number)
+INLINE UINT8 vga_logical_op(UINT8 data, UINT8 plane, UINT8 mask)
 {
-	return color_bitplane_to_packed[0][number][latch[0]]
-		|color_bitplane_to_packed[1][number][latch[1]]
-		|color_bitplane_to_packed[2][number][latch[2]]
-		|color_bitplane_to_packed[3][number][latch[3]];
-}
+	UINT8 res = 0;
 
-INLINE UINT8 vga_latch_helper(UINT8 cpu, UINT8 latch, UINT8 mask)
-{
-	switch (vga.gc.data[3] & 0x18)
+	switch(vga.gc.logical_op & 3)
 	{
-		case 0x00:
-			return rotate_right((cpu&mask)|(latch&~mask), vga.gc.data[3] & 0x07);
-		case 0x08:
-			return rotate_right(((cpu&latch)&mask)|(latch&~mask), vga.gc.data[3] & 0x07);
-		case 0x10:
-			return rotate_right(((cpu|latch)&mask)|(latch&~mask), vga.gc.data[3] & 0x07);
-		case 0x18:
-			return rotate_right(((cpu^latch)&mask)|(latch&~mask), vga.gc.data[3] & 0x07);
+		case 0: /* NONE */
+			res = (data & mask) | (vga.gc.latch[plane] & ~mask);
+			break;
+		case 1: /* AND */
+			res = (data | ~mask) & (vga.gc.latch[plane]);
+			break;
+		case 2: /* OR */
+			res = (data & mask) | (vga.gc.latch[plane]);
+			break;
+		case 3: /* XOR */
+			res = (data & mask) ^ (vga.gc.latch[plane]);
+			break;
 	}
-	return 0; /* must not be reached, suppress compiler warning */
+
+	return res;
 }
 
 INLINE UINT8 vga_latch_write(int offs, UINT8 data)
 {
-	switch (vga.gc.data[5]&3) {
+	UINT8 res = 0;
+
+	switch (vga.gc.write_mode & 3) {
 	case 0:
-		if (vga.gc.data[1]&(1<<offs)) {
-			return vga_latch_helper( (vga.gc.data[0]&(1<<offs))?vga.gc.data[8]:0,
-									  vga.gc.latch[offs],vga.gc.data[8] );
-		} else {
-			return vga_latch_helper(data, vga.gc.latch[offs], vga.gc.data[8]);
-		}
+		data = rotate_right(data);
+		if(vga.gc.enable_set_reset & 1<<offs)
+			res = vga_logical_op((vga.gc.set_reset & 1<<offs) ? vga.gc.bit_mask : 0, offs,vga.gc.bit_mask);
+		else
+			res = vga_logical_op(data, offs, vga.gc.bit_mask);
 		break;
 	case 1:
-		return vga.gc.latch[offs];
+		res = vga.gc.latch[offs];
+		break;
 	case 2:
-		if (data&(1<<offs)) {
-			return vga_latch_helper(0xff, vga.gc.latch[offs], vga.gc.data[8]);
-		} else {
-			return vga_latch_helper(0, vga.gc.latch[offs], vga.gc.data[8]);
-		}
+		res = vga_logical_op((data & 1<<offs) ? 0xff : 0x00,offs,vga.gc.bit_mask);
 		break;
 	case 3:
-		if (vga.gc.data[0]&(1<<offs)) {
-			return vga_latch_helper(0xff, vga.gc.latch[offs], data&vga.gc.data[8]);
-		} else {
-			return vga_latch_helper(0, vga.gc.latch[offs], data&vga.gc.data[8]);
-		}
+		data = rotate_right(data);
+		res = vga_logical_op((vga.gc.set_reset & 1<<offs) ? 0xff : 0x00,offs,data&vga.gc.bit_mask);
 		break;
 	}
-	return 0; /* must not be reached, suppress compiler warning */
+
+	return res;
 }
 
-#if 0
 static UINT8 crtc_reg_read(UINT8 index)
 {
 	UINT8 res;
@@ -759,35 +930,131 @@
 
 	switch(index)
 	{
+		case 0x00:
+			res  = vga.crtc.horz_total & 0xff;
+			break;
+		case 0x01:
+			res  = vga.crtc.horz_disp_end & 0xff;
+			break;
+		case 0x02:
+			res  = vga.crtc.horz_blank_start & 0xff;
+			break;
+		case 0x03:
+			res  = vga.crtc.horz_blank_end & 0x1f;
+			res |= (vga.crtc.disp_enable_skew & 3) << 5;
+			res |= (vga.crtc.evra & 1) << 7;
+			break;
+		case 0x04:
+			res  = vga.crtc.horz_retrace_start & 0xff;
+			break;
+		case 0x05:
+			res  = (vga.crtc.horz_blank_end & 0x20) << 2;
+			res |= (vga.crtc.horz_retrace_skew & 3) << 5;
+			res |= (vga.crtc.horz_retrace_end & 0x1f);
+			break;
+		case 0x06:
+			res  = vga.crtc.vert_total & 0xff;
+			break;
+		case 0x07: // Overflow Register
+			res  = (vga.crtc.line_compare & 0x100) >> 4;
+			res |= (vga.crtc.vert_retrace_start & 0x200) >> 2;
+			res |= (vga.crtc.vert_disp_end & 0x200) >> 3;
+			res |= (vga.crtc.vert_retrace_start & 0x200) >> 6;
+			res |= (vga.crtc.vert_total & 0x200) >> 4;
+			res |= (vga.crtc.vert_blank_start & 0x100) >> 5;
+			res |= (vga.crtc.vert_retrace_start & 0x100) >> 6;
+			res |= (vga.crtc.vert_disp_end & 0x100) >> 7;
+			res |= (vga.crtc.vert_total & 0x100) >> 8;
+			break;
+		case 0x08: // Preset Row Scan Register
+			res  = (vga.crtc.byte_panning & 3) << 5;
+			res |= (vga.crtc.preset_row_scan & 0x1f);
+			break;
+		case 0x09: // Maximum Scan Line Register
+			res  = (vga.crtc.maximum_scan_line & 0x1f) - 1;
+			res |= (vga.crtc.scan_doubling & 1) << 7;
+			res |= (vga.crtc.line_compare & 0x200) >> 3;
+			res |= (vga.crtc.vert_blank_start & 0x200) >> 4;
+			break;
+		case 0x0a:
+			res  = (vga.crtc.cursor_scan_start & 0x1f);
+			res |= ((vga.crtc.cursor_enable & 1) ^ 1) << 5;
+			break;
+		case 0x0b:
+			res  = (vga.crtc.cursor_skew & 3) << 5;
+			res |= (vga.crtc.cursor_scan_end & 0x1f);
+			break;
+		case 0x0c:
+		case 0x0d:
+			res  = (vga.crtc.start_addr >> ((index & 1) ^ 1)*8) & 0xff;
+			break;
+		case 0x0e:
+		case 0x0f:
+			res  = (vga.crtc.cursor_addr >> ((index & 1) ^ 1)*8) & 0xff;
+			break;
+		case 0x10:
+			res  = vga.crtc.vert_retrace_start & 0xff;
+			break;
+		case 0x11:
+			res  = (vga.crtc.protect_enable & 1) << 7;
+			res |= (vga.crtc.bandwidth & 1) << 6;
+			res |= (vga.crtc.vert_retrace_end & 0xf);
+			break;
+		case 0x12:
+			res  = vga.crtc.vert_disp_end & 0xff;
+			break;
+		case 0x13:
+			res  = vga.crtc.offset & 0xff;
+			break;
+		case 0x14:
+			res  = (vga.crtc.dw & 1) << 6;
+			res |= (vga.crtc.div4 & 1) << 5;
+			res |= (vga.crtc.underline_loc & 0x1f);
+			break;
+		case 0x15:
+			res  = vga.crtc.vert_blank_start & 0xff;
+			break;
+		case 0x16:
+			res  = vga.crtc.vert_blank_end & 0x7f;
+			break;
+		case 0x17:
+			res  = (vga.crtc.sync_en & 1) << 7;
+			res |= (vga.crtc.word_mode & 1) << 6;
+			res |= (vga.crtc.aw & 1) << 5;
+			res |= (vga.crtc.div2 & 1) << 3;
+			res |= (vga.crtc.sldiv & 1) << 2;
+			res |= (vga.crtc.map14 & 1) << 1;
+			res |= (vga.crtc.map13 & 1) << 0;
+			break;
+		case 0x18:
+			res = vga.crtc.line_compare & 0xff;
+			break;
 		default:
 			printf("Unhandled CRTC reg r %02x\n",index);
+			break;
 	}
 
 	return res;
 }
-#endif
 
-static void recompute_params(running_machine &machine)
+static void recompute_params_clock(running_machine &machine, int divisor, int xtal)
 {
 	int vblank_period,hblank_period;
 	attoseconds_t refresh;
-	UINT8 hclock_m;
+	UINT8 hclock_m = (!GRAPHIC_MODE) ? CHAR_WIDTH : 8;
 	int pixel_clock;
 
-	hclock_m = (!GRAPHIC_MODE) ? CHAR_WIDTH : 8;
-
 	/* safety check */
 	if(!vga.crtc.horz_disp_end || !vga.crtc.vert_disp_end || !vga.crtc.horz_total || !vga.crtc.vert_total)
 		return;
 
-	rectangle visarea(0, ((vga.crtc.horz_disp_end + 1) * hclock_m)-1, 0, vga.crtc.vert_disp_end);
+	rectangle visarea(0, ((vga.crtc.horz_disp_end + 1) * ((float)(hclock_m)/divisor))-1, 0, vga.crtc.vert_disp_end);
 
 	vblank_period = (vga.crtc.vert_total + 2);
-	hblank_period = ((vga.crtc.horz_total + 5) * hclock_m);
+	hblank_period = ((vga.crtc.horz_total + 5) * ((float)(hclock_m)/divisor));
 
 	/* TODO: 10b and 11b settings aren't known */
-	pixel_clock  = (vga.miscellaneous_output & 0xc) ? XTAL_28_63636MHz : XTAL_25_1748MHz;
-	pixel_clock /=	(((vga.sequencer.data[1]&8) >> 3) + 1);
+	pixel_clock = xtal / (((vga.sequencer.data[1]&8) >> 3) + 1);
 
 	refresh  = HZ_TO_ATTOSECONDS(pixel_clock) * (hblank_period) * vblank_period;
 
@@ -795,6 +1062,13 @@
 //  popmessage("%d %d\n",vga.crtc.horz_total * 8,vga.crtc.vert_total);
 }
 
+static void recompute_params(running_machine &machine)
+{
+	recompute_params_clock(machine, 1, (vga.miscellaneous_output & 0xc) ? XTAL_28_63636MHz : XTAL_25_1748MHz);
+	if(vga.miscellaneous_output & 8)
+		logerror("Warning: VGA external clock latch selected\n");
+}
+
 static void crtc_reg_write(running_machine &machine, UINT8 index, UINT8 data)
 {
 	/* Doom does this */
@@ -804,44 +1078,62 @@
 	switch(index)
 	{
 		case 0x00:
-			vga.crtc.horz_total = (data & 0xff);
+			if(vga.crtc.protect_enable)
+				break;
+			vga.crtc.horz_total = (vga.crtc.horz_total & ~0xff) | (data & 0xff);
 			recompute_params(machine);
 			break;
 		case 0x01:
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.horz_disp_end = (data & 0xff);
 			recompute_params(machine);
 			break;
-		case 0x02: vga.crtc.horz_blank_start = (data & 0xff); break;
+		case 0x02:
+			if(vga.crtc.protect_enable)
+				break;
+			vga.crtc.horz_blank_start = (data & 0xff);
+			break;
 		case 0x03:
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.horz_blank_end &= ~0x1f;
 			vga.crtc.horz_blank_end |= data & 0x1f;
 			vga.crtc.disp_enable_skew = (data & 0x60) >> 5;
 			vga.crtc.evra = (data & 0x80) >> 7;
 			break;
 		case 0x04:
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.horz_retrace_start = data & 0xff;
 			break;
 		case 0x05:
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.horz_blank_end &= ~0x20;
 			vga.crtc.horz_blank_end |= ((data & 0x80) >> 2);
 			vga.crtc.horz_retrace_skew = ((data & 0x60) >> 5);
 			vga.crtc.horz_retrace_end = data & 0x1f;
 			break;
 		case 0x06:
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.vert_total &= ~0xff;
 			vga.crtc.vert_total |= data & 0xff;
 			recompute_params(machine);
 			break;
 		case 0x07: // Overflow Register
+			vga.crtc.line_compare       &= ~0x100;
+			vga.crtc.line_compare       |= ((data & 0x10) << (8-4));
+			if(vga.crtc.protect_enable)
+				break;
 			vga.crtc.vert_total         &= ~0x300;
 			vga.crtc.vert_retrace_start &= ~0x300;
 			vga.crtc.vert_disp_end      &= ~0x300;
-			vga.crtc.line_compare       &= ~0x100;
 			vga.crtc.vert_blank_start   &= ~0x100;
 			vga.crtc.vert_retrace_start |= ((data & 0x80) << (9-7));
 			vga.crtc.vert_disp_end      |= ((data & 0x40) << (9-6));
 			vga.crtc.vert_total         |= ((data & 0x20) << (9-5));
-			vga.crtc.line_compare       |= ((data & 0x10) << (8-4));
 			vga.crtc.vert_blank_start   |= ((data & 0x08) << (8-3));
 			vga.crtc.vert_retrace_start |= ((data & 0x04) << (8-2));
 			vga.crtc.vert_disp_end      |= ((data & 0x02) << (8-1));
@@ -921,7 +1213,7 @@
 			vga.crtc.line_compare |= data & 0xff;
 			break;
 		default:
-			//printf("Unhandled CRTC reg w %02x %02x\n",index,data);
+			logerror("Unhandled CRTC reg w %02x %02x\n",index,data);
 			break;
 	}
 }
@@ -944,6 +1236,35 @@
 	}
 }
 
+static UINT8 vga_vblank(running_machine &machine)
+{
+	UINT8 res;
+	UINT16 vblank_start,vblank_end,vpos;
+
+	/* calculate vblank start / end positions */
+	res = 0;
+	vblank_start = vga.crtc.vert_blank_start;
+	vblank_end = vga.crtc.vert_blank_start + vga.crtc.vert_blank_end;
+	vpos = machine.primary_screen->vpos();
+
+	/* check if we are under vblank period */
+	if(vblank_end > vga.crtc.vert_total)
+	{
+		vblank_end -= vga.crtc.vert_total;
+		if(vpos >= vblank_start || vpos < vblank_end)
+			res = 1;
+	}
+	else
+	{
+		if(vpos >= vblank_start && vpos < vblank_end)
+			res = 1;
+	}
+
+//  popmessage("%d %d %d",vblank_start,vblank_end,vga.crtc.vert_total);
+
+	return res;
+}
+
 static READ8_HANDLER(vga_crtc_r)
 {
 	UINT8 data = 0xff;
@@ -953,8 +1274,7 @@
 		data = vga.crtc.index;
 		break;
 	case 5:
-		if (vga.crtc.index < vga.svga_intf.crtc_regcount)
-			data = vga.crtc.data[vga.crtc.index];
+		data = crtc_reg_read(vga.crtc.index);
 		break;
 	case 0xa:
 		UINT8 hsync,vsync;
@@ -962,7 +1282,7 @@
 		data = 0;
 
 		hsync = space->machine().primary_screen->hblank() & 1;
-		vsync = space->machine().primary_screen->vblank() & 1;
+		vsync = vga_vblank(space->machine()); //space->machine().primary_screen->vblank() & 1;
 
 		data |= (hsync | vsync) & 1; // DD - display disable register
 		data |= (vsync & 1) << 3; // VRetrace register
@@ -999,10 +1319,6 @@
 {
 	switch (offset)
 	{
-		case 0xa:
-			vga.feature_control = data;
-			break;
-
 		case 4:
 			vga.crtc.index = data;
 			break;
@@ -1016,9 +1332,6 @@
 					data);
 			}
 
-			if (vga.crtc.index < vga.svga_intf.crtc_regcount)
-				vga.crtc.data[vga.crtc.index] = data;
-
 			crtc_reg_write(space->machine(),vga.crtc.index,data);
 			//space->machine().primary_screen->update_partial(space->machine().primary_screen->vpos());
 			#if 0
@@ -1026,6 +1339,10 @@
 				printf("%02x %02x %d\n",vga.crtc.index,data,space->machine().primary_screen->vpos());
 			#endif
 			break;
+
+		case 0xa:
+			vga.feature_control = data;
+			break;
 	}
 }
 
@@ -1039,18 +1356,66 @@
 	return data;
 }
 
-READ8_HANDLER( vga_port_03c0_r )
+static UINT8 gc_reg_read(running_machine &machine,UINT8 index)
 {
-	UINT8 data = 0xff;
+	UINT8 res;
 
-	switch (offset)
+	switch(index)
 	{
-		case 0:
-			data = vga.attribute.index;
+		case 0x00:
+			res = vga.gc.set_reset & 0xf;
 			break;
-		case 1:
-			if( vga.attribute.index & 0x20) // protection bit
-				data = 0xff;
+		case 0x01:
+			res = vga.gc.enable_set_reset & 0xf;
+			break;
+		case 0x02:
+			res = vga.gc.color_compare & 0xf;
+			break;
+		case 0x03:
+			res  = (vga.gc.logical_op & 3) << 3;
+			res |= (vga.gc.rotate_count & 7);
+			break;
+		case 0x04:
+			res = vga.gc.read_map_sel & 3;
+			break;
+		case 0x05:
+			res  = (vga.gc.shift256 & 1) << 6;
+			res |= (vga.gc.shift_reg & 1) << 5;;
+			res |= (vga.gc.host_oe & 1) << 4;
+			res |= (vga.gc.read_mode & 1) << 3;
+			res |= (vga.gc.write_mode & 3);
+			break;
+		case 0x06:
+			res  = (vga.gc.memory_map_sel & 3) << 2;
+			res |= (vga.gc.chain_oe & 1) << 1;
+			res |= (vga.gc.alpha_dis & 1);
+			break;
+		case 0x07:
+			res = vga.gc.color_dont_care & 0xf;
+			break;
+		case 0x08:
+			res = vga.gc.bit_mask & 0xff;
+			break;
+		default:
+			res = 0xff;
+			break;
+	}
+
+	return res;
+}
+
+READ8_HANDLER( vga_port_03c0_r )
+{
+	UINT8 data = 0xff;
+
+	switch (offset)
+	{
+		case 0:
+			data = vga.attribute.index;
+			break;
+		case 1:
+			if(vga.attribute.index&0x20)
+				data = vga.attribute.index; // TODO: open bus
 			else if ((vga.attribute.index&0x1f)<sizeof(vga.attribute.data))
 				data=vga.attribute.data[vga.attribute.index&0x1f];
 			break;
@@ -1141,8 +1506,7 @@
 			break;
 
 		case 0xf:
-			if (vga.gc.index < vga.svga_intf.gc_regcount)
-				data = vga.gc.data[vga.gc.index];
+			data = gc_reg_read(space->machine(),vga.gc.index);
 			break;
 	}
 	return data;
@@ -1175,6 +1539,7 @@
 {
 	if((index & 0x30) == 0)
 	{
+		//if(vga.sequencer.data[1]&0x20) // ok?
 		vga.attribute.data[index & 0x1f] = data & 0x3f;
 	}
 	else
@@ -1185,7 +1550,7 @@
 			case 0x10: vga.attribute.data[0x10] = data; break;
 			case 0x11: vga.attribute.data[0x11] = data; break;
 			case 0x12: vga.attribute.data[0x12] = data; break;
-			case 0x13: vga.attribute.data[0x13] = data; break;
+			case 0x13: vga.attribute.pel_shift = vga.attribute.data[0x13] = data; break;
 			case 0x14: vga.attribute.data[0x14] = data; break;
 		}
 	}
@@ -1195,19 +1560,44 @@
 {
 	switch(index)
 	{
+		case 0x00:
+			vga.gc.set_reset = data & 0xf;
+			break;
+		case 0x01:
+			vga.gc.enable_set_reset = data & 0xf;
+			break;
 		case 0x02:
 			vga.gc.color_compare = data & 0xf;
 			break;
+		case 0x03:
+			vga.gc.logical_op = (data & 0x18) >> 3;
+			vga.gc.rotate_count = data & 7;
+			break;
 		case 0x04:
 			vga.gc.read_map_sel = data & 3;
 			break;
 		case 0x05:
+			vga.gc.shift256 = (data & 0x40) >> 6;
+			vga.gc.shift_reg = (data & 0x20) >> 5;
+			vga.gc.host_oe = (data & 0x10) >> 4;
 			vga.gc.read_mode = (data & 8) >> 3;
 			vga.gc.write_mode = data & 3;
+			//if(data & 0x10 && vga.gc.alpha_dis)
+			//  popmessage("Host O/E enabled, contact MAMEdev");
+			break;
+		case 0x06:
+			vga.gc.memory_map_sel = (data & 0xc) >> 2;
+			vga.gc.chain_oe = (data & 2) >> 1;
+			vga.gc.alpha_dis = (data & 1);
+			//if(data & 2 && vga.gc.alpha_dis)
+			//  popmessage("Chain O/E enabled, contact MAMEdev");
 			break;
 		case 0x07:
 			vga.gc.color_dont_care = data & 0xf;
 			break;
+		case 0x08:
+			vga.gc.bit_mask = data & 0xff;
+			break;
 	}
 }
 
@@ -1291,18 +1681,6 @@
 		vga.gc.index=data;
 		break;
 	case 0xf:
-		if (LOG_REGISTERS)
-		{
-			logerror("vga_port_03c0_w(): GC[0x%02X%s] = 0x%02X\n",
-				vga.gc.index,
-				(vga.gc.index < vga.svga_intf.gc_regcount) ? "" : "?",
-				data);
-		}
-		if (vga.gc.index < vga.svga_intf.gc_regcount)
-		{
-			vga.gc.data[vga.gc.index] = data;
-		}
-
 		gc_reg_write(space->machine(),vga.gc.index,data);
 		break;
 	}
@@ -1330,14 +1708,13 @@
 	vga.crtc.index = 0;
 	memset(vga.crtc.data, 0, vga.svga_intf.crtc_regcount * sizeof(*vga.crtc.data));
 	vga.gc.index = 0;
-	memset(vga.gc.data, 0, vga.svga_intf.gc_regcount * sizeof(*vga.gc.data));
 	memset(vga.gc.latch, 0, sizeof(vga.gc.latch));
 	memset(&vga.attribute, 0, sizeof(vga.attribute));
 	memset(&vga.dac, 0, sizeof(vga.dac));
 	memset(&vga.cursor, 0, sizeof(vga.cursor));
 	memset(&vga.oak, 0, sizeof(vga.oak));
 
-	vga.gc.data[6] = 0xc; /* prevent xtbios excepting vga ram as system ram */
+	vga.gc.memory_map_sel = 0x3; /* prevent xtbios excepting vga ram as system ram */
 /* amstrad pc1640 bios relies on the position of
    the video memory area,
    so I introduced the reset to switch to b8000 area */
@@ -1350,7 +1727,7 @@
 READ8_HANDLER(vga_mem_r)
 {
 	/* TODO: check me */
-	switch((vga.gc.data[6] >> 2) & 0x03)
+	switch(vga.gc.memory_map_sel & 0x03)
 	{
 		case 0: break;
 		case 1: offset &= 0x0ffff; break;
@@ -1361,26 +1738,19 @@
 	if(vga.sequencer.data[4] & 4)
 	{
 		int data;
-		vga.gc.latch[0]=vga.memory[(offset)];
-		vga.gc.latch[1]=vga.memory[(offset)+0x20000];
-		vga.gc.latch[2]=vga.memory[(offset)+0x40000];
-		vga.gc.latch[3]=vga.memory[(offset)+0x60000];
+		if (!space->debugger_access())
+		{
+			vga.gc.latch[0]=vga.memory[(offset)];
+			vga.gc.latch[1]=vga.memory[(offset)+0x10000];
+			vga.gc.latch[2]=vga.memory[(offset)+0x20000];
+			vga.gc.latch[3]=vga.memory[(offset)+0x30000];
+		}
 
 		if (vga.gc.read_mode)
 		{
 			UINT8 byte,layer;
 			UINT8 fill_latch;
 			data=0;
-			#if 0
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 0)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=1;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 1)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=2;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 2)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=4;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 3)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=8;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 4)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=0x10;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 5)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=0x20;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 6)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=0x40;
-			if (!(ega_bitplane_to_packed(vga.gc.latch, 7)^(vga.gc.color_compare&vga.gc.color_dont_care))) data|=0x80;
-			#endif
 
 			for(byte=0;byte<8;byte++)
 			{
@@ -1411,7 +1781,7 @@
 		for(i=0;i<4;i++)
 		{
 			if(vga.sequencer.map_mask & 1 << i)
-				data |= vga.memory[offset+i*0x20000];
+				data |= vga.memory[offset+i*0x10000];
 		}
 
 		return data;
@@ -1423,7 +1793,7 @@
 WRITE8_HANDLER(vga_mem_w)
 {
 	//Inside each case must prevent writes to non-mapped VGA memory regions, not only mask the offset.
-	switch((vga.gc.data[6] >> 2) & 0x03)
+	switch(vga.gc.memory_map_sel & 0x03)
 	{
 		case 0: break;
 		case 1:
@@ -1452,7 +1822,7 @@
 		for(i=0;i<4;i++)
 		{
 			if(vga.sequencer.map_mask & 1 << i)
-				vga.memory[offset+i*0x20000] = (vga.sequencer.data[4] & 4) ? vga_latch_write(i,data) : data;
+				vga.memory[offset+i*0x10000] = (vga.sequencer.data[4] & 4) ? vga_latch_write(i,data) : data;
 		}
 		return;
 	}
@@ -1460,18 +1830,8 @@
 
 void pc_vga_init(running_machine &machine, read8_space_func read_dipswitch, const struct pc_svga_interface *svga_intf)
 {
-	int i, j, k, mask1;
-
 	memset(&vga, 0, sizeof(vga));
 
-	for (k=0;k<4;k++)
-	{
-		for (mask1=0x80, j=0; j<8; j++, mask1>>=1)
-		{
-			for  (i=0; i<256; i++)
-				color_bitplane_to_packed[k][j][i]=(i&mask1)?(1<<k):0;
-		}
-	}
 	/* copy over interfaces */
 	vga.read_dipswitch = read_dipswitch;
 	if (svga_intf)
@@ -1480,8 +1840,6 @@
 
 		if (vga.svga_intf.seq_regcount < 0x05)
 			fatalerror("Invalid SVGA sequencer register count");
-		if (vga.svga_intf.gc_regcount < 0x09)
-			fatalerror("Invalid SVGA GC register count");
 		if (vga.svga_intf.crtc_regcount < 0x19)
 			fatalerror("Invalid SVGA CRTC register count");
 	}
@@ -1489,18 +1847,15 @@
 	{
 		vga.svga_intf.vram_size = 0x100000;
 		vga.svga_intf.seq_regcount = 0x05;
-		vga.svga_intf.gc_regcount = 0x09;
 		vga.svga_intf.crtc_regcount = 0x19;
 	}
 
 	vga.memory			= auto_alloc_array(machine, UINT8, vga.svga_intf.vram_size);
 	vga.sequencer.data	= auto_alloc_array(machine, UINT8, vga.svga_intf.seq_regcount);
 	vga.crtc.data		= auto_alloc_array(machine, UINT8, 0x100);
-	vga.gc.data			= auto_alloc_array(machine, UINT8, vga.svga_intf.gc_regcount);
 	memset(vga.memory, '\0', vga.svga_intf.vram_size);
 	memset(vga.sequencer.data, '\0', vga.svga_intf.seq_regcount);
 	memset(vga.crtc.data, '\0', 0x100);
-	memset(vga.gc.data, '\0', vga.svga_intf.gc_regcount);
 
 	pc_vga_reset(machine);
 
@@ -1591,17 +1946,81 @@
 
 ******************************************/
 
+static void tseng_define_video_mode(running_machine &machine)
+{
+	int divisor;
+	int xtal = 0;
+	svga.rgb8_en = 0;
+	svga.rgb15_en = 0;
+	svga.rgb16_en = 0;
+	svga.rgb24_en = 0;
+	switch(((et4k.aux_ctrl << 1) & 4)|(vga.miscellaneous_output & 0xc)>>2)
+	{
+		case 0:
+			xtal = XTAL_25_1748MHz;
+			break;
+		case 1:
+			xtal = XTAL_28_63636MHz;
+			break;
+		case 2:
+			xtal = 16257000*2; //2xEGA clock
+			break;
+		case 3:
+			xtal = XTAL_40MHz;
+			break;
+		case 4:
+			xtal = XTAL_36MHz;
+			break;
+		case 5:
+			xtal = XTAL_45MHz;
+			break;
+		case 6:
+			xtal = 31000000;
+			break;
+		case 7:
+			xtal = 38000000;
+			break;
+	}
+	switch(et4k.dac_ctrl & 0xe0)
+	{
+		case 0xa0:
+			svga.rgb15_en = 1;
+			divisor = 2;
+			break;
+		case 0xe0:
+			svga.rgb16_en = 1;
+			divisor = 2;
+			break;
+		case 0x60:
+			svga.rgb24_en = 1;
+			divisor = 3;
+			xtal *= 2.0f/3.0f;
+			break;
+		default:
+			svga.rgb8_en = (!(vga.sequencer.data[1] & 8) && (vga.sequencer.data[4] & 8) && vga.gc.shift256 && vga.crtc.div2 && GRAPHIC_MODE);
+			divisor = 1;
+			break;
+	}
+	recompute_params_clock(machine, divisor, xtal);
+}
+
 static UINT8 tseng_crtc_reg_read(running_machine &machine, UINT8 index)
 {
 	UINT8 res;
 
 	res = 0;
 	if(index <= 0x18)
-		res = vga.crtc.data[index];
+		res = crtc_reg_read(index);
 	else
 	{
 		switch(index)
 		{
+			case 0x34:
+				res = et4k.aux_ctrl;
+				break;
+			case 0x3f:
+				res = et4k.horz_overflow;
+				break;
 			default:
 				res = vga.crtc.data[index];
 				//printf("%02x\n",index);
@@ -1612,7 +2031,6 @@
 	return res;
 }
 
-
 static void tseng_crtc_reg_write(running_machine &machine, UINT8 index, UINT8 data)
 {
 	if(index <= 0x18)
@@ -1621,6 +2039,13 @@
 	{
 		switch(index)
 		{
+			case 0x34:
+				et4k.aux_ctrl = data;
+				break;
+			case 0x3f:
+				et4k.horz_overflow = data;
+				vga.crtc.horz_total = (vga.crtc.horz_total & 0xff) | ((data & 1) << 8);
+				break;
 			default:
 				//printf("%02x %02x\n",index,data);
 				break;
@@ -1656,7 +2081,6 @@
 	{
 		vga.sequencer.data[vga.sequencer.index] = data;
 		seq_reg_write(machine,vga.sequencer.index,data);
-		recompute_params(machine);
 	}
 	else
 	{
@@ -1670,6 +2094,55 @@
 	}
 }
 
+READ8_HANDLER(tseng_et4k_03b0_r)
+{
+	UINT8 res = 0xff;
+
+	if (CRTC_PORT_ADDR == 0x3b0)
+	{
+		switch(offset)
+		{
+			case 5:
+				res = tseng_crtc_reg_read(space->machine(),vga.crtc.index);
+				break;
+			case 8:
+				res = et4k.reg_3d8;
+				break;
+			default:
+				res = vga_port_03b0_r(space,offset);
+				break;
+		}
+	}
+
+	return res;
+}
+
+WRITE8_HANDLER(tseng_et4k_03b0_w)
+{
+	if (CRTC_PORT_ADDR == 0x3b0)
+	{
+		switch(offset)
+		{
+			case 5:
+				vga.crtc.data[vga.crtc.index] = data;
+				tseng_crtc_reg_write(space->machine(),vga.crtc.index,data);
+				break;
+			case 8:
+				et4k.reg_3d8 = data;
+				if(data == 0xa0)
+					et4k.ext_reg_ena = true;
+				else if(data == 0x29)
+					et4k.ext_reg_ena = false;
+				break;
+			default:
+				vga_port_03b0_w(space,offset,data);
+				break;
+		}
+	}
+	tseng_define_video_mode(space->machine());
+}
+
+
 READ8_HANDLER(tseng_et4k_03c0_r)
 {
 	UINT8 res;
@@ -1683,6 +2156,19 @@
 			res = svga.bank_w & 0xf;
 			res |= (svga.bank_r & 0xf) << 4;
 			break;
+		case 0x06:
+			if(et4k.dac_state == 4)
+			{
+				if(!et4k.dac_ctrl)
+					et4k.dac_ctrl = 0x80;
+				res = et4k.dac_ctrl;
+				break;
+			}
+			et4k.dac_state++;
+			res = vga_port_03c0_r(space,offset);
+			break;
+		case 0x08:
+			et4k.dac_state = 0;
 		default:
 			res = vga_port_03c0_r(space,offset);
 			break;
@@ -1702,10 +2188,17 @@
 			svga.bank_w = data & 0xf;
 			svga.bank_r = (data & 0xf0) >> 4;
 			break;
+		case 0x06:
+			if(et4k.dac_state == 4)
+			{
+				et4k.dac_ctrl = data;
+				break;
+			}
 		default:
 			vga_port_03c0_w(space,offset,data);
 			break;
 	}
+	tseng_define_video_mode(space->machine());
 }
 
 READ8_HANDLER(tseng_et4k_03d0_r)
@@ -1719,6 +2212,9 @@
 			case 5:
 				res = tseng_crtc_reg_read(space->machine(),vga.crtc.index);
 				break;
+			case 8:
+				res = et4k.reg_3d8;
+				break;
 			default:
 				res = vga_port_03d0_r(space,offset);
 				break;
@@ -1737,21 +2233,27 @@
 			case 5:
 				vga.crtc.data[vga.crtc.index] = data;
 				tseng_crtc_reg_write(space->machine(),vga.crtc.index,data);
+				//if((vga.crtc.index & 0xfe) != 0x0e)
+				//  printf("%02x %02x %d\n",vga.crtc.index,data,space->machine().primary_screen->vpos());
 				break;
-			/* TODO: investigate about this */
 			case 8:
-				svga.rgb8_en = data & 0x80;
+				et4k.reg_3d8 = data;
+				if(data == 0xa0)
+					et4k.ext_reg_ena = true;
+				else if(data == 0x29)
+					et4k.ext_reg_ena = false;
 				break;
 			default:
 				vga_port_03d0_w(space,offset,data);
 				break;
 		}
 	}
+	tseng_define_video_mode(space->machine());
 }
 
 READ8_HANDLER( tseng_mem_r )
 {
-	if(svga.rgb8_en)
+	if(svga.rgb8_en || svga.rgb15_en || svga.rgb16_en || svga.rgb24_en)
 	{
 		offset &= 0xffff;
 		return vga.memory[(offset+svga.bank_r*0x10000)];
@@ -1762,7 +2264,7 @@
 
 WRITE8_HANDLER( tseng_mem_w )
 {
-	if(svga.rgb8_en)
+	if(svga.rgb8_en || svga.rgb15_en || svga.rgb16_en || svga.rgb24_en)
 	{
 		offset &= 0xffff;
 		vga.memory[(offset+svga.bank_w*0x10000)] = data;
@@ -1956,3 +2458,291 @@
 
 	vga_mem_w(space,offset,data);
 }
+
+/******************************************
+
+S3 implementation
+
+******************************************/
+
+static UINT8 s3_crtc_reg_read(running_machine &machine, UINT8 index)
+{
+	UINT8 res;
+
+	res = 0;
+	if(index <= 0x18)
+		res = crtc_reg_read(index);
+	else
+	{
+		switch(index)
+		{
+			case 0x30: // CR30 Chip ID/REV register
+				res = 0xc0; // TODO: hardcoded to Vision 86c864
+				break;
+			case 0x31:
+				res = s3.memory_config;
+				break;
+			case 0x35:
+				res = s3.crt_reg_lock;
+				break;
+			case 0x38:
+				res = s3.reg_lock1;
+				break;
+			case 0x39:
+				res = s3.reg_lock2;
+				break;
+			case 0x42: // CR42 Mode Control
+				res = 0x0d; // hardcode to non-interlace
+				break;
+			case 0x67:
+				res = s3.ext_misc_ctrl_2;
+				break;
+			case 0x6a:
+				res = svga.bank_r & 0x7f;
+				break;
+			default:
+				res = vga.crtc.data[index];
+				//debugger_break(machine);
+				//printf("%02x\n",index);
+				break;
+		}
+	}
+
+	return res;
+}
+
+static void s3_define_video_mode(void)
+{
+	if((s3.ext_misc_ctrl_2) >> 4)
+	{
+		svga.rgb8_en = 0;
+		svga.rgb15_en = 0;
+		svga.rgb16_en = 0;
+		svga.rgb32_en = 0;
+		switch((s3.ext_misc_ctrl_2) >> 4)
+		{
+			case 0x03: svga.rgb15_en = 1; break;
+			case 0x05: svga.rgb16_en = 1; break;
+			case 0x0d: svga.rgb32_en = 1; break;
+			default: fatalerror("TODO: s3 video mode not implemented %02x",((s3.ext_misc_ctrl_2) >> 4)); break;
+		}
+	}
+	else
+	{
+		svga.rgb8_en = (s3.memory_config & 8) >> 3;
+		svga.rgb15_en = 0;
+		svga.rgb16_en = 0;
+		svga.rgb32_en = 0;
+	}
+}
+
+static void s3_crtc_reg_write(running_machine &machine, UINT8 index, UINT8 data)
+{
+	if(index <= 0x18)
+		crtc_reg_write(machine,index,data);
+	else
+	{
+		switch(index)
+		{
+			case 0x31: // CR31 Memory Configuration Register
+				s3.memory_config = data;
+				vga.crtc.start_addr &= ~0x30000;
+				vga.crtc.start_addr |= ((data & 0x30) << 12);
+				//popmessage("%02x",data);
+				s3_define_video_mode();
+				break;
+			case 0x35:
+				if((s3.reg_lock1 & 0xc) != 8 || ((s3.reg_lock1 & 0xc0) == 0)) // lock register
+					return;
+				s3.crt_reg_lock = data;
+				svga.bank_w = data & 0xf;
+				svga.bank_r = svga.bank_w;
+				break;
+			case 0x38:
+				s3.reg_lock1 = data;
+				break;
+			case 0x39:
+				/* TODO: reg lock mechanism */
+				s3.reg_lock2 = data;
+				break;
+			case 0x51:
+				vga.crtc.start_addr &= ~0xc0000;
+				vga.crtc.start_addr |= ((data & 0x3) << 18);
+				break;
+			case 0x67:
+				s3.ext_misc_ctrl_2 = data;
+				s3_define_video_mode();
+				//printf("%02x X\n",data);
+				//debugger_break(machine);
+				break;
+			case 0x6a:
+				svga.bank_w = data & 0xf;
+				svga.bank_r = svga.bank_w;
+				if(data & 0x60)
+					fatalerror("TODO: s3 bank selects above 1M");
+				break;
+			default:
+				//printf("%02x %02x\n",index,data);
+				break;
+		}
+	}
+}
+
+
+READ8_HANDLER(s3_port_03b0_r)
+{
+	UINT8 res = 0xff;
+
+	if (CRTC_PORT_ADDR == 0x3b0)
+	{
+		switch(offset)
+		{
+			case 5:
+				res = s3_crtc_reg_read(space->machine(),vga.crtc.index);
+				break;
+			default:
+				res = vga_port_03b0_r(space,offset);
+				break;
+		}
+	}
+
+	return res;
+}
+
+WRITE8_HANDLER(s3_port_03b0_w)
+{
+	if (CRTC_PORT_ADDR == 0x3b0)
+	{
+		switch(offset)
+		{
+			case 5:
+				vga.crtc.data[vga.crtc.index] = data;
+				s3_crtc_reg_write(space->machine(),vga.crtc.index,data);
+				break;
+			default:
+				vga_port_03b0_w(space,offset,data);
+				break;
+		}
+	}
+}
+
+READ8_HANDLER(s3_port_03c0_r)
+{
+	UINT8 res;
+
+	switch(offset)
+	{
+		default:
+			res = vga_port_03c0_r(space,offset);
+			break;
+	}
+
+	return res;
+}
+
+WRITE8_HANDLER(s3_port_03c0_w)
+{
+	switch(offset)
+	{
+		default:
+			vga_port_03c0_w(space,offset,data);
+			break;
+	}
+}
+
+READ8_HANDLER(s3_port_03d0_r)
+{
+	UINT8 res = 0xff;
+
+	if (CRTC_PORT_ADDR == 0x3d0)
+	{
+		switch(offset)
+		{
+			case 5:
+				res = s3_crtc_reg_read(space->machine(),vga.crtc.index);
+				break;
+			default:
+				res = vga_port_03d0_r(space,offset);
+				break;
+		}
+	}
+
+	return res;
+}
+
+WRITE8_HANDLER(s3_port_03d0_w)
+{
+	if (CRTC_PORT_ADDR == 0x3d0)
+	{
+		switch(offset)
+		{
+			case 5:
+				vga.crtc.data[vga.crtc.index] = data;
+				s3_crtc_reg_write(space->machine(),vga.crtc.index,data);
+				break;
+			default:
+				vga_port_03d0_w(space,offset,data);
+				break;
+		}
+	}
+}
+
+/* accelerated ports, TBD ... */
+READ8_HANDLER(s3_port_9ae8_r)
+{
+	return 0;
+}
+
+WRITE8_HANDLER(s3_port_9ae8_w)
+{
+	// ...
+}
+
+READ8_HANDLER( s3_mem_r )
+{
+	if (svga.rgb8_en || svga.rgb15_en || svga.rgb16_en || svga.rgb32_en)
+	{
+		int data;
+		if(offset & 0x10000)
+			return 0;
+		data = 0;
+		if(vga.sequencer.data[4] & 0x8)
+			data = vga.memory[offset + (svga.bank_r*0x10000)];
+		else
+		{
+			int i;
+
+			for(i=0;i<4;i++)
+			{
+				if(vga.sequencer.map_mask & 1 << i)
+					data |= vga.memory[offset*4+i+(svga.bank_r*0x10000)];
+			}
+		}
+		return data;
+	}
+	return vga_mem_r(space,offset);
+}
+
+WRITE8_HANDLER( s3_mem_w )
+{
+	if (svga.rgb8_en || svga.rgb15_en || svga.rgb16_en || svga.rgb32_en)
+	{
+		//printf("%08x %02x (%02x %02x) %02X\n",offset,data,vga.sequencer.map_mask,svga.bank_w,(vga.sequencer.data[4] & 0x08));
+		if(offset & 0x10000)
+			return;
+		if(vga.sequencer.data[4] & 0x8)
+			vga.memory[offset + (svga.bank_w*0x10000)] = data;
+		else
+		{
+			int i;
+			for(i=0;i<4;i++)
+			{
+				if(vga.sequencer.map_mask & 1 << i)
+					vga.memory[offset*4+i+(svga.bank_w*0x10000)] = data;
+			}
+		}
+		return;
+	}
+
+	vga_mem_w(space,offset,data);
+}
diff -Nru src-old/emu/video/pc_vga.h src/emu/video/pc_vga.h
--- src-old/emu/video/pc_vga.h	2012-02-02 19:59:07.000000000 +0100
+++ src/emu/video/pc_vga.h	2012-02-16 15:02:34.000000000 +0100
@@ -20,7 +20,7 @@
 	int seq_regcount;
 	int gc_regcount;
 	int crtc_regcount;
-	void (*choosevideomode)(running_machine &machine, bitmap_rgb32 &bitmap, const rectangle &cliprect, const UINT8 *sequencer, const UINT8 *crtc, const UINT8 *gc, int *width, int *height);
+	void (*choosevideomode)(running_machine &machine, bitmap_rgb32 &bitmap, const rectangle &cliprect, const UINT8 *sequencer, const UINT8 *crtc, int *width, int *height);
 };
 
 void pc_vga_init(running_machine &machine, read8_space_func read_dipswitch, const struct pc_svga_interface *svga_intf);
@@ -41,6 +41,8 @@
 WRITE8_HANDLER(vga_mem_w);
 
 /* per-device implementations */
+READ8_HANDLER(tseng_et4k_03b0_r);
+WRITE8_HANDLER(tseng_et4k_03b0_w);
 READ8_HANDLER(tseng_et4k_03c0_r);
 WRITE8_HANDLER(tseng_et4k_03c0_w);
 READ8_HANDLER(tseng_et4k_03d0_r);
@@ -55,6 +57,17 @@
 READ8_HANDLER(trident_mem_r);
 WRITE8_HANDLER(trident_mem_w);
 
+READ8_HANDLER(s3_port_03b0_r);
+WRITE8_HANDLER(s3_port_03b0_w);
+READ8_HANDLER(s3_port_03c0_r);
+WRITE8_HANDLER(s3_port_03c0_w);
+READ8_HANDLER(s3_port_03d0_r);
+WRITE8_HANDLER(s3_port_03d0_w);
+READ8_HANDLER(s3_port_9ae8_r);
+WRITE8_HANDLER(s3_port_9ae8_w);
+READ8_HANDLER(s3_mem_r);
+WRITE8_HANDLER(s3_mem_w);
+
 /*
   pega notes (paradise)
   build in amstrad pc1640
diff -Nru src-old/emu/video/polynew.h src/emu/video/polynew.h
--- src-old/emu/video/polynew.h	2012-01-21 21:39:52.000000000 +0100
+++ src/emu/video/polynew.h	2012-02-11 20:22:43.000000000 +0100
@@ -112,6 +112,7 @@
 			_BaseType start;					// parameter value at start
 			_BaseType dpdx;						// dp/dx relative to start
 		} param[_MaxParams];
+		void *userdata;							// custom per-span data
 	};
 
 	// delegate type for scanline callbacks
@@ -568,6 +569,7 @@
 			extent_t &extent = unit.extent[extnum];
 			extent.startx = istartx;
 			extent.stopx = istopx;
+			extent.userdata = NULL;
 			pixels += istopx - istartx;
 
 			// fill in the parameters for the extent
@@ -749,6 +751,7 @@
 			extent_t &extent = unit.extent[extnum];
 			extent.startx = istartx;
 			extent.stopx = istopx;
+			extent.userdata = NULL;
 			pixels += istopx - istartx;
 
 			// fill in the parameters for the extent
@@ -847,17 +850,13 @@
 			const extent_t &srcextent = extents[(curscan + extnum) - startscanline];
 			INT32 istartx = srcextent.startx, istopx = srcextent.stopx;
 
-			// force start < stop
-			if (istartx > istopx)
-			{
-				INT32 temp = istartx;
-				istartx = istopx;
-				istopx = temp;
-			}
-
 			// apply left/right clipping
 			if (istartx < cliprect.min_x)
 				istartx = cliprect.min_x;
+			if (istartx > cliprect.max_x)
+				istartx = cliprect.max_x + 1;
+			if (istopx < cliprect.min_x)
+				istopx = cliprect.min_x;
 			if (istopx > cliprect.max_x)
 				istopx = cliprect.max_x + 1;
 
@@ -865,8 +864,19 @@
 			extent_t &extent = unit.extent[extnum];
 			extent.startx = istartx;
 			extent.stopx = istopx;
+
+			// fill in the parameters for the extent
+			for (int paramnum = 0; paramnum < _MaxParams; paramnum++)
+			{
+				extent.param[paramnum].start = srcextent.param[paramnum].start;
+				extent.param[paramnum].dpdx = srcextent.param[paramnum].dpdx;
+			}
+
+			extent.userdata = srcextent.userdata;
 			if (istartx < istopx)
 				pixels += istopx - istartx;
+			else if(istopx < istartx)
+				pixels += istartx - istopx;
 		}
 	}
 
@@ -1064,6 +1074,7 @@
 				istartx = istopx = 0;
 			extent.startx = istartx;
 			extent.stopx = istopx;
+			extent.userdata = NULL;
 			pixels += istopx - istartx;
 		}
 	}
diff -Nru src-old/emu/video/voodoo.c src/emu/video/voodoo.c
--- src-old/emu/video/voodoo.c	2012-01-24 21:18:55.000000000 +0100
+++ src/emu/video/voodoo.c	2012-02-06 02:30:22.000000000 +0100
@@ -174,7 +174,6 @@
 #define EXPAND_RASTERIZERS
 
 #include "emu.h"
-#include "profiler.h"
 #include "video/poly.h"
 #include "video/rgbutil.h"
 #include "voodoo.h"
diff -Nru src-old/ldplayer/ldplayer.c src/ldplayer/ldplayer.c
--- src-old/ldplayer/ldplayer.c	2012-02-02 16:14:43.000000000 +0100
+++ src/ldplayer/ldplayer.c	2012-02-19 16:23:23.000000000 +0100
@@ -11,7 +11,6 @@
 
 #include "emu.h"
 #include "emuopts.h"
-#include "uimenu.h"
 #include "cpu/mcs48/mcs48.h"
 #include "machine/ldpr8210.h"
 #include "machine/ldv1000.h"
@@ -167,8 +166,6 @@
 
 	// iterate while we get new objects
 	const osd_directory_entry *dir;
-	emu_file *image_file = NULL;
-	chd_file *image_chd = NULL;
 	while ((dir = path.next()) != NULL)
 	{
 		int length = strlen(dir->name);
@@ -181,15 +178,17 @@
 			tolower(dir->name[length - 1]) == 'd')
 		{
 			// open the file itself via our search path
-			image_file = auto_alloc(machine(), emu_file(machine().options().media_path(), OPEN_FLAG_READ));
-			file_error filerr = image_file->open(dir->name);
+			emu_file image_file(machine().options().media_path(), OPEN_FLAG_READ);
+			file_error filerr = image_file.open(dir->name);
 			if (filerr == FILERR_NONE)
 			{
+				astring fullpath(image_file->fullpath();
+				image_file.close();
+
 				// try to open the CHD
-				chd_error chderr = chd_open_file(*image_file, CHD_OPEN_READ, NULL, &image_chd);
-				if (chderr == CHDERR_NONE)
+
+				if (set_disk_handle(machine(), "laserdisc", fullpath) == CHDERR_NONE)
 				{
-					set_disk_handle(machine(), "laserdisc", *image_file, *image_chd);
 					m_filename.cpy(dir->name);
 					break;
 				}
diff -Nru src-old/lib/formats/pc_dsk.c src/lib/formats/pc_dsk.c
--- src-old/lib/formats/pc_dsk.c	2012-01-24 09:38:33.000000000 +0100
+++ src/lib/formats/pc_dsk.c	2012-02-19 16:23:23.000000000 +0100
@@ -138,7 +138,39 @@
 LEGACY_FLOPPY_OPTIONS_END
 
 
-const floppy_image_format_t::desc_e pc_format::pc_desc[] = {
+const floppy_image_format_t::desc_e pc_format::pc_9_desc[] = {
+	{ MFM, 0x4e, 80 },
+	{ MFM, 0x00, 12 },
+	{ RAW, 0x5224, 3 },
+	{ MFM, 0xfc, 1 },
+	{ MFM, 0x4e, 50 },
+	{ MFM, 0x00, 12 },
+	{ SECTOR_LOOP_START, 0, 8 },
+	{   CRC_CCITT_START, 1 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfe, 1 },
+	{     TRACK_ID },
+	{     HEAD_ID },
+	{     SECTOR_ID },
+	{     SIZE_ID },
+	{   CRC_END, 1 },
+	{   CRC, 1 },
+	{   MFM, 0x4e, 22 },
+	{   MFM, 0x00, 12 },
+	{   CRC_CCITT_START, 2 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfb, 1 },
+	{     SECTOR_DATA, -1 },
+	{   CRC_END, 2 },
+	{   CRC, 2 },
+	{   MFM, 0x4e, 84 },
+	{   MFM, 0x00, 12 },
+	{ SECTOR_LOOP_END },
+	{ MFM, 0x4e, 170 },
+	{ END }
+};
+
+const floppy_image_format_t::desc_e pc_format::pc_18_desc[] = {
 	{ MFM, 0x4e, 80 },
 	{ MFM, 0x00, 12 },
 	{ RAW, 0x5224, 3 },
@@ -170,6 +202,53 @@
 	{ END }
 };
 
+const floppy_image_format_t::desc_e pc_format::pc_36_desc[] = {
+	{ MFM, 0x4e, 80 },
+	{ MFM, 0x00, 12 },
+	{ RAW, 0x5224, 3 },
+	{ MFM, 0xfc, 1 },
+	{ MFM, 0x4e, 50 },
+	{ MFM, 0x00, 12 },
+	{ SECTOR_LOOP_START, 0, 35 },
+	{   CRC_CCITT_START, 1 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfe, 1 },
+	{     TRACK_ID },
+	{     HEAD_ID },
+	{     SECTOR_ID },
+	{     SIZE_ID },
+	{   CRC_END, 1 },
+	{   CRC, 1 },
+	{   MFM, 0x4e, 22 },
+	{   MFM, 0x00, 12 },
+	{   CRC_CCITT_START, 2 },
+	{     RAW, 0x4489, 3 },
+	{     MFM, 0xfb, 1 },
+	{     SECTOR_DATA, -1 },
+	{   CRC_END, 2 },
+	{   CRC, 2 },
+	{   MFM, 0x4e, 84 },
+	{   MFM, 0x00, 12 },
+	{ SECTOR_LOOP_END },
+	{ MFM, 0x4e, 1154 },
+	{ END }
+};
+
+const pc_format::format pc_format::formats[] = {
+	{  8*1*40*512, floppy_image::FF_525, floppy_image::SSDD, 40, 1,  8, 0,          000000 },	/* 5 1/4 inch double density single sided */
+	{  8*2*40*512, floppy_image::FF_525, floppy_image::DSDD, 40, 2,  8, 0,          000000 },	/* 5 1/4 inch double density */
+	{  9*1*40*512, floppy_image::FF_525, floppy_image::SSDD, 40, 1,  9, 0,          000000 },	/* 5 1/4 inch double density single sided */
+	{  9*2*40*512, floppy_image::FF_525, floppy_image::DSDD, 40, 2,  9, 0,          000000 },	/* 5 1/4 inch double density */
+	{ 10*2*40*512, floppy_image::FF_525, floppy_image::DSDD, 40, 2, 10, 0,          000000 },	/* 5 1/4 inch double density 10spt */
+	{  9*2*80*512, floppy_image::FF_525, floppy_image::DSDD, 80, 2,  9, 0,          000000 },	/* 80 tracks 5 1/4 inch drives rare in PCs */
+	{  9*2*80*512, floppy_image::FF_35,  floppy_image::DSDD, 80, 2,  9, pc_9_desc,  100000 },	/* 3 1/2 inch double density */
+	{ 15*2*80*512, floppy_image::FF_525, floppy_image::DSHD, 80, 2, 15, 0,          000000 },	/* 5 1/4 inch high density (or japanese 3 1/2 inch high density) */
+	{ 18*2*80*512, floppy_image::FF_35,  floppy_image::DSHD, 80, 2, 18, pc_18_desc, 200000 },	/* 3 1/2 inch high density */
+	{ 21*2*80*512, floppy_image::FF_35,  floppy_image::DSHD, 80, 2, 21, 0,          000000 },	/* 3 1/2 inch high density DMF */
+	{ 36*2*80*512, floppy_image::FF_35,  floppy_image::DSED, 80, 2, 36, pc_36_desc, 400000 },	/* 3 1/2 inch enhanced density */
+	{ 0 },
+};
+
 pc_format::pc_format()
 {
 }
@@ -194,58 +273,75 @@
 	return true;
 }
 
-void pc_format::find_size(io_generic *io, UINT32 form_factor, int &track_count, int &head_count, int &sector_count)
+int pc_format::find_size(io_generic *io, UINT32 form_factor)
 {
 	int size = io_generic_size(io);
-	if(size == 512*18*2*80) {
-		track_count = 80;
-		head_count = 2;
-		sector_count = 18;
-	} else
-		track_count = head_count = sector_count = 0;
+	for(int type = 0; formats[type].size; type++)
+		if(formats[type].size == size && (formats[type].form_factor == form_factor || form_factor == floppy_image::FF_UNKNOWN))
+			return type;
+	return -1;
 }
 
 int pc_format::identify(io_generic *io, UINT32 form_factor)
 {
-	int track_count, head_count, sector_count;
-	find_size(io, form_factor, track_count, head_count, sector_count);
+	int type = find_size(io, form_factor);
 
-	if(track_count)
+	if(type != -1)
 		return 50;
 	return 0;
 }
 
 bool pc_format::load(io_generic *io, UINT32 form_factor, floppy_image *image)
 {
-	int track_count, head_count, sector_count;
-	find_size(io, form_factor, track_count, head_count, sector_count);
+	int type = find_size(io, form_factor);
+	if(type == -1)
+		return false;
+
+	const format &f = formats[type];
+	if(!f.desc)
+		return false;
 
 	UINT8 sectdata[36*512];
 	desc_s sectors[36];
-	for(int i=0; i<sector_count; i++) {
+	for(int i=0; i<f.sector_count; i++) {
 		sectors[i].data = sectdata + 512*i;
 		sectors[i].size = 512;
 		sectors[i].sector_id = i + 1;
 	}
 
-	int track_size = sector_count*512;
-	for(int track=0; track < track_count; track++) {
-		for(int head=0; head < head_count; head++) {
-			io_generic_read(io, sectdata, (track*head_count + head)*track_size, track_size);
-			generate_track(pc_desc,
-						   track, head, sectors, sector_count, 200000, image);
+	int track_size = f.sector_count*512;
+	for(int track=0; track < f.track_count; track++)
+		for(int head=0; head < f.head_count; head++) {
+			io_generic_read(io, sectdata, (track*f.head_count + head)*track_size, track_size);
+			generate_track(f.desc, track, head, sectors, f.sector_count, f.cell_count, image);
 		}
-	}
 
-	image->set_variant(floppy_image::DSHD);
+	image->set_variant(f.variant);
 
 	return true;
 }
 
 bool pc_format::save(io_generic *io, floppy_image *image)
 {
+	int cell_time = 1000;
+	switch(image->get_variant()) {
+	case floppy_image::SSSD:
+		cell_time = 4000; // fm too, actually
+		break;
+	case floppy_image::SSDD:
+	case floppy_image::DSDD:
+		cell_time = 2000;
+		break;
+	case floppy_image::DSHD:
+		cell_time = 1000;
+		break;
+	case floppy_image::DSED:
+		cell_time = 500;
+		break;
+	}
+
 	int track_count, head_count, sector_count;
-	get_geometry_mfm_pc(image, 1000, track_count, head_count, sector_count);
+	get_geometry_mfm_pc(image, cell_time, track_count, head_count, sector_count);
 
 	if(track_count < 80)
 		track_count = 80;
@@ -258,15 +354,15 @@
 
 	if(sector_count > 36)
 		sector_count = 36;
-	else if(sector_count < 9)
-		sector_count = 9;
+	else if(sector_count < 8)
+		sector_count = 8;
 
 	UINT8 sectdata[36*512];
 	int track_size = sector_count*512;
 
 	for(int track=0; track < track_count; track++) {
 		for(int head=0; head < head_count; head++) {
-			get_track_data_mfm_pc(track, head, image, 1000, 512, sector_count, sectdata);
+			get_track_data_mfm_pc(track, head, image, cell_time, 512, sector_count, sectdata);
 			io_generic_write(io, sectdata, (track*head_count + head)*track_size, track_size);
 		}
 	}
diff -Nru src-old/lib/formats/pc_dsk.h src/lib/formats/pc_dsk.h
--- src-old/lib/formats/pc_dsk.h	2012-01-07 22:03:04.000000000 +0100
+++ src/lib/formats/pc_dsk.h	2012-02-13 09:12:24.000000000 +0100
@@ -32,9 +32,21 @@
 	virtual bool supports_save() const;
 
 private:
-	static const desc_e pc_desc[];
+	struct format {
+		int size;
+		UINT32 form_factor;
+		UINT32 variant;
+		int track_count;
+		int head_count;
+		int sector_count;
+		const desc_e *desc;
+		int cell_count;
+	};
 
-	void find_size(io_generic *io, UINT32 form_factor, int &track_count, int &head_count, int &sector_count);
+	static const format formats[];
+	static const desc_e pc_9_desc[], pc_18_desc[], pc_36_desc[];
+
+	int find_size(io_generic *io, UINT32 form_factor);
 };
 
 extern const floppy_format_type FLOPPY_PC_FORMAT;
diff -Nru src-old/lib/lib.mak src/lib/lib.mak
--- src-old/lib/lib.mak	2012-02-05 18:37:10.000000000 +0100
+++ src/lib/lib.mak	2012-02-16 10:47:18.000000000 +0100
@@ -22,6 +22,7 @@
 	$(LIBOBJ)/libjpeg \
 	$(LIBOBJ)/libflac \
 	$(LIBOBJ)/libflacpp \
+	$(LIBOBJ)/lib7z \
 
 
 
@@ -31,16 +32,19 @@
 
 UTILOBJS = \
 	$(LIBOBJ)/util/astring.o \
-	$(LIBOBJ)/util/avcomp.o \
+	$(LIBOBJ)/util/avhuff.o \
 	$(LIBOBJ)/util/aviio.o \
 	$(LIBOBJ)/util/bitmap.o \
 	$(LIBOBJ)/util/cdrom.o \
 	$(LIBOBJ)/util/chd.o \
 	$(LIBOBJ)/util/chdcd.o \
+	$(LIBOBJ)/util/chdcodec.o \
 	$(LIBOBJ)/util/corefile.o \
 	$(LIBOBJ)/util/corestr.o \
 	$(LIBOBJ)/util/coreutil.o \
+	$(LIBOBJ)/util/flac.o \
 	$(LIBOBJ)/util/harddisk.o \
+	$(LIBOBJ)/util/hashing.o \
 	$(LIBOBJ)/util/huffman.o \
 	$(LIBOBJ)/util/jedparse.o \
 	$(LIBOBJ)/util/md5.o \
@@ -52,6 +56,7 @@
 	$(LIBOBJ)/util/sha1.o \
 	$(LIBOBJ)/util/unicode.o \
 	$(LIBOBJ)/util/unzip.o \
+	$(LIBOBJ)/util/un7z.o \
 	$(LIBOBJ)/util/vbiparse.o \
 	$(LIBOBJ)/util/xmlfile.o \
 	$(LIBOBJ)/util/zippath.o \
@@ -71,7 +76,7 @@
 
 $(OBJ)/libexpat.a: $(EXPATOBJS)
 
-$(LIBOBJ)/expat/%.o: $(LIBSRC)/explat/%.c | $(OSPREBUILD)
+$(LIBOBJ)/expat/%.o: $(LIBSRC)/expat/%.c | $(OSPREBUILD)
 	@echo Compiling $<...
 	$(CC) $(CDEFS) $(CCOMFLAGS) $(CONLYFLAGS) -c $< -o $@
 
@@ -184,6 +189,8 @@
 	$(LIBOBJ)/zlib/uncompr.o \
 	$(LIBOBJ)/zlib/zutil.o
 
+
+
 $(OBJ)/libz.a: $(ZLIBOBJS)
 
 $(LIBOBJ)/zlib/%.o: $(LIBSRC)/zlib/%.c | $(OSPREBUILD)
@@ -269,6 +276,7 @@
 	$(CC) $(CDEFS) $(CCOMFLAGS) $(CONLYFLAGS) -I$(LIBSRC)/libjpeg -c $< -o $@
 
 
+
 #-------------------------------------------------
 # libflac library objects
 #-------------------------------------------------
@@ -299,13 +307,35 @@
 	$(CC) $(CDEFS) $(FLACOPTS) $(CONLYFLAGS) -I$(LIBSRC)/libflac/include -c $< -o $@
 
 
-# LIBFLACPPOBJS = \
-#	$(LIBOBJ)/libflacpp/metadata.o \
-#	$(LIBOBJ)/libflacpp/stream_decoder.o \
-#	$(LIBOBJ)/libflacpp/stream_encoder.o
-
-# $(OBJ)/libflac++.a: $(LIBFLACPPOBJS)
-
-# $(LIBOBJ)/libflacpp/%.o: $(LIBSRC)/libflac/libflac++/%.cpp | $(OSPREBUILD)
-# 	@echo Compiling $<...
-#	$(CC) $(CDEFS) $(FLACOPTS) $(CPPONLYFLAGS) -I$(LIBSRC)/libflac/include -c $< -o $@
+
+#-------------------------------------------------
+# lib7z library objects
+#-------------------------------------------------
+
+7ZOPTS=-D_7ZIP_PPMD_SUPPPORT -D_7ZIP_ST
+
+LIB7ZOBJS = \
+	$(LIBOBJ)/lib7z/7zBuf.o \
+	$(LIBOBJ)/lib7z/7zBuf2.o \
+	$(LIBOBJ)/lib7z/7zCrc.o \
+	$(LIBOBJ)/lib7z/7zCrcOpt.o \
+	$(LIBOBJ)/lib7z/7zDec.o \
+	$(LIBOBJ)/lib7z/7zIn.o \
+	$(LIBOBJ)/lib7z/CpuArch.o \
+	$(LIBOBJ)/lib7z/LzmaDec.o \
+	$(LIBOBJ)/lib7z/Lzma2Dec.o \
+	$(LIBOBJ)/lib7z/LzmaEnc.o \
+	$(LIBOBJ)/lib7z/Lzma2Enc.o \
+	$(LIBOBJ)/lib7z/LzFind.o \
+	$(LIBOBJ)/lib7z/Bra.o \
+	$(LIBOBJ)/lib7z/Bra86.o \
+	$(LIBOBJ)/lib7z/Bcj2.o \
+	$(LIBOBJ)/lib7z/Ppmd7.o \
+	$(LIBOBJ)/lib7z/Ppmd7Dec.o \
+	$(LIBOBJ)/lib7z/7zStream.o \
+
+$(OBJ)/lib7z.a: $(LIB7ZOBJS)
+
+$(LIBOBJ)/lib7z/%.o: $(LIBSRC)/lib7z/%.c | $(OSPREBUILD)
+	@echo Compiling $<...
+	$(CC) $(CDEFS) $(7ZOPTS) $(CONLYFLAGS) -I$(LIBSRC)/lib7z/ -c $< -o $@
diff -Nru src-old/lib/lib7z/7z.h src/lib/lib7z/7z.h
--- src-old/lib/lib7z/7z.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7z.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,203 @@
+/* 7z.h -- 7z interface
+2010-03-11 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_H
+#define __7Z_H
+
+#include "7zBuf.h"
+
+EXTERN_C_BEGIN
+
+#define k7zStartHeaderSize 0x20
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+#define k7zMajorVersion 0
+
+enum EIdEnum
+{
+  k7zIdEnd,
+  k7zIdHeader,
+  k7zIdArchiveProperties,
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  k7zIdPackInfo,
+  k7zIdUnpackInfo,
+  k7zIdSubStreamsInfo,
+  k7zIdSize,
+  k7zIdCRC,
+  k7zIdFolder,
+  k7zIdCodersUnpackSize,
+  k7zIdNumUnpackStream,
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  k7zIdName,
+  k7zIdCTime,
+  k7zIdATime,
+  k7zIdMTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  k7zIdEncodedHeader,
+  k7zIdStartPos,
+  k7zIdDummy
+};
+
+typedef struct
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  UInt64 MethodID;
+  CBuf Props;
+} CSzCoderInfo;
+
+void SzCoderInfo_Init(CSzCoderInfo *p);
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+} CSzBindPair;
+
+typedef struct
+{
+  CSzCoderInfo *Coders;
+  CSzBindPair *BindPairs;
+  UInt32 *PackStreams;
+  UInt64 *UnpackSizes;
+  UInt32 NumCoders;
+  UInt32 NumBindPairs;
+  UInt32 NumPackStreams;
+  int UnpackCRCDefined;
+  UInt32 UnpackCRC;
+
+  UInt32 NumUnpackStreams;
+} CSzFolder;
+
+void SzFolder_Init(CSzFolder *p);
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p);
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p);
+
+SRes SzFolder_Decode(const CSzFolder *folder, const UInt64 *packSizes,
+    ILookInStream *stream, UInt64 startPos,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
+
+typedef struct
+{
+  UInt32 Low;
+  UInt32 High;
+} CNtfsFileTime;
+
+typedef struct
+{
+  CNtfsFileTime MTime;
+  UInt64 Size;
+  UInt32 Crc;
+  UInt32 Attrib;
+  Byte HasStream;
+  Byte IsDir;
+  Byte IsAnti;
+  Byte CrcDefined;
+  Byte MTimeDefined;
+  Byte AttribDefined;
+} CSzFileItem;
+
+void SzFile_Init(CSzFileItem *p);
+
+typedef struct
+{
+  UInt64 *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  CSzFolder *Folders;
+  CSzFileItem *Files;
+  UInt32 NumPackStreams;
+  UInt32 NumFolders;
+  UInt32 NumFiles;
+} CSzAr;
+
+void SzAr_Init(CSzAr *p);
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
+
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive.
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send
+    these values from previous call:
+      *blockIndex,
+      *outBuffer,
+      *outBufferSize
+    You can consider "*outBuffer" as cache of solid block. If your archive is solid,
+    it will increase decompression speed.
+
+    If you use external function, you can declare these 3 cache variables
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+typedef struct
+{
+  CSzAr db;
+
+  UInt64 startPosAfterHeader;
+  UInt64 dataPos;
+
+  UInt32 *FolderStartPackStreamIndex;
+  UInt64 *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+
+  size_t *FileNameOffsets; /* in 2-byte steps */
+  CBuf FileNames;  /* UTF-16-LE */
+} CSzArEx;
+
+void SzArEx_Init(CSzArEx *p);
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
+UInt64 SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, UInt64 *resSize);
+
+/*
+if dest == NULL, the return value specifies the required size of the buffer,
+  in 16-bit characters, including the null-terminating character.
+if dest != NULL, the return value specifies the number of 16-bit characters that
+  are written to the dest, including the null-terminating character. */
+
+size_t SzArEx_GetFileNameUtf16(const CSzArEx *p, size_t fileIndex, UInt16 *dest);
+
+SRes SzArEx_Extract(
+    const CSzArEx *db,
+    ILookInStream *inStream,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+
+/*
+SzArEx_Open Errors:
+SZ_ERROR_NO_ARCHIVE
+SZ_ERROR_ARCHIVE
+SZ_ERROR_UNSUPPORTED
+SZ_ERROR_MEM
+SZ_ERROR_CRC
+SZ_ERROR_INPUT_EOF
+SZ_ERROR_FAIL
+*/
+
+SRes SzArEx_Open(CSzArEx *p, ILookInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/7zBuf.c src/lib/lib7z/7zBuf.c
--- src-old/lib/lib7z/7zBuf.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zBuf.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,36 @@
+/* 7zBuf.c -- Byte Buffer
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include "7zBuf.h"
+
+void Buf_Init(CBuf *p)
+{
+  p->data = 0;
+  p->size = 0;
+}
+
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
+{
+  p->size = 0;
+  if (size == 0)
+  {
+    p->data = 0;
+    return 1;
+  }
+  p->data = (Byte *)alloc->Alloc(alloc, size);
+  if (p->data != 0)
+  {
+    p->size = size;
+    return 1;
+  }
+  return 0;
+}
+
+void Buf_Free(CBuf *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->data);
+  p->data = 0;
+  p->size = 0;
+}
diff -Nru src-old/lib/lib7z/7zBuf.h src/lib/lib7z/7zBuf.h
--- src-old/lib/lib7z/7zBuf.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zBuf.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,39 @@
+/* 7zBuf.h -- Byte Buffer
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_BUF_H
+#define __7Z_BUF_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+} CBuf;
+
+void Buf_Init(CBuf *p);
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
+void Buf_Free(CBuf *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+  size_t pos;
+} CDynBuf;
+
+void DynBuf_Construct(CDynBuf *p);
+void DynBuf_SeekToBeg(CDynBuf *p);
+int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc);
+void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/7zBuf2.c src/lib/lib7z/7zBuf2.c
--- src-old/lib/lib7z/7zBuf2.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zBuf2.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,45 @@
+/* 7zBuf2.c -- Byte Buffer
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include <string.h>
+#include "7zBuf.h"
+
+void DynBuf_Construct(CDynBuf *p)
+{
+  p->data = 0;
+  p->size = 0;
+  p->pos = 0;
+}
+
+void DynBuf_SeekToBeg(CDynBuf *p)
+{
+  p->pos = 0;
+}
+
+int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc)
+{
+  if (size > p->size - p->pos)
+  {
+    size_t newSize = p->pos + size;
+    Byte *data;
+    newSize += newSize / 4;
+    data = (Byte *)alloc->Alloc(alloc, newSize);
+    if (data == 0)
+      return 0;
+    p->size = newSize;
+    memcpy(data, p->data, p->pos);
+    alloc->Free(alloc, p->data);
+    p->data = data;
+  }
+  memcpy(p->data + p->pos, buf, size);
+  p->pos += size;
+  return 1;
+}
+
+void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->data);
+  p->data = 0;
+  p->size = 0;
+  p->pos = 0;
+}
diff -Nru src-old/lib/lib7z/7zCrc.c src/lib/lib7z/7zCrc.c
--- src-old/lib/lib7z/7zCrc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zCrc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,83 @@
+/* 7zCrc.c -- CRC32 init
+2010-12-01 : Igor Pavlov : Public domain */
+
+#include "7zCrc.h"
+#include "CpuArch.h"
+
+#define kCrcPoly 0xEDB88320
+
+#ifdef MY_CPU_X86_OR_AMD64
+  #define CRC_NUM_TABLES 8
+  UInt32 MY_FAST_CALL CrcUpdateT8(UInt32 v, const void *data, size_t size, const UInt32 *table);
+#elif defined(MY_CPU_LE)
+  #define CRC_NUM_TABLES 4
+#else
+  #define CRC_NUM_TABLES 5
+  #define CRC_UINT32_SWAP(v) ((v >> 24) | ((v >> 8) & 0xFF00) | ((v << 8) & 0xFF0000) | (v << 24))
+  UInt32 MY_FAST_CALL CrcUpdateT1_BeT4(UInt32 v, const void *data, size_t size, const UInt32 *table);
+#endif
+
+#ifndef MY_CPU_BE
+  UInt32 MY_FAST_CALL CrcUpdateT4(UInt32 v, const void *data, size_t size, const UInt32 *table);
+#endif
+
+typedef UInt32 (MY_FAST_CALL *CRC_FUNC)(UInt32 v, const void *data, size_t size, const UInt32 *table);
+
+static CRC_FUNC g_CrcUpdate;
+UInt32 g_CrcTable[256 * CRC_NUM_TABLES];
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
+{
+  return g_CrcUpdate(v, data, size, g_CrcTable);
+}
+
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
+{
+  return g_CrcUpdate(CRC_INIT_VAL, data, size, g_CrcTable) ^ CRC_INIT_VAL;
+}
+
+void MY_FAST_CALL CrcGenerateTable()
+{
+  UInt32 i;
+  for (i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    unsigned j;
+    for (j = 0; j < 8; j++)
+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
+    g_CrcTable[i] = r;
+  }
+  for (; i < 256 * CRC_NUM_TABLES; i++)
+  {
+    UInt32 r = g_CrcTable[i - 256];
+    g_CrcTable[i] = g_CrcTable[r & 0xFF] ^ (r >> 8);
+  }
+
+  #ifdef MY_CPU_LE
+
+  g_CrcUpdate = CrcUpdateT4;
+
+  #if CRC_NUM_TABLES == 8
+  if (!CPU_Is_InOrder())
+    g_CrcUpdate = CrcUpdateT8;
+  #endif
+
+  #else
+  {
+    #ifndef MY_CPU_BE
+    UInt32 k = 1;
+    if (*(const Byte *)&k == 1)
+      g_CrcUpdate = CrcUpdateT4;
+    else
+    #endif
+    {
+      for (i = 256 * CRC_NUM_TABLES - 1; i >= 256; i--)
+      {
+        UInt32 x = g_CrcTable[i - 256];
+        g_CrcTable[i] = CRC_UINT32_SWAP(x);
+      }
+      g_CrcUpdate = CrcUpdateT1_BeT4;
+    }
+  }
+  #endif
+}
diff -Nru src-old/lib/lib7z/7zCrc.h src/lib/lib7z/7zCrc.h
--- src-old/lib/lib7z/7zCrc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zCrc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,25 @@
+/* 7zCrc.h -- CRC32 calculation
+2009-11-21 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+extern UInt32 g_CrcTable[];
+
+/* Call CrcGenerateTable one time before other CRC functions */
+void MY_FAST_CALL CrcGenerateTable(void);
+
+#define CRC_INIT_VAL 0xFFFFFFFF
+#define CRC_GET_DIGEST(crc) ((crc) ^ CRC_INIT_VAL)
+#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/7zCrcOpt.c src/lib/lib7z/7zCrcOpt.c
--- src-old/lib/lib7z/7zCrcOpt.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zCrcOpt.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,64 @@
+/* 7zCrcOpt.c -- CRC32 calculation
+2010-12-01 : Igor Pavlov : Public domain */
+
+#include "CpuArch.h"
+
+#define CRC_UPDATE_BYTE_2(crc, b) (table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
+
+#ifndef MY_CPU_BE
+
+UInt32 MY_FAST_CALL CrcUpdateT4(UInt32 v, const void *data, size_t size, const UInt32 *table)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 && ((unsigned)(ptrdiff_t)p & 3) != 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  for (; size >= 4; size -= 4, p += 4)
+  {
+    v ^= *(const UInt32 *)p;
+    v =
+      table[0x300 + (v & 0xFF)] ^
+      table[0x200 + ((v >> 8) & 0xFF)] ^
+      table[0x100 + ((v >> 16) & 0xFF)] ^
+      table[0x000 + ((v >> 24))];
+  }
+  for (; size > 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  return v;
+}
+
+UInt32 MY_FAST_CALL CrcUpdateT8(UInt32 v, const void *data, size_t size, const UInt32 *table)
+{
+  return CrcUpdateT4(v, data, size, table);
+}
+
+#endif
+
+
+#ifndef MY_CPU_LE
+
+#define CRC_UINT32_SWAP(v) ((v >> 24) | ((v >> 8) & 0xFF00) | ((v << 8) & 0xFF0000) | (v << 24))
+
+UInt32 MY_FAST_CALL CrcUpdateT1_BeT4(UInt32 v, const void *data, size_t size, const UInt32 *table)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 && ((unsigned)(ptrdiff_t)p & 3) != 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  v = CRC_UINT32_SWAP(v);
+  table += 0x100;
+  for (; size >= 4; size -= 4, p += 4)
+  {
+    v ^= *(const UInt32 *)p;
+    v =
+      table[0x000 + (v & 0xFF)] ^
+      table[0x100 + ((v >> 8) & 0xFF)] ^
+      table[0x200 + ((v >> 16) & 0xFF)] ^
+      table[0x300 + ((v >> 24))];
+  }
+  table -= 0x100;
+  v = CRC_UINT32_SWAP(v);
+  for (; size > 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  return v;
+}
+
+#endif
diff -Nru src-old/lib/lib7z/7zDec.c src/lib/lib7z/7zDec.c
--- src-old/lib/lib7z/7zDec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zDec.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,470 @@
+/* 7zDec.c -- Decoding from 7z folder
+2010-11-02 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+/* #define _7ZIP_PPMD_SUPPPORT */
+
+#include "7z.h"
+
+#include "Bcj2.h"
+#include "Bra.h"
+#include "CpuArch.h"
+#include "LzmaDec.h"
+#include "Lzma2Dec.h"
+#ifdef _7ZIP_PPMD_SUPPPORT
+#include "Ppmd7.h"
+#endif
+
+#define k_Copy 0
+#define k_LZMA2 0x21
+#define k_LZMA  0x30101
+#define k_BCJ   0x03030103
+#define k_PPC   0x03030205
+#define k_ARM   0x03030501
+#define k_ARMT  0x03030701
+#define k_SPARC 0x03030805
+#define k_BCJ2  0x0303011B
+
+#ifdef _7ZIP_PPMD_SUPPPORT
+
+#define k_PPMD 0x30401
+
+typedef struct
+{
+  IByteIn p;
+  const Byte *cur;
+  const Byte *end;
+  const Byte *begin;
+  UInt64 processed;
+  Bool extra;
+  SRes res;
+  ILookInStream *inStream;
+} CByteInToLook;
+
+static Byte ReadByte(void *pp)
+{
+  CByteInToLook *p = (CByteInToLook *)pp;
+  if (p->cur != p->end)
+    return *p->cur++;
+  if (p->res == SZ_OK)
+  {
+    size_t size = p->cur - p->begin;
+    p->processed += size;
+    p->res = p->inStream->Skip(p->inStream, size);
+    size = (1 << 25);
+    p->res = p->inStream->Look(p->inStream, (const void **)&p->begin, &size);
+    p->cur = p->begin;
+    p->end = p->begin + size;
+    if (size != 0)
+      return *p->cur++;;
+  }
+  p->extra = True;
+  return 0;
+}
+
+static SRes SzDecodePpmd(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+{
+  CPpmd7 ppmd;
+  CByteInToLook s;
+  SRes res = SZ_OK;
+
+  s.p.Read = ReadByte;
+  s.inStream = inStream;
+  s.begin = s.end = s.cur = NULL;
+  s.extra = False;
+  s.res = SZ_OK;
+  s.processed = 0;
+
+  if (coder->Props.size != 5)
+    return SZ_ERROR_UNSUPPORTED;
+
+  {
+    unsigned order = coder->Props.data[0];
+    UInt32 memSize = GetUi32(coder->Props.data + 1);
+    if (order < PPMD7_MIN_ORDER ||
+        order > PPMD7_MAX_ORDER ||
+        memSize < PPMD7_MIN_MEM_SIZE ||
+        memSize > PPMD7_MAX_MEM_SIZE)
+      return SZ_ERROR_UNSUPPORTED;
+    Ppmd7_Construct(&ppmd);
+    if (!Ppmd7_Alloc(&ppmd, memSize, allocMain))
+      return SZ_ERROR_MEM;
+    Ppmd7_Init(&ppmd, order);
+  }
+  {
+    CPpmd7z_RangeDec rc;
+    Ppmd7z_RangeDec_CreateVTable(&rc);
+    rc.Stream = &s.p;
+    if (!Ppmd7z_RangeDec_Init(&rc))
+      res = SZ_ERROR_DATA;
+    else if (s.extra)
+      res = (s.res != SZ_OK ? s.res : SZ_ERROR_DATA);
+    else
+    {
+      SizeT i;
+      for (i = 0; i < outSize; i++)
+      {
+        int sym = Ppmd7_DecodeSymbol(&ppmd, &rc.p);
+        if (s.extra || sym < 0)
+          break;
+        outBuffer[i] = (Byte)sym;
+      }
+      if (i != outSize)
+        res = (s.res != SZ_OK ? s.res : SZ_ERROR_DATA);
+      else if (s.processed + (s.cur - s.begin) != inSize || !Ppmd7z_RangeDec_IsFinishedOK(&rc))
+        res = SZ_ERROR_DATA;
+    }
+  }
+  Ppmd7_Free(&ppmd, allocMain);
+  return res;
+}
+
+#endif
+
+
+static SRes SzDecodeLzma(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+{
+  CLzmaDec state;
+  SRes res = SZ_OK;
+
+  LzmaDec_Construct(&state);
+  RINOK(LzmaDec_AllocateProbs(&state, coder->Props.data, (unsigned)coder->Props.size, allocMain));
+  state.dic = outBuffer;
+  state.dicBufSize = outSize;
+  LzmaDec_Init(&state);
+
+  for (;;)
+  {
+    Byte *inBuf = NULL;
+    size_t lookahead = (1 << 18);
+    if (lookahead > inSize)
+      lookahead = (size_t)inSize;
+    res = inStream->Look((void *)inStream, (const void **)&inBuf, &lookahead);
+    if (res != SZ_OK)
+      break;
+
+    {
+      SizeT inProcessed = (SizeT)lookahead, dicPos = state.dicPos;
+      ELzmaStatus status;
+      res = LzmaDec_DecodeToDic(&state, outSize, inBuf, &inProcessed, LZMA_FINISH_END, &status);
+      lookahead -= inProcessed;
+      inSize -= inProcessed;
+      if (res != SZ_OK)
+        break;
+      if (state.dicPos == state.dicBufSize || (inProcessed == 0 && dicPos == state.dicPos))
+      {
+        if (state.dicBufSize != outSize || lookahead != 0 ||
+            (status != LZMA_STATUS_FINISHED_WITH_MARK &&
+             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
+          res = SZ_ERROR_DATA;
+        break;
+      }
+      res = inStream->Skip((void *)inStream, inProcessed);
+      if (res != SZ_OK)
+        break;
+    }
+  }
+
+  LzmaDec_FreeProbs(&state, allocMain);
+  return res;
+}
+
+static SRes SzDecodeLzma2(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+{
+  CLzma2Dec state;
+  SRes res = SZ_OK;
+
+  Lzma2Dec_Construct(&state);
+  if (coder->Props.size != 1)
+    return SZ_ERROR_DATA;
+  RINOK(Lzma2Dec_AllocateProbs(&state, coder->Props.data[0], allocMain));
+  state.decoder.dic = outBuffer;
+  state.decoder.dicBufSize = outSize;
+  Lzma2Dec_Init(&state);
+
+  for (;;)
+  {
+    Byte *inBuf = NULL;
+    size_t lookahead = (1 << 18);
+    if (lookahead > inSize)
+      lookahead = (size_t)inSize;
+    res = inStream->Look((void *)inStream, (const void **)&inBuf, &lookahead);
+    if (res != SZ_OK)
+      break;
+
+    {
+      SizeT inProcessed = (SizeT)lookahead, dicPos = state.decoder.dicPos;
+      ELzmaStatus status;
+      res = Lzma2Dec_DecodeToDic(&state, outSize, inBuf, &inProcessed, LZMA_FINISH_END, &status);
+      lookahead -= inProcessed;
+      inSize -= inProcessed;
+      if (res != SZ_OK)
+        break;
+      if (state.decoder.dicPos == state.decoder.dicBufSize || (inProcessed == 0 && dicPos == state.decoder.dicPos))
+      {
+        if (state.decoder.dicBufSize != outSize || lookahead != 0 ||
+            (status != LZMA_STATUS_FINISHED_WITH_MARK))
+          res = SZ_ERROR_DATA;
+        break;
+      }
+      res = inStream->Skip((void *)inStream, inProcessed);
+      if (res != SZ_OK)
+        break;
+    }
+  }
+
+  Lzma2Dec_FreeProbs(&state, allocMain);
+  return res;
+}
+
+static SRes SzDecodeCopy(UInt64 inSize, ILookInStream *inStream, Byte *outBuffer)
+{
+  while (inSize > 0)
+  {
+    void *inBuf;
+    size_t curSize = (1 << 18);
+    if (curSize > inSize)
+      curSize = (size_t)inSize;
+    RINOK(inStream->Look((void *)inStream, (const void **)&inBuf, &curSize));
+    if (curSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    memcpy(outBuffer, inBuf, curSize);
+    outBuffer += curSize;
+    inSize -= curSize;
+    RINOK(inStream->Skip((void *)inStream, curSize));
+  }
+  return SZ_OK;
+}
+
+static Bool IS_MAIN_METHOD(UInt32 m)
+{
+  switch(m)
+  {
+    case k_Copy:
+    case k_LZMA:
+    case k_LZMA2:
+    #ifdef _7ZIP_PPMD_SUPPPORT
+    case k_PPMD:
+    #endif
+      return True;
+  }
+  return False;
+}
+
+static Bool IS_SUPPORTED_CODER(const CSzCoderInfo *c)
+{
+  return
+      c->NumInStreams == 1 &&
+      c->NumOutStreams == 1 &&
+      c->MethodID <= (UInt32)0xFFFFFFFF &&
+      IS_MAIN_METHOD((UInt32)c->MethodID);
+}
+
+#define IS_BCJ2(c) ((c)->MethodID == k_BCJ2 && (c)->NumInStreams == 4 && (c)->NumOutStreams == 1)
+
+static SRes CheckSupportedFolder(const CSzFolder *f)
+{
+  if (f->NumCoders < 1 || f->NumCoders > 4)
+    return SZ_ERROR_UNSUPPORTED;
+  if (!IS_SUPPORTED_CODER(&f->Coders[0]))
+    return SZ_ERROR_UNSUPPORTED;
+  if (f->NumCoders == 1)
+  {
+    if (f->NumPackStreams != 1 || f->PackStreams[0] != 0 || f->NumBindPairs != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f->NumCoders == 2)
+  {
+    CSzCoderInfo *c = &f->Coders[1];
+    if (c->MethodID > (UInt32)0xFFFFFFFF ||
+        c->NumInStreams != 1 ||
+        c->NumOutStreams != 1 ||
+        f->NumPackStreams != 1 ||
+        f->PackStreams[0] != 0 ||
+        f->NumBindPairs != 1 ||
+        f->BindPairs[0].InIndex != 1 ||
+        f->BindPairs[0].OutIndex != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    switch ((UInt32)c->MethodID)
+    {
+      case k_BCJ:
+      case k_ARM:
+        break;
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+    return SZ_OK;
+  }
+  if (f->NumCoders == 4)
+  {
+    if (!IS_SUPPORTED_CODER(&f->Coders[1]) ||
+        !IS_SUPPORTED_CODER(&f->Coders[2]) ||
+        !IS_BCJ2(&f->Coders[3]))
+      return SZ_ERROR_UNSUPPORTED;
+    if (f->NumPackStreams != 4 ||
+        f->PackStreams[0] != 2 ||
+        f->PackStreams[1] != 6 ||
+        f->PackStreams[2] != 1 ||
+        f->PackStreams[3] != 0 ||
+        f->NumBindPairs != 3 ||
+        f->BindPairs[0].InIndex != 5 || f->BindPairs[0].OutIndex != 0 ||
+        f->BindPairs[1].InIndex != 4 || f->BindPairs[1].OutIndex != 1 ||
+        f->BindPairs[2].InIndex != 3 || f->BindPairs[2].OutIndex != 2)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  return SZ_ERROR_UNSUPPORTED;
+}
+
+static UInt64 GetSum(const UInt64 *values, UInt32 index)
+{
+  UInt64 sum = 0;
+  UInt32 i;
+  for (i = 0; i < index; i++)
+    sum += values[i];
+  return sum;
+}
+
+#define CASE_BRA_CONV(isa) case k_ ## isa: isa ## _Convert(outBuffer, outSize, 0, 0); break;
+
+static SRes SzFolder_Decode2(const CSzFolder *folder, const UInt64 *packSizes,
+    ILookInStream *inStream, UInt64 startPos,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain,
+    Byte *tempBuf[])
+{
+  UInt32 ci;
+  SizeT tempSizes[3] = { 0, 0, 0};
+  SizeT tempSize3 = 0;
+  Byte *tempBuf3 = 0;
+
+  RINOK(CheckSupportedFolder(folder));
+
+  for (ci = 0; ci < folder->NumCoders; ci++)
+  {
+    CSzCoderInfo *coder = &folder->Coders[ci];
+
+    if (IS_MAIN_METHOD((UInt32)coder->MethodID))
+    {
+      UInt32 si = 0;
+      UInt64 offset;
+      UInt64 inSize;
+      Byte *outBufCur = outBuffer;
+      SizeT outSizeCur = outSize;
+      if (folder->NumCoders == 4)
+      {
+        UInt32 indices[] = { 3, 2, 0 };
+        UInt64 unpackSize = folder->UnpackSizes[ci];
+        si = indices[ci];
+        if (ci < 2)
+        {
+          Byte *temp;
+          outSizeCur = (SizeT)unpackSize;
+          if (outSizeCur != unpackSize)
+            return SZ_ERROR_MEM;
+          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
+          if (temp == 0 && outSizeCur != 0)
+            return SZ_ERROR_MEM;
+          outBufCur = tempBuf[1 - ci] = temp;
+          tempSizes[1 - ci] = outSizeCur;
+        }
+        else if (ci == 2)
+        {
+          if (unpackSize > outSize) /* check it */
+            return SZ_ERROR_PARAM;
+          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
+          tempSize3 = outSizeCur = (SizeT)unpackSize;
+        }
+        else
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      offset = GetSum(packSizes, si);
+      inSize = packSizes[si];
+      RINOK(LookInStream_SeekTo(inStream, startPos + offset));
+
+      if (coder->MethodID == k_Copy)
+      {
+        if (inSize != outSizeCur) /* check it */
+          return SZ_ERROR_DATA;
+        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
+      }
+      else if (coder->MethodID == k_LZMA)
+      {
+        RINOK(SzDecodeLzma(coder, inSize, inStream, outBufCur, outSizeCur, allocMain));
+      }
+      else if (coder->MethodID == k_LZMA2)
+      {
+        RINOK(SzDecodeLzma2(coder, inSize, inStream, outBufCur, outSizeCur, allocMain));
+      }
+      else
+      {
+        #ifdef _7ZIP_PPMD_SUPPPORT
+        RINOK(SzDecodePpmd(coder, inSize, inStream, outBufCur, outSizeCur, allocMain));
+        #else
+        return SZ_ERROR_UNSUPPORTED;
+        #endif
+      }
+    }
+    else if (coder->MethodID == k_BCJ2)
+    {
+      UInt64 offset = GetSum(packSizes, 1);
+      UInt64 s3Size = packSizes[1];
+      SRes res;
+      if (ci != 3)
+        return SZ_ERROR_UNSUPPORTED;
+      RINOK(LookInStream_SeekTo(inStream, startPos + offset));
+      tempSizes[2] = (SizeT)s3Size;
+      if (tempSizes[2] != s3Size)
+        return SZ_ERROR_MEM;
+      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
+      if (tempBuf[2] == 0 && tempSizes[2] != 0)
+        return SZ_ERROR_MEM;
+      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
+      RINOK(res)
+
+      res = Bcj2_Decode(
+          tempBuf3, tempSize3,
+          tempBuf[0], tempSizes[0],
+          tempBuf[1], tempSizes[1],
+          tempBuf[2], tempSizes[2],
+          outBuffer, outSize);
+      RINOK(res)
+    }
+    else
+    {
+      if (ci != 1)
+        return SZ_ERROR_UNSUPPORTED;
+      switch(coder->MethodID)
+      {
+        case k_BCJ:
+        {
+          UInt32 state;
+          x86_Convert_Init(state);
+          x86_Convert(outBuffer, outSize, 0, &state, 0);
+          break;
+        }
+        CASE_BRA_CONV(ARM)
+        default:
+          return SZ_ERROR_UNSUPPORTED;
+      }
+    }
+  }
+  return SZ_OK;
+}
+
+SRes SzFolder_Decode(const CSzFolder *folder, const UInt64 *packSizes,
+    ILookInStream *inStream, UInt64 startPos,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  Byte *tempBuf[3] = { 0, 0, 0};
+  int i;
+  SRes res = SzFolder_Decode2(folder, packSizes, inStream, startPos,
+      outBuffer, (SizeT)outSize, allocMain, tempBuf);
+  for (i = 0; i < 3; i++)
+    IAlloc_Free(allocMain, tempBuf[i]);
+  return res;
+}
diff -Nru src-old/lib/lib7z/7zIn.c src/lib/lib7z/7zIn.c
--- src-old/lib/lib7z/7zIn.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zIn.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,1402 @@
+/* 7zIn.c -- 7z Input functions
+2010-10-29 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "7z.h"
+#include "7zCrc.h"
+#include "CpuArch.h"
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
+
+#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
+
+#define NUM_FOLDER_CODERS_MAX 32
+#define NUM_CODER_STREAMS_MAX 32
+
+void SzCoderInfo_Init(CSzCoderInfo *p)
+{
+  Buf_Init(&p->Props);
+}
+
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
+{
+  Buf_Free(&p->Props, alloc);
+  SzCoderInfo_Init(p);
+}
+
+void SzFolder_Init(CSzFolder *p)
+{
+  p->Coders = 0;
+  p->BindPairs = 0;
+  p->PackStreams = 0;
+  p->UnpackSizes = 0;
+  p->NumCoders = 0;
+  p->NumBindPairs = 0;
+  p->NumPackStreams = 0;
+  p->UnpackCRCDefined = 0;
+  p->UnpackCRC = 0;
+  p->NumUnpackStreams = 0;
+}
+
+void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p->Coders)
+    for (i = 0; i < p->NumCoders; i++)
+      SzCoderInfo_Free(&p->Coders[i], alloc);
+  IAlloc_Free(alloc, p->Coders);
+  IAlloc_Free(alloc, p->BindPairs);
+  IAlloc_Free(alloc, p->PackStreams);
+  IAlloc_Free(alloc, p->UnpackSizes);
+  SzFolder_Init(p);
+}
+
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i < p->NumCoders; i++)
+    result += p->Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i < p->NumBindPairs; i++)
+    if (p->BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i < p->NumBindPairs; i++)
+    if (p->BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p)
+{
+  int i = (int)SzFolder_GetNumOutStreams(p);
+  if (i == 0)
+    return 0;
+  for (i--; i >= 0; i--)
+    if (SzFolder_FindBindPairForOutStream(p, i) < 0)
+      return p->UnpackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+void SzFile_Init(CSzFileItem *p)
+{
+  p->HasStream = 1;
+  p->IsDir = 0;
+  p->IsAnti = 0;
+  p->CrcDefined = 0;
+  p->MTimeDefined = 0;
+}
+
+void SzAr_Init(CSzAr *p)
+{
+  p->PackSizes = 0;
+  p->PackCRCsDefined = 0;
+  p->PackCRCs = 0;
+  p->Folders = 0;
+  p->Files = 0;
+  p->NumPackStreams = 0;
+  p->NumFolders = 0;
+  p->NumFiles = 0;
+}
+
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p->Folders)
+    for (i = 0; i < p->NumFolders; i++)
+      SzFolder_Free(&p->Folders[i], alloc);
+
+  IAlloc_Free(alloc, p->PackSizes);
+  IAlloc_Free(alloc, p->PackCRCsDefined);
+  IAlloc_Free(alloc, p->PackCRCs);
+  IAlloc_Free(alloc, p->Folders);
+  IAlloc_Free(alloc, p->Files);
+  SzAr_Init(p);
+}
+
+
+void SzArEx_Init(CSzArEx *p)
+{
+  SzAr_Init(&p->db);
+  p->FolderStartPackStreamIndex = 0;
+  p->PackStreamStartPositions = 0;
+  p->FolderStartFileIndex = 0;
+  p->FileIndexToFolderIndexMap = 0;
+  p->FileNameOffsets = 0;
+  Buf_Init(&p->FileNames);
+}
+
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p->FolderStartPackStreamIndex);
+  IAlloc_Free(alloc, p->PackStreamStartPositions);
+  IAlloc_Free(alloc, p->FolderStartFileIndex);
+  IAlloc_Free(alloc, p->FileIndexToFolderIndexMap);
+
+  IAlloc_Free(alloc, p->FileNameOffsets);
+  Buf_Free(&p->FileNames, alloc);
+
+  SzAr_Free(&p->db, alloc);
+  SzArEx_Init(p);
+}
+
+/*
+UInt64 GetFolderPackStreamSize(int folderIndex, int streamIndex) const
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+UInt64 GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex >= 0)
+  {
+    const CSzFolder &folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
+  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
+
+static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
+{
+  UInt32 startPos = 0;
+  UInt64 startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  MY_ALLOC(UInt32, p->FolderStartPackStreamIndex, p->db.NumFolders, alloc);
+  for (i = 0; i < p->db.NumFolders; i++)
+  {
+    p->FolderStartPackStreamIndex[i] = startPos;
+    startPos += p->db.Folders[i].NumPackStreams;
+  }
+
+  MY_ALLOC(UInt64, p->PackStreamStartPositions, p->db.NumPackStreams, alloc);
+
+  for (i = 0; i < p->db.NumPackStreams; i++)
+  {
+    p->PackStreamStartPositions[i] = startPosSize;
+    startPosSize += p->db.PackSizes[i];
+  }
+
+  MY_ALLOC(UInt32, p->FolderStartFileIndex, p->db.NumFolders, alloc);
+  MY_ALLOC(UInt32, p->FileIndexToFolderIndexMap, p->db.NumFiles, alloc);
+
+  for (i = 0; i < p->db.NumFiles; i++)
+  {
+    CSzFileItem *file = p->db.Files + i;
+    int emptyStream = !file->HasStream;
+    if (emptyStream && indexInFolder == 0)
+    {
+      p->FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      for (;;)
+      {
+        if (folderIndex >= p->db.NumFolders)
+          return SZ_ERROR_ARCHIVE;
+        p->FolderStartFileIndex[folderIndex] = i;
+        if (p->db.Folders[folderIndex].NumUnpackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    p->FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder >= p->db.Folders[folderIndex].NumUnpackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+UInt64 SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return p->dataPos +
+    p->PackStreamStartPositions[p->FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, UInt64 *resSize)
+{
+  UInt32 packStreamIndex = p->FolderStartPackStreamIndex[folderIndex];
+  CSzFolder *folder = p->db.Folders + folderIndex;
+  UInt64 size = 0;
+  UInt32 i;
+  for (i = 0; i < folder->NumPackStreams; i++)
+  {
+    UInt64 t = size + p->db.PackSizes[packStreamIndex + i];
+    if (t < size) /* check it */
+      return SZ_ERROR_FAIL;
+    size = t;
+  }
+  *resSize = size;
+  return SZ_OK;
+}
+
+
+/*
+SRes SzReadTime(const CObjectVector<CBuf> &dataVector,
+    CObjectVector<CSzFileItem> &files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &dataVector));
+
+  for (int i = 0; i < files.Size(); i++)
+  {
+    CSzFileItem &file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
+      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
+      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+static int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i < k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+static SRes SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd->Size == 0)
+    return SZ_ERROR_ARCHIVE;
+  sd->Size--;
+  *b = *sd->Data++;
+  return SZ_OK;
+}
+
+static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i < size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i < 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt32)(b) << (8 * i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &firstByte));
+  *value = 0;
+  for (i = 0; i < 8; i++)
+  {
+    Byte b;
+    if ((firstByte & mask) == 0)
+    {
+      UInt64 highPart = firstByte & (mask - 1);
+      *value += (highPart << (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt64)b << (8 * i));
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &value64));
+  if (value64 >= 0x80000000)
+    return SZ_ERROR_UNSUPPORTED;
+  if (value64 >= ((UInt64)(1) << ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZ_ERROR_UNSUPPORTED;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadID(CSzData *sd, UInt64 *value)
+{
+  return SzReadNumber(sd, value);
+}
+
+static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size > sd->Size)
+    return SZ_ERROR_ARCHIVE;
+  sd->Size -= (size_t)size;
+  sd->Data += (size_t)size;
+  return SZ_OK;
+}
+
+static SRes SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &size));
+  return SzSkeepDataSize(sd, size);
+}
+
+static SRes SzReadArchiveProperties(CSzData *sd)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZ_ERROR_ARCHIVE;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b & mask) != 0) ? 1 : 0);
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, alloc);
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+static SRes SzReadHashDigests(
+    CSzData *sd,
+    size_t numItems,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *alloc)
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
+  MY_ALLOC(UInt32, *digests, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadPackInfo(
+    CSzData *sd,
+    UInt64 *dataOffset,
+    UInt32 *numPackStreams,
+    UInt64 **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    ISzAlloc *alloc)
+{
+  UInt32 i;
+  RINOK(SzReadNumber(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  MY_ALLOC(UInt64, *packSizes, (size_t)*numPackStreams, alloc);
+
+  for (i = 0; i < *numPackStreams; i++)
+  {
+    RINOK(SzReadNumber(sd, (*packSizes) + i));
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
+    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
+    for (i = 0; i < *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &external));
+  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
+}
+
+static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
+{
+  UInt32 numCoders, numBindPairs, numPackStreams, i;
+  UInt32 numInStreams = 0, numOutStreams = 0;
+
+  RINOK(SzReadNumber32(sd, &numCoders));
+  if (numCoders > NUM_FOLDER_CODERS_MAX)
+    return SZ_ERROR_UNSUPPORTED;
+  folder->NumCoders = numCoders;
+
+  MY_ALLOC(CSzCoderInfo, folder->Coders, (size_t)numCoders, alloc);
+
+  for (i = 0; i < numCoders; i++)
+    SzCoderInfo_Init(folder->Coders + i);
+
+  for (i = 0; i < numCoders; i++)
+  {
+    Byte mainByte;
+    CSzCoderInfo *coder = folder->Coders + i;
+    {
+      unsigned idSize, j;
+      Byte longID[15];
+      RINOK(SzReadByte(sd, &mainByte));
+      idSize = (unsigned)(mainByte & 0xF);
+      RINOK(SzReadBytes(sd, longID, idSize));
+      if (idSize > sizeof(coder->MethodID))
+        return SZ_ERROR_UNSUPPORTED;
+      coder->MethodID = 0;
+      for (j = 0; j < idSize; j++)
+        coder->MethodID |= (UInt64)longID[idSize - 1 - j] << (8 * j);
+
+      if ((mainByte & 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &coder->NumInStreams));
+        RINOK(SzReadNumber32(sd, &coder->NumOutStreams));
+        if (coder->NumInStreams > NUM_CODER_STREAMS_MAX ||
+            coder->NumOutStreams > NUM_CODER_STREAMS_MAX)
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      else
+      {
+        coder->NumInStreams = 1;
+        coder->NumOutStreams = 1;
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        if (!Buf_Create(&coder->Props, (size_t)propertiesSize, alloc))
+          return SZ_ERROR_MEM;
+        RINOK(SzReadBytes(sd, coder->Props.data, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte & 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte & 0xF)));
+      if ((mainByte & 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &n));
+        RINOK(SzReadNumber32(sd, &n));
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += coder->NumInStreams;
+    numOutStreams += coder->NumOutStreams;
+  }
+
+  if (numOutStreams == 0)
+    return SZ_ERROR_UNSUPPORTED;
+
+  folder->NumBindPairs = numBindPairs = numOutStreams - 1;
+  MY_ALLOC(CSzBindPair, folder->BindPairs, (size_t)numBindPairs, alloc);
+
+  for (i = 0; i < numBindPairs; i++)
+  {
+    CSzBindPair *bp = folder->BindPairs + i;
+    RINOK(SzReadNumber32(sd, &bp->InIndex));
+    RINOK(SzReadNumber32(sd, &bp->OutIndex));
+  }
+
+  if (numInStreams < numBindPairs)
+    return SZ_ERROR_UNSUPPORTED;
+
+  folder->NumPackStreams = numPackStreams = numInStreams - numBindPairs;
+  MY_ALLOC(UInt32, folder->PackStreams, (size_t)numPackStreams, alloc);
+
+  if (numPackStreams == 1)
+  {
+    for (i = 0; i < numInStreams ; i++)
+      if (SzFolder_FindBindPairForInStream(folder, i) < 0)
+        break;
+    if (i == numInStreams)
+      return SZ_ERROR_UNSUPPORTED;
+    folder->PackStreams[0] = i;
+  }
+  else
+    for (i = 0; i < numPackStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder->PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadUnpackInfo(
+    CSzData *sd,
+    UInt32 *numFolders,
+    CSzFolder **folders,  /* for alloc */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
+
+    for (i = 0; i < *numFolders; i++)
+      SzFolder_Init((*folders) + i);
+
+    for (i = 0; i < *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
+
+  for (i = 0; i < *numFolders; i++)
+  {
+    UInt32 j;
+    CSzFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
+
+    MY_ALLOC(UInt64, folder->UnpackSizes, (size_t)numOutStreams, alloc);
+
+    for (j = 0; j < numOutStreams; j++)
+    {
+      RINOK(SzReadNumber(sd, folder->UnpackSizes + j));
+    }
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SRes res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &crcsDefined, &crcs, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i < *numFolders; i++)
+        {
+          CSzFolder *folder = (*folders) + i;
+          folder->UnpackCRCDefined = crcsDefined[i];
+          folder->UnpackCRC = crcs[i];
+        }
+      }
+      IAlloc_Free(allocTemp, crcs);
+      IAlloc_Free(allocTemp, crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadSubStreamsInfo(
+    CSzData *sd,
+    UInt32 numFolders,
+    CSzFolder *folders,
+    UInt32 *numUnpackStreams,
+    UInt64 **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for (i = 0; i < numFolders; i++)
+    folders[i].NumUnpackStreams = 1;
+  *numUnpackStreams = numFolders;
+
+  for (;;)
+  {
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdNumUnpackStream)
+    {
+      *numUnpackStreams = 0;
+      for (i = 0; i < numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &numStreams));
+        folders[i].NumUnpackStreams = numStreams;
+        *numUnpackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnpackStreams == 0)
+  {
+    *unpackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unpackSizes = (UInt64 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt64));
+    RINOM(*unpackSizes);
+    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for (i = 0; i < numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    UInt64 sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j < numSubstreams; j++)
+    {
+      UInt64 size;
+      RINOK(SzReadNumber(sd, &size));
+      (*unpackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &type));
+  }
+
+  for (i = 0; i < *numUnpackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for (i = 0; i < numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+
+  si = 0;
+  for (;;)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0;
+      UInt32 *digests2 = 0;
+      SRes res = SzReadHashDigests(sd, numDigests, &digestsDefined2, &digests2, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i < numFolders; i++)
+        {
+          CSzFolder *folder = folders + i;
+          UInt32 numSubstreams = folder->NumUnpackStreams;
+          if (numSubstreams == 1 && folder->UnpackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder->UnpackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j < numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      IAlloc_Free(allocTemp, digestsDefined2);
+      IAlloc_Free(allocTemp, digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &type));
+  }
+}
+
+
+static SRes SzReadStreamsInfo(
+    CSzData *sd,
+    UInt64 *dataOffset,
+    CSzAr *p,
+    UInt32 *numUnpackStreams,
+    UInt64 **unpackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if ((UInt64)(int)type != type)
+      return SZ_ERROR_UNSUPPORTED;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &p->NumPackStreams,
+            &p->PackSizes, &p->PackCRCsDefined, &p->PackCRCs, alloc));
+        break;
+      }
+      case k7zIdUnpackInfo:
+      {
+        RINOK(SzReadUnpackInfo(sd, &p->NumFolders, &p->Folders, alloc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, p->NumFolders, p->Folders,
+            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+  }
+}
+
+size_t SzArEx_GetFileNameUtf16(const CSzArEx *p, size_t fileIndex, UInt16 *dest)
+{
+  size_t len = p->FileNameOffsets[fileIndex + 1] - p->FileNameOffsets[fileIndex];
+  if (dest != 0)
+  {
+    size_t i;
+    const Byte *src = p->FileNames.data + (p->FileNameOffsets[fileIndex] * 2);
+    for (i = 0; i < len; i++)
+      dest[i] = GetUi16(src + i * 2);
+  }
+  return len;
+}
+
+static SRes SzReadFileNames(const Byte *p, size_t size, UInt32 numFiles, size_t *sizes)
+{
+  UInt32 i;
+  size_t pos = 0;
+  for (i = 0; i < numFiles; i++)
+  {
+    sizes[i] = pos;
+    for (;;)
+    {
+      if (pos >= size)
+        return SZ_ERROR_ARCHIVE;
+      if (p[pos * 2] == 0 && p[pos * 2 + 1] == 0)
+        break;
+      pos++;
+    }
+    pos++;
+  }
+  sizes[i] = pos;
+  return (pos == size) ? SZ_OK : SZ_ERROR_ARCHIVE;
+}
+
+static SRes SzReadHeader2(
+    CSzArEx *p,   /* allocMain */
+    CSzData *sd,
+    UInt64 **unpackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    Byte **lwtVector,         /* allocTemp */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnpackStreams = 0;
+  UInt32 numFiles = 0;
+  CSzFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &type));
+  }
+
+
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &p->dataPos,
+        &p->db,
+        &numUnpackStreams,
+        unpackSizes,
+        digestsDefined,
+        digests, allocMain, allocTemp));
+    p->dataPos += p->startPosAfterHeader;
+    RINOK(SzReadID(sd, &type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZ_ERROR_ARCHIVE;
+
+  RINOK(SzReadNumber32(sd, &numFiles));
+  p->db.NumFiles = numFiles;
+
+  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
+
+  p->db.Files = files;
+  for (i = 0; i < numFiles; i++)
+    SzFile_Init(files + i);
+
+  for (;;)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &size));
+    if (size > sd->Size)
+      return SZ_ERROR_ARCHIVE;
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        size_t namesSize;
+        RINOK(SzReadSwitch(sd));
+        namesSize = (size_t)size - 1;
+        if ((namesSize & 1) != 0)
+          return SZ_ERROR_ARCHIVE;
+        if (!Buf_Create(&p->FileNames, namesSize, allocMain))
+          return SZ_ERROR_MEM;
+        MY_ALLOC(size_t, p->FileNameOffsets, numFiles + 1, allocMain);
+        memcpy(p->FileNames.data, sd->Data, namesSize);
+        RINOK(SzReadFileNames(sd->Data, namesSize >> 1, numFiles, p->FileNameOffsets))
+        RINOK(SzSkeepDataSize(sd, namesSize));
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
+        numEmptyStreams = 0;
+        for (i = 0; i < numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
+        break;
+      }
+      case k7zIdWinAttributes:
+      {
+        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
+        RINOK(SzReadSwitch(sd));
+        for (i = 0; i < numFiles; i++)
+        {
+          CSzFileItem *f = &files[i];
+          Byte defined = (*lwtVector)[i];
+          f->AttribDefined = defined;
+          f->Attrib = 0;
+          if (defined)
+          {
+            RINOK(SzReadUInt32(sd, &f->Attrib));
+          }
+        }
+        IAlloc_Free(allocTemp, *lwtVector);
+        *lwtVector = NULL;
+        break;
+      }
+      case k7zIdMTime:
+      {
+        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
+        RINOK(SzReadSwitch(sd));
+        for (i = 0; i < numFiles; i++)
+        {
+          CSzFileItem *f = &files[i];
+          Byte defined = (*lwtVector)[i];
+          f->MTimeDefined = defined;
+          f->MTime.Low = f->MTime.High = 0;
+          if (defined)
+          {
+            RINOK(SzReadUInt32(sd, &f->MTime.Low));
+            RINOK(SzReadUInt32(sd, &f->MTime.High));
+          }
+        }
+        IAlloc_Free(allocTemp, *lwtVector);
+        *lwtVector = NULL;
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for (i = 0; i < numFiles; i++)
+    {
+      CSzFileItem *file = files + i;
+      file->IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file->HasStream = 1;
+      else
+        file->HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if (file->HasStream)
+      {
+        file->IsDir = 0;
+        file->Size = (*unpackSizes)[sizeIndex];
+        file->Crc = (*digests)[sizeIndex];
+        file->CrcDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file->IsDir = 1;
+        else
+          file->IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file->Size = 0;
+        file->Crc = 0;
+        file->CrcDefined = 0;
+      }
+    }
+  }
+  return SzArEx_Fill(p, allocMain);
+}
+
+static SRes SzReadHeader(
+    CSzArEx *p,
+    CSzData *sd,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  Byte *lwtVector = 0;
+  SRes res = SzReadHeader2(p, sd,
+      &unpackSizes, &digestsDefined, &digests,
+      &emptyStreamVector, &emptyFileVector, &lwtVector,
+      allocMain, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  IAlloc_Free(allocTemp, emptyStreamVector);
+  IAlloc_Free(allocTemp, emptyFileVector);
+  IAlloc_Free(allocTemp, lwtVector);
+  return res;
+}
+
+static SRes SzReadAndDecodePackedStreams2(
+    ILookInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    UInt64 baseOffset,
+    CSzAr *p,
+    UInt64 **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnpackStreams = 0;
+  UInt64 dataStartPos;
+  CSzFolder *folder;
+  UInt64 unpackSize;
+  SRes res;
+
+  RINOK(SzReadStreamsInfo(sd, &dataStartPos, p,
+      &numUnpackStreams,  unpackSizes, digestsDefined, digests,
+      allocTemp, allocTemp));
+
+  dataStartPos += baseOffset;
+  if (p->NumFolders != 1)
+    return SZ_ERROR_ARCHIVE;
+
+  folder = p->Folders;
+  unpackSize = SzFolder_GetUnpackSize(folder);
+
+  RINOK(LookInStream_SeekTo(inStream, dataStartPos));
+
+  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
+    return SZ_ERROR_MEM;
+
+  res = SzFolder_Decode(folder, p->PackSizes,
+          inStream, dataStartPos,
+          outBuffer->data, (size_t)unpackSize, allocTemp);
+  RINOK(res);
+  if (folder->UnpackCRCDefined)
+    if (CrcCalc(outBuffer->data, (size_t)unpackSize) != folder->UnpackCRC)
+      return SZ_ERROR_CRC;
+  return SZ_OK;
+}
+
+static SRes SzReadAndDecodePackedStreams(
+    ILookInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    UInt64 baseOffset,
+    ISzAlloc *allocTemp)
+{
+  CSzAr p;
+  UInt64 *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  SRes res;
+  SzAr_Init(&p);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
+    &p, &unpackSizes, &digestsDefined, &digests,
+    allocTemp);
+  SzAr_Free(&p, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  return res;
+}
+
+static SRes SzArEx_Open2(
+    CSzArEx *p,
+    ILookInStream *inStream,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  Byte header[k7zStartHeaderSize];
+  Int64 startArcPos;
+  UInt64 nextHeaderOffset, nextHeaderSize;
+  size_t nextHeaderSizeT;
+  UInt32 nextHeaderCRC;
+  CBuf buffer;
+  SRes res;
+
+  startArcPos = 0;
+  RINOK(inStream->Seek(inStream, &startArcPos, SZ_SEEK_CUR));
+
+  RINOK(LookInStream_Read2(inStream, header, k7zStartHeaderSize, SZ_ERROR_NO_ARCHIVE));
+
+  if (!TestSignatureCandidate(header))
+    return SZ_ERROR_NO_ARCHIVE;
+  if (header[6] != k7zMajorVersion)
+    return SZ_ERROR_UNSUPPORTED;
+
+  nextHeaderOffset = GetUi64(header + 12);
+  nextHeaderSize = GetUi64(header + 20);
+  nextHeaderCRC = GetUi32(header + 28);
+
+  p->startPosAfterHeader = startArcPos + k7zStartHeaderSize;
+
+  if (CrcCalc(header + 12, 20) != GetUi32(header + 8))
+    return SZ_ERROR_CRC;
+
+  nextHeaderSizeT = (size_t)nextHeaderSize;
+  if (nextHeaderSizeT != nextHeaderSize)
+    return SZ_ERROR_MEM;
+  if (nextHeaderSizeT == 0)
+    return SZ_OK;
+  if (nextHeaderOffset > nextHeaderOffset + nextHeaderSize ||
+      nextHeaderOffset > nextHeaderOffset + nextHeaderSize + k7zStartHeaderSize)
+    return SZ_ERROR_NO_ARCHIVE;
+
+  {
+    Int64 pos = 0;
+    RINOK(inStream->Seek(inStream, &pos, SZ_SEEK_END));
+    if ((UInt64)pos < startArcPos + nextHeaderOffset ||
+        (UInt64)pos < startArcPos + k7zStartHeaderSize + nextHeaderOffset ||
+        (UInt64)pos < startArcPos + k7zStartHeaderSize + nextHeaderOffset + nextHeaderSize)
+      return SZ_ERROR_INPUT_EOF;
+  }
+
+  RINOK(LookInStream_SeekTo(inStream, startArcPos + k7zStartHeaderSize + nextHeaderOffset));
+
+  if (!Buf_Create(&buffer, nextHeaderSizeT, allocTemp))
+    return SZ_ERROR_MEM;
+
+  res = LookInStream_Read(inStream, buffer.data, nextHeaderSizeT);
+  if (res == SZ_OK)
+  {
+    res = SZ_ERROR_ARCHIVE;
+    if (CrcCalc(buffer.data, nextHeaderSizeT) == nextHeaderCRC)
+    {
+      CSzData sd;
+      UInt64 type;
+      sd.Data = buffer.data;
+      sd.Size = buffer.size;
+      res = SzReadID(&sd, &type);
+      if (res == SZ_OK)
+      {
+        if (type == k7zIdEncodedHeader)
+        {
+          CBuf outBuffer;
+          Buf_Init(&outBuffer);
+          res = SzReadAndDecodePackedStreams(inStream, &sd, &outBuffer, p->startPosAfterHeader, allocTemp);
+          if (res != SZ_OK)
+            Buf_Free(&outBuffer, allocTemp);
+          else
+          {
+            Buf_Free(&buffer, allocTemp);
+            buffer.data = outBuffer.data;
+            buffer.size = outBuffer.size;
+            sd.Data = buffer.data;
+            sd.Size = buffer.size;
+            res = SzReadID(&sd, &type);
+          }
+        }
+      }
+      if (res == SZ_OK)
+      {
+        if (type == k7zIdHeader)
+          res = SzReadHeader(p, &sd, allocMain, allocTemp);
+        else
+          res = SZ_ERROR_UNSUPPORTED;
+      }
+    }
+  }
+  Buf_Free(&buffer, allocTemp);
+  return res;
+}
+
+SRes SzArEx_Open(CSzArEx *p, ILookInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
+{
+  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArEx_Free(p, allocMain);
+  return res;
+}
+
+SRes SzArEx_Extract(
+    const CSzArEx *p,
+    ILookInStream *inStream,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer,
+    size_t *outBufferSize,
+    size_t *offset,
+    size_t *outSizeProcessed,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = p->FileIndexToFolderIndexMap[fileIndex];
+  SRes res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    IAlloc_Free(allocMain, *outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CSzFolder *folder = p->db.Folders + folderIndex;
+    UInt64 unpackSizeSpec = SzFolder_GetUnpackSize(folder);
+    size_t unpackSize = (size_t)unpackSizeSpec;
+    UInt64 startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
+
+    if (unpackSize != unpackSizeSpec)
+      return SZ_ERROR_MEM;
+    *blockIndex = folderIndex;
+    IAlloc_Free(allocMain, *outBuffer);
+    *outBuffer = 0;
+
+    RINOK(LookInStream_SeekTo(inStream, startOffset));
+
+    if (res == SZ_OK)
+    {
+      *outBufferSize = unpackSize;
+      if (unpackSize != 0)
+      {
+        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
+        if (*outBuffer == 0)
+          res = SZ_ERROR_MEM;
+      }
+      if (res == SZ_OK)
+      {
+        res = SzFolder_Decode(folder,
+          p->db.PackSizes + p->FolderStartPackStreamIndex[folderIndex],
+          inStream, startOffset,
+          *outBuffer, unpackSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (folder->UnpackCRCDefined)
+          {
+            if (CrcCalc(*outBuffer, unpackSize) != folder->UnpackCRC)
+              res = SZ_ERROR_CRC;
+          }
+        }
+      }
+    }
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i;
+    CSzFileItem *fileItem = p->db.Files + fileIndex;
+    *offset = 0;
+    for (i = p->FolderStartFileIndex[folderIndex]; i < fileIndex; i++)
+      *offset += (UInt32)p->db.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem->Size;
+    if (*offset + *outSizeProcessed > *outBufferSize)
+      return SZ_ERROR_FAIL;
+    if (fileItem->CrcDefined && CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem->Crc)
+      res = SZ_ERROR_CRC;
+  }
+  return res;
+}
diff -Nru src-old/lib/lib7z/7zStream.c src/lib/lib7z/7zStream.c
--- src-old/lib/lib7z/7zStream.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zStream.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,169 @@
+/* 7zStream.c -- 7z Stream functions
+2010-03-11 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "Types.h"
+
+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType)
+{
+  while (size != 0)
+  {
+    size_t processed = size;
+    RINOK(stream->Read(stream, buf, &processed));
+    if (processed == 0)
+      return errorType;
+    buf = (void *)((Byte *)buf + processed);
+    size -= processed;
+  }
+  return SZ_OK;
+}
+
+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size)
+{
+  return SeqInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
+}
+
+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf)
+{
+  size_t processed = 1;
+  RINOK(stream->Read(stream, buf, &processed));
+  return (processed == 1) ? SZ_OK : SZ_ERROR_INPUT_EOF;
+}
+
+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset)
+{
+  Int64 t = offset;
+  return stream->Seek(stream, &t, SZ_SEEK_SET);
+}
+
+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size)
+{
+  const void *lookBuf;
+  if (*size == 0)
+    return SZ_OK;
+  RINOK(stream->Look(stream, &lookBuf, size));
+  memcpy(buf, lookBuf, *size);
+  return stream->Skip(stream, *size);
+}
+
+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType)
+{
+  while (size != 0)
+  {
+    size_t processed = size;
+    RINOK(stream->Read(stream, buf, &processed));
+    if (processed == 0)
+      return errorType;
+    buf = (void *)((Byte *)buf + processed);
+    size -= processed;
+  }
+  return SZ_OK;
+}
+
+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size)
+{
+  return LookInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
+}
+
+static SRes LookToRead_Look_Lookahead(void *pp, const void **buf, size_t *size)
+{
+  SRes res = SZ_OK;
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t size2 = p->size - p->pos;
+  if (size2 == 0 && *size > 0)
+  {
+    p->pos = 0;
+    size2 = LookToRead_BUF_SIZE;
+    res = p->realStream->Read(p->realStream, p->buf, &size2);
+    p->size = size2;
+  }
+  if (size2 < *size)
+    *size = size2;
+  *buf = p->buf + p->pos;
+  return res;
+}
+
+static SRes LookToRead_Look_Exact(void *pp, const void **buf, size_t *size)
+{
+  SRes res = SZ_OK;
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t size2 = p->size - p->pos;
+  if (size2 == 0 && *size > 0)
+  {
+    p->pos = 0;
+    if (*size > LookToRead_BUF_SIZE)
+      *size = LookToRead_BUF_SIZE;
+    res = p->realStream->Read(p->realStream, p->buf, size);
+    size2 = p->size = *size;
+  }
+  if (size2 < *size)
+    *size = size2;
+  *buf = p->buf + p->pos;
+  return res;
+}
+
+static SRes LookToRead_Skip(void *pp, size_t offset)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  p->pos += offset;
+  return SZ_OK;
+}
+
+static SRes LookToRead_Read(void *pp, void *buf, size_t *size)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t rem = p->size - p->pos;
+  if (rem == 0)
+    return p->realStream->Read(p->realStream, buf, size);
+  if (rem > *size)
+    rem = *size;
+  memcpy(buf, p->buf + p->pos, rem);
+  p->pos += rem;
+  *size = rem;
+  return SZ_OK;
+}
+
+static SRes LookToRead_Seek(void *pp, Int64 *pos, ESzSeek origin)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  p->pos = p->size = 0;
+  return p->realStream->Seek(p->realStream, pos, origin);
+}
+
+void LookToRead_CreateVTable(CLookToRead *p, int lookahead)
+{
+  p->s.Look = lookahead ?
+      LookToRead_Look_Lookahead :
+      LookToRead_Look_Exact;
+  p->s.Skip = LookToRead_Skip;
+  p->s.Read = LookToRead_Read;
+  p->s.Seek = LookToRead_Seek;
+}
+
+void LookToRead_Init(CLookToRead *p)
+{
+  p->pos = p->size = 0;
+}
+
+static SRes SecToLook_Read(void *pp, void *buf, size_t *size)
+{
+  CSecToLook *p = (CSecToLook *)pp;
+  return LookInStream_LookRead(p->realStream, buf, size);
+}
+
+void SecToLook_CreateVTable(CSecToLook *p)
+{
+  p->s.Read = SecToLook_Read;
+}
+
+static SRes SecToRead_Read(void *pp, void *buf, size_t *size)
+{
+  CSecToRead *p = (CSecToRead *)pp;
+  return p->realStream->Read(p->realStream, buf, size);
+}
+
+void SecToRead_CreateVTable(CSecToRead *p)
+{
+  p->s.Read = SecToRead_Read;
+}
diff -Nru src-old/lib/lib7z/7zVersion.h src/lib/lib7z/7zVersion.h
--- src-old/lib/lib7z/7zVersion.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zVersion.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,8 @@
+#define MY_VER_MAJOR 9
+#define MY_VER_MINOR 22
+#define MY_VER_BUILD 00
+#define MY_VERSION "9.22 beta"
+#define MY_7ZIP_VERSION "9.22 beta"
+#define MY_DATE "2011-04-18"
+#define MY_COPYRIGHT ": Igor Pavlov : Public domain"
+#define MY_VERSION_COPYRIGHT_DATE MY_VERSION " " MY_COPYRIGHT " : " MY_DATE
diff -Nru src-old/lib/lib7z/7zVersion.rc src/lib/lib7z/7zVersion.rc
--- src-old/lib/lib7z/7zVersion.rc	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/7zVersion.rc	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,55 @@
+#define MY_VS_FFI_FILEFLAGSMASK  0x0000003FL
+#define MY_VOS_NT_WINDOWS32  0x00040004L
+#define MY_VOS_CE_WINDOWS32  0x00050004L
+
+#define MY_VFT_APP  0x00000001L
+#define MY_VFT_DLL  0x00000002L
+
+// #include <WinVer.h>
+
+#ifndef MY_VERSION
+#include "7zVersion.h"
+#endif
+
+#define MY_VER MY_VER_MAJOR,MY_VER_MINOR,MY_VER_BUILD,0
+
+#ifdef DEBUG
+#define DBG_FL VS_FF_DEBUG
+#else
+#define DBG_FL 0
+#endif
+
+#define MY_VERSION_INFO(fileType, descr, intName, origName)  \
+LANGUAGE 9, 1 \
+1 VERSIONINFO \
+  FILEVERSION MY_VER \
+  PRODUCTVERSION MY_VER \
+  FILEFLAGSMASK MY_VS_FFI_FILEFLAGSMASK \
+  FILEFLAGS DBG_FL \
+  FILEOS MY_VOS_NT_WINDOWS32 \
+  FILETYPE fileType \
+  FILESUBTYPE 0x0L \
+BEGIN \
+    BLOCK "StringFileInfo" \
+    BEGIN  \
+        BLOCK "040904b0" \
+        BEGIN \
+            VALUE "CompanyName", "Igor Pavlov" \
+            VALUE "FileDescription", descr \
+            VALUE "FileVersion", MY_VERSION  \
+            VALUE "InternalName", intName \
+            VALUE "LegalCopyright", MY_COPYRIGHT \
+            VALUE "OriginalFilename", origName \
+            VALUE "ProductName", "7-Zip" \
+            VALUE "ProductVersion", MY_VERSION \
+        END \
+    END \
+    BLOCK "VarFileInfo" \
+    BEGIN \
+        VALUE "Translation", 0x409, 1200 \
+    END \
+END
+
+#define MY_VERSION_INFO_APP(descr, intName) MY_VERSION_INFO(MY_VFT_APP, descr, intName, intName ".exe")
+
+#define MY_VERSION_INFO_DLL(descr, intName) MY_VERSION_INFO(MY_VFT_DLL, descr, intName, intName ".dll")
diff -Nru src-old/lib/lib7z/Aes.c src/lib/lib7z/Aes.c
--- src-old/lib/lib7z/Aes.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Aes.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,282 @@
+/* Aes.c -- AES encryption / decryption
+2009-11-23 : Igor Pavlov : Public domain */
+
+#include "Aes.h"
+#include "CpuArch.h"
+
+static UInt32 T[256 * 4];
+static Byte Sbox[256] = {
+  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
+
+void MY_FAST_CALL AesCbc_Encode(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCbc_Decode(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCtr_Code(UInt32 *ivAes, Byte *data, size_t numBlocks);
+
+void MY_FAST_CALL AesCbc_Encode_Intel(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCbc_Decode_Intel(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCtr_Code_Intel(UInt32 *ivAes, Byte *data, size_t numBlocks);
+
+AES_CODE_FUNC g_AesCbc_Encode;
+AES_CODE_FUNC g_AesCbc_Decode;
+AES_CODE_FUNC g_AesCtr_Code;
+
+static UInt32 D[256 * 4];
+static Byte InvS[256];
+
+static Byte Rcon[11] = { 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };
+
+#define xtime(x) ((((x) << 1) ^ (((x) & 0x80) != 0 ? 0x1B : 0)) & 0xFF)
+
+#define Ui32(a0, a1, a2, a3) ((UInt32)(a0) | ((UInt32)(a1) << 8) | ((UInt32)(a2) << 16) | ((UInt32)(a3) << 24))
+
+#define gb0(x) ( (x)          & 0xFF)
+#define gb1(x) (((x) >> ( 8)) & 0xFF)
+#define gb2(x) (((x) >> (16)) & 0xFF)
+#define gb3(x) (((x) >> (24)) & 0xFF)
+
+void AesGenTables(void)
+{
+  unsigned i;
+  for (i = 0; i < 256; i++)
+    InvS[Sbox[i]] = (Byte)i;
+  for (i = 0; i < 256; i++)
+  {
+    {
+      UInt32 a1 = Sbox[i];
+      UInt32 a2 = xtime(a1);
+      UInt32 a3 = a2 ^ a1;
+      T[        i] = Ui32(a2, a1, a1, a3);
+      T[0x100 + i] = Ui32(a3, a2, a1, a1);
+      T[0x200 + i] = Ui32(a1, a3, a2, a1);
+      T[0x300 + i] = Ui32(a1, a1, a3, a2);
+    }
+    {
+      UInt32 a1 = InvS[i];
+      UInt32 a2 = xtime(a1);
+      UInt32 a4 = xtime(a2);
+      UInt32 a8 = xtime(a4);
+      UInt32 a9 = a8 ^ a1;
+      UInt32 aB = a8 ^ a2 ^ a1;
+      UInt32 aD = a8 ^ a4 ^ a1;
+      UInt32 aE = a8 ^ a4 ^ a2;
+      D[        i] = Ui32(aE, a9, aD, aB);
+      D[0x100 + i] = Ui32(aB, aE, a9, aD);
+      D[0x200 + i] = Ui32(aD, aB, aE, a9);
+      D[0x300 + i] = Ui32(a9, aD, aB, aE);
+    }
+  }
+  g_AesCbc_Encode = AesCbc_Encode;
+  g_AesCbc_Decode = AesCbc_Decode;
+  g_AesCtr_Code = AesCtr_Code;
+  #ifdef MY_CPU_X86_OR_AMD64
+  if (CPU_Is_Aes_Supported())
+  {
+    g_AesCbc_Encode = AesCbc_Encode_Intel;
+    g_AesCbc_Decode = AesCbc_Decode_Intel;
+    g_AesCtr_Code = AesCtr_Code_Intel;
+  }
+  #endif
+}
+
+#define HT(i, x, s) (T + (x << 8))[gb ## x(s[(i + x) & 3])]
+#define HT4(m, i, s, p) m[i] = \
+    HT(i, 0, s) ^ \
+    HT(i, 1, s) ^ \
+    HT(i, 2, s) ^ \
+    HT(i, 3, s) ^ w[p + i]
+/* such order (2031) in HT16 is for VC6/K8 speed optimization) */
+#define HT16(m, s, p) \
+    HT4(m, 2, s, p); \
+    HT4(m, 0, s, p); \
+    HT4(m, 3, s, p); \
+    HT4(m, 1, s, p); \
+
+#define FT(i, x) Sbox[gb ## x(m[(i + x) & 3])]
+#define FT4(i) dest[i] = Ui32(FT(i, 0), FT(i, 1), FT(i, 2), FT(i, 3)) ^ w[i];
+
+#define HD(i, x, s) (D + (x << 8))[gb ## x(s[(i - x) & 3])]
+#define HD4(m, i, s, p) m[i] = \
+    HD(i, 0, s) ^ \
+    HD(i, 1, s) ^ \
+    HD(i, 2, s) ^ \
+    HD(i, 3, s) ^ w[p + i];
+/* such order (0231) in HD16 is for VC6/K8 speed optimization) */
+#define HD16(m, s, p) \
+    HD4(m, 0, s, p); \
+    HD4(m, 2, s, p); \
+    HD4(m, 3, s, p); \
+    HD4(m, 1, s, p); \
+
+#define FD(i, x) InvS[gb ## x(m[(i - x) & 3])]
+#define FD4(i) dest[i] = Ui32(FD(i, 0), FD(i, 1), FD(i, 2), FD(i, 3)) ^ w[i];
+
+void MY_FAST_CALL Aes_SetKey_Enc(UInt32 *w, const Byte *key, unsigned keySize)
+{
+  unsigned i, wSize;
+  wSize = keySize + 28;
+  keySize /= 4;
+  w[0] = ((UInt32)keySize / 2) + 3;
+  w += 4;
+
+  for (i = 0; i < keySize; i++, key += 4)
+    w[i] = GetUi32(key);
+
+  for (; i < wSize; i++)
+  {
+    UInt32 t = w[i - 1];
+    unsigned rem = i % keySize;
+    if (rem == 0)
+      t = Ui32(Sbox[gb1(t)] ^ Rcon[i / keySize], Sbox[gb2(t)], Sbox[gb3(t)], Sbox[gb0(t)]);
+    else if (keySize > 6 && rem == 4)
+      t = Ui32(Sbox[gb0(t)], Sbox[gb1(t)], Sbox[gb2(t)], Sbox[gb3(t)]);
+    w[i] = w[i - keySize] ^ t;
+  }
+}
+
+void MY_FAST_CALL Aes_SetKey_Dec(UInt32 *w, const Byte *key, unsigned keySize)
+{
+  unsigned i, num;
+  Aes_SetKey_Enc(w, key, keySize);
+  num = keySize + 20;
+  w += 8;
+  for (i = 0; i < num; i++)
+  {
+    UInt32 r = w[i];
+    w[i] =
+      D[        Sbox[gb0(r)]] ^
+      D[0x100 + Sbox[gb1(r)]] ^
+      D[0x200 + Sbox[gb2(r)]] ^
+      D[0x300 + Sbox[gb3(r)]];
+  }
+}
+
+/* Aes_Encode and Aes_Decode functions work with little-endian words.
+  src and dest are pointers to 4 UInt32 words.
+  arc and dest can point to same block */
+
+static void Aes_Encode(const UInt32 *w, UInt32 *dest, const UInt32 *src)
+{
+  UInt32 s[4];
+  UInt32 m[4];
+  UInt32 numRounds2 = w[0];
+  w += 4;
+  s[0] = src[0] ^ w[0];
+  s[1] = src[1] ^ w[1];
+  s[2] = src[2] ^ w[2];
+  s[3] = src[3] ^ w[3];
+  w += 4;
+  for (;;)
+  {
+    HT16(m, s, 0);
+    if (--numRounds2 == 0)
+      break;
+    HT16(s, m, 4);
+    w += 8;
+  }
+  w += 4;
+  FT4(0); FT4(1); FT4(2); FT4(3);
+}
+
+static void Aes_Decode(const UInt32 *w, UInt32 *dest, const UInt32 *src)
+{
+  UInt32 s[4];
+  UInt32 m[4];
+  UInt32 numRounds2 = w[0];
+  w += 4 + numRounds2 * 8;
+  s[0] = src[0] ^ w[0];
+  s[1] = src[1] ^ w[1];
+  s[2] = src[2] ^ w[2];
+  s[3] = src[3] ^ w[3];
+  for (;;)
+  {
+    w -= 8;
+    HD16(m, s, 4);
+    if (--numRounds2 == 0)
+      break;
+    HD16(s, m, 0);
+  }
+  FD4(0); FD4(1); FD4(2); FD4(3);
+}
+
+void AesCbc_Init(UInt32 *p, const Byte *iv)
+{
+  unsigned i;
+  for (i = 0; i < 4; i++)
+    p[i] = GetUi32(iv + i * 4);
+}
+
+void MY_FAST_CALL AesCbc_Encode(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  for (; numBlocks != 0; numBlocks--, data += AES_BLOCK_SIZE)
+  {
+    p[0] ^= GetUi32(data);
+    p[1] ^= GetUi32(data + 4);
+    p[2] ^= GetUi32(data + 8);
+    p[3] ^= GetUi32(data + 12);
+
+    Aes_Encode(p + 4, p, p);
+
+    SetUi32(data,      p[0]);
+    SetUi32(data + 4,  p[1]);
+    SetUi32(data + 8,  p[2]);
+    SetUi32(data + 12, p[3]);
+  }
+}
+
+void MY_FAST_CALL AesCbc_Decode(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  UInt32 in[4], out[4];
+  for (; numBlocks != 0; numBlocks--, data += AES_BLOCK_SIZE)
+  {
+    in[0] = GetUi32(data);
+    in[1] = GetUi32(data + 4);
+    in[2] = GetUi32(data + 8);
+    in[3] = GetUi32(data + 12);
+
+    Aes_Decode(p + 4, out, in);
+
+    SetUi32(data,      p[0] ^ out[0]);
+    SetUi32(data + 4,  p[1] ^ out[1]);
+    SetUi32(data + 8,  p[2] ^ out[2]);
+    SetUi32(data + 12, p[3] ^ out[3]);
+
+    p[0] = in[0];
+    p[1] = in[1];
+    p[2] = in[2];
+    p[3] = in[3];
+  }
+}
+
+void MY_FAST_CALL AesCtr_Code(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  for (; numBlocks != 0; numBlocks--)
+  {
+    UInt32 temp[4];
+    Byte buf[16];
+    int i;
+    if (++p[0] == 0)
+      p[1]++;
+    Aes_Encode(p + 4, temp, p);
+    SetUi32(buf,      temp[0]);
+    SetUi32(buf + 4,  temp[1]);
+    SetUi32(buf + 8,  temp[2]);
+    SetUi32(buf + 12, temp[3]);
+    for (i = 0; i < 16; i++)
+      *data++ ^= buf[i];
+  }
+}
diff -Nru src-old/lib/lib7z/Aes.h src/lib/lib7z/Aes.h
--- src-old/lib/lib7z/Aes.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Aes.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,38 @@
+/* Aes.h -- AES encryption / decryption
+2009-11-23 : Igor Pavlov : Public domain */
+
+#ifndef __AES_H
+#define __AES_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+#define AES_BLOCK_SIZE 16
+
+/* Call AesGenTables one time before other AES functions */
+void AesGenTables(void);
+
+/* UInt32 pointers must be 16-byte aligned */
+
+/* 16-byte (4 * 32-bit words) blocks: 1 (IV) + 1 (keyMode) + 15 (AES-256 roundKeys) */
+#define AES_NUM_IVMRK_WORDS ((1 + 1 + 15) * 4)
+
+/* aes - 16-byte aligned pointer to keyMode+roundKeys sequence */
+/* keySize = 16 or 24 or 32 (bytes) */
+typedef void (MY_FAST_CALL *AES_SET_KEY_FUNC)(UInt32 *aes, const Byte *key, unsigned keySize);
+void MY_FAST_CALL Aes_SetKey_Enc(UInt32 *aes, const Byte *key, unsigned keySize);
+void MY_FAST_CALL Aes_SetKey_Dec(UInt32 *aes, const Byte *key, unsigned keySize);
+
+/* ivAes - 16-byte aligned pointer to iv+keyMode+roundKeys sequence: UInt32[AES_NUM_IVMRK_WORDS] */
+void AesCbc_Init(UInt32 *ivAes, const Byte *iv); /* iv size is AES_BLOCK_SIZE */
+/* data - 16-byte aligned pointer to data */
+/* numBlocks - the number of 16-byte blocks in data array */
+typedef void (MY_FAST_CALL *AES_CODE_FUNC)(UInt32 *ivAes, Byte *data, size_t numBlocks);
+extern AES_CODE_FUNC g_AesCbc_Encode;
+extern AES_CODE_FUNC g_AesCbc_Decode;
+extern AES_CODE_FUNC g_AesCtr_Code;
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/AesOpt.c src/lib/lib7z/AesOpt.c
--- src-old/lib/lib7z/AesOpt.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/AesOpt.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,182 @@
+/* AesOpt.c -- Intel's AES
+2009-11-23 : Igor Pavlov : Public domain */
+
+#include "CpuArch.h"
+
+#ifdef MY_CPU_X86_OR_AMD64
+#if _MSC_VER >= 1500
+#define USE_INTEL_AES
+#endif
+#endif
+
+#ifdef USE_INTEL_AES
+
+#include <wmmintrin.h>
+
+void MY_FAST_CALL AesCbc_Encode_Intel(__m128i *p, __m128i *data, size_t numBlocks)
+{
+  __m128i m = *p;
+  for (; numBlocks != 0; numBlocks--, data++)
+  {
+    UInt32 numRounds2 = *(const UInt32 *)(p + 1) - 1;
+    const __m128i *w = p + 3;
+    m = _mm_xor_si128(m, *data);
+    m = _mm_xor_si128(m, p[2]);
+    do
+    {
+      m = _mm_aesenc_si128(m, w[0]);
+      m = _mm_aesenc_si128(m, w[1]);
+      w += 2;
+    }
+    while (--numRounds2 != 0);
+    m = _mm_aesenc_si128(m, w[0]);
+    m = _mm_aesenclast_si128(m, w[1]);
+    *data = m;
+  }
+  *p = m;
+}
+
+#define NUM_WAYS 3
+
+#define AES_OP_W(op, n) { \
+    const __m128i t = w[n]; \
+    m0 = op(m0, t); \
+    m1 = op(m1, t); \
+    m2 = op(m2, t); \
+    }
+
+#define AES_DEC(n) AES_OP_W(_mm_aesdec_si128, n)
+#define AES_DEC_LAST(n) AES_OP_W(_mm_aesdeclast_si128, n)
+#define AES_ENC(n) AES_OP_W(_mm_aesenc_si128, n)
+#define AES_ENC_LAST(n) AES_OP_W(_mm_aesenclast_si128, n)
+
+void MY_FAST_CALL AesCbc_Decode_Intel(__m128i *p, __m128i *data, size_t numBlocks)
+{
+  __m128i iv = *p;
+  for (; numBlocks >= NUM_WAYS; numBlocks -= NUM_WAYS, data += NUM_WAYS)
+  {
+    UInt32 numRounds2 = *(const UInt32 *)(p + 1);
+    const __m128i *w = p + numRounds2 * 2;
+    __m128i m0, m1, m2;
+    {
+      const __m128i t = w[2];
+      m0 = _mm_xor_si128(t, data[0]);
+      m1 = _mm_xor_si128(t, data[1]);
+      m2 = _mm_xor_si128(t, data[2]);
+    }
+    numRounds2--;
+    do
+    {
+      AES_DEC(1)
+      AES_DEC(0)
+      w -= 2;
+    }
+    while (--numRounds2 != 0);
+    AES_DEC(1)
+    AES_DEC_LAST(0)
+
+    {
+      __m128i t;
+      t = _mm_xor_si128(m0, iv); iv = data[0]; data[0] = t;
+      t = _mm_xor_si128(m1, iv); iv = data[1]; data[1] = t;
+      t = _mm_xor_si128(m2, iv); iv = data[2]; data[2] = t;
+    }
+  }
+  for (; numBlocks != 0; numBlocks--, data++)
+  {
+    UInt32 numRounds2 = *(const UInt32 *)(p + 1);
+    const __m128i *w = p + numRounds2 * 2;
+    __m128i m = _mm_xor_si128(w[2], *data);
+    numRounds2--;
+    do
+    {
+      m = _mm_aesdec_si128(m, w[1]);
+      m = _mm_aesdec_si128(m, w[0]);
+      w -= 2;
+    }
+    while (--numRounds2 != 0);
+    m = _mm_aesdec_si128(m, w[1]);
+    m = _mm_aesdeclast_si128(m, w[0]);
+
+    m = _mm_xor_si128(m, iv);
+    iv = *data;
+    *data = m;
+  }
+  *p = iv;
+}
+
+void MY_FAST_CALL AesCtr_Code_Intel(__m128i *p, __m128i *data, size_t numBlocks)
+{
+  __m128i ctr = *p;
+  __m128i one;
+  one.m128i_u64[0] = 1;
+  one.m128i_u64[1] = 0;
+  for (; numBlocks >= NUM_WAYS; numBlocks -= NUM_WAYS, data += NUM_WAYS)
+  {
+    UInt32 numRounds2 = *(const UInt32 *)(p + 1) - 1;
+    const __m128i *w = p;
+    __m128i m0, m1, m2;
+    {
+      const __m128i t = w[2];
+      ctr = _mm_add_epi64(ctr, one); m0 = _mm_xor_si128(ctr, t);
+      ctr = _mm_add_epi64(ctr, one); m1 = _mm_xor_si128(ctr, t);
+      ctr = _mm_add_epi64(ctr, one); m2 = _mm_xor_si128(ctr, t);
+    }
+    w += 3;
+    do
+    {
+      AES_ENC(0)
+      AES_ENC(1)
+      w += 2;
+    }
+    while (--numRounds2 != 0);
+    AES_ENC(0)
+    AES_ENC_LAST(1)
+    data[0] = _mm_xor_si128(data[0], m0);
+    data[1] = _mm_xor_si128(data[1], m1);
+    data[2] = _mm_xor_si128(data[2], m2);
+  }
+  for (; numBlocks != 0; numBlocks--, data++)
+  {
+    UInt32 numRounds2 = *(const UInt32 *)(p + 1) - 1;
+    const __m128i *w = p;
+    __m128i m;
+    ctr = _mm_add_epi64(ctr, one);
+    m = _mm_xor_si128(ctr, p[2]);
+    w += 3;
+    do
+    {
+      m = _mm_aesenc_si128(m, w[0]);
+      m = _mm_aesenc_si128(m, w[1]);
+      w += 2;
+    }
+    while (--numRounds2 != 0);
+    m = _mm_aesenc_si128(m, w[0]);
+    m = _mm_aesenclast_si128(m, w[1]);
+    *data = _mm_xor_si128(*data, m);
+  }
+  *p = ctr;
+}
+
+#else
+
+void MY_FAST_CALL AesCbc_Encode(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCbc_Decode(UInt32 *ivAes, Byte *data, size_t numBlocks);
+void MY_FAST_CALL AesCtr_Code(UInt32 *ivAes, Byte *data, size_t numBlocks);
+
+void MY_FAST_CALL AesCbc_Encode_Intel(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  AesCbc_Encode(p, data, numBlocks);
+}
+
+void MY_FAST_CALL AesCbc_Decode_Intel(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  AesCbc_Decode(p, data, numBlocks);
+}
+
+void MY_FAST_CALL AesCtr_Code_Intel(UInt32 *p, Byte *data, size_t numBlocks)
+{
+  AesCtr_Code(p, data, numBlocks);
+}
+
+#endif
diff -Nru src-old/lib/lib7z/Alloc.c src/lib/lib7z/Alloc.c
--- src-old/lib/lib7z/Alloc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Alloc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,127 @@
+/* Alloc.c -- Memory allocation functions
+2008-09-24
+Igor Pavlov
+Public domain */
+
+#ifdef _WIN32_7Z
+#include <windows.h>
+#endif
+#include <stdlib.h>
+
+#include "Alloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  {
+    void *p = malloc(size);
+    fprintf(stderr, "\nAlloc %10d bytes, count = %10d,  addr = %8X", size, g_allocCount++, (unsigned)p);
+    return p;
+  }
+  #else
+  return malloc(size);
+  #endif
+}
+
+void MyFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree; count = %10d,  addr = %8X", --g_allocCount, (unsigned)address);
+  #endif
+  free(address);
+}
+
+#ifdef _WIN32_7Z
+
+void *MidAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Mid %10d bytes;  count = %10d", size, g_allocCountMid++);
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#ifndef MEM_LARGE_PAGES
+#undef _7ZIP_LARGE_PAGES
+#endif
+
+#ifdef _7ZIP_LARGE_PAGES
+SIZE_T g_LargePageSize = 0;
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+#endif
+
+void SetLargePageSize()
+{
+  #ifdef _7ZIP_LARGE_PAGES
+  SIZE_T size = 0;
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetLargePageMinimum");
+  if (largePageMinimum == 0)
+    return;
+  size = largePageMinimum();
+  if (size == 0 || (size & (size - 1)) != 0)
+    return;
+  g_LargePageSize = size;
+  #endif
+}
+
+
+void *BigAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Big %10d bytes;  count = %10d", size, g_allocCountBig++);
+  #endif
+
+  #ifdef _7ZIP_LARGE_PAGES
+  if (g_LargePageSize != 0 && g_LargePageSize <= (1 << 30) && size >= (1 << 18))
+  {
+    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)),
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
+  #endif
+
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif
diff -Nru src-old/lib/lib7z/Alloc.h src/lib/lib7z/Alloc.h
--- src-old/lib/lib7z/Alloc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Alloc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,38 @@
+/* Alloc.h -- Memory allocation functions
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void *MyAlloc(size_t size);
+void MyFree(void *address);
+
+#ifdef _WIN32_7Z
+
+void SetLargePageSize();
+
+void *MidAlloc(size_t size);
+void MidFree(void *address);
+void *BigAlloc(size_t size);
+void BigFree(void *address);
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Bcj2.c src/lib/lib7z/Bcj2.c
--- src-old/lib/lib7z/Bcj2.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Bcj2.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,132 @@
+/* Bcj2.c -- Converter for x86 code (BCJ2)
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bcj2.h"
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)
+#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*buffer++)
+#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
+#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
+  { int i; for (i = 0; i < 5; i++) { RC_TEST; code = (code << 8) | RC_READ_BYTE; }}
+
+#define NORMALIZE if (range < kTopValue) { RC_TEST; range <<= 8; code = (code << 8) | RC_READ_BYTE; }
+
+#define IF_BIT_0(p) ttt = *(p); bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize)
+{
+  CProb p[256 + 2];
+  SizeT inPos = 0, outPos = 0;
+
+  const Byte *buffer, *bufferLim;
+  UInt32 range, code;
+  Byte prevByte = 0;
+
+  unsigned int i;
+  for (i = 0; i < sizeof(p) / sizeof(p[0]); i++)
+    p[i] = kBitModelTotal >> 1;
+
+  buffer = buf3;
+  bufferLim = buffer + size3;
+  RC_INIT2
+
+  if (outSize == 0)
+    return SZ_OK;
+
+  for (;;)
+  {
+    Byte b;
+    CProb *prob;
+    UInt32 bound;
+    UInt32 ttt;
+
+    SizeT limit = size0 - inPos;
+    if (outSize - outPos < limit)
+      limit = outSize - outPos;
+    while (limit != 0)
+    {
+      Byte b = buf0[inPos];
+      outBuf[outPos++] = b;
+      if (IsJ(prevByte, b))
+        break;
+      inPos++;
+      prevByte = b;
+      limit--;
+    }
+
+    if (limit == 0 || outPos == outSize)
+      break;
+
+    b = buf0[inPos++];
+
+    if (b == 0xE8)
+      prob = p + prevByte;
+    else if (b == 0xE9)
+      prob = p + 256;
+    else
+      prob = p + 257;
+
+    IF_BIT_0(prob)
+    {
+      UPDATE_0(prob)
+      prevByte = b;
+    }
+    else
+    {
+      UInt32 dest;
+      const Byte *v;
+      UPDATE_1(prob)
+      if (b == 0xE8)
+      {
+        v = buf1;
+        if (size1 < 4)
+          return SZ_ERROR_DATA;
+        buf1 += 4;
+        size1 -= 4;
+      }
+      else
+      {
+        v = buf2;
+        if (size2 < 4)
+          return SZ_ERROR_DATA;
+        buf2 += 4;
+        size2 -= 4;
+      }
+      dest = (((UInt32)v[0] << 24) | ((UInt32)v[1] << 16) |
+          ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
+      outBuf[outPos++] = (Byte)dest;
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest >> 8);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest >> 16);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = prevByte = (Byte)(dest >> 24);
+    }
+  }
+  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
+}
diff -Nru src-old/lib/lib7z/Bcj2.h src/lib/lib7z/Bcj2.h
--- src-old/lib/lib7z/Bcj2.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Bcj2.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,38 @@
+/* Bcj2.h -- Converter for x86 code (BCJ2)
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __BCJ2_H
+#define __BCJ2_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+Conditions:
+  outSize <= FullOutputSize,
+  where FullOutputSize is full size of output stream of x86_2 filter.
+
+If buf0 overlaps outBuf, there are two required conditions:
+  1) (buf0 >= outBuf)
+  2) (buf0 + size0 >= outBuf + FullOutputSize).
+
+Returns:
+  SZ_OK
+  SZ_ERROR_DATA - Data error
+*/
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Bra.c src/lib/lib7z/Bra.c
--- src-old/lib/lib7z/Bra.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Bra.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,133 @@
+/* Bra.c -- Converters for RISC code
+2010-04-16 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  ip += 8;
+  for (i = 0; i <= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 dest;
+      UInt32 src = ((UInt32)data[i + 2] << 16) | ((UInt32)data[i + 1] << 8) | (data[i + 0]);
+      src <<= 2;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest >>= 2;
+      data[i + 2] = (Byte)(dest >> 16);
+      data[i + 1] = (Byte)(dest >> 8);
+      data[i + 0] = (Byte)dest;
+    }
+  }
+  return i;
+}
+
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  ip += 4;
+  for (i = 0; i <= size; i += 2)
+  {
+    if ((data[i + 1] & 0xF8) == 0xF0 &&
+        (data[i + 3] & 0xF8) == 0xF8)
+    {
+      UInt32 dest;
+      UInt32 src =
+        (((UInt32)data[i + 1] & 0x7) << 19) |
+        ((UInt32)data[i + 0] << 11) |
+        (((UInt32)data[i + 3] & 0x7) << 8) |
+        (data[i + 2]);
+
+      src <<= 1;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest >>= 1;
+
+      data[i + 1] = (Byte)(0xF0 | ((dest >> 19) & 0x7));
+      data[i + 0] = (Byte)(dest >> 11);
+      data[i + 3] = (Byte)(0xF8 | ((dest >> 8) & 0x7));
+      data[i + 2] = (Byte)dest;
+      i += 2;
+    }
+  }
+  return i;
+}
+
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i <= size; i += 4)
+  {
+    if ((data[i] >> 2) == 0x12 && (data[i + 3] & 3) == 1)
+    {
+      UInt32 src = ((UInt32)(data[i + 0] & 3) << 24) |
+        ((UInt32)data[i + 1] << 16) |
+        ((UInt32)data[i + 2] << 8) |
+        ((UInt32)data[i + 3] & (~3));
+
+      UInt32 dest;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      data[i + 0] = (Byte)(0x48 | ((dest >> 24) &  0x3));
+      data[i + 1] = (Byte)(dest >> 16);
+      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 3] &= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}
+
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  UInt32 i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i <= size; i += 4)
+  {
+    if ((data[i] == 0x40 && (data[i + 1] & 0xC0) == 0x00) ||
+        (data[i] == 0x7F && (data[i + 1] & 0xC0) == 0xC0))
+    {
+      UInt32 src =
+        ((UInt32)data[i + 0] << 24) |
+        ((UInt32)data[i + 1] << 16) |
+        ((UInt32)data[i + 2] << 8) |
+        ((UInt32)data[i + 3]);
+      UInt32 dest;
+
+      src <<= 2;
+      if (encoding)
+        dest = ip + i + src;
+      else
+        dest = src - (ip + i);
+      dest >>= 2;
+
+      dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest >> 24);
+      data[i + 1] = (Byte)(dest >> 16);
+      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}
diff -Nru src-old/lib/lib7z/Bra.h src/lib/lib7z/Bra.h
--- src-old/lib/lib7z/Bra.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Bra.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,68 @@
+/* Bra.h -- Branch converters for executables
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __BRA_H
+#define __BRA_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+These functions convert relative addresses to absolute addresses
+in CALL instructions to increase the compression ratio.
+
+  In:
+    data     - data buffer
+    size     - size of data
+    ip       - current virtual Instruction Pinter (IP) value
+    state    - state variable for x86 converter
+    encoding - 0 (for decoding), 1 (for encoding)
+
+  Out:
+    state    - state variable for x86 converter
+
+  Returns:
+    The number of processed bytes. If you call these functions with multiple calls,
+    you must start next call with first byte after block of processed bytes.
+
+  Type   Endian  Alignment  LookAhead
+
+  x86    little      1          4
+  ARMT   little      2          2
+  ARM    little      4          0
+  PPC     big        4          0
+  SPARC   big        4          0
+  IA64   little     16          0
+
+  size must be >= Alignment + LookAhead, if it's not last block.
+  If (size < Alignment + LookAhead), converter returns 0.
+
+  Example:
+
+    UInt32 ip = 0;
+    for ()
+    {
+      ; size must be >= Alignment + LookAhead, if it's not last block
+      SizeT processed = Convert(data, size, ip, 1);
+      data += processed;
+      size -= processed;
+      ip += processed;
+    }
+*/
+
+#define x86_Convert_Init(state) { state = 0; }
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Bra86.c src/lib/lib7z/Bra86.c
--- src-old/lib/lib7z/Bra86.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Bra86.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,85 @@
+/* Bra86.c -- Converter for x86 code (BCJ)
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
+{
+  SizeT bufferPos = 0, prevPosT;
+  UInt32 prevMask = *state & 0x7;
+  if (size < 5)
+    return 0;
+  ip += 5;
+  prevPosT = (SizeT)0 - 1;
+
+  for (;;)
+  {
+    Byte *p = data + bufferPos;
+    Byte *limit = data + size - 4;
+    for (; p < limit; p++)
+      if ((*p & 0xFE) == 0xE8)
+        break;
+    bufferPos = (SizeT)(p - data);
+    if (p >= limit)
+      break;
+    prevPosT = bufferPos - prevPosT;
+    if (prevPosT > 3)
+      prevMask = 0;
+    else
+    {
+      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
+      if (prevMask != 0)
+      {
+        Byte b = p[4 - kMaskToBitNumber[prevMask]];
+        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
+        {
+          prevPosT = bufferPos;
+          prevMask = ((prevMask << 1) & 0x7) | 1;
+          bufferPos++;
+          continue;
+        }
+      }
+    }
+    prevPosT = bufferPos;
+
+    if (Test86MSByte(p[4]))
+    {
+      UInt32 src = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);
+      UInt32 dest;
+      for (;;)
+      {
+        Byte b;
+        int index;
+        if (encoding)
+          dest = (ip + (UInt32)bufferPos) + src;
+        else
+          dest = src - (ip + (UInt32)bufferPos);
+        if (prevMask == 0)
+          break;
+        index = kMaskToBitNumber[prevMask] * 8;
+        b = (Byte)(dest >> (24 - index));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 << (32 - index)) - 1);
+      }
+      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
+      p[3] = (Byte)(dest >> 16);
+      p[2] = (Byte)(dest >> 8);
+      p[1] = (Byte)dest;
+      bufferPos += 5;
+    }
+    else
+    {
+      prevMask = ((prevMask << 1) & 0x7) | 1;
+      bufferPos++;
+    }
+  }
+  prevPosT = bufferPos - prevPosT;
+  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
+  return bufferPos;
+}
diff -Nru src-old/lib/lib7z/BraIA64.c src/lib/lib7z/BraIA64.c
--- src-old/lib/lib7z/BraIA64.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/BraIA64.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,67 @@
+/* BraIA64.c -- Converter for IA-64 code
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+static const Byte kBranchTable[32] =
+{
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0
+};
+
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 16)
+    return 0;
+  size -= 16;
+  for (i = 0; i <= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] & 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    int slot;
+    for (slot = 0; slot < 3; slot++, bitPos += 41)
+    {
+      UInt32 bytePos, bitRes;
+      UInt64 instruction, instNorm;
+      int j;
+      if (((mask >> slot) & 1) == 0)
+        continue;
+      bytePos = (bitPos >> 3);
+      bitRes = bitPos & 0x7;
+      instruction = 0;
+      for (j = 0; j < 6; j++)
+        instruction += (UInt64)data[i + j + bytePos] << (8 * j);
+
+      instNorm = instruction >> bitRes;
+      if (((instNorm >> 37) & 0xF) == 0x5 && ((instNorm >> 9) & 0x7) == 0)
+      {
+        UInt32 src = (UInt32)((instNorm >> 13) & 0xFFFFF);
+        UInt32 dest;
+        src |= ((UInt32)(instNorm >> 36) & 1) << 20;
+
+        src <<= 4;
+
+        if (encoding)
+          dest = ip + (UInt32)i + src;
+        else
+          dest = src - (ip + (UInt32)i);
+
+        dest >>= 4;
+
+        instNorm &= ~((UInt64)(0x8FFFFF) << 13);
+        instNorm |= ((UInt64)(dest & 0xFFFFF) << 13);
+        instNorm |= ((UInt64)(dest & 0x100000) << (36 - 20));
+
+        instruction &= (1 << bitRes) - 1;
+        instruction |= (instNorm << bitRes);
+        for (j = 0; j < 6; j++)
+          data[i + j + bytePos] = (Byte)(instruction >> (8 * j));
+      }
+    }
+  }
+  return i;
+}
diff -Nru src-old/lib/lib7z/BwtSort.c src/lib/lib7z/BwtSort.c
--- src-old/lib/lib7z/BwtSort.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/BwtSort.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,516 @@
+/* BwtSort.c -- BWT block sorting
+2008-08-17
+Igor Pavlov
+Public domain */
+
+#include "BwtSort.h"
+#include "Sort.h"
+
+/* #define BLOCK_SORT_USE_HEAP_SORT */
+
+#define NO_INLINE MY_FAST_CALL
+
+/* Don't change it !!! */
+#define kNumHashBytes 2
+#define kNumHashValues (1 << (kNumHashBytes * 8))
+
+/* kNumRefBitsMax must be < (kNumHashBytes * 8) = 16 */
+#define kNumRefBitsMax 12
+
+#define BS_TEMP_SIZE kNumHashValues
+
+#ifdef BLOCK_SORT_EXTERNAL_FLAGS
+
+/* 32 Flags in UInt32 word */
+#define kNumFlagsBits 5
+#define kNumFlagsInWord (1 << kNumFlagsBits)
+#define kFlagsMask (kNumFlagsInWord - 1)
+#define kAllFlags 0xFFFFFFFF
+
+#else
+
+#define kNumBitsMax 20
+#define kIndexMask ((1 << kNumBitsMax) - 1)
+#define kNumExtraBits (32 - kNumBitsMax)
+#define kNumExtra0Bits (kNumExtraBits - 2)
+#define kNumExtra0Mask ((1 << kNumExtra0Bits) - 1)
+
+#define SetFinishedGroupSize(p, size) \
+  {  *(p) |= ((((size) - 1) & kNumExtra0Mask) << kNumBitsMax); \
+    if ((size) > (1 << kNumExtra0Bits)) { \
+    *(p) |= 0x40000000;  *((p) + 1) |= ((((size) - 1)>> kNumExtra0Bits) << kNumBitsMax); } } \
+
+static void SetGroupSize(UInt32 *p, UInt32 size)
+{
+  if (--size == 0)
+    return;
+  *p |= 0x80000000 | ((size & kNumExtra0Mask) << kNumBitsMax);
+  if (size >= (1 << kNumExtra0Bits))
+  {
+    *p |= 0x40000000;
+    p[1] |= ((size >> kNumExtra0Bits) << kNumBitsMax);
+  }
+}
+
+#endif
+
+/*
+SortGroup - is recursive Range-Sort function with HeapSort optimization for small blocks
+  "range" is not real range. It's only for optimization.
+returns: 1 - if there are groups, 0 - no more groups
+*/
+
+UInt32 NO_INLINE SortGroup(UInt32 BlockSize, UInt32 NumSortedBytes, UInt32 groupOffset, UInt32 groupSize, int NumRefBits, UInt32 *Indices
+  #ifndef BLOCK_SORT_USE_HEAP_SORT
+  , UInt32 left, UInt32 range
+  #endif
+  )
+{
+  UInt32 *ind2 = Indices + groupOffset;
+  UInt32 *Groups;
+  if (groupSize <= 1)
+  {
+    /*
+    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+    SetFinishedGroupSize(ind2, 1);
+    #endif
+    */
+    return 0;
+  }
+  Groups = Indices + BlockSize + BS_TEMP_SIZE;
+  if (groupSize <= ((UInt32)1 << NumRefBits)
+      #ifndef BLOCK_SORT_USE_HEAP_SORT
+      && groupSize <= range
+      #endif
+      )
+  {
+    UInt32 *temp = Indices + BlockSize;
+    UInt32 j;
+    UInt32 mask, thereAreGroups, group, cg;
+    {
+      UInt32 gPrev;
+      UInt32 gRes = 0;
+      {
+        UInt32 sp = ind2[0] + NumSortedBytes;
+        if (sp >= BlockSize) sp -= BlockSize;
+        gPrev = Groups[sp];
+        temp[0] = (gPrev << NumRefBits);
+      }
+
+      for (j = 1; j < groupSize; j++)
+      {
+        UInt32 sp = ind2[j] + NumSortedBytes;
+        UInt32 g;
+        if (sp >= BlockSize) sp -= BlockSize;
+        g = Groups[sp];
+        temp[j] = (g << NumRefBits) | j;
+        gRes |= (gPrev ^ g);
+      }
+      if (gRes == 0)
+      {
+        #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+        SetGroupSize(ind2, groupSize);
+        #endif
+        return 1;
+      }
+    }
+
+    HeapSort(temp, groupSize);
+    mask = ((1 << NumRefBits) - 1);
+    thereAreGroups = 0;
+
+    group = groupOffset;
+    cg = (temp[0] >> NumRefBits);
+    temp[0] = ind2[temp[0] & mask];
+
+    {
+    #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+    UInt32 *Flags = Groups + BlockSize;
+    #else
+    UInt32 prevGroupStart = 0;
+    #endif
+
+    for (j = 1; j < groupSize; j++)
+    {
+      UInt32 val = temp[j];
+      UInt32 cgCur = (val >> NumRefBits);
+
+      if (cgCur != cg)
+      {
+        cg = cgCur;
+        group = groupOffset + j;
+
+        #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+        {
+        UInt32 t = group - 1;
+        Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask));
+        }
+        #else
+        SetGroupSize(temp + prevGroupStart, j - prevGroupStart);
+        prevGroupStart = j;
+        #endif
+      }
+      else
+        thereAreGroups = 1;
+      {
+      UInt32 ind = ind2[val & mask];
+      temp[j] = ind;
+      Groups[ind] = group;
+      }
+    }
+
+    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+    SetGroupSize(temp + prevGroupStart, j - prevGroupStart);
+    #endif
+    }
+
+    for (j = 0; j < groupSize; j++)
+      ind2[j] = temp[j];
+    return thereAreGroups;
+  }
+
+  /* Check that all strings are in one group (cannot sort) */
+  {
+    UInt32 group, j;
+    UInt32 sp = ind2[0] + NumSortedBytes; if (sp >= BlockSize) sp -= BlockSize;
+    group = Groups[sp];
+    for (j = 1; j < groupSize; j++)
+    {
+      sp = ind2[j] + NumSortedBytes; if (sp >= BlockSize) sp -= BlockSize;
+      if (Groups[sp] != group)
+        break;
+    }
+    if (j == groupSize)
+    {
+      #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+      SetGroupSize(ind2, groupSize);
+      #endif
+      return 1;
+    }
+  }
+
+  #ifndef BLOCK_SORT_USE_HEAP_SORT
+  {
+  /* ---------- Range Sort ---------- */
+  UInt32 i;
+  UInt32 mid;
+  for (;;)
+  {
+    UInt32 j;
+    if (range <= 1)
+    {
+      #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+      SetGroupSize(ind2, groupSize);
+      #endif
+      return 1;
+    }
+    mid = left + ((range + 1) >> 1);
+    j = groupSize;
+    i = 0;
+    do
+    {
+      UInt32 sp = ind2[i] + NumSortedBytes; if (sp >= BlockSize) sp -= BlockSize;
+      if (Groups[sp] >= mid)
+      {
+        for (j--; j > i; j--)
+        {
+          sp = ind2[j] + NumSortedBytes; if (sp >= BlockSize) sp -= BlockSize;
+          if (Groups[sp] < mid)
+          {
+            UInt32 temp = ind2[i]; ind2[i] = ind2[j]; ind2[j] = temp;
+            break;
+          }
+        }
+        if (i >= j)
+          break;
+      }
+    }
+    while (++i < j);
+    if (i == 0)
+    {
+      range = range - (mid - left);
+      left = mid;
+    }
+    else if (i == groupSize)
+      range = (mid - left);
+    else
+      break;
+  }
+
+  #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+  {
+    UInt32 t = (groupOffset + i - 1);
+    UInt32 *Flags = Groups + BlockSize;
+    Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask));
+  }
+  #endif
+
+  {
+    UInt32 j;
+    for (j = i; j < groupSize; j++)
+      Groups[ind2[j]] = groupOffset + i;
+  }
+
+  {
+  UInt32 res = SortGroup(BlockSize, NumSortedBytes, groupOffset, i, NumRefBits, Indices, left, mid - left);
+  return res | SortGroup(BlockSize, NumSortedBytes, groupOffset + i, groupSize - i, NumRefBits, Indices, mid, range - (mid - left));
+  }
+
+  }
+
+  #else
+
+  /* ---------- Heap Sort ---------- */
+
+  {
+    UInt32 j;
+    for (j = 0; j < groupSize; j++)
+    {
+      UInt32 sp = ind2[j] + NumSortedBytes; if (sp >= BlockSize) sp -= BlockSize;
+      ind2[j] = sp;
+    }
+
+    HeapSortRef(ind2, Groups, groupSize);
+
+    /* Write Flags */
+    {
+    UInt32 sp = ind2[0];
+    UInt32 group = Groups[sp];
+
+    #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+    UInt32 *Flags = Groups + BlockSize;
+    #else
+    UInt32 prevGroupStart = 0;
+    #endif
+
+    for (j = 1; j < groupSize; j++)
+    {
+      sp = ind2[j];
+      if (Groups[sp] != group)
+      {
+        group = Groups[sp];
+        #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+        {
+        UInt32 t = groupOffset + j - 1;
+        Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask));
+        }
+        #else
+        SetGroupSize(ind2 + prevGroupStart, j - prevGroupStart);
+        prevGroupStart = j;
+        #endif
+      }
+    }
+
+    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+    SetGroupSize(ind2 + prevGroupStart, j - prevGroupStart);
+    #endif
+    }
+    {
+    /* Write new Groups values and Check that there are groups */
+    UInt32 thereAreGroups = 0;
+    for (j = 0; j < groupSize; j++)
+    {
+      UInt32 group = groupOffset + j;
+      #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+      UInt32 subGroupSize = ((ind2[j] & ~0xC0000000) >> kNumBitsMax);
+      if ((ind2[j] & 0x40000000) != 0)
+        subGroupSize += ((ind2[j + 1] >> kNumBitsMax) << kNumExtra0Bits);
+      subGroupSize++;
+      for (;;)
+      {
+        UInt32 original = ind2[j];
+        UInt32 sp = original & kIndexMask;
+        if (sp < NumSortedBytes) sp += BlockSize; sp -= NumSortedBytes;
+        ind2[j] = sp | (original & ~kIndexMask);
+        Groups[sp] = group;
+        if (--subGroupSize == 0)
+          break;
+        j++;
+        thereAreGroups = 1;
+      }
+      #else
+      UInt32 *Flags = Groups + BlockSize;
+      for (;;)
+      {
+        UInt32 sp = ind2[j]; if (sp < NumSortedBytes) sp += BlockSize; sp -= NumSortedBytes;
+        ind2[j] = sp;
+        Groups[sp] = group;
+        if ((Flags[(groupOffset + j) >> kNumFlagsBits] & (1 << ((groupOffset + j) & kFlagsMask))) == 0)
+          break;
+        j++;
+        thereAreGroups = 1;
+      }
+      #endif
+    }
+    return thereAreGroups;
+    }
+  }
+  #endif
+}
+
+/* conditions: blockSize > 0 */
+UInt32 BlockSort(UInt32 *Indices, const Byte *data, UInt32 blockSize)
+{
+  UInt32 *counters = Indices + blockSize;
+  UInt32 i;
+  UInt32 *Groups;
+  #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+  UInt32 *Flags;
+  #endif
+
+  /* Radix-Sort for 2 bytes */
+  for (i = 0; i < kNumHashValues; i++)
+    counters[i] = 0;
+  for (i = 0; i < blockSize - 1; i++)
+    counters[((UInt32)data[i] << 8) | data[i + 1]]++;
+  counters[((UInt32)data[i] << 8) | data[0]]++;
+
+  Groups = counters + BS_TEMP_SIZE;
+  #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+  Flags = Groups + blockSize;
+    {
+      UInt32 numWords = (blockSize + kFlagsMask) >> kNumFlagsBits;
+      for (i = 0; i < numWords; i++)
+        Flags[i] = kAllFlags;
+    }
+  #endif
+
+  {
+    UInt32 sum = 0;
+    for (i = 0; i < kNumHashValues; i++)
+    {
+      UInt32 groupSize = counters[i];
+      if (groupSize > 0)
+      {
+        #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+        UInt32 t = sum + groupSize - 1;
+        Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask));
+        #endif
+        sum += groupSize;
+      }
+      counters[i] = sum - groupSize;
+    }
+
+    for (i = 0; i < blockSize - 1; i++)
+      Groups[i] = counters[((UInt32)data[i] << 8) | data[i + 1]];
+    Groups[i] = counters[((UInt32)data[i] << 8) | data[0]];
+
+    for (i = 0; i < blockSize - 1; i++)
+      Indices[counters[((UInt32)data[i] << 8) | data[i + 1]]++] = i;
+    Indices[counters[((UInt32)data[i] << 8) | data[0]]++] = i;
+
+    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+    {
+    UInt32 prev = 0;
+    for (i = 0; i < kNumHashValues; i++)
+    {
+      UInt32 prevGroupSize = counters[i] - prev;
+      if (prevGroupSize == 0)
+        continue;
+      SetGroupSize(Indices + prev, prevGroupSize);
+      prev = counters[i];
+    }
+    }
+    #endif
+  }
+
+  {
+  int NumRefBits;
+  UInt32 NumSortedBytes;
+  for (NumRefBits = 0; ((blockSize - 1) >> NumRefBits) != 0; NumRefBits++);
+  NumRefBits = 32 - NumRefBits;
+  if (NumRefBits > kNumRefBitsMax)
+    NumRefBits = kNumRefBitsMax;
+
+  for (NumSortedBytes = kNumHashBytes; ; NumSortedBytes <<= 1)
+  {
+    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+    UInt32 finishedGroupSize = 0;
+    #endif
+    UInt32 newLimit = 0;
+    for (i = 0; i < blockSize;)
+    {
+      UInt32 groupSize;
+      #ifdef BLOCK_SORT_EXTERNAL_FLAGS
+
+      if ((Flags[i >> kNumFlagsBits] & (1 << (i & kFlagsMask))) == 0)
+      {
+        i++;
+        continue;
+      }
+      for (groupSize = 1;
+        (Flags[(i + groupSize) >> kNumFlagsBits] & (1 << ((i + groupSize) & kFlagsMask))) != 0;
+        groupSize++);
+
+      groupSize++;
+
+      #else
+
+      groupSize = ((Indices[i] & ~0xC0000000) >> kNumBitsMax);
+      {
+      Bool finishedGroup = ((Indices[i] & 0x80000000) == 0);
+      if ((Indices[i] & 0x40000000) != 0)
+      {
+        groupSize += ((Indices[i + 1] >> kNumBitsMax) << kNumExtra0Bits);
+        Indices[i + 1] &= kIndexMask;
+      }
+      Indices[i] &= kIndexMask;
+      groupSize++;
+      if (finishedGroup || groupSize == 1)
+      {
+        Indices[i - finishedGroupSize] &= kIndexMask;
+        if (finishedGroupSize > 1)
+          Indices[i - finishedGroupSize + 1] &= kIndexMask;
+        {
+        UInt32 newGroupSize = groupSize + finishedGroupSize;
+        SetFinishedGroupSize(Indices + i - finishedGroupSize, newGroupSize);
+        finishedGroupSize = newGroupSize;
+        }
+        i += groupSize;
+        continue;
+      }
+      finishedGroupSize = 0;
+      }
+
+      #endif
+
+      if (NumSortedBytes >= blockSize)
+      {
+        UInt32 j;
+        for (j = 0; j < groupSize; j++)
+        {
+          UInt32 t = (i + j);
+          /* Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask)); */
+          Groups[Indices[t]] = t;
+        }
+      }
+      else
+        if (SortGroup(blockSize, NumSortedBytes, i, groupSize, NumRefBits, Indices
+          #ifndef BLOCK_SORT_USE_HEAP_SORT
+          , 0, blockSize
+          #endif
+          ) != 0)
+          newLimit = i + groupSize;
+      i += groupSize;
+    }
+    if (newLimit == 0)
+      break;
+  }
+  }
+  #ifndef BLOCK_SORT_EXTERNAL_FLAGS
+  for (i = 0; i < blockSize;)
+  {
+    UInt32 groupSize = ((Indices[i] & ~0xC0000000) >> kNumBitsMax);
+    if ((Indices[i] & 0x40000000) != 0)
+    {
+      groupSize += ((Indices[i + 1] >> kNumBitsMax) << kNumExtra0Bits);
+      Indices[i + 1] &= kIndexMask;
+    }
+    Indices[i] &= kIndexMask;
+    groupSize++;
+    i += groupSize;
+  }
+  #endif
+  return Groups[0];
+}
+
diff -Nru src-old/lib/lib7z/BwtSort.h src/lib/lib7z/BwtSort.h
--- src-old/lib/lib7z/BwtSort.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/BwtSort.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,30 @@
+/* BwtSort.h -- BWT block sorting
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __BWT_SORT_H
+#define __BWT_SORT_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* use BLOCK_SORT_EXTERNAL_FLAGS if blockSize can be > 1M */
+/* #define BLOCK_SORT_EXTERNAL_FLAGS */
+
+#ifdef BLOCK_SORT_EXTERNAL_FLAGS
+#define BLOCK_SORT_EXTERNAL_SIZE(blockSize) ((((blockSize) + 31) >> 5))
+#else
+#define BLOCK_SORT_EXTERNAL_SIZE(blockSize) 0
+#endif
+
+#define BLOCK_SORT_BUF_SIZE(blockSize) ((blockSize) * 2 + BLOCK_SORT_EXTERNAL_SIZE(blockSize) + (1 << 16))
+
+UInt32 BlockSort(UInt32 *indices, const Byte *data, UInt32 blockSize);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/CpuArch.c src/lib/lib7z/CpuArch.c
--- src-old/lib/lib7z/CpuArch.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/CpuArch.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,168 @@
+/* CpuArch.c -- CPU specific code
+2010-10-26: Igor Pavlov : Public domain */
+
+#include "CpuArch.h"
+
+#ifdef MY_CPU_X86_OR_AMD64
+
+#if (defined(_MSC_VER) && !defined(MY_CPU_AMD64)) || defined(__GNUC__)
+#define USE_ASM
+#endif
+
+#if defined(USE_ASM) && !defined(MY_CPU_AMD64)
+static UInt32 CheckFlag(UInt32 flag)
+{
+  #ifdef _MSC_VER
+  __asm pushfd;
+  __asm pop EAX;
+  __asm mov EDX, EAX;
+  __asm xor EAX, flag;
+  __asm push EAX;
+  __asm popfd;
+  __asm pushfd;
+  __asm pop EAX;
+  __asm xor EAX, EDX;
+  __asm push EDX;
+  __asm popfd;
+  __asm and flag, EAX;
+  #else
+  __asm__ __volatile__ (
+    "pushf\n\t"
+    "pop  %%EAX\n\t"
+    "movl %%EAX,%%EDX\n\t"
+    "xorl %0,%%EAX\n\t"
+    "push %%EAX\n\t"
+    "popf\n\t"
+    "pushf\n\t"
+    "pop  %%EAX\n\t"
+    "xorl %%EDX,%%EAX\n\t"
+    "push %%EDX\n\t"
+    "popf\n\t"
+    "andl %%EAX, %0\n\t":
+    "=c" (flag) : "c" (flag));
+  #endif
+  return flag;
+}
+#define CHECK_CPUID_IS_SUPPORTED if (CheckFlag(1 << 18) == 0 || CheckFlag(1 << 21) == 0) return False;
+#else
+#define CHECK_CPUID_IS_SUPPORTED
+#endif
+
+static void MyCPUID(UInt32 function, UInt32 *a, UInt32 *b, UInt32 *c, UInt32 *d)
+{
+  #ifdef USE_ASM
+
+  #ifdef _MSC_VER
+
+  UInt32 a2, b2, c2, d2;
+  __asm xor EBX, EBX;
+  __asm xor ECX, ECX;
+  __asm xor EDX, EDX;
+  __asm mov EAX, function;
+  __asm cpuid;
+  __asm mov a2, EAX;
+  __asm mov b2, EBX;
+  __asm mov c2, ECX;
+  __asm mov d2, EDX;
+
+  *a = a2;
+  *b = b2;
+  *c = c2;
+  *d = d2;
+
+  #else
+
+  __asm__ __volatile__ (
+    "cpuid"
+    : "=a" (*a) ,
+      "=b" (*b) ,
+      "=c" (*c) ,
+      "=d" (*d)
+    : "0" (function)) ;
+
+  #endif
+
+  #else
+
+  int CPUInfo[4];
+  __cpuid(CPUInfo, function);
+  *a = CPUInfo[0];
+  *b = CPUInfo[1];
+  *c = CPUInfo[2];
+  *d = CPUInfo[3];
+
+  #endif
+}
+
+Bool x86cpuid_CheckAndRead(Cx86cpuid *p)
+{
+  CHECK_CPUID_IS_SUPPORTED
+  MyCPUID(0, &p->maxFunc, &p->vendor[0], &p->vendor[2], &p->vendor[1]);
+  MyCPUID(1, &p->ver, &p->b, &p->c, &p->d);
+  return True;
+}
+
+static UInt32 kVendors[][3] =
+{
+  { 0x756E6547, 0x49656E69, 0x6C65746E},
+  { 0x68747541, 0x69746E65, 0x444D4163},
+  { 0x746E6543, 0x48727561, 0x736C7561}
+};
+
+int x86cpuid_GetFirm(const Cx86cpuid *p)
+{
+  unsigned i;
+  for (i = 0; i < sizeof(kVendors) / sizeof(kVendors[i]); i++)
+  {
+    const UInt32 *v = kVendors[i];
+    if (v[0] == p->vendor[0] &&
+        v[1] == p->vendor[1] &&
+        v[2] == p->vendor[2])
+      return (int)i;
+  }
+  return -1;
+}
+
+Bool CPU_Is_InOrder(void)
+{
+  Cx86cpuid p;
+  int firm;
+  UInt32 family, model;
+  if (!x86cpuid_CheckAndRead(&p))
+    return True;
+  family = x86cpuid_GetFamily(&p);
+  model = x86cpuid_GetModel(&p);
+  firm = x86cpuid_GetFirm(&p);
+  switch (firm)
+  {
+    case CPU_FIRM_INTEL: return (family < 6 || (family == 6 && model == 0x100C));
+    case CPU_FIRM_AMD: return (family < 5 || (family == 5 && (model < 6 || model == 0xA)));
+    case CPU_FIRM_VIA: return (family < 6 || (family == 6 && model < 0xF));
+  }
+  return True;
+}
+
+#if !defined(MY_CPU_AMD64) && defined(_WIN32_7Z)
+static Bool CPU_Sys_Is_SSE_Supported(void)
+{
+  OSVERSIONINFO vi;
+  vi.dwOSVersionInfoSize = sizeof(vi);
+  if (!GetVersionEx(&vi))
+    return False;
+  return (vi.dwMajorVersion >= 5);
+}
+#define CHECK_SYS_SSE_SUPPORT if (!CPU_Sys_Is_SSE_Supported()) return False;
+#else
+#define CHECK_SYS_SSE_SUPPORT
+#endif
+
+Bool CPU_Is_Aes_Supported(void)
+{
+  Cx86cpuid p;
+  CHECK_SYS_SSE_SUPPORT
+  if (!x86cpuid_CheckAndRead(&p))
+    return False;
+  return (p.c >> 25) & 1;
+}
+
+#endif
diff -Nru src-old/lib/lib7z/CpuArch.h src/lib/lib7z/CpuArch.h
--- src-old/lib/lib7z/CpuArch.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/CpuArch.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,155 @@
+/* CpuArch.h -- CPU specific code
+2010-12-01: Igor Pavlov : Public domain */
+
+#ifndef __CPU_ARCH_H
+#define __CPU_ARCH_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+/*
+MY_CPU_LE means that CPU is LITTLE ENDIAN.
+If MY_CPU_LE is not defined, we don't know about that property of platform (it can be LITTLE ENDIAN).
+
+MY_CPU_LE_UNALIGN means that CPU is LITTLE ENDIAN and CPU supports unaligned memory accesses.
+If MY_CPU_LE_UNALIGN is not defined, we don't know about these properties of platform.
+*/
+
+#if defined(_M_X64) || defined(_M_AMD64) || defined(__x86_64__)
+#define MY_CPU_AMD64
+#endif
+
+#if defined(MY_CPU_AMD64) || defined(_M_IA64)
+#define MY_CPU_64BIT
+#endif
+
+#if defined(_M_IX86) || defined(__i386__)
+#define MY_CPU_X86
+#endif
+
+#if defined(MY_CPU_X86) || defined(MY_CPU_AMD64)
+#define MY_CPU_X86_OR_AMD64
+#endif
+
+#if defined(MY_CPU_X86) || defined(_M_ARM)
+#define MY_CPU_32BIT
+#endif
+
+#if defined(_WIN32_7Z) && defined(_M_ARM)
+#define MY_CPU_ARM_LE
+#endif
+
+#if defined(_WIN32_7Z) && defined(_M_IA64)
+#define MY_CPU_IA64_LE
+#endif
+
+#if defined(MY_CPU_X86_OR_AMD64)
+#define MY_CPU_LE_UNALIGN
+#endif
+
+#if defined(MY_CPU_X86_OR_AMD64) || defined(MY_CPU_ARM_LE)  || defined(MY_CPU_IA64_LE) || defined(__ARMEL__) || defined(__MIPSEL__) || defined(__LITTLE_ENDIAN__)
+#define MY_CPU_LE
+#endif
+
+#if defined(__BIG_ENDIAN__) || defined(__m68k__) ||  defined(__ARMEB__) || defined(__MIPSEB__)
+#define MY_CPU_BE
+#endif
+
+#if defined(MY_CPU_LE) && defined(MY_CPU_BE)
+Stop_Compiling_Bad_Endian
+#endif
+
+#ifdef MY_CPU_LE_UNALIGN
+
+#define GetUi16(p) (*(const UInt16 *)(p))
+#define GetUi32(p) (*(const UInt32 *)(p))
+#define GetUi64(p) (*(const UInt64 *)(p))
+#define SetUi16(p, d) *(UInt16 *)(p) = (d);
+#define SetUi32(p, d) *(UInt32 *)(p) = (d);
+#define SetUi64(p, d) *(UInt64 *)(p) = (d);
+
+#else
+
+#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] << 8))
+
+#define GetUi32(p) ( \
+             ((const Byte *)(p))[0]        | \
+    ((UInt32)((const Byte *)(p))[1] <<  8) | \
+    ((UInt32)((const Byte *)(p))[2] << 16) | \
+    ((UInt32)((const Byte *)(p))[3] << 24))
+
+#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))
+
+#define SetUi16(p, d) { UInt32 _x_ = (d); \
+    ((Byte *)(p))[0] = (Byte)_x_; \
+    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); }
+
+#define SetUi32(p, d) { UInt32 _x_ = (d); \
+    ((Byte *)(p))[0] = (Byte)_x_; \
+    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); \
+    ((Byte *)(p))[2] = (Byte)(_x_ >> 16); \
+    ((Byte *)(p))[3] = (Byte)(_x_ >> 24); }
+
+#define SetUi64(p, d) { UInt64 _x64_ = (d); \
+    SetUi32(p, (UInt32)_x64_); \
+    SetUi32(((Byte *)(p)) + 4, (UInt32)(_x64_ >> 32)); }
+
+#endif
+
+#if defined(MY_CPU_LE_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)
+
+#pragma intrinsic(_byteswap_ulong)
+#pragma intrinsic(_byteswap_uint64)
+#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
+#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
+
+#else
+
+#define GetBe32(p) ( \
+    ((UInt32)((const Byte *)(p))[0] << 24) | \
+    ((UInt32)((const Byte *)(p))[1] << 16) | \
+    ((UInt32)((const Byte *)(p))[2] <<  8) | \
+             ((const Byte *)(p))[3] )
+
+#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))
+
+#endif
+
+#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1])
+
+
+#ifdef MY_CPU_X86_OR_AMD64
+
+typedef struct
+{
+  UInt32 maxFunc;
+  UInt32 vendor[3];
+  UInt32 ver;
+  UInt32 b;
+  UInt32 c;
+  UInt32 d;
+} Cx86cpuid;
+
+enum
+{
+  CPU_FIRM_INTEL,
+  CPU_FIRM_AMD,
+  CPU_FIRM_VIA
+};
+
+Bool x86cpuid_CheckAndRead(Cx86cpuid *p);
+int x86cpuid_GetFirm(const Cx86cpuid *p);
+
+#define x86cpuid_GetFamily(p) (((p)->ver >> 8) & 0xFF00F)
+#define x86cpuid_GetModel(p) (((p)->ver >> 4) & 0xF00F)
+#define x86cpuid_GetStepping(p) ((p)->ver & 0xF)
+
+Bool CPU_Is_InOrder(void);
+Bool CPU_Is_Aes_Supported(void);
+
+#endif
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Delta.c src/lib/lib7z/Delta.c
--- src-old/lib/lib7z/Delta.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Delta.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,62 @@
+/* Delta.c -- Delta converter
+2009-05-26 : Igor Pavlov : Public domain */
+
+#include "Delta.h"
+
+void Delta_Init(Byte *state)
+{
+  unsigned i;
+  for (i = 0; i < DELTA_STATE_SIZE; i++)
+    state[i] = 0;
+}
+
+static void MyMemCpy(Byte *dest, const Byte *src, unsigned size)
+{
+  unsigned i;
+  for (i = 0; i < size; i++)
+    dest[i] = src[i];
+}
+
+void Delta_Encode(Byte *state, unsigned delta, Byte *data, SizeT size)
+{
+  Byte buf[DELTA_STATE_SIZE];
+  unsigned j = 0;
+  MyMemCpy(buf, state, delta);
+  {
+    SizeT i;
+    for (i = 0; i < size;)
+    {
+      for (j = 0; j < delta && i < size; i++, j++)
+      {
+        Byte b = data[i];
+        data[i] = (Byte)(b - buf[j]);
+        buf[j] = b;
+      }
+    }
+  }
+  if (j == delta)
+    j = 0;
+  MyMemCpy(state, buf + j, delta - j);
+  MyMemCpy(state + delta - j, buf, j);
+}
+
+void Delta_Decode(Byte *state, unsigned delta, Byte *data, SizeT size)
+{
+  Byte buf[DELTA_STATE_SIZE];
+  unsigned j = 0;
+  MyMemCpy(buf, state, delta);
+  {
+    SizeT i;
+    for (i = 0; i < size;)
+    {
+      for (j = 0; j < delta && i < size; i++, j++)
+      {
+        buf[j] = data[i] = (Byte)(buf[j] + data[i]);
+      }
+    }
+  }
+  if (j == delta)
+    j = 0;
+  MyMemCpy(state, buf + j, delta - j);
+  MyMemCpy(state + delta - j, buf, j);
+}
diff -Nru src-old/lib/lib7z/Delta.h src/lib/lib7z/Delta.h
--- src-old/lib/lib7z/Delta.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Delta.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,23 @@
+/* Delta.h -- Delta converter
+2009-04-15 : Igor Pavlov : Public domain */
+
+#ifndef __DELTA_H
+#define __DELTA_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DELTA_STATE_SIZE 256
+
+void Delta_Init(Byte *state);
+void Delta_Encode(Byte *state, unsigned delta, Byte *data, SizeT size);
+void Delta_Decode(Byte *state, unsigned delta, Byte *data, SizeT size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/HuffEnc.c src/lib/lib7z/HuffEnc.c
--- src-old/lib/lib7z/HuffEnc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/HuffEnc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,146 @@
+/* HuffEnc.c -- functions for Huffman encoding
+2009-09-02 : Igor Pavlov : Public domain */
+
+#include "HuffEnc.h"
+#include "Sort.h"
+
+#define kMaxLen 16
+#define NUM_BITS 10
+#define MASK ((1 << NUM_BITS) - 1)
+
+#define NUM_COUNTERS 64
+
+#define HUFFMAN_SPEED_OPT
+
+void Huffman_Generate(const UInt32 *freqs, UInt32 *p, Byte *lens, UInt32 numSymbols, UInt32 maxLen)
+{
+  UInt32 num = 0;
+  /* if (maxLen > 10) maxLen = 10; */
+  {
+    UInt32 i;
+
+    #ifdef HUFFMAN_SPEED_OPT
+
+    UInt32 counters[NUM_COUNTERS];
+    for (i = 0; i < NUM_COUNTERS; i++)
+      counters[i] = 0;
+    for (i = 0; i < numSymbols; i++)
+    {
+      UInt32 freq = freqs[i];
+      counters[(freq < NUM_COUNTERS - 1) ? freq : NUM_COUNTERS - 1]++;
+    }
+
+    for (i = 1; i < NUM_COUNTERS; i++)
+    {
+      UInt32 temp = counters[i];
+      counters[i] = num;
+      num += temp;
+    }
+
+    for (i = 0; i < numSymbols; i++)
+    {
+      UInt32 freq = freqs[i];
+      if (freq == 0)
+        lens[i] = 0;
+      else
+        p[counters[((freq < NUM_COUNTERS - 1) ? freq : NUM_COUNTERS - 1)]++] = i | (freq << NUM_BITS);
+    }
+    counters[0] = 0;
+    HeapSort(p + counters[NUM_COUNTERS - 2], counters[NUM_COUNTERS - 1] - counters[NUM_COUNTERS - 2]);
+
+    #else
+
+    for (i = 0; i < numSymbols; i++)
+    {
+      UInt32 freq = freqs[i];
+      if (freq == 0)
+        lens[i] = 0;
+      else
+        p[num++] = i | (freq << NUM_BITS);
+    }
+    HeapSort(p, num);
+
+    #endif
+  }
+
+  if (num < 2)
+  {
+    unsigned minCode = 0;
+    unsigned maxCode = 1;
+    if (num == 1)
+    {
+      maxCode = (unsigned)p[0] & MASK;
+      if (maxCode == 0)
+        maxCode++;
+    }
+    p[minCode] = 0;
+    p[maxCode] = 1;
+    lens[minCode] = lens[maxCode] = 1;
+    return;
+  }
+
+  {
+    UInt32 b, e, i;
+
+    i = b = e = 0;
+    do
+    {
+      UInt32 n, m, freq;
+      n = (i != num && (b == e || (p[i] >> NUM_BITS) <= (p[b] >> NUM_BITS))) ? i++ : b++;
+      freq = (p[n] & ~MASK);
+      p[n] = (p[n] & MASK) | (e << NUM_BITS);
+      m = (i != num && (b == e || (p[i] >> NUM_BITS) <= (p[b] >> NUM_BITS))) ? i++ : b++;
+      freq += (p[m] & ~MASK);
+      p[m] = (p[m] & MASK) | (e << NUM_BITS);
+      p[e] = (p[e] & MASK) | freq;
+      e++;
+    }
+    while (num - e > 1);
+
+    {
+      UInt32 lenCounters[kMaxLen + 1];
+      for (i = 0; i <= kMaxLen; i++)
+        lenCounters[i] = 0;
+
+      p[--e] &= MASK;
+      lenCounters[1] = 2;
+      while (e > 0)
+      {
+        UInt32 len = (p[p[--e] >> NUM_BITS] >> NUM_BITS) + 1;
+        p[e] = (p[e] & MASK) | (len << NUM_BITS);
+        if (len >= maxLen)
+          for (len = maxLen - 1; lenCounters[len] == 0; len--);
+        lenCounters[len]--;
+        lenCounters[len + 1] += 2;
+      }
+
+      {
+        UInt32 len;
+        i = 0;
+        for (len = maxLen; len != 0; len--)
+        {
+          UInt32 num;
+          for (num = lenCounters[len]; num != 0; num--)
+            lens[p[i++] & MASK] = (Byte)len;
+        }
+      }
+
+      {
+        UInt32 nextCodes[kMaxLen + 1];
+        {
+          UInt32 code = 0;
+          UInt32 len;
+          for (len = 1; len <= kMaxLen; len++)
+            nextCodes[len] = code = (code + lenCounters[len - 1]) << 1;
+        }
+        /* if (code + lenCounters[kMaxLen] - 1 != (1 << kMaxLen) - 1) throw 1; */
+
+        {
+          UInt32 i;
+          for (i = 0; i < numSymbols; i++)
+            p[i] = nextCodes[lens[i]]++;
+        }
+      }
+    }
+  }
+}
diff -Nru src-old/lib/lib7z/HuffEnc.h src/lib/lib7z/HuffEnc.h
--- src-old/lib/lib7z/HuffEnc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/HuffEnc.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,27 @@
+/* HuffEnc.h -- Huffman encoding
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __HUFF_ENC_H
+#define __HUFF_ENC_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+Conditions:
+  num <= 1024 = 2 ^ NUM_BITS
+  Sum(freqs) < 4M = 2 ^ (32 - NUM_BITS)
+  maxLen <= 16 = kMaxLen
+  Num_Items(p) >= HUFFMAN_TEMP_SIZE(num)
+*/
+
+void Huffman_Generate(const UInt32 *freqs, UInt32 *p, Byte *lens, UInt32 num, UInt32 maxLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/LzFind.c src/lib/lib7z/LzFind.c
--- src-old/lib/lib7z/LzFind.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzFind.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,761 @@
+/* LzFind.c -- Match finder for LZ algorithms
+2009-04-22 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "LzFind.h"
+#include "LzHash.h"
+
+#define kEmptyHashValue 0
+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
+#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
+#define kNormalizeMask (~(kNormalizeStepMin - 1))
+#define kMaxHistorySize ((UInt32)3 << 30)
+
+#define kStartMaxLen 3
+
+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  if (!p->directInput)
+  {
+    alloc->Free(alloc, p->bufferBase);
+    p->bufferBase = 0;
+  }
+}
+
+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
+
+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+{
+  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
+  if (p->directInput)
+  {
+    p->blockSize = blockSize;
+    return 1;
+  }
+  if (p->bufferBase == 0 || p->blockSize != blockSize)
+  {
+    LzInWindow_Free(p, alloc);
+    p->blockSize = blockSize;
+    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
+  }
+  return (p->bufferBase != 0);
+}
+
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
+
+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
+
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+{
+  p->posLimit -= subValue;
+  p->pos -= subValue;
+  p->streamPos -= subValue;
+}
+
+static void MatchFinder_ReadBlock(CMatchFinder *p)
+{
+  if (p->streamEndWasReached || p->result != SZ_OK)
+    return;
+  if (p->directInput)
+  {
+    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
+    if (curSize > p->directInputRem)
+      curSize = (UInt32)p->directInputRem;
+    p->directInputRem -= curSize;
+    p->streamPos += curSize;
+    if (p->directInputRem == 0)
+      p->streamEndWasReached = 1;
+    return;
+  }
+  for (;;)
+  {
+    Byte *dest = p->buffer + (p->streamPos - p->pos);
+    size_t size = (p->bufferBase + p->blockSize - dest);
+    if (size == 0)
+      return;
+    p->result = p->stream->Read(p->stream, dest, &size);
+    if (p->result != SZ_OK)
+      return;
+    if (size == 0)
+    {
+      p->streamEndWasReached = 1;
+      return;
+    }
+    p->streamPos += (UInt32)size;
+    if (p->streamPos - p->pos > p->keepSizeAfter)
+      return;
+  }
+}
+
+void MatchFinder_MoveBlock(CMatchFinder *p)
+{
+  memmove(p->bufferBase,
+    p->buffer - p->keepSizeBefore,
+    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
+  p->buffer = p->bufferBase + p->keepSizeBefore;
+}
+
+int MatchFinder_NeedMove(CMatchFinder *p)
+{
+  if (p->directInput)
+    return 0;
+  /* if (p->streamEndWasReached) return 0; */
+  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
+}
+
+void MatchFinder_ReadIfRequired(CMatchFinder *p)
+{
+  if (p->streamEndWasReached)
+    return;
+  if (p->keepSizeAfter >= p->streamPos - p->pos)
+    MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+{
+  if (MatchFinder_NeedMove(p))
+    MatchFinder_MoveBlock(p);
+  MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
+{
+  p->cutValue = 32;
+  p->btMode = 1;
+  p->numHashBytes = 4;
+  p->bigHash = 0;
+}
+
+#define kCrcPoly 0xEDB88320
+
+void MatchFinder_Construct(CMatchFinder *p)
+{
+  UInt32 i;
+  p->bufferBase = 0;
+  p->directInput = 0;
+  p->hash = 0;
+  MatchFinder_SetDefaultSettings(p);
+
+  for (i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j < 8; j++)
+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
+    p->crc[i] = r;
+  }
+}
+
+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->hash);
+  p->hash = 0;
+}
+
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  MatchFinder_FreeThisClassMemory(p, alloc);
+  LzInWindow_Free(p, alloc);
+}
+
+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
+{
+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
+  if (sizeInBytes / sizeof(CLzRef) != num)
+    return 0;
+  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
+}
+
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc)
+{
+  UInt32 sizeReserv;
+  if (historySize > kMaxHistorySize)
+  {
+    MatchFinder_Free(p, alloc);
+    return 0;
+  }
+  sizeReserv = historySize >> 1;
+  if (historySize > ((UInt32)2 << 30))
+    sizeReserv = historySize >> 2;
+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
+
+  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
+  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
+  if (LzInWindow_Create(p, sizeReserv, alloc))
+  {
+    UInt32 newCyclicBufferSize = historySize + 1;
+    UInt32 hs;
+    p->matchMaxLen = matchMaxLen;
+    {
+      p->fixedHashSize = 0;
+      if (p->numHashBytes == 2)
+        hs = (1 << 16) - 1;
+      else
+      {
+        hs = historySize - 1;
+        hs |= (hs >> 1);
+        hs |= (hs >> 2);
+        hs |= (hs >> 4);
+        hs |= (hs >> 8);
+        hs >>= 1;
+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
+        if (hs > (1 << 24))
+        {
+          if (p->numHashBytes == 3)
+            hs = (1 << 24) - 1;
+          else
+            hs >>= 1;
+        }
+      }
+      p->hashMask = hs;
+      hs++;
+      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
+      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
+      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
+      hs += p->fixedHashSize;
+    }
+
+    {
+      UInt32 prevSize = p->hashSizeSum + p->numSons;
+      UInt32 newSize;
+      p->historySize = historySize;
+      p->hashSizeSum = hs;
+      p->cyclicBufferSize = newCyclicBufferSize;
+      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
+      newSize = p->hashSizeSum + p->numSons;
+      if (p->hash != 0 && prevSize == newSize)
+        return 1;
+      MatchFinder_FreeThisClassMemory(p, alloc);
+      p->hash = AllocRefs(newSize, alloc);
+      if (p->hash != 0)
+      {
+        p->son = p->hash + p->hashSizeSum;
+        return 1;
+      }
+    }
+  }
+  MatchFinder_Free(p, alloc);
+  return 0;
+}
+
+static void MatchFinder_SetLimits(CMatchFinder *p)
+{
+  UInt32 limit = kMaxValForNormalize - p->pos;
+  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
+  if (limit2 < limit)
+    limit = limit2;
+  limit2 = p->streamPos - p->pos;
+  if (limit2 <= p->keepSizeAfter)
+  {
+    if (limit2 > 0)
+      limit2 = 1;
+  }
+  else
+    limit2 -= p->keepSizeAfter;
+  if (limit2 < limit)
+    limit = limit2;
+  {
+    UInt32 lenLimit = p->streamPos - p->pos;
+    if (lenLimit > p->matchMaxLen)
+      lenLimit = p->matchMaxLen;
+    p->lenLimit = lenLimit;
+  }
+  p->posLimit = p->pos + limit;
+}
+
+void MatchFinder_Init(CMatchFinder *p)
+{
+  UInt32 i;
+  for (i = 0; i < p->hashSizeSum; i++)
+    p->hash[i] = kEmptyHashValue;
+  p->cyclicBufferPos = 0;
+  p->buffer = p->bufferBase;
+  p->pos = p->streamPos = p->cyclicBufferSize;
+  p->result = SZ_OK;
+  p->streamEndWasReached = 0;
+  MatchFinder_ReadBlock(p);
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
+{
+  return (p->pos - p->historySize - 1) & kNormalizeMask;
+}
+
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+{
+  UInt32 i;
+  for (i = 0; i < numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value <= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+}
+
+static void MatchFinder_Normalize(CMatchFinder *p)
+{
+  UInt32 subValue = MatchFinder_GetSubValue(p);
+  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
+  MatchFinder_ReduceOffsets(p, subValue);
+}
+
+static void MatchFinder_CheckLimits(CMatchFinder *p)
+{
+  if (p->pos == kMaxValForNormalize)
+    MatchFinder_Normalize(p);
+  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
+    MatchFinder_CheckAndMoveAndRead(p);
+  if (p->cyclicBufferPos == p->cyclicBufferSize)
+    p->cyclicBufferPos = 0;
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  son[_cyclicBufferPos] = curMatch;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+      return distances;
+    {
+      const Byte *pb = cur - delta;
+      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
+      {
+        UInt32 len = 0;
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+            return distances;
+        }
+      }
+    }
+  }
+}
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return distances;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit && pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return distances;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        {
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+#define MOVE_POS \
+  ++p->cyclicBufferPos; \
+  p->buffer++; \
+  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
+
+#define MOVE_POS_RET MOVE_POS return offset;
+
+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+
+#define GET_MATCHES_HEADER2(minLen, ret_op) \
+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
+  cur = p->buffer;
+
+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
+
+#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
+
+#define GET_MATCHES_FOOTER(offset, maxLen) \
+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
+  distances + offset, maxLen) - distances); MOVE_POS_RET;
+
+#define SKIP_FOOTER \
+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+
+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(2)
+  HASH2_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 1)
+}
+
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 2)
+}
+
+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, delta2, maxLen, offset;
+  GET_MATCHES_HEADER(3)
+
+  HASH3_CALC;
+
+  delta2 = p->pos - p->hash[hash2Value];
+  curMatch = p->hash[kFix3HashSize + hashValue];
+
+  p->hash[hash2Value] =
+  p->hash[kFix3HashSize + hashValue] = p->pos;
+
+
+  maxLen = 2;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[0] = maxLen;
+    distances[1] = delta2 - 1;
+    offset = 2;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p->pos - p->hash[                hash2Value];
+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+  curMatch = p->hash[kFix4HashSize + hashValue];
+
+  p->hash[                hash2Value] =
+  p->hash[kFix3HashSize + hash3Value] =
+  p->hash[kFix4HashSize + hashValue] = p->pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen < 3)
+    maxLen = 3;
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p->pos - p->hash[                hash2Value];
+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+  curMatch = p->hash[kFix4HashSize + hashValue];
+
+  p->hash[                hash2Value] =
+  p->hash[kFix3HashSize + hash3Value] =
+  p->hash[kFix4HashSize + hashValue] = p->pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      p->son[p->cyclicBufferPos] = curMatch;
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen < 3)
+    maxLen = 3;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances + offset, maxLen) - (distances));
+  MOVE_POS_RET
+}
+
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances, 2) - (distances));
+  MOVE_POS_RET
+}
+
+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(2)
+    HASH2_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value;
+    SKIP_HEADER(3)
+    HASH3_CALC;
+    curMatch = p->hash[kFix3HashSize + hashValue];
+    p->hash[hash2Value] =
+    p->hash[kFix3HashSize + hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p->hash[kFix4HashSize + hashValue];
+    p->hash[                hash2Value] =
+    p->hash[kFix3HashSize + hash3Value] = p->pos;
+    p->hash[kFix4HashSize + hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p->hash[kFix4HashSize + hashValue];
+    p->hash[                hash2Value] =
+    p->hash[kFix3HashSize + hash3Value] =
+    p->hash[kFix4HashSize + hashValue] = p->pos;
+    p->son[p->cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    p->son[p->cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+{
+  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+  if (!p->btMode)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+  }
+  else if (p->numHashBytes == 2)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+  }
+  else if (p->numHashBytes == 3)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+  }
+  else
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+  }
+}
diff -Nru src-old/lib/lib7z/LzFind.h src/lib/lib7z/LzFind.h
--- src-old/lib/lib7z/LzFind.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzFind.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,115 @@
+/* LzFind.h -- Match finder for LZ algorithms
+2009-04-22 : Igor Pavlov : Public domain */
+
+#ifndef __LZ_FIND_H
+#define __LZ_FIND_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef UInt32 CLzRef;
+
+typedef struct _CMatchFinder
+{
+  Byte *buffer;
+  UInt32 pos;
+  UInt32 posLimit;
+  UInt32 streamPos;
+  UInt32 lenLimit;
+
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
+
+  UInt32 matchMaxLen;
+  CLzRef *hash;
+  CLzRef *son;
+  UInt32 hashMask;
+  UInt32 cutValue;
+
+  Byte *bufferBase;
+  ISeqInStream *stream;
+  int streamEndWasReached;
+
+  UInt32 blockSize;
+  UInt32 keepSizeBefore;
+  UInt32 keepSizeAfter;
+
+  UInt32 numHashBytes;
+  int directInput;
+  size_t directInputRem;
+  int btMode;
+  int bigHash;
+  UInt32 historySize;
+  UInt32 fixedHashSize;
+  UInt32 hashSizeSum;
+  UInt32 numSons;
+  SRes result;
+  UInt32 crc[256];
+} CMatchFinder;
+
+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
+
+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
+
+int MatchFinder_NeedMove(CMatchFinder *p);
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+void MatchFinder_MoveBlock(CMatchFinder *p);
+void MatchFinder_ReadIfRequired(CMatchFinder *p);
+
+void MatchFinder_Construct(CMatchFinder *p);
+
+/* Conditions:
+     historySize <= 3 GB
+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
+*/
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc);
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *distances, UInt32 maxLen);
+
+/*
+Conditions:
+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
+*/
+
+typedef void (*Mf_Init_Func)(void *object);
+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
+typedef void (*Mf_Skip_Func)(void *object, UInt32);
+
+typedef struct _IMatchFinder
+{
+  Mf_Init_Func Init;
+  Mf_GetIndexByte_Func GetIndexByte;
+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
+  Mf_GetMatches_Func GetMatches;
+  Mf_Skip_Func Skip;
+} IMatchFinder;
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+
+void MatchFinder_Init(CMatchFinder *p);
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/LzFindMt.c src/lib/lib7z/LzFindMt.c
--- src-old/lib/lib7z/LzFindMt.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzFindMt.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,793 @@
+/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
+2009-09-20 : Igor Pavlov : Public domain */
+
+#include "LzHash.h"
+
+#include "LzFindMt.h"
+
+void MtSync_Construct(CMtSync *p)
+{
+  p->wasCreated = False;
+  p->csWasInitialized = False;
+  p->csWasEntered = False;
+  Thread_Construct(&p->thread);
+  Event_Construct(&p->canStart);
+  Event_Construct(&p->wasStarted);
+  Event_Construct(&p->wasStopped);
+  Semaphore_Construct(&p->freeSemaphore);
+  Semaphore_Construct(&p->filledSemaphore);
+}
+
+void MtSync_GetNextBlock(CMtSync *p)
+{
+  if (p->needStart)
+  {
+    p->numProcessedBlocks = 1;
+    p->needStart = False;
+    p->stopWriting = False;
+    p->exit = False;
+    Event_Reset(&p->wasStarted);
+    Event_Reset(&p->wasStopped);
+
+    Event_Set(&p->canStart);
+    Event_Wait(&p->wasStarted);
+  }
+  else
+  {
+    CriticalSection_Leave(&p->cs);
+    p->csWasEntered = False;
+    p->numProcessedBlocks++;
+    Semaphore_Release1(&p->freeSemaphore);
+  }
+  Semaphore_Wait(&p->filledSemaphore);
+  CriticalSection_Enter(&p->cs);
+  p->csWasEntered = True;
+}
+
+/* MtSync_StopWriting must be called if Writing was started */
+
+void MtSync_StopWriting(CMtSync *p)
+{
+  UInt32 myNumBlocks = p->numProcessedBlocks;
+  if (!Thread_WasCreated(&p->thread) || p->needStart)
+    return;
+  p->stopWriting = True;
+  if (p->csWasEntered)
+  {
+    CriticalSection_Leave(&p->cs);
+    p->csWasEntered = False;
+  }
+  Semaphore_Release1(&p->freeSemaphore);
+
+  Event_Wait(&p->wasStopped);
+
+  while (myNumBlocks++ != p->numProcessedBlocks)
+  {
+    Semaphore_Wait(&p->filledSemaphore);
+    Semaphore_Release1(&p->freeSemaphore);
+  }
+  p->needStart = True;
+}
+
+void MtSync_Destruct(CMtSync *p)
+{
+  if (Thread_WasCreated(&p->thread))
+  {
+    MtSync_StopWriting(p);
+    p->exit = True;
+    if (p->needStart)
+      Event_Set(&p->canStart);
+    Thread_Wait(&p->thread);
+    Thread_Close(&p->thread);
+  }
+  if (p->csWasInitialized)
+  {
+    CriticalSection_Delete(&p->cs);
+    p->csWasInitialized = False;
+  }
+
+  Event_Close(&p->canStart);
+  Event_Close(&p->wasStarted);
+  Event_Close(&p->wasStopped);
+  Semaphore_Close(&p->freeSemaphore);
+  Semaphore_Close(&p->filledSemaphore);
+
+  p->wasCreated = False;
+}
+
+#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
+
+static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  if (p->wasCreated)
+    return SZ_OK;
+
+  RINOK_THREAD(CriticalSection_Init(&p->cs));
+  p->csWasInitialized = True;
+
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->canStart));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->wasStarted));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->wasStopped));
+
+  RINOK_THREAD(Semaphore_Create(&p->freeSemaphore, numBlocks, numBlocks));
+  RINOK_THREAD(Semaphore_Create(&p->filledSemaphore, 0, numBlocks));
+
+  p->needStart = True;
+
+  RINOK_THREAD(Thread_Create(&p->thread, startAddress, obj));
+  p->wasCreated = True;
+  return SZ_OK;
+}
+
+static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
+  if (res != SZ_OK)
+    MtSync_Destruct(p);
+  return res;
+}
+
+void MtSync_Init(CMtSync *p) { p->needStart = True; }
+
+#define kMtMaxValForNormalize 0xFFFFFFFF
+
+#define DEF_GetHeads2(name, v, action) \
+static void GetHeads ## name(const Byte *p, UInt32 pos, \
+UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
+{ action; for (; numHeads != 0; numHeads--) { \
+const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
+
+#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
+
+DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] << 8)), hashMask = hashMask; crc = crc; )
+DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8)) & hashMask)
+DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5)) & hashMask)
+DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ ((UInt32)p[3] << 16)) & hashMask)
+/* DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5) ^ (crc[p[4]] << 3)) & hashMask) */
+
+void HashThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &mt->hashSync;
+  for (;;)
+  {
+    UInt32 numProcessedBlocks = 0;
+    Event_Wait(&p->canStart);
+    Event_Set(&p->wasStarted);
+    for (;;)
+    {
+      if (p->exit)
+        return;
+      if (p->stopWriting)
+      {
+        p->numProcessedBlocks = numProcessedBlocks;
+        Event_Set(&p->wasStopped);
+        break;
+      }
+
+      {
+        CMatchFinder *mf = mt->MatchFinder;
+        if (MatchFinder_NeedMove(mf))
+        {
+          CriticalSection_Enter(&mt->btSync.cs);
+          CriticalSection_Enter(&mt->hashSync.cs);
+          {
+            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
+            const Byte *afterPtr;
+            MatchFinder_MoveBlock(mf);
+            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
+            mt->pointerToCurPos -= beforePtr - afterPtr;
+            mt->buffer -= beforePtr - afterPtr;
+          }
+          CriticalSection_Leave(&mt->btSync.cs);
+          CriticalSection_Leave(&mt->hashSync.cs);
+          continue;
+        }
+
+        Semaphore_Wait(&p->freeSemaphore);
+
+        MatchFinder_ReadIfRequired(mf);
+        if (mf->pos > (kMtMaxValForNormalize - kMtHashBlockSize))
+        {
+          UInt32 subValue = (mf->pos - mf->historySize - 1);
+          MatchFinder_ReduceOffsets(mf, subValue);
+          MatchFinder_Normalize3(subValue, mf->hash + mf->fixedHashSize, mf->hashMask + 1);
+        }
+        {
+          UInt32 *heads = mt->hashBuf + ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize;
+          UInt32 num = mf->streamPos - mf->pos;
+          heads[0] = 2;
+          heads[1] = num;
+          if (num >= mf->numHashBytes)
+          {
+            num = num - mf->numHashBytes + 1;
+            if (num > kMtHashBlockSize - 2)
+              num = kMtHashBlockSize - 2;
+            mt->GetHeadsFunc(mf->buffer, mf->pos, mf->hash + mf->fixedHashSize, mf->hashMask, heads + 2, num, mf->crc);
+            heads[0] += num;
+          }
+          mf->pos += num;
+          mf->buffer += num;
+        }
+      }
+
+      Semaphore_Release1(&p->filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
+{
+  MtSync_GetNextBlock(&p->hashSync);
+  p->hashBufPosLimit = p->hashBufPos = ((p->hashSync.numProcessedBlocks - 1) & kMtHashNumBlocksMask) * kMtHashBlockSize;
+  p->hashBufPosLimit += p->hashBuf[p->hashBufPos++];
+  p->hashNumAvail = p->hashBuf[p->hashBufPos++];
+}
+
+#define kEmptyHashValue 0
+
+/* #define MFMT_GM_INLINE */
+
+#ifdef MFMT_GM_INLINE
+
+#define NO_INLINE MY_FAST_CALL
+
+Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
+{
+  do
+  {
+  UInt32 *distances = _distances + 1;
+  UInt32 curMatch = pos - *hash++;
+
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  UInt32 cutValue = _cutValue;
+  UInt32 maxLen = _maxLen;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      break;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit && pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            break;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+  pos++;
+  _cyclicBufferPos++;
+  cur++;
+  {
+    UInt32 num = (UInt32)(distances - _distances);
+    *_distances = num - 1;
+    _distances += num;
+    limit -= num;
+  }
+  }
+  while (limit > 0 && --size != 0);
+  *posRes = pos;
+  return limit;
+}
+
+#endif
+
+void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  UInt32 numProcessed = 0;
+  UInt32 curPos = 2;
+  UInt32 limit = kMtBtBlockSize - (p->matchMaxLen * 2);
+  distances[1] = p->hashNumAvail;
+  while (curPos < limit)
+  {
+    if (p->hashBufPos == p->hashBufPosLimit)
+    {
+      MatchFinderMt_GetNextBlock_Hash(p);
+      distances[1] = numProcessed + p->hashNumAvail;
+      if (p->hashNumAvail >= p->numHashBytes)
+        continue;
+      for (; p->hashNumAvail != 0; p->hashNumAvail--)
+        distances[curPos++] = 0;
+      break;
+    }
+    {
+      UInt32 size = p->hashBufPosLimit - p->hashBufPos;
+      UInt32 lenLimit = p->matchMaxLen;
+      UInt32 pos = p->pos;
+      UInt32 cyclicBufferPos = p->cyclicBufferPos;
+      if (lenLimit >= p->hashNumAvail)
+        lenLimit = p->hashNumAvail;
+      {
+        UInt32 size2 = p->hashNumAvail - lenLimit + 1;
+        if (size2 < size)
+          size = size2;
+        size2 = p->cyclicBufferSize - cyclicBufferPos;
+        if (size2 < size)
+          size = size2;
+      }
+      #ifndef MFMT_GM_INLINE
+      while (curPos < limit && size-- != 0)
+      {
+        UInt32 *startDistances = distances + curPos;
+        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p->hashBuf[p->hashBufPos++],
+          pos, p->buffer, p->son, cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
+          startDistances + 1, p->numHashBytes - 1) - startDistances);
+        *startDistances = num - 1;
+        curPos += num;
+        cyclicBufferPos++;
+        pos++;
+        p->buffer++;
+      }
+      #else
+      {
+        UInt32 posRes;
+        curPos = limit - GetMatchesSpecN(lenLimit, pos, p->buffer, p->son, cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
+          distances + curPos, p->numHashBytes - 1, p->hashBuf + p->hashBufPos, (Int32)(limit - curPos) , size, &posRes);
+        p->hashBufPos += posRes - pos;
+        cyclicBufferPos += posRes - pos;
+        p->buffer += posRes - pos;
+        pos = posRes;
+      }
+      #endif
+
+      numProcessed += pos - p->pos;
+      p->hashNumAvail -= pos - p->pos;
+      p->pos = pos;
+      if (cyclicBufferPos == p->cyclicBufferSize)
+        cyclicBufferPos = 0;
+      p->cyclicBufferPos = cyclicBufferPos;
+    }
+  }
+  distances[0] = curPos;
+}
+
+void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
+{
+  CMtSync *sync = &p->hashSync;
+  if (!sync->needStart)
+  {
+    CriticalSection_Enter(&sync->cs);
+    sync->csWasEntered = True;
+  }
+
+  BtGetMatches(p, p->btBuf + (globalBlockIndex & kMtBtNumBlocksMask) * kMtBtBlockSize);
+
+  if (p->pos > kMtMaxValForNormalize - kMtBtBlockSize)
+  {
+    UInt32 subValue = p->pos - p->cyclicBufferSize;
+    MatchFinder_Normalize3(subValue, p->son, p->cyclicBufferSize * 2);
+    p->pos -= subValue;
+  }
+
+  if (!sync->needStart)
+  {
+    CriticalSection_Leave(&sync->cs);
+    sync->csWasEntered = False;
+  }
+}
+
+void BtThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &mt->btSync;
+  for (;;)
+  {
+    UInt32 blockIndex = 0;
+    Event_Wait(&p->canStart);
+    Event_Set(&p->wasStarted);
+    for (;;)
+    {
+      if (p->exit)
+        return;
+      if (p->stopWriting)
+      {
+        p->numProcessedBlocks = blockIndex;
+        MtSync_StopWriting(&mt->hashSync);
+        Event_Set(&p->wasStopped);
+        break;
+      }
+      Semaphore_Wait(&p->freeSemaphore);
+      BtFillBlock(mt, blockIndex++);
+      Semaphore_Release1(&p->filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_Construct(CMatchFinderMt *p)
+{
+  p->hashBuf = 0;
+  MtSync_Construct(&p->hashSync);
+  MtSync_Construct(&p->btSync);
+}
+
+void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->hashBuf);
+  p->hashBuf = 0;
+}
+
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  MtSync_Destruct(&p->hashSync);
+  MtSync_Destruct(&p->btSync);
+  MatchFinderMt_FreeMem(p, alloc);
+}
+
+#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
+#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
+
+static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
+static unsigned MY_STD_CALL BtThreadFunc2(void *p)
+{
+  Byte allocaDummy[0x180];
+  int i = 0;
+  for (i = 0; i < 16; i++)
+    allocaDummy[i] = (Byte)i;
+  BtThreadFunc((CMatchFinderMt *)p);
+  return 0;
+}
+
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
+{
+  CMatchFinder *mf = p->MatchFinder;
+  p->historySize = historySize;
+  if (kMtBtBlockSize <= matchMaxLen * 4)
+    return SZ_ERROR_PARAM;
+  if (p->hashBuf == 0)
+  {
+    p->hashBuf = (UInt32 *)alloc->Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
+    if (p->hashBuf == 0)
+      return SZ_ERROR_MEM;
+    p->btBuf = p->hashBuf + kHashBufferSize;
+  }
+  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
+  keepAddBufferAfter += kMtHashBlockSize;
+  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
+    return SZ_ERROR_MEM;
+
+  RINOK(MtSync_Create(&p->hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
+  RINOK(MtSync_Create(&p->btSync, BtThreadFunc2, p, kMtBtNumBlocks));
+  return SZ_OK;
+}
+
+/* Call it after ReleaseStream / SetStream */
+void MatchFinderMt_Init(CMatchFinderMt *p)
+{
+  CMatchFinder *mf = p->MatchFinder;
+  p->btBufPos = p->btBufPosLimit = 0;
+  p->hashBufPos = p->hashBufPosLimit = 0;
+  MatchFinder_Init(mf);
+  p->pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
+  p->btNumAvailBytes = 0;
+  p->lzPos = p->historySize + 1;
+
+  p->hash = mf->hash;
+  p->fixedHashSize = mf->fixedHashSize;
+  p->crc = mf->crc;
+
+  p->son = mf->son;
+  p->matchMaxLen = mf->matchMaxLen;
+  p->numHashBytes = mf->numHashBytes;
+  p->pos = mf->pos;
+  p->buffer = mf->buffer;
+  p->cyclicBufferPos = mf->cyclicBufferPos;
+  p->cyclicBufferSize = mf->cyclicBufferSize;
+  p->cutValue = mf->cutValue;
+}
+
+/* ReleaseStream is required to finish multithreading */
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
+{
+  MtSync_StopWriting(&p->btSync);
+  /* p->MatchFinder->ReleaseStream(); */
+}
+
+void MatchFinderMt_Normalize(CMatchFinderMt *p)
+{
+  MatchFinder_Normalize3(p->lzPos - p->historySize - 1, p->hash, p->fixedHashSize);
+  p->lzPos = p->historySize + 1;
+}
+
+void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
+{
+  UInt32 blockIndex;
+  MtSync_GetNextBlock(&p->btSync);
+  blockIndex = ((p->btSync.numProcessedBlocks - 1) & kMtBtNumBlocksMask);
+  p->btBufPosLimit = p->btBufPos = blockIndex * kMtBtBlockSize;
+  p->btBufPosLimit += p->btBuf[p->btBufPos++];
+  p->btNumAvailBytes = p->btBuf[p->btBufPos++];
+  if (p->lzPos >= kMtMaxValForNormalize - kMtBtBlockSize)
+    MatchFinderMt_Normalize(p);
+}
+
+const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
+{
+  return p->pointerToCurPos;
+}
+
+#define GET_NEXT_BLOCK_IF_REQUIRED if (p->btBufPos == p->btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
+
+UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
+{
+  GET_NEXT_BLOCK_IF_REQUIRED;
+  return p->btNumAvailBytes;
+}
+
+Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
+{
+  return p->pointerToCurPos[index];
+}
+
+UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, curMatch2;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH2_CALC
+
+  curMatch2 = hash[hash2Value];
+  hash[hash2Value] = lzPos;
+
+  if (curMatch2 >= matchMinPos)
+    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+    {
+      *distances++ = 2;
+      *distances++ = lzPos - curMatch2 - 1;
+    }
+  return distances;
+}
+
+UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH3_CALC
+
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+    lzPos;
+
+  if (curMatch2 >= matchMinPos && cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] = 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 >= matchMinPos && cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    *distances++ = 3;
+    *distances++ = lzPos - curMatch3 - 1;
+  }
+  return distances;
+}
+
+/*
+UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH4_CALC
+
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  curMatch4 = hash[kFix4HashSize + hash4Value];
+
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+  hash[kFix4HashSize + hash4Value] =
+    lzPos;
+
+  if (curMatch2 >= matchMinPos && cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 >= matchMinPos && cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch3 - 1;
+    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
+    {
+      distances[0] = 4;
+      return distances + 2;
+    }
+    distances[0] = 3;
+    distances += 2;
+  }
+
+  if (curMatch4 >= matchMinPos)
+    if (
+      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &&
+      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
+      )
+    {
+      *distances++ = 4;
+      *distances++ = lzPos - curMatch4 - 1;
+    }
+  return distances;
+}
+*/
+
+#define INCREASE_LZ_POS p->lzPos++; p->pointerToCurPos++;
+
+UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p->btBuf + p->btBufPos;
+  UInt32 len = *btBuf++;
+  p->btBufPos += 1 + len;
+  p->btNumAvailBytes--;
+  {
+    UInt32 i;
+    for (i = 0; i < len; i += 2)
+    {
+      *distances++ = *btBuf++;
+      *distances++ = *btBuf++;
+    }
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p->btBuf + p->btBufPos;
+  UInt32 len = *btBuf++;
+  p->btBufPos += 1 + len;
+
+  if (len == 0)
+  {
+    if (p->btNumAvailBytes-- >= 4)
+      len = (UInt32)(p->MixMatchesFunc(p, p->lzPos - p->historySize, distances) - (distances));
+  }
+  else
+  {
+    /* Condition: there are matches in btBuf with length < p->numHashBytes */
+    UInt32 *distances2;
+    p->btNumAvailBytes--;
+    distances2 = p->MixMatchesFunc(p, p->lzPos - btBuf[1], distances);
+    do
+    {
+      *distances2++ = *btBuf++;
+      *distances2++ = *btBuf++;
+    }
+    while ((len -= 2) != 0);
+    len  = (UInt32)(distances2 - (distances));
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+#define SKIP_HEADER2_MT  do { GET_NEXT_BLOCK_IF_REQUIRED
+#define SKIP_HEADER_MT(n) SKIP_HEADER2_MT if (p->btNumAvailBytes-- >= (n)) { const Byte *cur = p->pointerToCurPos; UInt32 *hash = p->hash;
+#define SKIP_FOOTER_MT } INCREASE_LZ_POS p->btBufPos += p->btBuf[p->btBufPos] + 1; } while (--num != 0);
+
+void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER2_MT { p->btNumAvailBytes--;
+  SKIP_FOOTER_MT
+}
+
+void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER_MT(2)
+      UInt32 hash2Value;
+      MT_HASH2_CALC
+      hash[hash2Value] = p->lzPos;
+  SKIP_FOOTER_MT
+}
+
+void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER_MT(3)
+      UInt32 hash2Value, hash3Value;
+      MT_HASH3_CALC
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p->lzPos;
+  SKIP_FOOTER_MT
+}
+
+/*
+void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER_MT(4)
+      UInt32 hash2Value, hash3Value, hash4Value;
+      MT_HASH4_CALC
+      hash[kFix4HashSize + hash4Value] =
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p->lzPos;
+  SKIP_FOOTER_MT
+}
+*/
+
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
+{
+  vTable->Init = (Mf_Init_Func)MatchFinderMt_Init;
+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
+  vTable->GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
+  switch(p->MatchFinder->numHashBytes)
+  {
+    case 2:
+      p->GetHeadsFunc = GetHeads2;
+      p->MixMatchesFunc = (Mf_Mix_Matches)0;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
+      vTable->GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
+      break;
+    case 3:
+      p->GetHeadsFunc = GetHeads3;
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
+      break;
+    default:
+    /* case 4: */
+      p->GetHeadsFunc = p->MatchFinder->bigHash ? GetHeads4b : GetHeads4;
+      /* p->GetHeadsFunc = GetHeads4; */
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
+      break;
+    /*
+    default:
+      p->GetHeadsFunc = GetHeads5;
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
+      break;
+    */
+  }
+}
diff -Nru src-old/lib/lib7z/LzFindMt.h src/lib/lib7z/LzFindMt.h
--- src-old/lib/lib7z/LzFindMt.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzFindMt.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,105 @@
+/* LzFindMt.h -- multithreaded Match finder for LZ algorithms
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __LZ_FIND_MT_H
+#define __LZ_FIND_MT_H
+
+#include "LzFind.h"
+#include "Threads.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define kMtHashBlockSize (1 << 13)
+#define kMtHashNumBlocks (1 << 3)
+#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
+
+#define kMtBtBlockSize (1 << 14)
+#define kMtBtNumBlocks (1 << 6)
+#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
+
+typedef struct _CMtSync
+{
+  Bool wasCreated;
+  Bool needStart;
+  Bool exit;
+  Bool stopWriting;
+
+  CThread thread;
+  CAutoResetEvent canStart;
+  CAutoResetEvent wasStarted;
+  CAutoResetEvent wasStopped;
+  CSemaphore freeSemaphore;
+  CSemaphore filledSemaphore;
+  Bool csWasInitialized;
+  Bool csWasEntered;
+  CCriticalSection cs;
+  UInt32 numProcessedBlocks;
+} CMtSync;
+
+typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
+
+/* kMtCacheLineDummy must be >= size_of_CPU_cache_line */
+#define kMtCacheLineDummy 128
+
+typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
+  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
+
+typedef struct _CMatchFinderMt
+{
+  /* LZ */
+  const Byte *pointerToCurPos;
+  UInt32 *btBuf;
+  UInt32 btBufPos;
+  UInt32 btBufPosLimit;
+  UInt32 lzPos;
+  UInt32 btNumAvailBytes;
+
+  UInt32 *hash;
+  UInt32 fixedHashSize;
+  UInt32 historySize;
+  const UInt32 *crc;
+
+  Mf_Mix_Matches MixMatchesFunc;
+
+  /* LZ + BT */
+  CMtSync btSync;
+  Byte btDummy[kMtCacheLineDummy];
+
+  /* BT */
+  UInt32 *hashBuf;
+  UInt32 hashBufPos;
+  UInt32 hashBufPosLimit;
+  UInt32 hashNumAvail;
+
+  CLzRef *son;
+  UInt32 matchMaxLen;
+  UInt32 numHashBytes;
+  UInt32 pos;
+  Byte *buffer;
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
+  UInt32 cutValue;
+
+  /* BT + Hash */
+  CMtSync hashSync;
+  /* Byte hashDummy[kMtCacheLineDummy]; */
+
+  /* Hash */
+  Mf_GetHeads GetHeadsFunc;
+  CMatchFinder *MatchFinder;
+} CMatchFinderMt;
+
+void MatchFinderMt_Construct(CMatchFinderMt *p);
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/LzHash.h src/lib/lib7z/LzHash.h
--- src-old/lib/lib7z/LzHash.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzHash.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,54 @@
+/* LzHash.h -- HASH functions for LZ algorithms
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __LZ_HASH_H
+#define __LZ_HASH_H
+
+#define kHash2Size (1 << 10)
+#define kHash3Size (1 << 16)
+#define kHash4Size (1 << 20)
+
+#define kFix3HashSize (kHash2Size)
+#define kFix4HashSize (kHash2Size + kHash3Size)
+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
+
+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
+
+#define HASH3_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
+
+#define HASH4_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
+
+#define HASH5_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
+  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
+  hash4Value &= (kHash4Size - 1); }
+
+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
+
+
+#define MT_HASH2_CALC \
+  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
+
+#define MT_HASH3_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
+
+#define MT_HASH4_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
+
+#endif
diff -Nru src-old/lib/lib7z/Lzma2Dec.c src/lib/lib7z/Lzma2Dec.c
--- src-old/lib/lib7z/Lzma2Dec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma2Dec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,350 @@
+/* Lzma2Dec.c -- LZMA2 Decoder
+2010-12-15 : Igor Pavlov : Public domain */
+
+/* #define SHOW_DEBUG_INFO */
+
+#ifdef SHOW_DEBUG_INFO
+#include <stdio.h>
+#endif
+
+#include <string.h>
+
+#include "Lzma2Dec.h"
+
+/*
+00000000  -  EOS
+00000001 U U  -  Uncompressed Reset Dic
+00000010 U U  -  Uncompressed No Reset
+100uuuuu U U P P  -  LZMA no reset
+101uuuuu U U P P  -  LZMA reset state
+110uuuuu U U P P S  -  LZMA reset state + new prop
+111uuuuu U U P P S  -  LZMA reset state + new prop + reset dic
+
+  u, U - Unpack Size
+  P - Pack Size
+  S - Props
+*/
+
+#define LZMA2_CONTROL_LZMA (1 << 7)
+#define LZMA2_CONTROL_COPY_NO_RESET 2
+#define LZMA2_CONTROL_COPY_RESET_DIC 1
+#define LZMA2_CONTROL_EOF 0
+
+#define LZMA2_IS_UNCOMPRESSED_STATE(p) (((p)->control & LZMA2_CONTROL_LZMA) == 0)
+
+#define LZMA2_GET_LZMA_MODE(p) (((p)->control >> 5) & 3)
+#define LZMA2_IS_THERE_PROP(mode) ((mode) >= 2)
+
+#define LZMA2_LCLP_MAX 4
+#define LZMA2_DIC_SIZE_FROM_PROP(p) (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11))
+
+#ifdef SHOW_DEBUG_INFO
+#define PRF(x) x
+#else
+#define PRF(x)
+#endif
+
+typedef enum
+{
+  LZMA2_STATE_CONTROL,
+  LZMA2_STATE_UNPACK0,
+  LZMA2_STATE_UNPACK1,
+  LZMA2_STATE_PACK0,
+  LZMA2_STATE_PACK1,
+  LZMA2_STATE_PROP,
+  LZMA2_STATE_DATA,
+  LZMA2_STATE_DATA_CONT,
+  LZMA2_STATE_FINISHED,
+  LZMA2_STATE_ERROR
+} ELzma2State;
+
+static SRes Lzma2Dec_GetOldProps(Byte prop, Byte *props)
+{
+  UInt32 dicSize;
+  if (prop > 40)
+    return SZ_ERROR_UNSUPPORTED;
+  dicSize = (prop == 40) ? 0xFFFFFFFF : LZMA2_DIC_SIZE_FROM_PROP(prop);
+  props[0] = (Byte)LZMA2_LCLP_MAX;
+  props[1] = (Byte)(dicSize);
+  props[2] = (Byte)(dicSize >> 8);
+  props[3] = (Byte)(dicSize >> 16);
+  props[4] = (Byte)(dicSize >> 24);
+  return SZ_OK;
+}
+
+SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
+{
+  Byte props[LZMA_PROPS_SIZE];
+  RINOK(Lzma2Dec_GetOldProps(prop, props));
+  return LzmaDec_AllocateProbs(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
+}
+
+SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
+{
+  Byte props[LZMA_PROPS_SIZE];
+  RINOK(Lzma2Dec_GetOldProps(prop, props));
+  return LzmaDec_Allocate(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
+}
+
+void Lzma2Dec_Init(CLzma2Dec *p)
+{
+  p->state = LZMA2_STATE_CONTROL;
+  p->needInitDic = True;
+  p->needInitState = True;
+  p->needInitProp = True;
+  LzmaDec_Init(&p->decoder);
+}
+
+static ELzma2State Lzma2Dec_UpdateState(CLzma2Dec *p, Byte b)
+{
+  switch(p->state)
+  {
+    case LZMA2_STATE_CONTROL:
+      p->control = b;
+      PRF(printf("\n %4X ", p->decoder.dicPos));
+      PRF(printf(" %2X", b));
+      if (p->control == 0)
+        return LZMA2_STATE_FINISHED;
+      if (LZMA2_IS_UNCOMPRESSED_STATE(p))
+      {
+        if ((p->control & 0x7F) > 2)
+          return LZMA2_STATE_ERROR;
+        p->unpackSize = 0;
+      }
+      else
+        p->unpackSize = (UInt32)(p->control & 0x1F) << 16;
+      return LZMA2_STATE_UNPACK0;
+
+    case LZMA2_STATE_UNPACK0:
+      p->unpackSize |= (UInt32)b << 8;
+      return LZMA2_STATE_UNPACK1;
+
+    case LZMA2_STATE_UNPACK1:
+      p->unpackSize |= (UInt32)b;
+      p->unpackSize++;
+      PRF(printf(" %8d", p->unpackSize));
+      return (LZMA2_IS_UNCOMPRESSED_STATE(p)) ? LZMA2_STATE_DATA : LZMA2_STATE_PACK0;
+
+    case LZMA2_STATE_PACK0:
+      p->packSize = (UInt32)b << 8;
+      return LZMA2_STATE_PACK1;
+
+    case LZMA2_STATE_PACK1:
+      p->packSize |= (UInt32)b;
+      p->packSize++;
+      PRF(printf(" %8d", p->packSize));
+      return LZMA2_IS_THERE_PROP(LZMA2_GET_LZMA_MODE(p)) ? LZMA2_STATE_PROP:
+        (p->needInitProp ? LZMA2_STATE_ERROR : LZMA2_STATE_DATA);
+
+    case LZMA2_STATE_PROP:
+    {
+      int lc, lp;
+      if (b >= (9 * 5 * 5))
+        return LZMA2_STATE_ERROR;
+      lc = b % 9;
+      b /= 9;
+      p->decoder.prop.pb = b / 5;
+      lp = b % 5;
+      if (lc + lp > LZMA2_LCLP_MAX)
+        return LZMA2_STATE_ERROR;
+      p->decoder.prop.lc = lc;
+      p->decoder.prop.lp = lp;
+      p->needInitProp = False;
+      return LZMA2_STATE_DATA;
+    }
+  }
+  return LZMA2_STATE_ERROR;
+}
+
+static void LzmaDec_UpdateWithUncompressed(CLzmaDec *p, const Byte *src, SizeT size)
+{
+  memcpy(p->dic + p->dicPos, src, size);
+  p->dicPos += size;
+  if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= size)
+    p->checkDicSize = p->prop.dicSize;
+  p->processedPos += (UInt32)size;
+}
+
+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState);
+
+SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT inSize = *srcLen;
+  *srcLen = 0;
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+
+  while (p->state != LZMA2_STATE_FINISHED)
+  {
+    SizeT dicPos = p->decoder.dicPos;
+    if (p->state == LZMA2_STATE_ERROR)
+      return SZ_ERROR_DATA;
+    if (dicPos == dicLimit && finishMode == LZMA_FINISH_ANY)
+    {
+      *status = LZMA_STATUS_NOT_FINISHED;
+      return SZ_OK;
+    }
+    if (p->state != LZMA2_STATE_DATA && p->state != LZMA2_STATE_DATA_CONT)
+    {
+      if (*srcLen == inSize)
+      {
+        *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+        return SZ_OK;
+      }
+      (*srcLen)++;
+      p->state = Lzma2Dec_UpdateState(p, *src++);
+      continue;
+    }
+    {
+      SizeT destSizeCur = dicLimit - dicPos;
+      SizeT srcSizeCur = inSize - *srcLen;
+      ELzmaFinishMode curFinishMode = LZMA_FINISH_ANY;
+
+      if (p->unpackSize <= destSizeCur)
+      {
+        destSizeCur = (SizeT)p->unpackSize;
+        curFinishMode = LZMA_FINISH_END;
+      }
+
+      if (LZMA2_IS_UNCOMPRESSED_STATE(p))
+      {
+        if (*srcLen == inSize)
+        {
+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+          return SZ_OK;
+        }
+
+        if (p->state == LZMA2_STATE_DATA)
+        {
+          Bool initDic = (p->control == LZMA2_CONTROL_COPY_RESET_DIC);
+          if (initDic)
+            p->needInitProp = p->needInitState = True;
+          else if (p->needInitDic)
+            return SZ_ERROR_DATA;
+          p->needInitDic = False;
+          LzmaDec_InitDicAndState(&p->decoder, initDic, False);
+        }
+
+        if (srcSizeCur > destSizeCur)
+          srcSizeCur = destSizeCur;
+
+        if (srcSizeCur == 0)
+          return SZ_ERROR_DATA;
+
+        LzmaDec_UpdateWithUncompressed(&p->decoder, src, srcSizeCur);
+
+        src += srcSizeCur;
+        *srcLen += srcSizeCur;
+        p->unpackSize -= (UInt32)srcSizeCur;
+        p->state = (p->unpackSize == 0) ? LZMA2_STATE_CONTROL : LZMA2_STATE_DATA_CONT;
+      }
+      else
+      {
+        SizeT outSizeProcessed;
+        SRes res;
+
+        if (p->state == LZMA2_STATE_DATA)
+        {
+          int mode = LZMA2_GET_LZMA_MODE(p);
+          Bool initDic = (mode == 3);
+          Bool initState = (mode > 0);
+          if ((!initDic && p->needInitDic) || (!initState && p->needInitState))
+            return SZ_ERROR_DATA;
+
+          LzmaDec_InitDicAndState(&p->decoder, initDic, initState);
+          p->needInitDic = False;
+          p->needInitState = False;
+          p->state = LZMA2_STATE_DATA_CONT;
+        }
+        if (srcSizeCur > p->packSize)
+          srcSizeCur = (SizeT)p->packSize;
+
+        res = LzmaDec_DecodeToDic(&p->decoder, dicPos + destSizeCur, src, &srcSizeCur, curFinishMode, status);
+
+        src += srcSizeCur;
+        *srcLen += srcSizeCur;
+        p->packSize -= (UInt32)srcSizeCur;
+
+        outSizeProcessed = p->decoder.dicPos - dicPos;
+        p->unpackSize -= (UInt32)outSizeProcessed;
+
+        RINOK(res);
+        if (*status == LZMA_STATUS_NEEDS_MORE_INPUT)
+          return res;
+
+        if (srcSizeCur == 0 && outSizeProcessed == 0)
+        {
+          if (*status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK ||
+              p->unpackSize != 0 || p->packSize != 0)
+            return SZ_ERROR_DATA;
+          p->state = LZMA2_STATE_CONTROL;
+        }
+        if (*status == LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)
+          *status = LZMA_STATUS_NOT_FINISHED;
+      }
+    }
+  }
+  *status = LZMA_STATUS_FINISHED_WITH_MARK;
+  return SZ_OK;
+}
+
+SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT outSize = *destLen, inSize = *srcLen;
+  *srcLen = *destLen = 0;
+  for (;;)
+  {
+    SizeT srcSizeCur = inSize, outSizeCur, dicPos;
+    ELzmaFinishMode curFinishMode;
+    SRes res;
+    if (p->decoder.dicPos == p->decoder.dicBufSize)
+      p->decoder.dicPos = 0;
+    dicPos = p->decoder.dicPos;
+    if (outSize > p->decoder.dicBufSize - dicPos)
+    {
+      outSizeCur = p->decoder.dicBufSize;
+      curFinishMode = LZMA_FINISH_ANY;
+    }
+    else
+    {
+      outSizeCur = dicPos + outSize;
+      curFinishMode = finishMode;
+    }
+
+    res = Lzma2Dec_DecodeToDic(p, outSizeCur, src, &srcSizeCur, curFinishMode, status);
+    src += srcSizeCur;
+    inSize -= srcSizeCur;
+    *srcLen += srcSizeCur;
+    outSizeCur = p->decoder.dicPos - dicPos;
+    memcpy(dest, p->decoder.dic + dicPos, outSizeCur);
+    dest += outSizeCur;
+    outSize -= outSizeCur;
+    *destLen += outSizeCur;
+    if (res != 0)
+      return res;
+    if (outSizeCur == 0 || outSize == 0)
+      return SZ_OK;
+  }
+}
+
+SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc)
+{
+  CLzma2Dec p;
+  SRes res;
+  SizeT outSize = *destLen, inSize = *srcLen;
+  *destLen = *srcLen = 0;
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+  Lzma2Dec_Construct(&p);
+  RINOK(Lzma2Dec_AllocateProbs(&p, prop, alloc));
+  p.decoder.dic = dest;
+  p.decoder.dicBufSize = outSize;
+  Lzma2Dec_Init(&p);
+  *srcLen = inSize;
+  res = Lzma2Dec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
+  *destLen = p.decoder.dicPos;
+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
+    res = SZ_ERROR_INPUT_EOF;
+  Lzma2Dec_FreeProbs(&p, alloc);
+  return res;
+}
diff -Nru src-old/lib/lib7z/Lzma2Dec.h src/lib/lib7z/Lzma2Dec.h
--- src-old/lib/lib7z/Lzma2Dec.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma2Dec.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,84 @@
+/* Lzma2Dec.h -- LZMA2 Decoder
+2009-05-03 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA2_DEC_H
+#define __LZMA2_DEC_H
+
+#include "LzmaDec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ---------- State Interface ---------- */
+
+typedef struct
+{
+  CLzmaDec decoder;
+  UInt32 packSize;
+  UInt32 unpackSize;
+  int state;
+  Byte control;
+  Bool needInitDic;
+  Bool needInitState;
+  Bool needInitProp;
+} CLzma2Dec;
+
+#define Lzma2Dec_Construct(p) LzmaDec_Construct(&(p)->decoder)
+#define Lzma2Dec_FreeProbs(p, alloc) LzmaDec_FreeProbs(&(p)->decoder, alloc);
+#define Lzma2Dec_Free(p, alloc) LzmaDec_Free(&(p)->decoder, alloc);
+
+SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
+SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
+void Lzma2Dec_Init(CLzma2Dec *p);
+
+
+/*
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen or dicLimit).
+  LZMA_FINISH_ANY - use smallest number of input bytes
+  LZMA_FINISH_END - read EndOfStream marker after decoding
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_NEEDS_MORE_INPUT
+  SZ_ERROR_DATA - Data error
+*/
+
+SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- One Call Interface ---------- */
+
+/*
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - use smallest number of input bytes
+  LZMA_FINISH_END - read EndOfStream marker after decoding
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Lzma2Enc.c src/lib/lib7z/Lzma2Enc.c
--- src-old/lib/lib7z/Lzma2Enc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma2Enc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,477 @@
+/* Lzma2Enc.c -- LZMA2 Encoder
+2010-09-24 : Igor Pavlov : Public domain */
+
+/* #include <stdio.h> */
+#include <string.h>
+
+/* #define _7ZIP_ST */
+
+#include "Lzma2Enc.h"
+
+#ifndef _7ZIP_ST
+#include "MtCoder.h"
+#else
+#define NUM_MT_CODER_THREADS_MAX 1
+#endif
+
+#define LZMA2_CONTROL_LZMA (1 << 7)
+#define LZMA2_CONTROL_COPY_NO_RESET 2
+#define LZMA2_CONTROL_COPY_RESET_DIC 1
+#define LZMA2_CONTROL_EOF 0
+
+#define LZMA2_LCLP_MAX 4
+
+#define LZMA2_DIC_SIZE_FROM_PROP(p) (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11))
+
+#define LZMA2_PACK_SIZE_MAX (1 << 16)
+#define LZMA2_COPY_CHUNK_SIZE LZMA2_PACK_SIZE_MAX
+#define LZMA2_UNPACK_SIZE_MAX (1 << 21)
+#define LZMA2_KEEP_WINDOW_SIZE LZMA2_UNPACK_SIZE_MAX
+
+#define LZMA2_CHUNK_SIZE_COMPRESSED_MAX ((1 << 16) + 16)
+
+
+#define PRF(x) /* x */
+
+/* ---------- CLzma2EncInt ---------- */
+
+typedef struct
+{
+  CLzmaEncHandle enc;
+  UInt64 srcPos;
+  Byte props;
+  Bool needInitState;
+  Bool needInitProp;
+} CLzma2EncInt;
+
+static SRes Lzma2EncInt_Init(CLzma2EncInt *p, const CLzma2EncProps *props)
+{
+  Byte propsEncoded[LZMA_PROPS_SIZE];
+  SizeT propsSize = LZMA_PROPS_SIZE;
+  RINOK(LzmaEnc_SetProps(p->enc, &props->lzmaProps));
+  RINOK(LzmaEnc_WriteProperties(p->enc, propsEncoded, &propsSize));
+  p->srcPos = 0;
+  p->props = propsEncoded[0];
+  p->needInitState = True;
+  p->needInitProp = True;
+  return SZ_OK;
+}
+
+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp, ISeqInStream *inStream, UInt32 keepWindowSize,
+    ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize);
+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp);
+void LzmaEnc_Finish(CLzmaEncHandle pp);
+void LzmaEnc_SaveState(CLzmaEncHandle pp);
+void LzmaEnc_RestoreState(CLzmaEncHandle pp);
+
+
+static SRes Lzma2EncInt_EncodeSubblock(CLzma2EncInt *p, Byte *outBuf,
+    size_t *packSizeRes, ISeqOutStream *outStream)
+{
+  size_t packSizeLimit = *packSizeRes;
+  size_t packSize = packSizeLimit;
+  UInt32 unpackSize = LZMA2_UNPACK_SIZE_MAX;
+  unsigned lzHeaderSize = 5 + (p->needInitProp ? 1 : 0);
+  Bool useCopyBlock;
+  SRes res;
+
+  *packSizeRes = 0;
+  if (packSize < lzHeaderSize)
+    return SZ_ERROR_OUTPUT_EOF;
+  packSize -= lzHeaderSize;
+
+  LzmaEnc_SaveState(p->enc);
+  res = LzmaEnc_CodeOneMemBlock(p->enc, p->needInitState,
+      outBuf + lzHeaderSize, &packSize, LZMA2_PACK_SIZE_MAX, &unpackSize);
+
+  PRF(printf("\npackSize = %7d unpackSize = %7d  ", packSize, unpackSize));
+
+  if (unpackSize == 0)
+    return res;
+
+  if (res == SZ_OK)
+    useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));
+  else
+  {
+    if (res != SZ_ERROR_OUTPUT_EOF)
+      return res;
+    res = SZ_OK;
+    useCopyBlock = True;
+  }
+
+  if (useCopyBlock)
+  {
+    size_t destPos = 0;
+    PRF(printf("################# COPY           "));
+    while (unpackSize > 0)
+    {
+      UInt32 u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;
+      if (packSizeLimit - destPos < u + 3)
+        return SZ_ERROR_OUTPUT_EOF;
+      outBuf[destPos++] = (Byte)(p->srcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);
+      outBuf[destPos++] = (Byte)((u - 1) >> 8);
+      outBuf[destPos++] = (Byte)(u - 1);
+      memcpy(outBuf + destPos, LzmaEnc_GetCurBuf(p->enc) - unpackSize, u);
+      unpackSize -= u;
+      destPos += u;
+      p->srcPos += u;
+      if (outStream)
+      {
+        *packSizeRes += destPos;
+        if (outStream->Write(outStream, outBuf, destPos) != destPos)
+          return SZ_ERROR_WRITE;
+        destPos = 0;
+      }
+      else
+        *packSizeRes = destPos;
+      /* needInitState = True; */
+    }
+    LzmaEnc_RestoreState(p->enc);
+    return SZ_OK;
+  }
+  {
+    size_t destPos = 0;
+    UInt32 u = unpackSize - 1;
+    UInt32 pm = (UInt32)(packSize - 1);
+    unsigned mode = (p->srcPos == 0) ? 3 : (p->needInitState ? (p->needInitProp ? 2 : 1) : 0);
+
+    PRF(printf("               "));
+
+    outBuf[destPos++] = (Byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));
+    outBuf[destPos++] = (Byte)(u >> 8);
+    outBuf[destPos++] = (Byte)u;
+    outBuf[destPos++] = (Byte)(pm >> 8);
+    outBuf[destPos++] = (Byte)pm;
+
+    if (p->needInitProp)
+      outBuf[destPos++] = p->props;
+
+    p->needInitProp = False;
+    p->needInitState = False;
+    destPos += packSize;
+    p->srcPos += unpackSize;
+
+    if (outStream)
+      if (outStream->Write(outStream, outBuf, destPos) != destPos)
+        return SZ_ERROR_WRITE;
+    *packSizeRes = destPos;
+    return SZ_OK;
+  }
+}
+
+/* ---------- Lzma2 Props ---------- */
+
+void Lzma2EncProps_Init(CLzma2EncProps *p)
+{
+  LzmaEncProps_Init(&p->lzmaProps);
+  p->numTotalThreads = -1;
+  p->numBlockThreads = -1;
+  p->blockSize = 0;
+}
+
+void Lzma2EncProps_Normalize(CLzma2EncProps *p)
+{
+  int t1, t1n, t2, t3;
+  {
+    CLzmaEncProps lzmaProps = p->lzmaProps;
+    LzmaEncProps_Normalize(&lzmaProps);
+    t1n = lzmaProps.numThreads;
+  }
+
+  t1 = p->lzmaProps.numThreads;
+  t2 = p->numBlockThreads;
+  t3 = p->numTotalThreads;
+
+  if (t2 > NUM_MT_CODER_THREADS_MAX)
+    t2 = NUM_MT_CODER_THREADS_MAX;
+
+  if (t3 <= 0)
+  {
+    if (t2 <= 0)
+      t2 = 1;
+    t3 = t1n * t2;
+  }
+  else if (t2 <= 0)
+  {
+    t2 = t3 / t1n;
+    if (t2 == 0)
+    {
+      t1 = 1;
+      t2 = t3;
+    }
+    if (t2 > NUM_MT_CODER_THREADS_MAX)
+      t2 = NUM_MT_CODER_THREADS_MAX;
+  }
+  else if (t1 <= 0)
+  {
+    t1 = t3 / t2;
+    if (t1 == 0)
+      t1 = 1;
+  }
+  else
+    t3 = t1n * t2;
+
+  p->lzmaProps.numThreads = t1;
+  p->numBlockThreads = t2;
+  p->numTotalThreads = t3;
+  LzmaEncProps_Normalize(&p->lzmaProps);
+
+  if (p->blockSize == 0)
+  {
+    UInt32 dictSize = p->lzmaProps.dictSize;
+    UInt64 blockSize = (UInt64)dictSize << 2;
+    const UInt32 kMinSize = (UInt32)1 << 20;
+    const UInt32 kMaxSize = (UInt32)1 << 28;
+    if (blockSize < kMinSize) blockSize = kMinSize;
+    if (blockSize > kMaxSize) blockSize = kMaxSize;
+    if (blockSize < dictSize) blockSize = dictSize;
+    p->blockSize = (size_t)blockSize;
+  }
+}
+
+static SRes Progress(ICompressProgress *p, UInt64 inSize, UInt64 outSize)
+{
+  return (p && p->Progress(p, inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;
+}
+
+/* ---------- Lzma2 ---------- */
+
+typedef struct
+{
+  Byte propEncoded;
+  CLzma2EncProps props;
+
+  Byte *outBuf;
+
+  ISzAlloc *alloc;
+  ISzAlloc *allocBig;
+
+  CLzma2EncInt coders[NUM_MT_CODER_THREADS_MAX];
+
+  #ifndef _7ZIP_ST
+  CMtCoder mtCoder;
+  #endif
+
+} CLzma2Enc;
+
+
+/* ---------- Lzma2EncThread ---------- */
+
+static SRes Lzma2Enc_EncodeMt1(CLzma2EncInt *p, CLzma2Enc *mainEncoder,
+  ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress)
+{
+  UInt64 packTotal = 0;
+  SRes res = SZ_OK;
+
+  if (mainEncoder->outBuf == 0)
+  {
+    mainEncoder->outBuf = (Byte *)IAlloc_Alloc(mainEncoder->alloc, LZMA2_CHUNK_SIZE_COMPRESSED_MAX);
+    if (mainEncoder->outBuf == 0)
+      return SZ_ERROR_MEM;
+  }
+  RINOK(Lzma2EncInt_Init(p, &mainEncoder->props));
+  RINOK(LzmaEnc_PrepareForLzma2(p->enc, inStream, LZMA2_KEEP_WINDOW_SIZE,
+      mainEncoder->alloc, mainEncoder->allocBig));
+  for (;;)
+  {
+    size_t packSize = LZMA2_CHUNK_SIZE_COMPRESSED_MAX;
+    res = Lzma2EncInt_EncodeSubblock(p, mainEncoder->outBuf, &packSize, outStream);
+    if (res != SZ_OK)
+      break;
+    packTotal += packSize;
+    res = Progress(progress, p->srcPos, packTotal);
+    if (res != SZ_OK)
+      break;
+    if (packSize == 0)
+      break;
+  }
+  LzmaEnc_Finish(p->enc);
+  if (res == SZ_OK)
+  {
+    Byte b = 0;
+    if (outStream->Write(outStream, &b, 1) != 1)
+      return SZ_ERROR_WRITE;
+  }
+  return res;
+}
+
+#ifndef _7ZIP_ST
+
+typedef struct
+{
+  IMtCoderCallback funcTable;
+  CLzma2Enc *lzma2Enc;
+} CMtCallbackImp;
+
+static SRes MtCallbackImp_Code(void *pp, unsigned index, Byte *dest, size_t *destSize,
+      const Byte *src, size_t srcSize, int finished)
+{
+  CMtCallbackImp *imp = (CMtCallbackImp *)pp;
+  CLzma2Enc *mainEncoder = imp->lzma2Enc;
+  CLzma2EncInt *p = &mainEncoder->coders[index];
+
+  SRes res = SZ_OK;
+  {
+    size_t destLim = *destSize;
+    *destSize = 0;
+
+    if (srcSize != 0)
+    {
+      RINOK(Lzma2EncInt_Init(p, &mainEncoder->props));
+
+      RINOK(LzmaEnc_MemPrepare(p->enc, src, srcSize, LZMA2_KEEP_WINDOW_SIZE,
+          mainEncoder->alloc, mainEncoder->allocBig));
+
+      while (p->srcPos < srcSize)
+      {
+        size_t packSize = destLim - *destSize;
+        res = Lzma2EncInt_EncodeSubblock(p, dest + *destSize, &packSize, NULL);
+        if (res != SZ_OK)
+          break;
+        *destSize += packSize;
+
+        if (packSize == 0)
+        {
+          res = SZ_ERROR_FAIL;
+          break;
+        }
+
+        if (MtProgress_Set(&mainEncoder->mtCoder.mtProgress, index, p->srcPos, *destSize) != SZ_OK)
+        {
+          res = SZ_ERROR_PROGRESS;
+          break;
+        }
+      }
+      LzmaEnc_Finish(p->enc);
+      if (res != SZ_OK)
+        return res;
+    }
+    if (finished)
+    {
+      if (*destSize == destLim)
+        return SZ_ERROR_OUTPUT_EOF;
+      dest[(*destSize)++] = 0;
+    }
+  }
+  return res;
+}
+
+#endif
+
+/* ---------- Lzma2Enc ---------- */
+
+CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzma2Enc *p = (CLzma2Enc *)alloc->Alloc(alloc, sizeof(CLzma2Enc));
+  if (p == 0)
+    return NULL;
+  Lzma2EncProps_Init(&p->props);
+  Lzma2EncProps_Normalize(&p->props);
+  p->outBuf = 0;
+  p->alloc = alloc;
+  p->allocBig = allocBig;
+  {
+    unsigned i;
+    for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
+      p->coders[i].enc = 0;
+  }
+  #ifndef _7ZIP_ST
+  MtCoder_Construct(&p->mtCoder);
+  #endif
+
+  return p;
+}
+
+void Lzma2Enc_Destroy(CLzma2EncHandle pp)
+{
+  CLzma2Enc *p = (CLzma2Enc *)pp;
+  unsigned i;
+  for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
+  {
+    CLzma2EncInt *t = &p->coders[i];
+    if (t->enc)
+    {
+      LzmaEnc_Destroy(t->enc, p->alloc, p->allocBig);
+      t->enc = 0;
+    }
+  }
+
+  #ifndef _7ZIP_ST
+  MtCoder_Destruct(&p->mtCoder);
+  #endif
+
+  IAlloc_Free(p->alloc, p->outBuf);
+  IAlloc_Free(p->alloc, pp);
+}
+
+SRes Lzma2Enc_SetProps(CLzma2EncHandle pp, const CLzma2EncProps *props)
+{
+  CLzma2Enc *p = (CLzma2Enc *)pp;
+  CLzmaEncProps lzmaProps = props->lzmaProps;
+  LzmaEncProps_Normalize(&lzmaProps);
+  if (lzmaProps.lc + lzmaProps.lp > LZMA2_LCLP_MAX)
+    return SZ_ERROR_PARAM;
+  p->props = *props;
+  Lzma2EncProps_Normalize(&p->props);
+  return SZ_OK;
+}
+
+Byte Lzma2Enc_WriteProperties(CLzma2EncHandle pp)
+{
+  CLzma2Enc *p = (CLzma2Enc *)pp;
+  unsigned i;
+  UInt32 dicSize = LzmaEncProps_GetDictSize(&p->props.lzmaProps);
+  for (i = 0; i < 40; i++)
+    if (dicSize <= LZMA2_DIC_SIZE_FROM_PROP(i))
+      break;
+  return (Byte)i;
+}
+
+SRes Lzma2Enc_Encode(CLzma2EncHandle pp,
+    ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress)
+{
+  CLzma2Enc *p = (CLzma2Enc *)pp;
+  int i;
+
+  for (i = 0; i < p->props.numBlockThreads; i++)
+  {
+    CLzma2EncInt *t = &p->coders[i];
+    if (t->enc == NULL)
+    {
+      t->enc = LzmaEnc_Create(p->alloc);
+      if (t->enc == NULL)
+        return SZ_ERROR_MEM;
+    }
+  }
+
+  #ifndef _7ZIP_ST
+  if (p->props.numBlockThreads <= 1)
+  #endif
+    return Lzma2Enc_EncodeMt1(&p->coders[0], p, outStream, inStream, progress);
+
+  #ifndef _7ZIP_ST
+
+  {
+    CMtCallbackImp mtCallback;
+
+    mtCallback.funcTable.Code = MtCallbackImp_Code;
+    mtCallback.lzma2Enc = p;
+
+    p->mtCoder.progress = progress;
+    p->mtCoder.inStream = inStream;
+    p->mtCoder.outStream = outStream;
+    p->mtCoder.alloc = p->alloc;
+    p->mtCoder.mtCallback = &mtCallback.funcTable;
+
+    p->mtCoder.blockSize = p->props.blockSize;
+    p->mtCoder.destBlockSize = p->props.blockSize + (p->props.blockSize >> 10) + 16;
+    p->mtCoder.numThreads = p->props.numBlockThreads;
+
+    return MtCoder_Code(&p->mtCoder);
+  }
+  #endif
+}
diff -Nru src-old/lib/lib7z/Lzma2Enc.h src/lib/lib7z/Lzma2Enc.h
--- src-old/lib/lib7z/Lzma2Enc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma2Enc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,66 @@
+/* Lzma2Enc.h -- LZMA2 Encoder
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA2_ENC_H
+#define __LZMA2_ENC_H
+
+#include "LzmaEnc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+  CLzmaEncProps lzmaProps;
+  size_t blockSize;
+  int numBlockThreads;
+  int numTotalThreads;
+} CLzma2EncProps;
+
+void Lzma2EncProps_Init(CLzma2EncProps *p);
+void Lzma2EncProps_Normalize(CLzma2EncProps *p);
+
+/* ---------- CLzmaEnc2Handle Interface ---------- */
+
+/* Lzma2Enc_* functions can return the following exit codes:
+Returns:
+  SZ_OK           - OK
+  SZ_ERROR_MEM    - Memory allocation error
+  SZ_ERROR_PARAM  - Incorrect paramater in props
+  SZ_ERROR_WRITE  - Write callback error
+  SZ_ERROR_PROGRESS - some break from progress callback
+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
+*/
+
+typedef void * CLzma2EncHandle;
+
+CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc, ISzAlloc *allocBig);
+void Lzma2Enc_Destroy(CLzma2EncHandle p);
+SRes Lzma2Enc_SetProps(CLzma2EncHandle p, const CLzma2EncProps *props);
+Byte Lzma2Enc_WriteProperties(CLzma2EncHandle p);
+SRes Lzma2Enc_Encode(CLzma2EncHandle p,
+    ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress);
+
+/* ---------- One Call Interface ---------- */
+
+/* Lzma2Encode
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+/*
+SRes Lzma2Encode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Lzma86.h src/lib/lib7z/Lzma86.h
--- src-old/lib/lib7z/Lzma86.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma86.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,111 @@
+/* Lzma86.h -- LZMA + x86 (BCJ) Filter
+2009-08-14 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA86_H
+#define __LZMA86_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+#define LZMA86_SIZE_OFFSET (1 + 5)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+/*
+It's an example for LZMA + x86 Filter use.
+You can use .lzma86 extension, if you write that stream to file.
+.lzma86 header adds one additional byte to standard .lzma header.
+.lzma86 header (14 bytes):
+  Offset Size  Description
+    0     1    = 0 - no filter, pure LZMA
+               = 1 - x86 filter + LZMA
+    1     1    lc, lp and pb in encoded form
+    2     4    dictSize (little endian)
+    6     8    uncompressed size (little endian)
+
+
+Lzma86_Encode
+-------------
+level - compression level: 0 <= level <= 9, the default value for "level" is 5.
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 << 27) bytes for 32-bit version
+          1 GB = (1 << 30) bytes for 64-bit version
+     The default value is 16 MB = (1 << 24) bytes, for level = 5.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 << N) or (3 << N) sizes.
+     For better compression ratio dictSize must be >= inSize.
+
+filterMode:
+    SZ_FILTER_NO   - no Filter
+    SZ_FILTER_YES  - x86 Filter
+    SZ_FILTER_AUTO - it tries both alternatives to select best.
+              Encoder will use 2 or 3 passes:
+              2 passes when FILTER_NO provides better compression.
+              3 passes when FILTER_YES provides better compression.
+
+Lzma86Encode allocates Data with MyAlloc functions.
+RAM Requirements for compressing:
+  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
+      filterMode     FilterBlockSize
+     SZ_FILTER_NO         0
+     SZ_FILTER_YES      inSize
+     SZ_FILTER_AUTO     inSize
+
+
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+enum ESzFilterMode
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode);
+
+
+/*
+Lzma86_GetUnpackSize:
+  In:
+    src      - input data
+    srcLen   - input data size
+  Out:
+    unpackSize - size of uncompressed stream
+  Return code:
+    SZ_OK               - OK
+    SZ_ERROR_INPUT_EOF  - Error in headers
+*/
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
+
+/*
+Lzma86_Decode:
+  In:
+    dest     - output data
+    destLen  - output data size
+    src      - input data
+    srcLen   - input data size
+  Out:
+    destLen  - processed output size
+    srcLen   - processed input size
+  Return code:
+    SZ_OK           - OK
+    SZ_ERROR_DATA  - Data error
+    SZ_ERROR_MEM   - Memory allocation error
+    SZ_ERROR_UNSUPPORTED - unsupported file
+    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
+*/
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Lzma86Dec.c src/lib/lib7z/Lzma86Dec.c
--- src-old/lib/lib7z/Lzma86Dec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma86Dec.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,56 @@
+/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
+2009-08-14 : Igor Pavlov : Public domain */
+
+#include "Lzma86.h"
+
+#include "Alloc.h"
+#include "Bra.h"
+#include "LzmaDec.h"
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
+{
+  unsigned i;
+  if (srcLen < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+  *unpackSize = 0;
+  for (i = 0; i < sizeof(UInt64); i++)
+    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) << (8 * i);
+  return SZ_OK;
+}
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
+{
+  ISzAlloc g_Alloc = { SzAlloc, SzFree };
+  SRes res;
+  int useFilter;
+  SizeT inSizePure;
+  ELzmaStatus status;
+
+  if (*srcLen < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  useFilter = src[0];
+
+  if (useFilter > 1)
+  {
+    *destLen = 0;
+    return SZ_ERROR_UNSUPPORTED;
+  }
+
+  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
+  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &inSizePure,
+      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &status, &g_Alloc);
+  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
+  if (res != SZ_OK)
+    return res;
+  if (useFilter == 1)
+  {
+    UInt32 x86State;
+    x86_Convert_Init(x86State);
+    x86_Convert(dest, *destLen, 0, &x86State, 0);
+  }
+  return SZ_OK;
+}
diff -Nru src-old/lib/lib7z/Lzma86Enc.c src/lib/lib7z/Lzma86Enc.c
--- src-old/lib/lib7z/Lzma86Enc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Lzma86Enc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,108 @@
+/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
+2009-08-14 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "Lzma86.h"
+
+#include "Alloc.h"
+#include "Bra.h"
+#include "LzmaEnc.h"
+
+#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+
+int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode)
+{
+  ISzAlloc g_Alloc = { SzAlloc, SzFree };
+  size_t outSize2 = *destLen;
+  Byte *filteredStream;
+  Bool useFilter;
+  int mainResult = SZ_ERROR_OUTPUT_EOF;
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&props);
+  props.level = level;
+  props.dictSize = dictSize;
+
+  *destLen = 0;
+  if (outSize2 < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  {
+    int i;
+    UInt64 t = srcLen;
+    for (i = 0; i < 8; i++, t >>= 8)
+      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
+  }
+
+  filteredStream = 0;
+  useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (srcLen != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(srcLen);
+      if (filteredStream == 0)
+        return SZ_ERROR_MEM;
+      memcpy(filteredStream, src, srcLen);
+    }
+    {
+      UInt32 x86State;
+      x86_Convert_Init(x86State);
+      x86_Convert(filteredStream, srcLen, 0, &x86State, 1);
+    }
+  }
+
+  {
+    size_t minSize = 0;
+    Bool bestIsFiltered = False;
+
+    /* passes for SZ_FILTER_AUTO:
+        0 - BCJ + LZMA
+        1 - LZMA
+        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
+    */
+    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+
+    int i;
+    for (i = 0; i < numPasses; i++)
+    {
+      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
+      size_t outPropsSize = 5;
+      SRes curRes;
+      Bool curModeIsFiltered = (numPasses > 1 && i == numPasses - 1);
+      if (curModeIsFiltered && !bestIsFiltered)
+        break;
+      if (useFilter && i == 0)
+        curModeIsFiltered = True;
+
+      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &outSizeProcessed,
+          curModeIsFiltered ? filteredStream : src, srcLen,
+          &props, dest + 1, &outPropsSize, 0,
+          NULL, &g_Alloc, &g_Alloc);
+
+      if (curRes != SZ_ERROR_OUTPUT_EOF)
+      {
+        if (curRes != SZ_OK)
+        {
+          mainResult = curRes;
+          break;
+        }
+        if (outSizeProcessed <= minSize || mainResult != SZ_OK)
+        {
+          minSize = outSizeProcessed;
+          bestIsFiltered = curModeIsFiltered;
+          mainResult = SZ_OK;
+        }
+      }
+    }
+    dest[0] = (bestIsFiltered ? 1 : 0);
+    *destLen = LZMA86_HEADER_SIZE + minSize;
+  }
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+}
diff -Nru src-old/lib/lib7z/LzmaDec.c src/lib/lib7z/LzmaDec.c
--- src-old/lib/lib7z/LzmaDec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaDec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,1014 @@
+/* LzmaDec.c -- LZMA Decoder
+2010-12-15 : Igor Pavlov : Public domain */
+
+#include "LzmaDec.h"
+
+#include <string.h>
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_INIT_SIZE 5
+
+#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
+
+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
+  { UPDATE_0(p); i = (i + i); A0; } else \
+  { UPDATE_1(p); i = (i + i) + 1; A1; }
+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
+
+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
+#define TREE_DECODE(probs, limit, i) \
+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
+
+/* #define _LZMA_SIZE_OPT */
+
+#ifdef _LZMA_SIZE_OPT
+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
+#else
+#define TREE_6_DECODE(probs, i) \
+  { i = 1; \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  i -= 0x40; }
+#endif
+
+#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
+
+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0_CHECK range = bound;
+#define UPDATE_1_CHECK range -= bound; code -= bound;
+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
+#define TREE_DECODE_CHECK(probs, limit, i) \
+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+#define LZMA_DIC_MIN (1 << 12)
+
+/* First LZMA-symbol is always decoded.
+And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
+Out:
+  Result:
+    SZ_OK - OK
+    SZ_ERROR_DATA - Error
+  p->remainLen:
+    < kMatchSpecLenStart : normal remain
+    = kMatchSpecLenStart : finished
+    = kMatchSpecLenStart + 1 : Flush marker
+    = kMatchSpecLenStart + 2 : State Init Marker
+*/
+
+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  CLzmaProb *probs = p->probs;
+
+  unsigned state = p->state;
+  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
+  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
+  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
+  unsigned lc = p->prop.lc;
+
+  Byte *dic = p->dic;
+  SizeT dicBufSize = p->dicBufSize;
+  SizeT dicPos = p->dicPos;
+
+  UInt32 processedPos = p->processedPos;
+  UInt32 checkDicSize = p->checkDicSize;
+  unsigned len = 0;
+
+  const Byte *buf = p->buf;
+  UInt32 range = p->range;
+  UInt32 code = p->code;
+
+  do
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = processedPos & pbMask;
+
+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
+    IF_BIT_0(prob)
+    {
+      unsigned symbol;
+      UPDATE_0(prob);
+      prob = probs + Literal;
+      if (checkDicSize != 0 || processedPos != 0)
+        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
+
+      if (state < kNumLitStates)
+      {
+        state -= (state < 4) ? state : 3;
+        symbol = 1;
+        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+        unsigned offs = 0x100;
+        state -= (state < 10) ? 3 : 6;
+        symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
+        }
+        while (symbol < 0x100);
+      }
+      dic[dicPos++] = (Byte)symbol;
+      processedPos++;
+      continue;
+    }
+    else
+    {
+      UPDATE_1(prob);
+      prob = probs + IsRep + state;
+      IF_BIT_0(prob)
+      {
+        UPDATE_0(prob);
+        state += kNumStates;
+        prob = probs + LenCoder;
+      }
+      else
+      {
+        UPDATE_1(prob);
+        if (checkDicSize == 0 && processedPos == 0)
+          return SZ_ERROR_DATA;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0(prob)
+        {
+          UPDATE_0(prob);
+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+            dicPos++;
+            processedPos++;
+            state = state < kNumLitStates ? 9 : 11;
+            continue;
+          }
+          UPDATE_1(prob);
+        }
+        else
+        {
+          UInt32 distance;
+          UPDATE_1(prob);
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            distance = rep1;
+          }
+          else
+          {
+            UPDATE_1(prob);
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0(prob)
+            {
+              UPDATE_0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UPDATE_1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0(probLen)
+        {
+          UPDATE_0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          limit = (1 << kLenNumLowBits);
+        }
+        else
+        {
+          UPDATE_1(probLen);
+          probLen = prob + LenChoice2;
+          IF_BIT_0(probLen)
+          {
+            UPDATE_0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = (1 << kLenNumMidBits);
+          }
+          else
+          {
+            UPDATE_1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = (1 << kLenNumHighBits);
+          }
+        }
+        TREE_DECODE(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state >= kNumStates)
+      {
+        UInt32 distance;
+        prob = probs + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
+        TREE_6_DECODE(prob, distance);
+        if (distance >= kStartPosModelIndex)
+        {
+          unsigned posSlot = (unsigned)distance;
+          int numDirectBits = (int)(((distance >> 1) - 1));
+          distance = (2 | (distance & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            distance <<= numDirectBits;
+            prob = probs + SpecPos + distance - posSlot - 1;
+            {
+              UInt32 mask = 1;
+              unsigned i = 1;
+              do
+              {
+                GET_BIT2(prob + i, i, ; , distance |= mask);
+                mask <<= 1;
+              }
+              while (--numDirectBits != 0);
+            }
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE
+              range >>= 1;
+
+              {
+                UInt32 t;
+                code -= range;
+                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
+                distance = (distance << 1) + (t + 1);
+                code += range & t;
+              }
+              /*
+              distance <<= 1;
+              if (code >= range)
+              {
+                code -= range;
+                distance |= 1;
+              }
+              */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            distance <<= kNumAlignBits;
+            {
+              unsigned i = 1;
+              GET_BIT2(prob + i, i, ; , distance |= 1);
+              GET_BIT2(prob + i, i, ; , distance |= 2);
+              GET_BIT2(prob + i, i, ; , distance |= 4);
+              GET_BIT2(prob + i, i, ; , distance |= 8);
+            }
+            if (distance == (UInt32)0xFFFFFFFF)
+            {
+              len += kMatchSpecLenStart;
+              state -= kNumStates;
+              break;
+            }
+          }
+        }
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        rep0 = distance + 1;
+        if (checkDicSize == 0)
+        {
+          if (distance >= processedPos)
+            return SZ_ERROR_DATA;
+        }
+        else if (distance >= checkDicSize)
+          return SZ_ERROR_DATA;
+        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
+      }
+
+      len += kMatchMinLen;
+
+      if (limit == dicPos)
+        return SZ_ERROR_DATA;
+      {
+        SizeT rem = limit - dicPos;
+        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
+        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
+
+        processedPos += curLen;
+
+        len -= curLen;
+        if (pos + curLen <= dicBufSize)
+        {
+          Byte *dest = dic + dicPos;
+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
+          const Byte *lim = dest + curLen;
+          dicPos += curLen;
+          do
+            *(dest) = (Byte)*(dest + src);
+          while (++dest != lim);
+        }
+        else
+        {
+          do
+          {
+            dic[dicPos++] = dic[pos];
+            if (++pos == dicBufSize)
+              pos = 0;
+          }
+          while (--curLen != 0);
+        }
+      }
+    }
+  }
+  while (dicPos < limit && buf < bufLimit);
+  NORMALIZE;
+  p->buf = buf;
+  p->range = range;
+  p->code = code;
+  p->remainLen = len;
+  p->dicPos = dicPos;
+  p->processedPos = processedPos;
+  p->reps[0] = rep0;
+  p->reps[1] = rep1;
+  p->reps[2] = rep2;
+  p->reps[3] = rep3;
+  p->state = state;
+
+  return SZ_OK;
+}
+
+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
+{
+  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
+  {
+    Byte *dic = p->dic;
+    SizeT dicPos = p->dicPos;
+    SizeT dicBufSize = p->dicBufSize;
+    unsigned len = p->remainLen;
+    UInt32 rep0 = p->reps[0];
+    if (limit - dicPos < len)
+      len = (unsigned)(limit - dicPos);
+
+    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
+      p->checkDicSize = p->prop.dicSize;
+
+    p->processedPos += len;
+    p->remainLen -= len;
+    while (len != 0)
+    {
+      len--;
+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+      dicPos++;
+    }
+    p->dicPos = dicPos;
+  }
+}
+
+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  do
+  {
+    SizeT limit2 = limit;
+    if (p->checkDicSize == 0)
+    {
+      UInt32 rem = p->prop.dicSize - p->processedPos;
+      if (limit - p->dicPos > rem)
+        limit2 = p->dicPos + rem;
+    }
+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
+    if (p->processedPos >= p->prop.dicSize)
+      p->checkDicSize = p->prop.dicSize;
+    LzmaDec_WriteRem(p, limit);
+  }
+  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
+
+  if (p->remainLen > kMatchSpecLenStart)
+  {
+    p->remainLen = kMatchSpecLenStart;
+  }
+  return 0;
+}
+
+typedef enum
+{
+  DUMMY_ERROR, /* unexpected end of input stream */
+  DUMMY_LIT,
+  DUMMY_MATCH,
+  DUMMY_REP
+} ELzmaDummy;
+
+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
+{
+  UInt32 range = p->range;
+  UInt32 code = p->code;
+  const Byte *bufLimit = buf + inSize;
+  CLzmaProb *probs = p->probs;
+  unsigned state = p->state;
+  ELzmaDummy res;
+
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
+
+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
+    IF_BIT_0_CHECK(prob)
+    {
+      UPDATE_0_CHECK
+
+      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
+
+      prob = probs + Literal;
+      if (p->checkDicSize != 0 || p->processedPos != 0)
+        prob += (LZMA_LIT_SIZE *
+          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
+          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
+
+      if (state < kNumLitStates)
+      {
+        unsigned symbol = 1;
+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
+            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
+        unsigned offs = 0x100;
+        unsigned symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
+        }
+        while (symbol < 0x100);
+      }
+      res = DUMMY_LIT;
+    }
+    else
+    {
+      unsigned len;
+      UPDATE_1_CHECK;
+
+      prob = probs + IsRep + state;
+      IF_BIT_0_CHECK(prob)
+      {
+        UPDATE_0_CHECK;
+        state = 0;
+        prob = probs + LenCoder;
+        res = DUMMY_MATCH;
+      }
+      else
+      {
+        UPDATE_1_CHECK;
+        res = DUMMY_REP;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0_CHECK(prob)
+        {
+          UPDATE_0_CHECK;
+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+            NORMALIZE_CHECK;
+            return DUMMY_REP;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+          }
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0_CHECK(prob)
+            {
+              UPDATE_0_CHECK;
+            }
+            else
+            {
+              UPDATE_1_CHECK;
+            }
+          }
+        }
+        state = kNumStates;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0_CHECK(probLen)
+        {
+          UPDATE_0_CHECK;
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          limit = 1 << kLenNumLowBits;
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          probLen = prob + LenChoice2;
+          IF_BIT_0_CHECK(probLen)
+          {
+            UPDATE_0_CHECK;
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = 1 << kLenNumMidBits;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = 1 << kLenNumHighBits;
+          }
+        }
+        TREE_DECODE_CHECK(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        unsigned posSlot;
+        prob = probs + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
+            kNumPosSlotBits);
+        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+
+          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
+
+          if (posSlot < kEndPosModelIndex)
+          {
+            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE_CHECK
+              range >>= 1;
+              code -= range & (((code - range) >> 31) - 1);
+              /* if (code >= range) code -= range; */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            unsigned i = 1;
+            do
+            {
+              GET_BIT_CHECK(prob + i, i);
+            }
+            while (--numDirectBits != 0);
+          }
+        }
+      }
+    }
+  }
+  NORMALIZE_CHECK;
+  return res;
+}
+
+
+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
+{
+  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
+  p->range = 0xFFFFFFFF;
+  p->needFlush = 0;
+}
+
+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+{
+  p->needFlush = 1;
+  p->remainLen = 0;
+  p->tempBufSize = 0;
+
+  if (initDic)
+  {
+    p->processedPos = 0;
+    p->checkDicSize = 0;
+    p->needInitState = 1;
+  }
+  if (initState)
+    p->needInitState = 1;
+}
+
+void LzmaDec_Init(CLzmaDec *p)
+{
+  p->dicPos = 0;
+  LzmaDec_InitDicAndState(p, True, True);
+}
+
+static void LzmaDec_InitStateReal(CLzmaDec *p)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
+  UInt32 i;
+  CLzmaProb *probs = p->probs;
+  for (i = 0; i < numProbs; i++)
+    probs[i] = kBitModelTotal >> 1;
+  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
+  p->state = 0;
+  p->needInitState = 0;
+}
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+    ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT inSize = *srcLen;
+  (*srcLen) = 0;
+  LzmaDec_WriteRem(p, dicLimit);
+
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+
+  while (p->remainLen != kMatchSpecLenStart)
+  {
+      int checkEndMarkNow;
+
+      if (p->needFlush != 0)
+      {
+        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
+          p->tempBuf[p->tempBufSize++] = *src++;
+        if (p->tempBufSize < RC_INIT_SIZE)
+        {
+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+          return SZ_OK;
+        }
+        if (p->tempBuf[0] != 0)
+          return SZ_ERROR_DATA;
+
+        LzmaDec_InitRc(p, p->tempBuf);
+        p->tempBufSize = 0;
+      }
+
+      checkEndMarkNow = 0;
+      if (p->dicPos >= dicLimit)
+      {
+        if (p->remainLen == 0 && p->code == 0)
+        {
+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
+          return SZ_OK;
+        }
+        if (finishMode == LZMA_FINISH_ANY)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_OK;
+        }
+        if (p->remainLen != 0)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_ERROR_DATA;
+        }
+        checkEndMarkNow = 1;
+      }
+
+      if (p->needInitState)
+        LzmaDec_InitStateReal(p);
+
+      if (p->tempBufSize == 0)
+      {
+        SizeT processed;
+        const Byte *bufLimit;
+        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            memcpy(p->tempBuf, src, inSize);
+            p->tempBufSize = (unsigned)inSize;
+            (*srcLen) += inSize;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+          bufLimit = src;
+        }
+        else
+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
+        p->buf = src;
+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
+          return SZ_ERROR_DATA;
+        processed = (SizeT)(p->buf - src);
+        (*srcLen) += processed;
+        src += processed;
+        inSize -= processed;
+      }
+      else
+      {
+        unsigned rem = p->tempBufSize, lookAhead = 0;
+        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
+          p->tempBuf[rem++] = src[lookAhead++];
+        p->tempBufSize = rem;
+        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            (*srcLen) += lookAhead;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+        }
+        p->buf = p->tempBuf;
+        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
+          return SZ_ERROR_DATA;
+        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
+        (*srcLen) += lookAhead;
+        src += lookAhead;
+        inSize -= lookAhead;
+        p->tempBufSize = 0;
+      }
+  }
+  if (p->code == 0)
+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
+  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
+}
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT outSize = *destLen;
+  SizeT inSize = *srcLen;
+  *srcLen = *destLen = 0;
+  for (;;)
+  {
+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+    ELzmaFinishMode curFinishMode;
+    SRes res;
+    if (p->dicPos == p->dicBufSize)
+      p->dicPos = 0;
+    dicPos = p->dicPos;
+    if (outSize > p->dicBufSize - dicPos)
+    {
+      outSizeCur = p->dicBufSize;
+      curFinishMode = LZMA_FINISH_ANY;
+    }
+    else
+    {
+      outSizeCur = dicPos + outSize;
+      curFinishMode = finishMode;
+    }
+
+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
+    src += inSizeCur;
+    inSize -= inSizeCur;
+    *srcLen += inSizeCur;
+    outSizeCur = p->dicPos - dicPos;
+    memcpy(dest, p->dic + dicPos, outSizeCur);
+    dest += outSizeCur;
+    outSize -= outSizeCur;
+    *destLen += outSizeCur;
+    if (res != 0)
+      return res;
+    if (outSizeCur == 0 || outSize == 0)
+      return SZ_OK;
+  }
+}
+
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->probs);
+  p->probs = 0;
+}
+
+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->dic);
+  p->dic = 0;
+}
+
+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+{
+  LzmaDec_FreeProbs(p, alloc);
+  LzmaDec_FreeDict(p, alloc);
+}
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+{
+  UInt32 dicSize;
+  Byte d;
+
+  if (size < LZMA_PROPS_SIZE)
+    return SZ_ERROR_UNSUPPORTED;
+  else
+    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
+
+  if (dicSize < LZMA_DIC_MIN)
+    dicSize = LZMA_DIC_MIN;
+  p->dicSize = dicSize;
+
+  d = data[0];
+  if (d >= (9 * 5 * 5))
+    return SZ_ERROR_UNSUPPORTED;
+
+  p->lc = d % 9;
+  d /= 9;
+  p->pb = d / 5;
+  p->lp = d % 5;
+
+  return SZ_OK;
+}
+
+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
+{
+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
+  if (p->probs == 0 || numProbs != p->numProbs)
+  {
+    LzmaDec_FreeProbs(p, alloc);
+    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
+    p->numProbs = numProbs;
+    if (p->probs == 0)
+      return SZ_ERROR_MEM;
+  }
+  return SZ_OK;
+}
+
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+  p->prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  SizeT dicBufSize;
+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+  dicBufSize = propNew.dicSize;
+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+  {
+    LzmaDec_FreeDict(p, alloc);
+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+    if (p->dic == 0)
+    {
+      LzmaDec_FreeProbs(p, alloc);
+      return SZ_ERROR_MEM;
+    }
+  }
+  p->dicBufSize = dicBufSize;
+  p->prop = propNew;
+  return SZ_OK;
+}
+
+// why isn't there an interface to pass in the properties directly????
+SRes LzmaDec_Allocate_MAME(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
+{
+  SizeT dicBufSize;
+  RINOK(LzmaDec_AllocateProbs2(p, propNew, alloc));
+  dicBufSize = propNew->dicSize;
+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+  {
+    LzmaDec_FreeDict(p, alloc);
+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+    if (p->dic == 0)
+    {
+      LzmaDec_FreeProbs(p, alloc);
+      return SZ_ERROR_MEM;
+    }
+  }
+  p->dicBufSize = dicBufSize;
+  p->prop = *propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc)
+{
+  CLzmaDec p;
+  SRes res;
+  SizeT outSize = *destLen, inSize = *srcLen;
+  *destLen = *srcLen = 0;
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+  if (inSize < RC_INIT_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+  LzmaDec_Construct(&p);
+  RINOK(LzmaDec_AllocateProbs(&p, propData, propSize, alloc));
+  p.dic = dest;
+  p.dicBufSize = outSize;
+  LzmaDec_Init(&p);
+  *srcLen = inSize;
+  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
+  *destLen = p.dicPos;
+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
+    res = SZ_ERROR_INPUT_EOF;
+  LzmaDec_FreeProbs(&p, alloc);
+  return res;
+}
diff -Nru src-old/lib/lib7z/LzmaDec.h src/lib/lib7z/LzmaDec.h
--- src-old/lib/lib7z/LzmaDec.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaDec.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,231 @@
+/* LzmaDec.h -- LZMA Decoder
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA_DEC_H
+#define __LZMA_DEC_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* #define _LZMA_PROB32 */
+/* _LZMA_PROB32 can increase the speed on some CPUs,
+   but memory usage for CLzmaDec::probs will be doubled in that case */
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+
+/* ---------- LZMA Properties ---------- */
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaProps
+{
+  unsigned lc, lp, pb;
+  UInt32 dicSize;
+} CLzmaProps;
+
+/* LzmaProps_Decode - decodes properties
+Returns:
+  SZ_OK
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+
+
+/* ---------- LZMA Decoder state ---------- */
+
+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
+   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
+
+#define LZMA_REQUIRED_INPUT_MAX 20
+
+typedef struct
+{
+  CLzmaProps prop;
+  CLzmaProb *probs;
+  Byte *dic;
+  const Byte *buf;
+  UInt32 range, code;
+  SizeT dicPos;
+  SizeT dicBufSize;
+  UInt32 processedPos;
+  UInt32 checkDicSize;
+  unsigned state;
+  UInt32 reps[4];
+  unsigned remainLen;
+  int needFlush;
+  int needInitState;
+  UInt32 numProbs;
+  unsigned tempBufSize;
+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
+} CLzmaDec;
+
+#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
+
+void LzmaDec_Init(CLzmaDec *p);
+
+/* There are two types of LZMA streams:
+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+
+typedef enum
+{
+  LZMA_FINISH_ANY,   /* finish at any point */
+  LZMA_FINISH_END    /* block must be finished at the end */
+} ELzmaFinishMode;
+
+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
+
+   You must use LZMA_FINISH_END, when you know that current output buffer
+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
+
+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
+   and output value of destLen will be less than output buffer size limit.
+   You can check status result also.
+
+   You can use multiple checks to test data integrity after full decompression:
+     1) Check Result and "status" variable.
+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
+        You must use correct finish mode in that case. */
+
+typedef enum
+{
+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
+} ELzmaStatus;
+
+/* ELzmaStatus is used only as output value for function call */
+
+
+/* ---------- Interfaces ---------- */
+
+/* There are 3 levels of interfaces:
+     1) Dictionary Interface
+     2) Buffer Interface
+     3) One Call Interface
+   You can select any of these interfaces, but don't mix functions from different
+   groups for same object. */
+
+
+/* There are two variants to allocate state for Dictionary Interface:
+     1) LzmaDec_Allocate / LzmaDec_Free
+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+   You can use variant 2, if you set dictionary buffer manually.
+   For Buffer Interface you must always use variant 1.
+
+LzmaDec_Allocate* can return:
+  SZ_OK
+  SZ_ERROR_MEM         - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+
+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+
+/* ---------- Dictionary Interface ---------- */
+
+/* You can use it, if you want to eliminate the overhead for data copying from
+   dictionary to some other external buffer.
+   You must work with CLzmaDec variables directly in this interface.
+
+   STEPS:
+     LzmaDec_Constr()
+     LzmaDec_Allocate()
+     for (each new stream)
+     {
+       LzmaDec_Init()
+       while (it needs more decompression)
+       {
+         LzmaDec_DecodeToDic()
+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+       }
+     }
+     LzmaDec_Free()
+*/
+
+/* LzmaDec_DecodeToDic
+
+   The decoding to internal dictionary buffer (CLzmaDec::dic).
+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (dicLimit).
+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+  LZMA_FINISH_END - Stream must be finished after dicLimit.
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_NEEDS_MORE_INPUT
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+*/
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- Buffer Interface ---------- */
+
+/* It's zlib-like interface.
+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+   to work with CLzmaDec variables manually.
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+*/
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaDecode
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/LzmaEnc.c src/lib/lib7z/LzmaEnc.c
--- src-old/lib/lib7z/LzmaEnc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaEnc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,2276 @@
+/* LzmaEnc.c -- LZMA Encoder
+2011-01-27 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+/* #define SHOW_STAT */
+/* #define SHOW_STAT2 */
+
+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
+#include <stdio.h>
+#endif
+
+#include "LzmaEnc.h"
+
+#include "LzFind.h"
+#ifndef _7ZIP_ST
+#include "LzFindMt.h"
+#endif
+
+#ifdef SHOW_STAT
+static int ttt = 0;
+#endif
+
+#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
+
+#define kBlockSize (9 << 10)
+#define kUnpackBlockSize (1 << 18)
+#define kMatchArraySize (1 << 21)
+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
+
+#define kNumMaxDirectBits (31)
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+#define kProbInitValue (kBitModelTotal >> 1)
+
+#define kNumMoveReducingBits 4
+#define kNumBitPriceShiftBits 4
+#define kBitPrice (1 << kNumBitPriceShiftBits)
+
+void LzmaEncProps_Init(CLzmaEncProps *p)
+{
+  p->level = 5;
+  p->dictSize = p->mc = 0;
+  p->reduceSize = (UInt32)(Int32)-1;
+  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
+  p->writeEndMark = 0;
+}
+
+void LzmaEncProps_Normalize(CLzmaEncProps *p)
+{
+  int level = p->level;
+  if (level < 0) level = 5;
+  p->level = level;
+  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
+  if (p->dictSize > p->reduceSize)
+  {
+    unsigned i;
+    for (i = 15; i <= 30; i++)
+    {
+      if (p->reduceSize <= ((UInt32)2 << i)) { p->dictSize = ((UInt32)2 << i); break; }
+      if (p->reduceSize <= ((UInt32)3 << i)) { p->dictSize = ((UInt32)3 << i); break; }
+    }
+  }
+  if (p->lc < 0) p->lc = 3;
+  if (p->lp < 0) p->lp = 0;
+  if (p->pb < 0) p->pb = 2;
+  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
+  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
+  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
+  if (p->numHashBytes < 0) p->numHashBytes = 4;
+  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
+  if (p->numThreads < 0)
+    p->numThreads =
+      #ifndef _7ZIP_ST
+      ((p->btMode && p->algo) ? 2 : 1);
+      #else
+      1;
+      #endif
+}
+
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+{
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&props);
+  return props.dictSize;
+}
+
+/* #define LZMA_LOG_BSR */
+/* Define it for Intel's CPU */
+
+
+#ifdef LZMA_LOG_BSR
+
+#define kDicLogSizeMaxCompress 30
+
+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
+
+UInt32 GetPosSlot1(UInt32 pos)
+{
+  UInt32 res;
+  BSR2_RET(pos, res);
+  return res;
+}
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
+
+#else
+
+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+
+void LzmaEnc_FastPosInit(Byte *g_FastPos)
+{
+  int c = 2, slotFast;
+  g_FastPos[0] = 0;
+  g_FastPos[1] = 1;
+
+  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
+  {
+    UInt32 k = (1 << ((slotFast >> 1) - 1));
+    UInt32 j;
+    for (j = 0; j < k; j++, c++)
+      g_FastPos[c] = (Byte)slotFast;
+  }
+}
+
+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
+  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
+  res = p->g_FastPos[pos >> i] + (i * 2); }
+/*
+#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
+  p->g_FastPos[pos >> 6] + 12 : \
+  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
+*/
+
+#define GetPosSlot1(pos) p->g_FastPos[pos]
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
+
+#endif
+
+
+#define LZMA_NUM_REPS 4
+
+typedef unsigned CState;
+
+typedef struct
+{
+  UInt32 price;
+
+  CState state;
+  int prev1IsChar;
+  int prev2;
+
+  UInt32 posPrev2;
+  UInt32 backPrev2;
+
+  UInt32 posPrev;
+  UInt32 backPrev;
+  UInt32 backs[LZMA_NUM_REPS];
+} COptimal;
+
+#define kNumOpts (1 << 12)
+
+#define kNumLenToPosStates 4
+#define kNumPosSlotBits 6
+#define kDicLogSizeMin 0
+#define kDicLogSizeMax 32
+#define kDistTableSizeMax (kDicLogSizeMax * 2)
+
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+#define kAlignMask (kAlignTableSize - 1)
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
+
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+#define LZMA_PB_MAX 4
+#define LZMA_LC_MAX 8
+#define LZMA_LP_MAX 4
+
+#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
+
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define LZMA_MATCH_LEN_MIN 2
+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
+
+#define kNumStates 12
+
+typedef struct
+{
+  CLzmaProb choice;
+  CLzmaProb choice2;
+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
+  CLzmaProb high[kLenNumHighSymbols];
+} CLenEnc;
+
+typedef struct
+{
+  CLenEnc p;
+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
+  UInt32 tableSize;
+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
+} CLenPriceEnc;
+
+typedef struct
+{
+  UInt32 range;
+  Byte cache;
+  UInt64 low;
+  UInt64 cacheSize;
+  Byte *buf;
+  Byte *bufLim;
+  Byte *bufBase;
+  ISeqOutStream *outStream;
+  UInt64 processed;
+  SRes res;
+} CRangeEnc;
+
+typedef struct
+{
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
+
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+} CSaveState;
+
+typedef struct
+{
+  IMatchFinder matchFinder;
+  void *matchFinderObj;
+
+  #ifndef _7ZIP_ST
+  Bool mtMode;
+  CMatchFinderMt matchFinderMt;
+  #endif
+
+  CMatchFinder matchFinderBase;
+
+  #ifndef _7ZIP_ST
+  Byte pad[128];
+  #endif
+
+  UInt32 optimumEndIndex;
+  UInt32 optimumCurrentIndex;
+
+  UInt32 longestMatchLength;
+  UInt32 numPairs;
+  UInt32 numAvail;
+  COptimal opt[kNumOpts];
+
+  #ifndef LZMA_LOG_BSR
+  Byte g_FastPos[1 << kNumLogBits];
+  #endif
+
+  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
+  UInt32 numFastBytes;
+  UInt32 additionalOffset;
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+
+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
+  UInt32 alignPrices[kAlignTableSize];
+  UInt32 alignPriceCount;
+
+  UInt32 distTableSize;
+
+  unsigned lc, lp, pb;
+  unsigned lpMask, pbMask;
+
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
+
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  unsigned lclp;
+
+  Bool fastMode;
+
+  CRangeEnc rc;
+
+  Bool writeEndMark;
+  UInt64 nowPos64;
+  UInt32 matchPriceCount;
+  Bool finished;
+  Bool multiThread;
+
+  SRes result;
+  UInt32 dictSize;
+
+  int needInit;
+
+  CSaveState saveState;
+} CLzmaEnc;
+
+void LzmaEnc_SaveState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CSaveState *dest = &p->saveState;
+  int i;
+  dest->lenEnc = p->lenEnc;
+  dest->repLenEnc = p->repLenEnc;
+  dest->state = p->state;
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+  }
+  for (i = 0; i < kNumLenToPosStates; i++)
+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+  memcpy(dest->reps, p->reps, sizeof(p->reps));
+  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
+}
+
+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *dest = (CLzmaEnc *)pp;
+  const CSaveState *p = &dest->saveState;
+  int i;
+  dest->lenEnc = p->lenEnc;
+  dest->repLenEnc = p->repLenEnc;
+  dest->state = p->state;
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+  }
+  for (i = 0; i < kNumLenToPosStates; i++)
+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+  memcpy(dest->reps, p->reps, sizeof(p->reps));
+  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
+}
+
+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&props);
+
+  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
+      props.dictSize > ((UInt32)1 << kDicLogSizeMaxCompress) || props.dictSize > ((UInt32)1 << 30))
+    return SZ_ERROR_PARAM;
+  p->dictSize = props.dictSize;
+  {
+    unsigned fb = props.fb;
+    if (fb < 5)
+      fb = 5;
+    if (fb > LZMA_MATCH_LEN_MAX)
+      fb = LZMA_MATCH_LEN_MAX;
+    p->numFastBytes = fb;
+  }
+  p->lc = props.lc;
+  p->lp = props.lp;
+  p->pb = props.pb;
+  p->fastMode = (props.algo == 0);
+  p->matchFinderBase.btMode = props.btMode;
+  {
+    UInt32 numHashBytes = 4;
+    if (props.btMode)
+    {
+      if (props.numHashBytes < 2)
+        numHashBytes = 2;
+      else if (props.numHashBytes < 4)
+        numHashBytes = props.numHashBytes;
+    }
+    p->matchFinderBase.numHashBytes = numHashBytes;
+  }
+
+  p->matchFinderBase.cutValue = props.mc;
+
+  p->writeEndMark = props.writeEndMark;
+
+  #ifndef _7ZIP_ST
+  /*
+  if (newMultiThread != _multiThread)
+  {
+    ReleaseMatchFinder();
+    _multiThread = newMultiThread;
+  }
+  */
+  p->multiThread = (props.numThreads > 1);
+  #endif
+
+  return SZ_OK;
+}
+
+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+#define IsCharState(s) ((s) < 7)
+
+#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
+
+#define kInfinityPrice (1 << 30)
+
+static void RangeEnc_Construct(CRangeEnc *p)
+{
+  p->outStream = 0;
+  p->bufBase = 0;
+}
+
+#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
+
+#define RC_BUF_SIZE (1 << 16)
+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
+{
+  if (p->bufBase == 0)
+  {
+    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
+    if (p->bufBase == 0)
+      return 0;
+    p->bufLim = p->bufBase + RC_BUF_SIZE;
+  }
+  return 1;
+}
+
+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->bufBase);
+  p->bufBase = 0;
+}
+
+static void RangeEnc_Init(CRangeEnc *p)
+{
+  /* Stream.Init(); */
+  p->low = 0;
+  p->range = 0xFFFFFFFF;
+  p->cacheSize = 1;
+  p->cache = 0;
+
+  p->buf = p->bufBase;
+
+  p->processed = 0;
+  p->res = SZ_OK;
+}
+
+static void RangeEnc_FlushStream(CRangeEnc *p)
+{
+  size_t num;
+  if (p->res != SZ_OK)
+    return;
+  num = p->buf - p->bufBase;
+  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
+    p->res = SZ_ERROR_WRITE;
+  p->processed += num;
+  p->buf = p->bufBase;
+}
+
+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
+{
+  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
+  {
+    Byte temp = p->cache;
+    do
+    {
+      Byte *buf = p->buf;
+      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
+      p->buf = buf;
+      if (buf == p->bufLim)
+        RangeEnc_FlushStream(p);
+      temp = 0xFF;
+    }
+    while (--p->cacheSize != 0);
+    p->cache = (Byte)((UInt32)p->low >> 24);
+  }
+  p->cacheSize++;
+  p->low = (UInt32)p->low << 8;
+}
+
+static void RangeEnc_FlushData(CRangeEnc *p)
+{
+  int i;
+  for (i = 0; i < 5; i++)
+    RangeEnc_ShiftLow(p);
+}
+
+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
+{
+  do
+  {
+    p->range >>= 1;
+    p->low += p->range & (0 - ((value >> --numBits) & 1));
+    if (p->range < kTopValue)
+    {
+      p->range <<= 8;
+      RangeEnc_ShiftLow(p);
+    }
+  }
+  while (numBits != 0);
+}
+
+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
+{
+  UInt32 ttt = *prob;
+  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
+  if (symbol == 0)
+  {
+    p->range = newBound;
+    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
+  }
+  else
+  {
+    p->low += newBound;
+    p->range -= newBound;
+    ttt -= ttt >> kNumMoveBits;
+  }
+  *prob = (CLzmaProb)ttt;
+  if (p->range < kTopValue)
+  {
+    p->range <<= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
+{
+  symbol |= 0x100;
+  do
+  {
+    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
+    symbol <<= 1;
+  }
+  while (symbol < 0x10000);
+}
+
+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
+{
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte <<= 1;
+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
+    symbol <<= 1;
+    offs &= ~(matchByte ^ symbol);
+  }
+  while (symbol < 0x10000);
+}
+
+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+{
+  UInt32 i;
+  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+  {
+    const int kCyclesBits = kNumBitPriceShiftBits;
+    UInt32 w = i;
+    UInt32 bitCount = 0;
+    int j;
+    for (j = 0; j < kCyclesBits; j++)
+    {
+      w = w * w;
+      bitCount <<= 1;
+      while (w >= ((UInt32)1 << 16))
+      {
+        w >>= 1;
+        bitCount++;
+      }
+    }
+    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
+  }
+}
+
+
+#define GET_PRICE(prob, symbol) \
+  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+
+#define GET_PRICEa(prob, symbol) \
+  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+
+#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
+#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
+
+#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
+
+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= 0x100;
+  do
+  {
+    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
+    symbol <<= 1;
+  }
+  while (symbol < 0x10000);
+  return price;
+}
+
+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte <<= 1;
+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
+    symbol <<= 1;
+    offs &= ~(matchByte ^ symbol);
+  }
+  while (symbol < 0x10000);
+  return price;
+}
+
+
+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0;)
+  {
+    UInt32 bit;
+    i--;
+    bit = (symbol >> i) & 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m << 1) | bit;
+  }
+}
+
+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = 0; i < numBitLevels; i++)
+  {
+    UInt32 bit = symbol & 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m << 1) | bit;
+    symbol >>= 1;
+  }
+}
+
+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= (1 << numBitLevels);
+  while (symbol != 1)
+  {
+    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
+    symbol >>= 1;
+  }
+  return price;
+}
+
+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol & 1;
+    symbol >>= 1;
+    price += GET_PRICEa(probs[m], bit);
+    m = (m << 1) | bit;
+  }
+  return price;
+}
+
+
+static void LenEnc_Init(CLenEnc *p)
+{
+  unsigned i;
+  p->choice = p->choice2 = kProbInitValue;
+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
+    p->low[i] = kProbInitValue;
+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
+    p->mid[i] = kProbInitValue;
+  for (i = 0; i < kLenNumHighSymbols; i++)
+    p->high[i] = kProbInitValue;
+}
+
+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
+{
+  if (symbol < kLenNumLowSymbols)
+  {
+    RangeEnc_EncodeBit(rc, &p->choice, 0);
+    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
+  }
+  else
+  {
+    RangeEnc_EncodeBit(rc, &p->choice, 1);
+    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
+    {
+      RangeEnc_EncodeBit(rc, &p->choice2, 0);
+      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
+    }
+    else
+    {
+      RangeEnc_EncodeBit(rc, &p->choice2, 1);
+      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
+    }
+  }
+}
+
+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
+{
+  UInt32 a0 = GET_PRICE_0a(p->choice);
+  UInt32 a1 = GET_PRICE_1a(p->choice);
+  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
+  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
+  UInt32 i = 0;
+  for (i = 0; i < kLenNumLowSymbols; i++)
+  {
+    if (i >= numSymbols)
+      return;
+    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
+  }
+  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
+  {
+    if (i >= numSymbols)
+      return;
+    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
+  }
+  for (; i < numSymbols; i++)
+    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
+}
+
+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
+{
+  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
+  p->counters[posState] = p->tableSize;
+}
+
+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
+{
+  UInt32 posState;
+  for (posState = 0; posState < numPosStates; posState++)
+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
+{
+  LenEnc_Encode(&p->p, rc, symbol, posState);
+  if (updatePrice)
+    if (--p->counters[posState] == 0)
+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+
+
+
+static void MovePos(CLzmaEnc *p, UInt32 num)
+{
+  #ifdef SHOW_STAT
+  ttt += num;
+  printf("\n MovePos %d", num);
+  #endif
+  if (num != 0)
+  {
+    p->additionalOffset += num;
+    p->matchFinder.Skip(p->matchFinderObj, num);
+  }
+}
+
+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
+{
+  UInt32 lenRes = 0, numPairs;
+  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
+  #ifdef SHOW_STAT
+  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
+  ttt++;
+  {
+    UInt32 i;
+    for (i = 0; i < numPairs; i += 2)
+      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
+  }
+  #endif
+  if (numPairs > 0)
+  {
+    lenRes = p->matches[numPairs - 2];
+    if (lenRes == p->numFastBytes)
+    {
+      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+      UInt32 distance = p->matches[numPairs - 1] + 1;
+      UInt32 numAvail = p->numAvail;
+      if (numAvail > LZMA_MATCH_LEN_MAX)
+        numAvail = LZMA_MATCH_LEN_MAX;
+      {
+        const Byte *pby2 = pby - distance;
+        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
+      }
+    }
+  }
+  p->additionalOffset++;
+  *numDistancePairsRes = numPairs;
+  return lenRes;
+}
+
+
+#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
+#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
+#define IsShortRep(p) ((p)->backPrev == 0)
+
+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
+{
+  return
+    GET_PRICE_0(p->isRepG0[state]) +
+    GET_PRICE_0(p->isRep0Long[state][posState]);
+}
+
+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
+{
+  UInt32 price;
+  if (repIndex == 0)
+  {
+    price = GET_PRICE_0(p->isRepG0[state]);
+    price += GET_PRICE_1(p->isRep0Long[state][posState]);
+  }
+  else
+  {
+    price = GET_PRICE_1(p->isRepG0[state]);
+    if (repIndex == 1)
+      price += GET_PRICE_0(p->isRepG1[state]);
+    else
+    {
+      price += GET_PRICE_1(p->isRepG1[state]);
+      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
+    }
+  }
+  return price;
+}
+
+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
+{
+  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
+    GetPureRepPrice(p, repIndex, state, posState);
+}
+
+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
+{
+  UInt32 posMem = p->opt[cur].posPrev;
+  UInt32 backMem = p->opt[cur].backPrev;
+  p->optimumEndIndex = cur;
+  do
+  {
+    if (p->opt[cur].prev1IsChar)
+    {
+      MakeAsChar(&p->opt[posMem])
+      p->opt[posMem].posPrev = posMem - 1;
+      if (p->opt[cur].prev2)
+      {
+        p->opt[posMem - 1].prev1IsChar = False;
+        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
+        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
+      }
+    }
+    {
+      UInt32 posPrev = posMem;
+      UInt32 backCur = backMem;
+
+      backMem = p->opt[posPrev].backPrev;
+      posMem = p->opt[posPrev].posPrev;
+
+      p->opt[posPrev].backPrev = backCur;
+      p->opt[posPrev].posPrev = cur;
+      cur = posPrev;
+    }
+  }
+  while (cur != 0);
+  *backRes = p->opt[0].backPrev;
+  p->optimumCurrentIndex  = p->opt[0].posPrev;
+  return p->optimumCurrentIndex;
+}
+
+#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
+
+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
+  UInt32 *matches;
+  const Byte *data;
+  Byte curByte, matchByte;
+  if (p->optimumEndIndex != p->optimumCurrentIndex)
+  {
+    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
+    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
+    *backRes = opt->backPrev;
+    p->optimumCurrentIndex = opt->posPrev;
+    return lenRes;
+  }
+  p->optimumCurrentIndex = p->optimumEndIndex = 0;
+
+  if (p->additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &numPairs);
+  else
+  {
+    mainLen = p->longestMatchLength;
+    numPairs = p->numPairs;
+  }
+
+  numAvail = p->numAvail;
+  if (numAvail < 2)
+  {
+    *backRes = (UInt32)(-1);
+    return 1;
+  }
+  if (numAvail > LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  repMaxIndex = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 lenTest;
+    const Byte *data2;
+    reps[i] = p->reps[i];
+    data2 = data - (reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+    repLens[i] = lenTest;
+    if (lenTest > repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if (repLens[repMaxIndex] >= p->numFastBytes)
+  {
+    UInt32 lenRes;
+    *backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    MovePos(p, lenRes - 1);
+    return lenRes;
+  }
+
+  matches = p->matches;
+  if (mainLen >= p->numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+  curByte = *data;
+  matchByte = *(data - (reps[0] + 1));
+
+  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
+  {
+    *backRes = (UInt32)-1;
+    return 1;
+  }
+
+  p->opt[0].state = (CState)p->state;
+
+  posState = (position & p->pbMask);
+
+  {
+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
+        (!IsCharState(p->state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+  }
+
+  MakeAsChar(&p->opt[1]);
+
+  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
+  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
+
+  if (matchByte == curByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
+    if (shortRepPrice < p->opt[1].price)
+    {
+      p->opt[1].price = shortRepPrice;
+      MakeAsShortRep(&p->opt[1]);
+    }
+  }
+  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
+
+  if (lenEnd < 2)
+  {
+    *backRes = p->opt[1].backPrev;
+    return 1;
+  }
+
+  p->opt[1].posPrev = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+    p->opt[0].backs[i] = reps[i];
+
+  len = lenEnd;
+  do
+    p->opt[len--].price = kInfinityPrice;
+  while (len >= 2);
+
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 repLen = repLens[i];
+    UInt32 price;
+    if (repLen < 2)
+      continue;
+    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
+    do
+    {
+      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
+      COptimal *opt = &p->opt[repLen];
+      if (curAndLenPrice < opt->price)
+      {
+        opt->price = curAndLenPrice;
+        opt->posPrev = 0;
+        opt->backPrev = i;
+        opt->prev1IsChar = False;
+      }
+    }
+    while (--repLen >= 2);
+  }
+
+  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
+
+  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
+  if (len <= mainLen)
+  {
+    UInt32 offs = 0;
+    while (len > matches[offs])
+      offs += 2;
+    for (; ; len++)
+    {
+      COptimal *opt;
+      UInt32 distance = matches[offs + 1];
+
+      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
+      UInt32 lenToPosState = GetLenToPosState(len);
+      if (distance < kNumFullDistances)
+        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
+      else
+      {
+        UInt32 slot;
+        GetPosSlot2(distance, slot);
+        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
+      }
+      opt = &p->opt[len];
+      if (curAndLenPrice < opt->price)
+      {
+        opt->price = curAndLenPrice;
+        opt->posPrev = 0;
+        opt->backPrev = distance + LZMA_NUM_REPS;
+        opt->prev1IsChar = False;
+      }
+      if (len == matches[offs])
+      {
+        offs += 2;
+        if (offs == numPairs)
+          break;
+      }
+    }
+  }
+
+  cur = 0;
+
+    #ifdef SHOW_STAT2
+    if (position >= 0)
+    {
+      unsigned i;
+      printf("\n pos = %4X", position);
+      for (i = cur; i <= lenEnd; i++)
+      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
+    }
+    #endif
+
+  for (;;)
+  {
+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
+    Bool nextIsChar;
+    Byte curByte, matchByte;
+    const Byte *data;
+    COptimal *curOpt;
+    COptimal *nextOpt;
+
+    cur++;
+    if (cur == lenEnd)
+      return Backward(p, backRes, cur);
+
+    newLen = ReadMatchDistances(p, &numPairs);
+    if (newLen >= p->numFastBytes)
+    {
+      p->numPairs = numPairs;
+      p->longestMatchLength = newLen;
+      return Backward(p, backRes, cur);
+    }
+    position++;
+    curOpt = &p->opt[cur];
+    posPrev = curOpt->posPrev;
+    if (curOpt->prev1IsChar)
+    {
+      posPrev--;
+      if (curOpt->prev2)
+      {
+        state = p->opt[curOpt->posPrev2].state;
+        if (curOpt->backPrev2 < LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      else
+        state = p->opt[posPrev].state;
+      state = kLiteralNextStates[state];
+    }
+    else
+      state = p->opt[posPrev].state;
+    if (posPrev == cur - 1)
+    {
+      if (IsShortRep(curOpt))
+        state = kShortRepNextStates[state];
+      else
+        state = kLiteralNextStates[state];
+    }
+    else
+    {
+      UInt32 pos;
+      const COptimal *prevOpt;
+      if (curOpt->prev1IsChar && curOpt->prev2)
+      {
+        posPrev = curOpt->posPrev2;
+        pos = curOpt->backPrev2;
+        state = kRepNextStates[state];
+      }
+      else
+      {
+        pos = curOpt->backPrev;
+        if (pos < LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      prevOpt = &p->opt[posPrev];
+      if (pos < LZMA_NUM_REPS)
+      {
+        UInt32 i;
+        reps[0] = prevOpt->backs[pos];
+        for (i = 1; i <= pos; i++)
+          reps[i] = prevOpt->backs[i - 1];
+        for (; i < LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt->backs[i];
+      }
+      else
+      {
+        UInt32 i;
+        reps[0] = (pos - LZMA_NUM_REPS);
+        for (i = 1; i < LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt->backs[i - 1];
+      }
+    }
+    curOpt->state = (CState)state;
+
+    curOpt->backs[0] = reps[0];
+    curOpt->backs[1] = reps[1];
+    curOpt->backs[2] = reps[2];
+    curOpt->backs[3] = reps[3];
+
+    curPrice = curOpt->price;
+    nextIsChar = False;
+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+    curByte = *data;
+    matchByte = *(data - (reps[0] + 1));
+
+    posState = (position & p->pbMask);
+
+    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
+    {
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      curAnd1Price +=
+        (!IsCharState(state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+    }
+
+    nextOpt = &p->opt[cur + 1];
+
+    if (curAnd1Price < nextOpt->price)
+    {
+      nextOpt->price = curAnd1Price;
+      nextOpt->posPrev = cur;
+      MakeAsChar(nextOpt);
+      nextIsChar = True;
+    }
+
+    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
+
+    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
+      if (shortRepPrice <= nextOpt->price)
+      {
+        nextOpt->price = shortRepPrice;
+        nextOpt->posPrev = cur;
+        MakeAsShortRep(nextOpt);
+        nextIsChar = True;
+      }
+    }
+    numAvailFull = p->numAvail;
+    {
+      UInt32 temp = kNumOpts - 1 - cur;
+      if (temp < numAvailFull)
+        numAvailFull = temp;
+    }
+
+    if (numAvailFull < 2)
+      continue;
+    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
+
+    if (!nextIsChar && matchByte != curByte) /* speed optimization */
+    {
+      /* try Literal + rep0 */
+      UInt32 temp;
+      UInt32 lenTest2;
+      const Byte *data2 = data - (reps[0] + 1);
+      UInt32 limit = p->numFastBytes + 1;
+      if (limit > numAvailFull)
+        limit = numAvailFull;
+
+      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
+      lenTest2 = temp - 1;
+      if (lenTest2 >= 2)
+      {
+        UInt32 state2 = kLiteralNextStates[state];
+        UInt32 posStateNext = (position + 1) & p->pbMask;
+        UInt32 nextRepMatchPrice = curAnd1Price +
+            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+            GET_PRICE_1(p->isRep[state2]);
+        /* for (; lenTest2 >= 2; lenTest2--) */
+        {
+          UInt32 curAndLenPrice;
+          COptimal *opt;
+          UInt32 offset = cur + 1 + lenTest2;
+          while (lenEnd < offset)
+            p->opt[++lenEnd].price = kInfinityPrice;
+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+          opt = &p->opt[offset];
+          if (curAndLenPrice < opt->price)
+          {
+            opt->price = curAndLenPrice;
+            opt->posPrev = cur + 1;
+            opt->backPrev = 0;
+            opt->prev1IsChar = True;
+            opt->prev2 = False;
+          }
+        }
+      }
+    }
+
+    startLen = 2; /* speed optimization */
+    {
+    UInt32 repIndex;
+    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
+    {
+      UInt32 lenTest;
+      UInt32 lenTestTemp;
+      UInt32 price;
+      const Byte *data2 = data - (reps[repIndex] + 1);
+      if (data[0] != data2[0] || data[1] != data2[1])
+        continue;
+      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+      while (lenEnd < cur + lenTest)
+        p->opt[++lenEnd].price = kInfinityPrice;
+      lenTestTemp = lenTest;
+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
+      do
+      {
+        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
+        COptimal *opt = &p->opt[cur + lenTest];
+        if (curAndLenPrice < opt->price)
+        {
+          opt->price = curAndLenPrice;
+          opt->posPrev = cur;
+          opt->backPrev = repIndex;
+          opt->prev1IsChar = False;
+        }
+      }
+      while (--lenTest >= 2);
+      lenTest = lenTestTemp;
+
+      if (repIndex == 0)
+        startLen = lenTest + 1;
+
+      /* if (_maxMode) */
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p->numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit > numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            UInt32 state2 = kRepNextStates[state];
+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
+            UInt32 curAndLenCharPrice =
+                price + p->repLenEnc.prices[posState][lenTest - 2] +
+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p->ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (position + lenTest + 1) & p->pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p->isRep[state2]);
+
+            /* for (; lenTest2 >= 2; lenTest2--) */
+            {
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while (lenEnd < offset)
+                p->opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &p->opt[offset];
+              if (curAndLenPrice < opt->price)
+              {
+                opt->price = curAndLenPrice;
+                opt->posPrev = cur + lenTest + 1;
+                opt->backPrev = 0;
+                opt->prev1IsChar = True;
+                opt->prev2 = True;
+                opt->posPrev2 = cur;
+                opt->backPrev2 = repIndex;
+              }
+            }
+          }
+        }
+    }
+    }
+    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
+    if (newLen > numAvail)
+    {
+      newLen = numAvail;
+      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
+      matches[numPairs] = newLen;
+      numPairs += 2;
+    }
+    if (newLen >= startLen)
+    {
+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
+      UInt32 offs, curBack, posSlot;
+      UInt32 lenTest;
+      while (lenEnd < cur + newLen)
+        p->opt[++lenEnd].price = kInfinityPrice;
+
+      offs = 0;
+      while (startLen > matches[offs])
+        offs += 2;
+      curBack = matches[offs + 1];
+      GetPosSlot2(curBack, posSlot);
+      for (lenTest = /*2*/ startLen; ; lenTest++)
+      {
+        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
+        UInt32 lenToPosState = GetLenToPosState(lenTest);
+        COptimal *opt;
+        if (curBack < kNumFullDistances)
+          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
+        else
+          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
+
+        opt = &p->opt[cur + lenTest];
+        if (curAndLenPrice < opt->price)
+        {
+          opt->price = curAndLenPrice;
+          opt->posPrev = cur;
+          opt->backPrev = curBack + LZMA_NUM_REPS;
+          opt->prev1IsChar = False;
+        }
+
+        if (/*_maxMode && */lenTest == matches[offs])
+        {
+          /* Try Match + Literal + Rep0 */
+          const Byte *data2 = data - (curBack + 1);
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p->numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit > numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            UInt32 state2 = kMatchNextStates[state];
+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice +
+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p->ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (posStateNext + 1) & p->pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p->isRep[state2]);
+
+            /* for (; lenTest2 >= 2; lenTest2--) */
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              while (lenEnd < offset)
+                p->opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &p->opt[offset];
+              if (curAndLenPrice < opt->price)
+              {
+                opt->price = curAndLenPrice;
+                opt->posPrev = cur + lenTest + 1;
+                opt->backPrev = 0;
+                opt->prev1IsChar = True;
+                opt->prev2 = True;
+                opt->posPrev2 = cur;
+                opt->backPrev2 = curBack + LZMA_NUM_REPS;
+              }
+            }
+          }
+          offs += 2;
+          if (offs == numPairs)
+            break;
+          curBack = matches[offs + 1];
+          if (curBack >= kNumFullDistances)
+            GetPosSlot2(curBack, posSlot);
+        }
+      }
+    }
+  }
+}
+
+#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
+
+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  const Byte *data;
+  const UInt32 *matches;
+
+  if (p->additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &numPairs);
+  else
+  {
+    mainLen = p->longestMatchLength;
+    numPairs = p->numPairs;
+  }
+
+  numAvail = p->numAvail;
+  *backRes = (UInt32)-1;
+  if (numAvail < 2)
+    return 1;
+  if (numAvail > LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+
+  repLen = repIndex = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 len;
+    const Byte *data2 = data - (p->reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
+    if (len >= p->numFastBytes)
+    {
+      *backRes = i;
+      MovePos(p, len - 1);
+      return len;
+    }
+    if (len > repLen)
+    {
+      repIndex = i;
+      repLen = len;
+    }
+  }
+
+  matches = p->matches;
+  if (mainLen >= p->numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+
+  mainDist = 0; /* for GCC */
+  if (mainLen >= 2)
+  {
+    mainDist = matches[numPairs - 1];
+    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
+    {
+      if (!ChangePair(matches[numPairs - 3], mainDist))
+        break;
+      numPairs -= 2;
+      mainLen = matches[numPairs - 2];
+      mainDist = matches[numPairs - 1];
+    }
+    if (mainLen == 2 && mainDist >= 0x80)
+      mainLen = 1;
+  }
+
+  if (repLen >= 2 && (
+        (repLen + 1 >= mainLen) ||
+        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
+        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
+  {
+    *backRes = repIndex;
+    MovePos(p, repLen - 1);
+    return repLen;
+  }
+
+  if (mainLen < 2 || numAvail <= 2)
+    return 1;
+
+  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
+  if (p->longestMatchLength >= 2)
+  {
+    UInt32 newDistance = matches[p->numPairs - 1];
+    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
+        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
+        (p->longestMatchLength > mainLen + 1) ||
+        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
+      return 1;
+  }
+
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 len, limit;
+    const Byte *data2 = data - (p->reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    limit = mainLen - 1;
+    for (len = 2; len < limit && data[len] == data2[len]; len++);
+    if (len >= limit)
+      return 1;
+  }
+  *backRes = mainDist + LZMA_NUM_REPS;
+  MovePos(p, mainLen - 2);
+  return mainLen;
+}
+
+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
+{
+  UInt32 len;
+  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
+  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
+  p->state = kMatchNextStates[p->state];
+  len = LZMA_MATCH_LEN_MIN;
+  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
+  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
+  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
+}
+
+static SRes CheckErrors(CLzmaEnc *p)
+{
+  if (p->result != SZ_OK)
+    return p->result;
+  if (p->rc.res != SZ_OK)
+    p->result = SZ_ERROR_WRITE;
+  if (p->matchFinderBase.result != SZ_OK)
+    p->result = SZ_ERROR_READ;
+  if (p->result != SZ_OK)
+    p->finished = True;
+  return p->result;
+}
+
+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
+{
+  /* ReleaseMFStream(); */
+  p->finished = True;
+  if (p->writeEndMark)
+    WriteEndMarker(p, nowPos & p->pbMask);
+  RangeEnc_FlushData(&p->rc);
+  RangeEnc_FlushStream(&p->rc);
+  return CheckErrors(p);
+}
+
+static void FillAlignPrices(CLzmaEnc *p)
+{
+  UInt32 i;
+  for (i = 0; i < kAlignTableSize; i++)
+    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
+  p->alignPriceCount = 0;
+}
+
+static void FillDistancesPrices(CLzmaEnc *p)
+{
+  UInt32 tempPrices[kNumFullDistances];
+  UInt32 i, lenToPosState;
+  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
+  {
+    UInt32 posSlot = GetPosSlot1(i);
+    UInt32 footerBits = ((posSlot >> 1) - 1);
+    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
+  }
+
+  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
+  {
+    UInt32 posSlot;
+    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
+    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
+    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
+    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
+      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
+
+    {
+      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
+      UInt32 i;
+      for (i = 0; i < kStartPosModelIndex; i++)
+        distancesPrices[i] = posSlotPrices[i];
+      for (; i < kNumFullDistances; i++)
+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
+    }
+  }
+  p->matchPriceCount = 0;
+}
+
+void LzmaEnc_Construct(CLzmaEnc *p)
+{
+  RangeEnc_Construct(&p->rc);
+  MatchFinder_Construct(&p->matchFinderBase);
+  #ifndef _7ZIP_ST
+  MatchFinderMt_Construct(&p->matchFinderMt);
+  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
+  #endif
+
+  {
+    CLzmaEncProps props;
+    LzmaEncProps_Init(&props);
+    LzmaEnc_SetProps(p, &props);
+  }
+
+  #ifndef LZMA_LOG_BSR
+  LzmaEnc_FastPosInit(p->g_FastPos);
+  #endif
+
+  LzmaEnc_InitPriceTables(p->ProbPrices);
+  p->litProbs = 0;
+  p->saveState.litProbs = 0;
+}
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
+{
+  void *p;
+  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
+  if (p != 0)
+    LzmaEnc_Construct((CLzmaEnc *)p);
+  return p;
+}
+
+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->litProbs);
+  alloc->Free(alloc, p->saveState.litProbs);
+  p->litProbs = 0;
+  p->saveState.litProbs = 0;
+}
+
+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  #ifndef _7ZIP_ST
+  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
+  #endif
+  MatchFinder_Free(&p->matchFinderBase, allocBig);
+  LzmaEnc_FreeLits(p, alloc);
+  RangeEnc_Free(&p->rc, alloc);
+}
+
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
+  alloc->Free(alloc, p);
+}
+
+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
+{
+  UInt32 nowPos32, startPos32;
+  if (p->needInit)
+  {
+    p->matchFinder.Init(p->matchFinderObj);
+    p->needInit = 0;
+  }
+
+  if (p->finished)
+    return p->result;
+  RINOK(CheckErrors(p));
+
+  nowPos32 = (UInt32)p->nowPos64;
+  startPos32 = nowPos32;
+
+  if (p->nowPos64 == 0)
+  {
+    UInt32 numPairs;
+    Byte curByte;
+    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
+      return Flush(p, nowPos32);
+    ReadMatchDistances(p, &numPairs);
+    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
+    p->state = kLiteralNextStates[p->state];
+    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
+    LitEnc_Encode(&p->rc, p->litProbs, curByte);
+    p->additionalOffset--;
+    nowPos32++;
+  }
+
+  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
+  for (;;)
+  {
+    UInt32 pos, len, posState;
+
+    if (p->fastMode)
+      len = GetOptimumFast(p, &pos);
+    else
+      len = GetOptimum(p, nowPos32, &pos);
+
+    #ifdef SHOW_STAT2
+    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
+    #endif
+
+    posState = nowPos32 & p->pbMask;
+    if (len == 1 && pos == (UInt32)-1)
+    {
+      Byte curByte;
+      CLzmaProb *probs;
+      const Byte *data;
+
+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
+      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+      curByte = *data;
+      probs = LIT_PROBS(nowPos32, *(data - 1));
+      if (IsCharState(p->state))
+        LitEnc_Encode(&p->rc, probs, curByte);
+      else
+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
+      p->state = kLiteralNextStates[p->state];
+    }
+    else
+    {
+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
+      if (pos < LZMA_NUM_REPS)
+      {
+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
+        if (pos == 0)
+        {
+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
+          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
+        }
+        else
+        {
+          UInt32 distance = p->reps[pos];
+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
+          if (pos == 1)
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
+          else
+          {
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
+            if (pos == 3)
+              p->reps[3] = p->reps[2];
+            p->reps[2] = p->reps[1];
+          }
+          p->reps[1] = p->reps[0];
+          p->reps[0] = distance;
+        }
+        if (len == 1)
+          p->state = kShortRepNextStates[p->state];
+        else
+        {
+          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+          p->state = kRepNextStates[p->state];
+        }
+      }
+      else
+      {
+        UInt32 posSlot;
+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
+        p->state = kMatchNextStates[p->state];
+        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+        pos -= LZMA_NUM_REPS;
+        GetPosSlot(pos, posSlot);
+        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
+
+        if (posSlot >= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot >> 1) - 1);
+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot < kEndPosModelIndex)
+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
+          else
+          {
+            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
+            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
+            p->alignPriceCount++;
+          }
+        }
+        p->reps[3] = p->reps[2];
+        p->reps[2] = p->reps[1];
+        p->reps[1] = p->reps[0];
+        p->reps[0] = pos;
+        p->matchPriceCount++;
+      }
+    }
+    p->additionalOffset -= len;
+    nowPos32 += len;
+    if (p->additionalOffset == 0)
+    {
+      UInt32 processed;
+      if (!p->fastMode)
+      {
+        if (p->matchPriceCount >= (1 << 7))
+          FillDistancesPrices(p);
+        if (p->alignPriceCount >= kAlignTableSize)
+          FillAlignPrices(p);
+      }
+      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
+        break;
+      processed = nowPos32 - startPos32;
+      if (useLimits)
+      {
+        if (processed + kNumOpts + 300 >= maxUnpackSize ||
+            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
+          break;
+      }
+      else if (processed >= (1 << 15))
+      {
+        p->nowPos64 += nowPos32 - startPos32;
+        return CheckErrors(p);
+      }
+    }
+  }
+  p->nowPos64 += nowPos32 - startPos32;
+  return Flush(p, nowPos32);
+}
+
+#define kBigHashDicLimit ((UInt32)1 << 24)
+
+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 beforeSize = kNumOpts;
+  Bool btMode;
+  if (!RangeEnc_Alloc(&p->rc, alloc))
+    return SZ_ERROR_MEM;
+  btMode = (p->matchFinderBase.btMode != 0);
+  #ifndef _7ZIP_ST
+  p->mtMode = (p->multiThread && !p->fastMode && btMode);
+  #endif
+
+  {
+    unsigned lclp = p->lc + p->lp;
+    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
+    {
+      LzmaEnc_FreeLits(p, alloc);
+      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
+      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
+      if (p->litProbs == 0 || p->saveState.litProbs == 0)
+      {
+        LzmaEnc_FreeLits(p, alloc);
+        return SZ_ERROR_MEM;
+      }
+      p->lclp = lclp;
+    }
+  }
+
+  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
+
+  if (beforeSize + p->dictSize < keepWindowSize)
+    beforeSize = keepWindowSize - p->dictSize;
+
+  #ifndef _7ZIP_ST
+  if (p->mtMode)
+  {
+    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
+    p->matchFinderObj = &p->matchFinderMt;
+    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
+  }
+  else
+  #endif
+  {
+    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
+      return SZ_ERROR_MEM;
+    p->matchFinderObj = &p->matchFinderBase;
+    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
+  }
+  return SZ_OK;
+}
+
+void LzmaEnc_Init(CLzmaEnc *p)
+{
+  UInt32 i;
+  p->state = 0;
+  for (i = 0 ; i < LZMA_NUM_REPS; i++)
+    p->reps[i] = 0;
+
+  RangeEnc_Init(&p->rc);
+
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    UInt32 j;
+    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
+    {
+      p->isMatch[i][j] = kProbInitValue;
+      p->isRep0Long[i][j] = kProbInitValue;
+    }
+    p->isRep[i] = kProbInitValue;
+    p->isRepG0[i] = kProbInitValue;
+    p->isRepG1[i] = kProbInitValue;
+    p->isRepG2[i] = kProbInitValue;
+  }
+
+  {
+    UInt32 num = 0x300 << (p->lp + p->lc);
+    for (i = 0; i < num; i++)
+      p->litProbs[i] = kProbInitValue;
+  }
+
+  {
+    for (i = 0; i < kNumLenToPosStates; i++)
+    {
+      CLzmaProb *probs = p->posSlotEncoder[i];
+      UInt32 j;
+      for (j = 0; j < (1 << kNumPosSlotBits); j++)
+        probs[j] = kProbInitValue;
+    }
+  }
+  {
+    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
+      p->posEncoders[i] = kProbInitValue;
+  }
+
+  LenEnc_Init(&p->lenEnc.p);
+  LenEnc_Init(&p->repLenEnc.p);
+
+  for (i = 0; i < (1 << kNumAlignBits); i++)
+    p->posAlignEncoder[i] = kProbInitValue;
+
+  p->optimumEndIndex = 0;
+  p->optimumCurrentIndex = 0;
+  p->additionalOffset = 0;
+
+  p->pbMask = (1 << p->pb) - 1;
+  p->lpMask = (1 << p->lp) - 1;
+}
+
+void LzmaEnc_InitPrices(CLzmaEnc *p)
+{
+  if (!p->fastMode)
+  {
+    FillDistancesPrices(p);
+    FillAlignPrices(p);
+  }
+
+  p->lenEnc.tableSize =
+  p->repLenEnc.tableSize =
+      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
+  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
+  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
+}
+
+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 i;
+  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
+    if (p->dictSize <= ((UInt32)1 << i))
+      break;
+  p->distTableSize = i * 2;
+
+  p->finished = False;
+  p->result = SZ_OK;
+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
+  LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  p->nowPos64 = 0;
+  return SZ_OK;
+}
+
+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p->matchFinderBase.stream = inStream;
+  p->needInit = 1;
+  p->rc.outStream = outStream;
+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+}
+
+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+    ISeqInStream *inStream, UInt32 keepWindowSize,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p->matchFinderBase.stream = inStream;
+  p->needInit = 1;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+{
+  p->matchFinderBase.directInput = 1;
+  p->matchFinderBase.bufferBase = (Byte *)src;
+  p->matchFinderBase.directInputRem = srcLen;
+}
+
+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+  p->needInit = 1;
+
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+void LzmaEnc_Finish(CLzmaEncHandle pp)
+{
+  #ifndef _7ZIP_ST
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  if (p->mtMode)
+    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
+  #else
+  pp = pp;
+  #endif
+}
+
+typedef struct
+{
+  ISeqOutStream funcTable;
+  Byte *data;
+  SizeT rem;
+  Bool overflow;
+} CSeqOutStreamBuf;
+
+static size_t MyWrite(void *pp, const void *data, size_t size)
+{
+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
+  if (p->rem < size)
+  {
+    size = p->rem;
+    p->overflow = True;
+  }
+  memcpy(p->data, data, size);
+  p->rem -= size;
+  p->data += size;
+  return size;
+}
+
+
+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+}
+
+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+}
+
+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  UInt64 nowPos64;
+  SRes res;
+  CSeqOutStreamBuf outStream;
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p->writeEndMark = False;
+  p->finished = False;
+  p->result = SZ_OK;
+
+  if (reInit)
+    LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  nowPos64 = p->nowPos64;
+  RangeEnc_Init(&p->rc);
+  p->rc.outStream = &outStream.funcTable;
+
+  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+
+  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  return res;
+}
+
+static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
+{
+  SRes res = SZ_OK;
+
+  #ifndef _7ZIP_ST
+  Byte allocaDummy[0x300];
+  int i = 0;
+  for (i = 0; i < 16; i++)
+    allocaDummy[i] = (Byte)i;
+  #endif
+
+  for (;;)
+  {
+    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
+    if (res != SZ_OK || p->finished != 0)
+      break;
+    if (progress != 0)
+    {
+      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
+      if (res != SZ_OK)
+      {
+        res = SZ_ERROR_PROGRESS;
+        break;
+      }
+    }
+  }
+  LzmaEnc_Finish(p);
+  return res;
+}
+
+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
+  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
+}
+
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  int i;
+  UInt32 dictSize = p->dictSize;
+  if (*size < LZMA_PROPS_SIZE)
+    return SZ_ERROR_PARAM;
+  *size = LZMA_PROPS_SIZE;
+  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
+
+  for (i = 11; i <= 30; i++)
+  {
+    if (dictSize <= ((UInt32)2 << i))
+    {
+      dictSize = (2 << i);
+      break;
+    }
+    if (dictSize <= ((UInt32)3 << i))
+    {
+      dictSize = (3 << i);
+      break;
+    }
+  }
+
+  for (i = 0; i < 4; i++)
+    props[1 + i] = (Byte)(dictSize >> (8 * i));
+  return SZ_OK;
+}
+
+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  SRes res;
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+
+  CSeqOutStreamBuf outStream;
+
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p->writeEndMark = writeEndMark;
+
+  p->rc.outStream = &outStream.funcTable;
+  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
+  if (res == SZ_OK)
+    res = LzmaEnc_Encode2(p, progress);
+
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+  return res;
+}
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+  SRes res;
+  if (p == 0)
+    return SZ_ERROR_MEM;
+
+  res = LzmaEnc_SetProps(p, props);
+  if (res == SZ_OK)
+  {
+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+    if (res == SZ_OK)
+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+          writeEndMark, progress, alloc, allocBig);
+  }
+
+  LzmaEnc_Destroy(p, alloc, allocBig);
+  return res;
+}
diff -Nru src-old/lib/lib7z/LzmaEnc.h src/lib/lib7z/LzmaEnc.h
--- src-old/lib/lib7z/LzmaEnc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaEnc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,78 @@
+/*  LzmaEnc.h -- LZMA Encoder
+2011-01-27 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA_ENC_H
+#define __LZMA_ENC_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaEncProps
+{
+  int level;       /*  0 <= level <= 9 */
+  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
+                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
+                       default = (1 << 24) */
+  UInt32 reduceSize; /* estimated size of data that will be compressed. default = 0xFFFFFFFF.
+                        Encoder uses this value to reduce dictionary size */
+  int lc;          /* 0 <= lc <= 8, default = 3 */
+  int lp;          /* 0 <= lp <= 4, default = 0 */
+  int pb;          /* 0 <= pb <= 4, default = 2 */
+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
+  int fb;          /* 5 <= fb <= 273, default = 32 */
+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
+  int numHashBytes; /* 2, 3 or 4, default = 4 */
+  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
+  int numThreads;  /* 1 or 2, default = 2 */
+} CLzmaEncProps;
+
+void LzmaEncProps_Init(CLzmaEncProps *p);
+void LzmaEncProps_Normalize(CLzmaEncProps *p);
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+
+
+/* ---------- CLzmaEncHandle Interface ---------- */
+
+/* LzmaEnc_* functions can return the following exit codes:
+Returns:
+  SZ_OK           - OK
+  SZ_ERROR_MEM    - Memory allocation error
+  SZ_ERROR_PARAM  - Incorrect paramater in props
+  SZ_ERROR_WRITE  - Write callback error.
+  SZ_ERROR_PROGRESS - some break from progress callback
+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
+*/
+
+typedef void * CLzmaEncHandle;
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaEncode
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/LzmaLib.c src/lib/lib7z/LzmaLib.c
--- src-old/lib/lib7z/LzmaLib.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaLib.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,46 @@
+/* LzmaLib.c -- LZMA library wrapper
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include "LzmaEnc.h"
+#include "LzmaDec.h"
+#include "Alloc.h"
+#include "LzmaLib.h"
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
+  unsigned char *outProps, size_t *outPropsSize,
+  int level, /* 0 <= level <= 9, default = 5 */
+  unsigned dictSize, /* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */
+  int lc, /* 0 <= lc <= 8, default = 3  */
+  int lp, /* 0 <= lp <= 4, default = 0  */
+  int pb, /* 0 <= pb <= 4, default = 2  */
+  int fb,  /* 5 <= fb <= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+)
+{
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&props);
+  props.level = level;
+  props.dictSize = dictSize;
+  props.lc = lc;
+  props.lp = lp;
+  props.pb = pb;
+  props.fb = fb;
+  props.numThreads = numThreads;
+
+  return LzmaEncode(dest, destLen, src, srcLen, &props, outProps, outPropsSize, 0,
+      NULL, &g_Alloc, &g_Alloc);
+}
+
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
+  const unsigned char *props, size_t propsSize)
+{
+  ELzmaStatus status;
+  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &status, &g_Alloc);
+}
diff -Nru src-old/lib/lib7z/LzmaLib.h src/lib/lib7z/LzmaLib.h
--- src-old/lib/lib7z/LzmaLib.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/LzmaLib.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,135 @@
+/* LzmaLib.h -- LZMA library interface
+2009-04-07 : Igor Pavlov : Public domain */
+
+#ifndef __LZMA_LIB_H
+#define __LZMA_LIB_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MY_STDAPI int MY_STD_CALL
+
+#define LZMA_PROPS_SIZE 5
+
+/*
+RAM requirements for LZMA:
+  for compression:   (dictSize * 11.5 + 6 MB) + state_size
+  for decompression: dictSize + state_size
+    state_size = (4 + (1.5 << (lc + lp))) KB
+    by default (lc=3, lp=0), state_size = 16 KB.
+
+LZMA properties (5 bytes) format
+    Offset Size  Description
+      0     1    lc, lp and pb in encoded form.
+      1     4    dictSize (little endian).
+*/
+
+/*
+LzmaCompress
+------------
+
+outPropsSize -
+     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+
+  LZMA Encoder will use defult values for any parameter, if it is
+  -1  for any from: level, loc, lp, pb, fb, numThreads
+   0  for dictSize
+
+level - compression level: 0 <= level <= 9;
+
+  level dictSize algo  fb
+    0:    16 KB   0    32
+    1:    64 KB   0    32
+    2:   256 KB   0    32
+    3:     1 MB   0    32
+    4:     4 MB   0    32
+    5:    16 MB   1    32
+    6:    32 MB   1    32
+    7+:   64 MB   1    64
+
+  The default value for "level" is 5.
+
+  algo = 0 means fast method
+  algo = 1 means normal method
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 << 27) bytes for 32-bit version
+          1 GB = (1 << 30) bytes for 64-bit version
+     The default value is 16 MB = (1 << 24) bytes.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 << N) or (3 << N) sizes.
+
+lc - The number of literal context bits (high bits of previous literal).
+     It can be in the range from 0 to 8. The default value is 3.
+     Sometimes lc=4 gives the gain for big files.
+
+lp - The number of literal pos bits (low bits of current position for literals).
+     It can be in the range from 0 to 4. The default value is 0.
+     The lp switch is intended for periodical data when the period is equal to 2^lp.
+     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
+     better to set lc=0, if you change lp switch.
+
+pb - The number of pos bits (low bits of current position).
+     It can be in the range from 0 to 4. The default value is 2.
+     The pb switch is intended for periodical data when the period is equal 2^pb.
+
+fb - Word size (the number of fast bytes).
+     It can be in the range from 5 to 273. The default value is 32.
+     Usually, a big number gives a little bit better compression ratio and
+     slower compression process.
+
+numThreads - The number of thereads. 1 or 2. The default value is 2.
+     Fast mode (algo = 0) can use only 1 thread.
+
+Out:
+  destLen  - processed output size
+Returns:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
+  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
+  int level,      /* 0 <= level <= 9, default = 5 */
+  unsigned dictSize,  /* default = (1 << 24) */
+  int lc,        /* 0 <= lc <= 8, default = 3  */
+  int lp,        /* 0 <= lp <= 4, default = 0  */
+  int pb,        /* 0 <= pb <= 4, default = 2  */
+  int fb,        /* 5 <= fb <= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+  );
+
+/*
+LzmaUncompress
+--------------
+In:
+  dest     - output data
+  destLen  - output data size
+  src      - input data
+  srcLen   - input data size
+Out:
+  destLen  - processed output size
+  srcLen   - processed input size
+Returns:
+  SZ_OK                - OK
+  SZ_ERROR_DATA        - Data error
+  SZ_ERROR_MEM         - Memory allocation arror
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
+*/
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
+  const unsigned char *props, size_t propsSize);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/MtCoder.c src/lib/lib7z/MtCoder.c
--- src-old/lib/lib7z/MtCoder.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/MtCoder.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,327 @@
+/* MtCoder.c -- Multi-thread Coder
+2010-09-24 : Igor Pavlov : Public domain */
+
+#include <stdio.h>
+
+#include "MtCoder.h"
+
+void LoopThread_Construct(CLoopThread *p)
+{
+  Thread_Construct(&p->thread);
+  Event_Construct(&p->startEvent);
+  Event_Construct(&p->finishedEvent);
+}
+
+void LoopThread_Close(CLoopThread *p)
+{
+  Thread_Close(&p->thread);
+  Event_Close(&p->startEvent);
+  Event_Close(&p->finishedEvent);
+}
+
+static THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE LoopThreadFunc(void *pp)
+{
+  CLoopThread *p = (CLoopThread *)pp;
+  for (;;)
+  {
+    if (Event_Wait(&p->startEvent) != 0)
+      return SZ_ERROR_THREAD;
+    if (p->stop)
+      return 0;
+    p->res = p->func(p->param);
+    if (Event_Set(&p->finishedEvent) != 0)
+      return SZ_ERROR_THREAD;
+  }
+}
+
+WRes LoopThread_Create(CLoopThread *p)
+{
+  p->stop = 0;
+  RINOK(AutoResetEvent_CreateNotSignaled(&p->startEvent));
+  RINOK(AutoResetEvent_CreateNotSignaled(&p->finishedEvent));
+  return Thread_Create(&p->thread, LoopThreadFunc, p);
+}
+
+WRes LoopThread_StopAndWait(CLoopThread *p)
+{
+  p->stop = 1;
+  if (Event_Set(&p->startEvent) != 0)
+    return SZ_ERROR_THREAD;
+  return Thread_Wait(&p->thread);
+}
+
+WRes LoopThread_StartSubThread(CLoopThread *p) { return Event_Set(&p->startEvent); }
+WRes LoopThread_WaitSubThread(CLoopThread *p) { return Event_Wait(&p->finishedEvent); }
+
+static SRes Progress(ICompressProgress *p, UInt64 inSize, UInt64 outSize)
+{
+  return (p && p->Progress(p, inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;
+}
+
+static void MtProgress_Init(CMtProgress *p, ICompressProgress *progress)
+{
+  unsigned i;
+  for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
+    p->inSizes[i] = p->outSizes[i] = 0;
+  p->totalInSize = p->totalOutSize = 0;
+  p->progress = progress;
+  p->res = SZ_OK;
+}
+
+static void MtProgress_Reinit(CMtProgress *p, unsigned index)
+{
+  p->inSizes[index] = 0;
+  p->outSizes[index] = 0;
+}
+
+#define UPDATE_PROGRESS(size, prev, total) \
+  if (size != (UInt64)(Int64)-1) { total += size - prev; prev = size; }
+
+SRes MtProgress_Set(CMtProgress *p, unsigned index, UInt64 inSize, UInt64 outSize)
+{
+  SRes res;
+  CriticalSection_Enter(&p->cs);
+  UPDATE_PROGRESS(inSize, p->inSizes[index], p->totalInSize)
+  UPDATE_PROGRESS(outSize, p->outSizes[index], p->totalOutSize)
+  if (p->res == SZ_OK)
+    p->res = Progress(p->progress, p->totalInSize, p->totalOutSize);
+  res = p->res;
+  CriticalSection_Leave(&p->cs);
+  return res;
+}
+
+static void MtProgress_SetError(CMtProgress *p, SRes res)
+{
+  CriticalSection_Enter(&p->cs);
+  if (p->res == SZ_OK)
+    p->res = res;
+  CriticalSection_Leave(&p->cs);
+}
+
+static void MtCoder_SetError(CMtCoder* p, SRes res)
+{
+  CriticalSection_Enter(&p->cs);
+  if (p->res == SZ_OK)
+    p->res = res;
+  CriticalSection_Leave(&p->cs);
+}
+
+/* ---------- MtThread ---------- */
+
+void CMtThread_Construct(CMtThread *p, CMtCoder *mtCoder)
+{
+  p->mtCoder = mtCoder;
+  p->outBuf = 0;
+  p->inBuf = 0;
+  Event_Construct(&p->canRead);
+  Event_Construct(&p->canWrite);
+  LoopThread_Construct(&p->thread);
+}
+
+#define RINOK_THREAD(x) { if((x) != 0) return SZ_ERROR_THREAD; }
+
+static void CMtThread_CloseEvents(CMtThread *p)
+{
+  Event_Close(&p->canRead);
+  Event_Close(&p->canWrite);
+}
+
+static void CMtThread_Destruct(CMtThread *p)
+{
+  CMtThread_CloseEvents(p);
+
+  if (Thread_WasCreated(&p->thread.thread))
+  {
+    LoopThread_StopAndWait(&p->thread);
+    LoopThread_Close(&p->thread);
+  }
+
+  if (p->mtCoder->alloc)
+    IAlloc_Free(p->mtCoder->alloc, p->outBuf);
+  p->outBuf = 0;
+
+  if (p->mtCoder->alloc)
+    IAlloc_Free(p->mtCoder->alloc, p->inBuf);
+  p->inBuf = 0;
+}
+
+#define MY_BUF_ALLOC(buf, size, newSize) \
+  if (buf == 0 || size != newSize) \
+  { IAlloc_Free(p->mtCoder->alloc, buf); \
+    size = newSize; buf = (Byte *)IAlloc_Alloc(p->mtCoder->alloc, size); \
+    if (buf == 0) return SZ_ERROR_MEM; }
+
+static SRes CMtThread_Prepare(CMtThread *p)
+{
+  MY_BUF_ALLOC(p->inBuf, p->inBufSize, p->mtCoder->blockSize)
+  MY_BUF_ALLOC(p->outBuf, p->outBufSize, p->mtCoder->destBlockSize)
+
+  p->stopReading = False;
+  p->stopWriting = False;
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->canRead));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->canWrite));
+
+  return SZ_OK;
+}
+
+static SRes FullRead(ISeqInStream *stream, Byte *data, size_t *processedSize)
+{
+  size_t size = *processedSize;
+  *processedSize = 0;
+  while (size != 0)
+  {
+    size_t curSize = size;
+    SRes res = stream->Read(stream, data, &curSize);
+    *processedSize += curSize;
+    data += curSize;
+    size -= curSize;
+    RINOK(res);
+    if (curSize == 0)
+      return SZ_OK;
+  }
+  return SZ_OK;
+}
+
+#define GET_NEXT_THREAD(p) &p->mtCoder->threads[p->index == p->mtCoder->numThreads  - 1 ? 0 : p->index + 1]
+
+static SRes MtThread_Process(CMtThread *p, Bool *stop)
+{
+  CMtThread *next;
+  *stop = True;
+  if (Event_Wait(&p->canRead) != 0)
+    return SZ_ERROR_THREAD;
+
+  next = GET_NEXT_THREAD(p);
+
+  if (p->stopReading)
+  {
+    next->stopReading = True;
+    return Event_Set(&next->canRead) == 0 ? SZ_OK : SZ_ERROR_THREAD;
+  }
+
+  {
+    size_t size = p->mtCoder->blockSize;
+    size_t destSize = p->outBufSize;
+
+    RINOK(FullRead(p->mtCoder->inStream, p->inBuf, &size));
+    next->stopReading = *stop = (size != p->mtCoder->blockSize);
+    if (Event_Set(&next->canRead) != 0)
+      return SZ_ERROR_THREAD;
+
+    RINOK(p->mtCoder->mtCallback->Code(p->mtCoder->mtCallback, p->index,
+        p->outBuf, &destSize, p->inBuf, size, *stop));
+
+    MtProgress_Reinit(&p->mtCoder->mtProgress, p->index);
+
+    if (Event_Wait(&p->canWrite) != 0)
+      return SZ_ERROR_THREAD;
+    if (p->stopWriting)
+      return SZ_ERROR_FAIL;
+    if (p->mtCoder->outStream->Write(p->mtCoder->outStream, p->outBuf, destSize) != destSize)
+      return SZ_ERROR_WRITE;
+    return Event_Set(&next->canWrite) == 0 ? SZ_OK : SZ_ERROR_THREAD;
+  }
+}
+
+static THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE ThreadFunc(void *pp)
+{
+  CMtThread *p = (CMtThread *)pp;
+  for (;;)
+  {
+    Bool stop;
+    CMtThread *next = GET_NEXT_THREAD(p);
+    SRes res = MtThread_Process(p, &stop);
+    if (res != SZ_OK)
+    {
+      MtCoder_SetError(p->mtCoder, res);
+      MtProgress_SetError(&p->mtCoder->mtProgress, res);
+      next->stopReading = True;
+      next->stopWriting = True;
+      Event_Set(&next->canRead);
+      Event_Set(&next->canWrite);
+      return res;
+    }
+    if (stop)
+      return 0;
+  }
+}
+
+void MtCoder_Construct(CMtCoder* p)
+{
+  unsigned i;
+  p->alloc = 0;
+  for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
+  {
+    CMtThread *t = &p->threads[i];
+    t->index = i;
+    CMtThread_Construct(t, p);
+  }
+  CriticalSection_Init(&p->cs);
+  CriticalSection_Init(&p->mtProgress.cs);
+}
+
+void MtCoder_Destruct(CMtCoder* p)
+{
+  unsigned i;
+  for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
+    CMtThread_Destruct(&p->threads[i]);
+  CriticalSection_Delete(&p->cs);
+  CriticalSection_Delete(&p->mtProgress.cs);
+}
+
+SRes MtCoder_Code(CMtCoder *p)
+{
+  unsigned i, numThreads = p->numThreads;
+  SRes res = SZ_OK;
+  p->res = SZ_OK;
+
+  MtProgress_Init(&p->mtProgress, p->progress);
+
+  for (i = 0; i < numThreads; i++)
+  {
+    RINOK(CMtThread_Prepare(&p->threads[i]));
+  }
+
+  for (i = 0; i < numThreads; i++)
+  {
+    CMtThread *t = &p->threads[i];
+    CLoopThread *lt = &t->thread;
+
+    if (!Thread_WasCreated(&lt->thread))
+    {
+      lt->func = ThreadFunc;
+      lt->param = t;
+
+      if (LoopThread_Create(lt) != SZ_OK)
+      {
+        res = SZ_ERROR_THREAD;
+        break;
+      }
+    }
+  }
+
+  if (res == SZ_OK)
+  {
+    unsigned j;
+    for (i = 0; i < numThreads; i++)
+    {
+      CMtThread *t = &p->threads[i];
+      if (LoopThread_StartSubThread(&t->thread) != SZ_OK)
+      {
+        res = SZ_ERROR_THREAD;
+        p->threads[0].stopReading = True;
+        break;
+      }
+    }
+
+    Event_Set(&p->threads[0].canWrite);
+    Event_Set(&p->threads[0].canRead);
+
+    for (j = 0; j < i; j++)
+      LoopThread_WaitSubThread(&p->threads[j].thread);
+  }
+
+  for (i = 0; i < numThreads; i++)
+    CMtThread_CloseEvents(&p->threads[i]);
+  return (res == SZ_OK) ? p->res : res;
+}
diff -Nru src-old/lib/lib7z/MtCoder.h src/lib/lib7z/MtCoder.h
--- src-old/lib/lib7z/MtCoder.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/MtCoder.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,98 @@
+/* MtCoder.h -- Multi-thread Coder
+2009-11-19 : Igor Pavlov : Public domain */
+
+#ifndef __MT_CODER_H
+#define __MT_CODER_H
+
+#include "Threads.h"
+
+EXTERN_C_BEGIN
+
+typedef struct
+{
+  CThread thread;
+  CAutoResetEvent startEvent;
+  CAutoResetEvent finishedEvent;
+  int stop;
+
+  THREAD_FUNC_TYPE func;
+  LPVOID param;
+  THREAD_FUNC_RET_TYPE res;
+} CLoopThread;
+
+void LoopThread_Construct(CLoopThread *p);
+void LoopThread_Close(CLoopThread *p);
+WRes LoopThread_Create(CLoopThread *p);
+WRes LoopThread_StopAndWait(CLoopThread *p);
+WRes LoopThread_StartSubThread(CLoopThread *p);
+WRes LoopThread_WaitSubThread(CLoopThread *p);
+
+#ifndef _7ZIP_ST
+#define NUM_MT_CODER_THREADS_MAX 32
+#else
+#define NUM_MT_CODER_THREADS_MAX 1
+#endif
+
+typedef struct
+{
+  UInt64 totalInSize;
+  UInt64 totalOutSize;
+  ICompressProgress *progress;
+  SRes res;
+  CCriticalSection cs;
+  UInt64 inSizes[NUM_MT_CODER_THREADS_MAX];
+  UInt64 outSizes[NUM_MT_CODER_THREADS_MAX];
+} CMtProgress;
+
+SRes MtProgress_Set(CMtProgress *p, unsigned index, UInt64 inSize, UInt64 outSize);
+
+struct _CMtCoder;
+
+typedef struct
+{
+  struct _CMtCoder *mtCoder;
+  Byte *outBuf;
+  size_t outBufSize;
+  Byte *inBuf;
+  size_t inBufSize;
+  unsigned index;
+  CLoopThread thread;
+
+  Bool stopReading;
+  Bool stopWriting;
+  CAutoResetEvent canRead;
+  CAutoResetEvent canWrite;
+} CMtThread;
+
+typedef struct
+{
+  SRes (*Code)(void *p, unsigned index, Byte *dest, size_t *destSize,
+      const Byte *src, size_t srcSize, int finished);
+} IMtCoderCallback;
+
+typedef struct _CMtCoder
+{
+  size_t blockSize;
+  size_t destBlockSize;
+  unsigned numThreads;
+
+  ISeqInStream *inStream;
+  ISeqOutStream *outStream;
+  ICompressProgress *progress;
+  ISzAlloc *alloc;
+
+  IMtCoderCallback *mtCallback;
+  CCriticalSection cs;
+  SRes res;
+
+  CMtProgress mtProgress;
+  CMtThread threads[NUM_MT_CODER_THREADS_MAX];
+} CMtCoder;
+
+void MtCoder_Construct(CMtCoder* p);
+void MtCoder_Destruct(CMtCoder* p);
+SRes MtCoder_Code(CMtCoder *p);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Ppmd.h src/lib/lib7z/Ppmd.h
--- src-old/lib/lib7z/Ppmd.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,86 @@
+/* Ppmd.h -- PPMD codec common code
+2011-01-27 : Igor Pavlov : Public domain
+This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
+
+#ifndef __PPMD_H
+#define __PPMD_H
+
+#include "Types.h"
+#include "CpuArch.h"
+
+EXTERN_C_BEGIN
+
+#ifdef MY_CPU_32BIT
+  #define PPMD_32BIT
+#endif
+
+#define PPMD_INT_BITS 7
+#define PPMD_PERIOD_BITS 7
+#define PPMD_BIN_SCALE (1 << (PPMD_INT_BITS + PPMD_PERIOD_BITS))
+
+#define PPMD_GET_MEAN_SPEC(summ, shift, round) (((summ) + (1 << ((shift) - (round)))) >> (shift))
+#define PPMD_GET_MEAN(summ) PPMD_GET_MEAN_SPEC((summ), PPMD_PERIOD_BITS, 2)
+#define PPMD_UPDATE_PROB_0(prob) ((prob) + (1 << PPMD_INT_BITS) - PPMD_GET_MEAN(prob))
+#define PPMD_UPDATE_PROB_1(prob) ((prob) - PPMD_GET_MEAN(prob))
+
+#define PPMD_N1 4
+#define PPMD_N2 4
+#define PPMD_N3 4
+#define PPMD_N4 ((128 + 3 - 1 * PPMD_N1 - 2 * PPMD_N2 - 3 * PPMD_N3) / 4)
+#define PPMD_NUM_INDEXES (PPMD_N1 + PPMD_N2 + PPMD_N3 + PPMD_N4)
+
+#pragma pack(push, 1)
+/* Most compilers works OK here even without #pragma pack(push, 1), but some GCC compilers need it. */
+
+/* SEE-contexts for PPM-contexts with masked symbols */
+typedef struct
+{
+  UInt16 Summ; /* Freq */
+  Byte Shift;  /* Speed of Freq change; low Shift is for fast change */
+  Byte Count;  /* Count to next change of Shift */
+} CPpmd_See;
+
+#define Ppmd_See_Update(p)  if ((p)->Shift < PPMD_PERIOD_BITS && --(p)->Count == 0) \
+    { (p)->Summ <<= 1; (p)->Count = (Byte)(3 << (p)->Shift++); }
+
+typedef struct
+{
+  Byte Symbol;
+  Byte Freq;
+  UInt16 SuccessorLow;
+  UInt16 SuccessorHigh;
+} CPpmd_State;
+
+#pragma pack(pop)
+
+typedef
+  #ifdef PPMD_32BIT
+    CPpmd_State *
+  #else
+    UInt32
+  #endif
+  CPpmd_State_Ref;
+
+typedef
+  #ifdef PPMD_32BIT
+    void *
+  #else
+    UInt32
+  #endif
+  CPpmd_Void_Ref;
+
+typedef
+  #ifdef PPMD_32BIT
+    Byte *
+  #else
+    UInt32
+  #endif
+  CPpmd_Byte_Ref;
+
+#define PPMD_SetAllBitsIn256Bytes(p) \
+  { unsigned i; for (i = 0; i < 256 / sizeof(p[0]); i += 8) { \
+  p[i+7] = p[i+6] = p[i+5] = p[i+4] = p[i+3] = p[i+2] = p[i+1] = p[i+0] = ~(size_t)0; }}
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Ppmd7.c src/lib/lib7z/Ppmd7.c
--- src-old/lib/lib7z/Ppmd7.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd7.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,708 @@
+/* Ppmd7.c -- PPMdH codec
+2010-03-12 : Igor Pavlov : Public domain
+This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
+
+#include <string.h>
+
+#include "Ppmd7.h"
+
+const Byte PPMD7_kExpEscape[16] = { 25, 14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
+static const UInt16 kInitBinEsc[] = { 0x3CDD, 0x1F3F, 0x59BF, 0x48F3, 0x64A1, 0x5ABC, 0x6632, 0x6051};
+
+#define MAX_FREQ 124
+#define UNIT_SIZE 12
+
+#define U2B(nu) ((UInt32)(nu) * UNIT_SIZE)
+#define U2I(nu) (p->Units2Indx[(nu) - 1])
+#define I2U(indx) (p->Indx2Units[indx])
+
+#ifdef PPMD_32BIT
+  #define REF(ptr) (ptr)
+#else
+  #define REF(ptr) ((UInt32)((Byte *)(ptr) - (p)->Base))
+#endif
+
+#define STATS_REF(ptr) ((CPpmd_State_Ref)REF(ptr))
+
+#define CTX(ref) ((CPpmd7_Context *)Ppmd7_GetContext(p, ref))
+#define STATS(ctx) Ppmd7_GetStats(p, ctx)
+#define ONE_STATE(ctx) Ppmd7Context_OneState(ctx)
+#define SUFFIX(ctx) CTX((ctx)->Suffix)
+
+typedef CPpmd7_Context * CTX_PTR;
+
+struct CPpmd7_Node_;
+
+typedef
+  #ifdef PPMD_32BIT
+    struct CPpmd7_Node_ *
+  #else
+    UInt32
+  #endif
+  CPpmd7_Node_Ref;
+
+typedef struct CPpmd7_Node_
+{
+  UInt16 Stamp; /* must be at offset 0 as CPpmd7_Context::NumStats. Stamp=0 means free */
+  UInt16 NU;
+  CPpmd7_Node_Ref Next; /* must be at offset >= 4 */
+  CPpmd7_Node_Ref Prev;
+} CPpmd7_Node;
+
+#ifdef PPMD_32BIT
+  #define NODE(ptr) (ptr)
+#else
+  #define NODE(offs) ((CPpmd7_Node *)(p->Base + (offs)))
+#endif
+
+void Ppmd7_Construct(CPpmd7 *p)
+{
+  unsigned i, k, m;
+
+  p->Base = 0;
+
+  for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)
+  {
+    unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);
+    do { p->Units2Indx[k++] = (Byte)i; } while(--step);
+    p->Indx2Units[i] = (Byte)k;
+  }
+
+  p->NS2BSIndx[0] = (0 << 1);
+  p->NS2BSIndx[1] = (1 << 1);
+  memset(p->NS2BSIndx + 2, (2 << 1), 9);
+  memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);
+
+  for (i = 0; i < 3; i++)
+    p->NS2Indx[i] = (Byte)i;
+  for (m = i, k = 1; i < 256; i++)
+  {
+    p->NS2Indx[i] = (Byte)m;
+    if (--k == 0)
+      k = (++m) - 2;
+  }
+
+  memset(p->HB2Flag, 0, 0x40);
+  memset(p->HB2Flag + 0x40, 8, 0x100 - 0x40);
+}
+
+void Ppmd7_Free(CPpmd7 *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->Base);
+  p->Size = 0;
+  p->Base = 0;
+}
+
+Bool Ppmd7_Alloc(CPpmd7 *p, UInt32 size, ISzAlloc *alloc)
+{
+  if (p->Base == 0 || p->Size != size)
+  {
+    Ppmd7_Free(p, alloc);
+    p->AlignOffset =
+      #ifdef PPMD_32BIT
+        (4 - size) & 3;
+      #else
+        4 - (size & 3);
+      #endif
+    if ((p->Base = (Byte *)alloc->Alloc(alloc, p->AlignOffset + size
+        #ifndef PPMD_32BIT
+        + UNIT_SIZE
+        #endif
+        )) == 0)
+      return False;
+    p->Size = size;
+  }
+  return True;
+}
+
+static void InsertNode(CPpmd7 *p, void *node, unsigned indx)
+{
+  *((CPpmd_Void_Ref *)node) = p->FreeList[indx];
+  p->FreeList[indx] = REF(node);
+}
+
+static void *RemoveNode(CPpmd7 *p, unsigned indx)
+{
+  CPpmd_Void_Ref *node = (CPpmd_Void_Ref *)Ppmd7_GetPtr(p, p->FreeList[indx]);
+  p->FreeList[indx] = *node;
+  return node;
+}
+
+static void SplitBlock(CPpmd7 *p, void *ptr, unsigned oldIndx, unsigned newIndx)
+{
+  unsigned i, nu = I2U(oldIndx) - I2U(newIndx);
+  ptr = (Byte *)ptr + U2B(I2U(newIndx));
+  if (I2U(i = U2I(nu)) != nu)
+  {
+    unsigned k = I2U(--i);
+    InsertNode(p, ((Byte *)ptr) + U2B(k), nu - k - 1);
+  }
+  InsertNode(p, ptr, i);
+}
+
+static void GlueFreeBlocks(CPpmd7 *p)
+{
+  #ifdef PPMD_32BIT
+  CPpmd7_Node headItem;
+  CPpmd7_Node_Ref head = &headItem;
+  #else
+  CPpmd7_Node_Ref head = p->AlignOffset + p->Size;
+  #endif
+
+  CPpmd7_Node_Ref n = head;
+  unsigned i;
+
+  p->GlueCount = 255;
+
+  /* create doubly-linked list of free blocks */
+  for (i = 0; i < PPMD_NUM_INDEXES; i++)
+  {
+    UInt16 nu = I2U(i);
+    CPpmd7_Node_Ref next = (CPpmd7_Node_Ref)p->FreeList[i];
+    p->FreeList[i] = 0;
+    while (next != 0)
+    {
+      CPpmd7_Node *node = NODE(next);
+      node->Next = n;
+      n = NODE(n)->Prev = next;
+      next = *(const CPpmd7_Node_Ref *)node;
+      node->Stamp = 0;
+      node->NU = (UInt16)nu;
+    }
+  }
+  NODE(head)->Stamp = 1;
+  NODE(head)->Next = n;
+  NODE(n)->Prev = head;
+  if (p->LoUnit != p->HiUnit)
+    ((CPpmd7_Node *)p->LoUnit)->Stamp = 1;
+
+  /* Glue free blocks */
+  while (n != head)
+  {
+    CPpmd7_Node *node = NODE(n);
+    UInt32 nu = (UInt32)node->NU;
+    for (;;)
+    {
+      CPpmd7_Node *node2 = NODE(n) + nu;
+      nu += node2->NU;
+      if (node2->Stamp != 0 || nu >= 0x10000)
+        break;
+      NODE(node2->Prev)->Next = node2->Next;
+      NODE(node2->Next)->Prev = node2->Prev;
+      node->NU = (UInt16)nu;
+    }
+    n = node->Next;
+  }
+
+  /* Fill lists of free blocks */
+  for (n = NODE(head)->Next; n != head;)
+  {
+    CPpmd7_Node *node = NODE(n);
+    unsigned nu;
+    CPpmd7_Node_Ref next = node->Next;
+    for (nu = node->NU; nu > 128; nu -= 128, node += 128)
+      InsertNode(p, node, PPMD_NUM_INDEXES - 1);
+    if (I2U(i = U2I(nu)) != nu)
+    {
+      unsigned k = I2U(--i);
+      InsertNode(p, node + k, nu - k - 1);
+    }
+    InsertNode(p, node, i);
+    n = next;
+  }
+}
+
+static void *AllocUnitsRare(CPpmd7 *p, unsigned indx)
+{
+  unsigned i;
+  void *retVal;
+  if (p->GlueCount == 0)
+  {
+    GlueFreeBlocks(p);
+    if (p->FreeList[indx] != 0)
+      return RemoveNode(p, indx);
+  }
+  i = indx;
+  do
+  {
+    if (++i == PPMD_NUM_INDEXES)
+    {
+      UInt32 numBytes = U2B(I2U(indx));
+      p->GlueCount--;
+      return ((UInt32)(p->UnitsStart - p->Text) > numBytes) ? (p->UnitsStart -= numBytes) : (NULL);
+    }
+  }
+  while (p->FreeList[i] == 0);
+  retVal = RemoveNode(p, i);
+  SplitBlock(p, retVal, i, indx);
+  return retVal;
+}
+
+static void *AllocUnits(CPpmd7 *p, unsigned indx)
+{
+  UInt32 numBytes;
+  if (p->FreeList[indx] != 0)
+    return RemoveNode(p, indx);
+  numBytes = U2B(I2U(indx));
+  if (numBytes <= (UInt32)(p->HiUnit - p->LoUnit))
+  {
+    void *retVal = p->LoUnit;
+    p->LoUnit += numBytes;
+    return retVal;
+  }
+  return AllocUnitsRare(p, indx);
+}
+
+#define MyMem12Cpy(dest, src, num) \
+  { UInt32 *d = (UInt32 *)dest; const UInt32 *s = (const UInt32 *)src; UInt32 n = num; \
+    do { d[0] = s[0]; d[1] = s[1]; d[2] = s[2]; s += 3; d += 3; } while(--n); }
+
+static void *ShrinkUnits(CPpmd7 *p, void *oldPtr, unsigned oldNU, unsigned newNU)
+{
+  unsigned i0 = U2I(oldNU);
+  unsigned i1 = U2I(newNU);
+  if (i0 == i1)
+    return oldPtr;
+  if (p->FreeList[i1] != 0)
+  {
+    void *ptr = RemoveNode(p, i1);
+    MyMem12Cpy(ptr, oldPtr, newNU);
+    InsertNode(p, oldPtr, i0);
+    return ptr;
+  }
+  SplitBlock(p, oldPtr, i0, i1);
+  return oldPtr;
+}
+
+#define SUCCESSOR(p) ((CPpmd_Void_Ref)((p)->SuccessorLow | ((UInt32)(p)->SuccessorHigh << 16)))
+
+static void SetSuccessor(CPpmd_State *p, CPpmd_Void_Ref v)
+{
+  (p)->SuccessorLow = (UInt16)((UInt32)(v) & 0xFFFF);
+  (p)->SuccessorHigh = (UInt16)(((UInt32)(v) >> 16) & 0xFFFF);
+}
+
+static void RestartModel(CPpmd7 *p)
+{
+  unsigned i, k, m;
+
+  memset(p->FreeList, 0, sizeof(p->FreeList));
+  p->Text = p->Base + p->AlignOffset;
+  p->HiUnit = p->Text + p->Size;
+  p->LoUnit = p->UnitsStart = p->HiUnit - p->Size / 8 / UNIT_SIZE * 7 * UNIT_SIZE;
+  p->GlueCount = 0;
+
+  p->OrderFall = p->MaxOrder;
+  p->RunLength = p->InitRL = -(Int32)((p->MaxOrder < 12) ? p->MaxOrder : 12) - 1;
+  p->PrevSuccess = 0;
+
+  p->MinContext = p->MaxContext = (CTX_PTR)(p->HiUnit -= UNIT_SIZE); /* AllocContext(p); */
+  p->MinContext->Suffix = 0;
+  p->MinContext->NumStats = 256;
+  p->MinContext->SummFreq = 256 + 1;
+  p->FoundState = (CPpmd_State *)p->LoUnit; /* AllocUnits(p, PPMD_NUM_INDEXES - 1); */
+  p->LoUnit += U2B(256 / 2);
+  p->MinContext->Stats = REF(p->FoundState);
+  for (i = 0; i < 256; i++)
+  {
+    CPpmd_State *s = &p->FoundState[i];
+    s->Symbol = (Byte)i;
+    s->Freq = 1;
+    SetSuccessor(s, 0);
+  }
+
+  for (i = 0; i < 128; i++)
+    for (k = 0; k < 8; k++)
+    {
+      UInt16 *dest = p->BinSumm[i] + k;
+      UInt16 val = (UInt16)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));
+      for (m = 0; m < 64; m += 8)
+        dest[m] = val;
+    }
+
+  for (i = 0; i < 25; i++)
+    for (k = 0; k < 16; k++)
+    {
+      CPpmd_See *s = &p->See[i][k];
+      s->Summ = (UInt16)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));
+      s->Count = 4;
+    }
+}
+
+void Ppmd7_Init(CPpmd7 *p, unsigned maxOrder)
+{
+  p->MaxOrder = maxOrder;
+  RestartModel(p);
+  p->DummySee.Shift = PPMD_PERIOD_BITS;
+  p->DummySee.Summ = 0; /* unused */
+  p->DummySee.Count = 64; /* unused */
+}
+
+static CTX_PTR CreateSuccessors(CPpmd7 *p, Bool skip)
+{
+  CPpmd_State upState;
+  CTX_PTR c = p->MinContext;
+  CPpmd_Byte_Ref upBranch = (CPpmd_Byte_Ref)SUCCESSOR(p->FoundState);
+  CPpmd_State *ps[PPMD7_MAX_ORDER];
+  unsigned numPs = 0;
+
+  if (!skip)
+    ps[numPs++] = p->FoundState;
+
+  while (c->Suffix)
+  {
+    CPpmd_Void_Ref successor;
+    CPpmd_State *s;
+    c = SUFFIX(c);
+    if (c->NumStats != 1)
+    {
+      for (s = STATS(c); s->Symbol != p->FoundState->Symbol; s++);
+    }
+    else
+      s = ONE_STATE(c);
+    successor = SUCCESSOR(s);
+    if (successor != upBranch)
+    {
+      c = CTX(successor);
+      if (numPs == 0)
+        return c;
+      break;
+    }
+    ps[numPs++] = s;
+  }
+
+  upState.Symbol = *(const Byte *)Ppmd7_GetPtr(p, upBranch);
+  SetSuccessor(&upState, upBranch + 1);
+
+  if (c->NumStats == 1)
+    upState.Freq = ONE_STATE(c)->Freq;
+  else
+  {
+    UInt32 cf, s0;
+    CPpmd_State *s;
+    for (s = STATS(c); s->Symbol != upState.Symbol; s++);
+    cf = s->Freq - 1;
+    s0 = c->SummFreq - c->NumStats - cf;
+    upState.Freq = (Byte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((2 * cf + 3 * s0 - 1) / (2 * s0))));
+  }
+
+  do
+  {
+    /* Create Child */
+    CTX_PTR c1; /* = AllocContext(p); */
+    if (p->HiUnit != p->LoUnit)
+      c1 = (CTX_PTR)(p->HiUnit -= UNIT_SIZE);
+    else if (p->FreeList[0] != 0)
+      c1 = (CTX_PTR)RemoveNode(p, 0);
+    else
+    {
+      c1 = (CTX_PTR)AllocUnitsRare(p, 0);
+      if (!c1)
+        return NULL;
+    }
+    c1->NumStats = 1;
+    *ONE_STATE(c1) = upState;
+    c1->Suffix = REF(c);
+    SetSuccessor(ps[--numPs], REF(c1));
+    c = c1;
+  }
+  while (numPs != 0);
+
+  return c;
+}
+
+static void SwapStates(CPpmd_State *t1, CPpmd_State *t2)
+{
+  CPpmd_State tmp = *t1;
+  *t1 = *t2;
+  *t2 = tmp;
+}
+
+static void UpdateModel(CPpmd7 *p)
+{
+  CPpmd_Void_Ref successor, fSuccessor = SUCCESSOR(p->FoundState);
+  CTX_PTR c;
+  unsigned s0, ns;
+
+  if (p->FoundState->Freq < MAX_FREQ / 4 && p->MinContext->Suffix != 0)
+  {
+    c = SUFFIX(p->MinContext);
+
+    if (c->NumStats == 1)
+    {
+      CPpmd_State *s = ONE_STATE(c);
+      if (s->Freq < 32)
+        s->Freq++;
+    }
+    else
+    {
+      CPpmd_State *s = STATS(c);
+      if (s->Symbol != p->FoundState->Symbol)
+      {
+        do { s++; } while (s->Symbol != p->FoundState->Symbol);
+        if (s[0].Freq >= s[-1].Freq)
+        {
+          SwapStates(&s[0], &s[-1]);
+          s--;
+        }
+      }
+      if (s->Freq < MAX_FREQ - 9)
+      {
+        s->Freq += 2;
+        c->SummFreq += 2;
+      }
+    }
+  }
+
+  if (p->OrderFall == 0)
+  {
+    p->MinContext = p->MaxContext = CreateSuccessors(p, True);
+    if (p->MinContext == 0)
+    {
+      RestartModel(p);
+      return;
+    }
+    SetSuccessor(p->FoundState, REF(p->MinContext));
+    return;
+  }
+
+  *p->Text++ = p->FoundState->Symbol;
+  successor = REF(p->Text);
+  if (p->Text >= p->UnitsStart)
+  {
+    RestartModel(p);
+    return;
+  }
+
+  if (fSuccessor)
+  {
+    if (fSuccessor <= successor)
+    {
+      CTX_PTR cs = CreateSuccessors(p, False);
+      if (cs == NULL)
+      {
+        RestartModel(p);
+        return;
+      }
+      fSuccessor = REF(cs);
+    }
+    if (--p->OrderFall == 0)
+    {
+      successor = fSuccessor;
+      p->Text -= (p->MaxContext != p->MinContext);
+    }
+  }
+  else
+  {
+    SetSuccessor(p->FoundState, successor);
+    fSuccessor = REF(p->MinContext);
+  }
+
+  s0 = p->MinContext->SummFreq - (ns = p->MinContext->NumStats) - (p->FoundState->Freq - 1);
+
+  for (c = p->MaxContext; c != p->MinContext; c = SUFFIX(c))
+  {
+    unsigned ns1;
+    UInt32 cf, sf;
+    if ((ns1 = c->NumStats) != 1)
+    {
+      if ((ns1 & 1) == 0)
+      {
+        /* Expand for one UNIT */
+        unsigned oldNU = ns1 >> 1;
+        unsigned i = U2I(oldNU);
+        if (i != U2I(oldNU + 1))
+        {
+          void *ptr = AllocUnits(p, i + 1);
+          void *oldPtr;
+          if (!ptr)
+          {
+            RestartModel(p);
+            return;
+          }
+          oldPtr = STATS(c);
+          MyMem12Cpy(ptr, oldPtr, oldNU);
+          InsertNode(p, oldPtr, i);
+          c->Stats = STATS_REF(ptr);
+        }
+      }
+      c->SummFreq = (UInt16)(c->SummFreq + (2 * ns1 < ns) + 2 * ((4 * ns1 <= ns) & (c->SummFreq <= 8 * ns1)));
+    }
+    else
+    {
+      CPpmd_State *s = (CPpmd_State*)AllocUnits(p, 0);
+      if (!s)
+      {
+        RestartModel(p);
+        return;
+      }
+      *s = *ONE_STATE(c);
+      c->Stats = REF(s);
+      if (s->Freq < MAX_FREQ / 4 - 1)
+        s->Freq <<= 1;
+      else
+        s->Freq = MAX_FREQ - 4;
+      c->SummFreq = (UInt16)(s->Freq + p->InitEsc + (ns > 3));
+    }
+    cf = 2 * (UInt32)p->FoundState->Freq * (c->SummFreq + 6);
+    sf = (UInt32)s0 + c->SummFreq;
+    if (cf < 6 * sf)
+    {
+      cf = 1 + (cf > sf) + (cf >= 4 * sf);
+      c->SummFreq += 3;
+    }
+    else
+    {
+      cf = 4 + (cf >= 9 * sf) + (cf >= 12 * sf) + (cf >= 15 * sf);
+      c->SummFreq = (UInt16)(c->SummFreq + cf);
+    }
+    {
+      CPpmd_State *s = STATS(c) + ns1;
+      SetSuccessor(s, successor);
+      s->Symbol = p->FoundState->Symbol;
+      s->Freq = (Byte)cf;
+      c->NumStats = (UInt16)(ns1 + 1);
+    }
+  }
+  p->MaxContext = p->MinContext = CTX(fSuccessor);
+}
+
+static void Rescale(CPpmd7 *p)
+{
+  unsigned i, adder, sumFreq, escFreq;
+  CPpmd_State *stats = STATS(p->MinContext);
+  CPpmd_State *s = p->FoundState;
+  {
+    CPpmd_State tmp = *s;
+    for (; s != stats; s--)
+      s[0] = s[-1];
+    *s = tmp;
+  }
+  escFreq = p->MinContext->SummFreq - s->Freq;
+  s->Freq += 4;
+  adder = (p->OrderFall != 0);
+  s->Freq = (Byte)((s->Freq + adder) >> 1);
+  sumFreq = s->Freq;
+
+  i = p->MinContext->NumStats - 1;
+  do
+  {
+    escFreq -= (++s)->Freq;
+    s->Freq = (Byte)((s->Freq + adder) >> 1);
+    sumFreq += s->Freq;
+    if (s[0].Freq > s[-1].Freq)
+    {
+      CPpmd_State *s1 = s;
+      CPpmd_State tmp = *s1;
+      do
+        s1[0] = s1[-1];
+      while (--s1 != stats && tmp.Freq > s1[-1].Freq);
+      *s1 = tmp;
+    }
+  }
+  while (--i);
+
+  if (s->Freq == 0)
+  {
+    unsigned numStats = p->MinContext->NumStats;
+    unsigned n0, n1;
+    do { i++; } while ((--s)->Freq == 0);
+    escFreq += i;
+    p->MinContext->NumStats = (UInt16)(p->MinContext->NumStats - i);
+    if (p->MinContext->NumStats == 1)
+    {
+      CPpmd_State tmp = *stats;
+      do
+      {
+        tmp.Freq = (Byte)(tmp.Freq - (tmp.Freq >> 1));
+        escFreq >>= 1;
+      }
+      while (escFreq > 1);
+      InsertNode(p, stats, U2I(((numStats + 1) >> 1)));
+      *(p->FoundState = ONE_STATE(p->MinContext)) = tmp;
+      return;
+    }
+    n0 = (numStats + 1) >> 1;
+    n1 = (p->MinContext->NumStats + 1) >> 1;
+    if (n0 != n1)
+      p->MinContext->Stats = STATS_REF(ShrinkUnits(p, stats, n0, n1));
+  }
+  p->MinContext->SummFreq = (UInt16)(sumFreq + escFreq - (escFreq >> 1));
+  p->FoundState = STATS(p->MinContext);
+}
+
+CPpmd_See *Ppmd7_MakeEscFreq(CPpmd7 *p, unsigned numMasked, UInt32 *escFreq)
+{
+  CPpmd_See *see;
+  unsigned nonMasked = p->MinContext->NumStats - numMasked;
+  if (p->MinContext->NumStats != 256)
+  {
+    see = p->See[p->NS2Indx[nonMasked - 1]] +
+        (nonMasked < (unsigned)SUFFIX(p->MinContext)->NumStats - p->MinContext->NumStats) +
+        2 * (p->MinContext->SummFreq < 11 * p->MinContext->NumStats) +
+        4 * (numMasked > nonMasked) +
+        p->HiBitsFlag;
+    {
+      unsigned r = (see->Summ >> see->Shift);
+      see->Summ = (UInt16)(see->Summ - r);
+      *escFreq = r + (r == 0);
+    }
+  }
+  else
+  {
+    see = &p->DummySee;
+    *escFreq = 1;
+  }
+  return see;
+}
+
+static void NextContext(CPpmd7 *p)
+{
+  CTX_PTR c = CTX(SUCCESSOR(p->FoundState));
+  if (p->OrderFall == 0 && (Byte *)c > p->Text)
+    p->MinContext = p->MaxContext = c;
+  else
+    UpdateModel(p);
+}
+
+void Ppmd7_Update1(CPpmd7 *p)
+{
+  CPpmd_State *s = p->FoundState;
+  s->Freq += 4;
+  p->MinContext->SummFreq += 4;
+  if (s[0].Freq > s[-1].Freq)
+  {
+    SwapStates(&s[0], &s[-1]);
+    p->FoundState = --s;
+    if (s->Freq > MAX_FREQ)
+      Rescale(p);
+  }
+  NextContext(p);
+}
+
+void Ppmd7_Update1_0(CPpmd7 *p)
+{
+  p->PrevSuccess = (2 * p->FoundState->Freq > p->MinContext->SummFreq);
+  p->RunLength += p->PrevSuccess;
+  p->MinContext->SummFreq += 4;
+  if ((p->FoundState->Freq += 4) > MAX_FREQ)
+    Rescale(p);
+  NextContext(p);
+}
+
+void Ppmd7_UpdateBin(CPpmd7 *p)
+{
+  p->FoundState->Freq = (Byte)(p->FoundState->Freq + (p->FoundState->Freq < 128 ? 1: 0));
+  p->PrevSuccess = 1;
+  p->RunLength++;
+  NextContext(p);
+}
+
+void Ppmd7_Update2(CPpmd7 *p)
+{
+  p->MinContext->SummFreq += 4;
+  if ((p->FoundState->Freq += 4) > MAX_FREQ)
+    Rescale(p);
+  p->RunLength = p->InitRL;
+  UpdateModel(p);
+}
diff -Nru src-old/lib/lib7z/Ppmd7.h src/lib/lib7z/Ppmd7.h
--- src-old/lib/lib7z/Ppmd7.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd7.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,140 @@
+/* Ppmd7.h -- PPMdH compression codec
+2010-03-12 : Igor Pavlov : Public domain
+This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
+
+/* This code supports virtual RangeDecoder and includes the implementation
+of RangeCoder from 7z, instead of RangeCoder from original PPMd var.H.
+If you need the compatibility with original PPMd var.H, you can use external RangeDecoder */
+
+#ifndef __PPMD7_H
+#define __PPMD7_H
+
+#include "Ppmd.h"
+
+EXTERN_C_BEGIN
+
+#define PPMD7_MIN_ORDER 2
+#define PPMD7_MAX_ORDER 64
+
+#define PPMD7_MIN_MEM_SIZE (1 << 11)
+#define PPMD7_MAX_MEM_SIZE (0xFFFFFFFF - 12 * 3)
+
+struct CPpmd7_Context_;
+
+typedef
+  #ifdef PPMD_32BIT
+    struct CPpmd7_Context_ *
+  #else
+    UInt32
+  #endif
+  CPpmd7_Context_Ref;
+
+typedef struct CPpmd7_Context_
+{
+  UInt16 NumStats;
+  UInt16 SummFreq;
+  CPpmd_State_Ref Stats;
+  CPpmd7_Context_Ref Suffix;
+} CPpmd7_Context;
+
+#define Ppmd7Context_OneState(p) ((CPpmd_State *)&(p)->SummFreq)
+
+typedef struct
+{
+  CPpmd7_Context *MinContext, *MaxContext;
+  CPpmd_State *FoundState;
+  unsigned OrderFall, InitEsc, PrevSuccess, MaxOrder, HiBitsFlag;
+  Int32 RunLength, InitRL; /* must be 32-bit at least */
+
+  UInt32 Size;
+  UInt32 GlueCount;
+  Byte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;
+  UInt32 AlignOffset;
+
+  Byte Indx2Units[PPMD_NUM_INDEXES];
+  Byte Units2Indx[128];
+  CPpmd_Void_Ref FreeList[PPMD_NUM_INDEXES];
+  Byte NS2Indx[256], NS2BSIndx[256], HB2Flag[256];
+  CPpmd_See DummySee, See[25][16];
+  UInt16 BinSumm[128][64];
+} CPpmd7;
+
+void Ppmd7_Construct(CPpmd7 *p);
+Bool Ppmd7_Alloc(CPpmd7 *p, UInt32 size, ISzAlloc *alloc);
+void Ppmd7_Free(CPpmd7 *p, ISzAlloc *alloc);
+void Ppmd7_Init(CPpmd7 *p, unsigned maxOrder);
+#define Ppmd7_WasAllocated(p) ((p)->Base != NULL)
+
+
+/* ---------- Internal Functions ---------- */
+
+extern const Byte PPMD7_kExpEscape[16];
+
+#ifdef PPMD_32BIT
+  #define Ppmd7_GetPtr(p, ptr) (ptr)
+  #define Ppmd7_GetContext(p, ptr) (ptr)
+  #define Ppmd7_GetStats(p, ctx) ((ctx)->Stats)
+#else
+  #define Ppmd7_GetPtr(p, offs) ((void *)((p)->Base + (offs)))
+  #define Ppmd7_GetContext(p, offs) ((CPpmd7_Context *)Ppmd7_GetPtr((p), (offs)))
+  #define Ppmd7_GetStats(p, ctx) ((CPpmd_State *)Ppmd7_GetPtr((p), ((ctx)->Stats)))
+#endif
+
+void Ppmd7_Update1(CPpmd7 *p);
+void Ppmd7_Update1_0(CPpmd7 *p);
+void Ppmd7_Update2(CPpmd7 *p);
+void Ppmd7_UpdateBin(CPpmd7 *p);
+
+#define Ppmd7_GetBinSumm(p) \
+    &p->BinSumm[Ppmd7Context_OneState(p->MinContext)->Freq - 1][p->PrevSuccess + \
+    p->NS2BSIndx[Ppmd7_GetContext(p, p->MinContext->Suffix)->NumStats - 1] + \
+    (p->HiBitsFlag = p->HB2Flag[p->FoundState->Symbol]) + \
+    2 * p->HB2Flag[Ppmd7Context_OneState(p->MinContext)->Symbol] + \
+    ((p->RunLength >> 26) & 0x20)]
+
+CPpmd_See *Ppmd7_MakeEscFreq(CPpmd7 *p, unsigned numMasked, UInt32 *scale);
+
+
+/* ---------- Decode ---------- */
+
+typedef struct
+{
+  UInt32 (*GetThreshold)(void *p, UInt32 total);
+  void (*Decode)(void *p, UInt32 start, UInt32 size);
+  UInt32 (*DecodeBit)(void *p, UInt32 size0);
+} IPpmd7_RangeDec;
+
+typedef struct
+{
+  IPpmd7_RangeDec p;
+  UInt32 Range;
+  UInt32 Code;
+  IByteIn *Stream;
+} CPpmd7z_RangeDec;
+
+void Ppmd7z_RangeDec_CreateVTable(CPpmd7z_RangeDec *p);
+Bool Ppmd7z_RangeDec_Init(CPpmd7z_RangeDec *p);
+#define Ppmd7z_RangeDec_IsFinishedOK(p) ((p)->Code == 0)
+
+int Ppmd7_DecodeSymbol(CPpmd7 *p, IPpmd7_RangeDec *rc);
+
+
+/* ---------- Encode ---------- */
+
+typedef struct
+{
+  UInt64 Low;
+  UInt32 Range;
+  Byte Cache;
+  UInt64 CacheSize;
+  IByteOut *Stream;
+} CPpmd7z_RangeEnc;
+
+void Ppmd7z_RangeEnc_Init(CPpmd7z_RangeEnc *p);
+void Ppmd7z_RangeEnc_FlushData(CPpmd7z_RangeEnc *p);
+
+void Ppmd7_EncodeSymbol(CPpmd7 *p, CPpmd7z_RangeEnc *rc, int symbol);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Ppmd7Dec.c src/lib/lib7z/Ppmd7Dec.c
--- src-old/lib/lib7z/Ppmd7Dec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd7Dec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,187 @@
+/* Ppmd7Dec.c -- PPMdH Decoder
+2010-03-12 : Igor Pavlov : Public domain
+This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
+
+#include "Ppmd7.h"
+
+#define kTopValue (1 << 24)
+
+Bool Ppmd7z_RangeDec_Init(CPpmd7z_RangeDec *p)
+{
+  unsigned i;
+  p->Code = 0;
+  p->Range = 0xFFFFFFFF;
+  if (p->Stream->Read((void *)p->Stream) != 0)
+    return False;
+  for (i = 0; i < 4; i++)
+    p->Code = (p->Code << 8) | p->Stream->Read((void *)p->Stream);
+  return (p->Code < 0xFFFFFFFF);
+}
+
+static UInt32 Range_GetThreshold(void *pp, UInt32 total)
+{
+  CPpmd7z_RangeDec *p = (CPpmd7z_RangeDec *)pp;
+  return (p->Code) / (p->Range /= total);
+}
+
+static void Range_Normalize(CPpmd7z_RangeDec *p)
+{
+  if (p->Range < kTopValue)
+  {
+    p->Code = (p->Code << 8) | p->Stream->Read((void *)p->Stream);
+    p->Range <<= 8;
+    if (p->Range < kTopValue)
+    {
+      p->Code = (p->Code << 8) | p->Stream->Read((void *)p->Stream);
+      p->Range <<= 8;
+    }
+  }
+}
+
+static void Range_Decode(void *pp, UInt32 start, UInt32 size)
+{
+  CPpmd7z_RangeDec *p = (CPpmd7z_RangeDec *)pp;
+  p->Code -= start * p->Range;
+  p->Range *= size;
+  Range_Normalize(p);
+}
+
+static UInt32 Range_DecodeBit(void *pp, UInt32 size0)
+{
+  CPpmd7z_RangeDec *p = (CPpmd7z_RangeDec *)pp;
+  UInt32 newBound = (p->Range >> 14) * size0;
+  UInt32 symbol;
+  if (p->Code < newBound)
+  {
+    symbol = 0;
+    p->Range = newBound;
+  }
+  else
+  {
+    symbol = 1;
+    p->Code -= newBound;
+    p->Range -= newBound;
+  }
+  Range_Normalize(p);
+  return symbol;
+}
+
+void Ppmd7z_RangeDec_CreateVTable(CPpmd7z_RangeDec *p)
+{
+  p->p.GetThreshold = Range_GetThreshold;
+  p->p.Decode = Range_Decode;
+  p->p.DecodeBit = Range_DecodeBit;
+}
+
+
+#define MASK(sym) ((signed char *)charMask)[sym]
+
+int Ppmd7_DecodeSymbol(CPpmd7 *p, IPpmd7_RangeDec *rc)
+{
+  size_t charMask[256 / sizeof(size_t)];
+  if (p->MinContext->NumStats != 1)
+  {
+    CPpmd_State *s = Ppmd7_GetStats(p, p->MinContext);
+    unsigned i;
+    UInt32 count, hiCnt;
+    if ((count = rc->GetThreshold(rc, p->MinContext->SummFreq)) < (hiCnt = s->Freq))
+    {
+      Byte symbol;
+      rc->Decode(rc, 0, s->Freq);
+      p->FoundState = s;
+      symbol = s->Symbol;
+      Ppmd7_Update1_0(p);
+      return symbol;
+    }
+    p->PrevSuccess = 0;
+    i = p->MinContext->NumStats - 1;
+    do
+    {
+      if ((hiCnt += (++s)->Freq) > count)
+      {
+        Byte symbol;
+        rc->Decode(rc, hiCnt - s->Freq, s->Freq);
+        p->FoundState = s;
+        symbol = s->Symbol;
+        Ppmd7_Update1(p);
+        return symbol;
+      }
+    }
+    while (--i);
+    if (count >= p->MinContext->SummFreq)
+      return -2;
+    p->HiBitsFlag = p->HB2Flag[p->FoundState->Symbol];
+    rc->Decode(rc, hiCnt, p->MinContext->SummFreq - hiCnt);
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(s->Symbol) = 0;
+    i = p->MinContext->NumStats - 1;
+    do { MASK((--s)->Symbol) = 0; } while (--i);
+  }
+  else
+  {
+    UInt16 *prob = Ppmd7_GetBinSumm(p);
+    if (rc->DecodeBit(rc, *prob) == 0)
+    {
+      Byte symbol;
+      *prob = (UInt16)PPMD_UPDATE_PROB_0(*prob);
+      symbol = (p->FoundState = Ppmd7Context_OneState(p->MinContext))->Symbol;
+      Ppmd7_UpdateBin(p);
+      return symbol;
+    }
+    *prob = (UInt16)PPMD_UPDATE_PROB_1(*prob);
+    p->InitEsc = PPMD7_kExpEscape[*prob >> 10];
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(Ppmd7Context_OneState(p->MinContext)->Symbol) = 0;
+    p->PrevSuccess = 0;
+  }
+  for (;;)
+  {
+    CPpmd_State *ps[256], *s;
+    UInt32 freqSum, count, hiCnt;
+    CPpmd_See *see;
+    unsigned i, num, numMasked = p->MinContext->NumStats;
+    do
+    {
+      p->OrderFall++;
+      if (!p->MinContext->Suffix)
+        return -1;
+      p->MinContext = Ppmd7_GetContext(p, p->MinContext->Suffix);
+    }
+    while (p->MinContext->NumStats == numMasked);
+    hiCnt = 0;
+    s = Ppmd7_GetStats(p, p->MinContext);
+    i = 0;
+    num = p->MinContext->NumStats - numMasked;
+    do
+    {
+      int k = (int)(MASK(s->Symbol));
+      hiCnt += (s->Freq & k);
+      ps[i] = s++;
+      i -= k;
+    }
+    while (i != num);
+
+    see = Ppmd7_MakeEscFreq(p, numMasked, &freqSum);
+    freqSum += hiCnt;
+    count = rc->GetThreshold(rc, freqSum);
+
+    if (count < hiCnt)
+    {
+      Byte symbol;
+      CPpmd_State **pps = ps;
+      for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++);
+      s = *pps;
+      rc->Decode(rc, hiCnt - s->Freq, s->Freq);
+      Ppmd_See_Update(see);
+      p->FoundState = s;
+      symbol = s->Symbol;
+      Ppmd7_Update2(p);
+      return symbol;
+    }
+    if (count >= freqSum)
+      return -2;
+    rc->Decode(rc, hiCnt, freqSum - hiCnt);
+    see->Summ = (UInt16)(see->Summ + freqSum);
+    do { MASK(ps[--i]->Symbol) = 0; } while (i != 0);
+  }
+}
diff -Nru src-old/lib/lib7z/Ppmd7Enc.c src/lib/lib7z/Ppmd7Enc.c
--- src-old/lib/lib7z/Ppmd7Enc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd7Enc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,185 @@
+/* Ppmd7Enc.c -- PPMdH Encoder
+2010-03-12 : Igor Pavlov : Public domain
+This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
+
+#include "Ppmd7.h"
+
+#define kTopValue (1 << 24)
+
+void Ppmd7z_RangeEnc_Init(CPpmd7z_RangeEnc *p)
+{
+  p->Low = 0;
+  p->Range = 0xFFFFFFFF;
+  p->Cache = 0;
+  p->CacheSize = 1;
+}
+
+static void RangeEnc_ShiftLow(CPpmd7z_RangeEnc *p)
+{
+  if ((UInt32)p->Low < (UInt32)0xFF000000 || (unsigned)(p->Low >> 32) != 0)
+  {
+    Byte temp = p->Cache;
+    do
+    {
+      p->Stream->Write(p->Stream, (Byte)(temp + (Byte)(p->Low >> 32)));
+      temp = 0xFF;
+    }
+    while(--p->CacheSize != 0);
+    p->Cache = (Byte)((UInt32)p->Low >> 24);
+  }
+  p->CacheSize++;
+  p->Low = (UInt32)p->Low << 8;
+}
+
+static void RangeEnc_Encode(CPpmd7z_RangeEnc *p, UInt32 start, UInt32 size, UInt32 total)
+{
+  p->Low += start * (p->Range /= total);
+  p->Range *= size;
+  while (p->Range < kTopValue)
+  {
+    p->Range <<= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void RangeEnc_EncodeBit_0(CPpmd7z_RangeEnc *p, UInt32 size0)
+{
+  p->Range = (p->Range >> 14) * size0;
+  while (p->Range < kTopValue)
+  {
+    p->Range <<= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void RangeEnc_EncodeBit_1(CPpmd7z_RangeEnc *p, UInt32 size0)
+{
+  UInt32 newBound = (p->Range >> 14) * size0;
+  p->Low += newBound;
+  p->Range -= newBound;
+  while (p->Range < kTopValue)
+  {
+    p->Range <<= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+void Ppmd7z_RangeEnc_FlushData(CPpmd7z_RangeEnc *p)
+{
+  unsigned i;
+  for (i = 0; i < 5; i++)
+    RangeEnc_ShiftLow(p);
+}
+
+
+#define MASK(sym) ((signed char *)charMask)[sym]
+
+void Ppmd7_EncodeSymbol(CPpmd7 *p, CPpmd7z_RangeEnc *rc, int symbol)
+{
+  size_t charMask[256 / sizeof(size_t)];
+  if (p->MinContext->NumStats != 1)
+  {
+    CPpmd_State *s = Ppmd7_GetStats(p, p->MinContext);
+    UInt32 sum;
+    unsigned i;
+    if (s->Symbol == symbol)
+    {
+      RangeEnc_Encode(rc, 0, s->Freq, p->MinContext->SummFreq);
+      p->FoundState = s;
+      Ppmd7_Update1_0(p);
+      return;
+    }
+    p->PrevSuccess = 0;
+    sum = s->Freq;
+    i = p->MinContext->NumStats - 1;
+    do
+    {
+      if ((++s)->Symbol == symbol)
+      {
+        RangeEnc_Encode(rc, sum, s->Freq, p->MinContext->SummFreq);
+        p->FoundState = s;
+        Ppmd7_Update1(p);
+        return;
+      }
+      sum += s->Freq;
+    }
+    while (--i);
+
+    p->HiBitsFlag = p->HB2Flag[p->FoundState->Symbol];
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(s->Symbol) = 0;
+    i = p->MinContext->NumStats - 1;
+    do { MASK((--s)->Symbol) = 0; } while (--i);
+    RangeEnc_Encode(rc, sum, p->MinContext->SummFreq - sum, p->MinContext->SummFreq);
+  }
+  else
+  {
+    UInt16 *prob = Ppmd7_GetBinSumm(p);
+    CPpmd_State *s = Ppmd7Context_OneState(p->MinContext);
+    if (s->Symbol == symbol)
+    {
+      RangeEnc_EncodeBit_0(rc, *prob);
+      *prob = (UInt16)PPMD_UPDATE_PROB_0(*prob);
+      p->FoundState = s;
+      Ppmd7_UpdateBin(p);
+      return;
+    }
+    else
+    {
+      RangeEnc_EncodeBit_1(rc, *prob);
+      *prob = (UInt16)PPMD_UPDATE_PROB_1(*prob);
+      p->InitEsc = PPMD7_kExpEscape[*prob >> 10];
+      PPMD_SetAllBitsIn256Bytes(charMask);
+      MASK(s->Symbol) = 0;
+      p->PrevSuccess = 0;
+    }
+  }
+  for (;;)
+  {
+    UInt32 escFreq;
+    CPpmd_See *see;
+    CPpmd_State *s;
+    UInt32 sum;
+    unsigned i, numMasked = p->MinContext->NumStats;
+    do
+    {
+      p->OrderFall++;
+      if (!p->MinContext->Suffix)
+        return; /* EndMarker (symbol = -1) */
+      p->MinContext = Ppmd7_GetContext(p, p->MinContext->Suffix);
+    }
+    while (p->MinContext->NumStats == numMasked);
+
+    see = Ppmd7_MakeEscFreq(p, numMasked, &escFreq);
+    s = Ppmd7_GetStats(p, p->MinContext);
+    sum = 0;
+    i = p->MinContext->NumStats;
+    do
+    {
+      int cur = s->Symbol;
+      if (cur == symbol)
+      {
+        UInt32 low = sum;
+        CPpmd_State *s1 = s;
+        do
+        {
+          sum += (s->Freq & (int)(MASK(s->Symbol)));
+          s++;
+        }
+        while (--i);
+        RangeEnc_Encode(rc, low, s1->Freq, sum + escFreq);
+        Ppmd_See_Update(see);
+        p->FoundState = s1;
+        Ppmd7_Update2(p);
+        return;
+      }
+      sum += (s->Freq & (int)(MASK(cur)));
+      MASK(cur) = 0;
+      s++;
+    }
+    while (--i);
+
+    RangeEnc_Encode(rc, sum, escFreq, sum + escFreq);
+    see->Summ = (UInt16)(see->Summ + sum + escFreq);
+  }
+}
diff -Nru src-old/lib/lib7z/Ppmd8.c src/lib/lib7z/Ppmd8.c
--- src-old/lib/lib7z/Ppmd8.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd8.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,1120 @@
+/* Ppmd8.c -- PPMdI codec
+2010-03-24 : Igor Pavlov : Public domain
+This code is based on PPMd var.I (2002): Dmitry Shkarin : Public domain */
+
+#include <memory.h>
+
+#include "Ppmd8.h"
+
+const Byte PPMD8_kExpEscape[16] = { 25, 14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
+static const UInt16 kInitBinEsc[] = { 0x3CDD, 0x1F3F, 0x59BF, 0x48F3, 0x64A1, 0x5ABC, 0x6632, 0x6051};
+
+#define MAX_FREQ 124
+#define UNIT_SIZE 12
+
+#define U2B(nu) ((UInt32)(nu) * UNIT_SIZE)
+#define U2I(nu) (p->Units2Indx[(nu) - 1])
+#define I2U(indx) (p->Indx2Units[indx])
+
+#ifdef PPMD_32BIT
+  #define REF(ptr) (ptr)
+#else
+  #define REF(ptr) ((UInt32)((Byte *)(ptr) - (p)->Base))
+#endif
+
+#define STATS_REF(ptr) ((CPpmd_State_Ref)REF(ptr))
+
+#define CTX(ref) ((CPpmd8_Context *)Ppmd8_GetContext(p, ref))
+#define STATS(ctx) Ppmd8_GetStats(p, ctx)
+#define ONE_STATE(ctx) Ppmd8Context_OneState(ctx)
+#define SUFFIX(ctx) CTX((ctx)->Suffix)
+
+typedef CPpmd8_Context * CTX_PTR;
+
+struct CPpmd8_Node_;
+
+typedef
+  #ifdef PPMD_32BIT
+    struct CPpmd8_Node_ *
+  #else
+    UInt32
+  #endif
+  CPpmd8_Node_Ref;
+
+typedef struct CPpmd8_Node_
+{
+  UInt32 Stamp;
+  CPpmd8_Node_Ref Next;
+  UInt32 NU;
+} CPpmd8_Node;
+
+#ifdef PPMD_32BIT
+  #define NODE(ptr) (ptr)
+#else
+  #define NODE(offs) ((CPpmd8_Node *)(p->Base + (offs)))
+#endif
+
+#define EMPTY_NODE 0xFFFFFFFF
+
+void Ppmd8_Construct(CPpmd8 *p)
+{
+  unsigned i, k, m;
+
+  p->Base = 0;
+
+  for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)
+  {
+    unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);
+    do { p->Units2Indx[k++] = (Byte)i; } while(--step);
+    p->Indx2Units[i] = (Byte)k;
+  }
+
+  p->NS2BSIndx[0] = (0 << 1);
+  p->NS2BSIndx[1] = (1 << 1);
+  memset(p->NS2BSIndx + 2, (2 << 1), 9);
+  memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);
+
+  for (i = 0; i < 5; i++)
+    p->NS2Indx[i] = (Byte)i;
+  for (m = i, k = 1; i < 260; i++)
+  {
+    p->NS2Indx[i] = (Byte)m;
+    if (--k == 0)
+      k = (++m) - 4;
+  }
+}
+
+void Ppmd8_Free(CPpmd8 *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->Base);
+  p->Size = 0;
+  p->Base = 0;
+}
+
+Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size, ISzAlloc *alloc)
+{
+  if (p->Base == 0 || p->Size != size)
+  {
+    Ppmd8_Free(p, alloc);
+    p->AlignOffset =
+      #ifdef PPMD_32BIT
+        (4 - size) & 3;
+      #else
+        4 - (size & 3);
+      #endif
+    if ((p->Base = (Byte *)alloc->Alloc(alloc, p->AlignOffset + size)) == 0)
+      return False;
+    p->Size = size;
+  }
+  return True;
+}
+
+static void InsertNode(CPpmd8 *p, void *node, unsigned indx)
+{
+  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;
+  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];
+  ((CPpmd8_Node *)node)->NU = I2U(indx);
+  p->FreeList[indx] = REF(node);
+  p->Stamps[indx]++;
+}
+
+static void *RemoveNode(CPpmd8 *p, unsigned indx)
+{
+  CPpmd8_Node *node = NODE((CPpmd8_Node_Ref)p->FreeList[indx]);
+  p->FreeList[indx] = node->Next;
+  p->Stamps[indx]--;
+  return node;
+}
+
+static void SplitBlock(CPpmd8 *p, void *ptr, unsigned oldIndx, unsigned newIndx)
+{
+  unsigned i, nu = I2U(oldIndx) - I2U(newIndx);
+  ptr = (Byte *)ptr + U2B(I2U(newIndx));
+  if (I2U(i = U2I(nu)) != nu)
+  {
+    unsigned k = I2U(--i);
+    InsertNode(p, ((Byte *)ptr) + U2B(k), nu - k - 1);
+  }
+  InsertNode(p, ptr, i);
+}
+
+static void GlueFreeBlocks(CPpmd8 *p)
+{
+  CPpmd8_Node_Ref head = 0;
+  CPpmd8_Node_Ref *prev = &head;
+  unsigned i;
+
+  p->GlueCount = 1 << 13;
+  memset(p->Stamps, 0, sizeof(p->Stamps));
+
+  /* Order-0 context is always at top UNIT, so we don't need guard NODE at the end.
+     All blocks up to p->LoUnit can be free, so we need guard NODE at LoUnit. */
+  if (p->LoUnit != p->HiUnit)
+    ((CPpmd8_Node *)p->LoUnit)->Stamp = 0;
+
+  /* Glue free blocks */
+  for (i = 0; i < PPMD_NUM_INDEXES; i++)
+  {
+    CPpmd8_Node_Ref next = (CPpmd8_Node_Ref)p->FreeList[i];
+    p->FreeList[i] = 0;
+    while (next != 0)
+    {
+      CPpmd8_Node *node = NODE(next);
+      if (node->NU != 0)
+      {
+        CPpmd8_Node *node2;
+        *prev = next;
+        prev = &(node->Next);
+        while ((node2 = node + node->NU)->Stamp == EMPTY_NODE)
+        {
+          node->NU += node2->NU;
+          node2->NU = 0;
+        }
+      }
+      next = node->Next;
+    }
+  }
+  *prev = 0;
+
+  /* Fill lists of free blocks */
+  while (head != 0)
+  {
+    CPpmd8_Node *node = NODE(head);
+    unsigned nu;
+    head = node->Next;
+    nu = node->NU;
+    if (nu == 0)
+      continue;
+    for (; nu > 128; nu -= 128, node += 128)
+      InsertNode(p, node, PPMD_NUM_INDEXES - 1);
+    if (I2U(i = U2I(nu)) != nu)
+    {
+      unsigned k = I2U(--i);
+      InsertNode(p, node + k, nu - k - 1);
+    }
+    InsertNode(p, node, i);
+  }
+}
+
+static void *AllocUnitsRare(CPpmd8 *p, unsigned indx)
+{
+  unsigned i;
+  void *retVal;
+  if (p->GlueCount == 0)
+  {
+    GlueFreeBlocks(p);
+    if (p->FreeList[indx] != 0)
+      return RemoveNode(p, indx);
+  }
+  i = indx;
+  do
+  {
+    if (++i == PPMD_NUM_INDEXES)
+    {
+      UInt32 numBytes = U2B(I2U(indx));
+      p->GlueCount--;
+      return ((UInt32)(p->UnitsStart - p->Text) > numBytes) ? (p->UnitsStart -= numBytes) : (NULL);
+    }
+  }
+  while (p->FreeList[i] == 0);
+  retVal = RemoveNode(p, i);
+  SplitBlock(p, retVal, i, indx);
+  return retVal;
+}
+
+static void *AllocUnits(CPpmd8 *p, unsigned indx)
+{
+  UInt32 numBytes;
+  if (p->FreeList[indx] != 0)
+    return RemoveNode(p, indx);
+  numBytes = U2B(I2U(indx));
+  if (numBytes <= (UInt32)(p->HiUnit - p->LoUnit))
+  {
+    void *retVal = p->LoUnit;
+    p->LoUnit += numBytes;
+    return retVal;
+  }
+  return AllocUnitsRare(p, indx);
+}
+
+#define MyMem12Cpy(dest, src, num) \
+  { UInt32 *d = (UInt32 *)dest; const UInt32 *s = (const UInt32 *)src; UInt32 n = num; \
+    do { d[0] = s[0]; d[1] = s[1]; d[2] = s[2]; s += 3; d += 3; } while(--n); }
+
+static void *ShrinkUnits(CPpmd8 *p, void *oldPtr, unsigned oldNU, unsigned newNU)
+{
+  unsigned i0 = U2I(oldNU);
+  unsigned i1 = U2I(newNU);
+  if (i0 == i1)
+    return oldPtr;
+  if (p->FreeList[i1] != 0)
+  {
+    void *ptr = RemoveNode(p, i1);
+    MyMem12Cpy(ptr, oldPtr, newNU);
+    InsertNode(p, oldPtr, i0);
+    return ptr;
+  }
+  SplitBlock(p, oldPtr, i0, i1);
+  return oldPtr;
+}
+
+static void FreeUnits(CPpmd8 *p, void *ptr, unsigned nu)
+{
+  InsertNode(p, ptr, U2I(nu));
+}
+
+static void SpecialFreeUnit(CPpmd8 *p, void *ptr)
+{
+  if ((Byte *)ptr != p->UnitsStart)
+    InsertNode(p, ptr, 0);
+  else
+  {
+    #ifdef PPMD8_FREEZE_SUPPORT
+    *(UInt32 *)ptr = EMPTY_NODE; /* it's used for (Flags == 0xFF) check in RemoveBinContexts */
+    #endif
+    p->UnitsStart += UNIT_SIZE;
+  }
+}
+
+static void *MoveUnitsUp(CPpmd8 *p, void *oldPtr, unsigned nu)
+{
+  unsigned indx = U2I(nu);
+  void *ptr;
+  if ((Byte *)oldPtr > p->UnitsStart + 16 * 1024 || REF(oldPtr) > p->FreeList[indx])
+    return oldPtr;
+  ptr = RemoveNode(p, indx);
+  MyMem12Cpy(ptr, oldPtr, nu);
+  if ((Byte*)oldPtr != p->UnitsStart)
+    InsertNode(p, oldPtr, indx);
+  else
+    p->UnitsStart += U2B(I2U(indx));
+  return ptr;
+}
+
+static void ExpandTextArea(CPpmd8 *p)
+{
+  UInt32 count[PPMD_NUM_INDEXES];
+  unsigned i;
+  memset(count, 0, sizeof(count));
+  if (p->LoUnit != p->HiUnit)
+    ((CPpmd8_Node *)p->LoUnit)->Stamp = 0;
+
+  {
+    CPpmd8_Node *node = (CPpmd8_Node *)p->UnitsStart;
+    for (; node->Stamp == EMPTY_NODE; node += node->NU)
+    {
+      node->Stamp = 0;
+      count[U2I(node->NU)]++;
+    }
+    p->UnitsStart = (Byte *)node;
+  }
+
+  for (i = 0; i < PPMD_NUM_INDEXES; i++)
+  {
+    CPpmd8_Node_Ref *next = (CPpmd8_Node_Ref *)&p->FreeList[i];
+    while (count[i] != 0)
+    {
+      CPpmd8_Node *node = NODE(*next);
+      while (node->Stamp == 0)
+      {
+        *next = node->Next;
+        node = NODE(*next);
+        p->Stamps[i]--;
+        if (--count[i] == 0)
+          break;
+      }
+      next = &node->Next;
+    }
+  }
+}
+
+#define SUCCESSOR(p) ((CPpmd_Void_Ref)((p)->SuccessorLow | ((UInt32)(p)->SuccessorHigh << 16)))
+
+static void SetSuccessor(CPpmd_State *p, CPpmd_Void_Ref v)
+{
+  (p)->SuccessorLow = (UInt16)((UInt32)(v) & 0xFFFF);
+  (p)->SuccessorHigh = (UInt16)(((UInt32)(v) >> 16) & 0xFFFF);
+}
+
+#define RESET_TEXT(offs) { p->Text = p->Base + p->AlignOffset + (offs); }
+
+static void RestartModel(CPpmd8 *p)
+{
+  unsigned i, k, m, r;
+
+  memset(p->FreeList, 0, sizeof(p->FreeList));
+  memset(p->Stamps, 0, sizeof(p->Stamps));
+  RESET_TEXT(0);
+  p->HiUnit = p->Text + p->Size;
+  p->LoUnit = p->UnitsStart = p->HiUnit - p->Size / 8 / UNIT_SIZE * 7 * UNIT_SIZE;
+  p->GlueCount = 0;
+
+  p->OrderFall = p->MaxOrder;
+  p->RunLength = p->InitRL = -(Int32)((p->MaxOrder < 12) ? p->MaxOrder : 12) - 1;
+  p->PrevSuccess = 0;
+
+  p->MinContext = p->MaxContext = (CTX_PTR)(p->HiUnit -= UNIT_SIZE); /* AllocContext(p); */
+  p->MinContext->Suffix = 0;
+  p->MinContext->NumStats = 255;
+  p->MinContext->Flags = 0;
+  p->MinContext->SummFreq = 256 + 1;
+  p->FoundState = (CPpmd_State *)p->LoUnit; /* AllocUnits(p, PPMD_NUM_INDEXES - 1); */
+  p->LoUnit += U2B(256 / 2);
+  p->MinContext->Stats = REF(p->FoundState);
+  for (i = 0; i < 256; i++)
+  {
+    CPpmd_State *s = &p->FoundState[i];
+    s->Symbol = (Byte)i;
+    s->Freq = 1;
+    SetSuccessor(s, 0);
+  }
+
+  for (i = m = 0; m < 25; m++)
+  {
+    while (p->NS2Indx[i] == m)
+      i++;
+    for (k = 0; k < 8; k++)
+    {
+      UInt16 val = (UInt16)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 1));
+      UInt16 *dest = p->BinSumm[m] + k;
+      for (r = 0; r < 64; r += 8)
+        dest[r] = val;
+    }
+  }
+
+  for (i = m = 0; m < 24; m++)
+  {
+    while (p->NS2Indx[i + 3] == m + 3)
+      i++;
+    for (k = 0; k < 32; k++)
+    {
+      CPpmd_See *s = &p->See[m][k];
+      s->Summ = (UInt16)((2 * i + 5) << (s->Shift = PPMD_PERIOD_BITS - 4));
+      s->Count = 7;
+    }
+  }
+}
+
+void Ppmd8_Init(CPpmd8 *p, unsigned maxOrder, unsigned restoreMethod)
+{
+  p->MaxOrder = maxOrder;
+  p->RestoreMethod = restoreMethod;
+  RestartModel(p);
+  p->DummySee.Shift = PPMD_PERIOD_BITS;
+  p->DummySee.Summ = 0; /* unused */
+  p->DummySee.Count = 64; /* unused */
+}
+
+static void Refresh(CPpmd8 *p, CTX_PTR ctx, unsigned oldNU, unsigned scale)
+{
+  unsigned i = ctx->NumStats, escFreq, sumFreq, flags;
+  CPpmd_State *s = (CPpmd_State *)ShrinkUnits(p, STATS(ctx), oldNU, (i + 2) >> 1);
+  ctx->Stats = REF(s);
+  #ifdef PPMD8_FREEZE_SUPPORT
+  /* fixed over Shkarin's code. Fixed code is not compatible with original code for some files in FREEZE mode. */
+  scale |= (ctx->SummFreq >= ((UInt32)1 << 15));
+  #endif
+  flags = (ctx->Flags & (0x10 + 0x04 * scale)) + 0x08 * (s->Symbol >= 0x40);
+  escFreq = ctx->SummFreq - s->Freq;
+  sumFreq = (s->Freq = (Byte)((s->Freq + scale) >> scale));
+  do
+  {
+    escFreq -= (++s)->Freq;
+    sumFreq += (s->Freq = (Byte)((s->Freq + scale) >> scale));
+    flags |= 0x08 * (s->Symbol >= 0x40);
+  }
+  while (--i);
+  ctx->SummFreq = (UInt16)(sumFreq + ((escFreq + scale) >> scale));
+  ctx->Flags = (Byte)flags;
+}
+
+static void SwapStates(CPpmd_State *t1, CPpmd_State *t2)
+{
+  CPpmd_State tmp = *t1;
+  *t1 = *t2;
+  *t2 = tmp;
+}
+
+static CPpmd_Void_Ref CutOff(CPpmd8 *p, CTX_PTR ctx, unsigned order)
+{
+  int i;
+  unsigned tmp;
+  CPpmd_State *s;
+
+  if (!ctx->NumStats)
+  {
+    s = ONE_STATE(ctx);
+    if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart)
+    {
+      if (order < p->MaxOrder)
+        SetSuccessor(s, CutOff(p, CTX(SUCCESSOR(s)), order + 1));
+      else
+        SetSuccessor(s, 0);
+      if (SUCCESSOR(s) || order <= 9) /* O_BOUND */
+        return REF(ctx);
+    }
+    SpecialFreeUnit(p, ctx);
+    return 0;
+  }
+
+  ctx->Stats = STATS_REF(MoveUnitsUp(p, STATS(ctx), tmp = ((unsigned)ctx->NumStats + 2) >> 1));
+
+  for (s = STATS(ctx) + (i = ctx->NumStats); s >= STATS(ctx); s--)
+    if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) < p->UnitsStart)
+    {
+      CPpmd_State *s2 = STATS(ctx) + (i--);
+      SetSuccessor(s, 0);
+      SwapStates(s, s2);
+    }
+    else if (order < p->MaxOrder)
+      SetSuccessor(s, CutOff(p, CTX(SUCCESSOR(s)), order + 1));
+    else
+      SetSuccessor(s, 0);
+
+  if (i != ctx->NumStats && order)
+  {
+    ctx->NumStats = (Byte)i;
+    s = STATS(ctx);
+    if (i < 0)
+    {
+      FreeUnits(p, s, tmp);
+      SpecialFreeUnit(p, ctx);
+      return 0;
+    }
+    if (i == 0)
+    {
+      ctx->Flags = (ctx->Flags & 0x10) + 0x08 * (s->Symbol >= 0x40);
+      *ONE_STATE(ctx) = *s;
+      FreeUnits(p, s, tmp);
+      ONE_STATE(ctx)->Freq = (Byte)((unsigned)ONE_STATE(ctx)->Freq + 11) >> 3;
+    }
+    else
+      Refresh(p, ctx, tmp, ctx->SummFreq > 16 * i);
+  }
+  return REF(ctx);
+}
+
+#ifdef PPMD8_FREEZE_SUPPORT
+static CPpmd_Void_Ref RemoveBinContexts(CPpmd8 *p, CTX_PTR ctx, unsigned order)
+{
+  CPpmd_State *s;
+  if (!ctx->NumStats)
+  {
+    s = ONE_STATE(ctx);
+    if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart && order < p->MaxOrder)
+      SetSuccessor(s, RemoveBinContexts(p, CTX(SUCCESSOR(s)), order + 1));
+    else
+      SetSuccessor(s, 0);
+    /* Suffix context can be removed already, since different (high-order)
+       Successors may refer to same context. So we check Flags == 0xFF (Stamp == EMPTY_NODE) */
+    if (!SUCCESSOR(s) && (!SUFFIX(ctx)->NumStats || SUFFIX(ctx)->Flags == 0xFF))
+    {
+      FreeUnits(p, ctx, 1);
+      return 0;
+    }
+    else
+      return REF(ctx);
+  }
+
+  for (s = STATS(ctx) + ctx->NumStats; s >= STATS(ctx); s--)
+    if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart && order < p->MaxOrder)
+      SetSuccessor(s, RemoveBinContexts(p, CTX(SUCCESSOR(s)), order + 1));
+    else
+      SetSuccessor(s, 0);
+
+  return REF(ctx);
+}
+#endif
+
+static UInt32 GetUsedMemory(const CPpmd8 *p)
+{
+  UInt32 v = 0;
+  unsigned i;
+  for (i = 0; i < PPMD_NUM_INDEXES; i++)
+    v += p->Stamps[i] * I2U(i);
+  return p->Size - (UInt32)(p->HiUnit - p->LoUnit) - (UInt32)(p->UnitsStart - p->Text) - U2B(v);
+}
+
+#ifdef PPMD8_FREEZE_SUPPORT
+  #define RESTORE_MODEL(c1, fSuccessor) RestoreModel(p, c1, fSuccessor)
+#else
+  #define RESTORE_MODEL(c1, fSuccessor) RestoreModel(p, c1)
+#endif
+
+static void RestoreModel(CPpmd8 *p, CTX_PTR c1
+    #ifdef PPMD8_FREEZE_SUPPORT
+    , CTX_PTR fSuccessor
+    #endif
+    )
+{
+  CTX_PTR c;
+  CPpmd_State *s;
+  RESET_TEXT(0);
+  for (c = p->MaxContext; c != c1; c = SUFFIX(c))
+    if (--(c->NumStats) == 0)
+    {
+      s = STATS(c);
+      c->Flags = (c->Flags & 0x10) + 0x08 * (s->Symbol >= 0x40);
+      *ONE_STATE(c) = *s;
+      SpecialFreeUnit(p, s);
+      ONE_STATE(c)->Freq = (ONE_STATE(c)->Freq + 11) >> 3;
+    }
+    else
+      Refresh(p, c, (c->NumStats+3) >> 1, 0);
+
+  for (; c != p->MinContext; c = SUFFIX(c))
+    if (!c->NumStats)
+      ONE_STATE(c)->Freq -= ONE_STATE(c)->Freq >> 1;
+    else if ((c->SummFreq += 4) > 128 + 4 * c->NumStats)
+      Refresh(p, c, (c->NumStats + 2) >> 1, 1);
+
+  #ifdef PPMD8_FREEZE_SUPPORT
+  if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)
+  {
+    p->MaxContext = fSuccessor;
+    p->GlueCount += !(p->Stamps[1] & 1);
+  }
+  else if (p->RestoreMethod == PPMD8_RESTORE_METHOD_FREEZE)
+  {
+    while (p->MaxContext->Suffix)
+      p->MaxContext = SUFFIX(p->MaxContext);
+    RemoveBinContexts(p, p->MaxContext, 0);
+    p->RestoreMethod++;
+    p->GlueCount = 0;
+    p->OrderFall = p->MaxOrder;
+  }
+  else
+  #endif
+  if (p->RestoreMethod == PPMD8_RESTORE_METHOD_RESTART || GetUsedMemory(p) < (p->Size >> 1))
+    RestartModel(p);
+  else
+  {
+    while (p->MaxContext->Suffix)
+      p->MaxContext = SUFFIX(p->MaxContext);
+    do
+    {
+      CutOff(p, p->MaxContext, 0);
+      ExpandTextArea(p);
+    }
+    while (GetUsedMemory(p) > 3 * (p->Size >> 2));
+    p->GlueCount = 0;
+    p->OrderFall = p->MaxOrder;
+  }
+}
+
+static CTX_PTR CreateSuccessors(CPpmd8 *p, Bool skip, CPpmd_State *s1, CTX_PTR c)
+{
+  CPpmd_State upState;
+  Byte flags;
+  CPpmd_Byte_Ref upBranch = (CPpmd_Byte_Ref)SUCCESSOR(p->FoundState);
+  /* fixed over Shkarin's code. Maybe it could work without + 1 too. */
+  CPpmd_State *ps[PPMD8_MAX_ORDER + 1];
+  unsigned numPs = 0;
+
+  if (!skip)
+    ps[numPs++] = p->FoundState;
+
+  while (c->Suffix)
+  {
+    CPpmd_Void_Ref successor;
+    CPpmd_State *s;
+    c = SUFFIX(c);
+    if (s1)
+    {
+      s = s1;
+      s1 = NULL;
+    }
+    else if (c->NumStats != 0)
+    {
+      for (s = STATS(c); s->Symbol != p->FoundState->Symbol; s++);
+      if (s->Freq < MAX_FREQ - 9)
+      {
+        s->Freq++;
+        c->SummFreq++;
+      }
+    }
+    else
+    {
+      s = ONE_STATE(c);
+      s->Freq += (!SUFFIX(c)->NumStats & (s->Freq < 24));
+    }
+    successor = SUCCESSOR(s);
+    if (successor != upBranch)
+    {
+      c = CTX(successor);
+      if (numPs == 0)
+        return c;
+      break;
+    }
+    ps[numPs++] = s;
+  }
+
+  upState.Symbol = *(const Byte *)Ppmd8_GetPtr(p, upBranch);
+  SetSuccessor(&upState, upBranch + 1);
+  flags = 0x10 * (p->FoundState->Symbol >= 0x40) + 0x08 * (upState.Symbol >= 0x40);
+
+  if (c->NumStats == 0)
+    upState.Freq = ONE_STATE(c)->Freq;
+  else
+  {
+    UInt32 cf, s0;
+    CPpmd_State *s;
+    for (s = STATS(c); s->Symbol != upState.Symbol; s++);
+    cf = s->Freq - 1;
+    s0 = c->SummFreq - c->NumStats - cf;
+    upState.Freq = (Byte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((cf + 2 * s0 - 3) / s0)));
+  }
+
+  do
+  {
+    /* Create Child */
+    CTX_PTR c1; /* = AllocContext(p); */
+    if (p->HiUnit != p->LoUnit)
+      c1 = (CTX_PTR)(p->HiUnit -= UNIT_SIZE);
+    else if (p->FreeList[0] != 0)
+      c1 = (CTX_PTR)RemoveNode(p, 0);
+    else
+    {
+      c1 = (CTX_PTR)AllocUnitsRare(p, 0);
+      if (!c1)
+        return NULL;
+    }
+    c1->NumStats = 0;
+    c1->Flags = flags;
+    *ONE_STATE(c1) = upState;
+    c1->Suffix = REF(c);
+    SetSuccessor(ps[--numPs], REF(c1));
+    c = c1;
+  }
+  while (numPs != 0);
+
+  return c;
+}
+
+static CTX_PTR ReduceOrder(CPpmd8 *p, CPpmd_State *s1, CTX_PTR c)
+{
+  CPpmd_State *s = NULL;
+  CTX_PTR c1 = c;
+  CPpmd_Void_Ref upBranch = REF(p->Text);
+
+  #ifdef PPMD8_FREEZE_SUPPORT
+  /* The BUG in Shkarin's code was fixed: ps could overflow in CUT_OFF mode. */
+  CPpmd_State *ps[PPMD8_MAX_ORDER + 1];
+  unsigned numPs = 0;
+  ps[numPs++] = p->FoundState;
+  #endif
+
+  SetSuccessor(p->FoundState, upBranch);
+  p->OrderFall++;
+
+  for (;;)
+  {
+    if (s1)
+    {
+      c = SUFFIX(c);
+      s = s1;
+      s1 = NULL;
+    }
+    else
+    {
+      if (!c->Suffix)
+      {
+        #ifdef PPMD8_FREEZE_SUPPORT
+        if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)
+        {
+          do { SetSuccessor(ps[--numPs], REF(c)); } while (numPs);
+          RESET_TEXT(1);
+          p->OrderFall = 1;
+        }
+        #endif
+        return c;
+      }
+      c = SUFFIX(c);
+      if (c->NumStats)
+      {
+        if ((s = STATS(c))->Symbol != p->FoundState->Symbol)
+          do { s++; } while (s->Symbol != p->FoundState->Symbol);
+        if (s->Freq < MAX_FREQ - 9)
+        {
+          s->Freq += 2;
+          c->SummFreq += 2;
+        }
+      }
+      else
+      {
+        s = ONE_STATE(c);
+        s->Freq += (s->Freq < 32);
+      }
+    }
+    if (SUCCESSOR(s))
+      break;
+    #ifdef PPMD8_FREEZE_SUPPORT
+    ps[numPs++] = s;
+    #endif
+    SetSuccessor(s, upBranch);
+    p->OrderFall++;
+  }
+
+  #ifdef PPMD8_FREEZE_SUPPORT
+  if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)
+  {
+    c = CTX(SUCCESSOR(s));
+    do { SetSuccessor(ps[--numPs], REF(c)); } while (numPs);
+    RESET_TEXT(1);
+    p->OrderFall = 1;
+    return c;
+  }
+  else
+  #endif
+  if (SUCCESSOR(s) <= upBranch)
+  {
+    CTX_PTR successor;
+    CPpmd_State *s1 = p->FoundState;
+    p->FoundState = s;
+
+    successor = CreateSuccessors(p, False, NULL, c);
+    if (successor == NULL)
+      SetSuccessor(s, 0);
+    else
+      SetSuccessor(s, REF(successor));
+    p->FoundState = s1;
+  }
+
+  if (p->OrderFall == 1 && c1 == p->MaxContext)
+  {
+    SetSuccessor(p->FoundState, SUCCESSOR(s));
+    p->Text--;
+  }
+  if (SUCCESSOR(s) == 0)
+    return NULL;
+  return CTX(SUCCESSOR(s));
+}
+
+static void UpdateModel(CPpmd8 *p)
+{
+  CPpmd_Void_Ref successor, fSuccessor = SUCCESSOR(p->FoundState);
+  CTX_PTR c;
+  unsigned s0, ns, fFreq = p->FoundState->Freq;
+  Byte flag, fSymbol = p->FoundState->Symbol;
+  CPpmd_State *s = NULL;
+
+  if (p->FoundState->Freq < MAX_FREQ / 4 && p->MinContext->Suffix != 0)
+  {
+    c = SUFFIX(p->MinContext);
+
+    if (c->NumStats == 0)
+    {
+      s = ONE_STATE(c);
+      if (s->Freq < 32)
+        s->Freq++;
+    }
+    else
+    {
+      s = STATS(c);
+      if (s->Symbol != p->FoundState->Symbol)
+      {
+        do { s++; } while (s->Symbol != p->FoundState->Symbol);
+        if (s[0].Freq >= s[-1].Freq)
+        {
+          SwapStates(&s[0], &s[-1]);
+          s--;
+        }
+      }
+      if (s->Freq < MAX_FREQ - 9)
+      {
+        s->Freq += 2;
+        c->SummFreq += 2;
+      }
+    }
+  }
+
+  c = p->MaxContext;
+  if (p->OrderFall == 0 && fSuccessor)
+  {
+    CTX_PTR cs = CreateSuccessors(p, True, s, p->MinContext);
+    if (cs == 0)
+    {
+      SetSuccessor(p->FoundState, 0);
+      RESTORE_MODEL(c, CTX(fSuccessor));
+    }
+    else
+    {
+      SetSuccessor(p->FoundState, REF(cs));
+      p->MaxContext = cs;
+    }
+    return;
+  }
+
+  *p->Text++ = p->FoundState->Symbol;
+  successor = REF(p->Text);
+  if (p->Text >= p->UnitsStart)
+  {
+    RESTORE_MODEL(c, CTX(fSuccessor)); /* check it */
+    return;
+  }
+
+  if (!fSuccessor)
+  {
+    CTX_PTR cs = ReduceOrder(p, s, p->MinContext);
+    if (cs == NULL)
+    {
+      RESTORE_MODEL(c, 0);
+      return;
+    }
+    fSuccessor = REF(cs);
+  }
+  else if ((Byte *)Ppmd8_GetPtr(p, fSuccessor) < p->UnitsStart)
+  {
+    CTX_PTR cs = CreateSuccessors(p, False, s, p->MinContext);
+    if (cs == NULL)
+    {
+      RESTORE_MODEL(c, 0);
+      return;
+    }
+    fSuccessor = REF(cs);
+  }
+
+  if (--p->OrderFall == 0)
+  {
+    successor = fSuccessor;
+    p->Text -= (p->MaxContext != p->MinContext);
+  }
+  #ifdef PPMD8_FREEZE_SUPPORT
+  else if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)
+  {
+    successor = fSuccessor;
+    RESET_TEXT(0);
+    p->OrderFall = 0;
+  }
+  #endif
+
+  s0 = p->MinContext->SummFreq - (ns = p->MinContext->NumStats) - fFreq;
+  flag = 0x08 * (fSymbol >= 0x40);
+
+  for (; c != p->MinContext; c = SUFFIX(c))
+  {
+    unsigned ns1;
+    UInt32 cf, sf;
+    if ((ns1 = c->NumStats) != 0)
+    {
+      if ((ns1 & 1) != 0)
+      {
+        /* Expand for one UNIT */
+        unsigned oldNU = (ns1 + 1) >> 1;
+        unsigned i = U2I(oldNU);
+        if (i != U2I(oldNU + 1))
+        {
+          void *ptr = AllocUnits(p, i + 1);
+          void *oldPtr;
+          if (!ptr)
+          {
+            RESTORE_MODEL(c, CTX(fSuccessor));
+            return;
+          }
+          oldPtr = STATS(c);
+          MyMem12Cpy(ptr, oldPtr, oldNU);
+          InsertNode(p, oldPtr, i);
+          c->Stats = STATS_REF(ptr);
+        }
+      }
+      c->SummFreq = (UInt16)(c->SummFreq + (3 * ns1 + 1 < ns));
+    }
+    else
+    {
+      CPpmd_State *s = (CPpmd_State*)AllocUnits(p, 0);
+      if (!s)
+      {
+        RESTORE_MODEL(c, CTX(fSuccessor));
+        return;
+      }
+      *s = *ONE_STATE(c);
+      c->Stats = REF(s);
+      if (s->Freq < MAX_FREQ / 4 - 1)
+        s->Freq <<= 1;
+      else
+        s->Freq = MAX_FREQ - 4;
+      c->SummFreq = (UInt16)(s->Freq + p->InitEsc + (ns > 2));
+    }
+    cf = 2 * fFreq * (c->SummFreq + 6);
+    sf = (UInt32)s0 + c->SummFreq;
+    if (cf < 6 * sf)
+    {
+      cf = 1 + (cf > sf) + (cf >= 4 * sf);
+      c->SummFreq += 4;
+    }
+    else
+    {
+      cf = 4 + (cf > 9 * sf) + (cf > 12 * sf) + (cf > 15 * sf);
+      c->SummFreq = (UInt16)(c->SummFreq + cf);
+    }
+    {
+      CPpmd_State *s = STATS(c) + ns1 + 1;
+      SetSuccessor(s, successor);
+      s->Symbol = fSymbol;
+      s->Freq = (Byte)cf;
+      c->Flags |= flag;
+      c->NumStats = (Byte)(ns1 + 1);
+    }
+  }
+  p->MaxContext = p->MinContext = CTX(fSuccessor);
+}
+
+static void Rescale(CPpmd8 *p)
+{
+  unsigned i, adder, sumFreq, escFreq;
+  CPpmd_State *stats = STATS(p->MinContext);
+  CPpmd_State *s = p->FoundState;
+  {
+    CPpmd_State tmp = *s;
+    for (; s != stats; s--)
+      s[0] = s[-1];
+    *s = tmp;
+  }
+  escFreq = p->MinContext->SummFreq - s->Freq;
+  s->Freq += 4;
+  adder = (p->OrderFall != 0
+      #ifdef PPMD8_FREEZE_SUPPORT
+      || p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE
+      #endif
+      );
+  s->Freq = (Byte)((s->Freq + adder) >> 1);
+  sumFreq = s->Freq;
+
+  i = p->MinContext->NumStats;
+  do
+  {
+    escFreq -= (++s)->Freq;
+    s->Freq = (Byte)((s->Freq + adder) >> 1);
+    sumFreq += s->Freq;
+    if (s[0].Freq > s[-1].Freq)
+    {
+      CPpmd_State *s1 = s;
+      CPpmd_State tmp = *s1;
+      do
+        s1[0] = s1[-1];
+      while (--s1 != stats && tmp.Freq > s1[-1].Freq);
+      *s1 = tmp;
+    }
+  }
+  while (--i);
+
+  if (s->Freq == 0)
+  {
+    unsigned numStats = p->MinContext->NumStats;
+    unsigned n0, n1;
+    do { i++; } while ((--s)->Freq == 0);
+    escFreq += i;
+    p->MinContext->NumStats = (Byte)(p->MinContext->NumStats - i);
+    if (p->MinContext->NumStats == 0)
+    {
+      CPpmd_State tmp = *stats;
+      tmp.Freq = (Byte)((2 * tmp.Freq + escFreq - 1) / escFreq);
+      if (tmp.Freq > MAX_FREQ / 3)
+        tmp.Freq = MAX_FREQ / 3;
+      InsertNode(p, stats, U2I((numStats + 2) >> 1));
+      p->MinContext->Flags = (p->MinContext->Flags & 0x10) + 0x08 * (tmp.Symbol >= 0x40);
+      *(p->FoundState = ONE_STATE(p->MinContext)) = tmp;
+      return;
+    }
+    n0 = (numStats + 2) >> 1;
+    n1 = (p->MinContext->NumStats + 2) >> 1;
+    if (n0 != n1)
+      p->MinContext->Stats = STATS_REF(ShrinkUnits(p, stats, n0, n1));
+    p->MinContext->Flags &= ~0x08;
+    p->MinContext->Flags |= 0x08 * ((s = STATS(p->MinContext))->Symbol >= 0x40);
+    i = p->MinContext->NumStats;
+    do { p->MinContext->Flags |= 0x08*((++s)->Symbol >= 0x40); } while (--i);
+  }
+  p->MinContext->SummFreq = (UInt16)(sumFreq + escFreq - (escFreq >> 1));
+  p->MinContext->Flags |= 0x4;
+  p->FoundState = STATS(p->MinContext);
+}
+
+CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p, unsigned numMasked1, UInt32 *escFreq)
+{
+  CPpmd_See *see;
+  if (p->MinContext->NumStats != 0xFF)
+  {
+    see = p->See[p->NS2Indx[p->MinContext->NumStats + 2] - 3] +
+        (p->MinContext->SummFreq > 11 * ((unsigned)p->MinContext->NumStats + 1)) +
+        2 * (2 * (unsigned)p->MinContext->NumStats <
+        ((unsigned)SUFFIX(p->MinContext)->NumStats + numMasked1)) +
+        p->MinContext->Flags;
+    {
+      unsigned r = (see->Summ >> see->Shift);
+      see->Summ = (UInt16)(see->Summ - r);
+      *escFreq = r + (r == 0);
+    }
+  }
+  else
+  {
+    see = &p->DummySee;
+    *escFreq = 1;
+  }
+  return see;
+}
+
+static void NextContext(CPpmd8 *p)
+{
+  CTX_PTR c = CTX(SUCCESSOR(p->FoundState));
+  if (p->OrderFall == 0 && (Byte *)c >= p->UnitsStart)
+    p->MinContext = p->MaxContext = c;
+  else
+  {
+    UpdateModel(p);
+    p->MinContext = p->MaxContext;
+  }
+}
+
+void Ppmd8_Update1(CPpmd8 *p)
+{
+  CPpmd_State *s = p->FoundState;
+  s->Freq += 4;
+  p->MinContext->SummFreq += 4;
+  if (s[0].Freq > s[-1].Freq)
+  {
+    SwapStates(&s[0], &s[-1]);
+    p->FoundState = --s;
+    if (s->Freq > MAX_FREQ)
+      Rescale(p);
+  }
+  NextContext(p);
+}
+
+void Ppmd8_Update1_0(CPpmd8 *p)
+{
+  p->PrevSuccess = (2 * p->FoundState->Freq >= p->MinContext->SummFreq);
+  p->RunLength += p->PrevSuccess;
+  p->MinContext->SummFreq += 4;
+  if ((p->FoundState->Freq += 4) > MAX_FREQ)
+    Rescale(p);
+  NextContext(p);
+}
+
+void Ppmd8_UpdateBin(CPpmd8 *p)
+{
+  p->FoundState->Freq = (Byte)(p->FoundState->Freq + (p->FoundState->Freq < 196));
+  p->PrevSuccess = 1;
+  p->RunLength++;
+  NextContext(p);
+}
+
+void Ppmd8_Update2(CPpmd8 *p)
+{
+  p->MinContext->SummFreq += 4;
+  if ((p->FoundState->Freq += 4) > MAX_FREQ)
+    Rescale(p);
+  p->RunLength = p->InitRL;
+  UpdateModel(p);
+  p->MinContext = p->MaxContext;
+}
+
+/* H->I changes:
+  NS2Indx
+  GlewCount, and Glue method
+  BinSum
+  See / EscFreq
+  CreateSuccessors updates more suffix contexts
+  UpdateModel consts.
+  PrevSuccess Update
+*/
diff -Nru src-old/lib/lib7z/Ppmd8.h src/lib/lib7z/Ppmd8.h
--- src-old/lib/lib7z/Ppmd8.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd8.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,137 @@
+/* Ppmd8.h -- PPMdI codec
+2011-01-27 : Igor Pavlov : Public domain
+This code is based on:
+  PPMd var.I (2002): Dmitry Shkarin : Public domain
+  Carryless rangecoder (1999): Dmitry Subbotin : Public domain */
+
+#ifndef __PPMD8_H
+#define __PPMD8_H
+
+#include "Ppmd.h"
+
+EXTERN_C_BEGIN
+
+#define PPMD8_MIN_ORDER 2
+#define PPMD8_MAX_ORDER 16
+
+struct CPpmd8_Context_;
+
+typedef
+  #ifdef PPMD_32BIT
+    struct CPpmd8_Context_ *
+  #else
+    UInt32
+  #endif
+  CPpmd8_Context_Ref;
+
+#pragma pack(push, 1)
+
+typedef struct CPpmd8_Context_
+{
+  Byte NumStats;
+  Byte Flags;
+  UInt16 SummFreq;
+  CPpmd_State_Ref Stats;
+  CPpmd8_Context_Ref Suffix;
+} CPpmd8_Context;
+
+#pragma pack(pop)
+
+#define Ppmd8Context_OneState(p) ((CPpmd_State *)&(p)->SummFreq)
+
+/* The BUG in Shkarin's code for FREEZE mode was fixed, but that fixed
+   code is not compatible with original code for some files compressed
+   in FREEZE mode. So we disable FREEZE mode support. */
+
+enum
+{
+  PPMD8_RESTORE_METHOD_RESTART,
+  PPMD8_RESTORE_METHOD_CUT_OFF
+  #ifdef PPMD8_FREEZE_SUPPORT
+  , PPMD8_RESTORE_METHOD_FREEZE
+  #endif
+};
+
+typedef struct
+{
+  CPpmd8_Context *MinContext, *MaxContext;
+  CPpmd_State *FoundState;
+  unsigned OrderFall, InitEsc, PrevSuccess, MaxOrder;
+  Int32 RunLength, InitRL; /* must be 32-bit at least */
+
+  UInt32 Size;
+  UInt32 GlueCount;
+  Byte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;
+  UInt32 AlignOffset;
+  unsigned RestoreMethod;
+
+  /* Range Coder */
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 Low;
+  union
+  {
+    IByteIn *In;
+    IByteOut *Out;
+  } Stream;
+
+  Byte Indx2Units[PPMD_NUM_INDEXES];
+  Byte Units2Indx[128];
+  CPpmd_Void_Ref FreeList[PPMD_NUM_INDEXES];
+  UInt32 Stamps[PPMD_NUM_INDEXES];
+
+  Byte NS2BSIndx[256], NS2Indx[260];
+  CPpmd_See DummySee, See[24][32];
+  UInt16 BinSumm[25][64];
+} CPpmd8;
+
+void Ppmd8_Construct(CPpmd8 *p);
+Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size, ISzAlloc *alloc);
+void Ppmd8_Free(CPpmd8 *p, ISzAlloc *alloc);
+void Ppmd8_Init(CPpmd8 *p, unsigned maxOrder, unsigned restoreMethod);
+#define Ppmd8_WasAllocated(p) ((p)->Base != NULL)
+
+
+/* ---------- Internal Functions ---------- */
+
+extern const Byte PPMD8_kExpEscape[16];
+
+#ifdef PPMD_32BIT
+  #define Ppmd8_GetPtr(p, ptr) (ptr)
+  #define Ppmd8_GetContext(p, ptr) (ptr)
+  #define Ppmd8_GetStats(p, ctx) ((ctx)->Stats)
+#else
+  #define Ppmd8_GetPtr(p, offs) ((void *)((p)->Base + (offs)))
+  #define Ppmd8_GetContext(p, offs) ((CPpmd8_Context *)Ppmd8_GetPtr((p), (offs)))
+  #define Ppmd8_GetStats(p, ctx) ((CPpmd_State *)Ppmd8_GetPtr((p), ((ctx)->Stats)))
+#endif
+
+void Ppmd8_Update1(CPpmd8 *p);
+void Ppmd8_Update1_0(CPpmd8 *p);
+void Ppmd8_Update2(CPpmd8 *p);
+void Ppmd8_UpdateBin(CPpmd8 *p);
+
+#define Ppmd8_GetBinSumm(p) \
+    &p->BinSumm[p->NS2Indx[Ppmd8Context_OneState(p->MinContext)->Freq - 1]][ \
+    p->NS2BSIndx[Ppmd8_GetContext(p, p->MinContext->Suffix)->NumStats] + \
+    p->PrevSuccess + p->MinContext->Flags + ((p->RunLength >> 26) & 0x20)]
+
+CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p, unsigned numMasked, UInt32 *scale);
+
+
+/* ---------- Decode ---------- */
+
+Bool Ppmd8_RangeDec_Init(CPpmd8 *p);
+#define Ppmd8_RangeDec_IsFinishedOK(p) ((p)->Code == 0)
+int Ppmd8_DecodeSymbol(CPpmd8 *p); /* returns: -1 as EndMarker, -2 as DataError */
+
+
+/* ---------- Encode ---------- */
+
+#define Ppmd8_RangeEnc_Init(p) { (p)->Low = 0; (p)->Range = 0xFFFFFFFF; }
+void Ppmd8_RangeEnc_FlushData(CPpmd8 *p);
+void Ppmd8_EncodeSymbol(CPpmd8 *p, int symbol); /* symbol = -1 means EndMarker */
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Ppmd8Dec.c src/lib/lib7z/Ppmd8Dec.c
--- src-old/lib/lib7z/Ppmd8Dec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd8Dec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,155 @@
+/* Ppmd8Dec.c -- PPMdI Decoder
+2010-04-16 : Igor Pavlov : Public domain
+This code is based on:
+  PPMd var.I (2002): Dmitry Shkarin : Public domain
+  Carryless rangecoder (1999): Dmitry Subbotin : Public domain */
+
+#include "Ppmd8.h"
+
+#define kTop (1 << 24)
+#define kBot (1 << 15)
+
+Bool Ppmd8_RangeDec_Init(CPpmd8 *p)
+{
+  unsigned i;
+  p->Low = 0;
+  p->Range = 0xFFFFFFFF;
+  p->Code = 0;
+  for (i = 0; i < 4; i++)
+    p->Code = (p->Code << 8) | p->Stream.In->Read(p->Stream.In);
+  return (p->Code < 0xFFFFFFFF);
+}
+
+static UInt32 RangeDec_GetThreshold(CPpmd8 *p, UInt32 total)
+{
+  return p->Code / (p->Range /= total);
+}
+
+static void RangeDec_Decode(CPpmd8 *p, UInt32 start, UInt32 size)
+{
+  start *= p->Range;
+  p->Low += start;
+  p->Code -= start;
+  p->Range *= size;
+
+  while ((p->Low ^ (p->Low + p->Range)) < kTop ||
+      (p->Range < kBot && ((p->Range = (0 - p->Low) & (kBot - 1)), 1)))
+  {
+    p->Code = (p->Code << 8) | p->Stream.In->Read(p->Stream.In);
+    p->Range <<= 8;
+    p->Low <<= 8;
+  }
+}
+
+#define MASK(sym) ((signed char *)charMask)[sym]
+
+int Ppmd8_DecodeSymbol(CPpmd8 *p)
+{
+  size_t charMask[256 / sizeof(size_t)];
+  if (p->MinContext->NumStats != 0)
+  {
+    CPpmd_State *s = Ppmd8_GetStats(p, p->MinContext);
+    unsigned i;
+    UInt32 count, hiCnt;
+    if ((count = RangeDec_GetThreshold(p, p->MinContext->SummFreq)) < (hiCnt = s->Freq))
+    {
+      Byte symbol;
+      RangeDec_Decode(p, 0, s->Freq);
+      p->FoundState = s;
+      symbol = s->Symbol;
+      Ppmd8_Update1_0(p);
+      return symbol;
+    }
+    p->PrevSuccess = 0;
+    i = p->MinContext->NumStats;
+    do
+    {
+      if ((hiCnt += (++s)->Freq) > count)
+      {
+        Byte symbol;
+        RangeDec_Decode(p, hiCnt - s->Freq, s->Freq);
+        p->FoundState = s;
+        symbol = s->Symbol;
+        Ppmd8_Update1(p);
+        return symbol;
+      }
+    }
+    while (--i);
+    if (count >= p->MinContext->SummFreq)
+      return -2;
+    RangeDec_Decode(p, hiCnt, p->MinContext->SummFreq - hiCnt);
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(s->Symbol) = 0;
+    i = p->MinContext->NumStats;
+    do { MASK((--s)->Symbol) = 0; } while (--i);
+  }
+  else
+  {
+    UInt16 *prob = Ppmd8_GetBinSumm(p);
+    if (((p->Code / (p->Range >>= 14)) < *prob))
+    {
+      Byte symbol;
+      RangeDec_Decode(p, 0, *prob);
+      *prob = (UInt16)PPMD_UPDATE_PROB_0(*prob);
+      symbol = (p->FoundState = Ppmd8Context_OneState(p->MinContext))->Symbol;
+      Ppmd8_UpdateBin(p);
+      return symbol;
+    }
+    RangeDec_Decode(p, *prob, (1 << 14) - *prob);
+    *prob = (UInt16)PPMD_UPDATE_PROB_1(*prob);
+    p->InitEsc = PPMD8_kExpEscape[*prob >> 10];
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(Ppmd8Context_OneState(p->MinContext)->Symbol) = 0;
+    p->PrevSuccess = 0;
+  }
+  for (;;)
+  {
+    CPpmd_State *ps[256], *s;
+    UInt32 freqSum, count, hiCnt;
+    CPpmd_See *see;
+    unsigned i, num, numMasked = p->MinContext->NumStats;
+    do
+    {
+      p->OrderFall++;
+      if (!p->MinContext->Suffix)
+        return -1;
+      p->MinContext = Ppmd8_GetContext(p, p->MinContext->Suffix);
+    }
+    while (p->MinContext->NumStats == numMasked);
+    hiCnt = 0;
+    s = Ppmd8_GetStats(p, p->MinContext);
+    i = 0;
+    num = p->MinContext->NumStats - numMasked;
+    do
+    {
+      int k = (int)(MASK(s->Symbol));
+      hiCnt += (s->Freq & k);
+      ps[i] = s++;
+      i -= k;
+    }
+    while (i != num);
+
+    see = Ppmd8_MakeEscFreq(p, numMasked, &freqSum);
+    freqSum += hiCnt;
+    count = RangeDec_GetThreshold(p, freqSum);
+
+    if (count < hiCnt)
+    {
+      Byte symbol;
+      CPpmd_State **pps = ps;
+      for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++);
+      s = *pps;
+      RangeDec_Decode(p, hiCnt - s->Freq, s->Freq);
+      Ppmd_See_Update(see);
+      p->FoundState = s;
+      symbol = s->Symbol;
+      Ppmd8_Update2(p);
+      return symbol;
+    }
+    if (count >= freqSum)
+      return -2;
+    RangeDec_Decode(p, hiCnt, freqSum - hiCnt);
+    see->Summ = (UInt16)(see->Summ + freqSum);
+    do { MASK(ps[--i]->Symbol) = 0; } while (i != 0);
+  }
+}
diff -Nru src-old/lib/lib7z/Ppmd8Enc.c src/lib/lib7z/Ppmd8Enc.c
--- src-old/lib/lib7z/Ppmd8Enc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Ppmd8Enc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,161 @@
+/* Ppmd8Enc.c -- PPMdI Encoder
+2010-04-16 : Igor Pavlov : Public domain
+This code is based on:
+  PPMd var.I (2002): Dmitry Shkarin : Public domain
+  Carryless rangecoder (1999): Dmitry Subbotin : Public domain */
+
+#include "Ppmd8.h"
+
+#define kTop (1 << 24)
+#define kBot (1 << 15)
+
+void Ppmd8_RangeEnc_FlushData(CPpmd8 *p)
+{
+  unsigned i;
+  for (i = 0; i < 4; i++, p->Low <<= 8 )
+    p->Stream.Out->Write(p->Stream.Out, (Byte)(p->Low >> 24));
+}
+
+static void RangeEnc_Normalize(CPpmd8 *p)
+{
+  while ((p->Low ^ (p->Low + p->Range)) < kTop ||
+      (p->Range < kBot && ((p->Range = (0 - p->Low) & (kBot - 1)), 1)))
+  {
+    p->Stream.Out->Write(p->Stream.Out, (Byte)(p->Low >> 24));
+    p->Range <<= 8;
+    p->Low <<= 8;
+  }
+}
+
+static void RangeEnc_Encode(CPpmd8 *p, UInt32 start, UInt32 size, UInt32 total)
+{
+  p->Low += start * (p->Range /= total);
+  p->Range *= size;
+  RangeEnc_Normalize(p);
+}
+
+static void RangeEnc_EncodeBit_0(CPpmd8 *p, UInt32 size0)
+{
+  p->Range >>= 14;
+  p->Range *= size0;
+  RangeEnc_Normalize(p);
+}
+
+static void RangeEnc_EncodeBit_1(CPpmd8 *p, UInt32 size0)
+{
+  p->Low += size0 * (p->Range >>= 14);
+  p->Range *= ((1 << 14) - size0);
+  RangeEnc_Normalize(p);
+}
+
+
+#define MASK(sym) ((signed char *)charMask)[sym]
+
+void Ppmd8_EncodeSymbol(CPpmd8 *p, int symbol)
+{
+  size_t charMask[256 / sizeof(size_t)];
+  if (p->MinContext->NumStats != 0)
+  {
+    CPpmd_State *s = Ppmd8_GetStats(p, p->MinContext);
+    UInt32 sum;
+    unsigned i;
+    if (s->Symbol == symbol)
+    {
+      RangeEnc_Encode(p, 0, s->Freq, p->MinContext->SummFreq);
+      p->FoundState = s;
+      Ppmd8_Update1_0(p);
+      return;
+    }
+    p->PrevSuccess = 0;
+    sum = s->Freq;
+    i = p->MinContext->NumStats;
+    do
+    {
+      if ((++s)->Symbol == symbol)
+      {
+        RangeEnc_Encode(p, sum, s->Freq, p->MinContext->SummFreq);
+        p->FoundState = s;
+        Ppmd8_Update1(p);
+        return;
+      }
+      sum += s->Freq;
+    }
+    while (--i);
+
+    PPMD_SetAllBitsIn256Bytes(charMask);
+    MASK(s->Symbol) = 0;
+    i = p->MinContext->NumStats;
+    do { MASK((--s)->Symbol) = 0; } while (--i);
+    RangeEnc_Encode(p, sum, p->MinContext->SummFreq - sum, p->MinContext->SummFreq);
+  }
+  else
+  {
+    UInt16 *prob = Ppmd8_GetBinSumm(p);
+    CPpmd_State *s = Ppmd8Context_OneState(p->MinContext);
+    if (s->Symbol == symbol)
+    {
+      RangeEnc_EncodeBit_0(p, *prob);
+      *prob = (UInt16)PPMD_UPDATE_PROB_0(*prob);
+      p->FoundState = s;
+      Ppmd8_UpdateBin(p);
+      return;
+    }
+    else
+    {
+      RangeEnc_EncodeBit_1(p, *prob);
+      *prob = (UInt16)PPMD_UPDATE_PROB_1(*prob);
+      p->InitEsc = PPMD8_kExpEscape[*prob >> 10];
+      PPMD_SetAllBitsIn256Bytes(charMask);
+      MASK(s->Symbol) = 0;
+      p->PrevSuccess = 0;
+    }
+  }
+  for (;;)
+  {
+    UInt32 escFreq;
+    CPpmd_See *see;
+    CPpmd_State *s;
+    UInt32 sum;
+    unsigned i, numMasked = p->MinContext->NumStats;
+    do
+    {
+      p->OrderFall++;
+      if (!p->MinContext->Suffix)
+        return; /* EndMarker (symbol = -1) */
+      p->MinContext = Ppmd8_GetContext(p, p->MinContext->Suffix);
+    }
+    while (p->MinContext->NumStats == numMasked);
+
+    see = Ppmd8_MakeEscFreq(p, numMasked, &escFreq);
+    s = Ppmd8_GetStats(p, p->MinContext);
+    sum = 0;
+    i = p->MinContext->NumStats + 1;
+    do
+    {
+      int cur = s->Symbol;
+      if (cur == symbol)
+      {
+        UInt32 low = sum;
+        CPpmd_State *s1 = s;
+        do
+        {
+          sum += (s->Freq & (int)(MASK(s->Symbol)));
+          s++;
+        }
+        while (--i);
+        RangeEnc_Encode(p, low, s1->Freq, sum + escFreq);
+        Ppmd_See_Update(see);
+        p->FoundState = s1;
+        Ppmd8_Update2(p);
+        return;
+      }
+      sum += (s->Freq & (int)(MASK(cur)));
+      MASK(cur) = 0;
+      s++;
+    }
+    while (--i);
+
+    RangeEnc_Encode(p, sum, escFreq, sum + escFreq);
+    see->Summ = (UInt16)(see->Summ + sum + escFreq);
+  }
+}
diff -Nru src-old/lib/lib7z/RotateDefs.h src/lib/lib7z/RotateDefs.h
--- src-old/lib/lib7z/RotateDefs.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/RotateDefs.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,20 @@
+/* RotateDefs.h -- Rotate functions
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __ROTATE_DEFS_H
+#define __ROTATE_DEFS_H
+
+#ifdef _MSC_VER
+
+#include <stdlib.h>
+#define rotlFixed(x, n) _rotl((x), (n))
+#define rotrFixed(x, n) _rotr((x), (n))
+
+#else
+
+#define rotlFixed(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
+#define rotrFixed(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
+
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Sha256.c src/lib/lib7z/Sha256.c
--- src-old/lib/lib7z/Sha256.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Sha256.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,204 @@
+/* Crypto/Sha256.c -- SHA-256 Hash
+2010-06-11 : Igor Pavlov : Public domain
+This code is based on public domain code from Wei Dai's Crypto++ library. */
+
+#include "RotateDefs.h"
+#include "Sha256.h"
+
+/* define it for speed optimization */
+/* #define _SHA256_UNROLL */
+/* #define _SHA256_UNROLL2 */
+
+void Sha256_Init(CSha256 *p)
+{
+  p->state[0] = 0x6a09e667;
+  p->state[1] = 0xbb67ae85;
+  p->state[2] = 0x3c6ef372;
+  p->state[3] = 0xa54ff53a;
+  p->state[4] = 0x510e527f;
+  p->state[5] = 0x9b05688c;
+  p->state[6] = 0x1f83d9ab;
+  p->state[7] = 0x5be0cd19;
+  p->count = 0;
+}
+
+#define S0(x) (rotrFixed(x, 2) ^ rotrFixed(x,13) ^ rotrFixed(x, 22))
+#define S1(x) (rotrFixed(x, 6) ^ rotrFixed(x,11) ^ rotrFixed(x, 25))
+#define s0(x) (rotrFixed(x, 7) ^ rotrFixed(x,18) ^ (x >> 3))
+#define s1(x) (rotrFixed(x,17) ^ rotrFixed(x,19) ^ (x >> 10))
+
+#define blk0(i) (W[i] = data[i])
+#define blk2(i) (W[i&15] += s1(W[(i-2)&15]) + W[(i-7)&15] + s0(W[(i-15)&15]))
+
+#define Ch(x,y,z) (z^(x&(y^z)))
+#define Maj(x,y,z) ((x&y)|(z&(x|y)))
+
+#define a(i) T[(0-(i))&7]
+#define b(i) T[(1-(i))&7]
+#define c(i) T[(2-(i))&7]
+#define d(i) T[(3-(i))&7]
+#define e(i) T[(4-(i))&7]
+#define f(i) T[(5-(i))&7]
+#define g(i) T[(6-(i))&7]
+#define h(i) T[(7-(i))&7]
+
+
+#ifdef _SHA256_UNROLL2
+
+#define R(a,b,c,d,e,f,g,h, i) h += S1(e) + Ch(e,f,g) + K[i+j] + (j?blk2(i):blk0(i));\
+  d += h; h += S0(a) + Maj(a, b, c)
+
+#define RX_8(i) \
+  R(a,b,c,d,e,f,g,h, i); \
+  R(h,a,b,c,d,e,f,g, i+1); \
+  R(g,h,a,b,c,d,e,f, i+2); \
+  R(f,g,h,a,b,c,d,e, i+3); \
+  R(e,f,g,h,a,b,c,d, i+4); \
+  R(d,e,f,g,h,a,b,c, i+5); \
+  R(c,d,e,f,g,h,a,b, i+6); \
+  R(b,c,d,e,f,g,h,a, i+7)
+
+#else
+
+#define R(i) h(i) += S1(e(i)) + Ch(e(i),f(i),g(i)) + K[i+j] + (j?blk2(i):blk0(i));\
+  d(i) += h(i); h(i) += S0(a(i)) + Maj(a(i), b(i), c(i))
+
+#ifdef _SHA256_UNROLL
+
+#define RX_8(i) R(i+0); R(i+1); R(i+2); R(i+3); R(i+4); R(i+5); R(i+6); R(i+7);
+
+#endif
+
+#endif
+
+static const UInt32 K[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+static void Sha256_Transform(UInt32 *state, const UInt32 *data)
+{
+  UInt32 W[16];
+  unsigned j;
+  #ifdef _SHA256_UNROLL2
+  UInt32 a,b,c,d,e,f,g,h;
+  a = state[0];
+  b = state[1];
+  c = state[2];
+  d = state[3];
+  e = state[4];
+  f = state[5];
+  g = state[6];
+  h = state[7];
+  #else
+  UInt32 T[8];
+  for (j = 0; j < 8; j++)
+    T[j] = state[j];
+  #endif
+
+  for (j = 0; j < 64; j += 16)
+  {
+    #if defined(_SHA256_UNROLL) || defined(_SHA256_UNROLL2)
+    RX_8(0); RX_8(8);
+    #else
+    unsigned i;
+    for (i = 0; i < 16; i++) { R(i); }
+    #endif
+  }
+
+  #ifdef _SHA256_UNROLL2
+  state[0] += a;
+  state[1] += b;
+  state[2] += c;
+  state[3] += d;
+  state[4] += e;
+  state[5] += f;
+  state[6] += g;
+  state[7] += h;
+  #else
+  for (j = 0; j < 8; j++)
+    state[j] += T[j];
+  #endif
+
+  /* Wipe variables */
+  /* memset(W, 0, sizeof(W)); */
+  /* memset(T, 0, sizeof(T)); */
+}
+
+#undef S0
+#undef S1
+#undef s0
+#undef s1
+
+static void Sha256_WriteByteBlock(CSha256 *p)
+{
+  UInt32 data32[16];
+  unsigned i;
+  for (i = 0; i < 16; i++)
+    data32[i] =
+      ((UInt32)(p->buffer[i * 4    ]) << 24) +
+      ((UInt32)(p->buffer[i * 4 + 1]) << 16) +
+      ((UInt32)(p->buffer[i * 4 + 2]) <<  8) +
+      ((UInt32)(p->buffer[i * 4 + 3]));
+  Sha256_Transform(p->state, data32);
+}
+
+void Sha256_Update(CSha256 *p, const Byte *data, size_t size)
+{
+  UInt32 curBufferPos = (UInt32)p->count & 0x3F;
+  while (size > 0)
+  {
+    p->buffer[curBufferPos++] = *data++;
+    p->count++;
+    size--;
+    if (curBufferPos == 64)
+    {
+      curBufferPos = 0;
+      Sha256_WriteByteBlock(p);
+    }
+  }
+}
+
+void Sha256_Final(CSha256 *p, Byte *digest)
+{
+  UInt64 lenInBits = (p->count << 3);
+  UInt32 curBufferPos = (UInt32)p->count & 0x3F;
+  unsigned i;
+  p->buffer[curBufferPos++] = 0x80;
+  while (curBufferPos != (64 - 8))
+  {
+    curBufferPos &= 0x3F;
+    if (curBufferPos == 0)
+      Sha256_WriteByteBlock(p);
+    p->buffer[curBufferPos++] = 0;
+  }
+  for (i = 0; i < 8; i++)
+  {
+    p->buffer[curBufferPos++] = (Byte)(lenInBits >> 56);
+    lenInBits <<= 8;
+  }
+  Sha256_WriteByteBlock(p);
+
+  for (i = 0; i < 8; i++)
+  {
+    *digest++ = (Byte)(p->state[i] >> 24);
+    *digest++ = (Byte)(p->state[i] >> 16);
+    *digest++ = (Byte)(p->state[i] >> 8);
+    *digest++ = (Byte)(p->state[i]);
+  }
+  Sha256_Init(p);
+}
diff -Nru src-old/lib/lib7z/Sha256.h src/lib/lib7z/Sha256.h
--- src-old/lib/lib7z/Sha256.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Sha256.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,26 @@
+/* Sha256.h -- SHA-256 Hash
+2010-06-11 : Igor Pavlov : Public domain */
+
+#ifndef __CRYPTO_SHA256_H
+#define __CRYPTO_SHA256_H
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+#define SHA256_DIGEST_SIZE 32
+
+typedef struct
+{
+  UInt32 state[8];
+  UInt64 count;
+  Byte buffer[64];
+} CSha256;
+
+void Sha256_Init(CSha256 *p);
+void Sha256_Update(CSha256 *p, const Byte *data, size_t size);
+void Sha256_Final(CSha256 *p, Byte *digest);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Sort.c src/lib/lib7z/Sort.c
--- src-old/lib/lib7z/Sort.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Sort.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,93 @@
+/* Sort.c -- Sort functions
+2010-09-17 : Igor Pavlov : Public domain */
+
+#include "Sort.h"
+
+#define HeapSortDown(p, k, size, temp) \
+  { for (;;) { \
+    UInt32 s = (k << 1); \
+    if (s > size) break; \
+    if (s < size && p[s + 1] > p[s]) s++; \
+    if (temp >= p[s]) break; \
+    p[k] = p[s]; k = s; \
+  } p[k] = temp; }
+
+void HeapSort(UInt32 *p, UInt32 size)
+{
+  if (size <= 1)
+    return;
+  p--;
+  {
+    UInt32 i = size / 2;
+    do
+    {
+      UInt32 temp = p[i];
+      UInt32 k = i;
+      HeapSortDown(p, k, size, temp)
+    }
+    while (--i != 0);
+  }
+  /*
+  do
+  {
+    UInt32 k = 1;
+    UInt32 temp = p[size];
+    p[size--] = p[1];
+    HeapSortDown(p, k, size, temp)
+  }
+  while (size > 1);
+  */
+  while (size > 3)
+  {
+    UInt32 temp = p[size];
+    UInt32 k = (p[3] > p[2]) ? 3 : 2;
+    p[size--] = p[1];
+    p[1] = p[k];
+    HeapSortDown(p, k, size, temp)
+  }
+  {
+    UInt32 temp = p[size];
+    p[size] = p[1];
+    if (size > 2 && p[2] < temp)
+    {
+      p[1] = p[2];
+      p[2] = temp;
+    }
+    else
+      p[1] = temp;
+  }
+}
+
+/*
+#define HeapSortRefDown(p, vals, n, size, temp) \
+  { UInt32 k = n; UInt32 val = vals[temp]; for (;;) { \
+    UInt32 s = (k << 1); \
+    if (s > size) break; \
+    if (s < size && vals[p[s + 1]] > vals[p[s]]) s++; \
+    if (val >= vals[p[s]]) break; \
+    p[k] = p[s]; k = s; \
+  } p[k] = temp; }
+
+void HeapSortRef(UInt32 *p, UInt32 *vals, UInt32 size)
+{
+  if (size <= 1)
+    return;
+  p--;
+  {
+    UInt32 i = size / 2;
+    do
+    {
+      UInt32 temp = p[i];
+      HeapSortRefDown(p, vals, i, size, temp);
+    }
+    while (--i != 0);
+  }
+  do
+  {
+    UInt32 temp = p[size];
+    p[size--] = p[1];
+    HeapSortRefDown(p, vals, 1, size, temp);
+  }
+  while (size > 1);
+}
+*/
diff -Nru src-old/lib/lib7z/Sort.h src/lib/lib7z/Sort.h
--- src-old/lib/lib7z/Sort.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Sort.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,20 @@
+/* Sort.h -- Sort functions
+2009-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_SORT_H
+#define __7Z_SORT_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void HeapSort(UInt32 *p, UInt32 size);
+/* void HeapSortRef(UInt32 *p, UInt32 *vals, UInt32 size); */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Threads.c src/lib/lib7z/Threads.c
--- src-old/lib/lib7z/Threads.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Threads.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,84 @@
+/* Threads.c -- multithreading library
+2009-09-20 : Igor Pavlov : Public domain */
+
+#ifndef _WIN32_7Z_WCE
+#include <process.h>
+#endif
+
+#include "Threads.h"
+
+static WRes GetError()
+{
+  DWORD res = GetLastError();
+  return (res) ? (WRes)(res) : 1;
+}
+
+WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
+WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
+
+WRes HandlePtr_Close(HANDLE *p)
+{
+  if (*p != NULL)
+    if (!CloseHandle(*p))
+      return GetError();
+  *p = NULL;
+  return 0;
+}
+
+WRes Handle_WaitObject(HANDLE h) { return (WRes)WaitForSingleObject(h, INFINITE); }
+
+WRes Thread_Create(CThread *p, THREAD_FUNC_TYPE func, LPVOID param)
+{
+  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
+  *p =
+    #ifdef UNDER_CE
+    CreateThread(0, 0, func, param, 0, &threadId);
+    #else
+    (HANDLE)_beginthreadex(NULL, 0, func, param, 0, &threadId);
+    #endif
+    /* maybe we must use errno here, but probably GetLastError() is also OK. */
+  return HandleToWRes(*p);
+}
+
+WRes Event_Create(CEvent *p, BOOL manualReset, int signaled)
+{
+  *p = CreateEvent(NULL, manualReset, (signaled ? TRUE : FALSE), NULL);
+  return HandleToWRes(*p);
+}
+
+WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(*p)); }
+WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(*p)); }
+
+WRes ManualResetEvent_Create(CManualResetEvent *p, int signaled) { return Event_Create(p, TRUE, signaled); }
+WRes AutoResetEvent_Create(CAutoResetEvent *p, int signaled) { return Event_Create(p, FALSE, signaled); }
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p) { return ManualResetEvent_Create(p, 0); }
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p) { return AutoResetEvent_Create(p, 0); }
+
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initCount, UInt32 maxCount)
+{
+  *p = CreateSemaphore(NULL, (LONG)initCount, (LONG)maxCount, NULL);
+  return HandleToWRes(*p);
+}
+
+static WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
+  { return BOOLToWRes(ReleaseSemaphore(*p, releaseCount, previousCount)); }
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num)
+  { return Semaphore_Release(p, (LONG)num, NULL); }
+WRes Semaphore_Release1(CSemaphore *p) { return Semaphore_ReleaseN(p, 1); }
+
+WRes CriticalSection_Init(CCriticalSection *p)
+{
+  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
+  #ifdef _MSC_VER
+  __try
+  #endif
+  {
+    InitializeCriticalSection(p);
+    /* InitializeCriticalSectionAndSpinCount(p, 0); */
+  }
+  #ifdef _MSC_VER
+  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
+  #endif
+  return 0;
+}
diff -Nru src-old/lib/lib7z/Threads.h src/lib/lib7z/Threads.h
--- src-old/lib/lib7z/Threads.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Threads.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,59 @@
+/* Threads.h -- multithreading library
+2009-03-27 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_THREADS_H
+#define __7Z_THREADS_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+WRes HandlePtr_Close(HANDLE *h);
+WRes Handle_WaitObject(HANDLE h);
+
+typedef HANDLE CThread;
+#define Thread_Construct(p) *(p) = NULL
+#define Thread_WasCreated(p) (*(p) != NULL)
+#define Thread_Close(p) HandlePtr_Close(p)
+#define Thread_Wait(p) Handle_WaitObject(*(p))
+typedef unsigned THREAD_FUNC_RET_TYPE;
+#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
+#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
+typedef THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE * THREAD_FUNC_TYPE)(void *);
+WRes Thread_Create(CThread *p, THREAD_FUNC_TYPE func, LPVOID param);
+
+typedef HANDLE CEvent;
+typedef CEvent CAutoResetEvent;
+typedef CEvent CManualResetEvent;
+#define Event_Construct(p) *(p) = NULL
+#define Event_IsCreated(p) (*(p) != NULL)
+#define Event_Close(p) HandlePtr_Close(p)
+#define Event_Wait(p) Handle_WaitObject(*(p))
+WRes Event_Set(CEvent *p);
+WRes Event_Reset(CEvent *p);
+WRes ManualResetEvent_Create(CManualResetEvent *p, int signaled);
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p);
+WRes AutoResetEvent_Create(CAutoResetEvent *p, int signaled);
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p);
+
+typedef HANDLE CSemaphore;
+#define Semaphore_Construct(p) (*p) = NULL
+#define Semaphore_Close(p) HandlePtr_Close(p)
+#define Semaphore_Wait(p) Handle_WaitObject(*(p))
+WRes Semaphore_Create(CSemaphore *p, UInt32 initCount, UInt32 maxCount);
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
+WRes Semaphore_Release1(CSemaphore *p);
+
+typedef CRITICAL_SECTION CCriticalSection;
+WRes CriticalSection_Init(CCriticalSection *p);
+#define CriticalSection_Delete(p) DeleteCriticalSection(p)
+#define CriticalSection_Enter(p) EnterCriticalSection(p)
+#define CriticalSection_Leave(p) LeaveCriticalSection(p)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nru src-old/lib/lib7z/Types.h src/lib/lib7z/Types.h
--- src-old/lib/lib7z/Types.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Types.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,254 @@
+/* Types.h -- Basic types
+2010-10-09 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_TYPES_H
+#define __7Z_TYPES_H
+
+#include <stddef.h>
+
+#ifdef _WIN32_7Z
+#include <windows.h>
+#endif
+
+#ifndef EXTERN_C_BEGIN
+#ifdef __cplusplus
+#define EXTERN_C_BEGIN extern "C" {
+#define EXTERN_C_END }
+#else
+#define EXTERN_C_BEGIN
+#define EXTERN_C_END
+#endif
+#endif
+
+EXTERN_C_BEGIN
+
+#define SZ_OK 0
+
+#define SZ_ERROR_DATA 1
+#define SZ_ERROR_MEM 2
+#define SZ_ERROR_CRC 3
+#define SZ_ERROR_UNSUPPORTED 4
+#define SZ_ERROR_PARAM 5
+#define SZ_ERROR_INPUT_EOF 6
+#define SZ_ERROR_OUTPUT_EOF 7
+#define SZ_ERROR_READ 8
+#define SZ_ERROR_WRITE 9
+#define SZ_ERROR_PROGRESS 10
+#define SZ_ERROR_FAIL 11
+#define SZ_ERROR_THREAD 12
+
+#define SZ_ERROR_ARCHIVE 16
+#define SZ_ERROR_NO_ARCHIVE 17
+
+typedef int SRes;
+
+#ifdef _WIN32_7Z
+typedef DWORD WRes;
+#else
+typedef int WRes;
+#endif
+
+#ifndef RINOK
+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
+#endif
+
+typedef unsigned char Byte;
+typedef short Int16;
+typedef unsigned short UInt16;
+
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef long Int32;
+typedef unsigned long UInt32;
+#else
+typedef int Int32;
+typedef unsigned int UInt32;
+#endif
+
+#ifdef _SZ_NO_INT_64
+
+/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
+   NOTES: Some code will work incorrectly in that case! */
+
+typedef long Int64;
+typedef unsigned long UInt64;
+
+#else
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#define UINT64_CONST(n) n
+#else
+typedef long long int Int64;
+typedef unsigned long long int UInt64;
+#define UINT64_CONST(n) n ## ULL
+#endif
+
+#endif
+
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+typedef size_t SizeT;
+#endif
+
+typedef int Bool;
+#define True 1
+#define False 0
+
+
+#ifdef _WIN32_7Z
+#define MY_STD_CALL __stdcall
+#else
+#define MY_STD_CALL
+#endif
+
+#ifdef _MSC_VER
+
+#if _MSC_VER >= 1300
+#define MY_NO_INLINE __declspec(noinline)
+#else
+#define MY_NO_INLINE
+#endif
+
+#define MY_CDECL __cdecl
+#define MY_FAST_CALL __fastcall
+
+#else
+
+#define MY_CDECL
+#define MY_FAST_CALL
+
+#endif
+
+
+/* The following interfaces use first parameter as pointer to structure */
+
+typedef struct
+{
+  Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
+} IByteIn;
+
+typedef struct
+{
+  void (*Write)(void *p, Byte b);
+} IByteOut;
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
+       (output(*size) < input(*size)) is allowed */
+} ISeqInStream;
+
+/* it can return SZ_ERROR_INPUT_EOF */
+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
+
+typedef struct
+{
+  size_t (*Write)(void *p, const void *buf, size_t size);
+    /* Returns: result - the number of actually written bytes.
+       (result < size) means error */
+} ISeqOutStream;
+
+typedef enum
+{
+  SZ_SEEK_SET = 0,
+  SZ_SEEK_CUR = 1,
+  SZ_SEEK_END = 2
+} ESzSeek;
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
+} ISeekInStream;
+
+typedef struct
+{
+  SRes (*Look)(void *p, const void **buf, size_t *size);
+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
+       (output(*size) > input(*size)) is not allowed
+       (output(*size) < input(*size)) is allowed */
+  SRes (*Skip)(void *p, size_t offset);
+    /* offset must be <= output(*size) of Look */
+
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* reads directly (without buffer). It's same as ISeqInStream::Read */
+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
+} ILookInStream;
+
+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
+
+/* reads via ILookInStream::Read */
+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
+
+#define LookToRead_BUF_SIZE (1 << 14)
+
+typedef struct
+{
+  ILookInStream s;
+  ISeekInStream *realStream;
+  size_t pos;
+  size_t size;
+  Byte buf[LookToRead_BUF_SIZE];
+} CLookToRead;
+
+void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
+void LookToRead_Init(CLookToRead *p);
+
+typedef struct
+{
+  ISeqInStream s;
+  ILookInStream *realStream;
+} CSecToLook;
+
+void SecToLook_CreateVTable(CSecToLook *p);
+
+typedef struct
+{
+  ISeqInStream s;
+  ILookInStream *realStream;
+} CSecToRead;
+
+void SecToRead_CreateVTable(CSecToRead *p);
+
+typedef struct
+{
+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
+    /* Returns: result. (result != SZ_OK) means break.
+       Value (UInt64)(Int64)-1 for size means unknown value. */
+} ICompressProgress;
+
+typedef struct
+{
+  void *(*Alloc)(void *p, size_t size);
+  void (*Free)(void *p, void *address); /* address can be 0 */
+} ISzAlloc;
+
+#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
+#define IAlloc_Free(p, a) (p)->Free((p), a)
+
+#ifdef _WIN32_7Z
+
+#define CHAR_PATH_SEPARATOR '\\'
+#define WCHAR_PATH_SEPARATOR L'\\'
+#define STRING_PATH_SEPARATOR "\\"
+#define WSTRING_PATH_SEPARATOR L"\\"
+
+#else
+
+#define CHAR_PATH_SEPARATOR '/'
+#define WCHAR_PATH_SEPARATOR L'/'
+#define STRING_PATH_SEPARATOR "/"
+#define WSTRING_PATH_SEPARATOR L"/"
+
+#endif
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/Xz.c src/lib/lib7z/Xz.c
--- src-old/lib/lib7z/Xz.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Xz.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,88 @@
+/* Xz.c - Xz
+2009-04-15 : Igor Pavlov : Public domain */
+
+#include "7zCrc.h"
+#include "CpuArch.h"
+#include "Xz.h"
+#include "XzCrc64.h"
+
+Byte XZ_SIG[XZ_SIG_SIZE] = { 0xFD, '7', 'z', 'X', 'Z', 0 };
+Byte XZ_FOOTER_SIG[XZ_FOOTER_SIG_SIZE] = { 'Y', 'Z' };
+
+unsigned Xz_WriteVarInt(Byte *buf, UInt64 v)
+{
+  unsigned i = 0;
+  do
+  {
+    buf[i++] = (Byte)((v & 0x7F) | 0x80);
+    v >>= 7;
+  }
+  while (v != 0);
+  buf[i - 1] &= 0x7F;
+  return i;
+}
+
+void Xz_Construct(CXzStream *p)
+{
+  p->numBlocks = p->numBlocksAllocated = 0;
+  p->blocks = 0;
+  p->flags = 0;
+}
+
+void Xz_Free(CXzStream *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->blocks);
+  p->numBlocks = p->numBlocksAllocated = 0;
+  p->blocks = 0;
+}
+
+unsigned XzFlags_GetCheckSize(CXzStreamFlags f)
+{
+  int t = XzFlags_GetCheckType(f);
+  return (t == 0) ? 0 : (4 << ((t - 1) / 3));
+}
+
+void XzCheck_Init(CXzCheck *p, int mode)
+{
+  p->mode = mode;
+  switch (mode)
+  {
+    case XZ_CHECK_CRC32: p->crc = CRC_INIT_VAL; break;
+    case XZ_CHECK_CRC64: p->crc64 = CRC64_INIT_VAL; break;
+    case XZ_CHECK_SHA256: Sha256_Init(&p->sha); break;
+  }
+}
+
+void XzCheck_Update(CXzCheck *p, const void *data, size_t size)
+{
+  switch (p->mode)
+  {
+    case XZ_CHECK_CRC32: p->crc = CrcUpdate(p->crc, data, size); break;
+    case XZ_CHECK_CRC64: p->crc64 = Crc64Update(p->crc64, data, size); break;
+    case XZ_CHECK_SHA256: Sha256_Update(&p->sha, (const Byte *)data, size); break;
+  }
+}
+
+int XzCheck_Final(CXzCheck *p, Byte *digest)
+{
+  switch (p->mode)
+  {
+    case XZ_CHECK_CRC32:
+      SetUi32(digest, CRC_GET_DIGEST(p->crc));
+      break;
+    case XZ_CHECK_CRC64:
+    {
+      int i;
+      UInt64 v = CRC64_GET_DIGEST(p->crc64);
+      for (i = 0; i < 8; i++, v >>= 8)
+        digest[i] = (Byte)(v & 0xFF);
+      break;
+    }
+    case XZ_CHECK_SHA256:
+      Sha256_Final(&p->sha, digest);
+      break;
+    default:
+      return 0;
+  }
+  return 1;
+}
diff -Nru src-old/lib/lib7z/Xz.h src/lib/lib7z/Xz.h
--- src-old/lib/lib7z/Xz.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/Xz.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,254 @@
+/* Xz.h - Xz interface
+2011-01-09 : Igor Pavlov : Public domain */
+
+#ifndef __XZ_H
+#define __XZ_H
+
+#include "Sha256.h"
+
+EXTERN_C_BEGIN
+
+#define XZ_ID_Subblock 1
+#define XZ_ID_Delta 3
+#define XZ_ID_X86 4
+#define XZ_ID_PPC 5
+#define XZ_ID_IA64 6
+#define XZ_ID_ARM 7
+#define XZ_ID_ARMT 8
+#define XZ_ID_SPARC 9
+#define XZ_ID_LZMA2 0x21
+
+unsigned Xz_ReadVarInt(const Byte *p, size_t maxSize, UInt64 *value);
+unsigned Xz_WriteVarInt(Byte *buf, UInt64 v);
+
+/* ---------- xz block ---------- */
+
+#define XZ_BLOCK_HEADER_SIZE_MAX 1024
+
+#define XZ_NUM_FILTERS_MAX 4
+#define XZ_BF_NUM_FILTERS_MASK 3
+#define XZ_BF_PACK_SIZE (1 << 6)
+#define XZ_BF_UNPACK_SIZE (1 << 7)
+
+#define XZ_FILTER_PROPS_SIZE_MAX 20
+
+typedef struct
+{
+  UInt64 id;
+  UInt32 propsSize;
+  Byte props[XZ_FILTER_PROPS_SIZE_MAX];
+} CXzFilter;
+
+typedef struct
+{
+  UInt64 packSize;
+  UInt64 unpackSize;
+  Byte flags;
+  CXzFilter filters[XZ_NUM_FILTERS_MAX];
+} CXzBlock;
+
+#define XzBlock_GetNumFilters(p) (((p)->flags & XZ_BF_NUM_FILTERS_MASK) + 1)
+#define XzBlock_HasPackSize(p)   (((p)->flags & XZ_BF_PACK_SIZE) != 0)
+#define XzBlock_HasUnpackSize(p) (((p)->flags & XZ_BF_UNPACK_SIZE) != 0)
+
+SRes XzBlock_Parse(CXzBlock *p, const Byte *header);
+SRes XzBlock_ReadHeader(CXzBlock *p, ISeqInStream *inStream, Bool *isIndex, UInt32 *headerSizeRes);
+
+/* ---------- xz stream ---------- */
+
+#define XZ_SIG_SIZE 6
+#define XZ_FOOTER_SIG_SIZE 2
+
+extern Byte XZ_SIG[XZ_SIG_SIZE];
+extern Byte XZ_FOOTER_SIG[XZ_FOOTER_SIG_SIZE];
+
+#define XZ_STREAM_FLAGS_SIZE 2
+#define XZ_STREAM_CRC_SIZE 4
+
+#define XZ_STREAM_HEADER_SIZE (XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZE + XZ_STREAM_CRC_SIZE)
+#define XZ_STREAM_FOOTER_SIZE (XZ_FOOTER_SIG_SIZE + XZ_STREAM_FLAGS_SIZE + XZ_STREAM_CRC_SIZE + 4)
+
+#define XZ_CHECK_MASK 0xF
+#define XZ_CHECK_NO 0
+#define XZ_CHECK_CRC32 1
+#define XZ_CHECK_CRC64 4
+#define XZ_CHECK_SHA256 10
+
+typedef struct
+{
+  int mode;
+  UInt32 crc;
+  UInt64 crc64;
+  CSha256 sha;
+} CXzCheck;
+
+void XzCheck_Init(CXzCheck *p, int mode);
+void XzCheck_Update(CXzCheck *p, const void *data, size_t size);
+int XzCheck_Final(CXzCheck *p, Byte *digest);
+
+typedef UInt16 CXzStreamFlags;
+
+#define XzFlags_IsSupported(f) ((f) <= XZ_CHECK_MASK)
+#define XzFlags_GetCheckType(f) ((f) & XZ_CHECK_MASK)
+#define XzFlags_HasDataCrc32(f) (Xz_GetCheckType(f) == XZ_CHECK_CRC32)
+unsigned XzFlags_GetCheckSize(CXzStreamFlags f);
+
+SRes Xz_ParseHeader(CXzStreamFlags *p, const Byte *buf);
+SRes Xz_ReadHeader(CXzStreamFlags *p, ISeqInStream *inStream);
+
+typedef struct
+{
+  UInt64 unpackSize;
+  UInt64 totalSize;
+} CXzBlockSizes;
+
+typedef struct
+{
+  CXzStreamFlags flags;
+  size_t numBlocks;
+  size_t numBlocksAllocated;
+  CXzBlockSizes *blocks;
+  UInt64 startOffset;
+} CXzStream;
+
+void Xz_Construct(CXzStream *p);
+void Xz_Free(CXzStream *p, ISzAlloc *alloc);
+
+#define XZ_SIZE_OVERFLOW ((UInt64)(Int64)-1)
+
+UInt64 Xz_GetUnpackSize(const CXzStream *p);
+UInt64 Xz_GetPackSize(const CXzStream *p);
+
+typedef struct
+{
+  size_t num;
+  size_t numAllocated;
+  CXzStream *streams;
+} CXzs;
+
+void Xzs_Construct(CXzs *p);
+void Xzs_Free(CXzs *p, ISzAlloc *alloc);
+SRes Xzs_ReadBackward(CXzs *p, ILookInStream *inStream, Int64 *startOffset, ICompressProgress *progress, ISzAlloc *alloc);
+
+UInt64 Xzs_GetNumBlocks(const CXzs *p);
+UInt64 Xzs_GetUnpackSize(const CXzs *p);
+
+typedef enum
+{
+  CODER_STATUS_NOT_SPECIFIED,               /* use main error code instead */
+  CODER_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
+  CODER_STATUS_NOT_FINISHED,                /* stream was not finished */
+  CODER_STATUS_NEEDS_MORE_INPUT             /* you must provide more input bytes */
+} ECoderStatus;
+
+typedef enum
+{
+  CODER_FINISH_ANY,   /* finish at any point */
+  CODER_FINISH_END    /* block must be finished at the end */
+} ECoderFinishMode;
+
+typedef struct _IStateCoder
+{
+  void *p;
+  void (*Free)(void *p, ISzAlloc *alloc);
+  SRes (*SetProps)(void *p, const Byte *props, size_t propSize, ISzAlloc *alloc);
+  void (*Init)(void *p);
+  SRes (*Code)(void *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+      int srcWasFinished, ECoderFinishMode finishMode, int *wasFinished);
+} IStateCoder;
+
+#define MIXCODER_NUM_FILTERS_MAX 4
+
+typedef struct
+{
+  ISzAlloc *alloc;
+  Byte *buf;
+  int numCoders;
+  int finished[MIXCODER_NUM_FILTERS_MAX - 1];
+  size_t pos[MIXCODER_NUM_FILTERS_MAX - 1];
+  size_t size[MIXCODER_NUM_FILTERS_MAX - 1];
+  UInt64 ids[MIXCODER_NUM_FILTERS_MAX];
+  IStateCoder coders[MIXCODER_NUM_FILTERS_MAX];
+} CMixCoder;
+
+void MixCoder_Construct(CMixCoder *p, ISzAlloc *alloc);
+void MixCoder_Free(CMixCoder *p);
+void MixCoder_Init(CMixCoder *p);
+SRes MixCoder_SetFromMethod(CMixCoder *p, int coderIndex, UInt64 methodId);
+SRes MixCoder_Code(CMixCoder *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, int srcWasFinished,
+    ECoderFinishMode finishMode, ECoderStatus *status);
+
+typedef enum
+{
+  XZ_STATE_STREAM_HEADER,
+  XZ_STATE_STREAM_INDEX,
+  XZ_STATE_STREAM_INDEX_CRC,
+  XZ_STATE_STREAM_FOOTER,
+  XZ_STATE_STREAM_PADDING,
+  XZ_STATE_BLOCK_HEADER,
+  XZ_STATE_BLOCK,
+  XZ_STATE_BLOCK_FOOTER
+} EXzState;
+
+typedef struct
+{
+  EXzState state;
+  UInt32 pos;
+  unsigned alignPos;
+  unsigned indexPreSize;
+
+  CXzStreamFlags streamFlags;
+
+  UInt32 blockHeaderSize;
+  UInt64 packSize;
+  UInt64 unpackSize;
+
+  UInt64 numBlocks;
+  UInt64 indexSize;
+  UInt64 indexPos;
+  UInt64 padSize;
+
+  UInt64 numStreams;
+
+  UInt32 crc;
+  CMixCoder decoder;
+  CXzBlock block;
+  CXzCheck check;
+  CSha256 sha;
+  Byte shaDigest[SHA256_DIGEST_SIZE];
+  Byte buf[XZ_BLOCK_HEADER_SIZE_MAX];
+} CXzUnpacker;
+
+void XzUnpacker_Construct(CXzUnpacker *p, ISzAlloc *alloc);
+void XzUnpacker_Init(CXzUnpacker *p);
+void XzUnpacker_Free(CXzUnpacker *p);
+
+/*
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - use smallest number of input bytes
+  LZMA_FINISH_END - read EndOfStream marker after decoding
+
+Returns:
+  SZ_OK
+    status:
+      CODER_STATUS_NOT_FINISHED,
+      CODER_STATUS_NEEDS_MORE_INPUT - maybe there are more xz streams,
+                                      call XzUnpacker_IsStreamWasFinished to check that current stream was finished
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+
+SRes XzUnpacker_Code(CXzUnpacker *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, /* int srcWasFinished, */ int finishMode,
+    ECoderStatus *status);
+
+Bool XzUnpacker_IsStreamWasFinished(CXzUnpacker *p);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/XzCrc64.c src/lib/lib7z/XzCrc64.c
--- src-old/lib/lib7z/XzCrc64.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzCrc64.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,33 @@
+/* XzCrc64.c -- CRC64 calculation
+2010-04-16 : Igor Pavlov : Public domain */
+
+#include "XzCrc64.h"
+
+#define kCrc64Poly UINT64_CONST(0xC96C5795D7870F42)
+UInt64 g_Crc64Table[256];
+
+void MY_FAST_CALL Crc64GenerateTable(void)
+{
+  UInt32 i;
+  for (i = 0; i < 256; i++)
+  {
+    UInt64 r = i;
+    int j;
+    for (j = 0; j < 8; j++)
+      r = (r >> 1) ^ ((UInt64)kCrc64Poly & ~((r & 1) - 1));
+    g_Crc64Table[i] = r;
+  }
+}
+
+UInt64 MY_FAST_CALL Crc64Update(UInt64 v, const void *data, size_t size)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 ; size--, p++)
+    v = CRC64_UPDATE_BYTE(v, *p);
+  return v;
+}
+
+UInt64 MY_FAST_CALL Crc64Calc(const void *data, size_t size)
+{
+  return CRC64_GET_DIGEST(Crc64Update(CRC64_INIT_VAL, data, size));
+}
diff -Nru src-old/lib/lib7z/XzCrc64.h src/lib/lib7z/XzCrc64.h
--- src-old/lib/lib7z/XzCrc64.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzCrc64.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,26 @@
+/* XzCrc64.h -- CRC64 calculation
+2010-04-16 : Igor Pavlov : Public domain */
+
+#ifndef __XZ_CRC64_H
+#define __XZ_CRC64_H
+
+#include <stddef.h>
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+extern UInt64 g_Crc64Table[];
+
+void MY_FAST_CALL Crc64GenerateTable(void);
+
+#define CRC64_INIT_VAL UINT64_CONST(0xFFFFFFFFFFFFFFFF)
+#define CRC64_GET_DIGEST(crc) ((crc) ^ CRC64_INIT_VAL)
+#define CRC64_UPDATE_BYTE(crc, b) (g_Crc64Table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
+
+UInt64 MY_FAST_CALL Crc64Update(UInt64 crc, const void *data, size_t size);
+UInt64 MY_FAST_CALL Crc64Calc(const void *data, size_t size);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/XzDec.c src/lib/lib7z/XzDec.c
--- src-old/lib/lib7z/XzDec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzDec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,889 @@
+/* XzDec.c -- Xz Decode
+2011-02-07 : Igor Pavlov : Public domain */
+
+/* #define XZ_DUMP */
+
+#ifdef XZ_DUMP
+#include <stdio.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "7zCrc.h"
+#include "Alloc.h"
+#include "Bra.h"
+#include "CpuArch.h"
+#include "Delta.h"
+#include "Lzma2Dec.h"
+
+#ifdef USE_SUBBLOCK
+#include "Bcj3Dec.c"
+#include "SbDec.c"
+#endif
+
+#include "Xz.h"
+
+#define XZ_CHECK_SIZE_MAX 64
+
+#define CODER_BUF_SIZE (1 << 17)
+
+unsigned Xz_ReadVarInt(const Byte *p, size_t maxSize, UInt64 *value)
+{
+  int i, limit;
+  *value = 0;
+  limit = (maxSize > 9) ? 9 : (int)maxSize;
+
+  for (i = 0; i < limit;)
+  {
+    Byte b = p[i];
+    *value |= (UInt64)(b & 0x7F) << (7 * i++);
+    if ((b & 0x80) == 0)
+      return (b == 0 && i != 1) ? 0 : i;
+  }
+  return 0;
+}
+
+/* ---------- BraState ---------- */
+
+#define BRA_BUF_SIZE (1 << 14)
+
+typedef struct
+{
+  size_t bufPos;
+  size_t bufConv;
+  size_t bufTotal;
+
+  UInt32 methodId;
+  int encodeMode;
+  UInt32 delta;
+  UInt32 ip;
+  UInt32 x86State;
+  Byte deltaState[DELTA_STATE_SIZE];
+
+  Byte buf[BRA_BUF_SIZE];
+} CBraState;
+
+void BraState_Free(void *pp, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, pp);
+}
+
+SRes BraState_SetProps(void *pp, const Byte *props, size_t propSize, ISzAlloc *alloc)
+{
+  CBraState *p = ((CBraState *)pp);
+  alloc = alloc;
+  p->ip = 0;
+  if (p->methodId == XZ_ID_Delta)
+  {
+    if (propSize != 1)
+      return SZ_ERROR_UNSUPPORTED;
+    p->delta = (unsigned)props[0] + 1;
+  }
+  else
+  {
+    if (propSize == 4)
+    {
+      UInt32 v = GetUi32(props);
+      switch(p->methodId)
+      {
+        case XZ_ID_PPC:
+        case XZ_ID_ARM:
+        case XZ_ID_SPARC:
+          if ((v & 3) != 0)
+            return SZ_ERROR_UNSUPPORTED;
+          break;
+        case XZ_ID_ARMT:
+          if ((v & 1) != 0)
+            return SZ_ERROR_UNSUPPORTED;
+          break;
+        case XZ_ID_IA64:
+          if ((v & 0xF) != 0)
+            return SZ_ERROR_UNSUPPORTED;
+          break;
+      }
+      p->ip = v;
+    }
+    else if (propSize != 0)
+      return SZ_ERROR_UNSUPPORTED;
+  }
+  return SZ_OK;
+}
+
+void BraState_Init(void *pp)
+{
+  CBraState *p = ((CBraState *)pp);
+  p->bufPos = p->bufConv = p->bufTotal = 0;
+  x86_Convert_Init(p->x86State);
+  if (p->methodId == XZ_ID_Delta)
+    Delta_Init(p->deltaState);
+}
+
+#define CASE_BRA_CONV(isa) case XZ_ID_ ## isa: p->bufConv = isa ## _Convert(p->buf, p->bufTotal, p->ip, p->encodeMode); break;
+
+static SRes BraState_Code(void *pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    int srcWasFinished, ECoderFinishMode finishMode, int *wasFinished)
+{
+  CBraState *p = ((CBraState *)pp);
+  SizeT destLenOrig = *destLen;
+  SizeT srcLenOrig = *srcLen;
+  *destLen = 0;
+  *srcLen = 0;
+  finishMode = finishMode;
+  *wasFinished = 0;
+  while (destLenOrig > 0)
+  {
+    if (p->bufPos != p->bufConv)
+    {
+      size_t curSize = p->bufConv - p->bufPos;
+      if (curSize > destLenOrig)
+        curSize = destLenOrig;
+      memcpy(dest, p->buf + p->bufPos, curSize);
+      p->bufPos += curSize;
+      *destLen += curSize;
+      dest += curSize;
+      destLenOrig -= curSize;
+      continue;
+    }
+    p->bufTotal -= p->bufPos;
+    memmove(p->buf, p->buf + p->bufPos, p->bufTotal);
+    p->bufPos = 0;
+    p->bufConv = 0;
+    {
+      size_t curSize = BRA_BUF_SIZE - p->bufTotal;
+      if (curSize > srcLenOrig)
+        curSize = srcLenOrig;
+      memcpy(p->buf + p->bufTotal, src, curSize);
+      *srcLen += curSize;
+      src += curSize;
+      srcLenOrig -= curSize;
+      p->bufTotal += curSize;
+    }
+    if (p->bufTotal == 0)
+      break;
+    switch(p->methodId)
+    {
+      case XZ_ID_Delta:
+        if (p->encodeMode)
+          Delta_Encode(p->deltaState, p->delta, p->buf, p->bufTotal);
+        else
+          Delta_Decode(p->deltaState, p->delta, p->buf, p->bufTotal);
+        p->bufConv = p->bufTotal;
+        break;
+      case XZ_ID_X86:
+        p->bufConv = x86_Convert(p->buf, p->bufTotal, p->ip, &p->x86State, p->encodeMode);
+        break;
+      CASE_BRA_CONV(PPC)
+      CASE_BRA_CONV(IA64)
+      CASE_BRA_CONV(ARM)
+      CASE_BRA_CONV(ARMT)
+      CASE_BRA_CONV(SPARC)
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+    p->ip += (UInt32)p->bufConv;
+
+    if (p->bufConv == 0)
+    {
+      if (!srcWasFinished)
+        break;
+      p->bufConv = p->bufTotal;
+    }
+  }
+  if (p->bufTotal == p->bufPos && srcLenOrig == 0 && srcWasFinished)
+    *wasFinished = 1;
+  return SZ_OK;
+}
+
+SRes BraState_SetFromMethod(IStateCoder *p, UInt64 id, int encodeMode, ISzAlloc *alloc)
+{
+  CBraState *decoder;
+  if (id != XZ_ID_Delta &&
+      id != XZ_ID_X86 &&
+      id != XZ_ID_PPC &&
+      id != XZ_ID_IA64 &&
+      id != XZ_ID_ARM &&
+      id != XZ_ID_ARMT &&
+      id != XZ_ID_SPARC)
+    return SZ_ERROR_UNSUPPORTED;
+  p->p = 0;
+  decoder = alloc->Alloc(alloc, sizeof(CBraState));
+  if (decoder == 0)
+    return SZ_ERROR_MEM;
+  decoder->methodId = (UInt32)id;
+  decoder->encodeMode = encodeMode;
+  p->p = decoder;
+  p->Free = BraState_Free;
+  p->SetProps = BraState_SetProps;
+  p->Init = BraState_Init;
+  p->Code = BraState_Code;
+  return SZ_OK;
+}
+
+/* ---------- SbState ---------- */
+
+#ifdef USE_SUBBLOCK
+
+static void SbState_Free(void *pp, ISzAlloc *alloc)
+{
+  CSbDec *p = (CSbDec *)pp;
+  SbDec_Free(p);
+  alloc->Free(alloc, pp);
+}
+
+static SRes SbState_SetProps(void *pp, const Byte *props, size_t propSize, ISzAlloc *alloc)
+{
+  pp = pp;
+  props = props;
+  alloc = alloc;
+  return (propSize == 0) ? SZ_OK : SZ_ERROR_UNSUPPORTED;
+}
+
+static void SbState_Init(void *pp)
+{
+  SbDec_Init((CSbDec *)pp);
+}
+
+static SRes SbState_Code(void *pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    int srcWasFinished, ECoderFinishMode finishMode, int *wasFinished)
+{
+  CSbDec *p = (CSbDec *)pp;
+  SRes res;
+  srcWasFinished = srcWasFinished;
+  p->dest = dest;
+  p->destLen = *destLen;
+  p->src = src;
+  p->srcLen = *srcLen;
+  p->finish = finishMode; /* change it */
+  res = SbDec_Decode((CSbDec *)pp);
+  *destLen -= p->destLen;
+  *srcLen -= p->srcLen;
+  *wasFinished = (*destLen == 0 && *srcLen == 0); /* change it */
+  return res;
+}
+
+SRes SbState_SetFromMethod(IStateCoder *p, ISzAlloc *alloc)
+{
+  CSbDec *decoder;
+  p->p = 0;
+  decoder = alloc->Alloc(alloc, sizeof(CSbDec));
+  if (decoder == 0)
+    return SZ_ERROR_MEM;
+  p->p = decoder;
+  p->Free = SbState_Free;
+  p->SetProps = SbState_SetProps;
+  p->Init = SbState_Init;
+  p->Code = SbState_Code;
+  SbDec_Construct(decoder);
+  SbDec_SetAlloc(decoder, alloc);
+  return SZ_OK;
+}
+#endif
+
+/* ---------- Lzma2State ---------- */
+
+static void Lzma2State_Free(void *pp, ISzAlloc *alloc)
+{
+  Lzma2Dec_Free((CLzma2Dec *)pp, alloc);
+  alloc->Free(alloc, pp);
+}
+
+static SRes Lzma2State_SetProps(void *pp, const Byte *props, size_t propSize, ISzAlloc *alloc)
+{
+  if (propSize != 1)
+    return SZ_ERROR_UNSUPPORTED;
+  return Lzma2Dec_Allocate((CLzma2Dec *)pp, props[0], alloc);
+}
+
+static void Lzma2State_Init(void *pp)
+{
+  Lzma2Dec_Init((CLzma2Dec *)pp);
+}
+
+static SRes Lzma2State_Code(void *pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    int srcWasFinished, ECoderFinishMode finishMode, int *wasFinished)
+{
+  ELzmaStatus status;
+  /* ELzmaFinishMode fm = (finishMode == LZMA_FINISH_ANY) ? LZMA_FINISH_ANY : LZMA_FINISH_END; */
+  SRes res = Lzma2Dec_DecodeToBuf((CLzma2Dec *)pp, dest, destLen, src, srcLen, finishMode, &status);
+  srcWasFinished = srcWasFinished;
+  *wasFinished = (status == LZMA_STATUS_FINISHED_WITH_MARK);
+  return res;
+}
+
+static SRes Lzma2State_SetFromMethod(IStateCoder *p, ISzAlloc *alloc)
+{
+  CLzma2Dec *decoder = alloc->Alloc(alloc, sizeof(CLzma2Dec));
+  p->p = decoder;
+  if (decoder == 0)
+    return SZ_ERROR_MEM;
+  p->Free = Lzma2State_Free;
+  p->SetProps = Lzma2State_SetProps;
+  p->Init = Lzma2State_Init;
+  p->Code = Lzma2State_Code;
+  Lzma2Dec_Construct(decoder);
+  return SZ_OK;
+}
+
+
+void MixCoder_Construct(CMixCoder *p, ISzAlloc *alloc)
+{
+  int i;
+  p->alloc = alloc;
+  p->buf = 0;
+  p->numCoders = 0;
+  for (i = 0; i < MIXCODER_NUM_FILTERS_MAX; i++)
+    p->coders[i].p = NULL;
+}
+
+void MixCoder_Free(CMixCoder *p)
+{
+  int i;
+  for (i = 0; i < p->numCoders; i++)
+  {
+    IStateCoder *sc = &p->coders[i];
+    if (p->alloc && sc->p)
+      sc->Free(sc->p, p->alloc);
+  }
+  p->numCoders = 0;
+  if (p->buf)
+    p->alloc->Free(p->alloc, p->buf);
+}
+
+void MixCoder_Init(CMixCoder *p)
+{
+  int i;
+  for (i = 0; i < p->numCoders - 1; i++)
+  {
+    p->size[i] = 0;
+    p->pos[i] = 0;
+    p->finished[i] = 0;
+  }
+  for (i = 0; i < p->numCoders; i++)
+  {
+    IStateCoder *coder = &p->coders[i];
+    coder->Init(coder->p);
+  }
+}
+
+SRes MixCoder_SetFromMethod(CMixCoder *p, int coderIndex, UInt64 methodId)
+{
+  IStateCoder *sc = &p->coders[coderIndex];
+  p->ids[coderIndex] = methodId;
+  switch(methodId)
+  {
+    case XZ_ID_LZMA2: return Lzma2State_SetFromMethod(sc, p->alloc);
+    #ifdef USE_SUBBLOCK
+    case XZ_ID_Subblock: return SbState_SetFromMethod(sc, p->alloc);
+    #endif
+  }
+  if (coderIndex == 0)
+    return SZ_ERROR_UNSUPPORTED;
+  return BraState_SetFromMethod(sc, methodId, 0, p->alloc);
+}
+
+SRes MixCoder_Code(CMixCoder *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, int srcWasFinished,
+    ECoderFinishMode finishMode, ECoderStatus *status)
+{
+  SizeT destLenOrig = *destLen;
+  SizeT srcLenOrig = *srcLen;
+  Bool allFinished = True;
+  *destLen = 0;
+  *srcLen = 0;
+  *status = CODER_STATUS_NOT_FINISHED;
+
+  if (p->buf == 0)
+  {
+    p->buf = p->alloc->Alloc(p->alloc, CODER_BUF_SIZE * (MIXCODER_NUM_FILTERS_MAX - 1));
+    if (p->buf == 0)
+      return SZ_ERROR_MEM;
+  }
+
+  if (p->numCoders != 1)
+    finishMode = CODER_FINISH_ANY;
+
+  for (;;)
+  {
+    Bool processed = False;
+    int i;
+    /*
+    if (p->numCoders == 1 && *destLen == destLenOrig && finishMode == LZMA_FINISH_ANY)
+      break;
+    */
+
+    for (i = 0; i < p->numCoders; i++)
+    {
+      SRes res;
+      IStateCoder *coder = &p->coders[i];
+      Byte *destCur;
+      SizeT destLenCur, srcLenCur;
+      const Byte *srcCur;
+      int srcFinishedCur;
+      int encodingWasFinished;
+
+      if (i == 0)
+      {
+        srcCur = src;
+        srcLenCur = srcLenOrig - *srcLen;
+        srcFinishedCur = srcWasFinished;
+      }
+      else
+      {
+        srcCur = p->buf + (CODER_BUF_SIZE * (i - 1)) + p->pos[i - 1];
+        srcLenCur = p->size[i - 1] - p->pos[i - 1];
+        srcFinishedCur = p->finished[i - 1];
+      }
+
+      if (i == p->numCoders - 1)
+      {
+        destCur = dest;
+        destLenCur = destLenOrig - *destLen;
+      }
+      else
+      {
+        if (p->pos[i] != p->size[i])
+          continue;
+        destCur = p->buf + (CODER_BUF_SIZE * i);
+        destLenCur = CODER_BUF_SIZE;
+      }
+
+      res = coder->Code(coder->p, destCur, &destLenCur, srcCur, &srcLenCur, srcFinishedCur, finishMode, &encodingWasFinished);
+
+      if (!encodingWasFinished)
+        allFinished = False;
+
+      if (i == 0)
+      {
+        *srcLen += srcLenCur;
+        src += srcLenCur;
+      }
+      else
+      {
+        p->pos[i - 1] += srcLenCur;
+      }
+
+      if (i == p->numCoders - 1)
+      {
+        *destLen += destLenCur;
+        dest += destLenCur;
+      }
+      else
+      {
+        p->size[i] = destLenCur;
+        p->pos[i] = 0;
+        p->finished[i] = encodingWasFinished;
+      }
+
+      if (res != SZ_OK)
+        return res;
+
+      if (destLenCur != 0 || srcLenCur != 0)
+        processed = True;
+    }
+    if (!processed)
+      break;
+  }
+  if (allFinished)
+    *status = CODER_STATUS_FINISHED_WITH_MARK;
+  return SZ_OK;
+}
+
+SRes Xz_ParseHeader(CXzStreamFlags *p, const Byte *buf)
+{
+  *p = (CXzStreamFlags)GetBe16(buf + XZ_SIG_SIZE);
+  if (CrcCalc(buf + XZ_SIG_SIZE, XZ_STREAM_FLAGS_SIZE) !=
+      GetUi32(buf + XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZE))
+    return SZ_ERROR_NO_ARCHIVE;
+  return XzFlags_IsSupported(*p) ? SZ_OK : SZ_ERROR_UNSUPPORTED;
+}
+
+static Bool Xz_CheckFooter(CXzStreamFlags flags, UInt64 indexSize, const Byte *buf)
+{
+  return
+      indexSize == (((UInt64)GetUi32(buf + 4) + 1) << 2) &&
+      (GetUi32(buf) == CrcCalc(buf + 4, 6) &&
+      flags == GetBe16(buf + 8) &&
+      memcmp(buf + 10, XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE) == 0);
+}
+
+#define READ_VARINT_AND_CHECK(buf, pos, size, res) \
+  { unsigned s = Xz_ReadVarInt(buf + pos, size - pos, res); \
+  if (s == 0) return SZ_ERROR_ARCHIVE; pos += s; }
+
+
+SRes XzBlock_Parse(CXzBlock *p, const Byte *header)
+{
+  unsigned pos;
+  int numFilters, i;
+  UInt32 headerSize = (UInt32)header[0] << 2;
+
+  if (CrcCalc(header, headerSize) != GetUi32(header + headerSize))
+    return SZ_ERROR_ARCHIVE;
+
+  pos = 1;
+  if (pos == headerSize)
+    return SZ_ERROR_ARCHIVE;
+  p->flags = header[pos++];
+
+  if (XzBlock_HasPackSize(p))
+  {
+    READ_VARINT_AND_CHECK(header, pos, headerSize, &p->packSize);
+    if (p->packSize == 0 || p->packSize + headerSize >= (UInt64)1 << 63)
+      return SZ_ERROR_ARCHIVE;
+  }
+
+  if (XzBlock_HasUnpackSize(p))
+    READ_VARINT_AND_CHECK(header, pos, headerSize, &p->unpackSize);
+
+  numFilters = XzBlock_GetNumFilters(p);
+  for (i = 0; i < numFilters; i++)
+  {
+    CXzFilter *filter = p->filters + i;
+    UInt64 size;
+    READ_VARINT_AND_CHECK(header, pos, headerSize, &filter->id);
+    READ_VARINT_AND_CHECK(header, pos, headerSize, &size);
+    if (size > headerSize - pos || size > XZ_FILTER_PROPS_SIZE_MAX)
+      return SZ_ERROR_ARCHIVE;
+    filter->propsSize = (UInt32)size;
+    memcpy(filter->props, header + pos, (size_t)size);
+    pos += (unsigned)size;
+
+    #ifdef XZ_DUMP
+    printf("\nf[%d] = %2X: ", i, filter->id);
+    {
+      int i;
+      for (i = 0; i < size; i++)
+        printf(" %2X", filter->props[i]);
+    }
+    #endif
+  }
+
+  while (pos < headerSize)
+    if (header[pos++] != 0)
+      return SZ_ERROR_ARCHIVE;
+  return SZ_OK;
+}
+
+SRes XzDec_Init(CMixCoder *p, const CXzBlock *block)
+{
+  int i;
+  Bool needReInit = True;
+  int numFilters = XzBlock_GetNumFilters(block);
+  if (numFilters == p->numCoders)
+  {
+    for (i = 0; i < numFilters; i++)
+      if (p->ids[i] != block->filters[numFilters - 1 - i].id)
+        break;
+    needReInit = (i != numFilters);
+  }
+  if (needReInit)
+  {
+    MixCoder_Free(p);
+    p->numCoders = numFilters;
+    for (i = 0; i < numFilters; i++)
+    {
+      const CXzFilter *f = &block->filters[numFilters - 1 - i];
+      RINOK(MixCoder_SetFromMethod(p, i, f->id));
+    }
+  }
+  for (i = 0; i < numFilters; i++)
+  {
+    const CXzFilter *f = &block->filters[numFilters - 1 - i];
+    IStateCoder *sc = &p->coders[i];
+    RINOK(sc->SetProps(sc->p, f->props, f->propsSize, p->alloc));
+  }
+  MixCoder_Init(p);
+  return SZ_OK;
+}
+
+void XzUnpacker_Init(CXzUnpacker *p)
+{
+  p->state = XZ_STATE_STREAM_HEADER;
+  p->pos = 0;
+  p->numStreams = 0;
+}
+
+void XzUnpacker_Construct(CXzUnpacker *p, ISzAlloc *alloc)
+{
+  MixCoder_Construct(&p->decoder, alloc);
+  XzUnpacker_Init(p);
+}
+
+void XzUnpacker_Free(CXzUnpacker *p)
+{
+  MixCoder_Free(&p->decoder);
+}
+
+SRes XzUnpacker_Code(CXzUnpacker *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, int finishMode, ECoderStatus *status)
+{
+  SizeT destLenOrig = *destLen;
+  SizeT srcLenOrig = *srcLen;
+  *destLen = 0;
+  *srcLen = 0;
+  *status = CODER_STATUS_NOT_SPECIFIED;
+  for (;;)
+  {
+    SizeT srcRem = srcLenOrig - *srcLen;
+
+    if (p->state == XZ_STATE_BLOCK)
+    {
+      SizeT destLen2 = destLenOrig - *destLen;
+      SizeT srcLen2 = srcLenOrig - *srcLen;
+      SRes res;
+      if (srcLen2 == 0 && destLen2 == 0)
+      {
+        *status = CODER_STATUS_NOT_FINISHED;
+        return SZ_OK;
+      }
+
+      res = MixCoder_Code(&p->decoder, dest, &destLen2, src, &srcLen2, False, finishMode, status);
+      XzCheck_Update(&p->check, dest, destLen2);
+
+      (*srcLen) += srcLen2;
+      src += srcLen2;
+      p->packSize += srcLen2;
+
+      (*destLen) += destLen2;
+      dest += destLen2;
+      p->unpackSize += destLen2;
+
+      RINOK(res);
+
+      if (*status == CODER_STATUS_FINISHED_WITH_MARK)
+      {
+        Byte temp[32];
+        unsigned num = Xz_WriteVarInt(temp, p->packSize + p->blockHeaderSize + XzFlags_GetCheckSize(p->streamFlags));
+        num += Xz_WriteVarInt(temp + num, p->unpackSize);
+        Sha256_Update(&p->sha, temp, num);
+        p->indexSize += num;
+        p->numBlocks++;
+
+        p->state = XZ_STATE_BLOCK_FOOTER;
+        p->pos = 0;
+        p->alignPos = 0;
+      }
+      else if (srcLen2 == 0 && destLen2 == 0)
+        return SZ_OK;
+
+      continue;
+    }
+
+    if (srcRem == 0)
+    {
+      *status = CODER_STATUS_NEEDS_MORE_INPUT;
+      return SZ_OK;
+    }
+
+    switch(p->state)
+    {
+      case XZ_STATE_STREAM_HEADER:
+      {
+        if (p->pos < XZ_STREAM_HEADER_SIZE)
+        {
+          if (p->pos < XZ_SIG_SIZE && *src != XZ_SIG[p->pos])
+            return SZ_ERROR_NO_ARCHIVE;
+          p->buf[p->pos++] = *src++;
+          (*srcLen)++;
+        }
+        else
+        {
+          RINOK(Xz_ParseHeader(&p->streamFlags, p->buf));
+          p->state = XZ_STATE_BLOCK_HEADER;
+          Sha256_Init(&p->sha);
+          p->indexSize = 0;
+          p->numBlocks = 0;
+          p->pos = 0;
+        }
+        break;
+      }
+
+      case XZ_STATE_BLOCK_HEADER:
+      {
+        if (p->pos == 0)
+        {
+          p->buf[p->pos++] = *src++;
+          (*srcLen)++;
+          if (p->buf[0] == 0)
+          {
+            p->indexPreSize = 1 + Xz_WriteVarInt(p->buf + 1, p->numBlocks);
+            p->indexPos = p->indexPreSize;
+            p->indexSize += p->indexPreSize;
+            Sha256_Final(&p->sha, p->shaDigest);
+            Sha256_Init(&p->sha);
+            p->crc = CrcUpdate(CRC_INIT_VAL, p->buf, p->indexPreSize);
+            p->state = XZ_STATE_STREAM_INDEX;
+          }
+          p->blockHeaderSize = ((UInt32)p->buf[0] << 2) + 4;
+        }
+        else if (p->pos != p->blockHeaderSize)
+        {
+          UInt32 cur = p->blockHeaderSize - p->pos;
+          if (cur > srcRem)
+            cur = (UInt32)srcRem;
+          memcpy(p->buf + p->pos, src, cur);
+          p->pos += cur;
+          (*srcLen) += cur;
+          src += cur;
+        }
+        else
+        {
+          RINOK(XzBlock_Parse(&p->block, p->buf));
+          p->state = XZ_STATE_BLOCK;
+          p->packSize = 0;
+          p->unpackSize = 0;
+          XzCheck_Init(&p->check, XzFlags_GetCheckType(p->streamFlags));
+          RINOK(XzDec_Init(&p->decoder, &p->block));
+        }
+        break;
+      }
+
+      case XZ_STATE_BLOCK_FOOTER:
+      {
+        if (((p->packSize + p->alignPos) & 3) != 0)
+        {
+          (*srcLen)++;
+          p->alignPos++;
+          if (*src++ != 0)
+            return SZ_ERROR_CRC;
+        }
+        else
+        {
+          UInt32 checkSize = XzFlags_GetCheckSize(p->streamFlags);
+          UInt32 cur = checkSize - p->pos;
+          if (cur != 0)
+          {
+            if (cur > srcRem)
+              cur = (UInt32)srcRem;
+            memcpy(p->buf + p->pos, src, cur);
+            p->pos += cur;
+            (*srcLen) += cur;
+            src += cur;
+          }
+          else
+          {
+            Byte digest[XZ_CHECK_SIZE_MAX];
+            p->state = XZ_STATE_BLOCK_HEADER;
+            p->pos = 0;
+            if (XzCheck_Final(&p->check, digest) && memcmp(digest, p->buf, checkSize) != 0)
+              return SZ_ERROR_CRC;
+          }
+        }
+        break;
+      }
+
+      case XZ_STATE_STREAM_INDEX:
+      {
+        if (p->pos < p->indexPreSize)
+        {
+          (*srcLen)++;
+          if (*src++ != p->buf[p->pos++])
+            return SZ_ERROR_CRC;
+        }
+        else
+        {
+          if (p->indexPos < p->indexSize)
+          {
+            UInt64 cur = p->indexSize - p->indexPos;
+            if (srcRem > cur)
+              srcRem = (SizeT)cur;
+            p->crc = CrcUpdate(p->crc, src, srcRem);
+            Sha256_Update(&p->sha, src, srcRem);
+            (*srcLen) += srcRem;
+            src += srcRem;
+            p->indexPos += srcRem;
+          }
+          else if ((p->indexPos & 3) != 0)
+          {
+            Byte b = *src++;
+            p->crc = CRC_UPDATE_BYTE(p->crc, b);
+            (*srcLen)++;
+            p->indexPos++;
+            p->indexSize++;
+            if (b != 0)
+              return SZ_ERROR_CRC;
+          }
+          else
+          {
+            Byte digest[SHA256_DIGEST_SIZE];
+            p->state = XZ_STATE_STREAM_INDEX_CRC;
+            p->indexSize += 4;
+            p->pos = 0;
+            Sha256_Final(&p->sha, digest);
+            if (memcmp(digest, p->shaDigest, SHA256_DIGEST_SIZE) != 0)
+              return SZ_ERROR_CRC;
+          }
+        }
+        break;
+      }
+
+      case XZ_STATE_STREAM_INDEX_CRC:
+      {
+        if (p->pos < 4)
+        {
+          (*srcLen)++;
+          p->buf[p->pos++] = *src++;
+        }
+        else
+        {
+          p->state = XZ_STATE_STREAM_FOOTER;
+          p->pos = 0;
+          if (CRC_GET_DIGEST(p->crc) != GetUi32(p->buf))
+            return SZ_ERROR_CRC;
+        }
+        break;
+      }
+
+      case XZ_STATE_STREAM_FOOTER:
+      {
+        UInt32 cur = XZ_STREAM_FOOTER_SIZE - p->pos;
+        if (cur > srcRem)
+          cur = (UInt32)srcRem;
+        memcpy(p->buf + p->pos, src, cur);
+        p->pos += cur;
+        (*srcLen) += cur;
+        src += cur;
+        if (p->pos == XZ_STREAM_FOOTER_SIZE)
+        {
+          p->state = XZ_STATE_STREAM_PADDING;
+          p->numStreams++;
+          p->padSize = 0;
+          if (!Xz_CheckFooter(p->streamFlags, p->indexSize, p->buf))
+            return SZ_ERROR_CRC;
+        }
+        break;
+      }
+
+      case XZ_STATE_STREAM_PADDING:
+      {
+        if (*src != 0)
+        {
+          if (((UInt32)p->padSize & 3) != 0)
+            return SZ_ERROR_NO_ARCHIVE;
+          p->pos = 0;
+          p->state = XZ_STATE_STREAM_HEADER;
+        }
+        else
+        {
+          (*srcLen)++;
+          src++;
+          p->padSize++;
+        }
+        break;
+      }
+
+      case XZ_STATE_BLOCK: break; /* to disable GCC warning */
+    }
+  }
+  /*
+  if (p->state == XZ_STATE_FINISHED)
+    *status = CODER_STATUS_FINISHED_WITH_MARK;
+  return SZ_OK;
+  */
+}
+
+Bool XzUnpacker_IsStreamWasFinished(CXzUnpacker *p)
+{
+  return (p->state == XZ_STATE_STREAM_PADDING) && (((UInt32)p->padSize & 3) == 0);
+}
diff -Nru src-old/lib/lib7z/XzEnc.c src/lib/lib7z/XzEnc.c
--- src-old/lib/lib7z/XzEnc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzEnc.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,520 @@
+/* XzEnc.c -- Xz Encode
+2011-02-07 : Igor Pavlov : Public domain */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "7zCrc.h"
+#include "Alloc.h"
+#include "Bra.h"
+#include "CpuArch.h"
+#ifdef USE_SUBBLOCK
+#include "Bcj3Enc.c"
+#include "SbFind.c"
+#include "SbEnc.c"
+#endif
+
+#include "XzEnc.h"
+
+static void *SzBigAlloc(void *p, size_t size) { p = p; return BigAlloc(size); }
+static void SzBigFree(void *p, void *address) { p = p; BigFree(address); }
+static ISzAlloc g_BigAlloc = { SzBigAlloc, SzBigFree };
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define XzBlock_ClearFlags(p)       (p)->flags = 0;
+#define XzBlock_SetNumFilters(p, n) (p)->flags |= ((n) - 1);
+#define XzBlock_SetHasPackSize(p)   (p)->flags |= XZ_BF_PACK_SIZE;
+#define XzBlock_SetHasUnpackSize(p) (p)->flags |= XZ_BF_UNPACK_SIZE;
+
+static SRes WriteBytes(ISeqOutStream *s, const void *buf, UInt32 size)
+{
+  return (s->Write(s, buf, size) == size) ? SZ_OK : SZ_ERROR_WRITE;
+}
+
+static SRes WriteBytesAndCrc(ISeqOutStream *s, const void *buf, UInt32 size, UInt32 *crc)
+{
+  *crc = CrcUpdate(*crc, buf, size);
+  return WriteBytes(s, buf, size);
+}
+
+SRes Xz_WriteHeader(CXzStreamFlags f, ISeqOutStream *s)
+{
+  UInt32 crc;
+  Byte header[XZ_STREAM_HEADER_SIZE];
+  memcpy(header, XZ_SIG, XZ_SIG_SIZE);
+  header[XZ_SIG_SIZE] = (Byte)(f >> 8);
+  header[XZ_SIG_SIZE + 1] = (Byte)(f & 0xFF);
+  crc = CrcCalc(header + XZ_SIG_SIZE, XZ_STREAM_FLAGS_SIZE);
+  SetUi32(header + XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZE, crc);
+  return WriteBytes(s, header, XZ_STREAM_HEADER_SIZE);
+}
+
+SRes XzBlock_WriteHeader(const CXzBlock *p, ISeqOutStream *s)
+{
+  Byte header[XZ_BLOCK_HEADER_SIZE_MAX];
+
+  unsigned pos = 1;
+  int numFilters, i;
+  header[pos++] = p->flags;
+
+  if (XzBlock_HasPackSize(p)) pos += Xz_WriteVarInt(header + pos, p->packSize);
+  if (XzBlock_HasUnpackSize(p)) pos += Xz_WriteVarInt(header + pos, p->unpackSize);
+  numFilters = XzBlock_GetNumFilters(p);
+  for (i = 0; i < numFilters; i++)
+  {
+    const CXzFilter *f = &p->filters[i];
+    pos += Xz_WriteVarInt(header + pos, f->id);
+    pos += Xz_WriteVarInt(header + pos, f->propsSize);
+    memcpy(header + pos, f->props, f->propsSize);
+    pos += f->propsSize;
+  }
+  while((pos & 3) != 0)
+    header[pos++] = 0;
+  header[0] = (Byte)(pos >> 2);
+  SetUi32(header + pos, CrcCalc(header, pos));
+  return WriteBytes(s, header, pos + 4);
+}
+
+SRes Xz_WriteFooter(CXzStream *p, ISeqOutStream *s)
+{
+  Byte buf[32];
+  UInt64 globalPos;
+  {
+    UInt32 crc = CRC_INIT_VAL;
+    unsigned pos = 1 + Xz_WriteVarInt(buf + 1, p->numBlocks);
+    size_t i;
+
+    globalPos = pos;
+    buf[0] = 0;
+    RINOK(WriteBytesAndCrc(s, buf, pos, &crc));
+    for (i = 0; i < p->numBlocks; i++)
+    {
+      const CXzBlockSizes *block = &p->blocks[i];
+      pos = Xz_WriteVarInt(buf, block->totalSize);
+      pos += Xz_WriteVarInt(buf + pos, block->unpackSize);
+      globalPos += pos;
+      RINOK(WriteBytesAndCrc(s, buf, pos, &crc));
+    }
+    pos = ((unsigned)globalPos & 3);
+    if (pos != 0)
+    {
+      buf[0] = buf[1] = buf[2] = 0;
+      RINOK(WriteBytesAndCrc(s, buf, 4 - pos, &crc));
+      globalPos += 4 - pos;
+    }
+    {
+      SetUi32(buf, CRC_GET_DIGEST(crc));
+      RINOK(WriteBytes(s, buf, 4));
+      globalPos += 4;
+    }
+  }
+
+  {
+    UInt32 indexSize = (UInt32)((globalPos >> 2) - 1);
+    SetUi32(buf + 4, indexSize);
+    buf[8] = (Byte)(p->flags >> 8);
+    buf[9] = (Byte)(p->flags & 0xFF);
+    SetUi32(buf, CrcCalc(buf + 4, 6));
+    memcpy(buf + 10, XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE);
+    return WriteBytes(s, buf, 12);
+  }
+}
+
+SRes Xz_AddIndexRecord(CXzStream *p, UInt64 unpackSize, UInt64 totalSize, ISzAlloc *alloc)
+{
+  if (p->blocks == 0 || p->numBlocksAllocated == p->numBlocks)
+  {
+    size_t num = (p->numBlocks + 1) * 2;
+    size_t newSize = sizeof(CXzBlockSizes) * num;
+    CXzBlockSizes *blocks;
+    if (newSize / sizeof(CXzBlockSizes) != num)
+      return SZ_ERROR_MEM;
+    blocks = alloc->Alloc(alloc, newSize);
+    if (blocks == 0)
+      return SZ_ERROR_MEM;
+    if (p->numBlocks != 0)
+    {
+      memcpy(blocks, p->blocks, p->numBlocks * sizeof(CXzBlockSizes));
+      Xz_Free(p, alloc);
+    }
+    p->blocks = blocks;
+    p->numBlocksAllocated = num;
+  }
+  {
+    CXzBlockSizes *block = &p->blocks[p->numBlocks++];
+    block->totalSize = totalSize;
+    block->unpackSize = unpackSize;
+  }
+  return SZ_OK;
+}
+
+/* ---------- CSeqCheckInStream ---------- */
+
+typedef struct
+{
+  ISeqInStream p;
+  ISeqInStream *realStream;
+  UInt64 processed;
+  CXzCheck check;
+} CSeqCheckInStream;
+
+void SeqCheckInStream_Init(CSeqCheckInStream *p, int mode)
+{
+  p->processed = 0;
+  XzCheck_Init(&p->check, mode);
+}
+
+void SeqCheckInStream_GetDigest(CSeqCheckInStream *p, Byte *digest)
+{
+  XzCheck_Final(&p->check, digest);
+}
+
+static SRes SeqCheckInStream_Read(void *pp, void *data, size_t *size)
+{
+  CSeqCheckInStream *p = (CSeqCheckInStream *)pp;
+  SRes res = p->realStream->Read(p->realStream, data, size);
+  XzCheck_Update(&p->check, data, *size);
+  p->processed += *size;
+  return res;
+}
+
+/* ---------- CSeqSizeOutStream ---------- */
+
+typedef struct
+{
+  ISeqOutStream p;
+  ISeqOutStream *realStream;
+  UInt64 processed;
+} CSeqSizeOutStream;
+
+static size_t MyWrite(void *pp, const void *data, size_t size)
+{
+  CSeqSizeOutStream *p = (CSeqSizeOutStream *)pp;
+  size = p->realStream->Write(p->realStream, data, size);
+  p->processed += size;
+  return size;
+}
+
+/* ---------- CSeqInFilter ---------- */
+
+#define FILTER_BUF_SIZE (1 << 20)
+
+typedef struct
+{
+  ISeqInStream p;
+  ISeqInStream *realStream;
+  IStateCoder StateCoder;
+  Byte *buf;
+  size_t curPos;
+  size_t endPos;
+  int srcWasFinished;
+} CSeqInFilter;
+
+static SRes SeqInFilter_Read(void *pp, void *data, size_t *size)
+{
+  CSeqInFilter *p = (CSeqInFilter *)pp;
+  size_t sizeOriginal = *size;
+  if (sizeOriginal == 0)
+    return S_OK;
+  *size = 0;
+  for (;;)
+  {
+    if (!p->srcWasFinished && p->curPos == p->endPos)
+    {
+      p->curPos = 0;
+      p->endPos = FILTER_BUF_SIZE;
+      RINOK(p->realStream->Read(p->realStream, p->buf, &p->endPos));
+      if (p->endPos == 0)
+        p->srcWasFinished = 1;
+    }
+    {
+      SizeT srcLen = p->endPos - p->curPos;
+      int wasFinished;
+      SRes res;
+      *size = sizeOriginal;
+      res = p->StateCoder.Code(p->StateCoder.p, data, size, p->buf + p->curPos, &srcLen,
+        p->srcWasFinished, CODER_FINISH_ANY, &wasFinished);
+      p->curPos += srcLen;
+      if (*size != 0 || srcLen == 0 || res != 0)
+        return res;
+    }
+  }
+}
+
+static void SeqInFilter_Construct(CSeqInFilter *p)
+{
+  p->buf = NULL;
+  p->p.Read = SeqInFilter_Read;
+}
+
+static void SeqInFilter_Free(CSeqInFilter *p)
+{
+  if (p->buf)
+  {
+    g_Alloc.Free(&g_Alloc, p->buf);
+    p->buf = NULL;
+  }
+}
+
+SRes BraState_SetFromMethod(IStateCoder *p, UInt64 id, int encodeMode, ISzAlloc *alloc);
+
+static SRes SeqInFilter_Init(CSeqInFilter *p, const CXzFilter *props)
+{
+  if (!p->buf)
+  {
+    p->buf = g_Alloc.Alloc(&g_Alloc, FILTER_BUF_SIZE);
+    if (!p->buf)
+      return SZ_ERROR_MEM;
+  }
+  p->curPos = p->endPos = 0;
+  p->srcWasFinished = 0;
+  RINOK(BraState_SetFromMethod(&p->StateCoder, props->id, 1, &g_Alloc));
+  RINOK(p->StateCoder.SetProps(p->StateCoder.p, props->props, props->propsSize, &g_Alloc));
+  p->StateCoder.Init(p->StateCoder.p);
+  return S_OK;
+}
+
+/* ---------- CSbEncInStream ---------- */
+
+#ifdef USE_SUBBLOCK
+
+typedef struct
+{
+  ISeqInStream p;
+  ISeqInStream *inStream;
+  CSbEnc enc;
+} CSbEncInStream;
+
+static SRes SbEncInStream_Read(void *pp, void *data, size_t *size)
+{
+  CSbEncInStream *p = (CSbEncInStream *)pp;
+  size_t sizeOriginal = *size;
+  if (sizeOriginal == 0)
+    return S_OK;
+  for (;;)
+  {
+    if (p->enc.needRead && !p->enc.readWasFinished)
+    {
+      size_t processed = p->enc.needReadSizeMax;
+      RINOK(p->inStream->Read(p->inStream, p->enc.buf + p->enc.readPos, &processed));
+      p->enc.readPos += processed;
+      if (processed == 0)
+      {
+        p->enc.readWasFinished = True;
+        p->enc.isFinalFinished = True;
+      }
+      p->enc.needRead = False;
+    }
+    *size = sizeOriginal;
+    RINOK(SbEnc_Read(&p->enc, data, size));
+    if (*size != 0 || !p->enc.needRead)
+      return S_OK;
+  }
+}
+
+void SbEncInStream_Construct(CSbEncInStream *p, ISzAlloc *alloc)
+{
+  SbEnc_Construct(&p->enc, alloc);
+  p->p.Read = SbEncInStream_Read;
+}
+
+SRes SbEncInStream_Init(CSbEncInStream *p)
+{
+  return SbEnc_Init(&p->enc);
+}
+
+void SbEncInStream_Free(CSbEncInStream *p)
+{
+  SbEnc_Free(&p->enc);
+}
+
+#endif
+
+
+typedef struct
+{
+  CLzma2EncHandle lzma2;
+  #ifdef USE_SUBBLOCK
+  CSbEncInStream sb;
+  #endif
+  CSeqInFilter filter;
+  ISzAlloc *alloc;
+  ISzAlloc *bigAlloc;
+} CLzma2WithFilters;
+
+
+static void Lzma2WithFilters_Construct(CLzma2WithFilters *p, ISzAlloc *alloc, ISzAlloc *bigAlloc)
+{
+  p->alloc = alloc;
+  p->bigAlloc = bigAlloc;
+  p->lzma2 = NULL;
+  #ifdef USE_SUBBLOCK
+  SbEncInStream_Construct(&p->sb, alloc);
+  #endif
+  SeqInFilter_Construct(&p->filter);
+}
+
+static SRes Lzma2WithFilters_Create(CLzma2WithFilters *p)
+{
+  p->lzma2 = Lzma2Enc_Create(p->alloc, p->bigAlloc);
+  if (p->lzma2 == 0)
+    return SZ_ERROR_MEM;
+  return SZ_OK;
+}
+
+static void Lzma2WithFilters_Free(CLzma2WithFilters *p)
+{
+  SeqInFilter_Free(&p->filter);
+  #ifdef USE_SUBBLOCK
+  SbEncInStream_Free(&p->sb);
+  #endif
+  if (p->lzma2)
+  {
+    Lzma2Enc_Destroy(p->lzma2);
+    p->lzma2 = NULL;
+  }
+}
+
+void XzProps_Init(CXzProps *p)
+{
+  p->lzma2Props = 0;
+  p->filterProps = 0;
+  p->checkId = XZ_CHECK_CRC32;
+}
+
+void XzFilterProps_Init(CXzFilterProps *p)
+{
+  p->id = 0;
+  p->delta = 0;
+  p->ip= 0;
+  p->ipDefined = False;
+}
+
+static SRes Xz_Compress(CXzStream *xz, CLzma2WithFilters *lzmaf,
+    ISeqOutStream *outStream, ISeqInStream *inStream,
+    const CXzProps *props, ICompressProgress *progress)
+{
+  xz->flags = (Byte)props->checkId;
+
+  RINOK(Lzma2Enc_SetProps(lzmaf->lzma2, props->lzma2Props));
+  RINOK(Xz_WriteHeader(xz->flags, outStream));
+
+  {
+    CSeqCheckInStream checkInStream;
+    CSeqSizeOutStream seqSizeOutStream;
+    CXzBlock block;
+    int filterIndex = 0;
+    CXzFilter *filter = NULL;
+    const CXzFilterProps *fp = props->filterProps;
+
+    XzBlock_ClearFlags(&block);
+    XzBlock_SetNumFilters(&block, 1 + (fp ? 1 : 0));
+
+    if (fp)
+    {
+      filter = &block.filters[filterIndex++];
+      filter->id = fp->id;
+      filter->propsSize = 0;
+      if (fp->id == XZ_ID_Delta)
+      {
+        filter->props[0] = (Byte)(fp->delta - 1);
+        filter->propsSize = 1;
+      }
+      else if (fp->ipDefined)
+      {
+        SetUi32(filter->props, fp->ip);
+        filter->propsSize = 4;
+      }
+    }
+
+    {
+      CXzFilter *f = &block.filters[filterIndex++];
+      f->id = XZ_ID_LZMA2;
+      f->propsSize = 1;
+      f->props[0] = Lzma2Enc_WriteProperties(lzmaf->lzma2);
+    }
+
+    seqSizeOutStream.p.Write = MyWrite;
+    seqSizeOutStream.realStream = outStream;
+    seqSizeOutStream.processed = 0;
+
+    RINOK(XzBlock_WriteHeader(&block, &seqSizeOutStream.p));
+
+    checkInStream.p.Read = SeqCheckInStream_Read;
+    checkInStream.realStream = inStream;
+    SeqCheckInStream_Init(&checkInStream, XzFlags_GetCheckType(xz->flags));
+
+    if (fp)
+    {
+      #ifdef USE_SUBBLOCK
+      if (fp->id == XZ_ID_Subblock)
+      {
+        lzmaf->sb.inStream = &checkInStream.p;
+        RINOK(SbEncInStream_Init(&lzmaf->sb));
+      }
+      else
+      #endif
+      {
+        lzmaf->filter.realStream = &checkInStream.p;
+        RINOK(SeqInFilter_Init(&lzmaf->filter, filter));
+      }
+    }
+
+    {
+      UInt64 packPos = seqSizeOutStream.processed;
+      SRes res = Lzma2Enc_Encode(lzmaf->lzma2, &seqSizeOutStream.p,
+        fp ?
+        #ifdef USE_SUBBLOCK
+        (fp->id == XZ_ID_Subblock) ? &lzmaf->sb.p:
+        #endif
+        &lzmaf->filter.p:
+        &checkInStream.p,
+        progress);
+      RINOK(res);
+      block.unpackSize = checkInStream.processed;
+      block.packSize = seqSizeOutStream.processed - packPos;
+    }
+
+    {
+      unsigned padSize = 0;
+      Byte buf[128];
+      while((((unsigned)block.packSize + padSize) & 3) != 0)
+        buf[padSize++] = 0;
+      SeqCheckInStream_GetDigest(&checkInStream, buf + padSize);
+      RINOK(WriteBytes(&seqSizeOutStream.p, buf, padSize + XzFlags_GetCheckSize(xz->flags)));
+      RINOK(Xz_AddIndexRecord(xz, block.unpackSize, seqSizeOutStream.processed - padSize, &g_Alloc));
+    }
+  }
+  return Xz_WriteFooter(xz, outStream);
+}
+
+SRes Xz_Encode(ISeqOutStream *outStream, ISeqInStream *inStream,
+    const CXzProps *props, ICompressProgress *progress)
+{
+  SRes res;
+  CXzStream xz;
+  CLzma2WithFilters lzmaf;
+  Xz_Construct(&xz);
+  Lzma2WithFilters_Construct(&lzmaf, &g_Alloc, &g_BigAlloc);
+  res = Lzma2WithFilters_Create(&lzmaf);
+  if (res == SZ_OK)
+    res = Xz_Compress(&xz, &lzmaf, outStream, inStream, props, progress);
+  Lzma2WithFilters_Free(&lzmaf);
+  Xz_Free(&xz, &g_Alloc);
+  return res;
+}
+
+SRes Xz_EncodeEmpty(ISeqOutStream *outStream)
+{
+  SRes res;
+  CXzStream xz;
+  Xz_Construct(&xz);
+  res = Xz_WriteHeader(xz.flags, outStream);
+  if (res == SZ_OK)
+    res = Xz_WriteFooter(&xz, outStream);
+  Xz_Free(&xz, &g_Alloc);
+  return res;
+}
diff -Nru src-old/lib/lib7z/XzEnc.h src/lib/lib7z/XzEnc.h
--- src-old/lib/lib7z/XzEnc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzEnc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,39 @@
+/* XzEnc.h -- Xz Encode
+2011-02-07 : Igor Pavlov : Public domain */
+
+#ifndef __XZ_ENC_H
+#define __XZ_ENC_H
+
+#include "Lzma2Enc.h"
+
+#include "Xz.h"
+
+EXTERN_C_BEGIN
+
+typedef struct
+{
+  UInt32 id;
+  UInt32 delta;
+  UInt32 ip;
+  int ipDefined;
+} CXzFilterProps;
+
+void XzFilterProps_Init(CXzFilterProps *p);
+
+typedef struct
+{
+  const CLzma2EncProps *lzma2Props;
+  const CXzFilterProps *filterProps;
+  unsigned checkId;
+} CXzProps;
+
+void XzProps_Init(CXzProps *p);
+
+SRes Xz_Encode(ISeqOutStream *outStream, ISeqInStream *inStream,
+    const CXzProps *props, ICompressProgress *progress);
+
+SRes Xz_EncodeEmpty(ISeqOutStream *outStream);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/lib7z/XzIn.c src/lib/lib7z/XzIn.c
--- src-old/lib/lib7z/XzIn.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/XzIn.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,305 @@
+/* XzIn.c - Xz input
+2011-02-01 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "7zCrc.h"
+#include "CpuArch.h"
+#include "Xz.h"
+
+SRes Xz_ReadHeader(CXzStreamFlags *p, ISeqInStream *inStream)
+{
+  Byte sig[XZ_STREAM_HEADER_SIZE];
+  RINOK(SeqInStream_Read2(inStream, sig, XZ_STREAM_HEADER_SIZE, SZ_ERROR_NO_ARCHIVE));
+  if (memcmp(sig, XZ_SIG, XZ_SIG_SIZE) != 0)
+    return SZ_ERROR_NO_ARCHIVE;
+  return Xz_ParseHeader(p, sig);
+}
+
+#define READ_VARINT_AND_CHECK(buf, pos, size, res) \
+  { unsigned s = Xz_ReadVarInt(buf + pos, size - pos, res); \
+  if (s == 0) return SZ_ERROR_ARCHIVE; pos += s; }
+
+SRes XzBlock_ReadHeader(CXzBlock *p, ISeqInStream *inStream, Bool *isIndex, UInt32 *headerSizeRes)
+{
+  Byte header[XZ_BLOCK_HEADER_SIZE_MAX];
+  unsigned headerSize;
+  *headerSizeRes = 0;
+  RINOK(SeqInStream_ReadByte(inStream, &header[0]));
+  headerSize = ((unsigned)header[0] << 2) + 4;
+  if (headerSize == 0)
+  {
+    *headerSizeRes = 1;
+    *isIndex = True;
+    return SZ_OK;
+  }
+
+  *isIndex = False;
+  *headerSizeRes = headerSize;
+  RINOK(SeqInStream_Read(inStream, header + 1, headerSize - 1));
+  return XzBlock_Parse(p, header);
+}
+
+#define ADD_SIZE_CHECH(size, val) \
+  { UInt64 newSize = size + (val); if (newSize < size) return XZ_SIZE_OVERFLOW; size = newSize; }
+
+UInt64 Xz_GetUnpackSize(const CXzStream *p)
+{
+  UInt64 size = 0;
+  size_t i;
+  for (i = 0; i < p->numBlocks; i++)
+    ADD_SIZE_CHECH(size, p->blocks[i].unpackSize);
+  return size;
+}
+
+UInt64 Xz_GetPackSize(const CXzStream *p)
+{
+  UInt64 size = 0;
+  size_t i;
+  for (i = 0; i < p->numBlocks; i++)
+    ADD_SIZE_CHECH(size, (p->blocks[i].totalSize + 3) & ~(UInt64)3);
+  return size;
+}
+
+/*
+SRes XzBlock_ReadFooter(CXzBlock *p, CXzStreamFlags f, ISeqInStream *inStream)
+{
+  return SeqInStream_Read(inStream, p->check, XzFlags_GetCheckSize(f));
+}
+*/
+
+static SRes Xz_ReadIndex2(CXzStream *p, const Byte *buf, size_t size, ISzAlloc *alloc)
+{
+  size_t i, numBlocks, crcStartPos, pos = 1;
+  UInt32 crc;
+
+  if (size < 5 || buf[0] != 0)
+    return SZ_ERROR_ARCHIVE;
+
+  size -= 4;
+  crc = CrcCalc(buf, size);
+  if (crc != GetUi32(buf + size))
+    return SZ_ERROR_ARCHIVE;
+
+  {
+    UInt64 numBlocks64;
+    READ_VARINT_AND_CHECK(buf, pos, size, &numBlocks64);
+    numBlocks = (size_t)numBlocks64;
+    if (numBlocks != numBlocks64 || numBlocks * 2 > size)
+      return SZ_ERROR_ARCHIVE;
+  }
+
+  crcStartPos = pos;
+  Xz_Free(p, alloc);
+  if (numBlocks != 0)
+  {
+    p->numBlocks = numBlocks;
+    p->numBlocksAllocated = numBlocks;
+    p->blocks = alloc->Alloc(alloc, sizeof(CXzBlockSizes) * numBlocks);
+    if (p->blocks == 0)
+      return SZ_ERROR_MEM;
+    for (i = 0; i < numBlocks; i++)
+    {
+      CXzBlockSizes *block = &p->blocks[i];
+      READ_VARINT_AND_CHECK(buf, pos, size, &block->totalSize);
+      READ_VARINT_AND_CHECK(buf, pos, size, &block->unpackSize);
+      if (block->totalSize == 0)
+        return SZ_ERROR_ARCHIVE;
+    }
+  }
+  while ((pos & 3) != 0)
+    if (buf[pos++] != 0)
+      return SZ_ERROR_ARCHIVE;
+  return (pos == size) ? SZ_OK : SZ_ERROR_ARCHIVE;
+}
+
+static SRes Xz_ReadIndex(CXzStream *p, ILookInStream *stream, UInt64 indexSize, ISzAlloc *alloc)
+{
+  SRes res;
+  size_t size;
+  Byte *buf;
+  if (indexSize > ((UInt32)1 << 31))
+    return SZ_ERROR_UNSUPPORTED;
+  size = (size_t)indexSize;
+  if (size != indexSize)
+    return SZ_ERROR_UNSUPPORTED;
+  buf = alloc->Alloc(alloc, size);
+  if (buf == 0)
+    return SZ_ERROR_MEM;
+  res = LookInStream_Read2(stream, buf, size, SZ_ERROR_UNSUPPORTED);
+  if (res == SZ_OK)
+    res = Xz_ReadIndex2(p, buf, size, alloc);
+  alloc->Free(alloc, buf);
+  return res;
+}
+
+static SRes SeekFromCur(ILookInStream *inStream, Int64 *res)
+{
+  return inStream->Seek(inStream, res, SZ_SEEK_CUR);
+}
+
+static SRes Xz_ReadBackward(CXzStream *p, ILookInStream *stream, Int64 *startOffset, ISzAlloc *alloc)
+{
+  UInt64 indexSize;
+  Byte buf[XZ_STREAM_FOOTER_SIZE];
+
+  if ((*startOffset & 3) != 0 || *startOffset < XZ_STREAM_FOOTER_SIZE)
+    return SZ_ERROR_NO_ARCHIVE;
+  *startOffset = -XZ_STREAM_FOOTER_SIZE;
+  RINOK(SeekFromCur(stream, startOffset));
+
+  RINOK(LookInStream_Read2(stream, buf, XZ_STREAM_FOOTER_SIZE, SZ_ERROR_NO_ARCHIVE));
+
+  if (memcmp(buf + 10, XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE) != 0)
+  {
+    UInt32 total = 0;
+    *startOffset += XZ_STREAM_FOOTER_SIZE;
+    for (;;)
+    {
+      size_t i;
+      #define TEMP_BUF_SIZE (1 << 10)
+      Byte tempBuf[TEMP_BUF_SIZE];
+      if (*startOffset < XZ_STREAM_FOOTER_SIZE || total > (1 << 16))
+        return SZ_ERROR_NO_ARCHIVE;
+      i = (*startOffset > TEMP_BUF_SIZE) ? TEMP_BUF_SIZE : (size_t)*startOffset;
+      total += (UInt32)i;
+      *startOffset = -(Int64)i;
+      RINOK(SeekFromCur(stream, startOffset));
+      RINOK(LookInStream_Read2(stream, tempBuf, i, SZ_ERROR_NO_ARCHIVE));
+      for (; i != 0; i--)
+        if (tempBuf[i - 1] != 0)
+          break;
+      if (i != 0)
+      {
+        if ((i & 3) != 0)
+          return SZ_ERROR_NO_ARCHIVE;
+        *startOffset += i;
+        break;
+      }
+    }
+    if (*startOffset < XZ_STREAM_FOOTER_SIZE)
+      return SZ_ERROR_NO_ARCHIVE;
+    *startOffset -= XZ_STREAM_FOOTER_SIZE;
+    RINOK(stream->Seek(stream, startOffset, SZ_SEEK_SET));
+    RINOK(LookInStream_Read2(stream, buf, XZ_STREAM_FOOTER_SIZE, SZ_ERROR_NO_ARCHIVE));
+    if (memcmp(buf + 10, XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE) != 0)
+      return SZ_ERROR_NO_ARCHIVE;
+  }
+
+  p->flags = (CXzStreamFlags)GetBe16(buf + 8);
+
+  if (!XzFlags_IsSupported(p->flags))
+    return SZ_ERROR_UNSUPPORTED;
+
+  if (GetUi32(buf) != CrcCalc(buf + 4, 6))
+    return SZ_ERROR_ARCHIVE;
+
+  indexSize = ((UInt64)GetUi32(buf + 4) + 1) << 2;
+
+  *startOffset = -(Int64)(indexSize + XZ_STREAM_FOOTER_SIZE);
+  RINOK(SeekFromCur(stream, startOffset));
+
+  RINOK(Xz_ReadIndex(p, stream, indexSize, alloc));
+
+  {
+    UInt64 totalSize = Xz_GetPackSize(p);
+    UInt64 sum = XZ_STREAM_HEADER_SIZE + totalSize + indexSize;
+    if (totalSize == XZ_SIZE_OVERFLOW ||
+      sum >= ((UInt64)1 << 63) ||
+      totalSize >= ((UInt64)1 << 63))
+      return SZ_ERROR_ARCHIVE;
+    *startOffset = -(Int64)sum;
+    RINOK(SeekFromCur(stream, startOffset));
+  }
+  {
+    CXzStreamFlags headerFlags;
+    CSecToRead secToRead;
+    SecToRead_CreateVTable(&secToRead);
+    secToRead.realStream = stream;
+
+    RINOK(Xz_ReadHeader(&headerFlags, &secToRead.s));
+    return (p->flags == headerFlags) ? SZ_OK : SZ_ERROR_ARCHIVE;
+  }
+}
+
+
+/* ---------- Xz Streams ---------- */
+
+void Xzs_Construct(CXzs *p)
+{
+  p->num = p->numAllocated = 0;
+  p->streams = 0;
+}
+
+void Xzs_Free(CXzs *p, ISzAlloc *alloc)
+{
+  size_t i;
+  for (i = 0; i < p->num; i++)
+    Xz_Free(&p->streams[i], alloc);
+  alloc->Free(alloc, p->streams);
+  p->num = p->numAllocated = 0;
+  p->streams = 0;
+}
+
+UInt64 Xzs_GetNumBlocks(const CXzs *p)
+{
+  UInt64 num = 0;
+  size_t i;
+  for (i = 0; i < p->num; i++)
+    num += p->streams[i].numBlocks;
+  return num;
+}
+
+UInt64 Xzs_GetUnpackSize(const CXzs *p)
+{
+  UInt64 size = 0;
+  size_t i;
+  for (i = 0; i < p->num; i++)
+    ADD_SIZE_CHECH(size, Xz_GetUnpackSize(&p->streams[i]));
+  return size;
+}
+
+/*
+UInt64 Xzs_GetPackSize(const CXzs *p)
+{
+  UInt64 size = 0;
+  size_t i;
+  for (i = 0; i < p->num; i++)
+    ADD_SIZE_CHECH(size, Xz_GetTotalSize(&p->streams[i]));
+  return size;
+}
+*/
+
+SRes Xzs_ReadBackward(CXzs *p, ILookInStream *stream, Int64 *startOffset, ICompressProgress *progress, ISzAlloc *alloc)
+{
+  Int64 endOffset = 0;
+  RINOK(stream->Seek(stream, &endOffset, SZ_SEEK_END));
+  *startOffset = endOffset;
+  for (;;)
+  {
+    CXzStream st;
+    SRes res;
+    Xz_Construct(&st);
+    res = Xz_ReadBackward(&st, stream, startOffset, alloc);
+    st.startOffset = *startOffset;
+    RINOK(res);
+    if (p->num == p->numAllocated)
+    {
+      size_t newNum = p->num + p->num / 4 + 1;
+      Byte *data = (Byte *)alloc->Alloc(alloc, newNum * sizeof(CXzStream));
+      if (data == 0)
+        return SZ_ERROR_MEM;
+      p->numAllocated = newNum;
+      memcpy(data, p->streams, p->num * sizeof(CXzStream));
+      alloc->Free(alloc, p->streams);
+      p->streams = (CXzStream *)data;
+    }
+    p->streams[p->num++] = st;
+    if (*startOffset == 0)
+      break;
+    RINOK(stream->Seek(stream, startOffset, SZ_SEEK_SET));
+    if (progress && progress->Progress(progress, endOffset - *startOffset, (UInt64)(Int64)-1) != SZ_OK)
+      return SZ_ERROR_PROGRESS;
+  }
+  return SZ_OK;
+}
diff -Nru src-old/lib/lib7z/x7zAlloc.c src/lib/lib7z/x7zAlloc.c
--- src-old/lib/lib7z/x7zAlloc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/x7zAlloc.c	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,76 @@
+/* 7zAlloc.c -- Allocation functions
+2010-10-29 : Igor Pavlov : Public domain */
+
+#include "7zAlloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32_7Z
+#include <windows.h>
+#endif
+
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+
+#endif
+
+void *SzAlloc(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc %10d bytes; count = %10d", size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, "\nFree; count = %10d", g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_temp %10d bytes;  count = %10d", size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32_7Z
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, "\nFree_temp; count = %10d", g_allocCountTemp);
+  }
+  #ifdef _WIN32_7Z
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}
diff -Nru src-old/lib/lib7z/x7zAlloc.h src/lib/lib7z/x7zAlloc.h
--- src-old/lib/lib7z/x7zAlloc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/x7zAlloc.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,15 @@
+/* 7zAlloc.h -- Allocation functions
+2010-10-29 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include <stdlib.h>
+
+void *SzAlloc(void *p, size_t size);
+void SzFree(void *p, void *address);
+
+void *SzAllocTemp(void *p, size_t size);
+void SzFreeTemp(void *p, void *address);
+
+#endif
diff -Nru src-old/lib/lib7z/x7zFile.c src/lib/lib7z/x7zFile.c
--- src-old/lib/lib7z/x7zFile.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/x7zFile.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,284 @@
+/* 7zFile.c -- File IO
+2009-11-24 : Igor Pavlov : Public domain */
+
+#include "7zFile.h"
+
+#ifndef USE_WINDOWS_FILE
+
+#ifndef UNDER_CE
+#include <errno.h>
+#endif
+
+#else
+
+/*
+   ReadFile and WriteFile functions in Windows have BUG:
+   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
+   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
+   (Insufficient system resources exist to complete the requested service).
+   Probably in some version of Windows there are problems with other sizes:
+   for 32 MB (maybe also for 16 MB).
+   And message can be "Network connection was lost"
+*/
+
+#define kChunkSizeMax (1 << 22)
+
+#endif
+
+void File_Construct(CSzFile *p)
+{
+  #ifdef USE_WINDOWS_FILE
+  p->handle = INVALID_HANDLE_VALUE;
+  #else
+  p->file = NULL;
+  #endif
+}
+
+#if !defined(UNDER_CE) || !defined(USE_WINDOWS_FILE)
+static WRes File_Open(CSzFile *p, const char *name, int writeMode)
+{
+  #ifdef USE_WINDOWS_FILE
+  p->handle = CreateFileA(name,
+      writeMode ? GENERIC_WRITE : GENERIC_READ,
+      FILE_SHARE_READ, NULL,
+      writeMode ? CREATE_ALWAYS : OPEN_EXISTING,
+      FILE_ATTRIBUTE_NORMAL, NULL);
+  return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();
+  #else
+  p->file = fopen(name, writeMode ? "wb+" : "rb");
+  return (p->file != 0) ? 0 :
+    #ifdef UNDER_CE
+    2; /* ENOENT */
+    #else
+    errno;
+    #endif
+  #endif
+}
+
+WRes InFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 0); }
+WRes OutFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 1); }
+#endif
+
+#ifdef USE_WINDOWS_FILE
+static WRes File_OpenW(CSzFile *p, const WCHAR *name, int writeMode)
+{
+  p->handle = CreateFileW(name,
+      writeMode ? GENERIC_WRITE : GENERIC_READ,
+      FILE_SHARE_READ, NULL,
+      writeMode ? CREATE_ALWAYS : OPEN_EXISTING,
+      FILE_ATTRIBUTE_NORMAL, NULL);
+  return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();
+}
+WRes InFile_OpenW(CSzFile *p, const WCHAR *name) { return File_OpenW(p, name, 0); }
+WRes OutFile_OpenW(CSzFile *p, const WCHAR *name) { return File_OpenW(p, name, 1); }
+#endif
+
+WRes File_Close(CSzFile *p)
+{
+  #ifdef USE_WINDOWS_FILE
+  if (p->handle != INVALID_HANDLE_VALUE)
+  {
+    if (!CloseHandle(p->handle))
+      return GetLastError();
+    p->handle = INVALID_HANDLE_VALUE;
+  }
+  #else
+  if (p->file != NULL)
+  {
+    int res = fclose(p->file);
+    if (res != 0)
+      return res;
+    p->file = NULL;
+  }
+  #endif
+  return 0;
+}
+
+WRes File_Read(CSzFile *p, void *data, size_t *size)
+{
+  size_t originalSize = *size;
+  if (originalSize == 0)
+    return 0;
+
+  #ifdef USE_WINDOWS_FILE
+
+  *size = 0;
+  do
+  {
+    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
+    DWORD processed = 0;
+    BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);
+    data = (void *)((Byte *)data + processed);
+    originalSize -= processed;
+    *size += processed;
+    if (!res)
+      return GetLastError();
+    if (processed == 0)
+      break;
+  }
+  while (originalSize > 0);
+  return 0;
+
+  #else
+
+  *size = fread(data, 1, originalSize, p->file);
+  if (*size == originalSize)
+    return 0;
+  return ferror(p->file);
+
+  #endif
+}
+
+WRes File_Write(CSzFile *p, const void *data, size_t *size)
+{
+  size_t originalSize = *size;
+  if (originalSize == 0)
+    return 0;
+
+  #ifdef USE_WINDOWS_FILE
+
+  *size = 0;
+  do
+  {
+    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
+    DWORD processed = 0;
+    BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);
+    data = (void *)((Byte *)data + processed);
+    originalSize -= processed;
+    *size += processed;
+    if (!res)
+      return GetLastError();
+    if (processed == 0)
+      break;
+  }
+  while (originalSize > 0);
+  return 0;
+
+  #else
+
+  *size = fwrite(data, 1, originalSize, p->file);
+  if (*size == originalSize)
+    return 0;
+  return ferror(p->file);
+
+  #endif
+}
+
+WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin)
+{
+  #ifdef USE_WINDOWS_FILE
+
+  LARGE_INTEGER value;
+  DWORD moveMethod;
+  value.LowPart = (DWORD)*pos;
+  value.HighPart = (LONG)((UInt64)*pos >> 16 >> 16); /* for case when UInt64 is 32-bit only */
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
+    case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
+    case SZ_SEEK_END: moveMethod = FILE_END; break;
+    default: return ERROR_INVALID_PARAMETER;
+  }
+  value.LowPart = SetFilePointer(p->handle, value.LowPart, &value.HighPart, moveMethod);
+  if (value.LowPart == 0xFFFFFFFF)
+  {
+    WRes res = GetLastError();
+    if (res != NO_ERROR)
+      return res;
+  }
+  *pos = ((Int64)value.HighPart << 32) | value.LowPart;
+  return 0;
+
+  #else
+
+  int moveMethod;
+  int res;
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
+    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
+    case SZ_SEEK_END: moveMethod = SEEK_END; break;
+    default: return 1;
+  }
+  res = fseek(p->file, (long)*pos, moveMethod);
+  *pos = ftell(p->file);
+  return res;
+
+  #endif
+}
+
+WRes File_GetLength(CSzFile *p, UInt64 *length)
+{
+  #ifdef USE_WINDOWS_FILE
+
+  DWORD sizeHigh;
+  DWORD sizeLow = GetFileSize(p->handle, &sizeHigh);
+  if (sizeLow == 0xFFFFFFFF)
+  {
+    DWORD res = GetLastError();
+    if (res != NO_ERROR)
+      return res;
+  }
+  *length = (((UInt64)sizeHigh) << 32) + sizeLow;
+  return 0;
+
+  #else
+
+  long pos = ftell(p->file);
+  int res = fseek(p->file, 0, SEEK_END);
+  *length = ftell(p->file);
+  fseek(p->file, pos, SEEK_SET);
+  return res;
+
+  #endif
+}
+
+
+/* ---------- FileSeqInStream ---------- */
+
+static SRes FileSeqInStream_Read(void *pp, void *buf, size_t *size)
+{
+  CFileSeqInStream *p = (CFileSeqInStream *)pp;
+  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
+}
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p)
+{
+  p->s.Read = FileSeqInStream_Read;
+}
+
+
+/* ---------- FileInStream ---------- */
+
+static SRes FileInStream_Read(void *pp, void *buf, size_t *size)
+{
+  CFileInStream *p = (CFileInStream *)pp;
+  return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;
+}
+
+static SRes FileInStream_Seek(void *pp, Int64 *pos, ESzSeek origin)
+{
+  CFileInStream *p = (CFileInStream *)pp;
+  return File_Seek(&p->file, pos, origin);
+}
+
+void FileInStream_CreateVTable(CFileInStream *p)
+{
+  p->s.Read = FileInStream_Read;
+  p->s.Seek = FileInStream_Seek;
+}
+
+
+/* ---------- FileOutStream ---------- */
+
+static size_t FileOutStream_Write(void *pp, const void *data, size_t size)
+{
+  CFileOutStream *p = (CFileOutStream *)pp;
+  File_Write(&p->file, data, &size);
+  return size;
+}
+
+void FileOutStream_CreateVTable(CFileOutStream *p)
+{
+  p->s.Write = FileOutStream_Write;
+}
diff -Nru src-old/lib/lib7z/x7zFile.h src/lib/lib7z/x7zFile.h
--- src-old/lib/lib7z/x7zFile.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/lib7z/x7zFile.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,83 @@
+/* 7zFile.h -- File IO
+2009-11-24 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_FILE_H
+#define __7Z_FILE_H
+
+#ifdef _WIN32_7Z
+#define USE_WINDOWS_FILE
+#endif
+
+#ifdef USE_WINDOWS_FILE
+#include <windows.h>
+#else
+#include <stdio.h>
+#endif
+
+#include "Types.h"
+
+EXTERN_C_BEGIN
+
+/* ---------- File ---------- */
+
+typedef struct
+{
+  #ifdef USE_WINDOWS_FILE
+  HANDLE handle;
+  #else
+  FILE *file;
+  #endif
+} CSzFile;
+
+void File_Construct(CSzFile *p);
+#if !defined(UNDER_CE) || !defined(USE_WINDOWS_FILE)
+WRes InFile_Open(CSzFile *p, const char *name);
+WRes OutFile_Open(CSzFile *p, const char *name);
+#endif
+#ifdef USE_WINDOWS_FILE
+WRes InFile_OpenW(CSzFile *p, const WCHAR *name);
+WRes OutFile_OpenW(CSzFile *p, const WCHAR *name);
+#endif
+WRes File_Close(CSzFile *p);
+
+/* reads max(*size, remain file's size) bytes */
+WRes File_Read(CSzFile *p, void *data, size_t *size);
+
+/* writes *size bytes */
+WRes File_Write(CSzFile *p, const void *data, size_t *size);
+
+WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin);
+WRes File_GetLength(CSzFile *p, UInt64 *length);
+
+
+/* ---------- FileInStream ---------- */
+
+typedef struct
+{
+  ISeqInStream s;
+  CSzFile file;
+} CFileSeqInStream;
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p);
+
+
+typedef struct
+{
+  ISeekInStream s;
+  CSzFile file;
+} CFileInStream;
+
+void FileInStream_CreateVTable(CFileInStream *p);
+
+
+typedef struct
+{
+  ISeqOutStream s;
+  CSzFile file;
+} CFileOutStream;
+
+void FileOutStream_CreateVTable(CFileOutStream *p);
+
+EXTERN_C_END
+
+#endif
diff -Nru src-old/lib/util/astring.h src/lib/util/astring.h
--- src-old/lib/util/astring.h	2012-01-08 15:41:35.000000000 +0100
+++ src/lib/util/astring.h	2012-02-16 10:47:18.000000000 +0100
@@ -52,7 +52,7 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-// derived class for C++
+// basic allocated string class
 class astring
 {
 public:
diff -Nru src-old/lib/util/avcomp.c src/lib/util/avcomp.c
--- src-old/lib/util/avcomp.c	2012-01-12 22:19:49.000000000 +0100
+++ src/lib/util/avcomp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,898 +0,0 @@
-/***************************************************************************
-
-    avcomp.c
-
-    Audio/video compression and decompression helpers.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-****************************************************************************
-
-    Each frame is compressed as a unit. The raw data is of the form:
-    (all multibyte values are stored in big-endian format)
-
-        +00 = 'chav' (4 bytes) - fixed header data to identify the format
-        +04 = metasize (1 byte) - size of metadata in bytes (max=255 bytes)
-        +05 = channels (1 byte) - number of audio channels
-        +06 = samples (2 bytes) - number of samples per audio stream
-        +08 = width (2 bytes) - width of video data
-        +0A = height (2 bytes) - height of video data
-        +0C = <metadata> - as raw bytes
-              <audio stream 0> - as signed 16-bit samples
-              <audio stream 1> - as signed 16-bit samples
-              ...
-              <video data> - as a raw array of 8-bit YUY data in (Cb,Y,Cr,Y) order
-
-    When compressed, the data is stored as follows:
-    (all multibyte values are stored in big-endian format)
-
-        +00 = metasize (1 byte) - size of metadata in bytes
-        +01 = channels (1 byte) - number of audio channels
-        +02 = samples (2 bytes) - number of samples per audio stream
-        +04 = width (2 bytes) - width of video data
-        +06 = height (2 bytes) - height of video data
-        +08 = audio huffman size (2 bytes) - size of audio huffman tables
-        +0A = str0size (2 bytes) - compressed size of stream 0
-        +0C = str1size (2 bytes) - compressed size of stream 1
-              ...
-              <metadata> - as raw data
-              <audio huffman table> - Huffman table for audio decoding
-              <audio stream 0 data> - Huffman-compressed deltas
-              <audio stream 1 data> - Huffman-compressed deltas
-              <...>
-              <video huffman tables> - Huffman tables for video decoding
-              <video data> - compressed data
-
-****************************************************************************
-
-    Attempted techniques that have not been worthwhile:
-
-    * Attempted to use integer DCTs from the IJG code; even the "slow"
-      variants produce a lot of error and thus kill our compression ratio,
-      since our compression is based on error not bitrate.
-
-    * Tried various other predictors for the lossless video encoding, but
-      none tended to give any significant gain over predicting the
-      previous pixel.
-
-***************************************************************************/
-
-#include "avcomp.h"
-#include "huffman.h"
-#include "chd.h"
-
-#include <math.h>
-#include <stdlib.h>
-#include <new>
-
-
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-#define MAX_CHANNELS	4
-
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-struct avcomp_state
-{
-	avcomp_state()
-		: maxwidth(0),
-		  maxheight(0),
-		  maxchannels(0),
-		  audiodata(NULL),
-		  ycontext(NULL),
-		  cbcontext(NULL),
-		  crcontext(NULL),
-		  audiohicontext(NULL),
-		  audiolocontext(NULL) { }
-
-	/* video parameters */
-	UINT32				maxwidth, maxheight;
-
-	/* audio parameters */
-	UINT32				maxchannels;
-
-	/* intermediate data */
-	UINT8 *				audiodata;
-
-	/* huffman contexts */
-	huffman_context *	ycontext;
-	huffman_context *	cbcontext;
-	huffman_context *	crcontext;
-	huffman_context *	audiohicontext;
-	huffman_context *	audiolocontext;
-
-	/* configuration data */
-	av_codec_compress_config compress;
-	av_codec_decompress_config decompress;
-};
-
-
-
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
-
-/* encoding helpers */
-static avcomp_error encode_audio(avcomp_state *state, int channels, int samples, const UINT8 **source, int sourcexor, UINT8 *dest, UINT8 *sizes);
-static avcomp_error encode_video(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 *complength);
-static avcomp_error encode_video_lossless(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 *complength);
-
-/* decoding helpers */
-static avcomp_error decode_audio(avcomp_state *state, int channels, int samples, const UINT8 *source, UINT8 **dest, UINT32 dxor, const UINT8 *sizes);
-static avcomp_error decode_video(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor);
-static avcomp_error decode_video_lossless(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 deststride, UINT32 destxor);
-
-
-
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    avcomp_init - allocate and initialize a
-    new state block for compression or
-    decompression
--------------------------------------------------*/
-
-avcomp_state *avcomp_init(UINT32 maxwidth, UINT32 maxheight, UINT32 maxchannels)
-{
-	huffman_error hufferr;
-	avcomp_state *state;
-
-	/* error if out of range */
-	if (maxchannels > MAX_CHANNELS)
-		return NULL;
-
-	/* allocate memory for state block */
-	state = new(std::nothrow) avcomp_state;
-	if (state == NULL)
-		return NULL;
-
-	/* compute the core info */
-	state->maxwidth = maxwidth;
-	state->maxheight = maxheight;
-	state->maxchannels = maxchannels;
-
-	/* now allocate data buffers */
-	state->audiodata = new(std::nothrow) UINT8[65536 * state->maxchannels * 2];
-	if (state->audiodata == NULL)
-		goto cleanup;
-
-	/* create huffman contexts */
-	hufferr = huffman_create_context(&state->ycontext, 16);
-	if (hufferr != HUFFERR_NONE)
-		goto cleanup;
-	hufferr = huffman_create_context(&state->cbcontext, 16);
-	if (hufferr != HUFFERR_NONE)
-		goto cleanup;
-	hufferr = huffman_create_context(&state->crcontext, 16);
-	if (hufferr != HUFFERR_NONE)
-		goto cleanup;
-	hufferr = huffman_create_context(&state->audiohicontext, 16);
-	if (hufferr != HUFFERR_NONE)
-		goto cleanup;
-	hufferr = huffman_create_context(&state->audiolocontext, 16);
-	if (hufferr != HUFFERR_NONE)
-		goto cleanup;
-
-	return state;
-
-cleanup:
-	avcomp_free(state);
-	return NULL;
-}
-
-
-/*-------------------------------------------------
-    avcomp_free - free a state block
--------------------------------------------------*/
-
-void avcomp_free(avcomp_state *state)
-{
-	/* free the data buffers */
-	delete[] state->audiodata;
-
-	/* free the contexts */
-	if (state->ycontext != NULL)
-		huffman_free_context(state->ycontext);
-	if (state->cbcontext != NULL)
-		huffman_free_context(state->cbcontext);
-	if (state->crcontext != NULL)
-		huffman_free_context(state->crcontext);
-	if (state->audiohicontext != NULL)
-		huffman_free_context(state->audiohicontext);
-	if (state->audiolocontext != NULL)
-		huffman_free_context(state->audiolocontext);
-
-	delete state;
-}
-
-
-/*-------------------------------------------------
-    avcomp_config_compress - configure compression
-    parameters
--------------------------------------------------*/
-
-void avcomp_config_compress(avcomp_state *state, av_codec_compress_config *config)
-{
-	state->compress.video.wrap(config->video, config->video.cliprect());
-	state->compress.channels = config->channels;
-	state->compress.samples = config->samples;
-	memcpy(state->compress.audio, config->audio, sizeof(state->compress.audio));
-	state->compress.metalength = config->metalength;
-	state->compress.metadata = config->metadata;
-}
-
-
-/*-------------------------------------------------
-    avcomp_config_decompress - configure
-    decompression parameters
--------------------------------------------------*/
-
-void avcomp_config_decompress(avcomp_state *state, av_codec_decompress_config *config)
-{
-	state->decompress.video.wrap(config->video, config->video.cliprect());
-	state->decompress.maxsamples = config->maxsamples;
-	state->decompress.actsamples = config->actsamples;
-	memcpy(state->decompress.audio, config->audio, sizeof(state->decompress.audio));
-	state->decompress.maxmetalength = config->maxmetalength;
-	state->decompress.actmetalength = config->actmetalength;
-	state->decompress.metadata = config->metadata;
-}
-
-
-
-/***************************************************************************
-    ENCODING/DECODING FRONTENDS
-***************************************************************************/
-
-/*-------------------------------------------------
-    avcomp_encode_data - encode a block of data
-    into a compressed data stream
--------------------------------------------------*/
-
-avcomp_error avcomp_encode_data(avcomp_state *state, const UINT8 *source, UINT8 *dest, UINT32 *complength)
-{
-	const UINT8 *metastart, *videostart, *audiostart[MAX_CHANNELS];
-	UINT32 metasize, channels, samples, width, height;
-	UINT32 audioxor, videoxor, videostride;
-	avcomp_error err;
-	UINT32 dstoffs;
-	int chnum;
-
-	/* extract data from source if present */
-	if (source != NULL)
-	{
-		/* validate the header */
-		if (source[0] != 'c' || source[1] != 'h' || source[2] != 'a' || source[3] != 'v')
-			return AVCERR_INVALID_DATA;
-
-		/* extract info from the header */
-		metasize = source[4];
-		channels = source[5];
-		samples = (source[6] << 8) + source[7];
-		width = (source[8] << 8) + source[9];
-		height = (source[10] << 8) + source[11];
-
-		/* determine the start of each piece of data */
-		source += 12;
-		metastart = source;
-		source += metasize;
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			audiostart[chnum] = source;
-			source += 2 * samples;
-		}
-		videostart = source;
-
-		/* data is assumed to be big-endian already */
-		audioxor = videoxor = 0;
-		videostride = 2 * width;
-	}
-
-	/* otherwise, extract from the state */
-	else
-	{
-		UINT16 betest = 0;
-
-		/* extract metadata information */
-		metastart = state->compress.metadata;
-		metasize = state->compress.metalength;
-		if ((metastart == NULL && metasize != 0) || (metastart != NULL && metasize == 0))
-			return AVCERR_INVALID_CONFIGURATION;
-
-		/* extract audio information */
-		channels = state->compress.channels;
-		samples = state->compress.samples;
-		for (chnum = 0; chnum < channels; chnum++)
-			audiostart[chnum] = (const UINT8 *)state->compress.audio[chnum];
-
-		/* extract video information */
-		videostart = NULL;
-		videostride = width = height = 0;
-		if (state->compress.video.valid())
-		{
-			videostart = reinterpret_cast<const UINT8 *>(&state->compress.video.pix(0));
-			videostride = state->compress.video.rowpixels() * 2;
-			width = state->compress.video.width();
-			height = state->compress.video.height();
-		}
-
-		/* data is assumed to be native-endian */
-		*(UINT8 *)&betest = 1;
-		audioxor = videoxor = (betest == 1) ? 1 : 0;
-	}
-
-	/* validate the info from the header */
-	if (width > state->maxwidth || height > state->maxheight)
-		return AVCERR_VIDEO_TOO_LARGE;
-	if (channels > state->maxchannels)
-		return AVCERR_AUDIO_TOO_LARGE;
-
-	/* write the basics to the new header */
-	dest[0] = metasize;
-	dest[1] = channels;
-	dest[2] = samples >> 8;
-	dest[3] = samples;
-	dest[4] = width >> 8;
-	dest[5] = width;
-	dest[6] = height >> 8;
-	dest[7] = height;
-
-	/* starting offsets */
-	dstoffs = 10 + 2 * channels;
-
-	/* copy the metadata first */
-	if (metasize > 0)
-	{
-		memcpy(dest + dstoffs, metastart, metasize);
-		dstoffs += metasize;
-	}
-
-	/* encode the audio channels */
-	if (channels > 0)
-	{
-		/* encode the audio */
-		err = encode_audio(state, channels, samples, audiostart, audioxor, dest + dstoffs, &dest[8]);
-		if (err != AVCERR_NONE)
-			return err;
-
-		/* advance the pointers past the data */
-		dstoffs += (dest[8] << 8) + dest[9];
-		for (chnum = 0; chnum < channels; chnum++)
-			dstoffs += (dest[10 + 2 * chnum] << 8) + dest[11 + 2 * chnum];
-	}
-
-	/* encode the video data */
-	if (width > 0 && height > 0)
-	{
-		UINT32 vidlength = 0;
-
-		/* encode the video */
-		err = encode_video(state, width, height, videostart, videostride, videoxor, dest + dstoffs, &vidlength);
-		if (err != AVCERR_NONE)
-			return err;
-
-		/* advance the pointers past the data */
-		dstoffs += vidlength;
-	}
-
-	/* set the total compression */
-	*complength = dstoffs;
-	return AVCERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    avcomp_decode_data - decode both
-    audio and video from a raw data stream
--------------------------------------------------*/
-
-avcomp_error avcomp_decode_data(avcomp_state *state, const UINT8 *source, UINT32 complength, UINT8 *dest)
-{
-	UINT8 *metastart, *videostart, *audiostart[MAX_CHANNELS];
-	UINT32 metasize, channels, samples, width, height;
-	UINT32 audioxor, videoxor, videostride;
-	UINT32 srcoffs, totalsize;
-	avcomp_error err;
-	int chnum;
-
-	/* extract info from the header */
-	if (complength < 8)
-		return AVCERR_INVALID_DATA;
-	metasize = source[0];
-	channels = source[1];
-	samples = (source[2] << 8) + source[3];
-	width = (source[4] << 8) + source[5];
-	height = (source[6] << 8) + source[7];
-
-	/* validate the info from the header */
-	if (width > state->maxwidth || height > state->maxheight)
-		return AVCERR_VIDEO_TOO_LARGE;
-	if (channels > state->maxchannels)
-		return AVCERR_AUDIO_TOO_LARGE;
-
-	/* validate that the sizes make sense */
-	if (complength < 10 + 2 * channels)
-		return AVCERR_INVALID_DATA;
-	totalsize = 10 + 2 * channels;
-	totalsize += (source[8] << 8) | source[9];
-	for (chnum = 0; chnum < channels; chnum++)
-		totalsize += (source[10 + 2 * chnum] << 8) | source[11 + 2 * chnum];
-	if (totalsize >= complength)
-		return AVCERR_INVALID_DATA;
-
-	/* starting offsets */
-	srcoffs = 10 + 2 * channels;
-
-	/* if we are decoding raw, set up the output parameters */
-	if (dest != NULL)
-	{
-		/* create a header */
-		dest[0] = 'c';
-		dest[1] = 'h';
-		dest[2] = 'a';
-		dest[3] = 'v';
-		dest[4] = metasize;
-		dest[5] = channels;
-		dest[6] = samples >> 8;
-		dest[7] = samples;
-		dest[8] = width >> 8;
-		dest[9] = width;
-		dest[10] = height >> 8;
-		dest[11] = height;
-
-		/* determine the start of each piece of data */
-		dest += 12;
-		metastart = dest;
-		dest += metasize;
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			audiostart[chnum] = dest;
-			dest += 2 * samples;
-		}
-		videostart = dest;
-
-		/* data is assumed to be big-endian already */
-		audioxor = videoxor = 0;
-		videostride = 2 * width;
-	}
-
-	/* otherwise, extract from the state */
-	else
-	{
-		UINT16 betest = 0;
-
-		/* determine the start of each piece of data */
-		metastart = state->decompress.metadata;
-		for (chnum = 0; chnum < channels; chnum++)
-			audiostart[chnum] = (UINT8 *)state->decompress.audio[chnum];
-		videostart = (state->decompress.video.valid()) ? reinterpret_cast<UINT8 *>(&state->decompress.video.pix(0)) : NULL;
-		videostride = (state->decompress.video.valid()) ? state->decompress.video.rowpixels() * 2 : 0;
-
-		/* data is assumed to be native-endian */
-		*(UINT8 *)&betest = 1;
-		audioxor = videoxor = (betest == 1) ? 1 : 0;
-
-		/* verify against sizes */
-		if (state->decompress.video.valid() && (state->decompress.video.width() < width || state->decompress.video.height() < height))
-			return AVCERR_VIDEO_TOO_LARGE;
-		for (chnum = 0; chnum < channels; chnum++)
-			if (state->decompress.audio[chnum] != NULL && state->decompress.maxsamples < samples)
-				return AVCERR_AUDIO_TOO_LARGE;
-		if (state->decompress.metadata != NULL && state->decompress.maxmetalength < metasize)
-			return AVCERR_METADATA_TOO_LARGE;
-
-		/* set the output values */
-		if (state->decompress.actsamples != NULL)
-			*state->decompress.actsamples = samples;
-		if (state->decompress.actmetalength != NULL)
-			*state->decompress.actmetalength = metasize;
-	}
-
-	/* copy the metadata first */
-	if (metasize > 0)
-	{
-		if (metastart != NULL)
-			memcpy(metastart, source + srcoffs, metasize);
-		srcoffs += metasize;
-	}
-
-	/* decode the audio channels */
-	if (channels > 0)
-	{
-		/* decode the audio */
-		err = decode_audio(state, channels, samples, source + srcoffs, audiostart, audioxor, &source[8]);
-		if (err != AVCERR_NONE)
-			return err;
-
-		/* advance the pointers past the data */
-		srcoffs += (source[8] << 8) + source[9];
-		for (chnum = 0; chnum < channels; chnum++)
-			srcoffs += (source[10 + 2 * chnum] << 8) + source[11 + 2 * chnum];
-	}
-
-	/* decode the video data */
-	if (width > 0 && height > 0 && videostart != NULL)
-	{
-		/* decode the video */
-		err = decode_video(state, width, height, source + srcoffs, complength - srcoffs, videostart, videostride, videoxor);
-		if (err != AVCERR_NONE)
-			return err;
-	}
-	return AVCERR_NONE;
-}
-
-
-
-/***************************************************************************
-    ENCODING HELPERS
-***************************************************************************/
-
-/*-------------------------------------------------
-    encode_audio - encode raw audio data
-    to the destination
--------------------------------------------------*/
-
-static avcomp_error encode_audio(avcomp_state *state, int channels, int samples, const UINT8 **source, int sourcexor, UINT8 *dest, UINT8 *sizes)
-{
-	UINT32 size, huffsize, totalsize;
-	huffman_context *contexts[2];
-	huffman_error hufferr;
-	UINT8 *output = dest;
-	int chnum, sampnum;
-	UINT8 *deltabuf;
-
-	/* iterate over channels to compute deltas */
-	deltabuf = state->audiodata;
-	for (chnum = 0; chnum < channels; chnum++)
-	{
-		const UINT8 *srcdata = source[chnum];
-		INT16 prevsample = 0;
-
-		/* extract audio data into hi and lo deltas stored in big-endian order */
-		for (sampnum = 0; sampnum < samples; sampnum++)
-		{
-			INT16 newsample = (srcdata[0 ^ sourcexor] << 8) | srcdata[1 ^ sourcexor];
-			INT16 delta = newsample - prevsample;
-			prevsample = newsample;
-			*deltabuf++ = delta >> 8;
-			*deltabuf++ = delta;
-			srcdata += 2;
-		}
-	}
-
-	/* compute the trees */
-	contexts[0] = state->audiohicontext;
-	contexts[1] = state->audiolocontext;
-	hufferr = huffman_compute_tree_interleaved(2, contexts, state->audiodata, samples * 2, channels, samples * 2, 0);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-
-	/* export them to the output */
-	hufferr = huffman_export_tree(state->audiohicontext, output, 256, &size);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += size;
-	hufferr = huffman_export_tree(state->audiolocontext, output, 256, &size);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += size;
-
-	/* note the size of the two trees */
-	huffsize = output - dest;
-	sizes[0] = huffsize >> 8;
-	sizes[1] = huffsize;
-
-	/* iterate over channels */
-	totalsize = huffsize;
-	for (chnum = 0; chnum < channels; chnum++)
-	{
-		const UINT8 *input = state->audiodata + chnum * samples * 2;
-
-		/* encode the data */
-		hufferr = huffman_encode_data_interleaved(2, contexts, input, samples * 2, 1, 0, 0, output, samples * 2, &size);
-		if (hufferr != HUFFERR_NONE)
-			return AVCERR_COMPRESSION_ERROR;
-		output += size;
-
-		/* store the size of this stream */
-		totalsize += size;
-		if (totalsize >= channels * samples * 2)
-			break;
-		sizes[chnum * 2 + 2] = size >> 8;
-		sizes[chnum * 2 + 3] = size;
-	}
-
-	/* if we ran out of room, throw it all away and just store raw */
-	if (chnum < channels)
-	{
-		memcpy(dest, state->audiodata, channels * samples * 2);
-		size = samples * 2;
-		sizes[0] = sizes[1] = 0;
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			sizes[chnum * 2 + 2] = size >> 8;
-			sizes[chnum * 2 + 3] = size;
-		}
-	}
-
-	return AVCERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    encode_video - encode raw video data
-    to the destination
--------------------------------------------------*/
-
-static avcomp_error encode_video(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 *complength)
-{
-	/* only lossless supported at this time */
-	return encode_video_lossless(state, width, height, source, sstride, sxor, dest, complength);
-}
-
-
-/*-------------------------------------------------
-    encode_video_lossless - do a lossless video
-    encoding using deltas and huffman encoding
--------------------------------------------------*/
-
-static avcomp_error encode_video_lossless(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 *complength)
-{
-	UINT32 srcbytes = width * height * 2;
-	huffman_context *contexts[4];
-	huffman_error hufferr;
-	UINT32 outbytes;
-	UINT8 *output;
-
-	/* set up the output; first byte is 0x80 to indicate lossless encoding */
-	output = dest;
-	*output++ = 0x80;
-
-	/* now encode to the destination using two trees, one for the Y and one for the Cr/Cb */
-	contexts[0] = state->ycontext;
-	contexts[1] = state->cbcontext;
-	contexts[2] = state->ycontext;
-	contexts[3] = state->crcontext;
-
-	/* compute the histograms for the data */
-	hufferr = huffman_deltarle_compute_tree_interleaved(4, contexts, source, width * 2, height, sstride, sxor);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-
-	/* export the trees to the data stream */
-	hufferr = huffman_deltarle_export_tree(state->ycontext, output, 256, &outbytes);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += outbytes;
-	hufferr = huffman_deltarle_export_tree(state->cbcontext, output, 256, &outbytes);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += outbytes;
-	hufferr = huffman_deltarle_export_tree(state->crcontext, output, 256, &outbytes);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += outbytes;
-
-	/* encode the data using the trees */
-	hufferr = huffman_deltarle_encode_data_interleaved(4, contexts, source, width * 2, height, sstride, sxor, output, srcbytes, &outbytes);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_COMPRESSION_ERROR;
-	output += outbytes;
-
-	/* set the final length */
-	*complength = output - dest;
-	return AVCERR_NONE;
-}
-
-
-
-/***************************************************************************
-    DECODING HELPERS
-***************************************************************************/
-
-/*-------------------------------------------------
-    decode_audio - decode audio from a
-    compressed data stream
--------------------------------------------------*/
-
-static avcomp_error decode_audio(avcomp_state *state, int channels, int samples, const UINT8 *source, UINT8 **dest, UINT32 dxor, const UINT8 *sizes)
-{
-	huffman_context *contexts[2];
-	UINT32 actsize, huffsize;
-	huffman_error hufferr;
-	int chnum, sampnum;
-	UINT16 size;
-
-	/* if no huffman length, just copy the data */
-	size = (sizes[0] << 8) | sizes[1];
-	if (size == 0)
-	{
-		/* loop over channels */
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			UINT8 *curdest = dest[chnum];
-
-			/* extract the size of this channel */
-			size = (sizes[chnum * 2 + 2] << 8) | sizes[chnum * 2 + 3];
-
-			/* extract data from the deltas */
-			if (dest[chnum] != NULL)
-			{
-				INT16 prevsample = 0;
-				for (sampnum = 0; sampnum < samples; sampnum++)
-				{
-					INT16 delta = (source[0] << 8) | source[1];
-					INT16 newsample = prevsample + delta;
-					prevsample = newsample;
-
-					curdest[0 ^ dxor] = newsample >> 8;
-					curdest[1 ^ dxor] = newsample;
-					source += 2;
-					curdest += 2;
-				}
-			}
-			else
-				source += size;
-		}
-		return AVCERR_NONE;
-	}
-
-	/* extract the huffman trees */
-	hufferr = huffman_import_tree(state->audiohicontext, source, size, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	source += actsize;
-	huffsize = actsize;
-
-	hufferr = huffman_import_tree(state->audiolocontext, source, size, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	source += actsize;
-	huffsize += actsize;
-	if (huffsize != size)
-		return AVCERR_INVALID_DATA;
-
-	/* set up the contexts */
-	contexts[0] = state->audiohicontext;
-	contexts[1] = state->audiolocontext;
-
-	/* now loop over channels and decode their data */
-	for (chnum = 0; chnum < channels; chnum++)
-	{
-		/* extract the size of this channel */
-		size = (sizes[chnum * 2 + 2] << 8) | sizes[chnum * 2 + 3];
-
-		/* decode the data */
-		if (dest[chnum] != NULL)
-		{
-			UINT8 *deltabuf = state->audiodata + chnum * samples * 2;
-			hufferr = huffman_decode_data_interleaved(2, contexts, source, size, deltabuf, samples * 2, 1, 0, 0, &actsize);
-			if (hufferr != HUFFERR_NONE || actsize != size)
-				return AVCERR_INVALID_DATA;
-		}
-
-		/* advance */
-		source += size;
-	}
-
-	/* reassemble audio from the deltas */
-	for (chnum = 0; chnum < channels; chnum++)
-		if (dest[chnum] != NULL)
-		{
-			UINT8 *deltabuf = state->audiodata + chnum * samples * 2;
-			UINT8 *curdest = dest[chnum];
-			INT16 prevsample = 0;
-
-			for (sampnum = 0; sampnum < samples; sampnum++)
-			{
-				INT16 delta = (deltabuf[0] << 8) | deltabuf[1];
-				INT16 newsample = prevsample + delta;
-				prevsample = newsample;
-
-				curdest[0 ^ dxor] = newsample >> 8;
-				curdest[1 ^ dxor] = newsample;
-				deltabuf += 2;
-				curdest += 2;
-			}
-		}
-
-	return AVCERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    decode_video - decode video from a
-    compressed data stream
--------------------------------------------------*/
-
-static avcomp_error decode_video(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor)
-{
-	/* if the high bit of the first byte is set, we decode losslessly */
-	if (source[0] & 0x80)
-		return decode_video_lossless(state, width, height, source, complength, dest, dstride, dxor);
-	else
-		return AVCERR_INVALID_DATA;
-}
-
-
-/*-------------------------------------------------
-    decode_video_lossless - do a lossless video
-    decoding using deltas and huffman encoding
--------------------------------------------------*/
-
-static avcomp_error decode_video_lossless(avcomp_state *state, int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 deststride, UINT32 destxor)
-{
-	const UINT8 *sourceend = source + complength;
-	huffman_context *contexts[4];
-	huffman_error hufferr;
-	UINT32 actsize;
-
-	/* skip the first byte */
-	source++;
-
-	/* import the tables */
-	hufferr = huffman_deltarle_import_tree(state->ycontext, source, sourceend - source, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	source += actsize;
-	hufferr = huffman_deltarle_import_tree(state->cbcontext, source, sourceend - source, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	source += actsize;
-	hufferr = huffman_deltarle_import_tree(state->crcontext, source, sourceend - source, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	source += actsize;
-
-	/* set up the decoding contexts */
-	contexts[0] = state->ycontext;
-	contexts[1] = state->cbcontext;
-	contexts[2] = state->ycontext;
-	contexts[3] = state->crcontext;
-
-	/* decode to the destination */
-	hufferr = huffman_deltarle_decode_data_interleaved(4, contexts, source, sourceend - source, dest, width * 2, height, deststride, destxor, &actsize);
-	if (hufferr != HUFFERR_NONE)
-		return AVCERR_INVALID_DATA;
-	if (actsize != sourceend - source)
-		return AVCERR_INVALID_DATA;
-
-	return AVCERR_NONE;
-}
diff -Nru src-old/lib/util/avcomp.h src/lib/util/avcomp.h
--- src-old/lib/util/avcomp.h	2012-01-12 22:19:49.000000000 +0100
+++ src/lib/util/avcomp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-/***************************************************************************
-
-    avcomp.h
-
-    Audio/video compression and decompression helpers.
-
-****************************************************************************
-
-    Copyright Aaron Giles
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-        * Redistributions of source code must retain the above copyright
-          notice, this list of conditions and the following disclaimer.
-        * Redistributions in binary form must reproduce the above copyright
-          notice, this list of conditions and the following disclaimer in
-          the documentation and/or other materials provided with the
-          distribution.
-        * Neither the name 'MAME' nor the names of its contributors may be
-          used to endorse or promote products derived from this software
-          without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-***************************************************************************/
-
-#ifndef __AVCOMP_H__
-#define __AVCOMP_H__
-
-#include "osdcore.h"
-#include "bitmap.h"
-
-
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-/* errors */
-enum _avcomp_error
-{
-	AVCERR_NONE = 0,
-	AVCERR_INVALID_DATA,
-	AVCERR_VIDEO_TOO_LARGE,
-	AVCERR_AUDIO_TOO_LARGE,
-	AVCERR_METADATA_TOO_LARGE,
-	AVCERR_OUT_OF_MEMORY,
-	AVCERR_COMPRESSION_ERROR,
-	AVCERR_TOO_MANY_CHANNELS,
-	AVCERR_INVALID_CONFIGURATION
-};
-typedef enum _avcomp_error avcomp_error;
-
-/* default decompression parameters */
-#define AVCOMP_ENABLE_META					(1 << 0)
-#define AVCOMP_ENABLE_VIDEO					(1 << 1)
-#define AVCOMP_ENABLE_AUDIO(x)				(1 << (2 + (x)))
-#define AVCOMP_ENABLE_DEFAULT				(~0)
-
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-/* compression configuration */
-struct av_codec_compress_config
-{
-	av_codec_compress_config()
-		: channels(0),
-		  samples(0),
-		  metalength(0),
-		  metadata(NULL)
-	{
-		memset(audio, 0, sizeof(audio));
-	}
-
-	bitmap_yuy16 video;						/* pointer to video bitmap */
-	UINT32		channels;					/* number of channels */
-	UINT32		samples;					/* number of samples per channel */
-	INT16 *		audio[16];					/* pointer to individual audio channels */
-	UINT32		metalength;					/* length of metadata */
-	UINT8 *		metadata;					/* pointer to metadata buffer */
-};
-
-
-/* decompression configuration */
-struct av_codec_decompress_config
-{
-	av_codec_decompress_config()
-		: maxsamples(0),
-		  actsamples(0),
-		  maxmetalength(0),
-		  actmetalength(0),
-		  metadata(NULL)
-	{
-		memset(audio, 0, sizeof(audio));
-	}
-
-	bitmap_yuy16 video;						/* pointer to video bitmap */
-	UINT32		maxsamples;					/* maximum number of samples per channel */
-	UINT32 *	actsamples;					/* actual number of samples per channel */
-	INT16 *		audio[16];					/* pointer to individual audio channels */
-	UINT32		maxmetalength;				/* maximum length of metadata */
-	UINT32 *	actmetalength;				/* actual length of metadata */
-	UINT8 *		metadata;					/* pointer to metadata buffer */
-};
-
-
-/* opaque state */
-struct avcomp_state;
-
-
-
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
-
-avcomp_state *avcomp_init(UINT32 maxwidth, UINT32 maxheight, UINT32 maxchannels);
-void avcomp_free(avcomp_state *state);
-
-void avcomp_config_compress(avcomp_state *state, av_codec_compress_config *config);
-void avcomp_config_decompress(avcomp_state *state, av_codec_decompress_config *config);
-
-avcomp_error avcomp_encode_data(avcomp_state *state, const UINT8 *source, UINT8 *dest, UINT32 *complength);
-avcomp_error avcomp_decode_data(avcomp_state *state, const UINT8 *source, UINT32 complength, UINT8 *dest);
-
-#endif
diff -Nru src-old/lib/util/avhuff.c src/lib/util/avhuff.c
--- src-old/lib/util/avhuff.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/avhuff.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,977 @@
+/***************************************************************************
+
+    avhuff.c
+
+    Audio/video compression and decompression helpers.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+****************************************************************************
+
+    Each frame is compressed as a unit. The raw data is of the form:
+    (all multibyte values are stored in big-endian format)
+
+        +00 = 'chav' (4 bytes) - fixed header data to identify the format
+        +04 = metasize (1 byte) - size of metadata in bytes (max=255 bytes)
+        +05 = channels (1 byte) - number of audio channels
+        +06 = samples (2 bytes) - number of samples per audio stream
+        +08 = width (2 bytes) - width of video data
+        +0A = height (2 bytes) - height of video data
+        +0C = <metadata> - as raw bytes
+              <audio stream 0> - as signed 16-bit samples
+              <audio stream 1> - as signed 16-bit samples
+              ...
+              <video data> - as a raw array of 8-bit YUY data in (Cb,Y,Cr,Y) order
+
+    When compressed, the data is stored as follows:
+    (all multibyte values are stored in big-endian format)
+
+        +00 = metasize (1 byte) - size of metadata in bytes
+        +01 = channels (1 byte) - number of audio channels
+        +02 = samples (2 bytes) - number of samples per audio stream
+        +04 = width (2 bytes) - width of video data
+        +06 = height (2 bytes) - height of video data
+        +08 = audio huffman size (2 bytes) - size of audio huffman tables
+                (0x0000 => uncompressed deltas are used)
+        +0A = str0size (2 bytes) - compressed size of stream 0
+        +0C = str1size (2 bytes) - compressed size of stream 1
+              ...
+              <metadata> - as raw data
+              <audio huffman table> - Huffman table for audio decoding
+              <audio stream 0 data> - Huffman-compressed deltas
+              <audio stream 1 data> - Huffman-compressed deltas
+              <...>
+              <video huffman tables> - Huffman tables for video decoding
+              <video data> - compressed data
+
+****************************************************************************
+
+    Attempted techniques that have not been worthwhile:
+
+    * Attempted to use integer DCTs from the IJG code; even the "slow"
+      variants produce a lot of error and thus kill our compression ratio,
+      since our compression is based on error not bitrate.
+
+    * Tried various other predictors for the lossless video encoding, but
+      none tended to give any significant gain over predicting the
+      previous pixel.
+
+***************************************************************************/
+
+#include "avhuff.h"
+#include "huffman.h"
+#include "chd.h"
+
+#include <math.h>
+#include <stdlib.h>
+#include <new>
+
+
+
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  code_to_rlecount - number of RLE repetitions
+//  encoded in a given byte
+//-------------------------------------------------
+
+inline int code_to_rlecount(int code)
+{
+	if (code == 0x00)
+		return 1;
+	if (code <= 0x107)
+		return 8 + (code - 0x100);
+	return 16 << (code - 0x108);
+}
+
+
+//-------------------------------------------------
+//  rlecount_to_byte - return a byte encoding
+//  the maximum RLE count less than or equal to
+//  the provided amount
+//-------------------------------------------------
+
+inline int rlecount_to_code(int rlecount)
+{
+	if (rlecount >= 2048)
+		return 0x10f;
+	if (rlecount >= 1024)
+		return 0x10e;
+	if (rlecount >= 512)
+		return 0x10d;
+	if (rlecount >= 256)
+		return 0x10c;
+	if (rlecount >= 128)
+		return 0x10b;
+	if (rlecount >= 64)
+		return 0x10a;
+	if (rlecount >= 32)
+		return 0x109;
+	if (rlecount >= 16)
+		return 0x108;
+	if (rlecount >= 8)
+		return 0x100 + (rlecount - 8);
+	return 0x00;
+}
+
+
+//-------------------------------------------------
+//  encode_one - encode data
+//-------------------------------------------------
+
+inline void avhuff_encoder::deltarle_encoder::encode_one(bitstream_out &bitbuf, UINT16 *&rleptr)
+{
+	// return RLE data if we still have some
+	if (m_rlecount != 0)
+	{
+		m_rlecount--;
+		return;
+	}
+
+	// fetch the data and process
+	UINT16 data = *rleptr++;
+	m_encoder.encode_one(bitbuf, data);
+	if (data >= 0x100)
+		m_rlecount = code_to_rlecount(data) - 1;
+}
+
+
+//-------------------------------------------------
+//  decode_one - decode data
+//-------------------------------------------------
+
+inline UINT32 avhuff_decoder::deltarle_decoder::decode_one(bitstream_in &bitbuf)
+{
+	// return RLE data if we still have some
+	if (m_rlecount != 0)
+	{
+		m_rlecount--;
+		return m_prevdata;
+	}
+
+	// fetch the data and process
+	int data = m_decoder.decode_one(bitbuf);
+	if (data < 0x100)
+	{
+		m_prevdata += UINT8(data);
+		return m_prevdata;
+	}
+	else
+	{
+		m_rlecount = code_to_rlecount(data);
+		m_rlecount--;
+		return m_prevdata;
+	}
+}
+
+
+
+//**************************************************************************
+//  AVHUFF ENCODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  avhuff_encoder - constructor
+//-------------------------------------------------
+
+avhuff_encoder::avhuff_encoder()
+{
+m_flac_encoder.set_sample_rate(48000);
+m_flac_encoder.set_num_channels(1);
+m_flac_encoder.set_strip_metadata(true);
+}
+
+
+//-------------------------------------------------
+//  encode_data - encode a block of data into a
+//  compressed data stream
+//-------------------------------------------------
+
+avhuff_error avhuff_encoder::encode_data(const UINT8 *source, UINT8 *dest, UINT32 &complength)
+{
+	// validate the header
+	if (source[0] != 'c' || source[1] != 'h' || source[2] != 'a' || source[3] != 'v')
+		return AVHERR_INVALID_DATA;
+
+	// extract info from the header
+	UINT32 metasize = source[4];
+	UINT32 channels = source[5];
+	UINT32 samples = (source[6] << 8) + source[7];
+	UINT32 width = (source[8] << 8) + source[9];
+	UINT32 height = (source[10] << 8) + source[11];
+	source += 12;
+
+	// write the basics to the new header
+	dest[0] = metasize;
+	dest[1] = channels;
+	dest[2] = samples >> 8;
+	dest[3] = samples;
+	dest[4] = width >> 8;
+	dest[5] = width;
+	dest[6] = height >> 8;
+	dest[7] = height;
+
+	// starting offsets
+	UINT32 dstoffs = 10 + 2 * channels;
+
+	// copy the metadata first
+	if (metasize > 0)
+	{
+		memcpy(dest + dstoffs, source, metasize);
+		source += metasize;
+		dstoffs += metasize;
+	}
+
+	// encode the audio channels
+	if (channels > 0)
+	{
+		// encode the audio
+		avhuff_error err = encode_audio(source, channels, samples, dest + dstoffs, &dest[8]);
+		source += channels * samples * 2;
+		if (err != AVHERR_NONE)
+			return err;
+
+		// advance the pointers past the data
+		UINT16 treesize = (dest[8] << 8) + dest[9];
+		if (treesize != 0xffff)
+			dstoffs += treesize;
+		for (int chnum = 0; chnum < channels; chnum++)
+			dstoffs += (dest[10 + 2 * chnum] << 8) + dest[11 + 2 * chnum];
+	}
+
+	// encode the video data
+	if (width > 0 && height > 0)
+	{
+		// encode the video
+		UINT32 vidlength = 0;
+		avhuff_error err = encode_video(source, width, height, dest + dstoffs, vidlength);
+		if (err != AVHERR_NONE)
+			return err;
+
+		// advance the pointers past the data
+		dstoffs += vidlength;
+	}
+
+	// set the total compression
+	complength = dstoffs;
+	return AVHERR_NONE;
+}
+
+
+//-------------------------------------------------
+//  raw_data_size - return the raw data size of
+//  a raw stream based on the header
+//-------------------------------------------------
+
+UINT32 avhuff_encoder::raw_data_size(const UINT8 *data)
+{
+	// make sure we have a correct header
+	int size = 0;
+	if (data[0] == 'c' && data[1] == 'h' && data[2] == 'a' && data[3] == 'v')
+	{
+		// add in header size plus metadata length
+		size = 12 + data[4];
+
+		// add in channels * samples
+		size += 2 * data[5] * ((data[6] << 8) + data[7]);
+
+		// add in 2 * width * height
+		size += 2 * ((data[8] << 8) + data[9]) * (((data[10] << 8) + data[11]) & 0x7fff);
+	}
+	return size;
+}
+
+
+//-------------------------------------------------
+//  assemble_data - assemble a datastream from raw
+//  bits
+//-------------------------------------------------
+
+avhuff_error avhuff_encoder::assemble_data(UINT8 *dest, UINT32 dlength, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata, UINT32 metadatasize)
+{
+	// sanity check the inputs
+	if (metadatasize > 255)
+		return AVHERR_METADATA_TOO_LARGE;
+	if (numsamples > 65535)
+		return AVHERR_AUDIO_TOO_LARGE;
+	if (bitmap.width() > 65535 || bitmap.height() > 65535)
+		return AVHERR_VIDEO_TOO_LARGE;
+	if (dlength < 12 + metadatasize + numsamples * channels * 2 + bitmap.width() * bitmap.height() * 2)
+		return AVHERR_BUFFER_TOO_SMALL;
+
+	// fill in the header
+	*dest++ = 'c';
+	*dest++ = 'h';
+	*dest++ = 'a';
+	*dest++ = 'v';
+	*dest++ = metadatasize;
+	*dest++ = channels;
+	*dest++ = numsamples >> 8;
+	*dest++ = numsamples & 0xff;
+	*dest++ = bitmap.width() >> 8;
+	*dest++ = bitmap.width() & 0xff;
+	*dest++ = bitmap.height() >> 8;
+	*dest++ = bitmap.height() & 0xff;
+
+	// copy the metadata
+	if (metadatasize > 0)
+		memcpy(dest, metadata, metadatasize);
+	dest += metadatasize;
+
+	// copy the audio streams
+	for (UINT8 curchan = 0; curchan < channels; curchan++)
+		for (UINT32 cursamp = 0; cursamp < numsamples; cursamp++)
+		{
+			*dest++ = samples[curchan][cursamp] >> 8;
+			*dest++ = samples[curchan][cursamp] & 0xff;
+		}
+
+	// copy the video data
+	for (INT32 y = 0; y < bitmap.height(); y++)
+	{
+		UINT16 *src = &bitmap.pix(y);
+		for (INT32 x = 0; x < bitmap.width(); x++)
+		{
+			*dest++ = src[x] >> 8;
+			*dest++ = src[x] & 0xff;
+		}
+	}
+	return AVHERR_NONE;
+}
+
+
+//-------------------------------------------------
+//  encode_audio - encode raw audio data to the
+//  destination
+//-------------------------------------------------
+
+avhuff_error avhuff_encoder::encode_audio(const UINT8 *source, int channels, int samples, UINT8 *dest, UINT8 *sizes)
+{
+#if AVHUFF_USE_FLAC
+
+	// input data is big-endian; determine our platform endianness
+	UINT16 be_test = 0;
+	*(UINT8 *)&be_test = 1;
+	bool swap_endian = (be_test == 1);
+
+	// set huffman tree size to 0xffff to indicate FLAC
+	sizes[0] = 0xff;
+	sizes[1] = 0xff;
+
+	// set the block size for this round and iterate over channels
+	m_flac_encoder.set_block_size(samples);
+	for (int chnum = 0; chnum < channels; chnum++)
+	{
+		// encode the data
+		m_flac_encoder.reset(dest, samples * 2);
+		if (!m_flac_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(source) + chnum * samples, samples, swap_endian))
+			return AVHERR_COMPRESSION_ERROR;
+
+		// set the size for this channel
+		UINT32 cursize = m_flac_encoder.finish();
+		sizes[chnum * 2 + 2] = cursize >> 8;
+		sizes[chnum * 2 + 3] = cursize;
+		dest += cursize;
+	}
+
+#else
+
+	// expand the delta buffer if needed
+	m_audiobuffer.resize(channels * samples * 2);
+	UINT8 *deltabuf = m_audiobuffer;
+
+	// iterate over channels to compute deltas
+	m_audiohi_encoder.histo_reset();
+	m_audiolo_encoder.histo_reset();
+	for (int chnum = 0; chnum < channels; chnum++)
+	{
+		// extract audio data into hi and lo deltas stored in big-endian order
+		INT16 prevsample = 0;
+		for (int sampnum = 0; sampnum < samples; sampnum++)
+		{
+			INT16 newsample = (source[0] << 8) | source[1];
+			source += 2;
+
+			INT16 delta = newsample - prevsample;
+			prevsample = newsample;
+			m_audiohi_encoder.histo_one(*deltabuf++ = delta >> 8);
+			m_audiolo_encoder.histo_one(*deltabuf++ = delta);
+		}
+	}
+
+	// compute the trees
+	huffman_error hufferr = m_audiohi_encoder.compute_tree_from_histo();
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+	hufferr = m_audiolo_encoder.compute_tree_from_histo();
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+
+	// export the trees to the output
+	bitstream_out bitbuf(dest, 2 * channels * samples);
+	hufferr = m_audiohi_encoder.export_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+	bitbuf.flush();
+	hufferr = m_audiolo_encoder.export_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+
+	// note the size of the two trees
+	UINT32 huffsize = bitbuf.flush();
+	sizes[0] = huffsize >> 8;
+	sizes[1] = huffsize;
+
+	// iterate over channels
+	UINT32 totalsize = huffsize;
+	int chnum;
+	for (chnum = 0; chnum < channels; chnum++)
+	{
+		// encode the data
+		const UINT8 *input = m_audiobuffer + chnum * samples * 2;
+		for (int sampnum = 0; sampnum < samples; sampnum++)
+		{
+			m_audiohi_encoder.encode_one(bitbuf, *input++);
+			m_audiolo_encoder.encode_one(bitbuf, *input++);
+		}
+
+		// store the size of this stream
+		UINT32 cursize = bitbuf.flush() - totalsize;
+		totalsize += cursize;
+		if (totalsize >= channels * samples * 2)
+			break;
+		sizes[chnum * 2 + 2] = cursize >> 8;
+		sizes[chnum * 2 + 3] = cursize;
+	}
+
+	// if we ran out of room, throw it all away and just store raw
+	if (chnum < channels)
+	{
+		memcpy(dest, m_audiobuffer, channels * samples * 2);
+		UINT32 size = samples * 2;
+		sizes[0] = sizes[1] = 0;
+		for (chnum = 0; chnum < channels; chnum++)
+		{
+			sizes[chnum * 2 + 2] = size >> 8;
+			sizes[chnum * 2 + 3] = size;
+		}
+	}
+
+#endif
+
+	return AVHERR_NONE;
+}
+
+
+//-------------------------------------------------
+//  encode_video - encode raw video data to the
+//  destination
+//-------------------------------------------------
+
+avhuff_error avhuff_encoder::encode_video(const UINT8 *source, int width, int height, UINT8 *dest, UINT32 &complength)
+{
+	// only lossless supported at this time
+	return encode_video_lossless(source, width, height, dest, complength);
+}
+
+
+//-------------------------------------------------
+//  encode_video_lossless - do a lossless video
+//  encoding using deltas and huffman encoding
+//-------------------------------------------------
+
+avhuff_error avhuff_encoder::encode_video_lossless(const UINT8 *source, int width, int height, UINT8 *dest, UINT32 &complength)
+{
+	// set up the output; first byte is 0x80 to indicate lossless encoding
+	bitstream_out bitbuf(dest, width * height * 2);
+	bitbuf.write(0x80, 8);
+
+	// compute the histograms for the data
+	UINT16 *yrle = m_ycontext.rle_and_histo_bitmap(source + 0, width, 2, height);
+	UINT16 *cbrle = m_cbcontext.rle_and_histo_bitmap(source + 1, width / 2, 4, height);
+	UINT16 *crrle = m_crcontext.rle_and_histo_bitmap(source + 3, width / 2, 4, height);
+
+	// export the trees to the data stream
+	huffman_error hufferr = m_ycontext.export_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+	bitbuf.flush();
+	hufferr = m_cbcontext.export_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+	bitbuf.flush();
+	hufferr = m_crcontext.export_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_COMPRESSION_ERROR;
+	bitbuf.flush();
+
+	// encode the data using the trees
+	for (UINT32 sy = 0; sy < height; sy++)
+	{
+		m_ycontext.flush_rle();
+		m_cbcontext.flush_rle();
+		m_crcontext.flush_rle();
+		for (UINT32 sx = 0; sx < width / 2; sx++)
+		{
+			m_ycontext.encode_one(bitbuf, yrle);
+			m_cbcontext.encode_one(bitbuf, cbrle);
+			m_ycontext.encode_one(bitbuf, yrle);
+			m_crcontext.encode_one(bitbuf, crrle);
+		}
+	}
+
+	// set the final length
+	complength = bitbuf.flush();
+	return AVHERR_NONE;
+}
+
+
+
+//**************************************************************************
+//  DELTA-RLE ENCODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  rle_and_histo_bitmap - RLE compress and
+//  histogram a bitmap's worth of data
+//-------------------------------------------------
+
+UINT16 *avhuff_encoder::deltarle_encoder::rle_and_histo_bitmap(const UINT8 *source, UINT32 items_per_row, UINT32 item_advance, UINT32 row_count)
+{
+	// resize our RLE buffer
+	m_rlebuffer.resize(items_per_row * row_count);
+	UINT16 *dest = m_rlebuffer;
+
+	// iterate over rows
+	m_encoder.histo_reset();
+	UINT8 prevdata = 0;
+	for (UINT32 row = 0; row < row_count; row++)
+	{
+		const UINT8 *end = source + items_per_row * item_advance;
+		for ( ; source < end; source += item_advance)
+		{
+			// fetch current data
+			UINT8 curdelta = *source - prevdata;
+			prevdata = *source;
+
+			// 0 deltas scan forward for a count
+			if (curdelta == 0)
+			{
+				int zerocount = 1;
+
+				// count the number of consecutive values
+				const UINT8 *scandata;
+				for (scandata = source + item_advance; scandata < end; scandata += item_advance)
+					if (*scandata == prevdata)
+						zerocount++;
+					else
+						break;
+
+				// if we hit the end of a row, maximize the count
+				if (scandata >= end && zerocount >= 8)
+					zerocount = 100000;
+
+				// encode the maximal count we can
+				int rlecode = rlecount_to_code(zerocount);
+				m_encoder.histo_one(*dest++ = rlecode);
+
+				// advance past the run
+				source += (code_to_rlecount(rlecode) - 1) * item_advance;
+			}
+
+			// otherwise, encode the actual data
+			else
+				m_encoder.histo_one(*dest++ = curdelta);
+		}
+
+		// advance to the next row
+		source = end;
+	}
+
+	// compute the tree for our histogram
+	m_encoder.compute_tree_from_histo();
+	return m_rlebuffer;
+}
+
+
+
+//**************************************************************************
+//  AVHUFF DECODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  avhuff_decoder - constructor
+//-------------------------------------------------
+
+avhuff_decoder::avhuff_decoder()
+{
+}
+
+
+//-------------------------------------------------
+//  configure - configure decompression parameters
+//-------------------------------------------------
+
+void avhuff_decoder::configure(const avhuff_decompress_config &config)
+{
+	m_config.video.wrap(config.video, config.video.cliprect());
+	m_config.maxsamples = config.maxsamples;
+	m_config.actsamples = config.actsamples;
+	memcpy(m_config.audio, config.audio, sizeof(m_config.audio));
+	m_config.maxmetalength = config.maxmetalength;
+	m_config.actmetalength = config.actmetalength;
+	m_config.metadata = config.metadata;
+}
+
+
+//-------------------------------------------------
+//  decode_data - decode both audio and video from
+//  a raw data stream
+//-------------------------------------------------
+
+avhuff_error avhuff_decoder::decode_data(const UINT8 *source, UINT32 complength, UINT8 *dest)
+{
+	// extract info from the header
+	if (complength < 8)
+		return AVHERR_INVALID_DATA;
+	UINT32 metasize = source[0];
+	UINT32 channels = source[1];
+	UINT32 samples = (source[2] << 8) + source[3];
+	UINT32 width = (source[4] << 8) + source[5];
+	UINT32 height = (source[6] << 8) + source[7];
+
+	// validate that the sizes make sense
+	if (complength < 10 + 2 * channels)
+		return AVHERR_INVALID_DATA;
+	UINT32 totalsize = 10 + 2 * channels;
+	totalsize += (source[8] << 8) | source[9];
+	for (int chnum = 0; chnum < channels; chnum++)
+		totalsize += (source[10 + 2 * chnum] << 8) | source[11 + 2 * chnum];
+	if (totalsize >= complength)
+		return AVHERR_INVALID_DATA;
+
+	// starting offsets
+	UINT32 srcoffs = 10 + 2 * channels;
+
+	// if we are decoding raw, set up the output parameters
+	UINT8 *metastart, *videostart, *audiostart[16];
+	UINT32 audioxor, videoxor, videostride;
+	if (dest != NULL)
+	{
+		// create a header
+		dest[0] = 'c';
+		dest[1] = 'h';
+		dest[2] = 'a';
+		dest[3] = 'v';
+		dest[4] = metasize;
+		dest[5] = channels;
+		dest[6] = samples >> 8;
+		dest[7] = samples;
+		dest[8] = width >> 8;
+		dest[9] = width;
+		dest[10] = height >> 8;
+		dest[11] = height;
+		dest += 12;
+
+		// determine the start of each piece of data
+		metastart = dest;
+		dest += metasize;
+		for (int chnum = 0; chnum < channels; chnum++)
+		{
+			audiostart[chnum] = dest;
+			dest += 2 * samples;
+		}
+		videostart = dest;
+
+		// data is assumed to be big-endian already
+		audioxor = videoxor = 0;
+		videostride = 2 * width;
+	}
+
+	// otherwise, extract from the state
+	else
+	{
+		// determine the start of each piece of data
+		metastart = m_config.metadata;
+		for (int chnum = 0; chnum < channels; chnum++)
+			audiostart[chnum] = (UINT8 *)m_config.audio[chnum];
+		videostart = (m_config.video.valid()) ? reinterpret_cast<UINT8 *>(&m_config.video.pix(0)) : NULL;
+		videostride = (m_config.video.valid()) ? m_config.video.rowpixels() * 2 : 0;
+
+		// data is assumed to be native-endian
+		UINT16 betest = 0;
+		*(UINT8 *)&betest = 1;
+		audioxor = videoxor = (betest == 1) ? 1 : 0;
+
+		// verify against sizes
+		if (m_config.video.valid() && (m_config.video.width() < width || m_config.video.height() < height))
+			return AVHERR_VIDEO_TOO_LARGE;
+		for (int chnum = 0; chnum < channels; chnum++)
+			if (m_config.audio[chnum] != NULL && m_config.maxsamples < samples)
+				return AVHERR_AUDIO_TOO_LARGE;
+		if (m_config.metadata != NULL && m_config.maxmetalength < metasize)
+			return AVHERR_METADATA_TOO_LARGE;
+
+		// set the output values
+		if (m_config.actsamples != NULL)
+			*m_config.actsamples = samples;
+		if (m_config.actmetalength != NULL)
+			*m_config.actmetalength = metasize;
+	}
+
+	// copy the metadata first
+	if (metasize > 0)
+	{
+		if (metastart != NULL)
+			memcpy(metastart, source + srcoffs, metasize);
+		srcoffs += metasize;
+	}
+
+	// decode the audio channels
+	if (channels > 0)
+	{
+		// decode the audio
+		avhuff_error err = decode_audio(channels, samples, source + srcoffs, audiostart, audioxor, &source[8]);
+		if (err != AVHERR_NONE)
+			return err;
+
+		// advance the pointers past the data
+		UINT32 treesize = (source[8] << 8) + source[9];
+		if (treesize != 0xffff)
+			srcoffs += treesize;
+		for (int chnum = 0; chnum < channels; chnum++)
+			srcoffs += (source[10 + 2 * chnum] << 8) + source[11 + 2 * chnum];
+	}
+
+	// decode the video data
+	if (width > 0 && height > 0 && videostart != NULL)
+	{
+		// decode the video
+		avhuff_error err = decode_video(width, height, source + srcoffs, complength - srcoffs, videostart, videostride, videoxor);
+		if (err != AVHERR_NONE)
+			return err;
+	}
+	return AVHERR_NONE;
+}
+
+
+//-------------------------------------------------
+//  decode_audio - decode audio from a compressed
+//  data stream
+//-------------------------------------------------
+
+avhuff_error avhuff_decoder::decode_audio(int channels, int samples, const UINT8 *source, UINT8 **dest, UINT32 dxor, const UINT8 *sizes)
+{
+	// extract the huffman trees
+	UINT16 treesize = (sizes[0] << 8) | sizes[1];
+
+#if AVHUFF_USE_FLAC
+
+	// if the tree size is 0xffff, the streams are FLAC-encoded
+	if (treesize == 0xffff)
+	{
+		// output data is big-endian; determine our platform endianness
+		UINT16 be_test = 0;
+		*(UINT8 *)&be_test = 1;
+		bool swap_endian = (be_test == 1);
+		if (dxor != 0)
+			swap_endian = !swap_endian;
+
+		// loop over channels
+		for (int chnum = 0; chnum < channels; chnum++)
+		{
+			// extract the size of this channel
+			UINT16 size = (sizes[chnum * 2 + 2] << 8) | sizes[chnum * 2 + 3];
+
+			// only process if the data is requested
+			UINT8 *curdest = dest[chnum];
+			if (curdest != NULL)
+			{
+				// reset and decode
+				if (!m_flac_decoder.reset(48000, 1, samples, source, size))
+					throw CHDERR_DECOMPRESSION_ERROR;
+				if (!m_flac_decoder.decode_interleaved(reinterpret_cast<INT16 *>(curdest), samples, swap_endian))
+					throw CHDERR_DECOMPRESSION_ERROR;
+
+				// finish up
+				m_flac_decoder.finish();
+			}
+
+			// advance to the next channel's data
+			source += size;
+		}
+		return AVHERR_NONE;
+	}
+
+#endif
+
+	// if we have a non-zero tree size, extract the trees
+	if (treesize != 0)
+	{
+		bitstream_in bitbuf(source, treesize);
+		huffman_error hufferr = m_audiohi_decoder.import_tree_rle(bitbuf);
+		if (hufferr != HUFFERR_NONE)
+			return AVHERR_INVALID_DATA;
+		bitbuf.flush();
+		hufferr = m_audiolo_decoder.import_tree_rle(bitbuf);
+		if (hufferr != HUFFERR_NONE)
+			return AVHERR_INVALID_DATA;
+		if (bitbuf.flush() != treesize)
+			return AVHERR_INVALID_DATA;
+		source += treesize;
+	}
+
+	// loop over channels
+	for (int chnum = 0; chnum < channels; chnum++)
+	{
+		// extract the size of this channel
+		UINT16 size = (sizes[chnum * 2 + 2] << 8) | sizes[chnum * 2 + 3];
+
+		// only process if the data is requested
+		UINT8 *curdest = dest[chnum];
+		if (curdest != NULL)
+		{
+			INT16 prevsample = 0;
+
+			// if no huffman length, just copy the data
+			if (treesize == 0)
+			{
+				const UINT8 *cursource = source;
+				for (int sampnum = 0; sampnum < samples; sampnum++)
+				{
+					INT16 delta = (cursource[0] << 8) | cursource[1];
+					cursource += 2;
+
+					INT16 newsample = prevsample + delta;
+					prevsample = newsample;
+
+					curdest[0 ^ dxor] = newsample >> 8;
+					curdest[1 ^ dxor] = newsample;
+					curdest += 2;
+				}
+			}
+
+			// otherwise, Huffman-decode the data
+			else
+			{
+				bitstream_in bitbuf(source, size);
+				for (int sampnum = 0; sampnum < samples; sampnum++)
+				{
+					INT16 delta = m_audiohi_decoder.decode_one(bitbuf) << 8;
+					delta |= m_audiolo_decoder.decode_one(bitbuf);
+
+					INT16 newsample = prevsample + delta;
+					prevsample = newsample;
+
+					curdest[0 ^ dxor] = newsample >> 8;
+					curdest[1 ^ dxor] = newsample;
+					curdest += 2;
+				}
+				if (bitbuf.overflow())
+					return AVHERR_INVALID_DATA;
+			}
+		}
+
+		// advance to the next channel's data
+		source += size;
+	}
+	return AVHERR_NONE;
+}
+
+
+//-------------------------------------------------
+//  decode_video - decode video from a compressed
+//  data stream
+//-------------------------------------------------
+
+avhuff_error avhuff_decoder::decode_video(int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor)
+{
+	// if the high bit of the first byte is set, we decode losslessly
+	if (source[0] & 0x80)
+		return decode_video_lossless(width, height, source, complength, dest, dstride, dxor);
+	else
+		return AVHERR_INVALID_DATA;
+}
+
+
+//-------------------------------------------------
+//  decode_video_lossless - do a lossless video
+//  decoding using deltas and huffman encoding
+//-------------------------------------------------
+
+avhuff_error avhuff_decoder::decode_video_lossless(int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor)
+{
+	// skip the first byte
+	bitstream_in bitbuf(source, complength);
+	bitbuf.read(8);
+
+	// import the tables
+	huffman_error hufferr = m_ycontext.import_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_INVALID_DATA;
+	bitbuf.flush();
+	hufferr = m_cbcontext.import_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_INVALID_DATA;
+	bitbuf.flush();
+	hufferr = m_crcontext.import_tree_rle(bitbuf);
+	if (hufferr != HUFFERR_NONE)
+		return AVHERR_INVALID_DATA;
+	bitbuf.flush();
+
+	// decode to the destination
+	m_ycontext.reset();
+	m_cbcontext.reset();
+	m_crcontext.reset();
+	for (UINT32 dy = 0; dy < height; dy++)
+	{
+		UINT8 *row = dest + dy * dstride;
+		for (UINT32 dx = 0; dx < width / 2; dx++)
+		{
+			row[0 ^ dxor] = m_ycontext.decode_one(bitbuf);
+			row[1 ^ dxor] = m_cbcontext.decode_one(bitbuf);
+			row[2 ^ dxor] = m_ycontext.decode_one(bitbuf);
+			row[3 ^ dxor] = m_crcontext.decode_one(bitbuf);
+			row += 4;
+		}
+		m_ycontext.flush_rle();
+		m_cbcontext.flush_rle();
+		m_crcontext.flush_rle();
+	}
+
+	// check for errors if we overflowed or decoded too little data
+	if (bitbuf.overflow() || bitbuf.flush() != complength)
+		return AVHERR_INVALID_DATA;
+	return AVHERR_NONE;
+}
diff -Nru src-old/lib/util/avhuff.h src/lib/util/avhuff.h
--- src-old/lib/util/avhuff.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/avhuff.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,231 @@
+/***************************************************************************
+
+    avhuff.h
+
+    Audio/video compression and decompression helpers.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __AVHUFF_H__
+#define __AVHUFF_H__
+
+#include "osdcore.h"
+#include "coretmpl.h"
+#include "bitmap.h"
+#include "huffman.h"
+#include "flac.h"
+
+
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+#define AVHUFF_USE_FLAC		(1)
+
+
+// errors
+enum avhuff_error
+{
+	AVHERR_NONE = 0,
+	AVHERR_INVALID_DATA,
+	AVHERR_VIDEO_TOO_LARGE,
+	AVHERR_AUDIO_TOO_LARGE,
+	AVHERR_METADATA_TOO_LARGE,
+	AVHERR_OUT_OF_MEMORY,
+	AVHERR_COMPRESSION_ERROR,
+	AVHERR_TOO_MANY_CHANNELS,
+	AVHERR_INVALID_CONFIGURATION,
+	AVHERR_INVALID_PARAMETER,
+	AVHERR_BUFFER_TOO_SMALL
+};
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> av_codec_decompress_config
+
+// decompression configuration
+class avhuff_decompress_config
+{
+public:
+	avhuff_decompress_config()
+		: maxsamples(0),
+		  actsamples(NULL),
+		  maxmetalength(0),
+		  actmetalength(NULL),
+		  metadata(NULL)
+	{
+		memset(audio, 0, sizeof(audio));
+	}
+
+	bitmap_yuy16 video;						// pointer to video bitmap
+	UINT32		maxsamples;					// maximum number of samples per channel
+	UINT32 *	actsamples;					// actual number of samples per channel
+	INT16 *		audio[16];					// pointer to individual audio channels
+	UINT32		maxmetalength;				// maximum length of metadata
+	UINT32 *	actmetalength;				// actual length of metadata
+	UINT8 *		metadata;					// pointer to metadata buffer
+};
+
+
+// ======================> avhuff_encoder
+
+// core state for the codec
+class avhuff_encoder
+{
+public:
+	// construction/destruction
+	avhuff_encoder();
+
+	// encode/decode
+	avhuff_error encode_data(const UINT8 *source, UINT8 *dest, UINT32 &complength);
+
+	// static helpers
+	static UINT32 raw_data_size(const UINT8 *data);
+	static UINT32 raw_data_size(UINT32 width, UINT32 height, UINT8 channels, UINT32 numsamples, UINT32 metadatasize = 0) { return 12 + channels * numsamples * 2 + width * height * 2; }
+	static avhuff_error assemble_data(UINT8 *dest, UINT32 dlength, bitmap_yuy16 &bitmap, UINT8 channels, UINT32 numsamples, INT16 **samples, UINT8 *metadata = NULL, UINT32 metadatasize = 0);
+
+private:
+	// delta-RLE Huffman encoder
+	class deltarle_encoder
+	{
+	public:
+		// construction/destruction
+		deltarle_encoder()
+			: m_rlecount(0) { }
+
+		// histogramming
+		UINT16 *rle_and_histo_bitmap(const UINT8 *source, UINT32 items_per_row, UINT32 item_advance, UINT32 row_count);
+
+		// encoding
+		void flush_rle() { m_rlecount = 0; }
+		void encode_one(bitstream_out &bitbuf, UINT16 *&rleptr);
+		huffman_error export_tree_rle(bitstream_out &bitbuf) { return m_encoder.export_tree_rle(bitbuf); }
+
+	private:
+		// internal state
+		int							m_rlecount;
+		huffman_encoder<256 + 16>	m_encoder;
+		dynamic_array<UINT16>		m_rlebuffer;
+	};
+
+	// internal helpers
+	avhuff_error encode_audio(const UINT8 *source, int channels, int samples, UINT8 *dest, UINT8 *sizes);
+	avhuff_error encode_video(const UINT8 *source, int width, int height, UINT8 *dest, UINT32 &complength);
+	avhuff_error encode_video_lossless(const UINT8 *source, int width, int height, UINT8 *dest, UINT32 &complength);
+
+	// video encoding contexts
+	deltarle_encoder			m_ycontext;
+	deltarle_encoder			m_cbcontext;
+	deltarle_encoder			m_crcontext;
+
+	// audio encoding contexts
+	dynamic_buffer				m_audiobuffer;
+#if AVHUFF_USE_FLAC
+	flac_encoder				m_flac_encoder;
+#else
+	huffman_8bit_encoder		m_audiohi_encoder;
+	huffman_8bit_encoder		m_audiolo_encoder;
+#endif
+};
+
+
+// ======================> avhuff_decoder
+
+// core state for the codec
+class avhuff_decoder
+{
+public:
+	// construction/destruction
+	avhuff_decoder();
+
+	// configuration
+	void configure(const avhuff_decompress_config &config);
+
+	// encode/decode
+	avhuff_error decode_data(const UINT8 *source, UINT32 complength, UINT8 *dest);
+
+private:
+	// delta-RLE Huffman decoder
+	class deltarle_decoder
+	{
+	public:
+		// construction/destruction
+		deltarle_decoder()
+			: m_rlecount(0), m_prevdata(0) { }
+
+		// general
+		void reset() { m_rlecount = m_prevdata = 0; }
+
+		// decoding
+		void flush_rle() { m_rlecount = 0; }
+		UINT32 decode_one(bitstream_in &bitbuf);
+		huffman_error import_tree_rle(bitstream_in &bitbuf) { return m_decoder.import_tree_rle(bitbuf); }
+
+	private:
+		// internal state
+		int							m_rlecount;
+		UINT8						m_prevdata;
+		huffman_decoder<256 + 16>	m_decoder;
+	};
+
+
+	// internal helpers
+	avhuff_error decode_audio(int channels, int samples, const UINT8 *source, UINT8 **dest, UINT32 dxor, const UINT8 *sizes);
+	avhuff_error decode_video(int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor);
+	avhuff_error decode_video_lossless(int width, int height, const UINT8 *source, UINT32 complength, UINT8 *dest, UINT32 dstride, UINT32 dxor);
+
+	// internal state
+	avhuff_decompress_config	m_config;
+
+	// video decoding contexts
+	deltarle_decoder			m_ycontext;
+	deltarle_decoder			m_cbcontext;
+	deltarle_decoder			m_crcontext;
+
+	// audio decoding contexts
+	huffman_8bit_decoder		m_audiohi_decoder;
+	huffman_8bit_decoder		m_audiolo_decoder;
+#if AVHUFF_USE_FLAC
+	flac_decoder				m_flac_decoder;
+#endif
+};
+
+
+#endif
diff -Nru src-old/lib/util/aviio.c src/lib/util/aviio.c
--- src-old/lib/util/aviio.c	2012-01-12 22:19:49.000000000 +0100
+++ src/lib/util/aviio.c	2012-02-16 10:47:18.000000000 +0100
@@ -1573,7 +1573,7 @@
 		{
 			const UINT8 *base = &chunkdata[24 + entry * 4 * longs_per_entry];
 			UINT32 offset = fetch_32bits(&base[0]);
-			UINT32 size = fetch_32bits(&base[4]);
+			UINT32 size = fetch_32bits(&base[4]) & 0x7fffffff;	// bit 31 == NOT a keyframe
 
 			/* set the info for this chunk and advance */
 			avierr = set_stream_chunk_info(stream, stream->chunks++, baseoffset + offset - 8, size + 8);
diff -Nru src-old/lib/util/bitmap.c src/lib/util/bitmap.c
--- src-old/lib/util/bitmap.c	2012-01-16 12:06:28.000000000 +0100
+++ src/lib/util/bitmap.c	2012-02-16 10:47:18.000000000 +0100
@@ -271,7 +271,7 @@
 //  bitmap does not own the memory
 //-------------------------------------------------
 
-void bitmap_t::wrap(bitmap_t &source, const rectangle &subrect)
+void bitmap_t::wrap(const bitmap_t &source, const rectangle &subrect)
 {
 	assert(m_format == source.m_format);
 	assert(m_bpp == source.m_bpp);
diff -Nru src-old/lib/util/bitmap.h src/lib/util/bitmap.h
--- src-old/lib/util/bitmap.h	2012-01-16 12:06:28.000000000 +0100
+++ src/lib/util/bitmap.h	2012-02-16 10:47:18.000000000 +0100
@@ -177,7 +177,7 @@
 protected:
 	// for use by subclasses only to ensure type correctness
 	void wrap(void *base, int width, int height, int rowpixels);
-	void wrap(bitmap_t &source, const rectangle &subrect);
+	void wrap(const bitmap_t &source, const rectangle &subrect);
 
 private:
 	// internal helpers
@@ -306,7 +306,7 @@
 	bitmap_ind8(UINT8 *base, int width, int height, int rowpixels) : bitmap8_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_ind8(bitmap_ind8 &source, const rectangle &subrect) : bitmap8_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT8 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -323,7 +323,7 @@
 	bitmap_ind16(UINT16 *base, int width, int height, int rowpixels) : bitmap16_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_ind16(bitmap_ind16 &source, const rectangle &subrect) : bitmap16_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT16 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -340,7 +340,7 @@
 	bitmap_ind32(UINT32 *base, int width, int height, int rowpixels) : bitmap32_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_ind32(bitmap_ind32 &source, const rectangle &subrect) : bitmap32_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT32 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -357,7 +357,7 @@
 	bitmap_ind64(UINT64 *base, int width, int height, int rowpixels) : bitmap64_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_ind64(bitmap_ind64 &source, const rectangle &subrect) : bitmap64_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT64 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_ind8 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -377,7 +377,7 @@
 	bitmap_yuy16(UINT16 *base, int width, int height, int rowpixels) : bitmap16_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_yuy16(bitmap_yuy16 &source, const rectangle &subrect) : bitmap16_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT16 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_yuy16 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_yuy16 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -394,7 +394,7 @@
 	bitmap_rgb32(UINT32 *base, int width, int height, int rowpixels) : bitmap32_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_rgb32(bitmap_rgb32 &source, const rectangle &subrect) : bitmap32_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT32 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_rgb32 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_rgb32 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
@@ -411,7 +411,7 @@
 	bitmap_argb32(UINT32 *base, int width, int height, int rowpixels) : bitmap32_t(k_bitmap_format, base, width, height, rowpixels) { }
 	bitmap_argb32(bitmap_argb32 &source, const rectangle &subrect) : bitmap32_t(k_bitmap_format, source, subrect) { }
 	void wrap(UINT32 *base, int width, int height, int rowpixels) { bitmap_t::wrap(base, width, height, rowpixels); }
-	void wrap(bitmap_argb32 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<bitmap_t &>(source), subrect); }
+	void wrap(const bitmap_argb32 &source, const rectangle &subrect) { bitmap_t::wrap(static_cast<const bitmap_t &>(source), subrect); }
 
 	// getters
 	bitmap_format format() const { return k_bitmap_format; }
diff -Nru src-old/lib/util/bitstream.h src/lib/util/bitstream.h
--- src-old/lib/util/bitstream.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/bitstream.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,265 @@
+/***************************************************************************
+
+    bitstream.h
+
+    Helper classes for reading/writing at the bit level.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __BITSTREAM_H__
+#define __BITSTREAM_H__
+
+#include "osdcore.h"
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// helper class for reading from a bit buffer
+class bitstream_in
+{
+public:
+	// construction/destruction
+	bitstream_in(const void *src, UINT32 srclength);
+
+	// getters
+	bool overflow() const { return ((m_doffset - m_bits / 8) > m_dlength); }
+	UINT32 read_offset() const;
+
+	// operations
+	UINT32 read(int numbits);
+	UINT32 peek(int numbits);
+	void remove(int numbits);
+	UINT32 flush();
+
+private:
+	// internal state
+	UINT32			m_buffer;		// current bit accumulator
+	int				m_bits;			// number of bits in the accumulator
+	const UINT8 *	m_read;			// read pointer
+	UINT32			m_doffset;		// byte offset within the data
+	UINT32			m_dlength;		// length of the data
+};
+
+
+// helper class for writing to a bit buffer
+class bitstream_out
+{
+public:
+	// construction/destruction
+	bitstream_out(void *dest, UINT32 destlength);
+
+	// getters
+	bool overflow() const { return (m_doffset > m_dlength); }
+
+	// operations
+	void write(UINT32 newbits, int numbits);
+	UINT32 flush();
+
+private:
+	// internal state
+	UINT32			m_buffer;			// current bit accumulator
+	int				m_bits;				// number of bits in the accumulator
+	UINT8 *			m_write;			// write pointer
+	UINT32			m_doffset;			// byte offset within the data
+	UINT32			m_dlength;			// length of the data
+};
+
+
+
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  bitstream_in - constructor
+//-------------------------------------------------
+
+inline bitstream_in::bitstream_in(const void *src, UINT32 srclength)
+	: m_buffer(0),
+	  m_bits(0),
+	  m_read(reinterpret_cast<const UINT8 *>(src)),
+	  m_doffset(0),
+	  m_dlength(srclength)
+{
+}
+
+
+//-------------------------------------------------
+//  peek - fetch the requested number of bits
+//  but don't advance the input pointer
+//-------------------------------------------------
+
+inline UINT32 bitstream_in::peek(int numbits)
+{
+	// fetch data if we need more
+	if (numbits > m_bits)
+	{
+		while (m_bits <= 24)
+		{
+			if (m_doffset < m_dlength)
+				m_buffer |= m_read[m_doffset] << (24 - m_bits);
+			m_doffset++;
+			m_bits += 8;
+		}
+	}
+
+	// return the data
+	return m_buffer >> (32 - numbits);
+}
+
+
+//-------------------------------------------------
+//  remove - advance the input pointer by the
+//  specified number of bits
+//-------------------------------------------------
+
+inline void bitstream_in::remove(int numbits)
+{
+	m_buffer <<= numbits;
+	m_bits -= numbits;
+}
+
+
+//-------------------------------------------------
+//  read - fetch the requested number of bits
+//-------------------------------------------------
+
+inline UINT32 bitstream_in::read(int numbits)
+{
+	UINT32 result = peek(numbits);
+	remove(numbits);
+	return result;
+}
+
+
+//-------------------------------------------------
+//  read_offset - return the current read offset
+//-------------------------------------------------
+
+inline UINT32 bitstream_in::read_offset() const
+{
+	UINT32 result = m_doffset;
+	int bits = m_bits;
+	while (bits >= 8)
+	{
+		result--;
+		bits -= 8;
+	}
+	return result;
+}
+
+
+//-------------------------------------------------
+//  flush - flush to the nearest byte
+//-------------------------------------------------
+
+inline UINT32 bitstream_in::flush()
+{
+	while (m_bits >= 8)
+	{
+		m_doffset--;
+		m_bits -= 8;
+	}
+	m_bits = m_buffer = 0;
+	return m_doffset;
+}
+
+
+//-------------------------------------------------
+//  bitstream_out - constructor
+//-------------------------------------------------
+
+inline bitstream_out::bitstream_out(void *dest, UINT32 destlength)
+	: m_buffer(0),
+	  m_bits(0),
+	  m_write(reinterpret_cast<UINT8 *>(dest)),
+	  m_doffset(0),
+	  m_dlength(destlength)
+{
+}
+
+
+
+//-------------------------------------------------
+//  write - write the given number of bits to the
+//  data stream
+//-------------------------------------------------
+
+inline void bitstream_out::write(UINT32 newbits, int numbits)
+{
+	// flush the buffer if we're going to overflow it
+	if (m_bits + numbits > 32)
+		while (m_bits >= 8)
+		{
+			if (m_doffset < m_dlength)
+				m_write[m_doffset] = m_buffer >> 24;
+			m_doffset++;
+			m_buffer <<= 8;
+			m_bits -= 8;
+		}
+
+	// shift the bits to the top
+	newbits <<= 32 - numbits;
+
+	// now shift it down to account for the number of bits we already have and OR them in
+	m_buffer |= newbits >> m_bits;
+	m_bits += numbits;
+}
+
+
+//-------------------------------------------------
+//  flush - output remaining bits and return the
+//  final output size in bytes
+//-------------------------------------------------
+
+inline UINT32 bitstream_out::flush()
+{
+	while (m_bits > 0)
+	{
+		if (m_doffset < m_dlength)
+			m_write[m_doffset] = m_buffer >> 24;
+		m_doffset++;
+		m_buffer <<= 8;
+		m_bits -= 8;
+	}
+	m_bits = m_buffer = 0;
+	return m_doffset;
+}
+
+
+#endif
diff -Nru src-old/lib/util/cdrom.c src/lib/util/cdrom.c
--- src-old/lib/util/cdrom.c	2011-12-31 03:49:25.000000000 +0100
+++ src/lib/util/cdrom.c	2012-02-19 16:23:23.000000000 +0100
@@ -40,7 +40,7 @@
     IMPORTANT:
     "physical" block addresses are the actual addresses on the emulated CD.
     "chd" block addresses are the block addresses in the CHD file.
-    Because we pad each track to a hunk boundry, these addressing
+    Because we pad each track to a 4-frame boundry, these addressing
     schemes will differ after track 1!
 
 ***************************************************************************/
@@ -75,23 +75,12 @@
 	chd_file *			chd;				/* CHD file */
 	cdrom_toc			cdtoc;				/* TOC for the CD */
 	chdcd_track_input_info track_info;		/* track info */
-	UINT32				hunksectors;		/* sectors per hunk */
-	UINT32				cachehunk;			/* which hunk is cached */
-	UINT8 *				cache;				/* cache of the current hunk */
 	core_file *			fhandle[CD_MAX_TRACKS];/* file handle */
 };
 
 
 
 /***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-static chd_error read_sector_into_cache(cdrom_file *file, UINT32 lbasector, UINT32 *sectoroffs, UINT32 *tracknum);
-
-
-
-/***************************************************************************
     INLINE FUNCTIONS
 ***************************************************************************/
 
@@ -100,7 +89,7 @@
     and the track number
 -------------------------------------------------*/
 
-INLINE UINT32 physical_to_chd_lba(cdrom_file *file, UINT32 physlba, UINT32 *tracknum)
+INLINE UINT32 physical_to_chd_lba(cdrom_file *file, UINT32 physlba, UINT32 &tracknum)
 {
 	UINT32 chdlba;
 	int track;
@@ -110,8 +99,7 @@
 		if (physlba < file->cdtoc.tracks[track + 1].physframeofs)
 		{
 			chdlba = physlba - file->cdtoc.tracks[track].physframeofs + file->cdtoc.tracks[track].chdframeofs;
-			if (tracknum != NULL)
-				*tracknum = track;
+			tracknum = track;
 			return chdlba;
 		}
 
@@ -131,36 +119,34 @@
 	UINT32 physofs;
 
 	/* allocate memory for the CD-ROM file */
-	file = (cdrom_file *)malloc(sizeof(cdrom_file));
+	file = new cdrom_file();
 	if (file == NULL)
 		return NULL;
 
 	/* setup the CDROM module and get the disc info */
-	chd_error err = chdcd_parse_toc(inputfile, &file->cdtoc, &file->track_info);
+	chd_error err = chdcd_parse_toc(inputfile, file->cdtoc, file->track_info);
 	if (err != CHDERR_NONE)
 	{
-		fprintf(stderr, "Error reading input file: %s\n", chd_error_string(err));
+		fprintf(stderr, "Error reading input file: %s\n", chd_file::error_string(err));
 		return NULL;
 	}
 
 	/* fill in the data */
 	file->chd = NULL;
-	file->hunksectors = 1;
-	file->cachehunk = -1;
 
 	LOG(("CD has %d tracks\n", file->cdtoc.numtrks));
 
 	for (i = 0; i < file->cdtoc.numtrks; i++)
 	{
-		file_error filerr = core_fopen(file->track_info.fname[i], OPEN_FLAG_READ, &file->fhandle[i]);
+		file_error filerr = core_fopen(file->track_info.track[i].fname, OPEN_FLAG_READ, &file->fhandle[i]);
 		if (filerr != FILERR_NONE)
 		{
-			fprintf(stderr, "Unable to open file: %s\n", file->track_info.fname[i]);
+			fprintf(stderr, "Unable to open file: %s\n", file->track_info.track[i].fname.cstr());
 			return NULL;
 		}
 	}
 	/* calculate the starting frame for each track, keeping in mind that CHDMAN
-       pads tracks out with extra frames to fit hunk size boundries
+       pads tracks out with extra frames to fit 4-frame size boundries
     */
 	physofs = 0;
 	for (i = 0; i < file->cdtoc.numtrks; i++)
@@ -185,14 +171,6 @@
 	file->cdtoc.tracks[i].physframeofs = physofs;
 	file->cdtoc.tracks[i].chdframeofs = 0;
 
-	/* allocate a cache */
-	file->cache = (UINT8 *)malloc(CD_FRAME_SIZE);
-	if (file->cache == NULL)
-	{
-		free(file);
-		return NULL;
-	}
-
 	return file;
 }
 
@@ -203,7 +181,6 @@
 
 cdrom_file *cdrom_open(chd_file *chd)
 {
-	const chd_header *header = chd_get_header(chd);
 	int i;
 	cdrom_file *file;
 	UINT32 physofs, chdofs;
@@ -214,7 +191,9 @@
 		return NULL;
 
 	/* validate the CHD information */
-	if (header->hunkbytes % CD_FRAME_SIZE != 0)
+	if (chd->hunk_bytes() % CD_FRAME_SIZE != 0)
+		return NULL;
+	if (chd->unit_bytes() != CD_FRAME_SIZE)
 		return NULL;
 
 	/* allocate memory for the CD-ROM file */
@@ -224,21 +203,19 @@
 
 	/* fill in the data */
 	file->chd = chd;
-	file->hunksectors = header->hunkbytes / CD_FRAME_SIZE;
-	file->cachehunk = -1;
 
 	/* read the CD-ROM metadata */
 	err = cdrom_parse_metadata(chd, &file->cdtoc);
 	if (err != CHDERR_NONE)
 	{
-		free(file);
+		delete(file);
 		return NULL;
 	}
 
 	LOG(("CD has %d tracks\n", file->cdtoc.numtrks));
 
 	/* calculate the starting frame for each track, keeping in mind that CHDMAN
-       pads tracks out with extra frames to fit hunk size boundries
+       pads tracks out with extra frames to fit 4-frame size boundries
     */
 	physofs = chdofs = 0;
 	for (i = 0; i < file->cdtoc.numtrks; i++)
@@ -265,14 +242,6 @@
 	file->cdtoc.tracks[i].physframeofs = physofs;
 	file->cdtoc.tracks[i].chdframeofs = chdofs;
 
-	/* allocate a cache */
-	file->cache = (UINT8 *)malloc(chd_get_header(chd)->hunkbytes);
-	if (file->cache == NULL)
-	{
-		free(file);
-		return NULL;
-	}
-
 	return file;
 }
 
@@ -286,10 +255,6 @@
 	if (file == NULL)
 		return;
 
-	/* free the cache */
-	if (file->cache)
-		free(file->cache);
-
 	if (file->chd == NULL)
 	{
 		for (int i = 0; i < file->cdtoc.numtrks; i++)
@@ -298,7 +263,7 @@
 		}
 	}
 
-	free(file);
+	delete(file);
 }
 
 
@@ -307,6 +272,37 @@
     CORE READ ACCESS
 ***************************************************************************/
 
+chd_error read_partial_sector(cdrom_file *file, void *dest, UINT32 chdsector, UINT32 tracknum, UINT32 startoffs, UINT32 length)
+{
+	// if a CHD, just read
+	if (file->chd != NULL)
+		return file->chd->read_bytes(UINT64(chdsector) * UINT64(CD_FRAME_SIZE) + startoffs, dest, length);
+
+	// else read from the appropriate file
+	core_file *srcfile = file->fhandle[tracknum];
+
+	UINT64 sourcefileoffset = file->track_info.track[tracknum].offset;
+	int bytespersector = file->cdtoc.tracks[tracknum].datasize + file->cdtoc.tracks[tracknum].subsize;
+
+	sourcefileoffset += chdsector * bytespersector + startoffs;
+
+	core_fseek(srcfile, sourcefileoffset, SEEK_SET);
+	core_fread(srcfile, dest, length);
+
+	if (file->track_info.track[tracknum].swap)
+	{
+		UINT8 *buffer = (UINT8 *)dest - startoffs;
+		for (int swapindex = startoffs; swapindex < 2352; swapindex += 2 )
+		{
+			int swaptemp = buffer[ swapindex ];
+			buffer[ swapindex ] = buffer[ swapindex + 1 ];
+			buffer[ swapindex + 1 ] = swaptemp;
+		}
+	}
+	return CHDERR_NONE;
+}
+
+
 /*-------------------------------------------------
     cdrom_read_data - read one or more sectors
     from a CD-ROM
@@ -314,31 +310,25 @@
 
 UINT32 cdrom_read_data(cdrom_file *file, UINT32 lbasector, void *buffer, UINT32 datatype)
 {
-	UINT32 tracktype, tracknum, sectoroffs;
-	chd_error err;
-	static const UINT8 syncbytes[12] = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
-
 	if (file == NULL)
 		return 0;
 
-	/* cache in the sector */
-	err = read_sector_into_cache(file, lbasector, &sectoroffs, &tracknum);
-	if (err != CHDERR_NONE)
-		return 0;
+	// compute CHD sector and tracknumber
+	UINT32 tracknum = 0;
+	UINT32 chdsector = physical_to_chd_lba(file, lbasector, tracknum);
 
 	/* copy out the requested sector */
-	tracktype = file->cdtoc.tracks[tracknum].trktype;
+	UINT32 tracktype = file->cdtoc.tracks[tracknum].trktype;
 	if ((datatype == tracktype) || (datatype == CD_TRACK_RAW_DONTCARE))
 	{
-		memcpy(buffer, &file->cache[sectoroffs * CD_FRAME_SIZE], file->cdtoc.tracks[tracknum].datasize);
+		return (read_partial_sector(file, buffer, chdsector, tracknum, 0, file->cdtoc.tracks[tracknum].datasize) == CHDERR_NONE);
 	}
 	else
 	{
 		/* return 2048 bytes of mode 1 data from a 2352 byte mode 1 raw sector */
 		if ((datatype == CD_TRACK_MODE1) && (tracktype == CD_TRACK_MODE1_RAW))
 		{
-			memcpy(buffer, &file->cache[(sectoroffs * CD_FRAME_SIZE) + 16], 2048);
-			return 1;
+			return (read_partial_sector(file, buffer, chdsector, tracknum, 16, 2048) == CHDERR_NONE);
 		}
 
 		/* return 2352 byte mode 1 raw sector from 2048 bytes of mode 1 data */
@@ -347,34 +337,31 @@
 			UINT8 *bufptr = (UINT8 *)buffer;
 			UINT32 msf = lba_to_msf(lbasector);
 
+			static const UINT8 syncbytes[12] = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
 			memcpy(bufptr, syncbytes, 12);
 			bufptr[12] = msf>>16;
 			bufptr[13] = msf>>8;
 			bufptr[14] = msf&0xff;
 			bufptr[15] = 1;	// mode 1
-			memcpy(bufptr+16, &file->cache[(sectoroffs * CD_FRAME_SIZE)], 2048);
 			LOG(("CDROM: promotion of mode1/form1 sector to mode1 raw is not complete!\n"));
-			return 1;
+			return (read_partial_sector(file, bufptr+16, chdsector, tracknum, 0, 2048) == CHDERR_NONE);
 		}
 
 		/* return 2048 bytes of mode 1 data from a mode2 form1 or raw sector */
 		if ((datatype == CD_TRACK_MODE1) && ((tracktype == CD_TRACK_MODE2_FORM1)||(tracktype == CD_TRACK_MODE2_RAW)))
 		{
-			memcpy(buffer, &file->cache[(sectoroffs * CD_FRAME_SIZE) + 24], 2048);
-			return 1;
+			return (read_partial_sector(file, buffer, chdsector, tracknum, 24, 2048) == CHDERR_NONE);
 		}
 
 		/* return mode 2 2336 byte data from a 2352 byte mode 1 or 2 raw sector (skip the header) */
 		if ((datatype == CD_TRACK_MODE2) && ((tracktype == CD_TRACK_MODE1_RAW) || (tracktype == CD_TRACK_MODE2_RAW)))
 		{
-			memcpy(buffer, &file->cache[(sectoroffs * CD_FRAME_SIZE) + 16], 2336);
-			return 1;
+			return (read_partial_sector(file, buffer, chdsector, tracknum, 16, 2336) == CHDERR_NONE);
 		}
 
 		LOG(("CDROM: Conversion from type %d to type %d not supported!\n", tracktype, datatype));
 		return 0;
 	}
-	return 1;
 }
 
 
@@ -385,20 +372,18 @@
 
 UINT32 cdrom_read_subcode(cdrom_file *file, UINT32 lbasector, void *buffer)
 {
-	UINT32 sectoroffs, tracknum;
-	chd_error err;
-
 	if (file == NULL)
 		return ~0;
 
-	/* cache in the sector */
-	err = read_sector_into_cache(file, lbasector, &sectoroffs, &tracknum);
-	if (err != CHDERR_NONE)
-		return 0;
-
-	/* copy out the requested data */
-	memcpy(buffer, &file->cache[(sectoroffs * CD_FRAME_SIZE) + file->cdtoc.tracks[tracknum].datasize], file->cdtoc.tracks[tracknum].subsize);
-	return 1;
+	// compute CHD sector and tracknumber
+	UINT32 tracknum = 0;
+	UINT32 chdsector = physical_to_chd_lba(file, lbasector, tracknum);
+	if (file->cdtoc.tracks[tracknum].subsize == 0)
+		return 1;
+
+	// read the data
+	chd_error err = read_partial_sector(file, buffer, chdsector, tracknum, file->cdtoc.tracks[tracknum].datasize, file->cdtoc.tracks[tracknum].subsize);
+	return (err == CHDERR_NONE);
 }
 
 
@@ -420,7 +405,7 @@
 		return ~0;
 
 	/* convert to a CHD sector offset and get track information */
-	physical_to_chd_lba(file, frame, &track);
+	physical_to_chd_lba(file, frame, track);
 	return track;
 }
 
@@ -704,81 +689,27 @@
 ***************************************************************************/
 
 /*-------------------------------------------------
-    read_sector_into_cache - cache a sector at
-    the given physical LBA
--------------------------------------------------*/
-
-static chd_error read_sector_into_cache(cdrom_file *file, UINT32 lbasector, UINT32 *sectoroffs, UINT32 *tracknum)
-{
-	UINT32 chdsector, hunknum;
-	chd_error err;
-
-	/* convert to a CHD sector offset and get track information */
-	*tracknum = 0;
-	chdsector = physical_to_chd_lba(file, lbasector, tracknum);
-	hunknum = chdsector / file->hunksectors;
-	*sectoroffs = chdsector % file->hunksectors;
-
-	/* if we haven't cached this hunk, read it now */
-	if (file->cachehunk != hunknum)
-	{
-		if (file->chd) {
-			err = chd_read(file->chd, hunknum, file->cache);
-			if (err != CHDERR_NONE)
-				return err;
-		} else {
-			core_file *srcfile = file->fhandle[*tracknum];
-
-			UINT64 sourcefileoffset = file->track_info.offset[*tracknum];
-			int bytespersector = file->cdtoc.tracks[*tracknum].datasize + file->cdtoc.tracks[*tracknum].subsize;
-
-			sourcefileoffset += chdsector * bytespersector;
-
-			core_fseek(srcfile, sourcefileoffset, SEEK_SET);
-			core_fread(srcfile, file->cache, bytespersector);
-
-			if (file->track_info.swap[*tracknum])
-			{
-				for (int swapindex = 0; swapindex < 2352; swapindex += 2 )
-				{
-					int swaptemp = file->cache[ swapindex ];
-					file->cache[ swapindex ] = file->cache[ swapindex + 1 ];
-					file->cache[ swapindex + 1 ] = swaptemp;
-				}
-			}
-		}
-
-		file->cachehunk = hunknum;
-	}
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
     cdrom_parse_metadata - parse metadata into the
     TOC structure
 -------------------------------------------------*/
 
 chd_error cdrom_parse_metadata(chd_file *chd, cdrom_toc *toc)
 {
-	static UINT32 oldmetadata[CD_METADATA_WORDS], *mrp;
-	const chd_header *header = chd_get_header(chd);
-	UINT32 hunksectors = header->hunkbytes / CD_FRAME_SIZE;
-	char metadata[512];
+	astring metadata;
 	chd_error err;
 	int i;
 
 	/* start with no tracks */
 	for (toc->numtrks = 0; toc->numtrks < CD_MAX_TRACKS; toc->numtrks++)
 	{
-		int tracknum = -1, frames = 0, hunks, pregap, postgap;
+		int tracknum = -1, frames = 0, pregap, postgap;
 		char type[16], subtype[16], pgtype[16], pgsub[16];
 		cdrom_track_info *track;
 
 		pregap = postgap = 0;
 
 		/* fetch the metadata for this track */
-		err = chd_get_metadata(chd, CDROM_TRACK_METADATA_TAG, toc->numtrks, metadata, sizeof(metadata), NULL, NULL, NULL);
+		err = chd->read_metadata(CDROM_TRACK_METADATA_TAG, toc->numtrks, metadata);
 		if (err == CHDERR_NONE)
 		{
 			/* parse the metadata */
@@ -791,7 +722,7 @@
 		}
 		else
 		{
-			err = chd_get_metadata(chd, CDROM_TRACK_METADATA2_TAG, toc->numtrks, metadata, sizeof(metadata), NULL, NULL, NULL);
+			err = chd->read_metadata(CDROM_TRACK_METADATA2_TAG, toc->numtrks, metadata);
 			if (err != CHDERR_NONE)
 				break;
 			/* parse the metadata */
@@ -818,8 +749,8 @@
 
 		/* set the frames and extra frames data */
 		track->frames = frames;
-		hunks = (frames + hunksectors - 1) / hunksectors;
-		track->extraframes = hunks * hunksectors - frames;
+		int padded = (frames + CD_TRACK_PADDING - 1) / CD_TRACK_PADDING;
+		track->extraframes = padded * CD_TRACK_PADDING - frames;
 
 		/* set the pregap info */
 		track->pregap = pregap;
@@ -839,12 +770,13 @@
 		return CHDERR_NONE;
 
 	/* look for old-style metadata */
-	err = chd_get_metadata(chd, CDROM_OLD_METADATA_TAG, 0, oldmetadata, sizeof(oldmetadata), NULL, NULL, NULL);
+	dynamic_buffer oldmetadata;
+	err = chd->read_metadata(CDROM_OLD_METADATA_TAG, 0, oldmetadata);
 	if (err != CHDERR_NONE)
 		return err;
 
 	/* reconstruct the TOC from it */
-	mrp = &oldmetadata[0];
+	UINT32 *mrp = reinterpret_cast<UINT32 *>(&oldmetadata[0]);
 	toc->numtrks = *mrp++;
 
 	for (i = 0; i < CD_MAX_TRACKS; i++)
@@ -855,6 +787,12 @@
 		toc->tracks[i].subsize = *mrp++;
 		toc->tracks[i].frames = *mrp++;
 		toc->tracks[i].extraframes = *mrp++;
+		toc->tracks[i].pregap = 0;
+		toc->tracks[i].postgap = 0;
+		toc->tracks[i].pgtype = 0;
+		toc->tracks[i].pgsub = 0;
+		toc->tracks[i].pgdatasize = 0;
+		toc->tracks[i].pgsubsize = 0;
 	}
 
 	/* TODO: I don't know why sometimes the data is one endian and sometimes another */
@@ -888,13 +826,13 @@
 	/* write the metadata */
 	for (i = 0; i < toc->numtrks; i++)
 	{
-		char metadata[512];
-		sprintf(metadata, CDROM_TRACK_METADATA2_FORMAT, i + 1, cdrom_get_type_string(toc->tracks[i].trktype),
+		astring metadata;
+		metadata.format(CDROM_TRACK_METADATA2_FORMAT, i + 1, cdrom_get_type_string(toc->tracks[i].trktype),
 				cdrom_get_subtype_string(toc->tracks[i].subtype), toc->tracks[i].frames, toc->tracks[i].pregap,
 				cdrom_get_type_string(toc->tracks[i].pgtype), cdrom_get_subtype_string(toc->tracks[i].pgsub),
 				toc->tracks[i].postgap);
 
-		err = chd_set_metadata(chd, CDROM_TRACK_METADATA2_TAG, i, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
+		err = chd->write_metadata(CDROM_TRACK_METADATA2_TAG, i, metadata);
 		if (err != CHDERR_NONE)
 			return err;
 	}
diff -Nru src-old/lib/util/cdrom.h src/lib/util/cdrom.h
--- src-old/lib/util/cdrom.h	2012-01-29 04:26:34.000000000 +0100
+++ src/lib/util/cdrom.h	2012-02-16 10:47:18.000000000 +0100
@@ -51,6 +51,9 @@
     CONSTANTS
 ***************************************************************************/
 
+// tracks are padded to a multiple of this many frames
+const UINT32 CD_TRACK_PADDING = 4;
+
 #define CD_MAX_TRACKS			(99)	/* AFAIK the theoretical limit */
 #define CD_MAX_SECTOR_DATA		(2352)
 #define CD_MAX_SUBCODE_DATA		(96)
@@ -90,8 +93,7 @@
 typedef struct _cdrom_file cdrom_file;
 
 
-typedef struct _cdrom_track_info cdrom_track_info;
-struct _cdrom_track_info
+struct cdrom_track_info
 {
 	/* fields used by CHDMAN and in MAME */
 	UINT32 trktype;		/* track type */
@@ -113,8 +115,7 @@
 };
 
 
-typedef struct _cdrom_toc cdrom_toc;
-struct _cdrom_toc
+struct cdrom_toc
 {
 	UINT32 numtrks;		/* number of tracks */
 	cdrom_track_info tracks[CD_MAX_TRACKS];
diff -Nru src-old/lib/util/chd.c src/lib/util/chd.c
--- src-old/lib/util/chd.c	2012-02-01 15:45:19.000000000 +0100
+++ src/lib/util/chd.c	2012-02-19 16:23:23.000000000 +0100
@@ -38,3532 +38,2730 @@
 ***************************************************************************/
 
 #include "chd.h"
-#include "avcomp.h"
-#include "md5.h"
-#include "sha1.h"
+#include "avhuff.h"
+#include "hashing.h"
+#include "flac.h"
 #include "cdrom.h"
+#include "coretmpl.h"
 #include <zlib.h>
 #include <time.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <new>
 
-#include "../../lib/libflac/include/flac/all.h"
 
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-/***************************************************************************
-    DEBUGGING
-***************************************************************************/
-
-#define PRINTF_MAX_HUNK				(0)
+// standard metadata formats
+const char *HARD_DISK_METADATA_FORMAT = "CYLS:%d,HEADS:%d,SECS:%d,BPS:%d";
+const char *CDROM_TRACK_METADATA_FORMAT = "TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d";
+const char *CDROM_TRACK_METADATA2_FORMAT = "TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d PREGAP:%d PGTYPE:%s PGSUB:%s POSTGAP:%d";
+const char *AV_METADATA_FORMAT = "FPS:%d.%06d WIDTH:%d HEIGHT:%d INTERLACED:%d CHANNELS:%d SAMPLERATE:%d";
 
+static const UINT32 METADATA_HEADER_SIZE = 16;			// metadata header size
 
+static const UINT8 V34_MAP_ENTRY_FLAG_TYPE_MASK	= 0x0f;		// what type of hunk
+static const UINT8 V34_MAP_ENTRY_FLAG_NO_CRC = 0x10;		// no CRC is present
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-#define MAP_STACK_ENTRIES			512			/* max number of entries to use on the stack */
-#define MAP_ENTRY_SIZE				16			/* V3 and later */
-#define OLD_MAP_ENTRY_SIZE			8			/* V1-V2 */
-#define METADATA_HEADER_SIZE		16			/* metadata header size */
-#define CRCMAP_HASH_SIZE			4095		/* number of CRC hashtable entries */
 
-#define MAP_ENTRY_FLAG_TYPE_MASK	0x0f		/* what type of hunk */
-#define MAP_ENTRY_FLAG_NO_CRC		0x10		/* no CRC is present */
-#define MAP_ENTRY_FLAG_HALF_HUNK	0x20		/* only the first half of this hunk is included in the SHA1 calculation (workaround for CD track padding issue) */
 
-#define MAP_ENTRY_TYPE_INVALID		        0x00		/* invalid type */
-#define MAP_ENTRY_TYPE_COMPRESSED	        0x01		/* standard compression */
-#define MAP_ENTRY_TYPE_UNCOMPRESSED	        0x02		/* uncompressed data */
-#define MAP_ENTRY_TYPE_MINI			        0x03		/* mini: use offset as raw data */
-#define MAP_ENTRY_TYPE_SELF_HUNK	        0x04		/* same as another hunk in this file */
-#define MAP_ENTRY_TYPE_PARENT_HUNK	        0x05		/* same as a hunk in the parent file */
-#define MAP_ENTRY_TYPE_2ND_COMPRESSED	    0x06		/* compressed with secondary algorithm (usually FLAC CDDA) */
+// V3-V4 entry types
+enum
+{
+	V34_MAP_ENTRY_TYPE_INVALID = 0,				// invalid type
+	V34_MAP_ENTRY_TYPE_COMPRESSED = 1,			// standard compression
+	V34_MAP_ENTRY_TYPE_UNCOMPRESSED = 2,		// uncompressed data
+	V34_MAP_ENTRY_TYPE_MINI = 3,				// mini: use offset as raw data
+	V34_MAP_ENTRY_TYPE_SELF_HUNK = 4,			// same as another hunk in this file
+	V34_MAP_ENTRY_TYPE_PARENT_HUNK = 5,			// same as a hunk in the parent file
+	V34_MAP_ENTRY_TYPE_2ND_COMPRESSED = 6		// compressed with secondary algorithm (usually FLAC CDDA)
+};
 
-#define CHD_V1_SECTOR_SIZE			512			/* size of a "sector" in the V1 header */
+// V5 compression types
+enum
+{
+	// these types are live when running
+	COMPRESSION_TYPE_0 = 0,						// codec #0
+	COMPRESSION_TYPE_1 = 1,						// codec #1
+	COMPRESSION_TYPE_2 = 2,						// codec #2
+	COMPRESSION_TYPE_3 = 3,						// codec #3
+	COMPRESSION_NONE = 4,						// no compression; implicit length = hunkbytes
+	COMPRESSION_SELF = 5,						// same as another block in this chd
+	COMPRESSION_PARENT = 6,						// same as a hunk's worth of units in the parent chd
+
+	// these additional pseudo-types are used for compressed encodings:
+	COMPRESSION_RLE_SMALL,						// start of small RLE run (4-bit length)
+	COMPRESSION_RLE_LARGE,						// start of large RLE run (8-bit length)
+	COMPRESSION_SELF_0,							// same as the last COMPRESSION_SELF block
+	COMPRESSION_SELF_1,							// same as the last COMPRESSION_SELF block + 1
+	COMPRESSION_PARENT_SELF,					// same block in the parent
+	COMPRESSION_PARENT_0,						// same as the last COMPRESSION_PARENT block
+	COMPRESSION_PARENT_1						// same as the last COMPRESSION_PARENT block + 1
+};
 
-#define COOKIE_VALUE				0xbaadf00d
-#define MAX_ZLIB_ALLOCS				64
 
-#define END_OF_LIST_COOKIE			"EndOfListCookie"
 
-#define NO_MATCH					(~0)
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> metadata_entry
+
+// description of where a metadata entry lives within the file
+struct chd_file::metadata_entry
+{
+	UINT64					offset;			// offset within the file of the header
+	UINT64					next;			// offset within the file of the next header
+	UINT64					prev;			// offset within the file of the previous header
+	UINT32					length;			// length of the metadata
+	UINT32					metatag;		// metadata tag
+	UINT8					flags;			// flag bits
+};
 
 
+// ======================> metadata_hash
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+struct chd_file::metadata_hash
+{
+	UINT8					tag[4];			// tag of the metadata in big-endian
+	sha1_t					sha1;			// hash data
+};
 
-#define EARLY_EXIT(x)				do { (void)(x); goto cleanup; } while (0)
 
 
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//-------------------------------------------------
+//  be_read - extract a big-endian number from
+//  a byte buffer
+//-------------------------------------------------
 
-/* interface to a codec */
-typedef struct _codec_interface codec_interface;
-struct _codec_interface
-{
-	UINT32		compression;				/* type of compression */
-	const char *compname;					/* name of the algorithm */
-	UINT8		lossy;						/* is this a lossy algorithm? */
-	chd_error	(*init)(chd_file *chd);		/* codec initialize */
-	void		(*free)(chd_file *chd);		/* codec free */
-	chd_error	(*compress)(chd_file *chd, const void *src, UINT32 *complen); /* compress data */
-	chd_error	(*decompress)(chd_file *chd, UINT32 complen, void *dst); /* decompress data */
-	chd_error	(*config)(chd_file *chd, int param, void *config); /* configure */
+inline UINT64 chd_file::be_read(const UINT8 *base, int numbytes)
+{
+	UINT64 result = 0;
+	while (numbytes--)
+		result = (result << 8) | *base++;
+	return result;
+}
 
-	chd_error	(*secondary_compress)(chd_file *chd, const void *src, UINT32 *complen); /* secondary compress data */
-	chd_error	(*secondary_decompress)(chd_file *chd, UINT32 complen, void *dst); /* secondary decompress data */
 
-};
+//-------------------------------------------------
+//  be_write - write a big-endian number to a byte
+//  buffer
+//-------------------------------------------------
 
+inline void chd_file::be_write(UINT8 *base, UINT64 value, int numbytes)
+{
+	base += numbytes;
+	while (numbytes--)
+	{
+		*--base = value;
+		value >>= 8;
+	}
+}
 
-/* a single map entry */
-typedef struct _map_entry map_entry;
-struct _map_entry
-{
-	UINT64					offset;			/* offset within the file of the data */
-	UINT32					crc;			/* 32-bit CRC of the data */
-	UINT32					length;			/* length of the data */
-	UINT8					flags;			/* misc flags */
-};
 
+//-------------------------------------------------
+//  be_read_sha1 - fetch a sha1_t from a data
+//  stream in bigendian order
+//-------------------------------------------------
 
-/* simple linked-list of hunks used for our CRC map */
-typedef struct _crcmap_entry crcmap_entry;
-struct _crcmap_entry
+inline sha1_t chd_file::be_read_sha1(const UINT8 *base)
 {
-	UINT32					hunknum;		/* hunk number */
-	crcmap_entry *			next;			/* next entry in list */
-};
-
+	sha1_t result;
+	memcpy(&result.m_raw[0], base, sizeof(result.m_raw));
+	return result;
+}
 
-/* a single metadata entry */
-typedef struct _metadata_entry metadata_entry;
-struct _metadata_entry
-{
-	UINT64					offset;			/* offset within the file of the header */
-	UINT64					next;			/* offset within the file of the next header */
-	UINT64					prev;			/* offset within the file of the previous header */
-	UINT32					length;			/* length of the metadata */
-	UINT32					metatag;		/* metadata tag */
-	UINT8					flags;			/* flag bits */
-};
 
+//-------------------------------------------------
+//  be_write_sha1 - write a sha1_t to a data
+//  stream in bigendian order
+//-------------------------------------------------
 
-/* internal representation of an open CHD file */
-struct _chd_file
+inline void chd_file::be_write_sha1(UINT8 *base, sha1_t value)
 {
-	UINT32					cookie;			/* cookie, should equal COOKIE_VALUE */
-
-	core_file *				file;			/* handle to the open core file */
-	UINT8					owns_file;		/* flag indicating if this file should be closed on chd_close() */
-	chd_header				header;			/* header, extracted from file */
+	memcpy(base, &value.m_raw[0], sizeof(value.m_raw));
+}
 
-	chd_file *				parent;			/* pointer to parent file, or NULL */
 
-	map_entry *				map;			/* array of map entries */
+//-------------------------------------------------
+//  file_read - read from the file at the given
+//  offset; on failure throw an error
+//-------------------------------------------------
 
-	UINT8 *					cache;			/* hunk cache pointer */
-	UINT32					cachehunk;		/* index of currently cached hunk */
+inline void chd_file::file_read(UINT64 offset, void *dest, UINT32 length)
+{
+	// no file = failure
+	if (m_file == NULL)
+		throw CHDERR_NOT_OPEN;
 
-	UINT8 *					compare;		/* hunk compare pointer */
-	UINT32					comparehunk;	/* index of current compare data */
+	// seek and read
+	core_fseek(m_file, offset, SEEK_SET);
+	UINT32 count = core_fread(m_file, dest, length);
+	if (count != length)
+		throw CHDERR_READ_ERROR;
+}
 
-	UINT8 *					compressed;		/* pointer to buffer for compressed data */
-	const codec_interface *	codecintf;		/* interface to the codec */
-	void *					codecdata;		/* opaque pointer to codec data */
 
-	crcmap_entry *			crcmap;			/* CRC map entries */
-	crcmap_entry *			crcfree;		/* free list CRC entries */
-	crcmap_entry **			crctable;		/* table of CRC entries */
+//-------------------------------------------------
+//  file_write - write to the file at the given
+//  offset; on failure throw an error
+//-------------------------------------------------
 
-	UINT32					maxhunk;		/* maximum hunk accessed */
+inline void chd_file::file_write(UINT64 offset, const void *source, UINT32 length)
+{
+	// no file = failure
+	if (m_file == NULL)
+		throw CHDERR_NOT_OPEN;
 
-	UINT8					compressing;	/* are we compressing? */
-	struct MD5Context		compmd5;		/* running MD5 during compression */
-	struct sha1_ctx			compsha1;		/* running SHA1 during compression */
-	UINT32					comphunk;		/* next hunk we will compress */
+	// seek and write
+	core_fseek(m_file, offset, SEEK_SET);
+	UINT32 count = core_fwrite(m_file, source, length);
+	if (count != length)
+		throw CHDERR_WRITE_ERROR;
+}
 
-	UINT8					verifying;		/* are we verifying? */
-	struct MD5Context		vermd5; 		/* running MD5 during verification */
-	struct sha1_ctx			versha1;		/* running SHA1 during verification */
-	UINT32					verhunk;		/* next hunk we will verify */
 
-	osd_work_queue *		workqueue;		/* pointer to work queue for async operations */
-	osd_work_item *			workitem;		/* active work item, or NULL if none */
-	UINT32					async_hunknum;	/* hunk index for asynchronous operations */
-	void *					async_buffer;	/* buffer pointer for asynchronous operations */
-};
+//-------------------------------------------------
+//  file_append - append to the file at the given
+//  offset, ensuring we start at the given
+//  alignment; on failure throw an error
+//-------------------------------------------------
 
+inline UINT64 chd_file::file_append(const void *source, UINT32 length, UINT32 alignment)
+{
+	// no file = failure
+	if (m_file == NULL)
+		throw CHDERR_NOT_OPEN;
 
-/* codec-private data for the ZLIB codec */
-typedef struct _zlib_codec_data zlib_codec_data;
-struct _zlib_codec_data
-{
-	z_stream				inflater;
-	z_stream				deflater;
-	UINT32 *				allocptr[MAX_ZLIB_ALLOCS];
-};
+	// seek to the end and align if necessary
+	core_fseek(m_file, 0, SEEK_END);
+	if (alignment != 0)
+	{
+		UINT64 offset = core_ftell(m_file);
+		UINT32 delta = offset % alignment;
+		if (delta != 0)
+		{
+			// pad with 0's from a local buffer
+			UINT8 buffer[1024];
+			memset(buffer, 0, sizeof(buffer));
+			delta = alignment - delta;
+			while (delta != 0)
+			{
+				UINT32 bytes_to_write = MIN(sizeof(buffer), delta);
+				UINT32 count = core_fwrite(m_file, buffer, bytes_to_write);
+				if (count != bytes_to_write)
+					throw CHDERR_WRITE_ERROR;
+				delta -= bytes_to_write;
+			}
+		}
+	}
 
+	// write the real data
+	UINT64 offset = core_ftell(m_file);
+	UINT32 count = core_fwrite(m_file, source, length);
+	if (count != length)
+		throw CHDERR_READ_ERROR;
+	return offset;
+}
 
-/* codec-private data for the A/V codec */
-struct av_codec_data
-{
-	avcomp_state *			compstate;
-	av_codec_compress_config compress;
-	av_codec_decompress_config decompress;
-};
 
+//-------------------------------------------------
+//  bits_for_value - return the number of bits
+//  necessary to represent all numbers 0..value
+//-------------------------------------------------
 
-/* a single metadata hash entry */
-typedef struct _metadata_hash metadata_hash;
-struct _metadata_hash
+inline UINT8 chd_file::bits_for_value(UINT64 value)
 {
-	UINT8					tag[4];			/* tag of the metadata in big-endian */
-	UINT8					sha1[CHD_SHA1_BYTES]; /* hash */
-};
-
+	UINT8 result = 0;
+	while (value != 0)
+		value >>= 1, result++;
+	return result;
+}
 
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
 
-static const UINT8 nullmd5[CHD_MD5_BYTES] = { 0 };
-static const UINT8 nullsha1[CHD_SHA1_BYTES] = { 0 };
+//**************************************************************************
+//  CHD FILE MANAGEMENT
+//**************************************************************************
 
+//-------------------------------------------------
+//  chd_file - constructor
+//-------------------------------------------------
 
+chd_file::chd_file()
+	: m_file(NULL)
+{
+	// reset state
+	memset(m_decompressor, 0, sizeof(m_decompressor));
+	close();
+}
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
 
-/* internal async operations */
-static void *async_read_callback(void *param, int threadid);
-static void *async_write_callback(void *param, int threadid);
-
-/* internal header operations */
-static chd_error header_validate(const chd_header *header);
-static chd_error header_read(core_file *file, chd_header *header);
-static chd_error header_write(core_file *file, const chd_header *header);
-
-/* internal hunk read/write */
-static chd_error hunk_read_into_cache(chd_file *chd, UINT32 hunknum);
-static chd_error hunk_read_into_memory(chd_file *chd, UINT32 hunknum, UINT8 *dest);
-static chd_error hunk_write_from_memory(chd_file *chd, UINT32 hunknum, const UINT8 *src, int is_half_hunk = 0);
-
-/* internal map access */
-static chd_error map_write_initial(core_file *file, chd_file *parent, const chd_header *header);
-static chd_error map_read(chd_file *chd);
-
-/* internal CRC map access */
-static void crcmap_init(chd_file *chd, int prepopulate);
-static void crcmap_add_entry(chd_file *chd, UINT32 hunknum);
-static UINT32 crcmap_find_hunk(chd_file *chd, UINT32 hunknum, UINT32 crc, const UINT8 *rawdata);
-
-/* metadata management */
-static chd_error metadata_find_entry(chd_file *chd, UINT32 metatag, UINT32 metaindex, metadata_entry *metaentry);
-static chd_error metadata_set_previous_next(chd_file *chd, UINT64 prevoffset, UINT64 nextoffset);
-static chd_error metadata_set_length(chd_file *chd, UINT64 offset, UINT32 length);
-static chd_error metadata_compute_hash(chd_file *chd, const UINT8 *rawsha1, UINT8 *finalsha1);
-static int CLIB_DECL metadata_hash_compare(const void *elem1, const void *elem2);
-
-/* zlib compression codec */
-static chd_error zlib_codec_init(chd_file *chd);
-static void zlib_codec_free(chd_file *chd);
-static chd_error zlib_codec_compress(chd_file *chd, const void *src, UINT32 *length);
-static chd_error zlib_codec_decompress(chd_file *chd, UINT32 srclength, void *dest);
-static voidpf zlib_fast_alloc(voidpf opaque, uInt items, uInt size);
-static void zlib_fast_free(voidpf opaque, voidpf address);
-
-/* flac compression codec */
-static chd_error flac_codec_compress(chd_file *chd, const void *src, UINT32 *length, int swap);
-static chd_error flac_codec_compress_normal(chd_file *chd, const void *src, UINT32 *length);
-static chd_error flac_codec_decompress(chd_file *chd, UINT32 srclength, void *dest);
-
-
-/* A/V compression codec */
-static chd_error av_codec_init(chd_file *chd);
-static void av_codec_free(chd_file *chd);
-static chd_error av_codec_compress(chd_file *chd, const void *src, UINT32 *length);
-static chd_error av_codec_decompress(chd_file *chd, UINT32 srclength, void *dest);
-static chd_error av_codec_config(chd_file *chd, int param, void *config);
-static chd_error av_codec_postinit(chd_file *chd);
+//-------------------------------------------------
+//  ~chd_file - destructor
+//-------------------------------------------------
 
+chd_file::~chd_file()
+{
+	// close any open files
+	close();
+}
 
 
-/***************************************************************************
-    CODEC INTERFACES
-***************************************************************************/
+//-------------------------------------------------
+//  sha1 - return our SHA1 value
+//-------------------------------------------------
 
-static const codec_interface codec_interfaces[] =
+sha1_t chd_file::sha1()
 {
-	/* "none" or no compression */
+	try
 	{
-		CHDCOMPRESSION_NONE,
-		"none",
-		FALSE,
-		NULL,
-		NULL,
-		NULL,
-		NULL,
-		NULL,
-		NULL,
-		NULL
-	},
-
-	/* standard zlib compression */
-	{
-		CHDCOMPRESSION_ZLIB,
-		"zlib",
-		FALSE,
-		zlib_codec_init,
-		zlib_codec_free,
-		zlib_codec_compress,
-		zlib_codec_decompress,
-		NULL,
-		NULL,
-		NULL
-	},
-
-	/* zlib+ compression */
-	{
-		CHDCOMPRESSION_ZLIB_PLUS,
-		"zlib+",
-		FALSE,
-		zlib_codec_init,
-		zlib_codec_free,
-		zlib_codec_compress,
-		zlib_codec_decompress,
-		NULL,
-		NULL,
-		NULL
-	},
-
-	/* a/v compression */
-	{
-		CHDCOMPRESSION_AV,
-		"A/V",
-		TRUE,
-		av_codec_init,
-		av_codec_free,
-		av_codec_compress,
-		av_codec_decompress,
-		av_codec_config,
-		NULL,
-		NULL
-	},
-
-	/* zlib+ with FLAC compression */
-	{
-		CHDCOMPRESSION_ZLIB_PLUS_WITH_FLAC,
-		"zlib+ with FLAC",
-		FALSE,
-		zlib_codec_init,
-		zlib_codec_free,
-		zlib_codec_compress,
-		zlib_codec_decompress,
-		NULL,
-		flac_codec_compress_normal,
-		flac_codec_decompress,
-	},
-};
-
-
+		// read the big-endian version
+		UINT8 rawbuf[sizeof(sha1_t)];
+		file_read(m_sha1_offset, rawbuf, sizeof(rawbuf));
+		return be_read_sha1(rawbuf);
+	}
+	catch (chd_error &)
+	{
+		// on failure, return NULL
+		return sha1_t::null;
+	}
+}
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
 
-/*-------------------------------------------------
-    get_bigendian_uint64 - fetch a UINT64 from
-    the data stream in bigendian order
--------------------------------------------------*/
+//-------------------------------------------------
+//  raw_sha1 - return our raw SHA1 value
+//-------------------------------------------------
 
-INLINE UINT64 get_bigendian_uint64(const UINT8 *base)
+sha1_t chd_file::raw_sha1()
 {
-	return ((UINT64)base[0] << 56) | ((UINT64)base[1] << 48) | ((UINT64)base[2] << 40) | ((UINT64)base[3] << 32) |
-			((UINT64)base[4] << 24) | ((UINT64)base[5] << 16) | ((UINT64)base[6] << 8) | (UINT64)base[7];
+	try
+	{
+		// determine offset within the file for data-only
+		if (m_rawsha1_offset == 0)
+			throw CHDERR_UNSUPPORTED_VERSION;
+
+		// read the big-endian version
+		UINT8 rawbuf[sizeof(sha1_t)];
+		file_read(m_rawsha1_offset, rawbuf, sizeof(rawbuf));
+		return be_read_sha1(rawbuf);
+	}
+	catch (chd_error &)
+	{
+		// on failure, return NULL
+		return sha1_t::null;
+	}
 }
 
 
-/*-------------------------------------------------
-    put_bigendian_uint64 - write a UINT64 to
-    the data stream in bigendian order
--------------------------------------------------*/
+//-------------------------------------------------
+//  parent_sha1 - return our parent's SHA1 value
+//-------------------------------------------------
 
-INLINE void put_bigendian_uint64(UINT8 *base, UINT64 value)
+sha1_t chd_file::parent_sha1()
 {
-	base[0] = value >> 56;
-	base[1] = value >> 48;
-	base[2] = value >> 40;
-	base[3] = value >> 32;
-	base[4] = value >> 24;
-	base[5] = value >> 16;
-	base[6] = value >> 8;
-	base[7] = value;
+	try
+	{
+		// determine offset within the file
+		if (m_parentsha1_offset == 0)
+			throw CHDERR_UNSUPPORTED_VERSION;
+
+		// read the big-endian version
+		UINT8 rawbuf[sizeof(sha1_t)];
+		file_read(m_parentsha1_offset, rawbuf, sizeof(rawbuf));
+		return be_read_sha1(rawbuf);
+	}
+	catch (chd_error &)
+	{
+		// on failure, return NULL
+		return sha1_t::null;
+	}
 }
 
 
-/*-------------------------------------------------
-    get_bigendian_uint32 - fetch a UINT32 from
-    the data stream in bigendian order
--------------------------------------------------*/
+//-------------------------------------------------
+//  hunk_info - return information about this
+//  hunk
+//-------------------------------------------------
 
-INLINE UINT32 get_bigendian_uint32(const UINT8 *base)
+chd_error chd_file::hunk_info(UINT32 hunknum, chd_codec_type &compressor, UINT32 &compbytes)
 {
-	return (base[0] << 24) | (base[1] << 16) | (base[2] << 8) | base[3];
-}
+	// error if invalid
+	if (hunknum >= m_hunkcount)
+		return CHDERR_HUNK_OUT_OF_RANGE;
 
+	// get the map pointer
+	UINT8 *rawmap;
+	switch (m_version)
+	{
+		// v3/v4 map entries
+		case 3:
+		case 4:
+			rawmap = m_rawmap + 16 * hunknum;
+			switch (rawmap[15] & V34_MAP_ENTRY_FLAG_TYPE_MASK)
+			{
+				case V34_MAP_ENTRY_TYPE_COMPRESSED:
+					compressor = CHD_CODEC_ZLIB;
+					compbytes = be_read(&rawmap[12], 2) + (rawmap[14] << 16);
+					break;
 
-/*-------------------------------------------------
-    put_bigendian_uint32 - write a UINT32 to
-    the data stream in bigendian order
--------------------------------------------------*/
+				case V34_MAP_ENTRY_TYPE_UNCOMPRESSED:
+					compressor = CHD_CODEC_NONE;
+					compbytes = m_hunkbytes;
+					break;
 
-INLINE void put_bigendian_uint32(UINT8 *base, UINT32 value)
-{
-	base[0] = value >> 24;
-	base[1] = value >> 16;
-	base[2] = value >> 8;
-	base[3] = value;
-}
+				case V34_MAP_ENTRY_TYPE_MINI:
+					compressor = CHD_CODEC_MINI;
+					compbytes = 0;
+					break;
 
+				case V34_MAP_ENTRY_TYPE_SELF_HUNK:
+					compressor = CHD_CODEC_SELF;
+					compbytes = 0;
+					break;
 
-/*-------------------------------------------------
-    get_bigendian_uint16 - fetch a UINT16 from
-    the data stream in bigendian order
--------------------------------------------------*/
+				case V34_MAP_ENTRY_TYPE_PARENT_HUNK:
+					compressor = CHD_CODEC_PARENT;
+					compbytes = 0;
+					break;
+			}
+			break;
 
-INLINE UINT16 get_bigendian_uint16(const UINT8 *base)
-{
-	return (base[0] << 8) | base[1];
-}
+		// v5 map entries
+		case 5:
+			rawmap = m_rawmap + m_mapentrybytes * hunknum;
 
+			// uncompressed case
+			if (!compressed())
+			{
+				if (be_read(&rawmap[0], 4) == 0)
+				{
+					compressor = CHD_CODEC_PARENT;
+					compbytes = 0;
+				}
+				else
+				{
+					compressor = CHD_CODEC_NONE;
+					compbytes = m_hunkbytes;
+				}
+				break;
+			}
 
-/*-------------------------------------------------
-    put_bigendian_uint16 - write a UINT16 to
-    the data stream in bigendian order
--------------------------------------------------*/
+			// compressed case
+			switch (rawmap[0])
+			{
+				case COMPRESSION_TYPE_0:
+				case COMPRESSION_TYPE_1:
+				case COMPRESSION_TYPE_2:
+				case COMPRESSION_TYPE_3:
+					compressor = m_compression[rawmap[0]];
+					compbytes = be_read(&rawmap[1], 3);
+					break;
 
-INLINE void put_bigendian_uint16(UINT8 *base, UINT16 value)
-{
-	base[0] = value >> 8;
-	base[1] = value;
+				case COMPRESSION_NONE:
+					compressor = CHD_CODEC_NONE;
+					compbytes = m_hunkbytes;
+					break;
+
+				case COMPRESSION_SELF:
+					compressor = CHD_CODEC_SELF;
+					compbytes = 0;
+					break;
+
+				case COMPRESSION_PARENT:
+					compressor = CHD_CODEC_PARENT;
+					compbytes = 0;
+					break;
+			}
+			break;
+	}
+	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    map_extract - extract a single map
-    entry from the datastream
--------------------------------------------------*/
+//-------------------------------------------------
+//  set_raw_sha1 - set our SHA1 values
+//-------------------------------------------------
 
-INLINE void map_extract(const UINT8 *base, map_entry *entry)
+void chd_file::set_raw_sha1(sha1_t rawdata)
 {
-	entry->offset = get_bigendian_uint64(&base[0]);
-	entry->crc = get_bigendian_uint32(&base[8]);
-	entry->length = get_bigendian_uint16(&base[12]) | (base[14] << 16);
-	entry->flags = base[15];
+	// create a big-endian version
+	UINT8 rawbuf[sizeof(sha1_t)];
+	be_write_sha1(rawbuf, rawdata);
+
+	// write to the header
+	UINT64 offset = (m_rawsha1_offset != 0) ? m_rawsha1_offset : m_sha1_offset;
+	assert(offset != 0);
+	file_write(offset, rawbuf, sizeof(rawbuf));
+
+	// if we have a separate rawsha1_offset, update the full sha1 as well
+	if (m_rawsha1_offset != 0)
+		metadata_update_hash();
 }
 
 
-/*-------------------------------------------------
-    map_assemble - write a single map
-    entry to the datastream
--------------------------------------------------*/
+//-------------------------------------------------
+//  set_parent_sha1 - set the parent SHA1 value
+//-------------------------------------------------
 
-INLINE void map_assemble(UINT8 *base, map_entry *entry)
+void chd_file::set_parent_sha1(sha1_t parent)
 {
-	put_bigendian_uint64(&base[0], entry->offset);
-	put_bigendian_uint32(&base[8], entry->crc);
-	put_bigendian_uint16(&base[12], entry->length);
-	base[14] = entry->length >> 16;
-	base[15] = entry->flags;
+	// if no file, fail
+	if (m_file == NULL)
+		throw CHDERR_INVALID_FILE;
+
+	// create a big-endian version
+	UINT8 rawbuf[sizeof(sha1_t)];
+	be_write_sha1(rawbuf, parent);
+
+	// write to the header
+	assert(m_parentsha1_offset != 0);
+	file_write(m_parentsha1_offset, rawbuf, sizeof(rawbuf));
 }
 
 
-/*-------------------------------------------------
-    map_extract_old - extract a single map
-    entry in old format from the datastream
--------------------------------------------------*/
+//-------------------------------------------------
+//  create - create a new file with no parent
+//  using an existing opened file handle
+//-------------------------------------------------
 
-INLINE void map_extract_old(const UINT8 *base, map_entry *entry, UINT32 hunkbytes)
+chd_error chd_file::create(core_file &file, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 unitbytes, chd_codec_type compression[4])
 {
-	entry->offset = get_bigendian_uint64(&base[0]);
-	entry->crc = 0;
-	entry->length = entry->offset >> 44;
-	entry->flags = MAP_ENTRY_FLAG_NO_CRC | ((entry->length == hunkbytes) ? MAP_ENTRY_TYPE_UNCOMPRESSED : MAP_ENTRY_TYPE_COMPRESSED);
-#ifdef __MWERKS__
-	entry->offset = entry->offset & 0x00000FFFFFFFFFFFLL;
-#else
-	entry->offset = (entry->offset << 20) >> 20;
-#endif
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
+
+	// set the header parameters
+	m_version = HEADER_VERSION;
+	m_logicalbytes = logicalbytes;
+	m_metaoffset = 0;
+	m_hunkbytes = hunkbytes;
+	m_hunkcount = (m_logicalbytes + m_hunkbytes - 1) / m_hunkbytes;
+	m_unitbytes = unitbytes;
+	memcpy(m_compression, compression, sizeof(m_compression));
+	m_parent = NULL;
+
+	// take ownership of the file
+	m_file = &file;
+	m_owns_file = false;
+	return create_common();
 }
 
 
-/*-------------------------------------------------
-    queue_async_operation - queue a new work
-    item
--------------------------------------------------*/
+//-------------------------------------------------
+//  create - create a new file with a parent
+//  using an existing opened file handle
+//-------------------------------------------------
 
-INLINE int queue_async_operation(chd_file *chd, osd_work_callback callback)
+chd_error chd_file::create(core_file &file, UINT64 logicalbytes, UINT32 hunkbytes, chd_codec_type compression[4], chd_file &parent)
 {
-	/* if no queue yet, create one on the fly */
-	if (chd->workqueue == NULL)
-	{
-		chd->workqueue = osd_work_queue_alloc(WORK_QUEUE_FLAG_IO);
-		if (chd->workqueue == NULL)
-			return FALSE;
-	}
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
 
-	/* make sure we cleared out the previous item */
-	if (chd->workitem != NULL)
-		return FALSE;
+	// set the header parameters
+	m_version = HEADER_VERSION;
+	m_logicalbytes = logicalbytes;
+	m_metaoffset = 0;
+	m_hunkbytes = hunkbytes;
+	m_hunkcount = (m_logicalbytes + m_hunkbytes - 1) / m_hunkbytes;
+	m_unitbytes = parent.unit_bytes();
+	memcpy(m_compression, compression, sizeof(m_compression));
+	m_parent = &parent;
 
-	/* create a new work item to run the job */
-	chd->workitem = osd_work_item_queue(chd->workqueue, callback, chd, 0);
-	if (chd->workitem == NULL)
-		return FALSE;
-
-	return TRUE;
+	// take ownership of the file
+	m_file = &file;
+	m_owns_file = false;
+	return create_common();
 }
 
 
-/*-------------------------------------------------
-    wait_for_pending_async - wait for any pending
-    async
--------------------------------------------------*/
+//-------------------------------------------------
+//  create - create a new file with no parent
+//  using a filename
+//-------------------------------------------------
 
-INLINE void wait_for_pending_async(chd_file *chd)
+chd_error chd_file::create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 unitbytes, chd_codec_type compression[4])
 {
-	/* if something is pending, wait for it */
-	if (chd->workitem != NULL)
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
+
+	// create the new file
+	core_file *file = NULL;
+	file_error filerr = core_fopen(filename, OPEN_FLAG_READ | OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &file);
+	if (filerr != FILERR_NONE)
+		return CHDERR_FILE_NOT_FOUND;
+
+	// create the file normally, then claim the file
+	chd_error chderr = create(*file, logicalbytes, hunkbytes, unitbytes, compression);
+	m_owns_file = true;
+
+	// if an error happened, close and delete the file
+	if (chderr != CHDERR_NONE)
 	{
-		/* 10 seconds should be enough for anything! */
-		int wait_successful = osd_work_item_wait(chd->workitem, 10 * osd_ticks_per_second());
-		if (!wait_successful)
-			osd_break_into_debugger("Pending async operation never completed!");
+		core_fclose(file);
+		osd_rmfile(filename);
 	}
+	return chderr;
 }
 
 
+//-------------------------------------------------
+//  create - create a new file with a parent
+//  using a filename
+//-------------------------------------------------
+
+chd_error chd_file::create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, chd_codec_type compression[4], chd_file &parent)
+{
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
 
-/***************************************************************************
-    CHD FILE MANAGEMENT
-***************************************************************************/
+	// create the new file
+	core_file *file = NULL;
+	file_error filerr = core_fopen(filename, OPEN_FLAG_READ | OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &file);
+	if (filerr != FILERR_NONE)
+		return CHDERR_FILE_NOT_FOUND;
 
-/*-------------------------------------------------
-    chd_create_file - create a new CHD file
--------------------------------------------------*/
-
-chd_error chd_create_file(core_file *file, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 compression, chd_file *parent)
-{
-	chd_file *newchd = NULL;
-	chd_header header;
-	chd_error err;
-	int intfnum;
-
-	/* verify parameters */
-	if (file == NULL)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (parent == NULL && (logicalbytes == 0 || hunkbytes == 0))
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-
-	/* verify the compression type */
-	for (intfnum = 0; intfnum < ARRAY_LENGTH(codec_interfaces); intfnum++)
-		if (codec_interfaces[intfnum].compression == compression)
-			break;
-	if (intfnum == ARRAY_LENGTH(codec_interfaces))
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
+	// create the file normally, then claim the file
+	chd_error chderr = create(*file, logicalbytes, hunkbytes, compression, parent);
+	m_owns_file = true;
 
-	/* if we have a parent, the sizes come from there */
-	if (parent != NULL)
+	// if an error happened, close and delete the file
+	if (chderr != CHDERR_NONE)
 	{
-		logicalbytes = parent->header.logicalbytes;
-		hunkbytes = parent->header.hunkbytes;
+		core_fclose(file);
+		osd_rmfile(filename);
 	}
+	return chderr;
+}
 
-	/* if we have a parent, it must be V3 or later */
-	if (parent != NULL && parent->header.version < 3)
-		EARLY_EXIT(err = CHDERR_UNSUPPORTED_VERSION);
-
-	/* build the header */
-	memset(&header, 0, sizeof(header));
-	header.length = CHD_V4_HEADER_SIZE;
-	header.version = CHD_HEADER_VERSION;
-	header.flags = CHDFLAGS_IS_WRITEABLE;
-	header.compression = compression;
-	header.hunkbytes = hunkbytes;
-	header.totalhunks = (logicalbytes + hunkbytes - 1) / hunkbytes;
-	header.logicalbytes = logicalbytes;
-
-	/* tweaks if there is a parent */
-	if (parent != NULL)
-	{
-		header.flags |= CHDFLAGS_HAS_PARENT;
-		memcpy(&header.parentmd5[0], &parent->header.md5[0], sizeof(header.parentmd5));
-		memcpy(&header.parentsha1[0], &parent->header.sha1[0], sizeof(header.parentsha1));
-	}
 
-	/* validate it */
-	err = header_validate(&header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+//-------------------------------------------------
+//  open - open an existing file for read or
+//  read/write
+//-------------------------------------------------
+
+chd_error chd_file::open(const char *filename, bool writeable, chd_file *parent)
+{
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
 
-	/* write the resulting header */
-	err = header_write(file, &header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+	// open the file
+	UINT32 openflags = writeable ? (OPEN_FLAG_READ | OPEN_FLAG_WRITE) : OPEN_FLAG_READ;
+	core_file *file = NULL;
+	file_error filerr = core_fopen(filename, openflags, &file);
+	if (filerr != FILERR_NONE)
+		return CHDERR_FILE_NOT_FOUND;
 
-	/* create an initial map */
-	err = map_write_initial(file, parent, &header);
+	// now open the CHD
+	chd_error err = open(*file, writeable, parent);
 	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
-
-	/* if we have a parent, clone the metadata */
-	if (parent != NULL)
 	{
-		/* open the new CHD via the standard mechanism */
-		err = chd_open_file(file, CHD_OPEN_READWRITE, parent, &newchd);
-		if (err != CHDERR_NONE)
-			EARLY_EXIT(err);
-
-		/* close the metadata */
-		err = chd_clone_metadata(parent, newchd);
-		if (err != CHDERR_NONE)
-			EARLY_EXIT(err);
-
-		/* close the CHD */
-		chd_close(newchd);
+		core_fclose(file);
+		return err;
 	}
 
-	return CHDERR_NONE;
-
-cleanup:
-	if (newchd != NULL)
-		chd_close(newchd);
+	// we now own this file
+	m_owns_file = true;
 	return err;
 }
 
 
-/*-------------------------------------------------
-    chd_open_file - open a CHD file for access
--------------------------------------------------*/
-
-chd_error chd_open_file(core_file *file, int mode, chd_file *parent, chd_file **chd)
-{
-	chd_file *newchd = NULL;
-	chd_error err;
-	int intfnum;
-
-	/* verify parameters */
-	if (file == NULL)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-
-	/* punt if invalid parent */
-	if (parent != NULL && parent->cookie != COOKIE_VALUE)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-
-	/* allocate memory for the final result */
-	newchd = (chd_file *)malloc(sizeof(**chd));
-	if (newchd == NULL)
-		EARLY_EXIT(err = CHDERR_OUT_OF_MEMORY);
-	memset(newchd, 0, sizeof(*newchd));
-	newchd->cookie = COOKIE_VALUE;
-	newchd->parent = parent;
-	newchd->file = file;
+//-------------------------------------------------
+//  open - open an existing file for read or
+//  read/write
+//-------------------------------------------------
+
+chd_error chd_file::open(core_file &file, bool writeable, chd_file *parent)
+{
+	// make sure we don't already have a file open
+	if (m_file != NULL)
+		return CHDERR_ALREADY_OPEN;
+
+	// open the file
+	m_file = &file;
+	m_owns_file = false;
+	m_parent = parent;
+	return open_common(writeable);
+}
+
+
+//-------------------------------------------------
+//  close - close a CHD file for access
+//-------------------------------------------------
+
+void chd_file::close()
+{
+	// reset file characteristics
+	if (m_owns_file && m_file != NULL)
+		core_fclose(m_file);
+	m_file = NULL;
+	m_owns_file = false;
+	m_allow_reads = false;
+	m_allow_writes = false;
+
+	// reset core parameters from the header
+	m_version = HEADER_VERSION;
+	m_logicalbytes = 0;
+	m_mapoffset = 0;
+	m_metaoffset = 0;
+	m_hunkbytes = 0;
+	m_hunkcount = 0;
+	m_unitbytes = 0;
+	m_unitcount = 0;
+	memset(m_compression, 0, sizeof(m_compression));
+	m_parent = NULL;
+	m_parent_missing = false;
+
+	// reset key offsets within the header
+	m_mapoffset_offset = 0;
+	m_metaoffset_offset = 0;
+	m_sha1_offset = 0;
+	m_rawsha1_offset = 0;
+	m_parentsha1_offset = 0;
+
+	// reset map information
+	m_mapentrybytes = 0;
+	m_rawmap.reset();
+
+	// reset compression management
+	for (int decompnum = 0; decompnum < ARRAY_LENGTH(m_decompressor); decompnum++)
+	{
+		delete m_decompressor[decompnum];
+		m_decompressor[decompnum] = NULL;
+	}
+	m_compressed.reset();
+
+	// reset caching
+	m_cache.reset();
+	m_cachehunk = ~0;
+}
+
+
+//-------------------------------------------------
+//  read - read a single hunk from the CHD file
+//-------------------------------------------------
+
+chd_error chd_file::read_hunk(UINT32 hunknum, void *buffer)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// punt if no file
+		if (m_file == NULL)
+			throw CHDERR_NOT_OPEN;
+
+		// return an error if out of range
+		if (hunknum >= m_hunkcount)
+			throw CHDERR_HUNK_OUT_OF_RANGE;
+
+		// get a pointer to the map entry
+		UINT64 blockoffs;
+		UINT32 blocklen;
+		UINT32 blockcrc;
+		UINT8 *rawmap;
+		UINT8 *dest = reinterpret_cast<UINT8 *>(buffer);
+		switch (m_version)
+		{
+			// v3/v4 map entries
+			case 3:
+			case 4:
+				rawmap = m_rawmap + 16 * hunknum;
+				blockoffs = be_read(&rawmap[0], 8);
+				blockcrc = be_read(&rawmap[8], 4);
+				switch (rawmap[15] & V34_MAP_ENTRY_FLAG_TYPE_MASK)
+				{
+					case V34_MAP_ENTRY_TYPE_COMPRESSED:
+						blocklen = be_read(&rawmap[12], 2) + (rawmap[14] << 16);
+						file_read(blockoffs, m_compressed, blocklen);
+						m_decompressor[0]->decompress(m_compressed, blocklen, dest, m_hunkbytes);
+						if (!(rawmap[15] & V34_MAP_ENTRY_FLAG_NO_CRC) && dest != NULL && crc32_creator::simple(dest, m_hunkbytes) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						return CHDERR_NONE;
+
+					case V34_MAP_ENTRY_TYPE_UNCOMPRESSED:
+						file_read(blockoffs, dest, m_hunkbytes);
+						if (!(rawmap[15] & V34_MAP_ENTRY_FLAG_NO_CRC) && crc32_creator::simple(dest, m_hunkbytes) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						return CHDERR_NONE;
+
+					case V34_MAP_ENTRY_TYPE_MINI:
+						be_write(dest, blockoffs, 8);
+						for (UINT32 bytes = 8; bytes < m_hunkbytes; bytes++)
+							dest[bytes] = dest[bytes - 8];
+						if (!(rawmap[15] & V34_MAP_ENTRY_FLAG_NO_CRC) && crc32_creator::simple(dest, m_hunkbytes) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						return CHDERR_NONE;
+
+					case V34_MAP_ENTRY_TYPE_SELF_HUNK:
+						return read_hunk(blockoffs, dest);
+
+					case V34_MAP_ENTRY_TYPE_PARENT_HUNK:
+						if (m_parent_missing)
+							throw CHDERR_REQUIRES_PARENT;
+						return m_parent->read_hunk(blockoffs, dest);
+				}
+				break;
 
-	/* now attempt to read the header */
-	err = header_read(newchd->file, &newchd->header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+			// v5 map entries
+			case 5:
+				rawmap = m_rawmap + m_mapentrybytes * hunknum;
 
-	/* validate the header */
-	err = header_validate(&newchd->header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+				// uncompressed case
+				if (!compressed())
+				{
+					blockoffs = UINT64(be_read(rawmap, 4)) * UINT64(m_hunkbytes);
+					if (blockoffs != 0)
+						file_read(blockoffs, dest, m_hunkbytes);
+					else if (m_parent_missing)
+						throw CHDERR_REQUIRES_PARENT;
+					else if (m_parent != NULL)
+						m_parent->read_hunk(hunknum, dest);
+					else
+						memset(dest, 0, m_hunkbytes);
+					return CHDERR_NONE;
+				}
+
+				// compressed case
+				blocklen = be_read(&rawmap[1], 3);
+				blockoffs = be_read(&rawmap[4], 6);
+				blockcrc = be_read(&rawmap[10], 2);
+				switch (rawmap[0])
+				{
+					case COMPRESSION_TYPE_0:
+					case COMPRESSION_TYPE_1:
+					case COMPRESSION_TYPE_2:
+					case COMPRESSION_TYPE_3:
+						file_read(blockoffs, m_compressed, blocklen);
+						m_decompressor[rawmap[0]]->decompress(m_compressed, blocklen, dest, m_hunkbytes);
+						if (!m_decompressor[rawmap[0]]->lossy() && dest != NULL && crc16_creator::simple(dest, m_hunkbytes) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						if (m_decompressor[rawmap[0]]->lossy() && crc16_creator::simple(m_compressed, blocklen) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						return CHDERR_NONE;
+
+					case COMPRESSION_NONE:
+						file_read(blockoffs, dest, m_hunkbytes);
+						if (crc16_creator::simple(dest, m_hunkbytes) != blockcrc)
+							throw CHDERR_DECOMPRESSION_ERROR;
+						return CHDERR_NONE;
+
+					case COMPRESSION_SELF:
+						return read_hunk(blockoffs, dest);
+
+					case COMPRESSION_PARENT:
+						if (m_parent_missing)
+							throw CHDERR_REQUIRES_PARENT;
+						return m_parent->read_bytes(UINT64(blockoffs) * UINT64(m_parent->unit_bytes()), dest, m_hunkbytes);
+				}
+				break;
+		}
 
-	/* make sure we don't open a read-only file writeable */
-	if (mode == CHD_OPEN_READWRITE && !(newchd->header.flags & CHDFLAGS_IS_WRITEABLE))
-		EARLY_EXIT(err = CHDERR_FILE_NOT_WRITEABLE);
-
-	/* also, never open an older version writeable */
-	if (mode == CHD_OPEN_READWRITE && newchd->header.version < CHD_HEADER_VERSION)
-		EARLY_EXIT(err = CHDERR_UNSUPPORTED_VERSION);
-
-	/* if we need a parent, make sure we have one */
-	if (parent == NULL && (newchd->header.flags & CHDFLAGS_HAS_PARENT))
-		EARLY_EXIT(err = CHDERR_REQUIRES_PARENT);
-
-	/* make sure we have a valid parent */
-	if (parent != NULL)
-	{
-		/* check MD5 if it isn't empty */
-		if (memcmp(nullmd5, newchd->header.parentmd5, sizeof(newchd->header.parentmd5)) != 0 &&
-			memcmp(nullmd5, newchd->parent->header.md5, sizeof(newchd->parent->header.md5)) != 0 &&
-			memcmp(newchd->parent->header.md5, newchd->header.parentmd5, sizeof(newchd->header.parentmd5)) != 0)
-			EARLY_EXIT(err = CHDERR_INVALID_PARENT);
-
-		/* check SHA1 if it isn't empty */
-		if (memcmp(nullsha1, newchd->header.parentsha1, sizeof(newchd->header.parentsha1)) != 0 &&
-			memcmp(nullsha1, newchd->parent->header.sha1, sizeof(newchd->parent->header.sha1)) != 0 &&
-			memcmp(newchd->parent->header.sha1, newchd->header.parentsha1, sizeof(newchd->header.parentsha1)) != 0)
-			EARLY_EXIT(err = CHDERR_INVALID_PARENT);
+		// if we get here, something was wrong
+		throw CHDERR_READ_ERROR;
 	}
 
-	/* now read the hunk map */
-	err = map_read(newchd);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+	// just return errors
+	catch (chd_error &err)
+	{
+		return err;
+	}
+}
 
-	/* allocate and init the hunk cache */
-	newchd->cache = (UINT8 *)malloc(newchd->header.hunkbytes);
-	newchd->compare = (UINT8 *)malloc(newchd->header.hunkbytes);
-	if (newchd->cache == NULL || newchd->compare == NULL)
-		EARLY_EXIT(err = CHDERR_OUT_OF_MEMORY);
-	newchd->cachehunk = ~0;
-	newchd->comparehunk = ~0;
-
-	/* allocate the temporary compressed buffer */
-	newchd->compressed = (UINT8 *)malloc(newchd->header.hunkbytes);
-	if (newchd->compressed == NULL)
-		EARLY_EXIT(err = CHDERR_OUT_OF_MEMORY);
-
-	/* find the codec interface */
-	for (intfnum = 0; intfnum < ARRAY_LENGTH(codec_interfaces); intfnum++)
-		if (codec_interfaces[intfnum].compression == newchd->header.compression)
-		{
-			newchd->codecintf = &codec_interfaces[intfnum];
-			break;
-		}
-	if (intfnum == ARRAY_LENGTH(codec_interfaces))
-		EARLY_EXIT(err = CHDERR_UNSUPPORTED_FORMAT);
 
-	/* initialize the codec */
-	if (newchd->codecintf->init != NULL)
-		err = (*newchd->codecintf->init)(newchd);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
+//-------------------------------------------------
+//  write - write a single hunk to the CHD file
+//-------------------------------------------------
+
+chd_error chd_file::write_hunk(UINT32 hunknum, const void *buffer)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// punt if no file
+		if (m_file == NULL)
+			throw CHDERR_NOT_OPEN;
+
+		// return an error if out of range
+		if (hunknum >= m_hunkcount)
+			throw CHDERR_HUNK_OUT_OF_RANGE;
+
+		// if not writeable, fail
+		if (!m_allow_writes)
+			throw CHDERR_FILE_NOT_WRITEABLE;
+
+		// uncompressed writes only via this interface
+		if (compressed())
+			throw CHDERR_FILE_NOT_WRITEABLE;
+
+		// see if we have allocated the space on disk for this hunk
+		UINT8 *rawmap = m_rawmap + hunknum * 4;
+		UINT32 rawentry = be_read(rawmap, 4);
+
+		// if not, allocate one now
+		if (rawentry == 0)
+		{
+			// first make sure we need to allocate it
+			bool all_zeros = true;
+			const UINT32 *scan = reinterpret_cast<const UINT32 *>(buffer);
+			for (UINT32 index = 0; index < m_hunkbytes / 4; index++)
+				if (scan[index] != 0)
+				{
+					all_zeros = false;
+					break;
+				}
 
-	/* all done */
-	*chd = newchd;
-	return CHDERR_NONE;
+			// if it's all zeros, do nothing more
+			if (all_zeros)
+				return CHDERR_NONE;
 
-cleanup:
-	if (newchd != NULL)
-		chd_close(newchd);
-	return err;
-}
+			// append new data to the end of the file, aligning the first chunk
+			rawentry = file_append(buffer, m_hunkbytes, m_hunkbytes) / m_hunkbytes;
 
+			// write the map entry back
+			be_write(rawmap, rawentry, 4);
+			file_write(m_mapoffset + hunknum * 4, rawmap, 4);
 
-/*-------------------------------------------------
-    chd_create - create a CHD file by
-    filename
--------------------------------------------------*/
+			// update the cached hunk if we just wrote it
+			if (hunknum == m_cachehunk && buffer != m_cache)
+				memcpy(m_cache, buffer, m_hunkbytes);
+		}
 
-chd_error chd_create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 compression, chd_file *parent)
-{
-	core_file *file = NULL;
-	file_error filerr;
-	chd_error chderr;
+		// otherwise, just overwrite
+		else
+			file_write(UINT64(rawentry) * UINT64(m_hunkbytes), buffer, m_hunkbytes);
+		return CHDERR_NONE;
+	}
 
-	filerr = core_fopen(filename, OPEN_FLAG_READ | OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &file);
-	if (filerr != FILERR_NONE)
+	// just return errors
+	catch (chd_error &err)
 	{
-		chderr = CHDERR_FILE_NOT_FOUND;
-		goto cleanup;
+		return err;
 	}
+}
 
-	chderr = chd_create_file(file, logicalbytes, hunkbytes, compression, parent);
-	if (chderr != CHDERR_NONE)
-		goto cleanup;
 
-cleanup:
-	if (file != NULL)
-		core_fclose(file);
-	return chderr;
+//-------------------------------------------------
+//  read_units - read the given number of units
+//  from the CHD
+//-------------------------------------------------
+
+chd_error chd_file::read_units(UINT64 unitnum, void *buffer, UINT32 count)
+{
+	return read_bytes(unitnum * UINT64(m_unitbytes), buffer, count * m_unitbytes);
 }
 
 
-/*-------------------------------------------------
-    chd_open - open a CHD file by
-    filename
--------------------------------------------------*/
+//-------------------------------------------------
+//  write_units - write the given number of units
+//  to the CHD
+//-------------------------------------------------
 
-chd_error chd_open(const char *filename, int mode, chd_file *parent, chd_file **chd)
+chd_error chd_file::write_units(UINT64 unitnum, const void *buffer, UINT32 count)
 {
-	chd_error err;
-	file_error filerr;
-	core_file *file = NULL;
-	UINT32 openflags;
-
-	/* choose the proper mode */
-	switch(mode)
-	{
-		case CHD_OPEN_READ:
-			openflags = OPEN_FLAG_READ;
-			break;
+	return write_bytes(unitnum * UINT64(m_unitbytes), buffer, count * m_unitbytes);
+}
 
-		case CHD_OPEN_READWRITE:
-			openflags = OPEN_FLAG_READ | OPEN_FLAG_WRITE;
-			break;
 
-		default:
-			err = CHDERR_INVALID_PARAMETER;
-			goto cleanup;
-	}
+//-------------------------------------------------
+//  read_bytes - read from the CHD at a byte level,
+//  using the cache to handle partial hunks
+//-------------------------------------------------
 
-	/* open the file */
-	filerr = core_fopen(filename, openflags, &file);
-	if (filerr != FILERR_NONE)
+chd_error chd_file::read_bytes(UINT64 offset, void *buffer, UINT32 bytes)
+{
+	// iterate over hunks
+	UINT32 first_hunk = offset / m_hunkbytes;
+	UINT32 last_hunk = (offset + bytes - 1) / m_hunkbytes;
+	UINT8 *dest = reinterpret_cast<UINT8 *>(buffer);
+	for (UINT32 curhunk = first_hunk; curhunk <= last_hunk; curhunk++)
 	{
-		err = CHDERR_FILE_NOT_FOUND;
-		goto cleanup;
-	}
+		// determine start/end boundaries
+		UINT32 startoffs = (curhunk == first_hunk) ? (offset % m_hunkbytes) : 0;
+		UINT32 endoffs = (curhunk == last_hunk) ? ((offset + bytes - 1) % m_hunkbytes) : (m_hunkbytes - 1);
 
-	/* now open the CHD */
-	err = chd_open_file(file, mode, parent, chd);
-	if (err != CHDERR_NONE)
-		goto cleanup;
+		// if it's a full block, just read directly from disk unless it's the cached hunk
+		chd_error err = CHDERR_NONE;
+		if (startoffs == 0 && endoffs == m_hunkbytes - 1 && curhunk != m_cachehunk)
+			err = read_hunk(curhunk, dest);
 
-	/* we now own this file */
-	(*chd)->owns_file = TRUE;
+		// otherwise, read from the cache
+		else
+		{
+			if (curhunk != m_cachehunk)
+			{
+				err = read_hunk(curhunk, m_cache);
+				if (err != CHDERR_NONE)
+					return err;
+				m_cachehunk = curhunk;
+			}
+			memcpy(dest, &m_cache[startoffs], endoffs + 1 - startoffs);
+		}
 
-cleanup:
-	if ((err != CHDERR_NONE) && (file != NULL))
-		core_fclose(file);
-	return err;
+		// handle errors and advance
+		if (err != CHDERR_NONE)
+			return err;
+		dest += endoffs + 1 - startoffs;
+	}
+	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    chd_close - close a CHD file for access
--------------------------------------------------*/
+//-------------------------------------------------
+//  write_bytes - write to the CHD at a byte level,
+//  using the cache to handle partial hunks
+//-------------------------------------------------
 
-void chd_close(chd_file *chd)
+chd_error chd_file::write_bytes(UINT64 offset, const void *buffer, UINT32 bytes)
 {
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
+	// iterate over hunks
+	UINT32 first_hunk = offset / m_hunkbytes;
+	UINT32 last_hunk = (offset + bytes - 1) / m_hunkbytes;
+	const UINT8 *source = reinterpret_cast<const UINT8 *>(buffer);
+	for (UINT32 curhunk = first_hunk; curhunk <= last_hunk; curhunk++)
+	{
+		// determine start/end boundaries
+		UINT32 startoffs = (curhunk == first_hunk) ? (offset % m_hunkbytes) : 0;
+		UINT32 endoffs = (curhunk == last_hunk) ? ((offset + bytes - 1) % m_hunkbytes) : (m_hunkbytes - 1);
 
-	/* kill the work queue and any work item */
-	if (chd->workitem != NULL)
-		osd_work_item_release(chd->workitem);
-	if (chd->workqueue != NULL)
-		osd_work_queue_free(chd->workqueue);
+		// if it's a full block, just write directly to disk unless it's the cached hunk
+		chd_error err = CHDERR_NONE;
+		if (startoffs == 0 && endoffs == m_hunkbytes - 1 && curhunk != m_cachehunk)
+			err = write_hunk(curhunk, source);
 
-	/* deinit the codec */
-	if (chd->codecintf != NULL && chd->codecintf->free != NULL)
-		(*chd->codecintf->free)(chd);
+		// otherwise, write from the cache
+		else
+		{
+			if (curhunk != m_cachehunk)
+			{
+				err = read_hunk(curhunk, m_cache);
+				if (err != CHDERR_NONE)
+					return err;
+				m_cachehunk = curhunk;
+			}
+			memcpy(&m_cache[startoffs], source, endoffs + 1 - startoffs);
+			err = write_hunk(curhunk, m_cache);
+		}
 
-	/* free the compressed data buffer */
-	if (chd->compressed != NULL)
-		free(chd->compressed);
+		// handle errors and advance
+		if (err != CHDERR_NONE)
+			return err;
+		source += endoffs + 1 - startoffs;
+	}
+	return CHDERR_NONE;
+}
 
-	/* free the hunk cache and compare data */
-	if (chd->compare != NULL)
-		free(chd->compare);
-	if (chd->cache != NULL)
-		free(chd->cache);
 
-	/* free the hunk map */
-	if (chd->map != NULL)
-		free(chd->map);
+//-------------------------------------------------
+//  read_metadata - read the indexed metadata
+//  of the given type
+//-------------------------------------------------
 
-	/* free the CRC table */
-	if (chd->crctable != NULL)
-		free(chd->crctable);
+chd_error chd_file::read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, astring &output)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// if we didn't find it, just return
+		metadata_entry metaentry;
+		if (!metadata_find(searchtag, searchindex, metaentry))
+			throw CHDERR_METADATA_NOT_FOUND;
 
-	/* free the CRC map */
-	if (chd->crcmap != NULL)
-		free(chd->crcmap);
+		// read the metadata
+		file_read(metaentry.offset + METADATA_HEADER_SIZE, output.stringbuffer(metaentry.length), metaentry.length);
+		return CHDERR_NONE;
+	}
 
-	/* close the file */
-	if (chd->owns_file && chd->file != NULL)
-		core_fclose(chd->file);
+	// just return errors
+	catch (chd_error &err)
+	{
+		return err;
+	}
+}
 
-	if (PRINTF_MAX_HUNK) printf("Max hunk = %d/%d\n", chd->maxhunk, chd->header.totalhunks);
+chd_error chd_file::read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, dynamic_buffer &output)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// if we didn't find it, just return
+		metadata_entry metaentry;
+		if (!metadata_find(searchtag, searchindex, metaentry))
+			throw CHDERR_METADATA_NOT_FOUND;
+
+		// read the metadata
+		output.resize(metaentry.length);
+		file_read(metaentry.offset + METADATA_HEADER_SIZE, output, metaentry.length);
+		return CHDERR_NONE;
+	}
 
-	/* free our memory */
-	free(chd);
+	// just return errors
+	catch (chd_error &err)
+	{
+		return err;
+	}
 }
 
+chd_error chd_file::read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, void *output, UINT32 outputlen, UINT32 &resultlen)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// if we didn't find it, just return
+		metadata_entry metaentry;
+		if (!metadata_find(searchtag, searchindex, metaentry))
+			throw CHDERR_METADATA_NOT_FOUND;
+
+		// read the metadata
+		resultlen = metaentry.length;
+		file_read(metaentry.offset + METADATA_HEADER_SIZE, output, MIN(outputlen, resultlen));
+		return CHDERR_NONE;
+	}
 
-/*-------------------------------------------------
-    chd_core_file - return the associated
-    core_file
--------------------------------------------------*/
+	// just return errors
+	catch (chd_error &err)
+	{
+		return err;
+	}
+}
 
-core_file *chd_core_file(chd_file *chd)
+chd_error chd_file::read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, dynamic_buffer &output, chd_metadata_tag &resulttag, UINT8 &resultflags)
 {
-	return chd->file;
+	// wrap this for clean reporting
+	try
+	{
+		// if we didn't find it, just return
+		metadata_entry metaentry;
+		if (!metadata_find(searchtag, searchindex, metaentry))
+			throw CHDERR_METADATA_NOT_FOUND;
+
+		// read the metadata
+		output.resize(metaentry.length);
+		file_read(metaentry.offset + METADATA_HEADER_SIZE, output, metaentry.length);
+		resulttag = metaentry.metatag;
+		resultflags = metaentry.flags;
+		return CHDERR_NONE;
+	}
+
+	// just return errors
+	catch (chd_error &err)
+	{
+		return err;
+	}
 }
 
 
-/*-------------------------------------------------
-    chd_error_string - return an error string for
-    the given CHD error
--------------------------------------------------*/
+//-------------------------------------------------
+//  write_metadata - write the indexed metadata
+//  of the given type
+//-------------------------------------------------
+
+chd_error chd_file::write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const void *inputbuf, UINT32 inputlen, UINT8 flags)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// must write at least 1 byte and no more than 16MB
+		if (inputlen < 1 || inputlen >= 16 * 1024 * 1024)
+			return CHDERR_INVALID_PARAMETER;
+
+		// find the entry if it already exists
+		metadata_entry metaentry;
+		bool finished = false;
+		if (metadata_find(metatag, metaindex, metaentry))
+		{
+			// if the new data fits over the old data, just overwrite
+			if (inputlen <= metaentry.length)
+			{
+				file_write(metaentry.offset + METADATA_HEADER_SIZE, inputbuf, inputlen);
 
-const char *chd_error_string(chd_error err)
-{
-	switch (err)
-	{
-		case CHDERR_NONE:						return "no error";
-		case CHDERR_NO_INTERFACE:				return "no drive interface";
-		case CHDERR_OUT_OF_MEMORY:				return "out of memory";
-		case CHDERR_INVALID_FILE:				return "invalid file";
-		case CHDERR_INVALID_PARAMETER:			return "invalid parameter";
-		case CHDERR_INVALID_DATA:				return "invalid data";
-		case CHDERR_FILE_NOT_FOUND:				return "file not found";
-		case CHDERR_REQUIRES_PARENT:			return "requires parent";
-		case CHDERR_FILE_NOT_WRITEABLE:			return "file not writeable";
-		case CHDERR_READ_ERROR:					return "read error";
-		case CHDERR_WRITE_ERROR:				return "write error";
-		case CHDERR_CODEC_ERROR:				return "codec error";
-		case CHDERR_INVALID_PARENT:				return "invalid parent";
-		case CHDERR_HUNK_OUT_OF_RANGE:			return "hunk out of range";
-		case CHDERR_DECOMPRESSION_ERROR:		return "decompression error";
-		case CHDERR_COMPRESSION_ERROR:			return "compression error";
-		case CHDERR_CANT_CREATE_FILE:			return "can't create file";
-		case CHDERR_CANT_VERIFY:				return "can't verify file";
-		case CHDERR_NOT_SUPPORTED:				return "operation not supported";
-		case CHDERR_METADATA_NOT_FOUND:			return "can't find metadata";
-		case CHDERR_INVALID_METADATA_SIZE:		return "invalid metadata size";
-		case CHDERR_UNSUPPORTED_VERSION:		return "unsupported CHD version";
-		case CHDERR_VERIFY_INCOMPLETE:			return "incomplete verify";
-		case CHDERR_INVALID_METADATA:			return "invalid metadata";
-		case CHDERR_INVALID_STATE:				return "invalid state";
-		case CHDERR_OPERATION_PENDING:			return "operation pending";
-		case CHDERR_NO_ASYNC_OPERATION:			return "no async operation in progress";
-		case CHDERR_UNSUPPORTED_FORMAT:			return "unsupported format";
-		default:								return "undocumented error";
-	}
-}
-
-
-
-/***************************************************************************
-    CHD HEADER MANAGEMENT
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_get_header - return a pointer to the
-    extracted header data
--------------------------------------------------*/
-
-const chd_header *chd_get_header(chd_file *chd)
-{
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return NULL;
-
-	return &chd->header;
-}
-
-
-/*-------------------------------------------------
-    chd_set_header_file - write the current header to
-    the file
--------------------------------------------------*/
-
-chd_error chd_set_header_file(core_file *file, const chd_header *header)
-{
-	chd_header oldheader;
-	chd_error err;
-
-	/* validate the header */
-	err = header_validate(header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
-
-	/* read the old header */
-	err = header_read(file, &oldheader);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
-
-	/* make sure we're only making valid changes */
-	if (header->length != oldheader.length)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->version != oldheader.version)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->compression != oldheader.compression)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->hunkbytes != oldheader.hunkbytes)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->totalhunks != oldheader.totalhunks)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->metaoffset != oldheader.metaoffset)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-	if (header->obsolete_hunksize != oldheader.obsolete_hunksize)
-		EARLY_EXIT(err = CHDERR_INVALID_PARAMETER);
-
-	/* write the new header */
-	err = header_write(file, header);
-	if (err != CHDERR_NONE)
-		EARLY_EXIT(err);
-
-	return CHDERR_NONE;
-
-cleanup:
-	return err;
-}
-
-
-/*-------------------------------------------------
-    chd_set_header - write the current
-    header to the file
--------------------------------------------------*/
-
-chd_error chd_set_header(const char *filename, const chd_header *header)
-{
-	core_file *file = NULL;
-	file_error filerr;
-	chd_error err;
-
-	filerr = core_fopen(filename, OPEN_FLAG_READ | OPEN_FLAG_WRITE, &file);
-	if (filerr != FILERR_NONE)
-	{
-		err = CHDERR_FILE_NOT_FOUND;
-		goto cleanup;
-	}
-
-	err = chd_set_header_file(file, header);
-	if (err != CHDERR_NONE)
-		goto cleanup;
-
-cleanup:
-	if (file != NULL)
-		core_fclose(file);
-	return err;
-}
-
-
-
-/***************************************************************************
-    CORE DATA READ/WRITE
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_read - read a single hunk from the CHD
-    file
--------------------------------------------------*/
-
-chd_error chd_read(chd_file *chd, UINT32 hunknum, void *buffer)
-{
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're past the end, fail */
-	if (hunknum >= chd->header.totalhunks)
-		return CHDERR_HUNK_OUT_OF_RANGE;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* perform the read */
-	return hunk_read_into_memory(chd, hunknum, (UINT8 *)buffer);
-}
-
-
-/*-------------------------------------------------
-    chd_read_async - read a single hunk from the
-    CHD file asynchronously
--------------------------------------------------*/
-
-chd_error chd_read_async(chd_file *chd, UINT32 hunknum, void *buffer)
-{
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're past the end, fail */
-	if (hunknum >= chd->header.totalhunks)
-		return CHDERR_HUNK_OUT_OF_RANGE;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* set the async parameters */
-	chd->async_hunknum = hunknum;
-	chd->async_buffer = buffer;
-
-	/* queue the work item */
-	if (queue_async_operation(chd, async_read_callback))
-		return CHDERR_OPERATION_PENDING;
-
-	/* if we fail, fall back on the sync version */
-	return chd_read(chd, hunknum, buffer);
-}
-
-
-/*-------------------------------------------------
-    chd_write - write a single hunk to the CHD
-    file
--------------------------------------------------*/
-
-chd_error chd_write(chd_file *chd, UINT32 hunknum, const void *buffer)
-{
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're past the end, fail */
-	if (hunknum >= chd->header.totalhunks)
-		return CHDERR_HUNK_OUT_OF_RANGE;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* then write out the hunk */
-	return hunk_write_from_memory(chd, hunknum, (const UINT8 *)buffer);
-}
-
-
-/*-------------------------------------------------
-    chd_write_async - write a single hunk to the
-    CHD file asynchronously
--------------------------------------------------*/
-
-chd_error chd_write_async(chd_file *chd, UINT32 hunknum, const void *buffer)
-{
-	/* punt if NULL or invalid */
-	if (chd == NULL || chd->cookie != COOKIE_VALUE)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're past the end, fail */
-	if (hunknum >= chd->header.totalhunks)
-		return CHDERR_HUNK_OUT_OF_RANGE;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* set the async parameters */
-	chd->async_hunknum = hunknum;
-	chd->async_buffer = (void *)buffer;
-
-	/* queue the work item */
-	if (queue_async_operation(chd, async_write_callback))
-		return CHDERR_OPERATION_PENDING;
-
-	/* if we fail, fall back on the sync version */
-	return chd_write(chd, hunknum, buffer);
-}
-
-
-/*-------------------------------------------------
-    chd_async_complete - get the result of a
-    completed work item and clear it out of the
-    system
--------------------------------------------------*/
-
-chd_error chd_async_complete(chd_file *chd)
-{
-	void *result;
-
-	/* if nothing present, return an error */
-	if (chd->workitem == NULL)
-		return CHDERR_NO_ASYNC_OPERATION;
-
-	/* wait for the work to complete */
-	wait_for_pending_async(chd);
-
-	/* get the result and free the work item */
-	result = osd_work_item_result(chd->workitem);
-	osd_work_item_release(chd->workitem);
-	chd->workitem = NULL;
-
-	return (chd_error)(ptrdiff_t)result;
-}
-
-
-
-/***************************************************************************
-    METADATA MANAGEMENT
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_get_metadata - get the indexed metadata
-    of the given type
--------------------------------------------------*/
-
-chd_error chd_get_metadata(chd_file *chd, UINT32 searchtag, UINT32 searchindex, void *output, UINT32 outputlen, UINT32 *resultlen, UINT32 *resulttag, UINT8 *resultflags)
-{
-	metadata_entry metaentry;
-	chd_error err;
-	UINT32 count;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* if we didn't find it, just return */
-	err = metadata_find_entry(chd, searchtag, searchindex, &metaentry);
-	if (err != CHDERR_NONE)
-	{
-		/* unless we're an old version and they are requesting hard disk metadata */
-		if (chd->header.version < 3 && (searchtag == HARD_DISK_METADATA_TAG || searchtag == CHDMETATAG_WILDCARD) && searchindex == 0)
-		{
-			char faux_metadata[256];
-			UINT32 faux_length;
-
-			/* fill in the faux metadata */
-			sprintf(faux_metadata, HARD_DISK_METADATA_FORMAT, chd->header.obsolete_cylinders, chd->header.obsolete_heads, chd->header.obsolete_sectors, chd->header.hunkbytes / chd->header.obsolete_hunksize);
-			faux_length = (UINT32)strlen(faux_metadata) + 1;
-
-			/* copy the metadata itself */
-			memcpy(output, faux_metadata, MIN(outputlen, faux_length));
-
-			/* return the length of the data and the tag */
-			if (resultlen != NULL)
-				*resultlen = faux_length;
-			if (resulttag != NULL)
-				*resulttag = HARD_DISK_METADATA_TAG;
-			return CHDERR_NONE;
-		}
-		return err;
-	}
-
-	/* read the metadata */
-	outputlen = MIN(outputlen, metaentry.length);
-	core_fseek(chd->file, metaentry.offset + METADATA_HEADER_SIZE, SEEK_SET);
-	count = core_fread(chd->file, output, outputlen);
-	if (count != outputlen)
-		return CHDERR_READ_ERROR;
-
-	/* return the length of the data and the tag */
-	if (resultlen != NULL)
-		*resultlen = metaentry.length;
-	if (resulttag != NULL)
-		*resulttag = metaentry.metatag;
-	if (resultflags != NULL)
-		*resultflags = metaentry.flags;
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    chd_set_metadata - write the indexed metadata
-    of the given type
--------------------------------------------------*/
-
-chd_error chd_set_metadata(chd_file *chd, UINT32 metatag, UINT32 metaindex, const void *inputbuf, UINT32 inputlen, UINT8 flags)
-{
-	UINT8 raw_meta_header[METADATA_HEADER_SIZE];
-	metadata_entry metaentry = { 0 };
-	chd_error err;
-	UINT64 offset;
-	UINT32 count;
-
-	/* if the disk is an old version, punt */
-	if (chd->header.version < 3)
-		return CHDERR_NOT_SUPPORTED;
-
-	/* if the disk isn't writeable, punt */
-	if (!(chd->header.flags & CHDFLAGS_IS_WRITEABLE))
-		return CHDERR_FILE_NOT_WRITEABLE;
-
-	/* must write at least 1 byte */
-	if (inputlen < 1)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* no more than 16MB */
-	if (inputlen >= 16 * 1024 * 1024)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* find the entry if it already exists */
-	err = metadata_find_entry(chd, metatag, metaindex, &metaentry);
-
-	/* if it's there and it fits, just overwrite */
-	if (err == CHDERR_NONE && inputlen <= metaentry.length)
-	{
-		/* overwrite the original data with our new input data */
-		core_fseek(chd->file, metaentry.offset + METADATA_HEADER_SIZE, SEEK_SET);
-		count = core_fwrite(chd->file, inputbuf, inputlen);
-		if (count != inputlen)
-		{
-			err = CHDERR_WRITE_ERROR;
-			goto update;
-		}
-
-		/* if the lengths don't match, we need to update the length in our header */
-		if (inputlen != metaentry.length)
-			err = metadata_set_length(chd, metaentry.offset, inputlen);
-		goto update;
-	}
-
-	/* if we already have an entry, unlink it */
-	if (err == CHDERR_NONE)
-	{
-		err = metadata_set_previous_next(chd, metaentry.prev, metaentry.next);
-		if (err != CHDERR_NONE)
-			goto update;
-	}
-
-	/* now build us a new entry */
-	put_bigendian_uint32(&raw_meta_header[0], metatag);
-	put_bigendian_uint32(&raw_meta_header[4], (inputlen & 0x00ffffff) | (flags << 24));
-	put_bigendian_uint64(&raw_meta_header[8], (err == CHDERR_NONE) ? metaentry.next : 0);
-
-	/* write out the new header */
-	offset = core_fsize(chd->file);
-	core_fseek(chd->file, offset, SEEK_SET);
-	count = core_fwrite(chd->file, raw_meta_header, sizeof(raw_meta_header));
-	if (count != sizeof(raw_meta_header))
-	{
-		err = CHDERR_WRITE_ERROR;
-		goto update;
-	}
-
-	/* follow that with the data */
-	core_fseek(chd->file, offset + METADATA_HEADER_SIZE, SEEK_SET);
-	count = core_fwrite(chd->file, inputbuf, inputlen);
-	if (count != inputlen)
-	{
-		err = CHDERR_WRITE_ERROR;
-		goto update;
-	}
-
-	/* set the previous entry to point to us */
-	err = metadata_set_previous_next(chd, metaentry.prev, offset);
-
-update:
-	/* update the hash */
-	if (metadata_compute_hash(chd, chd->header.rawsha1, chd->header.sha1) == CHDERR_NONE)
-		err = header_write(chd->file, &chd->header);
-	return err;
-}
-
-
-/*-------------------------------------------------
-    chd_clone_metadata - clone the metadata from
-    one CHD to a second
--------------------------------------------------*/
-
-chd_error chd_clone_metadata(chd_file *source, chd_file *dest)
-{
-	UINT32 metatag, metasize, metaindex;
-	UINT8 metabuffer[1024];
-	UINT8 metaflags;
-	chd_error err;
-
-	/* clone the metadata */
-	for (metaindex = 0; ; metaindex++)
-	{
-		/* fetch the next piece of metadata */
-		err = chd_get_metadata(source, CHDMETATAG_WILDCARD, metaindex, metabuffer, sizeof(metabuffer), &metasize, &metatag, &metaflags);
-		if (err != CHDERR_NONE)
-		{
-			if (err == CHDERR_METADATA_NOT_FOUND)
-				err = CHDERR_NONE;
-			break;
-		}
-
-		/* if that fit, just write it back from the temporary buffer */
-		if (metasize <= sizeof(metabuffer))
-		{
-			/* write it to the target */
-			err = chd_set_metadata(dest, metatag, CHD_METAINDEX_APPEND, metabuffer, metasize, metaflags);
-			if (err != CHDERR_NONE)
-				break;
-		}
-
-		/* otherwise, allocate a bigger temporary buffer */
-		else
-		{
-			UINT8 *allocbuffer = (UINT8 *)malloc(metasize);
-			if (allocbuffer == NULL)
-			{
-				err = CHDERR_OUT_OF_MEMORY;
-				break;
-			}
-
-			/* re-read the whole thing */
-			err = chd_get_metadata(source, CHDMETATAG_WILDCARD, metaindex, allocbuffer, metasize, &metasize, &metatag, &metaflags);
-			if (err != CHDERR_NONE)
-			{
-				free(allocbuffer);
-				break;
-			}
-
-			/* write it to the target */
-			err = chd_set_metadata(dest, metatag, CHD_METAINDEX_APPEND, allocbuffer, metasize, metaflags);
-			free(allocbuffer);
-			if (err != CHDERR_NONE)
-				break;
-		}
-	}
-	return err;
-}
-
-
-
-/***************************************************************************
-    COMPRESSION MANAGEMENT
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_compress_begin - begin compressing data
-    into a CHD
--------------------------------------------------*/
-
-chd_error chd_compress_begin(chd_file *chd)
-{
-	chd_error err;
-
-	/* verify parameters */
-	if (chd == NULL)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* mark the CHD writeable and write the updated header */
-	chd->header.flags |= CHDFLAGS_IS_WRITEABLE;
-	err = header_write(chd->file, &chd->header);
-	if (err != CHDERR_NONE)
-		return err;
-
-	/* create CRC maps for the new CHD and the parent */
-	crcmap_init(chd, FALSE);
-	if (chd->parent != NULL)
-		crcmap_init(chd->parent, TRUE);
-
-	/* init the MD5/SHA1 computations */
-	MD5Init(&chd->compmd5);
-	sha1_init(&chd->compsha1);
-	chd->compressing = TRUE;
-	chd->comphunk = 0;
-
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    chd_compress_hunk - append data to a CHD
-    that is being compressed
--------------------------------------------------*/
-
-chd_error chd_compress_hunk(chd_file *chd, const void *data, double *curratio, int is_half_hunk)
-{
-	UINT32 thishunk = chd->comphunk++;
-	UINT64 sourceoffset = (UINT64)thishunk * (UINT64)chd->header.hunkbytes;
-	UINT32 bytestochecksum;
-	const void *crcdata;
-	chd_error err;
-
-	/* error if in the wrong state */
-	if (!chd->compressing)
-		return CHDERR_INVALID_STATE;
-
-	/* write out the hunk */
-	err = hunk_write_from_memory(chd, thishunk, (const UINT8 *)data, is_half_hunk);
-	if (err != CHDERR_NONE)
-		return err;
-
-	/* if we are lossy, then we need to use the decompressed version in */
-	/* the cache as our MD5/SHA1 source */
-	crcdata = (chd->codecintf->lossy || data == NULL) ? chd->cache : data;
-
-	/* update the MD5/SHA1 */
-	bytestochecksum = chd->header.hunkbytes;
-
-	if (is_half_hunk)
-	{
-		bytestochecksum = bytestochecksum/2;
-	}
-
-	if (sourceoffset + chd->header.hunkbytes > chd->header.logicalbytes)
-	{
-		if (sourceoffset >= chd->header.logicalbytes)
-			bytestochecksum = 0;
-		else
-			bytestochecksum = chd->header.logicalbytes - sourceoffset;
-	}
-	if (bytestochecksum > 0)
-	{
-		MD5Update(&chd->compmd5, (const unsigned char *)crcdata, bytestochecksum);
-		sha1_update(&chd->compsha1, bytestochecksum, (const UINT8 *)crcdata);
-	}
-
-	/* update our CRC map */
-	if ((chd->map[thishunk].flags & MAP_ENTRY_FLAG_TYPE_MASK) != MAP_ENTRY_TYPE_SELF_HUNK &&
-		(chd->map[thishunk].flags & MAP_ENTRY_FLAG_TYPE_MASK) != MAP_ENTRY_TYPE_PARENT_HUNK)
-		crcmap_add_entry(chd, thishunk);
-
-	/* update the ratio */
-	if (curratio != NULL)
-	{
-		UINT64 curlength = core_fsize(chd->file);
-		*curratio = 1.0 - (double)curlength / (double)((UINT64)chd->comphunk * (UINT64)chd->header.hunkbytes);
-	}
-
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    chd_compress_finish - complete compression of
-    a CHD
--------------------------------------------------*/
-
-chd_error chd_compress_finish(chd_file *chd, int write_protect)
-{
-	/* error if in the wrong state */
-	if (!chd->compressing)
-		return CHDERR_INVALID_STATE;
-
-	/* compute the final MD5/SHA1 values */
-	MD5Final(chd->header.md5, &chd->compmd5);
-	sha1_final(&chd->compsha1);
-	sha1_digest(&chd->compsha1, SHA1_DIGEST_SIZE, chd->header.rawsha1);
-	metadata_compute_hash(chd, chd->header.rawsha1, chd->header.sha1);
-
-	/* turn off the writeable flag and re-write the header */
-	if (chd->header.compression != CHDCOMPRESSION_NONE || write_protect)
-		chd->header.flags &= ~CHDFLAGS_IS_WRITEABLE;
-	chd->compressing = FALSE;
-	return header_write(chd->file, &chd->header);
-}
-
-
-
-/***************************************************************************
-    VERIFICATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_verify_begin - begin compressing data
-    into a CHD
--------------------------------------------------*/
-
-chd_error chd_verify_begin(chd_file *chd)
-{
-	/* verify parameters */
-	if (chd == NULL)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if this is a writeable file image, we can't verify */
-	if (chd->header.flags & CHDFLAGS_IS_WRITEABLE)
-		return CHDERR_CANT_VERIFY;
-
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* init the MD5/SHA1 computations */
-	MD5Init(&chd->vermd5);
-	sha1_init(&chd->versha1);
-	chd->verifying = TRUE;
-	chd->verhunk = 0;
-
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    chd_verify_hunk - verify the next hunk in
-    the CHD
--------------------------------------------------*/
-
-chd_error chd_verify_hunk(chd_file *chd)
-{
-	UINT32 thishunk = chd->verhunk++;
-	UINT64 hunkoffset = (UINT64)thishunk * (UINT64)chd->header.hunkbytes;
-	map_entry *entry;
-	chd_error err;
-
-	/* error if in the wrong state */
-	if (!chd->verifying)
-		return CHDERR_INVALID_STATE;
-
-	/* read the hunk into the cache */
-	err = hunk_read_into_cache(chd, thishunk);
-	if (err != CHDERR_NONE)
-		return err;
-
-	entry = &chd->map[thishunk];
-
-	/* update the MD5/SHA1 */
-	if (hunkoffset < chd->header.logicalbytes)
-	{
-		UINT64 bytestochecksum = MIN(chd->header.hunkbytes, chd->header.logicalbytes - hunkoffset);
-
-		if (entry->flags & MAP_ENTRY_FLAG_HALF_HUNK)
-		{
-			bytestochecksum /= 2;
-		}
-
-		if (bytestochecksum > 0)
-		{
-			MD5Update(&chd->vermd5, chd->cache, bytestochecksum);
-			sha1_update(&chd->versha1, bytestochecksum, chd->cache);
-		}
-	}
-
-	/* validate the CRC if we have one */
-	if (!(entry->flags & MAP_ENTRY_FLAG_NO_CRC) && entry->crc != crc32(0, chd->cache, chd->header.hunkbytes))
-		return CHDERR_DECOMPRESSION_ERROR;
-
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    chd_verify_finish - finish verification of
-    the CHD
--------------------------------------------------*/
-
-chd_error chd_verify_finish(chd_file *chd, chd_verify_result *result)
-{
-	/* error if in the wrong state */
-	if (!chd->verifying)
-		return CHDERR_INVALID_STATE;
-
-	/* compute the final MD5 */
-	MD5Final(result->md5, &chd->vermd5);
-
-	/* compute the final SHA1 */
-	sha1_final(&chd->versha1);
-	sha1_digest(&chd->versha1, SHA1_DIGEST_SIZE, result->rawsha1);
-
-	/* compute the overall hash including metadata */
-	metadata_compute_hash(chd, result->rawsha1, result->sha1);
-
-	/* return an error */
-	chd->verifying = FALSE;
-	return (chd->verhunk < chd->header.totalhunks) ? CHDERR_VERIFY_INCOMPLETE : CHDERR_NONE;
-}
-
-
-
-/***************************************************************************
-    CODEC INTERFACES
-***************************************************************************/
-
-/*-------------------------------------------------
-    chd_codec_config - set internal codec
-    parameters
--------------------------------------------------*/
-
-chd_error chd_codec_config(chd_file *chd, int param, void *config)
-{
-	/* wait for any pending async operations */
-	wait_for_pending_async(chd);
-
-	/* if the codec has a configuration callback, call through to it */
-	if (chd->codecintf->config != NULL)
-		return (*chd->codecintf->config)(chd, param, config);
-
-	return CHDERR_INVALID_PARAMETER;
-}
-
-
-/*-------------------------------------------------
-    chd_get_codec_name - get the name of a
-    particular codec
--------------------------------------------------*/
-
-const char *chd_get_codec_name(UINT32 codec)
-{
-	int intfnum;
-
-	/* look for a matching codec and return its string */
-	for (intfnum = 0; intfnum < ARRAY_LENGTH(codec_interfaces); intfnum++)
-		if (codec_interfaces[intfnum].compression == codec)
-			return codec_interfaces[intfnum].compname;
-
-	return "Unknown";
-}
-
-
-
-/***************************************************************************
-    INTERNAL ASYNC OPERATIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    async_read_callback - asynchronous reading
-    callback
--------------------------------------------------*/
-
-static void *async_read_callback(void *param, int threadid)
-{
-	chd_file *chd = (chd_file *)param;
-	chd_error err;
-
-	/* read the hunk into the cache */
-	err = hunk_read_into_memory(chd, chd->async_hunknum, (UINT8 *)chd->async_buffer);
-
-	/* return the error */
-	return (void *)err;
-}
-
-
-/*-------------------------------------------------
-    async_write_callback - asynchronous writing
-    callback
--------------------------------------------------*/
-
-static void *async_write_callback(void *param, int threadid)
-{
-	chd_file *chd = (chd_file *)param;
-	chd_error err;
-
-	/* write the hunk from memory */
-	err = hunk_write_from_memory(chd, chd->async_hunknum, (const UINT8 *)chd->async_buffer);
-
-	/* return the error */
-	return (void *)err;
-}
-
-
-
-/***************************************************************************
-    INTERNAL HEADER OPERATIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    header_validate - check the validity of a
-    CHD header
--------------------------------------------------*/
-
-static chd_error header_validate(const chd_header *header)
-{
-	int intfnum;
-
-	/* require a valid version */
-	if (header->version == 0 || header->version > CHD_HEADER_VERSION)
-		return CHDERR_UNSUPPORTED_VERSION;
-
-	/* require a valid length */
-	if ((header->version == 1 && header->length != CHD_V1_HEADER_SIZE) ||
-		(header->version == 2 && header->length != CHD_V2_HEADER_SIZE) ||
-		(header->version == 3 && header->length != CHD_V3_HEADER_SIZE) ||
-		(header->version == 4 && header->length != CHD_V4_HEADER_SIZE))
-		return CHDERR_INVALID_PARAMETER;
-
-	/* require valid flags */
-	if (header->flags & CHDFLAGS_UNDEFINED)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* require a supported compression mechanism */
-	for (intfnum = 0; intfnum < ARRAY_LENGTH(codec_interfaces); intfnum++)
-		if (codec_interfaces[intfnum].compression == header->compression)
-			break;
-	if (intfnum == ARRAY_LENGTH(codec_interfaces))
-		return CHDERR_INVALID_PARAMETER;
-
-	/* require a valid hunksize */
-	if (header->hunkbytes == 0 || header->hunkbytes >= 65536 * 256)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* require a valid hunk count */
-	if (header->totalhunks == 0)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* require a valid MD5 and/or SHA1 if we're using a parent */
-	if ((header->flags & CHDFLAGS_HAS_PARENT) && memcmp(header->parentmd5, nullmd5, sizeof(nullmd5)) == 0 && memcmp(header->parentsha1, nullsha1, sizeof(nullsha1)) == 0)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're V3 or later, the obsolete fields must be 0 */
-	if (header->version >= 3 &&
-		(header->obsolete_cylinders != 0 || header->obsolete_sectors != 0 ||
-		 header->obsolete_heads != 0 || header->obsolete_hunksize != 0))
-		return CHDERR_INVALID_PARAMETER;
-
-	/* if we're pre-V3, the obsolete fields must NOT be 0 */
-	if (header->version < 3 &&
-		(header->obsolete_cylinders == 0 || header->obsolete_sectors == 0 ||
-		 header->obsolete_heads == 0 || header->obsolete_hunksize == 0))
-		return CHDERR_INVALID_PARAMETER;
+				// if the lengths don't match, we need to update the length in our header
+				if (inputlen != metaentry.length)
+				{
+					UINT8 length[3];
+					be_write(length, inputlen, 3);
+					file_write(metaentry.offset + 5, length, sizeof(length));
+				}
 
-	return CHDERR_NONE;
-}
+				// indicate we did everything
+				finished = true;
+			}
 
+			// if it doesn't fit, unlink the current entry
+			else
+				metadata_set_previous_next(metaentry.prev, metaentry.next);
+		}
 
-/*-------------------------------------------------
-    header_read - read a CHD header into the
-    internal data structure
--------------------------------------------------*/
+		// if not yet done, create a new entry and append
+		if (!finished)
+		{
+			// now build us a new entry
+			UINT8 raw_meta_header[METADATA_HEADER_SIZE];
+			be_write(&raw_meta_header[0], metatag, 4);
+			raw_meta_header[4] = flags;
+			be_write(&raw_meta_header[5], (inputlen & 0x00ffffff) | (flags << 24), 3);
+			be_write(&raw_meta_header[8], 0, 8);
 
-static chd_error header_read(core_file *file, chd_header *header)
-{
-	UINT8 rawheader[CHD_MAX_HEADER_SIZE];
-	UINT32 count;
+			// append the new header, then the data
+			UINT64 offset = file_append(raw_meta_header, sizeof(raw_meta_header));
+			file_append(inputbuf, inputlen);
 
-	/* punt if NULL */
-	if (header == NULL)
-		return CHDERR_INVALID_PARAMETER;
+			// set the previous entry to point to us
+			metadata_set_previous_next(metaentry.prev, offset);
+		}
 
-	/* punt if invalid file */
-	if (file == NULL)
-		return CHDERR_INVALID_FILE;
-
-	/* seek and read */
-	core_fseek(file, 0, SEEK_SET);
-	count = core_fread(file, rawheader, sizeof(rawheader));
-	if (count != sizeof(rawheader))
-		return CHDERR_READ_ERROR;
-
-	/* verify the tag */
-	if (strncmp((char *)rawheader, "MComprHD", 8) != 0)
-		return CHDERR_INVALID_DATA;
-
-	/* extract the direct data */
-	memset(header, 0, sizeof(*header));
-	header->length        = get_bigendian_uint32(&rawheader[8]);
-	header->version       = get_bigendian_uint32(&rawheader[12]);
-
-	/* make sure it's a version we understand */
-	if (header->version == 0 || header->version > CHD_HEADER_VERSION)
-		return CHDERR_UNSUPPORTED_VERSION;
-
-	/* make sure the length is expected */
-	if ((header->version == 1 && header->length != CHD_V1_HEADER_SIZE) ||
-		(header->version == 2 && header->length != CHD_V2_HEADER_SIZE) ||
-		(header->version == 3 && header->length != CHD_V3_HEADER_SIZE) ||
-		(header->version == 4 && header->length != CHD_V4_HEADER_SIZE))
-		return CHDERR_INVALID_DATA;
-
-	/* extract the common data */
-	header->flags         = get_bigendian_uint32(&rawheader[16]);
-	header->compression   = get_bigendian_uint32(&rawheader[20]);
-
-	/* extract the V1/V2-specific data */
-	if (header->version < 3)
-	{
-		int seclen = (header->version == 1) ? CHD_V1_SECTOR_SIZE : get_bigendian_uint32(&rawheader[76]);
-		header->obsolete_hunksize  = get_bigendian_uint32(&rawheader[24]);
-		header->totalhunks         = get_bigendian_uint32(&rawheader[28]);
-		header->obsolete_cylinders = get_bigendian_uint32(&rawheader[32]);
-		header->obsolete_heads     = get_bigendian_uint32(&rawheader[36]);
-		header->obsolete_sectors   = get_bigendian_uint32(&rawheader[40]);
-		memcpy(header->md5, &rawheader[44], CHD_MD5_BYTES);
-		memcpy(header->parentmd5, &rawheader[60], CHD_MD5_BYTES);
-		header->logicalbytes = (UINT64)header->obsolete_cylinders * (UINT64)header->obsolete_heads * (UINT64)header->obsolete_sectors * (UINT64)seclen;
-		header->hunkbytes = seclen * header->obsolete_hunksize;
-		header->metaoffset = 0;
-	}
-
-	/* extract the V3-specific data */
-	else if (header->version == 3)
-	{
-		header->totalhunks   = get_bigendian_uint32(&rawheader[24]);
-		header->logicalbytes = get_bigendian_uint64(&rawheader[28]);
-		header->metaoffset   = get_bigendian_uint64(&rawheader[36]);
-		memcpy(header->md5, &rawheader[44], CHD_MD5_BYTES);
-		memcpy(header->parentmd5, &rawheader[60], CHD_MD5_BYTES);
-		header->hunkbytes    = get_bigendian_uint32(&rawheader[76]);
-		memcpy(header->sha1, &rawheader[80], CHD_SHA1_BYTES);
-		memcpy(header->parentsha1, &rawheader[100], CHD_SHA1_BYTES);
+		// update the hash
+		metadata_update_hash();
+		return CHDERR_NONE;
 	}
 
-	/* extract the V4-specific data */
-	else
+	// return any errors
+	catch (chd_error &err)
 	{
-		header->totalhunks   = get_bigendian_uint32(&rawheader[24]);
-		header->logicalbytes = get_bigendian_uint64(&rawheader[28]);
-		header->metaoffset   = get_bigendian_uint64(&rawheader[36]);
-		header->hunkbytes    = get_bigendian_uint32(&rawheader[44]);
-		memcpy(header->sha1, &rawheader[48], CHD_SHA1_BYTES);
-		memcpy(header->parentsha1, &rawheader[68], CHD_SHA1_BYTES);
-		memcpy(header->rawsha1, &rawheader[88], CHD_SHA1_BYTES);
+		return err;
 	}
-
-	/* guess it worked */
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    header_write - write a CHD header from the
-    internal data structure
--------------------------------------------------*/
-
-static chd_error header_write(core_file *file, const chd_header *header)
-{
-	UINT8 rawheader[CHD_MAX_HEADER_SIZE];
-	UINT32 count;
-
-	/* punt if NULL */
-	if (header == NULL)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* punt if invalid file */
-	if (file == NULL)
-		return CHDERR_INVALID_FILE;
-
-	/* only support writing modern headers */
-	if (header->version != 4)
-		return CHDERR_INVALID_PARAMETER;
-
-	/* assemble the data */
-	memset(rawheader, 0, sizeof(rawheader));
-	memcpy(rawheader, "MComprHD", 8);
-
-	put_bigendian_uint32(&rawheader[8],  CHD_V4_HEADER_SIZE);
-	put_bigendian_uint32(&rawheader[12], header->version);
-	put_bigendian_uint32(&rawheader[16], header->flags);
-	put_bigendian_uint32(&rawheader[20], header->compression);
-	put_bigendian_uint32(&rawheader[24], header->totalhunks);
-	put_bigendian_uint64(&rawheader[28], header->logicalbytes);
-	put_bigendian_uint64(&rawheader[36], header->metaoffset);
-	put_bigendian_uint32(&rawheader[44], header->hunkbytes);
-	memcpy(&rawheader[48], header->sha1, CHD_SHA1_BYTES);
-	memcpy(&rawheader[68], header->parentsha1, CHD_SHA1_BYTES);
-	memcpy(&rawheader[88], header->rawsha1, CHD_SHA1_BYTES);
-
-	/* seek and write */
-	core_fseek(file, 0, SEEK_SET);
-	count = core_fwrite(file, rawheader, CHD_V4_HEADER_SIZE);
-	if (count != CHD_V4_HEADER_SIZE)
-		return CHDERR_WRITE_ERROR;
-
-	return CHDERR_NONE;
 }
 
 
+//-------------------------------------------------
+//  delete_metadata - remove the given metadata
+//  from the list
+//-------------------------------------------------
+
+chd_error chd_file::delete_metadata(chd_metadata_tag metatag, UINT32 metaindex)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// find the entry
+		metadata_entry metaentry;
+		if (!metadata_find(metatag, metaindex, metaentry))
+			throw CHDERR_METADATA_NOT_FOUND;
 
-/***************************************************************************
-    INTERNAL HUNK READ/WRITE
-***************************************************************************/
-
-/*-------------------------------------------------
-    hunk_read_into_cache - read a hunk into
-    the CHD's hunk cache
--------------------------------------------------*/
-
-static chd_error hunk_read_into_cache(chd_file *chd, UINT32 hunknum)
-{
-	chd_error err;
-
-	/* track the max */
-	if (hunknum > chd->maxhunk)
-		chd->maxhunk = hunknum;
-
-	/* if we're already in the cache, we're done */
-	if (chd->cachehunk == hunknum)
+		// point the previous to the next, unlinking us
+		metadata_set_previous_next(metaentry.prev, metaentry.next);
 		return CHDERR_NONE;
-	chd->cachehunk = ~0;
-
-	/* otherwise, read the data */
-	err = hunk_read_into_memory(chd, hunknum, chd->cache);
-	if (err != CHDERR_NONE)
-		return err;
-
-	/* mark the hunk successfully cached in */
-	chd->cachehunk = hunknum;
-	return CHDERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    hunk_read_into_memory - read a hunk into
-    memory at the given location
--------------------------------------------------*/
-
-static chd_error hunk_read_into_memory(chd_file *chd, UINT32 hunknum, UINT8 *dest)
-{
-	map_entry *entry = &chd->map[hunknum];
-	chd_error err;
-	UINT32 bytes;
-
-	/* return an error if out of range */
-	if (hunknum >= chd->header.totalhunks)
-		return CHDERR_HUNK_OUT_OF_RANGE;
+	}
 
-	/* switch off the entry type */
-	switch (entry->flags & MAP_ENTRY_FLAG_TYPE_MASK)
+	// return any errors
+	catch (chd_error &err)
 	{
-		/* compressed data */
-		case MAP_ENTRY_TYPE_COMPRESSED:
-
-			/* read it into the decompression buffer */
-			core_fseek(chd->file, entry->offset, SEEK_SET);
-			bytes = core_fread(chd->file, chd->compressed, entry->length);
-			if (bytes != entry->length)
-				return CHDERR_READ_ERROR;
-
-			/* now decompress using the codec */
-			err = CHDERR_NONE;
-			if (chd->codecintf->decompress != NULL)
-				err = (*chd->codecintf->decompress)(chd, entry->length, dest);
-			if (err != CHDERR_NONE)
-				return err;
-			break;
-
-		/* uncompressed data */
-		case MAP_ENTRY_TYPE_UNCOMPRESSED:
-			core_fseek(chd->file, entry->offset, SEEK_SET);
-			bytes = core_fread(chd->file, dest, chd->header.hunkbytes);
-			if (bytes != chd->header.hunkbytes)
-				return CHDERR_READ_ERROR;
-			break;
-
-		/* mini-compressed data */
-		case MAP_ENTRY_TYPE_MINI:
-			put_bigendian_uint64(&dest[0], entry->offset);
-			for (bytes = 8; bytes < chd->header.hunkbytes; bytes++)
-				dest[bytes] = dest[bytes - 8];
-			break;
-
-		/* self-referenced data */
-		case MAP_ENTRY_TYPE_SELF_HUNK:
-			if (chd->cachehunk == entry->offset && dest == chd->cache)
-				break;
-			return hunk_read_into_memory(chd, entry->offset, dest);
-
-		/* parent-referenced data */
-		case MAP_ENTRY_TYPE_PARENT_HUNK:
-			err = hunk_read_into_memory(chd->parent, entry->offset, dest);
-			if (err != CHDERR_NONE)
-				return err;
-			break;
-
-		case MAP_ENTRY_TYPE_2ND_COMPRESSED:
-			/* read it into the decompression buffer */
-			core_fseek(chd->file, entry->offset, SEEK_SET);
-			bytes = core_fread(chd->file, chd->compressed, entry->length);
-			if (bytes != entry->length)
-				return CHDERR_READ_ERROR;
-
-			/* now decompress using the codec */
-			err = CHDERR_NONE;
-			if (chd->codecintf->secondary_decompress != NULL)
-				err = (*chd->codecintf->secondary_decompress)(chd, entry->length, dest);
-			if (err != CHDERR_NONE)
-				return err;
-			break;
-
+		return err;
 	}
-	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    hunk_write_from_memory - write a hunk from
-    memory into a CHD
--------------------------------------------------*/
-
-
-static chd_error hunk_write_from_memory(chd_file *chd, UINT32 hunknum, const UINT8 *src, int is_half_hunk)
-{
-	map_entry *entry = &chd->map[hunknum];
-	map_entry newentry;
-	UINT8 fileentry[MAP_ENTRY_SIZE];
-	const void *data = src;
-	UINT32 bytes = 0, match;
-	chd_error err;
-	bool is_likely_cd = false;
-	int strategy = 0;
-
-	/* track the max */
-	if (hunknum > chd->maxhunk)
-		chd->maxhunk = hunknum;
-
-	/* first compute the CRC of the original data */
-    newentry.flags = 0;
-    newentry.length = 0;
-    newentry.offset = 0;
-	newentry.crc = 0;
-	if (src != NULL)
-		newentry.crc = crc32(0, &src[0], chd->header.hunkbytes);
-
-	/* if we're not a lossy codec, compute the CRC and look for matches */
-	if (!chd->codecintf->lossy && src != NULL)
-	{
-		/* some extra stuff for zlib+ compression */
-		if (chd->header.compression >= CHDCOMPRESSION_ZLIB_PLUS)
-		{
-			/* see if we can mini-compress first */
-			for (bytes = 8; bytes < chd->header.hunkbytes; bytes++)
-				if (src[bytes] != src[bytes - 8])
-					break;
-
-			/* if so, we don't need to write any data */
-			if (bytes == chd->header.hunkbytes)
-			{
-				newentry.offset = get_bigendian_uint64(&src[0]);
-				newentry.length = 0;
-				newentry.flags = MAP_ENTRY_TYPE_MINI;
-				goto write_entry;
-			}
-
-			/* otherwise, see if we can find a match in the current file */
-			match = crcmap_find_hunk(chd, hunknum, newentry.crc, &src[0]);
-			if (match != NO_MATCH)
-			{
-				newentry.offset = match;
-				newentry.length = 0;
-				newentry.flags = MAP_ENTRY_TYPE_SELF_HUNK;
-				goto write_entry;
-			}
-
-			/* if we have a parent, see if we can find a match in there */
-			if (chd->header.flags & CHDFLAGS_HAS_PARENT)
-			{
-				match = crcmap_find_hunk(chd->parent, ~0, newentry.crc, &src[0]);
-				if (match != NO_MATCH)
-				{
-					newentry.offset = match;
-					newentry.length = 0;
-					newentry.flags = MAP_ENTRY_TYPE_PARENT_HUNK;
-					goto write_entry;
-				}
-			}
-		}
-	}
-
-	if (chd->codecintf->secondary_compress != NULL)
-	{
-		if (chd->header.hunkbytes == (CD_MAX_SECTOR_DATA+CD_MAX_SUBCODE_DATA) * CD_FRAMES_PER_HUNK)
-			is_likely_cd = true;
-
-		if (is_likely_cd)
-		{
-			int offset = 0;
-			for (int frames=0;frames<CD_FRAMES_PER_HUNK;frames++)
-			{
-				int secoff;
-				for (secoff=0;secoff<CD_MAX_SECTOR_DATA;secoff++)
-				{
-					offset++;
-				}
-				for (secoff=0;secoff<CD_MAX_SUBCODE_DATA;secoff++)
-				{
-					if (src[offset]!=0x00)
-						is_likely_cd = false;
+//-------------------------------------------------
+//  clone_all_metadata - clone the metadata from
+//  one CHD to a second
+//-------------------------------------------------
+
+chd_error chd_file::clone_all_metadata(chd_file &source)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// iterate over metadata entries in the source
+		dynamic_buffer filedata;
+		metadata_entry metaentry;
+		metaentry.metatag = 0;
+		metaentry.length = 0;
+		metaentry.next = 0;
+		metaentry.flags = 0;
+		for (bool has_data = source.metadata_find(CHDMETATAG_WILDCARD, 0, metaentry); has_data; has_data = source.metadata_find(CHDMETATAG_WILDCARD, 0, metaentry, true))
+		{
+			// read the metadata item
+			filedata.resize(metaentry.length);
+			source.file_read(metaentry.offset + METADATA_HEADER_SIZE, filedata, metaentry.length);
 
-					offset++;
-				}
-			}
+			// write it to the destination
+			chd_error err = write_metadata(metaentry.metatag, (UINT32)-1, filedata, metaentry.length, metaentry.flags);
+			if (err != CHDERR_NONE)
+				throw err;
 		}
+		return CHDERR_NONE;
 	}
 
-	if (is_likely_cd)
-	{
-		err = CHDERR_COMPRESSION_ERROR;
-
-		UINT8* tempram = (UINT8 *)malloc(chd->header.hunkbytes);
-		UINT32 tempbytes = 0;
-		chd_error temperror = err;
-		int tempstrategy = 0;
-
-		/* try strategy 0 - zlib */
-		if (chd->codecintf->compress != NULL)
-		{
-			err = (*chd->codecintf->compress)(chd, src, &bytes);
-
-			/* store current results and errors */
-			memcpy(tempram, chd->compressed, bytes);
-			tempbytes = bytes;
-			temperror = err;
-			tempstrategy = 0;
-		}
-
-		/* try strategy 1 - flac */
-		if (chd->codecintf->secondary_compress != NULL)
-		{
-			strategy = 1;
-
-			err = (*chd->codecintf->secondary_compress)(chd, src, &bytes);
-
-			/* check against previous compression attempt if that was successful */
-			if (temperror == CHDERR_NONE)
-			{
-				/* if the previous compression was better, restore that ... */
-				if (bytes>=tempbytes)
-				{
-					strategy = tempstrategy;
-					memcpy(chd->compressed, tempram, tempbytes);
-					bytes = tempbytes;
-					err = temperror;
-				}
-			}
-		}
-
-		free(tempram);
-	}
-	else
+	// return any errors
+	catch (chd_error &err)
 	{
-		/* now try compressing the data */
-		err = CHDERR_COMPRESSION_ERROR;
-		if (chd->codecintf->compress != NULL)
-			err = (*chd->codecintf->compress)(chd, src, &bytes);
+		return err;
 	}
+}
 
-	/* if that worked, and we're lossy, decompress and CRC the result */
-	if (err == CHDERR_NONE && (chd->codecintf->lossy || src == NULL))
-	{
-		err = (*chd->codecintf->decompress)(chd, bytes, chd->cache);
-		if (err == CHDERR_NONE)
-			newentry.crc = crc32(0, chd->cache, chd->header.hunkbytes);
-	}
 
-	/* if we succeeded in compressing the data, replace our data pointer and mark it so */
-	if (err == CHDERR_NONE)
+//-------------------------------------------------
+//  compute_overall_sha1 - iterate through the
+//  metadata and compute the overall hash of the
+//  CHD file
+//-------------------------------------------------
+
+sha1_t chd_file::compute_overall_sha1(sha1_t rawsha1)
+{
+	// only works for v4 and above
+	if (m_version < 4)
+		return rawsha1;
+
+	// iterate over metadata
+	dynamic_buffer filedata;
+	dynamic_array<metadata_hash> hasharray;
+	metadata_entry metaentry;
+	for (bool has_data = metadata_find(CHDMETATAG_WILDCARD, 0, metaentry); has_data; has_data = metadata_find(CHDMETATAG_WILDCARD, 0, metaentry, true))
 	{
-		data = chd->compressed;
-		newentry.length = bytes;
+		// if not checksumming, continue
+		if ((metaentry.flags & CHD_MDFLAGS_CHECKSUM) == 0)
+			continue;
 
-		if (strategy == 0)
-		{
-			newentry.flags = MAP_ENTRY_TYPE_COMPRESSED;
-		}
-		else if (strategy == 1)
-		{
-			newentry.flags = MAP_ENTRY_TYPE_2ND_COMPRESSED;
-		}
-	}
+		// allocate memory and read the data
+		filedata.resize(metaentry.length);
+		file_read(metaentry.offset + METADATA_HEADER_SIZE, filedata, metaentry.length);
 
-	/* otherwise, mark it uncompressed and use the original data */
-	else
-	{
-		newentry.length = chd->header.hunkbytes;
-		newentry.flags = MAP_ENTRY_TYPE_UNCOMPRESSED;
+		// create an entry for this metadata and add it
+		metadata_hash hashentry;
+		be_write(hashentry.tag, metaentry.metatag, 4);
+		hashentry.sha1 = sha1_creator::simple(filedata, metaentry.length);
+		hasharray.append(hashentry);
 	}
 
+	// sort the array
+	if (hasharray.count() != 0)
+		qsort(&hasharray[0], hasharray.count(), sizeof(hasharray[0]), metadata_hash_compare);
 
-	/* if the data doesn't fit into the previous entry, make a new one at the eof */
-	newentry.offset = entry->offset;
-	if (newentry.offset == 0 || newentry.length > entry->length)
-		newentry.offset = core_fsize(chd->file);
-
-	/* write the data */
-	core_fseek(chd->file, newentry.offset, SEEK_SET);
-	bytes = core_fwrite(chd->file, data, newentry.length);
-	if (bytes != newentry.length)
-		return CHDERR_WRITE_ERROR;
-
-	/* update the entry in memory */
-write_entry:
-
-	if (is_half_hunk)
-		newentry.flags |= MAP_ENTRY_FLAG_HALF_HUNK;
-
-	*entry = newentry;
-
-	/* update the map on file */
-	map_assemble(&fileentry[0], &chd->map[hunknum]);
-	core_fseek(chd->file, chd->header.length + hunknum * sizeof(fileentry), SEEK_SET);
-	bytes = core_fwrite(chd->file, &fileentry[0], sizeof(fileentry));
-	if (bytes != sizeof(fileentry))
-		return CHDERR_WRITE_ERROR;
-
-	return CHDERR_NONE;
+	// read the raw data hash from our header and start a new SHA1 with that data
+	sha1_creator overall_sha1;
+	overall_sha1.append(&rawsha1, sizeof(rawsha1));
+	if (hasharray.count() != 0)
+		overall_sha1.append(&hasharray[0], hasharray.count() * sizeof(hasharray[0]));
+	return overall_sha1.finish();
 }
 
 
+//-------------------------------------------------
+//  codec_config - set internal codec parameters
+//-------------------------------------------------
 
-/***************************************************************************
-    INTERNAL MAP ACCESS
-***************************************************************************/
-
-/*-------------------------------------------------
-    map_write_initial - write an initial map to
-    a new CHD file
--------------------------------------------------*/
-
-static chd_error map_write_initial(core_file *file, chd_file *parent, const chd_header *header)
-{
-	UINT8 blank_map_entries[MAP_STACK_ENTRIES * MAP_ENTRY_SIZE];
-	int fullchunks, remainder, count, i, j;
-	map_entry mapentry;
-	UINT64 fileoffset;
-
-	/* create a mini hunk of 0's */
-	mapentry.offset = 0;
-	mapentry.crc = 0;
-	mapentry.length = 0;
-	mapentry.flags = MAP_ENTRY_TYPE_MINI | MAP_ENTRY_FLAG_NO_CRC;
-	for (i = 0; i < MAP_STACK_ENTRIES; i++)
-		map_assemble(&blank_map_entries[i * MAP_ENTRY_SIZE], &mapentry);
-
-	/* prepare to write a blank hunk map immediately following */
-	fileoffset = header->length;
-	fullchunks = header->totalhunks / MAP_STACK_ENTRIES;
-	remainder = header->totalhunks % MAP_STACK_ENTRIES;
-
-	/* first write full chunks of blank entries */
-	for (i = 0; i < fullchunks; i++)
-	{
-		/* parent drives need to be mapped through */
-		if (parent != NULL)
-			for (j = 0; j < MAP_STACK_ENTRIES; j++)
+chd_error chd_file::codec_configure(chd_codec_type codec, int param, void *config)
+{
+	// wrap this for clean reporting
+	try
+	{
+		// find the codec and call its configuration
+		for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_compression); codecnum++)
+			if (m_compression[codecnum] == codec)
 			{
-				mapentry.offset = i * MAP_STACK_ENTRIES + j;
-				mapentry.crc = parent->map[i * MAP_STACK_ENTRIES + j].crc;
-				mapentry.flags = MAP_ENTRY_TYPE_PARENT_HUNK;
-				map_assemble(&blank_map_entries[j * MAP_ENTRY_SIZE], &mapentry);
+				m_decompressor[codecnum]->configure(param, config);
+				return CHDERR_NONE;
 			}
-
-		/* write the chunks */
-		core_fseek(file, fileoffset, SEEK_SET);
-		count = core_fwrite(file, blank_map_entries, sizeof(blank_map_entries));
-		if (count != sizeof(blank_map_entries))
-			return CHDERR_WRITE_ERROR;
-		fileoffset += sizeof(blank_map_entries);
+		return CHDERR_INVALID_PARAMETER;
 	}
 
-	/* then write the remainder */
-	if (remainder > 0)
-	{
-		/* parent drives need to be mapped through */
-		if (parent != NULL)
-			for (j = 0; j < remainder; j++)
-			{
-				mapentry.offset = i * MAP_STACK_ENTRIES + j;
-				mapentry.crc = parent->map[i * MAP_STACK_ENTRIES + j].crc;
-				mapentry.flags = MAP_ENTRY_TYPE_PARENT_HUNK;
-				map_assemble(&blank_map_entries[j * MAP_ENTRY_SIZE], &mapentry);
-			}
-
-		/* write the chunks */
-		core_fseek(file, fileoffset, SEEK_SET);
-		count = core_fwrite(file, blank_map_entries, remainder * MAP_ENTRY_SIZE);
-		if (count != remainder * MAP_ENTRY_SIZE)
-			return CHDERR_WRITE_ERROR;
-		fileoffset += remainder * MAP_ENTRY_SIZE;
+	// return any errors
+	catch (chd_error &err)
+	{
+		return err;
 	}
-
-	/* then write a special end-of-list cookie */
-	memcpy(&blank_map_entries[0], END_OF_LIST_COOKIE, MAP_ENTRY_SIZE);
-	core_fseek(file, fileoffset, SEEK_SET);
-	count = core_fwrite(file, blank_map_entries, MAP_ENTRY_SIZE);
-	if (count != MAP_ENTRY_SIZE)
-		return CHDERR_WRITE_ERROR;
-
-	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    map_read - read the initial sector map
--------------------------------------------------*/
-
-static chd_error map_read(chd_file *chd)
-{
-	UINT32 entrysize = (chd->header.version < 3) ? OLD_MAP_ENTRY_SIZE : MAP_ENTRY_SIZE;
-	UINT8 raw_map_entries[MAP_STACK_ENTRIES * MAP_ENTRY_SIZE];
-	UINT64 fileoffset, maxoffset = 0;
-	UINT8 cookie[MAP_ENTRY_SIZE];
-	UINT32 count;
-	chd_error err;
-	int i;
-
-	/* first allocate memory */
-	chd->map = (map_entry *)malloc(sizeof(chd->map[0]) * chd->header.totalhunks);
-	if (!chd->map)
-		return CHDERR_OUT_OF_MEMORY;
-
-	/* read the map entries in in chunks and extract to the map list */
-	fileoffset = chd->header.length;
-	for (i = 0; i < chd->header.totalhunks; i += MAP_STACK_ENTRIES)
-	{
-		/* compute how many entries this time */
-		int entries = chd->header.totalhunks - i, j;
-		if (entries > MAP_STACK_ENTRIES)
-			entries = MAP_STACK_ENTRIES;
-
-		/* read that many */
-		core_fseek(chd->file, fileoffset, SEEK_SET);
-		count = core_fread(chd->file, raw_map_entries, entries * entrysize);
-		if (count != entries * entrysize)
-		{
-			err = CHDERR_READ_ERROR;
-			goto cleanup;
-		}
-		fileoffset += entries * entrysize;
-
-		/* process that many */
-		if (entrysize == MAP_ENTRY_SIZE)
-		{
-			for (j = 0; j < entries; j++)
-				map_extract(&raw_map_entries[j * MAP_ENTRY_SIZE], &chd->map[i + j]);
-		}
-		else
-		{
-			for (j = 0; j < entries; j++)
-				map_extract_old(&raw_map_entries[j * OLD_MAP_ENTRY_SIZE], &chd->map[i + j], chd->header.hunkbytes);
-		}
-
-		/* track the maximum offset */
-		for (j = 0; j < entries; j++)
-			if ((chd->map[i + j].flags & MAP_ENTRY_FLAG_TYPE_MASK) == MAP_ENTRY_TYPE_COMPRESSED ||
-				(chd->map[i + j].flags & MAP_ENTRY_FLAG_TYPE_MASK) == MAP_ENTRY_TYPE_2ND_COMPRESSED ||
-				(chd->map[i + j].flags & MAP_ENTRY_FLAG_TYPE_MASK) == MAP_ENTRY_TYPE_UNCOMPRESSED)
-				maxoffset = MAX(maxoffset, chd->map[i + j].offset + chd->map[i + j].length);
-	}
-
-	/* verify the cookie */
-	core_fseek(chd->file, fileoffset, SEEK_SET);
-	count = core_fread(chd->file, &cookie, entrysize);
-	if (count != entrysize || memcmp(&cookie, END_OF_LIST_COOKIE, entrysize))
-	{
-		err = CHDERR_INVALID_FILE;
-		goto cleanup;
-	}
+//-------------------------------------------------
+//  error_string - return an error string for
+//  the given CHD error
+//-------------------------------------------------
 
-	/* verify the length */
-	if (maxoffset > core_fsize(chd->file))
+const char *chd_file::error_string(chd_error err)
+{
+	switch (err)
 	{
-		err = CHDERR_INVALID_FILE;
-		goto cleanup;
+		case CHDERR_NONE:						return "no error";
+		case CHDERR_NO_INTERFACE:				return "no drive interface";
+		case CHDERR_OUT_OF_MEMORY:				return "out of memory";
+		case CHDERR_NOT_OPEN:					return "file not open";
+		case CHDERR_ALREADY_OPEN:				return "file already open";
+		case CHDERR_INVALID_FILE:				return "invalid file";
+		case CHDERR_INVALID_PARAMETER:			return "invalid parameter";
+		case CHDERR_INVALID_DATA:				return "invalid data";
+		case CHDERR_FILE_NOT_FOUND:				return "file not found";
+		case CHDERR_REQUIRES_PARENT:			return "requires parent";
+		case CHDERR_FILE_NOT_WRITEABLE:			return "file not writeable";
+		case CHDERR_READ_ERROR:					return "read error";
+		case CHDERR_WRITE_ERROR:				return "write error";
+		case CHDERR_CODEC_ERROR:				return "codec error";
+		case CHDERR_INVALID_PARENT:				return "invalid parent";
+		case CHDERR_HUNK_OUT_OF_RANGE:			return "hunk out of range";
+		case CHDERR_DECOMPRESSION_ERROR:		return "decompression error";
+		case CHDERR_COMPRESSION_ERROR:			return "compression error";
+		case CHDERR_CANT_CREATE_FILE:			return "can't create file";
+		case CHDERR_CANT_VERIFY:				return "can't verify file";
+		case CHDERR_NOT_SUPPORTED:				return "operation not supported";
+		case CHDERR_METADATA_NOT_FOUND:			return "can't find metadata";
+		case CHDERR_INVALID_METADATA_SIZE:		return "invalid metadata size";
+		case CHDERR_UNSUPPORTED_VERSION:		return "unsupported CHD version";
+		case CHDERR_VERIFY_INCOMPLETE:			return "incomplete verify";
+		case CHDERR_INVALID_METADATA:			return "invalid metadata";
+		case CHDERR_INVALID_STATE:				return "invalid state";
+		case CHDERR_OPERATION_PENDING:			return "operation pending";
+		case CHDERR_UNSUPPORTED_FORMAT:			return "unsupported format";
+		case CHDERR_UNKNOWN_COMPRESSION:		return "unknown compression type";
+		case CHDERR_WALKING_PARENT:				return "currently examining parent";
+		case CHDERR_COMPRESSING:				return "currently compressing";
+		default:								return "undocumented error";
 	}
-	return CHDERR_NONE;
-
-cleanup:
-	if (chd->map)
-		free(chd->map);
-	chd->map = NULL;
-	return err;
 }
 
 
 
-/***************************************************************************
-    INTERNAL CRC MAP ACCESS
-***************************************************************************/
+//**************************************************************************
+//  INTERNAL HELPERS
+//**************************************************************************
 
-/*-------------------------------------------------
-    crcmap_init - initialize the CRC map
--------------------------------------------------*/
+//-------------------------------------------------
+//  guess_unitbytes - for older CHD formats, take
+//  a guess at the bytes/unit based on metadata
+//-------------------------------------------------
 
-static void crcmap_init(chd_file *chd, int prepopulate)
+UINT32 chd_file::guess_unitbytes()
 {
-	int i;
-
-	/* if we already have one, bail */
-	if (chd->crcmap != NULL)
-		return;
-
-	/* reset all pointers */
-	chd->crcmap = NULL;
-	chd->crcfree = NULL;
-	chd->crctable = NULL;
-
-	/* allocate a list; one for each hunk */
-	chd->crcmap = (crcmap_entry *)malloc(chd->header.totalhunks * sizeof(chd->crcmap[0]));
-	if (chd->crcmap == NULL)
-		return;
-
-	/* allocate a CRC map table */
-	chd->crctable = (crcmap_entry **)malloc(CRCMAP_HASH_SIZE * sizeof(chd->crctable[0]));
-	if (chd->crctable == NULL)
-	{
-		free(chd->crcmap);
-		chd->crcmap = NULL;
-		return;
-	}
-
-	/* initialize the free list */
-	for (i = 0; i < chd->header.totalhunks; i++)
-	{
-		chd->crcmap[i].next = chd->crcfree;
-		chd->crcfree = &chd->crcmap[i];
-	}
+	// look for hard disk metadata; if found, then the unit size == sector size
+	astring metadata;
+	int i0, i1, i2, i3;
+	if (read_metadata(HARD_DISK_METADATA_TAG, 0, metadata) == CHDERR_NONE && sscanf(metadata, HARD_DISK_METADATA_FORMAT, &i0, &i1, &i2, &i3) == 4)
+		return i3;
 
-	/* initialize the table */
-	memset(chd->crctable, 0, CRCMAP_HASH_SIZE * sizeof(chd->crctable[0]));
+	// look for CD-ROM metadata; if found, then the unit size == CD frame size
+	if (read_metadata(CDROM_OLD_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
+		read_metadata(CDROM_TRACK_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
+		read_metadata(CDROM_TRACK_METADATA2_TAG, 0, metadata) == CHDERR_NONE)
+		return CD_FRAME_SIZE;
 
-	/* if we're to prepopulate, go for it */
-	if (prepopulate)
-		for (i = 0; i < chd->header.totalhunks; i++)
-			crcmap_add_entry(chd, i);
+	// otherwise, just map 1:1 with the hunk size
+	return m_hunkbytes;
 }
 
 
-/*-------------------------------------------------
-    crcmap_add_entry - log a CRC entry
--------------------------------------------------*/
+//-------------------------------------------------
+//  parse_v3_header - parse the header from a v3
+//  file and configure core parameters
+//-------------------------------------------------
 
-static void crcmap_add_entry(chd_file *chd, UINT32 hunknum)
+void chd_file::parse_v3_header(UINT8 *rawheader, sha1_t &parentsha1)
 {
-	UINT32 hash = chd->map[hunknum].crc % CRCMAP_HASH_SIZE;
-	crcmap_entry *crcmap;
+	// verify header length
+	if (be_read(&rawheader[8], 4) != V3_HEADER_SIZE)
+		throw CHDERR_INVALID_FILE;
 
-	/* pull a free entry off the list */
-	crcmap = chd->crcfree;
-	chd->crcfree = crcmap->next;
-
-	/* set up the entry and link it into the hash table */
-	crcmap->hunknum = hunknum;
-	crcmap->next = chd->crctable[hash];
-	chd->crctable[hash] = crcmap;
-}
+	// extract core info
+	m_logicalbytes = be_read(&rawheader[28], 8);
+	m_mapoffset = 120;
+	m_metaoffset = be_read(&rawheader[36], 8);
+	m_hunkbytes = be_read(&rawheader[76], 4);
+	m_hunkcount = be_read(&rawheader[24], 4);
 
+	// extract parent SHA-1
+	UINT32 flags = be_read(&rawheader[16], 4);
+	if ((flags & 2) && m_allow_writes)
+		throw CHDERR_FILE_NOT_WRITEABLE;
 
-/*-------------------------------------------------
-    crcmap_verify_hunk_match - verify that a
-    hunk really matches by doing a byte-for-byte
-    compare
--------------------------------------------------*/
-
-static int crcmap_verify_hunk_match(chd_file *chd, UINT32 hunknum, const UINT8 *rawdata)
-{
-	/* we have a potential match -- better be sure */
-	/* read the hunk from disk and compare byte-for-byte */
-	if (hunknum != chd->comparehunk)
+	// determine compression
+	switch (be_read(&rawheader[20], 4))
 	{
-		chd->comparehunk = ~0;
-		if (hunk_read_into_memory(chd, hunknum, chd->compare) == CHDERR_NONE)
-			chd->comparehunk = hunknum;
+		case 0:	m_compression[0] = CHD_CODEC_NONE;		break;
+		case 1:	m_compression[0] = CHD_CODEC_ZLIB;		break;
+		case 2:	m_compression[0] = CHD_CODEC_ZLIB;		break;
+		case 3:	m_compression[0] = CHD_CODEC_AVHUFF;	break;
+		default: throw CHDERR_UNKNOWN_COMPRESSION;
 	}
-	return (hunknum == chd->comparehunk && memcmp(rawdata, chd->compare, chd->header.hunkbytes) == 0);
-}
-
+	m_compression[1] = m_compression[2] = m_compression[3] = CHD_CODEC_NONE;
 
-/*-------------------------------------------------
-    crcmap_find_hunk - find a hunk with a matching
-    CRC in the map
--------------------------------------------------*/
+	// describe the format
+	m_mapoffset_offset = 0;
+	m_metaoffset_offset = 36;
+	m_sha1_offset = 80;
+	m_rawsha1_offset = 0;
+	m_parentsha1_offset = 100;
 
-static UINT32 crcmap_find_hunk(chd_file *chd, UINT32 hunknum, UINT32 crc, const UINT8 *rawdata)
-{
-	UINT32 lasthunk = (hunknum < chd->header.totalhunks) ? hunknum : chd->header.totalhunks;
-	int curhunk;
+	// determine properties of map entries
+	m_mapentrybytes = 16;
 
-	/* if we have a CRC map, use that */
-	if (chd->crctable)
-	{
-		crcmap_entry *curentry;
-		for (curentry = chd->crctable[crc % CRCMAP_HASH_SIZE]; curentry; curentry = curentry->next)
-		{
-			curhunk = curentry->hunknum;
-			if (chd->map[curhunk].crc == crc && !(chd->map[curhunk].flags & MAP_ENTRY_FLAG_NO_CRC) && !(chd->map[curhunk].flags & MAP_ENTRY_FLAG_HALF_HUNK) && crcmap_verify_hunk_match(chd, curhunk, rawdata))
-				return curhunk;
-		}
-		return NO_MATCH;
-	}
+	// extract parent SHA-1
+	if (flags & 1)
+		parentsha1 = be_read_sha1(&rawheader[m_parentsha1_offset]);
 
-	/* first see if the last match is a valid one */
-	if (chd->comparehunk < chd->header.totalhunks && chd->map[chd->comparehunk].crc == crc && !(chd->map[chd->comparehunk].flags & MAP_ENTRY_FLAG_NO_CRC) && !(chd->map[chd->comparehunk].flags & MAP_ENTRY_FLAG_HALF_HUNK) &&
-		memcmp(rawdata, chd->compare, chd->header.hunkbytes) == 0)
-		return chd->comparehunk;
+	// guess at the units based on snooping the metadata
+	m_unitbytes = guess_unitbytes();
+	m_unitcount = (m_logicalbytes + m_unitbytes - 1) / m_unitbytes;
+}
 
-	/* scan through the CHD's hunk map looking for a match */
-	for (curhunk = 0; curhunk < lasthunk; curhunk++)
-		if (chd->map[curhunk].crc == crc && !(chd->map[curhunk].flags & MAP_ENTRY_FLAG_NO_CRC) && !(chd->map[curhunk].flags & MAP_ENTRY_FLAG_HALF_HUNK) && crcmap_verify_hunk_match(chd, curhunk, rawdata))
-			return curhunk;
 
-	return NO_MATCH;
-}
+//-------------------------------------------------
+//  parse_v4_header - parse the header from a v4
+//  file and configure core parameters
+//-------------------------------------------------
 
+void chd_file::parse_v4_header(UINT8 *rawheader, sha1_t &parentsha1)
+{
+	// verify header length
+	if (be_read(&rawheader[8], 4) != V4_HEADER_SIZE)
+		throw CHDERR_INVALID_FILE;
 
+	// extract core info
+	m_logicalbytes = be_read(&rawheader[28], 8);
+	m_mapoffset = 108;
+	m_metaoffset = be_read(&rawheader[36], 8);
+	m_hunkbytes = be_read(&rawheader[44], 4);
+	m_hunkcount = be_read(&rawheader[24], 4);
 
-/***************************************************************************
-    INTERNAL METADATA ACCESS
-***************************************************************************/
+	// extract parent SHA-1
+	UINT32 flags = be_read(&rawheader[16], 4);
+	if ((flags & 2) && m_allow_writes)
+		throw CHDERR_FILE_NOT_WRITEABLE;
 
-/*-------------------------------------------------
-    metadata_find_entry - find a metadata entry
--------------------------------------------------*/
-
-static chd_error metadata_find_entry(chd_file *chd, UINT32 metatag, UINT32 metaindex, metadata_entry *metaentry)
-{
-	/* start at the beginning */
-	metaentry->offset = chd->header.metaoffset;
-	metaentry->prev = 0;
-
-	/* loop until we run out of options */
-	while (metaentry->offset != 0)
-	{
-		UINT8	raw_meta_header[METADATA_HEADER_SIZE];
-		UINT32	count;
-
-		/* read the raw header */
-		core_fseek(chd->file, metaentry->offset, SEEK_SET);
-		count = core_fread(chd->file, raw_meta_header, sizeof(raw_meta_header));
-		if (count != sizeof(raw_meta_header))
-			break;
+	// determine compression
+	switch (be_read(&rawheader[20], 4))
+	{
+		case 0:	m_compression[0] = CHD_CODEC_NONE;		break;
+		case 1:	m_compression[0] = CHD_CODEC_ZLIB;		break;
+		case 2:	m_compression[0] = CHD_CODEC_ZLIB;		break;
+		case 3:	m_compression[0] = CHD_CODEC_AVHUFF;	break;
+		default: throw CHDERR_UNKNOWN_COMPRESSION;
+	}
+	m_compression[1] = m_compression[2] = m_compression[3] = CHD_CODEC_NONE;
 
-		/* extract the data */
-		metaentry->metatag = get_bigendian_uint32(&raw_meta_header[0]);
-		metaentry->length = get_bigendian_uint32(&raw_meta_header[4]);
-		metaentry->next = get_bigendian_uint64(&raw_meta_header[8]);
-
-		/* flags are encoded in the high byte of length */
-		metaentry->flags = metaentry->length >> 24;
-		metaentry->length &= 0x00ffffff;
+	// describe the format
+	m_mapoffset_offset = 0;
+	m_metaoffset_offset = 36;
+	m_sha1_offset = 48;
+	m_rawsha1_offset = 88;
+	m_parentsha1_offset = 68;
 
-		/* if we got a match, proceed */
-		if (metatag == CHDMETATAG_WILDCARD || metaentry->metatag == metatag)
-			if (metaindex-- == 0)
-				return CHDERR_NONE;
+	// determine properties of map entries
+	m_mapentrybytes = 16;
 
-		/* no match, fetch the next link */
-		metaentry->prev = metaentry->offset;
-		metaentry->offset = metaentry->next;
-	}
+	// extract parent SHA-1
+	if (flags & 1)
+		parentsha1 = be_read_sha1(&rawheader[m_parentsha1_offset]);
 
-	/* if we get here, we didn't find it */
-	return CHDERR_METADATA_NOT_FOUND;
+	// guess at the units based on snooping the metadata
+	m_unitbytes = guess_unitbytes();
+	m_unitcount = (m_logicalbytes + m_unitbytes - 1) / m_unitbytes;
 }
 
 
-/*-------------------------------------------------
-    metadata_set_previous_next - set the 'next'
-    offset of a piece of metadata
--------------------------------------------------*/
+//-------------------------------------------------
+//  parse_v5_header - read the header from a v5
+//  file and configure core parameters
+//-------------------------------------------------
 
-static chd_error metadata_set_previous_next(chd_file *chd, UINT64 prevoffset, UINT64 nextoffset)
+void chd_file::parse_v5_header(UINT8 *rawheader, sha1_t &parentsha1)
 {
-	UINT8 raw_meta_header[METADATA_HEADER_SIZE];
-	chd_error err;
-	UINT32 count;
+	// verify header length
+	if (be_read(&rawheader[8], 4) != V5_HEADER_SIZE)
+		throw CHDERR_INVALID_FILE;
 
-	/* if we were the first entry, make the next entry the first */
-	if (prevoffset == 0)
-	{
-		chd->header.metaoffset = nextoffset;
-		err = header_write(chd->file, &chd->header);
-		if (err != CHDERR_NONE)
-			return err;
-	}
+	// extract core info
+	m_logicalbytes = be_read(&rawheader[32], 8);
+	m_mapoffset = be_read(&rawheader[40], 8);
+	m_metaoffset = be_read(&rawheader[48], 8);
+	m_hunkbytes = be_read(&rawheader[56], 4);
+	m_hunkcount = (m_logicalbytes + m_hunkbytes - 1) / m_hunkbytes;
+	m_unitbytes = be_read(&rawheader[60], 4);
+	m_unitcount = (m_logicalbytes + m_unitbytes - 1) / m_unitbytes;
 
-	/* otherwise, update the link in the previous pointer */
-	else
-	{
-		/* read the previous raw header */
-		core_fseek(chd->file, prevoffset, SEEK_SET);
-		count = core_fread(chd->file, raw_meta_header, sizeof(raw_meta_header));
-		if (count != sizeof(raw_meta_header))
-			return CHDERR_READ_ERROR;
+	// determine compression
+	m_compression[0] = be_read(&rawheader[16], 4);
+	m_compression[1] = be_read(&rawheader[20], 4);
+	m_compression[2] = be_read(&rawheader[24], 4);
+	m_compression[3] = be_read(&rawheader[28], 4);
 
-		/* copy our next pointer into the previous->next offset */
-		put_bigendian_uint64(&raw_meta_header[8], nextoffset);
+	// describe the format
+	m_mapoffset_offset = 40;
+	m_metaoffset_offset = 48;
+	m_sha1_offset = 84;
+	m_rawsha1_offset = 64;
+	m_parentsha1_offset = 104;
 
-		/* write the previous raw header */
-		core_fseek(chd->file, prevoffset, SEEK_SET);
-		count = core_fwrite(chd->file, raw_meta_header, sizeof(raw_meta_header));
-		if (count != sizeof(raw_meta_header))
-			return CHDERR_WRITE_ERROR;
-	}
+	// determine properties of map entries
+	m_mapentrybytes = compressed() ? 12 : 4;
 
-	return CHDERR_NONE;
+	// extract parent SHA-1
+	parentsha1 = be_read_sha1(&rawheader[m_parentsha1_offset]);
 }
 
 
-/*-------------------------------------------------
-    metadata_set_length - set the length field of
-    a piece of metadata
--------------------------------------------------*/
-
-static chd_error metadata_set_length(chd_file *chd, UINT64 offset, UINT32 length)
-{
-	UINT8 raw_meta_header[METADATA_HEADER_SIZE];
-	UINT32 oldlength;
-	UINT32 count;
-
-	/* read the raw header */
-	core_fseek(chd->file, offset, SEEK_SET);
-	count = core_fread(chd->file, raw_meta_header, sizeof(raw_meta_header));
-	if (count != sizeof(raw_meta_header))
-		return CHDERR_READ_ERROR;
-
-	/* update the length at offset 4, preserving the flags in the upper byte */
-	oldlength = get_bigendian_uint32(&raw_meta_header[4]);
-	length = (length & 0x00ffffff) | (oldlength & 0xff000000);
-	put_bigendian_uint32(&raw_meta_header[4], length);
-
-	/* write the raw header */
-	core_fseek(chd->file, offset, SEEK_SET);
-	count = core_fwrite(chd->file, raw_meta_header, sizeof(raw_meta_header));
-	if (count != sizeof(raw_meta_header))
-		return CHDERR_WRITE_ERROR;
+//-------------------------------------------------
+//  compress_v5_map - compress the v5 map and
+//  write it to the end of the file
+//-------------------------------------------------
 
-	return CHDERR_NONE;
-}
+chd_error chd_file::compress_v5_map()
+{
+	try
+	{
+		// first get a CRC-16 of the original rawmap
+		crc16_t mapcrc = crc16_creator::simple(m_rawmap, m_hunkcount * 12);
 
+		// create a buffer to hold the RLE data
+		dynamic_buffer compression_rle(m_hunkcount);
+		UINT8 *dest = compression_rle;
 
-/*-------------------------------------------------
-    metadata_compute_hash - compute the SHA1
-    hash of all metadata that requests it
--------------------------------------------------*/
-
-static chd_error metadata_compute_hash(chd_file *chd, const UINT8 *rawsha1, UINT8 *finalsha1)
-{
-	metadata_hash *hasharray = NULL;
-	chd_error err = CHDERR_NONE;
-	struct sha1_ctx sha1;
-	UINT32 hashindex = 0;
-	UINT32 hashalloc = 0;
-	UINT64 offset, next;
+		// use a huffman encoder for 16 different codes, maximum length is 8 bits
+		huffman_encoder<16, 8> encoder;
+		encoder.histo_reset();
 
-	/* only works for V4 and above */
-	if (chd->header.version < 4)
-	{
-		memcpy(finalsha1, rawsha1, SHA1_DIGEST_SIZE);
-		return CHDERR_NONE;
-	}
+		// RLE-compress the compression type since we expect runs of the same
+		UINT32 max_self = 0;
+		UINT32 last_self = 0;
+		UINT64 max_parent = 0;
+		UINT64 last_parent = 0;
+		UINT32 max_complen = 0;
+		UINT8 lastcomp = 0;
+		int count = 0;
+		for (int hunknum = 0; hunknum < m_hunkcount; hunknum++)
+		{
+			UINT8 curcomp = m_rawmap[hunknum * 12 + 0];
 
-	/* loop until we run out of data */
-	for (offset = chd->header.metaoffset; offset != 0; offset = next)
-	{
-		UINT8 raw_meta_header[METADATA_HEADER_SIZE];
-		UINT32 count, metalength, metatag;
-		UINT8 *tempbuffer;
-		UINT8 metaflags;
-
-		/* read the raw header */
-		core_fseek(chd->file, offset, SEEK_SET);
-		count = core_fread(chd->file, raw_meta_header, sizeof(raw_meta_header));
-		if (count != sizeof(raw_meta_header))
-			break;
+			// promote self block references to more compact forms
+			if (curcomp == COMPRESSION_SELF)
+			{
+				UINT32 refhunk = be_read(&m_rawmap[hunknum * 12 + 4], 6);
+				if (refhunk == last_self)
+					curcomp = COMPRESSION_SELF_0;
+				else if (refhunk == last_self + 1)
+					curcomp = COMPRESSION_SELF_1;
+				else
+					max_self = MAX(max_self, refhunk);
+				last_self = refhunk;
+			}
 
-		/* extract the data */
-		metatag = get_bigendian_uint32(&raw_meta_header[0]);
-		metalength = get_bigendian_uint32(&raw_meta_header[4]);
-		next = get_bigendian_uint64(&raw_meta_header[8]);
-
-		/* flags are encoded in the high byte of length */
-		metaflags = metalength >> 24;
-		metalength &= 0x00ffffff;
+			// promote parent block references to more compact forms
+			else if (curcomp == COMPRESSION_PARENT)
+			{
+				UINT32 refunit = be_read(&m_rawmap[hunknum * 12 + 4], 6);
+				if (refunit == (UINT64(hunknum) * UINT64(m_hunkbytes)) / m_unitbytes)
+					curcomp = COMPRESSION_PARENT_SELF;
+				else if (refunit == last_parent)
+					curcomp = COMPRESSION_PARENT_0;
+				else if (refunit == last_parent + m_hunkbytes / m_unitbytes)
+					curcomp = COMPRESSION_PARENT_1;
+				else
+					max_parent = MAX(max_parent, refunit);
+				last_parent = refunit;
+			}
 
-		/* if not checksumming, continue */
-		if (!(metaflags & CHD_MDFLAGS_CHECKSUM))
-			continue;
+			// track maximum compressed length
+			else //if (curcomp >= COMPRESSION_TYPE_0 && curcomp <= COMPRESSION_TYPE_3)
+				max_complen = MAX(max_complen, be_read(&m_rawmap[hunknum * 12 + 1], 3));
+
+			// track repeats
+			if (curcomp == lastcomp)
+				count++;
 
-		/* allocate memory */
-		tempbuffer = (UINT8 *)malloc(metalength);
-		if (tempbuffer == NULL)
-		{
-			err = CHDERR_OUT_OF_MEMORY;
-			goto cleanup;
+			// if no repeat, or we're at the end, flush it
+			if (curcomp != lastcomp || hunknum == m_hunkcount - 1)
+			{
+				while (count != 0)
+				{
+					if (count < 3)
+						encoder.histo_one(*dest++ = lastcomp), count--;
+					else if (count <= 3+15)
+					{
+						encoder.histo_one(*dest++ = COMPRESSION_RLE_SMALL);
+						encoder.histo_one(*dest++ = count - 3);
+						count = 0;
+					}
+					else
+					{
+						int this_count = MIN(count, 3+16+255);
+						encoder.histo_one(*dest++ = COMPRESSION_RLE_LARGE);
+						encoder.histo_one(*dest++ = (this_count - 3 - 16) >> 4);
+						encoder.histo_one(*dest++ = (this_count - 3 - 16) & 15);
+						count -= this_count;
+					}
+				}
+				if (curcomp != lastcomp)
+					encoder.histo_one(*dest++ = lastcomp = curcomp);
+			}
 		}
 
-		/* seek and read the metadata */
-		core_fseek(chd->file, offset + METADATA_HEADER_SIZE, SEEK_SET);
-		count = core_fread(chd->file, tempbuffer, metalength);
-		if (count != metalength)
-		{
-			free(tempbuffer);
-			err = CHDERR_READ_ERROR;
-			goto cleanup;
-		}
+		// compute a tree and export it to the buffer
+		dynamic_buffer compressed(m_hunkcount * 6);
+		bitstream_out bitbuf(&compressed[16], compressed.count() - 16);
+		huffman_error err = encoder.compute_tree_from_histo();
+		if (err != HUFFERR_NONE)
+			throw CHDERR_COMPRESSION_ERROR;
+		err = encoder.export_tree_rle(bitbuf);
+		if (err != HUFFERR_NONE)
+			throw CHDERR_COMPRESSION_ERROR;
+
+		// encode the data
+		for (UINT8 *src = compression_rle; src < dest; src++)
+			encoder.encode_one(bitbuf, *src);
+
+		// determine the number of bits we need to hold the a length
+		// and a hunk index
+		UINT8 lengthbits = bits_for_value(max_complen);
+		UINT8 selfbits = bits_for_value(max_self);
+		UINT8 parentbits = bits_for_value(max_parent);
+
+		// for each compression type, output the relevant data
+		lastcomp = 0;
+		count = 0;
+		UINT8 *src = compression_rle;
+		UINT64 firstoffs = 0;
+		for (int hunknum = 0; hunknum < m_hunkcount; hunknum++)
+		{
+			UINT8 *rawmap = &m_rawmap[hunknum * 12];
+			UINT32 length = be_read(&rawmap[1], 3);
+			UINT64 offset = be_read(&rawmap[4], 6);
+			UINT16 crc = be_read(&rawmap[10], 2);
 
-		/* compute this entry's hash */
-		sha1_init(&sha1);
-		sha1_update(&sha1, metalength, tempbuffer);
-		sha1_final(&sha1);
-		free(tempbuffer);
+			// if no count remaining, fetch the next entry
+			if (count == 0)
+			{
+				UINT8 val = *src++;
+				if (val == COMPRESSION_RLE_SMALL)
+					count = 2 + *src++;
+				else if (val == COMPRESSION_RLE_LARGE)
+					count = 2 + 16 + (*src++ << 4), count += *src++;
+				else
+					lastcomp = val;
+			}
+			else
+				count--;
 
-		/* expand the hasharray if necessary */
-		if (hashindex >= hashalloc)
-		{
-			hashalloc += 256;
-			hasharray = (metadata_hash *)realloc(hasharray, hashalloc * sizeof(hasharray[0]));
-			if (hasharray == NULL)
+			// output additional data needed for this entry
+			switch (lastcomp)
 			{
-				err = CHDERR_OUT_OF_MEMORY;
-				goto cleanup;
+				case COMPRESSION_TYPE_0:
+				case COMPRESSION_TYPE_1:
+				case COMPRESSION_TYPE_2:
+				case COMPRESSION_TYPE_3:
+					assert(length < (1 << lengthbits));
+					bitbuf.write(length, lengthbits);
+					bitbuf.write(crc, 16);
+					if (firstoffs == 0)
+						firstoffs = offset;
+					break;
+
+				case COMPRESSION_NONE:
+					bitbuf.write(crc, 16);
+					if (firstoffs == 0)
+						firstoffs = offset;
+					break;
+
+				case COMPRESSION_SELF:
+					assert(offset < (UINT64(1) << selfbits));
+					bitbuf.write(offset, selfbits);
+					break;
+
+				case COMPRESSION_PARENT:
+					assert(offset < (UINT64(1) << parentbits));
+					bitbuf.write(offset, parentbits);
+					break;
+
+				case COMPRESSION_SELF_0:
+				case COMPRESSION_SELF_1:
+				case COMPRESSION_PARENT_SELF:
+				case COMPRESSION_PARENT_0:
+				case COMPRESSION_PARENT_1:
+					break;
 			}
 		}
 
-		/* fill in the entry */
-		put_bigendian_uint32(hasharray[hashindex].tag, metatag);
-		sha1_digest(&sha1, SHA1_DIGEST_SIZE, hasharray[hashindex].sha1);
-		hashindex++;
-	}
-
-	/* sort the array */
-	qsort(hasharray, hashindex, sizeof(hasharray[0]), metadata_hash_compare);
-
-	/* compute the SHA1 of the raw plus the various metadata */
-	sha1_init(&sha1);
-	sha1_update(&sha1, CHD_SHA1_BYTES, rawsha1);
-	sha1_update(&sha1, hashindex * sizeof(hasharray[0]), (const UINT8 *)hasharray);
-	sha1_final(&sha1);
-	sha1_digest(&sha1, SHA1_DIGEST_SIZE, finalsha1);
-
-cleanup:
-	if (hasharray != NULL)
-		free(hasharray);
-	return err;
+		// write the map header
+		UINT32 complen = bitbuf.flush();
+		assert(!bitbuf.overflow());
+		be_write(&compressed[0], complen, 4);
+		be_write(&compressed[4], firstoffs, 6);
+		be_write(&compressed[10], mapcrc, 2);
+		compressed[12] = lengthbits;
+		compressed[13] = selfbits;
+		compressed[14] = parentbits;
+
+		// write the result
+		m_mapoffset = file_append(compressed, complen + 16);
+
+		// then write the map offset
+		UINT8 rawbuf[sizeof(UINT64)];
+		be_write(rawbuf, m_mapoffset, 8);
+		file_write(m_mapoffset_offset, rawbuf, sizeof(rawbuf));
+		return CHDERR_NONE;
+	}
+	catch (chd_error &err)
+	{
+		return err;
+	}
 }
 
 
-/*-------------------------------------------------
-    metadata_hash_compare - compare two hash
-    entries
--------------------------------------------------*/
+//-------------------------------------------------
+//  decompress_v5_map - decompress the v5 map
+//-------------------------------------------------
 
-static int CLIB_DECL metadata_hash_compare(const void *elem1, const void *elem2)
+void chd_file::decompress_v5_map()
 {
-	return memcmp(elem1, elem2, sizeof(metadata_hash));
-}
+	// if no offset, we haven't written it yet
+	if (m_mapoffset == 0)
+	{
+		memset(m_rawmap, 0xff, m_rawmap.count());
+		return;
+	}
 
+	// read the reader
+	UINT8 rawbuf[16];
+	file_read(m_mapoffset, rawbuf, sizeof(rawbuf));
+	UINT32 mapbytes = be_read(&rawbuf[0], 4);
+	UINT64 firstoffs = be_read(&rawbuf[4], 6);
+	UINT16 mapcrc = be_read(&rawbuf[10], 2);
+	UINT8 lengthbits = rawbuf[12];
+	UINT8 selfbits = rawbuf[13];
+	UINT8 parentbits = rawbuf[14];
+
+	// now read the map
+	dynamic_buffer compressed(mapbytes);
+	file_read(m_mapoffset + 16, compressed, mapbytes);
+	bitstream_in bitbuf(compressed, compressed.count());
+
+	// first decode the compression types
+	huffman_decoder<16, 8> decoder;
+	huffman_error err = decoder.import_tree_rle(bitbuf);
+	if (err != HUFFERR_NONE)
+		throw CHDERR_DECOMPRESSION_ERROR;
+	UINT8 lastcomp = 0;
+	int repcount = 0;
+	for (int hunknum = 0; hunknum < m_hunkcount; hunknum++)
+	{
+		UINT8 *rawmap = &m_rawmap[hunknum * 12];
+		if (repcount > 0)
+			rawmap[0] = lastcomp, repcount--;
+		else
+		{
+			UINT8 val = decoder.decode_one(bitbuf);
+			if (val == COMPRESSION_RLE_SMALL)
+				rawmap[0] = lastcomp, repcount = 2 + decoder.decode_one(bitbuf);
+			else if (val == COMPRESSION_RLE_LARGE)
+				rawmap[0] = lastcomp, repcount = 2 + 16 + (decoder.decode_one(bitbuf) << 4), repcount += decoder.decode_one(bitbuf);
+			else
+				rawmap[0] = lastcomp = val;
+		}
+	}
 
+	// then iterate through the hunks and extract the needed data
+	UINT64 curoffset = firstoffs;
+	UINT32 last_self = 0;
+	UINT64 last_parent = 0;
+	for (int hunknum = 0; hunknum < m_hunkcount; hunknum++)
+	{
+		UINT8 *rawmap = &m_rawmap[hunknum * 12];
+		UINT64 offset = curoffset;
+		UINT32 length = 0;
+		UINT16 crc = 0;
+		switch (rawmap[0])
+		{
+			// base types
+			case COMPRESSION_TYPE_0:
+			case COMPRESSION_TYPE_1:
+			case COMPRESSION_TYPE_2:
+			case COMPRESSION_TYPE_3:
+				curoffset += length = bitbuf.read(lengthbits);
+				crc = bitbuf.read(16);
+				break;
 
-/***************************************************************************
-    ZLIB COMPRESSION CODEC
-***************************************************************************/
+			case COMPRESSION_NONE:
+				curoffset += length = m_hunkbytes;
+				crc = bitbuf.read(16);
+				break;
 
-/*-------------------------------------------------
-    zlib_codec_init - initialize the ZLIB codec
--------------------------------------------------*/
-
-static chd_error zlib_codec_init(chd_file *chd)
-{
-	zlib_codec_data *data;
-	chd_error err;
-	int zerr;
-
-	/* allocate memory for the 2 stream buffers */
-	data = (zlib_codec_data *)malloc(sizeof(*data));
-	if (data == NULL)
-		return CHDERR_OUT_OF_MEMORY;
-
-	/* clear the buffers */
-	memset(data, 0, sizeof(*data));
-
-	/* init the inflater first */
-	data->inflater.next_in = (Bytef *)data;	/* bogus, but that's ok */
-	data->inflater.avail_in = 0;
-	data->inflater.zalloc = zlib_fast_alloc;
-	data->inflater.zfree = zlib_fast_free;
-	data->inflater.opaque = data;
-	zerr = inflateInit2(&data->inflater, -MAX_WBITS);
-
-	/* if that worked, initialize the deflater */
-	if (zerr == Z_OK)
-	{
-		data->deflater.next_in = (Bytef *)data;	/* bogus, but that's ok */
-		data->deflater.avail_in = 0;
-		data->deflater.zalloc = zlib_fast_alloc;
-		data->deflater.zfree = zlib_fast_free;
-		data->deflater.opaque = data;
-		zerr = deflateInit2(&data->deflater, Z_BEST_COMPRESSION, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY);
-	}
-
-	/* convert errors */
-	if (zerr == Z_MEM_ERROR)
-		err = CHDERR_OUT_OF_MEMORY;
-	else if (zerr != Z_OK)
-		err = CHDERR_CODEC_ERROR;
-	else
-		err = CHDERR_NONE;
+			case COMPRESSION_SELF:
+				last_self = offset = bitbuf.read(selfbits);
+				break;
 
-	/* handle an error */
-	if (err == CHDERR_NONE)
-		chd->codecdata = data;
-	else
-		free(data);
+			case COMPRESSION_PARENT:
+				offset = bitbuf.read(parentbits);
+				last_parent = offset;
+				break;
 
-	return err;
-}
+			// pseudo-types; convert into base types
+			case COMPRESSION_SELF_1:
+				last_self++;
+			case COMPRESSION_SELF_0:
+				rawmap[0] = COMPRESSION_SELF;
+				offset = last_self;
+				break;
 
+			case COMPRESSION_PARENT_SELF:
+				rawmap[0] = COMPRESSION_PARENT;
+				last_parent = offset = (UINT64(hunknum) * UINT64(m_hunkbytes)) / m_unitbytes;
+				break;
 
-/*-------------------------------------------------
-    zlib_codec_free - free data for the ZLIB
-    codec
--------------------------------------------------*/
+			case COMPRESSION_PARENT_1:
+				last_parent += m_hunkbytes / m_unitbytes;
+			case COMPRESSION_PARENT_0:
+				rawmap[0] = COMPRESSION_PARENT;
+				offset = last_parent;
+				break;
+		}
+		be_write(&rawmap[1], length, 3);
+		be_write(&rawmap[4], offset, 6);
+		be_write(&rawmap[10], crc, 2);
+	}
+
+	// verify the final CRC
+	if (crc16_creator::simple(m_rawmap, m_hunkcount * 12) != mapcrc)
+		throw CHDERR_DECOMPRESSION_ERROR;
+}
+
+
+//-------------------------------------------------
+//  create_common - command path when creating a
+//  new CHD file
+//-------------------------------------------------
+
+chd_error chd_file::create_common()
+{
+	// wrap in try for proper error handling
+	try
+	{
+		// if we have a parent, it must be V3 or later
+		if (m_parent != NULL && m_parent->version() < 3)
+			throw CHDERR_UNSUPPORTED_VERSION;
+
+		// must be an even number of units per hunk
+		if (m_hunkbytes % m_unitbytes != 0)
+			throw CHDERR_INVALID_PARAMETER;
+		if (m_parent != NULL && m_unitbytes != m_parent->unit_bytes())
+			throw CHDERR_INVALID_PARAMETER;
+
+		// writes are obviously permitted; reads only if uncompressed
+		m_allow_writes = true;
+		m_allow_reads = !compressed();
+
+		// verify the compression types
+		bool found_zero = false;
+		for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_compression); codecnum++)
+		{
+			// once we hit an empty slot, all later slots must be empty as well
+			if (m_compression[codecnum] == CHD_CODEC_NONE)
+				found_zero = true;
+			else if (found_zero)
+				throw CHDERR_INVALID_PARAMETER;
+			else if (!chd_codec_list::codec_exists(m_compression[codecnum]))
+				throw CHDERR_UNKNOWN_COMPRESSION;
+		}
+
+		// create our V5 header
+		assert(m_version == HEADER_VERSION);
+		UINT8 rawheader[V5_HEADER_SIZE];
+		memcpy(&rawheader[0], "MComprHD", 8);
+		be_write(&rawheader[8], V5_HEADER_SIZE, 4);
+		be_write(&rawheader[12], m_version, 4);
+		be_write(&rawheader[16], m_compression[0], 4);
+		be_write(&rawheader[20], m_compression[1], 4);
+		be_write(&rawheader[24], m_compression[2], 4);
+		be_write(&rawheader[28], m_compression[3], 4);
+		be_write(&rawheader[32], m_logicalbytes, 8);
+		be_write(&rawheader[40], compressed() ? 0 : V5_HEADER_SIZE, 8);
+		be_write(&rawheader[48], m_metaoffset, 8);
+		be_write(&rawheader[56], m_hunkbytes, 4);
+		be_write(&rawheader[60], m_unitbytes, 4);
+		be_write_sha1(&rawheader[64], sha1_t::null);
+		be_write_sha1(&rawheader[84], sha1_t::null);
+		be_write_sha1(&rawheader[104], (m_parent != NULL) ? m_parent->sha1() : sha1_t::null);
+
+		// write the resulting header
+		file_write(0, rawheader, sizeof(rawheader));
+
+		// parse it back out to set up fields appropriately
+		sha1_t parentsha1;
+		parse_v5_header(rawheader, parentsha1);
+
+		// write out the map (if not compressed)
+		if (!compressed())
+		{
+			UINT32 mapsize = m_mapentrybytes * m_hunkcount;
+			UINT8 buffer[4096] = { 0 };
+			UINT64 offset = m_mapoffset;
+			while (mapsize != 0)
+			{
+				UINT32 bytes_to_write = MIN(mapsize, sizeof(buffer));
+				file_write(offset, buffer, bytes_to_write);
+				offset += bytes_to_write;
+				mapsize -= bytes_to_write;
+			}
+		}
 
-static void zlib_codec_free(chd_file *chd)
-{
-	zlib_codec_data *data = (zlib_codec_data *)chd->codecdata;
+		// finish opening the file
+		create_open_common();
+	}
 
-	/* deinit the streams */
-	if (data != NULL)
+	// handle errors by closing ourself
+	catch (chd_error &err)
 	{
-		int i;
-
-		inflateEnd(&data->inflater);
-		deflateEnd(&data->deflater);
-
-		/* free our fast memory */
-		for (i = 0; i < MAX_ZLIB_ALLOCS; i++)
-			if (data->allocptr[i])
-				free(data->allocptr[i]);
-		free(data);
+		close();
+		return err;
+	}
+	catch (...)
+	{
+		close();
+		throw;
 	}
+	return CHDERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    zlib_codec_compress - compress data using the
-    ZLIB codec
--------------------------------------------------*/
+//-------------------------------------------------
+//  open_common - common path when opening an
+//  existing CHD file for input
+//-------------------------------------------------
 
-static chd_error zlib_codec_compress(chd_file *chd, const void *src, UINT32 *length)
+chd_error chd_file::open_common(bool writeable)
 {
-	zlib_codec_data *data = (zlib_codec_data *)chd->codecdata;
-	int zerr;
+	// wrap in try for proper error handling
+	try
+	{
+		// reads are always permitted; writes possibly as well
+		m_allow_reads = true;
+		m_allow_writes = writeable;
 
-	/* reset the decompressor */
-	data->deflater.next_in = (Bytef *)src;
-	data->deflater.avail_in = chd->header.hunkbytes;
-	data->deflater.total_in = 0;
-	data->deflater.next_out = chd->compressed;
-	data->deflater.avail_out = chd->header.hunkbytes;
-	data->deflater.total_out = 0;
-	zerr = deflateReset(&data->deflater);
-	if (zerr != Z_OK)
-		return CHDERR_COMPRESSION_ERROR;
+		// read the raw header
+		UINT8 rawheader[MAX_HEADER_SIZE];
+		file_read(0, rawheader, sizeof(rawheader));
 
-	/* do it */
-	zerr = deflate(&data->deflater, Z_FINISH);
+		// verify the signature
+		if (memcmp(rawheader, "MComprHD", 8) != 0)
+			throw CHDERR_INVALID_FILE;
 
-	/* if we ended up with more data than we started with, return an error */
-	if (zerr != Z_STREAM_END || data->deflater.total_out >= chd->header.hunkbytes)
-		return CHDERR_COMPRESSION_ERROR;
+		// only allow writes to the most recent version
+		m_version = be_read(&rawheader[12], 4);
+		if (m_allow_writes && m_version < HEADER_VERSION)
+			throw CHDERR_UNSUPPORTED_VERSION;
 
-	/* otherwise, fill in the length and return success */
-	*length = data->deflater.total_out;
-	return CHDERR_NONE;
-}
+		// read the header if we support it
+		sha1_t parentsha1 = sha1_t::null;
+		switch (m_version)
+		{
+			case 3:		parse_v3_header(rawheader, parentsha1);	break;
+			case 4:		parse_v4_header(rawheader, parentsha1);	break;
+			case 5:		parse_v5_header(rawheader, parentsha1);	break;
+			default:	throw CHDERR_UNSUPPORTED_VERSION;
+		}
 
+		// make sure we have a parent if we need one (and don't if we don't)
+		if (parentsha1 != sha1_t::null)
+		{
+			if (m_parent == NULL)
+				m_parent_missing = true;
+			else if (m_parent->sha1() != parentsha1)
+				throw CHDERR_INVALID_PARENT;
+		}
+		else if (parentsha1 == sha1_t::null && m_parent != NULL)
+			throw CHDERR_INVALID_PARAMETER;
 
-/*-------------------------------------------------
-    zlib_codec_decompress - decomrpess data using
-    the ZLIB codec
--------------------------------------------------*/
-
-static chd_error zlib_codec_decompress(chd_file *chd, UINT32 srclength, void *dest)
-{
-	zlib_codec_data *data = (zlib_codec_data *)chd->codecdata;
-	int zerr;
-
-	/* reset the decompressor */
-	data->inflater.next_in = chd->compressed;
-	data->inflater.avail_in = srclength;
-	data->inflater.total_in = 0;
-	data->inflater.next_out = (Bytef *)dest;
-	data->inflater.avail_out = chd->header.hunkbytes;
-	data->inflater.total_out = 0;
-	zerr = inflateReset(&data->inflater);
-	if (zerr != Z_OK)
-		return CHDERR_DECOMPRESSION_ERROR;
-
-	/* do it */
-	zerr = inflate(&data->inflater, Z_FINISH);
-	if (data->inflater.total_out != chd->header.hunkbytes)
-		return CHDERR_DECOMPRESSION_ERROR;
+		// finish opening the file
+		create_open_common();
+		return CHDERR_NONE;
+	}
 
-	return CHDERR_NONE;
+	// handle errors by closing ourself
+	catch (chd_error &err)
+	{
+		close();
+		return err;
+	}
 }
 
 
-/*-------------------------------------------------
-    zlib_fast_alloc - fast malloc for ZLIB, which
-    allocates and frees memory frequently
--------------------------------------------------*/
+//-------------------------------------------------
+//  create_open_common - common code for handling
+//  creation and opening of a file
+//-------------------------------------------------
 
-static voidpf zlib_fast_alloc(voidpf opaque, uInt items, uInt size)
+void chd_file::create_open_common()
 {
-	zlib_codec_data *data = (zlib_codec_data *)opaque;
-	UINT32 *ptr;
-	int i;
-
-	/* compute the size, rounding to the nearest 1k */
-	size = (size * items + 0x3ff) & ~0x3ff;
-
-	/* reuse a hunk if we can */
-	for (i = 0; i < MAX_ZLIB_ALLOCS; i++)
+	// verify the compression types and initialize the codecs
+	for (int decompnum = 0; decompnum < ARRAY_LENGTH(m_compression); decompnum++)
 	{
-		ptr = data->allocptr[i];
-		if (ptr && size == *ptr)
-		{
-			/* set the low bit of the size so we don't match next time */
-			*ptr |= 1;
-			return ptr + 1;
-		}
+		m_decompressor[decompnum] = chd_codec_list::new_decompressor(m_compression[decompnum], *this);
+		if (m_decompressor[decompnum] == NULL && m_compression[decompnum] != 0)
+			throw CHDERR_UNKNOWN_COMPRESSION;
 	}
 
-	/* alloc a new one */
-	ptr = (UINT32 *)malloc(size + sizeof(UINT32));
-	if (!ptr)
-		return NULL;
-
-	/* put it into the list */
-	for (i = 0; i < MAX_ZLIB_ALLOCS; i++)
-		if (!data->allocptr[i])
-		{
-			data->allocptr[i] = ptr;
-			break;
-		}
+	// read the map; v5+ compressed drives need to read and decompress their map
+	m_rawmap.resize(m_hunkcount * m_mapentrybytes);
+	if (m_version >= 5 && compressed())
+		decompress_v5_map();
+	else
+		file_read(m_mapoffset, m_rawmap, m_rawmap.count());
 
-	/* set the low bit of the size so we don't match next time */
-	*ptr = size | 1;
-	return ptr + 1;
+	// allocate the temporary compressed buffer and a buffer for caching
+	m_compressed.resize(m_hunkbytes);
+	m_cache.resize(m_hunkbytes);
 }
 
 
-/*-------------------------------------------------
-    zlib_fast_free - fast free for ZLIB, which
-    allocates and frees memory frequently
--------------------------------------------------*/
+//-------------------------------------------------
+//  verify_proper_compression_append - verify that
+//  the given hunk is a proper candidate for
+//  appending to a compressed CHD
+//-------------------------------------------------
 
-static void zlib_fast_free(voidpf opaque, voidpf address)
+void chd_file::verify_proper_compression_append(UINT32 hunknum)
 {
-	zlib_codec_data *data = (zlib_codec_data *)opaque;
-	UINT32 *ptr = (UINT32 *)address - 1;
-	int i;
+	// punt if no file
+	if (m_file == NULL)
+		throw CHDERR_NOT_OPEN;
 
-	/* find the hunk */
-	for (i = 0; i < MAX_ZLIB_ALLOCS; i++)
-		if (ptr == data->allocptr[i])
-		{
-			/* clear the low bit of the size to allow matches */
-			*ptr &= ~1;
-			return;
-		}
-}
+	// return an error if out of range
+	if (hunknum >= m_hunkcount)
+		throw CHDERR_HUNK_OUT_OF_RANGE;
 
-/*-------------------------------------------------
-    flac_codec_compress - compress data using the
-    FLAC codec
--------------------------------------------------*/
+	// if not writeable, fail
+	if (!m_allow_writes)
+		throw CHDERR_FILE_NOT_WRITEABLE;
 
+	// compressed writes only via this interface
+	if (!compressed())
+		throw CHDERR_FILE_NOT_WRITEABLE;
 
-const int INITIAL_BUFFER_SIZE = 0x20000;
-const int INITIAL_GROW_SIZE = 0x20000;
+	// only permitted to write new blocks
+	UINT8 *rawmap = &m_rawmap[hunknum * 12];
+	if (rawmap[0] != 0xff)
+		throw CHDERR_COMPRESSION_ERROR;
 
+	// if this isn't the first block, only permitted to write immediately
+	// after the previous one
+	if (hunknum != 0 && rawmap[-12] == 0xff)
+		throw CHDERR_COMPRESSION_ERROR;
+}
 
-struct flac_encoder_data
-{
-	FLAC__int32* pcm;
-	FLAC__byte* tempbuffer;
-	UINT8* flac_outputbuffer;
-	size_t flac_outputbuffer_size;
-	FLAC__uint64 flac_output_buffer_curpos;
-	FLAC__uint64 flac_output_buffer_total;
-};
 
-static FLAC__StreamEncoderWriteStatus flac_encoder_write_callback(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)
-{
-	if (((flac_encoder_data*)client_data)->flac_output_buffer_curpos + bytes >= ((flac_encoder_data*)client_data)->flac_outputbuffer_size)
-	{
-		((flac_encoder_data*)client_data)->flac_outputbuffer = (UINT8*)realloc(((flac_encoder_data*)client_data)->flac_outputbuffer, ((flac_encoder_data*)client_data)->flac_outputbuffer_size+INITIAL_GROW_SIZE);
-		((flac_encoder_data*)client_data)->flac_outputbuffer_size = ((flac_encoder_data*)client_data)->flac_outputbuffer_size+INITIAL_GROW_SIZE;
-	}
+//-------------------------------------------------
+//  hunk_write_compressed - write a hunk to a
+//  compressed CHD, discovering the best
+//  technique
+//-------------------------------------------------
 
-	memcpy(((flac_encoder_data*)client_data)->flac_outputbuffer+((flac_encoder_data*)client_data)->flac_output_buffer_curpos, buffer, bytes);
-	if (((flac_encoder_data*)client_data)->flac_output_buffer_curpos+bytes > ((flac_encoder_data*)client_data)->flac_output_buffer_total)
-		((flac_encoder_data*)client_data)->flac_output_buffer_total=((flac_encoder_data*)client_data)->flac_output_buffer_curpos+bytes;
+void chd_file::hunk_write_compressed(UINT32 hunknum, INT8 compression, const UINT8 *compressed, UINT32 complength, crc16_t crc16)
+{
+	// verify that we are appending properly to a compressed file
+	verify_proper_compression_append(hunknum);
 
-	((flac_encoder_data*)client_data)->flac_output_buffer_curpos+=bytes;
+	// write the final result
+	UINT64 offset = file_append(compressed, complength);
 
-	return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
+	// update the map entry
+	UINT8 *rawmap = &m_rawmap[hunknum * 12];
+	rawmap[0] = (compression == -1) ? COMPRESSION_NONE : compression;
+	be_write(&rawmap[1], complength, 3);
+	be_write(&rawmap[4], offset, 6);
+	be_write(&rawmap[10], crc16, 2);
 }
 
-#define FLAC_HEADER_SIZE (86)
 
-static chd_error flac_codec_compress(chd_file *chd, const void *src, UINT32 *length, int swap)
+//-------------------------------------------------
+//  hunk_copy_from_self - mark a hunk as being a
+//  copy of another hunk in the same CHD
+//-------------------------------------------------
+
+void chd_file::hunk_copy_from_self(UINT32 hunknum, UINT32 otherhunk)
 {
-	int FLAC_ENCODER_READSIZE = (CD_MAX_SECTOR_DATA/4);
-	int FLAC_ENCODER_FULLSIZE = ((CD_MAX_SECTOR_DATA+CD_MAX_SUBCODE_DATA)/4);
+	// verify that we are appending properly to a compressed file
+	verify_proper_compression_append(hunknum);
 
-	flac_encoder_data flac_encoder_client;
-	flac_encoder_data* flac_encoder_client_ptr = &flac_encoder_client;
-	flac_encoder_client_ptr->flac_outputbuffer = (UINT8*)malloc(INITIAL_BUFFER_SIZE);
-	flac_encoder_client_ptr->flac_outputbuffer_size = INITIAL_BUFFER_SIZE;
-	flac_encoder_client_ptr->flac_output_buffer_curpos = 0;
-	flac_encoder_client_ptr->flac_output_buffer_total = 0;
-	flac_encoder_client_ptr->pcm=(FLAC__int32*)malloc(FLAC_ENCODER_READSIZE * 2 * 4);
-	flac_encoder_client_ptr->tempbuffer=(FLAC__byte*)malloc(FLAC_ENCODER_READSIZE * 2 * 2);
+	// only permitted to reference prior hunks
+	if (otherhunk >= hunknum)
+		throw CHDERR_INVALID_PARAMETER;
 
+	// update the map entry
+	UINT8 *rawmap = &m_rawmap[hunknum * 12];
+	rawmap[0] = COMPRESSION_SELF;
+	be_write(&rawmap[1], 0, 3);
+	be_write(&rawmap[4], otherhunk, 6);
+	be_write(&rawmap[10], 0, 2);
+}
 
 
-	FLAC__StreamEncoder *encoder = 0;
-	FLAC__bool ok = true;
+//-------------------------------------------------
+//  hunk_copy_from_parent - mark a hunk as being a
+//  copy of a hunk from a parent CHD
+//-------------------------------------------------
 
-	if((encoder = FLAC__stream_encoder_new()) == NULL)
-	{
-		printf("ERROR: allocating encoder\n");
-		return CHDERR_COMPRESSION_ERROR;
-	}
+void chd_file::hunk_copy_from_parent(UINT32 hunknum, UINT64 parentunit)
+{
+	// verify that we are appending properly to a compressed file
+	verify_proper_compression_append(hunknum);
 
-	ok &= FLAC__stream_encoder_set_verify(encoder, false); // we trust libFLAC ;-)
-	ok &= FLAC__stream_encoder_set_compression_level(encoder, 8);
-	ok &= FLAC__stream_encoder_set_channels(encoder, 2);
-	ok &= FLAC__stream_encoder_set_bits_per_sample(encoder, 16);
-	ok &= FLAC__stream_encoder_set_sample_rate(encoder, 44100);
-	ok &= FLAC__stream_encoder_set_total_samples_estimate(encoder, 0);
-	ok &= FLAC__stream_encoder_set_streamable_subset(encoder, false);
-	ok &= FLAC__stream_encoder_set_blocksize(encoder, ((CD_MAX_SECTOR_DATA)*CD_FRAMES_PER_HUNK)/4 ); // /4 because this is in SAMPLES, not bytes
+	// update the map entry
+	UINT8 *rawmap = &m_rawmap[hunknum * 12];
+	rawmap[0] = COMPRESSION_PARENT;
+	be_write(&rawmap[1], 0, 3);
+	be_write(&rawmap[4], parentunit, 6);
+	be_write(&rawmap[10], 0, 2);
+}
 
-	if (!ok)
-	{
-		printf("error setting up stream encoder\n");
-		return CHDERR_COMPRESSION_ERROR;
-	}
 
-	if  (FLAC__stream_encoder_init_stream(encoder, flac_encoder_write_callback, NULL, NULL, NULL, flac_encoder_client_ptr)  != FLAC__STREAM_ENCODER_INIT_STATUS_OK)
+//-------------------------------------------------
+//  metadata_find - find a metadata entry
+//-------------------------------------------------
+
+bool chd_file::metadata_find(chd_metadata_tag metatag, INT32 metaindex, metadata_entry &metaentry, bool resume)
+{
+	// start at the beginning unless we're resuming a previous search
+	if (!resume)
 	{
-		printf("error initializing encoder\n");
-		return CHDERR_COMPRESSION_ERROR;
+		metaentry.offset = m_metaoffset;
+		metaentry.prev = 0;
 	}
-
-	size_t left = (size_t)chd->header.hunkbytes;
-	UINT8* srcdata = (UINT8*)src;
-
-	while(ok && left)
+	else
 	{
-		memcpy(flac_encoder_client_ptr->tempbuffer, srcdata, FLAC_ENCODER_READSIZE*4);
-		srcdata += FLAC_ENCODER_FULLSIZE*4;
-		{
-			size_t i;
-			for(i = 0; i < FLAC_ENCODER_READSIZE*2; i++)
-			{
-				if (!swap) flac_encoder_client_ptr->pcm[i] = (FLAC__int32)(((FLAC__int16)(FLAC__int8)flac_encoder_client_ptr->tempbuffer[2*i] << 8) | (FLAC__int16)flac_encoder_client_ptr->tempbuffer[2*i+1]);
-				else       flac_encoder_client_ptr->pcm[i] = (FLAC__int32)(((FLAC__int16)(FLAC__int8)flac_encoder_client_ptr->tempbuffer[2*i+1] << 8) | (FLAC__int16)flac_encoder_client_ptr->tempbuffer[2*i]);
-			}
-
-			ok = FLAC__stream_encoder_process_interleaved(encoder, flac_encoder_client_ptr->pcm, FLAC_ENCODER_READSIZE);
-		}
-
-
-		left -= (FLAC_ENCODER_FULLSIZE*4);
+		metaentry.prev = metaentry.offset;
+		metaentry.offset = metaentry.next;
 	}
 
-	if (!ok)
+	// loop until we run out of options
+	while (metaentry.offset != 0)
 	{
-		printf("error encoding!\n");
-		return CHDERR_COMPRESSION_ERROR;
-	}
+		// read the raw header
+		UINT8 raw_meta_header[METADATA_HEADER_SIZE];
+		file_read(metaentry.offset, raw_meta_header, sizeof(raw_meta_header));
 
-	ok &= FLAC__stream_encoder_finish(encoder);
+		// extract the data
+		metaentry.metatag = be_read(&raw_meta_header[0], 4);
+		metaentry.flags = raw_meta_header[4];
+		metaentry.length = be_read(&raw_meta_header[5], 3);
+		metaentry.next = be_read(&raw_meta_header[8], 8);
 
-	if (!ok)
-	{
-		printf("error finishing!\n");
-		return CHDERR_COMPRESSION_ERROR;
+		// if we got a match, proceed
+		if (metatag == CHDMETATAG_WILDCARD || metaentry.metatag == metatag)
+			if (metaindex-- == 0)
+				return true;
+
+		// no match, fetch the next link
+		metaentry.prev = metaentry.offset;
+		metaentry.offset = metaentry.next;
 	}
 
-	int totalout = flac_encoder_client_ptr->flac_output_buffer_total-FLAC_HEADER_SIZE;
+	// if we get here, we didn't find it
+	return false;
+}
 
 
+//-------------------------------------------------
+//  metadata_set_previous_next - set the 'next'
+//  offset of a piece of metadata
+//-------------------------------------------------
 
-	FLAC__stream_encoder_delete(encoder);
+void chd_file::metadata_set_previous_next(UINT64 prevoffset, UINT64 nextoffset)
+{
+	UINT64 offset = 0;
 
-	if (totalout >= chd->header.hunkbytes)
+	// if we were the first entry, make the next entry the first
+	if (prevoffset == 0)
 	{
-		free(flac_encoder_client_ptr->flac_outputbuffer);
-		return CHDERR_COMPRESSION_ERROR;
+		offset = m_metaoffset_offset;
+		m_metaoffset = nextoffset;
 	}
 
-	*length = totalout;
-	memcpy(chd->compressed, flac_encoder_client_ptr->flac_outputbuffer+FLAC_HEADER_SIZE, flac_encoder_client_ptr->flac_output_buffer_total-FLAC_HEADER_SIZE);
+	// otherwise, update the link in the previous header
+	else
+		offset = prevoffset + 8;
 
-	free(flac_encoder_client_ptr->flac_outputbuffer);
-	free(flac_encoder_client_ptr->pcm);
-	free(flac_encoder_client_ptr->tempbuffer);
-	return CHDERR_NONE;
-}
+	// create a big-endian version
+	UINT8 rawbuf[sizeof(UINT64)];
+	be_write(rawbuf, nextoffset, 8);
 
-static chd_error flac_codec_compress_normal(chd_file *chd, const void *src, UINT32 *length)
-{
-	return flac_codec_compress(chd, src, length, 0);
+	// write to the header and update our local copy
+	file_write(offset, rawbuf, sizeof(rawbuf));
 }
 
-// this data is always the same for our blocks, so don't store it in the file.
-static UINT8 flacHeader[FLAC_HEADER_SIZE] = {
-	0x66, 0x4C, 0x61, 0x43, 0x00, 0x00, 0x00, 0x22, 0x12, 0x60, 0x12, 0x60,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xC4, 0x42, 0xF0, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x28, 0x20, 0x00,
-	0x00, 0x00, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20,
-	0x6C, 0x69, 0x62, 0x46, 0x4C, 0x41, 0x43, 0x20, 0x31, 0x2E, 0x32, 0x2E,
-	0x31, 0x20, 0x32, 0x30, 0x30, 0x37, 0x30, 0x39, 0x31, 0x37, 0x00, 0x00,
-	0x00, 0x00,
-};
-/*-------------------------------------------------
-    flac_codec_decompress - decomrpess data using
-    the FLAC codec
--------------------------------------------------*/
 
+//-------------------------------------------------
+//  metadata_update_hash - compute the SHA1
+//  hash of all metadata that requests it
+//-------------------------------------------------
 
-struct flac_decoder_data
+void chd_file::metadata_update_hash()
 {
-	int readoffset;
-	size_t readbuffersize;
-	UINT8* readbuffer;
+	// only works for V4 and above, and only for compressed CHDs
+	if (m_version < 4 || !compressed())
+		return;
 
-	int writeoffset;
-	INT16 tempbuffer[(CD_MAX_SECTOR_DATA * CD_FRAMES_PER_HUNK)/2];
-	UINT64 amount_to_decode;
-};
+	// compute the new overall hash
+	sha1_t fullsha1 = compute_overall_sha1(raw_sha1());
 
-FLAC__StreamDecoderWriteStatus flac_decoder_write_callback(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 *const buffer[], void *client_data)
-{
+	// create a big-endian version
+	UINT8 rawbuf[sizeof(sha1_t)];
+	be_write_sha1(&rawbuf[0], fullsha1);
 
-	int blocksize = frame->header.blocksize;
-	int i = 0;
-	while (blocksize && ((flac_decoder_data*)client_data)->amount_to_decode)
-	{
-		((flac_decoder_data*)client_data)->tempbuffer[(((flac_decoder_data*)client_data)->writeoffset*2)+0] = buffer[0][i];
-		((flac_decoder_data*)client_data)->tempbuffer[(((flac_decoder_data*)client_data)->writeoffset*2)+1] =  buffer[1][i];
+	// write to the header
+	file_write(m_sha1_offset, rawbuf, sizeof(rawbuf));
+}
 
-		blocksize--;
-		i++;
-		((flac_decoder_data*)client_data)->amount_to_decode-=4;
-		((flac_decoder_data*)client_data)->writeoffset++;
-	}
 
-	return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
-}
+//-------------------------------------------------
+//  metadata_hash_compare - compare two hash
+//  entries
+//-------------------------------------------------
 
-FLAC__StreamDecoderReadStatus flac_decoder_read_callback(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
+int CLIB_DECL chd_file::metadata_hash_compare(const void *elem1, const void *elem2)
 {
-	size_t readsize = *bytes;
-	size_t readbuffersize = ((flac_decoder_data*)client_data)->readbuffersize;
+	return memcmp(elem1, elem2, sizeof(metadata_hash));
+}
+
 
-	if ((((flac_decoder_data*)client_data)->readoffset + readsize) > readbuffersize)
-	{
-		readsize = ((flac_decoder_data*)client_data)->readbuffersize-((flac_decoder_data*)client_data)->readoffset;
-	}
 
-	if (readsize==0) return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
+//**************************************************************************
+//  CHD COMPRESSOR
+//**************************************************************************
 
-	memcpy(buffer, ((flac_decoder_data*)client_data)->readbuffer+((flac_decoder_data*)client_data)->readoffset, readsize);
+//-------------------------------------------------
+//  chd_file_compressor - constructor
+//-------------------------------------------------
 
-	((flac_decoder_data*)client_data)->readoffset += readsize;
+chd_file_compressor::chd_file_compressor()
+	: m_walking_parent(false),
+	  m_total_in(0),
+	  m_total_out(0),
+	  m_read_queue(NULL),
+	  m_read_queue_offset(0),
+	  m_read_done_offset(0),
+	  m_read_error(false),
+	  m_work_queue(NULL),
+	  m_write_hunk(0)
+{
+	// zap arrays
+	memset(m_work_item, 0, sizeof(m_work_item));
+	memset(m_codecs, 0, sizeof(m_codecs));
 
-	return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+	// allocate work queues
+	m_read_queue = osd_work_queue_alloc(WORK_QUEUE_FLAG_IO);
+	m_work_queue = osd_work_queue_alloc(WORK_QUEUE_FLAG_MULTI);
 }
 
 
+//-------------------------------------------------
+//  ~chd_file_compressor - destructor
+//-------------------------------------------------
 
-void flac_decoder_metadata_callback(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)
+chd_file_compressor::~chd_file_compressor()
 {
+	// free the work queues
+	osd_work_queue_free(m_read_queue);
+	osd_work_queue_free(m_work_queue);
 
+	// delete allocated arrays
+	for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_codecs); codecnum++)
+		delete m_codecs[codecnum];
 }
 
-void flac_decoder_error_callback(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)
-{
 
-}
+//-------------------------------------------------
+//  compress_begin - initiate compression
+//-------------------------------------------------
 
-static chd_error flac_codec_decompress(chd_file *chd, UINT32 srclength, void *dest)
+void chd_file_compressor::compress_begin()
 {
-	FLAC__StreamDecoder *decoder = FLAC__stream_decoder_new();
-	flac_decoder_data flac_decoder_client;
-	flac_decoder_data* flac_decoder_client_ptr = &flac_decoder_client;
-
-	flac_decoder_client_ptr->readoffset = 0;
+	// reset state
+	m_walking_parent = (m_parent != NULL);
+	m_total_in = 0;
+	m_total_out = 0;
+	m_compsha1.reset();
 
-	flac_decoder_client_ptr->readbuffersize = srclength+FLAC_HEADER_SIZE;
-	flac_decoder_client_ptr->readbuffer = (UINT8*)malloc(flac_decoder_client_ptr->readbuffersize);
-	flac_decoder_client_ptr->amount_to_decode =  (CD_MAX_SECTOR_DATA*CD_FRAMES_PER_HUNK);
-	int frames_to_decode = flac_decoder_client_ptr->amount_to_decode / CD_MAX_SECTOR_DATA;
+	// reset our maps
+	m_parent_map.reset();
+	m_current_map.reset();
 
-	flac_decoder_client_ptr->writeoffset = 0;
+	// reset read state
+	m_read_queue_offset = 0;
+	m_read_done_offset = 0;
+	m_read_error = false;
 
-	memcpy(flac_decoder_client_ptr->readbuffer, flacHeader, FLAC_HEADER_SIZE);
-	memcpy(flac_decoder_client_ptr->readbuffer+FLAC_HEADER_SIZE, chd->compressed, srclength);
-
-	if (!decoder)
+	// reset work item state
+	m_work_buffer.resize(hunk_bytes() * (WORK_BUFFER_HUNKS + 1));
+	m_compressed_buffer.resize(hunk_bytes() * WORK_BUFFER_HUNKS);
+	for (int itemnum = 0; itemnum < WORK_BUFFER_HUNKS; itemnum++)
 	{
-		printf("unable to create FLAC decoder\n");
-		return CHDERR_READ_ERROR;
+		work_item &item = m_work_item[itemnum];
+		item.m_compressor = this;
+		item.m_data = m_work_buffer + hunk_bytes() * itemnum;
+		item.m_compressed = m_compressed_buffer + hunk_bytes() * itemnum;
+		item.m_hash.resize(hunk_bytes() / unit_bytes());
 	}
 
-	if(FLAC__stream_decoder_init_stream(
-		decoder,
-		flac_decoder_read_callback,
-		NULL,
-		NULL,
-		NULL,
-		NULL,
-		flac_decoder_write_callback,
-		flac_decoder_metadata_callback,
-		flac_decoder_error_callback,
-		flac_decoder_client_ptr ) != FLAC__STREAM_DECODER_INIT_STATUS_OK)
+	// initialize codec instances
+	for (int instance = 0; instance < ARRAY_LENGTH(m_codecs); instance++)
 	{
-		printf("unable to init FLAC decoder\n");
-		return CHDERR_READ_ERROR;
+		delete m_codecs[instance];
+		m_codecs[instance] = new chd_compressor_group(*this, m_compression);
 	}
 
-	if (FLAC__stream_decoder_process_until_end_of_metadata(decoder) != FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM)
-	{
-		printf("Fail FLAC__stream_decoder_process_until_end_of_metadata\n");
-		return CHDERR_READ_ERROR;
-	}
+	// reset write state
+	m_write_hunk = 0;
+}
+
+
+//-------------------------------------------------
+//  compress_continue - continue compression
+//-------------------------------------------------
 
-	/* only ever a single frame */
-	if (FLAC__stream_decoder_process_single(decoder) != FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM)
+chd_error chd_file_compressor::compress_continue(double &progress, double &ratio)
+{
+	// if done reading, queue some more
+	while (m_read_queue_offset < m_logicalbytes && osd_work_queue_items(m_read_queue) < 2)
 	{
-		printf("Fail FLAC__stream_decoder_process_until_end_of_metadata\n");
-		return CHDERR_READ_ERROR;
-	}
+		// if we got an error, return an error
+		if (m_read_error)
+			return CHDERR_READ_ERROR;
+
+		// see if we have enough free work items to read the next half of a buffer
+		UINT32 startitem = m_read_queue_offset / hunk_bytes();
+		UINT32 enditem = startitem + WORK_BUFFER_HUNKS / 2;
+		UINT32 curitem;
+		for (curitem = startitem; curitem < enditem; curitem++)
+			if (m_work_item[curitem % WORK_BUFFER_HUNKS].m_status != WS_READY)
+				break;
+
+		// if it's not all clear, defer
+		if (curitem != enditem)
+			break;
+
+		// if we're walking the parent, we want one more item to have cleared so we
+		// can read an extra hunk there
+		if (m_walking_parent && m_work_item[curitem % WORK_BUFFER_HUNKS].m_status != WS_READY)
+			break;
 
+		// queue the next read
+		for (curitem = startitem; curitem < enditem; curitem++)
+			m_work_item[curitem % WORK_BUFFER_HUNKS].m_status = WS_READING;
+		osd_work_item_queue(m_read_queue, async_read_static, this, WORK_ITEM_FLAG_AUTO_RELEASE);
+		m_read_queue_offset += WORK_BUFFER_HUNKS * hunk_bytes() / 2;
+	}
 
-	int srcoffset = 0;
-	UINT8* dest2 = (UINT8*)dest;
-	for (int frame = 0; frame<frames_to_decode;frame++)
+	// flush out any finished items
+	while (m_work_item[m_write_hunk % WORK_BUFFER_HUNKS].m_status == WS_COMPLETE)
 	{
-		int destoffset = frame * (CD_FRAME_SIZE);
+		work_item &item = m_work_item[m_write_hunk % WORK_BUFFER_HUNKS];
 
+		// free any OSD work item
+		if (item.m_osd != NULL)
+			osd_work_item_release(item.m_osd);
+		item.m_osd = NULL;
 
-		int index;
+		// for parent walking, just add to the hashmap
+		if (m_walking_parent)
+		{
+			UINT32 uph = hunk_bytes() / unit_bytes();
+			UINT32 units = uph;
+			if (item.m_hunknum == hunk_count() - 1 || !compressed())
+				units = 1;
+			for (UINT32 unit = 0; unit < units; unit++)
+				if (m_parent_map.find(item.m_hash[unit].m_crc16, item.m_hash[unit].m_sha1) == hashmap::NOT_FOUND)
+					m_parent_map.add(item.m_hunknum * uph + unit, item.m_hash[unit].m_crc16, item.m_hash[unit].m_sha1);
+		}
 
-		for (index = 0; index < 2352; index += 2 )
+		// if we're uncompressed, use regular writes
+		else if (!compressed())
 		{
-			dest2[ destoffset + index +1 ] = flac_decoder_client_ptr->tempbuffer[srcoffset] & 0xff;
-			dest2[ destoffset + index ] = flac_decoder_client_ptr->tempbuffer[srcoffset] >> 8;
+			chd_error err = write_hunk(item.m_hunknum, item.m_data);
+			if (err != CHDERR_NONE)
+				return err;
 
-			srcoffset++;
+			// writes of all-0 data don't actually take space, so see if we count this
+			chd_codec_type codec = CHD_CODEC_NONE;
+			UINT32 complen;
+			hunk_info(item.m_hunknum, codec, complen);
+			if (codec == CHD_CODEC_NONE)
+				m_total_out += m_hunkbytes;
 		}
-	}
 
+		// for compressing, process the result
+		else do
+		{
+			// first see if the hunk is in the parent or self maps
+			UINT64 selfhunk = m_current_map.find(item.m_hash[0].m_crc16, item.m_hash[0].m_sha1);
+			if (selfhunk != hashmap::NOT_FOUND)
+			{
+				hunk_copy_from_self(item.m_hunknum, selfhunk);
+				break;
+			}
 
-	if (FLAC__stream_decoder_finish (decoder) != true)
-	{
-		printf("unable to finish FLAC decoder\n");
-		return CHDERR_READ_ERROR;
-	}
+			// if not, see if it's in the parent map
+			if (m_parent != NULL)
+			{
+				UINT64 parentunit = m_parent_map.find(item.m_hash[0].m_crc16, item.m_hash[0].m_sha1);
+				if (parentunit != hashmap::NOT_FOUND)
+				{
+					hunk_copy_from_parent(item.m_hunknum, parentunit);
+					break;
+				}
+			}
 
-	FLAC__stream_decoder_delete(decoder);
-	free(flac_decoder_client_ptr->readbuffer);
+			// otherwise, append it compressed and add to the self map
+			hunk_write_compressed(item.m_hunknum, item.m_compression, item.m_compressed, item.m_complen, item.m_hash[0].m_crc16);
+			m_total_out += item.m_complen;
+			m_current_map.add(item.m_hunknum, item.m_hash[0].m_crc16, item.m_hash[0].m_sha1);
+		} while (0);
+
+		// reset the item and advance
+		item.m_status = WS_READY;
+		m_write_hunk++;
 
-	return CHDERR_NONE;
-}
+		// if we hit the end, finalize
+		if (m_write_hunk == m_hunkcount)
+		{
+			// if this is just walking the parent, reset and get ready for compression
+			if (m_walking_parent)
+			{
+				m_walking_parent = false;
+				m_read_queue_offset = m_read_done_offset = 0;
+				m_write_hunk = 0;
+				for (int itemnum = 0; itemnum < WORK_BUFFER_HUNKS; itemnum++)
+					m_work_item[itemnum].m_status = WS_READY;
+			}
 
+			// wait for all reads to finish and if we're compressed, write the final SHA1 and map
+			else
+			{
+				osd_work_queue_wait(m_read_queue, 30 * osd_ticks_per_second());
+				if (!compressed())
+					return CHDERR_NONE;
+				set_raw_sha1(m_compsha1.finish());
+				return compress_v5_map();
+			}
+		}
+	}
 
+	// update progress and ratio
+	if (m_walking_parent)
+		progress = double(m_read_done_offset) / double(logical_bytes());
+	else
+		progress = double(m_write_hunk) / double(m_hunkcount);
+	ratio = (m_total_in == 0) ? 1.0 : double(m_total_out) / double(m_total_in);
 
+	// if we're waiting for work, wait
+	while (m_work_item[m_write_hunk % WORK_BUFFER_HUNKS].m_status != WS_COMPLETE && m_work_item[m_write_hunk % WORK_BUFFER_HUNKS].m_osd != NULL)
+		osd_work_item_wait(m_work_item[m_write_hunk % WORK_BUFFER_HUNKS].m_osd, osd_ticks_per_second());
+
+	return m_walking_parent ? CHDERR_WALKING_PARENT : CHDERR_COMPRESSING;
+}
 
-/***************************************************************************
-    AV COMPRESSION CODEC
-***************************************************************************/
 
-/*-------------------------------------------------
-    av_raw_data_size - compute the raw data size
--------------------------------------------------*/
+//-------------------------------------------------
+//  async_walk_parent - handle asynchronous parent
+//  walking operations
+//-------------------------------------------------
 
-INLINE UINT32 av_raw_data_size(const UINT8 *data)
+void *chd_file_compressor::async_walk_parent_static(void *param, int threadid)
 {
-	int size = 0;
+	work_item *item = reinterpret_cast<work_item *>(param);
+	item->m_compressor->async_walk_parent(*item);
+	return NULL;
+}
 
-	/* make sure we have a correct header */
-	if (data[0] == 'c' && data[1] == 'h' && data[2] == 'a' && data[3] == 'v')
+void chd_file_compressor::async_walk_parent(work_item &item)
+{
+	// compute CRC-16 and SHA-1 hashes for each unit, unless we're the last one or we're uncompressed
+	UINT32 units = hunk_bytes() / unit_bytes();
+	if (item.m_hunknum == m_hunkcount - 1 || !compressed())
+		units = 1;
+	for (UINT32 unit = 0; unit < units; unit++)
 	{
-		/* add in header size plus metadata length */
-		size = 12 + data[4];
-
-		/* add in channels * samples */
-		size += 2 * data[5] * ((data[6] << 8) + data[7]);
-
-		/* add in 2 * width * height */
-		size += 2 * ((data[8] << 8) + data[9]) * (((data[10] << 8) + data[11]) & 0x7fff);
+		item.m_hash[unit].m_crc16 = crc16_creator::simple(item.m_data + unit * unit_bytes(), hunk_bytes());
+		item.m_hash[unit].m_sha1 = sha1_creator::simple(item.m_data + unit * unit_bytes(), hunk_bytes());
 	}
-	return size;
+	item.m_status = WS_COMPLETE;
 }
 
 
-/*-------------------------------------------------
-    av_codec_init - initialize the A/V codec
--------------------------------------------------*/
+//-------------------------------------------------
+//  async_compress_hunk - handle asynchronous
+//  hunk compression
+//-------------------------------------------------
+
+void *chd_file_compressor::async_compress_hunk_static(void *param, int threadid)
+{
+	work_item *item = reinterpret_cast<work_item *>(param);
+	item->m_compressor->async_compress_hunk(*item, threadid);
+	return NULL;
+}
 
-static chd_error av_codec_init(chd_file *chd)
+void chd_file_compressor::async_compress_hunk(work_item &item, int threadid)
 {
-	av_codec_data *data;
+	// use our thread's codec
+	assert(threadid < ARRAY_LENGTH(m_codecs));
+	item.m_codecs = m_codecs[threadid];
 
-	/* allocate memory for the 2 stream buffers */
-	data = new(std::nothrow) av_codec_data;
-	if (data == NULL)
-		return CHDERR_OUT_OF_MEMORY;
+	// compute CRC-16 and SHA-1 hashes
+	item.m_hash[0].m_crc16 = crc16_creator::simple(item.m_data, hunk_bytes());
+	item.m_hash[0].m_sha1 = sha1_creator::simple(item.m_data, hunk_bytes());
 
-	/* clear the buffers */
-	chd->codecdata = data;
+	// find the best compression scheme, unless we already have a self or parent match
+	// (note we may miss a self match from blocks not yet added, but this just results in extra work)
+	if (m_current_map.find(item.m_hash[0].m_crc16, item.m_hash[0].m_sha1) == hashmap::NOT_FOUND &&
+		m_parent_map.find(item.m_hash[0].m_crc16, item.m_hash[0].m_sha1) == hashmap::NOT_FOUND)
+		item.m_compression = item.m_codecs->find_best_compressor(item.m_data, item.m_compressed, item.m_complen);
 
-	/* attempt to do a post-init now; if we're creating a new CHD, this won't work */
-	/* but that's ok */
-	av_codec_postinit(chd);
-	return CHDERR_NONE;
+	// mark us complete
+	item.m_status = WS_COMPLETE;
 }
 
 
-/*-------------------------------------------------
-    av_codec_free - free data for the A/V
-    codec
--------------------------------------------------*/
+//-------------------------------------------------
+//  async_read - handle asynchronous source file
+//  reading
+//-------------------------------------------------
 
-static void av_codec_free(chd_file *chd)
+void *chd_file_compressor::async_read_static(void *param, int threadid)
 {
-	av_codec_data *data = (av_codec_data *)chd->codecdata;
-
-	/* deinit avcomp */
-	if (data != NULL)
-	{
-		if (data->compstate != NULL)
-			avcomp_free(data->compstate);
-		delete data;
-	}
+	reinterpret_cast<chd_file_compressor *>(param)->async_read();
+	return NULL;
 }
 
+void chd_file_compressor::async_read()
+{
+	// if in the error or complete state, stop
+	if (m_read_error)
+		return;
 
-/*-------------------------------------------------
-    av_codec_compress - compress data using the
-    A/V codec
--------------------------------------------------*/
+	// determine parameters for the read
+	UINT32 work_buffer_bytes = WORK_BUFFER_HUNKS * hunk_bytes();
+	UINT32 numbytes = work_buffer_bytes / 2;
+	if (m_read_done_offset + numbytes > logical_bytes())
+		numbytes = logical_bytes() - m_read_done_offset;
+
+	// catch any exceptions coming out of here
+	try
+	{
+		// do the read
+		UINT8 *dest = m_work_buffer + (m_read_done_offset % work_buffer_bytes);
+		assert(dest == m_work_buffer || dest == m_work_buffer + work_buffer_bytes/2);
+		UINT64 end_offset = m_read_done_offset + numbytes;
 
-static chd_error av_codec_compress(chd_file *chd, const void *src, UINT32 *length)
-{
-	av_codec_data *data = (av_codec_data *)chd->codecdata;
-	int averr;
-	int size;
+		// if walking the parent, read in hunks from the parent CHD
+		if (m_walking_parent)
+		{
+			UINT8 *curdest = dest;
+			for (UINT64 curoffs = m_read_done_offset; curoffs < end_offset + 1; curoffs += hunk_bytes())
+			{
+				m_parent->read_hunk(curoffs / hunk_bytes(), curdest);
+				curdest += hunk_bytes();
+			}
+		}
 
-	/* if we haven't yet set up the avcomp code, do it now */
-	if (data->compstate == NULL)
-	{
-		chd_error chderr = av_codec_postinit(chd);
-		if (chderr != CHDERR_NONE)
-			return chderr;
-	}
+		// otherwise, call the virtual function
+		else
+			read_data(dest, m_read_done_offset, numbytes);
+
+		// spawn off work for each hunk
+		for (UINT64 curoffs = m_read_done_offset; curoffs < end_offset; curoffs += hunk_bytes())
+		{
+			UINT32 hunknum = curoffs / hunk_bytes();
+			work_item &item = m_work_item[hunknum % WORK_BUFFER_HUNKS];
+			assert(item.m_status == WS_READING);
+			item.m_status = WS_QUEUED;
+			item.m_hunknum = hunknum;
+			item.m_osd = osd_work_item_queue(m_work_queue, m_walking_parent ? async_walk_parent_static : async_compress_hunk_static, &item, 0);
+		}
+
+		// continue the running SHA-1
+		if (!m_walking_parent)
+		{
+			if (compressed())
+				m_compsha1.append(dest, numbytes);
+			m_total_in += numbytes;
+		}
 
-	/* make sure short frames are padded with 0 */
-	if (src != NULL)
+		// advance the read pointer
+		m_read_done_offset += numbytes;
+	}
+	catch (...)
 	{
-		size = av_raw_data_size((const UINT8 *)src);
-		while (size < chd->header.hunkbytes)
-			if (((const UINT8 *)src)[size++] != 0)
-				return CHDERR_INVALID_DATA;
+		m_read_error = true;
 	}
+}
 
-	/* encode the audio and video */
-	averr = avcomp_encode_data(data->compstate, (const UINT8 *)src, chd->compressed, length);
-	if (averr != AVCERR_NONE || *length > chd->header.hunkbytes)
-		return CHDERR_COMPRESSION_ERROR;
 
-	return CHDERR_NONE;
+
+//**************************************************************************
+//  CHD COMPRESSOR HASHMAP
+//**************************************************************************
+
+//-------------------------------------------------
+//  hashmap - constructor
+//-------------------------------------------------
+
+chd_file_compressor::hashmap::hashmap()
+	: m_block_list(new entry_block(NULL))
+{
+	// initialize the map to empty
+	memset(m_map, 0, sizeof(m_map));
 }
 
 
-/*-------------------------------------------------
-    av_codec_decompress - decomrpess data using
-    the A/V codec
--------------------------------------------------*/
-
-static chd_error av_codec_decompress(chd_file *chd, UINT32 srclength, void *dest)
-{
-	av_codec_data *data = (av_codec_data *)chd->codecdata;
-	const UINT8 *source;
-	avcomp_error averr;
-	int size;
-
-	/* if we haven't yet set up the avcomp code, do it now */
-	if (data->compstate == NULL)
-	{
-		chd_error chderr = av_codec_postinit(chd);
-		if (chderr != CHDERR_NONE)
-			return chderr;
-	}
-
-	/* decode the audio and video */
-	source = chd->compressed;
-	averr = avcomp_decode_data(data->compstate, source, srclength, (UINT8 *)dest);
-	if (averr != AVCERR_NONE)
-		return CHDERR_DECOMPRESSION_ERROR;
-
-	/* pad short frames with 0 */
-	if (dest != NULL)
-	{
-		size = av_raw_data_size((const UINT8 *)dest);
-		while (size < chd->header.hunkbytes)
-			((UINT8 *)dest)[size++] = 0;
-	}
+//-------------------------------------------------
+//  ~hashmap - destructor
+//-------------------------------------------------
 
-	return CHDERR_NONE;
+chd_file_compressor::hashmap::~hashmap()
+{
+	reset();
 }
 
 
-/*-------------------------------------------------
-    av_codec_config - codec-specific configuration
-    for the A/V codec
--------------------------------------------------*/
-
-static chd_error av_codec_config(chd_file *chd, int param, void *config)
-{
-	av_codec_data *data = (av_codec_data *)chd->codecdata;
-
-	/* if we're getting the compression configuration, apply it now */
-	if (param == AV_CODEC_COMPRESS_CONFIG)
-	{
-		av_codec_compress_config *configsrc = reinterpret_cast<av_codec_compress_config *>(config);
-		data->compress.video.wrap(configsrc->video, configsrc->video.cliprect());
-		data->compress.channels = configsrc->channels;
-		data->compress.samples = configsrc->samples;
-		memcpy(data->compress.audio, configsrc->audio, sizeof(data->compress.audio));
-		data->compress.metalength = configsrc->metalength;
-		data->compress.metadata = configsrc->metadata;
-		if (data->compstate != NULL)
-			avcomp_config_compress(data->compstate, &data->compress);
-		return CHDERR_NONE;
-	}
+//-------------------------------------------------
+//  reset - reset the state of the map
+//-------------------------------------------------
 
-	/* if we're getting the decompression configuration, apply it now */
-	else if (param == AV_CODEC_DECOMPRESS_CONFIG)
+void chd_file_compressor::hashmap::reset()
+{
+	// delete all the blocks
+	while (m_block_list->m_next != NULL)
 	{
-		av_codec_decompress_config *configsrc = reinterpret_cast<av_codec_decompress_config *>(config);
-		data->decompress.video.wrap(configsrc->video, configsrc->video.cliprect());
-		data->decompress.maxsamples = configsrc->maxsamples;
-		data->decompress.actsamples = configsrc->actsamples;
-		memcpy(data->decompress.audio, configsrc->audio, sizeof(data->decompress.audio));
-		data->decompress.maxmetalength = configsrc->maxmetalength;
-		data->decompress.actmetalength = configsrc->actmetalength;
-		data->decompress.metadata = configsrc->metadata;
-		if (data->compstate != NULL)
-			avcomp_config_decompress(data->compstate, &data->decompress);
-		return CHDERR_NONE;
+		entry_block *block = m_block_list;
+		m_block_list = block->m_next;
+		delete block;
 	}
+	m_block_list->m_nextalloc = 0;
 
-	/* anything else is invalid */
-	return CHDERR_INVALID_PARAMETER;
+	// reset the hash
+	memset(m_map, 0, sizeof(m_map));
 }
 
 
-/*-------------------------------------------------
-    av_codec_postinit - actual initialization of
-    avcomp happens here, on the first attempt
-    to compress or decompress data
--------------------------------------------------*/
+//-------------------------------------------------
+//  find - find an item in the CRC map
+//-------------------------------------------------
 
-static chd_error av_codec_postinit(chd_file *chd)
+UINT64 chd_file_compressor::hashmap::find(crc16_t crc16, sha1_t sha1)
 {
-	int fps, fpsfrac, width, height, interlaced, channels, rate;
-	UINT32 fps_times_1million, max_samples_per_frame, bytes_per_frame;
-	av_codec_data *data = (av_codec_data *)chd->codecdata;
-	char metadata[256];
-	chd_error err;
+	// look up the entry in the map
+	for (entry_t *entry = m_map[crc16]; entry != NULL; entry = entry->m_next)
+		if (entry->m_sha1 == sha1)
+			return entry->m_itemnum;
+	return NOT_FOUND;
+}
 
-	/* the code below won't work asynchronously */
-	if (chd->workitem != NULL)
-		return CHDERR_OPERATION_PENDING;
 
-	/* get the metadata */
-	err = chd_get_metadata(chd, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
-	if (err != CHDERR_NONE)
-		return err;
+//-------------------------------------------------
+//  add - add an item to the CRC map
+//-------------------------------------------------
 
-	/* extract the info */
-	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
-		return CHDERR_INVALID_METADATA;
-
-	/* compute the bytes per frame */
-	fps_times_1million = fps * 1000000 + fpsfrac;
-	max_samples_per_frame = ((UINT64)rate * 1000000 + fps_times_1million - 1) / fps_times_1million;
-	bytes_per_frame = 12 + channels * max_samples_per_frame * 2 + width * height * 2;
-	if (bytes_per_frame > chd->header.hunkbytes)
-		return CHDERR_INVALID_METADATA;
-
-	/* create the avcomp state */
-	data->compstate = avcomp_init(width, height, channels);
-
-	/* configure the codec */
-	avcomp_config_compress(data->compstate, &data->compress);
-	avcomp_config_decompress(data->compstate, &data->decompress);
-	return CHDERR_NONE;
+void chd_file_compressor::hashmap::add(UINT64 itemnum, crc16_t crc16, sha1_t sha1)
+{
+	// add to the appropriate map
+	if (m_block_list->m_nextalloc == ARRAY_LENGTH(m_block_list->m_array))
+		m_block_list = new entry_block(m_block_list);
+	entry_t *entry = &m_block_list->m_array[m_block_list->m_nextalloc++];
+	entry->m_itemnum = itemnum;
+	entry->m_sha1 = sha1;
+	entry->m_next = m_map[crc16];
+	m_map[crc16] = entry;
 }
diff -Nru src-old/lib/util/chd.h src/lib/util/chd.h
--- src-old/lib/util/chd.h	2012-01-22 20:24:20.000000000 +0100
+++ src/lib/util/chd.h	2012-02-19 16:23:23.000000000 +0100
@@ -43,16 +43,20 @@
 #define __CHD_H__
 
 #include "osdcore.h"
+#include "coretmpl.h"
+#include "astring.h"
 #include "bitmap.h"
 #include "corefile.h"
-#include "avcomp.h"
+#include "hashing.h"
+#include "chdcodec.h"
 
 
 /***************************************************************************
 
     Compressed Hunks of Data header format. All numbers are stored in
-    Motorola (big-endian) byte ordering. The header is 76 (V1) or 80 (V2)
-    bytes long.
+    Motorola (big-endian) byte ordering.
+
+    =========================================================================
 
     V1 header:
 
@@ -70,6 +74,21 @@
     [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file
     [ 76] (V1 header length)
 
+    Flags:
+        0x00000001 - set if this drive has a parent
+        0x00000002 - set if this drive allows writes
+
+    Compression types:
+        CHDCOMPRESSION_NONE = 0
+        CHDCOMPRESSION_ZLIB = 1
+
+    V1 map format:
+
+    [  0] UINT64 offset : 44;   // starting offset within the file
+    [  0] UINT64 length : 20;   // length of data; if == hunksize, data is uncompressed
+
+    =========================================================================
+
     V2 header:
 
     [  0] char   tag[8];        // 'MComprHD'
@@ -87,6 +106,10 @@
     [ 76] UINT32 seclen;        // number of bytes per sector
     [ 80] (V2 header length)
 
+    Flags and map format are same as V1
+
+    =========================================================================
+
     V3 header:
 
     [  0] char   tag[8];        // 'MComprHD'
@@ -104,6 +127,23 @@
     [100] UINT8  parentsha1[20];// SHA1 checksum of parent file
     [120] (V3 header length)
 
+    Flags are the same as V1
+
+    Compression types:
+        CHDCOMPRESSION_NONE = 0
+        CHDCOMPRESSION_ZLIB = 1
+        CHDCOMPRESSION_ZLIB_PLUS = 2
+
+    V3 map format:
+
+    [  0] UINT64 offset;        // starting offset within the file
+    [  8] UINT32 crc32;         // 32-bit CRC of the uncompressed data
+    [ 12] UINT16 length_lo;     // lower 16 bits of length
+    [ 14] UINT8 length_hi;      // upper 8 bits of length
+    [ 15] UINT8 flags;          // flags, indicating compression info
+
+    =========================================================================
+
     V4 header:
 
     [  0] char   tag[8];        // 'MComprHD'
@@ -120,89 +160,116 @@
     [ 88] UINT8  rawsha1[20];   // raw data SHA1
     [108] (V4 header length)
 
-    Flags:
-        0x00000001 - set if this drive has a parent
-        0x00000002 - set if this drive allows writes
+    Flags are the same as V1
 
-***************************************************************************/
+    Compression types:
+        CHDCOMPRESSION_NONE = 0
+        CHDCOMPRESSION_ZLIB = 1
+        CHDCOMPRESSION_ZLIB_PLUS = 2
+        CHDCOMPRESSION_AV = 3
 
+    Map format is the same as V3
+
+    =========================================================================
+
+    V5 header:
+
+    [  0] char   tag[8];        // 'MComprHD'
+    [  8] UINT32 length;        // length of header (including tag and length fields)
+    [ 12] UINT32 version;       // drive format version
+    [ 16] UINT32 compressors[4];// which custom compressors are used?
+    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)
+    [ 40] UINT64 mapoffset;     // offset to the map
+    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata
+    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)
+    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk
+    [ 64] UINT8  rawsha1[20];   // raw data SHA1
+    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1
+    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent
+    [124] (V5 header length)
+
+    If parentsha1 != 0, we have a parent (no need for flags)
+    If compressors[0] == 0, we are uncompressed (including maps)
+
+    V5 uncompressed map format:
+
+    [  0] UINT32 offset;        // starting offset / hunk size
+
+    V5 compressed map format header:
+
+    [  0] UINT32 length;        // length of compressed map
+    [  4] UINT48 datastart;     // offset of first block
+    [ 10] UINT16 crc;           // crc-16 of the map
+    [ 12] UINT8 lengthbits;     // bits used to encode complength
+    [ 13] UINT8 hunkbits;       // bits used to encode self-refs
+    [ 14] UINT8 parentunitbits; // bits used to encode parent unit refs
+    [ 15] UINT8 reserved;       // future use
+    [ 16] (compressed header length)
+
+    Each compressed map entry, once expanded, looks like:
+
+    [  0] UINT8 compression;    // compression type
+    [  1] UINT24 complength;    // compressed length
+    [  4] UINT48 offset;        // offset
+    [ 10] UINT16 crc;           // crc-16 of the data
 
-/***************************************************************************
-    CONSTANTS
 ***************************************************************************/
 
-/* header information */
-#define CHD_HEADER_VERSION			4
-#define CHD_V1_HEADER_SIZE			76
-#define CHD_V2_HEADER_SIZE			80
-#define CHD_V3_HEADER_SIZE			120
-#define CHD_V4_HEADER_SIZE			108
-#define CHD_MAX_HEADER_SIZE			CHD_V4_HEADER_SIZE
-
-/* checksumming information */
-#define CHD_MD5_BYTES				16
-#define CHD_SHA1_BYTES				20
-
-/* CHD global flags */
-#define CHDFLAGS_HAS_PARENT			0x00000001
-#define CHDFLAGS_IS_WRITEABLE		0x00000002
-#define CHDFLAGS_UNDEFINED			0xfffffffc
-
-/* compression types */
-#define CHDCOMPRESSION_NONE			        0
-#define CHDCOMPRESSION_ZLIB			        1
-#define CHDCOMPRESSION_ZLIB_PLUS	        2
-#define CHDCOMPRESSION_AV			        3
-#define CHDCOMPRESSION_ZLIB_PLUS_WITH_FLAC  4
-
-/* A/V codec configuration parameters */
-#define AV_CODEC_COMPRESS_CONFIG	1
-#define AV_CODEC_DECOMPRESS_CONFIG	2
-
-/* metadata parameters */
-#define CHDMETATAG_WILDCARD			0
-#define CHD_METAINDEX_APPEND		((UINT32)-1)
-
-/* metadata flags */
-#define CHD_MDFLAGS_CHECKSUM		0x01		/* indicates data is checksummed */
-
-/* standard hard disk metadata */
-#define HARD_DISK_METADATA_TAG		0x47444444	/* 'GDDD' */
-#define HARD_DISK_METADATA_FORMAT	"CYLS:%d,HEADS:%d,SECS:%d,BPS:%d"
-
-/* hard disk identify information */
-#define HARD_DISK_IDENT_METADATA_TAG 0x49444e54 /* 'IDNT' */
-
-/* hard disk key information */
-#define HARD_DISK_KEY_METADATA_TAG	0x4b455920  /* 'KEY '  */
-
-/* pcmcia CIS information */
-#define PCMCIA_CIS_METADATA_TAG		0x43495320  /* 'CIS '  */
-
-/* standard CD-ROM metadata */
-#define CDROM_OLD_METADATA_TAG		0x43484344	/* 'CHCD' */
-#define CDROM_TRACK_METADATA_TAG	0x43485452	/* 'CHTR' */
-#define CDROM_TRACK_METADATA_FORMAT	"TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d"
-#define CDROM_TRACK_METADATA2_TAG	0x43485432	/* 'CHT2' */
-#define CDROM_TRACK_METADATA2_FORMAT	"TRACK:%d TYPE:%s SUBTYPE:%s FRAMES:%d PREGAP:%d PGTYPE:%s PGSUB:%s POSTGAP:%d"
-
-/* standard A/V metadata */
-#define AV_METADATA_TAG				0x41564156	/* 'AVAV' */
-#define AV_METADATA_FORMAT			"FPS:%d.%06d WIDTH:%d HEIGHT:%d INTERLACED:%d CHANNELS:%d SAMPLERATE:%d"
-
-/* A/V laserdisc frame metadata */
-#define AV_LD_METADATA_TAG			0x41564C44	/* 'AVLD' */
-
-/* CHD open values */
-#define CHD_OPEN_READ				1
-#define CHD_OPEN_READWRITE			2
 
-/* error types */
-enum _chd_error
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+// pseudo-codecs returned by hunk_info
+const chd_codec_type CHD_CODEC_SELF 		= 1;	// copy of another hunk
+const chd_codec_type CHD_CODEC_PARENT		= 2;	// copy of a parent's hunk
+const chd_codec_type CHD_CODEC_MINI 		= 3;	// legacy "mini" 8-byte repeat
+
+// core types
+typedef UINT32 chd_metadata_tag;
+
+// metadata parameters
+const chd_metadata_tag CHDMETATAG_WILDCARD = 0;
+const UINT32 CHDMETAINDEX_APPEND = ~0;
+
+// metadata flags
+const UINT8 CHD_MDFLAGS_CHECKSUM = 0x01;		// indicates data is checksummed
+
+// standard hard disk metadata
+const chd_metadata_tag HARD_DISK_METADATA_TAG = CHD_MAKE_TAG('G','D','D','D');
+extern const char *HARD_DISK_METADATA_FORMAT;
+
+// hard disk identify information
+const chd_metadata_tag HARD_DISK_IDENT_METADATA_TAG = CHD_MAKE_TAG('I','D','N','T');
+
+// hard disk key information
+const chd_metadata_tag HARD_DISK_KEY_METADATA_TAG = CHD_MAKE_TAG('K','E','Y',' ');
+
+// pcmcia CIS information
+const chd_metadata_tag PCMCIA_CIS_METADATA_TAG = CHD_MAKE_TAG('C','I','S',' ');
+
+// standard CD-ROM metadata
+const chd_metadata_tag CDROM_OLD_METADATA_TAG = CHD_MAKE_TAG('C','H','C','D');
+const chd_metadata_tag CDROM_TRACK_METADATA_TAG = CHD_MAKE_TAG('C','H','T','R');
+extern const char *CDROM_TRACK_METADATA_FORMAT;
+const chd_metadata_tag CDROM_TRACK_METADATA2_TAG = CHD_MAKE_TAG('C','H','T','2');
+extern const char *CDROM_TRACK_METADATA2_FORMAT;
+
+// standard A/V metadata
+const chd_metadata_tag AV_METADATA_TAG = CHD_MAKE_TAG('A','V','A','V');
+extern const char *AV_METADATA_FORMAT;
+
+// A/V laserdisc frame metadata
+const chd_metadata_tag AV_LD_METADATA_TAG = CHD_MAKE_TAG('A','V','L','D');
+
+// error types
+enum chd_error
 {
 	CHDERR_NONE,
 	CHDERR_NO_INTERFACE,
 	CHDERR_OUT_OF_MEMORY,
+	CHDERR_NOT_OPEN,
+	CHDERR_ALREADY_OPEN,
 	CHDERR_INVALID_FILE,
 	CHDERR_INVALID_PARAMETER,
 	CHDERR_INVALID_DATA,
@@ -226,166 +293,303 @@
 	CHDERR_INVALID_METADATA,
 	CHDERR_INVALID_STATE,
 	CHDERR_OPERATION_PENDING,
-	CHDERR_NO_ASYNC_OPERATION,
-	CHDERR_UNSUPPORTED_FORMAT
+	CHDERR_UNSUPPORTED_FORMAT,
+	CHDERR_UNKNOWN_COMPRESSION,
+	CHDERR_WALKING_PARENT,
+	CHDERR_COMPRESSING
 };
-typedef enum _chd_error chd_error;
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-/* opaque types */
-typedef struct _chd_file chd_file;
+class chd_codec;
 
 
-/* extract header structure (NOT the on-disk header structure) */
-typedef struct _chd_header chd_header;
-struct _chd_header
-{
-	UINT32		length;						/* length of header data */
-	UINT32		version;					/* drive format version */
-	UINT32		flags;						/* flags field */
-	UINT32		compression;				/* compression type */
-	UINT32		hunkbytes;					/* number of bytes per hunk */
-	UINT32		totalhunks;					/* total # of hunks represented */
-	UINT64		logicalbytes;				/* logical size of the data */
-	UINT64		metaoffset;					/* offset in file of first metadata */
-	UINT8		md5[CHD_MD5_BYTES];			/* overall MD5 checksum */
-	UINT8		parentmd5[CHD_MD5_BYTES];	/* overall MD5 checksum of parent */
-	UINT8		sha1[CHD_SHA1_BYTES];		/* overall SHA1 checksum */
-	UINT8		rawsha1[CHD_SHA1_BYTES];	/* SHA1 checksum of raw data */
-	UINT8		parentsha1[CHD_SHA1_BYTES];	/* overall SHA1 checksum of parent */
-
-	UINT32		obsolete_cylinders;			/* obsolete field -- do not use! */
-	UINT32		obsolete_sectors;			/* obsolete field -- do not use! */
-	UINT32		obsolete_heads;				/* obsolete field -- do not use! */
-	UINT32		obsolete_hunksize;			/* obsolete field -- do not use! */
-};
-
+// ======================> chd_file
 
-/* structure for returning information about a verification pass */
-typedef struct _chd_verify_result chd_verify_result;
-struct _chd_verify_result
+// core file class
+class chd_file
 {
-	UINT8		md5[CHD_MD5_BYTES];			/* overall MD5 checksum */
-	UINT8		sha1[CHD_SHA1_BYTES];		/* overall SHA1 checksum */
-	UINT8		rawsha1[CHD_SHA1_BYTES];	/* SHA1 checksum of raw data */
-	UINT8		metasha1[CHD_SHA1_BYTES];	/* SHA1 checksum of metadata */
-};
-
-
-
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-
-/* ----- CHD file management ----- */
-
-/* create a new CHD file fitting the given description */
-chd_error chd_create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 compression, chd_file *parent);
-
-/* same as chd_create(), but accepts an already-opened core_file object */
-chd_error chd_create_file(core_file *file, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 compression, chd_file *parent);
-
-/* open an existing CHD file */
-chd_error chd_open(const char *filename, int mode, chd_file *parent, chd_file **chd);
-
-/* same as chd_open(), but accepts an already-opened core_file object */
-chd_error chd_open_file(core_file *file, int mode, chd_file *parent, chd_file **chd);
-
-/* close a CHD file */
-void chd_close(chd_file *chd);
-
-/* return the associated core_file */
-core_file *chd_core_file(chd_file *chd);
-
-/* return an error string for the given CHD error */
-const char *chd_error_string(chd_error err);
-
-
-
-/* ----- CHD header management ----- */
-
-/* return a pointer to the extracted CHD header data */
-const chd_header *chd_get_header(chd_file *chd);
-
-/* set a modified header */
-chd_error chd_set_header(const char *filename, const chd_header *header);
-
-/* same as chd_set_header(), but accepts an already-opened core_file object */
-chd_error chd_set_header_file(core_file *file, const chd_header *header);
-
-
-
-/* ----- core data read/write ----- */
-
-/* read one hunk from the CHD file */
-chd_error chd_read(chd_file *chd, UINT32 hunknum, void *buffer);
-
-/* read one hunk from the CHD file asynchronously */
-chd_error chd_read_async(chd_file *chd, UINT32 hunknum, void *buffer);
-
-/* write one hunk to a CHD file */
-chd_error chd_write(chd_file *chd, UINT32 hunknum, const void *buffer);
-
-/* write one hunk to a CHD file asynchronously */
-chd_error chd_write_async(chd_file *chd, UINT32 hunknum, const void *buffer);
-
-/* wait for a previously issued async read/write to complete and return the error */
-chd_error chd_async_complete(chd_file *chd);
-
-
-
-/* ----- metadata management ----- */
-
-/* get indexed metadata of a particular sort */
-chd_error chd_get_metadata(chd_file *chd, UINT32 searchtag, UINT32 searchindex, void *output, UINT32 outputlen, UINT32 *resultlen, UINT32 *resulttag, UINT8 *resultflags);
-
-/* set indexed metadata of a particular sort */
-chd_error chd_set_metadata(chd_file *chd, UINT32 metatag, UINT32 metaindex, const void *inputbuf, UINT32 inputlen, UINT8 flags);
-
-/* clone all of the metadata from one CHD to another */
-chd_error chd_clone_metadata(chd_file *source, chd_file *dest);
-
-
-
-/* ----- compression management ----- */
-
-/* begin compressing data to a CHD */
-chd_error chd_compress_begin(chd_file *chd);
-
-/* compress the next hunk of data */
-chd_error chd_compress_hunk(chd_file *chd, const void *data, double *curratio, int is_half_hunk = 0);
-
-/* finish compressing data to a CHD */
-chd_error chd_compress_finish(chd_file *chd, int write_protect);
-
-
-
-/* ----- verification management ----- */
-
-/* begin verifying a CHD */
-chd_error chd_verify_begin(chd_file *chd);
-
-/* verify a single hunk of data */
-chd_error chd_verify_hunk(chd_file *chd);
-
-/* finish verifying a CHD, returning the computed MD5 and SHA1 */
-chd_error chd_verify_finish(chd_file *chd, chd_verify_result *result);
+	friend class chd_file_compressor;
+	friend class chd_verifier;
 
+	// constants
+	static const UINT32 HEADER_VERSION = 5;
+	static const UINT32 V3_HEADER_SIZE = 120;
+	static const UINT32 V4_HEADER_SIZE = 108;
+	static const UINT32 V5_HEADER_SIZE = 124;
+	static const UINT32 MAX_HEADER_SIZE = V5_HEADER_SIZE;
+
+public:
+	// construction/destruction
+	chd_file();
+	virtual ~chd_file();
+
+	// operators
+	operator core_file *() { return m_file; }
+
+	// getters
+	bool opened() const { return (m_file != NULL); }
+	UINT32 version() const { return m_version; }
+	UINT64 logical_bytes() const { return m_logicalbytes; }
+	UINT32 hunk_bytes() const { return m_hunkbytes; }
+	UINT32 hunk_count() const { return m_hunkcount; }
+	UINT32 unit_bytes() const { return m_unitbytes; }
+	UINT64 unit_count() const { return m_unitcount; }
+	bool compressed() const { return (m_compression[0] != CHD_CODEC_NONE); }
+	chd_codec_type compression(int index) const { return m_compression[index]; }
+	chd_file *parent() const { return m_parent; }
+	sha1_t sha1();
+	sha1_t raw_sha1();
+	sha1_t parent_sha1();
+	chd_error hunk_info(UINT32 hunknum, chd_codec_type &compressor, UINT32 &compbytes);
+
+	// setters
+	void set_raw_sha1(sha1_t rawdata);
+	void set_parent_sha1(sha1_t parent);
+
+	// file create
+	chd_error create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 unitbytes, chd_codec_type compression[4]);
+	chd_error create(core_file &file, UINT64 logicalbytes, UINT32 hunkbytes, UINT32 unitbytes, chd_codec_type compression[4]);
+	chd_error create(const char *filename, UINT64 logicalbytes, UINT32 hunkbytes, chd_codec_type compression[4], chd_file &parent);
+	chd_error create(core_file &file, UINT64 logicalbytes, UINT32 hunkbytes, chd_codec_type compression[4], chd_file &parent);
+
+	// file open
+	chd_error open(const char *filename, bool writeable = false, chd_file *parent = NULL);
+	chd_error open(core_file &file, bool writeable = false, chd_file *parent = NULL);
+
+	// file close
+	void close();
+
+	// read/write
+	chd_error read_hunk(UINT32 hunknum, void *buffer);
+	chd_error write_hunk(UINT32 hunknum, const void *buffer);
+	chd_error read_units(UINT64 unitnum, void *buffer, UINT32 count = 1);
+	chd_error write_units(UINT64 unitnum, const void *buffer, UINT32 count = 1);
+	chd_error read_bytes(UINT64 offset, void *buffer, UINT32 bytes);
+	chd_error write_bytes(UINT64 offset, const void *buffer, UINT32 bytes);
+
+	// metadata management
+	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, astring &output);
+	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, dynamic_buffer &output);
+	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, void *output, UINT32 outputlen, UINT32 &resultlen);
+	chd_error read_metadata(chd_metadata_tag searchtag, UINT32 searchindex, dynamic_buffer &output, chd_metadata_tag &resulttag, UINT8 &resultflags);
+	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const void *inputbuf, UINT32 inputlen, UINT8 flags = CHD_MDFLAGS_CHECKSUM);
+	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const astring &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input.cstr(), input.len() + 1, flags = CHD_MDFLAGS_CHECKSUM); }
+	chd_error write_metadata(chd_metadata_tag metatag, UINT32 metaindex, const dynamic_buffer &input, UINT8 flags = CHD_MDFLAGS_CHECKSUM) { return write_metadata(metatag, metaindex, input, input.count(), flags = CHD_MDFLAGS_CHECKSUM); }
+	chd_error delete_metadata(chd_metadata_tag metatag, UINT32 metaindex);
+	chd_error clone_all_metadata(chd_file &source);
+
+	// hashing helper
+	sha1_t compute_overall_sha1(sha1_t rawsha1);
+
+	// codec interfaces
+	chd_error codec_configure(chd_codec_type codec, int param, void *config);
+
+	// static helpers
+	static const char *error_string(chd_error err);
+
+private:
+	struct metadata_entry;
+	struct metadata_hash;
+
+	// inline helpers
+	UINT64 be_read(const UINT8 *base, int numbytes);
+	void be_write(UINT8 *base, UINT64 value, int numbytes);
+	sha1_t be_read_sha1(const UINT8 *base);
+	void be_write_sha1(UINT8 *base, sha1_t value);
+	void file_read(UINT64 offset, void *dest, UINT32 length);
+	void file_write(UINT64 offset, const void *source, UINT32 length);
+	UINT64 file_append(const void *source, UINT32 length, UINT32 alignment = 0);
+	UINT8 bits_for_value(UINT64 value);
+
+	// internal helpers
+	UINT32 guess_unitbytes();
+	void parse_v3_header(UINT8 *rawheader, sha1_t &parentsha1);
+	void parse_v4_header(UINT8 *rawheader, sha1_t &parentsha1);
+	void parse_v5_header(UINT8 *rawheader, sha1_t &parentsha1);
+	chd_error compress_v5_map();
+	void decompress_v5_map();
+	chd_error create_common();
+	chd_error open_common(bool writeable);
+	void create_open_common();
+	void verify_proper_compression_append(UINT32 hunknum);
+	void hunk_write_compressed(UINT32 hunknum, INT8 compression, const UINT8 *compressed, UINT32 complength, crc16_t crc16);
+	void hunk_copy_from_self(UINT32 hunknum, UINT32 otherhunk);
+	void hunk_copy_from_parent(UINT32 hunknum, UINT64 parentunit);
+	bool metadata_find(chd_metadata_tag metatag, INT32 metaindex, metadata_entry &metaentry, bool resume = false);
+	void metadata_set_previous_next(UINT64 prevoffset, UINT64 nextoffset);
+	void metadata_update_hash();
+	static int CLIB_DECL metadata_hash_compare(const void *elem1, const void *elem2);
+
+	// file characteristics
+	core_file *				m_file;				// handle to the open core file
+	bool					m_owns_file;		// flag indicating if this file should be closed on chd_close()
+	bool					m_allow_reads;		// permit reads from this CHD?
+	bool					m_allow_writes;		// permit writes to this CHD?
+
+	// core parameters from the header
+	UINT32					m_version;			// version of the header
+	UINT64					m_logicalbytes;		// logical size of the raw CHD data in bytes
+	UINT64					m_mapoffset;		// offset of map
+	UINT64					m_metaoffset;		// offset to first metadata bit
+	UINT32					m_hunkbytes;		// size of each raw hunk in bytes
+	UINT32					m_hunkcount;		// number of hunks represented
+	UINT32					m_unitbytes;		// size of each unit in bytes
+	UINT64					m_unitcount;		// number of units represented
+	chd_codec_type			m_compression[4];	// array of compression types used
+	chd_file *				m_parent;			// pointer to parent file, or NULL if none
+	bool					m_parent_missing;	// are we missing our parent?
+
+	// key offsets within the header
+	UINT64					m_mapoffset_offset;	// offset of map offset field
+	UINT64					m_metaoffset_offset;// offset of metaoffset field
+	UINT64					m_sha1_offset;		// offset of SHA1 field
+	UINT64					m_rawsha1_offset;	// offset of raw SHA1 field
+	UINT64					m_parentsha1_offset;// offset of paren SHA1 field
+
+	// map information
+	UINT32					m_mapentrybytes;	// length of each entry in a map
+	dynamic_buffer			m_rawmap;			// raw map data
+
+	// compression management
+	chd_decompressor *		m_decompressor[4];	// array of decompression codecs
+	dynamic_buffer			m_compressed;		// temporary buffer for compressed data
+
+	// caching
+	dynamic_buffer			m_cache;			// single-hunk cache for partial reads/writes
+	UINT32					m_cachehunk;		// which hunk is in the cache?
+};
 
 
-/* ----- codec interfaces ----- */
+// ======================> chd_file_compressor
 
-/* set internal codec parameters */
-chd_error chd_codec_config(chd_file *chd, int param, void *config);
+// class for creating a new compressed CHD
+class chd_file_compressor : public chd_file
+{
+public:
+	// construction/destruction
+	chd_file_compressor();
+	virtual ~chd_file_compressor();
+
+	// compression management
+	void compress_begin();
+	chd_error compress_continue(double &progress, double &ratio);
+
+protected:
+	// required override: read more data
+	virtual UINT32 read_data(void *dest, UINT64 offset, UINT32 length) = 0;
+
+private:
+	// hash map for looking up values
+	class hashmap
+	{
+	public:
+		// construction/destruction
+		hashmap();
+		~hashmap();
+
+		// operations
+		void reset();
+		UINT64 find(crc16_t crc16, sha1_t sha1);
+		void add(UINT64 itemnum, crc16_t crc16, sha1_t sha1);
+
+		// constants
+		static const UINT64 NOT_FOUND = ~UINT64(0);
+	private:
+		// internal entry
+		struct entry_t
+		{
+			entry_t *			m_next;				// next entry in list
+			UINT64				m_itemnum;			// item number
+			sha1_t				m_sha1;				// SHA-1 of the block
+		};
+
+		// block of entries
+		struct entry_block
+		{
+			entry_block(entry_block *prev)
+				: m_next(prev), m_nextalloc(0) { }
+
+			entry_block *		m_next;				// next block in list
+			UINT32				m_nextalloc;		// next to be allocated
+			entry_t				m_array[16384];		// array of entries
+		};
+
+		// internal state
+		entry_t *			m_map[65536];			// map, hashed by CRC-16
+		entry_block *		m_block_list;			// list of allocated blocks
+	};
+
+	// status of a given work item
+	enum work_status
+	{
+		WS_READY = 0,
+		WS_READING,
+		WS_QUEUED,
+		WS_COMPLETE
+	};
+
+	// a CRC-16/SHA-1 pair
+	struct hash_pair
+	{
+		crc16_t				m_crc16;			// calculated CRC-16
+		sha1_t				m_sha1;				// calculated SHA-1
+	};
+
+	// a single work item
+	struct work_item
+	{
+		osd_work_item *		m_osd;				// OSD work item running on this block
+		chd_file_compressor *m_compressor;		// pointer back to the compressor
+		volatile work_status m_status;			// current status of this item
+		UINT32				m_hunknum;			// number of the hunk we're working on
+		UINT8 *				m_data;				// pointer to the data we are working on
+		UINT8 *				m_compressed;		// pointer to the compressed data
+		UINT32				m_complen;			// compressed data length
+		INT8				m_compression;		// type of compression used
+		chd_compressor_group *m_codecs;			// codec instance
+		dynamic_array<hash_pair> m_hash;		// array of hashes
+	};
+
+	// internal helpers
+	static void *async_walk_parent_static(void *param, int threadid);
+	void async_walk_parent(work_item &item);
+	static void *async_compress_hunk_static(void *param, int threadid);
+	void async_compress_hunk(work_item &item, int threadid);
+	static void *async_read_static(void *param, int threadid);
+	void async_read();
+
+	// current compression status
+	bool					m_walking_parent;	// are we building the parent map?
+	UINT64					m_total_in;			// total bytes in
+	UINT64					m_total_out;		// total bytes out
+	sha1_creator			m_compsha1;			// running SHA-1 on raw data
+
+	// hash lookup maps
+	hashmap					m_parent_map;		// hash map for parent
+	hashmap					m_current_map;		// hash map for current
+
+	// read I/O thread
+	osd_work_queue *		m_read_queue;		// work queue for reading
+	UINT64					m_read_queue_offset;// next offset to enqueue
+	UINT64					m_read_done_offset;	// next offset that will complete
+	bool					m_read_error;		// error during reading?
+
+	// work item thread
+	static const int WORK_BUFFER_HUNKS = 256;
+	osd_work_queue *		m_work_queue;		// queue for doing work on other threads
+	dynamic_buffer			m_work_buffer;		// buffer containing hunk data to work on
+	dynamic_buffer			m_compressed_buffer;// buffer containing compressed data
+	work_item				m_work_item[WORK_BUFFER_HUNKS]; // status of each hunk
+	chd_compressor_group *	m_codecs[WORK_MAX_THREADS]; // codecs to use
 
-/* return a string description of a codec */
-const char *chd_get_codec_name(UINT32 codec);
+	// output state
+	UINT32					m_write_hunk;		// next hunk to write
+};
 
 
-#endif /* __CHD_H__ */
+#endif // __CHD_H__
diff -Nru src-old/lib/util/chdcd.c src/lib/util/chdcd.c
--- src-old/lib/util/chdcd.c	2012-01-05 00:39:17.000000000 +0100
+++ src/lib/util/chdcd.c	2012-02-16 10:47:18.000000000 +0100
@@ -304,7 +304,7 @@
     chdcd_parse_toc - parse a CDRWin format CUE file
 -------------------------------------------------*/
 
-chd_error chdcd_parse_nero(const char *tocfname, cdrom_toc *outtoc, chdcd_track_input_info *outinfo)
+chd_error chdcd_parse_nero(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo)
 {
 	FILE *infile;
 	unsigned char buffer[12];
@@ -322,8 +322,8 @@
 	}
 
 	/* clear structures */
-	memset(outtoc, 0, sizeof(cdrom_toc));
-	memset(outinfo, 0, sizeof(chdcd_track_input_info));
+	memset(&outtoc, 0, sizeof(outtoc));
+	outinfo.reset();
 
 	// seek to 12 bytes before the end
 	fseek(infile, -12, SEEK_END);
@@ -372,7 +372,7 @@
 
 //          printf("TOC type: %08x.  Start track %d  End track: %d\n", toc_type, start, end);
 
-			outtoc->numtrks = (end-start) + 1;
+			outtoc.numtrks = (end-start) + 1;
 
 			offset = 0;
 			for (track = start; track <= end; track++)
@@ -388,27 +388,26 @@
 				index2 = read_uint64(infile);
 
 //              printf("Track %d: sector size %d mode %x index0 %llx index1 %llx index2 %llx (pregap %d sectors, length %d sectors)\n", track, size, mode, index0, index1, index2, (UINT32)(index1-index0)/size, (UINT32)(index2-index1)/size);
-				strncpy(outinfo->fname[track-1], path.cstr(), 256);
-				strncat(outinfo->fname[track-1], tocfname, 256);
-				outinfo->offset[track-1] = offset + (UINT32)(index1-index0);
-				outinfo->idx0offs[track-1] = 0;
-				outinfo->idx1offs[track-1] = 0;
+				outinfo.track[track-1].fname.cpy(path.cstr()).cat(tocfname);
+				outinfo.track[track-1].offset = offset + (UINT32)(index1-index0);
+				outinfo.track[track-1].idx0offs = 0;
+				outinfo.track[track-1].idx1offs = 0;
 
 				switch (mode>>24)
 				{
 					case 0x00:	// 2048 byte data
-						outtoc->tracks[track-1].trktype = CD_TRACK_MODE1;
-						outinfo->swap[track-1] = 0;
+						outtoc.tracks[track-1].trktype = CD_TRACK_MODE1;
+						outinfo.track[track-1].swap = false;
 						break;
 
 					case 0x06:	// 2352 byte mode 2 raw
-						outtoc->tracks[track-1].trktype = CD_TRACK_MODE2_RAW;
-						outinfo->swap[track-1] = 0;
+						outtoc.tracks[track-1].trktype = CD_TRACK_MODE2_RAW;
+						outinfo.track[track-1].swap = false;
 						break;
 
 					case 0x07:	// 2352 byte audio
-						outtoc->tracks[track-1].trktype = CD_TRACK_AUDIO;
-						outinfo->swap[track-1] = 1;
+						outtoc.tracks[track-1].trktype = CD_TRACK_AUDIO;
+						outinfo.track[track-1].swap = true;
 						break;
 
 					default:
@@ -416,18 +415,18 @@
 						break;
 				}
 
-				outtoc->tracks[track-1].datasize = size;
+				outtoc.tracks[track-1].datasize = size;
 
-				outtoc->tracks[track-1].subtype = CD_SUB_NONE;
-				outtoc->tracks[track-1].subsize = 0;
+				outtoc.tracks[track-1].subtype = CD_SUB_NONE;
+				outtoc.tracks[track-1].subsize = 0;
 
-				outtoc->tracks[track-1].pregap = (UINT32)(index1-index0)/size;
-				outtoc->tracks[track-1].frames = (UINT32)(index2-index1)/size;
-				outtoc->tracks[track-1].postgap = 0;
-				outtoc->tracks[track-1].pgtype = 0;
-				outtoc->tracks[track-1].pgsub = CD_SUB_NONE;
-				outtoc->tracks[track-1].pgdatasize = 0;
-				outtoc->tracks[track-1].pgsubsize = 0;
+				outtoc.tracks[track-1].pregap = (UINT32)(index1-index0)/size;
+				outtoc.tracks[track-1].frames = (UINT32)(index2-index1)/size;
+				outtoc.tracks[track-1].postgap = 0;
+				outtoc.tracks[track-1].pgtype = 0;
+				outtoc.tracks[track-1].pgsub = CD_SUB_NONE;
+				outtoc.tracks[track-1].pgdatasize = 0;
+				outtoc.tracks[track-1].pgsubsize = 0;
 
 				offset += (UINT32)index2-index1;
 			}
@@ -452,7 +451,7 @@
     chdcd_parse_gdi - parse a Sega GD-ROM rip
 -------------------------------------------------*/
 
-static chd_error chdcd_parse_gdi(const char *tocfname, cdrom_toc *outtoc, chdcd_track_input_info *outinfo)
+static chd_error chdcd_parse_gdi(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo)
 {
 	FILE *infile;
 	int i, numtracks;
@@ -469,8 +468,8 @@
 	}
 
 	/* clear structures */
-	memset(outtoc, 0, sizeof(cdrom_toc));
-	memset(outinfo, 0, sizeof(chdcd_track_input_info));
+	memset(&outtoc, 0, sizeof(outtoc));
+	outinfo.reset();
 
 
 	fgets(linebuffer,511,infile);
@@ -491,16 +490,16 @@
 
 		trknum=atoi(tok)-1;
 
-		outinfo->swap[trknum]=0;
-		outinfo->offset[trknum]=0;
+		outinfo.track[trknum].swap=false;
+		outinfo.track[trknum].offset=0;
 
-		//outtoc->tracks[trknum].trktype = CD_TRACK_MODE1;
-		outtoc->tracks[trknum].datasize = 0;
-		outtoc->tracks[trknum].subtype = CD_SUB_NONE;
-		outtoc->tracks[trknum].subsize = 0;
+		//outtoc.tracks[trknum].trktype = CD_TRACK_MODE1;
+		outtoc.tracks[trknum].datasize = 0;
+		outtoc.tracks[trknum].subtype = CD_SUB_NONE;
+		outtoc.tracks[trknum].subsize = 0;
 
 		tok=strtok(NULL," ");
-		outtoc->tracks[trknum].physframeofs=atoi(tok);
+		outtoc.tracks[trknum].physframeofs=atoi(tok);
 
 		tok=strtok(NULL," ");
 		trktype=atoi(tok);
@@ -510,19 +509,19 @@
 
 		if(trktype==4 && trksize==2352)
 		{
-			outtoc->tracks[trknum].trktype=CD_TRACK_MODE1_RAW;
-			outtoc->tracks[trknum].datasize=2352;
+			outtoc.tracks[trknum].trktype=CD_TRACK_MODE1_RAW;
+			outtoc.tracks[trknum].datasize=2352;
 		}
 		if(trktype==4 && trksize==2048)
 		{
-			outtoc->tracks[trknum].trktype=CD_TRACK_MODE1;
-			outtoc->tracks[trknum].datasize=2048;
+			outtoc.tracks[trknum].trktype=CD_TRACK_MODE1;
+			outtoc.tracks[trknum].datasize=2048;
 		}
 		if(trktype==0)
 		{
 			//assert(trksize==2352);
-			outtoc->tracks[trknum].trktype=CD_TRACK_AUDIO;
-			outtoc->tracks[trknum].datasize=2352;
+			outtoc.tracks[trknum].trktype=CD_TRACK_AUDIO;
+			outtoc.tracks[trknum].datasize=2352;
 		}
 
 		astring name;
@@ -539,43 +538,42 @@
 			} while(tok!=NULL && (strrchr(tok,'"')-tok !=(strlen(tok)-1)));
 			name = name.delchr('"');
 		}
-		strncpy(outinfo->fname[trknum], path.cstr(), 256);
-		strncat(outinfo->fname[trknum], name, 256);
+		outinfo.track[trknum].fname.cpy(path.cstr()).cat(name);
 
-		sz=get_file_size(outinfo->fname[trknum]);
+		sz=get_file_size(outinfo.track[trknum].fname);
 
-		outtoc->tracks[trknum].frames=sz/trksize;
-		outtoc->tracks[trknum].extraframes=0;
+		outtoc.tracks[trknum].frames=sz/trksize;
+		outtoc.tracks[trknum].extraframes=0;
 
 		if(trknum!=0)
 		{
-			int dif=outtoc->tracks[trknum].physframeofs-(outtoc->tracks[trknum-1].frames+outtoc->tracks[trknum-1].physframeofs);
-			outtoc->tracks[trknum-1].frames+=dif;
+			int dif=outtoc.tracks[trknum].physframeofs-(outtoc.tracks[trknum-1].frames+outtoc.tracks[trknum-1].physframeofs);
+			outtoc.tracks[trknum-1].frames+=dif;
 		}
 
 /*
         if(trknum!=0)
         {
-            outtoc->tracks[trknum-1].extraframes=outtoc->tracks[trknum].physframeofs-(outtoc->tracks[trknum-1].frames+outtoc->tracks[trknum-1].physframeofs);
+            outtoc.tracks[trknum-1].extraframes=outtoc.tracks[trknum].physframeofs-(outtoc.tracks[trknum-1].frames+outtoc.tracks[trknum-1].physframeofs);
         }
 */
-		hunks = (outtoc->tracks[trknum].frames+CD_FRAMES_PER_HUNK - 1) / CD_FRAMES_PER_HUNK;
-		outtoc->tracks[trknum].extraframes = hunks * CD_FRAMES_PER_HUNK - outtoc->tracks[trknum].frames;
+		hunks = (outtoc.tracks[trknum].frames+CD_FRAMES_PER_HUNK - 1) / CD_FRAMES_PER_HUNK;
+		outtoc.tracks[trknum].extraframes = hunks * CD_FRAMES_PER_HUNK - outtoc.tracks[trknum].frames;
 
-		//chdpos+=outtoc->tracks[trknum].frames+outtoc->tracks[trknum].extraframes;
+		//chdpos+=outtoc.tracks[trknum].frames+outtoc.tracks[trknum].extraframes;
 
 	}
 	/*
     for(i=0;i<numtracks;++i)
     {
-        printf("%s %d %d %d\n",outinfo->fname[i],outtoc->tracks[i].frames,outtoc->tracks[i].extraframes,outtoc->tracks[i].physframeofs);
+        printf("%s %d %d %d\n",outinfo.track[i].fname,outtoc.tracks[i].frames,outtoc.tracks[i].extraframes,outtoc.tracks[i].physframeofs);
     }
     */
 	/* close the input TOC */
 	fclose(infile);
 
 	/* store the number of tracks found */
-	outtoc->numtrks = numtracks;
+	outtoc.numtrks = numtracks;
 
 	return CHDERR_NONE;
 }
@@ -584,7 +582,7 @@
     chdcd_parse_toc - parse a CDRWin format CUE file
 -------------------------------------------------*/
 
-chd_error chdcd_parse_cue(const char *tocfname, cdrom_toc *outtoc, chdcd_track_input_info *outinfo)
+chd_error chdcd_parse_cue(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo)
 {
 	FILE *infile;
 	int i, trknum;
@@ -601,8 +599,8 @@
 	}
 
 	/* clear structures */
-	memset(outtoc, 0, sizeof(cdrom_toc));
-	memset(outinfo, 0, sizeof(chdcd_track_input_info));
+	memset(&outtoc, 0, sizeof(outtoc));
+	outinfo.reset();
 
 	trknum = -1;
 	wavoffs = wavlen = 0;
@@ -633,11 +631,11 @@
 
 				if (!strcmp(token, "BINARY"))
 				{
-					outinfo->swap[trknum] = 0;
+					outinfo.track[trknum].swap = false;
 				}
 				else if (!strcmp(token, "MOTOROLA"))
 				{
-					outinfo->swap[trknum] = 1;
+					outinfo.track[trknum].swap = true;
 				}
 				else if (!strcmp(token, "WAVE"))
 				{
@@ -672,28 +670,28 @@
 
 				if (wavlen != 0)
 				{
-					outtoc->tracks[trknum].trktype = CD_TRACK_AUDIO;
-					outtoc->tracks[trknum].frames = wavlen/2352;
-					outinfo->offset[trknum] = wavoffs;
+					outtoc.tracks[trknum].trktype = CD_TRACK_AUDIO;
+					outtoc.tracks[trknum].frames = wavlen/2352;
+					outinfo.track[trknum].offset = wavoffs;
 					wavoffs = wavlen = 0;
 				}
 				else
 				{
-					outtoc->tracks[trknum].trktype = CD_TRACK_MODE1;
-					outtoc->tracks[trknum].datasize = 0;
-					outinfo->offset[trknum] = 0;
-				}
-				outtoc->tracks[trknum].subtype = CD_SUB_NONE;
-				outtoc->tracks[trknum].subsize = 0;
-				outtoc->tracks[trknum].pregap = 0;
-				outinfo->idx0offs[trknum] = -1;
-				outinfo->idx1offs[trknum] = 0;
+					outtoc.tracks[trknum].trktype = CD_TRACK_MODE1;
+					outtoc.tracks[trknum].datasize = 0;
+					outinfo.track[trknum].offset = 0;
+				}
+				outtoc.tracks[trknum].subtype = CD_SUB_NONE;
+				outtoc.tracks[trknum].subsize = 0;
+				outtoc.tracks[trknum].pregap = 0;
+				outinfo.track[trknum].idx0offs = -1;
+				outinfo.track[trknum].idx1offs = 0;
 
-				strncpy(outinfo->fname[trknum], lastfname, 256); // default filename to the last one
-//              printf("trk %d: fname %s offset %d\n", trknum, &outinfo->fname[trknum][0], outinfo->offset[trknum]);
+				outinfo.track[trknum].fname.cpy(lastfname); // default filename to the last one
+//              printf("trk %d: fname %s offset %d\n", trknum, outinfo.track[trknum].fname.cstr(), outinfo.track[trknum].offset);
 
-				cdrom_convert_type_string_to_track_info(token, &outtoc->tracks[trknum]);
-				if (outtoc->tracks[trknum].datasize == 0)
+				cdrom_convert_type_string_to_track_info(token, &outtoc.tracks[trknum]);
+				if (outtoc.tracks[trknum].datasize == 0)
 				{
 					printf("ERROR: Unknown track type [%s].  Contact MAMEDEV.\n", token);
 					return CHDERR_FILE_NOT_FOUND;
@@ -702,7 +700,7 @@
 				/* next (optional) token on the line is the subcode type */
 				TOKENIZE
 
-				cdrom_convert_subtype_string_to_track_info(token, &outtoc->tracks[trknum]);
+				cdrom_convert_subtype_string_to_track_info(token, &outtoc.tracks[trknum]);
 			}
 			else if (!strcmp(token, "INDEX"))	/* only in bin/cue files */
 			{
@@ -718,14 +716,14 @@
 
 				if (idx == 0)
 				{
-					outinfo->idx0offs[trknum] = frames;
+					outinfo.track[trknum].idx0offs = frames;
 				}
 				else if (idx == 1)
 				{
-					outinfo->idx1offs[trknum] = frames;
-					if ((outtoc->tracks[trknum].pregap == 0) && (outinfo->idx0offs[trknum] != -1))
+					outinfo.track[trknum].idx1offs = frames;
+					if ((outtoc.tracks[trknum].pregap == 0) && (outinfo.track[trknum].idx0offs != -1))
 					{
-						outtoc->tracks[trknum].pregap = frames - outinfo->idx0offs[trknum];
+						outtoc.tracks[trknum].pregap = frames - outinfo.track[trknum].idx0offs;
 					}
 				}
 			}
@@ -737,7 +735,7 @@
 				TOKENIZE
 				frames = msf_to_frames( token );
 
-				outtoc->tracks[trknum].pregap = frames;
+				outtoc.tracks[trknum].pregap = frames;
 			}
 			else if (!strcmp(token, "POSTGAP"))
 			{
@@ -747,7 +745,7 @@
 				TOKENIZE
 				frames = msf_to_frames( token );
 
-				outtoc->tracks[trknum].postgap = frames;
+				outtoc.tracks[trknum].postgap = frames;
 			}
 		}
 	}
@@ -756,67 +754,67 @@
 	fclose(infile);
 
 	/* store the number of tracks found */
-	outtoc->numtrks = trknum + 1;
+	outtoc.numtrks = trknum + 1;
 
 	/* now go over the files again and set the lengths */
-	for (trknum = 0; trknum < outtoc->numtrks; trknum++)
+	for (trknum = 0; trknum < outtoc.numtrks; trknum++)
 	{
 		UINT64 tlen = 0;
 
 		// this is true for cue/bin and cue/iso, and we need it for cue/wav since .WAV is little-endian
-		if (outtoc->tracks[trknum].trktype == CD_TRACK_AUDIO)
+		if (outtoc.tracks[trknum].trktype == CD_TRACK_AUDIO)
 		{
-			outinfo->swap[trknum] = 1;
+			outinfo.track[trknum].swap = true;
 		}
 
 		// don't do this for .WAV tracks, we already have their length and offset filled out
-		if (outinfo->offset[trknum] == 0)
+		if (outinfo.track[trknum].offset == 0)
 		{
 			// is this the last track?
-			if (trknum == (outtoc->numtrks-1))
+			if (trknum == (outtoc.numtrks-1))
 			{
 				/* if we have the same filename as the last track, do it that way */
-				if (!strcmp(&outinfo->fname[trknum][0], &outinfo->fname[trknum-1][0]))
+				if (outinfo.track[trknum].fname == outinfo.track[trknum-1].fname)
 				{
-					tlen = get_file_size(outinfo->fname[trknum]);
+					tlen = get_file_size(outinfo.track[trknum].fname);
 					if (tlen == 0)
 					{
-						printf("ERROR: couldn't find bin file [%s]\n", outinfo->fname[trknum-1]);
+						printf("ERROR: couldn't find bin file [%s]\n", outinfo.track[trknum-1].fname.cstr());
 						return CHDERR_FILE_NOT_FOUND;
 					}
-					outinfo->offset[trknum] = outinfo->offset[trknum-1] + outtoc->tracks[trknum-1].frames * (outtoc->tracks[trknum-1].datasize + outtoc->tracks[trknum-1].subsize);
-					outtoc->tracks[trknum].frames = (tlen - outinfo->offset[trknum]) / (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
+					outinfo.track[trknum].offset = outinfo.track[trknum-1].offset + outtoc.tracks[trknum-1].frames * (outtoc.tracks[trknum-1].datasize + outtoc.tracks[trknum-1].subsize);
+					outtoc.tracks[trknum].frames = (tlen - outinfo.track[trknum].offset) / (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
 				}
 				else	/* data files are different */
 				{
-					tlen = get_file_size(outinfo->fname[trknum]);
+					tlen = get_file_size(outinfo.track[trknum].fname);
 					if (tlen == 0)
 					{
-						printf("ERROR: couldn't find bin file [%s]\n", outinfo->fname[trknum-1]);
+						printf("ERROR: couldn't find bin file [%s]\n", outinfo.track[trknum-1].fname.cstr());
 						return CHDERR_FILE_NOT_FOUND;
 					}
-					tlen /= (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
-					outtoc->tracks[trknum].frames = tlen;
-					outinfo->offset[trknum] = 0;
+					tlen /= (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
+					outtoc.tracks[trknum].frames = tlen;
+					outinfo.track[trknum].offset = 0;
 				}
 			}
 			else
 			{
 				/* if we have the same filename as the next track, do it that way */
-				if (!strcmp(&outinfo->fname[trknum][0], &outinfo->fname[trknum+1][0]))
+				if (outinfo.track[trknum].fname == outinfo.track[trknum+1].fname)
 				{
-					outtoc->tracks[trknum].frames = outinfo->idx1offs[trknum+1] - outinfo->idx1offs[trknum];
+					outtoc.tracks[trknum].frames = outinfo.track[trknum+1].idx1offs - outinfo.track[trknum].idx1offs;
 
 					if (trknum == 0)	// track 0 offset is 0
 					{
-						outinfo->offset[trknum] = 0;
+						outinfo.track[trknum].offset = 0;
 					}
 					else
 					{
-						outinfo->offset[trknum] = outinfo->offset[trknum-1] + outtoc->tracks[trknum-1].frames * (outtoc->tracks[trknum-1].datasize + outtoc->tracks[trknum-1].subsize);
+						outinfo.track[trknum].offset = outinfo.track[trknum-1].offset + outtoc.tracks[trknum-1].frames * (outtoc.tracks[trknum-1].datasize + outtoc.tracks[trknum-1].subsize);
 					}
 
-					if (!outtoc->tracks[trknum].frames)
+					if (!outtoc.tracks[trknum].frames)
 					{
 						printf("ERROR: unable to determine size of track %d, missing INDEX 01 markers?\n", trknum+1);
 						return CHDERR_FILE_NOT_FOUND;
@@ -824,19 +822,19 @@
 				}
 				else	/* data files are different */
 				{
-					tlen = get_file_size(outinfo->fname[trknum]);
+					tlen = get_file_size(outinfo.track[trknum].fname);
 					if (tlen == 0)
 					{
-						printf("ERROR: couldn't find bin file [%s]\n", outinfo->fname[trknum]);
+						printf("ERROR: couldn't find bin file [%s]\n", outinfo.track[trknum].fname.cstr());
 						return CHDERR_FILE_NOT_FOUND;
 					}
-					tlen /= (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
-					outtoc->tracks[trknum].frames = tlen;
-					outinfo->offset[trknum] = 0;
+					tlen /= (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
+					outtoc.tracks[trknum].frames = tlen;
+					outinfo.track[trknum].offset = 0;
 				}
 			}
 		}
-		printf("trk %d: %d frames @ offset %d\n", trknum+1, outtoc->tracks[trknum].frames, outinfo->offset[trknum]);
+		printf("trk %d: %d frames @ offset %d\n", trknum+1, outtoc.tracks[trknum].frames, outinfo.track[trknum].offset);
 	}
 
 	return CHDERR_NONE;
@@ -846,7 +844,7 @@
     chdcd_parse_toc - parse a CDRDAO format TOC file
 -------------------------------------------------*/
 
-chd_error chdcd_parse_toc(const char *tocfname, cdrom_toc *outtoc, chdcd_track_input_info *outinfo)
+chd_error chdcd_parse_toc(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo)
 {
 	FILE *infile;
 	int i, trknum;
@@ -885,8 +883,8 @@
 	}
 
 	/* clear structures */
-	memset(outtoc, 0, sizeof(cdrom_toc));
-	memset(outinfo, 0, sizeof(chdcd_track_input_info));
+	memset(&outtoc, 0, sizeof(outtoc));
+	outinfo.reset();
 
 	trknum = -1;
 
@@ -910,8 +908,7 @@
 				TOKENIZE
 
 				/* keep the filename */
-				strncpy(outinfo->fname[trknum], path.cstr(), 256);
-				strncat(outinfo->fname[trknum], token, 256);
+				outinfo.track[trknum].fname.cpy(path.cstr()).cat(token);
 
 				/* get either the offset or the length */
 				TOKENIZE
@@ -920,11 +917,11 @@
 				{
 					TOKENIZE
 
-					outinfo->swap[trknum] = 1;
+					outinfo.track[trknum].swap = true;
 				}
 				else
 				{
-					outinfo->swap[trknum] = 0;
+					outinfo.track[trknum].swap = false;
 				}
 
 				if (token[0] == '#')
@@ -937,14 +934,14 @@
 					/* convert the time to an offset */
 					f = msf_to_frames( token );
 
-					f *= (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
+					f *= (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
 				}
 				else
 				{
 					f = 0;
 				}
 
-				outinfo->offset[trknum] = f;
+				outinfo.track[trknum].offset = f;
 
 				TOKENIZE
 
@@ -958,19 +955,19 @@
 					if (isdigit((UINT8)token[0]))
 					{
 						// it was an offset.
-						f *= (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
+						f *= (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
 
-						outinfo->offset[trknum] += f;
+						outinfo.track[trknum].offset += f;
 
 						// this is the length.
 						f = msf_to_frames( token );
 					}
 				}
-				else if( trknum == 0 && outinfo->offset[trknum] != 0 )
+				else if( trknum == 0 && outinfo.track[trknum].offset != 0 )
 				{
 					/* the 1st track might have a length with no offset */
-					f = outinfo->offset[trknum] / (outtoc->tracks[trknum].datasize + outtoc->tracks[trknum].subsize);
-					outinfo->offset[trknum] = 0;
+					f = outinfo.track[trknum].offset / (outtoc.tracks[trknum].datasize + outtoc.tracks[trknum].subsize);
+					outinfo.track[trknum].offset = 0;
 				}
 				else
 				{
@@ -978,7 +975,7 @@
 					f = 0;
 				}
 
-				outtoc->tracks[trknum].frames = f;
+				outtoc.tracks[trknum].frames = f;
 			}
 			else if (!strcmp(token, "TRACK"))
 			{
@@ -987,13 +984,13 @@
 				/* next token on the line is the track type */
 				TOKENIZE
 
-				outtoc->tracks[trknum].trktype = CD_TRACK_MODE1;
-				outtoc->tracks[trknum].datasize = 0;
-				outtoc->tracks[trknum].subtype = CD_SUB_NONE;
-				outtoc->tracks[trknum].subsize = 0;
+				outtoc.tracks[trknum].trktype = CD_TRACK_MODE1;
+				outtoc.tracks[trknum].datasize = 0;
+				outtoc.tracks[trknum].subtype = CD_SUB_NONE;
+				outtoc.tracks[trknum].subsize = 0;
 
-				cdrom_convert_type_string_to_track_info(token, &outtoc->tracks[trknum]);
-				if (outtoc->tracks[trknum].datasize == 0)
+				cdrom_convert_type_string_to_track_info(token, &outtoc.tracks[trknum]);
+				if (outtoc.tracks[trknum].datasize == 0)
 				{
 					printf("ERROR: Unknown track type [%s].  Contact MAMEDEV.\n", token);
 					return CHDERR_FILE_NOT_FOUND;
@@ -1002,7 +999,7 @@
 				/* next (optional) token on the line is the subcode type */
 				TOKENIZE
 
-				cdrom_convert_subtype_string_to_track_info(token, &outtoc->tracks[trknum]);
+				cdrom_convert_subtype_string_to_track_info(token, &outtoc.tracks[trknum]);
 			}
 			else if (!strcmp(token, "START"))
 			{
@@ -1012,7 +1009,7 @@
 				TOKENIZE
 				frames = msf_to_frames( token );
 
-				outtoc->tracks[trknum].pregap = frames;
+				outtoc.tracks[trknum].pregap = frames;
 			}
 		}
 	}
@@ -1021,7 +1018,7 @@
 	fclose(infile);
 
 	/* store the number of tracks found */
-	outtoc->numtrks = trknum + 1;
+	outtoc.numtrks = trknum + 1;
 
 	return CHDERR_NONE;
 }
diff -Nru src-old/lib/util/chdcd.h src/lib/util/chdcd.h
--- src-old/lib/util/chdcd.h	2011-08-20 07:47:40.000000000 +0200
+++ src/lib/util/chdcd.h	2012-02-16 10:47:18.000000000 +0100
@@ -14,17 +14,26 @@
 
 #include "cdrom.h"
 
-typedef struct _chdcd_track_input_info chdcd_track_input_info;
-struct _chdcd_track_input_info	/* used only at compression time */
+struct chdcd_track_input_entry
 {
-	char fname[CD_MAX_TRACKS][256];	/* filename for each track */
-	UINT32 offset[CD_MAX_TRACKS];	/* offset in the data file for each track */
-	int swap[CD_MAX_TRACKS];	/* data needs to be byte swapped */
-	UINT32 idx0offs[CD_MAX_TRACKS];
-	UINT32 idx1offs[CD_MAX_TRACKS];
+	chdcd_track_input_entry() { reset(); }
+	void reset() { fname.reset(); offset = idx0offs = idx1offs = 0; swap = false; }
+
+	astring fname;		// filename for each track
+	UINT32 offset;		// offset in the data file for each track
+	bool swap;			// data needs to be byte swapped
+	UINT32 idx0offs;
+	UINT32 idx1offs;
+};
+
+struct chdcd_track_input_info
+{
+	void reset() { for (int i = 0; i < CD_MAX_TRACKS; i++) track[i].reset(); }
+
+	chdcd_track_input_entry track[CD_MAX_TRACKS];
 };
 
 
-chd_error chdcd_parse_toc(const char *tocfname, cdrom_toc *outtoc, chdcd_track_input_info *outinfo);
+chd_error chdcd_parse_toc(const char *tocfname, cdrom_toc &outtoc, chdcd_track_input_info &outinfo);
 
 #endif	/* __CHDCD_H__ */
diff -Nru src-old/lib/util/chdcodec.c src/lib/util/chdcodec.c
--- src-old/lib/util/chdcodec.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/chdcodec.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,1558 @@
+/***************************************************************************
+
+    chdcodec.c
+
+    Codecs used by the CHD format
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#include "chd.h"
+#include "hashing.h"
+#include "avhuff.h"
+#include "flac.h"
+#include "cdrom.h"
+#include <zlib.h>
+#include "lib7z/LzmaEnc.h"
+#include "lib7z/LzmaDec.h"
+#include <new>
+
+// function that should exist but doesn't in the official release
+extern "C" SRes LzmaDec_Allocate_MAME(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc);
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> chd_zlib_allocator
+
+// allocation helper clas for zlib
+class chd_zlib_allocator
+{
+public:
+	// construction/destruction
+	chd_zlib_allocator();
+	~chd_zlib_allocator();
+
+	// installation
+	void install(z_stream &stream);
+
+private:
+	// internal helpers
+	static voidpf fast_alloc(voidpf opaque, uInt items, uInt size);
+	static void fast_free(voidpf opaque, voidpf address);
+
+	static const int MAX_ZLIB_ALLOCS = 64;
+	UINT32 *				m_allocptr[MAX_ZLIB_ALLOCS];
+};
+
+
+// ======================> chd_zlib_compressor
+
+// ZLIB compressor
+class chd_zlib_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_zlib_compressor(chd_file &chd, bool lossy);
+	~chd_zlib_compressor();
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+private:
+	// internal state
+	z_stream				m_deflater;
+	chd_zlib_allocator		m_allocator;
+};
+
+
+// ======================> chd_zlib_decompressor
+
+// ZLIB decompressor
+class chd_zlib_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_zlib_decompressor(chd_file &chd, bool lossy);
+	~chd_zlib_decompressor();
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+
+private:
+	// internal state
+	z_stream				m_inflater;
+	chd_zlib_allocator		m_allocator;
+};
+
+
+// ======================> chd_lzma_allocator
+
+// allocation helper clas for zlib
+class chd_lzma_allocator : public ISzAlloc
+{
+public:
+	// construction/destruction
+	chd_lzma_allocator();
+	~chd_lzma_allocator();
+
+private:
+	// internal helpers
+	static void *fast_alloc(void *p, size_t size);
+	static void fast_free(void *p, void *address);
+
+	static const int MAX_LZMA_ALLOCS = 64;
+	UINT32 *				m_allocptr[MAX_LZMA_ALLOCS];
+};
+
+
+// ======================> chd_lzma_compressor
+
+// LZMA compressor
+class chd_lzma_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_lzma_compressor(chd_file &chd, bool lossy);
+	~chd_lzma_compressor();
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+	// helpers
+	static void configure_properties(CLzmaEncProps &props, chd_file &chd);
+
+private:
+	// internal state
+	CLzmaEncProps			m_props;
+	chd_lzma_allocator		m_allocator;
+};
+
+
+// ======================> chd_lzma_decompressor
+
+// LZMA decompressor
+class chd_lzma_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_lzma_decompressor(chd_file &chd, bool lossy);
+	~chd_lzma_decompressor();
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+
+private:
+	// internal state
+	CLzmaProps				m_props;
+	CLzmaDec				m_decoder;
+	chd_lzma_allocator		m_allocator;
+};
+
+
+// ======================> chd_huffman_compressor
+
+// Huffman compressor
+class chd_huffman_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_huffman_compressor(chd_file &chd, bool lossy);
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+private:
+	// internal state
+	huffman_8bit_encoder	m_encoder;
+};
+
+
+// ======================> chd_huffman_decompressor
+
+// Huffman decompressor
+class chd_huffman_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_huffman_decompressor(chd_file &chd, bool lossy);
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+
+private:
+	// internal state
+	huffman_8bit_decoder	m_decoder;
+};
+
+
+// ======================> chd_flac_compressor
+
+// FLAC compressor
+class chd_flac_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_flac_compressor(chd_file &chd, bool lossy, bool bigendian);
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+private:
+	// internal state
+	bool			m_swap_endian;
+	flac_encoder	m_encoder;
+};
+
+// big-endian variant
+class chd_flac_compressor_be : public chd_flac_compressor
+{
+public:
+	// construction/destruction
+	chd_flac_compressor_be(chd_file &chd, bool lossy)
+		: chd_flac_compressor(chd, lossy, true) { }
+};
+
+// little-endian variant
+class chd_flac_compressor_le : public chd_flac_compressor
+{
+public:
+	// construction/destruction
+	chd_flac_compressor_le(chd_file &chd, bool lossy)
+		: chd_flac_compressor(chd, lossy, false) { }
+};
+
+
+// ======================> chd_flac_decompressor
+
+// FLAC decompressor
+class chd_flac_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_flac_decompressor(chd_file &chd, bool lossy, bool bigendian);
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+
+private:
+	// internal state
+	bool			m_swap_endian;
+	flac_decoder	m_decoder;
+};
+
+// big-endian variant
+class chd_flac_decompressor_be : public chd_flac_decompressor
+{
+public:
+	// construction/destruction
+	chd_flac_decompressor_be(chd_file &chd, bool lossy)
+		: chd_flac_decompressor(chd, lossy, true) { }
+};
+
+// little-endian variant
+class chd_flac_decompressor_le : public chd_flac_decompressor
+{
+public:
+	// construction/destruction
+	chd_flac_decompressor_le(chd_file &chd, bool lossy)
+		: chd_flac_decompressor(chd, lossy, false) { }
+};
+
+
+// ======================> chd_cd_flac_compressor
+
+// CD/FLAC compressor
+class chd_cd_flac_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_cd_flac_compressor(chd_file &chd, bool lossy);
+	~chd_cd_flac_compressor();
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+private:
+	// internal state
+	bool				m_swap_endian;
+	flac_encoder		m_encoder;
+	z_stream			m_deflater;
+	chd_zlib_allocator	m_allocator;
+	dynamic_buffer		m_buffer;
+};
+
+
+// ======================> chd_cd_flac_decompressor
+
+// FLAC decompressor
+class chd_cd_flac_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_cd_flac_decompressor(chd_file &chd, bool lossy);
+	~chd_cd_flac_decompressor();
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+
+private:
+	// internal state
+	bool				m_swap_endian;
+	flac_decoder		m_decoder;
+	z_stream			m_inflater;
+	chd_zlib_allocator	m_allocator;
+	dynamic_buffer		m_buffer;
+};
+
+
+// ======================> chd_avhuff_compressor
+
+// A/V compressor
+class chd_avhuff_compressor : public chd_compressor
+{
+public:
+	// construction/destruction
+	chd_avhuff_compressor(chd_file &chd, bool lossy);
+
+	// core functionality
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest);
+
+private:
+	// internal helpers
+	void postinit();
+
+	// internal state
+	avhuff_encoder				m_encoder;
+	bool						m_postinit;
+};
+
+
+// ======================> chd_avhuff_decompressor
+
+// A/V decompressor
+class chd_avhuff_decompressor : public chd_decompressor
+{
+public:
+	// construction/destruction
+	chd_avhuff_decompressor(chd_file &chd, bool lossy);
+
+	// core functionality
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen);
+	virtual void configure(int param, void *config);
+
+private:
+	// internal state
+	avhuff_decoder				m_decoder;
+};
+
+
+
+//**************************************************************************
+//  CODEC LIST
+//**************************************************************************
+
+// static list of available known codecs
+const chd_codec_list::codec_entry chd_codec_list::s_codec_list[] =
+{
+	{ CHD_CODEC_ZLIB,		false,	"Deflate",				&chd_codec_list::construct_compressor<chd_zlib_compressor>,		&chd_codec_list::construct_decompressor<chd_zlib_decompressor> },
+	{ CHD_CODEC_LZMA,		false,	"LZMA",					&chd_codec_list::construct_compressor<chd_lzma_compressor>,		&chd_codec_list::construct_decompressor<chd_lzma_decompressor> },
+	{ CHD_CODEC_HUFFMAN,	false,	"Huffman",				&chd_codec_list::construct_compressor<chd_huffman_compressor>,	&chd_codec_list::construct_decompressor<chd_huffman_decompressor> },
+	{ CHD_CODEC_FLAC_BE,	false,	"FLAC, big-endian",		&chd_codec_list::construct_compressor<chd_flac_compressor_be>,	&chd_codec_list::construct_decompressor<chd_flac_decompressor_be> },
+	{ CHD_CODEC_FLAC_LE,	false,	"FLAC, little-endian",	&chd_codec_list::construct_compressor<chd_flac_compressor_le>,	&chd_codec_list::construct_decompressor<chd_flac_decompressor_le> },
+	{ CHD_CODEC_CD_FLAC,	false,	"CD FLAC",				&chd_codec_list::construct_compressor<chd_cd_flac_compressor>,	&chd_codec_list::construct_decompressor<chd_cd_flac_decompressor> },
+	{ CHD_CODEC_AVHUFF,		false,	"A/V Huffman",			&chd_codec_list::construct_compressor<chd_avhuff_compressor>,	&chd_codec_list::construct_decompressor<chd_avhuff_decompressor> },
+};
+
+
+
+//**************************************************************************
+//  CHD CODEC
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_codec - constructor
+//-------------------------------------------------
+
+chd_codec::chd_codec(chd_file &file, bool lossy)
+	: m_chd(file),
+	  m_lossy(lossy)
+{
+}
+
+
+//-------------------------------------------------
+//  ~chd_codec - destructor
+//-------------------------------------------------
+
+chd_codec::~chd_codec()
+{
+}
+
+
+//-------------------------------------------------
+//  configure - configuration
+//-------------------------------------------------
+
+void chd_codec::configure(int param, void *config)
+{
+	// if not overridden, it is always a failure
+	throw CHDERR_INVALID_PARAMETER;
+}
+
+
+
+//**************************************************************************
+//  CHD COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_compressor - constructor
+//-------------------------------------------------
+
+chd_compressor::chd_compressor(chd_file &file, bool lossy)
+	: chd_codec(file, lossy)
+{
+}
+
+
+
+//**************************************************************************
+//  CHD DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_decompressor - constructor
+//-------------------------------------------------
+
+chd_decompressor::chd_decompressor(chd_file &file, bool lossy)
+	: chd_codec(file, lossy)
+{
+}
+
+
+
+//**************************************************************************
+//  CHD CODEC LIST
+//**************************************************************************
+
+//-------------------------------------------------
+//  new_compressor - create a new compressor
+//  instance of the given type
+//-------------------------------------------------
+
+chd_compressor *chd_codec_list::new_compressor(chd_codec_type type, chd_file &file)
+{
+	// find in the list and construct the class
+	const codec_entry *entry = find_in_list(type);
+	return (entry == NULL) ? NULL : (*entry->m_construct_compressor)(file, entry->m_lossy);
+}
+
+
+//-------------------------------------------------
+//  new_compressor - create a new decompressor
+//  instance of the given type
+//-------------------------------------------------
+
+chd_decompressor *chd_codec_list::new_decompressor(chd_codec_type type, chd_file &file)
+{
+	// find in the list and construct the class
+	const codec_entry *entry = find_in_list(type);
+	return (entry == NULL) ? NULL : (*entry->m_construct_decompressor)(file, entry->m_lossy);
+}
+
+
+//-------------------------------------------------
+//  codec_name - return the name of the given
+//  codec
+//-------------------------------------------------
+
+const char *chd_codec_list::codec_name(chd_codec_type type)
+{
+	// find in the list and construct the class
+	const codec_entry *entry = find_in_list(type);
+	return (entry == NULL) ? NULL : entry->m_name;
+}
+
+
+//-------------------------------------------------
+//  find_in_list - create a new compressor
+//  instance of the given type
+//-------------------------------------------------
+
+const chd_codec_list::codec_entry *chd_codec_list::find_in_list(chd_codec_type type)
+{
+	// find in the list and construct the class
+	for (int listnum = 0; listnum < ARRAY_LENGTH(s_codec_list); listnum++)
+		if (s_codec_list[listnum].m_type == type)
+			return &s_codec_list[listnum];
+	return NULL;
+}
+
+
+
+//**************************************************************************
+//  CODEC INSTANCE
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_compressor_group - constructor
+//-------------------------------------------------
+
+chd_compressor_group::chd_compressor_group(chd_file &file, UINT32 compressor_list[4])
+	: m_hunkbytes(file.hunk_bytes()),
+	  m_compress_test(m_hunkbytes)
+#if CHDCODEC_VERIFY_COMPRESSION
+	  ,m_decompressed(m_hunkbytes)
+#endif
+{
+	// verify the compression types and initialize the codecs
+	for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_compressor); codecnum++)
+	{
+		m_compressor[codecnum] = NULL;
+		if (compressor_list[codecnum] != CHD_CODEC_NONE)
+		{
+			m_compressor[codecnum] = chd_codec_list::new_compressor(compressor_list[codecnum], file);
+			if (m_compressor[codecnum] == NULL)
+				throw CHDERR_UNKNOWN_COMPRESSION;
+#if CHDCODEC_VERIFY_COMPRESSION
+			m_decompressor[codecnum] = chd_codec_list::new_decompressor(compressor_list[codecnum], file);
+			if (m_decompressor[codecnum] == NULL)
+				throw CHDERR_UNKNOWN_COMPRESSION;
+#endif
+		}
+	}
+}
+
+
+//-------------------------------------------------
+//  ~chd_compressor_group - destructor
+//-------------------------------------------------
+
+chd_compressor_group::~chd_compressor_group()
+{
+	// delete the codecs and the test buffer
+	for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_compressor); codecnum++)
+		delete m_compressor[codecnum];
+}
+
+
+//-------------------------------------------------
+//  find_best_compressor - iterate over all codecs
+//  to determine which one produces the best
+//  compression for this hunk
+//-------------------------------------------------
+
+INT8 chd_compressor_group::find_best_compressor(const UINT8 *src, UINT8 *compressed, UINT32 &complen)
+{
+	// determine best compression technique
+	complen = m_hunkbytes;
+	INT8 compression = -1;
+	for (int codecnum = 0; codecnum < ARRAY_LENGTH(m_compressor); codecnum++)
+		if (m_compressor[codecnum] != NULL)
+		{
+			// attempt to compress, swallowing errors
+			try
+			{
+				// if this is the best one, copy the data into the permanent buffer
+				UINT32 compbytes = m_compressor[codecnum]->compress(src, m_hunkbytes, m_compress_test);
+#if CHDCODEC_VERIFY_COMPRESSION
+				try
+				{
+					memset(m_decompressed, 0, m_hunkbytes);
+					m_decompressor[codecnum]->decompress(m_compress_test, compbytes, m_decompressed, m_hunkbytes);
+				}
+				catch (...)
+				{
+				}
+
+				if (memcmp(src, m_decompressed, m_hunkbytes) != 0)
+				{
+					compbytes = m_compressor[codecnum]->compress(src, m_hunkbytes, m_compress_test);
+					try
+					{
+						m_decompressor[codecnum]->decompress(m_compress_test, compbytes, m_decompressed, m_hunkbytes);
+					}
+					catch (...)
+					{
+						memset(m_decompressed, 0, m_hunkbytes);
+					}
+				}
+printf("   codec%d=%d bytes            \n", codecnum, compbytes);
+#endif
+				if (compbytes < complen)
+				{
+					compression = codecnum;
+					complen = compbytes;
+					memcpy(compressed, m_compress_test, compbytes);
+				}
+			}
+			catch (...) { }
+		}
+
+	// if the best is none, copy it over
+	if (compression == -1)
+		memcpy(compressed, src, m_hunkbytes);
+	return compression;
+}
+
+
+
+//**************************************************************************
+//  ZLIB ALLOCATOR HELPER
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_zlib_allocator - constructor
+//-------------------------------------------------
+
+chd_zlib_allocator::chd_zlib_allocator()
+{
+	// reset pointer list
+	memset(m_allocptr, 0, sizeof(m_allocptr));
+}
+
+
+//-------------------------------------------------
+//  ~chd_zlib_allocator - constructor
+//-------------------------------------------------
+
+chd_zlib_allocator::~chd_zlib_allocator()
+{
+	// free our memory
+	for (int memindex = 0; memindex < ARRAY_LENGTH(m_allocptr); memindex++)
+		delete[] m_allocptr[memindex];
+}
+
+
+//-------------------------------------------------
+//  install - configure the allocators for a
+//  stream
+//-------------------------------------------------
+
+void chd_zlib_allocator::install(z_stream &stream)
+{
+	stream.zalloc = &chd_zlib_allocator::fast_alloc;
+	stream.zfree = &chd_zlib_allocator::fast_free;
+	stream.opaque = this;
+}
+
+
+//-------------------------------------------------
+//  zlib_fast_alloc - fast malloc for ZLIB, which
+//  allocates and frees memory frequently
+//-------------------------------------------------
+
+voidpf chd_zlib_allocator::fast_alloc(voidpf opaque, uInt items, uInt size)
+{
+	chd_zlib_allocator *codec = reinterpret_cast<chd_zlib_allocator *>(opaque);
+
+	// compute the size, rounding to the nearest 1k
+	size = (size * items + 0x3ff) & ~0x3ff;
+
+	// reuse a hunk if we can
+	for (int scan = 0; scan < MAX_ZLIB_ALLOCS; scan++)
+	{
+		UINT32 *ptr = codec->m_allocptr[scan];
+		if (ptr != NULL && size == *ptr)
+		{
+			// set the low bit of the size so we don't match next time
+			*ptr |= 1;
+			return ptr + 1;
+		}
+	}
+
+	// alloc a new one and put it into the list
+	UINT32 *ptr = reinterpret_cast<UINT32 *>(new UINT8[size + sizeof(UINT32)]);
+	for (int scan = 0; scan < MAX_ZLIB_ALLOCS; scan++)
+		if (codec->m_allocptr[scan] == NULL)
+		{
+			codec->m_allocptr[scan] = ptr;
+			break;
+		}
+
+	// set the low bit of the size so we don't match next time
+	*ptr = size | 1;
+	return ptr + 1;
+}
+
+
+//-------------------------------------------------
+//  zlib_fast_free - fast free for ZLIB, which
+//  allocates and frees memory frequently
+//-------------------------------------------------
+
+void chd_zlib_allocator::fast_free(voidpf opaque, voidpf address)
+{
+	chd_zlib_allocator *codec = reinterpret_cast<chd_zlib_allocator *>(opaque);
+
+	// find the hunk
+	UINT32 *ptr = reinterpret_cast<UINT32 *>(address) - 1;
+	for (int scan = 0; scan < MAX_ZLIB_ALLOCS; scan++)
+		if (ptr == codec->m_allocptr[scan])
+		{
+			// clear the low bit of the size to allow matches
+			*ptr &= ~1;
+			return;
+		}
+}
+
+
+
+//**************************************************************************
+//  ZLIB COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_zlib_compressor - constructor
+//-------------------------------------------------
+
+chd_zlib_compressor::chd_zlib_compressor(chd_file &chd, bool lossy)
+	: chd_compressor(chd, lossy)
+{
+	// initialize the deflater
+	m_deflater.next_in = (Bytef *)this;	// bogus, but that's ok
+	m_deflater.avail_in = 0;
+	m_allocator.install(m_deflater);
+	int zerr = deflateInit2(&m_deflater, Z_BEST_COMPRESSION, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY);
+
+	// convert errors
+	if (zerr == Z_MEM_ERROR)
+		throw std::bad_alloc();
+	else if (zerr != Z_OK)
+		throw CHDERR_CODEC_ERROR;
+}
+
+
+//-------------------------------------------------
+//  ~chd_zlib_compressor - destructor
+//-------------------------------------------------
+
+chd_zlib_compressor::~chd_zlib_compressor()
+{
+	deflateEnd(&m_deflater);
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the ZLIB codec
+//-------------------------------------------------
+
+UINT32 chd_zlib_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	// reset the decompressor
+	m_deflater.next_in = const_cast<Bytef *>(src);
+	m_deflater.avail_in = srclen;
+	m_deflater.total_in = 0;
+	m_deflater.next_out = dest;
+	m_deflater.avail_out = srclen;
+	m_deflater.total_out = 0;
+	int zerr = deflateReset(&m_deflater);
+	if (zerr != Z_OK)
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// do it
+	zerr = deflate(&m_deflater, Z_FINISH);
+
+	// if we ended up with more data than we started with, return an error
+	if (zerr != Z_STREAM_END || m_deflater.total_out >= srclen)
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// otherwise, return the length
+	return m_deflater.total_out;
+}
+
+
+
+//**************************************************************************
+//  ZLIB DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_zlib_decompressor - constructor
+//-------------------------------------------------
+
+chd_zlib_decompressor::chd_zlib_decompressor(chd_file &chd, bool lossy)
+	: chd_decompressor(chd, lossy)
+{
+	// init the inflater
+	m_inflater.next_in = (Bytef *)this;	// bogus, but that's ok
+	m_inflater.avail_in = 0;
+	m_allocator.install(m_inflater);
+	int zerr = inflateInit2(&m_inflater, -MAX_WBITS);
+
+	// convert errors
+	if (zerr == Z_MEM_ERROR)
+		throw std::bad_alloc();
+	else if (zerr != Z_OK)
+		throw CHDERR_CODEC_ERROR;
+}
+
+
+//-------------------------------------------------
+//  ~chd_zlib_decompressor - destructor
+//-------------------------------------------------
+
+chd_zlib_decompressor::~chd_zlib_decompressor()
+{
+	inflateEnd(&m_inflater);
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the ZLIB
+//  codec
+//-------------------------------------------------
+
+void chd_zlib_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	// reset the decompressor
+	m_inflater.next_in = const_cast<Bytef *>(src);
+	m_inflater.avail_in = complen;
+	m_inflater.total_in = 0;
+	m_inflater.next_out = dest;
+	m_inflater.avail_out = destlen;
+	m_inflater.total_out = 0;
+	int zerr = inflateReset(&m_inflater);
+	if (zerr != Z_OK)
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// do it
+	zerr = inflate(&m_inflater, Z_FINISH);
+	if (m_inflater.total_out != destlen)
+		throw CHDERR_DECOMPRESSION_ERROR;
+}
+
+
+
+//**************************************************************************
+//  LZMA ALLOCATOR HELPER
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_lzma_allocator - constructor
+//-------------------------------------------------
+
+chd_lzma_allocator::chd_lzma_allocator()
+{
+	// reset pointer list
+	memset(m_allocptr, 0, sizeof(m_allocptr));
+
+	// set our pointers
+	Alloc = &chd_lzma_allocator::fast_alloc;
+	Free = &chd_lzma_allocator::fast_free;
+}
+
+
+//-------------------------------------------------
+//  ~chd_lzma_allocator - constructor
+//-------------------------------------------------
+
+chd_lzma_allocator::~chd_lzma_allocator()
+{
+	// free our memory
+	for (int memindex = 0; memindex < ARRAY_LENGTH(m_allocptr); memindex++)
+		delete[] m_allocptr[memindex];
+}
+
+
+//-------------------------------------------------
+//  lzma_fast_alloc - fast malloc for lzma, which
+//  allocates and frees memory frequently
+//-------------------------------------------------
+
+void *chd_lzma_allocator::fast_alloc(void *p, size_t size)
+{
+	chd_lzma_allocator *codec = reinterpret_cast<chd_lzma_allocator *>(p);
+
+	// compute the size, rounding to the nearest 1k
+	size = (size + 0x3ff) & ~0x3ff;
+
+	// reuse a hunk if we can
+	for (int scan = 0; scan < MAX_LZMA_ALLOCS; scan++)
+	{
+		UINT32 *ptr = codec->m_allocptr[scan];
+		if (ptr != NULL && size == *ptr)
+		{
+			// set the low bit of the size so we don't match next time
+			*ptr |= 1;
+			return ptr + 1;
+		}
+	}
+
+	// alloc a new one and put it into the list
+	UINT32 *ptr = reinterpret_cast<UINT32 *>(new UINT8[size + sizeof(UINT32)]);
+	for (int scan = 0; scan < MAX_LZMA_ALLOCS; scan++)
+		if (codec->m_allocptr[scan] == NULL)
+		{
+			codec->m_allocptr[scan] = ptr;
+			break;
+		}
+
+	// set the low bit of the size so we don't match next time
+	*ptr = size | 1;
+	return ptr + 1;
+}
+
+
+//-------------------------------------------------
+//  lzma_fast_free - fast free for lzma, which
+//  allocates and frees memory frequently
+//-------------------------------------------------
+
+void chd_lzma_allocator::fast_free(void *p, void *address)
+{
+	if (address == NULL)
+		return;
+
+	chd_lzma_allocator *codec = reinterpret_cast<chd_lzma_allocator *>(p);
+
+	// find the hunk
+	UINT32 *ptr = reinterpret_cast<UINT32 *>(address) - 1;
+	for (int scan = 0; scan < MAX_LZMA_ALLOCS; scan++)
+		if (ptr == codec->m_allocptr[scan])
+		{
+			// clear the low bit of the size to allow matches
+			*ptr &= ~1;
+			return;
+		}
+}
+
+
+
+//**************************************************************************
+//  LZMA COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_lzma_compressor - constructor
+//-------------------------------------------------
+
+chd_lzma_compressor::chd_lzma_compressor(chd_file &chd, bool lossy)
+	: chd_compressor(chd, lossy)
+{
+	// initialize the properties
+	configure_properties(m_props, chd);
+}
+
+
+//-------------------------------------------------
+//  ~chd_lzma_compressor - destructor
+//-------------------------------------------------
+
+chd_lzma_compressor::~chd_lzma_compressor()
+{
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the LZMA codec
+//-------------------------------------------------
+
+UINT32 chd_lzma_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	// allocate the encoder
+	CLzmaEncHandle encoder = LzmaEnc_Create(&m_allocator);
+	if (encoder == NULL)
+		throw CHDERR_COMPRESSION_ERROR;
+
+	try
+	{
+		// configure the encoder
+		SRes res = LzmaEnc_SetProps(encoder, &m_props);
+		if (res != SZ_OK)
+			throw CHDERR_COMPRESSION_ERROR;
+
+		// run it
+		SizeT complen = srclen;
+		res = LzmaEnc_MemEncode(encoder, dest, &complen, src, srclen, 0, NULL, &m_allocator, &m_allocator);
+		if (res != SZ_OK)
+			throw CHDERR_COMPRESSION_ERROR;
+
+		// clean up
+		LzmaEnc_Destroy(encoder, &m_allocator, &m_allocator);
+		return complen;
+	}
+	catch (...)
+	{
+		// destroy before re-throwing
+		LzmaEnc_Destroy(encoder, &m_allocator, &m_allocator);
+		throw;
+	}
+}
+
+
+//-------------------------------------------------
+//  configure_properties - configure the LZMA
+//  codec
+//-------------------------------------------------
+
+void chd_lzma_compressor::configure_properties(CLzmaEncProps &props, chd_file &chd)
+{
+	LzmaEncProps_Init(&props);
+	props.level = 9;
+	props.reduceSize = chd.hunk_bytes();
+	LzmaEncProps_Normalize(&props);
+}
+
+
+
+//**************************************************************************
+//  LZMA DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_lzma_decompressor - constructor
+//-------------------------------------------------
+
+chd_lzma_decompressor::chd_lzma_decompressor(chd_file &chd, bool lossy)
+	: chd_decompressor(chd, lossy)
+{
+	// construct the decoder
+	LzmaDec_Construct(&m_decoder);
+
+	// configure the properties like the compressor did
+	CLzmaEncProps encoder_props;
+	chd_lzma_compressor::configure_properties(encoder_props, chd);
+
+	// convert to decoder properties
+	CLzmaProps decoder_props;
+	decoder_props.lc = encoder_props.lc;
+	decoder_props.lp = encoder_props.lp;
+	decoder_props.pb = encoder_props.pb;
+	decoder_props.dicSize = encoder_props.dictSize;
+
+	// do memory allocations
+	SRes res = LzmaDec_Allocate_MAME(&m_decoder, &decoder_props, &m_allocator);
+	if (res != SZ_OK)
+		throw CHDERR_DECOMPRESSION_ERROR;
+}
+
+
+//-------------------------------------------------
+//  ~chd_lzma_decompressor - destructor
+//-------------------------------------------------
+
+chd_lzma_decompressor::~chd_lzma_decompressor()
+{
+	// free memory
+	LzmaDec_Free(&m_decoder, &m_allocator);
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the LZMA
+//  codec
+//-------------------------------------------------
+
+void chd_lzma_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	// initialize
+	LzmaDec_Init(&m_decoder);
+
+	// decode
+	SizeT consumedlen = complen;
+	SizeT decodedlen = destlen;
+	ELzmaStatus status;
+	SRes res = LzmaDec_DecodeToBuf(&m_decoder, dest, &decodedlen, src, &consumedlen, LZMA_FINISH_END, &status);
+	if ((res != SZ_OK && res != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK) || consumedlen != complen || decodedlen != destlen)
+		throw CHDERR_DECOMPRESSION_ERROR;
+}
+
+
+
+//**************************************************************************
+//  HUFFMAN COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_huffman_compressor - constructor
+//-------------------------------------------------
+
+chd_huffman_compressor::chd_huffman_compressor(chd_file &chd, bool lossy)
+	: chd_compressor(chd, lossy)
+{
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the Huffman
+//  codec
+//-------------------------------------------------
+
+UINT32 chd_huffman_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	UINT32 complen;
+	if (m_encoder.encode(src, srclen, dest, srclen, complen) != HUFFERR_NONE)
+		throw CHDERR_COMPRESSION_ERROR;
+	return complen;
+}
+
+
+
+//**************************************************************************
+//  HUFFMAN DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_huffman_decompressor - constructor
+//-------------------------------------------------
+
+chd_huffman_decompressor::chd_huffman_decompressor(chd_file &chd, bool lossy)
+	: chd_decompressor(chd, lossy)
+{
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the Huffman
+//  codec
+//-------------------------------------------------
+
+void chd_huffman_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	if (m_decoder.decode(src, complen, dest, destlen) != HUFFERR_NONE)
+		throw CHDERR_COMPRESSION_ERROR;
+}
+
+
+
+//**************************************************************************
+//  FLAC COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_flac_compressor - constructor
+//-------------------------------------------------
+
+chd_flac_compressor::chd_flac_compressor(chd_file &chd, bool lossy, bool bigendian)
+	: chd_compressor(chd, lossy)
+{
+	// determine whether we want native or swapped samples
+	UINT16 native_endian = 0;
+	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
+	if (native_endian == 1)
+		m_swap_endian = bigendian;
+	else
+		m_swap_endian = !bigendian;
+
+	// configure the encoder
+	m_encoder.set_sample_rate(44100);
+	m_encoder.set_num_channels(2);
+	m_encoder.set_block_size(chd.hunk_bytes() / 4);
+	m_encoder.set_strip_metadata(true);
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the FLAC codec
+//-------------------------------------------------
+
+UINT32 chd_flac_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	// reset and encode
+	m_encoder.reset(dest, chd().hunk_bytes());
+	if (!m_encoder.encode_interleaved(reinterpret_cast<const INT16 *>(src), srclen / 4, m_swap_endian))
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// finish up
+	UINT32 complen = m_encoder.finish();
+	if (complen >= chd().hunk_bytes())
+		throw CHDERR_COMPRESSION_ERROR;
+	return complen;
+}
+
+
+
+//**************************************************************************
+//  FLAC DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_flac_decompressor - constructor
+//-------------------------------------------------
+
+chd_flac_decompressor::chd_flac_decompressor(chd_file &chd, bool lossy, bool bigendian)
+	: chd_decompressor(chd, lossy)
+{
+	// determine whether we want native or swapped samples
+	UINT16 native_endian = 0;
+	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
+	if (native_endian == 1)
+		m_swap_endian = bigendian;
+	else
+		m_swap_endian = !bigendian;
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the FLAC
+//  codec
+//-------------------------------------------------
+
+void chd_flac_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	// reset and decode
+	if (!m_decoder.reset(44100, 2, chd().hunk_bytes() / 4, src, complen))
+		throw CHDERR_DECOMPRESSION_ERROR;
+	if (!m_decoder.decode_interleaved(reinterpret_cast<INT16 *>(dest), destlen / 4, m_swap_endian))
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// finish up
+	m_decoder.finish();
+}
+
+
+
+//**************************************************************************
+//  CD FLAC COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_cd_flac_compressor - constructor
+//-------------------------------------------------
+
+chd_cd_flac_compressor::chd_cd_flac_compressor(chd_file &chd, bool lossy)
+	: chd_compressor(chd, lossy),
+	  m_buffer(chd.hunk_bytes())
+{
+	// make sure the CHD's hunk size is an even multiple of the frame size
+	if (chd.hunk_bytes() % CD_FRAME_SIZE != 0)
+		throw CHDERR_CODEC_ERROR;
+
+	// determine whether we want native or swapped samples
+	UINT16 native_endian = 0;
+	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
+	m_swap_endian = (native_endian == 1);
+
+	// configure the encoder
+	m_encoder.set_sample_rate(44100);
+	m_encoder.set_num_channels(2);
+	m_encoder.set_block_size((chd.hunk_bytes() / CD_FRAME_SIZE) * (CD_MAX_SECTOR_DATA/4));
+	m_encoder.set_strip_metadata(true);
+
+	// initialize the deflater
+	m_deflater.next_in = (Bytef *)this;	// bogus, but that's ok
+	m_deflater.avail_in = 0;
+	m_allocator.install(m_deflater);
+	int zerr = deflateInit2(&m_deflater, Z_BEST_COMPRESSION, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY);
+
+	// convert errors
+	if (zerr == Z_MEM_ERROR)
+		throw std::bad_alloc();
+	else if (zerr != Z_OK)
+		throw CHDERR_CODEC_ERROR;
+}
+
+
+//-------------------------------------------------
+//  ~chd_cd_flac_compressor - destructor
+//-------------------------------------------------
+
+chd_cd_flac_compressor::~chd_cd_flac_compressor()
+{
+	deflateEnd(&m_deflater);
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the FLAC codec,
+//  and use zlib on the subcode data
+//-------------------------------------------------
+
+UINT32 chd_cd_flac_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	// copy audio data followed by subcode data
+	UINT32 frames = chd().hunk_bytes() / CD_FRAME_SIZE;
+	for (UINT32 framenum = 0; framenum < frames; framenum++)
+	{
+		memcpy(&m_buffer[framenum * CD_MAX_SECTOR_DATA], &src[framenum * CD_FRAME_SIZE], CD_MAX_SECTOR_DATA);
+		memcpy(&m_buffer[frames * CD_MAX_SECTOR_DATA + framenum * CD_MAX_SUBCODE_DATA], &src[framenum * CD_FRAME_SIZE + CD_MAX_SECTOR_DATA], CD_MAX_SUBCODE_DATA);
+	}
+
+	// reset and encode the audio portion
+	m_encoder.reset(dest, chd().hunk_bytes());
+	UINT8 *buffer = m_buffer;
+	if (!m_encoder.encode_interleaved(reinterpret_cast<INT16 *>(buffer), frames * CD_MAX_SECTOR_DATA/4, m_swap_endian))
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// finish up
+	UINT32 complen = m_encoder.finish();
+
+	// deflate the subcode data
+	m_deflater.next_in = const_cast<Bytef *>(&m_buffer[frames * CD_MAX_SECTOR_DATA]);
+	m_deflater.avail_in = frames * CD_MAX_SUBCODE_DATA;
+	m_deflater.total_in = 0;
+	m_deflater.next_out = &dest[complen];
+	m_deflater.avail_out = chd().hunk_bytes() - complen;
+	m_deflater.total_out = 0;
+	int zerr = deflateReset(&m_deflater);
+	if (zerr != Z_OK)
+		throw CHDERR_COMPRESSION_ERROR;
+
+	// do it
+	zerr = deflate(&m_deflater, Z_FINISH);
+
+	// if we ended up with more data than we started with, return an error
+	complen += m_deflater.total_out;
+	if (zerr != Z_STREAM_END || complen >= srclen)
+		throw CHDERR_COMPRESSION_ERROR;
+	return complen;
+}
+
+
+
+//**************************************************************************
+//  CD FLAC DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_cd_flac_decompressor - constructor
+//-------------------------------------------------
+
+chd_cd_flac_decompressor::chd_cd_flac_decompressor(chd_file &chd, bool lossy)
+	: chd_decompressor(chd, lossy),
+	  m_buffer(chd.hunk_bytes())
+{
+	// make sure the CHD's hunk size is an even multiple of the frame size
+	if (chd.hunk_bytes() % CD_FRAME_SIZE != 0)
+		throw CHDERR_CODEC_ERROR;
+
+	// determine whether we want native or swapped samples
+	UINT16 native_endian = 0;
+	*reinterpret_cast<UINT8 *>(&native_endian) = 1;
+	m_swap_endian = (native_endian == 1);
+
+	// init the inflater
+	m_inflater.next_in = (Bytef *)this;	// bogus, but that's ok
+	m_inflater.avail_in = 0;
+	m_allocator.install(m_inflater);
+	int zerr = inflateInit2(&m_inflater, -MAX_WBITS);
+
+	// convert errors
+	if (zerr == Z_MEM_ERROR)
+		throw std::bad_alloc();
+	else if (zerr != Z_OK)
+		throw CHDERR_CODEC_ERROR;
+}
+
+
+//-------------------------------------------------
+//  ~chd_cd_flac_decompressor - destructor
+//-------------------------------------------------
+
+chd_cd_flac_decompressor::~chd_cd_flac_decompressor()
+{
+	inflateEnd(&m_inflater);
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the FLAC
+//  codec
+//-------------------------------------------------
+
+void chd_cd_flac_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	// reset and decode
+	UINT32 frames = chd().hunk_bytes() / CD_FRAME_SIZE;
+	if (!m_decoder.reset(44100, 2, frames * CD_MAX_SECTOR_DATA/4, src, complen))
+		throw CHDERR_DECOMPRESSION_ERROR;
+	UINT8 *buffer = m_buffer;
+	if (!m_decoder.decode_interleaved(reinterpret_cast<INT16 *>(buffer), frames * CD_MAX_SECTOR_DATA/4, m_swap_endian))
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// inflate the subcode data
+	UINT32 offset = m_decoder.finish();
+	m_inflater.next_in = const_cast<Bytef *>(src + offset);
+	m_inflater.avail_in = complen - offset;
+	m_inflater.total_in = 0;
+	m_inflater.next_out = &m_buffer[frames * CD_MAX_SECTOR_DATA];
+	m_inflater.avail_out = frames * CD_MAX_SUBCODE_DATA;
+	m_inflater.total_out = 0;
+	int zerr = inflateReset(&m_inflater);
+	if (zerr != Z_OK)
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// do it
+	zerr = inflate(&m_inflater, Z_FINISH);
+	if (m_inflater.total_out != frames * CD_MAX_SUBCODE_DATA)
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// reassemble the data
+	for (UINT32 framenum = 0; framenum < frames; framenum++)
+	{
+		memcpy(&dest[framenum * CD_FRAME_SIZE], &m_buffer[framenum * CD_MAX_SECTOR_DATA], CD_MAX_SECTOR_DATA);
+		memcpy(&dest[framenum * CD_FRAME_SIZE + CD_MAX_SECTOR_DATA], &m_buffer[frames * CD_MAX_SECTOR_DATA + framenum * CD_MAX_SUBCODE_DATA], CD_MAX_SUBCODE_DATA);
+	}
+}
+
+
+
+//**************************************************************************
+//  AVHUFF COMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_avhuff_compressor - constructor
+//-------------------------------------------------
+
+chd_avhuff_compressor::chd_avhuff_compressor(chd_file &chd, bool lossy)
+	: chd_compressor(chd, lossy),
+	  m_postinit(false)
+{
+	try
+	{
+		// attempt to do a post-init now
+		postinit();
+	}
+	catch (chd_error &)
+	{
+		// if we're creating a new CHD, it won't work but that's ok
+	}
+}
+
+
+//-------------------------------------------------
+//  compress - compress data using the A/V codec
+//-------------------------------------------------
+
+UINT32 chd_avhuff_compressor::compress(const UINT8 *src, UINT32 srclen, UINT8 *dest)
+{
+	// if we haven't yet set up the avhuff code, do it now
+	if (!m_postinit)
+		postinit();
+
+	// make sure short frames are padded with 0
+	if (src != NULL)
+	{
+		int size = avhuff_encoder::raw_data_size(src);
+		while (size < srclen)
+			if (src[size++] != 0)
+				throw CHDERR_INVALID_DATA;
+	}
+
+	// encode the audio and video
+	UINT32 complen;
+	avhuff_error averr = m_encoder.encode_data(src, dest, complen);
+	if (averr != AVHERR_NONE || complen > srclen)
+		throw CHDERR_COMPRESSION_ERROR;
+	return complen;
+}
+
+
+//-------------------------------------------------
+//  postinit - actual initialization of avhuff
+//  happens here, on the first attempt to compress
+//  or decompress data
+//-------------------------------------------------
+
+void chd_avhuff_compressor::postinit()
+{
+	// get the metadata
+	astring metadata;
+	chd_error err = chd().read_metadata(AV_METADATA_TAG, 0, metadata);
+	if (err != CHDERR_NONE)
+		throw err;
+
+	// extract the info
+	int fps, fpsfrac, width, height, interlaced, channels, rate;
+	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
+		throw CHDERR_INVALID_METADATA;
+
+	// compute the bytes per frame
+	UINT32 fps_times_1million = fps * 1000000 + fpsfrac;
+	UINT32 max_samples_per_frame = (UINT64(rate) * 1000000 + fps_times_1million - 1) / fps_times_1million;
+	UINT32 bytes_per_frame = 12 + channels * max_samples_per_frame * 2 + width * height * 2;
+	if (bytes_per_frame > chd().hunk_bytes())
+		throw CHDERR_INVALID_METADATA;
+
+	// done with post-init
+	m_postinit = true;
+}
+
+
+
+//**************************************************************************
+//  AVHUFF DECOMPRESSOR
+//**************************************************************************
+
+//-------------------------------------------------
+//  chd_avhuff_decompressor - constructor
+//-------------------------------------------------
+
+chd_avhuff_decompressor::chd_avhuff_decompressor(chd_file &chd, bool lossy)
+	: chd_decompressor(chd, lossy)
+{
+}
+
+
+//-------------------------------------------------
+//  decompress - decompress data using the A/V
+//  codec
+//-------------------------------------------------
+
+void chd_avhuff_decompressor::decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen)
+{
+	// decode the audio and video
+	avhuff_error averr = m_decoder.decode_data(src, complen, dest);
+	if (averr != AVHERR_NONE)
+		throw CHDERR_DECOMPRESSION_ERROR;
+
+	// pad short frames with 0
+	if (dest != NULL)
+	{
+		int size = avhuff_encoder::raw_data_size(dest);
+		if (size < destlen)
+			memset(dest + size, 0, destlen - size);
+	}
+}
+
+
+//-------------------------------------------------
+//  config - codec-specific configuration for the
+//  A/V codec
+//-------------------------------------------------
+
+void chd_avhuff_decompressor::configure(int param, void *config)
+{
+	// if we're getting the decompression configuration, apply it now
+	if (param == AVHUFF_CODEC_DECOMPRESS_CONFIG)
+		m_decoder.configure(*reinterpret_cast<avhuff_decompress_config *>(config));
+
+	// anything else is invalid
+	else
+		throw CHDERR_INVALID_PARAMETER;
+}
diff -Nru src-old/lib/util/chdcodec.h src/lib/util/chdcodec.h
--- src-old/lib/util/chdcodec.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/chdcodec.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,213 @@
+/***************************************************************************
+
+    chdcodec.h
+
+    Codecs used by the CHD format
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __CHDCODEC_H__
+#define __CHDCODEC_H__
+
+#include "osdcore.h"
+
+
+#define CHDCODEC_VERIFY_COMPRESSION 0
+
+
+//**************************************************************************
+//  MACROS
+//**************************************************************************
+
+#define CHD_MAKE_TAG(a,b,c,d)		(((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// forward references
+class chd_file;
+
+// base types
+typedef UINT32 chd_codec_type;
+
+
+// ======================> chd_codec
+
+// common base class for all compressors and decompressors
+class chd_codec
+{
+protected:
+	// can't create these directly
+	chd_codec(chd_file &file, bool lossy);
+
+public:
+	// allow public deletion
+	virtual ~chd_codec();
+
+	// accessors
+	chd_file &chd() const { return m_chd; }
+	bool lossy() const { return m_lossy; }
+
+	// implementation
+	virtual void configure(int param, void *config);
+
+private:
+	// internal state
+	chd_file &			m_chd;
+	bool				m_lossy;
+};
+
+
+// ======================> chd_compressor
+
+// base class for all compressors
+class chd_compressor : public chd_codec
+{
+protected:
+	// can't create these directly
+	chd_compressor(chd_file &file, bool lossy);
+
+public:
+	// implementation
+	virtual UINT32 compress(const UINT8 *src, UINT32 srclen, UINT8 *dest) = 0;
+};
+
+
+// ======================> chd_decompressor
+
+// base class for all decompressors
+class chd_decompressor : public chd_codec
+{
+protected:
+	// can't create these directly
+	chd_decompressor(chd_file &file, bool lossy);
+
+public:
+	// implementation
+	virtual void decompress(const UINT8 *src, UINT32 complen, UINT8 *dest, UINT32 destlen) = 0;
+};
+
+
+// ======================> chd_codec_list
+
+// wrapper to get at the list of codecs
+class chd_codec_list
+{
+public:
+	// create compressors or decompressors
+	static chd_compressor *new_compressor(chd_codec_type type, chd_file &file);
+	static chd_decompressor *new_decompressor(chd_codec_type type, chd_file &file);
+
+	// utilities
+	static bool codec_exists(chd_codec_type type) { return (find_in_list(type) != NULL); }
+	static const char *codec_name(chd_codec_type type);
+
+private:
+	// an entry in the list
+	struct codec_entry
+	{
+		chd_codec_type		m_type;
+		bool				m_lossy;
+		const char *		m_name;
+		chd_compressor *	(*m_construct_compressor)(chd_file &, bool);
+		chd_decompressor *	(*m_construct_decompressor)(chd_file &, bool);
+	};
+
+	// internal helper functions
+	static const codec_entry *find_in_list(chd_codec_type type);
+
+	template<class _CompressorClass>
+	static chd_compressor *construct_compressor(chd_file &chd, bool lossy) { return new _CompressorClass(chd, lossy); }
+
+	template<class _DecompressorClass>
+	static chd_decompressor *construct_decompressor(chd_file &chd, bool lossy) { return new _DecompressorClass(chd, lossy); }
+
+	// the static list
+	static const codec_entry s_codec_list[];
+};
+
+
+// ======================> chd_compressor_group
+
+// helper class that wraps several compressors
+class chd_compressor_group
+{
+public:
+	// construction/destruction
+	chd_compressor_group(chd_file &file, chd_codec_type compressor_list[4]);
+	~chd_compressor_group();
+
+	// find the best compressor
+	INT8 find_best_compressor(const UINT8 *src, UINT8 *compressed, UINT32 &complen);
+
+private:
+	// internal state
+	UINT32					m_hunkbytes;		// number of bytes in a hunk
+	chd_compressor *		m_compressor[4];	// array of active codecs
+	dynamic_buffer			m_compress_test;	// test buffer for compression
+#if CHDCODEC_VERIFY_COMPRESSION
+	chd_decompressor *		m_decompressor[4];	// array of active codecs
+	dynamic_buffer			m_decompressed;		// verification buffer
+#endif
+};
+
+
+
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+// currently-defined codecs
+const chd_codec_type CHD_CODEC_NONE 	= 0;
+const chd_codec_type CHD_CODEC_ZLIB 	= CHD_MAKE_TAG('z','l','i','b');
+const chd_codec_type CHD_CODEC_LZMA 	= CHD_MAKE_TAG('l','z','m','a');
+const chd_codec_type CHD_CODEC_HUFFMAN	= CHD_MAKE_TAG('h','u','f','f');
+const chd_codec_type CHD_CODEC_FLAC_BE	= CHD_MAKE_TAG('f','l','c','b');
+const chd_codec_type CHD_CODEC_FLAC_LE	= CHD_MAKE_TAG('f','l','c','l');
+const chd_codec_type CHD_CODEC_CD_FLAC	= CHD_MAKE_TAG('c','d','f','l');
+const chd_codec_type CHD_CODEC_AVHUFF	= CHD_MAKE_TAG('a','v','h','u');
+
+// A/V codec configuration parameters
+enum
+{
+	AVHUFF_CODEC_DECOMPRESS_CONFIG = 1
+};
+
+
+#endif // __CHDCODEC_H__
diff -Nru src-old/lib/util/corefile.c src/lib/util/corefile.c
--- src-old/lib/util/corefile.c	2012-01-03 01:21:13.000000000 +0100
+++ src/lib/util/corefile.c	2012-02-16 10:47:18.000000000 +0100
@@ -757,6 +757,41 @@
 	return FILERR_NONE;
 }
 
+file_error core_fload(const char *filename, dynamic_buffer &data)
+{
+	core_file *file = NULL;
+	file_error err;
+	UINT64 size;
+
+	/* attempt to open the file */
+	err = core_fopen(filename, OPEN_FLAG_READ, &file);
+	if (err != FILERR_NONE)
+		return err;
+
+	/* get the size */
+	size = core_fsize(file);
+	if ((UINT32)size != size)
+	{
+		core_fclose(file);
+		return FILERR_OUT_OF_MEMORY;
+	}
+
+	/* allocate memory */
+	data.resize(size);
+
+	/* read the data */
+	if (core_fread(file, data, size) != size)
+	{
+		core_fclose(file);
+		data.reset();
+		return FILERR_FAILURE;
+	}
+
+	/* close the file and return data */
+	core_fclose(file);
+	return FILERR_NONE;
+}
+
 
 
 /***************************************************************************
diff -Nru src-old/lib/util/corefile.h src/lib/util/corefile.h
--- src-old/lib/util/corefile.h	2012-01-03 01:21:13.000000000 +0100
+++ src/lib/util/corefile.h	2012-02-16 10:47:18.000000000 +0100
@@ -45,6 +45,7 @@
 #include <stdarg.h>
 #include "osdcore.h"
 #include "astring.h"
+#include "coretmpl.h"
 
 
 
@@ -129,6 +130,7 @@
 
 /* open a file with the specified filename, read it into memory, and return a pointer */
 file_error core_fload(const char *filename, void **data, UINT32 *length);
+file_error core_fload(const char *filename, dynamic_buffer &data);
 
 
 
diff -Nru src-old/lib/util/coretmpl.h src/lib/util/coretmpl.h
--- src-old/lib/util/coretmpl.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/coretmpl.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,109 @@
+/***************************************************************************
+
+    coretmpl.h
+
+    Core templates for basic non-string types.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __CORETMPL_H__
+#define __CORETMPL_H__
+
+#include <assert.h>
+#include "osdcore.h"
+
+
+// ======================> dynamic_array
+
+// an array that is dynamically sized and can optionally auto-expand
+template<class _ElementType>
+class dynamic_array
+{
+private:
+	// we don't support deep copying
+	dynamic_array(const dynamic_array &);
+	dynamic_array &operator=(const dynamic_array &);
+
+public:
+	// construction/destruction
+	dynamic_array(int initial = 0)
+		: m_array(NULL),
+		  m_count(0),
+		  m_allocated(0) { if (initial != 0) expand_internal(initial); m_count = initial; }
+	virtual ~dynamic_array() { reset(); }
+
+	// operators
+	operator _ElementType *() { return &m_array[0]; }
+	operator const _ElementType *() const { return &m_array[0]; }
+	_ElementType operator[](int index) const { assert(index < m_count); return m_array[index]; }
+	_ElementType &operator[](int index) { assert(index < m_count); return m_array[index]; }
+
+	// simple getters
+	int count() const { return m_count; }
+
+	// helpers
+	void append(const _ElementType &element) { if (m_count == m_allocated) expand_internal((m_allocated == 0) ? 16 : (m_allocated << 1), true); m_array[m_count++] = element; }
+	void reset() { delete[] m_array; m_array = NULL; m_count = m_allocated = 0; }
+	void resize(int count, bool keepdata = false) { if (count > m_allocated) expand_internal(count, keepdata); m_count = count; }
+
+private:
+	// internal helpers
+	void expand_internal(int count, bool keepdata = true)
+	{
+		// allocate a new array, copy the old one, and proceed
+		m_allocated = count;
+		_ElementType *newarray = new _ElementType[m_allocated];
+		if (keepdata)
+			for (int index = 0; index < m_count; index++)
+				newarray[index] = m_array[index];
+		delete[] m_array;
+		m_array = newarray;
+	}
+
+	// internal state
+	_ElementType *	m_array;		// allocated array
+	int 			m_count;		// number of objects accessed in the list
+	int				m_allocated;	// amount of space allocated for the array
+};
+
+
+// ======================> dynamic_buffer
+
+typedef dynamic_array<UINT8> dynamic_buffer;
+
+
+
+#endif
diff -Nru src-old/lib/util/flac.c src/lib/util/flac.c
--- src-old/lib/util/flac.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/flac.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,646 @@
+/***************************************************************************
+
+    flac.c
+
+    FLAC compression wrappers
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#include "flac.h"
+#include <assert.h>
+#include <new>
+
+
+//**************************************************************************
+//  FLAC ENCODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  flac_encoder - constructors
+//-------------------------------------------------
+
+flac_encoder::flac_encoder()
+{
+	init_common();
+}
+
+
+flac_encoder::flac_encoder(void *buffer, UINT32 buflength)
+{
+	init_common();
+	reset(buffer, buflength);
+}
+
+
+flac_encoder::flac_encoder(core_file &file)
+{
+	init_common();
+	reset(file);
+}
+
+
+//-------------------------------------------------
+//  ~flac_encoder - destructor
+//-------------------------------------------------
+
+flac_encoder::~flac_encoder()
+{
+	// delete the encoder
+	FLAC__stream_encoder_delete(m_encoder);
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with the original
+//  parameters
+//-------------------------------------------------
+
+bool flac_encoder::reset()
+{
+	// configure the output
+	m_compressed_offset = 0;
+	m_ignore_bytes = m_strip_metadata ? 4 : 0;
+	m_found_audio = !m_strip_metadata;
+
+	// configure the encoder in a standard way
+	// note we do this on each reset; if we don't, results are NOT consistent!
+	FLAC__stream_encoder_set_verify(m_encoder, false);
+//  FLAC__stream_encoder_set_do_md5(m_encoder, false);
+	FLAC__stream_encoder_set_compression_level(m_encoder, 8);
+	FLAC__stream_encoder_set_channels(m_encoder, m_channels);
+	FLAC__stream_encoder_set_bits_per_sample(m_encoder, 16);
+	FLAC__stream_encoder_set_sample_rate(m_encoder, m_sample_rate);
+	FLAC__stream_encoder_set_total_samples_estimate(m_encoder, 0);
+	FLAC__stream_encoder_set_streamable_subset(m_encoder, false);
+	FLAC__stream_encoder_set_blocksize(m_encoder, m_block_size);
+
+	// re-start processing
+	return (FLAC__stream_encoder_init_stream(m_encoder, write_callback_static, NULL, NULL, NULL, this) == FLAC__STREAM_ENCODER_INIT_STATUS_OK);
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with new memory parameters
+//-------------------------------------------------
+
+bool flac_encoder::reset(void *buffer, UINT32 buflength)
+{
+	// configure the output
+	m_compressed_start = reinterpret_cast<FLAC__byte *>(buffer);
+	m_compressed_length = buflength;
+	m_file = NULL;
+	return reset();
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with new file parameters
+//-------------------------------------------------
+
+bool flac_encoder::reset(core_file &file)
+{
+	// configure the output
+	m_compressed_start = NULL;
+	m_compressed_length = 0;
+	m_file = &file;
+	return reset();
+}
+
+
+//-------------------------------------------------
+//  encode_interleaved - encode a buffer with
+//  interleaved samples
+//-------------------------------------------------
+
+bool flac_encoder::encode_interleaved(const INT16 *samples, UINT32 samples_per_channel, bool swap_endian)
+{
+	int shift = swap_endian ? 8 : 0;
+
+	// loop over source samples
+	int num_channels = FLAC__stream_encoder_get_channels(m_encoder);
+	UINT32 srcindex = 0;
+	while (samples_per_channel != 0)
+	{
+		// process in batches of 2k samples
+		FLAC__int32 converted_buffer[2048];
+		FLAC__int32 *dest = converted_buffer;
+		UINT32 cur_samples = MIN(ARRAY_LENGTH(converted_buffer) / num_channels, samples_per_channel);
+
+		// convert a buffers' worth
+		for (UINT32 sampnum = 0; sampnum < cur_samples; sampnum++)
+			for (int channel = 0; channel < num_channels; channel++, srcindex++)
+				*dest++ = INT16((UINT16(samples[srcindex]) << shift) | (UINT16(samples[srcindex]) >> shift));
+
+		// process this batch
+		if (!FLAC__stream_encoder_process_interleaved(m_encoder, converted_buffer, cur_samples))
+			return false;
+		samples_per_channel -= cur_samples;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  encode - encode a buffer with individual
+//  sample streams
+//-------------------------------------------------
+
+bool flac_encoder::encode(INT16 *const *samples, UINT32 samples_per_channel, bool swap_endian)
+{
+	int shift = swap_endian ? 8 : 0;
+
+	// loop over source samples
+	int num_channels = FLAC__stream_encoder_get_channels(m_encoder);
+	UINT32 srcindex = 0;
+	while (samples_per_channel != 0)
+	{
+		// process in batches of 2k samples
+		FLAC__int32 converted_buffer[2048];
+		FLAC__int32 *dest = converted_buffer;
+		UINT32 cur_samples = MIN(ARRAY_LENGTH(converted_buffer) / num_channels, samples_per_channel);
+
+		// convert a buffers' worth
+		for (UINT32 sampnum = 0; sampnum < cur_samples; sampnum++, srcindex++)
+			for (int channel = 0; channel < num_channels; channel++)
+				*dest++ = INT16((UINT16(samples[channel][srcindex]) << shift) | (UINT16(samples[channel][srcindex]) >> shift));
+
+		// process this batch
+		if (!FLAC__stream_encoder_process_interleaved(m_encoder, converted_buffer, cur_samples))
+			return false;
+		samples_per_channel -= cur_samples;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  finish - complete encoding and flush the
+//  stream
+//-------------------------------------------------
+
+UINT32 flac_encoder::finish()
+{
+	// process the data and return the amount written
+	FLAC__stream_encoder_finish(m_encoder);
+	return (m_file != NULL) ? core_ftell(m_file) : m_compressed_offset;
+}
+
+
+//-------------------------------------------------
+//  init_common - common initialization
+//-------------------------------------------------
+
+void flac_encoder::init_common()
+{
+	// allocate the encoder
+	m_encoder = FLAC__stream_encoder_new();
+	if (m_encoder == NULL)
+		throw std::bad_alloc();
+
+	// initialize default state
+	m_file = NULL;
+	m_compressed_offset = 0;
+	m_compressed_start = NULL;
+	m_compressed_length = 0;
+	m_sample_rate = 44100;
+	m_channels = 2;
+	m_block_size = 0;
+	m_strip_metadata = false;
+	m_ignore_bytes = 0;
+	m_found_audio = false;
+}
+
+
+//-------------------------------------------------
+//  write_callback - handle writes to the
+//  output stream
+//-------------------------------------------------
+
+FLAC__StreamEncoderWriteStatus flac_encoder::write_callback_static(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)
+{
+	return reinterpret_cast<flac_encoder *>(client_data)->write_callback(buffer, bytes, samples, current_frame);
+}
+
+FLAC__StreamEncoderWriteStatus flac_encoder::write_callback(const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame)
+{
+	// loop over output data
+	size_t offset = 0;
+	while (offset < bytes)
+	{
+		// if we're ignoring, continue to do so
+		if (m_ignore_bytes != 0)
+		{
+			int ignore = MIN(bytes - offset, m_ignore_bytes);
+			offset += ignore;
+			m_ignore_bytes -= ignore;
+		}
+
+		// if we haven't hit the end of metadata, process a new piece
+		else if (!m_found_audio)
+		{
+			assert(bytes - offset >= 4);
+			m_found_audio = ((buffer[offset] & 0x80) != 0);
+			m_ignore_bytes = (buffer[offset + 1] << 16) | (buffer[offset + 2] << 8) | buffer[offset + 3];
+			offset += 4;
+		}
+
+		// otherwise process as audio data and copy to the output
+		else
+		{
+			int count = bytes - offset;
+			if (m_file != NULL)
+				core_fwrite(m_file, buffer, count);
+			else
+			{
+				if (m_compressed_offset + count <= m_compressed_length)
+					memcpy(m_compressed_start + m_compressed_offset, buffer, count);
+				m_compressed_offset += count;
+			}
+			offset += count;
+		}
+	}
+	return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
+}
+
+
+
+//**************************************************************************
+//  FLAC DECODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  flac_decoder - constructor
+//-------------------------------------------------
+
+flac_decoder::flac_decoder()
+	: m_decoder(FLAC__stream_decoder_new()),
+	  m_file(NULL),
+	  m_compressed_offset(0),
+	  m_compressed_start(NULL),
+	  m_compressed_length(0),
+	  m_compressed2_start(NULL),
+	  m_compressed2_length(0)
+{
+}
+
+
+//-------------------------------------------------
+//  flac_decoder - constructor
+//-------------------------------------------------
+
+flac_decoder::flac_decoder(const void *buffer, UINT32 length, const void *buffer2, UINT32 length2)
+	: m_decoder(FLAC__stream_decoder_new()),
+	  m_file(NULL),
+	  m_compressed_offset(0),
+	  m_compressed_start(reinterpret_cast<const FLAC__byte *>(buffer)),
+	  m_compressed_length(length),
+	  m_compressed2_start(reinterpret_cast<const FLAC__byte *>(buffer2)),
+	  m_compressed2_length(length2)
+{
+	reset();
+}
+
+
+//-------------------------------------------------
+//  flac_decoder - constructor
+//-------------------------------------------------
+
+flac_decoder::flac_decoder(core_file &file)
+	: m_decoder(FLAC__stream_decoder_new()),
+	  m_file(&file),
+	  m_compressed_offset(0),
+	  m_compressed_start(NULL),
+	  m_compressed_length(0),
+	  m_compressed2_start(NULL),
+	  m_compressed2_length(0)
+{
+	reset();
+}
+
+
+//-------------------------------------------------
+//  flac_decoder - destructor
+//-------------------------------------------------
+
+flac_decoder::~flac_decoder()
+{
+	FLAC__stream_decoder_delete(m_decoder);
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with the original
+//  parameters
+//-------------------------------------------------
+
+bool flac_decoder::reset()
+{
+	m_compressed_offset = 0;
+	if (FLAC__stream_decoder_init_stream(m_decoder,
+				&flac_decoder::read_callback_static,
+				NULL,
+				&flac_decoder::tell_callback_static,
+				NULL,
+				NULL,
+				&flac_decoder::write_callback_static,
+				&flac_decoder::metadata_callback_static,
+				&flac_decoder::error_callback_static, this) != FLAC__STREAM_DECODER_INIT_STATUS_OK)
+		return false;
+	return FLAC__stream_decoder_process_until_end_of_metadata(m_decoder);
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with new memory parameters
+//-------------------------------------------------
+
+bool flac_decoder::reset(const void *buffer, UINT32 length, const void *buffer2, UINT32 length2)
+{
+	m_file = NULL;
+	m_compressed_start = reinterpret_cast<const FLAC__byte *>(buffer);
+	m_compressed_length = length;
+	m_compressed2_start = reinterpret_cast<const FLAC__byte *>(buffer2);
+	m_compressed2_length = length2;
+	return reset();
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with new memory parameters
+//  and a custom-generated header
+//-------------------------------------------------
+
+bool flac_decoder::reset(UINT32 sample_rate, UINT8 num_channels, UINT32 block_size, const void *buffer, UINT32 length)
+{
+	// modify the template header with our parameters
+	static const UINT8 s_header_template[0x2a] =
+	{
+		0x66, 0x4C, 0x61, 0x43, 						// +00: 'fLaC' stream header
+		0x80,											// +04: metadata block type 0 (STREAMINFO),
+														//      flagged as last block
+		0x00, 0x00, 0x22,								// +05: metadata block length = 0x22
+		0x00, 0x00, 									// +08: minimum block size
+		0x00, 0x00,										// +0A: maximum block size
+		0x00, 0x00, 0x00,								// +0C: minimum frame size (0 == unknown)
+		0x00, 0x00, 0x00,								// +0F: maximum frame size (0 == unknown)
+		0x0A, 0xC4, 0x42, 0xF0, 0x00, 0x00, 0x00, 0x00, // +12: sample rate (0x0ac44 == 44100),
+														//      numchannels (2), sample bits (16),
+														//      samples in stream (0 == unknown)
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // +1A: MD5 signature (0 == none)
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	//
+														// +2A: start of stream data
+	};
+	memcpy(m_custom_header, s_header_template, sizeof(s_header_template));
+	m_custom_header[0x08] = m_custom_header[0x0a] = block_size >> 8;
+	m_custom_header[0x09] = m_custom_header[0x0b] = block_size & 0xff;
+	m_custom_header[0x12] = sample_rate >> 12;
+	m_custom_header[0x13] = sample_rate >> 4;
+	m_custom_header[0x14] = (sample_rate << 4) | ((num_channels - 1) << 1);
+
+	// configure the header ahead of the provided buffer
+	m_file = NULL;
+	m_compressed_start = reinterpret_cast<const FLAC__byte *>(m_custom_header);
+	m_compressed_length = sizeof(m_custom_header);
+	m_compressed2_start = reinterpret_cast<const FLAC__byte *>(buffer);
+	m_compressed2_length = length;
+	return reset();
+}
+
+
+//-------------------------------------------------
+//  reset - reset state with new file parameter
+//-------------------------------------------------
+
+bool flac_decoder::reset(core_file &file)
+{
+	m_file = &file;
+	m_compressed_start = NULL;
+	m_compressed_length = 0;
+	m_compressed2_start = NULL;
+	m_compressed2_length = 0;
+	return reset();
+}
+
+
+//-------------------------------------------------
+//  decode_interleaved - decode to an interleaved
+//  sound stream
+//-------------------------------------------------
+
+bool flac_decoder::decode_interleaved(INT16 *samples, UINT32 num_samples, bool swap_endian)
+{
+	// configure the uncompressed buffer
+	memset(m_uncompressed_start, 0, sizeof(m_uncompressed_start));
+	m_uncompressed_start[0] = samples;
+	m_uncompressed_offset = 0;
+	m_uncompressed_length = num_samples;
+	m_uncompressed_swap = swap_endian;
+
+	// loop until we get everything we want
+	while (m_uncompressed_offset < m_uncompressed_length)
+		if (!FLAC__stream_decoder_process_single(m_decoder))
+			return false;
+	return true;
+}
+
+
+//-------------------------------------------------
+//  decode - decode to an multiple independent
+//  data streams
+//-------------------------------------------------
+
+bool flac_decoder::decode(INT16 **samples, UINT32 num_samples, bool swap_endian)
+{
+	// make sure we don't have too many channels
+	int chans = channels();
+	if (chans > ARRAY_LENGTH(m_uncompressed_start))
+		return false;
+
+	// configure the uncompressed buffer
+	memset(m_uncompressed_start, 0, sizeof(m_uncompressed_start));
+	for (int curchan = 0; curchan < chans; curchan++)
+		m_uncompressed_start[curchan] = samples[curchan];
+	m_uncompressed_offset = 0;
+	m_uncompressed_length = num_samples;
+	m_uncompressed_swap = swap_endian;
+
+	// loop until we get everything we want
+	while (m_uncompressed_offset < m_uncompressed_length)
+		if (!FLAC__stream_decoder_process_single(m_decoder))
+			return false;
+	return true;
+}
+
+
+//-------------------------------------------------
+//  finish - finish up the decode
+//-------------------------------------------------
+
+UINT32 flac_decoder::finish()
+{
+	// get the final decoding position and move forward
+	FLAC__uint64 position = 0;
+	FLAC__stream_decoder_get_decode_position(m_decoder, &position);
+	FLAC__stream_decoder_finish(m_decoder);
+
+	// adjust position if we provided the header
+	if (position == 0)
+		return 0;
+	if (m_compressed_start == reinterpret_cast<const FLAC__byte *>(m_custom_header))
+		position -= m_compressed_length;
+	return position;
+}
+
+
+//-------------------------------------------------
+//  read_callback - handle reads from the input
+//  stream
+//-------------------------------------------------
+
+FLAC__StreamDecoderReadStatus flac_decoder::read_callback_static(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
+{
+	return reinterpret_cast<flac_decoder *>(client_data)->read_callback(buffer, bytes);
+}
+
+FLAC__StreamDecoderReadStatus flac_decoder::read_callback(FLAC__byte buffer[], size_t *bytes)
+{
+	UINT32 expected = *bytes;
+
+	// if a file, just read
+	if (m_file != NULL)
+		*bytes = core_fread(m_file, buffer, expected);
+
+	// otherwise, copy from memory
+	else
+	{
+		// copy from primary buffer first
+		UINT32 outputpos = 0;
+		if (outputpos < *bytes && m_compressed_offset < m_compressed_length)
+		{
+			UINT32 bytes_to_copy = MIN(*bytes - outputpos, m_compressed_length - m_compressed_offset);
+			memcpy(&buffer[outputpos], m_compressed_start + m_compressed_offset, bytes_to_copy);
+			outputpos += bytes_to_copy;
+			m_compressed_offset += bytes_to_copy;
+		}
+
+		// once we're out of that, copy from the secondary buffer
+		if (outputpos < *bytes && m_compressed_offset < m_compressed_length + m_compressed2_length)
+		{
+			UINT32 bytes_to_copy = MIN(*bytes - outputpos, m_compressed2_length - (m_compressed_offset - m_compressed_length));
+			memcpy(&buffer[outputpos], m_compressed2_start + m_compressed_offset - m_compressed_length, bytes_to_copy);
+			outputpos += bytes_to_copy;
+			m_compressed_offset += bytes_to_copy;
+		}
+		*bytes = outputpos;
+	}
+
+	// return based on whether we ran out of data
+	return (*bytes < expected) ? FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM : FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+}
+
+
+//-------------------------------------------------
+//  metadata_callback - handle STREAMINFO metadata
+//-------------------------------------------------
+
+void flac_decoder::metadata_callback_static(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)
+{
+	// ignore all but STREAMINFO metadata
+	if (metadata->type != FLAC__METADATA_TYPE_STREAMINFO)
+		return;
+
+	// parse out the data we care about
+	flac_decoder *fldecoder = reinterpret_cast<flac_decoder *>(client_data);
+	fldecoder->m_sample_rate = metadata->data.stream_info.sample_rate;
+	fldecoder->m_bits_per_sample = metadata->data.stream_info.bits_per_sample;
+	fldecoder->m_channels = metadata->data.stream_info.channels;
+}
+
+
+//-------------------------------------------------
+//  tell_callback - handle requests to find out
+//  where in the input stream we are
+//-------------------------------------------------
+
+FLAC__StreamDecoderTellStatus flac_decoder::tell_callback_static(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
+{
+	*absolute_byte_offset = reinterpret_cast<flac_decoder *>(client_data)->m_compressed_offset;
+	return FLAC__STREAM_DECODER_TELL_STATUS_OK;
+}
+
+
+//-------------------------------------------------
+//  write_callback - handle writes to the output
+//  stream
+//-------------------------------------------------
+
+FLAC__StreamDecoderWriteStatus flac_decoder::write_callback_static(const FLAC__StreamDecoder *decoder, const ::FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data)
+{
+	return reinterpret_cast<flac_decoder *>(client_data)->write_callback(frame, buffer);
+}
+
+FLAC__StreamDecoderWriteStatus flac_decoder::write_callback(const ::FLAC__Frame *frame, const FLAC__int32 * const buffer[])
+{
+	assert(frame->header.channels == channels());
+
+	// interleaved case
+	int shift = m_uncompressed_swap ? 8 : 0;
+	int blocksize = frame->header.blocksize;
+	if (m_uncompressed_start[1] == NULL)
+	{
+		INT16 *dest = m_uncompressed_start[0] + m_uncompressed_offset * frame->header.channels;
+		for (int sampnum = 0; sampnum < blocksize && m_uncompressed_offset < m_uncompressed_length; sampnum++, m_uncompressed_offset++)
+			for (int chan = 0; chan < frame->header.channels; chan++)
+				*dest++ = INT16((UINT16(buffer[chan][sampnum]) << shift) | (UINT16(buffer[chan][sampnum]) >> shift));
+	}
+
+	// non-interleaved case
+	else
+	{
+		for (int sampnum = 0; sampnum < blocksize && m_uncompressed_offset < m_uncompressed_length; sampnum++, m_uncompressed_offset++)
+			for (int chan = 0; chan < frame->header.channels; chan++)
+				if (m_uncompressed_start[chan] != NULL)
+					m_uncompressed_start[chan][m_uncompressed_offset] = INT16((UINT16(buffer[chan][sampnum]) << shift) | (UINT16(buffer[chan][sampnum]) >> shift));
+	}
+	return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+}
+
+
+//-------------------------------------------------
+//  error_callback - handle errors (ignore them)
+//-------------------------------------------------
+
+void flac_decoder::error_callback_static(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)
+{
+}
diff -Nru src-old/lib/util/flac.h src/lib/util/flac.h
--- src-old/lib/util/flac.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/flac.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,173 @@
+/***************************************************************************
+
+    flac.h
+
+    FLAC compression wrappers
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __FLAC_H__
+#define __FLAC_H__
+
+#include "osdcore.h"
+#include "corefile.h"
+#include "../../lib/libflac/include/flac/all.h"
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> flac_encoder
+
+class flac_encoder
+{
+public:
+	// construction/destruction
+	flac_encoder();
+	flac_encoder(void *buffer, UINT32 buflength);
+	flac_encoder(core_file &file);
+	~flac_encoder();
+
+	// configuration
+	void set_sample_rate(UINT32 sample_rate) { m_sample_rate = sample_rate; }
+	void set_num_channels(UINT8 num_channels) { m_channels = num_channels; }
+	void set_block_size(UINT32 block_size) { m_block_size = block_size; }
+	void set_strip_metadata(bool strip) { m_strip_metadata = strip; }
+
+	// getters (valid after reset)
+	FLAC__StreamEncoderState state() const { return FLAC__stream_encoder_get_state(m_encoder); }
+	const char *state_string() const { return FLAC__stream_encoder_get_resolved_state_string(m_encoder); }
+
+	// reset
+	bool reset();
+	bool reset(void *buffer, UINT32 buflength);
+	bool reset(core_file &file);
+
+	// encode a buffer
+	bool encode_interleaved(const INT16 *samples, UINT32 samples_per_channel, bool swap_endian = false);
+	bool encode(INT16 *const *samples, UINT32 samples_per_channel, bool swap_endian = false);
+
+	// finish up
+	UINT32 finish();
+
+private:
+	// internal helpers
+	void init_common();
+	static FLAC__StreamEncoderWriteStatus write_callback_static(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data);
+	FLAC__StreamEncoderWriteStatus write_callback(const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame);
+
+	// internal state
+	FLAC__StreamEncoder *	m_encoder;				// actual encoder
+	core_file *				m_file;					// output file
+	UINT32					m_compressed_offset;	// current offset with the compressed stream
+	FLAC__byte *			m_compressed_start;		// start of compressed data
+	UINT32					m_compressed_length;	// length of the compressed stream
+
+	// parameters
+	UINT32					m_sample_rate;			// sample rate
+	UINT8					m_channels;				// number of channels
+	UINT32					m_block_size;			// block size
+
+	// header stripping
+	bool					m_strip_metadata;		// strip the the metadata?
+	UINT32					m_ignore_bytes;			// how many bytes to ignore when writing
+	bool					m_found_audio;			// have we hit the audio yet?
+};
+
+
+// ======================> flac_decoder
+
+class flac_decoder
+{
+public:
+	// construction/destruction
+	flac_decoder();
+	flac_decoder(const void *buffer, UINT32 length, const void *buffer2 = NULL, UINT32 length2 = 0);
+	flac_decoder(core_file &file);
+	~flac_decoder();
+
+	// getters (valid after reset)
+	UINT32 sample_rate() const { return m_sample_rate; }
+	UINT8 channels() const { return m_channels; }
+	UINT8 bits_per_sample() const { return m_bits_per_sample; }
+	UINT32 total_samples() const { return FLAC__stream_decoder_get_total_samples(m_decoder); }
+	FLAC__StreamDecoderState state() const { return FLAC__stream_decoder_get_state(m_decoder); }
+	const char *state_string() const { return FLAC__stream_decoder_get_resolved_state_string(m_decoder); }
+
+	// reset
+	bool reset();
+	bool reset(const void *buffer, UINT32 length, const void *buffer2 = NULL, UINT32 length2 = 0);
+	bool reset(UINT32 sample_rate, UINT8 num_channels, UINT32 block_size, const void *buffer, UINT32 length);
+	bool reset(core_file &file);
+
+	// decode to a buffer; num_samples must be a multiple of the block size
+	bool decode_interleaved(INT16 *samples, UINT32 num_samples, bool swap_endian = false);
+	bool decode(INT16 **samples, UINT32 num_samples, bool swap_endian = false);
+
+	// finish up
+	UINT32 finish();
+
+private:
+	// internal helpers
+	static FLAC__StreamDecoderReadStatus read_callback_static(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
+	FLAC__StreamDecoderReadStatus read_callback(FLAC__byte buffer[], size_t *bytes);
+	static void metadata_callback_static(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);
+	static FLAC__StreamDecoderTellStatus tell_callback_static(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
+	static FLAC__StreamDecoderWriteStatus write_callback_static(const FLAC__StreamDecoder *decoder, const ::FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);
+	FLAC__StreamDecoderWriteStatus write_callback(const ::FLAC__Frame *frame, const FLAC__int32 * const buffer[]);
+	static void error_callback_static(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);
+
+	// output state
+	FLAC__StreamDecoder *	m_decoder;				// actual encoder
+	core_file *				m_file;					// output file
+	UINT32					m_sample_rate;			// decoded sample rate
+	UINT8					m_channels;				// decoded number of channels
+	UINT8					m_bits_per_sample;		// decoded bits per sample
+	UINT32					m_compressed_offset;	// current offset in compressed data
+	const FLAC__byte *		m_compressed_start;		// start of compressed data
+	UINT32					m_compressed_length;	// length of compressed data
+	const FLAC__byte *		m_compressed2_start;	// start of compressed data
+	UINT32					m_compressed2_length;	// length of compressed data
+	INT16 *					m_uncompressed_start[8];// pointer to start of uncompressed data (up to 8 streams)
+	UINT32					m_uncompressed_offset;	// current position in uncompressed data
+	UINT32					m_uncompressed_length;	// length of uncompressed data
+	bool					m_uncompressed_swap;	// swap uncompressed sample data
+	UINT8					m_custom_header[0x2a];	// custom header
+};
+
+
+#endif // __FLAC_H__
diff -Nru src-old/lib/util/harddisk.c src/lib/util/harddisk.c
--- src-old/lib/util/harddisk.c	2010-01-17 21:15:47.000000000 +0100
+++ src/lib/util/harddisk.c	2012-02-16 10:47:18.000000000 +0100
@@ -46,13 +46,10 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
-struct _hard_disk_file
+struct hard_disk_file
 {
 	chd_file *			chd;				/* CHD file */
 	hard_disk_info		info;				/* hard disk info */
-	UINT32				hunksectors;		/* sectors per hunk */
-	UINT32				cachehunk;			/* which hunk is cached */
-	UINT8 *				cache;				/* cache of the current hunk */
 };
 
 
@@ -70,7 +67,7 @@
 {
 	int cylinders, heads, sectors, sectorbytes;
 	hard_disk_file *file;
-	char metadata[256];
+	astring metadata;
 	chd_error err;
 
 	/* punt if no CHD */
@@ -78,7 +75,7 @@
 		return NULL;
 
 	/* read the hard disk metadata */
-	err = chd_get_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
+	err = chd->read_metadata(HARD_DISK_METADATA_TAG, 0, metadata);
 	if (err != CHDERR_NONE)
 		return NULL;
 
@@ -97,17 +94,6 @@
 	file->info.heads = heads;
 	file->info.sectors = sectors;
 	file->info.sectorbytes = sectorbytes;
-	file->hunksectors = chd_get_header(chd)->hunkbytes / file->info.sectorbytes;
-	file->cachehunk = -1;
-
-	/* allocate a cache */
-	file->cache = (UINT8 *)malloc(chd_get_header(chd)->hunkbytes);
-	if (file->cache == NULL)
-	{
-		free(file);
-		return NULL;
-	}
-
 	return file;
 }
 
@@ -118,9 +104,6 @@
 
 void hard_disk_close(hard_disk_file *file)
 {
-	/* free the cache */
-	if (file->cache != NULL)
-		free(file->cache);
 	free(file);
 }
 
@@ -154,21 +137,8 @@
 
 UINT32 hard_disk_read(hard_disk_file *file, UINT32 lbasector, void *buffer)
 {
-	UINT32 hunknum = lbasector / file->hunksectors;
-	UINT32 sectoroffs = lbasector % file->hunksectors;
-
-	/* if we haven't cached this hunk, read it now */
-	if (file->cachehunk != hunknum)
-	{
-		chd_error err = chd_read(file->chd, hunknum, file->cache);
-		if (err != CHDERR_NONE)
-			return 0;
-		file->cachehunk = hunknum;
-	}
-
-	/* copy out the requested sector */
-	memcpy(buffer, &file->cache[sectoroffs * file->info.sectorbytes], file->info.sectorbytes);
-	return 1;
+	chd_error err = file->chd->read_units(lbasector, buffer);
+	return (err == CHDERR_NONE);
 }
 
 
@@ -179,23 +149,6 @@
 
 UINT32 hard_disk_write(hard_disk_file *file, UINT32 lbasector, const void *buffer)
 {
-	UINT32 hunknum = lbasector / file->hunksectors;
-	UINT32 sectoroffs = lbasector % file->hunksectors;
-	chd_error err;
-
-	/* if we haven't cached this hunk, read it now */
-	if (file->cachehunk != hunknum)
-	{
-		err = chd_read(file->chd, hunknum, file->cache);
-		if (err != CHDERR_NONE)
-			return 0;
-		file->cachehunk = hunknum;
-	}
-
-	/* copy in the requested data */
-	memcpy(&file->cache[sectoroffs * file->info.sectorbytes], buffer, file->info.sectorbytes);
-
-	/* write it back out */
-	err = chd_write(file->chd, hunknum, file->cache);
-	return (err == CHDERR_NONE) ? 1 : 0;
+	chd_error err = file->chd->write_units(lbasector, buffer);
+	return (err == CHDERR_NONE);
 }
diff -Nru src-old/lib/util/harddisk.h src/lib/util/harddisk.h
--- src-old/lib/util/harddisk.h	2009-10-12 09:45:25.000000000 +0200
+++ src/lib/util/harddisk.h	2012-02-16 10:47:18.000000000 +0100
@@ -50,10 +50,9 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _hard_disk_file hard_disk_file;
+struct hard_disk_file;
 
-typedef struct _hard_disk_info hard_disk_info;
-struct _hard_disk_info
+struct hard_disk_info
 {
 	UINT32			cylinders;
 	UINT32			heads;
diff -Nru src-old/lib/util/hashing.c src/lib/util/hashing.c
--- src-old/lib/util/hashing.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/hashing.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,302 @@
+/***************************************************************************
+
+    hashing.c
+
+    Hashing helper classes.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#include "hashing.h"
+#include "zlib.h"
+
+
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+const crc16_t crc16_t::null = { 0 };
+const crc32_t crc32_t::null = { 0 };
+const md5_t md5_t::null = { { 0 } };
+const sha1_t sha1_t::null = { { 0 } };
+
+
+
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  char_to_hex - return the hex value of a
+//  character
+//-------------------------------------------------
+
+inline int char_to_hex(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return 10 + c - 'a';
+	if (c >= 'A' && c <= 'F')
+		return 10 + c - 'A';
+	return -1;
+}
+
+
+
+//**************************************************************************
+//  SHA-1 HELPERS
+//**************************************************************************
+
+//-------------------------------------------------
+//  from_string - convert from a string
+//-------------------------------------------------
+
+bool sha1_t::from_string(const char *string, int length)
+{
+	// must be at least long enough to hold everything
+	if (length == -1)
+		length = strlen(string);
+	if (length < 2 * sizeof(m_raw))
+		return false;
+
+	// iterate through our raw buffer
+	for (int bytenum = 0; bytenum < sizeof(m_raw); bytenum++)
+	{
+		int upper = char_to_hex(*string++);
+		int lower = char_to_hex(*string++);
+		if (upper == -1 || lower == -1)
+			return false;
+		m_raw[bytenum] = (upper << 4) | lower;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  as_string - convert to a string
+//-------------------------------------------------
+
+const char *sha1_t::as_string(astring &buffer) const
+{
+	buffer.reset();
+	for (int i = 0; i < ARRAY_LENGTH(m_raw); i++)
+		buffer.catformat("%02x", m_raw[i]);
+	return buffer;
+}
+
+
+//**************************************************************************
+//  MD-5 HELPERS
+//**************************************************************************
+
+//-------------------------------------------------
+//  from_string - convert from a string
+//-------------------------------------------------
+
+bool md5_t::from_string(const char *string, int length)
+{
+	// must be at least long enough to hold everything
+	if (length == -1)
+		length = strlen(string);
+	if (length < 2 * sizeof(m_raw))
+		return false;
+
+	// iterate through our raw buffer
+	for (int bytenum = 0; bytenum < sizeof(m_raw); bytenum++)
+	{
+		int upper = char_to_hex(*string++);
+		int lower = char_to_hex(*string++);
+		if (upper == -1 || lower == -1)
+			return false;
+		m_raw[bytenum] = (upper << 4) | lower;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  as_string - convert to a string
+//-------------------------------------------------
+
+const char *md5_t::as_string(astring &buffer) const
+{
+	buffer.reset();
+	for (int i = 0; i < ARRAY_LENGTH(m_raw); i++)
+		buffer.catformat("%02x", m_raw[i]);
+	return buffer;
+}
+
+
+
+//**************************************************************************
+//  CRC-32 HELPERS
+//**************************************************************************
+
+//-------------------------------------------------
+//  from_string - convert from a string
+//-------------------------------------------------
+
+bool crc32_t::from_string(const char *string, int length)
+{
+	// must be at least long enough to hold everything
+	if (length == -1)
+		length = strlen(string);
+	if (length < 2 * sizeof(m_raw))
+		return false;
+
+	// iterate through our raw buffer
+	m_raw = 0;
+	for (int bytenum = 0; bytenum < sizeof(m_raw) * 2; bytenum++)
+	{
+		int nibble = char_to_hex(*string++);
+		if (nibble == -1)
+			return false;
+		m_raw = (m_raw << 4) | nibble;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  as_string - convert to a string
+//-------------------------------------------------
+
+const char *crc32_t::as_string(astring &buffer) const
+{
+	return buffer.format("%08x", m_raw);
+}
+
+
+//-------------------------------------------------
+//  append - hash a block of data, appending to
+//  the currently-accumulated value
+//-------------------------------------------------
+
+void crc32_creator::append(const void *data, UINT32 length)
+{
+	m_accum.m_raw = crc32(m_accum, reinterpret_cast<const Bytef *>(data), length);
+}
+
+
+
+//**************************************************************************
+//  CRC-16 HELPERS
+//**************************************************************************
+
+//-------------------------------------------------
+//  from_string - convert from a string
+//-------------------------------------------------
+
+bool crc16_t::from_string(const char *string, int length)
+{
+	// must be at least long enough to hold everything
+	if (length == -1)
+		length = strlen(string);
+	if (length < 2 * sizeof(m_raw))
+		return false;
+
+	// iterate through our raw buffer
+	m_raw = 0;
+	for (int bytenum = 0; bytenum < sizeof(m_raw) * 2; bytenum++)
+	{
+		int nibble = char_to_hex(*string++);
+		if (nibble == -1)
+			return false;
+		m_raw = (m_raw << 4) | nibble;
+	}
+	return true;
+}
+
+
+//-------------------------------------------------
+//  as_string - convert to a string
+//-------------------------------------------------
+
+const char *crc16_t::as_string(astring &buffer) const
+{
+	return buffer.format("%04x", m_raw);
+}
+
+
+//-------------------------------------------------
+//  append - hash a block of data, appending to
+//  the currently-accumulated value
+//-------------------------------------------------
+
+void crc16_creator::append(const void *data, UINT32 length)
+{
+	static const UINT16 s_table[256] =
+	{
+	    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
+	    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
+	    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
+	    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
+	    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
+	    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
+	    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
+	    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
+	    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+	    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
+	    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
+	    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
+	    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
+	    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
+	    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
+	    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
+	    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
+	    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+	    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
+	    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
+	    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
+	    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+	    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
+	    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
+	    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
+	    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
+	    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+	    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
+	    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
+	    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
+	    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
+	    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
+    };
+
+	const UINT8 *src = reinterpret_cast<const UINT8 *>(data);
+
+	// fetch the current value into a local and rip through the source data
+	UINT16 crc = m_accum.m_raw;
+	while (length-- != 0)
+		crc = (crc << 8) ^ s_table[(crc >> 8) ^ *src++];
+	m_accum.m_raw = crc;
+}
diff -Nru src-old/lib/util/hashing.h src/lib/util/hashing.h
--- src-old/lib/util/hashing.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/hashing.h	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,248 @@
+/***************************************************************************
+
+    hashing.h
+
+    Hashing helper classes.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __HASHING_H__
+#define __HASHING_H__
+
+#include "osdcore.h"
+#include "astring.h"
+#include "md5.h"
+#include "sha1.h"
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+
+// ======================> SHA-1
+
+// final digest
+struct sha1_t
+{
+	bool operator==(const sha1_t &rhs) const { return memcmp(m_raw, rhs.m_raw, sizeof(m_raw)) == 0; }
+	bool operator!=(const sha1_t &rhs) const { return memcmp(m_raw, rhs.m_raw, sizeof(m_raw)) != 0; }
+	operator UINT8 *() { return m_raw; }
+	bool from_string(const char *string, int length = -1);
+	const char *as_string(astring &buffer) const;
+	UINT8 m_raw[20];
+	static const sha1_t null;
+};
+
+// creation helper
+class sha1_creator
+{
+public:
+	// construction/destruction
+	sha1_creator() { reset(); }
+
+	// reset
+	void reset() { sha1_init(&m_context); }
+
+	// append data
+	void append(const void *data, UINT32 length) { sha1_update(&m_context, length, reinterpret_cast<const UINT8 *>(data)); }
+
+	// finalize and compute the final digest
+	sha1_t finish()
+	{
+		sha1_t result;
+		sha1_final(&m_context);
+		sha1_digest(&m_context, sizeof(result.m_raw), result.m_raw);
+		return result;
+	}
+
+	// static wrapper to just get the digest from a block
+	static sha1_t simple(const void *data, UINT32 length)
+	{
+		sha1_creator creator;
+		creator.append(data, length);
+		return creator.finish();
+	}
+
+protected:
+	// internal state
+	struct sha1_ctx 	m_context;		// internal context
+};
+
+
+
+// ======================> MD5
+
+// final digest
+struct md5_t
+{
+	bool operator==(const md5_t &rhs) const { return memcmp(m_raw, rhs.m_raw, sizeof(m_raw)) == 0; }
+	bool operator!=(const md5_t &rhs) const { return memcmp(m_raw, rhs.m_raw, sizeof(m_raw)) != 0; }
+	operator UINT8 *() { return m_raw; }
+	bool from_string(const char *string, int length = -1);
+	const char *as_string(astring &buffer) const;
+	UINT8 m_raw[16];
+	static const md5_t null;
+};
+
+// creation helper
+class md5_creator
+{
+public:
+	// construction/destruction
+	md5_creator() { reset(); }
+
+	// reset
+	void reset() { MD5Init(&m_context); }
+
+	// append data
+	void append(const void *data, UINT32 length) { MD5Update(&m_context, reinterpret_cast<const unsigned char *>(data), length); }
+
+	// finalize and compute the final digest
+	md5_t finish()
+	{
+		md5_t result;
+		MD5Final(result.m_raw, &m_context);
+		return result;
+	}
+
+	// static wrapper to just get the digest from a block
+	static md5_t simple(const void *data, UINT32 length)
+	{
+		md5_creator creator;
+		creator.append(data, length);
+		return creator.finish();
+	}
+
+protected:
+	// internal state
+	struct MD5Context	m_context;		// internal context
+};
+
+
+
+// ======================> CRC-32
+
+// final digest
+struct crc32_t
+{
+	bool operator==(const crc32_t &rhs) const { return m_raw == rhs.m_raw; }
+	bool operator!=(const crc32_t &rhs) const { return m_raw != rhs.m_raw; }
+	crc32_t &operator=(const UINT32 crc) { m_raw = crc; return *this; }
+	operator UINT32() const { return m_raw; }
+	bool from_string(const char *string, int length = -1);
+	const char *as_string(astring &buffer) const;
+	UINT32 m_raw;
+	static const crc32_t null;
+};
+
+// creation helper
+class crc32_creator
+{
+public:
+	// construction/destruction
+	crc32_creator() { reset(); }
+
+	// reset
+	void reset() { m_accum.m_raw = 0; }
+
+	// append data
+	void append(const void *data, UINT32 length);
+
+	// finalize and compute the final digest
+	crc32_t finish() { return m_accum; }
+
+	// static wrapper to just get the digest from a block
+	static crc32_t simple(const void *data, UINT32 length)
+	{
+		crc32_creator creator;
+		creator.append(data, length);
+		return creator.finish();
+	}
+
+protected:
+	// internal state
+	crc32_t 			m_accum;		// internal accumulator
+};
+
+
+
+// ======================> CRC-16
+
+// final digest
+struct crc16_t
+{
+	bool operator==(const crc16_t &rhs) const { return m_raw == rhs.m_raw; }
+	bool operator!=(const crc16_t &rhs) const { return m_raw != rhs.m_raw; }
+	crc16_t &operator=(const UINT16 crc) { m_raw = crc; return *this; }
+	operator UINT16() const { return m_raw; }
+	bool from_string(const char *string, int length = -1);
+	const char *as_string(astring &buffer) const;
+	UINT16 m_raw;
+	static const crc16_t null;
+};
+
+// creation helper
+class crc16_creator
+{
+public:
+	// construction/destruction
+	crc16_creator() { reset(); }
+
+	// reset
+	void reset() { m_accum.m_raw = 0xffff; }
+
+	// append data
+	void append(const void *data, UINT32 length);
+
+	// finalize and compute the final digest
+	crc16_t finish() { return m_accum; }
+
+	// static wrapper to just get the digest from a block
+	static crc16_t simple(const void *data, UINT32 length)
+	{
+		crc16_creator creator;
+		creator.append(data, length);
+		return creator.finish();
+	}
+
+protected:
+	// internal state
+	crc16_t 			m_accum;		// internal accumulator
+};
+
+
+#endif // __HASHING_H__
diff -Nru src-old/lib/util/huffman.c src/lib/util/huffman.c
--- src-old/lib/util/huffman.c	2010-01-17 21:15:47.000000000 +0100
+++ src/lib/util/huffman.c	2012-02-19 16:23:23.000000000 +0100
@@ -2,7 +2,7 @@
 
     huffman.c
 
-    Video compression and decompression helpers.
+    Static Huffman compression and decompression helpers.
 
 ****************************************************************************
 
@@ -127,1569 +127,636 @@
 
 #include <stdlib.h>
 
+#include "coretmpl.h"
 #include "huffman.h"
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-#define HUFFMAN_CODES			256
-#define HUFFMAN_DELTARLE_CODES	(HUFFMAN_CODES + 16)
-
-#define MAX_HUFFMAN_CODES		(HUFFMAN_DELTARLE_CODES)
-#define MAX_HUFFMAN_NODES		(MAX_HUFFMAN_CODES + MAX_HUFFMAN_CODES)
-
-
-
-/***************************************************************************
-    MACROS
-***************************************************************************/
-
-#define MAKE_LOOKUP(code,bits)	(((code) << 6) | ((bits) & 0x1f))
-#define LOOKUP_CODE(val)		((val) >> 6)
-#define LOOKUP_BITS(val)		((val) & 0x1f)
-
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-typedef struct _bit_buffer bit_buffer;
-struct _bit_buffer
-{
-	UINT32					buffer;							/* current bit accumulator */
-	int						bits;							/* number of bits in the accumulator */
-	union
-	{
-		const UINT8 *		read;							/* read pointer */
-		UINT8 *				write;							/* write pointer */
-	} data;
-	UINT32					doffset;						/* byte offset within the data */
-	UINT32					dlength;						/* length of the data */
-	int						overflow;						/* flag: true if we read/wrote past the end */
-};
-
-
-typedef struct _huffman_node huffman_node;
-struct _huffman_node
-{
-	huffman_node *			parent;							/* pointer to parent node */
-	UINT32					count;							/* number of hits on this node */
-	UINT32					weight;							/* assigned weight of this node */
-	UINT32					bits;							/* bits used to encode the node */
-	UINT8					numbits;						/* number of bits needed for this node */
-};
-
-
-struct _huffman_context
-{
-	UINT8					maxbits;						/* maximum bits per code */
-	UINT8					lookupdirty;					/* TRUE if the lookup table is dirty */
-	UINT8					prevdata;						/* value of the previous data (for delta-RLE encoding) */
-	UINT32					datahisto[MAX_HUFFMAN_CODES];	/* histogram of data values */
-	int						rleremaining;					/* number of RLE bytes remaining (for delta-RLE encoding) */
-	huffman_node			huffnode[MAX_HUFFMAN_NODES];	/* array of nodes */
-	huffman_lookup_value *	lookup;							/* pointer to the lookup table */
-};
+//**************************************************************************
+//  MACROS
+//**************************************************************************
 
+#define MAKE_LOOKUP(code,bits)	(((code) << 5) | ((bits) & 0x1f))
 
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
-
-static huffman_error huffman_deltarle_decode_data_interleaved_0102(huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength);
-
-static huffman_error import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength, UINT32 numcodes);
-static huffman_error export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength, UINT32 numcodes);
-static void write_rle_tree_bits(bit_buffer *bitbuf, int value, int repcount, int numbits);
-static int CLIB_DECL tree_node_compare(const void *item1, const void *item2);
-static huffman_error compute_optimal_tree(huffman_context *context, const UINT32 *datahisto, UINT32 numcodes);
-static int huffman_build_tree(huffman_context *context, const UINT32 *datahisto, UINT32 totaldata, UINT32 totalweight, UINT32 numcodes);
-static huffman_error assign_canonical_codes(huffman_context *context, UINT32 numcodes);
-static huffman_error build_lookup_table(huffman_context *context, UINT32 numcodes);
-
-
-
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    bit_buffer_write_init - initialize a bit
-    buffer for writing
--------------------------------------------------*/
-
-INLINE void bit_buffer_write_init(bit_buffer *bitbuf, UINT8 *data, UINT32 dlength)
-{
-	/* fill in the basic data structure */
-	bitbuf->buffer = 0;
-	bitbuf->bits = 0;
-	bitbuf->data.write = data;
-	bitbuf->doffset = 0;
-	bitbuf->dlength = dlength;
-	bitbuf->overflow = FALSE;
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_write - write 'numbits' to the
-    bit buffer, assuming that 'newbits' is right-
-    justified
--------------------------------------------------*/
-
-INLINE void bit_buffer_write(bit_buffer *bitbuf, UINT32 newbits, int numbits)
-{
-	/* flush the buffer if we're going to overflow it */
-	if (bitbuf->bits + numbits > 32)
-		while (bitbuf->bits >= 8)
-		{
-			if (bitbuf->doffset < bitbuf->dlength)
-				bitbuf->data.write[bitbuf->doffset] = bitbuf->buffer >> 24;
-			else
-				bitbuf->overflow = TRUE;
-			bitbuf->doffset++;
-			bitbuf->buffer <<= 8;
-			bitbuf->bits -= 8;
-		}
-
-	/* shift the bits to the top */
-	newbits <<= 32 - numbits;
-
-	/* now shift it down to account for the number of bits we already have and OR them in */
-	bitbuf->buffer |= newbits >> bitbuf->bits;
-	bitbuf->bits += numbits;
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_flush - flush any bits in the write
-    buffer and return the final data offset
--------------------------------------------------*/
-
-INLINE UINT32 bit_buffer_flush(bit_buffer *bitbuf)
-{
-	while (bitbuf->bits > 0)
-	{
-		if (bitbuf->doffset < bitbuf->dlength)
-			bitbuf->data.write[bitbuf->doffset] = bitbuf->buffer >> 24;
-		else
-			bitbuf->overflow = TRUE;
-		bitbuf->doffset++;
-		bitbuf->buffer <<= 8;
-		bitbuf->bits -= 8;
-	}
-	return bitbuf->doffset;
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_read_init - initialize a bit
-    buffer for reading
--------------------------------------------------*/
-
-INLINE void bit_buffer_read_init(bit_buffer *bitbuf, const UINT8 *data, UINT32 dlength)
-{
-	/* fill in the basic data structure */
-	bitbuf->buffer = 0;
-	bitbuf->bits = 0;
-	bitbuf->data.read = data;
-	bitbuf->doffset = 0;
-	bitbuf->dlength = dlength;
-	bitbuf->overflow = FALSE;
-}
 
+//**************************************************************************
+//  IMPLEMENTATION
+//**************************************************************************
 
-/*-------------------------------------------------
-    bit_buffer_read - read 'numbits' bits from
-    the buffer, returning them right-justified
--------------------------------------------------*/
+//-------------------------------------------------
+//  huffman_context_base - create an encoding/
+//  decoding context
+//-------------------------------------------------
 
-INLINE UINT32 bit_buffer_read(bit_buffer *bitbuf, int numbits)
+huffman_context_base::huffman_context_base(int numcodes, int maxbits, lookup_value *lookup, UINT32 *histo, node_t *nodes)
+	: m_numcodes(numcodes),
+	  m_maxbits(maxbits),
+	  m_prevdata(0),
+	  m_rleremaining(0),
+	  m_lookup(lookup),
+	  m_datahisto(histo),
+	  m_huffnode(nodes)
 {
-	UINT32 result;
-
-	/* fetch data if we need more */
-	if (numbits > bitbuf->bits)
-	{
-		while (bitbuf->bits <= 24)
-		{
-			if (bitbuf->doffset < bitbuf->dlength)
-				bitbuf->buffer |= bitbuf->data.read[bitbuf->doffset] << (24 - bitbuf->bits);
-			bitbuf->doffset++;
-			bitbuf->bits += 8;
-		}
-		if (numbits > bitbuf->bits)
-			bitbuf->overflow = TRUE;
-	}
-
-	/* return the data */
-	result = bitbuf->buffer >> (32 - numbits);
-	bitbuf->buffer <<= numbits;
-	bitbuf->bits -= numbits;
-	return result;
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_peek - peek ahead and return
-    'numbits' bits from the buffer, returning
-    them right-justified
--------------------------------------------------*/
-
-INLINE UINT32 bit_buffer_peek(bit_buffer *bitbuf, int numbits)
-{
-	/* fetch data if we need more */
-	if (numbits > bitbuf->bits)
-	{
-		while (bitbuf->bits <= 24)
-		{
-			if (bitbuf->doffset < bitbuf->dlength)
-				bitbuf->buffer |= bitbuf->data.read[bitbuf->doffset] << (24 - bitbuf->bits);
-			bitbuf->doffset++;
-			bitbuf->bits += 8;
-		}
-		if (numbits > bitbuf->bits)
-			bitbuf->overflow = TRUE;
-	}
-
-	/* return the data */
-	return bitbuf->buffer >> (32 - numbits);
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_remove - remove 'numbits' bits
-    from the bit buffer; this presupposes that
-    at least 'numbits' are present
--------------------------------------------------*/
-
-INLINE void bit_buffer_remove(bit_buffer *bitbuf, int numbits)
-{
-	bitbuf->buffer <<= numbits;
-	bitbuf->bits -= numbits;
-}
-
-
-/*-------------------------------------------------
-    bit_buffer_read_offset - return the current
-    rounded byte reading offset
--------------------------------------------------*/
-
-INLINE UINT32 bit_buffer_read_offset(bit_buffer *bitbuf)
-{
-	UINT32 result = bitbuf->doffset;
-	int bits = bitbuf->bits;
-	while (bits >= 8)
-	{
-		result--;
-		bits -= 8;
-	}
-	return result;
-}
-
-
-/*-------------------------------------------------
-    code_to_rlecount - number of RLE repetitions
-    encoded in a given byte
--------------------------------------------------*/
-
-INLINE int code_to_rlecount(int code)
-{
-	if (code == 0x00)
-		return 1;
-	if (code <= 0x107)
-		return 8 + (code - 0x100);
-	return 16 << (code - 0x108);
-}
-
-
-/*-------------------------------------------------
-    rlecount_to_byte - return a byte encoding
-    the maximum RLE count less than or equal to
-    the provided amount
--------------------------------------------------*/
-
-INLINE int rlecount_to_code(int rlecount)
-{
-	if (rlecount >= 2048)
-		return 0x10f;
-	if (rlecount >= 1024)
-		return 0x10e;
-	if (rlecount >= 512)
-		return 0x10d;
-	if (rlecount >= 256)
-		return 0x10c;
-	if (rlecount >= 128)
-		return 0x10b;
-	if (rlecount >= 64)
-		return 0x10a;
-	if (rlecount >= 32)
-		return 0x109;
-	if (rlecount >= 16)
-		return 0x108;
-	if (rlecount >= 8)
-		return 0x100 + (rlecount - 8);
-	return 0x00;
-}
-
-
-
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    huffman_create_context - create an encoding/
-    decoding context
--------------------------------------------------*/
-
-huffman_error huffman_create_context(huffman_context **context, int maxbits)
-{
-	/* limit to 24 bits */
+	// limit to 24 bits
 	if (maxbits > 24)
-		return HUFFERR_TOO_MANY_BITS;
-
-	/* allocate a context */
-	*context = (huffman_context *)malloc(sizeof(**context));
-	if (*context == NULL)
-		return HUFFERR_OUT_OF_MEMORY;
-
-	/* set the info */
-	memset(*context, 0, sizeof(**context));
-	(*context)->maxbits = maxbits;
-	(*context)->lookupdirty = TRUE;
-
-	return HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    huffman_free_context - free an encoding/
-    decoding context
--------------------------------------------------*/
-
-void huffman_free_context(huffman_context *context)
-{
-	if (context->lookup != NULL)
-		free(context->lookup);
-	free(context);
+		throw HUFFERR_TOO_MANY_BITS;
 }
 
 
-/*-------------------------------------------------
-    huffman_import_tree - import a huffman tree
-    from a source data stream
--------------------------------------------------*/
+//-------------------------------------------------
+//  import_tree_rle - import an RLE-encoded
+//  huffman tree from a source data stream
+//-------------------------------------------------
 
-huffman_error huffman_import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength)
+huffman_error huffman_context_base::import_tree_rle(bitstream_in &bitbuf)
 {
-	return import_tree(context, source, slength, actlength, HUFFMAN_CODES);
-}
-
-
-/*-------------------------------------------------
-    huffman_export_tree - export a huffman tree
-    to a target data stream
--------------------------------------------------*/
-
-huffman_error huffman_export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
-{
-	return export_tree(context, dest, dlength, actlength, HUFFMAN_CODES);
-}
-
-
-/*-------------------------------------------------
-    huffman_deltarle_import_tree - import a
-    huffman tree from a source data stream for
-    delta-RLE encoded data
--------------------------------------------------*/
-
-huffman_error huffman_deltarle_import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength)
-{
-	return import_tree(context, source, slength, actlength, HUFFMAN_DELTARLE_CODES);
-}
-
-
-/*-------------------------------------------------
-    huffman__deltarle_export_tree - export a
-    huffman tree to a target data stream for
-    delta-RLE encoded data
--------------------------------------------------*/
-
-huffman_error huffman_deltarle_export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
-{
-	return export_tree(context, dest, dlength, actlength, HUFFMAN_DELTARLE_CODES);
-}
-
-
-/*-------------------------------------------------
-    huffman_compute_tree - compute an optimal
-    huffman tree for the given source data
--------------------------------------------------*/
-
-huffman_error huffman_compute_tree(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor)
-{
-	return huffman_compute_tree_interleaved(1, &context, source, swidth, sheight, sstride, sxor);
-}
-
-huffman_error huffman_compute_tree_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor)
-{
-	UINT32 sx, sy, ctxnum;
-	huffman_error error;
-
-	/* initialize all nodes */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		memset(context->datahisto, 0, sizeof(context->datahisto));
-	}
-
-	/* iterate over "height" */
-	for (sy = 0; sy < sheight; sy++)
-	{
-		/* iterate over "width" */
-		for (sx = 0; sx < swidth; )
-		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, sx++)
-			{
-				huffman_context *context = contexts[ctxnum];
-				context->datahisto[source[sx ^ sxor]]++;
-			}
-		}
-
-		/* advance to the next row */
-		source += sstride;
-	}
-
-	/* compute optimal trees for each */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		error = compute_optimal_tree(context, context->datahisto, HUFFMAN_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
-	}
-	return HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    huffman_deltarle_compute_tree - compute an
-    optimal huffman tree for the given source
-    data, with pre-encoding as delta-RLE
--------------------------------------------------*/
-
-huffman_error huffman_deltarle_compute_tree(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor)
-{
-	return huffman_deltarle_compute_tree_interleaved(1, &context, source, swidth, sheight, sstride, sxor);
-}
-
-huffman_error huffman_deltarle_compute_tree_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor)
-{
-	UINT32 sx, sy, ctxnum;
-	huffman_error error;
+	// bits per entry depends on the maxbits
+	int numbits;
+	if (m_maxbits >= 16)
+		numbits = 5;
+	else if (m_maxbits >= 8)
+		numbits = 4;
+	else
+		numbits = 3;
 
-	/* initialize all nodes */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
+	// loop until we read all the nodes
+	int curnode;
+	for (curnode = 0; curnode < m_numcodes; )
 	{
-		huffman_context *context = contexts[ctxnum];
-		memset(context->datahisto, 0, sizeof(context->datahisto));
-		context->prevdata = 0;
-	}
+		// a non-one value is just raw
+		int nodebits = bitbuf.read(numbits);
+		if (nodebits != 1)
+			m_huffnode[curnode++].m_numbits = nodebits;
 
-	/* iterate over "height" */
-	for (sy = 0; sy < sheight; sy++)
-	{
-		/* reset RLE counts */
-		for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
+		// a one value is an escape code
+		else
 		{
-			huffman_context *context = contexts[ctxnum];
-			context->rleremaining = 0;
-		}
+			// a double 1 is just a single 1
+			nodebits = bitbuf.read(numbits);
+			if (nodebits == 1)
+				m_huffnode[curnode++].m_numbits = nodebits;
 
-		/* iterate over "width" */
-		for (sx = 0; sx < swidth; )
-		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, sx++)
+			// otherwise, we need one for value for the repeat count
+			else
 			{
-				huffman_context *context = contexts[ctxnum];
-				UINT8 newdata, delta;
-
-				/* if still counting RLE, do nothing */
-				if (context->rleremaining != 0)
-				{
-					context->rleremaining--;
-					continue;
-				}
-
-				/* fetch new data and compute the delta */
-				newdata = source[sx ^ sxor];
-				delta = newdata - context->prevdata;
-				context->prevdata = newdata;
-
-				/* 0 deltas scan forward for a count */
-				if (delta == 0)
-				{
-					int zerocount = 1;
-					int rlecode;
-					UINT32 scan;
-
-					/* count the number of consecutive values */
-					for (scan = sx + 1; scan < swidth; scan++)
-						if (contexts[scan % numcontexts] == context)
-						{
-							if (newdata == source[scan ^ sxor])
-								zerocount++;
-							else
-								break;
-						}
-
-					/* if we hit the end of row, maximize the count */
-					if (scan >= swidth && zerocount >= 8)
-						zerocount = 100000;
-
-					/* encode the maximal count we can */
-					rlecode = rlecount_to_code(zerocount);
-					context->datahisto[rlecode]++;
-
-					/* set up the remaining count */
-					context->rleremaining = code_to_rlecount(rlecode) - 1;
-				}
-				else
-				{
-					/* encode the actual delta */
-					context->datahisto[delta]++;
-				}
+				int repcount = bitbuf.read(numbits) + 3;
+				while (repcount--)
+					m_huffnode[curnode++].m_numbits = nodebits;
 			}
 		}
-
-		/* advance to the next row */
-		source += sstride;
-	}
-
-	/* compute optimal trees for each */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		error = compute_optimal_tree(context, context->datahisto, HUFFMAN_DELTARLE_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
 	}
-	return HUFFERR_NONE;
-}
-
 
-/*-------------------------------------------------
-    huffman_encode_data - encode data using the
-    given tree
--------------------------------------------------*/
-
-huffman_error huffman_encode_data(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
-{
-	return huffman_encode_data_interleaved(1, &context, source, swidth, sheight, sstride, sxor, dest, dlength, actlength);
-}
-
-huffman_error huffman_encode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
-{
-	UINT32 sx, sy, ctxnum;
-	bit_buffer bitbuf;
-
-	/* initialize the output buffer */
-	bit_buffer_write_init(&bitbuf, dest, dlength);
+	// make sure we ended up with the right number
+	if (curnode != m_numcodes)
+		return HUFFERR_INVALID_DATA;
 
-	/* iterate over "height" */
-	for (sy = 0; sy < sheight; sy++)
-	{
-		/* iterate over "width" */
-		for (sx = 0; sx < swidth; )
-		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, sx++)
-			{
-				huffman_context *context = contexts[ctxnum];
-				huffman_node *node = &context->huffnode[source[sx ^ sxor]];
-				bit_buffer_write(&bitbuf, node->bits, node->numbits);
-			}
-		}
+	// assign canonical codes for all nodes based on their code lengths
+	huffman_error error = assign_canonical_codes();
+	if (error != HUFFERR_NONE)
+		return error;
 
-		/* advance to the next row */
-		source += sstride;
-	}
+	// build the lookup table
+	build_lookup_table();
 
-	/* flush and return a status */
-	*actlength = bit_buffer_flush(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+	// determine final input length and report errors
+	return bitbuf.overflow() ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    huffman_deltarle_encode_data - encode data
-    using the given tree with delta-RLE
-    pre-encoding
--------------------------------------------------*/
+//-------------------------------------------------
+//  export_tree_rle - export a huffman tree to an
+//  RLE target data stream
+//-------------------------------------------------
 
-huffman_error huffman_deltarle_encode_data(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
+huffman_error huffman_context_base::export_tree_rle(bitstream_out &bitbuf)
 {
-	return huffman_deltarle_encode_data_interleaved(1, &context, source, swidth, sheight, sstride, sxor, dest, dlength, actlength);
-}
-
-huffman_error huffman_deltarle_encode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength)
-{
-	UINT32 sx, sy, ctxnum;
-	bit_buffer bitbuf;
-
-	/* initialize the output buffer */
-	bit_buffer_write_init(&bitbuf, dest, dlength);
-
-	/* initialize the contexts */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		context->prevdata = 0;
-	}
+	// bits per entry depends on the maxbits
+	int numbits;
+	if (m_maxbits >= 16)
+		numbits = 5;
+	else if (m_maxbits >= 8)
+		numbits = 4;
+	else
+		numbits = 3;
 
-	/* iterate over "height" */
-	for (sy = 0; sy < sheight; sy++)
+	// RLE encode the lengths
+	int lastval = ~0;
+	int repcount = 0;
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
 	{
-		/* reset RLE counts */
-		for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-		{
-			huffman_context *context = contexts[ctxnum];
-			context->rleremaining = 0;
-		}
+		// if we match the previous value, just bump the repcount
+		int newval = m_huffnode[curcode].m_numbits;
+		if (newval == lastval)
+			repcount++;
 
-		/* iterate over "width" */
-		for (sx = 0; sx < swidth; )
+		// otherwise, we need to flush the previous repeats
+		else
 		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, sx++)
-			{
-				huffman_context *context = contexts[ctxnum];
-				UINT8 newdata, delta;
-				huffman_node *node;
-
-				/* if still counting RLE, do nothing */
-				if (context->rleremaining != 0)
-				{
-					context->rleremaining--;
-					continue;
-				}
-
-				/* fetch new data and compute the delta */
-				newdata = source[sx ^ sxor];
-				delta = newdata - context->prevdata;
-				context->prevdata = newdata;
-
-				/* 0 deltas scan forward for a count */
-				if (delta == 0)
-				{
-					int zerocount = 1;
-					int rlecode;
-					UINT32 scan;
-
-					/* count the number of consecutive values */
-					for (scan = sx + 1; scan < swidth; scan++)
-						if (contexts[scan % numcontexts] == context)
-						{
-							if (newdata == source[scan ^ sxor])
-								zerocount++;
-							else
-								break;
-						}
-
-					/* if we hit the end of row, maximize the count */
-					if (scan >= swidth && zerocount >= 8)
-						zerocount = 100000;
-
-					/* encode the maximal count we can */
-					rlecode = rlecount_to_code(zerocount);
-					node = &context->huffnode[rlecode];
-					bit_buffer_write(&bitbuf, node->bits, node->numbits);
-
-					/* set up the remaining count */
-					context->rleremaining = code_to_rlecount(rlecode) - 1;
-				}
-				else
-				{
-					/* encode the actual delta */
-					node = &context->huffnode[delta];
-					bit_buffer_write(&bitbuf, node->bits, node->numbits);
-				}
-			}
+			if (repcount != 0)
+				write_rle_tree_bits(bitbuf, lastval, repcount, numbits);
+			lastval = newval;
+			repcount = 1;
 		}
-
-		/* advance to the next row */
-		source += sstride;
 	}
 
-	/* flush and return a status */
-	*actlength = bit_buffer_flush(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+	// flush the last value
+	write_rle_tree_bits(bitbuf, lastval, repcount, numbits);
+	return bitbuf.overflow() ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    huffman_decode_data - decode data using the
-    given tree
--------------------------------------------------*/
+//-------------------------------------------------
+//  import_tree_huffman - import a huffman-encoded
+//  huffman tree from a source data stream
+//-------------------------------------------------
 
-huffman_error huffman_decode_data(huffman_context *context, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength)
+huffman_error huffman_context_base::import_tree_huffman(bitstream_in &bitbuf)
 {
-	const huffman_lookup_value *table;
-	int maxbits = context->maxbits;
-	huffman_error error;
-	bit_buffer bitbuf;
-	UINT32 dx, dy;
-
-	/* regenerate the lookup table if necessary */
-	if (context->lookupdirty)
+	// start by parsing the lengths for the small tree
+	huffman_decoder<24, 6> smallhuff;
+	smallhuff.m_huffnode[0].m_numbits = bitbuf.read(3);
+	int start = bitbuf.read(3) + 1;
+	int count = 0;
+	for (int index = 1; index < 24; index++)
 	{
-		error = build_lookup_table(context, HUFFMAN_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
-	}
-	table = context->lookup;
-
-	/* initialize our bit buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
-
-	/* iterate over "height" */
-	for (dy = 0; dy < dheight; dy++)
-	{
-		/* iterate over "width" */
-		for (dx = 0; dx < dwidth; dx++)
+		if (index < start || count == 7)
+			smallhuff.m_huffnode[index].m_numbits = 0;
+		else
 		{
-			huffman_lookup_value lookup;
-			UINT32 bits;
-
-			/* peek ahead to get maxbits worth of data */
-			bits = bit_buffer_peek(&bitbuf, maxbits);
-
-			/* look it up, then remove the actual number of bits for this code */
-			lookup = table[bits];
-			bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-			/* store the upper byte */
-			dest[dx ^ dxor] = LOOKUP_CODE(lookup);
+			count = bitbuf.read(3);
+			smallhuff.m_huffnode[index].m_numbits = (count == 7) ? 0 : count;
 		}
-
-		/* advance to the next row */
-		dest += dstride;
 	}
 
-	/* determine the actual length and indicate overflow */
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    huffman_decode_data_interleaved - decode
-    interleaved data using multiple contexts
--------------------------------------------------*/
-
-huffman_error huffman_decode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength)
-{
-	UINT32 dx, dy, ctxnum;
-	huffman_error error;
-	bit_buffer bitbuf;
+	// then regenerate the tree
+	huffman_error error = smallhuff.assign_canonical_codes();
+	if (error != HUFFERR_NONE)
+		return error;
+	smallhuff.build_lookup_table();
 
-	/* regenerate the lookup tables if necessary */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		if (context->lookupdirty)
+	// determine the maximum length of an RLE count
+	UINT32 temp = m_numcodes - 9;
+	UINT8 rlefullbits = 0;
+	while (temp != 0)
+		temp >>= 1, rlefullbits++;
+
+	// now process the rest of the data
+	int last = 0;
+	int curcode;
+	for (curcode = 0; curcode < m_numcodes; )
+	{
+		int value = smallhuff.decode_one(bitbuf);
+		if (value != 0)
+			m_huffnode[curcode++].m_numbits = last = value - 1;
+		else
 		{
-			error = build_lookup_table(context, HUFFMAN_CODES);
-			if (error != HUFFERR_NONE)
-				return error;
+			int count = bitbuf.read(3) + 2;
+			if (count == 7+2)
+				count += bitbuf.read(rlefullbits);
+			for ( ; count != 0 && curcode < m_numcodes; count--)
+				m_huffnode[curcode++].m_numbits = last;
 		}
 	}
 
-	/* initialize our bit buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
-
-	/* iterate over "height" */
-	for (dy = 0; dy < dheight; dy++)
-	{
-		/* iterate over "width" */
-		for (dx = 0; dx < dwidth; )
-		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, dx++)
-			{
-				huffman_context *context = contexts[ctxnum];
-				huffman_lookup_value lookup;
-				UINT32 bits;
-
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, context->maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = context->lookup[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
+	// make sure we ended up with the right number
+	if (curcode != m_numcodes)
+		return HUFFERR_INVALID_DATA;
 
-				/* store the upper byte */
-				dest[dx ^ dxor] = LOOKUP_CODE(lookup);
-			}
-		}
+	// assign canonical codes for all nodes based on their code lengths
+	error = assign_canonical_codes();
+	if (error != HUFFERR_NONE)
+		return error;
 
-		/* advance to the next row */
-		dest += dstride;
-	}
+	// build the lookup table
+	build_lookup_table();
 
-	/* determine the actual length and indicate overflow */
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+	// determine final input length and report errors
+	return bitbuf.overflow() ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    huffman_deltarle_decode_data - decode data
-    using the given tree with delta-RLE
-    post-decoding
--------------------------------------------------*/
+//-------------------------------------------------
+//  export_tree_huffman - export a huffman tree to
+//  a huffman target data stream
+//-------------------------------------------------
 
-huffman_error huffman_deltarle_decode_data(huffman_context *context, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength)
+huffman_error huffman_context_base::export_tree_huffman(bitstream_out &bitbuf)
 {
-	const huffman_lookup_value *table;
-	int maxbits = context->maxbits;
-	UINT32 rleremaining = 0;
-	huffman_error error;
-	UINT8 prevdata = 0;
-	bit_buffer bitbuf;
-	UINT32 dx, dy;
+	// first RLE compress the lengths of all the nodes
+	dynamic_array<UINT8> rle_data(m_numcodes);
+	UINT8 *dest = rle_data;
+	dynamic_array<UINT16> rle_lengths(m_numcodes/3);
+	UINT16 *lengths = rle_lengths;
+	int last = ~0;
+	int repcount = 0;
 
-	/* regenerate the lookup table if necessary */
-	if (context->lookupdirty)
-	{
-		error = build_lookup_table(context, HUFFMAN_DELTARLE_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
-	}
-	table = context->lookup;
-
-	/* initialize our bit buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
+	// use a small huffman context to create a tree (ignoring RLE lengths)
+	huffman_encoder<24, 6> smallhuff;
 
-	/* iterate over "height" */
-	for (dy = 0; dy < dheight; dy++)
+	// RLE-compress the lengths
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
 	{
-		/* reset RLE counts */
-		rleremaining = 0;
-
-		/* iterate over "width" */
-		for (dx = 0; dx < dwidth; dx++)
+		// if this is the end of a repeat, flush any accumulation
+		int newval = m_huffnode[curcode].m_numbits;
+		if (newval != last && repcount > 0)
 		{
-			huffman_lookup_value lookup;
-			UINT32 bits;
-			int data;
-
-			/* if we have RLE remaining, just store that */
-			if (rleremaining != 0)
-			{
-				rleremaining--;
-				dest[dx ^ dxor] = prevdata;
-				continue;
-			}
-
-			/* peek ahead to get maxbits worth of data */
-			bits = bit_buffer_peek(&bitbuf, maxbits);
-
-			/* look it up, then remove the actual number of bits for this code */
-			lookup = table[bits];
-			bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-			/* compute the data and handle RLE decoding */
-			data = LOOKUP_CODE(lookup);
-
-			/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-			if (data < 0x100)
-				prevdata += (UINT8)data;
+			if (repcount == 1)
+				smallhuff.histo_one(*dest++ = last + 1);
 			else
-				rleremaining = code_to_rlecount(data) - 1;
-
-			/* store the updated data value */
-			dest[dx ^ dxor] = prevdata;
+				smallhuff.histo_one(*dest++ = 0), *lengths++ = repcount - 2;
 		}
 
-		/* advance to the next row */
-		dest += dstride;
-	}
-
-	/* determine the actual length and indicate overflow */
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    huffman_deltarle_decode_data_interleaved -
-    decode data using multiple contexts and
-    delta-RLE post-decoding
--------------------------------------------------*/
-
-huffman_error huffman_deltarle_decode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength)
-{
-	UINT32 dx, dy, ctxnum;
-	huffman_error error;
-	bit_buffer bitbuf;
-
-	/* fast case the A/V Y/Cb/Y/Cr case */
-	if (numcontexts == 4 && contexts[0] == contexts[2] && contexts[0] != contexts[1] && contexts[1] != contexts[3] &&
-		contexts[0]->maxbits == contexts[1]->maxbits && contexts[0]->maxbits == contexts[3]->maxbits)
-		return huffman_deltarle_decode_data_interleaved_0102(contexts, source, slength, dest, dwidth, dheight, dstride, dxor, actlength);
-
-	/* regenerate the lookup tables if necessary */
-	for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-	{
-		huffman_context *context = contexts[ctxnum];
-		if (context->lookupdirty)
-		{
-			error = build_lookup_table(context, HUFFMAN_DELTARLE_CODES);
-			if (error != HUFFERR_NONE)
-				return error;
-		}
-		context->prevdata = 0;
-	}
-
-	/* initialize our bit buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
-
-	/* iterate over "height" */
-	for (dy = 0; dy < dheight; dy++)
-	{
-		/* reset RLE counts */
-		for (ctxnum = 0; ctxnum < numcontexts; ctxnum++)
-		{
-			huffman_context *context = contexts[ctxnum];
-			context->rleremaining = 0;
-		}
+		// if same as last, just track repeats
+		if (newval == last)
+			repcount++;
 
-		/* iterate over "width" */
-		for (dx = 0; dx < dwidth; )
+		// otherwise, write it and start a new run
+		else
 		{
-			/* iterate over contexts */
-			for (ctxnum = 0; ctxnum < numcontexts; ctxnum++, dx++)
-			{
-				huffman_context *context = contexts[ctxnum];
-				huffman_lookup_value lookup;
-				UINT32 bits;
-				int data;
-
-				/* if we have RLE remaining, just store that */
-				if (context->rleremaining != 0)
-				{
-					context->rleremaining--;
-					dest[dx ^ dxor] = context->prevdata;
-					continue;
-				}
-
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, context->maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = context->lookup[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-				/* compute the data and handle RLE decoding */
-				data = LOOKUP_CODE(lookup);
-
-				/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-				if (data < 0x100)
-					context->prevdata += (UINT8)data;
-				else
-					context->rleremaining = code_to_rlecount(data) - 1;
-
-				/* store the updated data value */
-				dest[dx ^ dxor] = context->prevdata;
-			}
+			smallhuff.histo_one(*dest++ = newval + 1);
+			last = newval;
+			repcount = 0;
 		}
-
-		/* advance to the next row */
-		dest += dstride;
 	}
 
-	/* determine the actual length and indicate overflow */
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    huffman_deltarle_decode_data_interleaved_0102 -
-    decode data using 3 unique contexts in
-    0/1/0/2 order (used for Y/Cb/Y/Cr encoding)
--------------------------------------------------*/
-
-static huffman_error huffman_deltarle_decode_data_interleaved_0102(huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength)
-{
-	const huffman_lookup_value *table02, *table1, *table3;
-	int rleremaining02, rleremaining1, rleremaining3;
-	UINT8 prevdata02 = 0, prevdata1 = 0, prevdata3 = 0;
-	int maxbits = contexts[0]->maxbits;
-	huffman_error error;
-	bit_buffer bitbuf;
-	UINT32 dx, dy;
-
-	/* regenerate the lookup tables if necessary */
-	if (contexts[0]->lookupdirty)
+	// flush any final RLE counts
+	if (repcount > 0)
 	{
-		error = build_lookup_table(contexts[0], HUFFMAN_DELTARLE_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
-	}
-	if (contexts[1]->lookupdirty)
-	{
-		error = build_lookup_table(contexts[1], HUFFMAN_DELTARLE_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
-	}
-	if (contexts[3]->lookupdirty)
-	{
-		error = build_lookup_table(contexts[3], HUFFMAN_DELTARLE_CODES);
-		if (error != HUFFERR_NONE)
-			return error;
+		if (repcount == 1)
+			smallhuff.histo_one(*dest++ = last + 1);
+		else
+			smallhuff.histo_one(*dest++ = 0), *lengths++ = repcount - 2;
 	}
 
-	/* cache the tables locally */
-	table02 = contexts[0]->lookup;
-	table1 = contexts[1]->lookup;
-	table3 = contexts[3]->lookup;
-
-	/* initialize our bit buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
-
-	/* iterate over "height" */
-	for (dy = 0; dy < dheight; dy++)
-	{
-		/* reset RLE counts */
-		rleremaining02 = rleremaining1 = rleremaining3 = 0;
-
-		/* iterate over "width" */
-		for (dx = 0; dx < dwidth; dx += 4)
-		{
-			huffman_lookup_value lookup;
-			UINT32 bits;
-			int data;
-
-			/* ----- offset 0 ----- */
-
-			/* if we have RLE remaining, just store that */
-			if (rleremaining02 != 0)
-				rleremaining02--;
-			else
-			{
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = table02[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-				/* compute the data and handle RLE decoding */
-				data = LOOKUP_CODE(lookup);
-
-				/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-				if (data < 0x100)
-					prevdata02 += (UINT8)data;
-				else
-					rleremaining02 = code_to_rlecount(data) - 1;
-			}
-
-			/* store the updated data value */
-			dest[(dx + 0) ^ dxor] = prevdata02;
-
-			/* ----- offset 1 ----- */
+	// compute an optimal tree
+	smallhuff.compute_tree_from_histo();
 
-			/* if we have RLE remaining, just store that */
-			if (rleremaining1 != 0)
-				rleremaining1--;
+	// determine the first and last non-zero nodes
+	int first_non_zero = 31, last_non_zero = 0;
+	for (int index = 1; index < smallhuff.m_numcodes; index++)
+		if (smallhuff.m_huffnode[index].m_numbits != 0)
+		{
+			if (first_non_zero == 31)
+				first_non_zero = index;
+			last_non_zero = index;
+		}
+
+	// clamp first non-zero to be 8 at a maximum
+	first_non_zero = MIN(first_non_zero, 8);
+
+	// output the lengths of the each small tree node, starting with the RLE
+	// token (0), followed by the first_non_zero value, followed by the data
+	// terminated by a 7
+	bitbuf.write(smallhuff.m_huffnode[0].m_numbits, 3);
+	bitbuf.write(first_non_zero - 1, 3);
+	for (int index = first_non_zero; index <= last_non_zero; index++)
+		bitbuf.write(smallhuff.m_huffnode[index].m_numbits, 3);
+	bitbuf.write(7, 3);
+
+	// determine the maximum length of an RLE count
+	UINT32 temp = m_numcodes - 9;
+	UINT8 rlefullbits = 0;
+	while (temp != 0)
+		temp >>= 1, rlefullbits++;
+
+	// now encode the RLE data
+	lengths = rle_lengths;
+	for (UINT8 *src = rle_data; src < dest; src++)
+	{
+		// encode the data
+		UINT8 data = *src;
+		smallhuff.encode_one(bitbuf, data);
+
+		// if this is an RLE token, encode the length following
+		if (data == 0)
+		{
+			int count = *lengths++;
+			if (count < 7)
+				bitbuf.write(count, 3);
 			else
-			{
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = table1[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-				/* compute the data and handle RLE decoding */
-				data = LOOKUP_CODE(lookup);
-
-				/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-				if (data < 0x100)
-					prevdata1 += (UINT8)data;
-				else
-					rleremaining1 = code_to_rlecount(data) - 1;
-			}
-
-			/* store the updated data value */
-			dest[(dx + 1) ^ dxor] = prevdata1;
-
-			/* ----- offset 2 (same as 0) ----- */
-
-			/* if we have RLE remaining, just store that */
-			if (rleremaining02 != 0)
-				rleremaining02--;
-			else
-			{
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = table02[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-				/* compute the data and handle RLE decoding */
-				data = LOOKUP_CODE(lookup);
-
-				/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-				if (data < 0x100)
-					prevdata02 += (UINT8)data;
-				else
-					rleremaining02 = code_to_rlecount(data) - 1;
-			}
-
-			/* store the updated data value */
-			dest[(dx + 2) ^ dxor] = prevdata02;
-
-			/* ----- offset 3 ----- */
-
-			/* if we have RLE remaining, just store that */
-			if (rleremaining3 != 0)
-				rleremaining3--;
-			else
-			{
-				/* peek ahead to get maxbits worth of data */
-				bits = bit_buffer_peek(&bitbuf, maxbits);
-
-				/* look it up, then remove the actual number of bits for this code */
-				lookup = table3[bits];
-				bit_buffer_remove(&bitbuf, LOOKUP_BITS(lookup));
-
-				/* compute the data and handle RLE decoding */
-				data = LOOKUP_CODE(lookup);
-
-				/* if not an RLE special, just add to the previous; otherwise, start counting RLE */
-				if (data < 0x100)
-					prevdata3 += (UINT8)data;
-				else
-					rleremaining3 = code_to_rlecount(data) - 1;
-			}
-
-			/* store the updated data value */
-			dest[(dx + 3) ^ dxor] = prevdata3;
+				bitbuf.write(7, 3), bitbuf.write(count - 7, rlefullbits);
 		}
-
-		/* advance to the next row */
-		dest += dstride;
 	}
 
-	/* determine the actual length and indicate overflow */
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+	// flush the final buffer
+	return bitbuf.overflow() ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
 }
 
 
+//-------------------------------------------------
+//  compute_tree_from_histo - common backend for
+//  computing a tree based on the data histogram
+//-------------------------------------------------
 
-/***************************************************************************
-    INTERNAL FUNCTIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    import_tree - import a huffman tree from a
-    source data stream
--------------------------------------------------*/
-
-static huffman_error import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength, UINT32 numcodes)
+huffman_error huffman_context_base::compute_tree_from_histo()
 {
-	huffman_error error;
-	bit_buffer bitbuf;
-	int curnode;
-	int numbits;
+	// compute the number of data items in the histogram
+	UINT32 sdatacount = 0;
+	for (int i = 0; i < m_numcodes; i++)
+		sdatacount += m_datahisto[i];
 
-	/* initialize the input buffer */
-	bit_buffer_read_init(&bitbuf, source, slength);
-
-	/* bits per entry depends on the maxbits */
-	if (context->maxbits >= 16)
-		numbits = 5;
-	else if (context->maxbits >= 8)
-		numbits = 4;
-	else
-		numbits = 3;
-
-	/* loop until we read all the nodes */
-	for (curnode = 0; curnode < numcodes; )
+	// binary search to achieve the optimum encoding
+	UINT32 lowerweight = 0;
+	UINT32 upperweight = sdatacount * 2;
+	while (1)
 	{
-		int nodebits = bit_buffer_read(&bitbuf, numbits);
-
-		/* a non-one value is just raw */
-		if (nodebits != 1)
-			context->huffnode[curnode++].numbits = nodebits;
+		// build a tree using the current weight
+		UINT32 curweight = (upperweight + lowerweight) / 2;
+		int curmaxbits = build_tree(sdatacount, curweight);
 
-		/* a one value is an escape code */
-		else
+		// apply binary search here
+		if (curmaxbits <= m_maxbits)
 		{
-			nodebits = bit_buffer_read(&bitbuf, numbits);
-
-			/* a double 1 is just a single 1 */
-			if (nodebits == 1)
-				context->huffnode[curnode++].numbits = nodebits;
+			lowerweight = curweight;
 
-			/* otherwise, we need one for value for the repeat count */
-			else
-			{
-				int repcount = bit_buffer_read(&bitbuf, numbits) + 3;
-				while (repcount--)
-					context->huffnode[curnode++].numbits = nodebits;
-			}
+			// early out if it worked with the raw weights, or if we're done searching
+			if (curweight == sdatacount || (upperweight - lowerweight) <= 1)
+				break;
 		}
+		else
+			upperweight = curweight;
 	}
 
-	/* assign canonical codes for all nodes based on their code lengths */
-	error = assign_canonical_codes(context, numcodes);
-	if (error != HUFFERR_NONE)
-		return error;
-
-	/* make sure we ended up with the right number */
-	if (curnode != numcodes)
-		return HUFFERR_INVALID_DATA;
-
-	*actlength = bit_buffer_read_offset(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+	// assign canonical codes for all nodes based on their code lengths
+	return assign_canonical_codes();
 }
 
 
-/*-------------------------------------------------
-    export_tree - export a huffman tree to a
-    target data stream
--------------------------------------------------*/
-
-static huffman_error export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength, UINT32 numcodes)
-{
-	bit_buffer bitbuf;
-	int repcount;
-	int lastval;
-	int numbits;
-	int i;
-
-	/* initialize the output buffer */
-	bit_buffer_write_init(&bitbuf, dest, dlength);
-
-	/* bits per entry depends on the maxbits */
-	if (context->maxbits >= 16)
-		numbits = 5;
-	else if (context->maxbits >= 8)
-		numbits = 4;
-	else
-		numbits = 3;
 
-	/* RLE encode the lengths */
-	lastval = ~0;
-	repcount = 0;
-	for (i = 0; i < numcodes; i++)
-	{
-		int newval = context->huffnode[i].numbits;
+//**************************************************************************
+//  INTERNAL FUNCTIONS
+//**************************************************************************
 
-		/* if we match the previous value, just bump the repcount */
-		if (newval == lastval)
-			repcount++;
+//-------------------------------------------------
+//  write_rle_tree_bits - write an RLE encoded
+//  set of data to a target stream
+//-------------------------------------------------
 
-		/* otherwise, we need to flush the previous repeats */
-		else
-		{
-			if (repcount != 0)
-				write_rle_tree_bits(&bitbuf, lastval, repcount, numbits);
-			lastval = newval;
-			repcount = 1;
-		}
-	}
-
-	/* flush the last value */
-	write_rle_tree_bits(&bitbuf, lastval, repcount, numbits);
-	*actlength = bit_buffer_flush(&bitbuf);
-	return bitbuf.overflow ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    write_rle_tree_bits - write an RLE encoded
-    set of data to a target stream
--------------------------------------------------*/
-
-static void write_rle_tree_bits(bit_buffer *bitbuf, int value, int repcount, int numbits)
+void huffman_context_base::write_rle_tree_bits(bitstream_out &bitbuf, int value, int repcount, int numbits)
 {
-	/* loop until we have output all of the repeats */
+	// loop until we have output all of the repeats
 	while (repcount > 0)
 	{
-		/* if we have a 1, write it twice as it is an escape code */
+		// if we have a 1, write it twice as it is an escape code
 		if (value == 1)
 		{
-			bit_buffer_write(bitbuf, 1, numbits);
-			bit_buffer_write(bitbuf, 1, numbits);
+			bitbuf.write(1, numbits);
+			bitbuf.write(1, numbits);
 			repcount--;
 		}
 
-		/* if we have two or fewer in a row, write them raw */
+		// if we have two or fewer in a row, write them raw
 		else if (repcount <= 2)
 		{
-			bit_buffer_write(bitbuf, value, numbits);
+			bitbuf.write(value, numbits);
 			repcount--;
 		}
 
-		/* otherwise, write a triple using 1 as the escape code */
+		// otherwise, write a triple using 1 as the escape code
 		else
 		{
 			int cur_reps = MIN(repcount - 3, (1 << numbits) - 1);
-			bit_buffer_write(bitbuf, 1, numbits);
-			bit_buffer_write(bitbuf, value, numbits);
-			bit_buffer_write(bitbuf, cur_reps, numbits);
+			bitbuf.write(1, numbits);
+			bitbuf.write(value, numbits);
+			bitbuf.write(cur_reps, numbits);
 			repcount -= cur_reps + 3;
 		}
 	}
 }
 
 
-/*-------------------------------------------------
-    tree_node_compare - compare two tree nodes
-    by weight
--------------------------------------------------*/
+//-------------------------------------------------
+//  tree_node_compare - compare two tree nodes
+//  by weight
+//-------------------------------------------------
 
-static int CLIB_DECL tree_node_compare(const void *item1, const void *item2)
+int CLIB_DECL huffman_context_base::tree_node_compare(const void *item1, const void *item2)
 {
-	const huffman_node *node1 = *(const huffman_node **)item1;
-	const huffman_node *node2 = *(const huffman_node **)item2;
-	return node2->weight - node1->weight;
-}
-
-
-/*-------------------------------------------------
-    compute_optimal_tree - common backend for
-    computing a tree based on the data histogram
--------------------------------------------------*/
-
-static huffman_error compute_optimal_tree(huffman_context *context, const UINT32 *datahisto, UINT32 numcodes)
-{
-	UINT32 lowerweight, upperweight;
-	UINT32 sdatacount;
-	int i;
-
-	/* compute the number of data items in the histogram */
-	sdatacount = 0;
-	for (i = 0; i < numcodes; i++)
-		sdatacount += datahisto[i];
-
-	/* binary search to achieve the optimum encoding */
-	lowerweight = 0;
-	upperweight = sdatacount * 2;
-	while (TRUE)
-	{
-		UINT32 curweight = (upperweight + lowerweight) / 2;
-		int curmaxbits;
-
-		/* build a tree using the current weight */
-		curmaxbits = huffman_build_tree(context, datahisto, sdatacount, curweight, numcodes);
-
-		/* apply binary search here */
-		if (curmaxbits <= context->maxbits)
-		{
-			lowerweight = curweight;
-
-			/* early out if it worked with the raw weights, or if we're done searching */
-			if (curweight == sdatacount || (upperweight - lowerweight) <= 1)
-				break;
-		}
-		else
-			upperweight = curweight;
-	}
-
-	/* assign canonical codes for all nodes based on their code lengths */
-	return assign_canonical_codes(context, numcodes);
+	const node_t *node1 = *(const node_t **)item1;
+	const node_t *node2 = *(const node_t **)item2;
+	return node2->m_weight - node1->m_weight;
 }
 
 
-/*-------------------------------------------------
-    huffman_build_tree - build a huffman tree
-    based on the data distribution
--------------------------------------------------*/
+//-------------------------------------------------
+//  build_tree - build a huffman tree based on the
+//  data distribution
+//-------------------------------------------------
 
-static int huffman_build_tree(huffman_context *context, const UINT32 *datahisto, UINT32 totaldata, UINT32 totalweight, UINT32 numcodes)
+int huffman_context_base::build_tree(UINT32 totaldata, UINT32 totalweight)
 {
-	huffman_node *list[MAX_HUFFMAN_CODES];
-	int listitems;
-	int nextalloc;
-	int maxbits;
-	int i;
-
-	/* make a list of all non-zero nodes */
-	listitems = 0;
-	memset(context->huffnode, 0, numcodes * sizeof(context->huffnode[0]));
-	for (i = 0; i < numcodes; i++)
-		if (datahisto[i] != 0)
+	// make a list of all non-zero nodes
+	dynamic_array<node_t *> list(m_numcodes * 2);
+	int listitems = 0;
+	memset(m_huffnode, 0, m_numcodes * sizeof(m_huffnode[0]));
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
+		if (m_datahisto[curcode] != 0)
 		{
-			list[listitems++] = &context->huffnode[i];
-			context->huffnode[i].count = datahisto[i];
+			list[listitems++] = &m_huffnode[curcode];
+			m_huffnode[curcode].m_count = m_datahisto[curcode];
 
-			/* scale the weight by the current effective length, ensuring we don't go to 0 */
-			context->huffnode[i].weight = (UINT64)datahisto[i] * (UINT64)totalweight / (UINT64)totaldata;
-			if (context->huffnode[i].weight == 0)
-				context->huffnode[i].weight = 1;
+			// scale the weight by the current effective length, ensuring we don't go to 0
+			m_huffnode[curcode].m_weight = UINT64(m_datahisto[curcode]) * UINT64(totalweight) / UINT64(totaldata);
+			if (m_huffnode[curcode].m_weight == 0)
+				m_huffnode[curcode].m_weight = 1;
 		}
 
-	/* sort the list by weight, largest weight first */
+	// sort the list by weight, largest weight first
 	qsort(list, listitems, sizeof(list[0]), tree_node_compare);
 
-	/* now build the tree */
-	nextalloc = MAX_HUFFMAN_CODES;
+	// now build the tree
+	int nextalloc = m_numcodes;
 	while (listitems > 1)
 	{
-		huffman_node *node0, *node1, *newnode;
-
-		/* remove lowest two items */
-		node1 = list[--listitems];
-		node0 = list[--listitems];
-
-		/* create new node */
-		newnode = &context->huffnode[nextalloc++];
-		newnode->parent = NULL;
-		node0->parent = node1->parent = newnode;
-		newnode->weight = node0->weight + node1->weight;
-
-		/* insert into list at appropriate location */
-		for (i = 0; i < listitems; i++)
-			if (newnode->weight > list[i]->weight)
+		// remove lowest two items
+		node_t &node1 = *list[--listitems];
+		node_t &node0 = *list[--listitems];
+
+		// create new node
+		node_t &newnode = m_huffnode[nextalloc++];
+		newnode.m_parent = NULL;
+		node0.m_parent = node1.m_parent = &newnode;
+		newnode.m_weight = node0.m_weight + node1.m_weight;
+
+		// insert into list at appropriate location
+		int curitem;
+		for (curitem = 0; curitem < listitems; curitem++)
+			if (newnode.m_weight > list[curitem]->m_weight)
 			{
-				memmove(&list[i+1], &list[i], (listitems - i) * sizeof(list[0]));
+				memmove(&list[curitem+1], &list[curitem], (listitems - curitem) * sizeof(list[0]));
 				break;
 			}
-		list[i] = newnode;
+		list[curitem] = &newnode;
 		listitems++;
 	}
 
-	/* compute the number of bits in each code, and fill in another histogram */
-	maxbits = 0;
-	for (i = 0; i < numcodes; i++)
-	{
-		huffman_node *node = &context->huffnode[i];
-		node->numbits = 0;
+	// compute the number of bits in each code, and fill in another histogram
+	int maxbits = 0;
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
+	{
+		node_t &node = m_huffnode[curcode];
+		node.m_numbits = 0;
+
+		// if we have a non-zero weight, compute the number of bits
+		if (node.m_weight > 0)
+		{
+			// determine the number of bits for this node
+			for (node_t *curnode = &node; curnode->m_parent != NULL; curnode = curnode->m_parent)
+				node.m_numbits++;
+			if (node.m_numbits == 0)
+				node.m_numbits = 1;
 
-		/* if we have a non-zero weight, compute the number of bits */
-		if (node->weight > 0)
-		{
-			huffman_node *curnode;
-
-			/* determine the number of bits for this node */
-			for (curnode = node; curnode->parent != NULL; curnode = curnode->parent)
-				node->numbits++;
-			if (node->numbits == 0)
-				node->numbits = 1;
-
-			/* keep track of the max */
-			maxbits = MAX(maxbits, node->numbits);
+			// keep track of the max
+			maxbits = MAX(maxbits, node.m_numbits);
 		}
 	}
-
 	return maxbits;
 }
 
 
-/*-------------------------------------------------
-    assign_canonical_codes - assign
-    canonical codes to all the nodes based on the
-    number of bits in each
--------------------------------------------------*/
-
-static huffman_error assign_canonical_codes(huffman_context *context, UINT32 numcodes)
-{
-	UINT32 bithisto[33];
-	int curstart;
-	int i;
-
-	/* build up a histogram of bit lengths */
-	memset(bithisto, 0, sizeof(bithisto));
-	for (i = 0; i < numcodes; i++)
+//-------------------------------------------------
+//  assign_canonical_codes - assign canonical codes
+//  to all the nodes based on the number of bits
+//  in each
+//-------------------------------------------------
+
+huffman_error huffman_context_base::assign_canonical_codes()
+{
+	// build up a histogram of bit lengths
+	UINT32 bithisto[33] = { 0 };
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
 	{
-		huffman_node *node = &context->huffnode[i];
-		if (node->numbits > context->maxbits)
+		node_t &node = m_huffnode[curcode];
+		if (node.m_numbits > m_maxbits)
 			return HUFFERR_INTERNAL_INCONSISTENCY;
-		if (node->numbits <= 32)
-			bithisto[node->numbits]++;
+		if (node.m_numbits <= 32)
+			bithisto[node.m_numbits]++;
 	}
 
-	/* for each code length, determine the starting code number */
-	curstart = 0;
-	for (i = 32; i > 0; i--)
+	// for each code length, determine the starting code number
+	UINT32 curstart = 0;
+	for (int codelen = 32; codelen > 0; codelen--)
 	{
-		UINT32 nextstart = (curstart + bithisto[i]) >> 1;
-		if (i != 1 && nextstart * 2 != (curstart + bithisto[i]))
+		UINT32 nextstart = (curstart + bithisto[codelen]) >> 1;
+		if (codelen != 1 && nextstart * 2 != (curstart + bithisto[codelen]))
 			return HUFFERR_INTERNAL_INCONSISTENCY;
-		bithisto[i] = curstart;
+		bithisto[codelen] = curstart;
 		curstart = nextstart;
 	}
 
-	/* now assign canonical codes */
-	for (i = 0; i < numcodes; i++)
+	// now assign canonical codes
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
 	{
-		huffman_node *node = &context->huffnode[i];
-		if (node->numbits > 0)
-			node->bits = bithisto[node->numbits]++;
+		node_t &node = m_huffnode[curcode];
+		if (node.m_numbits > 0)
+			node.m_bits = bithisto[node.m_numbits]++;
 	}
-
-	/* if there was a decoding table, get rid of it now */
-	context->lookupdirty = TRUE;
 	return HUFFERR_NONE;
 }
 
 
-/*-------------------------------------------------
-    build_lookup_table - build a lookup
-    table for fast decoding
--------------------------------------------------*/
+//-------------------------------------------------
+//  build_lookup_table - build a lookup table for
+//  fast decoding
+//-------------------------------------------------
+
+void huffman_context_base::build_lookup_table()
+{
+	// iterate over all codes
+	for (int curcode = 0; curcode < m_numcodes; curcode++)
+	{
+		// process all nodes which have non-zero bits
+		node_t &node = m_huffnode[curcode];
+		if (node.m_numbits > 0)
+		{
+			// set up the entry
+			lookup_value value = MAKE_LOOKUP(curcode, node.m_numbits);
+
+			// fill all matching entries
+			int shift = m_maxbits - node.m_numbits;
+			lookup_value *dest = &m_lookup[node.m_bits << shift];
+			lookup_value *destend = &m_lookup[((node.m_bits + 1) << shift) - 1];
+			while (dest <= destend)
+				*dest++ = value;
+		}
+	}
+}
+
+
+
+//**************************************************************************
+//  8-BIT ENCODER
+//**************************************************************************
 
-static huffman_error build_lookup_table(huffman_context *context, UINT32 numcodes)
+//-------------------------------------------------
+//  huffman_8bit_encoder - constructor
+//-------------------------------------------------
+
+huffman_8bit_encoder::huffman_8bit_encoder()
 {
-	int i;
+}
 
-	/* allocate a table if needed */
-	if (context->lookup == NULL)
-		context->lookup = (huffman_lookup_value *)malloc((UINT32)sizeof(context->lookup[0]) * (UINT32)(1 << context->maxbits));
-	if (context->lookup == NULL)
-		return HUFFERR_OUT_OF_MEMORY;
 
-	/* now build */
-	for (i = 0; i < numcodes; i++)
-	{
-		huffman_node *node = &context->huffnode[i];
-		if (node->numbits > 0)
-		{
-			huffman_lookup_value *dest, *destend;
+//-------------------------------------------------
+//  encode - encode a full buffer
+//-------------------------------------------------
 
-			/* left justify this node's bit values to max bits */
-			int shift = context->maxbits - node->numbits;
-			UINT32 start = node->bits << shift;
-			UINT32 end = ((node->bits + 1) << shift) - 1;
-			huffman_lookup_value value;
-
-			/* set up the entry */
-			value = (i << 6) | node->numbits;
-
-			/* fill all matching entries */
-			dest = &context->lookup[start];
-			destend = &context->lookup[end];
-			while (dest <= destend)
-				*dest++ = value;
-		}
-	}
+huffman_error huffman_8bit_encoder::encode(const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dlength, UINT32 &complength)
+{
+	// first compute the histogram
+	histo_reset();
+	for (UINT32 cur = 0; cur < slength; cur++)
+		histo_one(source[cur]);
 
-	/* no longer dirty */
-	context->lookupdirty = FALSE;
-	return HUFFERR_NONE;
+	// then compute the tree
+	huffman_error err = compute_tree_from_histo();
+	if (err != HUFFERR_NONE)
+		return err;
+
+	// export the tree
+	bitstream_out bitbuf(dest, dlength);
+	err = export_tree_huffman(bitbuf);
+	if (err != HUFFERR_NONE)
+		return err;
+
+	// then encode the data
+	for (UINT32 cur = 0; cur < slength; cur++)
+		encode_one(bitbuf, source[cur]);
+	complength = bitbuf.flush();
+	return bitbuf.overflow() ? HUFFERR_OUTPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
+}
+
+
+
+//**************************************************************************
+//  8-BIT DECODER
+//**************************************************************************
+
+//-------------------------------------------------
+//  huffman_8bit_decoder - constructor
+//-------------------------------------------------
+
+huffman_8bit_decoder::huffman_8bit_decoder()
+{
+}
+
+
+//-------------------------------------------------
+//  decode - decode a full buffer
+//-------------------------------------------------
+
+huffman_error huffman_8bit_decoder::decode(const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dlength)
+{
+	// first import the tree
+	bitstream_in bitbuf(source, slength);
+	huffman_error err = import_tree_huffman(bitbuf);
+	if (err != HUFFERR_NONE)
+		return err;
+
+	// then decode the data
+	for (UINT32 cur = 0; cur < dlength; cur++)
+		dest[cur] = decode_one(bitbuf);
+	bitbuf.flush();
+	return bitbuf.overflow() ? HUFFERR_INPUT_BUFFER_TOO_SMALL : HUFFERR_NONE;
 }
diff -Nru src-old/lib/util/huffman.h src/lib/util/huffman.h
--- src-old/lib/util/huffman.h	2009-10-12 09:45:25.000000000 +0200
+++ src/lib/util/huffman.h	2012-02-19 16:23:23.000000000 +0100
@@ -2,7 +2,7 @@
 
     huffman.h
 
-    Huffman compression routines.
+    Static Huffman compression and decompression helpers.
 
 ****************************************************************************
 
@@ -37,19 +37,22 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __HUFFMAN_H__
+#define __HUFFMAN_H__
 
 #include "osdcore.h"
+#include "bitstream.h"
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-enum _huffman_error
+enum huffman_error
 {
 	HUFFERR_NONE = 0,
-	HUFFERR_OUT_OF_MEMORY,
 	HUFFERR_TOO_MANY_BITS,
 	HUFFERR_INVALID_DATA,
 	HUFFERR_INPUT_BUFFER_TOO_SMALL,
@@ -57,45 +60,193 @@
 	HUFFERR_INTERNAL_INCONSISTENCY,
 	HUFFERR_TOO_MANY_CONTEXTS
 };
-typedef enum _huffman_error huffman_error;
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> huffman_context_base
+
+// base class for encoding and decoding
+class huffman_context_base
+{
+protected:
+	typedef UINT16 lookup_value;
 
-typedef UINT16 huffman_lookup_value;
+	// a node in the huffman tree
+	struct node_t
+	{
+		node_t *			m_parent;				// pointer to parent node
+		UINT32				m_count;				// number of hits on this node
+		UINT32				m_weight;				// assigned weight of this node
+		UINT32				m_bits;					// bits used to encode the node
+		UINT8				m_numbits;				// number of bits needed for this node
+	};
+
+	// construction/destruction
+	huffman_context_base(int numcodes, int maxbits, lookup_value *lookup, UINT32 *histo, node_t *nodes);
+
+	// tree creation
+	huffman_error compute_tree_from_histo();
+
+	// static tree import; huffman is notably more efficient
+	huffman_error import_tree_rle(bitstream_in &bitbuf);
+	huffman_error import_tree_huffman(bitstream_in &bitbuf);
+
+	// static tree export
+	huffman_error export_tree_rle(bitstream_out &bitbuf);
+	huffman_error export_tree_huffman(bitstream_out &bitbuf);
+
+	// internal helpers
+	void write_rle_tree_bits(bitstream_out &bitbuf, int value, int repcount, int numbits);
+	static int CLIB_DECL tree_node_compare(const void *item1, const void *item2);
+	int build_tree(UINT32 totaldata, UINT32 totalweight);
+	huffman_error assign_canonical_codes();
+	void build_lookup_table();
+
+protected:
+	// internal state
+	UINT32					m_numcodes;				// number of total codes being processed
+	UINT8					m_maxbits;				// maximum bits per code
+	UINT8					m_prevdata;				// value of the previous data (for delta-RLE encoding)
+	int						m_rleremaining;			// number of RLE bytes remaining (for delta-RLE encoding)
+	lookup_value *			m_lookup;				// pointer to the lookup table
+	UINT32 *				m_datahisto;			// histogram of data values
+	node_t *				m_huffnode;				// array of nodes
+};
 
-typedef struct _huffman_context huffman_context;
 
+// ======================> huffman_encoder
 
+// template class for encoding
+template<int _NumCodes = 256, int _MaxBits = 16>
+class huffman_encoder : public huffman_context_base
+{
+public:
+	// pass through to the underlying constructor
+	huffman_encoder()
+		: huffman_context_base(_NumCodes, _MaxBits, NULL, m_datahisto_array, m_huffnode_array) { histo_reset(); }
+
+	// single item operations
+	void histo_reset() { memset(m_datahisto_array, 0, sizeof(m_datahisto_array)); }
+	void histo_one(UINT32 data);
+	void encode_one(bitstream_out &bitbuf, UINT32 data);
+
+	// expose tree computation and export
+	using huffman_context_base::compute_tree_from_histo;
+	using huffman_context_base::export_tree_rle;
+	using huffman_context_base::export_tree_huffman;
+
+private:
+	// array versions of the info we need
+	UINT32					m_datahisto_array[_NumCodes];
+	node_t					m_huffnode_array[_NumCodes * 2];
+};
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
 
-huffman_error huffman_create_context(huffman_context **context, int maxbits);
-void huffman_free_context(huffman_context *context);
+// ======================> huffman_decoder
+
+// template class for decoding
+template<int _NumCodes = 256, int _MaxBits = 16>
+class huffman_decoder : public huffman_context_base
+{
+public:
+	// pass through to the underlying constructor
+	huffman_decoder()
+		: huffman_context_base(_NumCodes, _MaxBits, m_lookup_array, NULL, m_huffnode_array) { }
+
+	// single item operations
+	UINT32 decode_one(bitstream_in &bitbuf);
+
+	// expose tree import
+	using huffman_context_base::import_tree_rle;
+	using huffman_context_base::import_tree_huffman;
+
+private:
+	// array versions of the info we need
+	node_t					m_huffnode_array[_NumCodes];
+	lookup_value			m_lookup_array[1 << _MaxBits];
+};
+
+
+// ======================> huffman_8bit_encoder
+
+// generic 8-bit encoder/decoder
+class huffman_8bit_encoder : public huffman_encoder<>
+{
+public:
+	// construction/destruction
+	huffman_8bit_encoder();
+
+	// operations
+	huffman_error encode(const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 destlength, UINT32 &complength);
+};
+
+
+// ======================> huffman_8bit_decoder
+
+// generic 8-bit encoder/decoder
+class huffman_8bit_decoder : public huffman_decoder<>
+{
+public:
+	// construction/destruction
+	huffman_8bit_decoder();
+
+	// operations
+	huffman_error decode(const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 destlength);
+};
+
+
+
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  histo_one - update the histogram
+//-------------------------------------------------
+
+template<int _NumCodes, int _MaxBits>
+inline void huffman_encoder<_NumCodes, _MaxBits>::histo_one(UINT32 data)
+{
+	m_datahisto[data]++;
+}
+
+
+//-------------------------------------------------
+//  encode_one - encode a single code to the
+//  huffman stream
+//-------------------------------------------------
+
+template<int _NumCodes, int _MaxBits>
+inline void huffman_encoder<_NumCodes, _MaxBits>::encode_one(bitstream_out &bitbuf, UINT32 data)
+{
+	// write the data
+	node_t &node = m_huffnode[data];
+	bitbuf.write(node.m_bits, node.m_numbits);
+}
+
+
+//-------------------------------------------------
+//  decode_one - decode a single code from the
+//  huffman stream
+//-------------------------------------------------
+
+template<int _NumCodes, int _MaxBits>
+inline UINT32 huffman_decoder<_NumCodes, _MaxBits>::decode_one(bitstream_in &bitbuf)
+{
+	// peek ahead to get maxbits worth of data
+	UINT32 bits = bitbuf.peek(m_maxbits);
+
+	// look it up, then remove the actual number of bits for this code
+	lookup_value lookup = m_lookup[bits];
+	bitbuf.remove(lookup & 0x1f);
+
+	// return the value
+	return lookup >> 5;
+}
 
-huffman_error huffman_import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength);
-huffman_error huffman_export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-huffman_error huffman_deltarle_import_tree(huffman_context *context, const UINT8 *source, UINT32 slength, UINT32 *actlength);
-huffman_error huffman_deltarle_export_tree(huffman_context *context, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-
-huffman_error huffman_compute_tree(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor);
-huffman_error huffman_compute_tree_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor);
-huffman_error huffman_deltarle_compute_tree(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor);
-huffman_error huffman_deltarle_compute_tree_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor);
-
-huffman_error huffman_encode_data(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-huffman_error huffman_encode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-huffman_error huffman_deltarle_encode_data(huffman_context *context, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-huffman_error huffman_deltarle_encode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 swidth, UINT32 sheight, UINT32 sstride, UINT32 sxor, UINT8 *dest, UINT32 dlength, UINT32 *actlength);
-
-huffman_error huffman_decode_data(huffman_context *context, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength);
-huffman_error huffman_decode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength);
-huffman_error huffman_deltarle_decode_data(huffman_context *context, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength);
-huffman_error huffman_deltarle_decode_data_interleaved(int numcontexts, huffman_context **contexts, const UINT8 *source, UINT32 slength, UINT8 *dest, UINT32 dwidth, UINT32 dheight, UINT32 dstride, UINT32 dxor, UINT32 *actlength);
 
 #endif
diff -Nru src-old/lib/util/tagmap.h src/lib/util/tagmap.h
--- src-old/lib/util/tagmap.h	2012-01-29 17:34:26.000000000 +0100
+++ src/lib/util/tagmap.h	2012-02-16 10:47:18.000000000 +0100
@@ -158,7 +158,7 @@
 		for (entry_t *entry = m_table[fullhash % ARRAY_LENGTH(m_table)]; entry != NULL; entry = entry->next())
 			if (entry->fullhash() == fullhash && entry->tag() == tag)
 				return entry->object();
-		return (_ElementType)NULL;
+		return _ElementType(NULL);
 	}
 
 	// find by tag without checking anything but the hash
diff -Nru src-old/lib/util/un7z.c src/lib/util/un7z.c
--- src-old/lib/util/un7z.c	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/un7z.c	2012-02-19 16:23:23.000000000 +0100
@@ -0,0 +1,519 @@
+/***************************************************************************
+
+    un7z.c
+
+    Functions to manipulate data within 7z files.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+// this is based on unzip.c, with modifications needed to use the 7zip library
+
+#include "osdcore.h"
+#include "un7z.h"
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <zlib.h>
+
+/***************************************************************************
+    7Zip Memory / File handling (adapted from 7zfile.c/.h and 7zalloc.c/.h)
+***************************************************************************/
+
+void *SZipAlloc(void *p, size_t size)
+{
+	p = p;
+	if (size == 0)
+		return 0;
+
+	return malloc(size);
+}
+
+void SZipFree(void *p, void *address)
+{
+	p = p;
+	free(address);
+}
+
+
+
+void File_Construct(CSzFile *p)
+{
+	p->_7z_osdfile = NULL;
+}
+
+static WRes File_Open(CSzFile *p, const char *name, int writeMode)
+{
+	/* we handle this ourselves ... */
+	if (!p->_7z_osdfile) return 1;
+	else return 0;
+}
+
+WRes InFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 0); }
+WRes OutFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 1); }
+
+
+WRes File_Close(CSzFile *p)
+{
+	/* we handle this ourselves ... */
+	return 0;
+}
+
+WRes File_Read(CSzFile *p, void *data, size_t *size)
+{
+//  file_error err;
+	UINT32 read_length;
+
+	if (!p->_7z_osdfile)
+	{
+		printf("un7z.c: called File_Read without file\n");
+		return 1;
+	}
+
+	size_t originalSize = *size;
+	if (originalSize == 0)
+		return 0;
+
+//  err =
+    osd_read( p->_7z_osdfile, data, p->_7z_currfpos, originalSize, &read_length );
+	*size = read_length;
+	p->_7z_currfpos += read_length;
+
+	if (*size == originalSize)
+		return 0;
+
+	return 0;
+}
+
+WRes File_Write(CSzFile *p, const void *data, size_t *size)
+{
+	return 0;
+}
+
+WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin)
+{
+	if (origin==0) p->_7z_currfpos = *pos;
+	if (origin==1) p->_7z_currfpos = p->_7z_currfpos + *pos;
+	if (origin==2) p->_7z_currfpos = p->_7z_length - *pos;
+
+	*pos = p->_7z_currfpos;
+
+	return 0;
+}
+
+WRes File_GetLength(CSzFile *p, UInt64 *length)
+{
+	*length = p->_7z_length;
+	return 0;
+}
+
+/* ---------- FileSeqInStream ---------- */
+
+static SRes FileSeqInStream_Read(void *pp, void *buf, size_t *size)
+{
+  CFileSeqInStream *p = (CFileSeqInStream *)pp;
+  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
+}
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p)
+{
+  p->s.Read = FileSeqInStream_Read;
+}
+
+
+/* ---------- FileInStream ---------- */
+
+static SRes FileInStream_Read(void *pp, void *buf, size_t *size)
+{
+	CFileInStream *p = (CFileInStream *)pp;
+	return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;
+}
+
+static SRes FileInStream_Seek(void *pp, Int64 *pos, ESzSeek origin)
+{
+	CFileInStream *p = (CFileInStream *)pp;
+	return File_Seek(&p->file, pos, origin);
+}
+
+void FileInStream_CreateVTable(CFileInStream *p)
+{
+	p->s.Read = FileInStream_Read;
+	p->s.Seek = FileInStream_Seek;
+}
+
+/* ---------- FileOutStream ---------- */
+
+static size_t FileOutStream_Write(void *pp, const void *data, size_t size)
+{
+  CFileOutStream *p = (CFileOutStream *)pp;
+  File_Write(&p->file, data, &size);
+  return size;
+}
+
+void FileOutStream_CreateVTable(CFileOutStream *p)
+{
+  p->s.Write = FileOutStream_Write;
+}
+
+/***************************************************************************
+    CONSTANTS
+***************************************************************************/
+
+/* number of open files to cache */
+#define _7Z_CACHE_SIZE	8
+
+
+/***************************************************************************
+    GLOBAL VARIABLES
+***************************************************************************/
+
+static _7z_file *_7z_cache[_7Z_CACHE_SIZE];
+
+/***************************************************************************
+    FUNCTION PROTOTYPES
+***************************************************************************/
+
+/* cache management */
+static void free__7z_file(_7z_file *_7z);
+
+
+/***************************************************************************
+    _7Z FILE ACCESS
+***************************************************************************/
+
+/*-------------------------------------------------
+    _7z_file_open - opens a _7Z file for reading
+-------------------------------------------------*/
+
+int _7z_search_crc_match(_7z_file *new_7z, UINT32 search_crc, const char* search_filename, int search_filename_length, bool matchcrc, bool matchname)
+{
+	UInt16 *temp = NULL;
+	size_t tempSize = 0;
+
+	for (int i = 0; i < new_7z->db.db.NumFiles; i++)
+	{
+		const CSzFileItem *f = new_7z->db.db.Files + i;
+		size_t len;
+
+		len = SzArEx_GetFileNameUtf16(&new_7z->db, i, NULL);
+
+		// if it's a directory entry we don't care about it..
+		if (f->IsDir)
+			continue;
+
+		if (len > tempSize)
+		{
+			SZipFree(NULL, temp);
+			tempSize = len;
+			temp = (UInt16 *)SZipAlloc(NULL, tempSize * sizeof(temp[0]));
+			if (temp == 0)
+			{
+				return -1; // memory error
+			}
+		}
+
+		bool crcmatch = false;
+		bool namematch = false;
+
+		UINT64 size = f->Size;
+		UINT32 crc = f->Crc;
+
+		/* Check for a name match */
+		SzArEx_GetFileNameUtf16(&new_7z->db, i, temp);
+
+		if (len == search_filename_length+1)
+		{
+			int j;
+			for (j=0;j<search_filename_length;j++)
+			{
+				UINT8 sn = search_filename[j];
+				UINT16 zn = temp[j]; // these are utf16
+
+				// MAME filenames are always lowercase so be case insensitive
+				if ((zn>=0x41) && (zn<=0x5a)) zn+=0x20;
+
+				if (sn != zn) break;
+			}
+			if (j==search_filename_length) namematch = true;
+		}
+
+
+		/* Check for a CRC match */
+		if (crc==search_crc) crcmatch = true;
+
+		bool found = false;
+
+		if (matchcrc && matchname)
+		{
+			if (crcmatch && namematch)
+				found = true;
+		}
+		else if (matchcrc)
+		{
+			if (crcmatch)
+				found = true;
+		}
+		else if (matchname)
+		{
+			if (namematch)
+				found = true;
+		}
+
+		if (found)
+		{
+		//  printf("found %S %d %08x %08x %08x %s %d\n", temp, len, crc, search_crc, size, search_filename, search_filename_length);
+			new_7z->curr_file_idx = i;
+			new_7z->uncompressed_length = size;
+			new_7z->crc = crc;
+
+			SZipFree(NULL, temp);
+			return i;
+		}
+	}
+
+	SZipFree(NULL, temp);
+	return -1;
+}
+
+
+_7z_error _7z_file_open(const char *filename, _7z_file **_7z)
+{
+	file_error err;
+	_7z_error _7zerr = _7ZERR_NONE;
+
+
+	_7z_file *new_7z;
+	char *string;
+	int cachenum;
+
+	SRes res;
+
+	/* ensure we start with a NULL result */
+	*_7z = NULL;
+
+	/* see if we are in the cache, and reopen if so */
+	for (cachenum = 0; cachenum < ARRAY_LENGTH(_7z_cache); cachenum++)
+	{
+		_7z_file *cached = _7z_cache[cachenum];
+
+		/* if we have a valid entry and it matches our filename, use it and remove from the cache */
+		if (cached != NULL && cached->filename != NULL && strcmp(filename, cached->filename) == 0)
+		{
+			*_7z = cached;
+			_7z_cache[cachenum] = NULL;
+			return _7ZERR_NONE;
+		}
+	}
+
+	/* allocate memory for the _7z_file structure */
+	new_7z = (_7z_file *)malloc(sizeof(*new_7z));
+	if (new_7z == NULL)
+		return _7ZERR_OUT_OF_MEMORY;
+	memset(new_7z, 0, sizeof(*new_7z));
+
+	new_7z->inited = false;
+	new_7z->archiveStream.file._7z_currfpos = 0;
+	err = osd_open(filename, OPEN_FLAG_READ, &new_7z->archiveStream.file._7z_osdfile, &new_7z->archiveStream.file._7z_length);
+	if (err != FILERR_NONE)
+	{
+		_7zerr = _7ZERR_FILE_ERROR;
+		goto error;
+	}
+
+	new_7z->allocImp.Alloc = SZipAlloc;
+	new_7z->allocImp.Free = SZipFree;
+
+	new_7z->allocTempImp.Alloc = SZipAlloc;
+	new_7z->allocTempImp.Free = SZipFree;
+
+	if (InFile_Open(&new_7z->archiveStream.file, filename))
+	{
+		_7zerr = _7ZERR_FILE_ERROR;
+		goto error;
+	}
+
+	FileInStream_CreateVTable(&new_7z->archiveStream);
+	LookToRead_CreateVTable(&new_7z->lookStream, False);
+
+	new_7z->lookStream.realStream = &new_7z->archiveStream.s;
+	LookToRead_Init(&new_7z->lookStream);
+
+	CrcGenerateTable();
+
+	SzArEx_Init(&new_7z->db);
+	new_7z->inited = true;
+
+	res = SzArEx_Open(&new_7z->db, &new_7z->lookStream.s, &new_7z->allocImp, &new_7z->allocTempImp);
+	if (res != SZ_OK)
+	{
+		_7zerr = _7ZERR_FILE_ERROR;
+		goto error;
+	}
+
+	new_7z->blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+	new_7z->outBuffer = 0; /* it must be 0 before first call for each new archive. */
+	new_7z->outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
+
+	/* make a copy of the filename for caching purposes */
+	string = (char *)malloc(strlen(filename) + 1);
+	if (string == NULL)
+	{
+		_7zerr = _7ZERR_OUT_OF_MEMORY;
+		goto error;
+	}
+	strcpy(string, filename);
+	new_7z->filename = string;
+	*_7z = new_7z;
+	return _7ZERR_NONE;
+
+error:
+	free__7z_file(new_7z);
+	return _7zerr;
+}
+
+
+/*-------------------------------------------------
+    _7z_file_close - close a _7Z file and add it
+    to the cache
+-------------------------------------------------*/
+
+void _7z_file_close(_7z_file *_7z)
+{
+	int cachenum;
+
+	/* close the open files */
+	if (_7z->archiveStream.file._7z_osdfile != NULL)
+		osd_close(_7z->archiveStream.file._7z_osdfile);
+	_7z->archiveStream.file._7z_osdfile = NULL;
+
+	/* find the first NULL entry in the cache */
+	for (cachenum = 0; cachenum < ARRAY_LENGTH(_7z_cache); cachenum++)
+		if (_7z_cache[cachenum] == NULL)
+			break;
+
+	/* if no room left in the cache, free the bottommost entry */
+	if (cachenum == ARRAY_LENGTH(_7z_cache))
+		free__7z_file(_7z_cache[--cachenum]);
+
+	/* move everyone else down and place us at the top */
+	if (cachenum != 0)
+		memmove(&_7z_cache[1], &_7z_cache[0], cachenum * sizeof(_7z_cache[0]));
+	_7z_cache[0] = _7z;
+}
+
+
+/*-------------------------------------------------
+    _7z_file_cache_clear - clear the _7Z file
+    cache and free all memory
+-------------------------------------------------*/
+
+void _7z_file_cache_clear(void)
+{
+	int cachenum;
+
+	/* clear call cache entries */
+	for (cachenum = 0; cachenum < ARRAY_LENGTH(_7z_cache); cachenum++)
+		if (_7z_cache[cachenum] != NULL)
+		{
+			free__7z_file(_7z_cache[cachenum]);
+			_7z_cache[cachenum] = NULL;
+		}
+}
+
+
+/*-------------------------------------------------
+    _7z_file_decompress - decompress a file
+    from a _7Z into the target buffer
+-------------------------------------------------*/
+
+_7z_error _7z_file_decompress(_7z_file *new_7z, void *buffer, UINT32 length)
+{
+	file_error err;
+	SRes res;
+	int index = new_7z->curr_file_idx;
+
+	/* make sure the file is open.. */
+	if (new_7z->archiveStream.file._7z_osdfile==NULL)
+	{
+		new_7z->archiveStream.file._7z_currfpos = 0;
+		err = osd_open(new_7z->filename, OPEN_FLAG_READ, &new_7z->archiveStream.file._7z_osdfile, &new_7z->archiveStream.file._7z_length);
+		if (err != FILERR_NONE)
+			return _7ZERR_FILE_ERROR;
+	}
+
+	size_t offset = 0;
+	size_t outSizeProcessed = 0;
+
+	res = SzArEx_Extract(&new_7z->db, &new_7z->lookStream.s, index,
+		&new_7z->blockIndex, &new_7z->outBuffer, &new_7z->outBufferSize,
+		&offset, &outSizeProcessed,
+		&new_7z->allocImp, &new_7z->allocTempImp);
+
+	if (res != SZ_OK)
+		return _7ZERR_FILE_ERROR;
+
+	memcpy(buffer, new_7z->outBuffer + offset, length);
+
+	return _7ZERR_NONE;
+}
+
+
+
+/***************************************************************************
+    CACHE MANAGEMENT
+***************************************************************************/
+
+/*-------------------------------------------------
+    free__7z_file - free all the data for a
+    _7z_file
+-------------------------------------------------*/
+
+static void free__7z_file(_7z_file *_7z)
+{
+	if (_7z != NULL)
+	{
+		if (_7z->archiveStream.file._7z_osdfile != NULL)
+			osd_close(_7z->archiveStream.file._7z_osdfile);
+		if (_7z->filename != NULL)
+			free((void *)_7z->filename);
+
+
+		if (_7z->outBuffer) IAlloc_Free(&_7z->allocImp, _7z->outBuffer);
+		if (_7z->inited) SzArEx_Free(&_7z->db, &_7z->allocImp);
+
+
+		free(_7z);
+	}
+}
+
+
diff -Nru src-old/lib/util/un7z.h src/lib/util/un7z.h
--- src-old/lib/util/un7z.h	1970-01-01 01:00:00.000000000 +0100
+++ src/lib/util/un7z.h	2012-02-12 18:55:51.000000000 +0100
@@ -0,0 +1,174 @@
+/***************************************************************************
+
+    un7z.h
+
+    7z file management.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+// this is based on unzip.h, with modifications needed to use the 7zip library
+
+#pragma once
+
+#ifndef __UN_7Z_H__
+#define __UN_7Z_H__
+
+#include "osdcore.h"
+
+#include "../lib7z/7z.h"
+#include "../lib7z/7zCrc.h"
+#include "../lib7z/7zVersion.h"
+
+
+void *SZipAlloc(void *p, size_t size);
+void SZipFree(void *p, void *address);
+void *SZipAllocTemp(void *p, size_t size);
+void SZipFreeTemp(void *p, void *address);
+
+typedef struct
+{
+	long _7z_currfpos;
+	UINT64			_7z_length;
+	osd_file *		_7z_osdfile;					/* OSD file handle */
+
+} CSzFile;
+
+
+typedef struct
+{
+	ISeqInStream s;
+	CSzFile file;
+} CFileSeqInStream;
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p);
+
+
+typedef struct
+{
+	ISeekInStream s;
+	CSzFile file;
+} CFileInStream;
+
+void FileInStream_CreateVTable(CFileInStream *p);
+
+
+typedef struct
+{
+	ISeqOutStream s;
+	CSzFile file;
+} CFileOutStream;
+
+void FileOutStream_CreateVTable(CFileOutStream *p);
+
+
+
+/***************************************************************************
+    CONSTANTS
+***************************************************************************/
+
+
+/* Error types */
+enum __7z_error
+{
+	_7ZERR_NONE = 0,
+	_7ZERR_OUT_OF_MEMORY,
+	_7ZERR_FILE_ERROR,
+	_7ZERR_BAD_SIGNATURE,
+	_7ZERR_DECOMPRESS_ERROR,
+	_7ZERR_FILE_TRUNCATED,
+	_7ZERR_FILE_CORRUPT,
+	_7ZERR_UNSUPPORTED,
+	_7ZERR_BUFFER_TOO_SMALL
+};
+typedef enum __7z_error _7z_error;
+
+
+
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+/* describes an open _7Z file */
+typedef struct __7z_file _7z_file;
+struct __7z_file
+{
+	const char *	filename;				/* copy of _7Z filename (for caching) */
+
+	int	curr_file_idx;						/* current file index */
+	UINT64 uncompressed_length;				/* current file uncompressed length */
+	UINT64 crc;								/* current file crc */
+
+	CFileInStream archiveStream;
+	CLookToRead lookStream;
+	CSzArEx db;
+	SRes res;
+	ISzAlloc allocImp;
+	ISzAlloc allocTempImp;
+	bool inited;
+
+	// cached stuff for solid blocks
+	UInt32 blockIndex;// = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+	Byte *outBuffer;// = 0; /* it must be 0 before first call for each new archive. */
+	size_t outBufferSize;// = 0;  /* it can have any value before first call (if outBuffer = 0) */
+};
+
+
+
+/***************************************************************************
+    FUNCTION PROTOTYPES
+***************************************************************************/
+
+
+/* ----- _7Z file access ----- */
+
+/* open a _7Z file and parse its central directory */
+_7z_error _7z_file_open(const char *filename, _7z_file **_7z);
+
+/* close a _7Z file (may actually be left open due to caching) */
+void _7z_file_close(_7z_file *_7z);
+
+/* clear out all open _7Z files from the cache */
+void _7z_file_cache_clear(void);
+
+
+/* ----- contained file access ----- */
+
+/* find a file index by crc, filename or both */
+int _7z_search_crc_match(_7z_file *new_7z, UINT32 crc, const char *search_filename, int search_filename_length, bool matchcrc, bool matchname);
+
+/* decompress the most recently found file in the _7Z */
+_7z_error _7z_file_decompress(_7z_file *_7z, void *buffer, UINT32 length);
+
+
+#endif	/* __UN_7Z_H__ */
diff -Nru src-old/mame/audio/8080bw.c src/mame/audio/8080bw.c
--- src-old/mame/audio/8080bw.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/8080bw.c	2012-02-19 02:53:16.000000000 +0100
@@ -38,10 +38,10 @@
 
 	sn76477_enable_w(state->m_sn, !(data & 0x01));			/* SAUCER SOUND */
 
-	if (rising_bits & 0x02) sample_start(state->m_samples, 0, 0, 0);		/* MISSLE SOUND */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 1, 1, 0);		/* EXPLOSION */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 2, 2, 0);		/* INVADER HIT */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 5, 8, 0);		/* BONUS MISSILE BASE */
+	if (rising_bits & 0x02) state->m_samples->start(0, 0);		/* MISSLE SOUND */
+	if (rising_bits & 0x04) state->m_samples->start(1, 1);		/* EXPLOSION */
+	if (rising_bits & 0x08) state->m_samples->start(2, 2);		/* INVADER HIT */
+	if (rising_bits & 0x10) state->m_samples->start(5, 8);		/* BONUS MISSILE BASE */
 
 	state->m_screen_red = data & 0x04;
 
@@ -63,11 +63,11 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 4, 3, 0);		/* FLEET */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 4, 4, 0);		/* FLEET */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 4, 5, 0);		/* FLEET */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 4, 6, 0);		/* FLEET */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 3, 7, 0);		/* SAUCER HIT */
+	if (rising_bits & 0x01) state->m_samples->start(4, 3);		/* FLEET */
+	if (rising_bits & 0x02) state->m_samples->start(4, 4);		/* FLEET */
+	if (rising_bits & 0x04) state->m_samples->start(4, 5);		/* FLEET */
+	if (rising_bits & 0x08) state->m_samples->start(4, 6);		/* FLEET */
+	if (rising_bits & 0x10) state->m_samples->start(3, 7);		/* SAUCER HIT */
 
 	state->m_c8080bw_flip_screen = data & 0x20;
 
@@ -88,9 +88,9 @@
 
 	sn76477_enable_w(state->m_sn, !(data & 0x01));			/* Saucer Sound */
 
-	if (rising_bits & 0x02) sample_start(state->m_samples, 0, 0, 0);		/* Shot Sound */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 1, 1, 0);		/* Base Hit */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 2, 2, 0);		/* Invader Hit */
+	if (rising_bits & 0x02) state->m_samples->start(0, 0);		/* Shot Sound */
+	if (rising_bits & 0x04) state->m_samples->start(1, 1);		/* Base Hit */
+	if (rising_bits & 0x08) state->m_samples->start(2, 2);		/* Invader Hit */
 
 	speaker_level_w(state->m_speaker, (data & 0x10) ? 1 : 0);		/* Various bitstream tunes */
 
@@ -130,11 +130,11 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 3, 0);		/* Thrust */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 1, 2, 0);		/* Shot Sound */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 0, 1, 0);		/* Death */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 1, 0, 0);		/* Alien Hit */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 2, 5, 0);		/* Bonus Ship (not confirmed) */
+	if (rising_bits & 0x01) state->m_samples->start(0, 3);		/* Thrust */
+	if (rising_bits & 0x02) state->m_samples->start(1, 2);		/* Shot Sound */
+	if (rising_bits & 0x04) state->m_samples->start(0, 1);		/* Death */
+	if (rising_bits & 0x08) state->m_samples->start(1, 0);		/* Alien Hit */
+	if (rising_bits & 0x10) state->m_samples->start(2, 5);		/* Bonus Ship (not confirmed) */
 
 	space->machine().sound().system_enable(data & 0x20);
 
@@ -148,14 +148,14 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 1, 8, 0);		/* Footstep high tone */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 1, 7, 0);		/* Footstep low tone */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 1, 4, 0);		/* Bonus when counting men saved */
+	if (rising_bits & 0x01) state->m_samples->start(1, 8);		/* Footstep high tone */
+	if (rising_bits & 0x02) state->m_samples->start(1, 7);		/* Footstep low tone */
+	if (rising_bits & 0x04) state->m_samples->start(1, 4);		/* Bonus when counting men saved */
 
 	speaker_level_w(state->m_speaker, (data & 0x08) ? 1 : 0);		/* Bitstream tunes - endlevel and bonus1 */
 
-	if (rising_bits & 0x10) sample_start(state->m_samples, 3, 6, 0);		/* Shooting Star and Rescue Ship sounds */
-	if ((~data & 0x10) && (state->m_port_2_last_extra & 0x10)) sample_stop (state->m_samples, 3);	/* This makes the rescue ship sound beep on and off */
+	if (rising_bits & 0x10) state->m_samples->start(3, 6);		/* Shooting Star and Rescue Ship sounds */
+	if ((~data & 0x10) && (state->m_port_2_last_extra & 0x10)) state->m_samples->stop(3);	/* This makes the rescue ship sound beep on and off */
 
 	state->m_c8080bw_flip_screen = data & 0x20;
 
@@ -188,11 +188,11 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 1, 2, 0);		/* Hit a balloon */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 2, 0, 0);		/* Shot Sound */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 2, 1, 0);		/* Base Hit */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 1, 7, 0);		/* Hit a Bomb */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 3, 8, 0);		/* Bonus Base at 1500 points */
+	if (rising_bits & 0x01) state->m_samples->start(1, 2);		/* Hit a balloon */
+	if (rising_bits & 0x02) state->m_samples->start(2, 0);		/* Shot Sound */
+	if (rising_bits & 0x04) state->m_samples->start(2, 1);		/* Base Hit */
+	if (rising_bits & 0x08) state->m_samples->start(1, 7);		/* Hit a Bomb */
+	if (rising_bits & 0x10) state->m_samples->start(3, 8);		/* Bonus Base at 1500 points */
 
 	space->machine().sound().system_enable(data & 0x20);
 
@@ -206,9 +206,9 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (data & 0x01) sample_start(state->m_samples, 0, 7, 0);		/* Indicates plane will drop bombs */
-	if (data & 0x04) sample_start(state->m_samples, 0, 4, 0);		/* Plane is dropping new balloons at start of level */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 2, 2, 0);		/* Balloon hit and bomb drops */
+	if (data & 0x01) state->m_samples->start(0, 7);		/* Indicates plane will drop bombs */
+	if (data & 0x04) state->m_samples->start(0, 4);		/* Plane is dropping new balloons at start of level */
+	if (rising_bits & 0x10) state->m_samples->start(2, 2);		/* Balloon hit and bomb drops */
 
 	state->m_c8080bw_flip_screen = data & 0x20;
 
@@ -265,10 +265,10 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 1, 7, 0);		/* Death */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 0, 1, 0);		/* Shot Sound */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 2, 3, 0);		/* Move */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 3, 2, 0);		/* Hit */
+	if (rising_bits & 0x01) state->m_samples->start(1, 7);		/* Death */
+	if (rising_bits & 0x02) state->m_samples->start(0, 1);		/* Shot Sound */
+	if (rising_bits & 0x04) state->m_samples->start(2, 3);		/* Move */
+	if (rising_bits & 0x08) state->m_samples->start(3, 2);		/* Hit */
 
 	space->machine().sound().system_enable(data & 0x20);
 
@@ -282,10 +282,10 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 4, 0, 0);		/* Bird dropped an egg, Lasso used */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 4, 2, 0);		/* Egg hatches, egg shot */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 5, 0, 0);		/* Grabber, Lasso caught something */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 3, 7, 0);		/* Lasso sound */
+	if (rising_bits & 0x01) state->m_samples->start(4, 0);		/* Bird dropped an egg, Lasso used */
+	if (rising_bits & 0x02) state->m_samples->start(4, 2);		/* Egg hatches, egg shot */
+	if (rising_bits & 0x08) state->m_samples->start(5, 0);		/* Grabber, Lasso caught something */
+	if (rising_bits & 0x10) state->m_samples->start(3, 7);		/* Lasso sound */
 
 	state->m_port_2_last_extra = data;
 }
@@ -954,9 +954,9 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_3_last_extra;
 
-	if (rising_bits & 0x02) sample_start(state->m_samples, 4, 0, 0);	/* Steering */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 0, 1, 0);	/* Collision */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 1, 8, 0);	/* Computer car is starting to move */
+	if (rising_bits & 0x02) state->m_samples->start(4, 0);	/* Steering */
+	if (rising_bits & 0x04) state->m_samples->start(0, 1);	/* Collision */
+	if (rising_bits & 0x10) state->m_samples->start(1, 8);	/* Computer car is starting to move */
 
 	state->m_port_3_last_extra = data;
 }
@@ -980,24 +980,24 @@
 	switch (data)
 	{
 		case 0x06:
-			sample_start(state->m_samples, 1, 0, 0);				/* Shoot */
+			state->m_samples->start(1, 0);				/* Shoot */
 			break;
 
 		case 0x14:
-			sample_start(state->m_samples, 2, 2, 0);				/* Hit Alien */
+			state->m_samples->start(2, 2);				/* Hit Alien */
 			break;
 
 		case 0x16:
-			sample_start(state->m_samples, 2, 5, 0);				/* Hit Asteroid */
+			state->m_samples->start(2, 5);				/* Hit Asteroid */
 			break;
 
 		case 0x1e:
-			sample_start(state->m_samples, 3, 1, 0);				/* Death (followed by 0x0a byte), also bit 4 of port 5 */
+			state->m_samples->start(3, 1);				/* Death (followed by 0x0a byte), also bit 4 of port 5 */
 			break;
 
 		case 0x18:						/* Fuel Low */
 		case 0x30:						/* Fuel bar filling up */
-			sample_start(state->m_samples, 4, 7, 0);
+			state->m_samples->start(4, 7);
 			break;
 
 		case 0x02:						/* Coin */
@@ -1007,7 +1007,7 @@
 			break;
 
 		case 0x3a:						/* Thrust, Docking, extra ship? */
-			sample_start(state->m_samples, 0, 8, 0);
+			state->m_samples->start(0, 8);
 			break;
 	}
 }
@@ -1023,13 +1023,13 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 6, 0);		/* Walking, get money */
+	if (rising_bits & 0x01) state->m_samples->start(0, 6);		/* Walking, get money */
 
 	sn76477_enable_w(state->m_sn, data & 0x02 ? 0:1);			/* Helicopter */
 
-	if (rising_bits & 0x04) sample_start(state->m_samples, 0, 7, 0);		/* Translocate */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 0, 1, 0);		/* Jail */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 3, 8, 0);		/* Bonus Man */
+	if (rising_bits & 0x04) state->m_samples->start(0, 7);		/* Translocate */
+	if (rising_bits & 0x08) state->m_samples->start(0, 1);		/* Jail */
+	if (rising_bits & 0x10) state->m_samples->start(3, 8);		/* Bonus Man */
 
 	state->m_port_1_last_extra = data;
 }
@@ -1039,11 +1039,11 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 3, 0);		/* Lands on top of building, wife kicks man */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 1, 2, 0);		/* deposit money, start intermission, end game */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 2, 5, 0);		/* deposit money, start intermission, Slides down rope */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 3, 0, 0);		/* start intermission, end game */
-	//if (rising_bits & 0x10) sample_start(state->m_samples, 3, 9, 0);        /* Dog barking */
+	if (rising_bits & 0x01) state->m_samples->start(0, 3);		/* Lands on top of building, wife kicks man */
+	if (rising_bits & 0x02) state->m_samples->start(1, 2);		/* deposit money, start intermission, end game */
+	if (rising_bits & 0x04) state->m_samples->start(2, 5);		/* deposit money, start intermission, Slides down rope */
+	if (rising_bits & 0x08) state->m_samples->start(3, 0);		/* start intermission, end game */
+	//if (rising_bits & 0x10) state->m_samples->start(3, 9);        /* Dog barking */
 
 	state->m_color_map = data & 0x40;
 
@@ -1068,8 +1068,8 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x02) sample_start(state->m_samples, 1, 6, 0);		/* Ran over a dot */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 0, 1, 0);		/* Death */
+	if (rising_bits & 0x02) state->m_samples->start(1, 6);		/* Ran over a dot */
+	if (rising_bits & 0x10) state->m_samples->start(0, 1);		/* Death */
 
 	state->m_port_1_last_extra = data;
 }
@@ -1096,11 +1096,11 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 3, 0);			/* Game Over */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 2, 0, 0);			/* Bird dead */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 0, 1, 0);			/* Rifle being fired */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 1, 2, 0);			/* Man dead */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 5, 8, 0);			/* Bonus Man? */
+	if (rising_bits & 0x01) state->m_samples->start(0, 3);			/* Game Over */
+	if (rising_bits & 0x02) state->m_samples->start(2, 0);			/* Bird dead */
+	if (rising_bits & 0x04) state->m_samples->start(0, 1);			/* Rifle being fired */
+	if (rising_bits & 0x08) state->m_samples->start(1, 2);			/* Man dead */
+	if (rising_bits & 0x10) state->m_samples->start(5, 8);			/* Bonus Man? */
 
 	space->machine().sound().system_enable(data & 0x20);
 
@@ -1112,12 +1112,12 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_2_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 1, 6, 0);			/* Ready? , Game Over */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 3, 7, 0);			/* Big bird dead */
+	if (rising_bits & 0x01) state->m_samples->start(1, 6);			/* Ready? , Game Over */
+	if (rising_bits & 0x04) state->m_samples->start(3, 7);			/* Big bird dead */
 
 	sn76477_enable_w(state->m_sn, data & 0x08 ? 0:1);				/* Big bird */
 
-	if (rising_bits & 0x10) sample_start(state->m_samples, 2, 7, 0);			/* Game Over */
+	if (rising_bits & 0x10) state->m_samples->start(2, 7);			/* Game Over */
 
 	state->m_c8080bw_flip_screen = data & 0x20;
 
@@ -1136,8 +1136,8 @@
 	_8080bw_state *state = space->machine().driver_data<_8080bw_state>();
 	UINT8 rising_bits = data & ~state->m_port_1_last_extra;
 
-	if (rising_bits & 0x01) sample_start(state->m_samples, 4, 4, 0);			/* Fleet move */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 5, 8, 0);			/* Extra Tank */
+	if (rising_bits & 0x01) state->m_samples->start(4, 4);			/* Fleet move */
+	if (rising_bits & 0x02) state->m_samples->start(5, 8);			/* Extra Tank */
 
 	sn76477_enable_w(state->m_sn, data & 0x04 ? 0:1);				/* UFO */
 
@@ -1151,19 +1151,19 @@
 	switch (data)
 	{
 		case 0x23:
-			sample_start(state->m_samples, 2, 2, 0);				/* Hit */
+			state->m_samples->start(2, 2);				/* Hit */
 			break;
 
 		case 0x2b:
-			sample_start(state->m_samples, 0, 0, 0);				/* Shoot */
+			state->m_samples->start(0, 0);				/* Shoot */
 			break;
 
 		case 0xa3:
-			sample_start(state->m_samples, 3, 7, 0);				/* Hit UFO */
+			state->m_samples->start(3, 7);				/* Hit UFO */
 			break;
 
 		case 0xab:
-			sample_start(state->m_samples, 1, 1, 0);				/* Death */
+			state->m_samples->start(1, 1);				/* Death */
 			break;
 	}
 }
diff -Nru src-old/mame/audio/astrof.c src/mame/audio/astrof.c
--- src-old/mame/audio/astrof.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/astrof.c	2012-02-19 02:53:16.000000000 +0100
@@ -38,10 +38,10 @@
 	UINT8 rising_bits = data & ~state->m_port_1_last;
 
 	if (state->m_astrof_death_playing)
-		state->m_astrof_death_playing = sample_playing(state->m_samples, CHANNEL_EXPLOSION);
+		state->m_astrof_death_playing = state->m_samples->playing(CHANNEL_EXPLOSION);
 
 	if (state->m_astrof_bosskill_playing)
-		state->m_astrof_bosskill_playing = sample_playing(state->m_samples, CHANNEL_EXPLOSION);
+		state->m_astrof_bosskill_playing = state->m_samples->playing(CHANNEL_EXPLOSION);
 
 	/* D2 - explosion */
 	if (rising_bits & 0x04)
@@ -55,19 +55,19 @@
 	if ((data & 0x08) && (~state->m_port_1_last & 0x08))
 	{
 		int sample = SAMPLE_WAVE + (data & 3);
-		sample_start(state->m_samples, CHANNEL_WAVE, sample, 1);
+		state->m_samples->start(CHANNEL_WAVE, sample, 1);
 	}
 
 	if ((~data & 0x08) && (state->m_port_1_last & 0x08))
-		sample_stop(state->m_samples, CHANNEL_WAVE);
+		state->m_samples->stop(CHANNEL_WAVE);
 
 	/* D4 - boss laser */
 	if ((rising_bits & 0x10) && !state->m_astrof_bosskill_playing)
-		sample_start(state->m_samples, CHANNEL_BOSSFIRE, SAMPLE_BOSSFIRE, 0);
+		state->m_samples->start(CHANNEL_BOSSFIRE, SAMPLE_BOSSFIRE, 0);
 
 	/* D5 - fire */
 	if ((rising_bits & 0x20) && !state->m_astrof_bosskill_playing)
-		sample_start(state->m_samples, CHANNEL_FIRE, SAMPLE_FIRE, 0);
+		state->m_samples->start(CHANNEL_FIRE, SAMPLE_FIRE, 0);
 
 	/* D6 - don't know. Probably something to do with the explosion sounds */
 
@@ -95,19 +95,19 @@
 		{
 			if (!state->m_astrof_bosskill_playing)
 			{
-				sample_start(state->m_samples, CHANNEL_EXPLOSION, SAMPLE_BOSSKILL, 0);
+				state->m_samples->start(CHANNEL_EXPLOSION, SAMPLE_BOSSKILL, 0);
 				state->m_astrof_bosskill_playing = 1;
 			}
 		}
 		else if (data & 0x02)
-			sample_start(state->m_samples, CHANNEL_EXPLOSION, SAMPLE_BOSSHIT, 0);
+			state->m_samples->start(CHANNEL_EXPLOSION, SAMPLE_BOSSHIT, 0);
 		else if (data & 0x01)
-			sample_start(state->m_samples, CHANNEL_EXPLOSION, SAMPLE_EKILLED, 0);
+			state->m_samples->start(CHANNEL_EXPLOSION, SAMPLE_EKILLED, 0);
 		else
 		{
 			if (!state->m_astrof_death_playing)
 			{
-				sample_start(state->m_samples, CHANNEL_EXPLOSION, SAMPLE_DEATH, 0);
+				state->m_samples->start(CHANNEL_EXPLOSION, SAMPLE_DEATH, 0);
 				state->m_astrof_death_playing = 1;
 			}
 		}
@@ -117,7 +117,7 @@
 
 	/* D3 - low fuel warning */
 	if (rising_bits & 0x08)
-		sample_start(state->m_samples, CHANNEL_FUEL, SAMPLE_FUEL, 0);
+		state->m_samples->start(CHANNEL_FUEL, SAMPLE_FUEL, 0);
 
 	state->m_port_2_last = data;
 }
@@ -151,8 +151,7 @@
 
 MACHINE_CONFIG_FRAGMENT( astrof_audio )
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(astrof_samples_interface)
+	MCFG_SAMPLES_ADD("samples", astrof_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/audio/blockade.c src/mame/audio/blockade.c
--- src-old/mame/audio/blockade.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/blockade.c	2012-02-19 02:53:16.000000000 +0100
@@ -44,9 +44,9 @@
 
 WRITE8_HANDLER( blockade_env_on_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	if (BLOCKADE_LOG) mame_printf_debug("Boom Start\n");
-	sample_start(samples, 0,0,0);
+	samples->start(0,0);
 	return;
 }
 
diff -Nru src-old/mame/audio/carnival.c src/mame/audio/carnival.c
--- src-old/mame/audio/carnival.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/carnival.c	2012-02-19 02:53:16.000000000 +0100
@@ -75,8 +75,8 @@
 #define PSG_BC_LATCH_ADDRESS    ( MUSIC_PORT2_PSG_BDIR | MUSIC_PORT2_PSG_BC1 )
 
 
-#define PLAY(samp,id,loop)      sample_start( samp, id, id, loop )
-#define STOP(samp,id)           sample_stop( samp, id )
+#define PLAY(samp,id,loop)      samp->start( id, id, loop )
+#define STOP(samp,id)           samp->stop( id )
 
 
 /* sample file names */
@@ -127,7 +127,7 @@
 WRITE8_HANDLER( carnival_audio_1_w )
 {
 	static int port1State = 0;
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int bitsChanged;
 	int bitsGoneHigh;
 	int bitsGoneLow;
@@ -206,7 +206,7 @@
 
 WRITE8_HANDLER( carnival_audio_2_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int bitsChanged;
 	int bitsGoneHigh;
 	int bitsGoneLow;
@@ -306,7 +306,6 @@
 	MCFG_SOUND_ADD("psg", AY8910, PSG_CLOCK)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(carnival_samples_interface)
+	MCFG_SAMPLES_ADD("samples", carnival_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/audio/cclimber.c src/mame/audio/cclimber.c
--- src-old/mame/audio/cclimber.c	2011-03-29 16:50:04.000000000 +0200
+++ src/mame/audio/cclimber.c	2012-02-19 02:53:16.000000000 +0100
@@ -15,7 +15,7 @@
 
 static SAMPLES_START( cclimber_sh_start )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	samplebuf = 0;
 	if (machine.region("samples")->base())
 		samplebuf = auto_alloc_array(machine, INT16, 2 * machine.region("samples")->bytes());
@@ -27,7 +27,7 @@
 	int len;
 	int romlen = machine.region("samples")->bytes();
 	const UINT8 *rom = machine.region("samples")->base();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 
 	if (!rom) return;
@@ -47,7 +47,7 @@
 		len++;
 	}
 
-	sample_start_raw(samples,0,samplebuf,2 * len,freq,0);
+	samples->start_raw(0,samplebuf,2 * len,freq);
 }
 
 
diff -Nru src-old/mame/audio/cinemat.c src/mame/audio/cinemat.c
--- src-old/mame/audio/cinemat.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/cinemat.c	2012-02-19 02:53:16.000000000 +0100
@@ -143,31 +143,31 @@
 
 static void spacewar_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* Explosion - rising edge */
 	if (SOUNDVAL_RISING_EDGE(0x01))
-		sample_start(samples, 0, (machine.rand() & 1) ? 0 : 6, 0);
+		samples->start(0, (machine.rand() & 1) ? 0 : 6);
 
 	/* Fire sound - rising edge */
 	if (SOUNDVAL_RISING_EDGE(0x02))
-		sample_start(samples, 1, (machine.rand() & 1) ? 1 : 7, 0);
+		samples->start(1, (machine.rand() & 1) ? 1 : 7);
 
 	/* Player 1 thrust - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 3, 3, 1);
+		samples->start(3, 3, true);
 	if (SOUNDVAL_RISING_EDGE(0x04))
-		sample_stop(samples, 3);
+		samples->stop(3);
 
 	/* Player 2 thrust - 0=on, 1-off */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 4, 4, 1);
+		samples->start(4, 4, true);
 	if (SOUNDVAL_RISING_EDGE(0x08))
-		sample_stop(samples, 4);
+		samples->stop(4);
 
 	/* Mute - 0=off, 1=on */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_start(samples, 2, 2, 1);	/* play idle sound */
+		samples->start(2, 2, true);	/* play idle sound */
 	if (SOUNDVAL_RISING_EDGE(0x10))
 	{
         int i;
@@ -175,10 +175,10 @@
 		/* turn off all but the idle sound */
 		for (i = 0; i < 5; i++)
 			if (i != 2)
-				sample_stop(samples, i);
+				samples->stop(i);
 
 		/* Pop when board is shut off */
-		sample_start(samples, 2, 5, 0);
+		samples->start(2, 5);
 	}
 }
 
@@ -193,8 +193,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(spacewar_samples_interface)
+	MCFG_SAMPLES_ADD("samples", spacewar_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -223,19 +222,19 @@
 
 static void barrier_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* Player die - rising edge */
 	if (SOUNDVAL_RISING_EDGE(0x01))
-		sample_start(samples, 0, 0, 0);
+		samples->start(0, 0);
 
 	/* Player move - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 1, 1, 0);
+		samples->start(1, 1);
 
 	/* Enemy move - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 2, 2, 0);
+		samples->start(2, 2);
 }
 
 static MACHINE_RESET( barrier )
@@ -249,8 +248,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(barrier_samples_interface)
+	MCFG_SAMPLES_ADD("samples", barrier_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -278,7 +276,7 @@
 static void speedfrk_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* on the falling edge of bit 0x08, clock the inverse of bit 0x04 into the top of the shiftreg */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
@@ -292,9 +290,9 @@
 
 	/* off-road - 1=on, 0=off */
 	if (SOUNDVAL_RISING_EDGE(0x10))
-		sample_start(samples, 0, 0, 1);
+		samples->start(0, 0, true);
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_stop(samples, 0);
+		samples->stop(0);
 
     /* start LED is controlled by bit 0x02 */
     set_led_status(machine, 0, ~sound_val & 0x02);
@@ -311,8 +309,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(speedfrk_samples_interface)
+	MCFG_SAMPLES_ADD("samples", speedfrk_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -344,37 +341,37 @@
 
 static void starhawk_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x01))
-		sample_start(samples, 0, 0, 0);
+		samples->start(0, 0);
 
 	/* right laser - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 1, 1, 0);
+		samples->start(1, 1);
 
 	/* left laser - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 2, 2, 0);
+		samples->start(2, 2);
 
 	/* K - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 3, 3, 1);
+		samples->start(3, 3, true);
 	if (SOUNDVAL_RISING_EDGE(0x08))
-		sample_stop(samples, 3);
+		samples->stop(3);
 
 	/* master - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_start(samples, 4, 4, 1);
+		samples->start(4, 4, true);
 	if (SOUNDVAL_RISING_EDGE(0x10))
-		sample_stop(samples, 4);
+		samples->stop(4);
 
 	/* K exit - 1=on, 0=off */
 	if (SOUNDVAL_RISING_EDGE(0x80))
-		sample_start(samples, 3, 5, 1);
+		samples->start(3, 5, true);
 	if (SOUNDVAL_FALLING_EDGE(0x80))
-		sample_stop(samples, 3);
+		samples->stop(3);
 }
 
 static MACHINE_RESET( starhawk )
@@ -388,8 +385,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(starhawk_samples_interface)
+	MCFG_SAMPLES_ADD("samples", starhawk_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -421,31 +417,31 @@
 
 static void sundance_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* bong - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x01))
-		sample_start(samples, 0, 0, 0);
+		samples->start(0, 0);
 
 	/* whoosh - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 1, 1, 0);
+		samples->start(1, 1);
 
 	/* explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 2, 2, 0);
+		samples->start(2, 2);
 
 	/* ping - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 3, 3, 0);
+		samples->start(3, 3);
 
 	/* ping - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_start(samples, 4, 4, 0);
+		samples->start(4, 4);
 
 	/* hatch - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x80))
-		sample_start(samples, 5, 5, 0);
+		samples->start(5, 5);
 }
 
 static MACHINE_RESET( sundance )
@@ -459,8 +455,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(sundance_samples_interface)
+	MCFG_SAMPLES_ADD("samples", sundance_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -496,40 +491,40 @@
 	/* the falling edge of bit 0x10 clocks bit 0x08 into the mux selected by bits 0x07 */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
 	{
-		device_t *samples = machine.device("samples");
+		samples_device *samples = machine.device<samples_device>("samples");
 
 		/* update the shift register (actually just a simple mux) */
 		state->m_current_shift = (state->m_current_shift & ~(1 << (sound_val & 7))) | (((sound_val >> 3) & 1) << (sound_val & 7));
 
 		/* explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x01))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* rumble - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x02))
-			sample_start(samples, 1, 1, 1);
+			samples->start(1, 1, true);
 		if (SHIFTREG_RISING_EDGE(0x02))
-			sample_stop(samples, 1);
+			samples->stop(1);
 
 		/* laser - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x04))
-			sample_start(samples, 2, 2, 1);
+			samples->start(2, 2, true);
 		if (SHIFTREG_RISING_EDGE(0x04))
-			sample_stop(samples, 2);
+			samples->stop(2);
 
 		/* shield - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x08))
-			sample_start(samples, 3, 3, 1);
+			samples->start(3, 3, true);
 		if (SHIFTREG_RISING_EDGE(0x08))
-			sample_stop(samples, 3);
+			samples->stop(3);
 
 		/* bounce - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 4, 4, 0);
+			samples->start(4, 4);
 
 		/* hyperspace - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_start(samples, 5, 5, 0);
+			samples->start(5, 5);
 
 		/* LED */
 		set_led_status(machine, 0, state->m_current_shift & 0x40);
@@ -550,8 +545,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(tailg_samples_interface)
+	MCFG_SAMPLES_ADD("samples", tailg_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -582,31 +576,31 @@
 
 static void warrior_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* normal level - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x01))
-		sample_start(samples, 0, 0, 1);
+		samples->start(0, 0, true);
 	if (SOUNDVAL_RISING_EDGE(0x01))
-		sample_stop(samples, 0);
+		samples->stop(0);
 
 	/* hi level - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 1, 1, 1);
+		samples->start(1, 1, true);
 	if (SOUNDVAL_RISING_EDGE(0x02))
-		sample_stop(samples, 1);
+		samples->stop(1);
 
 	/* explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 2, 2, 0);
+		samples->start(2, 2);
 
 	/* fall - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 3, 3, 0);
+		samples->start(3, 3);
 
 	/* appear - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_start(samples, 4, 4, 0);
+		samples->start(4, 4);
 }
 
 static MACHINE_RESET( warrior )
@@ -620,8 +614,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(warrior_samples_interface)
+	MCFG_SAMPLES_ADD("samples", warrior_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -655,7 +648,7 @@
 static void armora_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
 	if (SOUNDVAL_RISING_EDGE(0x10))
@@ -668,19 +661,19 @@
 
 		/* lo explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* jeep fire - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* hi explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 2, 2, 0);
+			samples->start(2, 2);
 
 		/* tank fire - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 3, 3, 0);
+			samples->start(3, 3);
 
 		/* remember the previous value */
 		state->m_last_shift = state->m_current_shift;
@@ -689,21 +682,21 @@
 	/* tank sound - 0=on, 1=off */
 	/* still not totally correct - should be multiple speeds based on remaining bits in shift reg */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 4, 4, 1);
+		samples->start(4, 4, true);
 	if (SOUNDVAL_RISING_EDGE(0x02))
-		sample_stop(samples, 4);
+		samples->stop(4);
 
 	/* beep sound - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 5, 5, 1);
+		samples->start(5, 5, true);
 	if (SOUNDVAL_RISING_EDGE(0x04))
-		sample_stop(samples, 5);
+		samples->stop(5);
 
 	/* chopper sound - 0=on, 1=off */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 6, 6, 1);
+		samples->start(6, 6, true);
 	if (SOUNDVAL_RISING_EDGE(0x08))
-		sample_stop(samples, 6);
+		samples->stop(6);
 }
 
 static MACHINE_RESET( armora )
@@ -717,8 +710,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(armora_samples_interface)
+	MCFG_SAMPLES_ADD("samples", armora_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -758,7 +750,7 @@
 static void ripoff_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* on the rising edge of bit 0x02, clock bit 0x01 into the shift register */
 	if (SOUNDVAL_RISING_EDGE(0x02))
@@ -769,19 +761,19 @@
 	{
 		/* background - 0=on, 1=off, selected by bits 0x38 */
 		if ((((state->m_current_shift ^ state->m_last_shift) & 0x38) && !(state->m_current_shift & 0x04)) || SHIFTREG_FALLING_EDGE(0x04))
-			sample_start(samples, 5, 5 + ((state->m_current_shift >> 5) & 7), 1);
+			samples->start(5, 5 + ((state->m_current_shift >> 5) & 7), true);
 		if (SHIFTREG_RISING_EDGE(0x04))
-			sample_stop(samples, 5);
+			samples->stop(5);
 
 		/* beep - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x02))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* motor - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x01))
-			sample_start(samples, 1, 1, 1);
+			samples->start(1, 1, true);
 		if (SHIFTREG_RISING_EDGE(0x01))
-			sample_stop(samples, 1);
+			samples->stop(1);
 
 		/* remember the previous value */
 		state->m_last_shift = state->m_current_shift;
@@ -789,15 +781,15 @@
 
 	/* torpedo - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 2, 2, 0);
+		samples->start(2, 2);
 
 	/* laser - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x10))
-		sample_start(samples, 3, 3, 0);
+		samples->start(3, 3);
 
 	/* explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x80))
-		sample_start(samples, 4, 4, 0);
+		samples->start(4, 4);
 }
 
 static MACHINE_RESET( ripoff )
@@ -811,8 +803,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(ripoff_samples_interface)
+	MCFG_SAMPLES_ADD("samples", ripoff_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -847,7 +838,7 @@
 static void starcas_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	UINT32 target_pitch;
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
@@ -859,29 +850,29 @@
 	{
 		/* fireball - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* shield hit - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* star sound - 0=off, 1=on */
 		if (SHIFTREG_RISING_EDGE(0x20))
-			sample_start(samples, 2, 2, 1);
+			samples->start(2, 2, true);
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_stop(samples, 2);
+			samples->stop(2);
 
 		/* thrust sound - 1=off, 0=on*/
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 3, 3, 1);
+			samples->start(3, 3, true);
 		if (SHIFTREG_RISING_EDGE(0x10))
-			sample_stop(samples, 3);
+			samples->stop(3);
 
 		/* drone - 1=off, 0=on */
 		if (SHIFTREG_FALLING_EDGE(0x08))
-			sample_start(samples, 4, 4, 1);
+			samples->start(4, 4, true);
 		if (SHIFTREG_RISING_EDGE(0x08))
-			sample_stop(samples, 4);
+			samples->stop(4);
 
 		/* latch the drone pitch */
 		target_pitch = (state->m_current_shift & 7) + ((state->m_current_shift & 2) << 2);
@@ -894,7 +885,7 @@
                 state->m_current_pitch -= 225;
             if (state->m_current_pitch < target_pitch)
                 state->m_current_pitch += 150;
-            sample_set_freq(samples, 4, state->m_current_pitch);
+            samples->set_frequency(4, state->m_current_pitch);
             state->m_last_frame = machine.primary_screen->frame_number();
         }
 
@@ -904,15 +895,15 @@
 
 	/* loud explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 5, 5, 0);
+		samples->start(5, 5);
 
 	/* soft explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 6, 6, 0);
+		samples->start(6, 6);
 
 	/* player fire - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 7, 7, 0);
+		samples->start(7, 7);
 }
 
 static MACHINE_RESET( starcas )
@@ -926,8 +917,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(starcas_samples_interface)
+	MCFG_SAMPLES_ADD("samples", starcas_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
@@ -962,7 +952,7 @@
 static void solarq_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
 	if (SOUNDVAL_RISING_EDGE(0x10))
@@ -976,53 +966,53 @@
 
 		/* loud explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* soft explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* thrust - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x20))
 		{
 			state->m_target_volume = 1.0;
-			if (!sample_playing(samples, 2))
-				sample_start(samples, 2, 2, 1);
+			if (!samples->playing(2))
+				samples->start(2, 2, true);
 		}
 		if (SHIFTREG_RISING_EDGE(0x20))
 			state->m_target_volume = 0;
 
 		/* ramp the thrust volume */
-        if (sample_playing(samples, 2) && machine.primary_screen->frame_number() > state->m_last_frame)
+        if (samples->playing(2) && machine.primary_screen->frame_number() > state->m_last_frame)
         {
             if (state->m_current_volume > state->m_target_volume)
                 state->m_current_volume -= 0.078f;
             if (state->m_current_volume < state->m_target_volume)
                 state->m_current_volume += 0.078f;
             if (state->m_current_volume > 0)
-                sample_set_volume(samples, 2, state->m_current_volume);
+                samples->set_volume(2, state->m_current_volume);
             else
-                sample_stop(samples, 2);
+                samples->stop(2);
             state->m_last_frame = machine.primary_screen->frame_number();
         }
 
 		/* fire - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 3, 3, 0);
+			samples->start(3, 3);
 
 		/* capture - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x08))
-			sample_start(samples, 4, 4, 0);
+			samples->start(4, 4);
 
 		/* nuke - 1=on, 0=off */
 		if (SHIFTREG_RISING_EDGE(0x04))
-			sample_start(samples, 5, 5, 1);
+			samples->start(5, 5, true);
 		if (SHIFTREG_FALLING_EDGE(0x04))
-			sample_stop(samples, 5);
+			samples->stop(5);
 
 		/* photon - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x02))
-			sample_start(samples, 6, 6, 0);
+			samples->start(6, 6);
 
 		/* remember the previous value */
 		state->m_last_shift = state->m_current_shift;
@@ -1035,17 +1025,17 @@
 
 		/* start/stop the music sample on the high bit */
 		if (SHIFTREG2_RISING_EDGE(0x8000))
-			sample_start(samples, 7, 7, 1);
+			samples->start(7, 7, true);
 		if (SHIFTREG2_FALLING_EDGE(0x8000))
-			sample_stop(samples, 7);
+			samples->stop(7);
 
 		/* set the frequency */
 		freq = 56818.181818 / (4096 - (state->m_current_shift & 0xfff));
-		sample_set_freq(samples, 7, 44100 * freq / 1050);
+		samples->set_frequency(7, 44100 * freq / 1050);
 
 		/* set the volume */
 		vol = (~state->m_current_shift >> 12) & 7;
-		sample_set_volume(samples, 7, vol / 7.0);
+		samples->set_volume(7, vol / 7.0);
 
 		/* remember the previous value */
 		state->m_last_shift2 = state->m_current_shift;
@@ -1063,8 +1053,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(solarq_samples_interface)
+	MCFG_SAMPLES_ADD("samples", solarq_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
@@ -1103,7 +1092,7 @@
 static void boxingb_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
 	if (SOUNDVAL_RISING_EDGE(0x10))
@@ -1117,37 +1106,37 @@
 
 		/* soft explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* loud explosion - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* chirping birds - 0=on, 1=off */
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_start(samples, 2, 2, 0);
+			samples->start(2, 2);
 		if (SHIFTREG_RISING_EDGE(0x20))
-			sample_stop(samples, 2);
+			samples->stop(2);
 
 		/* egg cracking - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 3, 3, 0);
+			samples->start(3, 3);
 
 		/* bug pushing A - rising edge */
 		if (SHIFTREG_RISING_EDGE(0x08))
-			sample_start(samples, 4, 4, 0);
+			samples->start(4, 4);
 
 		/* bug pushing B - rising edge */
 		if (SHIFTREG_RISING_EDGE(0x04))
-			sample_start(samples, 5, 5, 0);
+			samples->start(5, 5);
 
 		/* bug dying - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x02))
-			sample_start(samples, 6, 6, 0);
+			samples->start(6, 6);
 
 		/* beetle on screen - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x01))
-			sample_start(samples, 7, 7, 0);
+			samples->start(7, 7);
 
 		/* remember the previous value */
 		state->m_last_shift = state->m_current_shift;
@@ -1160,21 +1149,21 @@
 
 		/* start/stop the music sample on the high bit */
 		if (SHIFTREG2_RISING_EDGE(0x8000))
-			sample_start(samples, 8, 8, 1);
+			samples->start(8, 8, true);
 		if (SHIFTREG2_FALLING_EDGE(0x8000))
-			sample_stop(samples, 8);
+			samples->stop(8);
 
 		/* set the frequency */
 		freq = 56818.181818 / (4096 - (state->m_current_shift & 0xfff));
-		sample_set_freq(samples, 8, 44100 * freq / 1050);
+		samples->set_frequency(8, 44100 * freq / 1050);
 
 		/* set the volume */
 		vol = (~state->m_current_shift >> 12) & 3;
-		sample_set_volume(samples, 8, vol / 3.0);
+		samples->set_volume(8, vol / 3.0);
 
         /* cannon - falling edge */
         if (SHIFTREG2_RISING_EDGE(0x4000))
-        	sample_start(samples, 9, 9, 0);
+        	samples->start(9, 9);
 
 		/* remember the previous value */
 		state->m_last_shift2 = state->m_current_shift;
@@ -1182,11 +1171,11 @@
 
 	/* bounce - rising edge */
 	if (SOUNDVAL_RISING_EDGE(0x04))
-		sample_start(samples, 10, 10, 0);
+		samples->start(10, 10);
 
 	/* bell - falling edge */
 	if (SOUNDVAL_RISING_EDGE(0x08))
-		sample_start(samples, 11, 11, 0);
+		samples->start(11, 11);
 }
 
 static MACHINE_RESET( boxingb )
@@ -1200,8 +1189,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(boxingb_samples_interface)
+	MCFG_SAMPLES_ADD("samples", boxingb_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -1236,7 +1224,7 @@
 static void wotw_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	UINT32 target_pitch;
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
@@ -1248,29 +1236,29 @@
 	{
 		/* fireball - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* shield hit - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* star sound - 0=off, 1=on */
 		if (SHIFTREG_RISING_EDGE(0x20))
-			sample_start(samples, 2, 2, 1);
+			samples->start(2, 2, true);
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_stop(samples, 2);
+			samples->stop(2);
 
 		/* thrust sound - 1=off, 0=on*/
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 3, 3, 1);
+			samples->start(3, 3, true);
 		if (SHIFTREG_RISING_EDGE(0x10))
-			sample_stop(samples, 3);
+			samples->stop(3);
 
 		/* drone - 1=off, 0=on */
 		if (SHIFTREG_FALLING_EDGE(0x08))
-			sample_start(samples, 4, 4, 1);
+			samples->start(4, 4, true);
 		if (SHIFTREG_RISING_EDGE(0x08))
-			sample_stop(samples, 4);
+			samples->stop(4);
 
 		/* latch the drone pitch */
 		target_pitch = (state->m_current_shift & 7) + ((state->m_current_shift & 2) << 2);
@@ -1283,7 +1271,7 @@
                 state->m_current_pitch -= 300;
             if (state->m_current_pitch < target_pitch)
                 state->m_current_pitch += 200;
-            sample_set_freq(samples, 4, state->m_current_pitch);
+            samples->set_frequency(4, state->m_current_pitch);
             state->m_last_frame = machine.primary_screen->frame_number();
         }
 
@@ -1293,15 +1281,15 @@
 
 	/* loud explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 5, 5, 0);
+		samples->start(5, 5);
 
 	/* soft explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 6, 6, 0);
+		samples->start(6, 6);
 
 	/* player fire - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 7, 7, 0);
+		samples->start(7, 7);
 }
 
 static MACHINE_RESET( wotw )
@@ -1315,8 +1303,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(wotw_samples_interface)
+	MCFG_SAMPLES_ADD("samples", wotw_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -1351,7 +1338,7 @@
 static void wotwc_sound_w(running_machine &machine, UINT8 sound_val, UINT8 bits_changed)
 {
 	cinemat_state *state = machine.driver_data<cinemat_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	UINT32 target_pitch;
 
 	/* on the rising edge of bit 0x10, clock bit 0x80 into the shift register */
@@ -1363,29 +1350,29 @@
 	{
 		/* fireball - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x80))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 
 		/* shield hit - falling edge */
 		if (SHIFTREG_FALLING_EDGE(0x40))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 
 		/* star sound - 0=off, 1=on */
 		if (SHIFTREG_RISING_EDGE(0x20))
-			sample_start(samples, 2, 2, 1);
+			samples->start(2, 2, true);
 		if (SHIFTREG_FALLING_EDGE(0x20))
-			sample_stop(samples, 2);
+			samples->stop(2);
 
 		/* thrust sound - 1=off, 0=on*/
 		if (SHIFTREG_FALLING_EDGE(0x10))
-			sample_start(samples, 3, 3, 1);
+			samples->start(3, 3, true);
 		if (SHIFTREG_RISING_EDGE(0x10))
-			sample_stop(samples, 3);
+			samples->stop(3);
 
 		/* drone - 1=off, 0=on */
 		if (SHIFTREG_FALLING_EDGE(0x08))
-			sample_start(samples, 4, 4, 1);
+			samples->start(4, 4, true);
 		if (SHIFTREG_RISING_EDGE(0x08))
-			sample_stop(samples, 4);
+			samples->stop(4);
 
 		/* latch the drone pitch */
 		target_pitch = (state->m_current_shift & 7) + ((state->m_current_shift & 2) << 2);
@@ -1398,7 +1385,7 @@
                 state->m_current_pitch -= 300;
             if (state->m_current_pitch < target_pitch)
                 state->m_current_pitch += 200;
-            sample_set_freq(samples, 4, state->m_current_pitch);
+            samples->set_frequency(4, state->m_current_pitch);
             state->m_last_frame = machine.primary_screen->frame_number();
         }
 
@@ -1408,15 +1395,15 @@
 
 	/* loud explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x02))
-		sample_start(samples, 5, 5, 0);
+		samples->start(5, 5);
 
 	/* soft explosion - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x04))
-		sample_start(samples, 6, 6, 0);
+		samples->start(6, 6);
 
 	/* player fire - falling edge */
 	if (SOUNDVAL_FALLING_EDGE(0x08))
-		sample_start(samples, 7, 7, 0);
+		samples->start(7, 7);
 }
 
 static MACHINE_RESET( wotwc )
@@ -1430,8 +1417,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(wotwc_samples_interface)
+	MCFG_SAMPLES_ADD("samples", wotwc_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/audio/circus.c src/mame/audio/circus.c
--- src-old/mame/audio/circus.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/circus.c	2012-02-19 02:53:16.000000000 +0100
@@ -193,26 +193,26 @@
 					break;
 
 				case 2 : /* Circus = Pop; Rip Cord = Splash */
-					sample_start(state->m_samples, 0, 0, 0);
+					state->m_samples->start(0, 0);
 					break;
 
 				case 3 : /* Normal Video */
 					break;
 
 				case 4 : /* Circus = Miss; Rip Cord = Scream */
-					sample_start(state->m_samples, 1, 1, 0);
+					state->m_samples->start(1, 1);
 					break;
 
 				case 5 : /* Invert Video */
 					break;
 
 				case 6 : /* Circus = Bounce; Rip Cord = Chute Open */
-					sample_start(state->m_samples, 2, 2, 0);
+					state->m_samples->start(2, 2);
 					break;
 
 				case 7 : /* Circus = not used; Rip Cord = Whistle */
 					if (state->m_game_id == 4)
-						sample_start(state->m_samples, 3, 3, 0);
+						state->m_samples->start(3, 3);
 					break;
 			}
 			break;
@@ -221,19 +221,19 @@
 			discrete_sound_w(state->m_discrete, ROBOTBWL_MUSIC_BIT, data & 0x08);	/* Footsteps */
 
 			if (data & 0x40)	/* Hit */
-				sample_start(state->m_samples, 0, 0, 0);
+				state->m_samples->start(0, 0);
 
 			if (data & 0x20)	/* Roll */
-				sample_start(state->m_samples, 1, 1, 0);
+				state->m_samples->start(1, 1);
 
 			if (data & 0x10)	/* Ball Drop */
-				sample_start(state->m_samples, 2, 2, 0);
+				state->m_samples->start(2, 2);
 
 			if (data & 0x02)	/* Demerit */
-				sample_start(state->m_samples, 3, 3, 0);
+				state->m_samples->start(3, 3);
 
 			if (data & 0x01)	/* Reward */
-				sample_start(state->m_samples, 4, 4, 0);
+				state->m_samples->start(4, 4);
 
 			// if (data & 0x04) /* Invert */
 			break;
@@ -251,7 +251,7 @@
 					break;
 
 				case 2 : /* Crash */
-					sample_start(state->m_samples, 0, 0, 0);
+					state->m_samples->start(0, 0);
 					break;
 
 				case 3 : /* Normal Video and Beep */
diff -Nru src-old/mame/audio/dcs.c src/mame/audio/dcs.c
--- src-old/mame/audio/dcs.c	2011-06-05 23:35:20.000000000 +0200
+++ src/mame/audio/dcs.c	2012-02-11 11:01:01.000000000 +0100
@@ -1977,7 +1977,7 @@
 		reg = dcs.ireg_base;
 
 		/* generate the (internal, thats why the pulse) irq */
-		generic_pulse_irq_line(dcs.cpu, ADSP2105_IRQ1);
+		generic_pulse_irq_line(dcs.cpu,  ADSP2105_IRQ1, 1);
 	}
 
 	/* store it */
diff -Nru src-old/mame/audio/depthch.c src/mame/audio/depthch.c
--- src-old/mame/audio/depthch.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/depthch.c	2012-02-19 02:53:16.000000000 +0100
@@ -13,8 +13,8 @@
 #define OUT_PORT_1_SONAR        0x08
 
 
-#define PLAY(samp,id,loop)      sample_start( samp, id, id, loop )
-#define STOP(samp,id)           sample_stop( samp, id )
+#define PLAY(samp,id,loop)      samp->start( id, id, loop )
+#define STOP(samp,id)           samp->stop( id )
 
 
 /* sample file names */
@@ -37,8 +37,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( depthch_audio )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(depthch_samples_interface)
+	MCFG_SAMPLES_ADD("samples", depthch_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
@@ -56,7 +55,7 @@
 WRITE8_HANDLER( depthch_audio_w )
 {
 	static int port1State = 0;
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int bitsChanged;
 	int bitsGoneHigh;
 	int bitsGoneLow;
diff -Nru src-old/mame/audio/gorf.c src/mame/audio/gorf.c
--- src-old/mame/audio/gorf.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/gorf.c	2012-02-19 02:53:16.000000000 +0100
@@ -112,7 +112,7 @@
 READ8_HANDLER( gorf_speech_r )
 {
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int Phoneme, Intonation;
 	int i = 0;
 	UINT8 data = offset >> 8;
@@ -126,7 +126,7 @@
 	logerror("Date : %d Speech : %s at intonation %d\n",Phoneme, PhonemeTable[Phoneme],Intonation);
 
 	if(Phoneme==63) {
-		sample_stop(samples, 0);
+		samples->stop(0);
 		if (strlen(state->m_totalword)>2) logerror("Clearing sample %s\n",state->m_totalword);
 		state->m_totalword[0] = 0;				   /* Clear the total word stack */
 		return data;
@@ -139,8 +139,8 @@
 		if (state->m_plural != 0) {
 			logerror("found a possible plural at %d\n",state->m_plural-1);
 			if (!strcmp("S",state->m_totalword)) {		   /* Plural check */
-				sample_start(samples, 0, num_samples-2, 0);	   /* play the sample at position of word */
-				sample_set_freq(samples, 0, 11025);    /* play at correct rate */
+				samples->start(0, num_samples-2);	   /* play the sample at position of word */
+				samples->set_frequency(0, 11025);    /* play at correct rate */
 				state->m_totalword[0] = 0;				   /* Clear the total word stack */
 				state->m_oldword[0] = 0;				   /* Clear the total word stack */
 				return data;
@@ -162,8 +162,8 @@
 			} else {
 				state->m_plural=0;
 			}
-			sample_start(samples, 0, i, 0);	                   /* play the sample at position of word */
-			sample_set_freq(samples, 0, 11025);       /* play at correct rate */
+			samples->start(0, i);	                   /* play the sample at position of word */
+			samples->set_frequency(0, 11025);       /* play at correct rate */
 			logerror("Playing sample %d",i);
 			state->m_totalword[0] = 0;				   /* Clear the total word stack */
 			return data;
@@ -177,6 +177,6 @@
 
 CUSTOM_INPUT( gorf_speech_status_r )
 {
-	device_t *samples = field.machine().device("samples");
-	return !sample_playing(samples, 0);
+	samples_device *samples = field.machine().device<samples_device>("samples");
+	return !samples->playing(0);
 }
diff -Nru src-old/mame/audio/gottlieb.c src/mame/audio/gottlieb.c
--- src-old/mame/audio/gottlieb.c	2011-12-28 14:23:49.000000000 +0100
+++ src/mame/audio/gottlieb.c	2012-02-19 02:53:16.000000000 +0100
@@ -31,7 +31,7 @@
 
 static void gottlieb1_sh_w(device_t *riot, UINT8 data);
 static void gottlieb2_sh_w(address_space *space, UINT8 data);
-static void trigger_sample(device_t *samples, UINT8 data);
+static void trigger_sample(samples_device *samples, UINT8 data);
 
 
 
@@ -62,7 +62,7 @@
 
 static void gottlieb1_sh_w(device_t *riot, UINT8 data)
 {
-	device_t *samples = riot->machine().device("samples");
+	samples_device *samples = riot->machine().device<samples_device>("samples");
 	int pa7 = (data & 0x0f) != 0xf;
 	int pa0_5 = ~data & 0x3f;
 
@@ -112,24 +112,24 @@
  *
  *************************************/
 
-static void play_sample(device_t *samples, const char *phonemes)
+static void play_sample(samples_device *samples, const char *phonemes)
 {
 	if (strcmp(phonemes, "[0] HEH3LOOW     AH1EH3I3YMTERI2NDAHN") == 0)	  /* Q-Bert - Hello, I am turned on */
-		sample_start(samples, 0, 42, 0);
+		samples->start(0, 42);
 	else if (strcmp(phonemes, "[0]BAH1EH1Y") == 0)							  /* Q-Bert - Bye, bye */
-		sample_start(samples, 0, 43, 0);
+		samples->start(0, 43);
 	else if (strcmp(phonemes, "[0]A2YHT LEH2FTTH") == 0)					  /* Reactor - Eight left */
-		sample_start(samples, 0, 0, 0);
+		samples->start(0, 0);
 	else if (strcmp(phonemes, "[0]SI3KS DTYN LEH2FTTH") == 0)				  /* Reactor - Sixteen left */
-		sample_start(samples, 0, 1, 0);
+		samples->start(0, 1);
 	else if (strcmp(phonemes, "[0]WO2RNYNG KO2R UH1NSDTABUH1L") == 0)		  /* Reactor - Warning core unstable */
-		sample_start(samples, 0, 5, 0);
+		samples->start(0, 5);
 	else if (strcmp(phonemes, "[0]CHAMBERR   AE1EH2KTI1VA1I3DTEH1DT ") == 0) /* Reactor - Chamber activated */
-		sample_start(samples, 0, 7, 0);
+		samples->start(0, 7);
 }
 
 
-static void trigger_sample(device_t *samples, UINT8 data)
+static void trigger_sample(samples_device *samples, UINT8 data)
 {
 	gottlieb_state *state = samples->machine().driver_data<gottlieb_state>();
 	/* Reactor samples */
@@ -141,7 +141,7 @@
 			case 56:
 			case 57:
 			case 59:
-				sample_start(samples, 0, data - 53, 0);
+				samples->start(0, data - 53);
 				break;
 
 			case 31:
@@ -151,7 +151,7 @@
 			case 39:
 				state->m_score_sample++;
 				if (state->m_score_sample < 20)
-					sample_start(samples, 0, state->m_score_sample, 0);
+					samples->start(0, state->m_score_sample);
 				break;
 		}
 	}
@@ -166,16 +166,16 @@
 			case 19:
 			case 20:
 			case 21:
-				sample_start(samples, 0, (data - 17) * 8 + state->m_random_offset, 0);
+				samples->start(0, (data - 17) * 8 + state->m_random_offset);
 				state->m_random_offset = (state->m_random_offset + 1) & 7;
 				break;
 
 			case 22:
-				sample_start(samples, 0,40,0);
+				samples->start(0,40);
 				break;
 
 			case 23:
-				sample_start(samples, 0,41,0);
+				samples->start(0,41);
 				break;
 		}
 	}
@@ -185,12 +185,12 @@
 #ifdef UNUSED_FUNCTION
 void gottlieb_knocker(running_machine &machine)
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	if (!strcmp(machine.system().name,"reactor"))	/* reactor */
 	{
 	}
 	else if (samples != NULL)	/* qbert */
-		sample_start(samples, 0,44,0);
+		samples->start(0,44);
 }
 #endif
 
@@ -234,7 +234,7 @@
 	{
 		if (state->m_votrax_queuepos > 1)
 		{
-			device_t *samples = space->machine().device("samples");
+			samples_device *samples = space->machine().device<samples_device>("samples");
 			int last = -1;
 			int i;
 			char phonemes[200];
diff -Nru src-old/mame/audio/gotya.c src/mame/audio/gotya.c
--- src-old/mame/audio/gotya.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/gotya.c	2012-02-19 02:53:16.000000000 +0100
@@ -46,7 +46,7 @@
 
 	if (data == 0)
 	{
-		sample_stop(state->m_samples, 0);
+		state->m_samples->stop(0);
 		state->m_theme_playing = 0;
 		return;
 	}
@@ -62,7 +62,7 @@
 				return;
 			}
 
-			sample_start(state->m_samples, gotya_samples[sample_number].channel, sample_number, gotya_samples[sample_number].looping);
+			state->m_samples->start(gotya_samples[sample_number].channel, sample_number, gotya_samples[sample_number].looping);
 
 			if (gotya_samples[sample_number].channel == 0)
 			{
diff -Nru src-old/mame/audio/gridlee.c src/mame/audio/gridlee.c
--- src-old/mame/audio/gridlee.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/gridlee.c	2012-02-19 02:53:16.000000000 +0100
@@ -24,7 +24,7 @@
 
 	/* sound streaming variables */
 	sound_stream *m_stream;
-	device_t *m_samples;
+	samples_device *m_samples;
 	double m_freq_to_step;
 	UINT8 m_sound_data[24];
 };
@@ -74,7 +74,7 @@
 	/* allocate the stream */
 	state->m_stream = device->machine().sound().stream_alloc(*device, 0, 1, machine.sample_rate(), NULL, gridlee_stream_update);
 
-	state->m_samples = device->machine().device("samples");
+	state->m_samples = device->machine().device<samples_device>("samples");
 
 	state->m_freq_to_step = (double)(1 << 24) / (double)machine.sample_rate();
 }
@@ -102,7 +102,7 @@
 {
 	gridlee_sound_state *state = get_safe_token(device);
 	UINT8 *sound_data = state->m_sound_data;
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 
 	state->m_stream->update();
 
@@ -110,13 +110,13 @@
 	{
 		case 0x04:
 			if (data == 0xef && sound_data[offset] != 0xef)
-				sample_start(samples, 4, 1, 0);
+				samples->start(4, 1);
 			else if (data != 0xef && sound_data[offset] == 0xef)
-				sample_stop(samples, 4);
+				samples->stop(4);
 //          if (!(data & 0x01) && (sound_data[offset] & 0x01))
-//              sample_start(samples, 5, 1, 0);
+//              samples->start(5, 1);
 //          else if ((data & 0x01) && !(sound_data[offset] & 0x01))
-//              sample_stop(samples, 5);
+//              samples->stop(5);
 			break;
 
 		case 0x0c:
@@ -124,9 +124,9 @@
 		case 0x0e:
 		case 0x0f:
 			if ((data & 1) && !(sound_data[offset] & 1))
-				sample_start(samples, offset - 0x0c, 1 - sound_data[offset - 4], 0);
+				samples->start(offset - 0x0c, 1 - sound_data[offset - 4]);
 			else if (!(data & 1) && (sound_data[offset] & 1))
-				sample_stop(samples, offset - 0x0c);
+				samples->stop(offset - 0x0c);
 			break;
 
 		case 0x08+0x08:
diff -Nru src-old/mame/audio/invinco.c src/mame/audio/invinco.c
--- src-old/mame/audio/invinco.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/invinco.c	2012-02-19 02:53:16.000000000 +0100
@@ -15,8 +15,8 @@
 #define OUT_PORT_2_SHIPHIT		0x80
 
 
-#define PLAY(samp,id,loop)      sample_start( samp, id, id, loop )
-#define STOP(samp,id)           sample_stop( samp, id )
+#define PLAY(samp,id,loop)      samp->start( id, id, loop )
+#define STOP(samp,id)           samp->stop( id )
 
 
 /* sample file names */
@@ -43,8 +43,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( invinco_audio )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(invinco_samples_interface)
+	MCFG_SAMPLES_ADD("samples", invinco_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
@@ -66,7 +65,7 @@
 WRITE8_HANDLER( invinco_audio_w )
 {
 	static int port2State = 0;
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int bitsChanged;
 	//int bitsGoneHigh;
 	int bitsGoneLow;
diff -Nru src-old/mame/audio/meadows.c src/mame/audio/meadows.c
--- src-old/mame/audio/meadows.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/meadows.c	2012-02-19 02:53:16.000000000 +0100
@@ -30,7 +30,7 @@
 /************************************/
 SAMPLES_START( meadows_sh_start )
 {
-	meadows_state *state = device->machine().driver_data<meadows_state>();
+	meadows_state *state = device.machine().driver_data<meadows_state>();
 	state->m_0c00 = state->m_0c01 = state->m_0c02 = state->m_0c03 = 0;
 	state->m_dac = 0;
 	state->m_dac_enable = 0;
@@ -38,10 +38,10 @@
 	state->m_freq1 = state->m_freq2 = 1000;
 	state->m_latched_0c01 = state->m_latched_0c02 = state->m_latched_0c03 = 0;
 
-	sample_set_volume(device,0,0);
-	sample_start_raw(device,0,waveform,ARRAY_LENGTH(waveform),state->m_freq1,1);
-	sample_set_volume(device,1,0);
-	sample_start_raw(device,1,waveform,ARRAY_LENGTH(waveform),state->m_freq2,1);
+	device.set_volume(0,0);
+	device.start_raw(0,waveform,ARRAY_LENGTH(waveform),state->m_freq1,true);
+	device.set_volume(1,0);
+	device.start_raw(1,waveform,ARRAY_LENGTH(waveform),state->m_freq2,true);
 }
 
 /************************************/
@@ -50,7 +50,7 @@
 void meadows_sh_update(running_machine &machine)
 {
 	meadows_state *state = machine.driver_data<meadows_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	int preset, amp;
 
 	if (state->m_latched_0c01 != state->m_0c01 || state->m_latched_0c03 != state->m_0c03)
@@ -67,8 +67,8 @@
 			state->m_freq1 = BASE_CTR1 / (preset + 1);
 		else amp = 0;
 		logerror("meadows ctr1 channel #%d preset:%3d freq:%5d amp:%d\n", state->m_channel, preset, state->m_freq1, amp);
-		sample_set_freq(samples, 0, state->m_freq1 * sizeof(waveform)/2);
-		sample_set_volume(samples, 0,amp/255.0);
+		samples->set_frequency(0, state->m_freq1 * sizeof(waveform)/2);
+		samples->set_volume(0,amp/255.0);
 	}
 
 	if (state->m_latched_0c02 != state->m_0c02 || state->m_latched_0c03 != state->m_0c03)
@@ -85,8 +85,8 @@
 		}
 		else amp = 0;
 		logerror("meadows ctr2 channel #%d preset:%3d freq:%5d amp:%d\n", state->m_channel+1, preset, state->m_freq2, amp);
-		sample_set_freq(samples, 1, state->m_freq2 * sizeof(waveform));
-		sample_set_volume(samples, 1,amp/255.0);
+		samples->set_frequency(1, state->m_freq2 * sizeof(waveform));
+		samples->set_volume(1,amp/255.0);
 	}
 
 	if (state->m_latched_0c03 != state->m_0c03)
diff -Nru src-old/mame/audio/mw8080bw.c src/mame/audio/mw8080bw.c
--- src-old/mame/audio/mw8080bw.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/mw8080bw.c	2012-02-19 02:53:16.000000000 +0100
@@ -157,8 +157,7 @@
 	MCFG_SOUND_START(samples)
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(seawolf_samples_interface)
+	MCFG_SAMPLES_ADD("samples", seawolf_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.6)
 MACHINE_CONFIG_END
 
@@ -169,19 +168,19 @@
 	UINT8 rising_bits = data & ~state->m_port_1_last;
 
 	/* if (data & 0x01)  enable SHIP HIT sound */
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 0, 0);
+	if (rising_bits & 0x01) state->m_samples->start(0, 0);
 
 	/* if (data & 0x02)  enable TORPEDO sound */
-	if (rising_bits & 0x02) sample_start(state->m_samples, 1, 1, 0);
+	if (rising_bits & 0x02) state->m_samples->start(1, 1);
 
 	/* if (data & 0x04)  enable DIVE sound */
-	if (rising_bits & 0x04) sample_start(state->m_samples, 2, 2, 0);
+	if (rising_bits & 0x04) state->m_samples->start(2, 2);
 
 	/* if (data & 0x08)  enable SONAR sound */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 3, 3, 0);
+	if (rising_bits & 0x08) state->m_samples->start(3, 3);
 
 	/* if (data & 0x10)  enable MINE HIT sound */
-	if (rising_bits & 0x10) sample_start(state->m_samples, 4, 4, 0);
+	if (rising_bits & 0x10) state->m_samples->start(4, 4);
 
 	coin_counter_w(space->machine(), 0, (data >> 5) & 0x01);
 
@@ -219,12 +218,10 @@
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("samples1", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gunfight_samples_interface)
+	MCFG_SAMPLES_ADD("samples1", gunfight_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 
-	MCFG_SOUND_ADD("samples2", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gunfight_samples_interface)
+	MCFG_SAMPLES_ADD("samples2", gunfight_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 MACHINE_CONFIG_END
 
@@ -245,22 +242,22 @@
 
 	case 0x01:
 		/* enable LEFT SHOOT sound (left speaker) */
-		sample_start(state->m_samples1, 0, 0, 0);
+		state->m_samples1->start(0, 0);
 		break;
 
 	case 0x02:
 		/* enable RIGHT SHOOT sound (right speaker) */
-		sample_start(state->m_samples2, 0, 0, 0);
+		state->m_samples2->start(0, 0);
 		break;
 
 	case 0x03:
 		/* enable LEFT HIT sound (left speaker) */
-		sample_start(state->m_samples1, 0, 1, 0);
+		state->m_samples1->start(0, 1);
 		break;
 
 	case 0x04:
 		/* enable RIGHT HIT sound (right speaker) */
-		sample_start(state->m_samples2, 0, 1, 0);
+		state->m_samples2->start(0, 1);
 		break;
 
 	default:
@@ -1577,12 +1574,10 @@
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("samples1", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gmissile_samples_interface)
+	MCFG_SAMPLES_ADD("samples1", gmissile_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 1.9)
 
-	MCFG_SOUND_ADD("samples2", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gmissile_samples_interface)
+	MCFG_SAMPLES_ADD("samples2", gmissile_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 1.9)
 MACHINE_CONFIG_END
 
@@ -1603,18 +1598,18 @@
 	space->machine().sound().system_enable((data >> 3) & 0x01);
 
 	/* if (data & 0x10)  enable RIGHT MISSILE sound (goes to right speaker) */
-	if (rising_bits & 0x10) sample_start(state->m_samples2, 0, 0, 0);
+	if (rising_bits & 0x10) state->m_samples2->start(0, 0);
 
 	/* if (data & 0x20)  enable LEFT EXPLOSION sound (goes to left speaker) */
 	output_set_value("L_EXP_LIGHT", (data >> 5) & 0x01);
-	if (rising_bits & 0x20) sample_start(state->m_samples1, 0, 1, 0);
+	if (rising_bits & 0x20) state->m_samples1->start(0, 1);
 
 	/* if (data & 0x40)  enable LEFT MISSILE sound (goes to left speaker) */
-	if (rising_bits & 0x40) sample_start(state->m_samples1, 0, 0, 0);
+	if (rising_bits & 0x40) state->m_samples1->start(0, 0);
 
 	/* if (data & 0x80)  enable RIGHT EXPLOSION sound (goes to right speaker) */
 	output_set_value("R_EXP_LIGHT", (data >> 7) & 0x01);
-	if (rising_bits & 0x80) sample_start(state->m_samples2, 0, 1, 0);
+	if (rising_bits & 0x80) state->m_samples2->start(0, 1);
 
 	state->m_port_1_last = data;
 }
@@ -1676,12 +1671,10 @@
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("samples1", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(m4_samples_interface)
+	MCFG_SAMPLES_ADD("samples1", m4_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 1)
 
-	MCFG_SOUND_ADD("samples2", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(m4_samples_interface)
+	MCFG_SAMPLES_ADD("samples2", m4_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 1)
 MACHINE_CONFIG_END
 
@@ -1698,16 +1691,16 @@
 	space->machine().sound().system_enable((data >> 3) & 0x01);
 
 	/* if (data & 0x10)  enable LEFT PLAYER SHOT sound (goes to left speaker) */
-	if (rising_bits & 0x10) sample_start(state->m_samples1, 0, 0, 0);
+	if (rising_bits & 0x10) state->m_samples1->start(0, 0);
 
 	/* if (data & 0x20)  enable RIGHT PLAYER SHOT sound (goes to right speaker) */
-	if (rising_bits & 0x20) sample_start(state->m_samples2, 0, 0, 0);
+	if (rising_bits & 0x20) state->m_samples2->start(0, 0);
 
 	/* if (data & 0x40)  enable LEFT PLAYER EXPLOSION sound via 300K res (goes to left speaker) */
-	if (rising_bits & 0x40) sample_start(state->m_samples1, 1, 1, 0);
+	if (rising_bits & 0x40) state->m_samples1->start(1, 1);
 
 	/* if (data & 0x80)  enable RIGHT PLAYER EXPLOSION sound via 300K res (goes to right speaker) */
-	if (rising_bits & 0x80) sample_start(state->m_samples2, 1, 1, 0);
+	if (rising_bits & 0x80) state->m_samples2->start(1, 1);
 
 	state->m_port_1_last = data;
 }
@@ -1719,10 +1712,10 @@
 	UINT8 rising_bits = data & ~state->m_port_2_last;
 
 	/* if (data & 0x01)  enable LEFT PLAYER EXPLOSION sound via 510K res (goes to left speaker) */
-	if (rising_bits & 0x01) sample_start(state->m_samples1, 1, 1, 0);
+	if (rising_bits & 0x01) state->m_samples1->start(1, 1);
 
 	/* if (data & 0x02)  enable RIGHT PLAYER EXPLOSION sound via 510K res (goes to right speaker) */
-	if (rising_bits & 0x02) sample_start(state->m_samples2, 1, 1, 0);
+	if (rising_bits & 0x02) state->m_samples2->start(1, 1);
 
 	/* if (data & 0x04)  enable LEFT TANK MOTOR sound (goes to left speaker) */
 
@@ -1938,8 +1931,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(clowns_samples_interface)
+	MCFG_SAMPLES_ADD("samples", clowns_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.70)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
@@ -1974,7 +1966,7 @@
 
 	discrete_sound_w(device, CLOWNS_SPRINGBOARD_HIT_EN, (data >> 4) & 0x01);
 
-	if (rising_bits & 0x20) sample_start(state->m_samples, 0, 0, 0);  /* springboard miss */
+	if (rising_bits & 0x20) state->m_samples->start(0, 0);  /* springboard miss */
 
 	/* D6 and D7 are not connected */
 
@@ -3341,8 +3333,7 @@
 	MCFG_SOUND_START(samples)
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(phantom2_samples_interface)
+	MCFG_SAMPLES_ADD("samples", phantom2_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1)
 MACHINE_CONFIG_END
 
@@ -3353,7 +3344,7 @@
 	UINT8 rising_bits = data & ~state->m_port_1_last;
 
 	/* if (data & 0x01)  enable PLAYER SHOT sound */
-	if (rising_bits & 0x01) sample_start(state->m_samples, 0, 0, 0);
+	if (rising_bits & 0x01) state->m_samples->start(0, 0);
 
 	/* if (data & 0x02)  enable ENEMY SHOT sound */
 
@@ -3378,7 +3369,7 @@
 	/* D0-D2 are not connected */
 
 	/* if (data & 0x08)  enable EXPLOSION sound */
-	if (rising_bits & 0x08) sample_start(state->m_samples, 1, 1, 0);
+	if (rising_bits & 0x08) state->m_samples->start(1, 1);
 
 	output_set_value("EXPLAMP", (data >> 4) & 0x01);
 
@@ -3628,8 +3619,7 @@
 	MCFG_SOUND_CONFIG(invaders_sn76477_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(invaders_samples_interface)
+	MCFG_SAMPLES_ADD("samples", invaders_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/audio/n8080.c src/mame/audio/n8080.c
--- src-old/mame/audio/n8080.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/n8080.c	2012-02-11 11:06:43.000000000 +0100
@@ -191,7 +191,7 @@
 	}
 	if (changes & ((1 << 0x2) | (1 << 0x3) | (1 << 0x5)))
 	{
-		generic_pulse_irq_line(machine.device("audiocpu"), 0);
+		generic_pulse_irq_line(machine.device("audiocpu"), 0, 2);
 	}
 }
 
@@ -216,7 +216,7 @@
 	}
 	if (changes & ((1 << 0x2) | (1 << 0x3) | (1 << 0x5)))
 	{
-		generic_pulse_irq_line(machine.device("audiocpu"), 0);
+		generic_pulse_irq_line(machine.device("audiocpu"), 0, 2);
 	}
 }
 
@@ -232,7 +232,7 @@
 
 	if (changes & (1 << 6))
 	{
-		generic_pulse_irq_line(machine.device("audiocpu"), 0);
+		generic_pulse_irq_line(machine.device("audiocpu"), 0, 2);
 	}
 }
 
diff -Nru src-old/mame/audio/polyplay.c src/mame/audio/polyplay.c
--- src-old/mame/audio/polyplay.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/polyplay.c	2012-02-19 02:53:16.000000000 +0100
@@ -20,7 +20,7 @@
 
 SAMPLES_START( polyplay_sh_start )
 {
-	polyplay_state *state = device->machine().driver_data<polyplay_state>();
+	polyplay_state *state = device.machine().driver_data<polyplay_state>();
 	int i;
 
 	for (i = 0; i < SAMPLE_LENGTH / 2; i++) {
@@ -49,29 +49,29 @@
 void polyplay_play_channel1(running_machine &machine, int data)
 {
 	polyplay_state *state = machine.driver_data<polyplay_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	if (data) {
 		state->m_freq1 = 2457600 / 16 / data / 8;
-		sample_set_volume(samples, 0, state->m_channel_playing1 * 1.0);
-		sample_start_raw(samples, 0, state->m_backgroundwave, ARRAY_LENGTH(state->m_backgroundwave), sizeof(state->m_backgroundwave)*state->m_freq1,1);
+		samples->set_volume(0, state->m_channel_playing1 * 1.0);
+		samples->start_raw(0, state->m_backgroundwave, ARRAY_LENGTH(state->m_backgroundwave), sizeof(state->m_backgroundwave)*state->m_freq1,true);
 	}
 	else {
-		sample_stop(samples, 0);
-		sample_stop(samples, 1);
+		samples->stop(0);
+		samples->stop(1);
 	}
 }
 
 void polyplay_play_channel2(running_machine &machine, int data)
 {
 	polyplay_state *state = machine.driver_data<polyplay_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	if (data) {
 		state->m_freq2 = 2457600 / 16 / data / 8;
-		sample_set_volume(samples, 1, state->m_channel_playing2 * 1.0);
-		sample_start_raw(samples, 1, state->m_backgroundwave, ARRAY_LENGTH(state->m_backgroundwave), sizeof(state->m_backgroundwave)*state->m_freq2,1);
+		samples->set_volume(1, state->m_channel_playing2 * 1.0);
+		samples->start_raw(1, state->m_backgroundwave, ARRAY_LENGTH(state->m_backgroundwave), sizeof(state->m_backgroundwave)*state->m_freq2,true);
 	}
 	else {
-		sample_stop(samples, 0);
-		sample_stop(samples, 1);
+		samples->stop(0);
+		samples->stop(1);
 	}
 }
diff -Nru src-old/mame/audio/pulsar.c src/mame/audio/pulsar.c
--- src-old/mame/audio/pulsar.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/pulsar.c	2012-02-19 02:53:16.000000000 +0100
@@ -28,8 +28,8 @@
 #define OUT_PORT_2_MOVMAZE		0x10
 
 
-#define PLAY(samp,id,loop)           sample_start( samp, id, id, loop )
-#define STOP(samp,id)                sample_stop( samp, id )
+#define PLAY(samp,id,loop)           samp->start( id, id, loop )
+#define STOP(samp,id)                samp->stop( id )
 
 
 /* sample file names */
@@ -60,8 +60,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( pulsar_audio )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(pulsar_samples_interface)
+	MCFG_SAMPLES_ADD("samples", pulsar_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
@@ -88,7 +87,7 @@
 
 WRITE8_HANDLER( pulsar_audio_1_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int bitsChanged;
 	//int bitsGoneHigh;
 	int bitsGoneLow;
@@ -139,7 +138,7 @@
 
 WRITE8_HANDLER( pulsar_audio_2_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	static int port2State = 0;
 	int bitsChanged;
 	int bitsGoneHigh;
@@ -159,7 +158,7 @@
 
 	if ( bitsGoneLow & OUT_PORT_2_GATE )
 	{
-		sample_start( samples, SND_CLANG, SND_GATE, 0 );
+		samples->start(SND_CLANG, SND_GATE);
 	}
 	if ( bitsGoneHigh & OUT_PORT_2_GATE )
 	{
diff -Nru src-old/mame/audio/segag80r.c src/mame/audio/segag80r.c
--- src-old/mame/audio/segag80r.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/segag80r.c	2012-02-19 02:53:16.000000000 +0100
@@ -190,8 +190,7 @@
 	MCFG_SOUND_START(astrob)
 
 	/* sound hardware */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(astrob_samples_interface)
+	MCFG_SAMPLES_ADD("samples", astrob_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
@@ -225,7 +224,7 @@
 	{
 		120.0f, 82.0f, 62.0f, 56.0f, 47.0f, 39.0f, 33.0f, 27.0f, 24.0f, 22.0f
 	};
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	float freq_factor;
 
 	UINT8 diff = data ^ state->m_sound_state[offset];
@@ -235,54 +234,54 @@
 	{
 		case 0:
 			/* INVADER-1: channel 0 */
-			if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 0, (data & 0x80) ? 0 : 1, TRUE);
-			if ((data & 0x01) && sample_playing(samples, 0)) sample_stop(samples, 0);
+			if ((diff & 0x01) && !(data & 0x01)) samples->start(0, (data & 0x80) ? 0 : 1, true);
+			if ((data & 0x01) && samples->playing(0)) samples->stop(0);
 
 			/* INVADER-2: channel 1 */
-			if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 1, (data & 0x80) ? 2 : 3, TRUE);
-			if ((data & 0x02) && sample_playing(samples, 1)) sample_stop(samples, 1);
+			if ((diff & 0x02) && !(data & 0x02)) samples->start(1, (data & 0x80) ? 2 : 3, true);
+			if ((data & 0x02) && samples->playing(1)) samples->stop(1);
 
 			/* INVADER-3: channel 2 */
-			if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 2, (data & 0x80) ? 4 : 5, TRUE);
-			if ((data & 0x04) && sample_playing(samples, 2)) sample_stop(samples, 2);
+			if ((diff & 0x04) && !(data & 0x04)) samples->start(2, (data & 0x80) ? 4 : 5, true);
+			if ((data & 0x04) && samples->playing(2)) samples->stop(2);
 
 			/* INVADER-4: channel 3 */
-			if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 3, (data & 0x80) ? 6 : 7, TRUE);
-			if ((data & 0x08) && sample_playing(samples, 3)) sample_stop(samples, 3);
+			if ((diff & 0x08) && !(data & 0x08)) samples->start(3, (data & 0x80) ? 6 : 7, true);
+			if ((data & 0x08) && samples->playing(3)) samples->stop(3);
 
 			/* ASTROIDS: channel 4 */
-			if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 4, 8, TRUE);
-			if ((data & 0x10) && sample_playing(samples, 4)) sample_stop(samples, 4);
+			if ((diff & 0x10) && !(data & 0x10)) samples->start(4, 8, true);
+			if ((data & 0x10) && samples->playing(4)) samples->stop(4);
 
 			/* MUTE */
 			space->machine().sound().system_mute(data & 0x20);
 
 			/* REFILL: channel 5 */
-			if (!(data & 0x40) && !sample_playing(samples, 5)) sample_start(samples, 5, 9, FALSE);
-			if ( (data & 0x40) && sample_playing(samples, 5))  sample_stop(samples, 5);
+			if (!(data & 0x40) && !samples->playing(5)) samples->start(5, 9);
+			if ( (data & 0x40) && samples->playing(5))  samples->stop(5);
 
 			/* WARP: changes which sample is played for the INVADER samples above */
 			if (diff & 0x80)
 			{
-				if (sample_playing(samples, 0)) sample_start(samples, 0, (data & 0x80) ? 0 : 1, TRUE);
-				if (sample_playing(samples, 1)) sample_start(samples, 1, (data & 0x80) ? 2 : 3, TRUE);
-				if (sample_playing(samples, 2)) sample_start(samples, 2, (data & 0x80) ? 4 : 5, TRUE);
-				if (sample_playing(samples, 3)) sample_start(samples, 3, (data & 0x80) ? 6 : 7, TRUE);
+				if (samples->playing(0)) samples->start(0, (data & 0x80) ? 0 : 1, true);
+				if (samples->playing(1)) samples->start(1, (data & 0x80) ? 2 : 3, true);
+				if (samples->playing(2)) samples->start(2, (data & 0x80) ? 4 : 5, true);
+				if (samples->playing(3)) samples->start(3, (data & 0x80) ? 6 : 7, true);
 			}
 			break;
 
 		case 1:
 			/* LASER #1: channel 6 */
-			if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 6, 10, FALSE);
+			if ((diff & 0x01) && !(data & 0x01)) samples->start(6, 10);
 
 			/* LASER #2: channel 7 */
-			if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 7, 11, FALSE);
+			if ((diff & 0x02) && !(data & 0x02)) samples->start(7, 11);
 
 			/* SHORT EXPL: channel 8 */
-			if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 8, 12, FALSE);
+			if ((diff & 0x04) && !(data & 0x04)) samples->start(8, 12);
 
 			/* LONG EXPL: channel 8 */
-			if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 8, 13, FALSE);
+			if ((diff & 0x08) && !(data & 0x08)) samples->start(8, 13);
 
 			/* ATTACK RATE */
 			if ((diff & 0x10) && !(data & 0x10)) state->m_sound_rate = (state->m_sound_rate + 1) % 10;
@@ -291,10 +290,10 @@
 			if (!(data & 0x20)) state->m_sound_rate = 0;
 
 			/* BONUS: channel 9 */
-			if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 9, 14, FALSE);
+			if ((diff & 0x40) && !(data & 0x40)) samples->start(9, 14);
 
 			/* SONAR: channel 10 */
-			if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 10, 15, FALSE);
+			if ((diff & 0x80) && !(data & 0x80)) samples->start(10, 15);
 			break;
 	}
 
@@ -308,10 +307,10 @@
 
 	/* adjust the sample rate of invader sounds based the sound_rate */
 	/* this is an approximation */
-	if (sample_playing(samples, 0)) sample_set_freq(samples, 0, sample_get_base_freq(samples, 0) * freq_factor);
-	if (sample_playing(samples, 1)) sample_set_freq(samples, 1, sample_get_base_freq(samples, 1) * freq_factor);
-	if (sample_playing(samples, 2)) sample_set_freq(samples, 2, sample_get_base_freq(samples, 2) * freq_factor);
-	if (sample_playing(samples, 3)) sample_set_freq(samples, 3, sample_get_base_freq(samples, 3) * freq_factor);
+	if (samples->playing(0)) samples->set_frequency(0, samples->base_frequency(0) * freq_factor);
+	if (samples->playing(1)) samples->set_frequency(1, samples->base_frequency(1) * freq_factor);
+	if (samples->playing(2)) samples->set_frequency(2, samples->base_frequency(2) * freq_factor);
+	if (samples->playing(3)) samples->set_frequency(3, samples->base_frequency(3) * freq_factor);
 }
 
 
@@ -422,8 +421,7 @@
 	/* sound hardware */
 	MCFG_SOUND_START(sega005)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(sega005_samples_interface)
+	MCFG_SAMPLES_ADD("samples", sega005_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("005", SEGA005, 0)
@@ -459,32 +457,32 @@
 static WRITE8_DEVICE_HANDLER( sega005_sound_a_w )
 {
 	segag80r_state *state = device->machine().driver_data<segag80r_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[0];
 	state->m_sound_state[0] = data;
 
 	/* LARGE EXPL: channel 0 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 0, 0, FALSE);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(0, 0);
 
 	/* SMALL EXPL: channel 1 */
-	if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 1, 1, FALSE);
+	if ((diff & 0x02) && !(data & 0x02)) samples->start(1, 1);
 
 	/* DROP BOMB: channel 2 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 2, 2, FALSE);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(2, 2);
 
 	/* SHOOT PISTOL: channel 3 */
-	if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 3, 3, FALSE);
+	if ((diff & 0x08) && !(data & 0x08)) samples->start(3, 3);
 
 	/* MISSILE: channel 4 */
-	if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 4, 4, FALSE);
+	if ((diff & 0x10) && !(data & 0x10)) samples->start(4, 4);
 
 	/* HELICOPTER: channel 5 */
-	if ((diff & 0x20) && !(data & 0x20) && !sample_playing(samples, 5)) sample_start(samples, 5, 5, TRUE);
-	if ((diff & 0x20) &&  (data & 0x20)) sample_stop(samples, 5);
+	if ((diff & 0x20) && !(data & 0x20) && !samples->playing(5)) samples->start(5, 5, true);
+	if ((diff & 0x20) &&  (data & 0x20)) samples->stop(5);
 
 	/* WHISTLE: channel 6 */
-	if ((diff & 0x40) && !(data & 0x40) && !sample_playing(samples, 6)) sample_start(samples, 6, 6, TRUE);
-	if ((diff & 0x40) &&  (data & 0x40)) sample_stop(samples, 6);
+	if ((diff & 0x40) && !(data & 0x40) && !samples->playing(6)) samples->start(6, 6, true);
+	if ((diff & 0x40) &&  (data & 0x40)) samples->stop(6);
 }
 
 
@@ -664,8 +662,7 @@
 	/* sound hardware */
 	MCFG_SOUND_START(spaceod)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(spaceod_samples_interface)
+	MCFG_SAMPLES_ADD("samples", spaceod_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
@@ -694,7 +691,7 @@
 WRITE8_HANDLER( spaceod_sound_w )
 {
 	segag80r_state *state = space->machine().driver_data<segag80r_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[offset];
 	state->m_sound_state[offset] = data;
 
@@ -702,40 +699,40 @@
 	{
 		case 0:
 			/* BACK G: channel 0 */
-			if ((diff & 0x01) && !(data & 0x01) && !sample_playing(samples, 0)) sample_start(samples, 0, 7, TRUE);
-			if ((diff & 0x01) &&  (data & 0x01)) sample_stop(samples, 0);
+			if ((diff & 0x01) && !(data & 0x01) && !samples->playing(0)) samples->start(0, 7, true);
+			if ((diff & 0x01) &&  (data & 0x01)) samples->stop(0);
 
 			/* SHORT EXP: channel 1 */
-			if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 1, 2, FALSE);
+			if ((diff & 0x04) && !(data & 0x04)) samples->start(1, 2);
 
 			/* ACCELERATE: channel 2 */
-			if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 2, 8, FALSE);
+			if ((diff & 0x10) && !(data & 0x10)) samples->start(2, 8);
 
 			/* BATTLE STAR: channel 3 */
-			if ((diff & 0x20) && !(data & 0x20)) sample_start(samples, 3, 10, FALSE);
+			if ((diff & 0x20) && !(data & 0x20)) samples->start(3, 10);
 
 			/* D BOMB: channel 4 */
-			if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 4, 1, FALSE);
+			if ((diff & 0x40) && !(data & 0x40)) samples->start(4, 1);
 
 			/* LONG EXP: channel 5 */
-			if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 5, 3, FALSE);
+			if ((diff & 0x80) && !(data & 0x80)) samples->start(5, 3);
 			break;
 
 		case 1:
 			/* SHOT: channel 6 */
-			if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 6, 0, FALSE);
+			if ((diff & 0x01) && !(data & 0x01)) samples->start(6, 0);
 
 			/* BONUS UP: channel 7 */
-			if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 7, 6, FALSE);
+			if ((diff & 0x02) && !(data & 0x02)) samples->start(7, 6);
 
 			/* WARP: channel 8 */
-			if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 8, 4, FALSE);
+			if ((diff & 0x08) && !(data & 0x08)) samples->start(8, 4);
 
 			/* APPEARANCE UFO: channel 9 */
-			if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 9, 5, FALSE);
+			if ((diff & 0x40) && !(data & 0x40)) samples->start(9, 5);
 
 			/* BLACK HOLE: channel 10 */
-			if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 10, 9, FALSE);
+			if ((diff & 0x80) && !(data & 0x80)) samples->start(10, 9);
 			break;
 	}
 }
@@ -841,8 +838,7 @@
 	/* sound hardware */
 	MCFG_SOUND_START(monsterb)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(monsterb_samples_interface)
+	MCFG_SAMPLES_ADD("samples", monsterb_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("music", TMS36XX, 247)
@@ -902,15 +898,15 @@
 static WRITE8_DEVICE_HANDLER( monsterb_sound_b_w )
 {
 	segag80r_state *state = device->machine().driver_data<segag80r_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
 
 	/* SHOT: channel 0 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 0, 0, FALSE);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(0, 0);
 
 	/* DIVE: channel 1 */
-	if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 1, 1, FALSE);
+	if ((diff & 0x02) && !(data & 0x02)) samples->start(1, 1);
 
     /* TODO: D7 on Port B might affect TMS3617 output (mute?) */
 }
diff -Nru src-old/mame/audio/segag80v.c src/mame/audio/segag80v.c
--- src-old/mame/audio/segag80v.c	2011-03-29 16:50:04.000000000 +0200
+++ src/mame/audio/segag80v.c	2012-02-19 02:53:16.000000000 +0100
@@ -137,197 +137,197 @@
 
 WRITE8_HANDLER( elim1_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	data ^= 0xff;
 
 	/* Play fireball sample */
 	if (data & 0x02)
-		sample_start (samples, 0, 0, 0);
+		samples->start(0, 0);
 
 	/* Play explosion samples */
 	if (data & 0x04)
-		sample_start (samples, 1, 10, 0);
+		samples->start(1, 10);
 	if (data & 0x08)
-		sample_start (samples, 1, 9, 0);
+		samples->start(1, 9);
 	if (data & 0x10)
-		sample_start (samples, 1, 8, 0);
+		samples->start(1, 8);
 
 	/* Play bounce sample */
 	if (data & 0x20)
 	{
-		if (sample_playing(samples, 2))
-			sample_stop (samples, 2);
-		sample_start (samples, 2, 1, 0);
+		if (samples->playing(2))
+			samples->stop(2);
+		samples->start(2, 1);
 	}
 
 	/* Play lazer sample */
 	if (data & 0xc0)
 	{
-		if (sample_playing(samples, 3))
-			sample_stop (samples, 3);
-		sample_start (samples, 3, 5, 0);
+		if (samples->playing(3))
+			samples->stop(3);
+		samples->start(3, 5);
 	}
 }
 
 WRITE8_HANDLER( elim2_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	data ^= 0xff;
 
 	/* Play thrust sample */
 	if (data & 0x0f)
-		sample_start (samples, 4, 6, 0);
+		samples->start(4, 6);
 	else
-		sample_stop (samples, 4);
+		samples->stop(4);
 
 	/* Play skitter sample */
 	if (data & 0x10)
-		sample_start (samples, 5, 2, 0);
+		samples->start(5, 2);
 
 	/* Play eliminator sample */
 	if (data & 0x20)
-		sample_start (samples, 6, 3, 0);
+		samples->start(6, 3);
 
 	/* Play electron samples */
 	if (data & 0x40)
-		sample_start (samples, 7, 7, 0);
+		samples->start(7, 7);
 	if (data & 0x80)
-		sample_start (samples, 7, 4, 0);
+		samples->start(7, 4);
 }
 
 
 WRITE8_HANDLER( zektor1_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	data ^= 0xff;
 
 	/* Play fireball sample */
 	if (data & 0x02)
-                sample_start (samples, 0, 0, 0);
+                samples->start(0, 0);
 
 	/* Play explosion samples */
 	if (data & 0x04)
-                sample_start (samples, 1, 10, 0);
+                samples->start(1, 10);
 	if (data & 0x08)
-                  sample_start (samples, 1, 9, 0);
+                  samples->start(1, 9);
 	if (data & 0x10)
-                  sample_start (samples, 1, 8, 0);
+                  samples->start(1, 8);
 
 	/* Play bounce sample */
 	if (data & 0x20)
 	{
-                if (sample_playing(samples, 2))
-                        sample_stop (samples, 2);
-                sample_start (samples, 2, 1, 0);
+                if (samples->playing(2))
+                        samples->stop(2);
+                samples->start(2, 1);
 	}
 
 	/* Play lazer sample */
 	if (data & 0xc0)
 	{
-		if (sample_playing(samples, 3))
-			sample_stop (samples, 3);
-                sample_start (samples, 3, 5, 0);
+		if (samples->playing(3))
+			samples->stop(3);
+                samples->start(3, 5);
 	}
 }
 
 WRITE8_HANDLER( zektor2_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	data ^= 0xff;
 
 	/* Play thrust sample */
 	if (data & 0x0f)
-            sample_start (samples, 4, 6, 0);
+            samples->start(4, 6);
 	else
-		sample_stop (samples, 4);
+		samples->stop(4);
 
 	/* Play skitter sample */
 	if (data & 0x10)
-                sample_start (samples, 5, 2, 0);
+                samples->start(5, 2);
 
 	/* Play eliminator sample */
 	if (data & 0x20)
-                sample_start (samples, 6, 3, 0);
+                samples->start(6, 3);
 
 	/* Play electron samples */
 	if (data & 0x40)
-                sample_start (samples, 7, 40, 0);
+                samples->start(7, 40);
 	if (data & 0x80)
-                sample_start (samples, 7, 41, 0);
+                samples->start(7, 41);
 }
 
 
 
 WRITE8_HANDLER( spacfury1_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	data ^= 0xff;
 
 	/* craft growing */
 	if (data & 0x01)
-		sample_start (samples, 1, 0, 0);
+		samples->start(1, 0);
 
 	/* craft moving */
 	if (data & 0x02)
 	{
-		if (!sample_playing(samples, 2))
-			sample_start (samples, 2, 1, 1);
+		if (!samples->playing(2))
+			samples->start(2, 1, true);
 	}
 	else
-		sample_stop (samples, 2);
+		samples->stop(2);
 
 	/* Thrust */
 	if (data & 0x04)
 	{
-		if (!sample_playing(samples, 3))
-			sample_start (samples, 3, 4, 1);
+		if (!samples->playing(3))
+			samples->start(3, 4, true);
 	}
 	else
-		sample_stop (samples, 3);
+		samples->stop(3);
 
 	/* star spin */
 	if (data & 0x40)
-		sample_start (samples, 4, 8, 0);
+		samples->start(4, 8);
 
 	/* partial warship? */
 	if (data & 0x80)
-		sample_start (samples, 4, 9, 0);
+		samples->start(4, 9);
 
 }
 
 WRITE8_HANDLER( spacfury2_sh_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	data ^= 0xff;
 
 	/* craft joining */
 	if (data & 0x01)
-		sample_start (samples, 5, 2, 0);
+		samples->start(5, 2);
 
 	/* ship firing */
 	if (data & 0x02)
 	{
-		if (sample_playing(samples, 6))
-			sample_stop(samples, 6);
-		sample_start(samples, 6, 3, 0);
+		if (samples->playing(6))
+			samples->stop(6);
+		samples->start(6, 3);
 
 	}
 
 	/* fireball */
 	if (data & 0x04)
-		sample_start (samples, 7, 6, 0);
+		samples->start(7, 6);
 
 	/* small explosion */
 	if (data & 0x08)
-		sample_start (samples, 7, 6, 0);
+		samples->start(7, 6);
 	/* large explosion */
 	if (data & 0x10)
-		sample_start (samples, 7, 5, 0);
+		samples->start(7, 5);
 
 	/* docking bang */
 	if (data & 0x20)
-		sample_start (samples, 0, 7, 0);
+		samples->start(0, 7);
 
 }
 
diff -Nru src-old/mame/audio/senjyo.c src/mame/audio/senjyo.c
--- src-old/mame/audio/senjyo.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/senjyo.c	2012-02-19 02:53:16.000000000 +0100
@@ -52,13 +52,13 @@
 	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	state->m_single_volume = data & 0x0f;
-	sample_set_volume(samples, 0, state->m_single_volume / 15.0);
+	samples->set_volume(0, state->m_single_volume / 15.0);
 }
 
 
 static TIMER_CALLBACK( senjyo_sh_update )
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	senjyo_state *state = machine.driver_data<senjyo_state>();
 
 	/* ctc2 timer single tone generator frequency */
@@ -69,13 +69,13 @@
 	else
 		state->m_single_rate = 0;
 
-	sample_set_freq(samples, 0, state->m_single_rate);
+	samples->set_frequency(0, state->m_single_rate);
 }
 
 
 SAMPLES_START( senjyo_sh_start )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	senjyo_state *state = machine.driver_data<senjyo_state>();
 	int i;
 
@@ -87,8 +87,8 @@
 	/* CTC2 single tone generator */
 	state->m_single_rate = 1000;
 	state->m_single_volume = 0;
-	sample_set_volume(device, 0, state->m_single_volume / 15.0);
-	sample_start_raw(device, 0, state->m_single_data, SINGLE_LENGTH, state->m_single_rate, 1);
+	device.set_volume(0, state->m_single_volume / 15.0);
+	device.start_raw(0, state->m_single_data, SINGLE_LENGTH, state->m_single_rate, true);
 
 	machine.scheduler().timer_pulse(machine.primary_screen->frame_period(), FUNC(senjyo_sh_update));
 }
diff -Nru src-old/mame/audio/snk6502.c src/mame/audio/snk6502.c
--- src-old/mame/audio/snk6502.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/snk6502.c	2012-02-19 02:53:16.000000000 +0100
@@ -49,7 +49,7 @@
 	INT32 m_tone_clock;
 	sound_stream * m_tone_stream;
 
-	device_t *m_samples;
+	samples_device *m_samples;
 	UINT8 *m_ROM;
 	int m_Sound0StopOnRollover;
 	UINT8 m_LastPort1;
@@ -653,7 +653,7 @@
 {
 	snk6502_sound_state *state = get_safe_token(device);
 
-	state->m_samples = device->machine().device("samples");
+	state->m_samples = device->machine().device<samples_device>("samples");
 	state->m_ROM = device->machine().region("snk6502")->base();
 
 	// adjusted
@@ -695,7 +695,7 @@
 {
 	device_t *device = space->machine().device("snk6502");
 	snk6502_sound_state *state = get_safe_token(device);
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 	TONE *tone_channels = state->m_tone_channels;
 
 	switch (offset)
@@ -715,13 +715,13 @@
         */
 
 		if ((~data & 0x01) && (state->m_LastPort1 & 0x01))
-			sample_start(samples, 0, 0, 0);
+			samples->start(0, 0);
 		if ((~data & 0x02) && (state->m_LastPort1 & 0x02))
-			sample_start(samples, 1, 1, 0);
+			samples->start(1, 1);
 		if ((~data & 0x04) && (state->m_LastPort1 & 0x04))
-			sample_start(samples, 2, 2, 0);
+			samples->start(2, 2);
 		if ((~data & 0x08) && (state->m_LastPort1 & 0x08))
-			sample_start(samples, 3, 3, 0);
+			samples->start(3, 3);
 
 		if ((data & 0x80) && (~state->m_LastPort1 & 0x80))
 		{
@@ -765,7 +765,7 @@
 {
 	device_t *device = space->machine().device("snk6502");
 	snk6502_sound_state *state = get_safe_token(device);
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 	TONE *tone_channels = state->m_tone_channels;
 
 	switch (offset)
@@ -782,7 +782,7 @@
 
 		/* bit 2 = analog sound trigger */
 		if (data & 0x04 && !(state->m_LastPort1 & 0x04))
-			sample_start(samples, 0, 1, 0);
+			samples->start(0, 1);
 
 		if (data & 0x08)
 		{
@@ -832,7 +832,7 @@
 {
 	device_t *device = space->machine().device("snk6502");
 	snk6502_sound_state *state = get_safe_token(device);
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 	TONE *tone_channels = state->m_tone_channels;
 
 	switch (offset)
@@ -860,13 +860,13 @@
 		/* play noise samples requested by sound command byte */
 		/* SHOT A */
 		if (data & 0x20 && !(state->m_LastPort1 & 0x20))
-			sample_start(samples, 1, 0, 0);
+			samples->start(1, 0);
 		else if (!(data & 0x20) && state->m_LastPort1 & 0x20)
-			sample_stop(samples, 1);
+			samples->stop(1);
 
 		/* BOMB */
 		if (data & 0x80 && !(state->m_LastPort1 & 0x80))
-			sample_start(samples, 2, 1, 0);
+			samples->start(2, 1);
 
 		if (data & 0x08)
 		{
@@ -1086,7 +1086,7 @@
 
 	device_t *device = machine.device("snk6502");
 	snk6502_sound_state *state = get_safe_token(device);
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 
 	if ((data & HD38880_CTP) && (data & HD38880_CMV))
 	{
@@ -1100,7 +1100,7 @@
 			case HD38880_START:
 				logerror("speech: START\n");
 
-				if (state->m_hd38880_data_bytes == 5 && !sample_playing(samples, 0))
+				if (state->m_hd38880_data_bytes == 5 && !samples->playing(0))
 				{
 					int i;
 
@@ -1108,7 +1108,7 @@
 					{
 						if (table[i] && table[i] == state->m_hd38880_addr)
 						{
-							sample_start(samples, 0, start + i, 0);
+							samples->start(0, start + i);
 							break;
 						}
 					}
@@ -1120,7 +1120,7 @@
 				break;
 
 			case HD38880_STOP:
-				sample_stop(samples, 0);
+				samples->stop(0);
 				logerror("speech: STOP\n");
 				break;
 
diff -Nru src-old/mame/audio/spacefb.c src/mame/audio/spacefb.c
--- src-old/mame/audio/spacefb.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/spacefb.c	2012-02-19 02:53:16.000000000 +0100
@@ -35,15 +35,15 @@
 WRITE8_HANDLER( spacefb_port_1_w )
 {
 	spacefb_state *state = space->machine().driver_data<spacefb_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	cputag_set_input_line(space->machine(), "audiocpu", 0, (data & 0x02) ? CLEAR_LINE : ASSERT_LINE);
 
 	/* enemy killed */
-	if (!(data & 0x01) && (state->m_sound_latch & 0x01))  sample_start(samples, 0,0,0);
+	if (!(data & 0x01) && (state->m_sound_latch & 0x01))  samples->start(0,0);
 
 	/* ship fire */
-	if (!(data & 0x40) && (state->m_sound_latch & 0x40))  sample_start(samples, 1,1,0);
+	if (!(data & 0x40) && (state->m_sound_latch & 0x40))  samples->start(1,1);
 
 	/*
      *  Explosion Noise
@@ -57,10 +57,10 @@
 	{
 		if (data & 0x80)
 			/* play decaying noise */
-			sample_start(samples, 2,3,0);
+			samples->start(2,3);
 		else
 			/* start looping noise */
-			sample_start(samples, 2,2,1);
+			samples->start(2,2, true);
 	}
 
 	state->m_sound_latch = data;
@@ -91,7 +91,6 @@
 	MCFG_SOUND_ADD("dac", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(spacefb_samples_interface)
+	MCFG_SAMPLES_ADD("samples", spacefb_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/audio/suna8.c src/mame/audio/suna8.c
--- src-old/mame/audio/suna8.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/audio/suna8.c	2012-02-19 02:53:16.000000000 +0100
@@ -16,14 +16,15 @@
 	suna8_state *state = device->machine().driver_data<suna8_state>();
 	if( data )
 	{
+		samples_device *samples = downcast<samples_device *>(device);
 		if( ~data & 0x10 )
 		{
-			sample_start_raw(device, 0, &state->m_samplebuf[0x800*state->m_sample], 0x0800, 4000, 0);
+			samples->start_raw(0, &state->m_samplebuf[0x800*state->m_sample], 0x0800, 4000);
 		}
 		else if( ~data & 0x08 )
 		{
 			state->m_sample &= 3;
-			sample_start_raw(device, 0, &state->m_samplebuf[0x800*(state->m_sample+7)], 0x0800, 4000, 0);
+			samples->start_raw(0, &state->m_samplebuf[0x800*(state->m_sample+7)], 0x0800, 4000);
 		}
 	}
 }
@@ -35,7 +36,8 @@
 	{
 		if(( state->m_sample != 0 ) && ( ~data & 0x30 ))	// don't play state->m_sample zero when the bit is active
 		{
-			sample_start_raw(device, 0, &state->m_samplebuf[0x800*state->m_sample], 0x0800, 4000, 0);
+			samples_device *samples = downcast<samples_device *>(device);
+			samples->start_raw(0, &state->m_samplebuf[0x800*state->m_sample], 0x0800, 4000);
 		}
 	}
 }
@@ -48,8 +50,8 @@
 
 SAMPLES_START( suna8_sh_start )
 {
-	suna8_state *state = device->machine().driver_data<suna8_state>();
-	running_machine &machine = device->machine();
+	suna8_state *state = device.machine().driver_data<suna8_state>();
+	running_machine &machine = device.machine();
 	int i, len = machine.region("samples")->bytes();
 	UINT8 *ROM = machine.region("samples")->base();
 
diff -Nru src-old/mame/audio/targ.c src/mame/audio/targ.c
--- src-old/mame/audio/targ.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/targ.c	2012-02-19 02:53:16.000000000 +0100
@@ -45,52 +45,52 @@
 
 
 
-static void adjust_sample(device_t *samples, UINT8 freq)
+static void adjust_sample(samples_device *samples, UINT8 freq)
 {
 	tone_freq = freq;
 
 	if ((tone_freq == 0xff) || (tone_freq == 0x00))
-		sample_set_volume(samples, 3, 0);
+		samples->set_volume(3, 0);
 	else
 	{
-		sample_set_freq(samples, 3, 1.0 * max_freq / (0xff - tone_freq));
-		sample_set_volume(samples, 3, tone_active);
+		samples->set_frequency(3, 1.0 * max_freq / (0xff - tone_freq));
+		samples->set_volume(3, tone_active);
 	}
 }
 
 
 WRITE8_HANDLER( targ_audio_1_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	/* CPU music */
 	if ((data & 0x01) != (port_1_last & 0x01))
 		dac_data_w(space->machine().device("dac"),(data & 0x01) * 0xff);
 
 	/* shot */
-	if (FALLING_EDGE(0x02) && !sample_playing(samples, 0))  sample_start(samples, 0,1,0);
-	if (RISING_EDGE(0x02)) sample_stop(samples, 0);
+	if (FALLING_EDGE(0x02) && !samples->playing(0))  samples->start(0,1);
+	if (RISING_EDGE(0x02)) samples->stop(0);
 
 	/* crash */
 	if (RISING_EDGE(0x20))
 	{
 		if (data & 0x40)
-			sample_start(samples, 1,2,0);
+			samples->start(1,2);
 		else
-			sample_start(samples, 1,0,0);
+			samples->start(1,0);
 	}
 
 	/* Sspec */
 	if (data & 0x10)
-		sample_stop(samples, 2);
+		samples->stop(2);
 	else
 	{
 		if ((data & 0x08) != (port_1_last & 0x08))
 		{
 			if (data & 0x08)
-				sample_start(samples, 2,3,1);
+				samples->start(2,3,true);
 			else
-				sample_start(samples, 2,4,1);
+				samples->start(2,4,true);
 		}
 	}
 
@@ -114,7 +114,7 @@
 {
 	if ((data & 0x01) && !(port_2_last & 0x01))
 	{
-		device_t *samples = space->machine().device("samples");
+		samples_device *samples = space->machine().device<samples_device>("samples");
 		UINT8 *prom = space->machine().region("targ")->base();
 
 		tone_pointer = (tone_pointer + 1) & 0x0f;
@@ -128,7 +128,7 @@
 
 WRITE8_HANDLER( spectar_audio_2_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	adjust_sample(samples, data);
 }
 
@@ -147,14 +147,14 @@
 
 static void common_audio_start(running_machine &machine, int freq)
 {
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	max_freq = freq;
 
 	tone_freq = 0;
 	tone_active = 0;
 
-	sample_set_volume(samples, 3, 0);
-	sample_start_raw(samples, 3, sine_wave, 32, 1000, 1);
+	samples->set_volume(3, 0);
+	samples->start_raw(3, sine_wave, 32, 1000, true);
 
 	state_save_register_global(machine, port_1_last);
 	state_save_register_global(machine, port_2_last);
@@ -165,14 +165,13 @@
 
 static SAMPLES_START( spectar_audio_start )
 {
-	running_machine &machine = device->machine();
-	common_audio_start(machine, SPECTAR_MAXFREQ);
+	common_audio_start(device.machine(), SPECTAR_MAXFREQ);
 }
 
 
 static SAMPLES_START( targ_audio_start )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	common_audio_start(machine, TARG_MAXFREQ);
 
 	tone_pointer = 0;
@@ -201,8 +200,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(spectar_samples_interface)
+	MCFG_SAMPLES_ADD("samples", spectar_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
@@ -214,8 +212,7 @@
 
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(targ_samples_interface)
+	MCFG_SAMPLES_ADD("samples", targ_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
diff -Nru src-old/mame/audio/turbo.c src/mame/audio/turbo.c
--- src-old/mame/audio/turbo.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/turbo.c	2012-02-19 02:53:16.000000000 +0100
@@ -19,19 +19,19 @@
  *
  *************************************/
 
-static void turbo_update_samples(turbo_state *state, device_t *samples)
+static void turbo_update_samples(turbo_state *state, samples_device *samples)
 {
 	/* accelerator sounds */
 	/* BSEL == 3 --> off */
 	/* BSEL == 2 --> standard */
 	/* BSEL == 1 --> tunnel */
 	/* BSEL == 0 --> ??? */
-	if (state->m_turbo_bsel == 3 && sample_playing(samples, 5))
-		sample_stop(samples, 5);
-	else if (state->m_turbo_bsel != 3 && !sample_playing(samples, 5))
-		sample_start(samples, 5, 7, TRUE);
-	if (sample_playing(samples, 5))
-		sample_set_freq(samples, 5, sample_get_base_freq(samples, 5) * ((state->m_turbo_accel & 0x3f) / 5.25 + 1));
+	if (state->m_turbo_bsel == 3 && samples->playing(5))
+		samples->stop(5);
+	else if (state->m_turbo_bsel != 3 && !samples->playing(5))
+		samples->start(5, 7, true);
+	if (samples->playing(5))
+		samples->set_frequency(5, samples->base_frequency(5) * ((state->m_turbo_accel & 0x3f) / 5.25 + 1));
 }
 
 
@@ -72,7 +72,7 @@
 WRITE8_DEVICE_HANDLER( turbo_sound_a_w )
 {
 #if (!DISCRETE_TEST)
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 #endif
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[0];
@@ -81,28 +81,28 @@
 #if (!DISCRETE_TEST)
 
 	/* /CRASH.S: channel 0 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 0, 5, FALSE);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(0, 5);
 
 	/* /TRIG1: channel 1 */
-	if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 1, 0, FALSE);
+	if ((diff & 0x02) && !(data & 0x02)) samples->start(1, 0);
 
 	/* /TRIG2: channel 1 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 1, 1, FALSE);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(1, 1);
 
 	/* /TRIG3: channel 1 */
-	if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 1, 2, FALSE);
+	if ((diff & 0x08) && !(data & 0x08)) samples->start(1, 2);
 
 	/* /TRIG4: channel 1 */
-	if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 1, 3, FALSE);
+	if ((diff & 0x10) && !(data & 0x10)) samples->start(1, 3);
 
 	/* OSEL0 */
 	state->m_turbo_osel = (state->m_turbo_osel & 6) | ((data >> 5) & 1);
 
 	/* /SLIP: channel 2 */
-	if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 2, 4, FALSE);
+	if ((diff & 0x40) && !(data & 0x40)) samples->start(2, 4);
 
 	/* /CRASH.L: channel 3 */
-	if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 3, 5, FALSE);
+	if ((diff & 0x80) && !(data & 0x80)) samples->start(3, 5);
 
 	/* update any samples */
 	turbo_update_samples(state, samples);
@@ -122,7 +122,7 @@
 
 WRITE8_DEVICE_HANDLER( turbo_sound_b_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
@@ -132,11 +132,11 @@
 	output_set_value("tachometer", state->m_turbo_accel);
 
 	/* /AMBU: channel 4 */
-	if ((diff & 0x40) && !(data & 0x40) && !sample_playing(samples, 4)) sample_start(samples, 4, 8, TRUE);
-	if ((diff & 0x40) &&  (data & 0x40)) sample_stop(samples, 4);
+	if ((diff & 0x40) && !(data & 0x40) && !samples->playing(4)) samples->start(4, 8, true);
+	if ((diff & 0x40) &&  (data & 0x40)) samples->stop(4);
 
 	/* /SPIN: channel 2 */
-	if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 2, 6, FALSE);
+	if ((diff & 0x80) && !(data & 0x80)) samples->start(2, 6);
 
 	/* update any samples */
 	turbo_update_samples(state, samples);
@@ -145,7 +145,7 @@
 
 WRITE8_DEVICE_HANDLER( turbo_sound_c_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 
 	/* OSEL1-2 */
@@ -200,8 +200,7 @@
 	MCFG_SPEAKER_ADD("lspeaker", -0.2, 0.0, 1.0)	/* left */
 	MCFG_SPEAKER_ADD("rspeaker", 0.2, 0.0, 1.0)		/* right */
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(turbo_samples_interface)
+	MCFG_SAMPLES_ADD("samples", turbo_samples_interface)
 
 	/* channel 0 = CRASH.S -> CRASH.S/SM */
 	MCFG_SOUND_ROUTE(0, "fspeaker", 0.25)
@@ -304,7 +303,7 @@
 }
 
 
-INLINE void subroc3d_update_volume(device_t *samples, int leftchan, UINT8 dis, UINT8 dir)
+INLINE void subroc3d_update_volume(samples_device *samples, int leftchan, UINT8 dis, UINT8 dir)
 {
 	float volume = (float)(15 - dis) / 16.0f;
 	float lvol, rvol;
@@ -319,14 +318,14 @@
 		lvol = rvol = 0;
 
 	/* if the sample is playing, adjust it */
-	sample_set_volume(samples, leftchan + 0, lvol);
-	sample_set_volume(samples, leftchan + 1, rvol);
+	samples->set_volume(leftchan + 0, lvol);
+	samples->set_volume(leftchan + 1, rvol);
 }
 
 
 WRITE8_DEVICE_HANDLER( subroc3d_sound_b_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
@@ -336,10 +335,10 @@
 	{
 		state->m_subroc3d_mdis = state->m_sound_state[0] & 0x0f;
 		state->m_subroc3d_mdir = (state->m_sound_state[0] >> 4) & 0x07;
-		if (!sample_playing(samples, 0))
+		if (!samples->playing(0))
 		{
-			sample_start(samples, 0, 0, TRUE);
-			sample_start(samples, 1, 0, TRUE);
+			samples->start(0, 0, true);
+			samples->start(1, 0, true);
 		}
 		subroc3d_update_volume(samples, 0, state->m_subroc3d_mdis, state->m_subroc3d_mdir);
 	}
@@ -349,10 +348,10 @@
 	{
 		state->m_subroc3d_tdis = state->m_sound_state[0] & 0x0f;
 		state->m_subroc3d_tdir = (state->m_sound_state[0] >> 4) & 0x07;
-		if (!sample_playing(samples, 2))
+		if (!samples->playing(2))
 		{
-			sample_start(samples, 2, 1, TRUE);
-			sample_start(samples, 3, 1, TRUE);
+			samples->start(2, 1, true);
+			samples->start(3, 1, true);
 		}
 		subroc3d_update_volume(samples, 2, state->m_subroc3d_tdis, state->m_subroc3d_tdir);
 	}
@@ -362,10 +361,10 @@
 	{
 		state->m_subroc3d_fdis = state->m_sound_state[0] & 0x0f;
 		state->m_subroc3d_fdir = (state->m_sound_state[0] >> 4) & 0x07;
-		if (!sample_playing(samples, 4))
+		if (!samples->playing(4))
 		{
-			sample_start(samples, 4, 2, TRUE);
-			sample_start(samples, 5, 2, TRUE);
+			samples->start(4, 2, true);
+			samples->start(5, 2, true);
 		}
 		subroc3d_update_volume(samples, 4, state->m_subroc3d_fdis, state->m_subroc3d_fdir);
 	}
@@ -382,7 +381,7 @@
 
 WRITE8_DEVICE_HANDLER( subroc3d_sound_c_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[2];
 	state->m_sound_state[2] = data;
@@ -390,28 +389,28 @@
 	/* /FIRE TRIG */
 	/* FIRE SELECT */
 	if ((diff & 0x01) && (data & 0x01))
-		sample_start(samples, 8, (data & 0x02) ? 6 : 5, FALSE);
+		samples->start(8, (data & 0x02) ? 6 : 5);
 
 	/* /SHIP EXP TRIG -> MY SHIP EXP: channel 9 */
 	if ((diff & 0x04) && (data & 0x04))
-		sample_start(samples, 9, 7, FALSE);
+		samples->start(9, 7);
 
 	/* /HIT TRIG -> HIT.L/R: channels 6+7 */
 	if ((diff & 0x08) && (data & 0x08))
 	{
-		sample_start(samples, 6, (state->m_sound_state[0] & 0x80) ? 4 : 3, FALSE);
-		sample_start(samples, 7, (state->m_sound_state[0] & 0x80) ? 4 : 3, FALSE);
+		samples->start(6, (state->m_sound_state[0] & 0x80) ? 4 : 3);
+		samples->start(7, (state->m_sound_state[0] & 0x80) ? 4 : 3);
 	}
 
 	/* /ALARM TRIG -> ALARM.M: channel 10 */
 	/* ALARM SELECT */
 	if ((diff & 0x10) && (data & 0x10))
-		sample_start(samples, 10, (data & 0x20) ? 10 : 9, FALSE);
+		samples->start(10, (data & 0x20) ? 10 : 9);
 
 	/* /PROLOGUE */
-	if (!sample_playing(samples, 11))
-		sample_start(samples, 11, 8, TRUE);
-	sample_set_volume(samples, 11, (data & 0x40) ? 0 : 1.0);
+	if (!samples->playing(11))
+		samples->start(11, 8, true);
+	samples->set_volume(11, (data & 0x40) ? 0 : 1.0);
 
 	/* /GAME START */
 	device->machine().sound().system_mute(data & 0x80);
@@ -453,8 +452,7 @@
 MACHINE_CONFIG_FRAGMENT( subroc3d_samples )
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(subroc3d_samples_interface)
+	MCFG_SAMPLES_ADD("samples", subroc3d_samples_interface)
 
 	/* MISSILE in channels 0 and 1 */
 	MCFG_SOUND_ROUTE(0, "lspeaker",  0.25)
@@ -497,24 +495,24 @@
  *
  *************************************/
 
-static void buckrog_update_samples(turbo_state *state, device_t *samples)
+static void buckrog_update_samples(turbo_state *state, samples_device *samples)
 {
 	/* accelerator sounds */
-	if (sample_playing(samples, 5))
-		sample_set_freq(samples, 5, sample_get_base_freq(samples, 5) * (state->m_buckrog_myship / 100.25 + 1));
+	if (samples->playing(5))
+		samples->set_frequency(5, samples->base_frequency(5) * (state->m_buckrog_myship / 100.25 + 1));
 }
 
 
 WRITE8_DEVICE_HANDLER( buckrog_sound_a_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[0];
 	state->m_sound_state[0] = data;
 
 	/* clock HIT DIS from bits 0-2 */
 	if ((diff & 0x10) && (data & 0x10))
-		sample_set_volume(samples, 3, (float)(/*7 - */(data & 7)) / 7.0f);
+		samples->set_volume(3, (float)(/*7 - */(data & 7)) / 7.0f);
 
 	/* clock ACC from bits 0-3 */
 	if ((diff & 0x20) && (data & 0x20))
@@ -524,49 +522,49 @@
 	}
 
 	/* /ALARM0: channel 0 */
-	if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 0, 0, FALSE);
+	if ((diff & 0x40) && !(data & 0x40)) samples->start(0, 0);
 
 	/* /ALARM1: channel 0 */
-	if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 0, 1, FALSE);
+	if ((diff & 0x80) && !(data & 0x80)) samples->start(0, 1);
 }
 
 
 WRITE8_DEVICE_HANDLER( buckrog_sound_b_w )
 {
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	turbo_state *state = device->machine().driver_data<turbo_state>();
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
 
 	/* /ALARM3: channel 0 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 0, 2, FALSE);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(0, 2);
 
 	/* /ALARM4: channel 0 */
-	if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 0, 3, FALSE);
+	if ((diff & 0x02) && !(data & 0x02)) samples->start(0, 3);
 
 	/* /FIRE: channel 1 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 1, 5, FALSE);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(1, 5);
 
 	/* /EXP: channel 2 */
-	if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 2, 4, FALSE);
+	if ((diff & 0x08) && !(data & 0x08)) samples->start(2, 4);
 
 	/* /HIT: channel 3 */
 	if ((diff & 0x10) && !(data & 0x10))
 	{
-		sample_start(samples, 3, 7, FALSE);
+		samples->start(3, 7);
 		buckrog_update_samples(state, samples);
 	}
 
 	/* /REBOUND: channel 4 */
-	if ((diff & 0x20) && !(data & 0x20)) sample_start(samples, 4, 6, FALSE);
+	if ((diff & 0x20) && !(data & 0x20)) samples->start(4, 6);
 
 	/* SHIP: channel 5 */
-	if ((diff & 0x40) &&  (data & 0x40) && !sample_playing(samples, 5))
+	if ((diff & 0x40) &&  (data & 0x40) && !samples->playing(5))
 	{
-		sample_start(samples, 5, 8, TRUE);
+		samples->start(5, 8, true);
 		buckrog_update_samples(state, samples);
 	}
-	if ((diff & 0x40) && !(data & 0x40) &&  sample_playing(samples, 5)) sample_stop(samples, 5);
+	if ((diff & 0x40) && !(data & 0x40) &&  samples->playing(5)) samples->stop(5);
 
 	/* GAME ON */
 	device->machine().sound().system_enable(data & 0x80);
@@ -607,8 +605,7 @@
 
 MACHINE_CONFIG_FRAGMENT( buckrog_samples )
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(buckrog_samples_interface)
+	MCFG_SAMPLES_ADD("samples", buckrog_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/audio/vicdual.c src/mame/audio/vicdual.c
--- src-old/mame/audio/vicdual.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/vicdual.c	2012-02-19 02:53:16.000000000 +0100
@@ -120,8 +120,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( frogs_audio )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(frogs_samples_interface)
+	MCFG_SAMPLES_ADD("samples", frogs_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.35)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
@@ -132,8 +131,8 @@
 
 static TIMER_CALLBACK( frogs_croak_callback )
 {
-	device_t *samples = machine.device("samples");
-	sample_stop(samples, 2);
+	samples_device *samples = machine.device<samples_device>("samples");
+	samples->stop(2);
 }
 
 
@@ -145,7 +144,7 @@
 
 WRITE8_HANDLER( frogs_audio_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	device_t *discrete = space->machine().device("discrete");
 	static int last_croak = 0;
 	static int last_buzzz = 0;
@@ -160,11 +159,11 @@
 //  discrete_sound_w(discrete, FROGS_SPLASH_EN, data & 0x80);
 
 	if (data & 0x01)
-		sample_start (samples, 3, 3, 0);	// Hop
+		samples->start(3, 3);	// Hop
 	if (data & 0x02)
-		sample_start (samples, 0, 0, 0);	// Boing
+		samples->start(0, 0);	// Boing
 	if (new_croak)
-		sample_start (samples, 2, 2, 0);	// Croak
+		samples->start(2, 2);	// Croak
 	else
 	{
 		if (last_croak)
@@ -187,12 +186,12 @@
          * 12 seconds.
          */
 		if (!last_buzzz)
-			sample_start (samples, 1, 1, 1);	// Buzzz
+			samples->start(1, 1, true);	// Buzzz
 	}
 	else
-		sample_stop(samples, 1);
+		samples->stop(1);
 	if (data & 0x80)
-		sample_start (samples, 4, 4, 0);	// Splash
+		samples->start(4, 4);	// Splash
 
 	last_croak = new_croak;
 	last_buzzz = new_buzzz;
diff -Nru src-old/mame/audio/wow.c src/mame/audio/wow.c
--- src-old/mame/audio/wow.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/audio/wow.c	2012-02-19 02:53:16.000000000 +0100
@@ -103,7 +103,7 @@
 READ8_HANDLER( wow_speech_r )
 {
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	int Phoneme/*, Intonation*/;
 	int i = 0;
 	UINT8 data = offset >> 8;
@@ -117,7 +117,7 @@
 	//logerror("Data : %d Speech : %s at intonation %d\n",Phoneme, PhonemeTable[Phoneme],Intonation);
 
 	if(Phoneme==63) {
-		sample_stop(samples, 0);
+		samples->stop(0);
 		//logerror("Clearing sample %s\n",state->m_totalword);
 		state->m_totalword[0] = 0;				   /* Clear the total word stack */
 		return data;
@@ -132,8 +132,8 @@
 		if (state->m_plural != 0) {
 			//logerror("found a possible plural at %d\n",state->m_plural-1);
 			if (!strcmp("S",state->m_totalword)) {		   /* Plural check */
-				sample_start(samples, 0, num_samples-2, 0);	   /* play the sample at position of word */
-				sample_set_freq(samples, 0, 11025);    /* play at correct rate */
+				samples->start(0, num_samples-2);	   /* play the sample at position of word */
+				samples->set_frequency(0, 11025);    /* play at correct rate */
 				state->m_totalword[0] = 0;				   /* Clear the total word stack */
 				state->m_oldword[0] = 0;				   /* Clear the total word stack */
 				return data;
@@ -156,8 +156,8 @@
 			} else {
 				state->m_plural=0;
 			}
-			sample_start(samples, 0, i, 0);	                   /* play the sample at position of word */
-			sample_set_freq(samples, 0, 11025);         /* play at correct rate */
+			samples->start(0, i);	                   /* play the sample at position of word */
+			samples->set_frequency(0, 11025);         /* play at correct rate */
 			//logerror("Playing sample %d\n",i);
 			state->m_totalword[0] = 0;				   /* Clear the total word stack */
 			return data;
@@ -171,6 +171,6 @@
 
 CUSTOM_INPUT( wow_speech_status_r )
 {
-	device_t *samples = field.machine().device("samples");
-	return !sample_playing(samples, 0);
+	samples_device *samples = field.machine().device<samples_device>("samples");
+	return !samples->playing(0);
 }
diff -Nru src-old/mame/audio/zaxxon.c src/mame/audio/zaxxon.c
--- src-old/mame/audio/zaxxon.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/audio/zaxxon.c	2012-02-19 02:53:16.000000000 +0100
@@ -98,8 +98,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( zaxxon_samples )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(zaxxon_samples_interface)
+	MCFG_SAMPLES_ADD("samples", zaxxon_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
@@ -114,72 +113,72 @@
 WRITE8_DEVICE_HANDLER( zaxxon_sound_a_w )
 {
 	zaxxon_state *state = device->machine().driver_data<zaxxon_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[0];
 	state->m_sound_state[0] = data;
 
 	/* PLAYER SHIP A/B: volume */
-	sample_set_volume(samples, 10, 0.5 + 0.157 * (data & 0x03));
-	sample_set_volume(samples, 11, 0.5 + 0.157 * (data & 0x03));
+	samples->set_volume(10, 0.5 + 0.157 * (data & 0x03));
+	samples->set_volume(11, 0.5 + 0.157 * (data & 0x03));
 
 	/* PLAYER SHIP C: channel 10 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 10, 10, TRUE);
-	if ((diff & 0x04) &&  (data & 0x04)) sample_stop(samples, 10);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(10, 10, true);
+	if ((diff & 0x04) &&  (data & 0x04)) samples->stop(10);
 
 	/* PLAYER SHIP D: channel 11 */
-	if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 11, 11, TRUE);
-	if ((diff & 0x08) &&  (data & 0x08)) sample_stop(samples, 11);
+	if ((diff & 0x08) && !(data & 0x08)) samples->start(11, 11, true);
+	if ((diff & 0x08) &&  (data & 0x08)) samples->stop(11);
 
 	/* HOMING MISSILE: channel 0 */
-	if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 0, 0, TRUE);
-	if ((diff & 0x10) &&  (data & 0x10)) sample_stop(samples, 0);
+	if ((diff & 0x10) && !(data & 0x10)) samples->start(0, 0, true);
+	if ((diff & 0x10) &&  (data & 0x10)) samples->stop(0);
 
 	/* BASE MISSILE: channel 1 */
-	if ((diff & 0x20) && !(data & 0x20)) sample_start(samples, 1, 1, FALSE);
+	if ((diff & 0x20) && !(data & 0x20)) samples->start(1, 1);
 
 	/* LASER: channel 2 */
-	if ((diff & 0x40) && !(data & 0x40)) sample_start(samples, 2, 2, TRUE);
-	if ((diff & 0x40) &&  (data & 0x40)) sample_stop(samples, 2);
+	if ((diff & 0x40) && !(data & 0x40)) samples->start(2, 2, true);
+	if ((diff & 0x40) &&  (data & 0x40)) samples->stop(2);
 
 	/* BATTLESHIP: channel 3 */
-	if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 3, 3, TRUE);
-	if ((diff & 0x80) &&  (data & 0x80)) sample_stop(samples, 3);
+	if ((diff & 0x80) && !(data & 0x80)) samples->start(3, 3, true);
+	if ((diff & 0x80) &&  (data & 0x80)) samples->stop(3);
 }
 
 
 WRITE8_DEVICE_HANDLER( zaxxon_sound_b_w )
 {
 	zaxxon_state *state = device->machine().driver_data<zaxxon_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
 
 	/* S-EXP: channel 4 */
-	if ((diff & 0x10) && !(data & 0x10)) sample_start(samples, 4, 4, FALSE);
+	if ((diff & 0x10) && !(data & 0x10)) samples->start(4, 4);
 
 	/* M-EXP: channel 5 */
-	if ((diff & 0x20) && !(data & 0x20) && !sample_playing(samples, 5)) sample_start(samples, 5, 5, FALSE);
+	if ((diff & 0x20) && !(data & 0x20) && !samples->playing(5)) samples->start(5, 5);
 
 	/* CANNON: channel 6 */
-	if ((diff & 0x80) && !(data & 0x80)) sample_start(samples, 6, 6, FALSE);
+	if ((diff & 0x80) && !(data & 0x80)) samples->start(6, 6);
 }
 
 
 WRITE8_DEVICE_HANDLER( zaxxon_sound_c_w )
 {
 	zaxxon_state *state = device->machine().driver_data<zaxxon_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[2];
 	state->m_sound_state[2] = data;
 
 	/* SHOT: channel 7 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 7, 7, FALSE);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(7, 7);
 
 	/* ALARM2: channel 8 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 8, 8, FALSE);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(8, 8);
 
 	/* ALARM3: channel 9 */
-	if ((diff & 0x08) && !(data & 0x08) && !sample_playing(samples, 9)) sample_start(samples, 9, 9, FALSE);
+	if ((diff & 0x08) && !(data & 0x08) && !samples->playing(9)) samples->start(9, 9);
 }
 
 
@@ -210,8 +209,7 @@
 
 
 MACHINE_CONFIG_FRAGMENT( congo_samples )
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(congo_samples_interface)
+	MCFG_SAMPLES_ADD("samples", congo_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
@@ -226,37 +224,37 @@
 WRITE8_DEVICE_HANDLER( congo_sound_b_w )
 {
 	zaxxon_state *state = device->machine().driver_data<zaxxon_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[1];
 	state->m_sound_state[1] = data;
 
 	/* bit 7 = mute */
 
 	/* GORILLA: channel 0 */
-	if ((diff & 0x02) && !(data & 0x02) && !sample_playing(samples, 0)) sample_start(samples, 0, 0, FALSE);
+	if ((diff & 0x02) && !(data & 0x02) && !samples->playing(0)) samples->start(0, 0);
 }
 
 
 WRITE8_DEVICE_HANDLER( congo_sound_c_w )
 {
 	zaxxon_state *state = device->machine().driver_data<zaxxon_state>();
-	device_t *samples = device->machine().device("samples");
+	samples_device *samples = device->machine().device<samples_device>("samples");
 	UINT8 diff = data ^ state->m_sound_state[2];
 	state->m_sound_state[2] = data;
 
 	/* BASS DRUM: channel 1 */
-	if ((diff & 0x01) && !(data & 0x01)) sample_start(samples, 1, 1, FALSE);
-	if ((diff & 0x01) &&  (data & 0x01)) sample_stop(samples, 1);
+	if ((diff & 0x01) && !(data & 0x01)) samples->start(1, 1);
+	if ((diff & 0x01) &&  (data & 0x01)) samples->stop(1);
 
 	/* CONGA (LOW): channel 2 */
-	if ((diff & 0x02) && !(data & 0x02)) sample_start(samples, 2, 2, FALSE);
-	if ((diff & 0x02) &&  (data & 0x02)) sample_stop(samples, 2);
+	if ((diff & 0x02) && !(data & 0x02)) samples->start(2, 2);
+	if ((diff & 0x02) &&  (data & 0x02)) samples->stop(2);
 
 	/* CONGA (HIGH): channel 3 */
-	if ((diff & 0x04) && !(data & 0x04)) sample_start(samples, 3, 3, FALSE);
-	if ((diff & 0x04) &&  (data & 0x04)) sample_stop(samples, 3);
+	if ((diff & 0x04) && !(data & 0x04)) samples->start(3, 3);
+	if ((diff & 0x04) &&  (data & 0x04)) samples->stop(3);
 
 	/* RIM: channel 4 */
-	if ((diff & 0x08) && !(data & 0x08)) sample_start(samples, 4, 4, FALSE);
-	if ((diff & 0x08) &&  (data & 0x08)) sample_stop(samples, 4);
+	if ((diff & 0x08) && !(data & 0x08)) samples->start(4, 4);
+	if ((diff & 0x08) &&  (data & 0x08)) samples->stop(4);
 }
diff -Nru src-old/mame/drivers/30test.c src/mame/drivers/30test.c
--- src-old/mame/drivers/30test.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/30test.c	2012-02-12 16:49:27.000000000 +0100
@@ -5,7 +5,6 @@
     driver by Angelo Salese
 
     TODO:
-    - clickable artwork;
     - portd meaning is a mystery
     - inputs are annoying to map;
     - EEPROM
@@ -60,28 +59,26 @@
 };
 
 
-static VIDEO_START( 30test )
-{
-
-}
+static const UINT8 led_map[16] =
+	{ 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67,0x77,0x7c,0x39,0x5e,0x79,0x00 };
 
-static SCREEN_UPDATE_IND16( 30test )
+static WRITE8_HANDLER( namco_30test_led_w )
 {
-	return 0;
+	output_set_digit_value(0 + offset * 2, led_map[(data & 0xf0) >> 4]);
+	output_set_digit_value(1 + offset * 2, led_map[(data & 0x0f) >> 0]);
 }
 
-static READ8_HANDLER(hc11_mux_r)
+static WRITE8_HANDLER( namco_30test_led_rank_w )
 {
-	namco_30test_state *state = space->machine().driver_data<namco_30test_state>();
-
-	return state->m_mux_data;
+	output_set_digit_value(64 + offset * 2, led_map[(data & 0xf0) >> 4]);
+	output_set_digit_value(65 + offset * 2, led_map[(data & 0x0f) >> 0]);
 }
 
-static WRITE8_HANDLER(hc11_mux_w)
+static WRITE8_HANDLER( namco_30test_lamps_w )
 {
-	namco_30test_state *state = space->machine().driver_data<namco_30test_state>();
-
-	state->m_mux_data = data;
+	// d0-d5: ranking, d6: game over, d7: assume marquee lamp
+	for (int i = 0; i < 8; i++)
+		output_set_lamp_value(i, data >> i & 1);
 }
 
 static READ8_HANDLER(namco_30test_mux_r)
@@ -100,33 +97,16 @@
 	return res;
 }
 
-static const UINT8 led_map[16] =
-	{ 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67,0x77,0x7c,0x39,0x5e,0x79,0x00 };
-
-static WRITE8_HANDLER( namco_30test_led_w )
-{
-	output_set_digit_value(0 + offset * 2, led_map[(data & 0xf0) >> 4]);
-	output_set_digit_value(1 + offset * 2, led_map[(data & 0x0f) >> 0]);
-}
-
-static WRITE8_HANDLER( namco_30test_led_rank_w )
+static READ8_HANDLER(hc11_mux_r)
 {
-	output_set_digit_value(64 + offset * 2, led_map[(data & 0xf0) >> 4]);
-	output_set_digit_value(65 + offset * 2, led_map[(data & 0x0f) >> 0]);
+	namco_30test_state *state = space->machine().driver_data<namco_30test_state>();
+	return state->m_mux_data;
 }
 
-static WRITE8_HANDLER( namco_30test_lamps_w )
+static WRITE8_HANDLER(hc11_mux_w)
 {
-	if(!(data & 0x80)) // guess: lamps mask
-		data = 0;
-
-	output_set_lamp_value(0, (data & 0x01) >> 0); // really OK! lamp
-	output_set_lamp_value(1, (data & 0x02) >> 1); // pretty good lamp
-	output_set_lamp_value(2, (data & 0x04) >> 2); // not bad lamp
-	output_set_lamp_value(3, (data & 0x08) >> 3); // normal lamp
-	output_set_lamp_value(4, (data & 0x10) >> 4); // pretty bad lamp
-	output_set_lamp_value(5, (data & 0x20) >> 5); // worst lamp
-	output_set_lamp_value(6, (data & 0x40) >> 6); // game over lamp
+	namco_30test_state *state = space->machine().driver_data<namco_30test_state>();
+	state->m_mux_data = data;
 }
 
 static READ8_DEVICE_HANDLER( hc11_okibank_r )
@@ -173,68 +153,63 @@
 
 
 static INPUT_PORTS_START( 30test )
-	/* we use num pad to map system inputs */
 	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-1") PORT_CODE(KEYCODE_1)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-1") PORT_CODE(KEYCODE_2)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-1") PORT_CODE(KEYCODE_3)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("4-1") PORT_CODE(KEYCODE_4)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("5-1") PORT_CODE(KEYCODE_5)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("6-1") PORT_CODE(KEYCODE_6)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-2") PORT_CODE(KEYCODE_Q)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-2") PORT_CODE(KEYCODE_W)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-1") PORT_CODE(KEYCODE_1)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-2") PORT_CODE(KEYCODE_2)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-3") PORT_CODE(KEYCODE_3)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-4") PORT_CODE(KEYCODE_4)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-5") PORT_CODE(KEYCODE_5)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 1-6") PORT_CODE(KEYCODE_6)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-1") PORT_CODE(KEYCODE_Q)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-2") PORT_CODE(KEYCODE_W)
 
 	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-2") PORT_CODE(KEYCODE_E)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("4-2") PORT_CODE(KEYCODE_R)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("5-2") PORT_CODE(KEYCODE_T)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("6-2") PORT_CODE(KEYCODE_Y)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-3") PORT_CODE(KEYCODE_A)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-3") PORT_CODE(KEYCODE_S)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-3") PORT_CODE(KEYCODE_D)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("4-3") PORT_CODE(KEYCODE_F)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-3") PORT_CODE(KEYCODE_E)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-4") PORT_CODE(KEYCODE_R)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-5") PORT_CODE(KEYCODE_T)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 2-6") PORT_CODE(KEYCODE_Y)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-1") PORT_CODE(KEYCODE_A)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-2") PORT_CODE(KEYCODE_S)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-3") PORT_CODE(KEYCODE_D)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-4") PORT_CODE(KEYCODE_F)
 
 	PORT_START("IN2")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("5-3") PORT_CODE(KEYCODE_G)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("6-3") PORT_CODE(KEYCODE_H)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-4") PORT_CODE(KEYCODE_Z)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-4") PORT_CODE(KEYCODE_X)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-4") PORT_CODE(KEYCODE_C)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("4-4") PORT_CODE(KEYCODE_V)
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("5-4") PORT_CODE(KEYCODE_B)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("6-4") PORT_CODE(KEYCODE_N)
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-5") PORT_CODE(KEYCODE_G)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 3-6") PORT_CODE(KEYCODE_H)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-1") PORT_CODE(KEYCODE_Z)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-2") PORT_CODE(KEYCODE_X)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-3") PORT_CODE(KEYCODE_C)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-4") PORT_CODE(KEYCODE_V)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-5") PORT_CODE(KEYCODE_B)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 4-6") PORT_CODE(KEYCODE_N)
 
 	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("1-5") PORT_CODE(KEYCODE_LSHIFT)
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("2-5") PORT_CODE(KEYCODE_LCONTROL)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("3-5") PORT_CODE(KEYCODE_LALT)
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("4-5") PORT_CODE(KEYCODE_SPACE)
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("5-5") PORT_CODE(KEYCODE_RALT)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("6-5") PORT_CODE(KEYCODE_RCONTROL)
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-1") PORT_CODE(KEYCODE_LSHIFT)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-2") PORT_CODE(KEYCODE_LCONTROL)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-3") PORT_CODE(KEYCODE_LALT)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-4") PORT_CODE(KEYCODE_SPACE)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-5") PORT_CODE(KEYCODE_RALT)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Button 5-6") PORT_CODE(KEYCODE_RCONTROL)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("SYSTEM")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CODE(KEYCODE_5_PAD)
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CODE(KEYCODE_6_PAD)
-	PORT_DIPNAME( 0x08, 0x08, "SYSTEM" )
+	PORT_SERVICE( 0x01, IP_ACTIVE_LOW )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_CODE(KEYCODE_7)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_CODE(KEYCODE_8)
+	PORT_DIPNAME( 0x08, 0x08, "UNK3" )
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x10, 0x10, "UNK4" )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x20, 0x20, "UNK5" )
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x40, 0x40, "UNK6" )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x80, "UNK7" )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
@@ -272,24 +247,12 @@
 	MCFG_MACHINE_START(30test)
 	MCFG_MACHINE_RESET(30test)
 
-	/* video hardware */
-	/* TODO: NOT raster! */
-	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_REFRESH_RATE(60)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
-	MCFG_SCREEN_SIZE(32*8, 32*8)
-	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(30test)
-
-//  MCFG_PALETTE_INIT(30test)
-	MCFG_PALETTE_LENGTH(2)
-
-	MCFG_VIDEO_START(30test)
+	/* no video! */
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_OKIM6295_ADD("oki", 1056000, OKIM6295_PIN7_HIGH) // pin 7 not verified
+	MCFG_OKIM6295_ADD("oki", 1056000, OKIM6295_PIN7_HIGH)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/8080bw.c src/mame/drivers/8080bw.c
--- src-old/mame/drivers/8080bw.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/8080bw.c	2012-02-19 02:53:16.000000000 +0100
@@ -806,8 +806,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(lrescue_samples_interface)
+	MCFG_SAMPLES_ADD("samples", lrescue_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.75)
 
 	/* extra audio channel */
@@ -1624,7 +1623,7 @@
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
 	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_START1 )
 	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-	//PORT_BIT( 0x70, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM(invaders_in1_control_r, NULL)
+	PORT_BIT( 0x70, IP_ACTIVE_HIGH, IPT_SPECIAL ) PORT_CUSTOM(invaders_in1_control_r, NULL)
 	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNUSED )
 
 	PORT_START("IN1")
@@ -1645,9 +1644,6 @@
 	/* Dummy controls port, P1 */
 	INVADERS_CONTROL_PORT_P1
 
-	/* Dummy controls port, P2 */
-	INVADERS_CONTROL_PORT_P2
-
 	/* Dummy port for cocktail mode (not used) */
 	PORT_START(CABINET_PORT_TAG)
 	PORT_BIT( 0xff, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -2552,8 +2548,8 @@
 	ROM_LOAD( "sv06.41",     0x1c00, 0x0400, CRC(2c68e0b4) SHA1(a5e5357120102ad32792bf3ef6362f45b7ba7070) )
 
 	ROM_REGION( 0x0800, "proms", 0 )		/* color maps player 1/player 2 */
-	ROM_LOAD( "cv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
-	ROM_LOAD( "cv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
+	ROM_LOAD( "sv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
+	ROM_LOAD( "sv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
 ROM_END
 
 ROM_START( sisv2 )
@@ -2566,8 +2562,8 @@
 	ROM_LOAD( "sv14.41",     0x1c00, 0x0400, CRC(58730370) SHA1(13dc806bcecd2d6089a85dd710ac2869413f7475) )
 
 	ROM_REGION( 0x0800, "proms", 0 )		/* color maps player 1/player 2 */
-	ROM_LOAD( "cv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
-	ROM_LOAD( "cv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
+	ROM_LOAD( "sv01.1",      0x0000, 0x0400, CRC(aac24f34) SHA1(ad110e776547fb48baac568bb50d61854537ca34) )
+	ROM_LOAD( "sv02.2",      0x0400, 0x0400, CRC(2bdf83a0) SHA1(01ffbd43964c41987e7d44816271308f9a70802b) )
 ROM_END
 
 ROM_START( spceking )
@@ -2643,6 +2639,20 @@
 	ROM_LOAD( "pv07.2",   0x0400, 0x0400, CRC(2c5b91cb) SHA1(7fa4d4aef85473b1b4f18734230c164e72be44e7) )
 ROM_END
 
+ROM_START( invadpt2br )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "pv01_bad",    0x0000, 0x0800, BAD_DUMP CRC(2931a033) SHA1(b04ccde4a4a04b37aa65edc4af4e53a8c1f03dfe) ) // chunk of garbage in prg area $500-$600, the rest of rom contents is same as parent
+	ROM_LOAD( "pv01",        0x0000, 0x0800, CRC(7288a511) SHA1(ff617872784c28ed03591aefa9f0519e5651701f) ) // so let's load the parent rom instead
+	ROM_LOAD( "br_pv02",     0x0800, 0x0800, CRC(420c7c35) SHA1(b51265f4d9e5a8cf9d53099a97cadd25ea0b34ce) )
+	ROM_LOAD( "br_pv03",     0x1000, 0x0800, CRC(dffd04b9) SHA1(d51a0f27e90b0a49cf2d57ec82a863dcae9f3ea4) )
+	ROM_LOAD( "br_pv04",     0x1800, 0x0800, CRC(b0626aff) SHA1(b7de6c21030732bd0479228f057ca4c87b913b0a) )
+	ROM_LOAD( "br_pv05",     0x4000, 0x0800, CRC(84c70bb8) SHA1(75fef3ee6da3e7e01a257629016bc10a23691d62) )
+
+	ROM_REGION( 0x0800, "proms", 0 )		/* color maps player 1/player 2 (taken from parent set) */
+	ROM_LOAD( "pv06.1",   0x0000, 0x0400, CRC(a732810b) SHA1(a5fabffa73ca740909e23b9530936f9274dff356) )
+	ROM_LOAD( "pv07.2",   0x0400, 0x0400, CRC(2c5b91cb) SHA1(7fa4d4aef85473b1b4f18734230c164e72be44e7) )
+ROM_END
+
 ROM_START( invaddlx )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "invdelux.h",   0x0000, 0x0800, CRC(e690818f) SHA1(0860fb03a64d34a9704a1459a5e96929eafd39c7) )
@@ -3367,7 +3377,7 @@
 
 ROM_START( galactic )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1",       0x0000, 0x0800, CRC(b5098f1e) SHA1(9d1d045d8abeafd4716d3052fe93e52c6b347049) )
+	ROM_LOAD( "1_gal",   0x0000, 0x0800, CRC(b5098f1e) SHA1(9d1d045d8abeafd4716d3052fe93e52c6b347049) )
 	ROM_LOAD( "2",       0x0800, 0x0800, CRC(f97410ee) SHA1(47f1f296c905fa13f6c521edc12c10f1f0e42400) )
 	ROM_LOAD( "3",       0x1000, 0x0800, CRC(c1175feb) SHA1(83bf955ed3a52e1ce8c688d89725d8dee1bcc866) )
 	ROM_LOAD( "4",       0x1800, 0x0800, CRC(b4451d7c) SHA1(62a18e8e927ef00a7f6cb933cdc5aeae9f074dc0) )
@@ -3378,7 +3388,7 @@
 
 ROM_START( spacmiss )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1",       0x0000, 0x0800, CRC(e212dc88) SHA1(bc56052bf43d18081f777b936b2be792e91ba842) )
+	ROM_LOAD( "1_sm",    0x0000, 0x0800, CRC(e212dc88) SHA1(bc56052bf43d18081f777b936b2be792e91ba842) )
 	ROM_LOAD( "2",       0x0800, 0x0800, CRC(f97410ee) SHA1(47f1f296c905fa13f6c521edc12c10f1f0e42400) )
 	ROM_LOAD( "3",       0x1000, 0x0800, CRC(c1175feb) SHA1(83bf955ed3a52e1ce8c688d89725d8dee1bcc866) )
 	ROM_LOAD( "4",       0x1800, 0x0800, CRC(b4451d7c) SHA1(62a18e8e927ef00a7f6cb933cdc5aeae9f074dc0) )
@@ -3407,6 +3417,7 @@
 GAME( 1979, grescue,  lrescue,  lrescue,  lrescue,  0, ROT270, "Taito (Universal license?)", "Galaxy Rescue", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1979, desterth, lrescue,  lrescue,  invrvnge, 0, ROT270, "bootleg", "Destination Earth", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1979, invadpt2, 0,        invadpt2, invadpt2, 0, ROT270, "Taito", "Space Invaders Part II (Taito)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
+GAME( 1979, invadpt2br,invadpt2,invadpt2, invadpt2, 0, ROT270, "Taito do Brasil", "Space Invaders Part II (Brazil)", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
 GAME( 1980, invaddlx, invadpt2, invaders, invadpt2, 0, ROT270, "Taito (Midway license)", "Space Invaders Deluxe", GAME_SUPPORTS_SAVE )
 GAME( 1980, vortex,   0,        vortex,   vortex, vortex, ROT270, "Zilec Electronics", "Vortex", GAME_IMPERFECT_COLORS | GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND ) /* Encrypted 8080/IO */
 GAME( 1979, cosmo,    0,        cosmo,    cosmo,    0, ROT90,  "TDS & Mints", "Cosmo", GAME_SUPPORTS_SAVE | GAME_IMPERFECT_SOUND )
diff -Nru src-old/mame/drivers/aleck64.c src/mame/drivers/aleck64.c
--- src-old/mame/drivers/aleck64.c	2012-01-17 20:16:44.000000000 +0100
+++ src/mame/drivers/aleck64.c	2012-02-13 17:12:01.000000000 +0100
@@ -800,18 +800,12 @@
 	62500000			/* system clock */
 };
 
-static INTERRUPT_GEN( n64_vblank )
-{
-	signal_rcp_interrupt(device->machine(), VI_INTERRUPT);
-}
-
-static MACHINE_CONFIG_START( aleck64, _n64_state )
+static MACHINE_CONFIG_START( aleck64, n64_state )
 
 	/* basic machine hardware */
 	MCFG_CPU_ADD("maincpu", VR4300BE, 93750000)
 	MCFG_CPU_CONFIG(vr4300_config)
 	MCFG_CPU_PROGRAM_MAP(n64_map)
-	MCFG_CPU_VBLANK_INT("screen", n64_vblank)
 
 	MCFG_CPU_ADD("rsp", RSP, 62500000)
 	MCFG_CPU_CONFIG(n64_rsp_config)
diff -Nru src-old/mame/drivers/aristmk4.c src/mame/drivers/aristmk4.c
--- src-old/mame/drivers/aristmk4.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/aristmk4.c	2012-02-19 02:53:16.000000000 +0100
@@ -266,7 +266,7 @@
 
 	int m_rtc_address_strobe;
 	int m_rtc_data_strobe;
-	device_t *m_samples;
+	samples_device *m_samples;
 	UINT8 *m_shapeRomPtr;
 	UINT8 m_shapeRom[0xc000];
 	UINT8 *m_mkiv_vram;
@@ -577,7 +577,7 @@
 		if(emet[i])
 		{
 		//logerror("Mechanical meter %d pulse: %02d\n",i+1, emet[i]);
-		sample_start(state->m_samples,i,0, FALSE); // pulse sound for mechanical meters
+		state->m_samples->start(i,0); // pulse sound for mechanical meters
 		}
 	}
 }
@@ -586,7 +586,7 @@
 
 static const char *const meter_sample_names[] =
 {
-	"*aristmk4",
+	"*3bagflvt",
 	"tick",
 	0
 };
@@ -1617,7 +1617,7 @@
 {
 	aristmk4_state *state = machine.driver_data<aristmk4_state>();
 
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 	state_save_register_global_pointer(machine, state->m_nvram, 0x1000); // state->m_nvram
 }
 
@@ -1701,8 +1701,7 @@
 	MCFG_SOUND_CONFIG(ay8910_config2)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.40)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(meter_samples_interface)
+	MCFG_SAMPLES_ADD("samples", meter_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.05)
 
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/astinvad.c src/mame/drivers/astinvad.c
--- src-old/mame/drivers/astinvad.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/astinvad.c	2012-02-19 02:53:16.000000000 +0100
@@ -61,7 +61,7 @@
 	device_t *m_maincpu;
 	device_t *m_ppi8255_0;
 	device_t *m_ppi8255_1;
-	device_t *m_samples;
+	samples_device *m_samples;
 };
 
 
@@ -230,7 +230,7 @@
 	state->m_maincpu = machine.device("maincpu");
 	state->m_ppi8255_0 = machine.device("ppi8255_0");
 	state->m_ppi8255_1 = machine.device("ppi8255_1");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->m_int_timer = machine.scheduler().timer_alloc(FUNC(kamizake_int_gen));
 	state->m_int_timer->adjust(machine.primary_screen->time_until_pos(128), 128);
@@ -256,7 +256,7 @@
 	astinvad_state *state = machine.driver_data<astinvad_state>();
 
 	state->m_maincpu = machine.device("maincpu");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->save_item(NAME(state->m_screen_flip));
 	state->save_item(NAME(state->m_sound_state));
@@ -327,11 +327,11 @@
 	int bits_gone_hi = data & ~state->m_sound_state[0];
 	state->m_sound_state[0] = data;
 
-	if (bits_gone_hi & 0x01) sample_start(state->m_samples, 0, SND_UFO, 1);
-	if (!(data & 0x01))      sample_stop(state->m_samples, 0);
-	if (bits_gone_hi & 0x02) sample_start(state->m_samples, 1, SND_SHOT, 0);
-	if (bits_gone_hi & 0x04) sample_start(state->m_samples, 2, SND_BASEHIT, 0);
-	if (bits_gone_hi & 0x08) sample_start(state->m_samples, 3, SND_INVADERHIT, 0);
+	if (bits_gone_hi & 0x01) state->m_samples->start(0, SND_UFO, true);
+	if (!(data & 0x01))      state->m_samples->stop(0);
+	if (bits_gone_hi & 0x02) state->m_samples->start(1, SND_SHOT);
+	if (bits_gone_hi & 0x04) state->m_samples->start(2, SND_BASEHIT);
+	if (bits_gone_hi & 0x08) state->m_samples->start(3, SND_INVADERHIT);
 
 	device->machine().sound().system_enable(data & 0x20);
 	state->m_screen_red = data & 0x04;
@@ -344,11 +344,11 @@
 	int bits_gone_hi = data & ~state->m_sound_state[1];
 	state->m_sound_state[1] = data;
 
-	if (bits_gone_hi & 0x01) sample_start(state->m_samples, 5, SND_FLEET1, 0);
-	if (bits_gone_hi & 0x02) sample_start(state->m_samples, 5, SND_FLEET2, 0);
-	if (bits_gone_hi & 0x04) sample_start(state->m_samples, 5, SND_FLEET3, 0);
-	if (bits_gone_hi & 0x08) sample_start(state->m_samples, 5, SND_FLEET4, 0);
-	if (bits_gone_hi & 0x10) sample_start(state->m_samples, 4, SND_UFOHIT, 0);
+	if (bits_gone_hi & 0x01) state->m_samples->start(5, SND_FLEET1);
+	if (bits_gone_hi & 0x02) state->m_samples->start(5, SND_FLEET2);
+	if (bits_gone_hi & 0x04) state->m_samples->start(5, SND_FLEET3);
+	if (bits_gone_hi & 0x08) state->m_samples->start(5, SND_FLEET4);
+	if (bits_gone_hi & 0x10) state->m_samples->start(4, SND_UFOHIT);
 
 	state->m_screen_flip = (input_port_read(device->machine(), "CABINET") & data & 0x20) ? 0xff : 0x00;
 }
@@ -360,16 +360,16 @@
 	int bits_gone_hi = data & ~state->m_sound_state[0];
 	state->m_sound_state[0] = data;
 
-	if (bits_gone_hi & 0x01) sample_start(state->m_samples, 1, SND_SHOT, 0);
-	if (bits_gone_hi & 0x02) sample_start(state->m_samples, 2, SND_BASEHIT, 0);
-	if (bits_gone_hi & 0x04) sample_start(state->m_samples, 4, SND_UFOHIT, 0);
-	if (bits_gone_hi & 0x08) sample_start(state->m_samples, 0, SND_UFO, 1);
-	if (!(data & 0x08))      sample_stop(state->m_samples, 0);
-
-	if (bits_gone_hi & 0x10) sample_start(state->m_samples, 5, SND_FLEET1, 0);
-	if (bits_gone_hi & 0x20) sample_start(state->m_samples, 5, SND_FLEET2, 0);
-	if (bits_gone_hi & 0x40) sample_start(state->m_samples, 5, SND_FLEET3, 0);
-	if (bits_gone_hi & 0x80) sample_start(state->m_samples, 5, SND_FLEET4, 0);
+	if (bits_gone_hi & 0x01) state->m_samples->start(1, SND_SHOT);
+	if (bits_gone_hi & 0x02) state->m_samples->start(2, SND_BASEHIT);
+	if (bits_gone_hi & 0x04) state->m_samples->start(4, SND_UFOHIT);
+	if (bits_gone_hi & 0x08) state->m_samples->start(0, SND_UFO, true);
+	if (!(data & 0x08))      state->m_samples->stop(0);
+
+	if (bits_gone_hi & 0x10) state->m_samples->start(5, SND_FLEET1);
+	if (bits_gone_hi & 0x20) state->m_samples->start(5, SND_FLEET2);
+	if (bits_gone_hi & 0x40) state->m_samples->start(5, SND_FLEET3);
+	if (bits_gone_hi & 0x80) state->m_samples->start(5, SND_FLEET4);
 }
 
 
@@ -381,7 +381,7 @@
 
 	space->machine().sound().system_enable(data & 0x02);
 
-	if (bits_gone_hi & 0x04) sample_start(state->m_samples, 3, SND_INVADERHIT, 0);
+	if (bits_gone_hi & 0x04) state->m_samples->start(3, SND_INVADERHIT);
 
 	state->m_screen_flip = (input_port_read(space->machine(), "CABINET") & data & 0x80) ? 0xff : 0x00;
 }
@@ -605,8 +605,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(astinvad_samples_interface)
+	MCFG_SAMPLES_ADD("samples", astinvad_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -642,8 +641,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(astinvad_samples_interface)
+	MCFG_SAMPLES_ADD("samples", astinvad_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/astrocde.c src/mame/drivers/astrocde.c
--- src-old/mame/drivers/astrocde.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/astrocde.c	2012-02-19 02:53:16.000000000 +0100
@@ -205,46 +205,46 @@
 static WRITE8_HANDLER( seawolf2_sound_1_w )  // Port 40
 {
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 rising_bits = data & ~state->m_port_1_last;
 	state->m_port_1_last = data;
 
-	if (rising_bits & 0x01) sample_start(samples, 1, 1, 0);  /* Left Torpedo */
-	if (rising_bits & 0x02) sample_start(samples, 0, 0, 0);  /* Left Ship Hit */
-	if (rising_bits & 0x04) sample_start(samples, 4, 4, 0);  /* Left Mine Hit */
-	if (rising_bits & 0x08) sample_start(samples, 6, 1, 0);  /* Right Torpedo */
-	if (rising_bits & 0x10) sample_start(samples, 5, 0, 0);  /* Right Ship Hit */
-	if (rising_bits & 0x20) sample_start(samples, 9, 4, 0);  /* Right Mine Hit */
+	if (rising_bits & 0x01) samples->start(1, 1);  /* Left Torpedo */
+	if (rising_bits & 0x02) samples->start(0, 0);  /* Left Ship Hit */
+	if (rising_bits & 0x04) samples->start(4, 4);  /* Left Mine Hit */
+	if (rising_bits & 0x08) samples->start(6, 1);  /* Right Torpedo */
+	if (rising_bits & 0x10) samples->start(5, 0);  /* Right Ship Hit */
+	if (rising_bits & 0x20) samples->start(9, 4);  /* Right Mine Hit */
 }
 
 
 static WRITE8_HANDLER( seawolf2_sound_2_w )  // Port 41
 {
 	astrocde_state *state = space->machine().driver_data<astrocde_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 rising_bits = data & ~state->m_port_2_last;
 	state->m_port_2_last = data;
 
-	sample_set_volume(samples, 0, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 1, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 3, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 4, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 5, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 6, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 8, (data & 0x80) ? 1.0 : 0.0);
-	sample_set_volume(samples, 9, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(0, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(1, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(3, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(4, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(5, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(6, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(8, (data & 0x80) ? 1.0 : 0.0);
+	samples->set_volume(9, (data & 0x80) ? 1.0 : 0.0);
 
 	/* dive panning controlled by low 3 bits */
-	sample_set_volume(samples, 2, (float)(~data & 0x07) / 7.0);
-	sample_set_volume(samples, 7, (float)(data & 0x07) / 7.0);
+	samples->set_volume(2, (float)(~data & 0x07) / 7.0);
+	samples->set_volume(7, (float)(data & 0x07) / 7.0);
 
 	if (rising_bits & 0x08)
 	{
-		sample_start(samples, 2, 2, 0);
-		sample_start(samples, 7, 2, 0);
+		samples->start(2, 2);
+		samples->start(7, 2);
 	}
-	if (rising_bits & 0x10) sample_start(samples, 8, 3, 0);  /* Right Sonar */
-	if (rising_bits & 0x20) sample_start(samples, 3, 3, 0);  /* Left Sonar */
+	if (rising_bits & 0x10) samples->start(8, 3);  /* Right Sonar */
+	if (rising_bits & 0x20) samples->start(3, 3);  /* Left Sonar */
 
 	coin_counter_w(space->machine(), 0, data & 0x40);    /* Coin Counter */
 }
@@ -1370,8 +1370,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(seawolf2_samples_interface)
+	MCFG_SAMPLES_ADD("samples", seawolf2_samples_interface)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.25)
 	MCFG_SOUND_ROUTE(1, "lspeaker", 0.25)
 	MCFG_SOUND_ROUTE(2, "lspeaker", 0.25)
@@ -1421,8 +1420,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_ADD("center", 0.0, 0.0, 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(wow_samples_interface)
+	MCFG_SAMPLES_ADD("samples", wow_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "center", 0.85)
 MACHINE_CONFIG_END
 
@@ -1448,8 +1446,7 @@
 	MCFG_SOUND_ADD("astrocade2",  ASTROCADE, ASTROCADE_CLOCK/4)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lower", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gorf_samples_interface)
+	MCFG_SAMPLES_ADD("samples", gorf_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "upper", 0.85)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/astrocorp.c src/mame/drivers/astrocorp.c
--- src-old/mame/drivers/astrocorp.c	2012-01-15 02:13:13.000000000 +0100
+++ src/mame/drivers/astrocorp.c	2012-02-18 03:48:45.000000000 +0100
@@ -907,15 +907,15 @@
 
 ROM_START( winbingoa )
 	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "f29c51001t.u31", 0x00000, 0x20000, CRC(c33676c3) SHA1(9f5b7d05d187cf59948a572f80c55cb8fa1f656f) )
-	ROM_LOAD16_BYTE( "f29c51001t.u25", 0x00001, 0x20000, CRC(43c7b2d8) SHA1(16ee79c34b7c485dfccecdf3e0ae9f18f8a20150) )
+	ROM_LOAD16_BYTE( "f29c51001t_alt.u31", 0x00000, 0x20000, CRC(c33676c3) SHA1(9f5b7d05d187cf59948a572f80c55cb8fa1f656f) )
+	ROM_LOAD16_BYTE( "f29c51001t_alt.u25", 0x00001, 0x20000, CRC(43c7b2d8) SHA1(16ee79c34b7c485dfccecdf3e0ae9f18f8a20150) )
 
 	ROM_REGION( 0x400000, "sprites", 0 )
 	ROM_LOAD( "mx29f1610mc.u26", 0x000000, 0x200000, CRC(ad1f61e7) SHA1(845aa01d49c50bcadaed16d76c0dd9131a425b46) )
 	ROM_LOAD( "mx29f1610mc.u30", 0x200000, 0x200000, CRC(31613d99) SHA1(1c720f8d981c3e9cb9d9b3b27eb95e7f72ccfc93) )
 
 	ROM_REGION( 0x80000, "oki", 0 )
-	ROM_LOAD( "mx27c4000pc.u35", 0x00000, 0x80000, CRC(e48ed57d) SHA1(11995b90e70e010b292ba9db2da0af4ebf795c1a) )
+	ROM_LOAD( "mx27c4000pc_alt.u35", 0x00000, 0x80000, CRC(e48ed57d) SHA1(11995b90e70e010b292ba9db2da0af4ebf795c1a) )
 ROM_END
 
 /***************************************************************************
diff -Nru src-old/mame/drivers/astrof.c src/mame/drivers/astrof.c
--- src-old/mame/drivers/astrof.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/astrof.c	2012-02-19 02:53:16.000000000 +0100
@@ -501,7 +501,7 @@
 	astrof_set_video_control_2(machine, 0xff);
 
 	state->m_maincpu = machine.device("maincpu");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	/* register for state saving */
 	state->save_item(NAME(state->m_red_on));
diff -Nru src-old/mame/drivers/balsente.c src/mame/drivers/balsente.c
--- src-old/mame/drivers/balsente.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/balsente.c	2012-02-19 01:27:36.000000000 +0100
@@ -1830,7 +1830,7 @@
 	ROM_LOAD( "cd01.u4a",  0x20000, 0x4000, CRC(75e9b51a) SHA1(dbe575d37836245746ea85ffe85e8e6665ec37ea) )
 	ROM_LOAD( "cd23.u3a",  0x24000, 0x4000, CRC(0a32e0a5) SHA1(dedbe08aed483bae27e1a607334e24cdfcb2f851) )
 	ROM_LOAD( "cd45.u2a",  0x28000, 0x4000, CRC(9bb292fe) SHA1(6fc7abcc110c2cf7399d11a478cfdadb3439b6ab) )
-	ROM_LOAD( "cd6ef.u1a", 0x2c000, 0x4000, CRC(c77d2302) SHA1(2b0956a7d6bdff5e4f77084149a9528fb07154dc) )
+	ROM_LOAD( "ns2_cd6ef.u1a", 0x2c000, 0x4000, CRC(c77d2302) SHA1(2b0956a7d6bdff5e4f77084149a9528fb07154dc) )
 
 	SOUNDBOARD_ROMS
 
@@ -1897,16 +1897,16 @@
 
 ROM_START( spiker2 ) /* Spiker U.R. 5/5/86 */
 	ROM_REGION( 0x40000, "maincpu", 0 )     /* 64k for code for the first CPU, plus 128k of banked ROMs */
-	ROM_LOAD( "ab01.u8a",  0x10000, 0x4000, CRC(59025e39) SHA1(f0e3e45bb32cc6664831c4ef6b0cfabf3fc71f58) )
-	ROM_LOAD( "ab23.u7a",  0x14000, 0x4000, CRC(ffb23288) SHA1(3458e486794f6c936d15e837be0f419027b01311) )
-	ROM_LOAD( "cd6ef.u1a", 0x2c000, 0x4000, CRC(7f04774d) SHA1(c49ac3aa86425cdbab9877fc253999329bb99a49) )
+	ROM_LOAD( "ab01_050586.u8a",  0x10000, 0x4000, CRC(59025e39) SHA1(f0e3e45bb32cc6664831c4ef6b0cfabf3fc71f58) )
+	ROM_LOAD( "ab23_050586.u7a",  0x14000, 0x4000, CRC(ffb23288) SHA1(3458e486794f6c936d15e837be0f419027b01311) )
+	ROM_LOAD( "cd6ef_050586.u1a", 0x2c000, 0x4000, CRC(7f04774d) SHA1(c49ac3aa86425cdbab9877fc253999329bb99a49) )
 
 	SOUNDBOARD_ROMS
 
 	ROM_REGION( 0x10000, "gfx1", 0 )		/* up to 64k of sprites */
-	ROM_LOAD( "gr01.u4c", 0x00000, 0x4000, CRC(1228b7a3) SHA1(70a207714ba7bc4f4dbc492768480afa424b31c0) )
-	ROM_LOAD( "gr23.u3c", 0x04000, 0x4000, CRC(970c81f6) SHA1(f22189e172a795d115597feb48ccbc04be3859b9) )
-	ROM_LOAD( "gr45.u2c", 0x08000, 0x4000, CRC(bf2b413d) SHA1(f0f797853ac1b6e45ff606d7aa5c9350765efd48) )
+	ROM_LOAD( "gr01_050586.u4c", 0x00000, 0x4000, CRC(1228b7a3) SHA1(70a207714ba7bc4f4dbc492768480afa424b31c0) )
+	ROM_LOAD( "gr23.u3c",        0x04000, 0x4000, CRC(970c81f6) SHA1(f22189e172a795d115597feb48ccbc04be3859b9) )
+	ROM_LOAD( "gr45_050586.u2c", 0x08000, 0x4000, CRC(bf2b413d) SHA1(f0f797853ac1b6e45ff606d7aa5c9350765efd48) )
 
 	ROM_REGION( 0x00001, "cart_pals", 0) /* PAL's located on the cartridge */
 	ROM_LOAD( "pal16r8.u7c", 0x0000, 0x0001, NO_DUMP ) /* PAL16R8ANC */
@@ -1919,7 +1919,7 @@
 	ROM_REGION( 0x40000, "maincpu", 0 )     /* 64k for code for the first CPU, plus 128k of banked ROMs */
 	ROM_LOAD( "ab01.u8a",  0x10000, 0x4000, CRC(2d53d023) SHA1(01c1d2cd7d8be60c40527e9c1571b84388a39bd8) )
 	ROM_LOAD( "ab23.u7a",  0x14000, 0x4000, CRC(3be87edf) SHA1(0d4f1ff501d5d865abc3906f6b232ec04586d3dc) )
-	ROM_LOAD( "cd6ef.u1a", 0x2c000, 0x4000, CRC(5b5a6d86) SHA1(a173637991601adc87f0fc8fd1ee9102f5fb2b81) )
+	ROM_LOAD( "cd6ef_060686.u1a", 0x2c000, 0x4000, CRC(5b5a6d86) SHA1(a173637991601adc87f0fc8fd1ee9102f5fb2b81) )
 
 	SOUNDBOARD_ROMS
 
diff -Nru src-old/mame/drivers/bfcobra.c src/mame/drivers/bfcobra.c
--- src-old/mame/drivers/bfcobra.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/bfcobra.c	2012-02-11 11:01:01.000000000 +0100
@@ -1398,7 +1398,7 @@
 		if (changed & (1 << i))
 		{
 			MechMtr_update(i, data & (1 << i) );
-			generic_pulse_irq_line(&space->device(), M6809_FIRQ_LINE);
+			generic_pulse_irq_line(&space->device(), M6809_FIRQ_LINE, 1);
 		}
 	}
 }
@@ -1756,7 +1756,7 @@
 /* TODO */
 static INTERRUPT_GEN( timer_irq )
 {
-	generic_pulse_irq_line(device, M6809_IRQ_LINE);
+	generic_pulse_irq_line(device, M6809_IRQ_LINE, 1);
 }
 
 /* TODO */
diff -Nru src-old/mame/drivers/bfm_sc1.c src/mame/drivers/bfm_sc1.c
--- src-old/mame/drivers/bfm_sc1.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/bfm_sc1.c	2012-02-11 11:01:01.000000000 +0100
@@ -176,7 +176,7 @@
 
 	    state->m_sc1_Inputs[2] = input_port_read(device->machine(),"STROBE0");
 
-		generic_pulse_irq_line(device->machine().device("maincpu"), M6809_IRQ_LINE);
+		generic_pulse_irq_line(device->machine().device("maincpu"), M6809_IRQ_LINE, 1);
 	}
 }
 
@@ -277,7 +277,7 @@
 			if ( changed & (1 << i) )
 			{
 				MechMtr_update(i, data & (1 << i) );
-				generic_pulse_irq_line(space->machine().device("maincpu"), M6809_FIRQ_LINE);
+				generic_pulse_irq_line(space->machine().device("maincpu"), M6809_FIRQ_LINE, 1);
 			}
 		}
 	}
diff -Nru src-old/mame/drivers/bfm_sc2.c src/mame/drivers/bfm_sc2.c
--- src-old/mame/drivers/bfm_sc2.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/bfm_sc2.c	2012-02-19 02:23:50.000000000 +0100
@@ -444,7 +444,7 @@
 		state->m_irq_timer_stat = 0x01;
 		state->m_irq_status     = 0x02;
 
-		generic_pulse_irq_line(device, M6809_IRQ_LINE);
+		generic_pulse_irq_line(device, M6809_IRQ_LINE, 1);
 	}
 }
 
@@ -4930,6 +4930,9 @@
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "alongtheprom.bin", 0x0000, 0x010000, CRC(0f212ba9) SHA1(34dfe67f8cbdf1cba806dcc7a3e872a8b59747d3) )
 
+	ROM_REGION( 0x20000, "matrix", 0 )
+	ROM_LOAD("alongthepromdot.bin",  0x00000, 0x10000, CRC(b5a96f4d) SHA1(716dda738e8437b13cb72a6b071e0898abceb647))
+
 	ROM_REGION( 0x200000, "upd", ROMREGION_ERASE00 )
 	ROM_LOAD( "alongthepromsnd.bin", 0x0000, 0x040000, CRC(380f56af) SHA1(9125c09e6585e6f4a2de9ea8715371662245aa9a) )
 ROM_END
@@ -5118,7 +5121,7 @@
 
 ROM_START( sc2scshxstar )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "scxsp10.bin", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
+	ROM_LOAD( "scxsp10_star.bin", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
 	ROM_REGION( 0x200000, "altrevs", ROMREGION_ERASE00 )
 	ROM_LOAD( "cxspv1gr", 0x0000, 0x010000, CRC(67f69bd4) SHA1(ee2dd0cd98c98a4727df8c7c721de9ac49b583ff) )
 	ROM_LOAD( "cxspv2gr", 0x0000, 0x010000, CRC(2fe512ad) SHA1(d409f27a62405dc45f487f9351e4d158e4d35440) )
@@ -5474,10 +5477,9 @@
 // custom Global sound system?
 GAME( 199?, sc2dick		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Global",   "Spotted Dick (Global) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2pick		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Global",   "Pick Of The Bunch (Global) (Scorpion 2/3)", GAME_FLAGS)
-GAME( 199?, sc2rock		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Global",   "How Big's Your Rock (Global) (Scorpion 2/3)", GAME_FLAGS)
+GAME( 199?, sc2rock		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Global",   "How Big's Your Rock? (Global) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2call		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Global",   "It's Your Call (Global) (Scorpion 2/3)", GAME_FLAGS)
 
-GAME( 199?, sc2prom		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "BFM",   "Along The Prom (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2payr		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "BFM/Mazooma",   "Pay Roll Casino (Bellfruit/Mazooma) (Scorpion 2/3)", GAME_FLAGS)
 
 GAME( 199?, sc2bar7		, 0			,  scorpion2		, drwho		, drwho		, 0,		 "Concept",   "Bar 7 (Concept)", GAME_FLAGS)
@@ -5525,5 +5527,6 @@
 GAME( 199?, sc2cops		, 0			,  scorpion2_dm01	, drwho		, drwho		, 0,		 "BFM",      "Cops 'n' Robbers (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2copcl	, 0			,  scorpion2_dm01	, drwho		, drwho		, 0,		 "BFM",      "Cops 'n' Robbers Club (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2copdc	, 0			,  scorpion2_dm01	, drwho		, drwho		, 0,		 "BFM",      "Cops 'n' Robbers Club Deluxe (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
+GAME( 199?, sc2prom		, 0			,  scorpion2_dm01	, drwho		, drwho		, 0,		 "BFM",      "Along The Prom (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
 GAME( 199?, sc2prem		, 0			,  scorpion2_dm01	, drwho		, drwho		, 0,		 "BFM",      "Premier Club Manager (Bellfruit) (Scorpion 2/3)", GAME_FLAGS)
 
diff -Nru src-old/mame/drivers/bfm_sc4.c src/mame/drivers/bfm_sc4.c
--- src-old/mame/drivers/bfm_sc4.c	2012-01-05 01:13:16.000000000 +0100
+++ src/mame/drivers/bfm_sc4.c	2012-02-19 05:06:59.000000000 +0100
@@ -24727,11 +24727,11 @@
 GAME( 200?, sc4quartm	,sc4quart,	sc4, sc4, sc4, ROT0, "Mazooma","Quaterback (PR2064) (German) (Mazooma) (Scorpion 4) (set 8)", GAME_IS_SKELETON_MECHANICAL )
 
 // QUAZZI MO' DOUGH..........QUAZZSND.......  (no standard header)
-GAME( 200?, sc4qmodo	,0,			sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo Dough (Qps) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4qmodoa	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo Dough (Qps) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4qmodob	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo Dough (Qps) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4qmodoc	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo Dough (Qps) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, sc4qmodod	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo Dough (Qps) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4qmodo	,       0,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo' Dough (Qps) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4qmodoa	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo' Dough (Qps) (Scorpion 4) (set 2)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4qmodob	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo' Dough (Qps) (Scorpion 4) (set 3)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4qmodoc	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo' Dough (Qps) (Scorpion 4) (set 4)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, sc4qmodod	,sc4qmodo,	sc4, sc4, sc4, ROT0, "Qps","Quazzi Mo' Dough (Qps) (Scorpion 4) (set 5)", GAME_IS_SKELETON_MECHANICAL )
 
 
 GAME( 200?, sc4quidr	,0,			sc4, sc4, sc4, ROT0, "Qps","Quid Rock (Qps) (Scorpion 4) (set 1)", GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/bfmsys85.c src/mame/drivers/bfmsys85.c
--- src-old/mame/drivers/bfmsys85.c	2011-08-16 05:44:19.000000000 +0200
+++ src/mame/drivers/bfmsys85.c	2012-02-11 11:01:01.000000000 +0100
@@ -172,7 +172,7 @@
 	if ( state->m_is_timer_enabled )
 	{
 		state->m_irq_status = 0x01 |0x02; //0xff;
-		generic_pulse_irq_line(device, M6809_IRQ_LINE);
+		generic_pulse_irq_line(device, M6809_IRQ_LINE, 1);
 	}
 }
 
@@ -235,7 +235,7 @@
 	for (i=0; i<8; i++)
 	if ( changed & (1 << i) )	MechMtr_update(i, data & (1 << i) );
 
-	if ( data ) generic_pulse_irq_line(space->machine().device("maincpu"), M6809_FIRQ_LINE);
+	if ( data ) generic_pulse_irq_line(space->machine().device("maincpu"), M6809_FIRQ_LINE, 1);
 }
 ///////////////////////////////////////////////////////////////////////////
 
diff -Nru src-old/mame/drivers/blockade.c src/mame/drivers/blockade.c
--- src-old/mame/drivers/blockade.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/blockade.c	2012-02-19 02:53:16.000000000 +0100
@@ -498,8 +498,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(blockade_samples_interface)
+	MCFG_SAMPLES_ADD("samples", blockade_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
diff -Nru src-old/mame/drivers/bntyhunt.c src/mame/drivers/bntyhunt.c
--- src-old/mame/drivers/bntyhunt.c	2012-02-05 14:59:47.000000000 +0100
+++ src/mame/drivers/bntyhunt.c	2012-02-06 23:41:22.000000000 +0100
@@ -1,6 +1,6 @@
 /* Bounty Hunter
 
- PC hardware.. no dumps of the bios roms tho
+ PC hardware.. no dumps of the bios roms are currently available
 
 */
 
@@ -49,7 +49,7 @@
 
 static MACHINE_CONFIG_START( bntyhunt, bntyhunt_state )
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", PENTIUM, 2000000000) /* Probably a Pentium or higher .. ?? Mhz*/
+	MCFG_CPU_ADD("maincpu", PENTIUM, 200000000) /* Probably a Pentium or higher .. ?? Mhz*/
 	MCFG_CPU_PROGRAM_MAP(bntyhunt_map)
 
 	/* video hardware */
@@ -69,7 +69,7 @@
 	ROM_LOAD("bntyhunt.pcbios", 0x000000, 0x10000, NO_DUMP )
 
 	DISK_REGION( "disks" )
-	DISK_IMAGE( "bntyhunt", 0, SHA1(f5c737aaf3da5b57de3fb6bb5dfb85f8f3d4b1b1) )
+	DISK_IMAGE( "bntyhunt", 0, SHA1(e50937d14d5c6adfb5e0012db5a7df090eebc2e1) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/by17.c src/mame/drivers/by17.c
--- src-old/mame/drivers/by17.c	2011-12-23 17:44:48.000000000 +0100
+++ src/mame/drivers/by17.c	2012-02-19 01:27:36.000000000 +0100
@@ -128,7 +128,7 @@
 ROM_START(nightr20)
 	ROM_REGION(0x10000, "maincpu", 0)
 	ROM_LOAD( "721-21_1.716", 0x1000, 0x0800, CRC(237c4060) SHA1(4ce3dba9189fe7666fc76a2c8ee7fff9b12d4c00))
-	ROM_LOAD( "720-20_6.716", 0x1800, 0x0800, CRC(0c17aa4d) SHA1(729e61a29691857112579efcdb96a35e8e5b1279))
+	ROM_LOAD( "rev20_720-20_6.716", 0x1800, 0x0800, CRC(0c17aa4d) SHA1(729e61a29691857112579efcdb96a35e8e5b1279))
 	ROM_RELOAD( 0xf800, 0x0800)
 ROM_END
 
diff -Nru src-old/mame/drivers/calchase.c src/mame/drivers/calchase.c
--- src-old/mame/drivers/calchase.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/calchase.c	2012-02-09 11:27:12.000000000 +0100
@@ -920,7 +920,7 @@
 	MCFG_I8237_ADD( "dma8237_2", XTAL_14_31818MHz/3, dma8237_2_config )
 	MCFG_PIC8259_ADD( "pic8259_1", calchase_pic8259_1_config )
 	MCFG_PIC8259_ADD( "pic8259_2", calchase_pic8259_2_config )
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 	MCFG_PCI_BUS_ADD("pcibus", 0)
@@ -985,7 +985,7 @@
 	ROM_REGION( 0x800, "nvram", 0 )
 	ROM_LOAD( "ds1220y_nv.bin", 0x000, 0x800, CRC(7912c070) SHA1(b4c55c7ca76bcd8dad1c4b50297233349ae02ed3) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE_READONLY( "calchase", 0,SHA1(6ae51a9b3f31cf4166322328a98c0235b0874eb3) )
 ROM_END
 
diff -Nru src-old/mame/drivers/cb2001.c src/mame/drivers/cb2001.c
--- src-old/mame/drivers/cb2001.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/cb2001.c	2012-02-11 11:01:01.000000000 +0100
@@ -736,7 +736,7 @@
 
 static INTERRUPT_GEN( vblank_irq )
 {
-	generic_pulse_irq_line(device, NEC_INPUT_LINE_INTP0);
+	generic_pulse_irq_line(device, NEC_INPUT_LINE_INTP0, 1);
 }
 
 static const gfx_layout cb2001_layout =
diff -Nru src-old/mame/drivers/cball.c src/mame/drivers/cball.c
--- src-old/mame/drivers/cball.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/cball.c	2012-02-11 11:01:01.000000000 +0100
@@ -73,7 +73,7 @@
 	cball_state *state = machine.driver_data<cball_state>();
 	int scanline = param;
 
-	generic_pulse_irq_line(state->m_maincpu, 0);
+	generic_pulse_irq_line(state->m_maincpu, 0, 1);
 
 	scanline = scanline + 32;
 
diff -Nru src-old/mame/drivers/cclimber.c src/mame/drivers/cclimber.c
--- src-old/mame/drivers/cclimber.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/cclimber.c	2012-02-19 02:53:16.000000000 +0100
@@ -1023,8 +1023,7 @@
 	MCFG_SOUND_CONFIG(cclimber_ay8910_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(cclimber_samples_interface)
+	MCFG_SAMPLES_ADD("samples", cclimber_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/changela.c src/mame/drivers/changela.c
--- src-old/mame/drivers/changela.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/changela.c	2012-02-11 11:01:01.000000000 +0100
@@ -433,7 +433,7 @@
 {
 	changela_state *state = device->machine().driver_data<changela_state>();
 
-	generic_pulse_irq_line(state->m_mcu, 0);
+	generic_pulse_irq_line(state->m_mcu, 0, 1);
 }
 
 static MACHINE_START(changela)
diff -Nru src-old/mame/drivers/chihiro.c src/mame/drivers/chihiro.c
--- src-old/mame/drivers/chihiro.c	2012-01-29 03:59:41.000000000 +0100
+++ src/mame/drivers/chihiro.c	2012-02-19 16:23:23.000000000 +0100
@@ -822,33 +822,77 @@
 	pic8259_ir6_w(chihiro_devices.pic8259_2, state); // IRQ 14
 }
 
-void get_info(device_t *device, UINT8 *buffer, UINT16 &cylinders, UINT8 &sectors, UINT8 &heads)
+// ======================> ide_baseboard_device
+
+class ide_baseboard_device : public ide_hdd_device
+{
+public:
+    // construction/destruction
+    ide_baseboard_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock);
+
+	virtual int	 read_sector(UINT32 lba, void *buffer);
+	virtual int	 write_sector(UINT32 lba, const void *buffer);
+	virtual bool is_ready() { return true; }
+	virtual void read_key(UINT8 key[]) { }
+protected:
+    // device-level overrides
+    virtual void device_start();
+	virtual void device_reset();
+};
+
+//**************************************************************************
+//  IDE HARD DISK IMAGE DEVICE
+//**************************************************************************
+
+// device type definition
+const device_type IDE_BASEBOARD = &device_creator<ide_baseboard_device>;
+
+//-------------------------------------------------
+//  ide_baseboard_device - constructor
+//-------------------------------------------------
+
+ide_baseboard_device::ide_baseboard_device(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
+    : ide_hdd_device(mconfig, IDE_BASEBOARD, "IDE Baseboard", tag, owner, clock)
+{
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ide_baseboard_device::device_start()
 {
-	cylinders=65535;
-	sectors=255;
-	heads=255;
 }
 
-int read_sector(device_t *device, UINT32 lba, void *buffer)
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ide_baseboard_device::device_reset()
+{
+	m_num_cylinders=65535;
+	m_num_sectors=255;
+	m_num_heads=255;
+	ide_build_features();
+}
+
+int ide_baseboard_device::read_sector(UINT32 lba, void *buffer)
 {
 	int off;
 	UINT8 *data;
 
 	logerror("baseboard: read sector lba %08x\n",lba);
 	off=(lba&0x7ff)*512;
-	data=device->machine().region("others")->base();
+	data=machine().region("others")->base();
 	memcpy(buffer,data+off,512);
 	return 1;
 }
-
-int write_sector(device_t *device, UINT32 lba, const void *buffer)
+int ide_baseboard_device::write_sector(UINT32 lba, const void *buffer)
 {
 	logerror("baseboard: write sector lba %08x\n",lba);
 	return 1;
 }
 
-ide_hardware baseboard={get_info,read_sector,write_sector};
-
 /*
  * PIC & PIT
  */
@@ -1107,6 +1151,10 @@
 		debug_console_register_command(machine,"chihiro",CMDFLAG_NONE,0,1,4,chihiro_debug_commands);
 }
 
+static SLOT_INTERFACE_START(ide_baseboard)
+	SLOT_INTERFACE("bb", IDE_BASEBOARD)
+SLOT_INTERFACE_END
+
 static MACHINE_CONFIG_START( chihiro_base, driver_device )
 
 	/* basic machine hardware */
@@ -1128,9 +1176,8 @@
 	MCFG_PIC8259_ADD( "pic8259_1", chihiro_pic8259_1_config )
 	MCFG_PIC8259_ADD( "pic8259_2", chihiro_pic8259_2_config )
 	MCFG_PIT8254_ADD( "pit8254", chihiro_pit8254_config )
-	MCFG_IDE_CONTROLLER_ADD( "ide", ide_interrupt )
-	MCFG_IDE_BUS_MASTER_SPACE( "maincpu", PROGRAM )
-	MCFG_IDE_CONNECTED_TO( &baseboard )
+	MCFG_IDE_CONTROLLER_ADD( "ide", ide_interrupt , ide_baseboard, "bb", NULL)
+	MCFG_IDE_BUS_MASTER_SPACE( "ide", "maincpu", PROGRAM )
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/chinagat.c src/mame/drivers/chinagat.c
--- src-old/mame/drivers/chinagat.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/chinagat.c	2012-02-19 01:27:36.000000000 +0100
@@ -764,10 +764,10 @@
 	ROM_LOAD( "23ja-0.100", 0x60000, 0x20000, CRC(f678594f) SHA1(4bdcf9407543925f4630a8c7f1f48b85f76343a9) )	/* 0,1 */
 
 	ROM_REGION(0x40000, "gfx3", 0 )	/* Background */
-	ROM_LOAD( "a-13", 0x00000, 0x10000, NO_DUMP )
-	ROM_LOAD( "a-12", 0x10000, 0x10000, NO_DUMP )
-	ROM_LOAD( "a-15", 0x20000, 0x10000, NO_DUMP )
-	ROM_LOAD( "a-14", 0x30000, 0x10000, NO_DUMP )
+	ROM_LOAD( "saiyugou_a-13", 0x00000, 0x10000, NO_DUMP )
+	ROM_LOAD( "saiyugou_a-12", 0x10000, 0x10000, NO_DUMP )
+	ROM_LOAD( "saiyugou_a-15", 0x20000, 0x10000, NO_DUMP )
+	ROM_LOAD( "saiyugou_a-14", 0x30000, 0x10000, NO_DUMP )
 
 	ROM_REGION(0x40000, "oki", 0 )	/* ADPCM */
 	ROM_LOAD( "23j1-0.53", 0x00000, 0x20000, CRC(f91f1001) SHA1(378402a3c966cabd61e9662ae5decd66672a228b) )
diff -Nru src-old/mame/drivers/circus.c src/mame/drivers/circus.c
--- src-old/mame/drivers/circus.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/circus.c	2012-02-19 02:53:16.000000000 +0100
@@ -266,7 +266,7 @@
 	circus_state *state = machine.driver_data<circus_state>();
 
 	state->m_maincpu = machine.device("maincpu");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 	state->m_discrete = machine.device("discrete");
 
 	state->save_item(NAME(state->m_clown_x));
@@ -311,8 +311,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(circus_samples_interface)
+	MCFG_SAMPLES_ADD("samples", circus_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
@@ -348,8 +347,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(robotbwl_samples_interface)
+	MCFG_SAMPLES_ADD("samples", robotbwl_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
@@ -392,8 +390,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(crash_samples_interface)
+	MCFG_SAMPLES_ADD("samples", crash_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
@@ -428,8 +425,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(ripcord_samples_interface)
+	MCFG_SAMPLES_ADD("samples", ripcord_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
diff -Nru src-old/mame/drivers/cobra.c src/mame/drivers/cobra.c
--- src-old/mame/drivers/cobra.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/cobra.c	2012-02-09 11:27:12.000000000 +0100
@@ -2021,7 +2021,7 @@
 	MCFG_PCI_BUS_ADD("pcibus", 0)
 	MCFG_PCI_BUS_DEVICE(0, NULL, mpc106_pci_r, mpc106_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_VIDEO_START(cobra)
@@ -2142,7 +2142,7 @@
 	ROM_REGION64_BE(0x80000, "user3", 0)		/* Gfx CPU program (PPC604) */
 	ROM_LOAD("645a03.u17", 0x00000, 0x80000, CRC(086abd0b) SHA1(24df439eb9828ed3842f43f5f4014a3fc746e1e3) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE_READONLY( "645c04", 0, SHA1(c0aabe69f6eb4e4cf748d606ae50674297af6a04) )
 ROM_END
 
@@ -2156,7 +2156,7 @@
 	ROM_REGION64_BE(0x80000, "user3", 0)		/* Gfx CPU program (PPC604) */
 	ROM_LOAD( "676a03.u17", 0x000000, 0x080000, CRC(66f77cbd) SHA1(f1c7e50dbbfcc27ac011cbbb8ad2fd376c2e9056) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE_READONLY( "676a04", 0, SHA1(8e89d3e5099e871b99fccba13adaa3cf8a6b71f0) )
 ROM_END
 
diff -Nru src-old/mame/drivers/coolridr.c src/mame/drivers/coolridr.c
--- src-old/mame/drivers/coolridr.c	2012-01-15 02:13:13.000000000 +0100
+++ src/mame/drivers/coolridr.c	2012-02-19 16:23:23.000000000 +0100
@@ -257,6 +257,15 @@
 public:
 	coolridr_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag),
+        m_textBytesToWrite(0x00),
+		m_blitterSerialCount(0x00),
+		m_blitterMode(0x00),
+		m_textOffset(0x0000),
+		m_colorNumber(0x00000000),
+		m_vCellCount(0x0000),
+		m_hCellCount(0x0000),
+		m_vPosition(0x0000),
+		m_hPosition(0x0000),
 		m_maincpu(*this, "maincpu"),
 		m_subcpu(*this,"sub"),
 		m_soundcpu(*this,"soundcpu")
@@ -273,13 +282,17 @@
 	UINT32 m_test_offs;
 	int m_color;
 	UINT8 m_vblank;
-	UINT16 m_cmd;
-	UINT16 m_param;
-	UINT32 m_dst_addr;
-	UINT32 m_txt_buff[0x10];
-	UINT32 m_attr_buff[0x10];
-	UINT8 m_txt_index;
-	UINT8 m_attr_index;
+
+	// Blitter state
+	UINT16 m_textBytesToWrite;
+	INT16  m_blitterSerialCount;
+	UINT8  m_blitterMode;
+	UINT16 m_textOffset;
+	UINT32 m_colorNumber;
+	UINT16 m_vCellCount;
+	UINT16 m_hCellCount;
+	UINT16 m_vPosition;
+	UINT16 m_hPosition;
 
 	required_device<cpu_device> m_maincpu;
 	required_device<cpu_device> m_subcpu;
@@ -402,36 +415,9 @@
 	COMBINE_DATA(&h1_ioga[offset]);
 }
 #endif
-/*
-CMD = 03f4 PARAM = 0230 | ?
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00000059
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 07000000
-CMD = ac90 PARAM = 0001 DATA = 00010000
-CMD = ac90 PARAM = 0001 DATA = 00010001
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00400040
-CMD = ac90 PARAM = 0001 DATA = 01200050
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 03f40230
-
-CMD = 03f4 PARAM = 0170 | ?
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00000059
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 07000000
-CMD = ac90 PARAM = 0001 DATA = 00010000
-CMD = ac90 PARAM = 0001 DATA = 00010001
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 00400040
-CMD = ac90 PARAM = 0001 DATA = 00800050
-CMD = ac90 PARAM = 0001 DATA = 00000000
-CMD = ac90 PARAM = 0001 DATA = 03f40170
-*/
-/* this looks like an exotic I/O-based tilemap / sprite blitter, very unusual from Sega... */
+
+
+/* This is a RLE-based sprite blitter (US Patent #6,141,122), very unusual from Sega... */
 static WRITE32_HANDLER( sysh1_txt_blit_w )
 {
 	coolridr_state *state = space->machine().driver_data<coolridr_state>();
@@ -440,66 +426,134 @@
 
 	switch(offset)
 	{
-		case 0x10/4: //state->m_cmd + state->m_param?
-			state->m_cmd = (state->m_sysh1_txt_blit[offset] & 0xffff0000) >> 16;
-			state->m_param = (state->m_sysh1_txt_blit[offset] & 0x0000ffff) >> 0;
-			state->m_dst_addr = 0x3f40000;
-			state->m_txt_index = 0;
-			state->m_attr_index = 0;
-			break;
-		case 0x14/4: //data
-			/*  "THIS MACHINE IS STAND-ALONE." / disclaimer written with this CMD */
-			if((state->m_cmd & 0xff) == 0xf4)
+		// The mode register
+		case 0x04:
+		{
+			state->m_blitterMode = (data & 0x00ff0000) >> 16;
+
+			if (state->m_blitterMode == 0xf4)
+			{
+				// Some sort of addressing state.
+				// In the case of text, simply writes 4 characters per 32-bit word.
+				// These values may be loaded into RAM somewhere as they are written.
+				// The number of characters is determined by the upper-most 8 bits.
+				state->m_textBytesToWrite = (data & 0xff000000) >> 24;
+				state->m_textOffset = (data & 0x0000ffff);
+				state->m_blitterSerialCount = 0;
+			}
+			else if (state->m_blitterMode == 0x30 || state->m_blitterMode == 0x90)
+			{
+				// The blitter function(s).
+				// After this is set a fixed count of 11 32-bit words are sent to the data register.
+				// The lower word always seems to be 0x0001 and the upper byte always 0xac.
+				state->m_blitterSerialCount = 0;
+			}
+			else if (state->m_blitterMode == 0x10)
 			{
-				state->m_txt_buff[state->m_txt_index++] = data;
+				// Could be a full clear of VRAM?
+				for(UINT32 vramAddr = 0x3f40000; vramAddr < 0x3f4ffff; vramAddr+=4)
+					space->write_dword(vramAddr, 0x00000000);
+			}
+			break;
+		}
 
-				//printf("CMD = %04x PARAM = %04x | %c%c%c%c\n",state->m_cmd,state->m_param,(data >> 24) & 0xff,(data >> 16) & 0xff,(data >> 8) & 0xff,(data >> 0) & 0xff);
+		// The data register
+		case 0x05:
+		{
+			if (state->m_blitterMode == 0xf4)
+			{
+				// Uploads a series of bytes that index into the encoded sprite table
+				const size_t memOffset = 0x03f40000 + state->m_textOffset + state->m_blitterSerialCount;
+				space->write_dword(memOffset, data);
+				state->m_blitterSerialCount += 0x04;
+
+				// DEBUG: Uncomment to see the ASCII strings as they are being blitted
+				//if (state->m_blitterSerialCount >= state->m_textBytesToWrite)
+				//{
+				//  for (int i = 0; i < state->m_textBytesToWrite+1; i++)
+				//      printf("%c", space->read_byte(0x03f40000 + state->m_textOffset + i));
+				//  printf("\n");
+				//}
 			}
-			else if((state->m_cmd & 0xff) == 0x90 || (state->m_cmd & 0xff) == 0x30)
+			else if (state->m_blitterMode == 0x30 || state->m_blitterMode == 0x90)
 			{
-				state->m_attr_buff[state->m_attr_index++] = data;
+				// Serialized 32-bit words in order of appearance:
+				//  0: 00000000 - totally unknown : always seems to be zero
+				//  1: xxxxxxxx - "Color Number" (all bits or just lower 16/8?)
+				//  2: 00000000 - unknown : OT flag?  (transparency)
+				//  3: 00000000 - unknown : RF flag?  (90 degree rotation)
+				//  4: 07000000 - unknown : VF flag?  (vertically flipped)
+				//  5: 00010000 - unknown : HF flag?  (horizontally flipped)
+				//  6: vvvv---- - "Vertical Cell Count"
+				//  6: ----hhhh - "Horizontal Cell Count"
+				//  7: 00000000 - unknown : "Vertical|Horizontal Zoom Centers"?
+				//  8: 00400040 - unknown : "Vertical|Horizontal Zoom Ratios"?
+				//  9: xxxx---- - "Display Vertical Position"
+				//  9: ----yyyy - "Display Horizontal Position"
+				// 10: 00000000 - unknown : always seems to be zero
+				// 11: ........ - complex - likely an address into bytes uploaded by mode 0xf4
+				//                (See ifdef'ed out code below for a closer examination)
 
-				if(state->m_attr_index == 0xa)
+				// Serialized counts
+				if (state->m_blitterSerialCount == 1)
 				{
-					UINT16 x,y;
-
-					y = (state->m_attr_buff[9] & 0x01f00000) >> 20;
-					x = (state->m_attr_buff[9] & 0x1f0) >> 4;
-					state->m_dst_addr = 0x3f40000 | y*0x40 | x;
-
-					{
-						int x2,y2;
-						const gfx_element *gfx = space->machine().gfx[1];
-						rectangle clip;
-
-						y2 = (state->m_attr_buff[9] & 0x01ff0000) >> 16;
-						x2 = (state->m_attr_buff[9] & 0x000001ff);
-						clip = state->m_temp_bitmap_sprites.cliprect();
-
-						drawgfx_opaque(state->m_temp_bitmap_sprites,clip,gfx,1,1,0,0,x2,y2);
-					}
+					state->m_colorNumber = (data & 0x000000ff);	// Probably more bits
+				}
+				else if (state->m_blitterSerialCount == 6)
+				{
+					state->m_vCellCount = (data & 0xffff0000) >> 16;
+					state->m_hCellCount = (data & 0x0000ffff);
+				}
+				else if (state->m_blitterSerialCount == 9)
+				{
+					state->m_vPosition = (data & 0xffff0000) >> 16;
+					state->m_hPosition = (data & 0x0000ffff);
 				}
-				if(state->m_attr_index == 0xc)
+				else if (state->m_blitterSerialCount == 11)
 				{
-					UINT8 size;
+					const UINT32 memOffset = data;
 
-					size = (state->m_attr_buff[6] / 4)+1;
-					for(state->m_txt_index = 0;state->m_txt_index < size; state->m_txt_index++)
+					// Splat some sprites
+					for (int h = 0; h < state->m_hCellCount; h++)
 					{
-						space->write_dword((state->m_dst_addr),state->m_txt_buff[state->m_txt_index]);
-						state->m_dst_addr+=4;
+						for (int v = 0; v < state->m_vCellCount; v++)
+						{
+							const int pixelOffsetX = state->m_hPosition + (h*16);
+							const int pixelOffsetY = state->m_vPosition + (v*16);
+
+							// It's unknown if it's row-major or column-major
+							// TODO: Study the CRT test and "Cool Riders" logo for clues.
+							UINT8 spriteNumber = space->read_byte(memOffset + h + (v*h));
+
+							// DEBUG: For demo purposes, skip spaces and NULL characters
+							if (spriteNumber == 0x20 || spriteNumber == 0x00)
+								continue;
+
+							// DEBUG: Draw 16x16 block
+							for (int x = 1; x < 15; x++)
+							{
+								for (int y = 1; y < 15; y++)
+								{
+									UINT32 color;
+									if (state->m_colorNumber == 0x5b)
+										color = 0xffff0000;
+									else if (state->m_colorNumber == 0x5d)
+										color = 0xff00ff00;
+									else if (state->m_colorNumber == 0x5e)
+										color = 0xff0000ff;
+									else
+										color = 0xff00ffff;
+									state->m_temp_bitmap_sprites.pix32(pixelOffsetY+y, pixelOffsetX+x) = color;
+								}
+							}
+						}
 					}
 				}
+
+				state->m_blitterSerialCount++;
 			}
-			else if((state->m_cmd & 0xff) == 0x10)
-			{
-				UINT32 clear_vram;
-				for(clear_vram=0x3f40000;clear_vram < 0x3f4ffff;clear_vram+=4)
-					space->write_dword((clear_vram),0x00000000);
-			}
-			//else
-			//  printf("CMD = %04x PARAM = %04x DATA = %08x\n",state->m_cmd,state->m_param,data);
 			break;
+		}
 	}
 }
 
diff -Nru src-old/mame/drivers/cosmic.c src/mame/drivers/cosmic.c
--- src-old/mame/drivers/cosmic.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/cosmic.c	2012-02-19 02:53:16.000000000 +0100
@@ -48,7 +48,7 @@
 		int count;
 		if (data == 0)
 			for (count = 0; count < 9; count++)
-				sample_stop(state->m_samples, count);
+				state->m_samples->stop(count);
 
 		state->m_sound_enabled = data;
 	}
@@ -57,50 +57,50 @@
 	{
 		switch (offset)
 		{
-		case 0:	if (data) sample_start(state->m_samples, 0, 0, 0); break;	/* Walk */
-		case 1:	if (data) sample_start(state->m_samples, 0, 5, 0); break;	/* Enemy Die 1 */
+		case 0:	if (data) state->m_samples->start(0, 0); break;	/* Walk */
+		case 1:	if (data) state->m_samples->start(0, 5); break;	/* Enemy Die 1 */
 		case 2:	if (data)									/* Drop 1 */
 				{
-					if (!sample_playing(state->m_samples, 1))
+					if (!state->m_samples->playing(1))
 					{
-						sample_stop(state->m_samples, 2);
-						sample_start(state->m_samples, 1, 3, 0);
+						state->m_samples->stop(2);
+						state->m_samples->start(1, 3);
 					}
 				}
 				else
-					sample_stop(state->m_samples, 1);
+					state->m_samples->stop(1);
 				break;
 
-		case 3:	if (data && !sample_playing(state->m_samples, 6))			/* Oxygen */
-					sample_start(state->m_samples, 6, 9, 1);
+		case 3:	if (data && !state->m_samples->playing(6))			/* Oxygen */
+					state->m_samples->start(6, 9, true);
 				break;
 
 		case 4:	break;										/* Drop 2 */
-		case 5:	if (data) sample_start(state->m_samples, 0, 5, 0); break;	/* Enemy Die 2 (use same sample as 1) */
-		case 6:	if (data && !sample_playing(state->m_samples, 1) && !sample_playing(state->m_samples, 3))   /* Hang */
-					sample_start(state->m_samples, 2, 2, 0);
+		case 5:	if (data) state->m_samples->start(0, 5); break;	/* Enemy Die 2 (use same sample as 1) */
+		case 6:	if (data && !state->m_samples->playing(1) && !state->m_samples->playing(3))   /* Hang */
+					state->m_samples->start(2, 2);
 				break;
 
 		case 7:	if (data)									/* Escape */
 				{
-					sample_stop(state->m_samples, 2);
-					sample_start(state->m_samples, 3, 4, 0);
+					state->m_samples->stop(2);
+					state->m_samples->start(3, 4);
 				}
 				else
-					sample_stop(state->m_samples, 3);
+					state->m_samples->stop(3);
 				break;
 
-		case 8:	if (data) sample_start(state->m_samples, 0, 1, 0); break;	/* Stairs */
+		case 8:	if (data) state->m_samples->start(0, 1); break;	/* Stairs */
 		case 9:	if (data)									/* Extend */
-					sample_start(state->m_samples, 4, 8, 0);
+					state->m_samples->start(4, 8);
 				else
-					sample_stop(state->m_samples, 4);
+					state->m_samples->stop(4);
 				break;
 
 		case 10:	dac_data_w(state->m_dac, data); break;/* Bonus */
-		case 15:	if (data) sample_start(state->m_samples, 0, 6, 0); break;	/* Player Die */
-		case 16:	if (data) sample_start(state->m_samples, 5, 7, 0); break;	/* Enemy Laugh */
-		case 17:	if (data) sample_start(state->m_samples, 0, 10, 0); break;	/* Coin - Not triggered by software */
+		case 15:	if (data) state->m_samples->start(0, 6); break;	/* Player Die */
+		case 16:	if (data) state->m_samples->start(5, 7); break;	/* Enemy Laugh */
+		case 17:	if (data) state->m_samples->start(0, 10); break;	/* Coin - Not triggered by software */
 		}
 	}
 
@@ -126,7 +126,7 @@
 		state->m_sound_enabled = data;
 		if (data == 0)
 			for (count = 0; count < 9; count++)
-				sample_stop(state->m_samples, count);
+				state->m_samples->stop(count);
 	}
 
 	if (state->m_sound_enabled)
@@ -138,37 +138,37 @@
 		/* be used for anything. It is implemented for sake of */
 		/* completness. Maybe it plays a tune if you win ?     */
 		case 1:	dac_data_w(state->m_dac, -data); break;
-		case 2:	if (data) sample_start(state->m_samples, 0, state->m_march_select, 0); break;	/* March Sound */
+		case 2:	if (data) state->m_samples->start(0, state->m_march_select); break;	/* March Sound */
 		case 3:	state->m_march_select = (state->m_march_select & 0xfe) | data; break;
 		case 4:	state->m_march_select = (state->m_march_select & 0xfd) | (data << 1); break;
 		case 5:	state->m_march_select = (state->m_march_select & 0xfb) | (data << 2); break;
 
 		case 6:	if (data)							/* Killer Attack (crawly thing at bottom of screen) */
-					sample_start(state->m_samples, 1, 8, 1);
+					state->m_samples->start(1, 8, true);
 				else
-					sample_stop(state->m_samples, 1);
+					state->m_samples->stop(1);
 				break;
 
 		case 7:	if (data)								/* Bonus Chance & Got Bonus */
 				{
-					sample_stop(state->m_samples, 4);
-					sample_start(state->m_samples, 4, 10, 0);
+					state->m_samples->stop(4);
+					state->m_samples->start(4, 10);
 				}
 				break;
 
 		case 8:	if (data)
 				{
-					if (!sample_playing(state->m_samples, 4)) sample_start(state->m_samples, 4, 9, 1);
+					if (!state->m_samples->playing(4)) state->m_samples->start(4, 9, true);
 				}
 				else
-					sample_stop(state->m_samples, 4);
+					state->m_samples->stop(4);
 				break;
 
-		case 9:	if (data) sample_start(state->m_samples, 3, 11, 0); break;	/* Got Ship */
+		case 9:	if (data) state->m_samples->start(3, 11); break;	/* Got Ship */
 //      case 11: watchdog_reset_w(0, 0); break;             /* Watchdog */
-		case 13:	if (data) sample_start(state->m_samples, 8, 13 - state->m_gun_die_select, 0); break;  /* Got Monster / Gunshot */
+		case 13:	if (data) state->m_samples->start(8, 13 - state->m_gun_die_select); break;  /* Got Monster / Gunshot */
 		case 14:	state->m_gun_die_select = data; break;
-		case 15:	if (data) sample_start(state->m_samples, 5, 14, 0); break;	/* Coin Extend (extra base) */
+		case 15:	if (data) state->m_samples->start(5, 14); break;	/* Coin Extend (extra base) */
 		}
 	}
 
@@ -188,10 +188,10 @@
 		int count;
 		if (data == 0)
 			for (count = 0; count < 12; count++)
-				sample_stop(state->m_samples, count);
+				state->m_samples->stop(count);
 		else
 		{
-			sample_start(state->m_samples, 0, 0, 1); /*Background Noise*/
+			state->m_samples->start(0, 0, true); /*Background Noise*/
 		}
 
 		state->m_sound_enabled = data;
@@ -201,7 +201,7 @@
 	{
 		switch (offset)
 		{
-		case 0:	if (data) sample_start(state->m_samples, 1, 2, 0); break; /*Dive Bombing Type A*/
+		case 0:	if (data) state->m_samples->start(1, 2); break; /*Dive Bombing Type A*/
 
 		case 2:	/*Dive Bombing Type B (Main Control)*/
 			if (data)
@@ -209,58 +209,58 @@
 				switch (state->m_dive_bomb_b_select)
 				{
 				case 2:
-					if (sample_playing(state->m_samples, 2))
+					if (state->m_samples->playing(2))
 					{
-						sample_stop(state->m_samples, 2);
-						sample_start(state->m_samples, 2, 3, 0); break;
+						state->m_samples->stop(2);
+						state->m_samples->start(2, 3); break;
 					}
 					else
-						sample_start(state->m_samples, 2, 3, 0); break;
+						state->m_samples->start(2, 3); break;
 
 				case 3:
-					if (sample_playing(state->m_samples, 3))
+					if (state->m_samples->playing(3))
 					{
-						sample_stop(state->m_samples, 3);
-						sample_start(state->m_samples, 3, 4, 0); break;
+						state->m_samples->stop(3);
+						state->m_samples->start(3, 4); break;
 					}
 					else
-						sample_start(state->m_samples, 3, 4, 0); break;
+						state->m_samples->start(3, 4); break;
 
 				case 4:
-					if (sample_playing(state->m_samples, 4))
+					if (state->m_samples->playing(4))
 					{
-						sample_stop(state->m_samples, 4);
-						sample_start(state->m_samples, 4, 5, 0); break;
+						state->m_samples->stop(4);
+						state->m_samples->start(4, 5); break;
 					}
 					else
-						sample_start(state->m_samples, 4, 5, 0); break;
+						state->m_samples->start(4, 5); break;
 
 				case 5:
-					if (sample_playing(state->m_samples, 5))
+					if (state->m_samples->playing(5))
 					{
-						sample_stop(state->m_samples, 5);
-						sample_start(state->m_samples, 5, 6, 0); break;
+						state->m_samples->stop(5);
+						state->m_samples->start(5, 6); break;
 					}
 					else
-						sample_start(state->m_samples, 5, 6, 0); break;
+						state->m_samples->start(5, 6); break;
 
 				case 6:
-					if (sample_playing(state->m_samples, 6))
+					if (state->m_samples->playing(6))
 					{
-						sample_stop(state->m_samples, 6);
-						sample_start(state->m_samples, 6, 7, 0); break;
+						state->m_samples->stop(6);
+						state->m_samples->start(6, 7); break;
 					}
 					else
-						sample_start(state->m_samples, 6, 7, 0); break;
+						state->m_samples->start(6, 7); break;
 
 				case 7:
-					if (sample_playing(state->m_samples, 7))
+					if (state->m_samples->playing(7))
 					{
-						sample_stop(state->m_samples, 7);
-						sample_start(state->m_samples, 7, 8, 0); break;
+						state->m_samples->stop(7);
+						state->m_samples->start(7, 8); break;
 					}
 					else
-						sample_start(state->m_samples, 7, 8, 0); break;
+						state->m_samples->start(7, 8); break;
 				}
 			}
 
@@ -287,20 +287,20 @@
 			break;
 
 
-		case 6:	if (data) sample_start(state->m_samples, 8, 9, 0); break; /*Fire Control*/
+		case 6:	if (data) state->m_samples->start(8, 9); break; /*Fire Control*/
 
-		case 7:	if (data) sample_start(state->m_samples, 9, 10, 0); break; /*Small Explosion*/
+		case 7:	if (data) state->m_samples->start(9, 10); break; /*Small Explosion*/
 
-		case 8:	if (data) sample_start(state->m_samples, 10, 11, 0); break; /*Loud Explosion*/
+		case 8:	if (data) state->m_samples->start(10, 11); break; /*Loud Explosion*/
 
 		case 9:
 			if (data)
-				sample_start(state->m_samples, 11, 1, 1);
+				state->m_samples->start(11, 1, true);
 			else
-				sample_stop(state->m_samples, 11);
+				state->m_samples->stop(11);
 			break; /*Extend Sound control*/
 
-		case 12:	if (data) sample_start(state->m_samples, 11,12, 0); break; /*Insert Coin*/
+		case 12:	if (data) state->m_samples->start(11,12); break; /*Insert Coin*/
 		}
 	}
 
@@ -965,7 +965,7 @@
 {
 	cosmic_state *state = machine.driver_data<cosmic_state>();
 
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 	state->m_dac = machine.device("dac");
 
 	state->save_item(NAME(state->m_sound_enabled));
@@ -1035,8 +1035,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(panic_samples_interface)
+	MCFG_SAMPLES_ADD("samples", panic_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
@@ -1061,8 +1060,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(cosmica_samples_interface)
+	MCFG_SAMPLES_ADD("samples", cosmica_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
@@ -1099,8 +1097,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(cosmicg_samples_interface)
+	MCFG_SAMPLES_ADD("samples", cosmicg_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("dac", DAC, 0)
diff -Nru src-old/mame/drivers/cps1.c src/mame/drivers/cps1.c
--- src-old/mame/drivers/cps1.c	2012-01-17 07:16:20.000000000 +0100
+++ src/mame/drivers/cps1.c	2012-02-19 04:59:57.000000000 +0100
@@ -10147,20 +10147,20 @@
 
 	ROM_REGION( 0x800000, "gfx", 0 )
 	ROMX_LOAD( "rcm_01.3a",  0x000000, 0x80000, CRC(6ecdf13f) SHA1(2a8fe06bf5011e3f990f90d9224f91d8631ec0cc) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_03.5a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_02.4a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_02.4a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_03.5a
+	ROMX_LOAD( "rcm_03.5a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_02.4a
 	ROMX_LOAD( "rcm_04.6a",  0x000006, 0x80000, CRC(54e622ff) SHA1(36f6297e3d410f041be5e582919478b0d52520ca) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_05.7a",  0x200000, 0x80000, CRC(5dd131fd) SHA1(1a7fc8cf38901245d40901996e946e7ad9c0e0c5) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_07.9a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_06.8a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_06.8a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_07.9a
+	ROMX_LOAD( "rcm_07.9a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_06.8a
 	ROMX_LOAD( "rcm_08.10a", 0x200006, 0x80000, CRC(fbff64cf) SHA1(f0cb531ef195dc1dcd224a208906a62fb5d199a1) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_10.3c",  0x400000, 0x80000, CRC(4dc8ada9) SHA1(776c2b3ef24c2b8f390c05a9c6728b14ceec696e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_12.5c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_11.4c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_11.4c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_12.5c
+	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_11.4c
 	ROMX_LOAD( "rcm_13.6c",  0x400006, 0x80000, CRC(5069d4a9) SHA1(b832b98be94371af52bd4bb911e18ec57430a7db) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_14.7c",  0x600000, 0x80000, CRC(303be3bd) SHA1(1e5c3fd71966ea9f457840c40582795b501c323e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_16.9c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_15.8c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_16_9c
+	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )	// Dumped as rcm_15_8c
 	ROMX_LOAD( "rcm_17.10c", 0x600006, 0x80000, CRC(92371042) SHA1(c55833cbaddcc986edd23c009a3e3c7ff09c2708) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
@@ -10197,20 +10197,20 @@
 
 	ROM_REGION( 0x800000, "gfx", 0 )
 	ROMX_LOAD( "rcm_01.3a",  0x000000, 0x80000, CRC(6ecdf13f) SHA1(2a8fe06bf5011e3f990f90d9224f91d8631ec0cc) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_02.4a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_03.5a
-	ROMX_LOAD( "rcm_03.5a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_02.4a
+	ROMX_LOAD( "rcm_02.4a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_03.5a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_04.6a",  0x000006, 0x80000, CRC(54e622ff) SHA1(36f6297e3d410f041be5e582919478b0d52520ca) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_05.7a",  0x200000, 0x80000, CRC(5dd131fd) SHA1(1a7fc8cf38901245d40901996e946e7ad9c0e0c5) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_06.8a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_07.9a
-	ROMX_LOAD( "rcm_07.9a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_06.8a
+	ROMX_LOAD( "rcm_06.8a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_07.9a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_08.10a", 0x200006, 0x80000, CRC(fbff64cf) SHA1(f0cb531ef195dc1dcd224a208906a62fb5d199a1) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_10.3c",  0x400000, 0x80000, CRC(4dc8ada9) SHA1(776c2b3ef24c2b8f390c05a9c6728b14ceec696e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_11.4c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_12.5c
-	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_11.4c
+	ROMX_LOAD( "rcm_11.4c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_13.6c",  0x400006, 0x80000, CRC(5069d4a9) SHA1(b832b98be94371af52bd4bb911e18ec57430a7db) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_14.7c",  0x600000, 0x80000, CRC(303be3bd) SHA1(1e5c3fd71966ea9f457840c40582795b501c323e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_16.9c
-	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_15.8c
+	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_17.10c", 0x600006, 0x80000, CRC(92371042) SHA1(c55833cbaddcc986edd23c009a3e3c7ff09c2708) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x28000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
@@ -10247,20 +10247,20 @@
 
 	ROM_REGION( 0x800000, "gfx", 0 )
 	ROMX_LOAD( "rcm_01.3a",  0x000000, 0x80000, CRC(6ecdf13f) SHA1(2a8fe06bf5011e3f990f90d9224f91d8631ec0cc) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_02.4a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_03.5a
-	ROMX_LOAD( "rcm_03.5a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_02.4a
+	ROMX_LOAD( "rcm_02.4a",  0x000002, 0x80000, CRC(944d4f0f) SHA1(665dc9a537e9c9b565f6136f939ff5c2861f875f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_03.5a",  0x000004, 0x80000, CRC(36f3073c) SHA1(457d68e63599d06a136e152a9ad60adac1c91edd) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_04.6a",  0x000006, 0x80000, CRC(54e622ff) SHA1(36f6297e3d410f041be5e582919478b0d52520ca) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_05.7a",  0x200000, 0x80000, CRC(5dd131fd) SHA1(1a7fc8cf38901245d40901996e946e7ad9c0e0c5) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_06.8a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_07.9a
-	ROMX_LOAD( "rcm_07.9a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_06.8a
+	ROMX_LOAD( "rcm_06.8a",  0x200002, 0x80000, CRC(f0faf813) SHA1(adff01c2ecc4c8ce6f8a50cbd07d8f8bb9f48168) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_07.9a",  0x200004, 0x80000, CRC(826de013) SHA1(47f36b1d92a487c43c8dadc8293b8e6f40649286) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_08.10a", 0x200006, 0x80000, CRC(fbff64cf) SHA1(f0cb531ef195dc1dcd224a208906a62fb5d199a1) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_10.3c",  0x400000, 0x80000, CRC(4dc8ada9) SHA1(776c2b3ef24c2b8f390c05a9c6728b14ceec696e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_11.4c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_12.5c
-	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_11.4c
+	ROMX_LOAD( "rcm_11.4c",  0x400002, 0x80000, CRC(f2b9ee06) SHA1(db315b00d1caed1a8c0f6e0ae726e8fa05b011fa) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_12.5c",  0x400004, 0x80000, CRC(fed5f203) SHA1(23db14490519b5e2d0bb92ffe6e14540d1999e4b) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_13.6c",  0x400006, 0x80000, CRC(5069d4a9) SHA1(b832b98be94371af52bd4bb911e18ec57430a7db) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_14.7c",  0x600000, 0x80000, CRC(303be3bd) SHA1(1e5c3fd71966ea9f457840c40582795b501c323e) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_16.9c
-	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )	// == rcm_15.8c
+	ROMX_LOAD( "rcm_15.8c",  0x600002, 0x80000, CRC(4f2d372f) SHA1(db6a94d1f92c1b96e404b38ebcb1eedbec3ae6cc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "rcm_16.9c",  0x600004, 0x80000, CRC(93d97fde) SHA1(e4be5216f98ad08a9118d629d398be2bd54e2e2a) , ROM_GROUPWORD | ROM_SKIP(6) )
 	ROMX_LOAD( "rcm_17.10c", 0x600006, 0x80000, CRC(92371042) SHA1(c55833cbaddcc986edd23c009a3e3c7ff09c2708) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x28000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
diff -Nru src-old/mame/drivers/cps3.c src/mame/drivers/cps3.c
--- src-old/mame/drivers/cps3.c	2012-01-28 20:48:44.000000000 +0100
+++ src/mame/drivers/cps3.c	2012-02-15 02:56:05.000000000 +0100
@@ -54,69 +54,69 @@
 From late 1996 to 1999 Capcom developed another hardware platform to rival the CPS2 System and called
 it CP SYSTEM III. Only 6 games were produced. Here's a detailed table of all known releases until now:
 
-                                                           |--------------- Cart ----------------|  |--------------- CD --------------|
-Game                                                 Year  Part #     Label      Region  CD  NO CD  Part #      Catalog #   Label        Revision
----------------------------------------------------  ----  ---------  ---------  ------  --  -----  ----------  ----------  -----------  --------
-Warzard                                              1996  WZD96a00F  CP300000G  JAPAN   X          CAP-WZD000  CAP-WZD-3   CAP-WZD-3    961023
-Warzard                                                    WZD96a00F  CP300000G  JAPAN   X          CAP-WZD000  CAP-WZD-5   CAP-WZD-5    961121
-Red Earth                                                  WZD96aA0F  CP3000B0G  EUROPE  X          CAP-WZD0A0  CAP-WZD-3   CAP-WZD-3    961023
-Red Earth                                                  WZD96aA0F  CP3000B0G  EUROPE  X          CAP-WZD0A0  CAP-WZD-5   CAP-WZD-5    961121
-Red Earth                                                  WZD96aA0F  CP3000H0G  MEXICO* X          CAP-WZD0A0  CAP-WZD-3   CAP-WZD-3    961023
-Red Earth                                                  WZD96aA0F  CP3000H0G  MEXICO* X          CAP-WZD0A0  CAP-WZD-5   CAP-WZD-5    961121
-Red Earth                                                  WZD96aA0F  CP3000U0G  USA*    X          CAP-WZD0A0  CAP-WZD-3   CAP-WZD-3    961023
-Red Earth                                                  WZD96aA0F  CP3000U0G  USA*    X          CAP-WZD0A0  CAP-WZD-5   CAP-WZD-5    961121
-
-Street Fighter III: New Generation                   1997  SF397200F  CP300000G  JAPAN   X          CAP-SF3000  CAP-SF3-3   CAP-SF3-3    970204
-Street Fighter III: New Generation                         SF397200F  CP300000G  JAPAN   X          CAP-SF3000  ?           ?            970312*
-Street Fighter III: New Generation                         SF397200F  CP300000G  JAPAN   X          CAP-SF3000  ?           ?            970403*
-Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                           970204
-Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                           970312*
-Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                           970403*
-Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  CAP-SF3-3   CAP-SF3-3    970204
-Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  ?           ?            970312*
-Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  ?           ?            970403*
-Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  CAP-SF3-3   CAP-SF3-3    970204
-Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  ?           ?            970312*
-Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  ?           ?            970403*
-
-Street Fighter III 2nd Impact: Giant Attack          1997  3GA97a00F  CP300000G  JAPAN   X          CAP-3GA000  CAP-3GA000  CAP-3GA-1    970930
-Street Fighter III 2nd Impact: Giant Attack                3GA97a00F  CP300000G  JAPAN   X          CAP-3GA000  ?           ?            971016*
-Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000C0G  ASIA        X                                           970930
-Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000C0G  ASIA        X                                           971016*
-Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000U0G  USA     X          CAP-3GA0A0  CAP-3GA000  CAP-3GA-1    970930
-Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000U0G  USA     X          CAP-3GA0A0  ?           ?            971016*
-
-JoJo no Kimyouna Bouken                              1998  JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK000  CAP-JJK-140  981202
-JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK-2   CAP-JJK-160  990108
-JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  ?           ?            990128*
-JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                           981202
-JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                           990108
-JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                           990128*
-JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK000  CAP-JJK-140  981202
-JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK-2   CAP-JJK-160  990108
-JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  ?           ?            990128*
-
-Street Fighter III 3rd Strike: Fight for the Future  1999  33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-1   CAP-33S-1    990512
-Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-2   CAP-33S-2    990608
-Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN       X                                           990512
-Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN       X                                           990608
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000B0G  EUROPE  X          CAP-33S0A0  CAP-33S-1   CAP-33S-1    990512
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000B0G  EUROPE  X          CAP-33S0A0  CAP-33S-2   CAP-33S-2    990608
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*   X          CAP-33S0A0  CAP-33S-1   CAP-33S-1    990512
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*   X          CAP-33S0A0  CAP-33S-2   CAP-33S-2    990608
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*       X                                           990512
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*       X                                           990608
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000H0G  MEXICO* ?          CAP-33S0A0  CAP-33S-1   CAP-33S-1    990512
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000H0G  MEXICO* ?          CAP-33S0A0  CAP-33S-2   CAP-33S-2    990608
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000U0G  USA     X          CAP-33S0A0  CAP-33S-1   CAP-33S-1    990512
-Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000U0G  USA     X          CAP-33S0A0  CAP-33S-2   CAP-33S-2    990608
-
-JoJo no Kimyouna Bouken: Miraie no Isan              1999  JJM99900F  CP300000G  JAPAN   X          CAP-JJM000  CAP-JJM-0   CAP-JJM-110  990913
-JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN   X          CAP-JJM000  ?           ?            990927*
-JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN       X                                           990913
-JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN       X                                           990927*
-JoJo's Bizarre Adventure                                   JJM999A0F  CP3000B0G  EUROPE      X                                           990913
-JoJo's Bizarre Adventure                                   JJM999A0F  CP3000B0G  EUROPE      X                                           990927*
+                                                           |--------------- Cart ----------------|  |--------------- CD ---------------|
+Game                                                 Year  Part #     Label      Region  CD  NO CD  Part #      Catalog #    Label        Revision
+---------------------------------------------------  ----  ---------  ---------  ------  --  -----  ----------  -----------  -----------  --------
+Warzard                                              1996  WZD96a00F  CP300000G  JAPAN   X          CAP-WZD000  CAP-WZD-3    CAP-WZD-3    961023
+Warzard                                                    WZD96a00F  CP300000G  JAPAN   X          CAP-WZD000  CAP-WZD-5    CAP-WZD-5    961121
+Red Earth                                                  WZD96aA0F  CP3000B0G  EUROPE  X          CAP-WZD0A0  CAP-WZD-3    CAP-WZD-3    961023
+Red Earth                                                  WZD96aA0F  CP3000B0G  EUROPE  X          CAP-WZD0A0  CAP-WZD-5    CAP-WZD-5    961121
+Red Earth                                                  WZD96aA0F  CP3000H0G  MEXICO* X          CAP-WZD0A0  CAP-WZD-3    CAP-WZD-3    961023
+Red Earth                                                  WZD96aA0F  CP3000H0G  MEXICO* X          CAP-WZD0A0  CAP-WZD-5    CAP-WZD-5    961121
+Red Earth                                                  WZD96aA0F  CP3000U0G  USA*    X          CAP-WZD0A0  CAP-WZD-3    CAP-WZD-3    961023
+Red Earth                                                  WZD96aA0F  CP3000U0G  USA*    X          CAP-WZD0A0  CAP-WZD-5    CAP-WZD-5    961121
+
+Street Fighter III: New Generation                   1997  SF397200F  CP300000G  JAPAN   X          CAP-SF3000  CAP-SF3-3    CAP-SF3-3    970204
+Street Fighter III: New Generation                         SF397200F  CP300000G  JAPAN   X          CAP-SF3000  ?            ?            970312*
+Street Fighter III: New Generation                         SF397200F  CP300000G  JAPAN   X          CAP-SF3000  ?            ?            970403*
+Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                            970204
+Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                            970312*
+Street Fighter III: New Generation                         SF3972A0F  CP3000C0G  ASIA        X                                            970403*
+Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  CAP-SF3-3    CAP-SF3-3    970204
+Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  ?            ?            970312*
+Street Fighter III: New Generation                         SF3972A0F  CP3000H0G  MEXICO  X          CAP-SF30A0  ?            ?            970403*
+Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  CAP-SF3-3    CAP-SF3-3    970204
+Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  ?            ?            970312*
+Street Fighter III: New Generation                         SF3972A0F  CP3000U0G  USA     X          CAP-SF30A0  ?            ?            970403*
+
+Street Fighter III 2nd Impact: Giant Attack          1997  3GA97a00F  CP300000G  JAPAN   X          CAP-3GA000  CAP-3GA000   CAP-3GA-1    970930
+Street Fighter III 2nd Impact: Giant Attack                3GA97a00F  CP300000G  JAPAN   X          CAP-3GA000  ?            ?            971016*
+Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000C0G  ASIA        X                                            970930
+Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000C0G  ASIA        X                                            971016*
+Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000U0G  USA     X          CAP-3GA0A0  CAP-3GA000   CAP-3GA-1    970930
+Street Fighter III 2nd Impact: Giant Attack                3GA97aA0F  CP3000U0G  USA     X          CAP-3GA0A0  ?            ?            971016*
+
+JoJo no Kimyouna Bouken                              1998  JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK000   CAP-JJK-140  981202
+JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  CAP-JJK-2    CAP-JJK-160  990108
+JoJo no Kimyouna Bouken                                    JJK98c00F  CP300000G  JAPAN   X          CAP-JJK000  ?            ?            990128*
+JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            981202
+JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            990108
+JoJo's Venture                                             JJK98cA0F  CP3000C0G  ASIA        X                                            990128*
+JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK000   CAP-JJK-140  981202
+JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  CAP-JJK-2    CAP-JJK-160  990108
+JoJo's Venture                                             JJK98cA0F  CP3000U0G  USA     X          CAP-JJK0A0  ?            ?            990128*
+
+Street Fighter III 3rd Strike: Fight for the Future  1999  33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-1    CAP-33S-1    990512
+Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN*  X          CAP-33S000  CAP-33S-2    CAP-33S-2    990608
+Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN       X                                            990512
+Street Fighter III 3rd Strike: Fight for the Future        33S99400F  CP300000G  JAPAN       X                                            990608
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000B0G  EUROPE  X          CAP-33S0A0  CAP-33S-1    CAP-33S-1    990512
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000B0G  EUROPE  X          CAP-33S0A0  CAP-33S-2    CAP-33S-2    990608
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*   X          CAP-33S0A0  CAP-33S-1    CAP-33S-1    990512
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*   X          CAP-33S0A0  CAP-33S-2    CAP-33S-2    990608
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*       X                                            990512
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000C0G  ASIA*       X                                            990608
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000H0G  MEXICO* ?          CAP-33S0A0  CAP-33S-1    CAP-33S-1    990512
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000H0G  MEXICO* ?          CAP-33S0A0  CAP-33S-2    CAP-33S-2    990608
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000U0G  USA     X          CAP-33S0A0  CAP-33S-1    CAP-33S-1    990512
+Street Fighter III 3rd Strike: Fight for the Future        33S994A0F  CP3000U0G  USA     X          CAP-33S0A0  CAP-33S-2    CAP-33S-2    990608
+
+JoJo no Kimyouna Bouken: Miraie no Isan              1999  JJM99900F  CP300000G  JAPAN   X          CAP-JJM000  CAP-JJM-0    CAP-JJM-110  990913
+JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN   X          CAP-JJM000  CAP-JJM-120  CAP-JJM-120  990927
+JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN       X                                            990913
+JoJo no Kimyouna Bouken: Miraie no Isan                    JJM99900F  CP300000G  JAPAN       X                                            990927
+JoJo's Bizarre Adventure                                   JJM999A0F  CP3000B0G  EUROPE      X                                            990913
+JoJo's Bizarre Adventure                                   JJM999A0F  CP3000B0G  EUROPE      X                                            990927
 
 * NOT DUMPED but known to exist
 
@@ -2920,15 +2920,15 @@
 #define SFIII3_990512_CDROM \
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-33s-1", 0, SHA1(2f4a9006a31903114f9f9dc09465ae253e565c51) ) \
 
-#define JOJOBA_990913_FLASH \
-	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba-simm1.0", 0x00000, 0x200000, CRC(76976231) SHA1(90adde7e5983ec6a4e02789d5cefe9e85c9c52d5) ) \
-	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoba-simm1.1", 0x00000, 0x200000, CRC(cedd78e7) SHA1(964988b90a2f14c1da2cfc48d943e16e54da3fd3) ) \
-	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoba-simm1.2", 0x00000, 0x200000, CRC(2955b77f) SHA1(2a907a5cd91448bfc420c318584e5ef4bbe55a91) ) \
-	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoba-simm1.3", 0x00000, 0x200000, CRC(280139d7) SHA1(b7c28f6f0218688fb873a3106d2f95ea2e1e927c) ) \
-	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoba-simm2.0", 0x00000, 0x200000, CRC(305c4914) SHA1(c3a73ffe58f61ab8f1cd9e3f0891037638dc5a9b) ) \
-	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoba-simm2.1", 0x00000, 0x200000, CRC(18af4f3b) SHA1(04b8fdf23a782b10c203b111cc634a6d3474044a) ) \
-	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoba-simm2.2", 0x00000, 0x200000, CRC(397e5c9e) SHA1(021d86ee66bf951fb6a1dd90fb7007c6865cbb8b) ) \
-	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoba-simm2.3", 0x00000, 0x200000, CRC(a9d0a7d7) SHA1(b2cfc0661f8903ddbeea8a604ee8b42097e10ab8) ) \
+#define JOJOBA_990927_FLASH \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojoba-simm1.0", 0x00000, 0x200000, CRC(adcd8377) SHA1(f1aacbe061e3bcade5cca34435c3f86aec5f1499) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojoba-simm1.1", 0x00000, 0x200000, CRC(d7590b59) SHA1(bfee627ebb7cb7b28216527b17e1b06a4e6f19f4) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojoba-simm1.2", 0x00000, 0x200000, CRC(e62e240b) SHA1(70468cae67c009a80b45954c2a30794577343c77) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojoba-simm1.3", 0x00000, 0x200000, CRC(c95450c3) SHA1(55616e009b007180d1ac6290c8da44b0d864a494) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojoba-simm2.0", 0x00000, 0x200000, CRC(535f2eba) SHA1(167bec0dccfc2f91cb10cb1e2631ee619b3eb9fe) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojoba-simm2.1", 0x00000, 0x200000, CRC(01dd3a01) SHA1(08c462219796baa3ec28d78d038a18187cd838bb) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojoba-simm2.2", 0x00000, 0x200000, CRC(61432672) SHA1(d0416a75d395926041f90a3d34edb96a080acfd6) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojoba-simm2.3", 0x00000, 0x200000, CRC(acdc9aca) SHA1(89f77ddd6286709182a676fd9bd6c333a3b16271) ) \
 	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojoba-simm3.0", 0x00000, 0x200000, CRC(4d16e111) SHA1(f198007375be65e89856d64ee2b3857a18b4eab8) ) \
 	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojoba-simm3.1", 0x00000, 0x200000, CRC(9b3406d3) SHA1(54e90cd334d13e2c74305c6b87ebce1365ef3d59) ) \
 	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojoba-simm3.2", 0x00000, 0x200000, CRC(f2414997) SHA1(fb89d5784250538ad17fd527267b513afb6eca20) ) \
@@ -2954,6 +2954,43 @@
 	ROM_REGION( 0x200000, "simm5.6", 0 ) ROM_LOAD( "jojoba-simm5.6", 0x00000, 0x200000, CRC(4fb32906) SHA1(3a5965b3197517932c8aa4c07a6ea6a190a338d7) ) \
 	ROM_REGION( 0x200000, "simm5.7", 0 ) ROM_LOAD( "jojoba-simm5.7", 0x00000, 0x200000, CRC(8c8be520) SHA1(c461f3f76a83592b36b29afb316679a7c8972404) ) \
 
+#define JOJOBA_990927_CDROM \
+	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjm-120", 0, SHA1(8628d3fa555fbd5f4121082e925c1834b76c5e65) ) \
+
+#define JOJOBA_990913_FLASH \
+	ROM_REGION( 0x200000, "simm1.0", 0 ) ROM_LOAD( "jojobaa-simm1.0", 0x00000, 0x200000, CRC(76976231) SHA1(90adde7e5983ec6a4e02789d5cefe9e85c9c52d5) ) \
+	ROM_REGION( 0x200000, "simm1.1", 0 ) ROM_LOAD( "jojobaa-simm1.1", 0x00000, 0x200000, CRC(cedd78e7) SHA1(964988b90a2f14c1da2cfc48d943e16e54da3fd3) ) \
+	ROM_REGION( 0x200000, "simm1.2", 0 ) ROM_LOAD( "jojobaa-simm1.2", 0x00000, 0x200000, CRC(2955b77f) SHA1(2a907a5cd91448bfc420c318584e5ef4bbe55a91) ) \
+	ROM_REGION( 0x200000, "simm1.3", 0 ) ROM_LOAD( "jojobaa-simm1.3", 0x00000, 0x200000, CRC(280139d7) SHA1(b7c28f6f0218688fb873a3106d2f95ea2e1e927c) ) \
+	ROM_REGION( 0x200000, "simm2.0", 0 ) ROM_LOAD( "jojobaa-simm2.0", 0x00000, 0x200000, CRC(305c4914) SHA1(c3a73ffe58f61ab8f1cd9e3f0891037638dc5a9b) ) \
+	ROM_REGION( 0x200000, "simm2.1", 0 ) ROM_LOAD( "jojobaa-simm2.1", 0x00000, 0x200000, CRC(18af4f3b) SHA1(04b8fdf23a782b10c203b111cc634a6d3474044a) ) \
+	ROM_REGION( 0x200000, "simm2.2", 0 ) ROM_LOAD( "jojobaa-simm2.2", 0x00000, 0x200000, CRC(397e5c9e) SHA1(021d86ee66bf951fb6a1dd90fb7007c6865cbb8b) ) \
+	ROM_REGION( 0x200000, "simm2.3", 0 ) ROM_LOAD( "jojobaa-simm2.3", 0x00000, 0x200000, CRC(a9d0a7d7) SHA1(b2cfc0661f8903ddbeea8a604ee8b42097e10ab8) ) \
+	ROM_REGION( 0x200000, "simm3.0", 0 ) ROM_LOAD( "jojoba-simm3.0",  0x00000, 0x200000, CRC(4d16e111) SHA1(f198007375be65e89856d64ee2b3857a18b4eab8) ) \
+	ROM_REGION( 0x200000, "simm3.1", 0 ) ROM_LOAD( "jojoba-simm3.1",  0x00000, 0x200000, CRC(9b3406d3) SHA1(54e90cd334d13e2c74305c6b87ebce1365ef3d59) ) \
+	ROM_REGION( 0x200000, "simm3.2", 0 ) ROM_LOAD( "jojoba-simm3.2",  0x00000, 0x200000, CRC(f2414997) SHA1(fb89d5784250538ad17fd527267b513afb6eca20) ) \
+	ROM_REGION( 0x200000, "simm3.3", 0 ) ROM_LOAD( "jojoba-simm3.3",  0x00000, 0x200000, CRC(954b9c7d) SHA1(0d64d97167d4e669d7e4f3a388f9d5ec1e18ed42) ) \
+	ROM_REGION( 0x200000, "simm3.4", 0 ) ROM_LOAD( "jojoba-simm3.4",  0x00000, 0x200000, CRC(625adc1d) SHA1(533d62759ecece10c711d99bfca403e5cba279b5) ) \
+	ROM_REGION( 0x200000, "simm3.5", 0 ) ROM_LOAD( "jojoba-simm3.5",  0x00000, 0x200000, CRC(20a70bb4) SHA1(3bd8376304ffc974fb8031eac8bebff27969538c) ) \
+	ROM_REGION( 0x200000, "simm3.6", 0 ) ROM_LOAD( "jojoba-simm3.6",  0x00000, 0x200000, CRC(a10ec5af) SHA1(9b403260e8fbdacaa5369ab79fc05855cc6a6bdb) ) \
+	ROM_REGION( 0x200000, "simm3.7", 0 ) ROM_LOAD( "jojoba-simm3.7",  0x00000, 0x200000, CRC(0bd0de7a) SHA1(1debecda5f282f2a1dd17e887e522a4d00c5dc9d) ) \
+	ROM_REGION( 0x200000, "simm4.0", 0 ) ROM_LOAD( "jojoba-simm4.0",  0x00000, 0x200000, CRC(6ea14adc) SHA1(696b2ec66f3c197817a60f507a1b4c78db37f488) ) \
+	ROM_REGION( 0x200000, "simm4.1", 0 ) ROM_LOAD( "jojoba-simm4.1",  0x00000, 0x200000, CRC(8f4c42fb) SHA1(363d769b0b066ce139125426d2da6dfa15d1eb28) ) \
+	ROM_REGION( 0x200000, "simm4.2", 0 ) ROM_LOAD( "jojoba-simm4.2",  0x00000, 0x200000, CRC(ef0586d1) SHA1(8fcc350da20e3e59fa76fa14e10f2c47233ba9dc) ) \
+	ROM_REGION( 0x200000, "simm4.3", 0 ) ROM_LOAD( "jojoba-simm4.3",  0x00000, 0x200000, CRC(93ccc470) SHA1(5d267679e61c0fb592ad5f696d3c06ec1746d0b3) ) \
+	ROM_REGION( 0x200000, "simm4.4", 0 ) ROM_LOAD( "jojoba-simm4.4",  0x00000, 0x200000, CRC(3d9ec7d2) SHA1(665b867bab928be183c2006527e55f9b8ec4a271) ) \
+	ROM_REGION( 0x200000, "simm4.5", 0 ) ROM_LOAD( "jojoba-simm4.5",  0x00000, 0x200000, CRC(03e66850) SHA1(8478662dc9db20d9a186d315a883bd1cbb5e5000) ) \
+	ROM_REGION( 0x200000, "simm4.6", 0 ) ROM_LOAD( "jojoba-simm4.6",  0x00000, 0x200000, CRC(01606ac3) SHA1(ccc74edeca6abdd86fc1cf42ececa1ea393b3261) ) \
+	ROM_REGION( 0x200000, "simm4.7", 0 ) ROM_LOAD( "jojoba-simm4.7",  0x00000, 0x200000, CRC(36392b87) SHA1(e62080c8461775c1e180400dfb44414679fd0fc1) ) \
+	ROM_REGION( 0x200000, "simm5.0", 0 ) ROM_LOAD( "jojoba-simm5.0",  0x00000, 0x200000, CRC(2ef8c60c) SHA1(dea87a73a11b8edd27c3c9c5ab2af295cb5508f9) ) \
+	ROM_REGION( 0x200000, "simm5.1", 0 ) ROM_LOAD( "jojoba-simm5.1",  0x00000, 0x200000, CRC(cf7d7ca6) SHA1(b347707b1e5bc71d28b282273f893592e5f9e333) ) \
+	ROM_REGION( 0x200000, "simm5.2", 0 ) ROM_LOAD( "jojoba-simm5.2",  0x00000, 0x200000, CRC(b7815bfa) SHA1(0b5a3a2ffe1b3c0ca765dcedc297e78e5928302b) ) \
+	ROM_REGION( 0x200000, "simm5.3", 0 ) ROM_LOAD( "jojoba-simm5.3",  0x00000, 0x200000, CRC(9bfec049) SHA1(62cc9a1920047863205544b77344ee18f310f084) ) \
+	ROM_REGION( 0x200000, "simm5.4", 0 ) ROM_LOAD( "jojoba-simm5.4",  0x00000, 0x200000, CRC(d167536b) SHA1(e2637d3486f168ce44e0a00413d38960cb86db4c) ) \
+	ROM_REGION( 0x200000, "simm5.5", 0 ) ROM_LOAD( "jojoba-simm5.5",  0x00000, 0x200000, CRC(55e7a042) SHA1(c18bda61fa005d9174a27b7b7d324004262a4525) ) \
+	ROM_REGION( 0x200000, "simm5.6", 0 ) ROM_LOAD( "jojoba-simm5.6",  0x00000, 0x200000, CRC(4fb32906) SHA1(3a5965b3197517932c8aa4c07a6ea6a190a338d7) ) \
+	ROM_REGION( 0x200000, "simm5.7", 0 ) ROM_LOAD( "jojoba-simm5.7",  0x00000, 0x200000, CRC(8c8be520) SHA1(c461f3f76a83592b36b29afb316679a7c8972404) ) \
+
 #define JOJOBA_990913_CDROM \
 	DISK_REGION( "cdrom" ) DISK_IMAGE_READONLY( "cap-jjm-0", 0, SHA1(0678a0baeb853dcff1d230c14f0873cc9f143d7b) ) \
 
@@ -3102,6 +3139,14 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_japan.29f400.u2", 0x000000, 0x080000, CRC(3085478c) SHA1(055eab1fc42816f370a44b17fd7e87ffcb10e8b7) )
 
+	JOJOBA_990927_FLASH
+	JOJOBA_990927_CDROM
+ROM_END
+
+ROM_START( jojobaa )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojoba_japan.29f400.u2", 0x000000, 0x080000, CRC(3085478c) SHA1(055eab1fc42816f370a44b17fd7e87ffcb10e8b7) )
+
 	JOJOBA_990913_FLASH
 	JOJOBA_990913_CDROM
 ROM_END
@@ -3155,6 +3200,13 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_japan_nocd.29f400.u2", 0x000000, 0x080000, CRC(4dab19f5) SHA1(ba07190e7662937fc267f07285c51e99a45c061e) )
 
+	JOJOBA_990927_FLASH
+ROM_END
+
+ROM_START( jojobaan )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojoba_japan_nocd.29f400.u2", 0x000000, 0x080000, CRC(4dab19f5) SHA1(ba07190e7662937fc267f07285c51e99a45c061e) )
+
 	JOJOBA_990913_FLASH
 ROM_END
 
@@ -3162,6 +3214,13 @@
 	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
 	ROM_LOAD( "jojoba_euro_nocd.29f400.u2", 0x000000, 0x080000, CRC(1ee2d679) SHA1(9e129b454a376606b3f7e8aec64de425cf9c635c) )
 
+	JOJOBA_990927_FLASH
+ROM_END
+
+ROM_START( jojobaane )
+	ROM_REGION32_BE( 0x080000, "user1", 0 ) /* bios region */
+	ROM_LOAD( "jojoba_euro_nocd.29f400.u2", 0x000000, 0x080000, CRC(1ee2d679) SHA1(9e129b454a376606b3f7e8aec64de425cf9c635c) )
+
 	JOJOBA_990913_FLASH
 ROM_END
 
@@ -3325,7 +3384,8 @@
 GAME( 1999, sfiii3a,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Euro 990512)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, sfiii3u,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (USA 990608)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, sfiii3au,  sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (USA 990512)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojoba,    0,        jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojoba,    0,        jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990927)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobaa,   jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913)", GAME_IMPERFECT_GRAPHICS )
 
 /* NO CD sets */
 
@@ -3335,5 +3395,7 @@
 GAME( 1998, jojoan,    jojo,     jojo,     cps3_jojo, jojo,     ROT0, "Capcom", "JoJo's Venture (Asia 981202, NO CD)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, sfiii3n,   sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990608, NO CD)", GAME_IMPERFECT_GRAPHICS )
 GAME( 1999, sfiii3an,  sfiii3,   sfiii3,   cps3,      sfiii3,   ROT0, "Capcom", "Street Fighter III 3rd Strike: Fight for the Future (Japan 990512, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojoban,   jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
-GAME( 1999, jojobane,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojoban,   jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990927, NO CD)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobaan,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo no Kimyouna Bouken: Miraie no Isan (Japan 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobane,  jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990927, NO CD)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1999, jojobaane, jojoba,   jojoba,   cps3_jojo, jojoba,   ROT0, "Capcom", "JoJo's Bizarre Adventure (Euro 990913, NO CD)", GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/cvs.c src/mame/drivers/cvs.c
--- src-old/mame/drivers/cvs.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/cvs.c	2012-02-11 11:01:01.000000000 +0100
@@ -239,7 +239,7 @@
 static INTERRUPT_GEN( cvs_main_cpu_interrupt )
 {
 	device_set_input_line_vector(device, 0, 0x03);
-	generic_pulse_irq_line(device, 0);
+	generic_pulse_irq_line(device, 0, 1);
 
 	cvs_scroll_stars(device->machine());
 }
diff -Nru src-old/mame/drivers/dai3wksi.c src/mame/drivers/dai3wksi.c
--- src-old/mame/drivers/dai3wksi.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/dai3wksi.c	2012-02-19 02:53:16.000000000 +0100
@@ -197,7 +197,7 @@
 static WRITE8_HANDLER( dai3wksi_audio_1_w )
 {
 	dai3wksi_state *state = space->machine().driver_data<dai3wksi_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 rising_bits = data & ~state->m_port_last1;
 
 	state->m_enabled_sound = data & 0x80;
@@ -205,12 +205,12 @@
 	if ((rising_bits & 0x20) && state->m_enabled_sound)
 	{
 		if (data & 0x04)
-			sample_start(samples, CHANNEL_SOUND5, SAMPLE_SOUND5, 0);
+			samples->start(CHANNEL_SOUND5, SAMPLE_SOUND5);
 		else
-			sample_start(samples, CHANNEL_SOUND5, SAMPLE_SOUND5, 1);
+			samples->start(CHANNEL_SOUND5, SAMPLE_SOUND5, true);
 	}
 	if (!(data & 0x20) && (state->m_port_last1 & 0x20))
-		sample_stop(samples, CHANNEL_SOUND5);
+		samples->stop(CHANNEL_SOUND5);
 
 	state->m_port_last1 = data;
 }
@@ -218,7 +218,7 @@
 static WRITE8_HANDLER( dai3wksi_audio_2_w )
 {
 	dai3wksi_state *state = space->machine().driver_data<dai3wksi_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 rising_bits = data & ~state->m_port_last2;
 
 	state->m_dai3wksi_flipscreen = data & 0x10;
@@ -227,15 +227,15 @@
 
 	if (state->m_enabled_sound)
 	{
-		if (rising_bits & 0x01) sample_start(samples, CHANNEL_SOUND1, SAMPLE_SOUND1, 0);
-		if (rising_bits & 0x02) sample_start(samples, CHANNEL_SOUND2, SAMPLE_SOUND2, 0);
-		if (rising_bits & 0x08) sample_start(samples, CHANNEL_SOUND4, SAMPLE_SOUND4, 0);
+		if (rising_bits & 0x01) samples->start(CHANNEL_SOUND1, SAMPLE_SOUND1);
+		if (rising_bits & 0x02) samples->start(CHANNEL_SOUND2, SAMPLE_SOUND2);
+		if (rising_bits & 0x08) samples->start(CHANNEL_SOUND4, SAMPLE_SOUND4);
 		if (rising_bits & 0x04)
 		{
 			if (!state->m_sound3_counter)
-				sample_start(samples, CHANNEL_SOUND3, SAMPLE_SOUND3_1, 0);
+				samples->start(CHANNEL_SOUND3, SAMPLE_SOUND3_1);
 			else
-				sample_start(samples, CHANNEL_SOUND3, SAMPLE_SOUND3_2, 0);
+				samples->start(CHANNEL_SOUND3, SAMPLE_SOUND3_2);
 
 			state->m_sound3_counter ^= 1;
 		}
@@ -247,14 +247,14 @@
 static WRITE8_HANDLER( dai3wksi_audio_3_w )
 {
 	dai3wksi_state *state = space->machine().driver_data<dai3wksi_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	if (state->m_enabled_sound)
 	{
 		if (data & 0x40)
-			sample_start(samples, CHANNEL_SOUND6, SAMPLE_SOUND6_1, 0);
+			samples->start(CHANNEL_SOUND6, SAMPLE_SOUND6_1);
 		else if (data & 0x80)
-			sample_start(samples, CHANNEL_SOUND6, SAMPLE_SOUND6_2, 0);
+			samples->start(CHANNEL_SOUND6, SAMPLE_SOUND6_2);
 	}
 }
 
@@ -607,8 +607,7 @@
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
 #if (USE_SAMPLES)
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(dai3wksi_samples_interface)
+	MCFG_SAMPLES_ADD("samples", dai3wksi_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 #else
 	MCFG_SOUND_ADD("ic76", SN76477, 0)
diff -Nru src-old/mame/drivers/ddenlovr.c src/mame/drivers/ddenlovr.c
--- src-old/mame/drivers/ddenlovr.c	2012-01-26 17:49:31.000000000 +0100
+++ src/mame/drivers/ddenlovr.c	2012-02-06 02:30:22.000000000 +0100
@@ -102,7 +102,6 @@
 #include "sound/okim6295.h"
 #include "sound/2413intf.h"
 #include "machine/msm6242.h"
-#include "profiler.h"
 #include "includes/dynax.h"
 
 
diff -Nru src-old/mame/drivers/ddragon.c src/mame/drivers/ddragon.c
--- src-old/mame/drivers/ddragon.c	2012-01-30 00:42:13.000000000 +0100
+++ src/mame/drivers/ddragon.c	2012-02-19 01:27:36.000000000 +0100
@@ -1489,10 +1489,10 @@
 
 ROM_START( ddragonb2 )
 	ROM_REGION( 0x30000, "maincpu", 0 )	/* 64k for code + bankswitched memory */
-	ROM_LOAD( "4.bin",        0x08000, 0x08000, CRC(668dfa19) SHA1(9b2ff1b66eeba0989e4ed850b7df1f5719ba5572) )
-	ROM_LOAD( "5.bin",        0x10000, 0x08000, CRC(5779705e) SHA1(4b8f22225d10f5414253ce0383bbebd6f720f3af) ) /* banked at 0x4000-0x8000 */
-	ROM_LOAD( "6.bin",        0x18000, 0x08000, CRC(3bdea613) SHA1(d9038c80646a6ce3ea61da222873237b0383680e) ) /* banked at 0x4000-0x8000 */
-	ROM_LOAD( "7.bin",        0x20000, 0x08000, CRC(728f87b9) SHA1(d7442be24d41bb9fc021587ef44ae5b830e4503d) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "b2_4.bin",     0x08000, 0x08000, CRC(668dfa19) SHA1(9b2ff1b66eeba0989e4ed850b7df1f5719ba5572) )
+	ROM_LOAD( "b2_5.bin",     0x10000, 0x08000, CRC(5779705e) SHA1(4b8f22225d10f5414253ce0383bbebd6f720f3af) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "b2_6.bin",     0x18000, 0x08000, CRC(3bdea613) SHA1(d9038c80646a6ce3ea61da222873237b0383680e) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "b2_7.bin",     0x20000, 0x08000, CRC(728f87b9) SHA1(d7442be24d41bb9fc021587ef44ae5b830e4503d) ) /* banked at 0x4000-0x8000 */
 
 	ROM_REGION( 0x10000, "sub", 0 ) /* sprite cpu */
 	ROM_LOAD( "63701.bin",    0xc000, 0x4000, CRC(f5232d03) SHA1(e2a194e38633592fd6587690b3cb2669d93985c7) )
@@ -1501,7 +1501,7 @@
 	ROM_LOAD( "b2_3.bin",     0x08000, 0x08000, CRC(9efa95bb) SHA1(da997d9cc7b9e7b2c70a4b6d30db693086a6f7d8) )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )
-	ROM_LOAD( "8.bin",        0x00000, 0x08000, CRC(7a8b8db4) SHA1(8368182234f9d4d763d4714fd7567a9e31b7ebeb) )	/* chars */
+	ROM_LOAD( "b2_8.bin",     0x00000, 0x08000, CRC(7a8b8db4) SHA1(8368182234f9d4d763d4714fd7567a9e31b7ebeb) )	/* chars */
 
 	ROM_REGION( 0x80000, "gfx2", 0 )
 	ROM_LOAD( "11.bin",       0x00000, 0x10000, CRC(574face3) SHA1(481fe574cb79d0159a65ff7486cbc945d50538c5) )	/* sprites */
@@ -1537,13 +1537,13 @@
  */
 ROM_START( ddragon6809 )
 	ROM_REGION( 0x30000, "maincpu", 0 )	/* 64k for code + bankswitched memory */
-	ROM_LOAD( "16.bin",   0x08000, 0x08000, CRC(f4c72690) SHA1(c70d032355acf3f7f6586b6e57a94f80e099bf1a) )
-	ROM_LOAD( "17.bin",   0x10000, 0x08000, CRC(6489d637) SHA1(fd17fd870e9386a3e3bdd56c8d731c73d8c70b88) ) /* banked at 0x4000-0x8000 */
-	ROM_LOAD( "18.bin",   0x18000, 0x08000, CRC(154d50c4) SHA1(4ffdd29406b6c6b552344f820f83715b1c7727d1) ) /* banked at 0x4000-0x8000 */
-	ROM_LOAD( "19.bin",   0x20000, 0x08000, CRC(090e2baf) SHA1(29b775c59c7a4d30a33e3d10e736cd1a83baf3bb) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "6809_16.bin",   0x08000, 0x08000, CRC(f4c72690) SHA1(c70d032355acf3f7f6586b6e57a94f80e099bf1a) )
+	ROM_LOAD( "6809_17.bin",   0x10000, 0x08000, CRC(6489d637) SHA1(fd17fd870e9386a3e3bdd56c8d731c73d8c70b88) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "6809_18.bin",   0x18000, 0x08000, CRC(154d50c4) SHA1(4ffdd29406b6c6b552344f820f83715b1c7727d1) ) /* banked at 0x4000-0x8000 */
+	ROM_LOAD( "6809_19.bin",   0x20000, 0x08000, CRC(090e2baf) SHA1(29b775c59c7a4d30a33e3d10e736cd1a83baf3bb) ) /* banked at 0x4000-0x8000 */
 
 	ROM_REGION( 0x10000, "sub", 0 ) /* sprite cpu */
-	ROM_LOAD( "20.bin",    0x8000, 0x8000, CRC(67e3b4f1) SHA1(4945d76b0694299f2f4739ebfba98da6d96fe4cb) )
+	ROM_LOAD( "6809_20.bin",   0x8000, 0x8000, CRC(67e3b4f1) SHA1(4945d76b0694299f2f4739ebfba98da6d96fe4cb) )
 
 	ROM_REGION( 0x10000, "soundcpu", 0 ) /* audio cpu */
 	ROM_LOAD( "21.bin",      0x08000, 0x08000, CRC(4437fc51) SHA1(fffcf2bec50d0b79861904b4abc607206b7794e6) )
@@ -1552,7 +1552,7 @@
 	ROM_REGION( 0x08000, "gfx1", ROMREGION_ERASEFF )
 
 	ROM_REGION( 0x08000, "chars", 0 )
-	ROM_LOAD( "13.bin",        0x00000, 0x08000, CRC(b5a54537) SHA1(a6157cde4f9738565008d11a4a6d8576ae3abfef) )	/* chars */
+	ROM_LOAD( "6809_13.bin",   0x00000, 0x08000, CRC(b5a54537) SHA1(a6157cde4f9738565008d11a4a6d8576ae3abfef) )	/* chars */
 
 	ROM_REGION( 0x80000, "gfx2", 0 )
 	ROM_LOAD( "22.bin",        0x00000, 0x08000, CRC(fe08ef61) SHA1(50404936934dc61f3553add4d4b918529b3b5ef3) )
@@ -1564,23 +1564,23 @@
 	ROM_LOAD( "28.bin",        0x30000, 0x08000, CRC(51b8a217) SHA1(60c067cd7272f856e29cdb64312535236656891a) )
 	ROM_LOAD( "29.bin",        0x38000, 0x08000, CRC(e4ec2394) SHA1(43376ce2a07c1fc3053f7ac9b750e944d289105b) )
 	ROM_LOAD( "6809_1.bin",    0x40000, 0x08000, CRC(2485a71d) SHA1(3e987a2f3e9a59da5fdc7bb779a43736ca67aac7) )
-	ROM_LOAD( "2.bin",         0x48000, 0x08000, CRC(6940120d) SHA1(bbe94f095ef983f54658c936f916ba6a72a84ead) )
-	ROM_LOAD( "3.bin",         0x50000, 0x08000, CRC(c67aac12) SHA1(aab535507e3889bf1bdc2f4fe4828a70a350ba63) )
-	ROM_LOAD( "4.bin",         0x58000, 0x08000, CRC(941dcd08) SHA1(266dee264f28affe8c3f57fe569929817ae16508) )
-	ROM_LOAD( "5.bin",         0x60000, 0x08000, CRC(42d36bc3) SHA1(080cbc3ffda8ab26dc65a8e9eaf948c509d064b3) )
-	ROM_LOAD( "6.bin",         0x68000, 0x08000, CRC(d5d19a8d) SHA1(c4b044dd12d6468c0ad114644f01813d4fe9a673) )
-	ROM_LOAD( "7.bin",         0x70000, 0x08000, CRC(d4e350cd) SHA1(78ed2baa8c52b766f998091e7ce9e1a2941352e7) )
-	ROM_LOAD( "8.bin",         0x78000, 0x08000, CRC(204fdb7d) SHA1(f75b1bc6f65e7a33927cd451267fcd7e2aa44f7e) )
+	ROM_LOAD( "6809_2.bin",    0x48000, 0x08000, CRC(6940120d) SHA1(bbe94f095ef983f54658c936f916ba6a72a84ead) )
+	ROM_LOAD( "6809_3.bin",    0x50000, 0x08000, CRC(c67aac12) SHA1(aab535507e3889bf1bdc2f4fe4828a70a350ba63) )
+	ROM_LOAD( "6809_4.bin",    0x58000, 0x08000, CRC(941dcd08) SHA1(266dee264f28affe8c3f57fe569929817ae16508) )
+	ROM_LOAD( "6809_5.bin",    0x60000, 0x08000, CRC(42d36bc3) SHA1(080cbc3ffda8ab26dc65a8e9eaf948c509d064b3) )
+	ROM_LOAD( "6809_6.bin",    0x68000, 0x08000, CRC(d5d19a8d) SHA1(c4b044dd12d6468c0ad114644f01813d4fe9a673) )
+	ROM_LOAD( "6809_7.bin",    0x70000, 0x08000, CRC(d4e350cd) SHA1(78ed2baa8c52b766f998091e7ce9e1a2941352e7) )
+	ROM_LOAD( "6809_8.bin",    0x78000, 0x08000, CRC(204fdb7d) SHA1(f75b1bc6f65e7a33927cd451267fcd7e2aa44f7e) )
 
 	ROM_REGION( 0x40000, "gfx3", 0 )
-	ROM_LOAD( "9.bin",         0x00000, 0x10000, CRC(736eff0f) SHA1(ae2ec2d5c8ab1db579a08256d874426dc5d889c6) )
+	ROM_LOAD( "6809_9.bin",    0x00000, 0x10000, CRC(736eff0f) SHA1(ae2ec2d5c8ab1db579a08256d874426dc5d889c6) )
 	ROM_LOAD( "6809_10.bin",   0x10000, 0x10000, CRC(a670d088) SHA1(27e7b49645753dd039f104c3e0a7e6513a98710d) )
-	ROM_LOAD( "11.bin",        0x20000, 0x10000, CRC(4171b70d) SHA1(dc300c9bca6481417e97ad03c973e47389f261c1) )
-	ROM_LOAD( "12.bin",        0x30000, 0x10000, CRC(5f6a6d6f) SHA1(7d546a226cda81c28e7ccfb4c5daebc65072198d) )
+	ROM_LOAD( "6809_11.bin",   0x20000, 0x10000, CRC(4171b70d) SHA1(dc300c9bca6481417e97ad03c973e47389f261c1) )
+	ROM_LOAD( "6809_12.bin",   0x30000, 0x10000, CRC(5f6a6d6f) SHA1(7d546a226cda81c28e7ccfb4c5daebc65072198d) )
 
 	ROM_REGION( 0x20000, "adpcm", 0 ) /* adpcm samples  */
-	ROM_LOAD( "14.bin",        0x00000, 0x08000, CRC(678f8657) SHA1(2652fdc6719d2c889ca87802f6e2cefae59fc2eb) )
-	ROM_LOAD( "15.bin",        0x10000, 0x08000, CRC(10f21dea) SHA1(739cf649f91490384297a81a2cc9855acb58a1c0) )
+	ROM_LOAD( "6809_14.bin",   0x00000, 0x08000, CRC(678f8657) SHA1(2652fdc6719d2c889ca87802f6e2cefae59fc2eb) )
+	ROM_LOAD( "6809_15.bin",   0x10000, 0x08000, CRC(10f21dea) SHA1(739cf649f91490384297a81a2cc9855acb58a1c0) )
 ROM_END
 
 /*
diff -Nru src-old/mame/drivers/deadang.c src/mame/drivers/deadang.c
--- src-old/mame/drivers/deadang.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/deadang.c	2012-02-19 04:59:57.000000000 +0100
@@ -316,9 +316,9 @@
 
 ROM_START( leadang )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* v20 main cpu */
-	ROM_LOAD16_BYTE("2.18h",   0x0c0000, 0x10000, CRC(611247e0) SHA1(1b9ad50f67ba3a3a9e5a0d6e33f4d4be2fc20446) )
-	ROM_LOAD16_BYTE("4.22h",   0x0c0001, 0x10000, CRC(348c1201) SHA1(277dd77dcbc950299de0fd56a4f66db8f90752ad) )
-	ROM_LOAD16_BYTE("1.18f",   0x0e0000, 0x10000, CRC(fb952d71) SHA1(c6578cddf019872e6005c3a9e8e3e024d17d8c6e) )
+	ROM_LOAD16_BYTE("2(__leadang).18h",   0x0c0000, 0x10000, CRC(611247e0) SHA1(1b9ad50f67ba3a3a9e5a0d6e33f4d4be2fc20446) )
+	ROM_LOAD16_BYTE("4(__leadang).22h",   0x0c0001, 0x10000, CRC(348c1201) SHA1(277dd77dcbc950299de0fd56a4f66db8f90752ad) )
+	ROM_LOAD16_BYTE("1(__leadang).18f",   0x0e0000, 0x10000, CRC(fb952d71) SHA1(c6578cddf019872e6005c3a9e8e3e024d17d8c6e) )
 	ROM_LOAD16_BYTE("3.22f",   0x0e0001, 0x10000, CRC(2271c6df) SHA1(774a92bb698606e58d0c74ea07d7eaecf766dddf) )
 
 	ROM_REGION( 0x100000, "sub", 0 ) /* v20 sub cpu */
diff -Nru src-old/mame/drivers/decocass.c src/mame/drivers/decocass.c
--- src-old/mame/drivers/decocass.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/decocass.c	2012-02-13 20:29:50.000000000 +0100
@@ -17,13 +17,13 @@
     Early boardset: (1980-1983) (proms unknown for this boardset, no schematics for this boardset)
     One RMS-3 pcb with a 6502 processor, two ay-3-8910s, and one 2716 eprom holding the audio bios. (audio)
     One DSP-3 pcb with a 6502 processor, two 2716 eproms (main processor and bios, graphics, dipswitches?)
-    One BIO-3 pcb with an 8041 MCU (cassette control)
+    One BIO-3 pcb with an 8041 MCU (DECO Cassette control)
     TODO: get more info about this older boardset: D. Widel has some info about it on his page at http://www.widel.com/stuff/decopin.htm
 
     Later boardset: (1984 onward, schematic is dated 10/83)
     One DE-0097C-0 RMS-8 pcb with a 6502 processor, two ay-3-8910s, two eproms (2716 and 2732) plus one prom, and 48k worth of 4116 16kx1 DRAMs; the 6502 processor has its own 4K of SRAM. (audio processor and RAM, Main processor's dram, dipswitches)
     One DE-0096C-0 DSP-8 board with a 'DECO 222' custom on it (labeled '8049 // C10707-2') which appears to really be a 'cleverly' disguised 6502, and two proms, plus 4K of sram, and three hm2511-1 1kx1 srams. (main processor and graphics)
-    One DE-0098C-0 B10-8 (BIO-8 on schematics) board with an 8041, an analog devices ADC0908 8-bit adc, and 4K of SRAM on it (cassette control, inputs)
+    One DE-0098C-0 B10-8 (BIO-8 on schematics) board with an 8041, an analog devices ADC0908 8-bit adc, and 4K of SRAM on it (DECO Cassette control, inputs)
 
 
     The actual cassettes use a custom player hooked to the BIO board, and are roughly microcassette form factor, but are larger and will not fit in a conventional microcassette player.
@@ -1284,7 +1284,7 @@
 ROM_END
 
 /* The Following use Dongle Type 4 (unknown part number?)
-    (dongle data probably differs for each game, but only one is known using it atm) */
+    (dongle data is used for most of the graphics) */
 
 ROM_START( cscrtry )
 	DECOCASS_BIOS_B_ROMS
@@ -1306,6 +1306,16 @@
 	ROM_LOAD( "cscrtry2.cas",  0x0000, 0x8000, CRC(04597842) SHA1(7f1fc3e06b61df880debe9056bdfbbb8600af739) )
 ROM_END
 
+ROM_START( cgsumo )
+	DECOCASS_BIOS_A_ROMS
+
+	ROM_REGION( 0x08000, "dongle", 0 )	  /* dongle data */
+	ROM_LOAD( "dp-141a.pro",  0x0000, 0x8000, CRC(bc379d2c) SHA1(bab19dcb6d68fdbd547ebab1598353f436321157) )
+
+	ROM_REGION( 0x10000, "cassette", 0 )	  /* (max) 64k for cassette image */
+	ROM_LOAD( "dt-141[1a]ext.bin",  0x0000, 0x10000, CRC(20c2e86a) SHA1(a18248ba00b847a09df0bea7752a21162af8af76) )
+ROM_END
+
 /* The Following use Dongle Type 5 (unknown part number?)
     (dongle data not read)       */
 
@@ -1400,43 +1410,65 @@
 	state->save_pointer(NAME(state->m_decrypted2), romlength);
 }
 
+/* -- */ GAME( 1981, decocass, 0,        decocass, decocass, decocass, ROT270, "Data East Corporation", "DECO Cassette System", GAME_IS_BIOS_ROOT )
+/* -- */ GAME( 1981, ctsttape, decocass, ctsttape, decocass, decocass, ROT270, "Data East Corporation", "Test Tape (DECO Cassette)", 0 )
+/* 01 */ GAME( 1980, chwy,     decocass, chwy,     decocass, decocass, ROT270, "Data East Corporation", "Highway Chase (DECO Cassette)", 0 )
+/* 02 */ // 1980.12 Sengoku Ninjatai
+/* 03 */ // 1981.01 Manhattan
+/* 04 */ GAME( 1981, cterrani, decocass, cterrani, cterrani, decocass, ROT270, "Data East Corporation", "Terranean (DECO Cassette)", 0 )
+/* 05 */ // 1981.?? Missile Sprinter
+/* 06 */ // 1980.12 Nebula
+/* 07 */ GAME( 1981, castfant, decocass, castfant, decocass, decocass, ROT270, "Data East Corporation", "Astro Fantasia (DECO Cassette)", 0 )
+/* 08 */ // 1981.03 The Tower
+/* 09 */ GAME( 1981, csuperas, decocass, csuperas, csuperas, decocass, ROT270, "Data East Corporation", "Super Astro Fighter (DECO Cassette)", 0 )
+/* 10 */ // 1981.?? Ocean to Ocean (medal)
+/* 11 */ GAME( 1981, clocknch, decocass, clocknch, clocknch, decocass, ROT270, "Data East Corporation", "Lock'n'Chase (DECO Cassette)", 0 )
+/* 12 */ // 1981.08 Flash Boy/DECO Kid
+/* 13 */ GAME( 1981, cprogolf, decocass, cprogolf, cprogolf, decocass, ROT270, "Data East Corporation", "Tournament Pro Golf (DECO Cassette)", 0 )
+/* 14 */ // 1981.06 DS Telejan
+/* 15 */ GAME( 1981, cluckypo, decocass, cluckypo, decocass, decocass, ROT270, "Data East Corporation", "Lucky Poker (DECO Cassette)", 0 )
+/* 16 */ GAME( 1981, ctisland, decocass, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (DECO Cassette, set 1)", 0 )
+		 GAME( 1981, ctisland2,ctisland, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (DECO Cassette, set 2)", 0 )
+		 GAME( 1981, ctisland3,ctisland, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (DECO Cassette, set 3)", GAME_NOT_WORKING ) /* Different Bitswap? */
+/* 17 */ // 1981.10 Bobbitto
+/* 18 */ GAME( 1982, cexplore, decocass, cexplore, cexplore, decocass, ROT270, "Data East Corporation", "Explorer (DECO Cassette)", GAME_NOT_WORKING )
+/* 19 */ GAME( 1982, cdiscon1, decocass, cdiscon1, decocass, decocass, ROT270, "Data East Corporation", "Disco No.1 (DECO Cassette)", 0 )
+		 GAME( 1982, csweetht, cdiscon1, cdiscon1, decocass, decocass, ROT270, "Data East Corporation", "Sweet Heart (DECO Cassette)", 0 )
+/* 20 */ GAME( 1982, ctornado, decocass, ctornado, ctornado, decocass, ROT270, "Data East Corporation", "Tornado (DECO Cassette)", 0 )
+/* 21 */ GAME( 1982, cmissnx,  decocass, cmissnx,  cmissnx,  decocass, ROT270, "Data East Corporation", "Mission-X (DECO Cassette)", 0 )
+/* 22 */ GAME( 1982, cptennis, decocass, cptennis, decocass, decocass, ROT270, "Data East Corporation", "Pro Tennis (DECO Cassette)", 0 )
+/* 23 */ // 1982.?? 18 Hole Pro Golf
+/* 24 */ // 1982.07 Tsumego Kaisyou
+/* 25 */ // 1982.10 Angler Dangler? (fishing)
+/* 26 */ GAME( 1983, cbtime,   decocass, cbtime,   cbtime,   decocass, ROT270, "Data East Corporation", "Burger Time (DECO Cassette)", 0 )
+/* 27 */ GAME( 1982, cburnrub, decocass, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (DECO Cassette, set 1)", 0 )
+		 GAME( 1982, cburnrub2,cburnrub, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (DECO Cassette, set 2)", 0 )
+		 GAME( 1982, cbnj,     cburnrub, cbnj,     decocass, decocass, ROT270, "Data East Corporation", "Bump 'n' Jump (DECO Cassette)", 0 )
+/* 28 */ GAME( 1983, cgraplop, decocass, cgraplop, cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (DECO Cassette, set 1)", 0 )
+		 GAME( 1983, cgraplop2,cgraplop, cgraplop2,cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (DECO Cassette, set 2)", GAME_NOT_WORKING )
+/* 29 */ GAME( 1983, clapapa,  decocass, clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' / La-Pa-Pa (DECO Cassette)" , 0) /* Displays 'La-Pa-Pa during attract */
+	     GAME( 1983, clapapa2, clapapa,  clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' (DECO Cassette)" , 0) /* Displays 'Rootin' Tootin' during attract */
+/* 30 */ // 1983.03 Skater
+/* 31 */ GAME( 1983, cprobowl, decocass, cprobowl, decocass, decocass, ROT270, "Data East Corporation", "Pro Bowling (DECO Cassette)", 0 )
+/* 32 */ GAME( 1983, cnightst, decocass, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (DECO Cassette, set 1)", 0 )
+		 GAME( 1983, cnightst2,cnightst, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (DECO Cassette, set 2)", 0 )
+/* 33 */ GAME( 1983, cpsoccer, decocass, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (DECO Cassette)", 0 )
+		 GAME( 1983, cpsoccerj,cpsoccer, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (DECO Cassette, Japan)", 0 )
+/* 34 */ // 1983.09 Super Doubles Tennis
+/* 35 */ GAME( 1985, cflyball, decocass, cflyball, decocass, decocass, ROT270, "Data East Corporation", "Flying Ball (DECO Cassette)", 0 )
+/* 36 */ // 1984.04 Genesis/Boomer Rang'r
+/* 37 */ GAME( 1983, czeroize, decocass, czeroize, decocass, decocass, ROT270, "Data East Corporation", "Zeroize (DECO Cassette)", 0 )
+/* 38 */ GAME( 1984, cscrtry,  decocass, cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 1)", 0 )
+		 GAME( 1984, cscrtry2, cscrtry,  cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (DECO Cassette, set 2)", 0 )
+/* 39 */ GAME( 1984, cppicf,   decocass, cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (DECO Cassette, set 1)", 0 )
+		 GAME( 1984, cppicf2,  cppicf,   cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (DECO Cassette, set 2)", 0 )
+/* 40 */ GAME( 1984, cfghtice, decocass, cfghtice, cfghtice, decocass, ROT270, "Data East Corporation", "Fighting Ice Hockey (DECO Cassette)", 0 )
+/* 41 */ GAME( 1984, cgsumo,   decocass, cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Oozumou - The Grand Sumo (DECO Cassette)", 0 )
+/* 42 */ // 1984.08 Hellow Gateball // not a typo, this is official spelling
+/* 43 */ // 1984.08 Yellow Cab
+/* 44 */ GAME( 1985, cbdash,   decocass, cbdash,   cbdash,   decocass, ROT270, "Data East Corporation", "Boulder Dash (DECO Cassette)", 0 )
+
+/* UX7 */ // 1984.12 Tokyo MIE Clinic/Tokyo MIE Shinryoujo
+/* UX8 */ // 1985.01 Tokyo MIE Clinic/Tokyo MIE Shinryoujo Part 2
+/* UX9 */ // 1985.05 Geinoujin Shikaku Shiken
 
-         GAME( 1981, decocass, 0, decocass, decocass, decocass, ROT270, "Data East Corporation", "DECO Cassette System", GAME_IS_BIOS_ROOT )
-         GAME( 1981, ctsttape, decocass, ctsttape, decocass, decocass, ROT270, "Data East Corporation", "Test Tape (Cassette)", 0 )
-/* 01 */ GAME( 1980, chwy,     decocass, chwy,     decocass, decocass, ROT270, "Data East Corporation", "Highway Chase (Cassette)", 0 )
-/* 04 */ GAME( 1981, cterrani, decocass, cterrani, cterrani, decocass, ROT270, "Data East Corporation", "Terranean (Cassette)", 0 )
-/* 07 */ GAME( 1981, castfant, decocass, castfant, decocass, decocass, ROT270, "Data East Corporation", "Astro Fantasia (Cassette)", 0 )
-/* 09 */ GAME( 1981, csuperas, decocass, csuperas, csuperas, decocass, ROT270, "Data East Corporation", "Super Astro Fighter (Cassette)", 0 )
-/* 11 */ GAME( 1981, clocknch, decocass, clocknch, clocknch, decocass, ROT270, "Data East Corporation", "Lock'n'Chase (Cassette)", 0 )
-/* 13 */ GAME( 1981, cprogolf, decocass, cprogolf, cprogolf, decocass, ROT270, "Data East Corporation", "Tournament Pro Golf (Cassette)", 0 )
-/* 15 */ GAME( 1981, cluckypo, decocass, cluckypo, decocass, decocass, ROT270, "Data East Corporation", "Lucky Poker (Cassette)", 0 )
-/* 16 */ GAME( 1981, ctisland, decocass, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (Cassette, set 1)", 0 )
-/* 16 */ GAME( 1981, ctisland2,ctisland, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (Cassette, set 2)", 0 )
-/* 16 */ GAME( 1981, ctisland3,ctisland, ctisland, decocass, decocrom, ROT270, "Data East Corporation", "Treasure Island (Cassette, set 3)", GAME_NOT_WORKING ) /* Different Bitswap? */
-/* 18 */ GAME( 1982, cexplore, decocass, cexplore, cexplore, decocass, ROT270, "Data East Corporation", "Explorer (Cassette)", GAME_NOT_WORKING )
-/* 19 */ GAME( 1982, cdiscon1, decocass, cdiscon1, decocass, decocass, ROT270, "Data East Corporation", "Disco No.1 (Cassette)", 0 )
-/* 19 */ GAME( 1982, csweetht, cdiscon1, cdiscon1, decocass, decocass, ROT270, "Data East Corporation", "Sweet Heart (Cassette)", 0 )
-/* 20 */ GAME( 1982, ctornado, decocass, ctornado, ctornado, decocass, ROT270, "Data East Corporation", "Tornado (Cassette)", 0 )
-/* 21 */ GAME( 1982, cmissnx,  decocass, cmissnx,  cmissnx,  decocass, ROT270, "Data East Corporation", "Mission-X (Cassette)", 0 )
-/* 22 */ GAME( 1982, cptennis, decocass, cptennis, decocass, decocass, ROT270, "Data East Corporation", "Pro Tennis (Cassette)", 0 )
-/* 26 */ GAME( 1983, cbtime,   decocass, cbtime,   cbtime,   decocass, ROT270, "Data East Corporation", "Burger Time (Cassette)", 0 )
-/* 27 */ GAME( 1982, cburnrub, decocass, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (Cassette, set 1)", 0 )
-/* 27 */ GAME( 1982, cburnrub2,cburnrub, cburnrub, decocass, decocass, ROT270, "Data East Corporation", "Burnin' Rubber (Cassette, set 2)", 0 )
-/* 27 */ GAME( 1982, cbnj,     cburnrub, cbnj,     decocass, decocass, ROT270, "Data East Corporation", "Bump 'n' Jump (Cassette)", 0 )
-/* 28 */ GAME( 1983, cgraplop, decocass, cgraplop, cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (Cassette, set 1)", 0 )
-/* 28 */ GAME( 1983, cgraplop2,cgraplop, cgraplop2,cgraplop, decocass, ROT270, "Data East Corporation", "Cluster Buster / Graplop (Cassette, set 2)", GAME_NOT_WORKING )
-/* 29 */ GAME( 1983, clapapa,  decocass, clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' / La-Pa-Pa (Cassette)" , 0) /* Displays 'La-Pa-Pa during attract */
-/* 29 */ GAME( 1983, clapapa2, clapapa,  clapapa,  decocass, decocass, ROT270, "Data East Corporation", "Rootin' Tootin' (Cassette)" , 0) /* Displays 'Rootin' Tootin' during attract */
-/* 31 */ GAME( 1983, cprobowl, decocass, cprobowl, decocass, decocass, ROT270, "Data East Corporation", "Pro Bowling (Cassette)", 0 )
-/* 32 */ GAME( 1983, cnightst, decocass, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (Cassette, set 1)", 0 )
-/* 32 */ GAME( 1983, cnightst2,cnightst, cnightst, cnightst, decocass, ROT270, "Data East Corporation", "Night Star (Cassette, set 2)", 0 )
-/* 33 */ GAME( 1983, cpsoccer, decocass, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (Cassette)", 0 )
-/* 33 */ GAME( 1983, cpsoccerj,cpsoccer, cpsoccer, cpsoccer, decocass, ROT270, "Data East Corporation", "Pro Soccer (Cassette, Japan)", 0 )
-/* 35 */ GAME( 1985, cflyball, decocass, cflyball, decocass, decocass, ROT270, "Data East Corporation", "Flying Ball (Cassette)", 0 )
-/* 37 */ GAME( 1983, czeroize, decocass, czeroize, decocass, decocass, ROT270, "Data East Corporation", "Zeroize (Cassette)", 0 )
-/* 38 */ GAME( 1984, cscrtry,  decocass, cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (Cassette, set 1)", 0 )
-/* 38 */ GAME( 1984, cscrtry2, cscrtry,  cscrtry,  cscrtry,  decocass, ROT270, "Data East Corporation", "Scrum Try (Cassette, set 2)", 0 )
-/* 39 */ GAME( 1984, cppicf,   decocass, cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (Cassette, set 1)", 0 )
-/* 39 */ GAME( 1984, cppicf2,  cppicf,   cppicf,   decocass, decocass, ROT270, "Data East Corporation", "Peter Pepper's Ice Cream Factory (Cassette, set 2)", 0 )
-/* 40 */ GAME( 1984, cfghtice, decocass, cfghtice, cfghtice, decocass, ROT270, "Data East Corporation", "Fighting Ice Hockey (Cassette)", 0 )
-/* 44 */ GAME( 1985, cbdash,   decocass, cbdash,   cbdash,   decocass, ROT270, "Data East Corporation", "Boulder Dash (Cassette)", 0 )
diff -Nru src-old/mame/drivers/djmain.c src/mame/drivers/djmain.c
--- src-old/mame/drivers/djmain.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/djmain.c	2012-02-09 11:27:12.000000000 +0100
@@ -1488,7 +1488,7 @@
 	MCFG_MACHINE_START(djmain)
 	MCFG_MACHINE_RESET(djmain)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -1544,7 +1544,7 @@
 	ROM_LOAD16_BYTE( "753jaa09.25d", 0x100000, 0x80000, CRC(B50C3DBB) SHA1(6022ea249aad0793b2279699e68087b4bc9b4ef1) )
 	ROM_LOAD16_BYTE( "753jaa10.27d", 0x100001, 0x80000, CRC(391F4BFD) SHA1(791c9889ea3ce639bbfb87934a1cad9aa3c9ccde) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "753jaa11", 0, SHA1(2e70cf31a853322f29f99b6f292c187a2cf33015) )	/* ver 1.00 JA */
 	// There is an alternate image
 	//DISK_IMAGE( "753jaa11", 0, MD5(260c9b72f4a03055e3abad61c6225324) SHA1(2cc3e149744516bf2353a2b47d33bc9d2072b6c4) ) /* ver 1.00 JA */
@@ -1569,7 +1569,7 @@
 	ROM_LOAD16_BYTE( "853jaa09.25d", 0x100000, 0x80000, CRC(8584E21E) SHA1(3d1ca6de00f9ac07bbe7cd1e67093cca7bf484bb) )
 	ROM_LOAD16_BYTE( "853jaa10.27d", 0x100001, 0x80000, CRC(9CB92D98) SHA1(6ace4492ba0b5a8f94a9e7b4f7126b31c6254637) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "853jaa11", 0, SHA1(9683ff8462491252b6eb2e5b3aa6496884c01506) )	/* ver 1.10 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1592,7 +1592,7 @@
 	ROM_LOAD16_BYTE( "853jaa09.25d", 0x100000, 0x80000, CRC(8584E21E) SHA1(3d1ca6de00f9ac07bbe7cd1e67093cca7bf484bb) )
 	ROM_LOAD16_BYTE( "853jaa10.27d", 0x100001, 0x80000, CRC(9CB92D98) SHA1(6ace4492ba0b5a8f94a9e7b4f7126b31c6254637) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "853jaa11", 0, SHA1(9683ff8462491252b6eb2e5b3aa6496884c01506) )	/* ver 1.10 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1615,7 +1615,7 @@
 	ROM_LOAD16_BYTE( "825jaa09.25d", 0x100000, 0x80000, CRC(D3E65669) SHA1(51abf452da60794fa47c05d11c08b203dde563ff) )
 	ROM_LOAD16_BYTE( "825jaa10.27d", 0x100001, 0x80000, CRC(44D184F3) SHA1(28f3ec33a29164a6531f53db071272ccf015f66d) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "825jaa11", 0, SHA1(048919977232bbce046406a7212586cf39b77cf2) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1638,7 +1638,7 @@
 	ROM_LOAD16_BYTE( "858jaa09.25d", 0x100000, 0x80000, CRC(0B4AD843) SHA1(c01e15053dd1975dc68db9f4e6da47062d8f9b54) )
 	ROM_LOAD16_BYTE( "858jaa10.27d", 0x100001, 0x80000, CRC(00B124EE) SHA1(435d28a327c2707833a8ddfe841104df65ffa3f8) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "858jaa11", 0, SHA1(bc590472046336a1000f29901fe3fd7b29747e47) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1661,7 +1661,7 @@
 	ROM_LOAD16_BYTE( "858uaa09.25d", 0x100000, 0x80000, CRC(99519886) SHA1(664f6bd953201a6e2fc123cb8b3facf72766107d) )
 	ROM_LOAD16_BYTE( "858uaa10.27d", 0x100001, 0x80000, CRC(20AA7145) SHA1(eeff87eb9a9864985d751f45e843ee6e73db8cfd) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "858jaa11", 0, SHA1(bc590472046336a1000f29901fe3fd7b29747e47) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1684,7 +1684,7 @@
 	ROM_LOAD16_BYTE( "847jab09.25d", 0x100000, 0x80000, CRC(2E4AC9FE) SHA1(bbd4c6e0c82fc0be88f851e901e5853b6bcf775f) )
 	ROM_LOAD16_BYTE( "847jab10.27d", 0x100001, 0x80000, CRC(C78516F5) SHA1(1adf5805c808dc55de14a9a9b20c3d2cf7bf414d) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "847jaa11", 0, SHA1(8cad631531b5616d6a4b0a99d988f4b525932dc7) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1707,7 +1707,7 @@
 	ROM_LOAD16_BYTE( "981jaa09.25d", 0x100000, 0x80000, CRC(D96D4E1C) SHA1(379aa4e82cd06490645f54dab1724c827108735d) )
 	ROM_LOAD16_BYTE( "981jaa10.27d", 0x100001, 0x80000, CRC(06BEE0E4) SHA1(6eea8614cb01e7079393b9976b6fd6a52c14e3c0) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "981jaa11", 0, SHA1(dc7353fa436d96ae174a58d3a38ca9928a63727f) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1730,7 +1730,7 @@
 	ROM_LOAD16_BYTE( "993jaa09.25d", 0x100000, 0x80000, CRC(E1A172DD) SHA1(42e850c055dc5bfccf6b6989f9f3a945fce13006) )
 	ROM_LOAD16_BYTE( "993jaa10.27d", 0x100001, 0x80000, CRC(9D113A2D) SHA1(eee94a5f7015c49aa630b8df0c8e9d137d238811) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "993hdda01", 0, SHA1(f5d4df1dd27ce6ee2d0897852342691d55b63bfb) )
 	// this image has not been verified
 	//  DISK_IMAGE( "993jaa11", 0, MD5(e26eb62d7cf3357585f5066da6063143) )  /* ver 1.00 JA */
@@ -1755,7 +1755,7 @@
 	ROM_LOAD16_BYTE( "988jaa09.25d", 0x100000, 0x80000, CRC(8F3BAE7F) SHA1(c4dac14f6c7f75a2b19153e05bfe969e9eb4aca0) )
 	ROM_LOAD16_BYTE( "988jaa10.27d", 0x100001, 0x80000, CRC(248BF0EE) SHA1(d89205ed57e771401bfc2c24043d200ecbd0b7fc) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "988jaa11", 0, SHA1(12a0988c631dd3331e54b8417a9659402afe168b) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1778,7 +1778,7 @@
 	ROM_LOAD16_BYTE( "988uaa09.25d", 0x100000, 0x80000, CRC(C2AD6810) SHA1(706388c5acf6718297fd90e10f8a673463a0893b) )
 	ROM_LOAD16_BYTE( "988uaa10.27d", 0x100001, 0x80000, CRC(DAB0F3C9) SHA1(6fd899e753e32f60262c54ab8553c686c7ef28de) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "988jaa11", 0, SHA1(12a0988c631dd3331e54b8417a9659402afe168b) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1801,7 +1801,7 @@
 	ROM_LOAD16_BYTE( "995jaa09.25d", 0x100000, 0x80000, CRC(1510A9C2) SHA1(daf1ab26b7b6b0fe0123b3fbee68684157c2ce51) )
 	ROM_LOAD16_BYTE( "995jaa10.27d", 0x100001, 0x80000, CRC(F9E4E9F2) SHA1(fe91badf6b0baeea690d75399d8c66fabcf6d352) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "995jaa11", 0, SHA1(8fec3c4d97f64f48b9867230a97cda4347496075) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1824,7 +1824,7 @@
 	ROM_LOAD16_BYTE( "a05jaa09.25d", 0x100000, 0x80000, CRC(1504D62C) SHA1(3c31c6625bc089235a96fe21021239f2d0c0f6e1) )
 	ROM_LOAD16_BYTE( "a05jaa10.27d", 0x100001, 0x80000, CRC(99D75C36) SHA1(9599420863aa0a9492d3caeb03f8ac5fd4c3cdb2) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "a05jaa11", 0, SHA1(7ebc41cc3e9a0a922b49201b34e29201522eb726) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1847,7 +1847,7 @@
 	ROM_LOAD16_BYTE( "a21jaa09.25d", 0x100000, 0x80000, CRC(181E6F70) SHA1(82c7ca3068ace9a66b614ead4b90ea6fe4017d51) )
 	ROM_LOAD16_BYTE( "a21jaa10.27d", 0x100001, 0x80000, CRC(1AC33595) SHA1(3173bb8dc420487c4d427e779444a98aad37d51e) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "a21jaa11", 0, SHA1(ed0a07212a360e75934fc22c56265842cf0829b6) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1870,7 +1870,7 @@
 	ROM_LOAD16_BYTE( "b07jaa09.25d", 0x100000, 0x80000, CRC(2530CEDB) SHA1(94b38b4fe198b26a2ff4d99d2cb28a0f935fe940) )
 	ROM_LOAD16_BYTE( "b07jaa10.27d", 0x100001, 0x80000, CRC(6B75BA9C) SHA1(aee922adc3bc0296ae6e08e461b20a9e5e72a2df) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "b07jaa11", 0, SHA1(e4925494f0a801abb4d3aa6524c379eb445d8dff) )	/* ver 1.00 JA */
 	// this image has not been verified
 	//DISK_IMAGE( "b07jab11", 0, MD5(0e9440787ca69567792095085e2a3619) )    /* ver 1.00 JA */
@@ -1895,7 +1895,7 @@
 	ROM_LOAD16_BYTE( "c01jaa09.25d", 0x100000, 0x80000, CRC(45CF93B1) SHA1(7c5082bcd1fe15761a0a965e25dda121904ff1bd) )
 	ROM_LOAD16_BYTE( "c01jaa10.27d", 0x100001, 0x80000, CRC(C9927749) SHA1(c2644877bda483e241381265e723ea8ab8357761) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "c01jaa11", 0, SHA1(0a53c4412a72a886f5fb98c12c529d056d625244) )	/* ver 1.00 JA */
 	// this image has not been verified
 	//DISK_IMAGE( "c01jaa11", 0, MD5(8bb7e6b6bc63cac8a4f2997307c25748) )    /* ver 1.00 JA */
@@ -1920,7 +1920,7 @@
 	ROM_LOAD16_BYTE( "831jaa09.25d", 0x100000, 0x80000, CRC(AE7838D2) SHA1(4f8a6793065c6c1eb08161f65b1d6246987bf47e) )
 	ROM_LOAD16_BYTE( "831jaa10.27d", 0x100001, 0x80000, CRC(85173CB6) SHA1(bc4d86bf4654a9a0a58e624f77090854950f3993) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "831jhdda01", 0, SHA1(ef62d5fcc1a36235fc932e6ecef71dc845d1d72d) )
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1945,7 +1945,7 @@
 	ROM_LOAD16_BYTE( "825jab09.25d", 0x100000, 0x80000, CRC(1407BA5D) SHA1(e7a0d190326589f4d94e83cb7c85dd4e91f4efad) )
 	ROM_LOAD16_BYTE( "825jab10.27d", 0x100001, 0x80000, CRC(2AFD0A10) SHA1(1b8b868ac5720bb1b376f4eb8952efb190257bda) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "825jab11", 0, MD5(f4360da10a932ba90e93469df7426d1d) SHA1(1) )  /* ver 1.01 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1968,7 +1968,7 @@
 	ROM_LOAD16_BYTE( "803jaa09.25d", 0x100000, 0x80000, CRC(204D53EB) SHA1(349de147246b0ed08fb7e473d63e073b71fa30c9) )
 	ROM_LOAD16_BYTE( "803jaa10.27d", 0x100001, 0x80000, CRC(535A61A3) SHA1(b24c57601a7e3a349473af69114703133a46806d) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "803jaa11", 0, MD5(54a8ac87857d81740621c622e27736d7) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -1991,7 +1991,7 @@
 	ROM_LOAD16_BYTE( "980jaa09.25d", 0x100000, 0x80000, CRC(1CB4D84E) SHA1(9669585c6a2825aeae6e47dd03458624b4c44721) )
 	ROM_LOAD16_BYTE( "980jaa10.27d", 0x100001, 0x80000, CRC(7776B87E) SHA1(662b7cd7cb4fb8f8bab240ef543bf9a593e23a03) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "980jaa11", 0, MD5(6e5cc17a6bc75cac0256192cc700215c) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
@@ -2014,7 +2014,7 @@
 	ROM_LOAD16_BYTE( "970jba09.25d", 0x100000, 0x80000, CRC(5D2BDA52) SHA1(d03c135ac04437b54e4d267ae168fe7ebb9e5b65) )
 	ROM_LOAD16_BYTE( "970jba10.27d", 0x100001, 0x80000, CRC(EDC4A245) SHA1(30bbd7bf0299a064119c535abb9be69d725aa130) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "970jba11", 0, MD5(1616905838fdb2b521d53499c6c2a7a4) )	/* ver 1.00 JA */
 
 	ROM_REGION( 0x1000000, "shared", ROMREGION_ERASE00 )		/* K054539 RAM */
diff -Nru src-old/mame/drivers/dynax.c src/mame/drivers/dynax.c
--- src-old/mame/drivers/dynax.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/dynax.c	2012-02-19 01:27:36.000000000 +0100
@@ -6684,7 +6684,7 @@
 	ROM_LOAD( "mc0.u11",          0x00000, 0x40000, CRC(8488a3ab) SHA1(f367a2dcc65410929db595b3c442d310d50a4940) )
 	ROM_RELOAD(                   0x10000, 0x40000 )
 	// tenkai internal rom is incompatible with the code of this set
-	ROM_LOAD( "tmp91p640n-10.5b", 0x00000, 0x04000, NO_DUMP )
+	ROM_LOAD( "tenkai2b_tmp91p640n-10.5b", 0x00000, 0x04000, NO_DUMP )
 
 	ROM_REGION( 0x100000, "gfx1", 0 )	// blitter data
 	ROM_LOAD( "mc1.u8",  0x000000, 0x100000, CRC(786698e3) SHA1(9ddf4e31f454fb3c7969b1433771e95a976de741) )
@@ -6899,7 +6899,7 @@
 	ROM_RELOAD(                   0x10000, 0x40000 )
 	ROM_RELOAD(                   0x50000, 0x40000 )
 	// tenkai internal rom is incompatible with the code of this set
-	ROM_LOAD( "tmp91p640n-10.5b", 0x00000, 0x04000, NO_DUMP )
+	ROM_LOAD( "tenkaid_tmp91p640n-10.5b", 0x00000, 0x04000, NO_DUMP )
 
 	ROM_REGION( 0x100000, "gfx1", 0 )	// blitter data
 	ROM_LOAD( "tydg002.u8",  0x00000, 0x80000, CRC(b0f08a20) SHA1(5f7083d5caadd77594eaf46efa11a8756cefcf7d) )
@@ -6929,7 +6929,7 @@
 	ROM_REGION( 0x50000, "maincpu", 0 )
 	ROM_LOAD( "epr-a01.rom",      0x00000, 0x40000, CRC(a35e54db) SHA1(247c856e19989fb834e8ed135393927bbd9c0277) )
 	ROM_RELOAD(                   0x10000, 0x40000 )
-	ROM_LOAD( "tmp91p640n-10.5b", 0x00000, 0x04000, BAD_DUMP CRC(509f1c97) SHA1(08557bea2e924053fd5bc9de5e306f3ecf8e98e6) ) // not dumped, rom taken from tenkai
+	ROM_LOAD( "tmp91p640n-10_bad.5b", 0x00000, 0x04000, BAD_DUMP CRC(509f1c97) SHA1(08557bea2e924053fd5bc9de5e306f3ecf8e98e6) ) // not dumped, rom taken from tenkai
 
 	ROM_REGION( 0x100000, "gfx1", 0 )	// blitter data
 	ROM_LOAD( "lzc-01.rom", 0x000000, 0x100000, CRC(786698e3) SHA1(9ddf4e31f454fb3c7969b1433771e95a976de741) )
diff -Nru src-old/mame/drivers/equites.c src/mame/drivers/equites.c
--- src-old/mame/drivers/equites.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/equites.c	2012-02-19 02:53:16.000000000 +0100
@@ -436,7 +436,7 @@
 
 		case 1: // c0f9: RST75 trigger (written by NMI handler)
 			// Note: solder pad CP3 on the pcb would allow to disable this
-			generic_pulse_irq_line(state->m_audio_cpu, I8085_RST75_LINE);
+			generic_pulse_irq_line(state->m_audio_cpu, I8085_RST75_LINE, 1);
 			break;
 
 		case 2: // c0fa: INTR trigger (written by NMI handler)
@@ -476,16 +476,17 @@
 static WRITE8_DEVICE_HANDLER( equites_8910porta_w )
 {
 	equites_state *state = device->machine().driver_data<equites_state>();
+	samples_device *samples = downcast<samples_device *>(device);
 
 	// bongo 1
-	sample_set_volume(device, 0, ((data & 0x30) >> 4) * 0.33);
+	samples->set_volume(0, ((data & 0x30) >> 4) * 0.33);
 	if (data & ~state->m_ay_port_a & 0x80)
-		sample_start(device, 0, 0, 0);
+		samples->start(0, 0);
 
 	// bongo 2
-	sample_set_volume(device, 1, (data & 0x03) * 0.33);
+	samples->set_volume(1, (data & 0x03) * 0.33);
 	if (data & ~state->m_ay_port_a & 0x08)
-		sample_start(device, 1, 1, 0);
+		samples->start(1, 1);
 
 	state->m_ay_port_a = data;
 
@@ -497,15 +498,16 @@
 static WRITE8_DEVICE_HANDLER( equites_8910portb_w )
 {
 	equites_state *state = device->machine().driver_data<equites_state>();
+	samples_device *samples = downcast<samples_device *>(device);
 #if POPDRUMKIT
 if (data & ~state->m_ay_port_b & 0x08) state->m_cymbal++;
 if (data & ~state->m_ay_port_b & 0x04) state->m_hihat++;
 #endif
 
 	// bongo 3
-	sample_set_volume(device, 2, ((data & 0x30)>>4) * 0.33);
+	samples->set_volume(2, ((data & 0x30)>>4) * 0.33);
 	if (data & ~state->m_ay_port_b & 0x80)
-		sample_start(device, 2, 2, 0);
+		samples->start(2, 2);
 
 	// FIXME I'm just enabling the MSM5232 Noise Output for now. Proper emulation
 	// of the analog circuitry should be done instead.
@@ -1141,7 +1143,7 @@
 
 static const char *const alphamc07_sample_names[] =
 {
-	"*alphamc07",
+	"*equites",
 	"bongo1",
 	"bongo2",
 	"bongo3",
@@ -1193,8 +1195,7 @@
 	MCFG_SOUND_ADD("dac2", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(alphamc07_samples_interface)
+	MCFG_SAMPLES_ADD("samples", alphamc07_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/esh.c src/mame/drivers/esh.c
--- src-old/mame/drivers/esh.c	2012-01-13 23:06:59.000000000 +0100
+++ src/mame/drivers/esh.c	2012-02-19 01:27:36.000000000 +0100
@@ -346,7 +346,7 @@
 	/* Main program CPU */
 	ROM_REGION( 0x4000, "maincpu", 0 )
 	ROM_LOAD( "is1.h8", 0x0000, 0x2000, CRC(114c912b) SHA1(7c033a102d046199f3e2c6787579dac5b5295d50) )
-	ROM_LOAD( "is2.f8", 0x2000, 0x2000, CRC(7a562f49) SHA1(acfa49b3b3d96b001a5dbdee39cbb0ca80be1763) )
+	ROM_LOAD( "esha_is2.f8", 0x2000, 0x2000, CRC(7a562f49) SHA1(acfa49b3b3d96b001a5dbdee39cbb0ca80be1763) )
 
 	/* Tiles */
 	ROM_REGION( 0x3000, "gfx1", 0 )
diff -Nru src-old/mame/drivers/firetrap.c src/mame/drivers/firetrap.c
--- src-old/mame/drivers/firetrap.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/firetrap.c	2012-02-19 04:59:57.000000000 +0100
@@ -916,7 +916,7 @@
 
 	ROM_REGION( 0x20000, "gfx4", 0 )	/* sprites */
 	ROM_LOAD( "fi-17.17h",    0x00000, 0x8000, CRC(0de055d7) SHA1(ef763237c317545520c659f438b572b11c342d5a) )
-	ROM_LOAD( "fi-14.13h",    0x08000, 0x8000, CRC(869219da) SHA1(9ab2439d6d1c62fce24c4f78ac7887f34c86cd75) )
+	ROM_LOAD( "fi-14(__bootleg).13h",  0x08000, 0x8000, CRC(869219da) SHA1(9ab2439d6d1c62fce24c4f78ac7887f34c86cd75) )
 	ROM_LOAD( "fi-15.14h",    0x10000, 0x8000, CRC(6b65812e) SHA1(209e07b2fced6b033c6d5398a998374588a35f46) )
 	ROM_LOAD( "fi-16.15h",    0x18000, 0x8000, CRC(3e27f77d) SHA1(9ceccb1f56a8d0e05f6dea45d102690a1370624e) )
 
diff -Nru src-old/mame/drivers/firetrk.c src/mame/drivers/firetrk.c
--- src-old/mame/drivers/firetrk.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/firetrk.c	2012-02-11 11:01:01.000000000 +0100
@@ -62,7 +62,7 @@
 {
 	int scanline = param;
 
-	generic_pulse_irq_line(machine.device("maincpu"), 0);
+	generic_pulse_irq_line(machine.device("maincpu"), 0, 1);
 
 	/* IRQs are generated by inverse 16V signal */
 	scanline += 32;
diff -Nru src-old/mame/drivers/flyball.c src/mame/drivers/flyball.c
--- src-old/mame/drivers/flyball.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/flyball.c	2012-02-11 11:01:01.000000000 +0100
@@ -119,7 +119,7 @@
 	int potsense = param;
 
 	if (potsense & ~state->m_potmask)
-		generic_pulse_irq_line(state->m_maincpu, 0);
+		generic_pulse_irq_line(state->m_maincpu, 0, 1);
 
 	state->m_potsense |= potsense;
 }
diff -Nru src-old/mame/drivers/funkball.c src/mame/drivers/funkball.c
--- src-old/mame/drivers/funkball.c	2012-01-27 00:58:19.000000000 +0100
+++ src/mame/drivers/funkball.c	2012-02-09 11:27:12.000000000 +0100
@@ -1165,7 +1165,7 @@
 	MCFG_PCI_BUS_DEVICE(7, "voodoo_0", voodoo_0_pci_r, voodoo_0_pci_w)
 	MCFG_PCI_BUS_DEVICE(18, NULL, cx5510_pci_r, cx5510_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_3DFX_VOODOO_1_ADD("voodoo_0", STD_VOODOO_1_CLOCK, 2, "screen")
diff -Nru src-old/mame/drivers/funworld.c src/mame/drivers/funworld.c
--- src-old/mame/drivers/funworld.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/funworld.c	2012-02-18 03:48:45.000000000 +0100
@@ -3461,8 +3461,8 @@
 	ROM_LOAD( "r2.bin", 0x8000, 0x8000, CRC(25dfe0dc) SHA1(1a857a910d0c34b6b5bfc2b6ea2e08ed8ed0cae0) )
 
 	ROM_REGION( 0x10000, "gfx1", 0 )
-	ROM_LOAD( "2.bin", 0x0000, 0x8000, CRC(85e77661) SHA1(7d7a765c1bfcfeb9eb91d2519b22d734f20eab24) )
-	ROM_LOAD( "1.bin", 0x8000, 0x8000, CRC(41f7a0b3) SHA1(9aff2b8832d2a4f868daa9849a0bfe5e44f88fc0) )
+	ROM_LOAD( "rcd_2.bin", 0x0000, 0x8000, CRC(85e77661) SHA1(7d7a765c1bfcfeb9eb91d2519b22d734f20eab24) )
+	ROM_LOAD( "rcd_1.bin", 0x8000, 0x8000, CRC(41f7a0b3) SHA1(9aff2b8832d2a4f868daa9849a0bfe5e44f88fc0) )
 
 	ROM_REGION( 0x0800,	"nvram", 0 )	/* default NVRAM */
 	ROM_LOAD( "royalcrdd_nvram.bin", 0x0000, 0x0800, CRC(335bfa5a) SHA1(7e9cbb502f450c515ea03ffcf4b7fbae60af4e73) )
diff -Nru src-old/mame/drivers/gaelco3d.c src/mame/drivers/gaelco3d.c
--- src-old/mame/drivers/gaelco3d.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/gaelco3d.c	2012-02-11 11:01:01.000000000 +0100
@@ -657,7 +657,7 @@
 		reg = state->m_adsp_ireg_base;
 
 		/* generate the (internal, thats why the pulse) irq */
-		generic_pulse_irq_line(adsp, ADSP2105_IRQ1);
+		generic_pulse_irq_line(adsp, ADSP2105_IRQ1, 1);
 	}
 
 	/* store it */
diff -Nru src-old/mame/drivers/galaga.c src/mame/drivers/galaga.c
--- src-old/mame/drivers/galaga.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/galaga.c	2012-02-19 02:53:16.000000000 +0100
@@ -1854,8 +1854,7 @@
 	/* sound hardware */
 	MCFG_DEVICE_REMOVE("discrete")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(battles_samples_interface)
+	MCFG_SAMPLES_ADD("samples", battles_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/galaxian.c src/mame/drivers/galaxian.c
--- src-old/mame/drivers/galaxian.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/galaxian.c	2012-02-19 02:53:16.000000000 +0100
@@ -2206,8 +2206,7 @@
 	MCFG_SOUND_CONFIG(cclimber_ay8910_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(cclimber_samples_interface)
+	MCFG_SAMPLES_ADD("samples", cclimber_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/galaxold.c src/mame/drivers/galaxold.c
--- src-old/mame/drivers/galaxold.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/galaxold.c	2012-02-19 01:27:36.000000000 +0100
@@ -2560,19 +2560,19 @@
 	ROM_CONTINUE(              0x0000, 0x0400)
 	ROM_CONTINUE(              0x1800, 0x0400)
 	ROM_CONTINUE(              0x2800, 0x0400)
-	ROM_LOAD( "ck3.bin",       0x3400, 0x0400, CRC(65157cde) SHA1(572b9bd56894600e21220356d0bf193c7920672c) )
+	ROM_LOAD( "g_ck3.bin",     0x3400, 0x0400, CRC(65157cde) SHA1(572b9bd56894600e21220356d0bf193c7920672c) )
 	ROM_CONTINUE(              0x4c00, 0x0400)
 	ROM_CONTINUE(              0x5000, 0x0400)
 	ROM_CONTINUE(              0x0400, 0x0400)
-	ROM_LOAD( "ck4.bin",       0x2000, 0x0400, CRC(43827bc6) SHA1(a2ca9afff0dd1bdcfc3a6ead9ff30b7c91caa7ea) )
+	ROM_LOAD( "g_ck4.bin",     0x2000, 0x0400, CRC(43827bc6) SHA1(a2ca9afff0dd1bdcfc3a6ead9ff30b7c91caa7ea) )
 	ROM_CONTINUE(              0x3800, 0x0400)
 	ROM_CONTINUE(              0x1000, 0x0400)
 	ROM_CONTINUE(              0x4000, 0x0400)
-	ROM_LOAD( "ck5.bin",       0x0800, 0x0400, CRC(a74ed96e) SHA1(1e845d693a728fea9d52953b5493ec98fdec63e3) )
+	ROM_LOAD( "g_ck5.bin",     0x0800, 0x0400, CRC(a74ed96e) SHA1(1e845d693a728fea9d52953b5493ec98fdec63e3) )
 	ROM_CONTINUE(              0x5400, 0x0400)  // fill
 	ROM_CONTINUE(              0x2c00, 0x0400)
 	ROM_CONTINUE(              0x1400, 0x0400)
-	ROM_LOAD( "ck7.bin",       0x3000, 0x0400, CRC(2c4d8129) SHA1(ab1708ff72ee027106fe8da0caea03a796b3212b) )
+	ROM_LOAD( "g_ck7.bin",     0x3000, 0x0400, CRC(2c4d8129) SHA1(ab1708ff72ee027106fe8da0caea03a796b3212b) )
 	ROM_CONTINUE(              0x3c00, 0x0400)
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
diff -Nru src-old/mame/drivers/galdrvr.c src/mame/drivers/galdrvr.c
--- src-old/mame/drivers/galdrvr.c	2011-12-06 14:29:48.000000000 +0100
+++ src/mame/drivers/galdrvr.c	2012-02-19 01:27:36.000000000 +0100
@@ -4791,7 +4791,7 @@
 
 	ROM_REGION( 0x2000, "samples", 0 )	/* samples */
 	ROM_LOAD( "my07",         0x0000, 0x1000, CRC(522a2920) SHA1(a64d821a8ff6bd6e2b0bdb1e632181e65a97363b) )
-	ROM_LOAD( "my06",         0x1000, 0x1000, CRC(466415f2) SHA1(a05f8238cdcebe926a564ef6268b3cd677987fa2) )
+	ROM_LOAD( "my06e",        0x1000, 0x1000, CRC(466415f2) SHA1(a05f8238cdcebe926a564ef6268b3cd677987fa2) )
 ROM_END
 
 ROM_START( mshuttle2 )
@@ -4799,12 +4799,12 @@
 	ROM_LOAD( "my05",         0x0000, 0x1000, CRC(83574af1) SHA1(d69c2a0538a49d6c72c3346ac4e3959d91da6c98) )
 	ROM_LOAD( "my04",         0x1000, 0x1000, CRC(1cfae2c8) SHA1(6c7eeee70e91b8498c41525dcc60f8086cff8da7) )
 	ROM_LOAD( "my03",         0x2000, 0x1000, CRC(c8b8a368) SHA1(140ba60f55285d1e9f7a262634f5ce5c3470ab71) )
-	ROM_LOAD( "my02",         0x3000, 0x1000, CRC(9804061c) SHA1(d5147e827c5a851f6baadea4a0a3b1deb19dda16) )
-	ROM_LOAD( "my01",         0x4000, 0x1000, CRC(ca746a61) SHA1(259b1556b0646bf0108b1e3ffbd77bf7238350b0) )
+	ROM_LOAD( "my02-2",         0x3000, 0x1000, CRC(9804061c) SHA1(d5147e827c5a851f6baadea4a0a3b1deb19dda16) )
+	ROM_LOAD( "my01-2",         0x4000, 0x1000, CRC(ca746a61) SHA1(259b1556b0646bf0108b1e3ffbd77bf7238350b0) )
 
 	ROM_REGION( 0x4000, "gfx1", 0 )
 	ROM_LOAD( "my09",         0x0000, 0x1000, CRC(3601b380) SHA1(c0b9d1801f58a16449708d514d2fd88e34af340b) )
-	ROM_LOAD( "my11",         0x1000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
+	ROM_LOAD( "my11-2",         0x1000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
 	ROM_LOAD( "my08",         0x2000, 0x1000, CRC(992b06cd) SHA1(8645ccad8169601bbe25b9f2b17b99004c0a584f) )
 	ROM_LOAD( "my10",         0x3000, 0x0800, CRC(d860e6ce) SHA1(2912d13bf69496f8f18358a36366a1f60afd0070) )
 
diff -Nru src-old/mame/drivers/galivan.c src/mame/drivers/galivan.c
--- src-old/mame/drivers/galivan.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/galivan.c	2012-02-18 03:48:45.000000000 +0100
@@ -986,12 +986,13 @@
 PR.7E        [6d66da81] NOT FOUND!
 PR.7H        [262d0809] = YNCP-7F.BIN  from Youma Ninpou Chou (Nichibutsu, Ninja Emaki jpn)
 PR.8E        [ffb4b287] = YNCP-8E.BIN  from Youma Ninpou Chou (Nichibutsu, Ninja Emaki jpn)
+
 */
 
 ROM_START( youmab2 )
 	ROM_REGION( 0x18000, "maincpu", 0 )	/* main cpu code */
-	ROM_LOAD( "1.1d",	  0x00000, 0x8000, CRC(692ae497) SHA1(572e5a1eae9b0bb48f65dce5de2df5c5ae95a3bd) )
-	ROM_LOAD( "3.4d",     0x10000, 0x8000, CRC(ebf61afc) SHA1(30235a90e8316f5033d44d31f02cca97c64f2d5e) )
+	ROM_LOAD( "b2_1.1d",	  0x00000, 0x8000, CRC(692ae497) SHA1(572e5a1eae9b0bb48f65dce5de2df5c5ae95a3bd) )
+	ROM_LOAD( "b2_3.4d",     0x10000, 0x8000, CRC(ebf61afc) SHA1(30235a90e8316f5033d44d31f02cca97c64f2d5e) )
 
 	ROM_REGION( 0x10000, "user2", 0 )	/* main cpu code */
 	/* This rom is double the size of the original one, appears to have extra (banked) code for 0x8000 */
@@ -1002,7 +1003,7 @@
 	ROM_LOAD( "12.15b",  0x4000, 0x8000, CRC(ac3a0b81) SHA1(39f2c305706e313d5256c357a3c8b57bbe45d3d7) )
 
 	ROM_REGION( 0x08000, "gfx1", 0 )
-	ROM_LOAD( "4.7d",    0x00000, 0x8000, CRC(a1954f44) SHA1(b10a22b51bd1a02c0d7b116b4d7390003c41decf) )	/* chars */
+	ROM_LOAD( "b2_4.7d",    0x00000, 0x8000, CRC(a1954f44) SHA1(b10a22b51bd1a02c0d7b116b4d7390003c41decf) )	/* chars */
 
 	ROM_REGION( 0x20000, "gfx2", 0 )
 	ROM_LOAD( "7.13f",   0x00000, 0x8000, CRC(655f0a58) SHA1(8ffe73cec68d52c7b09651b546289613d6d4dde4) ) /* tiles */
diff -Nru src-old/mame/drivers/gamecstl.c src/mame/drivers/gamecstl.c
--- src-old/mame/drivers/gamecstl.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/gamecstl.c	2012-02-09 11:27:12.000000000 +0100
@@ -711,7 +711,7 @@
 
 	MCFG_PIC8259_ADD( "pic8259_2", gamecstl_pic8259_2_config )
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
@@ -786,7 +786,7 @@
 	ROM_REGION(0x08100, "gfx1", 0)
 	ROM_LOAD("cga.chr",     0x00000, 0x01000, BAD_DUMP CRC(42009069) SHA1(ed08559ce2d7f97f68b9f540bddad5b6295294dd))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "gamecstl", 0, SHA1(b431af3c42c48ba07972d77a3d24e60ee1e4359e) )
 ROM_END
 
@@ -797,7 +797,7 @@
 	ROM_REGION(0x08100, "gfx1", 0)
 	ROM_LOAD("cga.chr",     0x00000, 0x01000, BAD_DUMP CRC(42009069) SHA1(ed08559ce2d7f97f68b9f540bddad5b6295294dd))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "gamecst2", 0, SHA1(14e1b311cb474801c7bdda3164a0c220fb102159) )
 ROM_END
 
diff -Nru src-old/mame/drivers/gaplus.c src/mame/drivers/gaplus.c
--- src-old/mame/drivers/gaplus.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/gaplus.c	2012-02-19 02:53:16.000000000 +0100
@@ -606,8 +606,7 @@
 	MCFG_SOUND_CONFIG(namco_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gaplus_samples_interface)
+	MCFG_SAMPLES_ADD("samples", gaplus_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/goldnpkr.c src/mame/drivers/goldnpkr.c
--- src-old/mame/drivers/goldnpkr.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/goldnpkr.c	2012-02-19 01:27:36.000000000 +0100
@@ -3629,8 +3629,8 @@
 	ROM_LOAD( "wc3050.a5",	0x4000, 0x2000, CRC(6f35b9c4) SHA1(df86687164f18f2bfe71e73cccd28fe4117e748c) )    /* text layer, alt gfx */
 
 	ROM_REGION( 0x6000, "gfx2", 0 )
-	ROM_LOAD( "wc1.a2",	0x0000, 0x2000, CRC(10b34856) SHA1(52e4cc81b36b4c807b1d4471c0f7bea66108d3fd) )    /* cards deck gfx, bitplane1 */
-	ROM_LOAD( "wc2.a4",	0x2000, 0x2000, CRC(5fc965ef) SHA1(d9ecd7e9b4915750400e76ca604bec8152df1fe4) )    /* cards deck gfx, bitplane2 */
+	ROM_LOAD( "wch1.a2",	0x0000, 0x2000, CRC(10b34856) SHA1(52e4cc81b36b4c807b1d4471c0f7bea66108d3fd) )    /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "wch2.a4",	0x2000, 0x2000, CRC(5fc965ef) SHA1(d9ecd7e9b4915750400e76ca604bec8152df1fe4) )    /* cards deck gfx, bitplane2 */
 	ROM_COPY( "gfx1",	0x4800, 0x4000, 0x0800 )    /* cards deck gfx, bitplane3. found in the 2nd quarter of the text layer rom */
 
 	ROM_REGION( 0x0100, "proms", 0 )
@@ -3698,7 +3698,7 @@
 
 ROM_START( witchgme )
 	ROM_REGION( 0x10000, "maincpu", 0 )	/* Video Klein */
-	ROM_LOAD( "hn58c256p.box",	0x0000, 0x8000, CRC(26c334cb) SHA1(d8368835c88668f09560f6096148a6e528806f65) )
+	ROM_LOAD( "hn58c256p.box12t1",	0x0000, 0x8000, CRC(26c334cb) SHA1(d8368835c88668f09560f6096148a6e528806f65) )
 
 	ROM_REGION( 0x3000, "gfx2", 0 )
 	ROM_LOAD( "1.2a",	0x0000, 0x0800, CRC(f2f94661) SHA1(f37f7c0dff680fd02897dae64e13e297d0fdb3e7) )  /* cards deck gfx, bitplane1 */
@@ -3728,11 +3728,11 @@
 
 	ROM_REGION( 0x3000, "gfx1", 0 )
 	ROM_FILL(			 0x0000, 0x2000, 0 ) /* filling the R-G bitplanes */
-	ROM_LOAD( "wc4.7a",	 0x2000, 0x1000, BAD_DUMP CRC(3bf07c44) SHA1(f6e859b142b7d4585b89ca609d8bc85c84fe2b09) )    /* text chars, corrupt */
+	ROM_LOAD( "wc4.7a_bad",	 0x2000, 0x1000, BAD_DUMP CRC(3bf07c44) SHA1(f6e859b142b7d4585b89ca609d8bc85c84fe2b09) )    /* text chars, corrupt */
 	ROM_COPY( "gfx1",    0x2800, 0x2000, 0x0800 )	/* srctag, srcoffs, offset, length */
 
 	ROM_REGION( 0x3000, "gfx2", 0 )
-	ROM_LOAD( "wc1.2a",	0x0000, 0x1000, CRC(f59c6fd2) SHA1(bea4b6043728311ca9fff36e2d7e24254af5b97a) )    /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "wck1.2a",	0x0000, 0x1000, CRC(f59c6fd2) SHA1(bea4b6043728311ca9fff36e2d7e24254af5b97a) )    /* cards deck gfx, bitplane1 */
 	ROM_LOAD( "wc2.4a",	0x1000, 0x1000, CRC(40e426af) SHA1(7e7cb30dafc96bcb87a05d3e0ef5c2d426ed6a74) )    /* cards deck gfx, bitplane2 */
 	ROM_LOAD( "wc3.5a",	0x2000, 0x1000, CRC(232374f3) SHA1(b75907edbf769b8c46fb1ebdb301c325c556e6c2) )    /* cards deck gfx, bitplane3 */
 
@@ -4184,10 +4184,10 @@
 	ROM_LOAD( "fw4.7a",	0x1000, 0x0800, CRC(f0517b0d) SHA1(474bcf429f2539ff1f3d7d32d259c5973ccb0234) )  /* text layer */
 
 	ROM_REGION( 0x1800, "gfx2", 0 )
-	ROM_LOAD( "fw1.2a",	0x0000, 0x0800, BAD_DUMP CRC(229cedde) SHA1(5b6d0b900714924c7a2390151ee65f36bdb02e8b) )  /* cards deck gfx, bitplane1 */
+	ROM_LOAD( "fw1.2a_bad",	0x0000, 0x0800, BAD_DUMP CRC(229cedde) SHA1(5b6d0b900714924c7a2390151ee65f36bdb02e8b) )  /* cards deck gfx, bitplane1 */
 	ROM_IGNORE(                 0x0800)
-	ROM_LOAD( "fw2.4a",	0x0800, 0x0800, BAD_DUMP CRC(9ad3c578) SHA1(a69385a807e3270d90040c44721bfff21e95706a) )  /* cards deck gfx, bitplane2 */
-	ROM_LOAD( "fw3.5a",	0x1000, 0x0800, BAD_DUMP CRC(87abebe5) SHA1(5950082b563718476576dbc9f45439019209493e) )  /* cards deck gfx, bitplane3 */
+	ROM_LOAD( "fw2.4a_bad",	0x0800, 0x0800, BAD_DUMP CRC(9ad3c578) SHA1(a69385a807e3270d90040c44721bfff21e95706a) )  /* cards deck gfx, bitplane2 */
+	ROM_LOAD( "fw3.5a_bad",	0x1000, 0x0800, BAD_DUMP CRC(87abebe5) SHA1(5950082b563718476576dbc9f45439019209493e) )  /* cards deck gfx, bitplane3 */
 
 	ROM_REGION( 0x0100, "proms", 0 )
 	ROM_LOAD( "n82s137f.box",	0x0000, 0x0100, BAD_DUMP CRC(7f31066b) SHA1(15420780ec6b2870fc4539ec3afe4f0c58eedf12) )
@@ -4656,7 +4656,7 @@
 
 ROM_START( wldwitch )
 	ROM_REGION( 0x10000, "maincpu", 0 )	/* Video Klein */
-	ROM_LOAD( "hn58c256p.box",	0x8000, 0x8000, CRC(1de736a7) SHA1(e714a97999555fe0107390c8c9c2c3c1e822809a) )
+	ROM_LOAD( "hn58c256p.box163",	0x8000, 0x8000, CRC(1de736a7) SHA1(e714a97999555fe0107390c8c9c2c3c1e822809a) )
 
 	ROM_REGION( 0x18000, "temp", 0 )
 	ROM_LOAD( "03.a3",	0x00000, 0x8000, CRC(ae474414) SHA1(6dee760cee18e125791c17b562ca8aabe1f4593e) )
@@ -4905,7 +4905,6 @@
 GAMEL( 198?, potnpkrc, pottnpkr, pottnpkr, potnpkrc, 0,        ROT0,   "bootleg",                  "Jack Potten's Poker (set 4)",             0,                layout_goldnpkr )
 GAMEL( 198?, potnpkrd, pottnpkr, pottnpkr, potnpkrc, 0,        ROT0,   "bootleg",                  "Jack Potten's Poker (set 5)",             0,                layout_goldnpkr )
 GAMEL( 198?, potnpkre, pottnpkr, pottnpkr, pottnpkr, 0,        ROT0,   "bootleg",                  "Jack Potten's Poker (set 6)",             0,                layout_goldnpkr )
-GAMEL( 1991, goodluck, pottnpkr, witchcrd, goodluck, 0,        ROT0,   "<unknown>",                "Good Luck",                               0,                layout_goldnpkr )
 GAMEL( 198?, superdbl, pottnpkr, goldnpkr, goldnpkr, 0,        ROT0,   "Karateco",                 "Super Double (French)",                   0,                layout_goldnpkr )
 GAMEL( 198?, ngold,    pottnpkr, pottnpkr, ngold,    0,        ROT0,   "<unknown>",                "Jack Potten's Poker (NGold, set 1)",      0,                layout_goldnpkr )
 GAMEL( 198?, ngolda,   pottnpkr, pottnpkr, ngold,    0,        ROT0,   "<unknown>",                "Jack Potten's Poker (NGold, set 2)",      0,                layout_goldnpkr )
@@ -4948,6 +4947,7 @@
 GAMEL( 1991, bsuertes, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                "Buena Suerte (Spanish, set 20)",          0,                layout_goldnpkr )
 GAMEL( 1991, bsuertet, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                "Buena Suerte (Spanish, set 21)",          0,                layout_goldnpkr )
 GAMEL( 1991, bsuerteu, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                "Buena Suerte (Spanish, set 22)",          0,                layout_goldnpkr )
+GAMEL( 1991, goodluck, bsuerte,  witchcrd, goodluck, 0,        ROT0,   "<unknown>",                "Good Luck",                               0,                layout_goldnpkr )
 
 GAMEL( 1991, falcnwld,  0,        wildcard, wildcard, 0,       ROT0,   "TVG",                      "Falcons Wild - Wild Card 1991 (TVG)",     0,                layout_goldnpkr )
 GAMEL( 1990, falcnwlda, falcnwld, wildcard, wildcard, 0,       ROT0,   "Video Klein",              "Falcons Wild - World Wide Poker (Video Klein)",     GAME_UNEMULATED_PROTECTION, layout_goldnpkr )
diff -Nru src-old/mame/drivers/goldstar.c src/mame/drivers/goldstar.c
--- src-old/mame/drivers/goldstar.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/goldstar.c	2012-02-19 01:27:36.000000000 +0100
@@ -7979,18 +7979,18 @@
 ROM_START( lucky8a )
 	ROM_REGION( 0x8000, "maincpu", 0 )
 	// we have to patch this, it might be bad
-	ROM_LOAD( "1",  0x0000, 0x8000, BAD_DUMP CRC(554cddff) SHA1(8a0678993c7010f70adc9e9443b51cf5929bf110) )
+	ROM_LOAD( "1_bad", 0x0000, 0x8000, BAD_DUMP CRC(554cddff) SHA1(8a0678993c7010f70adc9e9443b51cf5929bf110) )
 
 	ROM_REGION( 0x18000, "gfx1", 0 )
-	ROM_LOAD( "6",  0x00000, 0x8000, CRC(59026af3) SHA1(3d7f7e78968ca26275635aeaa0e994468a3da575) )
-	ROM_LOAD( "7",  0x08000, 0x8000, CRC(67a073c1) SHA1(36194d57d0dc0601fa1fdf2e6806f11b2ea6da36) )
-	ROM_LOAD( "8",  0x10000, 0x8000, CRC(80b35f06) SHA1(561d257d7bc8976cfa08f36d84961f1263509b5b) )
+	ROM_LOAD( "6a",  0x00000, 0x8000, CRC(59026af3) SHA1(3d7f7e78968ca26275635aeaa0e994468a3da575) )
+	ROM_LOAD( "7a",  0x08000, 0x8000, CRC(67a073c1) SHA1(36194d57d0dc0601fa1fdf2e6806f11b2ea6da36) )
+	ROM_LOAD( "8a",  0x10000, 0x8000, CRC(80b35f06) SHA1(561d257d7bc8976cfa08f36d84961f1263509b5b) )
 
 	ROM_REGION( 0x8000, "gfx2", 0 )
-	ROM_LOAD( "2",   0x0000, 0x2000, CRC(29d6f197) SHA1(1542ca457594f6b7fe8f28f7d78023edd7021bc8) )
-	ROM_LOAD( "3",   0x2000, 0x2000, CRC(5f812e65) SHA1(70d9ea82f9337936bf21f82b6961768d436f3a6f) )
-	ROM_LOAD( "4",   0x4000, 0x2000, CRC(898b9ed5) SHA1(11b7d1cfcf425d00d086c74e0dbcb72068dda9fe) )
-	ROM_LOAD( "5",   0x6000, 0x2000, CRC(4f7cfb35) SHA1(0617cf4419be00d9bacc78724089cb8af4104d68) )
+	ROM_LOAD( "2a",  0x0000, 0x2000, CRC(29d6f197) SHA1(1542ca457594f6b7fe8f28f7d78023edd7021bc8) )
+	ROM_LOAD( "3a",  0x2000, 0x2000, CRC(5f812e65) SHA1(70d9ea82f9337936bf21f82b6961768d436f3a6f) )
+	ROM_LOAD( "4a",  0x4000, 0x2000, CRC(898b9ed5) SHA1(11b7d1cfcf425d00d086c74e0dbcb72068dda9fe) )
+	ROM_LOAD( "5a",  0x6000, 0x2000, CRC(4f7cfb35) SHA1(0617cf4419be00d9bacc78724089cb8af4104d68) )
 
 	ROM_REGION( 0x200, "proms", 0 )
 	ROM_LOAD( "prom3", 0x0000, 0x0100, CRC(23e81049) SHA1(78071dae70fad870e972d944642fb3a2374be5e4) )
diff -Nru src-old/mame/drivers/gottlieb.c src/mame/drivers/gottlieb.c
--- src-old/mame/drivers/gottlieb.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/gottlieb.c	2012-02-19 02:53:16.000000000 +0100
@@ -1907,8 +1907,7 @@
 	MCFG_DEVICE_REMOVE("nvram")
 
 	/* sound hardware */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(reactor_samples_interface)
+	MCFG_SAMPLES_ADD("samples", reactor_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
@@ -1916,8 +1915,7 @@
 static MACHINE_CONFIG_DERIVED( qbert, gottlieb1 )
 
 	/* video hardware */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(qbert_samples_interface)
+	MCFG_SAMPLES_ADD("samples", qbert_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/gotya.c src/mame/drivers/gotya.c
--- src-old/mame/drivers/gotya.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/gotya.c	2012-02-19 02:53:16.000000000 +0100
@@ -178,7 +178,7 @@
 {
 	gotya_state *state = machine.driver_data<gotya_state>();
 
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->save_item(NAME(state->m_scroll_bit_8));
 	state->save_item(NAME(state->m_theme_playing));
@@ -219,8 +219,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gotya_samples_interface)
+	MCFG_SAMPLES_ADD("samples", gotya_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/gridlee.c src/mame/drivers/gridlee.c
--- src-old/mame/drivers/gridlee.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/gridlee.c	2012-02-19 02:53:16.000000000 +0100
@@ -451,8 +451,7 @@
 	MCFG_SOUND_ADD("gridlee", GRIDLEE, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(gridlee_samples_interface)
+	MCFG_SAMPLES_ADD("samples", gridlee_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.40)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/harddriv.c src/mame/drivers/harddriv.c
--- src-old/mame/drivers/harddriv.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/harddriv.c	2012-02-13 19:48:41.000000000 +0100
@@ -968,10 +968,10 @@
 	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)	/* up/down */
 
 	PORT_START("12BADC2")		/* b80000 - 12 bit ADC 2 */
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Y ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)  PORT_NAME("Collective") PORT_REVERSE	/* collective */
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_Z ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)  PORT_NAME("Collective") PORT_REVERSE	/* collective */
 
 	PORT_START("12BADC3")		/* b80000 - 12 bit ADC 3 */
-	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)  PORT_NAME("Rudder")	/* rudder */
+	PORT_BIT( 0xff, 0x80, IPT_AD_STICK_X ) PORT_SENSITIVITY(25) PORT_KEYDELTA(10)  PORT_NAME("Rudder") PORT_PLAYER(2)	/* rudder */
 
 	PORT_INCLUDE( atarijsa_iii )		/* audio board port */
 	/* steeltal has its own coins */
@@ -4180,20 +4180,9 @@
 	else
 		state->m_m68k_slapstic_base = state->m_maincpu->memory().space(AS_PROGRAM)->install_legacy_readwrite_handler(0xe0000, 0xfffff, FUNC(st68k_protosloop_r), FUNC(st68k_protosloop_w));
 
-	/* synchronization */
-	state->m_stmsp_sync[0] = &state->m_msp_ram[TOWORD(0x80010)];
-	state->m_msp->memory().space(AS_PROGRAM)->install_legacy_write_handler(0x80010, 0x8007f, FUNC(stmsp_sync0_w));
-	state->m_stmsp_sync[1] = &state->m_msp_ram[TOWORD(0x99680)];
-	state->m_msp->memory().space(AS_PROGRAM)->install_legacy_write_handler(0x99680, 0x9968f, FUNC(stmsp_sync1_w));
-	state->m_stmsp_sync[2] = &state->m_msp_ram[TOWORD(0x99d30)];
-	state->m_msp->memory().space(AS_PROGRAM)->install_legacy_write_handler(0x99d30, 0x99d4f, FUNC(stmsp_sync2_w));
-
 	/* set up protection hacks */
 	state->m_gsp_protection = state->m_gsp->memory().space(AS_PROGRAM)->install_legacy_write_handler(0xfff965d0, 0xfff965df, FUNC(hdgsp_protection_w));
 
-	/* set up msp speedup handlers */
-	state->m_msp->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x80020, 0x8002f, FUNC(stmsp_speedup_r));
-
 	/* set up adsp speedup handlers */
 	state->m_adsp->memory().space(AS_DATA)->install_legacy_read_handler(0x1fff, 0x1fff, FUNC(hdadsp_speedup_r));
 	state->m_adsp->memory().space(AS_DATA)->install_legacy_read_handler(0x1f99, 0x1f99, FUNC(hdds3_speedup_r));
diff -Nru src-old/mame/drivers/igs_m027.c src/mame/drivers/igs_m027.c
--- src-old/mame/drivers/igs_m027.c	2012-01-31 18:22:15.000000000 +0100
+++ src/mame/drivers/igs_m027.c	2012-02-11 11:01:01.000000000 +0100
@@ -383,7 +383,7 @@
 
 static INTERRUPT_GEN( igs_majhong_interrupt )
 {
-	generic_pulse_irq_line(device, ARM7_FIRQ_LINE);
+	generic_pulse_irq_line(device, ARM7_FIRQ_LINE, 1);
 }
 
 
diff -Nru src-old/mame/drivers/igspc.c src/mame/drivers/igspc.c
--- src-old/mame/drivers/igspc.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/igspc.c	2012-02-06 23:41:22.000000000 +0100
@@ -102,7 +102,7 @@
 	ROM_LOAD( "szz_v116cn.rom", 0x000000, 0x80000, CRC(8c443a89) SHA1(efdbaa832def812e0786cab95ebf60cdc226d3c4))
 
 	DISK_REGION( "disks" )
-	DISK_IMAGE( "szz_cf", 0, SHA1(2f19b68b1db8a0b5e85ad43dc3b5bf651d465bd9) )
+	DISK_IMAGE( "szz_cf", 0, SHA1(d02cb1af0f03ce83719870d8a66244dde9795b2e) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/itgamble.c src/mame/drivers/itgamble.c
--- src-old/mame/drivers/itgamble.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/itgamble.c	2012-02-19 01:27:36.000000000 +0100
@@ -519,10 +519,10 @@
 	ROM_LOAD( "4a.ic18", 0x000000, 0x80000, CRC(5decae2d) SHA1(d918aad0e2a1249b18677833f743c92fb678050a) )
 	ROM_LOAD( "5a.ic17", 0x080000, 0x80000, CRC(8f1bbbf3) SHA1(5efcf77674f8737fc1b98881acebacb26b10adc1) )
 	ROM_LOAD( "2a.ic20", 0x100000, 0x40000, CRC(f9bffb07) SHA1(efba175189d99a4548739a72f8a1f03c2782a3d0) )
-	ROM_LOAD( "3a.ic19", 0x140000, 0x80000, CRC(56c8a73d) SHA1(49b44e5604cd8675d8f9770e5fb68dad4394e11d) ) /* identical halves */
+	ROM_LOAD( "euro2k2a_3a.ic19", 0x140000, 0x80000, CRC(56c8a73d) SHA1(49b44e5604cd8675d8f9770e5fb68dad4394e11d) ) /* identical halves */
 
 	ROM_REGION( 0x40000, "oki", 0 ) /* M6295 samples */
-	ROM_LOAD( "1.ic25", 0x00000, 0x40000, CRC(4fe79e43) SHA1(7c154cb00e9b64fbdcc218280f2183b816cef20b) )
+	ROM_LOAD( "euro2k2a_1.ic25", 0x00000, 0x40000, CRC(4fe79e43) SHA1(7c154cb00e9b64fbdcc218280f2183b816cef20b) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/jaguar.c src/mame/drivers/jaguar.c
--- src-old/mame/drivers/jaguar.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/jaguar.c	2012-02-19 01:27:36.000000000 +0100
@@ -1684,7 +1684,7 @@
 	MCFG_MACHINE_RESET(cojag)
 	MCFG_NVRAM_ADD_1FILL("nvram")
 
-	MCFG_IDE_CONTROLLER_ADD("ide", jaguar_external_int)
+	MCFG_IDE_CONTROLLER_ADD("ide", jaguar_external_int, ide_devices, "hdd", NULL)
 
 	MCFG_TIMER_ADD("serial_timer", jaguar_serial_callback)
 
@@ -1967,7 +1967,7 @@
 	ROM_LOAD32_BYTE( "136105-0001c.3m", 0x00002, 0x80000, CRC(6f135a81) SHA1(2d9660f240b14481e8c46bc98713e9dc12035063) )
 	ROM_LOAD32_BYTE( "136105-0000c.3k", 0x00003, 0x80000, CRC(94f50c14) SHA1(a54552e3ac5c4f481ba4f2fc7d724534576fe76c) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "area51t", 0, SHA1(d2865cc7b1bb08a4393a72013a90e18d8a8f9860) )
 ROM_END
 
@@ -1978,7 +1978,7 @@
 	ROM_LOAD32_BYTE( "136105-0001a.3m", 0x00002, 0x80000, CRC(c6d8322b) SHA1(90cf848a4195c51b505653cc2c74a3b9e3c851b8) )
 	ROM_LOAD32_BYTE( "136105-0000a.3k", 0x00003, 0x80000, CRC(729eb1b7) SHA1(21864b4281b1ad17b2903e3aa294e4be74161e80) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "area51", 0, SHA1(3b303bc37e206a6d7339352c869f050d04186f11) )
 ROM_END
 
@@ -1989,7 +1989,7 @@
 	ROM_LOAD32_BYTE( "a51_2-c.lh", 0x00002, 0x80000, CRC(a6524f73) SHA1(ae377a6803a4f7d1bbcc111725af121a3e82317d) )
 	ROM_LOAD32_BYTE( "a51_2-c.ll", 0x00003, 0x80000, CRC(471b15d2) SHA1(4b5f45ee140b03a6be61475cae1c2dbef0f07457) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "area51", 0, SHA1(3b303bc37e206a6d7339352c869f050d04186f11) )
 ROM_END
 
@@ -2000,7 +2000,7 @@
 	ROM_LOAD32_BYTE( "maxf_105.lh", 0x00002, 0x80000, CRC(84d49423) SHA1(88d9a6724f1118f2bbef5dfa27accc2b65c5ba1d) )
 	ROM_LOAD32_BYTE( "maxf_105.ll", 0x00003, 0x80000, CRC(16d0768d) SHA1(665a6d7602a7f2f5b1f332b0220b1533143d56b1) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "maxforce", 0, SHA1(d54e7a8f3866bb2a1d28ae637e7c92ffa4dbe558) )
 ROM_END
 
@@ -2012,7 +2012,7 @@
 	ROM_LOAD32_BYTE( "maxf_102.lh", 0x00002, 0x80000, CRC(459ffba5) SHA1(adb40db6904e84c17f32ac6518fd2e994da7883f) )
 	ROM_LOAD32_BYTE( "maxf_102.ll", 0x00003, 0x80000, CRC(e491be7f) SHA1(cbe281c099a4aa87067752d68cf2bb0ab3900531) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "maxforce", 0, SHA1(d54e7a8f3866bb2a1d28ae637e7c92ffa4dbe558) )
 ROM_END
 
@@ -2027,7 +2027,7 @@
 	ROM_REGION( 0x800, "user2", 0 ) /* 28C16 style eeprom, currently loaded but not used */
 	ROM_LOAD( "28c16.17z", 0x000, 0x800, CRC(1cdd9088) SHA1(4f01f02ff95f31ced87a3cdd7f171afd92551266) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "maxforce", 0, SHA1(d54e7a8f3866bb2a1d28ae637e7c92ffa4dbe558) )
 ROM_END
 
@@ -2039,7 +2039,7 @@
 	ROM_LOAD32_BYTE( "area51mx.3m", 0x00002, 0x80000, CRC(d800ac17) SHA1(3d515c8608d8101ee9227116175b3c3f1fe22e0c) )
 	ROM_LOAD32_BYTE( "area51mx.3k", 0x00003, 0x80000, CRC(0e78f308) SHA1(adc4c8e441eb8fe525d0a6220eb3a2a8791a7289) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "area51mx", 0, SHA1(5ff10f4e87094d4449eabf3de7549564ca568c7e) )
 ROM_END
 
@@ -2051,7 +2051,7 @@
 	ROM_LOAD32_BYTE( "a51mxr3k.lh", 0x00002, 0x80000, CRC(d7d94dac) SHA1(2060a74715f36a0d7f5dd0855eda48ad1f20f095) )
 	ROM_LOAD32_BYTE( "a51mxr3k.ll", 0x00003, 0x80000, CRC(ece9e5ae) SHA1(7e44402726f5afa6d1670b27aa43ad13d21c4ad9) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "area51mx", 0, SHA1(5ff10f4e87094d4449eabf3de7549564ca568c7e) )
 ROM_END
 
@@ -2063,7 +2063,7 @@
 	ROM_LOAD32_BYTE( "lh", 0x00002, 0x80000, CRC(be4b2ef6) SHA1(4332b3036e9cb12685e914d085d9a63aa856f0be) )
 	ROM_LOAD32_BYTE( "ll", 0x00003, 0x80000, CRC(ba8753eb) SHA1(0322e0e37d814a38d08ba191b1a97fb1a55fe461) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "vcircle", 0, SHA1(bfa79c4cacdc9c2cd6362f62a23056b3e35a2034) )
 ROM_END
 
@@ -2157,132 +2157,132 @@
 
 ROM_START( freezeat2 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "prog.hh",              0x000000, 0x040000, CRC(a8aefa52) SHA1(ba95da93035520de4b15245f68217c59dfb69dbd) )
-	ROM_LOAD32_BYTE( "prog.hl",              0x000001, 0x040000, CRC(152dd641) SHA1(52fa260baf1979ed8f15f8abcbbeebd8e595d0e4) )
-	ROM_LOAD32_BYTE( "prog.lh",              0x000002, 0x040000, CRC(416d26ed) SHA1(11cf3b88415a8a5d0bb8e1df08603a85202186ef) )
-	ROM_LOAD32_BYTE( "prog.ll",              0x000003, 0x040000, CRC(d6a5dbc8) SHA1(0e2176c35cbc59b2a5283366210409d0e930bac7) )
+	ROM_LOAD32_BYTE( "961018_prog.hh",              0x000000, 0x040000, CRC(a8aefa52) SHA1(ba95da93035520de4b15245f68217c59dfb69dbd) )
+	ROM_LOAD32_BYTE( "961018_prog.hl",              0x000001, 0x040000, CRC(152dd641) SHA1(52fa260baf1979ed8f15f8abcbbeebd8e595d0e4) )
+	ROM_LOAD32_BYTE( "961018_prog.lh",              0x000002, 0x040000, CRC(416d26ed) SHA1(11cf3b88415a8a5d0bb8e1df08603a85202186ef) )
+	ROM_LOAD32_BYTE( "961018_prog.ll",              0x000003, 0x040000, CRC(d6a5dbc8) SHA1(0e2176c35cbc59b2a5283366210409d0e930bac7) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish_gr0.63-56", 0x000000, 0x100000, CRC(99d0dc75) SHA1(b32126eea70c7584d1c34a6ca33282fbaf4b03aa), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.55-48", 0x000001, 0x100000, CRC(2dfdfe62) SHA1(e0554d36ef5cf4b6ce171857ea4f2737f11286a5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.47-40", 0x000002, 0x100000, CRC(722aee2a) SHA1(bc79433131bed5b08453d1b80324a28a552783de), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.39-32", 0x000003, 0x100000, CRC(919e31b4) SHA1(3807d4629d8277c780dba888c23d17ba47803f27), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.31-24", 0x000004, 0x100000, CRC(a957ac95) SHA1(ddfaca994c06976bee8b123857904e64f40b7f31), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.23-16", 0x000005, 0x100000, CRC(a147ec66) SHA1(6291008158d581b81e025ed34ff0950983c12c67), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.15-08", 0x000006, 0x100000, CRC(206d2f38) SHA1(6aca89df26d3602ff1da3c23f19e0782439623ff), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.07-00", 0x000007, 0x100000, CRC(06559831) SHA1(b2c022457425d7900337cfa2fd1622336c0c0bc5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.63-56", 0x800000, 0x100000, CRC(30c624d2) SHA1(4ced77d1663169d0cb37d6728ec52e67f05064c5), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.55-48", 0x800001, 0x100000, CRC(049cd60f) SHA1(8a7615a76b57a4e6ef5d95a5ee6c56086671dbb6), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.47-40", 0x800002, 0x100000, CRC(d6aaf3bf) SHA1(1c597bdc0e61fd0941cff5a8a93f24f108bd0daa), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.39-32", 0x800003, 0x100000, CRC(7d6ebc69) SHA1(668769297f75f9c367bc5cde26419ed092fc9dd8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.31-24", 0x800004, 0x100000, CRC(6e5fee1f) SHA1(1eca79c8d395f881d0a05f10073998fcae70c3b1), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.23-16", 0x800005, 0x100000, CRC(a8b1e9b4) SHA1(066285928e574e656510b90bc212a8d86660bd07), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.15-08", 0x800006, 0x100000, CRC(c90080e6) SHA1(a764bdd6b4e9e727f7468a53424a9211ec5fd5a8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.07-00", 0x800007, 0x100000, CRC(1f20c020) SHA1(71b32386dc0444264f2f1e2a81899e0e9260994c), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.63-56", 0x000000, 0x100000, CRC(99d0dc75) SHA1(b32126eea70c7584d1c34a6ca33282fbaf4b03aa), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.55-48", 0x000001, 0x100000, CRC(2dfdfe62) SHA1(e0554d36ef5cf4b6ce171857ea4f2737f11286a5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.47-40", 0x000002, 0x100000, CRC(722aee2a) SHA1(bc79433131bed5b08453d1b80324a28a552783de), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.39-32", 0x000003, 0x100000, CRC(919e31b4) SHA1(3807d4629d8277c780dba888c23d17ba47803f27), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.31-24", 0x000004, 0x100000, CRC(a957ac95) SHA1(ddfaca994c06976bee8b123857904e64f40b7f31), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.23-16", 0x000005, 0x100000, CRC(a147ec66) SHA1(6291008158d581b81e025ed34ff0950983c12c67), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.15-08", 0x000006, 0x100000, CRC(206d2f38) SHA1(6aca89df26d3602ff1da3c23f19e0782439623ff), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr0.07-00", 0x000007, 0x100000, CRC(06559831) SHA1(b2c022457425d7900337cfa2fd1622336c0c0bc5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.63-56", 0x800000, 0x100000, CRC(30c624d2) SHA1(4ced77d1663169d0cb37d6728ec52e67f05064c5), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.55-48", 0x800001, 0x100000, CRC(049cd60f) SHA1(8a7615a76b57a4e6ef5d95a5ee6c56086671dbb6), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.47-40", 0x800002, 0x100000, CRC(d6aaf3bf) SHA1(1c597bdc0e61fd0941cff5a8a93f24f108bd0daa), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.39-32", 0x800003, 0x100000, CRC(7d6ebc69) SHA1(668769297f75f9c367bc5cde26419ed092fc9dd8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.31-24", 0x800004, 0x100000, CRC(6e5fee1f) SHA1(1eca79c8d395f881d0a05f10073998fcae70c3b1), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.23-16", 0x800005, 0x100000, CRC(a8b1e9b4) SHA1(066285928e574e656510b90bc212a8d86660bd07), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.15-08", 0x800006, 0x100000, CRC(c90080e6) SHA1(a764bdd6b4e9e727f7468a53424a9211ec5fd5a8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961018_gr1.07-00", 0x800007, 0x100000, CRC(1f20c020) SHA1(71b32386dc0444264f2f1e2a81899e0e9260994c), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat3 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "prog.hh",              0x000000, 0x040000, CRC(863942e6) SHA1(c7429c8a5c86ff93c64950e201cffca83dd7b7b0) )
-	ROM_LOAD32_BYTE( "prog.hl",              0x000001, 0x040000, CRC(2acc18ef) SHA1(ead02566f7641b1d1066bd2e257b695e5c7e8437) )
-	ROM_LOAD32_BYTE( "prog.lh",              0x000002, 0x040000, CRC(948cf20c) SHA1(86c757aa3c849ef5ba94ed4d5dbf10e833dab6bd) )
-	ROM_LOAD32_BYTE( "prog.ll",              0x000003, 0x040000, CRC(5f44969e) SHA1(32345d7c56a3a890e71f8c71f25414d442b60af8) )
+	ROM_LOAD32_BYTE( "961007_prog.hh",              0x000000, 0x040000, CRC(863942e6) SHA1(c7429c8a5c86ff93c64950e201cffca83dd7b7b0) )
+	ROM_LOAD32_BYTE( "961007_prog.hl",              0x000001, 0x040000, CRC(2acc18ef) SHA1(ead02566f7641b1d1066bd2e257b695e5c7e8437) )
+	ROM_LOAD32_BYTE( "961007_prog.lh",              0x000002, 0x040000, CRC(948cf20c) SHA1(86c757aa3c849ef5ba94ed4d5dbf10e833dab6bd) )
+	ROM_LOAD32_BYTE( "961007_prog.ll",              0x000003, 0x040000, CRC(5f44969e) SHA1(32345d7c56a3a890e71f8c71f25414d442b60af8) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.63-56", 0x800000, 0x100000, CRC(ead678c9) SHA1(f83d467f6685965b6176b10adbd4e35ef808baf3), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.55-48", 0x800001, 0x100000, CRC(3591e752) SHA1(df242d2f724edfd78f7191f0ba7a8cde2c09b25f), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.47-40", 0x800002, 0x100000, CRC(e29a7a6c) SHA1(0bfb26076b390492eed81d4c4f0852c64fdccfce), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.39-32", 0x800003, 0x100000, CRC(e980f957) SHA1(78e8ef07f443ce7991a46005627d5802d36d731c), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.31-24", 0x800004, 0x100000, CRC(d90c5221) SHA1(7a330f39f3751d58157f872d92c3c2b91fe60d14), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.23-16", 0x800005, 0x100000, CRC(9be0d4de) SHA1(9bb67a1f1db77483e896fed7096c1e23c153ede4), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.15-08", 0x800006, 0x100000, CRC(122248af) SHA1(80dd5486106d475bd9f6d78919ebeb176e7becff), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.07-00", 0x800007, 0x100000, CRC(5ae08327) SHA1(822d8292793509ebfbfce27e92a74c78c4328bda), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.63-56", 0x800000, 0x100000, CRC(ead678c9) SHA1(f83d467f6685965b6176b10adbd4e35ef808baf3), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.55-48", 0x800001, 0x100000, CRC(3591e752) SHA1(df242d2f724edfd78f7191f0ba7a8cde2c09b25f), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.47-40", 0x800002, 0x100000, CRC(e29a7a6c) SHA1(0bfb26076b390492eed81d4c4f0852c64fdccfce), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.39-32", 0x800003, 0x100000, CRC(e980f957) SHA1(78e8ef07f443ce7991a46005627d5802d36d731c), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.31-24", 0x800004, 0x100000, CRC(d90c5221) SHA1(7a330f39f3751d58157f872d92c3c2b91fe60d14), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.23-16", 0x800005, 0x100000, CRC(9be0d4de) SHA1(9bb67a1f1db77483e896fed7096c1e23c153ede4), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.15-08", 0x800006, 0x100000, CRC(122248af) SHA1(80dd5486106d475bd9f6d78919ebeb176e7becff), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961007_gr1.07-00", 0x800007, 0x100000, CRC(5ae08327) SHA1(822d8292793509ebfbfce27e92a74c78c4328bda), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat4 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "prog.hh",              0x000000, 0x040000, CRC(80336f5e) SHA1(9946e8eebec2cd68db059f40f535ea212f41913d) )
-	ROM_LOAD32_BYTE( "prog.hl",              0x000001, 0x040000, CRC(55125520) SHA1(13be4fbf32bcd94a2ea97fd690bd1dfdff146d33) )
-	ROM_LOAD32_BYTE( "prog.lh",              0x000002, 0x040000, CRC(9d99c794) SHA1(f443f05a5979db66d61ef4174f0369a1cf4b7793) )
-	ROM_LOAD32_BYTE( "prog.ll",              0x000003, 0x040000, CRC(e03700e0) SHA1(24d41750f02ee7e8fb379e517751b661400aa521) )
+	ROM_LOAD32_BYTE( "961003_prog.hh",              0x000000, 0x040000, CRC(80336f5e) SHA1(9946e8eebec2cd68db059f40f535ea212f41913d) )
+	ROM_LOAD32_BYTE( "961003_prog.hl",              0x000001, 0x040000, CRC(55125520) SHA1(13be4fbf32bcd94a2ea97fd690bd1dfdff146d33) )
+	ROM_LOAD32_BYTE( "961003_prog.lh",              0x000002, 0x040000, CRC(9d99c794) SHA1(f443f05a5979db66d61ef4174f0369a1cf4b7793) )
+	ROM_LOAD32_BYTE( "961003_prog.ll",              0x000003, 0x040000, CRC(e03700e0) SHA1(24d41750f02ee7e8fb379e517751b661400aa521) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.63-56", 0x800000, 0x100000, CRC(c91b6ee4) SHA1(58d2d6b1b9847150b8b3e358842c4a097ef91475), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.55-48", 0x800001, 0x100000, CRC(65528e55) SHA1(18020cababed379f77149b7e89e80b294766df31), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.47-40", 0x800002, 0x100000, CRC(8fe4187f) SHA1(c9ceec40688617e1251142465d0e608f80a83e40), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.39-32", 0x800003, 0x100000, CRC(fdf05a42) SHA1(849e224b68be2fb396ee4cb4729517470af7c282), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.31-24", 0x800004, 0x100000, CRC(bb2cd741) SHA1(ac55a54c702d222cb1b9bb480b0f7a71bc315878), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.23-16", 0x800005, 0x100000, CRC(ea8c5984) SHA1(eca1619c17dfac154a2024ec49b4b4f9f06a50c9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.15-08", 0x800006, 0x100000, CRC(0b00c816) SHA1(879b0e9d92fe737d740c348dc1cc376c8abfbdb8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.07-00", 0x800007, 0x100000, CRC(a84335c3) SHA1(340f5ddb9bff1ecd469eab8be36cc0ede84f1f5e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.63-56", 0x000000, 0x100000, CRC(36799449) SHA1(bb706fe7fdc68f840702a127eed7d4519dd45869), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.55-48", 0x000001, 0x100000, CRC(23959947) SHA1(a35a6e62c7b2be57d41b1b64be93713cbf897f0a), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.47-40", 0x000002, 0x100000, CRC(4657e4e0) SHA1(b6c07182babcb0a106bf4a8f2e3f524371dd882d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.39-32", 0x000003, 0x100000, CRC(b6ea4b64) SHA1(176f94f14307c40b9c611d6f6bc9118e498cdfad), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.31-24", 0x000004, 0x100000, CRC(7d4ce71f) SHA1(a1cf5aa9df8dd29c777c10cfdce0925981584261), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.23-16", 0x000005, 0x100000, CRC(02db4fd1) SHA1(fce6f31802bf36d6b006f0b212f553bdf21f9374), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.15-08", 0x000006, 0x100000, CRC(7d496d6c) SHA1(f82db0621729a00acf4077482e9dfab040ac829b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr0.07-00", 0x000007, 0x100000, CRC(3aa389d8) SHA1(52502f2f3c91d7c29261f60fe8f489a352399c96), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.63-56", 0x800000, 0x100000, CRC(c91b6ee4) SHA1(58d2d6b1b9847150b8b3e358842c4a097ef91475), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.55-48", 0x800001, 0x100000, CRC(65528e55) SHA1(18020cababed379f77149b7e89e80b294766df31), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.47-40", 0x800002, 0x100000, CRC(8fe4187f) SHA1(c9ceec40688617e1251142465d0e608f80a83e40), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.39-32", 0x800003, 0x100000, CRC(fdf05a42) SHA1(849e224b68be2fb396ee4cb4729517470af7c282), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.31-24", 0x800004, 0x100000, CRC(bb2cd741) SHA1(ac55a54c702d222cb1b9bb480b0f7a71bc315878), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.23-16", 0x800005, 0x100000, CRC(ea8c5984) SHA1(eca1619c17dfac154a2024ec49b4b4f9f06a50c9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.15-08", 0x800006, 0x100000, CRC(0b00c816) SHA1(879b0e9d92fe737d740c348dc1cc376c8abfbdb8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish961003_gr1.07-00", 0x800007, 0x100000, CRC(a84335c3) SHA1(340f5ddb9bff1ecd469eab8be36cc0ede84f1f5e), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat5 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "prog.hh",              0x000000, 0x040000, CRC(95c4fc64) SHA1(cd00efe7f760ef1e4cdc4bc8a3b368427cb15d8a) )
-	ROM_LOAD32_BYTE( "prog.hl",              0x000001, 0x040000, CRC(ffb9cb71) SHA1(35d6a5440d63bc5b94c4447645365039169da368) )
-	ROM_LOAD32_BYTE( "prog.lh",              0x000002, 0x040000, CRC(3ddacd80) SHA1(79f9650531847eefd83908b6ea1e8362688b377c) )
-	ROM_LOAD32_BYTE( "prog.ll",              0x000003, 0x040000, CRC(95ebefb0) SHA1(b88b12adabd7b0902c3a78919bcec8d9a2b04168) )
+	ROM_LOAD32_BYTE( "960920_prog.hh",              0x000000, 0x040000, CRC(95c4fc64) SHA1(cd00efe7f760ef1e4cdc4bc8a3b368427cb15d8a) )
+	ROM_LOAD32_BYTE( "960920_prog.hl",              0x000001, 0x040000, CRC(ffb9cb71) SHA1(35d6a5440d63bc5b94c4447645365039169da368) )
+	ROM_LOAD32_BYTE( "960920_prog.lh",              0x000002, 0x040000, CRC(3ddacd80) SHA1(79f9650531847eefd83908b6ea1e8362688b377c) )
+	ROM_LOAD32_BYTE( "960920_prog.ll",              0x000003, 0x040000, CRC(95ebefb0) SHA1(b88b12adabd7b0902c3a78919bcec8d9a2b04168) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish_gr0.63-56", 0x000000, 0x100000, CRC(404a10c3) SHA1(8e353ac7608bd54f0fea610c85166ad14f2faadb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.55-48", 0x000001, 0x100000, CRC(0b262f2f) SHA1(2a963cb5c3344091406d090edfdda498709c6aa6), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.47-40", 0x000002, 0x100000, CRC(43f86d26) SHA1(b31d36b11052514b5bcd5bf8e400457ca572c306), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.39-32", 0x000003, 0x100000, CRC(5cf0228f) SHA1(7a8c59cf9a7744e9f332db5f661f507323375968), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.31-24", 0x000004, 0x100000, CRC(7a24ff98) SHA1(db9e0e8bb417f187267a6e4fc1e66ff060ee4096), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.23-16", 0x000005, 0x100000, CRC(ea163c93) SHA1(d07ed26191d36497c56b15774625a49ecb958386), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.15-08", 0x000006, 0x100000, CRC(d364534f) SHA1(153908bb8929a898945f768f8bc3d853c6aeaceb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.07-00", 0x000007, 0x100000, CRC(7ba4cb0d) SHA1(16bd487123f499b7080596dc76253081179a0f66), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.63-56", 0x800000, 0x100000, CRC(0e1fc4a9) SHA1(a200bb0af5f1e2c3f8d221ae4e9ba55b9dfb8550), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.55-48", 0x800001, 0x100000, CRC(b696b875) SHA1(16dc4d5cee3f08360cf19926584419c21d781f45), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.47-40", 0x800002, 0x100000, CRC(e78d9302) SHA1(f8b5ed992c433d63677edbeafd3e465b1d42b455), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.39-32", 0x800003, 0x100000, CRC(9b50374c) SHA1(d8af3c9d8e0459e24b974cdf2e75c7c39582912f), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.31-24", 0x800004, 0x100000, CRC(b6a19b7e) SHA1(5668b27db4dade8efb1524b8ecd1fe78498e8460), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.23-16", 0x800005, 0x100000, CRC(ff835b67) SHA1(19da2de1d067069871c33c8b25fd2eac2d03f627), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.15-08", 0x800006, 0x100000, CRC(8daf6995) SHA1(2f44031378b5fb1ba1f80a966dbe902316dc6fe8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.07-00", 0x800007, 0x100000, CRC(3676ac70) SHA1(640c4d4f53ca2bcae2009e402fd6ad70e40defa4), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.63-56", 0x000000, 0x100000, CRC(404a10c3) SHA1(8e353ac7608bd54f0fea610c85166ad14f2faadb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.55-48", 0x000001, 0x100000, CRC(0b262f2f) SHA1(2a963cb5c3344091406d090edfdda498709c6aa6), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.47-40", 0x000002, 0x100000, CRC(43f86d26) SHA1(b31d36b11052514b5bcd5bf8e400457ca572c306), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.39-32", 0x000003, 0x100000, CRC(5cf0228f) SHA1(7a8c59cf9a7744e9f332db5f661f507323375968), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.31-24", 0x000004, 0x100000, CRC(7a24ff98) SHA1(db9e0e8bb417f187267a6e4fc1e66ff060ee4096), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.23-16", 0x000005, 0x100000, CRC(ea163c93) SHA1(d07ed26191d36497c56b15774625a49ecb958386), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.15-08", 0x000006, 0x100000, CRC(d364534f) SHA1(153908bb8929a898945f768f8bc3d853c6aeaceb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr0.07-00", 0x000007, 0x100000, CRC(7ba4cb0d) SHA1(16bd487123f499b7080596dc76253081179a0f66), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.63-56", 0x800000, 0x100000, CRC(0e1fc4a9) SHA1(a200bb0af5f1e2c3f8d221ae4e9ba55b9dfb8550), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.55-48", 0x800001, 0x100000, CRC(b696b875) SHA1(16dc4d5cee3f08360cf19926584419c21d781f45), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.47-40", 0x800002, 0x100000, CRC(e78d9302) SHA1(f8b5ed992c433d63677edbeafd3e465b1d42b455), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.39-32", 0x800003, 0x100000, CRC(9b50374c) SHA1(d8af3c9d8e0459e24b974cdf2e75c7c39582912f), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.31-24", 0x800004, 0x100000, CRC(b6a19b7e) SHA1(5668b27db4dade8efb1524b8ecd1fe78498e8460), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.23-16", 0x800005, 0x100000, CRC(ff835b67) SHA1(19da2de1d067069871c33c8b25fd2eac2d03f627), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.15-08", 0x800006, 0x100000, CRC(8daf6995) SHA1(2f44031378b5fb1ba1f80a966dbe902316dc6fe8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960920_gr1.07-00", 0x800007, 0x100000, CRC(3676ac70) SHA1(640c4d4f53ca2bcae2009e402fd6ad70e40defa4), ROM_SKIP(7) )
 ROM_END
 
 ROM_START( freezeat6 )
 	ROM_REGION32_BE( 0x200000, "user1", 0 )	/* 2MB for R3000 code */
-	ROM_LOAD32_BYTE( "prog.hh",              0x000000, 0x040000, CRC(120711fe) SHA1(387e3cc8a1a9ea7d65c528387891d09ed9889fe3) )
-	ROM_LOAD32_BYTE( "prog.hl",              0x000001, 0x040000, CRC(18dd292a) SHA1(00e79851140716985f43594142c97e510a06b24a) )
-	ROM_LOAD32_BYTE( "prog.lh",              0x000002, 0x040000, CRC(ce387e72) SHA1(021a274da0b828550a47c3778e1059d4e759693a) )
-	ROM_LOAD32_BYTE( "prog.ll",              0x000003, 0x040000, CRC(9b307b7c) SHA1(71b696802fe7c867525d2626351dcfacedabd696) )
+	ROM_LOAD32_BYTE( "960907_prog.hh",              0x000000, 0x040000, CRC(120711fe) SHA1(387e3cc8a1a9ea7d65c528387891d09ed9889fe3) )
+	ROM_LOAD32_BYTE( "960907_prog.hl",              0x000001, 0x040000, CRC(18dd292a) SHA1(00e79851140716985f43594142c97e510a06b24a) )
+	ROM_LOAD32_BYTE( "960907_prog.lh",              0x000002, 0x040000, CRC(ce387e72) SHA1(021a274da0b828550a47c3778e1059d4e759693a) )
+	ROM_LOAD32_BYTE( "960907_prog.ll",              0x000003, 0x040000, CRC(9b307b7c) SHA1(71b696802fe7c867525d2626351dcfacedabd696) )
 
 	ROM_REGION32_BE( 0x1000000, "user2", 0 )	/* 16MB for 64-bit ROM data */
-	ROMX_LOAD( "fish_gr0.63-56", 0x000000, 0x100000, CRC(293a3308) SHA1(e4c88759c3b8f8a359db83817dbd0428350b4f7e), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.55-48", 0x000001, 0x100000, CRC(18bb4bdf) SHA1(1f6c49b3b5946390fa7582b531f8d9af3baa2567), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.47-40", 0x000002, 0x100000, CRC(1faedcc6) SHA1(1e4ecbe4553fb3ebfbd03bd7e16066ccb531d00b), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.39-32", 0x000003, 0x100000, CRC(536bc349) SHA1(06d7ac38b2c8cdc85e2cb531bba9c836e50c8247), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.31-24", 0x000004, 0x100000, CRC(813d4a31) SHA1(e024f9da2f15a482d8142870baf487297b995ed9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.23-16", 0x000005, 0x100000, CRC(f881514b) SHA1(a694f90621e2c1569a6a5ed8920838ba5506f72e), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.15-08", 0x000006, 0x100000, CRC(d7634655) SHA1(d7ac83c0fa5d0ec57d096d4d704fe99ee8160e09), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr0.07-00", 0x000007, 0x100000, CRC(3fca32a3) SHA1(22753a9678e04d9355238e013e58d9f45315579d), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.63-56", 0x800000, 0x100000, CRC(a2b89d3a) SHA1(9cfcd0b88dea192ba39efcdccc78d1a0fd8f3388), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.55-48", 0x800001, 0x100000, CRC(766822a8) SHA1(2c9b14542a5467c1a3451559ea296da09c2cfdb9), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.47-40", 0x800002, 0x100000, CRC(112b519c) SHA1(f0e1ed1b8ad271fa9708f513b11d5cca6e550668), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.39-32", 0x800003, 0x100000, CRC(435b5d37) SHA1(ecb6e7271d993f8e315b85e69166838e66dd41a8), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.31-24", 0x800004, 0x100000, CRC(2637ae7f) SHA1(5e0bd0e08d8c1eaae725b4d55030c2698abd46e7), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.23-16", 0x800005, 0x100000, CRC(e732f1bf) SHA1(a228aee0cc36a0089716f20bfa75d87750692adb), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.15-08", 0x800006, 0x100000, CRC(7d4e2d9e) SHA1(4cb9b754b7585df4cae6bdd7085a57729d53e643), ROM_SKIP(7) )
-	ROMX_LOAD( "fish_gr1.07-00", 0x800007, 0x100000, CRC(8ea036af) SHA1(1f9baec6712e0ba0e8a744529e41799217760194), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.63-56", 0x000000, 0x100000, CRC(293a3308) SHA1(e4c88759c3b8f8a359db83817dbd0428350b4f7e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.55-48", 0x000001, 0x100000, CRC(18bb4bdf) SHA1(1f6c49b3b5946390fa7582b531f8d9af3baa2567), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.47-40", 0x000002, 0x100000, CRC(1faedcc6) SHA1(1e4ecbe4553fb3ebfbd03bd7e16066ccb531d00b), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.39-32", 0x000003, 0x100000, CRC(536bc349) SHA1(06d7ac38b2c8cdc85e2cb531bba9c836e50c8247), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.31-24", 0x000004, 0x100000, CRC(813d4a31) SHA1(e024f9da2f15a482d8142870baf487297b995ed9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.23-16", 0x000005, 0x100000, CRC(f881514b) SHA1(a694f90621e2c1569a6a5ed8920838ba5506f72e), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.15-08", 0x000006, 0x100000, CRC(d7634655) SHA1(d7ac83c0fa5d0ec57d096d4d704fe99ee8160e09), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr0.07-00", 0x000007, 0x100000, CRC(3fca32a3) SHA1(22753a9678e04d9355238e013e58d9f45315579d), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.63-56", 0x800000, 0x100000, CRC(a2b89d3a) SHA1(9cfcd0b88dea192ba39efcdccc78d1a0fd8f3388), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.55-48", 0x800001, 0x100000, CRC(766822a8) SHA1(2c9b14542a5467c1a3451559ea296da09c2cfdb9), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.47-40", 0x800002, 0x100000, CRC(112b519c) SHA1(f0e1ed1b8ad271fa9708f513b11d5cca6e550668), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.39-32", 0x800003, 0x100000, CRC(435b5d37) SHA1(ecb6e7271d993f8e315b85e69166838e66dd41a8), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.31-24", 0x800004, 0x100000, CRC(2637ae7f) SHA1(5e0bd0e08d8c1eaae725b4d55030c2698abd46e7), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.23-16", 0x800005, 0x100000, CRC(e732f1bf) SHA1(a228aee0cc36a0089716f20bfa75d87750692adb), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.15-08", 0x800006, 0x100000, CRC(7d4e2d9e) SHA1(4cb9b754b7585df4cae6bdd7085a57729d53e643), ROM_SKIP(7) )
+	ROMX_LOAD( "fish960907_gr1.07-00", 0x800007, 0x100000, CRC(8ea036af) SHA1(1f9baec6712e0ba0e8a744529e41799217760194), ROM_SKIP(7) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/jpmimpct.c src/mame/drivers/jpmimpct.c
--- src-old/mame/drivers/jpmimpct.c	2012-01-24 04:02:39.000000000 +0100
+++ src/mame/drivers/jpmimpct.c	2012-02-19 01:27:36.000000000 +0100
@@ -3787,7 +3787,7 @@
 	ROM_LOAD16_BYTE( "7606.bin", 0x000000, 0x020000, CRC(90dae2a6) SHA1(38b790a3eb2aad3d2c039b27c18a1331b5c57b46) )
 
 	ROM_REGION( 0x80000, "upd", ROMREGION_ERASE00 )
-	/* missing? */
+	ROM_LOAD( "popoli_snd.bin", 0x000000, 0x080000, CRC(e982a788) SHA1(3c6aed29892011c3d7d076ea9bef5882f7ded055) )
 ROM_END
 
 
@@ -4419,13 +4419,13 @@
 	ROM_REGION( 0x1000000, "altrevs", 0 )
 	ROM_LOAD16_BYTE( "thbi-2_1.bin", 0x000000, 0x020000, CRC(a1ca874a) SHA1(0a12f387a9a3e261c1017922b8d6a652c696855a) )
 	ROM_LOAD16_BYTE( "thbi-2_2.bin", 0x000000, 0x020000, CRC(65320620) SHA1(3db5ccf4e69d85bb8b0270b12674c64ff674834c) )
-	ROM_LOAD16_BYTE( "thbi-2a1.bin", 0x000000, 0x020000, CRC(f30e472b) SHA1(e30b4c5c04f31ebf677af5f7924efc8836e6a91f) )
+	ROM_LOAD16_BYTE( "thbib-2a1.bin",0x000000, 0x020000, CRC(f30e472b) SHA1(e30b4c5c04f31ebf677af5f7924efc8836e6a91f) )
 	ROM_LOAD16_BYTE( "thbi-2n1.bin", 0x000000, 0x020000, CRC(90fc3f8e) SHA1(6b3e50482e8b779ad0cad8509ba76efd055d6987) )
-	ROM_LOAD16_BYTE( "thbi-2p1.bin", 0x000000, 0x020000, CRC(4a54d372) SHA1(bd7924eaeab185f097283c14b3bb197403853050) )
+	ROM_LOAD16_BYTE( "thbib-2p1.bin",0x000000, 0x020000, CRC(4a54d372) SHA1(bd7924eaeab185f097283c14b3bb197403853050) )
 	ROM_LOAD16_BYTE( "thbi-2w1.bin", 0x000000, 0x020000, CRC(c3a7f6c2) SHA1(c72a05ed21801401d5aec610d30482560b00baee) )
-	ROM_LOAD16_BYTE( "thbi-3a1.bin", 0x000000, 0x020000, CRC(be79183d) SHA1(13936aafbb5420748d74b531cbef0a1c39f9be5d) )
+	ROM_LOAD16_BYTE( "thbib-3a1.bin",0x000000, 0x020000, CRC(be79183d) SHA1(13936aafbb5420748d74b531cbef0a1c39f9be5d) )
 	ROM_LOAD16_BYTE( "thbi-3n1.bin", 0x000000, 0x020000, CRC(dd8b6098) SHA1(79d2fcf128fbfe14bd62cc649825fefc10d386a5) )
-	ROM_LOAD16_BYTE( "thbi-3p1.bin", 0x000000, 0x020000, CRC(07238c64) SHA1(8653eb78537c22a89bcd90e69ddc226dd25dbd76) )
+	ROM_LOAD16_BYTE( "thbib-3p1.bin",0x000000, 0x020000, CRC(07238c64) SHA1(8653eb78537c22a89bcd90e69ddc226dd25dbd76) )
 	ROM_LOAD16_BYTE( "thbi2np1.bin", 0x000000, 0x020000, CRC(7b626bb6) SHA1(ed8eefb2207f908b0c5bc3f315d014faccdfb493) )
 	ROM_LOAD16_BYTE( "thbi3np1.bin", 0x000000, 0x020000, CRC(361534a0) SHA1(e2ad00f1698a69b71084dba99b75f40a5f59aa20) )
 
diff -Nru src-old/mame/drivers/kinst.c src/mame/drivers/kinst.c
--- src-old/mame/drivers/kinst.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/kinst.c	2012-02-14 15:41:27.000000000 +0100
@@ -166,6 +166,26 @@
 static MACHINE_START( kinst )
 {
 	kinst_state *state = machine.driver_data<kinst_state>();
+	/* set the fastest DRC options */
+	mips3drc_set_options(machine.device("maincpu"), MIPS3DRC_FASTEST_OPTIONS);
+
+	/* configure fast RAM regions for DRC */
+	mips3drc_add_fastram(machine.device("maincpu"), 0x08000000, 0x087fffff, FALSE, state->m_rambase2);
+	mips3drc_add_fastram(machine.device("maincpu"), 0x00000000, 0x0007ffff, FALSE, state->m_rambase);
+	mips3drc_add_fastram(machine.device("maincpu"), 0x1fc00000, 0x1fc7ffff, TRUE,  state->m_rombase);
+}
+
+
+
+/*************************************
+ *
+ *  Machine init
+ *
+ *************************************/
+
+static MACHINE_RESET( kinst )
+{
+	kinst_state *state = machine.driver_data<kinst_state>();
 	device_t *ide = machine.device("ide");
 	UINT8 *features = ide_get_features(ide,0);
 
@@ -198,26 +218,6 @@
 		features[14*2+1] = 0x41;
 	}
 
-	/* set the fastest DRC options */
-	mips3drc_set_options(machine.device("maincpu"), MIPS3DRC_FASTEST_OPTIONS);
-
-	/* configure fast RAM regions for DRC */
-	mips3drc_add_fastram(machine.device("maincpu"), 0x08000000, 0x087fffff, FALSE, state->m_rambase2);
-	mips3drc_add_fastram(machine.device("maincpu"), 0x00000000, 0x0007ffff, FALSE, state->m_rambase);
-	mips3drc_add_fastram(machine.device("maincpu"), 0x1fc00000, 0x1fc7ffff, TRUE,  state->m_rombase);
-}
-
-
-
-/*************************************
- *
- *  Machine init
- *
- *************************************/
-
-static MACHINE_RESET( kinst )
-{
-	kinst_state *state = machine.driver_data<kinst_state>();
 	/* set a safe base location for video */
 	state->m_video_base = &state->m_rambase[0x30000/4];
 }
@@ -660,7 +660,7 @@
 	MCFG_MACHINE_START(kinst)
 	MCFG_MACHINE_RESET(kinst)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
@@ -701,7 +701,7 @@
 	ROM_LOAD16_BYTE( "u35-l1", 0xc00000, 0x80000, CRC(0aaef4fc) SHA1(48c4c954ac9db648f28ad64f9845e19ec432eec3) )
 	ROM_LOAD16_BYTE( "u36-l1", 0xe00000, 0x80000, CRC(0577bb60) SHA1(cc78070cc41701e9a91fde5cfbdc7e1e83354854) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst", 0, SHA1(81d833236e994528d1482979261401b198d1ca53) )
 ROM_END
 
@@ -720,7 +720,7 @@
 	ROM_LOAD16_BYTE( "u35-l1", 0xc00000, 0x80000, CRC(0aaef4fc) SHA1(48c4c954ac9db648f28ad64f9845e19ec432eec3) )
 	ROM_LOAD16_BYTE( "u36-l1", 0xe00000, 0x80000, CRC(0577bb60) SHA1(cc78070cc41701e9a91fde5cfbdc7e1e83354854) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst", 0, SHA1(81d833236e994528d1482979261401b198d1ca53) )
 ROM_END
 
@@ -739,7 +739,7 @@
 	ROM_LOAD16_BYTE( "u35-l1", 0xc00000, 0x80000, CRC(0aaef4fc) SHA1(48c4c954ac9db648f28ad64f9845e19ec432eec3) )
 	ROM_LOAD16_BYTE( "u36-l1", 0xe00000, 0x80000, CRC(0577bb60) SHA1(cc78070cc41701e9a91fde5cfbdc7e1e83354854) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst", 0, SHA1(81d833236e994528d1482979261401b198d1ca53) )
 ROM_END
 
@@ -758,7 +758,7 @@
 	ROM_LOAD16_BYTE( "u35-l1", 0xc00000, 0x80000, CRC(0aaef4fc) SHA1(48c4c954ac9db648f28ad64f9845e19ec432eec3) )
 	ROM_LOAD16_BYTE( "u36-l1", 0xe00000, 0x80000, CRC(0577bb60) SHA1(cc78070cc41701e9a91fde5cfbdc7e1e83354854) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst", 0, SHA1(81d833236e994528d1482979261401b198d1ca53) )
 ROM_END
 
@@ -777,7 +777,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
@@ -796,7 +796,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
@@ -815,7 +815,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
@@ -834,7 +834,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
@@ -853,7 +853,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
@@ -872,7 +872,7 @@
 	ROM_LOAD16_BYTE( "ki2_l1.u35", 0xc00000, 0x80000, CRC(7245ce69) SHA1(24a3ff009c8a7f5a0bfcb198b8dcb5df365770d3) )
 	ROM_LOAD16_BYTE( "ki2_l1.u36", 0xe00000, 0x80000, CRC(8920acbb) SHA1(0fca72c40067034939b984b4bf32972a5a6c26af) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kinst2", 0, SHA1(e7c9291b4648eae0012ea0cc230731ed4987d1d5) )
 ROM_END
 
diff -Nru src-old/mame/drivers/kungfur.c src/mame/drivers/kungfur.c
--- src-old/mame/drivers/kungfur.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/kungfur.c	2012-02-19 16:23:23.000000000 +0100
@@ -1,17 +1,9 @@
 /***************************************************************************
 
-TODO:
-- understand the 7segs properly;
-- inputs;
-- lamps;
-- Fix sound index/sound stop for the ADPCM sound chips;
-
-===========================================================================
-
 KUNG-FU ROUSHI
 (c)1987 NAMCO
 
-6809         (4Mhz?)
+6809         (4MHz?)
 RAM 2016x1
 MSM5205 x 2  (2 SPEAKERS)
 8255    x 2
@@ -25,9 +17,40 @@
 Information:
 http://www.wshin.com/games/review/ka/kung-fu-roushi.htm
 http://www.youtube.com/watch?v=ssEfw-RbSjs
+http://www.youtube.com/watch?v=1YacVjpUG8g
+
+---------------------------------------------------------------------------
+
+Game Panel:
+
+tokuten                                       honjitsu yuuryoukiroku
+(score)                                       (today's best scores)
+XX                                            #1 XX points
+                                              #2 XX points
+dankai                                        #3 XX points
+(level)
+1 2 3 4 5
+
+hannoujikan        heikinhannoujikan          shuuryou
+(reaction time)    (average reaction time)    (finished, complete)
+X.XX seconds       X.XX seconds
 
 
-----------------------------------------------------------------
+Control Panel:
+
+washi no kakegoe no toori ni botan wo osunojazoi!
+(hit the buttons as I call them out)
+
+over 8, or 10 points --> level 1
+"   16, or 20 "      --> level 2
+"   28, or 35 "      --> level 3
+"   42, or 52 "      --> level 4
+"   52, or 73(?) "   --> level 5
+menkyokaiden(full certification)
+
+The 4 buttons are labeled:
+mae(forward), migi(right), ushiro(back), hidari(left)
+
 
 ***************************************************************************/
 
@@ -36,6 +59,8 @@
 #include "sound/msm5205.h"
 #include "machine/8255ppi.h"
 
+#include "kungfur.lh"
+
 
 class kungfur_state : public driver_device
 {
@@ -43,164 +68,149 @@
 	kungfur_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag) { }
 
-	UINT8 m_led[0x10];
-	UINT8 m_mux_data;
+	UINT8 m_latch[3];
+	UINT8 m_control;
+
 	UINT32 m_adpcm_pos[2];
-	UINT8 m_adpcm_idle[2];
-	UINT8 m_trigger1;
-	UINT8 m_adpcm_data1;
-	UINT8 m_trigger2;
-	UINT8 m_adpcm_data2;
+	UINT8 m_adpcm_data[2];
+	UINT8 m_adpcm_sel[2];
 };
 
 
-static VIDEO_START( kungfur )
+static INTERRUPT_GEN( kungfur_irq )
 {
-
+	kungfur_state *state = device->machine().driver_data<kungfur_state>();
+	if (state->m_control & 0x10)
+		device_set_input_line(device, M6809_IRQ_LINE, ASSERT_LINE);
 }
 
-/* TODO: I believe that f segment is incorrectly connected (the following is just copied from acommand.c).*/
-/*
-     a
-    ---
-f   | | b
-    -g-
-e   | | c
-    ---
-     d
-a & 1
-b & 2
-c & 4
-d & 8
-e & 10
-f & 20
-g & 40
-7f
-*/
-
-#define LED_ON		0x0001
-#define LED_OFF		0x0000
-
-static void draw_led(bitmap_ind16 &bitmap, int x, int y,UINT8 value)
-{
-	bitmap.plot_box(x, y, 6, 10, 0x00000000);
-
-	/*a*/
-	bitmap.pix16(y+0, x+1) = ((value & 0x01) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+0, x+2) = ((value & 0x01) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+0, x+3) = ((value & 0x01) ? LED_ON : LED_OFF);
-	/*b*/
-	bitmap.pix16(y+1, x+4) = ((value & 0x02) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+2, x+4) = ((value & 0x02) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+3, x+4) = ((value & 0x02) ? LED_ON : LED_OFF);
-	/*c*/
-	bitmap.pix16(y+5, x+4) = ((value & 0x04) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+6, x+4) = ((value & 0x04) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+7, x+4) = ((value & 0x04) ? LED_ON : LED_OFF);
-	/*d*/
-	bitmap.pix16(y+8, x+1) = ((value & 0x08) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+8, x+2) = ((value & 0x08) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+8, x+3) = ((value & 0x08) ? LED_ON : LED_OFF);
-	/*e*/
-	bitmap.pix16(y+5, x+0) = ((value & 0x10) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+6, x+0) = ((value & 0x10) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+7, x+0) = ((value & 0x10) ? LED_ON : LED_OFF);
-	/*f*/
-	bitmap.pix16(y+1, x+0) = ((value & 0x20) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+2, x+0) = ((value & 0x20) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+3, x+0) = ((value & 0x20) ? LED_ON : LED_OFF);
-	/*g*/
-	bitmap.pix16(y+4, x+1) = ((value & 0x40) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+4, x+2) = ((value & 0x40) ? LED_ON : LED_OFF);
-	bitmap.pix16(y+4, x+3) = ((value & 0x40) ? LED_ON : LED_OFF);
-	/*"point" (just for debugging)*/
-	bitmap.pix16(y+9, x+4) = ((value & 0x80) ? LED_ON : LED_OFF);
-}
-
-/* actually debugging purpose, it will be converted to the artwork system at some point. */
-static SCREEN_UPDATE_IND16( kungfur )
-{
-	kungfur_state *state = screen.machine().driver_data<kungfur_state>();
-//  popmessage("%02x %02x %02x %02x %02x %02x",io_data[0],io_data[1],io_data[2],io_data[3],io_data[4],io_data[5]);
-	int i;
 
-	for(i=0;i<16;i++)
-		draw_led(bitmap,  (i*8)+2, 100, state->m_led[i]);
+/***************************************************************************
 
-	return 0;
-}
+  I/O
 
-static WRITE8_DEVICE_HANDLER( test0_w )
+***************************************************************************/
+
+static WRITE8_DEVICE_HANDLER( kungfur_output_w )
 {
 	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-	state->m_mux_data = data & 7;	/* multiplexer selector? (00-06) */
 
-	state->m_mux_data|= (data & 0x10)>>1;
-//  printf("%02x MUX W\n",data);
-}
+	// d0-d2: output led7seg
+	static const int lut_digits[24] =
+	{
+		0, 2, 4, 6, 9, 12,14,0,
+		0, 1, 3, 5, 8, 11,13,0,
+		0, 0, 0, 0, 7, 10,0, 0
+	};
+	for (int i = 0; i < 3; i++)
+	{
+		int offs = i << 3 | (data & 7);
+		if (lut_digits[offs])
+			output_set_digit_value(lut_digits[offs] - 1, state->m_latch[i]);
+	}
 
-static WRITE8_DEVICE_HANDLER( test1_w )
-{
-//  io_data[1] = data;  /* the whole port should be NULL */
-//  printf("%02x Unk 1 W\n",data);
+	// 2.6 goes to level lamps
+	if ((data & 7) == 6)
+	{
+		for (int i = 0; i < 5; i++)
+			output_set_lamp_value(i, state->m_latch[2] >> i & 1);
+	}
+
+	// d7: game-over lamp, d3-d4: marquee lamps
+	output_set_lamp_value(5, data >> 7 & 1);
+	output_set_lamp_value(6, data >> 3 & 1);
+	output_set_lamp_value(7, data >> 4 & 1);
+
+	// d5: N/C?
+	// d6: coincounter
+	coin_counter_w(device->machine(), 0, data & 0x40);
 }
 
-static WRITE8_DEVICE_HANDLER( test2_w )
+
+// lamp output latches
+static WRITE8_DEVICE_HANDLER( kungfur_latch1_w )
 {
 	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-//  io_data[2] = data;  /* lower nibble should be NULL */
-	state->m_led[state->m_mux_data] = data;
-//  printf("%02x Unk 2 W\n",data);
+	state->m_latch[0] = data;
 }
 
-static WRITE8_DEVICE_HANDLER( test3_w )
+static WRITE8_DEVICE_HANDLER( kungfur_latch2_w )
 {
-//  io_data[3] = data;
-//  printf("%02x Unk 3 W\n",data);
+	kungfur_state *state = device->machine().driver_data<kungfur_state>();
+	state->m_latch[1] = data;
 }
 
-/*mux is always 0*/
-static WRITE8_DEVICE_HANDLER( test4_w )
+static WRITE8_DEVICE_HANDLER( kungfur_latch3_w )
 {
 	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-//  io_data[4] = data;
-	state->m_led[state->m_mux_data] = data;
+	state->m_latch[2] = data;
 }
 
-/* this looks like lamps. */
-static WRITE8_DEVICE_HANDLER( test5_w )
+
+static WRITE8_DEVICE_HANDLER( kungfur_control_w )
 {
-//  io_data[5] = data;
-//  printf("%02x Unk 5 W\n",data);
-}
+	kungfur_state *state = device->machine().driver_data<kungfur_state>();
+
+	// d0-d3: N/C
+	// d4: irq ack
+	if (~data & 0x10)
+		cputag_set_input_line(device->machine(), "maincpu", M6809_IRQ_LINE, CLEAR_LINE);
+
+	// d5: ?
+	// d6-d7: sound trigger (edge)
+	if ((data ^ state->m_control) & 0x40)
+	{
+		msm5205_reset_w(device->machine().device("adpcm1"), data >> 6 & 1);
+		state->m_adpcm_pos[0] = state->m_adpcm_data[0] * 0x400;
+		state->m_adpcm_sel[0] = 0;
+	}
+	if ((data ^ state->m_control) & 0x80)
+	{
+		msm5205_reset_w(device->machine().device("adpcm2"), data >> 7 & 1);
+		state->m_adpcm_pos[1] = state->m_adpcm_data[1] * 0x400;
+		state->m_adpcm_sel[1] = 0;
+	}
 
+	state->m_control = data;
+}
 
+// adpcm latches
 static WRITE8_DEVICE_HANDLER( kungfur_adpcm1_w )
 {
 	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-	state->m_adpcm_pos[0] = 0x40000+(data & 0xff) * 0x100;
-	state->m_adpcm_idle[0] = 0;
-	msm5205_reset_w(device->machine().device("adpcm1"),0);
+	state->m_adpcm_data[0] = data;
 }
 
 static WRITE8_DEVICE_HANDLER( kungfur_adpcm2_w )
 {
 	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-	state->m_adpcm_pos[1] = (data & 0xff) * 0x400;
-	state->m_adpcm_idle[1] = 0;
-	msm5205_reset_w(device->machine().device("adpcm2"),0);
+	state->m_adpcm_data[1] = data;
+}
+
+// adpcm callbacks
+static void kfr_adpcm1_int(device_t *device)
+{
+	kungfur_state *state = device->machine().driver_data<kungfur_state>();
+	UINT8 *ROM = device->machine().region("adpcm1")->base();
+	UINT8 data = ROM[state->m_adpcm_pos[0] & 0x1ffff];
+
+	msm5205_data_w(device, state->m_adpcm_sel[0] ? data & 0xf : data >> 4 & 0xf);
+	state->m_adpcm_pos[0] += state->m_adpcm_sel[0];
+	state->m_adpcm_sel[0] ^= 1;
 }
 
-/*
+static void kfr_adpcm2_int(device_t *device)
+{
+	kungfur_state *state = device->machine().driver_data<kungfur_state>();
+	UINT8 *ROM = device->machine().region("adpcm2")->base();
+	UINT8 data = ROM[state->m_adpcm_pos[1] & 0x3ffff];
+
+	msm5205_data_w(device, state->m_adpcm_sel[1] ? data & 0xf : data >> 4 & 0xf);
+	state->m_adpcm_pos[1] += state->m_adpcm_sel[1];
+	state->m_adpcm_sel[1] ^= 1;
+}
 
-  0000-07FF  ; RW ; Working RAM.
-  4000-4000  ;  W ; M5205?
-  4004-4004  ;  W ; M5205?
-  4008-400B  ; RW ; PPI8255_0. PPI mode 0 - Ports B & lower C as Input.
-  400C-400F  ;  W ; PPI8255_1. PPI mode 0 - All ports as output.
-  C000-FFFF  ; R  ; ROM space.
 
-*/
 static ADDRESS_MAP_START( kungfur_map, AS_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x07ff) AM_RAM
 	AM_RANGE(0x4000, 0x4000) AM_DEVWRITE("adpcm1", kungfur_adpcm1_w)
@@ -211,181 +221,123 @@
 ADDRESS_MAP_END
 
 
-static INPUT_PORTS_START( kungfur )
+/***************************************************************************
+
+  Inputs
+
+***************************************************************************/
 
+static INPUT_PORTS_START( kungfur )
 	PORT_START("IN0")
-	PORT_DIPNAME( 0x01, 0x01, "SYSTEM" )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_16WAY PORT_NAME("Migi (Right)")
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_16WAY PORT_NAME("Hidari (Left)")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN  ) PORT_16WAY PORT_NAME("Ushiro (Back)")
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_UP    ) PORT_16WAY PORT_NAME("Mae (Front)")
 
 	PORT_START("IN1")
-	PORT_DIPNAME( 0x01, 0x01, "SYSTEM" )
-	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coinage ) )
+	PORT_DIPSETTING( 0x05, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING( 0x06, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING( 0x07, DEF_STR( 1C_1C ) )
+	PORT_DIPSETTING( 0x03, DEF_STR( 1C_2C ) )
+//  PORT_DIPSETTING( 0x01, DEF_STR( 1C_2C ) ) // dupe
+	PORT_DIPSETTING( 0x02, DEF_STR( 1C_3C ) )
+//  PORT_DIPSETTING( 0x00, DEF_STR( 1C_3C ) ) // dupe
+//  PORT_DIPSETTING( 0x04, DEF_STR( 0C_0C ) ) // invalid
+	PORT_SERVICE( 0x08, IP_ACTIVE_LOW )
 	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
-
 INPUT_PORTS_END
 
-static const ppi8255_interface ppi8255_intf[2] =
-/* Unused ports are still hooked for a easy visibility of the port writes */
-{
-	{/* PPI mode 0 - ports B & lower C as Input - (4008) */
-		DEVCB_NULL,						/* Port A read */
-		DEVCB_INPUT_PORT("IN0"),		/* Port B read */
-		DEVCB_INPUT_PORT("IN1"),		/* Port C (lower) read */
-		DEVCB_HANDLER(test0_w),			/* Port A write */
-		DEVCB_HANDLER(test1_w),			/* Port B write */
-		DEVCB_HANDLER(test2_w)			/* Port C (higher) write */
-	},
-	{/* PPI mode 0 - All ports as output - (400c) */
-		DEVCB_NULL,						/* Port A read */
-		DEVCB_NULL,						/* Port B read */
-		DEVCB_NULL,						/* Port C read */
-		DEVCB_HANDLER(test3_w),			/* Port A write */
-		DEVCB_HANDLER(test4_w),			/* Port B write */
-		DEVCB_HANDLER(test5_w)			/* Port C write */
-	}
-};
 
-static void kfr_adpcm1_int(device_t *device)
-{
-	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-
-	if (state->m_adpcm_pos[0] >= 0x40000 || state->m_adpcm_idle[0])
-	{
-		msm5205_reset_w(device->machine().device("adpcm1"),1);
-		state->m_trigger1 = 0;
-	}
-	else
-	{
-		UINT8 *ROM = device->machine().region("adpcm1")->base();
+/***************************************************************************
 
-		state->m_adpcm_data1 = ((state->m_trigger1 ? (ROM[state->m_adpcm_pos[0]] & 0x0f) : (ROM[state->m_adpcm_pos[0]] & 0xf0)>>4) );
-		msm5205_data_w(device->machine().device("adpcm1"), state->m_adpcm_data1 & 0xf);
-		state->m_trigger1 ^= 1;
-		if(state->m_trigger1 == 0)
-		{
-			state->m_adpcm_pos[0]++;
-			if((ROM[state->m_adpcm_pos[0]] & 0xff) == 0xff)
-				state->m_adpcm_idle[0] = 1;
-		}
-	}
-}
+  Machine Config
 
+***************************************************************************/
 
-static void kfr_adpcm2_int(device_t *device)
+static const ppi8255_interface ppi8255_intf[2] =
 {
-	kungfur_state *state = device->machine().driver_data<kungfur_state>();
-
-	if (state->m_adpcm_pos[1] >= 0x10000 || state->m_adpcm_idle[1])
+	// $4008 - always $83 (PPI mode 0, ports B & lower C as input)
 	{
-		msm5205_reset_w(device->machine().device("adpcm2"),1);
-		state->m_trigger2 = 0;
-	}
-	else
+		DEVCB_NULL,
+		DEVCB_INPUT_PORT("IN0"),
+		DEVCB_INPUT_PORT("IN1"),
+		DEVCB_HANDLER(kungfur_output_w),
+		DEVCB_NULL,
+		DEVCB_HANDLER(kungfur_control_w)
+	},
+	// $400c - always $80 (PPI mode 0, all ports as output)
 	{
-		UINT8 *ROM = device->machine().region("adpcm2")->base();
-
-		state->m_adpcm_data2 = ((state->m_trigger2 ? (ROM[state->m_adpcm_pos[1]] & 0x0f) : (ROM[state->m_adpcm_pos[1]] & 0xf0)>>4) );
-		msm5205_data_w(device->machine().device("adpcm2"), state->m_adpcm_data2 & 0xf);
-		state->m_trigger2 ^= 1;
-		if(state->m_trigger2 == 0)
-		{
-			state->m_adpcm_pos[1]++;
-			if((ROM[state->m_adpcm_pos[1]] & 0xff) == 0xff)
-				state->m_adpcm_idle[1] = 1;
-		}
+		DEVCB_NULL,
+		DEVCB_NULL,
+		DEVCB_NULL,
+		DEVCB_HANDLER(kungfur_latch1_w),
+		DEVCB_HANDLER(kungfur_latch2_w),
+		DEVCB_HANDLER(kungfur_latch3_w)
 	}
-}
+};
 
 static const msm5205_interface msm5205_config_1 =
 {
-	kfr_adpcm1_int,	/* interrupt function */
-	MSM5205_S48_4B	/* 8kHz */
+	kfr_adpcm1_int,
+	MSM5205_S48_4B
 };
 
 static const msm5205_interface msm5205_config_2 =
 {
-	kfr_adpcm2_int,	/* interrupt function */
-	MSM5205_S48_4B	/* 8kHz */
+	kfr_adpcm2_int,
+	MSM5205_S48_4B
 };
 
-static MACHINE_RESET( kungfur )
+static MACHINE_START( kungfur )
 {
 	kungfur_state *state = machine.driver_data<kungfur_state>();
-	state->m_adpcm_pos[0] =	state->m_adpcm_pos[1] = 0;
-	state->m_adpcm_idle[0] = state->m_adpcm_idle[1] = 1;
+
+	state->save_item(NAME(state->m_control));
+	state->save_item(NAME(state->m_latch));
+
+	state->save_item(NAME(state->m_adpcm_pos));
+	state->save_item(NAME(state->m_adpcm_data));
+	state->save_item(NAME(state->m_adpcm_sel));
 }
 
-static INTERRUPT_GEN( kungfur_irq )
+static MACHINE_RESET( kungfur )
 {
-	cputag_set_input_line(device->machine(), "maincpu", M6809_IRQ_LINE, HOLD_LINE);
+	kungfur_state *state = machine.driver_data<kungfur_state>();
+	state->m_control = 0;
 }
 
 static MACHINE_CONFIG_START( kungfur, kungfur_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu",M6809,8000000/2)
+	MCFG_CPU_ADD("maincpu", M6809, 8000000/2)	// 4MHz?
 	MCFG_CPU_PROGRAM_MAP(kungfur_map)
-	MCFG_CPU_VBLANK_INT("screen",kungfur_irq)
+	MCFG_CPU_PERIODIC_INT(kungfur_irq, 975)		// close approximation
 
 	MCFG_PPI8255_ADD( "ppi8255_0", ppi8255_intf[0] )
 	MCFG_PPI8255_ADD( "ppi8255_1", ppi8255_intf[1] )
 
-	MCFG_MACHINE_RESET( kungfur )
+	MCFG_MACHINE_START(kungfur)
+	MCFG_MACHINE_RESET(kungfur)
 
-	/* video hardware */
-	MCFG_SCREEN_ADD("screen", RASTER)
-	MCFG_SCREEN_REFRESH_RATE(60)
-	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
-	MCFG_SCREEN_SIZE(32*8, 32*8)
-	MCFG_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
-	MCFG_SCREEN_UPDATE_STATIC(kungfur)
-	MCFG_PALETTE_LENGTH(512)
-
-	MCFG_VIDEO_START(kungfur)
+	/* no video! */
 
 	/* sound hardware */
-	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("adpcm1", MSM5205, 400000)
+	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
+	MCFG_SOUND_ADD("adpcm1", MSM5205, XTAL_384kHz)	// clock verified with recording
 	MCFG_SOUND_CONFIG(msm5205_config_1)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 1.0)
 
-	MCFG_SOUND_ADD("adpcm2", MSM5205, 400000)
+	MCFG_SOUND_ADD("adpcm2", MSM5205, XTAL_384kHz)	// "
 	MCFG_SOUND_CONFIG(msm5205_config_2)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 1.0)
 MACHINE_CONFIG_END
 
+
 /***************************************************************************
 
   Game driver(s)
@@ -394,16 +346,16 @@
 
 ROM_START( kungfur )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "kr1.bin",   0xc000, 0x4000, CRC(f5b93cc7) SHA1(ed962915aeafea823a6562e6f284a88422f09a08) )
+	ROM_LOAD( "kr1.bin",   0x0c000, 0x04000, CRC(f5b93cc7) SHA1(ed962915aeafea823a6562e6f284a88422f09a08) )
 
-	ROM_REGION( 0x40000, "adpcm1", 0 )
+	ROM_REGION( 0x20000, "adpcm1", 0 )
 	ROM_LOAD( "kr2.bin",   0x00000, 0x10000, CRC(13f5eba8) SHA1(a3ae2d54ec60d48bfff6192e61033ec583e3603f) )
 	ROM_LOAD( "kr3.bin",   0x10000, 0x10000, CRC(05fd1301) SHA1(6871d872315ffb025fea7d2ccd9a203863dc142d) )
-	ROM_LOAD( "kr4.bin",   0x20000, 0x10000, CRC(58929279) SHA1(d90f68dd8cf2ddc5e73ed40eb31ebbb0be7e35a4) )
-	ROM_LOAD( "kr5.bin",   0x30000, 0x10000, CRC(31ed39c8) SHA1(8da50b2183a287fe3a41ec13078aff7fb40c43a3) )
 
-	ROM_REGION( 0x10000, "adpcm2", 0 )
-	ROM_LOAD( "kr6.bin",   0x00000, 0x10000, CRC(9ea75d4a) SHA1(57445ccb961acb11a25cdac81f2e543d92bcb7f9) )
+	ROM_REGION( 0x40000, "adpcm2", 0 )
+	ROM_LOAD( "kr4.bin",   0x00000, 0x10000, CRC(58929279) SHA1(d90f68dd8cf2ddc5e73ed40eb31ebbb0be7e35a4) )
+	ROM_LOAD( "kr5.bin",   0x10000, 0x10000, CRC(31ed39c8) SHA1(8da50b2183a287fe3a41ec13078aff7fb40c43a3) )
+	ROM_LOAD( "kr6.bin",   0x20000, 0x10000, CRC(9ea75d4a) SHA1(57445ccb961acb11a25cdac81f2e543d92bcb7f9) )
 ROM_END
 
-GAME( 1987, kungfur,  0,       kungfur,  kungfur,  0, ROT0, "Namco", "Kung Fu Roushi", GAME_NOT_WORKING | GAME_MECHANICAL)
+GAMEL(1987, kungfur,  0,       kungfur,  kungfur,  0, ROT0, "Namco", "Kung-Fu Roushi", GAME_SUPPORTS_SAVE, layout_kungfur )
diff -Nru src-old/mame/drivers/lasso.c src/mame/drivers/lasso.c
--- src-old/mame/drivers/lasso.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/lasso.c	2012-02-11 11:01:01.000000000 +0100
@@ -51,7 +51,7 @@
 {
 	lasso_state *state = space->machine().driver_data<lasso_state>();
 	soundlatch_w(space, offset, data);
-	generic_pulse_irq_line(state->m_audiocpu, 0);
+	generic_pulse_irq_line(state->m_audiocpu, 0, 1);
 }
 
 static WRITE8_HANDLER( pinbo_sound_command_w )
diff -Nru src-old/mame/drivers/m10.c src/mame/drivers/m10.c
--- src-old/mame/drivers/m10.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/m10.c	2012-02-19 02:53:16.000000000 +0100
@@ -199,7 +199,7 @@
 	state->m_maincpu = machine.device("maincpu");
 	state->m_ic8j1 = machine.device("ic8j1");
 	state->m_ic8j2 = machine.device("ic8j2");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->save_item(NAME(state->m_bottomline));
 	state->save_item(NAME(state->m_flip));
@@ -266,27 +266,27 @@
 			break;
 		case 0x01:
 			/* MISSILE sound */
-			sample_start(state->m_samples, 0, 0, 0);
+			state->m_samples->start(0, 0);
 			break;
 		case 0x02:
 			/* EXPLOSION sound */
-			sample_start(state->m_samples, 1, 1, 0);
+			state->m_samples->start(1, 1);
 			break;
 		case 0x03:
 			/* INVADER HIT sound */
-			sample_start(state->m_samples, 2, 2, 0);
+			state->m_samples->start(2, 2);
 			break;
 		case 0x04:
 			/* BONUS BASE sound */
-			sample_start(state->m_samples, 3, 8, 0);
+			state->m_samples->start(3, 8);
 			break;
 		case 0x05:
 			/* FLEET MOVE sound */
-			sample_start(state->m_samples, 3, 3, 0);
+			state->m_samples->start(3, 3);
 			break;
 		case 0x06:
 			/* SAUCER HIT SOUND */
-			sample_start(state->m_samples, 2, 7, 0);
+			state->m_samples->start(2, 7);
 			break;
 		default:
 			popmessage("Unknown sound M10: %02x\n", data & 0x07);
@@ -294,9 +294,9 @@
 	}
 	/* UFO SOUND */
 	if (data & 0x08)
-		sample_stop(state->m_samples, 4);
+		state->m_samples->stop(4);
 	else
-		sample_start(state->m_samples, 4, 9, 1);
+		state->m_samples->start(4, 9, true);
 
 }
 
@@ -403,21 +403,21 @@
 	// audio control!
 	/* MISSILE sound */
 	if (raising_bits & 0x01)
-		sample_start(state->m_samples, 0, 0, 0);
+		state->m_samples->start(0, 0);
 
 	/* EXPLOSION sound */
 	if (raising_bits & 0x02)
-		sample_start(state->m_samples, 1, 1, 0);
+		state->m_samples->start(1, 1);
 
 	/* Rapidly falling parachute */
 	if (raising_bits & 0x04)
-		sample_start(state->m_samples, 3, 8, 0);
+		state->m_samples->start(3, 8);
 
 	/* Background sound ? */
 	if (data & 0x10)
-		sample_start(state->m_samples, 4, 9, 1);
+		state->m_samples->start(4, 9, true);
 	else
-		sample_stop(state->m_samples, 4);
+		state->m_samples->stop(4);
 
 }
 
@@ -446,34 +446,34 @@
 #endif
 	/* DOT sound */
 	if (falling_bits & 0x40)
-		sample_start(state->m_samples, 0, 0, 0);
+		state->m_samples->start(0, 0);
 #if 0
 	if (raising_bits & 0x40)
-		sample_stop(state->m_samples, 0);
+		state->m_samples->stop(0);
 #endif
 
 	/* EXPLOSION sound */
 	if (falling_bits & 0x08)
-		sample_start(state->m_samples, 1, 1, 0);
+		state->m_samples->start(1, 1);
 #if 0
 	if (raising_bits & 0x08)
-		sample_stop(state->m_samples, 1);
+		state->m_samples->stop(1);
 #endif
 
 	/* player changes lane */
 	if (falling_bits & 0x10)
-		sample_start(state->m_samples, 3, 3, 0);
+		state->m_samples->start(3, 3);
 #if 0
 	if (raising_bits & 0x10)
-		sample_stop(state->m_samples, 3);
+		state->m_samples->stop(3);
 #endif
 
 	/* computer car changes lane */
 	if (falling_bits & 0x20)
-		sample_start(state->m_samples, 4, 4, 0);
+		state->m_samples->start(4, 4);
 #if 0
 	if (raising_bits & 0x20)
-		sample_stop(state->m_samples, 4);
+		state->m_samples->stop(4);
 #endif
 
 	state->m_last = data;
@@ -863,8 +863,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(m10_samples_interface)
+	MCFG_SAMPLES_ADD("samples", m10_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 MACHINE_CONFIG_END
@@ -903,8 +902,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(m10_samples_interface)
+	MCFG_SAMPLES_ADD("samples", m10_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/m63.c src/mame/drivers/m63.c
--- src-old/mame/drivers/m63.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/m63.c	2012-02-19 02:53:16.000000000 +0100
@@ -154,7 +154,7 @@
 	device_t *m_soundcpu;
 	device_t *m_ay1;
 	device_t *m_ay2;
-	device_t *m_samples;
+	samples_device *m_samples;
 };
 
 
@@ -433,7 +433,7 @@
 	m63_state *state = space->machine().driver_data<m63_state>();
 
 	if (data & 1)
-		sample_start_raw(state->m_samples, 0, state->m_samplebuf + ((data & 0xf0) << 8), 0x2000, 8000, 0);
+		state->m_samples->start_raw(0, state->m_samplebuf + ((data & 0xf0) << 8), 0x2000, 8000);
 }
 
 static WRITE8_HANDLER( nmi_mask_w )
@@ -687,7 +687,7 @@
 
 static SAMPLES_START( fghtbskt_sh_start )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	m63_state *state = machine.driver_data<m63_state>();
 	int i, len = machine.region("samples")->bytes();
 	UINT8 *ROM = machine.region("samples")->base();
@@ -719,7 +719,7 @@
 	state->m_soundcpu = machine.device("soundcpu");
 	state->m_ay1 = machine.device("ay1");
 	state->m_ay2 = machine.device("ay2");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->save_item(NAME(state->m_pal_bank));
 	state->save_item(NAME(state->m_fg_flag));
@@ -832,8 +832,7 @@
 	MCFG_SOUND_ADD("ay1", AY8910, XTAL_12MHz/8)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(fghtbskt_samples_interface)
+	MCFG_SAMPLES_ADD("samples", fghtbskt_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/m90.c src/mame/drivers/m90.c
--- src-old/mame/drivers/m90.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/m90.c	2012-02-11 11:01:01.000000000 +0100
@@ -696,7 +696,7 @@
 
 static INTERRUPT_GEN( m90_interrupt )
 {
-	generic_pulse_irq_line(device, NEC_INPUT_LINE_INTP0);
+	generic_pulse_irq_line(device, NEC_INPUT_LINE_INTP0, 1);
 }
 
 static INTERRUPT_GEN( dynablsb_interrupt )
diff -Nru src-old/mame/drivers/magicard.c src/mame/drivers/magicard.c
--- src-old/mame/drivers/magicard.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/drivers/magicard.c	2012-02-19 01:27:36.000000000 +0100
@@ -760,7 +760,7 @@
 
 ROM_START( magicardj )
 	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68070 Code & GFX */
-	ROM_LOAD16_WORD_SWAP( "27c4002.ic21", 0x00000, 0x80000, CRC(ab2ed583) SHA1(a2d7148b785a8dfce8cff3b15ada293d65561c98) )
+	ROM_LOAD16_WORD_SWAP( "27c4002j.ic21", 0x00000, 0x80000, CRC(ab2ed583) SHA1(a2d7148b785a8dfce8cff3b15ada293d65561c98) )
 
 	ROM_REGION( 0x0100, "pic16f84", 0 ) /* protected */
 	ROM_LOAD("pic16f84.ic29",	0x0000, 0x0100, BAD_DUMP CRC(0d968558) SHA1(b376885ac8452b6cbf9ced81b1080bfd570d9b91) )
diff -Nru src-old/mame/drivers/marineb.c src/mame/drivers/marineb.c
--- src-old/mame/drivers/marineb.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/marineb.c	2012-02-13 20:39:11.000000000 +0100
@@ -743,9 +743,9 @@
 	ROM_LOAD( "springer.7",    0x1000, 0x1000, CRC(95ab8fc0) SHA1(74dad6fe1edd38b22656cf6cd9e4a57012bf0d60) )
 
 	ROM_REGION( 0x4000, "gfx2", 0 )
-	ROM_LOAD( "springer.8",    0x0000, 0x1000, CRC(a54bafdc) SHA1(70f1a9ab116dc2a195aa9026ed1004101897d274) )
+	ROM_LOAD( "springer.9",    0x0000, 0x1000, CRC(fa302775) SHA1(412afdc620be95e70b3b782d1a08e4a46777e710) )
 							/* 0x1000-0x1fff empty for my convinience */
-	ROM_LOAD( "springer.9",    0x2000, 0x1000, CRC(fa302775) SHA1(412afdc620be95e70b3b782d1a08e4a46777e710) )
+	ROM_LOAD( "springer.8",    0x2000, 0x1000, CRC(a54bafdc) SHA1(70f1a9ab116dc2a195aa9026ed1004101897d274) )
 							/* 0x3000-0x3fff empty for my convinience */
 
 	ROM_REGION( 0x0200, "proms", 0 )
diff -Nru src-old/mame/drivers/maxaflex.c src/mame/drivers/maxaflex.c
--- src-old/mame/drivers/maxaflex.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/maxaflex.c	2012-02-11 11:01:01.000000000 +0100
@@ -178,7 +178,7 @@
 		if ( (state->m_tcr & 0x40) == 0 )
 		{
 			//timer interrupt!
-			generic_pulse_irq_line(timer.machine().device("mcu"), M68705_INT_TIMER);
+			generic_pulse_irq_line(timer.machine().device("mcu"), M68705_INT_TIMER, 1);
 		}
 	}
 }
diff -Nru src-old/mame/drivers/maygayep.c src/mame/drivers/maygayep.c
--- src-old/mame/drivers/maygayep.c	2011-12-23 18:29:55.000000000 +0100
+++ src/mame/drivers/maygayep.c	2012-02-19 02:23:50.000000000 +0100
@@ -4655,8 +4655,8 @@
 
 GAME( 199?, ep_braid	,  0,        maygayep,  maygayep,  0,  ROT0, "Extreme",        "Bank Raid (Extreme) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_bathl	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Bat Outa Hell (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, ep_beavr	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Beaver Las Vegas (Global) (EPOCH, set 1)",        GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, ep_beavra	,  ep_beavr, maygayep,  maygayep,  0,  ROT0, "Global",        "Beaver Las Vegas (Global) (EPOCH, set 2)",        GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, ep_beavr	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Casino Beaver Las Vegas (Global) (EPOCH, set 1)",        GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, ep_beavra	,  ep_beavr, maygayep,  maygayep,  0,  ROT0, "Global",        "Casino Beaver Las Vegas (Global) (EPOCH, set 2)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_bvrcl	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Beaver Las Vegas Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_bvruc	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Beaver Uncovered (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_bjclb	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Blackjack Club, The (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
@@ -4691,7 +4691,7 @@
 GAME( 199?, ep_monrt	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Money Returns Club, The (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_monsh	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "The Moonshine Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_mummy	,  0,        maygayep,  maygayep,  0,  ROT0, "Impulse",        "Mummy Talks (Impulse) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, ep_pkni		,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Phoenix Knights (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, ep_pkni		,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "The Phoenix Knights (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_redl		,  0,        maygayep,  maygayep,  0,  ROT0, "Extreme",        "Red Line (Extreme) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_rchik	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Rich Chics Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_royrc	,  0,        maygayep,  maygayep,  0,  ROT0, "Impulse",        "Royal Roulette Club (Impulse) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
@@ -4708,7 +4708,7 @@
 GAME( 199?, ep_utncl	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Utter Nutter Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_wleek	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Weakest Leek Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_wud		,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "What's Up Doc (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
-GAME( 199?, ep_milhr	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Who Wants To Be A Millionhare (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, ep_milhr	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Who Wants To Be A Millionhare? (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_mlhrc	,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Who Whats To Be A Millionhare Club (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_wf		,  0,        maygayep,  maygayep,  0,  ROT0, "Global",        "Wildfire (Global) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, ep_bbars	,  0,        maygayep,  maygayep,  0,  ROT0, "Maygay",        "Balloon Bars (Maygay) (EPOCH)",        GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/mcr.c src/mame/drivers/mcr.c
--- src-old/mame/drivers/mcr.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/mcr.c	2012-02-19 02:53:16.000000000 +0100
@@ -413,14 +413,14 @@
 
 static WRITE8_HANDLER( journey_op4_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	/* if we're not playing the sample yet, start it */
-	if (!sample_playing(samples, 0))
-		sample_start(samples, 0, 0, 1);
+	if (!samples->playing(0))
+		samples->start(0, 0, true);
 
 	/* bit 0 turns cassette on/off */
-	sample_set_pause(samples, 0, ~data & 1);
+	samples->pause(0, ~data & 1);
 }
 
 
@@ -433,16 +433,16 @@
 
 static WRITE8_HANDLER( twotiger_op4_w )
 {
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	for (int i = 0; i < 2; i++)
 	{
 		/* play tape, and loop it */
-		if (!sample_playing(samples, i))
-			sample_start(samples, i, i, 1);
+		if (!samples->playing(i))
+			samples->start(i, i, true);
 
 		/* bit 1 turns cassette on/off */
-		sample_set_pause(samples, i, ~data & 2);
+		samples->pause(i, ~data & 2);
 	}
 
 	// bit 2: lamp control?
@@ -1660,8 +1660,7 @@
 static MACHINE_CONFIG_DERIVED( mcr_90010_tt, mcr_90010 )
 
 	/* sound hardware */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(twotiger_samples_interface)
+	MCFG_SAMPLES_ADD("samples", twotiger_samples_interface)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.25)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.25)
 MACHINE_CONFIG_END
@@ -1674,8 +1673,7 @@
 	MCFG_PALETTE_LENGTH(128)
 
 	/* sound hardware */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(journey_samples_interface)
+	MCFG_SAMPLES_ADD("samples", journey_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.25)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.25)
 MACHINE_CONFIG_END
@@ -1996,12 +1994,12 @@
 
 ROM_START( tron3 )
 	ROM_REGION( 0x10000, "maincpu", 0 ) /* ROM's located on the Super CPU Board (90010) */
-	ROM_LOAD( "scpu_pga.d2", 0x0000, 0x2000, CRC(fc33afd7) SHA1(99a2ed972c3db477f35a7162079563367864f207) )
-	ROM_LOAD( "scpu_pgb.d3", 0x2000, 0x2000, CRC(7d9e22ac) SHA1(16a6e9651d5f764e8762fd8d6e53d13fda7473de) )
-	ROM_LOAD( "scpu_pgc.d4", 0x4000, 0x2000, CRC(902011c6) SHA1(17ac768a0fd1278ae83414f0d67d6ac8337f4773) )
-	ROM_LOAD( "scpu_pgd.d5", 0x6000, 0x2000, CRC(86477e89) SHA1(196f0d3930d10bfe4ddee82ce8b28bb99324069e) )
-	ROM_LOAD( "scpu_pge.d6", 0x8000, 0x2000, CRC(ea198fa8) SHA1(d8c97ea87d504e77edc38c87c2953c8c4f1a405b) )
-	ROM_LOAD( "scpu_pgf.d7", 0xa000, 0x2000, CRC(4325fb08) SHA1(70727aa37354425315d8a8b3ca07bbe91f7e8f08) )
+	ROM_LOAD( "scpu_pga_3.d2", 0x0000, 0x2000, CRC(fc33afd7) SHA1(99a2ed972c3db477f35a7162079563367864f207) )
+	ROM_LOAD( "scpu_pgb_3.d3", 0x2000, 0x2000, CRC(7d9e22ac) SHA1(16a6e9651d5f764e8762fd8d6e53d13fda7473de) )
+	ROM_LOAD( "scpu_pgc_3.d4", 0x4000, 0x2000, CRC(902011c6) SHA1(17ac768a0fd1278ae83414f0d67d6ac8337f4773) )
+	ROM_LOAD( "scpu_pgd_3.d5", 0x6000, 0x2000, CRC(86477e89) SHA1(196f0d3930d10bfe4ddee82ce8b28bb99324069e) )
+	ROM_LOAD( "scpu_pge_3.d6", 0x8000, 0x2000, CRC(ea198fa8) SHA1(d8c97ea87d504e77edc38c87c2953c8c4f1a405b) )
+	ROM_LOAD( "scpu_pgf_3.d7", 0xa000, 0x2000, CRC(4325fb08) SHA1(70727aa37354425315d8a8b3ca07bbe91f7e8f08) )
 
 	ROM_REGION( 0x10000, "ssiocpu", 0 ) /* ROM's located on the Super Sound I/O Board (90913) */
 	ROM_LOAD( "ssi_0a.a7",   0x0000, 0x1000, CRC(765e6eba) SHA1(42efeefc8571dfc237c0be3368248f1e56add92e) )
diff -Nru src-old/mame/drivers/meadows.c src/mame/drivers/meadows.c
--- src-old/mame/drivers/meadows.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/meadows.c	2012-02-19 02:53:16.000000000 +0100
@@ -675,8 +675,7 @@
 	MCFG_SOUND_ADD("dac", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(meadows_samples_interface)
+	MCFG_SAMPLES_ADD("samples", meadows_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
@@ -737,13 +736,11 @@
 	MCFG_SOUND_ADD("dac", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(meadows_samples_interface)
+	MCFG_SAMPLES_ADD("samples", meadows_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
 	/* audio hardware */
-	MCFG_SOUND_ADD("samples2", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(bowl3d_samples_interface)
+	MCFG_SAMPLES_ADD("samples2", bowl3d_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/drivers/mediagx.c	2012-02-09 11:27:12.000000000 +0100
@@ -1147,7 +1147,7 @@
 
 	MCFG_PIC8259_ADD( "pic8259_slave", mediagx_pic8259_2_config )
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	MCFG_TIMER_ADD("sound_timer", sound_timer_callback)
 
@@ -1326,7 +1326,7 @@
 	ROM_REGION(0x08100, "gfx1", 0)
 	ROM_LOAD("cga.chr",     0x00000, 0x01000, CRC(42009069) SHA1(ed08559ce2d7f97f68b9f540bddad5b6295294dd))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a51site4", 0, SHA1(48496666d1613700ae9274f9a5361ea5bbaebea0) )
 ROM_END
 
diff -Nru src-old/mame/drivers/megatech.c src/mame/drivers/megatech.c
--- src-old/mame/drivers/megatech.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/megatech.c	2012-02-09 13:08:07.000000000 +0100
@@ -517,14 +517,14 @@
 // we keep old region tags for compatibility with older macros... this might be changed at a later stage
 static const struct megatech_cart_region megatech_cart_table[] =
 {
-	{ "cart1", 0, "game0" },
-	{ "cart2", 1, "game1" },
-	{ "cart3", 2, "game2" },
-	{ "cart4", 3, "game3" },
-	{ "cart5", 4, "game4" },
-	{ "cart6", 5, "game5" },
-	{ "cart7", 6, "game6" },
-	{ "cart8", 7, "game7" },
+	{ ":cart1", 0, "game0" },
+	{ ":cart2", 1, "game1" },
+	{ ":cart3", 2, "game2" },
+	{ ":cart4", 3, "game3" },
+	{ ":cart5", 4, "game4" },
+	{ ":cart6", 5, "game5" },
+	{ ":cart7", 6, "game6" },
+	{ ":cart8", 7, "game7" },
 	{ 0 }
 };
 
diff -Nru src-old/mame/drivers/meritm.c src/mame/drivers/meritm.c
--- src-old/mame/drivers/meritm.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/meritm.c	2012-02-19 01:27:36.000000000 +0100
@@ -1578,8 +1578,8 @@
 	ROM_RELOAD(                     0x380000, 0x80000)
 
 	ROM_REGION( 0x1000, "user2", 0 ) // PALs
-	ROM_LOAD( "sc3943.u20",     0x000, 0x117, CRC(f31864ff) SHA1(ff44820379a350e7bd788ffb6926612b3483e114) )
-	ROM_LOAD( "sc3944-0a.u19",  0x000, 0x2dd, CRC(ad4fddaa) SHA1(10c1575dcaa5ca4af5dc630d84f43a9ed1cb3ace) )
+	ROM_LOAD( "super_sc3943.u20",     0x000, 0x117, CRC(f31864ff) SHA1(ff44820379a350e7bd788ffb6926612b3483e114) )
+	ROM_LOAD( "super_sc3944-0a.u19",  0x000, 0x2dd, CRC(ad4fddaa) SHA1(10c1575dcaa5ca4af5dc630d84f43a9ed1cb3ace) )
 	ROM_LOAD( "sc3980.u40",     0x000, 0x117, CRC(ee0cdab5) SHA1(216fef50a8a0f6a33b704d3501a4c5c3cbac2bad) )
 	ROM_LOAD( "sc3981-0a.u51",  0x000, 0x117, CRC(4fc750d0) SHA1(d09ff7a8c66aeb5c49e9fec84bd1521e3f5d8d0a) )
 ROM_END
diff -Nru src-old/mame/drivers/mgolf.c src/mame/drivers/mgolf.c
--- src-old/mame/drivers/mgolf.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/mgolf.c	2012-02-11 11:01:01.000000000 +0100
@@ -112,7 +112,7 @@
 
 	update_plunger(machine);
 
-	generic_pulse_irq_line(state->m_maincpu, 0);
+	generic_pulse_irq_line(state->m_maincpu, 0, 1);
 
 	scanline = scanline + 32;
 
diff -Nru src-old/mame/drivers/midqslvr.c src/mame/drivers/midqslvr.c
--- src-old/mame/drivers/midqslvr.c	2012-02-05 15:12:57.000000000 +0100
+++ src/mame/drivers/midqslvr.c	2012-02-09 11:27:12.000000000 +0100
@@ -716,7 +716,7 @@
 	MCFG_PCI_BUS_DEVICE( 0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
 	MCFG_PCI_BUS_DEVICE(31, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
@@ -731,7 +731,7 @@
 //  ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 //  ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "disk" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "offrthnd", 0, SHA1(d88f1c5b75361a1e310565a8a5a09c674a4a1a22) )
 ROM_END
 
@@ -743,7 +743,7 @@
 //  ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 //  ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "disk" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "hydro", 0,  SHA1(d481d178782943c066b41764628a419cd55f676d) )
 ROM_END
 
@@ -755,7 +755,7 @@
 //  ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 //  ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "disk" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "arctthnd", 0,  SHA1(f4373e57c3f453ac09c735b5d8d99ff811416a23) )
 ROM_END
 
@@ -768,7 +768,7 @@
 //  ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 //  ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "disk" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "uarctict", 0, SHA1(8557a1d7ae8dc41c879350cb1c228f4c27a0dd09) )
 ROM_END
 
diff -Nru src-old/mame/drivers/midvunit.c src/mame/drivers/midvunit.c
--- src-old/mame/drivers/midvunit.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/midvunit.c	2012-02-09 11:27:12.000000000 +0100
@@ -1057,7 +1057,7 @@
 	MCFG_DEVICE_REMOVE("nvram")
 	MCFG_NVRAM_HANDLER(midway_serial_pic2)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", NULL)
+	MCFG_IDE_CONTROLLER_ADD("ide", NULL, ide_devices, "hdd", NULL)
 
 	/* sound hardware */
 	MCFG_FRAGMENT_ADD(dcs2_audio_2115)
@@ -1618,7 +1618,7 @@
 	ROM_REGION32_LE( 0x1000000, "user1", 0 )
 	ROM_LOAD( "u41.rom", 0x000000, 0x20000, CRC(398c54cc) SHA1(6c4b5d6ec5c844dcbf181f9d86a9196a088ed2db) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "wargods", 0, SHA1(141063f95867fdcc4b15c844e510696604a70c6a) )
 ROM_END
 
diff -Nru src-old/mame/drivers/mil4000.c src/mame/drivers/mil4000.c
--- src-old/mame/drivers/mil4000.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/mil4000.c	2012-02-19 01:27:36.000000000 +0100
@@ -436,8 +436,8 @@
 
 ROM_START( mil4000b )
 	ROM_REGION( 0x100000, "maincpu", 0 ) // 68000 code
-	ROM_LOAD16_BYTE( "27.u75", 0x000001, 0x20000, CRC(a5ca8a1e) SHA1(c42244e27031175c37e83995f548d960708eabab) )
-	ROM_LOAD16_BYTE( "28.u76", 0x000000, 0x20000, CRC(5bf4e681) SHA1(818d0ec1b2cc544334b0349ae15fd53ff32ef8c1) )
+	ROM_LOAD16_BYTE( "b27.u75", 0x000001, 0x20000, CRC(a5ca8a1e) SHA1(c42244e27031175c37e83995f548d960708eabab) )
+	ROM_LOAD16_BYTE( "b28.u76", 0x000000, 0x20000, CRC(5bf4e681) SHA1(818d0ec1b2cc544334b0349ae15fd53ff32ef8c1) )
 
 	ROM_REGION( 0xa0000, "gfx1", 0 ) // 5bpp?
 	ROM_LOAD( "2.u36",   0x000000, 0x20000, CRC(bb4fcfde) SHA1(7e19722ce42b9ec86faac32a526429b0e56639b5) )
diff -Nru src-old/mame/drivers/model2.c src/mame/drivers/model2.c
--- src-old/mame/drivers/model2.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/model2.c	2012-02-14 02:30:42.000000000 +0100
@@ -27,7 +27,7 @@
     srallyc
     skytargt
     dynamcop
-    dynabb
+    dynabb97
     lastbrnj/lastbrnx
     skisuprg
 
@@ -4297,7 +4297,6 @@
 	ROM_LOAD("mpr-19750.24s", 0xc00000, 0x400000, CRC(cd95d0bf) SHA1(40e2a2980c89049c339fefd48bf7aac79962cd2e) )
 ROM_END
 
-
 ROM_START( doaa ) /* Dead or Alive Revision A, Model 2A */
 	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
 	ROM_LOAD32_WORD("epr-19310a.12", 0x000000, 0x080000, CRC(06486f7a) SHA1(b3e14103570e5f45aed16e1c158e469bc85002ae) )
@@ -4454,7 +4453,6 @@
 	ROM_LOAD("mpr-18653.34", 0x400000, 0x400000, CRC(9ec3e7bf) SHA1(197bc8adc823e93128c1cebf69361a7c7297f808))
 ROM_END
 
-
 ROM_START( vonj ) /* Virtual On Cyber Troopers Revision B (Japan), Model 2B */
 	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
 	ROM_LOAD32_WORD("epr-18664b.15", 0x000000, 0x080000, CRC(27d0172c) SHA1(f3bcae9898c7d656eccb4d2546c9bb93daaefbb7) )
@@ -4567,7 +4565,43 @@
 	ROM_LOAD("mpr-18065.34", 0x400000, 0x200000, CRC(046b55fe) SHA1(2db7eabf4318881a67b10dba24f6f0cd68940ace) )
 ROM_END
 
-ROM_START( dynabb ) /* Dynamite Baseball '97 Revision A, Model 2B */
+ROM_START( dynabb ) /* Dynamite Baseball, Model 2B */
+	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
+	ROM_LOAD32_WORD("epr-19170.15", 0x000000, 0x080000, CRC(e00eb49e) SHA1(20975d892cf1c9f50605238d6ab41d79ece39f69) )
+	ROM_LOAD32_WORD("epr-19171.16", 0x000002, 0x080000, CRC(9878d67d) SHA1(d3350546b7e0e6fe8bb2f9d1a91475655f931b8b) )
+	ROM_LOAD32_WORD("epr-19168.13", 0x100000, 0x080000, CRC(041da66b) SHA1(4a58153baf5f0b34e054bf23e519edcf364a9336) )
+	ROM_LOAD32_WORD("epr-19169.14", 0x100002, 0x080000, CRC(91a5acef) SHA1(2520a3e4ff15e4d583861ba656570abca5f7c611) )
+
+	ROM_REGION32_LE( 0x2000000, "user1", 0 ) // Data
+	ROM_LOAD32_WORD("mpr-19178.11", 0x0000000, 0x400000, CRC(0d621e21) SHA1(31adc229258a5d468ff80d789c59bd8a6777f900) )
+	ROM_LOAD32_WORD("mpr-19179.12", 0x0000002, 0x400000, CRC(337a4ec2) SHA1(77d7d186344715237895ac1ed0ab219fcc340a7e) )
+	ROM_LOAD32_WORD("mpr-19176.9",  0x0800000, 0x400000, CRC(2c4e90f5) SHA1(8d5ed0b26e79dd6476282bc69cb27b42381635f2) )
+	ROM_LOAD32_WORD("mpr-19177.10", 0x0800002, 0x400000, CRC(b0f1e512) SHA1(81e4124ac7766c7ea6bac7e7f4db110783394ae3) )
+	ROM_LOAD32_WORD("mpr-19174.7",  0x1000000, 0x400000, CRC(057e5200) SHA1(dd07eb438d91a8132789154a633fb6ec4e2ef0d1) )
+	ROM_LOAD32_WORD("mpr-19175.8",  0x1000002, 0x400000, CRC(85254156) SHA1(aae9531980d1b394d86e285c00c7384601875470) )
+	ROM_LOAD32_WORD("mpr-19172.5",  0x1800000, 0x400000, CRC(9214aaaf) SHA1(769ad943ca90f0f3cc81f00e7a8cca95c660d266) )
+	ROM_LOAD32_WORD("mpr-19173.6",  0x1800002, 0x400000, CRC(31adbeed) SHA1(3984be892f0dce21c8d423dda055ef7e57df4d4e) )
+
+	ROM_REGION( 0x800000, "user2", 0 ) // Models
+	ROM_LOAD32_WORD("mpr-19180.17", 0x000000, 0x400000, CRC(d2e311a5) SHA1(83fb31c6ad7c32f1a7bcf870edb2719653c3db97) )
+	ROM_LOAD32_WORD("mpr-19181.21", 0x000002, 0x400000, CRC(09a86c33) SHA1(30601c5b00fa3c9db815f60a0de16576e34b8c42) )
+
+	ROM_REGION( 0x800000, "user3", 0 ) // Textures
+	ROM_LOAD32_WORD("mpr-19183.27", 0x000000, 0x400000, CRC(5e29074b) SHA1(f4dfa396653aeb649ec170c9584ea1a74377929a) )
+	ROM_LOAD32_WORD("mpr-19182.25", 0x000002, 0x400000, CRC(c899923d) SHA1(15cc86c885329227d3c19e9837363eaf6c38829b) )
+
+	ROM_REGION( 0x800000, "user5", ROMREGION_ERASE00 ) // Coprocessor Data ROM
+
+	ROM_REGION( 0x100000, "audiocpu", 0 ) // Sound program
+	ROM_LOAD16_WORD_SWAP("epr-19184.31", 0x080000,  0x80000, CRC(c013a163) SHA1(c564df8295e3c19082ead0eb22478dc651e0b430) )
+
+	ROM_REGION( 0x600000, "scsp", 0 ) // Samples
+	ROM_LOAD("mpr-19185.32", 0x000000, 0x200000, CRC(5175b7d8) SHA1(bed43db286703e95cc8025013b2d129598faab3c) )
+	ROM_LOAD("mpr-19186.33", 0x200000, 0x200000, CRC(f23440b5) SHA1(9bb862d61ed079cb3eb0bd7a37b19c6134859b99) )
+	ROM_LOAD("mpr-19187.34", 0x400000, 0x200000, CRC(20918769) SHA1(90951bd61654d39537c54325b6e157a019edcda8) )
+ROM_END
+
+ROM_START( dynabb97 ) /* Dynamite Baseball 97 Revision A, Model 2B */
 	ROM_REGION( 0x200000, "maincpu", 0 ) // i960 program
 	ROM_LOAD32_WORD("epr-19833a.15", 0x000000, 0x080000, CRC(d99ed1b2) SHA1(b04613d564c04c35feafccad56ed85810d894185) )
 	ROM_LOAD32_WORD("epr-19834a.16", 0x000002, 0x080000, CRC(24192bb1) SHA1(c535ab4b38ffd42f03eed6a5a1706e867eaccd67) )
@@ -4591,8 +4625,8 @@
 	ROM_LOAD32_WORD("mpr-19846.22", 0x800002, 0x400000, CRC(fe53cd17) SHA1(58eab07976972917c345a8d3a50ff1e96e5fa798) )
 
 	ROM_REGION( 0x800000, "user3", 0 ) // Textures
-	ROM_LOAD32_WORD("mpr-19848.27", 0x0000000, 0x400000, CRC(4c0526b7) SHA1(e8db7125be8a052e41a00c69cc08ca0d75b3b96f) )
-	ROM_LOAD32_WORD("mpr-19847.25", 0x0000002, 0x400000, CRC(fe55edbd) SHA1(b0b6135b23349d7d6ae007002d8df83748cab7b1) )
+	ROM_LOAD32_WORD("mpr-19848.27", 0x000000, 0x400000, CRC(4c0526b7) SHA1(e8db7125be8a052e41a00c69cc08ca0d75b3b96f) )
+	ROM_LOAD32_WORD("mpr-19847.25", 0x000002, 0x400000, CRC(fe55edbd) SHA1(b0b6135b23349d7d6ae007002d8df83748cab7b1) )
 
 	ROM_REGION( 0x800000, "user5", ROMREGION_ERASE00 ) // Coprocessor Data ROM
 
@@ -4600,9 +4634,9 @@
 	ROM_LOAD16_WORD_SWAP("epr-19849.31", 0x080000,  0x80000, CRC(b0d5bff0) SHA1(1fb824adaf3ed330a8039be726a87eb85c00abd7) )
 
 	ROM_REGION( 0x800000, "scsp", 0 ) // Samples
-	ROM_LOAD("mpr-19880.32", 0x000000, 0x200000, CRC(e1fd27bf) SHA1(a7189ad398138a91f96b192cb7c112c0301dcda4) )
-	ROM_LOAD("mpr-19850.33", 0x200000, 0x200000, CRC(dc644077) SHA1(8765bdb1d471dbeea065a97ae131f2d8f78aa13d) )
-	ROM_LOAD("mpr-19851.34", 0x400000, 0x200000, CRC(cfda4efd) SHA1(14d55f127da6673c538c2ef9be34a4e02ca449f3) )
+	ROM_LOAD("mpr-19850.32", 0x000000, 0x200000, CRC(e1fd27bf) SHA1(a7189ad398138a91f96b192cb7c112c0301dcda4) )
+	ROM_LOAD("mpr-19851.33", 0x200000, 0x200000, CRC(dc644077) SHA1(8765bdb1d471dbeea065a97ae131f2d8f78aa13d) )
+	ROM_LOAD("mpr-19852.34", 0x400000, 0x200000, CRC(cfda4efd) SHA1(14d55f127da6673c538c2ef9be34a4e02ca449f3) )
 	ROM_LOAD("mpr-19853.35", 0x600000, 0x200000, CRC(cfc64857) SHA1(cf51fafb3d45bf799b9ccb407bee862e15c95981) )
 ROM_END
 
@@ -5221,7 +5255,8 @@
 GAME( 1996, sgt24h,          0, model2b, srallyc, sgt24h, ROT0, "Jaleco", "Super GT 24h", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, von,             0, model2b, model2, 0,       ROT0, "Sega", "Virtual On Cyber Troopers (US, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1996, vonj,          von, model2b, model2, 0,       ROT0, "Sega", "Virtual On Cyber Troopers (Japan, Revision B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1997, dynabb,          0, model2b, model2, 0,       ROT0, "Sega", "Dynamite Baseball '97 (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1996, dynabb,          0, model2b, model2, 0,       ROT0, "Sega", "Dynamite Baseball", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+GAME( 1997, dynabb97,        0, model2b, model2, 0,       ROT0, "Sega", "Dynamite Baseball 97 (Revision A)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, zerogun,         0, model2b, model2, zerogun, ROT0, "Psikyo", "Zero Gunner (Export, Model 2B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1997, zerogunj,  zerogun, model2b, model2, zerogun, ROT0, "Psikyo", "Zero Gunner (Japan, Model 2B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
 GAME( 1998, dynamcopb,dynamcop, model2b, model2, genprot, ROT0, "Sega", "Dynamite Cop (Export, Model 2B)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/moo.c src/mame/drivers/moo.c
--- src-old/mame/drivers/moo.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/moo.c	2012-02-19 01:27:36.000000000 +0100
@@ -692,7 +692,7 @@
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	/* main program */
 	ROM_LOAD16_BYTE( "151_b01",    0x000000,  0x40000, CRC(fb2fa298) SHA1(f03b24681a2b329ba797fd2780ac9a3cf862ebcb) ) /* Version UAB? */
-	ROM_LOAD16_BYTE( "151_ua_b02", 0x000001,  0x40000, CRC(3d9f4d59) SHA1(db47044bd4935fce94ec659242c9819c30eb6d0f) )
+	ROM_LOAD16_BYTE( "151_uaa_b02", 0x000001,  0x40000, CRC(3d9f4d59) SHA1(db47044bd4935fce94ec659242c9819c30eb6d0f) )
 
 	/* data */
 	ROM_LOAD16_BYTE( "151a03", 0x100000,  0x40000, CRC(c896d3ea) SHA1(ea83c63e2c3dbc4f1e1d49f1852a78ffc1f0ea4b) )
diff -Nru src-old/mame/drivers/mpu4.c src/mame/drivers/mpu4.c
--- src-old/mame/drivers/mpu4.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/mpu4.c	2012-02-14 02:33:01.000000000 +0100
@@ -10887,9 +10887,12 @@
 	ROM_LOAD( "sv_20a__.4_1", 0x0000, 0x020000, CRC(0e790ae8) SHA1(48f055f3f1f5d3392b7fba1c5c30624c1f230327) )
 	ROM_LOAD( "sv_20sb_.4_1", 0x0000, 0x020000, CRC(e88c1c29) SHA1(49d180068e4ae9cb65a58e65b4e1ac4d6657ae1d) )
 	ROM_LOAD( "svi20___.4_1", 0x0000, 0x020000, CRC(643037ed) SHA1(d4063faba3069625474dd761f9ad2dcf2f710a19) )
+	ROM_LOAD( "sinbadbwb1_1game.bin", 0x0000, 0x020000, CRC(cfe152a7) SHA1(b8ecfa8b763d04515b65eb902c18dba7198191c3) )
 
 	ROM_REGION( 0x180000, "msm6376", ROMREGION_ERASE00 )
-	/* missing? */
+	//These were with the last listed set, though I have no reason to believe they aren't valid for all BwB Sinbad games
+	ROM_LOAD( "sinbadbwb1_2snd.bin", 0x000000, 0x080000, CRC(2ee60ce6) SHA1(865860639e8471f97ace0beac2f4c7fddb8ca97c) )
+	ROM_LOAD( "sinbadbwb1_3snd.bin", 0x000000, 0x080000, CRC(7701e5cc) SHA1(4f9ff91f2b6b15a9c08396b52fc8509ba476ed8d) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/multigam.c src/mame/drivers/multigam.c
--- src-old/mame/drivers/multigam.c	2012-01-23 13:25:48.000000000 +0100
+++ src/mame/drivers/multigam.c	2012-02-11 11:01:01.000000000 +0100
@@ -377,7 +377,7 @@
 		if (--state->m_multigam3_mmc3_scanline_counter == -1)
 		{
 			state->m_multigam3_mmc3_scanline_counter = state->m_multigam3_mmc3_scanline_latch;
-			generic_pulse_irq_line(device->machine().device("maincpu"), 0);
+			generic_pulse_irq_line(device->machine().device("maincpu"), 0, 1);
 		}
 	}
 }
diff -Nru src-old/mame/drivers/mw18w.c src/mame/drivers/mw18w.c
--- src-old/mame/drivers/mw18w.c	2011-04-27 06:11:18.000000000 +0200
+++ src/mame/drivers/mw18w.c	2012-02-19 01:27:36.000000000 +0100
@@ -192,7 +192,7 @@
 
 ROM_START(18w2)
 	ROM_REGION(0x10000, "maincpu", 0)
-	ROM_LOAD( "18w_b1.rom1", 0x0000, 0x0800, CRC(cbc0fb2c) SHA1(66b14f0d76baebbd64e8ed107e536ad811d55273))
+	ROM_LOAD( "18w2_b1.rom1",0x0000, 0x0800, CRC(cbc0fb2c) SHA1(66b14f0d76baebbd64e8ed107e536ad811d55273))
 	ROM_LOAD( "18w_b2.rom2", 0x0800, 0x0800, CRC(efbadee8) SHA1(834eaf8ca50544123de7529b90b828cf46b1c001))
 	ROM_LOAD( "18w_b3.rom3", 0x1000, 0x0800, CRC(214606f6) SHA1(9a9dc20259b4462661c6be410d98d2be54657a0e))
 	ROM_LOAD( "18w_b4.rom4", 0x1800, 0x0800, CRC(e88ad6a9) SHA1(ac010aa7e0288197ff9342801522623b64dd2a47))
diff -Nru src-old/mame/drivers/namcond1.c src/mame/drivers/namcond1.c
--- src-old/mame/drivers/namcond1.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/namcond1.c	2012-02-11 11:01:01.000000000 +0100
@@ -273,7 +273,7 @@
 	namcond1_state *state = device->machine().driver_data<namcond1_state>();
 	if( state->m_h8_irq5_enabled )
 	{
-		generic_pulse_irq_line(device, H8_IRQ5);
+		generic_pulse_irq_line(device, H8_IRQ5, 1);
 	}
 }
 
diff -Nru src-old/mame/drivers/namcos10.c src/mame/drivers/namcos10.c
--- src-old/mame/drivers/namcos10.c	2011-10-29 05:38:49.000000000 +0200
+++ src/mame/drivers/namcos10.c	2012-02-19 01:27:36.000000000 +0100
@@ -612,8 +612,8 @@
 	ROM_FILL( 0x0000000, 0x400000, 0x55 )
 
 	ROM_REGION( 0x2100000, "user2", 0 ) /* main prg */
-	ROM_LOAD( "0.8e",         0x0000000, 0x1080000, CRC(31b39221) SHA1(7fcb14aaa26c531928a6cd704e746d0e3ae3e031) )
-	ROM_LOAD( "1.8d",         0x1080000, 0x1080000, CRC(82d2cfb5) SHA1(4b5e713a55e74a7b32b1b9b5811892df2df86256) )
+	ROM_LOAD( "gnn2a.8e",         0x0000000, 0x1080000, CRC(31b39221) SHA1(7fcb14aaa26c531928a6cd704e746d0e3ae3e031) )
+	ROM_LOAD( "gnn2a.8d",         0x1080000, 0x1080000, CRC(82d2cfb5) SHA1(4b5e713a55e74a7b32b1b9b5811892df2df86256) )
 ROM_END
 
 ROM_START( gunbalina )
@@ -621,8 +621,8 @@
 	ROM_FILL( 0x0000000, 0x400000, 0x55 )
 
 	ROM_REGION( 0x2100000, "user2", 0 ) /* main prg */
-	ROM_LOAD( "0.8e",         0x0000000, 0x1080000, CRC(981b03d4) SHA1(1c55458f1b2964afe2cf4e9d84548c0699808e9f) )
-	ROM_LOAD( "1.8d",         0x1080000, 0x1080000, CRC(6cd343e0) SHA1(dcec44abae1504025895f42fe574549e5010f7d5) )
+	ROM_LOAD( "gnn1a.8e",         0x0000000, 0x1080000, CRC(981b03d4) SHA1(1c55458f1b2964afe2cf4e9d84548c0699808e9f) )
+	ROM_LOAD( "gnn1a.8d",         0x1080000, 0x1080000, CRC(6cd343e0) SHA1(dcec44abae1504025895f42fe574549e5010f7d5) )
 ROM_END
 
 ROM_START( chocovdr )
diff -Nru src-old/mame/drivers/namcos21.c src/mame/drivers/namcos21.c
--- src-old/mame/drivers/namcos21.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/namcos21.c	2012-02-19 16:23:23.000000000 +0100
@@ -1523,6 +1523,7 @@
 	namcos2_kickstart = namcos21_kickstart;
 }
 
+
 static MACHINE_CONFIG_START( s21base, namcos21_state )
 	MCFG_CPU_ADD("maincpu", M68000,12288000) /* Master */
 	MCFG_CPU_PROGRAM_MAP(namcos21_68k_master)
@@ -1571,6 +1572,7 @@
 	MCFG_VIDEO_START(namcos21)
 MACHINE_CONFIG_END
 
+
 static MACHINE_CONFIG_DERIVED( poly_c140_typeA, s21base )
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
@@ -1585,6 +1587,7 @@
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.30)
 MACHINE_CONFIG_END
 
+
 static MACHINE_CONFIG_DERIVED( poly_c140_typeB, s21base )
 
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
@@ -1599,6 +1602,7 @@
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.30)
 MACHINE_CONFIG_END
 
+
 static MACHINE_CONFIG_START( driveyes, namcos21_state )
 	MCFG_CPU_ADD("maincpu", M68000,12288000) /* Master */
 	MCFG_CPU_PROGRAM_MAP(driveyes_68k_master)
@@ -1653,7 +1657,8 @@
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.30)
 MACHINE_CONFIG_END
 
-static MACHINE_CONFIG_START( winrun_c140_typeB, namcos21_state )
+
+static MACHINE_CONFIG_START( winrun_c140_typeA, namcos21_state )
 	MCFG_CPU_ADD("maincpu", M68000,12288000) /* Master */
 	MCFG_CPU_PROGRAM_MAP(am_master_winrun)
 	MCFG_CPU_VBLANK_INT("screen", namcos2_68k_master_vblank)
@@ -1701,7 +1706,7 @@
 	MCFG_SPEAKER_STANDARD_STEREO("lspeaker", "rspeaker")
 
 	MCFG_SOUND_ADD("c140", C140, 8000000/374)
-	MCFG_SOUND_CONFIG(C140_interface_typeB)
+	MCFG_SOUND_CONFIG(C140_interface_typeA)
 	MCFG_SOUND_ROUTE(0, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.50)
 
@@ -1710,6 +1715,15 @@
 	MCFG_SOUND_ROUTE(1, "rspeaker", 0.30)
 MACHINE_CONFIG_END
 
+
+static MACHINE_CONFIG_DERIVED( winrun_c140_typeB, winrun_c140_typeA )
+	MCFG_SOUND_REPLACE("c140", C140, 8000000/374)
+	MCFG_SOUND_CONFIG(C140_interface_typeB)
+	MCFG_SOUND_ROUTE(0, "lspeaker", 0.50)
+	MCFG_SOUND_ROUTE(1, "rspeaker", 0.50)
+MACHINE_CONFIG_END
+
+
 ROM_START( aircomb )
 	ROM_REGION( 0x100000, "maincpu", 0 ) /* Master */
 	ROM_LOAD16_BYTE( "ac2-mpr-u.3j",  0x000000, 0x80000, CRC(a7133f85) SHA1(9f1c99dd503f1fc81096170fd272e33ae8a7de2f) )
@@ -2096,6 +2110,72 @@
 
 ROM_START( winrun )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68k code */
+	ROM_LOAD16_BYTE( "wr2mpub.3k",  0x000000, 0x20000, CRC(3bb0ea17) SHA1(201cedf5865224c1c4a0c9b017982e36ec9b8243) )
+	ROM_LOAD16_BYTE( "wr2mplb.1k",  0x000001, 0x20000, CRC(95465062) SHA1(7d010ff92e87949b7b9109f8320ab61de7d0400a) )
+
+	ROM_REGION( 0x40000, "slave", 0 ) /* 68k code */
+	ROM_LOAD16_BYTE( "wr1spu.6b",  0x000000, 0x20000, CRC(d4915d44) SHA1(57056051138b259d021b3e7cc1c43a9f951b5cc1) )
+	ROM_LOAD16_BYTE( "wr1spl.4b",  0x000001, 0x20000, CRC(0c336505) SHA1(edee073bf6fabe45c577b0b9375295183eb30c62) )
+
+	ROM_REGION( 0x30000, "audiocpu", 0 ) /* Sound */
+	ROM_LOAD( "wr1snd0.7c",  0x00c000, 0x004000, CRC(698bae12) SHA1(86d22c1c639a9489e3c95820e4e3f04c30407e41) )
+	ROM_CONTINUE(            0x010000, 0x01c000 )
+	ROM_RELOAD(              0x010000, 0x020000 )
+
+	ROM_REGION( 0x10000, "mcu", 0 ) /* I/O MCU */
+	ROM_LOAD( "sys2mcpu.bin",  0x000000, 0x002000, CRC(a342a97e) SHA1(2c420d34dba21e409bf78ddca710fc7de65a6642) )
+	ROM_LOAD( "sys2c65c.bin",  0x008000, 0x008000, CRC(a5b2a4ff) SHA1(068bdfcc71a5e83706e8b23330691973c1c214dc) )
+
+	ROM_REGION( 0x20000, "dsp", ROMREGION_ERASEFF ) /* DSP */
+
+	ROM_REGION( 0x80000, "gpu", 0 ) /* 68k code */
+	ROM_LOAD16_BYTE( "wr1gp0u.1k",  0x00000, 0x20000, CRC(c66a43be) SHA1(88ec02c5c18c8bb91a95934c14e9ae530ae09880) )
+	ROM_LOAD16_BYTE( "wr1gp0l.3k",  0x00001, 0x20000, CRC(91a70e6f) SHA1(e613e2544f63cd386588445a2a199ae6b84d741e) )
+	ROM_LOAD16_BYTE( "wr1gp1u.1l",  0x40000, 0x20000, CRC(8ff51a3d) SHA1(81fbcd4e8c51742f35607537e1b1a86fd7782827) )
+	ROM_LOAD16_BYTE( "wr1gp1l.3l",  0x40001, 0x20000, CRC(9360d34e) SHA1(e558eb540c02acfe84f2dfe2d65afd609b7f3207) )
+
+	ROM_REGION16_BE( 0x80000, "user1", 0 ) /* 68k */
+	ROM_LOAD16_BYTE( "wr1d0u.3a", 0x00000, 0x20000, CRC(84ea1492) SHA1(56274b39bd5be076c9904d9ed9ce3f6e29d9f038) )
+	ROM_LOAD16_BYTE( "wr1d0l.1a", 0x00001, 0x20000, CRC(b81508f9) SHA1(51c03c3dff86cece9790667b1557de940ebccbe9) )
+	ROM_LOAD16_BYTE( "wr1d1u.3b", 0x40000, 0x20000, CRC(bbd1fdd7) SHA1(026e9410525fa0e93f155949bbc1d3b8a2785bd1) )
+	ROM_LOAD16_BYTE( "wr1d1l.1b", 0x40001, 0x20000, CRC(8ddd7eac) SHA1(b873b253b0a095e66a9f68d45a2cb41fa025ba16) )
+
+	ROM_REGION16_BE( 0x80000, "user2", 0 ) /* 3d objects */
+	ROM_LOAD16_BYTE( "wr1pt0u.8j", 0x00000, 0x20000, CRC(7ec4cf6b) SHA1(92ec92567b9f7321efb4a3724cbcdba216eb22f9) )
+	ROM_LOAD16_BYTE( "wr1pt0l.8d", 0x00001, 0x20000, CRC(58c14b73) SHA1(e34a26866cd870743e166669f7fa5915a82104e9) )
+
+	ROM_REGION16_BE( 0x100000, "user3", 0 ) /* bitmapped graphics */
+	ROM_LOAD16_BYTE( "wr1gd0u-2.1p",  0x00000, 0x40000, CRC(9752eef5) SHA1(d6df0faf9c2696247bdf463f53c1e474ec595dd0) )
+	ROM_LOAD16_BYTE( "wr1gd0l-2.3p",  0x00001, 0x40000, CRC(349c95cc) SHA1(8898eecf5918485ec683900520f123483077df28) )
+
+	ROM_REGION( 0x200000, "c140", 0 ) /* sound samples */
+	ROM_LOAD("wrvoi-0.11b", 0x040000, 0x40000, CRC(8040b645) SHA1(7ccafb3073fa79910e26cf9b8b6e8e9ae22e55fc) )
+	ROM_LOAD("wrvoi-1.11c", 0x0c0000, 0x40000, CRC(d347e904) SHA1(620cd07e6230322c306283e45a43fa1e217028d4) )
+	ROM_LOAD("wrvoi-2.11d", 0x140000, 0x40000, CRC(b34747af) SHA1(7e0b55631bffa0583bf4f7f5368db9f09e411ba1) )
+	ROM_LOAD("wrvoi-3.11e", 0x1c0000, 0x40000, CRC(43085303) SHA1(9f743055c20df3548879118194244e37a0b91f7e) )
+
+	ROM_REGION( 0x1000, "pals", 0 )
+	/* Main PCB (2252960101) */
+	ROM_LOAD("sys87b-2.3w", 0x000, 0x104, CRC(18f43c22) SHA1(72849c5b842678bb9037541d26d4c99cdf879982) ) /* PAL16L8ACN */
+	ROM_LOAD("wr-c1.6p",    0x000, 0x040, CRC(d6c33258) SHA1(5baf71fae1ad73a75d91ee2dededca2254b4f414) ) /* PAL12L10CNS */
+	ROM_LOAD("wr-c2.8k",    0x000, 0x040, CRC(a3e77ade) SHA1(b4282fc4d21ce7813aba7772a85d721fb25144b6) ) /* PAL12L10CNS */
+
+	/* Framebuffer PCB (2252960900) */
+	ROM_LOAD("wr-g1.3a",    0x000, 0x104, CRC(d6b4373d) SHA1(b4db4526a37b7d6862cec1d223f2281e5120f225) ) /* PAL16L8ACN */
+	ROM_LOAD("wr-g2b.4p",   0x000, 0x104, NO_DUMP ) /* PAL16L8ACN */
+	ROM_LOAD("wr-g3.4s",    0x000, 0x104, NO_DUMP ) /* GAL20V8 */
+	ROM_LOAD("wr-g4.7f",    0x000, 0x104, CRC(f858b32b) SHA1(59af496e4416c9becb116315542858ac917cbe46) ) /* PAL16L8ACN */
+
+	/* 3D PCB (2252960701) */
+	ROM_LOAD("wr-p1.1b",    0x000, 0x104, CRC(5856cc43) SHA1(4578c7a7d731c61d678d594dd071370db46cc3f7) ) /* PAL16L8ACN */
+
+	/* DSP PCB (2252960601) */
+	ROM_LOAD("wr-d1.3b",    0x000, 0x104, CRC(7a072b71) SHA1(45b8d9405a2c1a40f2cd9c6a33d105565136c538) ) /* PAL16L8ACN */
+	ROM_LOAD("wr-d2.4j",    0x000, 0x104, CRC(614de474) SHA1(80c3ab287896e07073a70dd42e7b47f515dd3931) ) /* PAL16L8ACN */
+ROM_END
+
+ROM_START( winrungp )
+	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68k code */
 	ROM_LOAD16_BYTE( "sg1-mp-ub.3k",  0x000000, 0x20000, CRC(7f9b855a) SHA1(6d39a3a9959dbcd0047dbaab0fcd68adc81f5508) )
 	ROM_LOAD16_BYTE( "sg1-mp-lb.1k",  0x000001, 0x20000, CRC(a45e8543) SHA1(f9e583a988e4661026ee7873a48d078225778df3) )
 
@@ -2450,15 +2530,15 @@
 	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
-/*    YEAR, NAME,     PARENT,  MACHINE,           INPUT,        INIT,     MONITOR,  COMPANY,   FULLNAME,                       FLAGS */
-GAME( 1992, aircomb,  0,       poly_c140_typeB,   aircombt,     aircombt, ROT0,    "Namco", "Air Combat (US)",	             GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1992, aircombj, aircomb, poly_c140_typeB,   aircombt,     aircombt, ROT0,    "Namco", "Air Combat (Japan)",            GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1993, cybsled,  0,       poly_c140_typeA,   cybsled,      cybsled,  ROT0,    "Namco", "Cyber Sled (US)",               GAME_IMPERFECT_GRAPHICS )
-GAME( 1993, cybsledj, cybsled, poly_c140_typeA,   cybsled,      cybsled,  ROT0,    "Namco", "Cyber Sled (Japan)",            GAME_IMPERFECT_GRAPHICS )
-/* 1992, ShimDrive */
-GAME( 1991, solvalou, 0,       poly_c140_typeA,   s21default,   solvalou, ROT0,    "Namco", "Solvalou (Japan)",              GAME_IMPERFECT_GRAPHICS )
+/*    YEAR, NAME,     PARENT,  MACHINE,           INPUT,        INIT,     MONITOR,  COMPANY,   FULLNAME,                             FLAGS */
+GAME( 1988, winrun,   0,       winrun_c140_typeA, winrun,       winrun,   ROT0,    "Namco", "Winning Run",                           GAME_IMPERFECT_GRAPHICS )
+GAME( 1989, winrungp, 0,       winrun_c140_typeB, winrun,       winrun,   ROT0,    "Namco", "Winning Run Suzuka Grand Prix (Japan)", GAME_IMPERFECT_GRAPHICS )
+GAME( 1991, winrun91, 0,       winrun_c140_typeB, winrun,       winrun,   ROT0,    "Namco", "Winning Run 91 (Japan)",                GAME_IMPERFECT_GRAPHICS )
+GAME( 1991, driveyes, 0,       driveyes,          winrun,       driveyes, ROT0,    "Namco", "Driver's Eyes (US)",                    GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
+GAME( 1991, solvalou, 0,       poly_c140_typeA,   s21default,   solvalou, ROT0,    "Namco", "Solvalou (Japan)",                      GAME_IMPERFECT_GRAPHICS )
 GAME( 1991, starblad, 0,       poly_c140_typeA,   s21default,   starblad, ROT0,    "Namco", "Starblade (Japan)",                     GAME_IMPERFECT_GRAPHICS )
-GAME( 1991, winrun91, 0,       winrun_c140_typeB, winrun,       winrun,   ROT0,    "Namco", "Winning Run 91 (Japan)",                GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-GAME( 1989, winrun,   0,       winrun_c140_typeB, winrun,       winrun,   ROT0,    "Namco", "Winning Run Suzuka Grand Prix (Japan)", GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
-/* 1988, Winning Run */
-GAME( 1991, driveyes, 0,       driveyes,          winrun,       driveyes, ROT0,    "Namco", "Driver's Eyes (US)",                 GAME_NOT_WORKING|GAME_IMPERFECT_GRAPHICS )
+/* 1992, ShimDrive */
+GAME( 1992, aircomb,  0,       poly_c140_typeB,   aircombt,     aircombt, ROT0,    "Namco", "Air Combat (US)",	                     GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
+GAME( 1992, aircombj, aircomb, poly_c140_typeB,   aircombt,     aircombt, ROT0,    "Namco", "Air Combat (Japan)",                    GAME_NOT_WORKING | GAME_IMPERFECT_GRAPHICS )
+GAME( 1993, cybsled,  0,       poly_c140_typeA,   cybsled,      cybsled,  ROT0,    "Namco", "Cyber Sled (US)",                       GAME_IMPERFECT_GRAPHICS )
+GAME( 1993, cybsledj, cybsled, poly_c140_typeA,   cybsled,      cybsled,  ROT0,    "Namco", "Cyber Sled (Japan)",                    GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/namcos22.c src/mame/drivers/namcos22.c
--- src-old/mame/drivers/namcos22.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/namcos22.c	2012-02-11 11:01:01.000000000 +0100
@@ -2727,7 +2727,7 @@
 				int i;
 				for (i = 0; i < 16; i++)
 				{
-					generic_pulse_irq_line(space->machine().device("mcu"), M37710_LINE_TIMERA3TICK);
+					generic_pulse_irq_line(space->machine().device("mcu"), M37710_LINE_TIMERA3TICK, 1);
 				}
 			}
 
diff -Nru src-old/mame/drivers/namcos23.c src/mame/drivers/namcos23.c
--- src-old/mame/drivers/namcos23.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/namcos23.c	2012-02-19 16:23:23.000000000 +0100
@@ -968,6 +968,256 @@
       J105            - 110VAC power input
       J106            - DC variable power output to feed-back motor
 
+
+Namco Gorgon-based games
+------------------------
+
+Rapid River, Final Furlong (both Namco, 1997)
+
+These games run on hardware called "GORGON". It appears to have similar
+capabilities to System 23 but like Super System 22 has sprites also.
+(System 23 doesn't have sprites). The PCBs are about two times larger
+than System 23.
+
+The system comprises Main PCB, ROM PCB and I/O PCB all located inside
+a metal box with 3 separate power supplies for 5V, 12V and 3.3V. Main
+input power is 115V.
+Rapid River is controlled by rotating a paddle (for thrust) and turning it
+sideways (moves left/right).
+The rotation action is done with a 5K potentiometer whereby the thrust
+is achieved by moving the pot from full left to full right continuously.
+The left/right turning movement is just another 5K potentiometer connected
+to the column of the paddle center shaft.
+There are also some buttons just for test mode, including SELECT, UP & DOWN
+The player's seat has movement controlled by a compressor and several
+potentiometers. On bootup, the system tests the seat movement and displays
+a warning if it's not working. Pressing START allows the game to continue
+and function normally without the seat movement.
+
+The other game on this system (Final Furlong) and is a horse racing game.
+To control the horse you rock it forwards and backwards continually (it's very tiring
+to play this game).
+This would activate possibly one or two 5K potentiometers inside the horse body.
+Just like a real horse you need to control the speed so your horse lasts the entire race.
+If you rock too much, a message on screen says 'Too Fast'. To steer the horse turn the
+head sideways using the reins. There would be another 5K potentiometer in the head
+to activate the turning direction.
+
+
+Main PCB
+--------
+
+8664960102 (8664970102) GORGON MAIN PCB
+|------------------------------------------------------------------------------------------------------|
+|                                   J4                       J5                         J6             |
+|                              |---------|           |---------| |------| |---------|                  |
+|         |---------| |------| |         |           |         | |C401  | |         |HM534251 HM534251 |
+| CXD1178Q|         | |C381  | |  C374   |  |------| |  C417   | |      | |  304    |HM534251 HM534251 |
+|         |  C404   | |      | |         |  |C435  | |         | |------| |         |HM534251 HM534251 |
+|         |         | |------| |         |  |      | |         | |------| |         |                  |
+|         |         |          |---------|  |------| |---------| |C400  | |---------|                  |
+|         |---------|     |---------|       |------|             |      | |---------|                  |
+|                         |         |       |C435  |    341256   |------| |         |HM534251 HM534251 |
+|                         |  C397   |       |      |             |------| |  304    |HM534251 HM534251 |
+|  341256 341256  341256  |         |       |------|    341256   |C401  | |         |HM534251 HM534251 |
+|  M5M51008       341256  |         |     |---------|            |      | |         |                  |
+|                         |---------|     |         | |------|   |------| |---------|                  |
+|  M5M51008       341256         |------| |  C403   | |C406  |   |------| |---------|                  |
+|ADM485              |---------| |C379  | |         | |      |   |C400  | |         |HM534251 HM534251 |
+|                    |         | |      | |         | |------|   |      | |  304    |HM534251 HM534251 |
+|    M5M51008        |  C300   | |------| |---------|            |------| |         |HM534251 HM534251 |
+|                    |         | LH540204  LH540204              |------| |         |                  |
+|    M5M51008        |         |341256                 |------|  |C401  | |---------|                  |
+|J1   HCPL0611       |---------|341256                 |C407  |  |      | |---------|                  |
+|         DS8921                  PST575  PST575       |      |  |------| |         |                  |
+|  DS8921                                              |------|  |------| |  304    |HM534251 HM534251 |
+|                 M5M51008                                       |C400  | |         |HM534251 HM534251 |
+|       CY7C128             CY2291S                              |      | |         |                  |
+|         |------|M5M51008  14.31818MHz                          |------| |---------|                  |
+|         |C422  |          J9           M5M5256                 |------| |---------|         3V_BATT  |
+|         |      |341256                                         |C400  | |         |                  |
+|         |------|341256                                         |      | |  C399   |341256  LEDS(8)   |
+|                                   |------|      |--------|     |------| |         |341256            |
+|                                   |C352  |      |ALTERA  |     |------| |         |                  |
+|  ADM485        DSW1(2)   |------| |      |      |EPM7128 |     |C401  | |---------| DSW3(2)   DSW5(8)|
+|    2061ASC               |C416  | |------|      |        |     |      |     |---------| |---------|  |
+|      14.7456MHz          |      |               |--------|     |------|     |         | |NKK      |  |
+|PAL             |-----|   |------|    |------|                   D4516161    |  C413   | |NR4650   |  |
+|                |H8/  |               |C361  |                   D4516161    |         | |LQF-13B  |  |
+|                |3002 |               |      |LC321664                       |         | |         |  |
+|  J10           |-----|               |------|    J8                         |---------| |---------|  |
+|------------------------------------------------------------------------------------------------------|
+Notes:
+     NKK NR4650 - R4600-based 64bit RISC CPU (Main CPU, QFP208, clock input source = CY2291S)
+     H8/3002  - Hitachi H8/3002 HD6413002F17 (Sound CPU, QFP100, running at 14.7456MHz)
+     EPM7128  - Altera EPM7128 FPGA labelled 'GOR-M1' (PLCC84)
+     PAL      - PALCE16V8H stamped 'GOR-M3' (PLCC20)
+     HM534251 - Hitachi HM534251 256k x4 Dynamic Video RAM (SOJ28)
+     N341256  - NKK 32k x8 SRAM (SOJ28)
+     M5M5256  - Mitsubishi 32k x8 SRAM (SOP28)
+     D4516161 - NEC uPD4516161AG5-A80 1M x16 (16MBit) SDRAM (SSOP50)
+     LC321664 - Sanyo 64k x16 EDO DRAM (SOJ40)
+     M5M51008 - Mitsubishi 128k x8 SRAM (SOP32)
+     CY7C128  - Cypress 2k x8 SRAM (SOJ28)
+     LH540204 - Sharp CMOS 4096 x 9 Asynchronous FIFO (PLCC32)
+     2061ASC-1- IC Designs 2061ASC-1 programmable clock generator (SOIC16)
+     DS8921   - Dallas Semiconductor DS8921 RS-422/423 Differential Line Driver and Receiver Pair (SOIC8)
+     HCPL0611 - Fairchild HCPL0611 High Speed 10MBits/sec Logic Gate Optocoupler (SOIC8)
+     ADM485   - Analog Devices ADM485 5V Low Power EIA RS-485 Transceiver (SOIC8)
+     PST575   - System Reset IC (SOIC8)
+     CXD1178Q - Sony CXD1178Q 8-bit RGB 3-channel D/A converter (QFP48)
+     J1       - 64 pin connector for connection of I/O board
+     J4/J5/J6 \
+     J8/J9    / Custom NAMCO connectors for connection of MEM(M1) PCB
+     J10      - Custom NAMCO connector for MSPM(FR) PCB
+
+
+     Namco Custom ICs
+     ----------------
+     C300 (QFP160)
+     304  (x4, QFP120)
+     C352 (QFP100)
+     C361 (QFP120)
+     C374 (QFP160)
+     C379 (QFP64)
+     C381 (QFP144)
+     C397 (QFP160)
+     C399 (QFP160)
+     C400 (QFP100)
+     C401 (x4, QFP64)
+     C403 (QFP136)
+     C404 (QFP208)
+     C406 (QFP120)
+     C407 (QFP64)
+     C413 (QFP208)
+     C416 (QFP176)
+     C417 (QFP208)
+     C422 (QFP64)
+     C435 (x2, TQFP144)
+
+
+Program ROM PCB
+---------------
+
+MSPM(FR) PCB 8699015200 (8699015100)
+|--------------------------|
+|            J1            |
+|                          |
+|  IC3               IC1   |
+|                          |
+|                          |
+|                    IC2   |
+|--------------------------|
+Notes:
+     J1 -  Connector to plug into Main PCB
+     IC1 \
+     IC2 / Main Program  (Fujitsu 29F016 16MBit FlashROM, TSOP48)
+     IC3 - Sound Program (Fujitsu 29F400T 4MBit FlashROM, TSOP48)
+
+     Games that use this PCB include...
+
+     Game           Code and revision
+     --------------------------------
+     Rapid River    RD2 Ver.C
+     Rapid River    RD3 Ver.C
+     Final Furlong  FF2 Ver.A
+
+ROM PCB
+-------
+
+MEM(M1) PCB
+8664960202 (8664970202)
+|--------------------------------------------------------|
+|    J2(TEXTURE)        J3(POINT)           J5(SPRITE)   |
+| PAL1                                                   |
+|                                                        |
+|                                                        |
+|                                                        |
+| CCRL.11A                                               |
+|      CCRL.11E  PT3L.12J PT3H.12L  SPRLL.12P SPRLL.12T  |
+| CCRH.11B                                               |
+|      CCRH.11F                                          |
+|                PT2L.11J PT2H.11L  SPRLM.11P SPRLM.11T  |
+|                                                        |
+|                                                        |
+|                PT1L.10J PT1H.10L  SPRUM.10P SPRUM.10T  |
+|   PAL2        PAL3                                     |
+|                                                        |
+|                PT0L.9J  PT0H.9L   SPRUU.9P  SPRUU.9T   |
+|                                   JP7       JP9        |
+|                                   JP6       JP8        |
+| CGLL.8B     CGLL.8F                                    |
+|                                                        |
+|                                                        |
+| CGLM.7B     CGLM.7F                                    |
+|      JP2    JP4                                        |
+|      JP1    JP3                                        |
+| CGUM.6B     CGUM.6F                                    |
+|                                          J1(WAVE)      |
+|                                                        |
+| CGUU.5B     CGUU.5F                      WAVEH.3S      |
+|                                                        |
+|                    MTBH.5J               WAVEL.2S      |
+|                    MTAH.3J                      JP5    |
+|                    MTBL.2J                             |
+|                    MTAL.1J    KEYCUS                   |
+|                                                        |
+|                    J4(MOTION)                          |
+|--------------------------------------------------------|
+Notes:
+     PAL1 - PALCE16V8H stamped 'SS22M1' (PLCC20)
+     PAL2 - PALCE20V8H stamped 'SS22M2' (PLCC32)
+     PAL3 - PALCE20V8H stamped 'SS22M2' (PLCC32)
+     KEYCUS - for Rapid River: MACH211 CPLD stamped 'KC012' (PLCC44)
+     KEYCUS - for Final Furlong: MACH211 CPLD stamped 'KC011' (PLCC44)
+     J1->J5 - Custom NAMCO connectors for joining ROM PCB to Main PCB
+     JP1/JP2 \
+     JP3/JP4 |
+     JP5     | Jumpers to set ROM sizes (32M/64M)
+     JP6/JP7 |
+     JP8/JP9 /
+
+     ROMs
+     ----
+          PT*  - Point ROMs, sizes configurable to either 16M or 32M (SOP44)
+          MT*  - Motion ROMs, sizes configurable to either 32M or 64M (SOP44)
+          CG*  - Texture ROMs, sizes configurable to either 32M or 64M (SOP44)
+          CCR* - Texture Tilemap ROMs, sizes fixed at 16M (SOP44)
+          SPR* - Sprite ROMs, sizes configurable to either 32M or 64M (SOP44)
+          WAVE*- Wave ROMs, sizes configurable to either 32M or 64M (SOP44)
+
+I/O PCB
+-------
+
+V187 ASCA-2A PCB
+2477960102 (2477970102)
+|--------------------------------------------------------|
+|                   J105                                 |
+|                           |-------|        14.7456MHz  |
+|   J104                    |ALTERA |    ADM485   PST592 |
+|                           |EPM7064|     |-------|      |
+|                           |       |     |       |      |
+|                           |-------|     | C78   |      |
+|     LC78815                             |       |      |
+|                                         |-------|      |
+|     MB87078                              |---|         |
+| LA4705                                   |IC1| 62256   |
+|                                          |---|         |
+|         J101                J102                       |
+|--------------------------------------------------------|
+Notes:
+     IC1  - Atmel AT29C020 2MBit EEPROM labelled 'ASCA1 I/O-A' (PLCC32)
+     C78  - Namco Custom MCU, positively identified as a Hitachi H8/3334 (PLCC84)
+     EPM7064 - Altera EPM7064LC68-15 PLD, labelled 'ASCA DR0' (PLCC68)
+     PST592 - System Reset IC (SOIC4)
+     ADM485 - Analog Devices +ADM485 5V Low Power EIA RS-485 Transceiver (SOIC8)
+     MB87078 - Fujitsu MB87078 Electronic Volume Control IC (SOIC24)
+     LC78815 - Sanyo LM78815 2-Channel 16-Bit D/A Converter (SOIC20)
+     J101 - 34 pin flat cable connector for filter board
+     J102 - 50 pin flat cable connector for filter board
+     J104 - 8 pin power connector (+5V, +12V, +3.3V)
+     J105 - 64 pin connector for connection of Main PCB
+
 */
 
 #include "emu.h"
diff -Nru src-old/mame/drivers/naomi.c src/mame/drivers/naomi.c
--- src-old/mame/drivers/naomi.c	2012-02-02 05:17:12.000000000 +0100
+++ src/mame/drivers/naomi.c	2012-02-19 16:23:23.000000000 +0100
@@ -6852,6 +6852,18 @@
 	ROM_LOAD("gds-0032_pic", 0x00, 0x50, NO_DUMP ) // PIC was missing
 ROM_END
 
+ROM_START( initdv3e )
+	NAOMI2_BIOS
+	NAOMI_DEFAULT_EEPROM
+
+	DISK_REGION( "gdrom" )
+	DISK_IMAGE_READONLY( "gds-0033", 0,  SHA1(8908238a0211c6343ce6f3f27729e33c4e276d35) )
+
+	ROM_REGION( 0x4300, "pic", ROMREGION_ERASEFF)
+	//PIC16C622A (317-0384-COM)
+    ROM_LOAD( "317-0384-com.pic", 0x000000, 0x004300, CRC(081ccd51) SHA1(598b3bd9e8b16f5954d15738c1ca55703609b690) )
+ROM_END
+
 /*
 Title   THE_MAZE_OF_THE_KINGS
 Media ID    E3D0
@@ -7044,6 +7056,37 @@
 	ROM_LOAD( "mpr-23818.ic20", 0xa000000, 0x800000, CRC(be902c2b) SHA1(1f1aa6933da528bdcef45942a0caa33cb24e7ddd) )
 ROM_END
 
+ROM_START( soulsurf )
+	NAOMI2_BIOS
+	NAOMI_DEFAULT_EEPROM
+
+    ROM_REGION( 0xb000000, "rom_board", ROMREGION_ERASEFF)
+    // Cart has a Sega factory EPROM sticker stating "EPR-23838C" and a Sega factory sticker stating "Rev. A".  Seriously.
+    ROM_LOAD( "epr-23838c.ic22", 0x000000, 0x400000, CRC(5e5fb00f) SHA1(c5e81ebead9072cc08f09d1715d609cb0f7631ba) )
+    ROM_RELOAD( 0x400000, 0x400000)
+    ROM_LOAD( "ssf01.ic1s",   0x0800000, 0x800000, CRC(4f12f789) SHA1(7b79b687fc61e2e981b9e5e8e0939c4ad24a98f0) )
+    ROM_LOAD( "ssf02.ic2s",   0x1000000, 0x800000, CRC(a255d41a) SHA1(3e932527eb68edf3e8538c1ad264a1c599f6a9d5) )
+    ROM_LOAD( "ssf03.ic3s",   0x1800000, 0x800000, CRC(0f8d6577) SHA1(afaf440e667bacc941c0a5418a0e3b0f2bb725b7) )
+    ROM_LOAD( "ssf04.ic4s",   0x2000000, 0x800000, CRC(bdf25bd0) SHA1(f79b1fdba9c48969c49617c43c1919637adb13ba) )
+    ROM_LOAD( "ssf05.ic5s",   0x2800000, 0x800000, CRC(a74b3bb4) SHA1(0ce7cef849061a9af7a61d69dc633f6971a3a63d) )
+    ROM_LOAD( "ssf06.ic6s",   0x3000000, 0x800000, CRC(3cd1f5d5) SHA1(77573c3a60af64e6e6a0eb85d5b8176ed98b0723) )
+    ROM_LOAD( "ssf07.ic7s",   0x3800000, 0x800000, CRC(00d240f5) SHA1(43010fc596f2cdffdff35a6122f2ab02a5251bc0) )
+    ROM_LOAD( "ssf08.ic8s",   0x4000000, 0x800000, CRC(d4907fa1) SHA1(79b1c771819f6e4baa048010bfb940a45370eba2) )
+    ROM_LOAD( "ssf09.ic9s",   0x4800000, 0x800000, CRC(6327d49e) SHA1(a10e3c27f70dbf18e63cf51962b6a79a52eba26c) )
+    ROM_LOAD( "ssf10.ic10s",  0x5000000, 0x800000, CRC(7975dc80) SHA1(81bda50968f0153a0c4432d8d81e817c1e82e5b2) )
+    ROM_LOAD( "ssf11.ic11s",  0x5800000, 0x800000, CRC(a242f682) SHA1(435ea5bb1b3667f9ef3d7de081b15f4e8e6a0d01) )
+    ROM_LOAD( "ssf12.ic12s",  0x6000000, 0x800000, CRC(45fa259e) SHA1(8d7e708e7a2cbc2d60b68715dd79bac28d894d4c) )
+    ROM_LOAD( "ssf13.ic13s",  0x6800000, 0x800000, CRC(e9578063) SHA1(618f66d01f6bdacbf2a3242774a316b130594e02) )
+    ROM_LOAD( "ssf14.ic14s",  0x7000000, 0x800000, CRC(2edc1311) SHA1(bceb54dd29012580e2e6f15f16c6b31195010153) )
+    ROM_LOAD( "ssf15.ic15s",  0x7800000, 0x800000, CRC(416db320) SHA1(34536716a35260d9457703704bb9174fb1616d60) )
+    ROM_LOAD( "ssf16.ic16s",  0x8000000, 0x800000, CRC(2530cc04) SHA1(6425c031e5a129a3c9451bc694b5da8553f154c2) )
+    ROM_LOAD( "ssf17.ic17s",  0x8800000, 0x800000, CRC(9e6afcc2) SHA1(4fb69d834ea12c82e897af47a22dcc47f3c83768) )
+    ROM_LOAD( "ssf18.ic18s",  0x9000000, 0x800000, CRC(854ed5e5) SHA1(e445599f6a9e9d05c279259307edc08bce5d6d1f) )
+    ROM_LOAD( "ssf19.ic19s",  0x9800000, 0x800000, CRC(4f8ec86a) SHA1(406ab9eeccd99fa5515d4a2c229c8db1a5cb8f83) )
+    ROM_LOAD( "ssf20.ic20s",  0xa000000, 0x800000, CRC(c90b960d) SHA1(66e9f09d1f7f6a991371574a2e095c0e22fb7031) )
+    ROM_LOAD( "ssf21.ic21s",  0xa800000, 0x800000, CRC(1477c064) SHA1(87fb8d8a91d6bed70b246a8df88fa77fbf3db443) )
+ROM_END
+
 /*
     Tests IC1 like gram2000 if actel_id is 0xffff, see ROM_COPY
 */
@@ -7481,7 +7524,7 @@
 	AW_BIOS
 
 	ROM_REGION( 0x8000000, "rom_board", ROMREGION_ERASE)
-	ROM_LOAD( "ax2201p01.ic18", 0x0000000, 0x0800000, CRC(27aab918) SHA1(41c5ddd8bd4c91481750606ab44aa115b5fe01d0) )
+	ROM_LOAD( "ax2201en_p01.ic18", 0x0000000, 0x0800000, CRC(27aab918) SHA1(41c5ddd8bd4c91481750606ab44aa115b5fe01d0) )
 	ROM_LOAD( "ax2201m01.ic11", 0x1000000, 0x1000000, CRC(22ea665b) SHA1(292c92c9ae43eea2d1c27cedfb89c3956b8dea32) )
 	ROM_LOAD( "ax2202m01.ic12", 0x2000000, 0x1000000, CRC(7fad1bea) SHA1(89f3f88af48973a4685955d86ef97a1487b8e7a8) )
 	ROM_LOAD( "ax2203m01.ic13", 0x3000000, 0x1000000, CRC(78986ca4) SHA1(5a6c8c12955573f33361d2c6f20f85de35ac7bae) )
@@ -7497,8 +7540,9 @@
 	AW_BIOS
 
 	ROM_REGION( 0x8000000, "rom_board", ROMREGION_ERASE)
-	    ROM_LOAD( "ax2201p01.ic18", 0x0000000, 0x0800000, CRC(ecc4a5c7) SHA1(97c2ef2be95b39bc978474a8243740df50255a8b) )
-	    /* these are taken from the above set, game *seems* to work fine with these ... */
+	ROM_LOAD( "ax2201jp_p01.ic18", 0x0000000, 0x0800000, CRC(ecc4a5c7) SHA1(97c2ef2be95b39bc978474a8243740df50255a8b) )
+
+	/* these are taken from the above set, game *seems* to work fine with these ... */
 	ROM_LOAD( "ax2201m01.ic11", 0x1000000, 0x1000000, CRC(22ea665b) SHA1(292c92c9ae43eea2d1c27cedfb89c3956b8dea32) )
 	ROM_LOAD( "ax2202m01.ic12", 0x2000000, 0x1000000, CRC(7fad1bea) SHA1(89f3f88af48973a4685955d86ef97a1487b8e7a8) )
 	ROM_LOAD( "ax2203m01.ic13", 0x3000000, 0x1000000, CRC(78986ca4) SHA1(5a6c8c12955573f33361d2c6f20f85de35ac7bae) )
@@ -7811,7 +7855,7 @@
 /* 0062 */ GAME( 2002, clubkrte, naomi2,   naomi2,   naomi,    naomi2,   ROT0, "Sega", "Club Kart: European Session (Rev D)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 /* 0080 */ GAME( 2002, vf4cart,  naomi2,   naomi2m2, naomi,    naomi2,   ROT0, "Sega", "Virtua Fighter 4 (Cartridge)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 /* 0087 */ GAME( 2002, kingrt66, naomi2,   naomi2,   naomi,    naomi2,   ROT0, "Sega", "King of Route 66 (Rev A)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
-// 0095 Soul Surfer
+/* 0095 */ GAME( 2002, soulsurf, naomi2,   naomi2,   naomi,    naomi2,   ROT0, "Sega", "Soul Surfer (Rev A)", GAME_FLAGS )
 /* 0106 */ GAME( 2002, vf4evoct, naomi2,   naomi2m1, naomi,    vf4evoct, ROT0, "Sega", "Virtua Fighter 4 Evolution (Cartridge)", GAME_UNEMULATED_PROTECTION|GAME_FLAGS )
 // 0129 Club Kart Prize
 
@@ -7904,7 +7948,7 @@
 // 0032A Initial D Arcade Stage Ver. 3 (Japan) (Rev A)
 /* 0032B */ GAME( 2004, initdv3jb, initdv3j, naomigd, naomi,    naomi2,   ROT0, "Sega", "Initial D Arcade Stage Ver. 3 (Japan) (Rev. B) (GDS-0032B)", GAME_FLAGS )
 /* 0032C */ GAME( 2004, initdv3j,  naomi2,   naomi2gd,naomi,    naomi2,   ROT0, "Sega", "Initial D Arcade Stage Ver. 3 (Japan) (Rev. C) (GDS-0032C)", GAME_FLAGS )
-// 0033  Initial D Arcade Stage Ver. 3 (Export)
+/* 0033 */  GAME( 2004, initdv3e,  naomi2,   naomi2gd,naomi,    naomi2,   ROT0, "Sega", "Initial D Arcade Stage Ver. 3 (Export) (GDS-0033)", GAME_FLAGS )
 // 0034
 // 0035
 // 0036  Virtua Fighter 4 Final Tuned
diff -Nru src-old/mame/drivers/naughtyb.c src/mame/drivers/naughtyb.c
--- src-old/mame/drivers/naughtyb.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/naughtyb.c	2012-02-18 03:48:45.000000000 +0100
@@ -746,9 +746,9 @@
 
 ROM_START( trvmstrb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ic30-3.bin",   0x0000, 0x1000, CRC(d3eb4197) SHA1(5843ffc8ec82ffe9a6519180e54c82b0375cc3dc) )
-	ROM_LOAD( "ic28.bin",     0x1000, 0x1000, CRC(70322d65) SHA1(498102236390f2e15444943e0fff8a53f37db083) )
-	ROM_LOAD( "ic26.bin",     0x2000, 0x1000, CRC(31dfa9cf) SHA1(007c6ef2381ce9e707932c66a451805cec342eeb) )
+	ROM_LOAD( "ic30_b.bin",   0x0000, 0x1000, CRC(d3eb4197) SHA1(5843ffc8ec82ffe9a6519180e54c82b0375cc3dc) )
+	ROM_LOAD( "ic28_b.bin",   0x1000, 0x1000, CRC(70322d65) SHA1(498102236390f2e15444943e0fff8a53f37db083) )
+	ROM_LOAD( "ic26_b.bin",   0x2000, 0x1000, CRC(31dfa9cf) SHA1(007c6ef2381ce9e707932c66a451805cec342eeb) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
 	ROM_LOAD( "ic44.bin",     0x0000, 0x1000, CRC(dac8cff7) SHA1(21da2b2ceb4a726d03b2e49a2df75ca66b89a197) )
diff -Nru src-old/mame/drivers/neodrvr.c src/mame/drivers/neodrvr.c
--- src-old/mame/drivers/neodrvr.c	2012-02-04 16:09:04.000000000 +0100
+++ src/mame/drivers/neodrvr.c	2012-02-19 16:23:23.000000000 +0100
@@ -8887,8 +8887,9 @@
 
 	NEO_BIOS_AUDIO_512K( "1b.bin", CRC(7b1f86f7) SHA1(15b6af7f9fbd0f1f6a1ecd912200ca8d0af2da2a) )
 
-	ROM_REGION( 0x200000, "ymsnd", 0 )
-	ROM_LOAD( "sbp.snd", 0x000000, 0x080000, NO_DUMP )
+	ROM_REGION( 0x800000, "ymsnd", 0 )
+	ROM_LOAD( "12a.bin", 0x000000, 0x400000, CRC(c96723b9) SHA1(52eec88550781d45f84efbf9b905d7e7912e96fa) )
+	ROM_LOAD( "13a.bin", 0x400000, 0x400000, CRC(08c339a5) SHA1(badc9510ae243ef2a7877977eb36efa81b1489fe) )
 
 	NO_DELTAT_REGION
 
diff -Nru src-old/mame/drivers/nightgal.c src/mame/drivers/nightgal.c
--- src-old/mame/drivers/nightgal.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/nightgal.c	2012-02-18 03:48:45.000000000 +0100
@@ -1131,11 +1131,11 @@
 
 ROM_START( sweetgal )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "10.3n",  0x00000, 0x04000, CRC(0f6c4bf0) SHA1(50e5c6f08e124641f5df8938ccfcdebde18f6a0f) )
+	ROM_LOAD( "10_sw.3n",  0x00000, 0x04000, CRC(0f6c4bf0) SHA1(50e5c6f08e124641f5df8938ccfcdebde18f6a0f) )
 	ROM_LOAD( "11.3p", 0x04000, 0x04000, CRC(7388e9b3) SHA1(e318d2d3888679bbd43a0aab68252fd359b7969d) )
 
 	ROM_REGION( 0x10000, "sub", 0 )
-	ROM_LOAD( "1.3a", 0x0e000, 0x2000, CRC(5342c757) SHA1(b4ff84c45bd2c6a6a468f1d0daaf5b19c4dbf8fe) )
+	ROM_LOAD( "1_sw.3a", 0x0e000, 0x2000, CRC(5342c757) SHA1(b4ff84c45bd2c6a6a468f1d0daaf5b19c4dbf8fe) )
 
 	ROM_REGION( 0xc000, "samples", 0 ) // sound samples
 	ROM_LOAD( "v2_12.bin",  0x00000, 0x04000, CRC(66a35be2) SHA1(4f0d73d753387acacc5ccc90e91d848a5ecce55e) )
@@ -1143,8 +1143,8 @@
 	ROM_LOAD( "v2_14.bin",  0x08000, 0x04000, CRC(149e84c1) SHA1(5c4e18637bef2f31bc3578cae6525fb6280fbc06) )
 
 	ROM_REGION( 0x20000, "gfx1", 0 )
-	ROM_LOAD( "2.3c",  0x00000, 0x04000, CRC(3a3d78f7) SHA1(71e35529f30c43ee8ec2363f85fe17042f1d304e) )
-	ROM_LOAD( "3.3d",  0x04000, 0x04000, CRC(c6f9b884) SHA1(32d6fe1906a3f1f528f30dbd3f89971b2ea1925b) )
+	ROM_LOAD( "2_sw.3c",  0x00000, 0x04000, CRC(3a3d78f7) SHA1(71e35529f30c43ee8ec2363f85fe17042f1d304e) )
+	ROM_LOAD( "3_sw.3d",  0x04000, 0x04000, CRC(c6f9b884) SHA1(32d6fe1906a3f1f528f30dbd3f89971b2ea1925b) )
 	// all roms below match sexygal
 	ROM_LOAD( "4.3e",  0x08000, 0x04000, CRC(f1cdbedb) SHA1(caacf2887a3a05e498d57d570a1e9873f95a5d5f) )
 	ROM_LOAD( "5.3f",  0x0c000, 0x04000, CRC(76569186) SHA1(79cb32c1f1a96f90d59f331a01ca548936933b87) )
diff -Nru src-old/mame/drivers/ninjakd2.c src/mame/drivers/ninjakd2.c
--- src-old/mame/drivers/ninjakd2.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/ninjakd2.c	2012-02-19 02:53:16.000000000 +0100
@@ -226,8 +226,8 @@
 
 static SAMPLES_START( ninjakd2_init_samples )
 {
-	ninjakd2_state *state = device->machine().driver_data<ninjakd2_state>();
-	running_machine &machine = device->machine();
+	ninjakd2_state *state = device.machine().driver_data<ninjakd2_state>();
+	running_machine &machine = device.machine();
 	const UINT8* const rom = machine.region("pcm")->base();
 	const int length = machine.region("pcm")->bytes();
 	INT16* sampledata = auto_alloc_array(machine, INT16, length);
@@ -244,7 +244,7 @@
 static WRITE8_HANDLER( ninjakd2_pcm_play_w )
 {
 	ninjakd2_state *state = space->machine().driver_data<ninjakd2_state>();
-	device_t *samples = space->machine().device("pcm");
+	samples_device *samples = space->machine().device<samples_device>("pcm");
 	const UINT8* const rom = space->machine().region("pcm")->base();
 
 	// only Ninja Kid II uses this
@@ -262,9 +262,9 @@
 			++end;
 
 		if (end - start)
-			sample_start_raw(samples, 0, &state->m_sampledata[start], end - start, NE555_FREQUENCY, 0);
+			samples->start_raw(0, &state->m_sampledata[start], end - start, NE555_FREQUENCY);
 		else
-			sample_stop(samples, 0);
+			samples->stop(0);
 	}
 }
 
@@ -979,8 +979,7 @@
 	MCFG_SOUND_ROUTE(2, "mono", 0.10)
 	MCFG_SOUND_ROUTE(3, "mono", 0.50)
 
-	MCFG_SOUND_ADD("pcm", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(ninjakd2_samples_interface)
+	MCFG_SAMPLES_ADD("pcm", ninjakd2_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/nwk-tr.c src/mame/drivers/nwk-tr.c
--- src-old/mame/drivers/nwk-tr.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/nwk-tr.c	2012-02-18 03:48:45.000000000 +0100
@@ -638,9 +638,9 @@
 static void sound_irq_callback(running_machine &machine, int irq)
 {
 	if (irq == 0)
-		generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ1);
+		generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ1, 1);
 	else
-		generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ2);
+		generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ2, 1);
 }
 
 static const k056800_interface nwktr_k056800_interface =
@@ -766,7 +766,7 @@
 	ROM_LOAD( "676a10.14p",   0x400000, 0x400000, CRC(7b5b7828) SHA1(aec224d62e4b1e8fdb929d7947ce70d84ba676cf) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1", 0x000000, 0x002000, CRC(47e1628c) SHA1(7c42d06ae2f2cd24d083890f333552cbf4f1d3c9) )
+	ROM_LOAD( "racingj_m48t58y-70pc1", 0x000000, 0x002000, CRC(47e1628c) SHA1(7c42d06ae2f2cd24d083890f333552cbf4f1d3c9) )
 ROM_END
 
 ROM_START(racingj2j)
@@ -790,7 +790,7 @@
 	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1", 0x000000, 0x002000, CRC(f691f5ab) SHA1(e81f652c5caa2caa8bd1c6d6db488d849bda058e) )
+	ROM_LOAD( "racingj2j_m48t58y-70pc1", 0x000000, 0x002000, CRC(f691f5ab) SHA1(e81f652c5caa2caa8bd1c6d6db488d849bda058e) )
 ROM_END
 
 ROM_START(racingj2)
@@ -814,7 +814,7 @@
 	ROM_LOAD( "888a10.14p",   0x400000, 0x400000, CRC(328ce610) SHA1(dbbc779a1890c53298c0db129d496df048929496) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1.35d", 0x000000, 0x002000, CRC(1aa43a1f) SHA1(814b691b8a358bf1545a13d595d17070e612e9a4) )
+	ROM_LOAD( "racingj2_m48t58y-70pc1.35d", 0x000000, 0x002000, CRC(1aa43a1f) SHA1(814b691b8a358bf1545a13d595d17070e612e9a4) )
 ROM_END
 
 ROM_START(thrilld)
@@ -837,7 +837,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
+	ROM_LOAD( "thrilld_m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
 ROM_END
 
 ROM_START(thrilldb)
@@ -860,7 +860,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
+	ROM_LOAD( "thrilldb_m48t58y-70pc1", 0x000000, 0x002000, CRC(5d8fbcb2) SHA1(74ad91544d2a200cf599a565005476623075e7d6) )
 ROM_END
 
 ROM_START(thrilldae)
@@ -883,7 +883,7 @@
 	ROM_LOAD( "713a10.14p",   0x400000, 0x400000, CRC(27f9833e) SHA1(1540f00d2571ecb81b914c553682b67fca94bbbd) )
 
 	ROM_REGION(0x2000, "m48t58",0)
-	ROM_LOAD( "m48t58y-70pc1", 0x000000, 0x002000, CRC(056ea8fa) SHA1(23574e0c1d011dab8644f3d98763d4a2d11a05b3)  )
+	ROM_LOAD( "thrilldae_m48t58y-70pc1", 0x000000, 0x002000, CRC(056ea8fa) SHA1(23574e0c1d011dab8644f3d98763d4a2d11a05b3)  )
 ROM_END
 
 /*****************************************************************************/
diff -Nru src-old/mame/drivers/pacman.c src/mame/drivers/pacman.c
--- src-old/mame/drivers/pacman.c	2012-01-30 01:05:45.000000000 +0100
+++ src/mame/drivers/pacman.c	2012-02-19 01:27:36.000000000 +0100
@@ -3635,20 +3635,20 @@
 
 ROM_START( popeyeman )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1.6e",   0x0000, 0x0800, CRC(9d027c4a) SHA1(88e094880057451a75cdc2ce9477403021813982) )
-	ROM_LOAD( "5.6k",   0x0800, 0x0800, CRC(194c7189) SHA1(fd423bac2810015313841c7b935054565390fbd0) )
-	ROM_LOAD( "2.6f",   0x1000, 0x0800, CRC(5ba228bb) SHA1(b0e902cdf98bee72d6ec8069eec96adce3245074) )
-	ROM_LOAD( "6.6m",   0x1800, 0x0800, CRC(baf5461e) SHA1(754586a6449fd54a342f260e572c1cd60ab70815) )
-	ROM_LOAD( "3.6h",   0x2000, 0x0800, CRC(08419c4a) SHA1(7e5001adad401080c788737c1d2349f218750442) )
-	ROM_LOAD( "7.6n",   0x2800, 0x0800, CRC(ab74b51f) SHA1(1bce8933ed7807eb7aca9670df8994f8d1a8b5b7) )
-	ROM_LOAD( "4.6j",   0x3000, 0x0800, CRC(5039b082) SHA1(086a6ac4742734167d283b1121fce29d8ac4a6cd) )
-	ROM_LOAD( "8.6p",   0x3800, 0x0800, CRC(931770d7) SHA1(78fcf88e07ec5126c12c3297b62ca388809e947c) )
+	ROM_LOAD( "pop1.6e",      0x0000, 0x0800, CRC(9d027c4a) SHA1(88e094880057451a75cdc2ce9477403021813982) )
+	ROM_LOAD( "pop5.6k",      0x0800, 0x0800, CRC(194c7189) SHA1(fd423bac2810015313841c7b935054565390fbd0) )
+	ROM_LOAD( "pop2.6f",      0x1000, 0x0800, CRC(5ba228bb) SHA1(b0e902cdf98bee72d6ec8069eec96adce3245074) )
+	ROM_LOAD( "pop6.6m",      0x1800, 0x0800, CRC(baf5461e) SHA1(754586a6449fd54a342f260e572c1cd60ab70815) )
+	ROM_LOAD( "pop3.6h",      0x2000, 0x0800, CRC(08419c4a) SHA1(7e5001adad401080c788737c1d2349f218750442) )
+	ROM_LOAD( "pop7.6n",      0x2800, 0x0800, CRC(ab74b51f) SHA1(1bce8933ed7807eb7aca9670df8994f8d1a8b5b7) )
+	ROM_LOAD( "pop4.6j",      0x3000, 0x0800, CRC(5039b082) SHA1(086a6ac4742734167d283b1121fce29d8ac4a6cd) )
+	ROM_LOAD( "pop8.6p",      0x3800, 0x0800, CRC(931770d7) SHA1(78fcf88e07ec5126c12c3297b62ca388809e947c) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
-	ROM_LOAD( "9.5e",	0x0000, 0x0800, CRC(b569c4c1) SHA1(34a09bcb6eb08375cd5e9ce0aa66b23d60489f92) )
-	ROM_LOAD( "11.5h",  0x0800, 0x0800, CRC(3591b89d) SHA1(79bb456be6c39c1ccd7d077fbe181523131fb300) )
-	ROM_LOAD( "10.5f",	0x1000, 0x0800, CRC(014fb5a4) SHA1(7779f0f0d11027adf3b9175af26d53f1e3a54f29) )
-	ROM_LOAD( "12.5j",	0x1800, 0x0800, CRC(21b91c64) SHA1(4818194ecc18b5df159f3799ea93c911fd4b9556) )
+	ROM_LOAD( "pop9.5e",      0x0000, 0x0800, CRC(b569c4c1) SHA1(34a09bcb6eb08375cd5e9ce0aa66b23d60489f92) )
+	ROM_LOAD( "pop11.5h",     0x0800, 0x0800, CRC(3591b89d) SHA1(79bb456be6c39c1ccd7d077fbe181523131fb300) )
+	ROM_LOAD( "pop10.5f",     0x1000, 0x0800, CRC(014fb5a4) SHA1(7779f0f0d11027adf3b9175af26d53f1e3a54f29) )
+	ROM_LOAD( "pop12.5j",     0x1800, 0x0800, CRC(21b91c64) SHA1(4818194ecc18b5df159f3799ea93c911fd4b9556) )
 
 	ROM_REGION( 0x0120, "proms", 0 )
 	ROM_LOAD( "82s123.7f",    0x0000, 0x0020, CRC(2fc650bd) SHA1(8d0268dee78e47c712202b0ec4f1f51109b1f2a5) )
@@ -3731,12 +3731,12 @@
 
 ROM_START( pacheart )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1.6e",         0x0000, 0x0800, CRC(d844b679) SHA1(c4486198b3126bb8e05a308c53787e51065f77ae) )
+	ROM_LOAD( "pacheart1.6e", 0x0000, 0x0800, CRC(d844b679) SHA1(c4486198b3126bb8e05a308c53787e51065f77ae) )
 	ROM_LOAD( "pacheart.pg2", 0x0800, 0x0800, CRC(b9152a38) SHA1(b6be2cb6bc7dd123503eb6bf1165dd1c99456813) )
-	ROM_LOAD( "2.6f",         0x1000, 0x0800, CRC(7d177853) SHA1(9b5ddaaa8b564654f97af193dbcc29f81f230a25) )
+	ROM_LOAD( "pacheart2.6f", 0x1000, 0x0800, CRC(7d177853) SHA1(9b5ddaaa8b564654f97af193dbcc29f81f230a25) )
 	ROM_LOAD( "pacheart.pg4", 0x1800, 0x0800, CRC(842d6574) SHA1(40e32d09cc8d701eb318716493a68cf3f95d3d6d) )
-	ROM_LOAD( "3.6h",         0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
-	ROM_LOAD( "7.6n",         0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
+	ROM_LOAD( "pacheart3.6h", 0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
+	ROM_LOAD( "pacheart7.6n", 0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
 	ROM_LOAD( "pacheart.pg7", 0x3000, 0x0800, CRC(f5265c10) SHA1(9a320790d7a03fd6192a92d30b3e9c754bbc6a9d) )
 	ROM_LOAD( "pacheart.pg8", 0x3800, 0x0800, CRC(1a21a381) SHA1(d5367a327d19fb57ba5e484bd4fda1b10953c040) )
 
@@ -3757,20 +3757,20 @@
 
 ROM_START( bucaner )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1.6e", 0x0000, 0x0800, CRC(2c0fa0ab) SHA1(37680e4502771ae69d51d07ce43f65b9b2dd2a49) )
-	ROM_LOAD( "5.6k", 0x0800, 0x0800, CRC(afeca2f1) SHA1(1e6d6c75eeb3a354ce2dc88da62caf9e7d53d0cb) )
-	ROM_LOAD( "2.6f", 0x1000, 0x0800, CRC(6b53ada9) SHA1(a905688b389bfbc6792965d8f3d5bb1b9f0f4ec6) )
-	ROM_LOAD( "6.6m", 0x1800, 0x0800, CRC(35f3ca84) SHA1(3da7336caa0742ea79f1e0e8f6b80f8560507a33) )
-	ROM_LOAD( "3.6h", 0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
-	ROM_LOAD( "7.6n", 0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
-	ROM_LOAD( "4.6j", 0x3000, 0x0800, CRC(292de161) SHA1(09b439c301d7bedb76c1590e937e9d8d5e24a048) )
-	ROM_LOAD( "8.6p", 0x3800, 0x0800, CRC(884af858) SHA1(bad8b0dfdaf221dff0f84928f20873b01a168be5) )
+	ROM_LOAD( "buc1.6e",      0x0000, 0x0800, CRC(2c0fa0ab) SHA1(37680e4502771ae69d51d07ce43f65b9b2dd2a49) )
+	ROM_LOAD( "buc5.6k",      0x0800, 0x0800, CRC(afeca2f1) SHA1(1e6d6c75eeb3a354ce2dc88da62caf9e7d53d0cb) )
+	ROM_LOAD( "buc2.6f",      0x1000, 0x0800, CRC(6b53ada9) SHA1(a905688b389bfbc6792965d8f3d5bb1b9f0f4ec6) )
+	ROM_LOAD( "buc6.6m",      0x1800, 0x0800, CRC(35f3ca84) SHA1(3da7336caa0742ea79f1e0e8f6b80f8560507a33) )
+	ROM_LOAD( "buc3.6h",      0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
+	ROM_LOAD( "buc7.6n",      0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
+	ROM_LOAD( "buc4.6j",      0x3000, 0x0800, CRC(292de161) SHA1(09b439c301d7bedb76c1590e937e9d8d5e24a048) )
+	ROM_LOAD( "buc8.6p",      0x3800, 0x0800, CRC(884af858) SHA1(bad8b0dfdaf221dff0f84928f20873b01a168be5) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
-	ROM_LOAD( "9.5e",  0x0000, 0x0800, CRC(4060c077) SHA1(78d4aa5243246f73533fc0886438dc1fa6f7ebe5) )
-	ROM_LOAD( "11.5h", 0x0800, 0x0800, CRC(e3861283) SHA1(61cf8ed24902910e98438d9e2e2745f226ad2a13) )
-	ROM_LOAD( "10.5f", 0x1000, 0x0800, CRC(09f66dec) SHA1(2d3649341fed19bac15ec274f7d747de46a3edb2) )
-	ROM_LOAD( "12.5j", 0x1800, 0x0800, CRC(653314e7) SHA1(c466a421917b3502e9115ebda1b2d11f7f586de8) )
+	ROM_LOAD( "buc9.5e",      0x0000, 0x0800, CRC(4060c077) SHA1(78d4aa5243246f73533fc0886438dc1fa6f7ebe5) )
+	ROM_LOAD( "buc11.5h",     0x0800, 0x0800, CRC(e3861283) SHA1(61cf8ed24902910e98438d9e2e2745f226ad2a13) )
+	ROM_LOAD( "buc10.5f",     0x1000, 0x0800, CRC(09f66dec) SHA1(2d3649341fed19bac15ec274f7d747de46a3edb2) )
+	ROM_LOAD( "buc12.5j",     0x1800, 0x0800, CRC(653314e7) SHA1(c466a421917b3502e9115ebda1b2d11f7f586de8) )
 
 	ROM_REGION( 0x0120, "proms", 0 )
 	ROM_LOAD( "82s123.7f",    0x0000, 0x0020, CRC(2fc650bd) SHA1(8d0268dee78e47c712202b0ec4f1f51109b1f2a5) )
@@ -3783,20 +3783,20 @@
 
 ROM_START( joyman )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "1.6e",         0x0000, 0x0800, CRC(d844b679) SHA1(c4486198b3126bb8e05a308c53787e51065f77ae) )
-	ROM_LOAD( "5.6k",         0x0800, 0x0800, CRC(ab9c8f29) SHA1(3753b8609c30d85d89acf745cf9303b77be440fd) )
-	ROM_LOAD( "2.6f",         0x1000, 0x0800, CRC(7d177853) SHA1(9b5ddaaa8b564654f97af193dbcc29f81f230a25) )
-	ROM_LOAD( "6.6m",         0x1800, 0x0800, CRC(b3c8d32e) SHA1(8b336fca1300820308cd5c4efc60bf2ba4199302) )
-	ROM_LOAD( "3.6h",         0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
-	ROM_LOAD( "7.6n",         0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
-	ROM_LOAD( "4.6j",         0x3000, 0x0800, CRC(00b553f8) SHA1(57f2e4a6da9f00935fead447b2123a8b95e5d672) )
-	ROM_LOAD( "8.6p",         0x3800, 0x0800, CRC(5d5ce992) SHA1(ced7ed39cfc7ec7b2c0459e275577976109ee82f) )
+	ROM_LOAD( "joy1.6e",      0x0000, 0x0800, CRC(d844b679) SHA1(c4486198b3126bb8e05a308c53787e51065f77ae) )
+	ROM_LOAD( "joy5.6k",      0x0800, 0x0800, CRC(ab9c8f29) SHA1(3753b8609c30d85d89acf745cf9303b77be440fd) )
+	ROM_LOAD( "joy2.6f",      0x1000, 0x0800, CRC(7d177853) SHA1(9b5ddaaa8b564654f97af193dbcc29f81f230a25) )
+	ROM_LOAD( "joy6.6m",      0x1800, 0x0800, CRC(b3c8d32e) SHA1(8b336fca1300820308cd5c4efc60bf2ba4199302) )
+	ROM_LOAD( "joy3.6h",      0x2000, 0x0800, CRC(9045a44c) SHA1(a97d7016effbd2ace9a7d92ceb04a6ce18fb42f9) )
+	ROM_LOAD( "joy7.6n",      0x2800, 0x0800, CRC(888f3c3e) SHA1(c2b5917bf13071131dd53ea76f0da86706db2d80) )
+	ROM_LOAD( "joy4.6j",      0x3000, 0x0800, CRC(00b553f8) SHA1(57f2e4a6da9f00935fead447b2123a8b95e5d672) )
+	ROM_LOAD( "joy8.6p",      0x3800, 0x0800, CRC(5d5ce992) SHA1(ced7ed39cfc7ec7b2c0459e275577976109ee82f) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
-	ROM_LOAD( "9.5e",  0x0000, 0x0800, CRC(39b557bc) SHA1(0f602ec84cb25fced89699e430b95b5ae93c83bd) )
-	ROM_LOAD( "11.5h", 0x0800, 0x0800, CRC(33e0289e) SHA1(c1b910bdc61e560a8c34298deb11401f718e7330) )
-	ROM_LOAD( "10.5f", 0x1000, 0x0800, CRC(338771a6) SHA1(7cd68cc428986255d0de29aae894900519e7fda5) )
-	ROM_LOAD( "12.5j", 0x1800, 0x0800, CRC(f4f0add5) SHA1(d71c54ef55a755ec1316623d183b4f615ef7c055) )
+	ROM_LOAD( "joy9.5e",      0x0000, 0x0800, CRC(39b557bc) SHA1(0f602ec84cb25fced89699e430b95b5ae93c83bd) )
+	ROM_LOAD( "joy11.5h",     0x0800, 0x0800, CRC(33e0289e) SHA1(c1b910bdc61e560a8c34298deb11401f718e7330) )
+	ROM_LOAD( "joy10.5f",     0x1000, 0x0800, CRC(338771a6) SHA1(7cd68cc428986255d0de29aae894900519e7fda5) )
+	ROM_LOAD( "joy12.5j",     0x1800, 0x0800, CRC(f4f0add5) SHA1(d71c54ef55a755ec1316623d183b4f615ef7c055) )
 
 	ROM_REGION( 0x0120, "proms", 0 )
 	ROM_LOAD( "82s123.7f",    0x0000, 0x0020, CRC(2fc650bd) SHA1(8d0268dee78e47c712202b0ec4f1f51109b1f2a5) )
@@ -4547,6 +4547,33 @@
 ROM_END
 
 
+ROM_START( eyesb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "1.bin",           0x0000, 0x0800, CRC(339d279a) SHA1(bc2a7801b9f94782f260346255f84a0e84729f01) )
+	ROM_LOAD( "5.bin",           0x0800, 0x0800, CRC(1b68a61d) SHA1(348ef7b19934b000b03c74bec4796f1089dfc5eb) )
+	ROM_LOAD( "2.bin",           0x1000, 0x0800, CRC(d4f9aaf8) SHA1(1e450a7ecf42f9bc2d58823907930dd7aa454215) )
+	ROM_LOAD( "6.bin",           0x1800, 0x0800, CRC(6b41bb80) SHA1(aa3555833a2e8e596e126a749fe12853e4aa05b1) )
+	ROM_LOAD( "3.bin",           0x2000, 0x0800, CRC(748e0e48) SHA1(857de6f7fe79a2613a93fb3efd981edb64c0190e) )
+	ROM_LOAD( "7.bin",           0x2800, 0x0800, CRC(7b7f4a74) SHA1(373229de4ed25d577fe15deb3b6bc36786988284) )
+	ROM_LOAD( "4.bin",           0x3000, 0x0800, CRC(367a3884) SHA1(d55d7eca56412661adac1849a398298670e86d15) )
+	ROM_LOAD( "8.bin",           0x3800, 0x0800, CRC(2baaadae) SHA1(7b20ed5935e9a4f793f690bab2a6bc0db44d12af) )
+
+	ROM_REGION( 0x2000, "gfx1", 0 )
+	ROM_LOAD( "9.bin",           0x0000, 0x0800, CRC(342c0653) SHA1(d07e3d4528b72e54a1b5dbed009cce765a5a086f) )
+	ROM_LOAD( "11.bin",          0x0800, 0x0800, CRC(aaa7a537) SHA1(571d981ed2aad62d7c7f2798e9084228d45523d4) )
+	ROM_LOAD( "10.bin",          0x1000, 0x0800, CRC(b247b82c) SHA1(8c10a8ef5e79b0b5fefad6eb77bfa68a0ca18035) )
+	ROM_LOAD( "12.bin",          0x1800, 0x0800, CRC(99af4b30) SHA1(6a0939ff2fa7ae39a960dd4d9f9b7c01f57647c5) )
+
+	ROM_REGION( 0x0120, "proms", 0 )
+	ROM_LOAD( "7051.bin",        0x0000, 0x0020, CRC(0dad2ccb) SHA1(f42c5ee7084e5702b5b0c8c1d86b0a41a6e1821d) )
+	ROM_LOAD( "7051-3.bin",      0x0020, 0x0100, CRC(d8d78829) SHA1(19820d1651423210083a087fb70ebea73ad34951) )
+
+	ROM_REGION( 0x0200, "namco", 0 )	/* sound PROMs */
+	ROM_LOAD( "82s126.1m",       0x0000, 0x0100, CRC(a9cc86bf) SHA1(bbcec0570aeceb582ff8238a4bc8546a23430081) )	// not dumped, taken from parent
+	ROM_LOAD( "7051-2.bin",      0x0100, 0x0100, CRC(77245b66) SHA1(0c4d0bee858b97632411c440bea6948a74759746) )	// two of these?
+ROM_END
+
+
 ROM_START( eyeszac )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "1.7d",         0x0000, 0x1000, BAD_DUMP CRC(568851aa) SHA1(a97963556a6d77400afaafd73bcc32cb7f3a54d2) ) // 2532 vs 2732 problem, (near)identical halves
@@ -4571,16 +4598,16 @@
  roms marked with a comment were in the set but we're not using them */
 ROM_START( eyeszacb )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-/**/ROM_LOAD( "11.bin",          0x0000, 0x0800, CRC(69c1602a) SHA1(47b0935406b7ee2f414de58da1d4e81c6277a0c2) ) // "no diagnostics, bad custom??" (unused)
-	ROM_LOAD( "1.bin",           0x0000, 0x0800, CRC(a4a9d7a0) SHA1(f0b807d2fa347e50df52971aa7539a88f342bad6) )
-	ROM_LOAD( "5.bin",           0x0800, 0x0800, CRC(c32b3f73) SHA1(80d2e987f0318b984e5c7c4d0b5faa262eebeca4) )
-	ROM_LOAD( "2.bin",           0x1000, 0x0800, CRC(195b9473) SHA1(62eb16af38cc9004787dc55433ed3db11af44a4b) )
-	ROM_LOAD( "6.bin",           0x1800, 0x0800, CRC(292886cb) SHA1(e77c3724c7cd8cd95014194ba4bb2f7e04afb0dd) )
+        ROM_LOAD( "zacb_11.bin",  0x0000, 0x0800, CRC(69c1602a) SHA1(47b0935406b7ee2f414de58da1d4e81c6277a0c2) ) // "no diagnostics, bad custom??" (unused)
+	ROM_LOAD( "zacb_1.bin",   0x0000, 0x0800, CRC(a4a9d7a0) SHA1(f0b807d2fa347e50df52971aa7539a88f342bad6) )
+	ROM_LOAD( "zacb_5.bin",   0x0800, 0x0800, CRC(c32b3f73) SHA1(80d2e987f0318b984e5c7c4d0b5faa262eebeca4) )
+	ROM_LOAD( "zacb_2.bin",   0x1000, 0x0800, CRC(195b9473) SHA1(62eb16af38cc9004787dc55433ed3db11af44a4b) )
+	ROM_LOAD( "zacb_6.bin",   0x1800, 0x0800, CRC(292886cb) SHA1(e77c3724c7cd8cd95014194ba4bb2f7e04afb0dd) )
 //  ROM_LOAD( "33.bin",          0x2000, 0x0800, CRC(df983e1d) SHA1(7c06fc69b7d0424f7b9348649d5587ff4d6dfc2d) ) // alt rom with copyright removed (unused)
-	ROM_LOAD( "3.bin",           0x2000, 0x0800, CRC(ff94b015) SHA1(6d8f43db3c98cadb35f70e3bff788e653dc132cd) )
-	ROM_LOAD( "7.bin",           0x2800, 0x0800, CRC(9271c58c) SHA1(e6b8f1807c5852ae4e822d80719a4e8f8b036c31) )
-	ROM_LOAD( "4.bin",           0x3000, 0x0800, CRC(965cf32b) SHA1(68cc573a24c74f2ab417d0330fc9523e77fda961) )
-	ROM_LOAD( "8.bin",           0x3800, 0x0800, CRC(c254e92e) SHA1(023b45403ebc69c29516d77950dc69f05a1a130c) )
+	ROM_LOAD( "zacb_3.bin",   0x2000, 0x0800, CRC(ff94b015) SHA1(6d8f43db3c98cadb35f70e3bff788e653dc132cd) )
+	ROM_LOAD( "zacb_7.bin",   0x2800, 0x0800, CRC(9271c58c) SHA1(e6b8f1807c5852ae4e822d80719a4e8f8b036c31) )
+	ROM_LOAD( "zacb_4.bin",   0x3000, 0x0800, CRC(965cf32b) SHA1(68cc573a24c74f2ab417d0330fc9523e77fda961) )
+	ROM_LOAD( "zacb_8.bin",   0x3800, 0x0800, CRC(c254e92e) SHA1(023b45403ebc69c29516d77950dc69f05a1a130c) )
 
 	ROM_REGION( 0x2000, "gfx1", 0 )
 	ROM_LOAD( "x.bin",           0x0000, 0x0800, CRC(59dce22e) SHA1(81eaef3e4d8299b5133b62d04460abfa519696f5) )
@@ -5898,8 +5925,9 @@
 GAME( 1982, ctrpllrp, puckman,  pacman,   pacman,   0,        ROT90,  "hack", "Caterpillar Pacman Hack", GAME_SUPPORTS_SAVE )
 GAME( 1982, eyes,     0,        pacman,   eyes,     eyes,     ROT90,  "Digitrex Techstar (Rock-Ola license)", "Eyes (US set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1982, eyes2,    eyes,     pacman,   eyes,     eyes,     ROT90,  "Techstar (Rock-Ola license)", "Eyes (US set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1982, eyesb,    eyes,     pacman,   eyes,     eyes,     ROT90,  "bootleg", "Eyes (bootleg set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1982, eyeszac,  eyes,     pacman,   eyes,     eyes,     ROT90,  "Techstar (Zaccaria license)", "Eyes (Italy)", GAME_SUPPORTS_SAVE | GAME_NOT_WORKING ) // bad dump
-GAME( 1982, eyeszacb, eyes,     pacman,   eyes,     0,        ROT90,  "bootleg", "Eyes (bootleg)", GAME_SUPPORTS_SAVE ) // based on Zaccaria version
+GAME( 1982, eyeszacb, eyes,     pacman,   eyes,     0,        ROT90,  "bootleg", "Eyes (bootleg set 2, decrypted)", GAME_SUPPORTS_SAVE ) // based on Zaccaria version
 GAME( 1983, birdiy,   0,        birdiy,   pacman,   0,        ROT270, "Mama Top", "Birdiy", GAME_SUPPORTS_SAVE )
 GAME( 1983, mrtnt,    0,        pacman,   mrtnt,    eyes,     ROT90,  "Techstar (Telko license)", "Mr. TNT", GAME_SUPPORTS_SAVE )
 GAME( 1983, gorkans,  mrtnt,    pacman,   mrtnt,    0,        ROT90,  "Techstar", "Gorkans", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/pgm.c src/mame/drivers/pgm.c
--- src-old/mame/drivers/pgm.c	2012-01-30 15:13:49.000000000 +0100
+++ src/mame/drivers/pgm.c	2012-02-11 11:01:01.000000000 +0100
@@ -313,7 +313,7 @@
 		logerror("M68K: Latch write: %04x (%04x) (%06x)\n", data & 0x0000ffff, mem_mask, cpu_get_pc(&space->device()));
 	COMBINE_DATA(&state->m_kov2_latchdata_68k_w);
 
-	generic_pulse_irq_line(state->m_prot, ARM7_FIRQ_LINE);
+	generic_pulse_irq_line(state->m_prot, ARM7_FIRQ_LINE, 1);
 	space->machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(200));
 	device_spin_until_time(&space->device(), state->m_prot->cycles_to_attotime(200)); // give the arm time to respond (just boosting the interleave doesn't help)
 }
@@ -562,7 +562,7 @@
 static WRITE16_HANDLER( svg_68k_nmi_w )
 {
 	pgm_state *state = space->machine().driver_data<pgm_state>();
-	generic_pulse_irq_line(state->m_prot, ARM7_FIRQ_LINE);
+	generic_pulse_irq_line(state->m_prot, ARM7_FIRQ_LINE, 1);
 	space->machine().scheduler().boost_interleave(attotime::zero, attotime::from_usec(200));
 	device_spin_until_time(&space->device(), state->m_prot->cycles_to_attotime(200)); // give the arm time to respond (just boosting the interleave doesn't help)
 }
diff -Nru src-old/mame/drivers/pinkiri8.c src/mame/drivers/pinkiri8.c
--- src-old/mame/drivers/pinkiri8.c	2012-01-24 21:18:55.000000000 +0100
+++ src/mame/drivers/pinkiri8.c	2012-02-06 02:30:22.000000000 +0100
@@ -33,7 +33,6 @@
 #include "emu.h"
 #include "cpu/z180/z180.h"
 #include "sound/okim6295.h"
-#include "video/generic.h"
 
 
 class pinkiri8_state : public driver_device
diff -Nru src-old/mame/drivers/pluto5.c src/mame/drivers/pluto5.c
--- src-old/mame/drivers/pluto5.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/pluto5.c	2012-02-19 02:23:50.000000000 +0100
@@ -533,8 +533,8 @@
 GAME( 200?, hb_gldwn	,0,			pluto5, pluto5, hb, ROT0, "Fairgames","Golden Winner (Fairgames)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, hb_jailb	,0,			pluto5, pluto5, hb, ROT0, "Qps","Jail Break (Qps)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, hb_jkrwl	,0,			pluto5, pluto5, hb, ROT0, "Fairgames","Jokers Wild (Fairgames)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, hb_mrmon	,0,			pluto5, pluto5, hb, ROT0, "Qps","Mr Money (Qps)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, hb_mrmon	,0,			pluto5, pluto5, hb, ROT0, "Qps","Mr. Money (Qps)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, hb_rhv		,0,			pluto5, pluto5, hb, ROT0, "Qps","Red Hot Voucher (Qps)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, hb_ringb	,0,			pluto5, pluto5, hb, ROT0, "Jpm","Ring A Bell (Jpm)", GAME_IS_SKELETON_MECHANICAL )
 GAME( 200?, hb_rckrl	,0,			pluto5, pluto5, hb, ROT0, "Qps","Rock 'n' Roll (Qps)", GAME_IS_SKELETON_MECHANICAL )
-GAME( 200?, hb_ydd		,0,			pluto5, pluto5, hb, ROT0, "Qps","Yabba Dabba Dough (Qps)", GAME_IS_SKELETON_MECHANICAL )
+GAME( 200?, hb_ydd		,0,			pluto5, pluto5, hb, ROT0, "Qps","Yabba-Dabba-Dough (Qps)", GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/pntnpuzl.c src/mame/drivers/pntnpuzl.c
--- src-old/mame/drivers/pntnpuzl.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/pntnpuzl.c	2012-02-11 11:01:01.000000000 +0100
@@ -319,7 +319,7 @@
 
 	/* TODO: change this! */
 	if(newval)
-		generic_pulse_irq_line(state->m_maincpu, (UINT8)(FPTR)param);
+		generic_pulse_irq_line(state->m_maincpu, (UINT8)(FPTR)param, 1);
 }
 
 static INPUT_PORTS_START( pntnpuzl )
diff -Nru src-old/mame/drivers/polyplay.c src/mame/drivers/polyplay.c
--- src-old/mame/drivers/polyplay.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/polyplay.c	2012-02-19 02:53:16.000000000 +0100
@@ -300,8 +300,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(polyplay_samples_interface)
+	MCFG_SAMPLES_ADD("samples", polyplay_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/proconn.c src/mame/drivers/proconn.c
--- src-old/mame/drivers/proconn.c	2011-12-23 18:29:55.000000000 +0100
+++ src/mame/drivers/proconn.c	2012-02-14 02:33:01.000000000 +0100
@@ -361,6 +361,7 @@
 	ROM_LOAD( "943a20pn.250", 0x0000, 0x010000, CRC(a6f86f67) SHA1(43b96e2866099af6693aaf03313e119474180934) )
 	ROM_LOAD( "f-wheel.bin", 0x0000, 0x010000, CRC(ecce8953) SHA1(d90a203e3009be73d456a1f028ffe88754175514) )
 	ROM_LOAD( "fortunewheel6.bin", 0x0000, 0x010000, CRC(fa95bf1b) SHA1(e22b6979f01ff545c47fdc58600a42b78ecea731) )
+	ROM_LOAD( "943a206n.258", 0x0000, 0x010000, CRC(3ef23263) SHA1(40fb4399e4ac34fcb52aaca6ec19a38723bc8031) )//6GBP
 
 	ROM_REGION( 0x80000, "snd", 0 )
 	ROM_LOAD( "943snd1.000", 0x000000, 0x020000, CRC(6b4223a7) SHA1(7af5779ef0309fef40b930f522e962708bd25930) )
@@ -604,6 +605,7 @@
 	ROM_REGION( 0x80000, "altrevs", 0 )
 	ROM_LOAD( "treasuretrail.bin", 0x0000, 0x010000, CRC(2be4e149) SHA1(d8cd8f9196b7f2131c78e3e00384872d3ecc0f5f) )
 	ROM_LOAD( "ttrail 10_93.bin", 0x0000, 0x010000, CRC(88f97fff) SHA1(e6954030e13cc069e561f3a4729eca077ca8df20) )
+	ROM_LOAD( "bifi-projectcoin.bin", 0x0000, 0x010000, CRC(463dd269) SHA1(da647f5942491f574aec17e6fdd99f75641ff332) )
 ROM_END
 
 ROM_START( pr_trpx )
@@ -653,6 +655,10 @@
 	ROM_LOAD( "up&underprojectcoin.bin", 0x0000, 0x010000, CRC(053a394f) SHA1(8d7e55092dfba2ce49ee009ed388be027be2ff28) )
 ROM_END
 
+ROM_START( pr_qksht )
+	ROM_REGION( 0x80000, "maincpu", 0 )
+	ROM_LOAD( "quickshot27256.bin", 0x0000, 0x008000, CRC(44188ee9) SHA1(a48807252a3fe3aeacbf2e6d2691bdeafc90e249) ) // Should be 10000?
+ROM_END
 
 
 DRIVER_INIT( proconn )
@@ -699,6 +705,7 @@
 GAME( 199?, pr_medl			,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Medalist (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, pr_megmn		,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Mega Money (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, pr_nudxs		,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Nudge XS (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
+GAME( 199?, pr_qksht		,0			,proconn	,proconn	,proconn	,ROT0	,"Maygay", "Quickshot (Maygay) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, pr_rags			,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Rags To Riches (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, pr_reflx		,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Reflex (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
 GAME( 199?, pr_roadr		,0			,proconn	,proconn	,proconn	,ROT0	,"Project", "Road Riot (Project) (PROCONN)",GAME_IS_SKELETON_MECHANICAL )
diff -Nru src-old/mame/drivers/punchout.c src/mame/drivers/punchout.c
--- src-old/mame/drivers/punchout.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/punchout.c	2012-02-18 03:48:45.000000000 +0100
@@ -1079,33 +1079,33 @@
 ROM_START( punchita )
 	/* Unique to this set */
 	ROM_REGION( 0x10000, "maincpu", 0 )	/* 64k for code */
-	ROM_LOAD( "chp1-c.8l",    0x0000, 0x2000, CRC(1d595ce2) SHA1(affd43bef96c68f953e66cfa14ad4e9c304dc022) )
-	ROM_LOAD( "chp1-c.8k",    0x2000, 0x2000, CRC(c062fa5c) SHA1(8ebd6fd76f1fd1b85216a4e21d8a13be8317b9e2) )
-	ROM_LOAD( "chp1-c.8j",    0x4000, 0x2000, CRC(48d453ef) SHA1(145f3ace8bec87e83b64c6472e2b71f1ebea13ea) )
-	ROM_LOAD( "chp1-c.8h",    0x6000, 0x2000, CRC(67f5aedc) SHA1(c63a8b0696eec87bb147d435c18ee7e26d19e2a4) )
-	ROM_LOAD( "chp1-c.8f",    0x8000, 0x4000, CRC(761de4f3) SHA1(66754bc762c14fea620fabf408f85e6e3acb89ad) )
+	ROM_LOAD( "ita_chp1-c.8l",    0x0000, 0x2000, CRC(1d595ce2) SHA1(affd43bef96c68f953e66cfa14ad4e9c304dc022) )
+	ROM_LOAD( "ita_chp1-c.8k",    0x2000, 0x2000, CRC(c062fa5c) SHA1(8ebd6fd76f1fd1b85216a4e21d8a13be8317b9e2) )
+	ROM_LOAD( "ita_chp1-c.8j",    0x4000, 0x2000, CRC(48d453ef) SHA1(145f3ace8bec87e83b64c6472e2b71f1ebea13ea) )
+	ROM_LOAD( "ita_chp1-c.8h",    0x6000, 0x2000, CRC(67f5aedc) SHA1(c63a8b0696eec87bb147d435c18ee7e26d19e2a4) )
+	ROM_LOAD( "ita_chp1-c.8f",    0x8000, 0x4000, CRC(761de4f3) SHA1(66754bc762c14fea620fabf408f85e6e3acb89ad) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* 64k for the sound CPU */
 	ROM_LOAD( "chp1-c.4k",    0xe000, 0x2000, CRC(cb6ef376) SHA1(503dbcc1b18a497311bf129689d5650860bf96c7) )
 
 	/* Unique to this set */
 	ROM_REGION( 0x04000, "gfx1", ROMREGION_ERASEFF )
-	ROM_LOAD( "chp1-b.4c",    0x00000, 0x0800, CRC(9a9ff1d3) SHA1(d91adf69acb717f238cd5954909701a8748f2185) )	/* chars #1 */
+	ROM_LOAD( "ita_chp1-b.4c",    0x00000, 0x0800, CRC(9a9ff1d3) SHA1(d91adf69acb717f238cd5954909701a8748f2185) )	/* chars #1 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "chp1-b.4d",    0x02000, 0x0800, CRC(4c23350f) SHA1(70a76002db9209699cdf1f092b2b5ef32d0b7b75) )
+	ROM_LOAD( "ita_chp1-b.4d",    0x02000, 0x0800, CRC(4c23350f) SHA1(70a76002db9209699cdf1f092b2b5ef32d0b7b75) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
 
 	/* These match SUPER PunchOut */
 	ROM_REGION( 0x04000, "gfx2", ROMREGION_ERASEFF )
-	ROM_LOAD( "chp1-b.4a",    0x00000, 0x0800, CRC(c075f831) SHA1(f22d9e415637599420c443ce08e7e70d1eb1c6f5) )	/* chars #2 */
+	ROM_LOAD( "ita_chp1-b.4a",    0x00000, 0x0800, CRC(c075f831) SHA1(f22d9e415637599420c443ce08e7e70d1eb1c6f5) )	/* chars #2 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "chp1-b.4b",    0x02000, 0x0800, CRC(c4cc2b5a) SHA1(7b9d4dcecc67271980c3c44561fc25a6f6c93ee3) )
+	ROM_LOAD( "ita_chp1-b.4b",    0x02000, 0x0800, CRC(c4cc2b5a) SHA1(7b9d4dcecc67271980c3c44561fc25a6f6c93ee3) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
@@ -1131,20 +1131,20 @@
 
 	/* These match SUPER PunchOut */
 	ROM_REGION( 0x10000, "gfx4", ROMREGION_ERASEFF )
-	ROM_LOAD( "chp1-v.6p",    0x00000, 0x0800, CRC(75be7aae) SHA1(396bc1d301b99e064de4dad699882618b1b9c958) )	/* chars #4 */
+	ROM_LOAD( "ita_chp1-v.6p",    0x00000, 0x0800, CRC(75be7aae) SHA1(396bc1d301b99e064de4dad699882618b1b9c958) )	/* chars #4 */
 	ROM_CONTINUE(             0x01000, 0x0800 )
 	ROM_CONTINUE(             0x00800, 0x0800 )
 	ROM_CONTINUE(             0x01800, 0x0800 )
-	ROM_LOAD( "chp1-v.6n",    0x02000, 0x0800, CRC(daf74de0) SHA1(9373d4527b675b3128a5a830f42e1dc5dcb85307) )
+	ROM_LOAD( "ita_chp1-v.6n",    0x02000, 0x0800, CRC(daf74de0) SHA1(9373d4527b675b3128a5a830f42e1dc5dcb85307) )
 	ROM_CONTINUE(             0x03000, 0x0800 )
 	ROM_CONTINUE(             0x02800, 0x0800 )
 	ROM_CONTINUE(             0x03800, 0x0800 )
 	/* 04000-07fff empty (space for 6l and 6k) */
-	ROM_LOAD( "chp1-v.8p",    0x08000, 0x0800, CRC(4cb7ea82) SHA1(213b7c1431f4c92e5519a8771035bda28b3bab8a) )
+	ROM_LOAD( "ita_chp1-v.8p",    0x08000, 0x0800, CRC(4cb7ea82) SHA1(213b7c1431f4c92e5519a8771035bda28b3bab8a) )
 	ROM_CONTINUE(             0x09000, 0x0800 )
 	ROM_CONTINUE(             0x08800, 0x0800 )
 	ROM_CONTINUE(             0x09800, 0x0800 )
-	ROM_LOAD( "chp1-v.8n",    0x0a000, 0x0800, CRC(1c0d09aa) SHA1(3276bae7400453f3612f53d7b47fb199cbe53e6d) )
+	ROM_LOAD( "ita_chp1-v.8n",    0x0a000, 0x0800, CRC(1c0d09aa) SHA1(3276bae7400453f3612f53d7b47fb199cbe53e6d) )
 	ROM_CONTINUE(             0x0b000, 0x0800 )
 	ROM_CONTINUE(             0x0a800, 0x0800 )
 	ROM_CONTINUE(             0x0b800, 0x0800 )
diff -Nru src-old/mame/drivers/qdrmfgp.c src/mame/drivers/qdrmfgp.c
--- src-old/mame/drivers/qdrmfgp.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/qdrmfgp.c	2012-02-09 11:27:12.000000000 +0100
@@ -684,7 +684,7 @@
 	MCFG_MACHINE_RESET(qdrmfgp)
 	MCFG_NVRAM_ADD_1FILL("nvram")
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -721,7 +721,7 @@
 	MCFG_MACHINE_RESET(qdrmfgp)
 	MCFG_NVRAM_ADD_1FILL("nvram")
 
-	MCFG_IDE_CONTROLLER_ADD("ide", gp2_ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", gp2_ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -766,7 +766,7 @@
 	ROM_LOAD( "gq_460_a07.14h", 0x000000, 0x80000, CRC(67d8ea6b) SHA1(11af1b5a33de2a6e24823964d210bef193ecefe4) )
 	ROM_LOAD( "gq_460_a06.12h", 0x080000, 0x80000, CRC(97ed5a77) SHA1(68600fd8d914451284cf181fb4bd5872860fb9ad) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "gq460a08", 0, SHA1(2f142f986fa3c79d5c4102e800980d1706c35f75) )
 ROM_END
 
@@ -783,7 +783,7 @@
 	ROM_LOAD( "ge_557_a07.19h", 0x000000, 0x80000, CRC(7491e0c8) SHA1(6459ab5e7af052ef7a1c4ce01cd844c0f4319f2e) )
 	ROM_LOAD( "ge_557_a08.19k", 0x080000, 0x80000, CRC(3da2b20c) SHA1(fdc2cdc27f3299f541944a78ce36ed33a7926056) )
 
-	DISK_REGION( "ide" )			/* IDE HARD DRIVE */
+	DISK_REGION( "drive_0" )			/* IDE HARD DRIVE */
 	DISK_IMAGE( "ge557a09", 0, SHA1(1ef8093b542fe0bf8240a5fd64e5af3839b6a04c) )
 ROM_END
 
diff -Nru src-old/mame/drivers/queen.c src/mame/drivers/queen.c
--- src-old/mame/drivers/queen.c	2012-01-24 15:16:25.000000000 +0100
+++ src/mame/drivers/queen.c	2012-02-09 11:27:12.000000000 +0100
@@ -701,7 +701,7 @@
 	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
 	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
@@ -718,7 +718,7 @@
 //  ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 //  ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "pqiidediskonmodule", 0,SHA1(a56efcc711b1c5a2e63160b3088001a8c4fb56c2) )
 ROM_END
 
diff -Nru src-old/mame/drivers/rallyx.c src/mame/drivers/rallyx.c
--- src-old/mame/drivers/rallyx.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/rallyx.c	2012-02-19 02:53:16.000000000 +0100
@@ -218,7 +218,7 @@
 	rallyx_state *state = space->machine().driver_data<rallyx_state>();
 
 	if (data == 0 && state->m_last_bang != 0)
-		sample_start(state->m_samples, 0, 0, 0);
+		state->m_samples->start(0, 0);
 
 	state->m_last_bang = data;
 }
@@ -880,7 +880,7 @@
 	rallyx_state *state = machine.driver_data<rallyx_state>();
 
 	state->m_maincpu = machine.device<cpu_device>("maincpu");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	state->save_item(NAME(state->m_last_bang));
 	state->save_item(NAME(state->m_stars_enable));
@@ -944,8 +944,7 @@
 	MCFG_SOUND_CONFIG(namco_config)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(rallyx_samples_interface)
+	MCFG_SAMPLES_ADD("samples", rallyx_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/rastan.c src/mame/drivers/rastan.c
--- src-old/mame/drivers/rastan.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/rastan.c	2012-02-18 03:48:45.000000000 +0100
@@ -552,9 +552,9 @@
 	ROM_REGION( 0x60000, "maincpu", 0 ) /* 6*64k for 68000 code */
 	ROM_LOAD16_BYTE( "b04-38.19", 0x00000, 0x10000, CRC(a38ac909) SHA1(66d792fee03c6bd87d15060b9d5cae74137c5ebd) )
 	ROM_LOAD16_BYTE( "b04-37.7",  0x00001, 0x10000, CRC(bad60872) SHA1(e020f79b3ac3d2abccfcd5d135d2dc49e1335c7d) )
-	ROM_LOAD16_BYTE( "b04-40.20", 0x20000, 0x10000, CRC(6bcf70dc) SHA1(3e369548ac01981c503150b44c2747e6c2cec12a) )
+	ROM_LOAD16_BYTE( "rs_b04-40.20", 0x20000, 0x10000, CRC(6bcf70dc) SHA1(3e369548ac01981c503150b44c2747e6c2cec12a) )
 	ROM_LOAD16_BYTE( "b04-39.8",  0x20001, 0x10000, CRC(8838ecc5) SHA1(42b43ab77969bbacdf178fbe73a0a27652ccb297) )
-	ROM_LOAD16_BYTE( "b04-42.21", 0x40000, 0x10000, CRC(b626c439) SHA1(976e820edc4ba107c5b579edaaee1e354e85fb67) )
+	ROM_LOAD16_BYTE( "rs_b04-42.21", 0x40000, 0x10000, CRC(b626c439) SHA1(976e820edc4ba107c5b579edaaee1e354e85fb67) )
 	ROM_LOAD16_BYTE( "b04-43.9",  0x40001, 0x10000, CRC(c928a516) SHA1(fe87fdf2d1b7ba93e1986460eb6af648b58f42e4) )
 
 	ROM_REGION( 0x1c000, "audiocpu", 0 )
diff -Nru src-old/mame/drivers/safarir.c src/mame/drivers/safarir.c
--- src-old/mame/drivers/safarir.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/safarir.c	2012-02-19 02:53:16.000000000 +0100
@@ -66,7 +66,7 @@
 	UINT8 *m_bg_scroll;
 	UINT8 m_port_last;
 	UINT8 m_port_last2;
-	device_t *m_samples;
+	samples_device *m_samples;
 };
 
 
@@ -235,36 +235,36 @@
 static WRITE8_HANDLER( safarir_audio_w )
 {
 	safarir_state *state = space->machine().driver_data<safarir_state>();
-	device_t *samples = state->m_samples;
+	samples_device *samples = state->m_samples;
 	UINT8 rising_bits = data & ~state->m_port_last;
 
-	if (rising_bits == 0x12) sample_start(samples, CHANNEL_SOUND1, SAMPLE_SOUND1_1, 0);
-	if (rising_bits == 0x02) sample_start(samples, CHANNEL_SOUND1, SAMPLE_SOUND1_2, 0);
-	if (rising_bits == 0x95) sample_start(samples, CHANNEL_SOUND1, SAMPLE_SOUND6, 0);
+	if (rising_bits == 0x12) samples->start(CHANNEL_SOUND1, SAMPLE_SOUND1_1);
+	if (rising_bits == 0x02) samples->start(CHANNEL_SOUND1, SAMPLE_SOUND1_2);
+	if (rising_bits == 0x95) samples->start(CHANNEL_SOUND1, SAMPLE_SOUND6);
 
-	if (rising_bits == 0x04 && (data == 0x15 || data ==0x16)) sample_start(samples, CHANNEL_SOUND2, SAMPLE_SOUND2, 0);
+	if (rising_bits == 0x04 && (data == 0x15 || data ==0x16)) samples->start(CHANNEL_SOUND2, SAMPLE_SOUND2);
 
-	if (data == 0x5f && (rising_bits == 0x49 || rising_bits == 0x5f)) sample_start(samples, CHANNEL_SOUND3, SAMPLE_SOUND3, 1);
-	if (data == 0x00 || rising_bits == 0x01) sample_stop(samples, CHANNEL_SOUND3);
+	if (data == 0x5f && (rising_bits == 0x49 || rising_bits == 0x5f)) samples->start(CHANNEL_SOUND3, SAMPLE_SOUND3, true);
+	if (data == 0x00 || rising_bits == 0x01) samples->stop(CHANNEL_SOUND3);
 
 	if (data == 0x13)
 	{
 		if ((rising_bits == 0x13 && state->m_port_last != 0x04) || (rising_bits == 0x01 && state->m_port_last == 0x12))
 		{
-			sample_start(samples, CHANNEL_SOUND4, SAMPLE_SOUND7, 0);
+			samples->start(CHANNEL_SOUND4, SAMPLE_SOUND7);
 		}
-		else if (rising_bits == 0x03 && state->m_port_last2 == 0x15 && !sample_playing(samples, CHANNEL_SOUND4))
+		else if (rising_bits == 0x03 && state->m_port_last2 == 0x15 && !samples->playing(CHANNEL_SOUND4))
 		{
-			sample_start(samples, CHANNEL_SOUND4, SAMPLE_SOUND4_1, 0);
+			samples->start(CHANNEL_SOUND4, SAMPLE_SOUND4_1);
 		}
 	}
-	if (data == 0x53 && state->m_port_last == 0x55) sample_start(samples, CHANNEL_SOUND4, SAMPLE_SOUND4_2, 0);
+	if (data == 0x53 && state->m_port_last == 0x55) samples->start(CHANNEL_SOUND4, SAMPLE_SOUND4_2);
 
-	if (data == 0x1f && rising_bits == 0x1f) sample_start(samples, CHANNEL_SOUND5, SAMPLE_SOUND5_1, 0);
-	if (data == 0x14 && (rising_bits == 0x14 || rising_bits == 0x04)) sample_start(samples, CHANNEL_SOUND5, SAMPLE_SOUND5_2, 0);
+	if (data == 0x1f && rising_bits == 0x1f) samples->start(CHANNEL_SOUND5, SAMPLE_SOUND5_1);
+	if (data == 0x14 && (rising_bits == 0x14 || rising_bits == 0x04)) samples->start(CHANNEL_SOUND5, SAMPLE_SOUND5_2);
 
-	if (data == 0x07 && rising_bits == 0x07 && !sample_playing(samples, CHANNEL_SOUND6))
-		sample_start(samples, CHANNEL_SOUND6, SAMPLE_SOUND8, 0);
+	if (data == 0x07 && rising_bits == 0x07 && !samples->playing(CHANNEL_SOUND6))
+		samples->start(CHANNEL_SOUND6, SAMPLE_SOUND8);
 
 	state->m_port_last2 = state->m_port_last;
 	state->m_port_last = data;
@@ -298,8 +298,7 @@
 
 static MACHINE_CONFIG_FRAGMENT( safarir_audio )
 	MCFG_SPEAKER_STANDARD_MONO("mono")
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(safarir_samples_interface)
+	MCFG_SAMPLES_ADD("samples", safarir_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -319,7 +318,7 @@
 	state->m_ram_2 = auto_alloc_array(machine, UINT8, state->m_ram_size);
 	state->m_port_last = 0;
 	state->m_port_last2 = 0;
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 
 	/* setup for save states */
 	state->save_pointer(NAME(state->m_ram_1), state->m_ram_size);
diff -Nru src-old/mame/drivers/saturn.c src/mame/drivers/saturn.c
--- src-old/mame/drivers/saturn.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/saturn.c	2012-02-09 13:08:07.000000000 +0100
@@ -2336,10 +2336,10 @@
 
 static const struct stv_cart_region stv_cart_table[] =
 {
-	{ "cart1", 0, "game0" },
-	{ "cart2", 1, "game1" },
-	{ "cart3", 2, "game2" },
-	{ "cart4", 3, "game3" },
+	{ ":cart1", 0, "game0" },
+	{ ":cart2", 1, "game1" },
+	{ ":cart3", 2, "game2" },
+	{ ":cart4", 3, "game3" },
 	{ 0 }
 };
 
diff -Nru src-old/mame/drivers/savquest.c src/mame/drivers/savquest.c
--- src-old/mame/drivers/savquest.c	2012-01-24 15:16:25.000000000 +0100
+++ src/mame/drivers/savquest.c	2012-02-09 11:27:12.000000000 +0100
@@ -565,7 +565,7 @@
 	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
 	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
@@ -579,7 +579,7 @@
 	ROM_LOAD16_BYTE( "trident_tgui9680_bios.bin", 0x0000, 0x4000, BAD_DUMP CRC(1eebde64) SHA1(67896a854d43a575037613b3506aea6dae5d6a19) )
 	ROM_CONTINUE(                                 0x0001, 0x4000 )
 
-	DISK_REGION( "disk" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "savquest", 0, SHA1(b20cacf45e093b533c538bf4fc08f05f9475d640) )
 ROM_END
 
diff -Nru src-old/mame/drivers/sderby.c src/mame/drivers/sderby.c
--- src-old/mame/drivers/sderby.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/sderby.c	2012-02-19 01:27:36.000000000 +0100
@@ -704,8 +704,8 @@
 
 ROM_START( croupiera )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
-	ROM_LOAD16_BYTE( "2.bin", 0x00000, 0x20000, CRC(1677a2de) SHA1(4dcbb3c1ce9b65e06ba7e0cffa00c0c8016538f5))
-	ROM_LOAD16_BYTE( "3.bin", 0x00001, 0x20000, CRC(11acaac2) SHA1(19e7bbbf4356fc9a866f9f36d0568c42d6a36c07))
+	ROM_LOAD16_BYTE( "2a.bin", 0x00000, 0x20000, CRC(1677a2de) SHA1(4dcbb3c1ce9b65e06ba7e0cffa00c0c8016538f5))
+	ROM_LOAD16_BYTE( "3a.bin", 0x00001, 0x20000, CRC(11acaac2) SHA1(19e7bbbf4356fc9a866f9f36d0568c42d6a36c07))
 
 	ROM_REGION( 0x080000, "oki", 0 ) /* samples are ok */
 	ROM_LOAD( "1.bin", 0x00000, 0x40000, CRC(6673de85) SHA1(df390cd6268efc0e743a9020f19bc0cbeb757cfa))
diff -Nru src-old/mame/drivers/seattle.c src/mame/drivers/seattle.c
--- src-old/mame/drivers/seattle.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/seattle.c	2012-02-09 11:27:12.000000000 +0100
@@ -2505,8 +2505,8 @@
 	MCFG_MACHINE_RESET(seattle)
 	MCFG_NVRAM_ADD_1FILL("nvram")
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
-	MCFG_IDE_BUS_MASTER_SPACE("maincpu", PROGRAM)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
+	MCFG_IDE_BUS_MASTER_SPACE("ide", "maincpu", PROGRAM)
 
 	MCFG_3DFX_VOODOO_1_ADD("voodoo", STD_VOODOO_1_CLOCK, 2, "screen")
 	MCFG_3DFX_VOODOO_CPU("maincpu")
@@ -2587,7 +2587,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version L1.2 (10/8/96) */
 	ROM_LOAD( "wg3dh_12.u32", 0x000000, 0x80000, CRC(15e4cea2) SHA1(72c0db7dc53ce645ba27a5311b5ce803ad39f131) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.3 (Guts 10/15/96, Main 10/15/96) */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.3 (Guts 10/15/96, Main 10/15/96) */
 	DISK_IMAGE( "wg3dh", 0, SHA1(4fc6f25d7f043d9bcf8743aa8df1d9be3cbc375b) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version L1.1 */
@@ -2599,7 +2599,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.0ce 7/2/97 */
 	ROM_LOAD( "mace10ce.u32", 0x000000, 0x80000, CRC(7a50b37e) SHA1(33788835f84a9443566c80bee9f20a1691490c6d) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.0B 6/10/97 (Guts 7/2/97, Main 7/2/97) */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.0B 6/10/97 (Guts 7/2/97, Main 7/2/97) */
 	DISK_IMAGE( "mace", 0, SHA1(96ec8d3ff5dd894e21aa81403bcdbeba44bb97ea) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version L1.1, Labeled as Version 1.0 */
@@ -2611,7 +2611,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version ??? 5/7/97 */
 	ROM_LOAD( "maceboot.u32", 0x000000, 0x80000, CRC(effe3ebc) SHA1(7af3ca3580d6276ffa7ab8b4c57274e15ee6bcbb) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.0a (Guts 6/9/97, Main 5/12/97) */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.0a (Guts 6/9/97, Main 5/12/97) */
 	DISK_IMAGE( "macea", 0, BAD_DUMP SHA1(9bd4a60627915d71932cab24f89c48ea21f4c1cb) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version L1.1 */
@@ -2632,7 +2632,7 @@
 	ROM_LOAD32_WORD( "sfrush.u53",  0x800000, 0x200000, CRC(71f8ddb0) SHA1(c24bef801f43bae68fda043c4356e8cf1298ca97) )
 	ROM_LOAD32_WORD( "sfrush.u49",  0x800002, 0x200000, CRC(dfb0a54c) SHA1(ed34f9485f7a7e5bb73bf5c6428b27548e12db12) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version L1.06 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version L1.06 */
 	DISK_IMAGE( "sfrush", 0, SHA1(e2db0270a707fb2115207f988d5751081d6b4994) )
 ROM_END
 
@@ -2650,7 +2650,7 @@
 	ROM_LOAD32_WORD( "audio.u53",  0x800000, 0x200000, CRC(51c89a14) SHA1(6bc62bcda224040a4596d795132874828011a038) )
 	ROM_LOAD32_WORD( "audio.u49",  0x800002, 0x200000, CRC(e6b684d3) SHA1(1f5bab7fae974cecc8756dd23e3c7aa2cf6e7dc7) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.2 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.2 */
 	DISK_IMAGE( "sfrushrk", 0, SHA1(e763f26aca67ebc17fe8b8df4fba91d492cf7837) )
 ROM_END
 
@@ -2659,7 +2659,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.2 (2/18/98) */
 	ROM_LOAD( "caspd1_2.u32", 0x000000, 0x80000, CRC(0a235e4e) SHA1(b352f10fad786260b58bd344b5002b6ea7aaf76d) )
 
-	DISK_REGION( "ide" )	/* Release version 2.1a (4/17/98) (Guts 1.25 4/17/98, Main 4/17/98) */
+	DISK_REGION( "drive_0" )	/* Release version 2.1a (4/17/98) (Guts 1.25 4/17/98, Main 4/17/98) */
 	DISK_IMAGE( "calspeed", 0, SHA1(08d411c591d4b8bbdd6437ea80d01c4cec8516f8) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version 1.02 */
@@ -2671,7 +2671,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.2 (2/18/98) */
 	ROM_LOAD( "caspd1_2.u32", 0x000000, 0x80000, CRC(0a235e4e) SHA1(b352f10fad786260b58bd344b5002b6ea7aaf76d) )
 
-	DISK_REGION( "ide" )	/* Release version 1.0r7a (3/4/98) (Guts 3/3/98, Main 1/19/98) */
+	DISK_REGION( "drive_0" )	/* Release version 1.0r7a (3/4/98) (Guts 3/3/98, Main 1/19/98) */
 	DISK_IMAGE( "calspeda", 0, SHA1(6b1c3a7530195ef7309b06a651b01c8b3ece92c6) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version 1.02 */
@@ -2683,7 +2683,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "vtrxboot.bin", 0x000000, 0x80000, CRC(ee487a6c) SHA1(fb9efda85047cf615f24f7276a9af9fd542f3354) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "vaportrx", 0, SHA1(fe53ca7643d2ed2745086abb7f2243c69678cab1) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version 1.02 */
@@ -2695,7 +2695,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "vtrxboot.bin", 0x000000, 0x80000, CRC(ee487a6c) SHA1(fb9efda85047cf615f24f7276a9af9fd542f3354) )
 
-	DISK_REGION( "ide" ) /* Guts: Apr 10 1998 11:03:14  Main: Apr 10 1998 11:27:44 */
+	DISK_REGION( "drive_0" ) /* Guts: Apr 10 1998 11:03:14  Main: Apr 10 1998 11:27:44 */
 	DISK_IMAGE( "vaportrp", 0, SHA1(6c86637c442ebd6994eee8c0ae0dce343c35dbe9) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2115 data Version 1.02 */
@@ -2710,7 +2710,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 ) /* Seattle System Boot ROM Version 0.1i Apr 14 1997  14:52:53 */
 	ROM_LOAD( "biofreak.u32", 0x000000, 0x80000, CRC(cefa00bb) SHA1(7e171610ede1e8a448fb8d175f9cb9e7d549de28) )
 
-	DISK_REGION( "ide" ) /* Build Date 12/11/97 */
+	DISK_REGION( "drive_0" ) /* Build Date 12/11/97 */
 	DISK_IMAGE( "biofreak", 0, SHA1(711241642f92ded8eaf20c418ea748989183fe10) )
 ROM_END
 
@@ -2722,7 +2722,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.2 */
 	ROM_LOAD( "blitz1_2.u32", 0x000000, 0x80000, CRC(38dbecf5) SHA1(7dd5a5b3baf83a7f8f877ff4cd3f5e8b5201b36f) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.21 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.21 */
 	DISK_IMAGE( "blitz", 0, SHA1(9131c7888e89b3c172780156ed3fe1fe46f78b0a) )
 ROM_END
 
@@ -2734,7 +2734,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.1 */
 	ROM_LOAD( "blitz1_1.u32", 0x000000, 0x80000, CRC(8163ce02) SHA1(89b432d8879052f6c5534ee49599f667f50a010f) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.21 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.21 */
 	DISK_IMAGE( "blitz", 0, SHA1(9131c7888e89b3c172780156ed3fe1fe46f78b0a) )
 ROM_END
 
@@ -2746,7 +2746,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.0 */
 	ROM_LOAD( "bltz9910.u32", 0x000000, 0x80000, CRC(777119b2) SHA1(40d255181c2f3a787919c339e83593fd506779a5) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.30 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.30 */
 	DISK_IMAGE( "blitz99", 0, SHA1(19877e26ffce81dd525031e9e2b4f83ff982e2d9) )
 ROM_END
 
@@ -2758,7 +2758,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* Boot Code Version 1.4 */
 	ROM_LOAD( "bltz2k14.u32", 0x000000, 0x80000, CRC(ac4f0051) SHA1(b8125c17370db7bfd9b783230b4ef3d5b22a2025) )
 
-	DISK_REGION( "ide" )	/* Hard Drive Version 1.5 */
+	DISK_REGION( "drive_0" )	/* Hard Drive Version 1.5 */
 	DISK_IMAGE( "blitz2k", 0, SHA1(e89b7fbd4b4a9854d47ae97493e0afffbd1f69e7) )
 ROM_END
 
@@ -2770,7 +2770,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 ) /* Boot Rom Version 1.9 */
 	ROM_LOAD( "carnevil1_9.u32", 0x000000, 0x80000, CRC(82c07f2e) SHA1(fa51c58022ce251c53bad12fc6ffadb35adb8162) )
 
-	DISK_REGION( "ide" )	/* Hard Drive v1.0.3  Diagnostics v3.4 / Feb 1 1999 16:00:07 */
+	DISK_REGION( "drive_0" )	/* Hard Drive v1.0.3  Diagnostics v3.4 / Feb 1 1999 16:00:07 */
 	DISK_IMAGE( "carnevil", 0, SHA1(5cffb0de63ad36eb01c5951bab04d3f8a9e23e16) )
 ROM_END
 
@@ -2782,7 +2782,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 ) /* Boot Rom Version 1.9 */
 	ROM_LOAD( "carnevil1_9.u32", 0x000000, 0x80000, CRC(82c07f2e) SHA1(fa51c58022ce251c53bad12fc6ffadb35adb8162) )
 
-	DISK_REGION( "ide" )	/* Hard Drive v1.0.1  Diagnostics v3.3 / Oct 20 1998 11:44:41 */
+	DISK_REGION( "drive_0" )	/* Hard Drive v1.0.1  Diagnostics v3.3 / Oct 20 1998 11:44:41 */
 	DISK_IMAGE( "carnevi1", 0, BAD_DUMP SHA1(94532727512280930a100fe473bf3a938fe2d44f) )
 ROM_END
 
@@ -2794,7 +2794,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 ) /* Boot Rom Version 9. */
 	ROM_LOAD( "hyprdrve.u32", 0x000000, 0x80000, CRC(3e18cb80) SHA1(b18cc4253090ee1d65d72a7ec0c426ed08c4f238) )
 
-	DISK_REGION( "ide" )	/* Version 1.40  Oct 23 1998  15:16:00 */
+	DISK_REGION( "drive_0" )	/* Version 1.40  Oct 23 1998  15:16:00 */
 	DISK_IMAGE( "hyprdriv", 0, SHA1(8cfa343797575b32f46cc24150024be48963a03e) )
 ROM_END
 
diff -Nru src-old/mame/drivers/segag80v.c src/mame/drivers/segag80v.c
--- src-old/mame/drivers/segag80v.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/segag80v.c	2012-02-19 02:53:16.000000000 +0100
@@ -927,8 +927,7 @@
 static MACHINE_CONFIG_DERIVED( elim2, g80v_base )
 
 	/* custom sound board */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(elim2_samples_interface)
+	MCFG_SAMPLES_ADD("samples", elim2_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
@@ -936,8 +935,7 @@
 static MACHINE_CONFIG_DERIVED( spacfury, g80v_base )
 
 	/* custom sound board */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(spacfury_samples_interface)
+	MCFG_SAMPLES_ADD("samples", spacfury_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
 	/* speech board */
@@ -948,8 +946,7 @@
 static MACHINE_CONFIG_DERIVED( zektor, g80v_base )
 
 	/* custom sound board */
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(zektor_samples_interface)
+	MCFG_SAMPLES_ADD("samples", zektor_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
 	MCFG_SOUND_ADD("aysnd", AY8910, CPU_CLOCK/2/2)
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/segas16b.c	2012-02-11 11:01:01.000000000 +0100
@@ -1401,7 +1401,7 @@
 {
 	segas1x_state *state = space->machine().driver_data<segas1x_state>();
 	state->m_mcu_data = data;
-	generic_pulse_irq_line(state->m_mcu, 1);
+	generic_pulse_irq_line(state->m_mcu, 1, 1);
 }
 #endif
 
diff -Nru src-old/mame/drivers/seicross.c src/mame/drivers/seicross.c
--- src-old/mame/drivers/seicross.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/seicross.c	2012-02-13 10:59:59.000000000 +0100
@@ -408,7 +408,7 @@
 	MCFG_CPU_IO_MAP(main_portmap)
 	MCFG_CPU_VBLANK_INT("screen", vblank_irq)
 
-	MCFG_CPU_ADD("mcu", NSC8105, 6000000)	/* ??? */
+	MCFG_CPU_ADD("mcu", NSC8105, 3072000)	/* ??? */
 	MCFG_CPU_PROGRAM_MAP(mcu_nvram_map)
 
 	MCFG_QUANTUM_TIME(attotime::from_hz(1200))	/* 20 CPU slices per frame - an high value to ensure proper */
diff -Nru src-old/mame/drivers/senjyo.c src/mame/drivers/senjyo.c
--- src-old/mame/drivers/senjyo.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/senjyo.c	2012-02-19 02:53:16.000000000 +0100
@@ -586,8 +586,7 @@
 	MCFG_SOUND_ADD("sn3", SN76496, 2000000)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(senjyo_samples_interface)
+	MCFG_SAMPLES_ADD("samples", senjyo_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.15)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/sigmab52.c src/mame/drivers/sigmab52.c
--- src-old/mame/drivers/sigmab52.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/sigmab52.c	2012-02-11 11:01:01.000000000 +0100
@@ -528,7 +528,7 @@
 
 static INTERRUPT_GEN( timer_irq )
 {
-	generic_pulse_irq_line(device, M6809_IRQ_LINE);
+	generic_pulse_irq_line(device, M6809_IRQ_LINE, 1);
 }
 
 
diff -Nru src-old/mame/drivers/sms.c src/mame/drivers/sms.c
--- src-old/mame/drivers/sms.c	2012-01-15 02:13:13.000000000 +0100
+++ src/mame/drivers/sms.c	2012-02-16 02:10:13.000000000 +0100
@@ -220,10 +220,10 @@
 #include "machine/nvram.h"
 
 
-class sms_state : public driver_device
+class smsmfg_state : public driver_device
 {
 public:
-	sms_state(const machine_config &mconfig, device_type type, const char *tag)
+	smsmfg_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag) { }
 
 	UINT8 m_communication_port[4];
@@ -252,7 +252,7 @@
 
 static READ8_HANDLER(link_r)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	switch(offset)
 	{
 		case 0:
@@ -269,7 +269,7 @@
 
 static WRITE8_HANDLER(link_w)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	switch(offset)
 	{
 		case 0:
@@ -285,13 +285,13 @@
 
 static READ8_HANDLER(z80_8088_r)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	return state->m_communication_port_status;
 }
 
 static READ8_HANDLER(p03_r)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	switch(offset)
 	{
 		case 0:
@@ -306,7 +306,7 @@
 
 static WRITE8_HANDLER(p03_w)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	switch(offset)
 	{
 		case 0:
@@ -434,7 +434,7 @@
 
 static WRITE8_HANDLER(video_w)
 {
-	sms_state *state = space->machine().driver_data<sms_state>();
+	smsmfg_state *state = space->machine().driver_data<smsmfg_state>();
 	state->m_vid_regs[offset] = data;
 	if ( offset == 5 )
 	{
@@ -464,7 +464,7 @@
 
 static VIDEO_START( sms )
 {
-	sms_state *state = machine.driver_data<sms_state>();
+	smsmfg_state *state = machine.driver_data<smsmfg_state>();
 	machine.primary_screen->register_screen_bitmap(state->m_bitmap);
 
 	state_save_register_global_array(machine, state->m_vid_regs);
@@ -473,7 +473,7 @@
 
 static SCREEN_UPDATE_IND16( sms )
 {
-	sms_state *state = screen.machine().driver_data<sms_state>();
+	smsmfg_state *state = screen.machine().driver_data<smsmfg_state>();
 	copybitmap(bitmap, state->m_bitmap, 0, 0, 0, 0, cliprect);
 	return 0;
 }
@@ -531,7 +531,7 @@
 
 static MACHINE_START( sms )
 {
-	sms_state *state = machine.driver_data<sms_state>();
+	smsmfg_state *state = machine.driver_data<smsmfg_state>();
 	memory_configure_bank(machine, "bank1", 0, 16, machine.region("questions")->base(), 0x4000);
 
 	state_save_register_global(machine, state->m_communication_port_status);
@@ -540,18 +540,18 @@
 
 static MACHINE_START( sureshot )
 {
-	sms_state *state = machine.driver_data<sms_state>();
+	smsmfg_state *state = machine.driver_data<smsmfg_state>();
 	state_save_register_global(machine, state->m_communication_port_status);
 	state_save_register_global_array(machine, state->m_communication_port);
 }
 
 static MACHINE_RESET( sms )
 {
-	sms_state *state = machine.driver_data<sms_state>();
+	smsmfg_state *state = machine.driver_data<smsmfg_state>();
 	state->m_communication_port_status = 0;
 }
 
-static MACHINE_CONFIG_START( sms, sms_state )
+static MACHINE_CONFIG_START( sms, smsmfg_state )
 	MCFG_CPU_ADD("maincpu", I8088, XTAL_24MHz/8)
 	MCFG_CPU_PROGRAM_MAP(sms_map)
 
diff -Nru src-old/mame/drivers/snk6502.c src/mame/drivers/snk6502.c
--- src-old/mame/drivers/snk6502.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/snk6502.c	2012-02-19 02:53:16.000000000 +0100
@@ -856,8 +856,7 @@
 	MCFG_SOUND_ADD("snk6502", SNK6502, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(sasuke_samples_interface)
+	MCFG_SAMPLES_ADD("samples", sasuke_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.12)
 
 	MCFG_SOUND_ADD("sn76477.1", SN76477, 0)
@@ -884,8 +883,7 @@
 	MCFG_GFXDECODE(satansat)
 
 	// sound hardware
-	MCFG_SOUND_REPLACE("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(vanguard_samples_interface)
+	MCFG_SAMPLES_REPLACE("samples", vanguard_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_REPLACE("sn76477.1", SN76477, 0)
@@ -929,8 +927,7 @@
 	MCFG_SOUND_ADD("snk6502", SNK6502, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(vanguard_samples_interface)
+	MCFG_SAMPLES_ADD("samples", vanguard_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 
 	MCFG_SOUND_ADD("sn76477.1", SN76477, 0)
@@ -948,8 +945,7 @@
 	MCFG_CPU_PROGRAM_MAP(fantasy_map)
 
 	// sound hardware
-	MCFG_SOUND_REPLACE("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(fantasy_samples_interface)
+	MCFG_SAMPLES_REPLACE("samples", fantasy_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.5)
 
 	MCFG_SOUND_REPLACE("sn76477.1", SN76477, 0)
diff -Nru src-old/mame/drivers/spoker.c src/mame/drivers/spoker.c
--- src-old/mame/drivers/spoker.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/drivers/spoker.c	2012-02-18 03:48:45.000000000 +0100
@@ -607,12 +607,12 @@
 
 ROM_START( spk115it )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "v.bin",   0x0000, 0x10000, CRC(df52997b) SHA1(72a76e84aeedfdebd4c6cb47809117a28b5d3892) )
+	ROM_LOAD( "v_115.bin",   0x0000, 0x10000, CRC(df52997b) SHA1(72a76e84aeedfdebd4c6cb47809117a28b5d3892) )
 
 	ROM_REGION( 0xc0000, "gfx1", 0 )
-	ROM_LOAD( "6.bin",  0x80000, 0x40000, CRC(f9b027f8) SHA1(c4686a4024062482f9864e0445087e32899fc775) )
-	ROM_LOAD( "5.bin",  0x40000, 0x40000, CRC(baca51b6) SHA1(c97322c814729332378b6304a79062fea385ca97) )
-	ROM_LOAD( "4.bin",  0x00000, 0x40000, CRC(1172c790) SHA1(43f1d019ecae5c605722e3fe77ae2f022b01260b) )
+	ROM_LOAD( "6_115.bin",  0x80000, 0x40000, CRC(f9b027f8) SHA1(c4686a4024062482f9864e0445087e32899fc775) )
+	ROM_LOAD( "5_115.bin",  0x40000, 0x40000, CRC(baca51b6) SHA1(c97322c814729332378b6304a79062fea385ca97) )
+	ROM_LOAD( "4_115.bin",  0x00000, 0x40000, CRC(1172c790) SHA1(43f1d019ecae5c605722e3fe77ae2f022b01260b) )
 
 	ROM_REGION( 0x30000, "gfx2", 0 )
 	ROM_LOAD( "3.bin",  0x20000, 0x10000, CRC(5f18b012) SHA1(c9a96237eaf3138f136bbaffb29dde0ef568ce73) )
@@ -661,9 +661,9 @@
 	ROM_LOAD( "pic16c65a-20-p", 0x0000, 0x1000, NO_DUMP )
 
 	ROM_REGION( 0xc0000, "gfx1", 0 )
-	ROM_LOAD( "1.bin", 0x00000, 0x40000, BAD_DUMP CRC(d9d3e21e) SHA1(2f3f07ca427d9f56f0ff143d15d95cbf15255e33) )
-	ROM_LOAD( "2.bin", 0x40000, 0x40000, BAD_DUMP CRC(fbb50ab1) SHA1(50a7ef9219c38d59117c510fe6d53fb3ba1fa456) )
-	ROM_LOAD( "3.bin", 0x80000, 0x40000, BAD_DUMP CRC(545aa4e6) SHA1(3348d4b692900c9e9cd4a52b20922a84e596cd35) )
+	ROM_LOAD( "1_bad.bin", 0x00000, 0x40000, BAD_DUMP CRC(d9d3e21e) SHA1(2f3f07ca427d9f56f0ff143d15d95cbf15255e33) )
+	ROM_LOAD( "2_bad.bin", 0x40000, 0x40000, BAD_DUMP CRC(fbb50ab1) SHA1(50a7ef9219c38d59117c510fe6d53fb3ba1fa456) )
+	ROM_LOAD( "3_bad.bin", 0x80000, 0x40000, BAD_DUMP CRC(545aa4e6) SHA1(3348d4b692900c9e9cd4a52b20922a84e596cd35) )
 	ROM_FILL( 0x00000 ,0x20000, 0x00 )
 	ROM_FILL( 0x40000 ,0x20000, 0x00 )
 	ROM_FILL( 0x80000 ,0x20000, 0x00 )
diff -Nru src-old/mame/drivers/ssfindo.c src/mame/drivers/ssfindo.c
--- src-old/mame/drivers/ssfindo.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/ssfindo.c	2012-02-11 11:01:01.000000000 +0100
@@ -279,7 +279,7 @@
 	state->m_PS7500_IO[IRQSTA]|=0x20;
 	if(state->m_PS7500_IO[IRQMSKA]&0x20)
 	{
-		generic_pulse_irq_line(machine.device("maincpu"), ARM7_IRQ_LINE);
+		generic_pulse_irq_line(machine.device("maincpu"), ARM7_IRQ_LINE, 1);
 	}
 }
 
@@ -300,7 +300,7 @@
 	state->m_PS7500_IO[IRQSTA]|=0x40;
 	if(state->m_PS7500_IO[IRQMSKA]&0x40)
 	{
-		generic_pulse_irq_line(machine.device("maincpu"), ARM7_IRQ_LINE);
+		generic_pulse_irq_line(machine.device("maincpu"), ARM7_IRQ_LINE, 1);
 	}
 }
 
@@ -320,7 +320,7 @@
 	state->m_PS7500_IO[IRQSTA]|=0x08;
 		if(state->m_PS7500_IO[IRQMSKA]&0x08)
 		{
-			generic_pulse_irq_line(device, ARM7_IRQ_LINE);
+			generic_pulse_irq_line(device, ARM7_IRQ_LINE, 1);
 		}
 }
 
diff -Nru src-old/mame/drivers/starcrus.c src/mame/drivers/starcrus.c
--- src-old/mame/drivers/starcrus.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/starcrus.c	2012-02-19 02:53:16.000000000 +0100
@@ -159,8 +159,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(starcrus_samples_interface)
+	MCFG_SAMPLES_ADD("samples", starcrus_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/starshp1.c src/mame/drivers/starshp1.c
--- src-old/mame/drivers/starshp1.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/starshp1.c	2012-02-11 11:01:01.000000000 +0100
@@ -17,7 +17,7 @@
 static INTERRUPT_GEN( starshp1_interrupt )
 {
 	if ((input_port_read(device->machine(), "SYSTEM") & 0x90) != 0x90)
-		generic_pulse_irq_line(device, 0);
+		generic_pulse_irq_line(device, 0, 1);
 }
 
 
diff -Nru src-old/mame/drivers/stfight.c src/mame/drivers/stfight.c
--- src-old/mame/drivers/stfight.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/stfight.c	2012-02-19 01:27:36.000000000 +0100
@@ -599,8 +599,8 @@
 
 ROM_START( empcityj )
 	ROM_REGION( 2*0x18000, "maincpu", 0 )	/* 96k for code + 96k for decrypted opcodes */
-	ROM_LOAD( "1.bin",      0x00000, 0x8000, CRC(8162331c) SHA1(f2fdf5fbc52d4ea692fb87fa049c48935a73d67b) )
-	ROM_LOAD( "2.bin",      0x10000, 0x8000, CRC(960edea6) SHA1(fd19475e841defe42625a94c40c6390b7e6e7682) )	/* bank switched */
+	ROM_LOAD( "ec_1.bin",   0x00000, 0x8000, CRC(8162331c) SHA1(f2fdf5fbc52d4ea692fb87fa049c48935a73d67b) )
+	ROM_LOAD( "ec_2.bin",   0x10000, 0x8000, CRC(960edea6) SHA1(fd19475e841defe42625a94c40c6390b7e6e7682) )	/* bank switched */
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )	/* 64k for the second CPU */
 	ROM_LOAD( "ec_04.rom",  0x0000,  0x8000, CRC(aa3e7d1e) SHA1(da350384d55f011253d19ce17fc327cd2604257f) )
diff -Nru src-old/mame/drivers/stv.c src/mame/drivers/stv.c
--- src-old/mame/drivers/stv.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/stv.c	2012-02-09 15:31:53.000000000 +0100
@@ -2276,7 +2276,20 @@
 	ROM_LOAD( "pclub2kc.nv", 0x0000, 0x0080, CRC(064366fe) SHA1(b85489ae19ddc0fbd67b441a6967f10a6cd22d45) )
 ROM_END
 
+ROM_START( pclb2elk ) // set to 1p
+	STV_BIOS
 
+	ROM_REGION32_BE( 0x3000000, "game0", ROMREGION_ERASE00 ) /* SH2 code */
+
+	ROM_LOAD16_WORD_SWAP( "pclb2elk_ic22",    0x0200000, 0x0200000, CRC(2faed82a) SHA1(035ef25dd974679e46a79e408ee284eca0310557) ) // OK (tested as IC7)
+	ROM_LOAD16_WORD_SWAP( "pclb2elk_ic24",    0x0400000, 0x0200000, CRC(9cacfb7b) SHA1(1c68e1ba077e02ded0f388b4e9ad24998a5d8a48) ) // OK (tested as IC2)
+	ROM_LOAD16_WORD_SWAP( "pclb2elk_ic26",    0x0600000, 0x0200000, CRC(533a189e) SHA1(23a08a9ab02b21d6c75c770f4adc33c6dfe98a4e) ) // OK (tested as IC2)
+	ROM_LOAD16_WORD_SWAP( "pclb2elk_ic28",    0x0800000, 0x0200000, CRC(1f0c9113) SHA1(b65fc9012cb159c374674cde1fd2fb2cf192e7c5) ) // OK (tested as IC3)
+	ROM_LOAD16_WORD_SWAP( "pclb2elk_ic30",    0x0a00000, 0x0200000, CRC(0e188b8c) SHA1(8574f884fbeb2f428913c24e147ee8753305ce86) ) // OK (tested as IC3)
+
+	ROM_REGION16_BE( 0x80, "eeprom", 0 ) // preconfigured to 1 player
+	ROM_LOAD( "pclb2elk.nv", 0x0000, 0x0080, CRC(54c7564f) SHA1(574dcc5e8fe4aac091fee1476347485ed660eddd) )
+ROM_END
 
 
 GAME( 1996, stvbios,   0,       stv_slot, stv,      stv,        ROT0,   "Sega",                         "ST-V Bios", GAME_IS_BIOS_ROOT )
@@ -2344,8 +2357,7 @@
 GAME( 1999, pclub2v3,  pclub2,  stv,      stv,		stv,    	ROT0,   "Atlus",	    				"Print Club 2 Vol. 3 (U 990310 V1.000)", GAME_NOT_WORKING )
 GAME( 1999, pclubpok,  stvbios, stv,      stv,      stv,        ROT0,   "Atlus",                        "Print Club Pokemon B (U 991126 V1.000)", GAME_NOT_WORKING )
 GAME( 1997, pclub2kc,  stvbios, stv,      stv,      stv,        ROT0,   "Atlus",                        "Print Club Kome Kome Club (J 970203 V1.000)", GAME_NOT_WORKING )
-
-
+GAME( 1997, pclb2elk,  stvbios, stv,      stv,      stv,        ROT0,   "Atlus",                        "Print Club 2 Earth Limited Kobe (Print Club Custom) (J 970808 V1.000)", GAME_NOT_WORKING )
 
 
 /* Doing something.. but not enough yet */
diff -Nru src-old/mame/drivers/suna8.c src/mame/drivers/suna8.c
--- src-old/mame/drivers/suna8.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/suna8.c	2012-02-19 02:53:16.000000000 +0100
@@ -1531,8 +1531,7 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.30)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.30)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(suna8_samples_interface)
+	MCFG_SAMPLES_ADD("samples", suna8_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 MACHINE_CONFIG_END
@@ -1595,8 +1594,7 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.90)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.90)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(suna8_samples_interface)
+	MCFG_SAMPLES_ADD("samples", suna8_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 MACHINE_CONFIG_END
@@ -1767,8 +1765,7 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(suna8_samples_interface)
+	MCFG_SAMPLES_ADD("samples", suna8_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 MACHINE_CONFIG_END
@@ -1815,8 +1812,7 @@
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.30)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.30)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(suna8_samples_interface)
+	MCFG_SAMPLES_ADD("samples", suna8_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.50)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.50)
 MACHINE_CONFIG_END
diff -Nru src-old/mame/drivers/superqix.c src/mame/drivers/superqix.c
--- src-old/mame/drivers/superqix.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/superqix.c	2012-02-19 02:53:16.000000000 +0100
@@ -110,8 +110,8 @@
 
 static SAMPLES_START( pbillian_sh_start )
 {
-	superqix_state *state = device->machine().driver_data<superqix_state>();
-	running_machine &machine = device->machine();
+	superqix_state *state = device.machine().driver_data<superqix_state>();
+	running_machine &machine = device.machine();
 	UINT8 *src = machine.region("samples")->base();
 	int i, len = machine.region("samples")->bytes();
 
@@ -124,7 +124,7 @@
 static WRITE8_HANDLER( pbillian_sample_trigger_w )
 {
 	superqix_state *state = space->machine().driver_data<superqix_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	UINT8 *src = space->machine().region("samples")->base();
 	int len = space->machine().region("samples")->bytes();
 	int start,end;
@@ -135,7 +135,7 @@
 	while (end < len && src[end] != 0xff)
 		end++;
 
-	sample_start_raw(samples, 0, state->m_samplebuf + start, end - start, 5000, 0); // 5khz ?
+	samples->start_raw(0, state->m_samplebuf + start, end - start, 5000); // 5khz ?
 }
 
 
@@ -1070,8 +1070,7 @@
 	MCFG_SOUND_CONFIG(pbillian_ay8910_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(pbillian_samples_interface)
+	MCFG_SAMPLES_ADD("samples", pbillian_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -1105,8 +1104,7 @@
 	MCFG_SOUND_CONFIG(hotsmash_ay8910_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.30)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(pbillian_samples_interface)
+	MCFG_SAMPLES_ADD("samples", pbillian_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/system1.c src/mame/drivers/system1.c
--- src-old/mame/drivers/system1.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/system1.c	2012-02-18 03:48:45.000000000 +0100
@@ -3423,7 +3423,7 @@
 */
 ROM_START( shtngmste )
 	ROM_REGION( 0x20000, "maincpu", 0 )
-	ROM_LOAD( "epr7100.ic18", 0x00000, 0x8000, CRC(268ecb1d) SHA1(a9274c9718f7244235cc6df76331d6a0b7e4e4c8) )
+	ROM_LOAD( "epr7100_evg.ic18", 0x00000, 0x8000, CRC(268ecb1d) SHA1(a9274c9718f7244235cc6df76331d6a0b7e4e4c8) )
 	ROM_LOAD( "epr7101.ic91", 0x10000, 0x8000, CRC(ebf5ff72) SHA1(13ae06e3a81cf00b80ec939d5baf30143d61d480) )
 	ROM_LOAD( "epr7102.ic92", 0x18000, 0x8000, CRC(c890a4ad) SHA1(4b59d37902ace3a69b380ff40652ee37c85f0e9d) )
 
diff -Nru src-old/mame/drivers/taitogn.c src/mame/drivers/taitogn.c
--- src-old/mame/drivers/taitogn.c	2012-01-28 05:45:41.000000000 +0100
+++ src/mame/drivers/taitogn.c	2012-02-19 16:23:23.000000000 +0100
@@ -451,7 +451,8 @@
 	taitogn_state *state = space->machine().driver_data<taitogn_state>();
 
 	if(offset >= 0x140 && offset <= 0x144) {
-		UINT8 key[5];
+		dynamic_buffer key;
+
 		int pos = (offset - 0x140)*2;
 		UINT8 v, k;
 		if(ACCESSING_BITS_16_23) {
@@ -459,8 +460,8 @@
 			pos++;
 		} else
 			v = data;
-		chd_get_metadata(get_disk_handle(space->machine(), ":card"), HARD_DISK_KEY_METADATA_TAG, 0, key, 5, 0, 0, 0);
-		k = pos < 5 ? key[pos] : 0;
+		get_disk_handle(space->machine(), ":drive_0")->read_metadata(HARD_DISK_KEY_METADATA_TAG, 0, key);
+		k = pos < key.count() ? key[pos] : 0;
 		if(v == k)
 			state->m_locked &= ~(1 << pos);
 		else
@@ -889,9 +890,10 @@
 	psx_sio_install_handler(machine, 0, sio_pad_handler);
 	state->m_dip_timer = machine.scheduler().timer_alloc( FUNC(dip_timer_fired), NULL );
 
+	UINT32 metalength;
 	memset(state->m_cis, 0xff, 512);
-	if (get_disk_handle(machine, ":card") != NULL)
-		chd_get_metadata(get_disk_handle(machine, ":card"), PCMCIA_CIS_METADATA_TAG, 0, state->m_cis, 512, 0, 0, 0);
+	if (get_disk_handle(machine, ":drive_0") != NULL)
+		get_disk_handle(machine, ":drive_0")->read_metadata(PCMCIA_CIS_METADATA_TAG, 0, state->m_cis, 512, metalength);
 }
 
 static DRIVER_INIT( coh3002t_mp )
@@ -975,7 +977,7 @@
 	MCFG_MACHINE_RESET( coh3002t )
 
 	MCFG_AT28C16_ADD( "at28c16", 0 )
-	MCFG_IDE_CONTROLLER_ADD( "card", 0 )
+	MCFG_IDE_CONTROLLER_ADD( "card", 0, ide_devices, "hdd", NULL)
 
 	MCFG_MB3773_ADD("mb3773")
 
@@ -1127,7 +1129,7 @@
 ROM_START(raycris)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "raycris", 0, SHA1(015cb0e6c4421cc38809de28c4793b4491386aee))
 ROM_END
 
@@ -1135,28 +1137,28 @@
 ROM_START(gobyrc)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "gobyrc", 0, SHA1(0bee1f495fc8b033fd56aad9260ae94abb35eb58))
 ROM_END
 
 ROM_START(rcdego)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "rcdego", 0, SHA1(9e177f2a3954cfea0c8c5a288e116324d10f5dd1))
 ROM_END
 
 ROM_START(chaoshea)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "chaosheat", 0, SHA1(c13b7d7025eee05f1f696d108801c7bafb3f1356))
 ROM_END
 
 ROM_START(chaosheaj)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "chaosheatj", 0, SHA1(2f211ac08675ea8ec33c7659a13951db94eaa627))
 ROM_END
 
@@ -1164,7 +1166,7 @@
 ROM_START(flipmaze)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "flipmaze", 0, SHA1(423b6c06f4f2d9a608ce20b61a3ac11687d22c40) )
 ROM_END
 
@@ -1172,42 +1174,42 @@
 ROM_START(spuzbobl)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "spuzbobl", 0, SHA1(1b1c72fb7e5656021485fefaef8f2ba48e2b4ea8))
 ROM_END
 
 ROM_START(spuzboblj)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "spuzbobj", 0, SHA1(dac433cf88543d2499bf797d7406b82ae4338726))
 ROM_END
 
 ROM_START(soutenry)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "soutenry", 0, SHA1(9204d0be833d29f37b8cd3fbdf09da69b622254b))
 ROM_END
 
 ROM_START(shanghss)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "shanghss", 0, SHA1(7964f71ec5c81d2120d83b63a82f97fbad5a8e6d))
 ROM_END
 
 ROM_START(sianniv)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "sianniv", 0, SHA1(1e08b813190a9e1baf29bc16884172d6c8da7ae3))
 ROM_END
 
 ROM_START(kollon)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kollon", 0, SHA1(d8ea5b5b0ee99004b16ef89883e23de6c7ddd7ce))
 ROM_END
 
@@ -1215,14 +1217,14 @@
 	TAITOGNET_BIOS
 	ROM_DEFAULT_BIOS( "v2" )
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "kollonc", 0, SHA1(ce62181659701cfb8f7c564870ab902be4d8e060)) /* Original Taito Compact Flash version */
 ROM_END
 
 ROM_START(shikigam)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "shikigam", 0, SHA1(fa49a0bc47f5cb7c30d7e49e2c3696b21bafb840))
 ROM_END
 
@@ -1232,7 +1234,7 @@
 ROM_START(otenamih)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "otenamih", 0, SHA1(b3babe3a1876c43745616ee1e7d87276ce7dad0b) )
 ROM_END
 
@@ -1240,28 +1242,28 @@
 ROM_START(psyvaria)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "psyvaria", 0,  SHA1(b981a42a10069322b77f7a268beae1d409b4156d))
 ROM_END
 
 ROM_START(psyvarrv)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "psyvarrv", 0, SHA1(277c4f52502bcd7acc1889840962ec80d56465f3))
 ROM_END
 
 ROM_START(zooo)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "zooo", 0, SHA1(e275b3141b2bc49142990e6b497a5394a314a30b))
 ROM_END
 
 ROM_START(zokuoten)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "zokuoten", 0, SHA1(5ce13db00518f96af64935176c71ec68d2a51938))
 ROM_END
 
@@ -1269,7 +1271,7 @@
 	TAITOGNET_BIOS
 	ROM_DEFAULT_BIOS( "v2" )
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "otenamhf", 0, SHA1(5b15c33bf401e5546d78e905f538513d6ffcf562)) /* Original Taito Compact Flash version */
 ROM_END
 
@@ -1281,14 +1283,14 @@
 ROM_START(nightrai)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "nightrai", 0, SHA1(74d0458f851cbcf10453c5cc4c47bb4388244cdf))
 ROM_END
 
 ROM_START(otenki)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "otenki", 0, SHA1(7e745ca4c4570215f452fd09cdd56a42c39caeba))
 ROM_END
 
@@ -1297,21 +1299,21 @@
 ROM_START(usagi)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "usagi", 0, SHA1(edf9dd271957f6cb06feed238ae21100514bef8e))
 ROM_END
 
 ROM_START(mahjngoh)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "mahjngoh", 0, SHA1(3ef1110d15582d7c0187438d7ad61765dd121cff))
 ROM_END
 
 ROM_START(shangtou)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "shanghaito", 0, SHA1(9901db5a9aae77e3af4157aa2c601eaab5b7ca85) )
 ROM_END
 
@@ -1321,7 +1323,7 @@
 ROM_START(xiistag)
 	TAITOGNET_BIOS
 
-	DISK_REGION( "card" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "xiistag", 0, SHA1(586e37c8d926293b2bd928e5f0d693910cfb05a2))
 ROM_END
 
diff -Nru src-old/mame/drivers/taitowlf.c src/mame/drivers/taitowlf.c
--- src-old/mame/drivers/taitowlf.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/drivers/taitowlf.c	2012-02-09 11:27:12.000000000 +0100
@@ -644,7 +644,7 @@
 	MCFG_I8237_ADD( "dma8237_2", XTAL_14_31818MHz/3, dma8237_2_config )
 	MCFG_PIC8259_ADD( "pic8259_1", taitowlf_pic8259_1_config )
 	MCFG_PIC8259_ADD( "pic8259_2", taitowlf_pic8259_2_config )
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 	MCFG_MC146818_ADD( "rtc", MC146818_STANDARD )
 
 	/* video hardware */
diff -Nru src-old/mame/drivers/tankbatt.c src/mame/drivers/tankbatt.c
--- src-old/mame/drivers/tankbatt.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/tankbatt.c	2012-02-19 02:53:16.000000000 +0100
@@ -98,7 +98,7 @@
 	state->m_sound_enable = !data;
 
 	/* hack - turn off the engine noise if the normal game nmi's are disabled */
-	if (data) sample_stop (space->machine().device("samples"), 2);
+	if (data) space->machine().device<samples_device>("samples")->stop(2);
 }
 
 static WRITE8_HANDLER( tankbatt_demo_interrupt_enable_w )
@@ -112,23 +112,23 @@
 	tankbatt_state *state = space->machine().driver_data<tankbatt_state>();
 	if (state->m_sound_enable)
 	{
-		device_t *samples = space->machine().device("samples");
-		sample_start (samples, 1, 3, 0);
+		samples_device *samples = space->machine().device<samples_device>("samples");
+		samples->start(1, 3);
 	}
 }
 
 static WRITE8_HANDLER( tankbatt_sh_engine_w )
 {
 	tankbatt_state *state = space->machine().driver_data<tankbatt_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	if (state->m_sound_enable)
 	{
 		if (data)
-			sample_start (samples, 2, 2, 1);
+			samples->start(2, 2, true);
 		else
-			sample_start (samples, 2, 1, 1);
+			samples->start(2, 1, true);
 	}
-	else sample_stop (samples, 2);
+	else samples->stop(2);
 }
 
 static WRITE8_HANDLER( tankbatt_sh_fire_w )
@@ -136,8 +136,8 @@
 	tankbatt_state *state = space->machine().driver_data<tankbatt_state>();
 	if (state->m_sound_enable)
 	{
-		device_t *samples = space->machine().device("samples");
-		sample_start (samples, 0, 0, 0);
+		samples_device *samples = space->machine().device<samples_device>("samples");
+		samples->start(0, 0);
 	}
 }
 
@@ -311,8 +311,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(tankbatt_samples_interface)
+	MCFG_SAMPLES_ADD("samples", tankbatt_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/thayers.c src/mame/drivers/thayers.c
--- src-old/mame/drivers/thayers.c	2012-01-15 22:40:54.000000000 +0100
+++ src/mame/drivers/thayers.c	2012-02-18 03:48:45.000000000 +0100
@@ -821,7 +821,7 @@
 ROM_START( thayersa )
 	ROM_REGION( 0xe000, "maincpu", 0 )
 	ROM_LOAD( "tq_u33.bin", 0x0000, 0x8000, CRC(82df5d89) SHA1(58dfd62bf8c5a55d1eba397d2c284e99a4685a3f) )
-	ROM_LOAD( "tq_u1.bin",  0xc000, 0x2000, CRC(33817e25) SHA1(f9750da863dd57fe2f5b6e8fce9c6695dc5c9adc) )
+	ROM_LOAD( "tq_u1_alt.bin",  0xc000, 0x2000, CRC(33817e25) SHA1(f9750da863dd57fe2f5b6e8fce9c6695dc5c9adc) )
 
 	ROM_REGION( 0x400, "mcu", 0 )
 	ROM_LOAD( "tq_cop.bin", 0x000, 0x400, CRC(6748e6b3) SHA1(5d7d1ecb57c1501ef6a2d9691eecc9970586606b) )
diff -Nru src-old/mame/drivers/thepit.c src/mame/drivers/thepit.c
--- src-old/mame/drivers/thepit.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/thepit.c	2012-02-19 01:27:36.000000000 +0100
@@ -834,11 +834,11 @@
 	ROM_LOAD( "bl-ic33.bin",  0x4000, 0x1000, CRC(1f3c78ee) SHA1(961b6ba8d08ddcbeda52b98a2f181f37beed5fb1) )
 
 	ROM_REGION( 0x10000, "audiocpu", 0 )
-	ROM_LOAD( "ic30.bin",     0x0000, 0x0800, CRC(1b18faee) SHA1(b4002e2fdaa6bb966da4faa46ac56751a3841f5f) )
-	ROM_LOAD( "ic31.bin",     0x0800, 0x0800, CRC(76cf4394) SHA1(5dc13bd5fc92ce4ce12bab60576292a6028891c3) )
+	ROM_LOAD( "bl-ic30.bin",  0x0000, 0x0800, CRC(1b18faee) SHA1(b4002e2fdaa6bb966da4faa46ac56751a3841f5f) )
+	ROM_LOAD( "bl-ic31.bin",  0x0800, 0x0800, CRC(76cf4394) SHA1(5dc13bd5fc92ce4ce12bab60576292a6028891c3) )
 
 	ROM_REGION( 0x1800, "gfx1", 0 ) /* chars and sprites */
-	ROM_LOAD( "ic9.bin",      0x0000, 0x0800, CRC(394676a2) SHA1(5bd26d717e25b7c192af8173db9ae18371dbcfbe) )
+	ROM_LOAD( "bl-ic9.bin",   0x0000, 0x0800, CRC(394676a2) SHA1(5bd26d717e25b7c192af8173db9ae18371dbcfbe) )
 	ROM_LOAD( "ic10.bin",     0x1000, 0x0800, CRC(a38d708d) SHA1(6632392cece34332a2a4427ec14d95f201319c67) )
 
 	ROM_REGION( 0x0020, "proms", 0 )
diff -Nru src-old/mame/drivers/thief.c src/mame/drivers/thief.c
--- src-old/mame/drivers/thief.c	2012-02-03 16:00:15.000000000 +0100
+++ src/mame/drivers/thief.c	2012-02-19 02:53:16.000000000 +0100
@@ -59,35 +59,35 @@
 	kTalkTrack, kCrashTrack
 };
 
-static void tape_set_audio( device_t *samples, int track, int bOn )
+static void tape_set_audio( samples_device *samples, int track, int bOn )
 {
-	sample_set_volume(samples, track, bOn ? 1.0 : 0.0 );
+	samples->set_volume(track, bOn ? 1.0 : 0.0 );
 }
 
-static void tape_set_motor( device_t *samples, int bOn )
+static void tape_set_motor( samples_device *samples, int bOn )
 {
 	if( bOn )
 	{
 		/* If talk track is not playing, start it. */
-		if (! sample_playing(samples,  kTalkTrack ))
-			sample_start( samples, 0, kTalkTrack, 1 );
+		if (! samples->playing( kTalkTrack ))
+			samples->start( 0, kTalkTrack, true );
 
 		/* Resume playback of talk track. */
-		sample_set_pause( samples, kTalkTrack, 0);
+		samples->pause( kTalkTrack, false);
 
 
 		/* If crash track is not playing, start it. */
-		if (! sample_playing(samples,  kCrashTrack ))
-			sample_start( samples, 1, kCrashTrack, 1 );
+		if (! samples->playing( kCrashTrack ))
+			samples->start( 1, kCrashTrack, true );
 
 		/* Resume playback of crash track. */
-		sample_set_pause( samples, kCrashTrack, 0);
+		samples->pause( kCrashTrack, false);
 	}
 	else
 	{
 		/* Pause both the talk and crash tracks. */
-		sample_set_pause( samples, kTalkTrack, 1 );
-		sample_set_pause( samples, kCrashTrack, 1 );
+		samples->pause( kTalkTrack, true );
+		samples->pause( kCrashTrack, true );
 	}
 }
 
@@ -113,27 +113,27 @@
 		break;
 
 	case 0x08: /* talk track on */
-		tape_set_audio( device, kTalkTrack, 1 );
+		tape_set_audio( downcast<samples_device *>(device), kTalkTrack, 1 );
 		break;
 
 	case 0x09: /* talk track off */
-		tape_set_audio( device, kTalkTrack, 0 );
+		tape_set_audio( downcast<samples_device *>(device), kTalkTrack, 0 );
 		break;
 
 	case 0x0a: /* motor on */
-		tape_set_motor( device, 1 );
+		tape_set_motor( downcast<samples_device *>(device), 1 );
 		break;
 
 	case 0x0b: /* motor off */
-		tape_set_motor( device, 0 );
+		tape_set_motor( downcast<samples_device *>(device), 0 );
 		break;
 
 	case 0x0c: /* crash track on */
-		tape_set_audio( device, kCrashTrack, 1 );
+		tape_set_audio( downcast<samples_device *>(device), kCrashTrack, 1 );
 		break;
 
 	case 0x0d: /* crash track off */
-		tape_set_audio( device, kCrashTrack, 0 );
+		tape_set_audio( downcast<samples_device *>(device), kCrashTrack, 0 );
 		break;
 	}
 }
@@ -465,8 +465,7 @@
 	MCFG_SOUND_ADD("ay2", AY8910, 4000000/4)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(sharkatt_samples_interface)
+	MCFG_SAMPLES_ADD("samples", sharkatt_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -502,8 +501,7 @@
 	MCFG_SOUND_ADD("ay2", AY8910, 4000000/4)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(thief_samples_interface)
+	MCFG_SAMPLES_ADD("samples", thief_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
@@ -539,8 +537,7 @@
 	MCFG_SOUND_ADD("ay2", AY8910, 4000000/4)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(natodef_samples_interface)
+	MCFG_SAMPLES_ADD("samples", natodef_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/tmnt.c src/mame/drivers/tmnt.c
--- src-old/mame/drivers/tmnt.c	2012-01-28 00:57:39.000000000 +0100
+++ src/mame/drivers/tmnt.c	2012-02-19 02:53:16.000000000 +0100
@@ -264,11 +264,11 @@
 	/* bit 2 plays the title music */
 	if (data & 0x04)
 	{
-		if (!sample_playing(state->m_samples, 0))
-			sample_start_raw(state->m_samples, 0, state->m_sampledata, 0x40000, 20000, 0);
+		if (!state->m_samples->playing(0))
+			state->m_samples->start_raw(0, state->m_sampledata, 0x40000, 20000);
 	}
 	else
-		sample_stop(state->m_samples, 0);
+		state->m_samples->stop(0);
 	state->m_tmnt_soundlatch = data;
 }
 
@@ -285,7 +285,7 @@
 
 static SAMPLES_START( tmnt_decode_sample )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	tmnt_state *state = machine.driver_data<tmnt_state>();
 	int i;
 	UINT8 *source = machine.region("title")->base();
@@ -2235,7 +2235,7 @@
 	state->m_k053260 = machine.device("k053260");
 	state->m_k054539 = machine.device("k054539");
 	state->m_upd = machine.device("upd");
-	state->m_samples = machine.device("samples");
+	state->m_samples = machine.device<samples_device>("samples");
 	state->m_k052109 = machine.device("k052109");
 	state->m_k051960 = machine.device("k051960");
 	state->m_k053245 = machine.device("k053245");
@@ -2413,8 +2413,7 @@
 	MCFG_SOUND_ADD("upd", UPD7759, XTAL_640kHz)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.60)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(tmnt_samples_interface)
+	MCFG_SAMPLES_ADD("samples", tmnt_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/tnzs.c src/mame/drivers/tnzs.c
--- src-old/mame/drivers/tnzs.c	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/drivers/tnzs.c	2012-02-19 02:53:16.000000000 +0100
@@ -632,7 +632,7 @@
 
 static SAMPLES_START( kageki_init_samples )
 {
-	running_machine &machine = device->machine();
+	running_machine &machine = device.machine();
 	tnzs_state *state = machine.driver_data<tnzs_state>();
 	UINT8 *scan, *src;
 	INT16 *dest;
@@ -717,16 +717,17 @@
 	}
 	else
 	{
+		samples_device *samples = downcast<samples_device *>(device);
 		if (data > MAX_SAMPLES)
 		{
 			// stop samples
-			sample_stop(device, 0);
+			samples->stop(0);
 			sprintf(mess, "VOICE:%02X STOP", data);
 		}
 		else
 		{
 			// play samples
-			sample_start_raw(device, 0, state->m_sampledata[data], state->m_samplesize[data], 7000, 0);
+			samples->start_raw(0, state->m_sampledata[data], state->m_samplesize[data], 7000);
 			sprintf(mess, "VOICE:%02X PLAY", data);
 		}
 	//  popmessage(mess);
@@ -1818,8 +1819,7 @@
 	MCFG_SOUND_ROUTE(2, "mono", 0.15)
 	MCFG_SOUND_ROUTE(3, "mono", 0.35)
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(tnzs_samples_interface)
+	MCFG_SAMPLES_ADD("samples", tnzs_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_CONFIG_END
 
diff -Nru src-old/mame/drivers/toratora.c src/mame/drivers/toratora.c
--- src-old/mame/drivers/toratora.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/toratora.c	2012-02-11 11:01:01.000000000 +0100
@@ -149,7 +149,7 @@
 	if (state->m_last != (input_port_read(device->machine(), "INPUT") & 0x0f))
 	{
 		state->m_last = input_port_read(device->machine(), "INPUT") & 0x0f;
-		generic_pulse_irq_line(device, 0);
+		generic_pulse_irq_line(device, 0, 1);
 	}
 	state->m_pia_u1->set_a_input(input_port_read(device->machine(), "INPUT") & 0x0f, 0);
 	state->m_pia_u1->ca1_w(input_port_read(device->machine(), "INPUT") & 0x10);
diff -Nru src-old/mame/drivers/triplhnt.c src/mame/drivers/triplhnt.c
--- src-old/mame/drivers/triplhnt.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/triplhnt.c	2012-02-19 02:53:16.000000000 +0100
@@ -36,7 +36,7 @@
 static void triplhnt_update_misc(running_machine &machine, int offset)
 {
 	triplhnt_state *state = machine.driver_data<triplhnt_state>();
-	device_t *samples = machine.device("samples");
+	samples_device *samples = machine.device<samples_device>("samples");
 	device_t *discrete = machine.device("discrete");
 	UINT8 is_witch_hunt;
 	UINT8 bit = offset >> 1;
@@ -80,14 +80,14 @@
 	bit = ~state->m_misc_flags & 0x40;
 
 	/* if we're not playing the sample yet, start it */
-	if (!sample_playing(samples, 0))
-		sample_start(samples, 0, 0, 1);
-	if (!sample_playing(samples, 1))
-		sample_start(samples, 1, 1, 1);
+	if (!samples->playing(0))
+		samples->start(0, 0, true);
+	if (!samples->playing(1))
+		samples->start(1, 1, true);
 
 	/* bit 6 turns cassette on/off */
-	sample_set_pause(samples, 0,  is_witch_hunt || bit);
-	sample_set_pause(samples, 1, !is_witch_hunt || bit);
+	samples->pause(0,  is_witch_hunt || bit);
+	samples->pause(1, !is_witch_hunt || bit);
 }
 
 
@@ -334,8 +334,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("samples", SAMPLES, 0)
-	MCFG_SOUND_CONFIG(triplhnt_samples_interface)
+	MCFG_SAMPLES_ADD("samples", triplhnt_samples_interface)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.20)
 
 	MCFG_SOUND_ADD("discrete", DISCRETE, 0)
diff -Nru src-old/mame/drivers/truco.c src/mame/drivers/truco.c
--- src-old/mame/drivers/truco.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/truco.c	2012-02-11 11:01:01.000000000 +0100
@@ -399,7 +399,7 @@
 	{
 		if ( state->m_trigger == 0 )
 		{
-			generic_pulse_irq_line(device, M6809_IRQ_LINE);
+			generic_pulse_irq_line(device, M6809_IRQ_LINE, 1);
 			state->m_trigger++;
 		}
 	} else
diff -Nru src-old/mame/drivers/tsamurai.c src/mame/drivers/tsamurai.c
--- src-old/mame/drivers/tsamurai.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/tsamurai.c	2012-02-10 19:13:08.000000000 +0100
@@ -350,9 +350,9 @@
 static INPUT_PORTS_START( tsamurai )
 	PORT_START("P1")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_4WAY
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_4WAY
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_4WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_4WAY
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -360,9 +360,9 @@
 
 	PORT_START("P2")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -428,9 +428,26 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( nunchaku )
+
+static INPUT_PORTS_START( ladymstr )
 	PORT_INCLUDE( tsamurai )
 
+	PORT_MODIFY("P1")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY
+
+	PORT_MODIFY("P2")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY PORT_COCKTAIL
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( nunchaku )
+	PORT_INCLUDE( ladymstr )
+
 	PORT_MODIFY("DSW2")
 	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Lives ) )
 	PORT_DIPSETTING(    0x00, "3" )
@@ -455,9 +472,22 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 INPUT_PORTS_END
 
+
 static INPUT_PORTS_START( vsgongf )
 	PORT_INCLUDE( tsamurai )
 
+	PORT_MODIFY("P1")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY
+
+	PORT_MODIFY("P2")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY PORT_COCKTAIL
+
 	PORT_MODIFY("DSW2")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
@@ -485,14 +515,15 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 INPUT_PORTS_END
 
+
 static INPUT_PORTS_START( yamagchi )
 	PORT_INCLUDE( tsamurai )
 
 	PORT_MODIFY("P1")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_8WAY
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_8WAY
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_8WAY
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON2 )
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 )
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -500,9 +531,9 @@
 
 	PORT_MODIFY("P2")
 	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON2 ) PORT_COCKTAIL
 	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
@@ -533,8 +564,21 @@
 	PORT_DIPSETTING(    0x80, DEF_STR( On ) )
 INPUT_PORTS_END
 
+
 static INPUT_PORTS_START( m660 )
-	PORT_INCLUDE( yamagchi )
+	PORT_INCLUDE( tsamurai )
+
+	PORT_MODIFY("P1")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY
+
+	PORT_MODIFY("P2")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT  ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP    ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN  ) PORT_8WAY PORT_COCKTAIL
 
 	PORT_MODIFY("DSW1")
 	PORT_DIPNAME( 0x07, 0x00, DEF_STR( Coin_A ) )
@@ -643,15 +687,15 @@
 static MACHINE_CONFIG_START( tsamurai, tsamurai_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", Z80, 4000000)
+	MCFG_CPU_ADD("maincpu", Z80, XTAL_24MHz/8)
 	MCFG_CPU_PROGRAM_MAP(main_map)
 	MCFG_CPU_IO_MAP(z80_io_map)
 	MCFG_CPU_VBLANK_INT("screen", samurai_interrupt)
 
-	MCFG_CPU_ADD("audiocpu", Z80, 2000000)
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_24MHz/8)
 	MCFG_CPU_PROGRAM_MAP(sound1_map)
 
-	MCFG_CPU_ADD("audio2", Z80, 2000000)
+	MCFG_CPU_ADD("audio2", Z80, XTAL_24MHz/8)
 	MCFG_CPU_PROGRAM_MAP(sound2_map)
 
 	/* video hardware */
@@ -671,7 +715,7 @@
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("aysnd", AY8910, 2000000)
+	MCFG_SOUND_ADD("aysnd", AY8910, XTAL_24MHz/8)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
 	MCFG_SOUND_ADD("dac1", DAC, 0)
@@ -682,24 +726,17 @@
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_START( m660, tsamurai_state )
+static MACHINE_CONFIG_START( vsgongf, tsamurai_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", Z80, 4000000)
-	MCFG_CPU_PROGRAM_MAP(m660_map)
-	MCFG_CPU_IO_MAP(z80_m660_io_map)
+	MCFG_CPU_ADD("maincpu", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(vsgongf_map)
 	MCFG_CPU_VBLANK_INT("screen", samurai_interrupt)
 
-	MCFG_CPU_ADD("audiocpu", Z80, 2000000)
-	MCFG_CPU_PROGRAM_MAP(sound1_m660_map)
-
-	MCFG_CPU_ADD("audio2", Z80, 2000000)
-	MCFG_CPU_PROGRAM_MAP(sound2_m660_map)
-
-	MCFG_CPU_ADD("audio3", Z80, 2000000)
-	MCFG_CPU_PROGRAM_MAP(sound3_m660_map)
-	MCFG_CPU_IO_MAP(sound3_m660_io_map)
-	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(sound_vsgongf_map)
+	MCFG_CPU_IO_MAP(vsgongf_audio_io_map)
+	MCFG_CPU_PERIODIC_INT(vsgongf_sound_interrupt,3*60)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -707,39 +744,43 @@
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0, 255, 8, 255-8)
-	MCFG_SCREEN_UPDATE_STATIC(tsamurai)
+	MCFG_SCREEN_UPDATE_STATIC(vsgongf)
 
 	MCFG_GFXDECODE(tsamurai)
 	MCFG_PALETTE_LENGTH(256)
 
 	MCFG_PALETTE_INIT(RRRR_GGGG_BBBB)
-	MCFG_VIDEO_START(tsamurai)
+	MCFG_VIDEO_START(vsgongf)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("aysnd", AY8910, 2000000)
+	MCFG_SOUND_ADD("aysnd", AY8910, XTAL_24MHz/8)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
-	MCFG_SOUND_ADD("dac1", DAC, 0)
-	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.20)
-
-	MCFG_SOUND_ADD("dac2", DAC, 0)
+	MCFG_SOUND_ADD("dac", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.20)
 MACHINE_CONFIG_END
 
 
-static MACHINE_CONFIG_START( vsgongf, tsamurai_state )
+static MACHINE_CONFIG_START( m660, tsamurai_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", Z80, 4000000)
-	MCFG_CPU_PROGRAM_MAP(vsgongf_map)
+	MCFG_CPU_ADD("maincpu", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(m660_map)
+	MCFG_CPU_IO_MAP(z80_m660_io_map)
 	MCFG_CPU_VBLANK_INT("screen", samurai_interrupt)
 
-	MCFG_CPU_ADD("audiocpu", Z80, 4000000)
-	MCFG_CPU_PROGRAM_MAP(sound_vsgongf_map)
-	MCFG_CPU_IO_MAP(vsgongf_audio_io_map)
-	MCFG_CPU_PERIODIC_INT(vsgongf_sound_interrupt,3*60)
+	MCFG_CPU_ADD("audiocpu", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(sound1_m660_map)
+
+	MCFG_CPU_ADD("audio2", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(sound2_m660_map)
+
+	MCFG_CPU_ADD("audio3", Z80, XTAL_24MHz/8)
+	MCFG_CPU_PROGRAM_MAP(sound3_m660_map)
+	MCFG_CPU_IO_MAP(sound3_m660_io_map)
+	MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
 
 	/* video hardware */
 	MCFG_SCREEN_ADD("screen", RASTER)
@@ -747,21 +788,24 @@
 	MCFG_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
 	MCFG_SCREEN_SIZE(32*8, 32*8)
 	MCFG_SCREEN_VISIBLE_AREA(0, 255, 8, 255-8)
-	MCFG_SCREEN_UPDATE_STATIC(vsgongf)
+	MCFG_SCREEN_UPDATE_STATIC(tsamurai)
 
 	MCFG_GFXDECODE(tsamurai)
 	MCFG_PALETTE_LENGTH(256)
 
 	MCFG_PALETTE_INIT(RRRR_GGGG_BBBB)
-	MCFG_VIDEO_START(vsgongf)
+	MCFG_VIDEO_START(tsamurai)
 
 	/* sound hardware */
 	MCFG_SPEAKER_STANDARD_MONO("mono")
 
-	MCFG_SOUND_ADD("aysnd", AY8910, 2000000)
+	MCFG_SOUND_ADD("aysnd", AY8910, XTAL_24MHz/8)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.10)
 
-	MCFG_SOUND_ADD("dac", DAC, 0)
+	MCFG_SOUND_ADD("dac1", DAC, 0)
+	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.20)
+
+	MCFG_SOUND_ADD("dac2", DAC, 0)
 	MCFG_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.20)
 MACHINE_CONFIG_END
 
@@ -1205,11 +1249,11 @@
 GAME( 1984, ringfgt,  vsgongf,  vsgongf,  vsgongf,  0, ROT90, "Kaneko (Taito license)", "Ring Fighter (set 1)", GAME_IMPERFECT_COLORS )
 GAME( 1984, ringfgt2, vsgongf,  vsgongf,  vsgongf,  0, ROT90, "Kaneko (Taito license)", "Ring Fighter (set 2)", GAME_IMPERFECT_COLORS )
 
-GAME( 1985, tsamurai, 0,        tsamurai, tsamurai, 0, ROT90, "Kaneko / Taito", "Samurai Nihon-ichi (set 1)", 0 )
-GAME( 1985, tsamurai2,tsamurai, tsamurai, tsamurai, 0, ROT90, "Kaneko / Taito", "Samurai Nihon-ichi (set 2)", 0 )
-GAME( 1985, tsamuraih,tsamurai, tsamurai, tsamurai, 0, ROT90, "bootleg", "Samurai Nihon-ichi (bootleg, harder)", 0 )
+GAME( 1985, tsamurai, 0,        tsamurai, tsamurai, 0, ROT90, "Kaneko / Taito", "Samurai Nihon-Ichi (set 1)", 0 )
+GAME( 1985, tsamurai2,tsamurai, tsamurai, tsamurai, 0, ROT90, "Kaneko / Taito", "Samurai Nihon-Ichi (set 2)", 0 )
+GAME( 1985, tsamuraih,tsamurai, tsamurai, tsamurai, 0, ROT90, "bootleg", "Samurai Nihon-Ichi (bootleg, harder)", 0 )
 
-GAME( 1985, ladymstr, 0,		tsamurai, tsamurai, 0, ROT90, "Kaneko / Taito", "Lady Master of Kung Fu", 0 )
+GAME( 1985, ladymstr, 0,        tsamurai, ladymstr, 0, ROT90, "Kaneko / Taito", "Lady Master of Kung Fu", 0 )
 GAME( 1985, nunchaku, ladymstr, tsamurai, nunchaku, 0, ROT90, "Kaneko / Taito", "Nunchackun", GAME_IMPERFECT_COLORS )
 
 GAME( 1985, yamagchi, 0,        tsamurai, yamagchi, 0, ROT90, "Kaneko / Taito", "Go Go Mr. Yamaguchi / Yuke Yuke Yamaguchi-kun", GAME_IMPERFECT_COLORS )
diff -Nru src-old/mame/drivers/twinkle.c src/mame/drivers/twinkle.c
--- src-old/mame/drivers/twinkle.c	2012-02-03 11:35:22.000000000 +0100
+++ src/mame/drivers/twinkle.c	2012-02-09 11:27:12.000000000 +0100
@@ -897,7 +897,7 @@
 	MCFG_MACHINE_RESET( twinkle )
 	MCFG_I2CMEM_ADD("security",i2cmem_interface)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 	MCFG_RTC65271_ADD("rtc", twinkle_rtc)
 
 	/* video hardware */
@@ -995,7 +995,7 @@
 	DISK_REGION( "cdrom1" ) // video CD
 	DISK_IMAGE_READONLY("863jaa04", 0, SHA1(8f6a0d2e191153032c9388b5298d8ee531b22a41) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE_READONLY("c44jaa03", 0, SHA1(53e9bd25d1674a04aeec81c0224b4e4e44af802a) )	// was part of a 1st mix machine, but "c44" indicates 8th mix?
 ROM_END
 
diff -Nru src-old/mame/drivers/ultrsprt.c src/mame/drivers/ultrsprt.c
--- src-old/mame/drivers/ultrsprt.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/ultrsprt.c	2012-02-11 11:01:01.000000000 +0100
@@ -202,7 +202,7 @@
 static void sound_irq_callback(running_machine &machine, int irq)
 {
 	if (irq == 0)
-		/*generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ5)*/;
+		/*generic_pulse_irq_line(machine.device("audiocpu"), INPUT_LINE_IRQ5, 1)*/;
 	else
 		cputag_set_input_line(machine, "audiocpu", INPUT_LINE_IRQ6, HOLD_LINE);
 }
diff -Nru src-old/mame/drivers/vamphalf.c src/mame/drivers/vamphalf.c
--- src-old/mame/drivers/vamphalf.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/drivers/vamphalf.c	2012-02-19 16:23:23.000000000 +0100
@@ -18,6 +18,7 @@
     Date Quiz Go Go Episode 2       (c) 2000 SemiCom
     Mission Craft                   (c) 2000 Sun                (version 2.4)
     Mr. Dig                         (c) 2000 Sun
+    Diet Family                     (c) 2001 SemiCom
     Final Godori                    (c) 2001 SemiCom            (version 2.20.5915)
     Wyvern Wings                    (c) 2001 SemiCom
     Mr. Kicker                      (c) 2001 SemiCom [1]
@@ -43,7 +44,6 @@
    Red Wyvern - A semi-sequel or update?
  Same time era, but unknown hardware:
    Gaia The last Choice of the Earth (c) 1998 (might be Byron Future Assault type hardware)
-   Diet Family (c) 2001
    Choice III: Joker's Dream (c) 2001
 
 TODO:
@@ -1351,7 +1351,6 @@
 	ROM_LOAD( "cm-vrom1.020", 0x00000, 0x40000, CRC(fcc28081) SHA1(44031df0ee28ca49df12bcb73c83299fac205e21) )
 ROM_END
 
-
 /*
 
 Date Quiz Go Go Episode 2
@@ -1426,6 +1425,78 @@
 
 /*
 
+Diet Family
+SemiCom, 2001
+
+PCB Layout
+----------
+
+F-E1-16-010
++-----------------------------------------------+
+|     VR1          YM3012  VROM1                |
+|                  YM2151  M6295   ROML03 ROMU03|
+|               CRAM2              ROML02 ROMU02|
+|               CRAM1              ROML01 ROMU01|
+|               MEM1L              ROML00 ROMU00|
+|J              MEM1U                           |
+|A              MEM2  +----------++----------+  |
+|M                    |          ||          |  |
+|M              MEM3  |Quicklogic||Quicklogic| 2|
+|A                    | QL2003-  || QL2003-  | 8|
+|               MEM6  | XPL84C   || XPL84C   | M|
+|                     |          ||          | H|
+|               MEM7  +----------++----------+ z|
+|                      GAL                      |
+|    93C46                       ROM1           |
+|P1 P2   50MHz E1-16T   DRAM1    ROM2           |
++-----------------------------------------------+
+
+Notes:
+CPU - Hyperstone E1-16T @ 50.000MHz
+
+DRAM1 - LG Semi GM71C18163 1M x16 EDO DRAM (SOJ44)
+CRAMx - W24M257AK-15 32K x8 SRAM (SOJ28)
+MEMx  - UM61256FK-15 32K x8 SRAM (SOJ28)
+
+Oki M6295 rebaged as AD-65
+YM3012/YM2151 rebaged as BS902/KA51
+
+ P1 - Reset push button
+ P2 - Setup push button
+VR1 - Volume adjust pot
+
+ROMs:
+    ROML00 & ROMH00 - Macronix MX29F1610MC-12 SOP44 16MBit FlashROM
+    ROML01 & ROMH01 - Macronix MX29F1610MC-12 SOP44 16MBit FlashROM
+    ROML02 & ROMH02 - Macronix MX29F1610MC-12 SOP44 16MBit FlashROM
+    ROML03 & ROMH03 - Unpopulated space for MX29F1610MC-12 SOP44 16MBit FlashROM
+    VROM1           - 27C040 2MBit DIP32 EPROM
+    ROM1            - 27C040 4MBit DIP32 EPROM
+    ROM2            - 27C040 4MBit DIP32 EPROM
+
+*/
+
+ROM_START( dtfamily )
+	ROM_REGION16_BE( 0x100000, "user1", ROMREGION_ERASE00 ) /* Hyperstone CPU Code */
+	ROM_LOAD( "rom1",         0x00000, 0x080000, CRC(738636d2) SHA1(ba7906df99764ee7e1f505c319d364c64c605ff0) )
+	ROM_LOAD( "rom2",         0x80000, 0x080000, CRC(0953f5e4) SHA1(ee8b3c4f9c9301c9815747eab5435e006ec84ca1) )
+
+	ROM_REGION( 0xc00000, "gfx1", 0 ) /* 16x16x8 Sprites */
+	ROM_LOAD32_WORD( "roml00", 0x000000, 0x200000, CRC(7e2a7520) SHA1(0ff157fe34ff31cd8636af821fe14c12242d757f) )
+	ROM_LOAD32_WORD( "romu00", 0x000002, 0x200000, CRC(c170755f) SHA1(019d24979071f0ab2b3c93a5ec9327e6a0b2afa2) )
+	ROM_LOAD32_WORD( "roml01", 0x400000, 0x200000, CRC(3d487ffe) SHA1(c5608423d608922c0e1ac8bdfaa0de062b2c9821) )
+	ROM_LOAD32_WORD( "romu01", 0x400002, 0x200000, CRC(716efedb) SHA1(fb468d93817a49173698872c49a289c257f77a92) )
+	ROM_LOAD32_WORD( "roml02", 0x800000, 0x200000, CRC(c3dd3c96) SHA1(2707f690b5850685f782fc04a7dbd1d91f443223) )
+	ROM_LOAD32_WORD( "romu02", 0x800002, 0x200000, CRC(80830961) SHA1(b318e9e3a4d1d7dca61d7d4c9ee01f605e2b2f4a) )
+	/* roml03 empty */
+	/* romu03 empty */
+
+	ROM_REGION( 0x80000, "oki", 0 ) /* Oki Samples */
+	ROM_LOAD( "vrom1", 0x00000, 0x80000, CRC(4aacaef3) SHA1(c079170dc0ba0b91b1780cd175dc38151d640ff0) )
+ROM_END
+
+/*
+
 Toy Land Adventure
 SemiCom, 2001
 
@@ -1581,6 +1652,31 @@
 	ROM_LOAD( "qs1001a",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
 ROM_END
 
+ROM_START( wyvernwga )
+	ROM_REGION32_BE( 0x100000, "user1", ROMREGION_ERASE00 ) /* Hyperstone CPU Code */
+	ROM_LOAD( "rom1_alt.rom", 0x000000, 0x080000, CRC(586881fd) SHA1(d335bbd91def8fa4935eb2375c9b00471a1f40eb) )
+	ROM_LOAD( "rom2_alt.rom", 0x080000, 0x080000, CRC(938049ec) SHA1(cc10944c99ceb388dd4aafc93377c40540861d14) )
+
+	ROM_REGION( 0x020000, "audiocpu", 0 ) /* QDSP ('51) Code */
+	ROM_LOAD( "u7", 0x0000, 0x20000, CRC(00a3f705) SHA1(f0a6bafd16bea53d4c05c8cc108983cbd41e5757) )
+
+	ROM_REGION( 0x1000000, "gfx1", 0 )  /* gfx data */
+	ROM_LOAD32_WORD( "roml00", 0x000000, 0x200000, CRC(fb3541b6) SHA1(4f569ac7bde92c5febf005ab73f76552421ec223) )
+	ROM_LOAD32_WORD( "romh00", 0x000002, 0x200000, CRC(516aca48) SHA1(42cf5678eb4c0ee7da2ab0bd66e4e34b2735c75a) )
+	ROM_LOAD32_WORD( "roml01", 0x400000, 0x200000, CRC(1c764f95) SHA1(ba6ac1376e837b491bc0269f2a1d10577a3d40cb) )
+	ROM_LOAD32_WORD( "romh01", 0x400002, 0x200000, CRC(fee42c63) SHA1(a27b5cbca0defa9be85fee91dde1273f445d3372) )
+	ROM_LOAD32_WORD( "roml02", 0x800000, 0x200000, CRC(fc846707) SHA1(deaee15ab71927f644dcf576959e2ceaa55bfd44) )
+	ROM_LOAD32_WORD( "romh02", 0x800002, 0x200000, CRC(86141c7d) SHA1(22a82cc7d44d655b03867503a83e81f7c82d6c91) )
+	ROM_LOAD32_WORD( "roml03", 0xc00000, 0x200000, CRC(b10bf37c) SHA1(6af835b1e2573f0bb2c17057e016a7aecc8fcde8) )
+	ROM_LOAD32_WORD( "romh03", 0xc00002, 0x200000, CRC(e01c2a92) SHA1(f53c2db92d62f595d473b1835c46d426f0dbe6b3) )
+
+	ROM_REGION( 0x200000, "sfx", 0 ) /* Music data / QDSP samples (SFX) */
+	ROM_LOAD( "romsnd.u15a",  0x000000, 0x200000, CRC(fc89eedc) SHA1(2ce28bdb773cfa5b5660e4c0a9ef454cb658f2da) )
+
+	ROM_REGION( 0x080000, "wavetable", 0 ) /* QDSP wavetable rom */
+	ROM_LOAD( "qs1001a",  0x000000, 0x80000, CRC(d13c6407) SHA1(57b14f97c7d4f9b5d9745d3571a0b7115fbe3176) )
+ROM_END
+
 /*
 
 Mission Craft
@@ -2068,8 +2164,10 @@
 
 static READ32_HANDLER( wyvernwg_speedup_r )
 {
+	int pc = cpu_get_pc(&space->device());
+
 	vamphalf_state *state = space->machine().driver_data<vamphalf_state>();
-	if(cpu_get_pc(&space->device()) == 0x10758 )
+	if(pc == 0x10758)
 	{
 		if(irq_active(space))
 			device_spin_until_interrupt(&space->device());
@@ -2080,6 +2178,24 @@
 	return state->m_wram32[0x00b56fc/4];
 }
 
+static READ32_HANDLER( wyvernwga_speedup_r )
+{
+	int pc = cpu_get_pc(&space->device());
+
+	vamphalf_state *state = space->machine().driver_data<vamphalf_state>();
+	if(pc == 0x10758)
+	{
+		if(irq_active(space))
+			device_spin_until_interrupt(&space->device());
+		else
+			device_eat_cycles(&space->device(), 50);
+	}
+
+	return state->m_wram32[0x00b74f8/4];
+}
+
+
+
 static READ32_HANDLER( finalgdr_speedup_r )
 {
 	vamphalf_state *state = space->machine().driver_data<vamphalf_state>();
@@ -2168,6 +2284,19 @@
 	return state->m_wram[(0x00a99c / 2)+offset];
 }
 
+static READ16_HANDLER( dtfamily_speedup_r )
+{
+	vamphalf_state *state = space->machine().driver_data<vamphalf_state>();
+
+	int pc = cpu_get_pc(&space->device());
+
+	if (pc == 0x12fa6)
+		device_spin_until_interrupt(&space->device());
+
+	return state->m_wram[0xcc2a8 / 2];
+
+}
+
 static READ16_HANDLER( toyland_speedup_r )
 {
 	vamphalf_state *state = space->machine().driver_data<vamphalf_state>();
@@ -2267,6 +2396,7 @@
 {
 	vamphalf_state *state = machine.driver_data<vamphalf_state>();
 	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x00b56fc, 0x00b56ff, FUNC(wyvernwg_speedup_r) );
+	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0x00b74f8, 0x00b74fb, FUNC(wyvernwga_speedup_r) );
 
 	state->m_palshift = 0;
 	state->m_flip_bit = 1;
@@ -2318,6 +2448,16 @@
 	state->m_flip_bit = 1;
 }
 
+static DRIVER_INIT( dtfamily )
+{
+	vamphalf_state *state = machine.driver_data<vamphalf_state>();
+	machine.device("maincpu")->memory().space(AS_PROGRAM)->install_legacy_read_handler(0xcc2a8, 0xcc2a9, FUNC(dtfamily_speedup_r) );
+
+	state->m_palshift = 0;
+	state->m_flip_bit = 1;
+}
+
+
 static DRIVER_INIT( toyland )
 {
 	vamphalf_state *state = machine.driver_data<vamphalf_state>();
@@ -2376,9 +2516,11 @@
 GAME( 2000, dquizgo2, 0,        coolmini, common,   dquizgo2, ROT0,   "SemiCom",           "Date Quiz Go Go Episode 2" , 0)
 GAME( 2000, misncrft, 0,        misncrft, common,   misncrft, ROT90,  "Sun",               "Mission Craft (version 2.4)", GAME_NO_SOUND )
 GAME( 2000, mrdig,    0,        mrdig,    common,   mrdig,    ROT0,   "Sun",               "Mr. Dig", 0 )
+GAME( 2001, dtfamily, 0,        coolmini, common,   dtfamily, ROT0,   "SemiCom",           "Diet Family", 0 )
 GAME( 2001, finalgdr, 0,        finalgdr, finalgdr, finalgdr, ROT0,   "SemiCom",           "Final Godori (Korea, version 2.20.5915)", 0 )
 GAME( 2001, mrkicker, 0,        mrkicker, finalgdr, mrkicker, ROT0,   "SemiCom",           "Mr. Kicker", GAME_NOT_WORKING ) // game stops booting / working properly after you get a high score, or if you don't have a default eeprom with 'valid data.  It's never worked properly, CPU core issue?
 GAME( 2001, toyland,  0,        coolmini, common,   toyland,  ROT0,   "SemiCom",           "Toy Land Adventure", 0 )
-GAME( 2001, wyvernwg, 0,        wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings", GAME_NO_SOUND )
+GAME( 2001, wyvernwg, 0,        wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 1)", GAME_NO_SOUND )
+GAME( 2001, wyvernwga,wyvernwg, wyvernwg, common,   wyvernwg, ROT270, "SemiCom (Game Vision license)", "Wyvern Wings (set 2)", GAME_NO_SOUND )
 GAME( 2001, aoh,      0,        aoh,      aoh,      aoh,      ROT0,   "Unico",             "Age Of Heroes - Silkroad 2 (v0.63 - 2001/02/07)", 0 )
 GAME( 2001, boonggab, 0,        boonggab, boonggab, boonggab, ROT270, "Taff System",	   "Boong-Ga Boong-Ga (Spank'em!)", 0 )
diff -Nru src-old/mame/drivers/vegas.c src/mame/drivers/vegas.c
--- src-old/mame/drivers/vegas.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/vegas.c	2012-02-09 11:27:12.000000000 +0100
@@ -2220,8 +2220,8 @@
 	MCFG_MACHINE_RESET(vegas)
 	MCFG_M48T37_ADD("timekeeper")
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
-	MCFG_IDE_BUS_MASTER_SPACE("maincpu", PROGRAM)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
+	MCFG_IDE_BUS_MASTER_SPACE("ide", "maincpu", PROGRAM)
 
 	MCFG_SMC91C94_ADD("ethernet", ethernet_interrupt)
 
@@ -2311,7 +2311,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.5 11/17/1998 */
 	ROM_LOAD( "legend15.bin", 0x000000, 0x80000, CRC(a8372d70) SHA1(d8cd4fd4d7007ee38bb58b5a818d0f83043d5a48) )
 
-	DISK_REGION( "ide" )	/* Guts 1.5 1/14/1999 Game 1/14/1999 */
+	DISK_REGION( "drive_0" )	/* Guts 1.5 1/14/1999 Game 1/14/1999 */
 	DISK_IMAGE( "gauntleg", 0, SHA1(66eb70e2fba574a7abe54be8bd45310654b24b08) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2323,7 +2323,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.3 9/25/1998 */
 	ROM_LOAD( "legend12.bin", 0x000000, 0x80000, CRC(34674c5f) SHA1(92ec1779f3ab32944cbd953b6e1889503a57794b) )
 
-	DISK_REGION( "ide" )	/* Guts 1.4 10/22/1998 Main 10/23/1998 */
+	DISK_REGION( "drive_0" )	/* Guts 1.4 10/22/1998 Main 10/23/1998 */
 	DISK_IMAGE( "gauntl12", 0, SHA1(c8208e3ce3b02a271dc6b089efa98dd996b66ce0) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2335,7 +2335,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.7 12/14/1999 */
 	ROM_LOAD( "gauntdl.bin", 0x000000, 0x80000, CRC(3d631518) SHA1(d7f5a3bc109a19c9c7a711d607ff87e11868b536) )
 
-	DISK_REGION( "ide" )	/* Guts: 1.9 3/17/2000 Game 5/9/2000 */
+	DISK_REGION( "drive_0" )	/* Guts: 1.9 3/17/2000 Game 5/9/2000 */
 	DISK_IMAGE( "gauntdl", 0, SHA1(ba3af48171e727c2f7232c06dcf8411cbcf14de8) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2347,7 +2347,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.7 12/14/1999 */
 	ROM_LOAD( "gauntdl.bin", 0x000000, 0x80000, CRC(3d631518) SHA1(d7f5a3bc109a19c9c7a711d607ff87e11868b536) )
 
-	DISK_REGION( "ide" )	/* Guts: 1.9 3/17/2000 Game 3/19/2000 */
+	DISK_REGION( "drive_0" )	/* Guts: 1.9 3/17/2000 Game 3/19/2000 */
 	DISK_IMAGE( "gauntd24", 0, SHA1(3e055794d23d62680732e906cfaf9154765de698) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2359,7 +2359,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.9 3/25/1999 */
 	ROM_LOAD( "warboot.v19", 0x000000, 0x80000, CRC(b0c095cd) SHA1(d3b8cccdca83f0ecb49aa7993864cfdaa4e5c6f0) )
 
-	DISK_REGION( "ide" )	/* Guts 1.3 4/20/1999 Game 4/20/1999 */
+	DISK_REGION( "drive_0" )	/* Guts 1.3 4/20/1999 Game 4/20/1999 */
 	DISK_IMAGE( "warfa", 0, SHA1(87f8a8878cd6be716dbd6c68fb1bc7f564ede484) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2371,7 +2371,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "tenthdeg.bio", 0x000000, 0x80000, CRC(1cd2191b) SHA1(a40c48f3d6a9e2760cec809a79a35abe762da9ce) )
 
-	DISK_REGION( "ide" )	/* Guts 5/26/1998 Main 8/25/1998 */
+	DISK_REGION( "drive_0" )	/* Guts 5/26/1998 Main 8/25/1998 */
 	DISK_IMAGE( "tenthdeg", 0, SHA1(41a1a045a2d118cf6235be2cc40bf16dbb8be5d1) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2383,7 +2383,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 2.6 4/22/1999 */
 	ROM_LOAD( "rbmain.bin", 0x000000, 0x80000, CRC(060e1aa8) SHA1(2a1027d209f87249fe143500e721dfde7fb5f3bc) )
 
-	DISK_REGION( "ide" )	/* Guts 4/22/1999 Game 4/22/1999 */
+	DISK_REGION( "drive_0" )	/* Guts 4/22/1999 Game 4/22/1999 */
 	DISK_IMAGE( "roadburn", 0, SHA1(a62870cceafa6357d7d3505aca250c3f16087566) )
 ROM_END
 
@@ -2392,7 +2392,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "nbau27.100", 0x000000, 0x80000, CRC(ff5d620d) SHA1(8f07567929f40a2269a42495dfa9dd5edef688fe) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "nbashowt", 0, SHA1(f7c56bc3dcbebc434de58034986179ae01127f87) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2405,7 +2405,7 @@
 	ROM_LOAD( "u27nflnba.bin", 0x000000, 0x80000, CRC(6a9bd382) SHA1(18b942df6af86ea944c24166dbe88148334eaff9) )
 //  ROM_LOAD( "bootnflnba.bin", 0x000000, 0x80000, CRC(3def7053) SHA1(8f07567929f40a2269a42495dfa9dd5edef688fe) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "nbanfl", 0, SHA1(f60c627f85f1bf58f2ea674063736a1e516e7e9e) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* Vegas SIO boot ROM */
@@ -2417,7 +2417,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "bootu27", 0x000000, 0x80000, CRC(c44550a2) SHA1(ad30f1c3382ff2f5902a4cbacbb1f0c4e37f42f9) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "cartfury", 0, SHA1(4c5bc2803297ea9a191bbd8b002d0e46b4ae1563) )
 
 	ROM_REGION16_LE( 0x10000, "dcs", 0 )	/* ADSP-2105 data */
@@ -2429,7 +2429,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )	/* EPROM 1.02 7/9/1999 */
 	ROM_LOAD( "sf2049.u27", 0x000000, 0x80000, CRC(174ba8fe) SHA1(baba83b811eca659f00514a008a86ef0ac9680ee) )
 
-	DISK_REGION( "ide" )	/* Guts 1.03 9/3/1999 Game 9/8/1999 */
+	DISK_REGION( "drive_0" )	/* Guts 1.03 9/3/1999 Game 9/8/1999 */
 	DISK_IMAGE( "sf2049", 0, SHA1(9e0661b8566a6c78d18c59c11cd3a6628d025405) )
 ROM_END
 
@@ -2438,7 +2438,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "sf2049se.u27", 0x000000, 0x80000, CRC(da4ecd9c) SHA1(2574ff3d608ebcc59a63cf6dea13ee7650ae8921) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "sf2049se", 0, SHA1(7b27a8ce2a953050ce267548bb7160b41f3e8054) )
 ROM_END
 
@@ -2447,7 +2447,7 @@
 	ROM_REGION32_LE( 0x80000, "user1", 0 )
 	ROM_LOAD( "sf2049te.u27", 0x000000, 0x80000, CRC(cc7c8601) SHA1(3f37dbd1b32b3ac5caa300725468e8e426f0fb83) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "sf2049te", 0, SHA1(625aa36436587b7bec3e7db1d19793b760e2ea51) )
 ROM_END
 
diff -Nru src-old/mame/drivers/viper.c src/mame/drivers/viper.c
--- src-old/mame/drivers/viper.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/viper.c	2012-02-18 03:48:45.000000000 +0100
@@ -2004,7 +2004,7 @@
 	MCFG_PCI_BUS_DEVICE(0, "mpc8240", mpc8240_pci_r, mpc8240_pci_w)
 	MCFG_PCI_BUS_DEVICE(12, "voodoo", voodoo3_pci_r, voodoo3_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 	MCFG_3DFX_VOODOO_3_ADD("voodoo", STD_VOODOO_3_CLOCK, 8, "screen")
 	MCFG_3DFX_VOODOO_CPU("maincpu")
 	MCFG_3DFX_VOODOO_VBLANK(voodoo_vblank)
@@ -2071,7 +2071,7 @@
 
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "ppp2nd", 0, SHA1(b8b90483d515c83eac05ffa617af19612ea990b0))
 ROM_END
 
@@ -2082,7 +2082,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a45jaa_nvram.u39", 0x00000, 0x2000, CRC(c24e29fc) SHA1(efb6ecaf25cbdf9d8dfcafa85e38a195fa5ff6c4))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a45a02", 0, SHA1(9af2481f53de705ae48fad08d8dd26553667c2d0) )
 ROM_END
 
@@ -2092,7 +2092,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "922d02", 0, SHA1(01f35e324c9e8567da0f51b3e68fff1562c32116) )
 ROM_END
 
@@ -2102,7 +2102,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "922b02", 0, SHA1(4d288b5dcfab3678af662783e7083a358eee99ce) )
 ROM_END
 
@@ -2113,7 +2113,7 @@
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(d0604e84) SHA1(18d1183f1331af3e655a56692eb7ab877b4bc239)) //old dump, probably has non-default settings.
 	ROM_LOAD("941jab_nvram.u39", 0x00000, 0x2000, CRC(6c4a852f) SHA1(2753dda42cdd81af22dc6780678f1ddeb3c62013))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "941b02", 0,  SHA1(943bc9b1ea7273a8382b94c8a75010dfe296df14) )
 ROM_END
 
@@ -2123,7 +2123,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("941eaa_nvram.u39", 0x00000, 0x2000, CRC(5ee7004d) SHA1(92e0ce01049308f459985d466fbfcfac82f34a47))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "941a02", 0,  NO_DUMP )
 ROM_END
 
@@ -2133,7 +2133,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b41ebc_nvram.u39", 0x00000, 0x2000, CRC(55d1681d) SHA1(26868cf0d14f23f06b81f2df0b4186924439bb43))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "b41c02", 0, SHA1(fb6b0b43a6f818041d644bcd711f6a727348d3aa) )
 ROM_END
 
@@ -2144,7 +2144,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b33uaa_nvram.u39", 0x00000, 0x1ff8, BAD_DUMP CRC(0f0ba988) SHA1(5618c03b21fc2ba14b2e159cee3aab7f53c2c34d)) //data looks plain bad (compared to the other games)
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "b33a02", 0, SHA1(819d8fac5d2411542c1b989105cffe38a5545fc2) )
 ROM_END
 
@@ -2154,7 +2154,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a29aaa_nvram.u39", 0x000000, 0x2000, CRC(14b9fe68) SHA1(3c59e6df1bb46bc1835c13fd182b1bb092c08759)) //supposed to be aab version?
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a29b02", 0, SHA1(f0c04310caf2cca804fde20805eb30a44c5a6796) ) //missing bootloader
 ROM_END
 
@@ -2164,7 +2164,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a29jaa_nvram.u39", 0x000000, 0x2000, CRC(2f7cdf27) SHA1(0b69d8728be12909e235268268a312982f81d46a))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a29a02", 0, SHA1(00afad399737652b3e17257c70a19f62e37f3c97) )
 ROM_END
 
@@ -2174,7 +2174,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00uad_nvram.u39", 0x000000, 0x2000, CRC(cca056ca) SHA1(de1a00d84c1311d48bbe6d24f5b36e22ecf5e85a))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a00uad02", 0, SHA1(6acb8dc41920e7025b87034a3a62b185ef0109d9) )
 ROM_END
 
@@ -2184,7 +2184,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00uac_nvram.u39", 0x000000, 0x2000,  NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a00uac02", 0, SHA1(b268789416dbf8886118a634b911f0ee254970de) )
 ROM_END
 
@@ -2194,7 +2194,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00kac_nvram.u39", 0x000000, 0x2000,  CRC(8ddc921c) SHA1(901538da237679fc74966a301278b36d1335671f) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a00kac02", 0, SHA1(b268789416dbf8886118a634b911f0ee254970de) )
 ROM_END
 
@@ -2204,7 +2204,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00eaa_nvram.u39", 0x000000, 0x2000,  CRC(4f3497b6) SHA1(3045c54f98dff92cdf3a1fc0cd4c76ba82d632d7) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a00eaa02", 0, SHA1(81565a2dce2e2b0a7927078a784354948af1f87c) )
 ROM_END
 
@@ -2214,7 +2214,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a00jaa_nvram.u39", 0x000000, 0x2000, CRC(9ecf70dc) SHA1(4769a99b0cc28563e219860b8d480f32d1e21f60))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a00jac02", 0, SHA1(d962d3a8ea84c380767d0fe336296911c289c224) )
 ROM_END
 
@@ -2224,7 +2224,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "b11a02", 0, SHA1(57665664321b78c1913d01f0d2c0b8d3efd42e04) )
 ROM_END
 
@@ -2234,7 +2234,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c00jab", 0, BAD_DUMP SHA1(3763aaded9b45388a664edd84a3f7f8ff4101be4) )
 ROM_END
 
@@ -2244,7 +2244,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a13uaa_nvram.u39", 0x000000, 0x2000, CRC(7b0e1ac8) SHA1(1ea549964539e27f87370e9986bfa44eeed037cd))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a13c02", 0, SHA1(d740784fa51a3f43695ea95e23f92ef05f43284a) )
 ROM_END
 
@@ -2256,7 +2256,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("nvram.u39", 0x000000, 0x2000, CRC(2f325c55) SHA1(0bc44f40f981a815c8ce64eae95ae55db510c565))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a13b02", 0, SHA1(c25a61b76d365794c2da4a9e7de88a5519e944ec) )
 ROM_END
 
@@ -2267,7 +2267,7 @@
 	ROM_LOAD("a41ebb_nvram.u39", 0x00000, 0x2000, CRC(22f59ac0) SHA1(e14ea2ba95b72edf0a3331ab82c192760bfdbce3))
 //  a41eba_nvram == a41ebb_nvram
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a41b02", 0, SHA1(0426f4bb9001cf457f44e2c22e3d7575b8049aa3) )
 ROM_END
 
@@ -2277,7 +2277,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a41aaa_nvram.u39", 0x00000, 0x2000, CRC(d5de9b8e) SHA1(768bcd46a6ad20948f60f5e0ecd2f7b9c2901061))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a41a02", 0, SHA1(bbb71e23bddfa07dfa30b6565a35befd82b055b8) )
 ROM_END
 
@@ -2288,7 +2288,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("941eaa_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a41c02", 0, SHA1(ab3020e8709768c0fd2467573e92b679a05944e5) )
 ROM_END
 
@@ -2298,7 +2298,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a30eab_nvram.u39", 0x00000, 0x2000, CRC(c123342c) SHA1(55416767608fe0311a362854a16b214b04435a31))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a30b02", 0, SHA1(d2be83b7323c365ba445de7697c3fb8eb83d0212) )
 ROM_END
 
@@ -2308,7 +2308,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("a30jac_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "a30c02", 0, SHA1(533b5669b00884a800df9ba29651777a76559862) )
 ROM_END
 
@@ -2317,9 +2317,9 @@
 	VIPER_BIOS
 
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
-	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(4f8b5858) SHA1(68066241c6f9db7f45e55b3c5da101987f4ce53c))
+	ROM_LOAD("wcombat_nvram.u39", 0x00000, 0x2000, CRC(4f8b5858) SHA1(68066241c6f9db7f45e55b3c5da101987f4ce53c))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c22d02", 0, BAD_DUMP SHA1(85d2a8b5ec4cfd932190486cad991f0c180ca6b3) )
 ROM_END
 
@@ -2327,9 +2327,9 @@
 	VIPER_BIOS
 
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
-	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(ebd4d645) SHA1(2fa7e2c6b113214f3eb1900c8ceef4d5fcf0bb76))
+	ROM_LOAD("wcombatk_nvram.u39", 0x00000, 0x2000, CRC(ebd4d645) SHA1(2fa7e2c6b113214f3eb1900c8ceef4d5fcf0bb76))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c22c02", 0, BAD_DUMP SHA1(8bd1dfbf926ad5b28fa7dafd7e31c475325ec569) )
 ROM_END
 
@@ -2337,9 +2337,9 @@
 	VIPER_BIOS
 
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
-	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(bd8a6640) SHA1(2d409197ef3fb07d984d27fa943f29c7a711d715))
+	ROM_LOAD("wcombatj_nvram.u39", 0x00000, 0x2000, CRC(bd8a6640) SHA1(2d409197ef3fb07d984d27fa943f29c7a711d715))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c22a02", 0, BAD_DUMP SHA1(b607fb2ddfd0bd552b7a736cea4ac1aa3ea021bd) )
 ROM_END
 
@@ -2349,7 +2349,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("b4xjab_nvram.u39", 0x00000, 0x2000, CRC(33708a93) SHA1(715968e3c9c15edf628fa6ac655dc0864e336c6c))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "b4xb02", 0, SHA1(d8d54f3f16b762bf0187fe29b2f8696015c0a940) )
 ROM_END
 
@@ -2408,7 +2408,7 @@
 	ROM_LOAD("nvram.u39", 0x00000, 0x2000, CRC(9fb551a5) SHA1(a33d185e186d404c3bf62277d7e34e5ad0000b09)) //likely non-default settings
 	ROM_LOAD("c09jad_nvram.u39", 0x00000, 0x2000, CRC(33e960b7) SHA1(a9a249e68c89b18d4685f1859fe35dc21df18e14))
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c09d04", 0, SHA1(7395b7a33e953f65827aea44461e49f8388464fb) )
 ROM_END
 
@@ -2419,7 +2419,7 @@
 	ROM_REGION(0x2000, "m48t58", ROMREGION_ERASE00)		/* M48T58 Timekeeper NVRAM */
 	ROM_LOAD("c09jac_nvram.u39", 0x00000, 0x2000, NO_DUMP )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "c09c04", 0, SHA1(bf5f7447d74399d34edd4eb6dfcca7f6fc2154f2) )
 ROM_END
 
diff -Nru src-old/mame/drivers/wecleman.c src/mame/drivers/wecleman.c
--- src-old/mame/drivers/wecleman.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/wecleman.c	2012-02-11 11:01:01.000000000 +0100
@@ -1084,7 +1084,7 @@
 
 static INTERRUPT_GEN( hotchase_sound_timer )
 {
-	generic_pulse_irq_line(device, M6809_FIRQ_LINE);
+	generic_pulse_irq_line(device, M6809_FIRQ_LINE, 1);
 }
 
 static const k051316_interface hotchase_k051316_intf_0 =
diff -Nru src-old/mame/drivers/white_mod.c src/mame/drivers/white_mod.c
--- src-old/mame/drivers/white_mod.c	2011-12-23 17:41:40.000000000 +0100
+++ src/mame/drivers/white_mod.c	2012-02-18 03:48:45.000000000 +0100
@@ -3140,12 +3140,12 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
+	ROM_LOAD("sopsnd3_400.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnda.u17", 0x000000, 0x100000, CRC(21e0cfd2) SHA1(d2ff1242f1f4a206e0b2884c079ef2be5df143ac))
-	ROM_LOAD("sopsnda.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
-	ROM_LOAD("sopsnda.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
-	ROM_LOAD("sopsnda.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
+	ROM_LOAD("sopsnda_400.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
+	ROM_LOAD("sopsnda_400.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
+	ROM_LOAD("sopsnda_400.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
 ROM_END
 
 ROM_START(sopranos_300)
@@ -3163,12 +3163,12 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
+	ROM_LOAD("sopsnd3_300.u7",0x0000,0x10000,CRC(b22ba5aa) SHA1(8f69932e3b115ae7a6bcb9a15a8b5bf6579e94e0))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnda.u17", 0x000000, 0x100000, CRC(21e0cfd2) SHA1(d2ff1242f1f4a206e0b2884c079ef2be5df143ac))
-	ROM_LOAD("sopsnda.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
-	ROM_LOAD("sopsnda.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
-	ROM_LOAD("sopsnda.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
+	ROM_LOAD("sopsnda_300.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
+	ROM_LOAD("sopsnda_300.u36", 0x200000, 0x100000, CRC(db33b45c) SHA1(d3285008a3c770371389be470c1ec5ca49c1e568))
+	ROM_LOAD("sopsnda_300.u37", 0x300000, 0x100000, CRC(06a2a6e1) SHA1(fdbe622223724ac2b4c5183c43d3e635654864bf))
 ROM_END
 
 ROM_START(sopranos_204)
@@ -3186,7 +3186,7 @@
 	ROM_LOAD("biosv8.u8", 0x400000, 0x20000, CRC(c81b5532) SHA1(7bd630179910423a01394f82ad7ff2008c02f7ff))
 	ROM_RELOAD(0x0,0x20000)
 	ROM_REGION(0x10000, "sound1", 0)
-	ROM_LOAD("sopsnd3.u7",0x0000,0x10000,CRC(4f6748b5) SHA1(63e953a1455dee2a44484fef951fa34cb2e55d7b))
+	ROM_LOAD("sopsnd3_204.u7",0x0000,0x10000,CRC(4f6748b5) SHA1(63e953a1455dee2a44484fef951fa34cb2e55d7b))
 	ROM_REGION(0x400000, "sound2", 0)
 	ROM_LOAD("sopsnd1.u17", 0x000000, 0x100000, CRC(1ecc5ecc) SHA1(42897387b90df8da8ae556ccc46e281ca461c063))
 	ROM_LOAD("sopsnd1.u21", 0x100000, 0x100000, CRC(257ab09d) SHA1(1d18e279139b1658ce02160d9a37b4bf043393f0))
diff -Nru src-old/mame/drivers/whitestar.c src/mame/drivers/whitestar.c
--- src-old/mame/drivers/whitestar.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/whitestar.c	2012-02-19 01:27:36.000000000 +0100
@@ -2207,8 +2207,8 @@
 	ROM_LOAD("spcjam.u7", 0x0000, 0x10000, CRC(c693d853) SHA1(3e81e60967dff496c681962f3ff8c7c1fbb7746a))
 	ROM_REGION(0x1000000, "bsmt", 0 )
 	ROM_LOAD("spcjam.u17", 0x000000, 0x80000, CRC(ccefe457) SHA1(4186dee689fbfc08e5070ccfe8d4be95220cd87b))
-	ROM_LOAD("spcjam.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
-	ROM_LOAD("spcjam.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
+	ROM_LOAD("spcjamg.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
+	ROM_LOAD("spcjamg.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
 ROM_END
 ROM_START(spacejmf)
 	ROM_REGION(0x80000, "user1", 0)
@@ -2222,8 +2222,8 @@
 	ROM_LOAD("spcjam.u7", 0x0000, 0x10000, CRC(c693d853) SHA1(3e81e60967dff496c681962f3ff8c7c1fbb7746a))
 	ROM_REGION(0x1000000, "bsmt", 0 )
 	ROM_LOAD("spcjam.u17", 0x000000, 0x80000, CRC(ccefe457) SHA1(4186dee689fbfc08e5070ccfe8d4be95220cd87b))
-	ROM_LOAD("spcjam.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
-	ROM_LOAD("spcjam.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
+	ROM_LOAD("spcjamf.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
+	ROM_LOAD("spcjamf.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
 ROM_END
 ROM_START(spacejmi)
 	ROM_REGION(0x80000, "user1", 0)
@@ -2237,8 +2237,8 @@
 	ROM_LOAD("spcjam.u7", 0x0000, 0x10000, CRC(c693d853) SHA1(3e81e60967dff496c681962f3ff8c7c1fbb7746a))
 	ROM_REGION(0x1000000, "bsmt", 0 )
 	ROM_LOAD("spcjam.u17", 0x000000, 0x80000, CRC(ccefe457) SHA1(4186dee689fbfc08e5070ccfe8d4be95220cd87b))
-	ROM_LOAD("spcjam.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
-	ROM_LOAD("spcjam.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
+	ROM_LOAD("spcjami.u21", 0x080000, 0x80000, CRC(9e7fe0a6) SHA1(187e5893f84d0c0fd70d15c3978fc3fc51e12a51))
+	ROM_LOAD("spcjami.u36", 0x100000, 0x80000, CRC(7d11e1eb) SHA1(96d4635b1edf8a22947a5cd529ce9025cf7d0c71))
 ROM_END
 
 /*-------------------------------------------------------------------
@@ -2975,8 +2975,8 @@
 	ROM_REGION(0x010000, "soundcpu", 0)
 	ROM_LOAD("ctcu7d.bin", 0x0000, 0x10000, CRC(92bfe454) SHA1(8182f7ac84addf8bdb7976a85c801edf3424d16b))
 	ROM_REGION(0x1000000, "bsmt", 0)
-	ROM_LOAD("ctcu17.bin", 0x000000, 0x80000, CRC(7ee35d17) SHA1(f2c9b70285926fc782a2e1289532395cd8dbf999))
-	ROM_LOAD("ctcu21.bin", 0x080000, 0x80000, CRC(84dd40ac) SHA1(c9327b95f1730a3aa741540c28078f214af214b8))
+	ROM_LOAD("ctcdxu17.bin", 0x000000, 0x80000, CRC(7ee35d17) SHA1(f2c9b70285926fc782a2e1289532395cd8dbf999))
+	ROM_LOAD("ctcdxu21.bin", 0x080000, 0x80000, CRC(84dd40ac) SHA1(c9327b95f1730a3aa741540c28078f214af214b8))
 ROM_END
 
 /*-------------------------------------------------------------------
diff -Nru src-old/mame/drivers/williams.c src/mame/drivers/williams.c
--- src-old/mame/drivers/williams.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/drivers/williams.c	2012-02-19 01:27:36.000000000 +0100
@@ -2397,12 +2397,12 @@
 
 ROM_START( blastero )
 	ROM_REGION( 0x54000, "maincpu", 0 )
-	ROM_LOAD( "16.ic39",     0x0d000, 0x1000, CRC(2db032d2) SHA1(287769361639695b1c1ceae0fe6899d83b4575d5) )
-	ROM_LOAD( "13.ic27",     0x0e000, 0x2000, CRC(c99213c7) SHA1(d1c1549c053de3d862d8ef3ebca02811ed289464) )
+	ROM_LOAD( "o_16.ic39",   0x0d000, 0x1000, CRC(2db032d2) SHA1(287769361639695b1c1ceae0fe6899d83b4575d5) )
+	ROM_LOAD( "o_13.ic27",   0x0e000, 0x2000, CRC(c99213c7) SHA1(d1c1549c053de3d862d8ef3ebca02811ed289464) )
 
-	ROM_LOAD( "11.ic25",     0x10000, 0x2000, CRC(bc2d7eda) SHA1(831e9ecb75b143f9770eab1939136092a29e64f7) )
-	ROM_LOAD( "12.ic26",     0x12000, 0x2000, CRC(8a215017) SHA1(ee9233134907c03f7a1221d9daa84fe047c2db94) )
-	ROM_LOAD( "17.ic41",     0x14000, 0x1000, CRC(b308f0e5) SHA1(262e25be40dff66e65a0fe34c9d013a750b90876) )
+	ROM_LOAD( "o_11.ic25",   0x10000, 0x2000, CRC(bc2d7eda) SHA1(831e9ecb75b143f9770eab1939136092a29e64f7) )
+	ROM_LOAD( "o_12.ic26",   0x12000, 0x2000, CRC(8a215017) SHA1(ee9233134907c03f7a1221d9daa84fe047c2db94) )
+	ROM_LOAD( "o_17.ic41",   0x14000, 0x1000, CRC(b308f0e5) SHA1(262e25be40dff66e65a0fe34c9d013a750b90876) )
 
 	ROM_LOAD( "15.ic38",     0x18000, 0x4000, CRC(1ad146a4) SHA1(5ab3d9618023b59bc329a9eeef986901867a639b) )
 	ROM_LOAD( "8.ic20",      0x1c000, 0x4000, CRC(f110bbb0) SHA1(314dea232a3706509399348c7415f933c64cea1b) )
@@ -2411,11 +2411,11 @@
 	ROM_LOAD( "6.ic13",      0x28000, 0x4000, CRC(47fc007e) SHA1(3a80b9b7ae460e9732f7c1cdd465a5b06ded970f) )
 	ROM_LOAD( "5.ic11",      0x2c000, 0x4000, CRC(15c1b94d) SHA1(5d97628541eb8933870c3ffd3646b7aaf8af6af5) )
 	ROM_LOAD( "14.ic35",     0x30000, 0x4000, CRC(aea6b846) SHA1(04cb4b5eb000471a0cec377a5236ac8c83529528) )
-	ROM_LOAD( "7.ic15",      0x34000, 0x4000, CRC(a1c4db77) SHA1(7a878d44b6ca7444ecbb6c8f75e5e91de149daf3) )
+	ROM_LOAD( "o_7.ic15",    0x34000, 0x4000, CRC(a1c4db77) SHA1(7a878d44b6ca7444ecbb6c8f75e5e91de149daf3) )
 	ROM_LOAD( "1.ic1",       0x38000, 0x4000, CRC(8d0ea9e7) SHA1(34f8e2e99748bed29285f7e4929bb920960ab03e) )
 	ROM_LOAD( "2.ic3",       0x3c000, 0x4000, CRC(03c4012c) SHA1(53f0adc91e5f1ac58b08b3a6d2de8de5a40bebab) )
-	ROM_LOAD( "4.ic7",       0x40000, 0x4000, CRC(39d2a32c) SHA1(33707877e841ef86a11b47ffabddce7f3d2a7030) )
-	ROM_LOAD( "3.ic6",       0x44000, 0x4000, CRC(054c9f1c) SHA1(c21e3493f1ae506ab9fd28ed9ecc67d3305e9d7a) )
+	ROM_LOAD( "o_4.ic7",     0x40000, 0x4000, CRC(39d2a32c) SHA1(33707877e841ef86a11b47ffabddce7f3d2a7030) )
+	ROM_LOAD( "o_3.ic6",     0x44000, 0x4000, CRC(054c9f1c) SHA1(c21e3493f1ae506ab9fd28ed9ecc67d3305e9d7a) )
 
 	ROM_REGION( 0x10000, "soundcpu", 0 )
 	ROM_LOAD( "18.sb13",      0xf000, 0x1000, CRC(c33a3145) SHA1(6ffe2da7b70c0b576fbc1790a33eecdbb9ee3d02) )
diff -Nru src-old/mame/drivers/xtom3d.c src/mame/drivers/xtom3d.c
--- src-old/mame/drivers/xtom3d.c	2012-01-24 15:16:25.000000000 +0100
+++ src/mame/drivers/xtom3d.c	2012-02-09 11:27:12.000000000 +0100
@@ -707,7 +707,7 @@
 	MCFG_PCI_BUS_DEVICE(0, NULL, intel82439tx_pci_r, intel82439tx_pci_w)
 	MCFG_PCI_BUS_DEVICE(7, NULL, intel82371ab_pci_r, intel82371ab_pci_w)
 
-	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", ide_interrupt, ide_devices, "hdd", NULL)
 
 	/* video hardware */
 	MCFG_FRAGMENT_ADD( pcvideo_vga )
diff -Nru src-old/mame/drivers/zn.c src/mame/drivers/zn.c
--- src-old/mame/drivers/zn.c	2012-01-20 02:16:08.000000000 +0100
+++ src/mame/drivers/zn.c	2012-02-09 11:27:12.000000000 +0100
@@ -1476,7 +1476,7 @@
 static MACHINE_CONFIG_DERIVED( coh1000w, zn1_2mb_vram )
 	MCFG_MACHINE_RESET( coh1000w )
 
-	MCFG_IDE_CONTROLLER_ADD("ide", atpsx_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", atpsx_interrupt, ide_devices, "hdd", NULL)
 	MCFG_PSX_DMA_CHANNEL_READ( "maincpu", 5, psx_dma_read_delegate( FUNC( atpsx_dma_read ), (zn_state *) owner ) )
 	MCFG_PSX_DMA_CHANNEL_WRITE( "maincpu", 5, psx_dma_write_delegate( FUNC( atpsx_dma_write ), (zn_state *) owner ) )
 MACHINE_CONFIG_END
@@ -2160,7 +2160,7 @@
 
 	MCFG_MACHINE_RESET( coh1000a )
 
-	MCFG_IDE_CONTROLLER_ADD("ide", jdredd_ide_interrupt)
+	MCFG_IDE_CONTROLLER_ADD("ide", jdredd_ide_interrupt, ide_devices, "hdd", NULL)
 MACHINE_CONFIG_END
 
 /*
@@ -4478,7 +4478,7 @@
 
 	ROM_REGION32_LE( 0x0400000, "user3", ROMREGION_ERASE00 )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE("bam2", 0, SHA1(634d9a745a82c567fc4d7ce48e3570d88326c5f9) )
 ROM_END
 
@@ -4502,7 +4502,7 @@
 	ROM_LOAD16_BYTE( "pr2_036.u17",  0x100001, 0x080000, CRC(3681516c) SHA1(714f73ea4ac190c36a6eb2308616a4aecabc4e69) )
 	ROM_LOAD16_BYTE( "pr2_036.u15",  0x100000, 0x080000, CRC(4b24bd54) SHA1(7f27cd524d10e5869aab6d4dc6a4217d049c475d) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "primrag2", 0, SHA1(bc615068ddf4fd967f770ee01c02f285c052c4c5) )
 ROM_END
 
@@ -4554,7 +4554,7 @@
 	ROM_LOAD16_BYTE( "j-dread.u36",  0x000001, 0x020000, CRC(37addbf9) SHA1(a4061a1ba9e230f080f0bfea69bf77efe9264a92) )
 	ROM_LOAD16_BYTE( "j-dread.u35",  0x000000, 0x020000, CRC(c1e17191) SHA1(82901439b1a51b9aadb4df4b9d944f26697a1460) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "jdreddc", 0, SHA1(eee205f83e5f590f8baf36452c873d7063156bd0) )
 ROM_END
 
@@ -4565,7 +4565,7 @@
 	ROM_LOAD16_BYTE( "j-dread.u36",  0x000001, 0x020000, CRC(37addbf9) SHA1(a4061a1ba9e230f080f0bfea69bf77efe9264a92) )
 	ROM_LOAD16_BYTE( "j-dread.u35",  0x000000, 0x020000, CRC(c1e17191) SHA1(82901439b1a51b9aadb4df4b9d944f26697a1460) )
 
-	DISK_REGION( "ide" )
+	DISK_REGION( "drive_0" )
 	DISK_IMAGE( "jdreddb", 0, SHA1(20f696fa6e1fbf97793bac2a794631c5dd4fb39a) )
 ROM_END
 
diff -Nru src-old/mame/includes/astrof.h src/mame/includes/astrof.h
--- src-old/mame/includes/astrof.h	2011-04-27 06:11:18.000000000 +0200
+++ src/mame/includes/astrof.h	2012-02-19 02:53:16.000000000 +0100
@@ -4,6 +4,8 @@
 
 ****************************************************************************/
 
+#include "sound/samples.h"
+
 class astrof_state : public driver_device
 {
 public:
@@ -33,7 +35,7 @@
 
 	/* devices */
 	device_t *m_maincpu;
-	device_t *m_samples;	// astrof & abattle
+	samples_device *m_samples;	// astrof & abattle
 	device_t *m_sn;	// tomahawk
 };
 
diff -Nru src-old/mame/includes/circus.h src/mame/includes/circus.h
--- src-old/mame/includes/circus.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/circus.h	2012-02-19 02:53:16.000000000 +0100
@@ -17,7 +17,7 @@
 
 	/* devices */
 	device_t *m_maincpu;
-	device_t *m_samples;
+	samples_device *m_samples;
 	device_t *m_discrete;
 
 	/* game id */
diff -Nru src-old/mame/includes/cosmic.h src/mame/includes/cosmic.h
--- src-old/mame/includes/cosmic.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/cosmic.h	2012-02-19 02:53:16.000000000 +0100
@@ -4,6 +4,8 @@
 
 *************************************************************************/
 
+#include "sound/samples.h"
+
 #define COSMICG_MASTER_CLOCK     XTAL_9_828MHz
 #define Z80_MASTER_CLOCK         XTAL_10_816MHz
 
@@ -36,7 +38,7 @@
 	UINT32         m_pixel_clock;
 
 	/* devices */
-	device_t *m_samples;
+	samples_device *m_samples;
 	device_t *m_dac;
 };
 
diff -Nru src-old/mame/includes/gotya.h src/mame/includes/gotya.h
--- src-old/mame/includes/gotya.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/gotya.h	2012-02-19 02:53:16.000000000 +0100
@@ -1,3 +1,4 @@
+#include "sound/samples.h"
 
 class gotya_state : public driver_device
 {
@@ -20,7 +21,7 @@
 	int      m_theme_playing;
 
 	/* devices */
-	device_t *m_samples;
+	samples_device *m_samples;
 };
 
 
diff -Nru src-old/mame/includes/harddriv.h src/mame/includes/harddriv.h
--- src-old/mame/includes/harddriv.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/harddriv.h	2012-02-13 19:48:41.000000000 +0100
@@ -53,7 +53,6 @@
 	UINT32 *				m_adsp_pgm_memory;
 
 	UINT16 *				m_gsp_protection;
-	UINT16 *				m_stmsp_sync[3];
 
 	UINT16 *				m_gsp_speedup_addr[2];
 	offs_t					m_gsp_speedup_pc;
@@ -215,9 +214,6 @@
 
 WRITE16_HANDLER( hdgsp_protection_w );
 
-WRITE16_HANDLER( stmsp_sync0_w );
-WRITE16_HANDLER( stmsp_sync1_w );
-WRITE16_HANDLER( stmsp_sync2_w );
 
 /* ADSP board */
 READ16_HANDLER( hd68k_adsp_program_r );
@@ -290,7 +286,6 @@
 /* MSP optimizations */
 READ16_HANDLER( hdmsp_speedup_r );
 WRITE16_HANDLER( hdmsp_speedup_w );
-READ16_HANDLER( stmsp_speedup_r );
 
 /* ADSP optimizations */
 READ16_HANDLER( hdadsp_speedup_r );
diff -Nru src-old/mame/includes/m10.h src/mame/includes/m10.h
--- src-old/mame/includes/m10.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/m10.h	2012-02-19 02:53:16.000000000 +0100
@@ -4,6 +4,7 @@
 
 ****************************************************************************/
 
+#include "sound/samples.h"
 
 #define IREMM10_MASTER_CLOCK		(12500000)
 
@@ -59,7 +60,7 @@
 	device_t *m_maincpu;
 	device_t *m_ic8j1;
 	device_t *m_ic8j2;
-	device_t *m_samples;
+	samples_device *m_samples;
 };
 
 
diff -Nru src-old/mame/includes/mw8080bw.h src/mame/includes/mw8080bw.h
--- src-old/mame/includes/mw8080bw.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/mw8080bw.h	2012-02-19 02:53:16.000000000 +0100
@@ -68,9 +68,9 @@
 	/* devices */
 	device_t *m_maincpu;
 	device_t *m_mb14241;
-	device_t *m_samples;
-	device_t *m_samples1;
-	device_t *m_samples2;
+	samples_device *m_samples;
+	samples_device *m_samples1;
+	samples_device *m_samples2;
 	device_t *m_sn1;
 	device_t *m_sn2;
 	device_t *m_sn;
diff -Nru src-old/mame/includes/n64.h src/mame/includes/n64.h
--- src-old/mame/includes/n64.h	2012-01-15 02:21:06.000000000 +0100
+++ src/mame/includes/n64.h	2012-02-19 01:44:19.000000000 +0100
@@ -2,22 +2,22 @@
 #define _INCLUDES_N64_H_
 
 #include "cpu/rsp/rsp.h"
-#include "video/n64.h"
 #include "sound/dmadac.h"
-#include "includes/n64.h"
 
 /*----------- forward decls -----------*/
 
 /*----------- driver state -----------*/
 
-class _n64_state : public driver_device
+class n64_rdp;
+
+class n64_state : public driver_device
 {
 public:
-	_n64_state(const machine_config &mconfig, device_type type, const char *tag)
+	n64_state(const machine_config &mconfig, device_type type, const char *tag)
 		: driver_device(mconfig, type, tag) { }
 
 	/* video-related */
-	N64::RDP::Processor m_rdp;
+	n64_rdp *m_rdp;
 };
 
 /*----------- devices -----------*/
@@ -27,6 +27,13 @@
 
 #define AUDIO_DMA_DEPTH     2
 
+struct n64_savable_data_t
+{
+	UINT8 sram[0x20000];
+	UINT8 eeprom[2048];
+	UINT8 mempak[2][0x8000];
+};
+
 class n64_periphs : public device_t
 {
 private:
@@ -58,6 +65,8 @@
 	DECLARE_WRITE32_MEMBER( ri_reg_w );
 	DECLARE_READ32_MEMBER( si_reg_r );
 	DECLARE_WRITE32_MEMBER( si_reg_w );
+	DECLARE_READ32_MEMBER( dd_reg_r );
+	DECLARE_WRITE32_MEMBER( dd_reg_w );
 	DECLARE_READ32_MEMBER( pif_ram_r );
 	DECLARE_WRITE32_MEMBER( pif_ram_w );
 
@@ -66,9 +75,12 @@
 
 	void sp_set_status(UINT32 status);
 	void signal_rcp_interrupt(int interrupt);
+	void check_interrupts();
 
 	void ai_timer_tick();
 	void pi_dma_tick();
+	void vi_scanline_tick();
+	void reset_tick();
 
 	// Video Interface (VI) registers
 	UINT32 vi_width;
@@ -86,6 +98,19 @@
 	UINT32 vi_intr;
 	UINT32 vi_vburst;
 
+	/* nvram-specific for MESS */
+	device_t *m_nvram_image;
+
+	n64_savable_data_t m_save_data;
+
+	UINT32 cart_length;
+
+	bool dd_present;
+
+	void poll_reset_button(bool button);
+
+	UINT32 dp_clock;
+
 protected:
     // device-level overrides
     virtual void device_start();
@@ -98,8 +123,14 @@
 
 	void clear_rcp_interrupt(int interrupt);
 
+	bool reset_held;
+	emu_timer *reset_timer;
+
 	UINT8 is64_buffer[0x10000];
 
+	// Video interface (VI) registers and functions
+	emu_timer *vi_scanline_timer;
+
 	// Audio Interface (AI) registers and functions
 	void ai_dma();
 	AUDIO_DMA *ai_fifo_get_top();
@@ -140,7 +171,19 @@
 	int sp_dma_count;
 	int sp_dma_skip;
 	UINT32 sp_semaphore;
-	UINT32 dp_clock;
+
+	// Disk Drive (DD) registers and functions
+	UINT32 dd_buffer[256];
+	UINT32 dd_sector_data[32]; // ?
+	UINT32 dd_ram_seq_data[32]; // ?
+	UINT32 dd_data_reg;
+	UINT32 dd_status_reg;
+	UINT32 dd_track_reg;
+	UINT32 dd_buf_status_reg;
+	UINT32 dd_sector_err_reg;
+	UINT32 dd_seq_status_reg;
+	UINT32 dd_seq_ctrl_reg;
+	UINT8 dd_int;
 
 	// Peripheral Interface (PI) registers and functions
 	void pi_dma();
@@ -165,7 +208,7 @@
 	void pif_dma(int direction);
 	void handle_pif();
 	int pif_channel_handle_command(int channel, int slength, UINT8 *sdata, int rlength, UINT8 *rdata);
-	UINT8 calc_mempack_crc(UINT8 *buffer, int length);
+	UINT8 calc_mempak_crc(UINT8 *buffer, int length);
 	UINT8 pif_ram[0x40];
 	UINT8 pif_cmd[0x40];
 	UINT32 si_dram_addr;
@@ -173,10 +216,10 @@
 	UINT32 si_pif_addr_rd64b;
 	UINT32 si_pif_addr_wr64b;
 	UINT32 si_status;
-	UINT8 eeprom[512];
-	UINT8 mempack[0x8000];
 	UINT32 cic_status;
 
+	n64_savable_data_t savable_data;
+
 	// Video Interface (VI) functions
 	void vi_recalculate_resolution();
 };
@@ -224,6 +267,7 @@
 
 extern const rsp_config n64_rsp_config;
 
+extern UINT32 *n64_sram;
 extern UINT32 *rdram;
 extern UINT32 *rsp_imem;
 extern UINT32 *rsp_dmem;
diff -Nru src-old/mame/includes/rallyx.h src/mame/includes/rallyx.h
--- src-old/mame/includes/rallyx.h	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/includes/rallyx.h	2012-02-19 02:53:16.000000000 +0100
@@ -1,3 +1,5 @@
+#include "sound/samples.h"
+
 struct jungler_star
 {
 	int x, y, color;
@@ -33,7 +35,7 @@
 
 	/* devices */
 	cpu_device *m_maincpu;
-	device_t *m_samples;
+	samples_device *m_samples;
 
 	UINT8    m_main_irq_mask;
 };
diff -Nru src-old/mame/includes/tmnt.h src/mame/includes/tmnt.h
--- src-old/mame/includes/tmnt.h	2012-01-14 01:39:13.000000000 +0100
+++ src/mame/includes/tmnt.h	2012-02-19 02:53:16.000000000 +0100
@@ -1,3 +1,4 @@
+#include "sound/samples.h"
 
 class tmnt_state : public driver_device
 {
@@ -54,7 +55,7 @@
 	device_t *m_k053936;
 	device_t *m_k054000;
 	device_t *m_upd;
-	device_t *m_samples;
+	samples_device *m_samples;
 
 	/* memory buffers */
 	INT16      m_sampledata[0x40000];
diff -Nru src-old/mame/layout/30test.lay src/mame/layout/30test.lay
--- src-old/mame/layout/30test.lay	2011-09-20 22:10:48.000000000 +0200
+++ src/mame/layout/30test.lay	2012-02-12 16:49:27.000000000 +0100
@@ -1,385 +1,690 @@
 <?xml version="1.0"?>
 <mamelayout version="2">
-	<element name="digit" defstate="10">
+
+<!-- define elements -->
+
+	<element name="digit" defstate="0">
 		<led7seg>
-			<color red="1.0" green="0.0" blue="0.0" />
+			<color red="1.0" green="0.1" blue="0.1" />
 		</led7seg>
 	</element>
 
-	<element name="rank">
-		<rect state="1">
-			<color red="1.0" green="0.0" blue="0.0" />
-		</rect>
-		<rect state="0">
+	<element name="disk_lamp">
+		<disk state="1">
+			<color red="1.0" green="0.1" blue="0.1" />
+		</disk>
+		<disk state="0">
 			<color red="0.1" green="0.0" blue="0.0" />
+		</disk>
+	</element>
+
+	<element name="disk_blue">
+		<disk>
+			<color red="0.1" green="0.35" blue="0.8" />
+		</disk>
+	</element>
+	<element name="disk_red">
+		<disk>
+			<color red="0.8" green="0.1" blue="0.0" />
+		</disk>
+	</element>
+
+	<element name="static_black">
+		<rect>
+			<color red="0.0" green="0.0" blue="0.0" />
+		</rect>
+	</element>
+	<element name="static_blue">
+		<rect>
+			<color red="0.1" green="0.35" blue="0.8" />
+		</rect>
+	</element>
+	<element name="static_yellow">
+		<rect>
+			<color red="0.95" green="0.8" blue="0.1" />
+		</rect>
+	</element>
+	<element name="static_red">
+		<rect>
+			<color red="0.8" green="0.1" blue="0.0" />
 		</rect>
 	</element>
 
-	<view name="Simple LEDs">
-		<screen index="0">
-			<bounds left="0" top="0" right="3.2" bottom="4.3" />
-		</screen>
+	<!-- note: cab has a white button underneath, -->
+	<!-- make the border white-ish instead (normally red), -->
+	<!-- implying that it should be clickable -->
+	<element name="led_box" defstate="0">
+		<rect state="0">
+			<color red="0.7" green="0.7" blue="0.8" />
+			<bounds x="0" y="0" width="30" height="25" />
+		</rect>
+		<rect state="0">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="2" y="2" width="26" height="21" />
+		</rect>
+		<rect state="0">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="2" y="2" width="26" height="21" />
+		</rect>
+		<rect state="1">
+			<color red="1.0" green="0.7" blue="0.8" />
+			<bounds x="1" y="1" width="28" height="23" />
+		</rect>
+		<rect state="1">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="3" y="3" width="24" height="19" />
+		</rect>
+	</element>
 
 
-		<bezel name="digit0" element="digit">
-			<bounds x="0.0" y="1.3" width="0.2" height="0.3" />
-		</bezel>
+<!-- define text -->
 
-		<bezel name="digit1" element="digit">
-			<bounds x="0.2" y="1.3" width="0.2" height="0.3" />
-		</bezel>
+	<element name="text_score">
+		<text string="SCORE">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_time">
+		<text string="TIME">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_best">
+		<text string="BEST">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
 
+	<element name="text_1">
+		<text string="1." align="2">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_2">
+		<text string="2." align="2">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_3">
+		<text string="3." align="2">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
 
-		<bezel name="digit2" element="digit">
-			<bounds x="0.6" y="1.3" width="0.2" height="0.3" />
-		</bezel>
+	<element name="text_rank1">
+		<text string="great!!" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_rank2">
+		<text string="pretty good" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_rank3">
+		<text string="not bad" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_rank4">
+		<text string="mediocre" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_rank5">
+		<text string="pretty bad" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
+	<element name="text_rank6">
+		<text string="awful" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
 
-		<bezel name="digit3" element="digit">
-			<bounds x="0.8" y="1.3" width="0.2" height="0.3" />
-		</bezel>
+	<element name="text_gameover">
+		<text string="game over" align="1">
+			<color red="0.1" green="0.35" blue="0.8" />
+		</text>
+	</element>
 
 
-		<bezel name="digit4" element="digit">
-			<bounds x="1.2" y="1.3" width="0.2" height="0.3" />
-		</bezel>
 
-		<bezel name="digit5" element="digit">
-			<bounds x="1.4" y="1.3" width="0.2" height="0.3" />
-		</bezel>
 
 
-		<bezel name="digit6" element="digit">
-			<bounds x="1.8" y="1.3" width="0.2" height="0.3" />
+	<view name="Internal Layout">
+		<bounds left="0" top="0" right="246" bottom="246" />
+		<bezel element="static_blue">
+			<bounds left="0" right="246" top="0" bottom="246" />
 		</bezel>
 
-		<bezel name="digit7" element="digit">
-			<bounds x="2.0" y="1.3" width="0.2" height="0.3" />
-		</bezel>
 
+<!-- info box -->
 
-		<bezel name="digit8" element="digit">
-			<bounds x="2.4" y="1.3" width="0.2" height="0.3" />
+		<bezel element="static_red">
+			<bounds x="18" y="5" width="210" height="69" />
 		</bezel>
 
-		<bezel name="digit9" element="digit">
-			<bounds x="2.6" y="1.3" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="18" y="5" width="4" height="4" />
+		</bezel>
+		<bezel element="disk_red">
+			<bounds x="18" y="5" width="8" height="8" />
 		</bezel>
 
+		<bezel element="static_blue">
+			<bounds x="18" y="70" width="4" height="4" />
+		</bezel>
+		<bezel element="disk_red">
+			<bounds x="18" y="66" width="8" height="8" />
+		</bezel>
 
-		<bezel name="digit10" element="digit">
-			<bounds x="3.0" y="1.3" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="224" y="5" width="4" height="4" />
+		</bezel>
+		<bezel element="disk_red">
+			<bounds x="220" y="5" width="8" height="8" />
 		</bezel>
 
-		<bezel name="digit11" element="digit">
-			<bounds x="3.2" y="1.3" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="224" y="70" width="4" height="4" />
+		</bezel>
+		<bezel element="disk_red">
+			<bounds x="220" y="66" width="8" height="8" />
 		</bezel>
 
+		<bezel element="static_yellow">
+			<bounds x="20" y="7" width="206" height="65" />
+		</bezel>
 
 
+<!-- score -->
 
-		<bezel name="digit12" element="digit">
-			<bounds x="0.0" y="1.9" width="0.2" height="0.3" />
+		<bezel element="text_score">
+			<bounds x="25" y="7" width="37.4" height="7" />
 		</bezel>
 
-		<bezel name="digit13" element="digit">
-			<bounds x="0.2" y="1.9" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="25" y="14.3" width="37.4" height="28.9" />
 		</bezel>
-
-
-		<bezel name="digit14" element="digit">
-			<bounds x="0.6" y="1.9" width="0.2" height="0.3" />
+		<bezel element="static_black">
+			<bounds x="25.7" y="15" width="36" height="27.5" />
 		</bezel>
 
-		<bezel name="digit15" element="digit">
-			<bounds x="0.8" y="1.9" width="0.2" height="0.3" />
+		<bezel name="digit70" element="digit">
+			<bounds x="26.7" y="16" width="17" height="25.5" />
 		</bezel>
-
-
-		<bezel name="digit16" element="digit">
-			<bounds x="1.2" y="1.9" width="0.2" height="0.3" />
+		<bezel name="digit71" element="digit">
+			<bounds x="43.7" y="16" width="17" height="25.5" />
 		</bezel>
 
-		<bezel name="digit17" element="digit">
-			<bounds x="1.4" y="1.9" width="0.2" height="0.3" />
-		</bezel>
 
+<!-- time -->
 
-		<bezel name="digit18" element="digit">
-			<bounds x="1.8" y="1.9" width="0.2" height="0.3" />
+		<bezel element="text_time">
+			<bounds x="22.3" y="43" width="43.4" height="7" />
 		</bezel>
 
-		<bezel name="digit19" element="digit">
-			<bounds x="2.0" y="1.9" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="22.3" y="50.3" width="43.4" height="18.4" />
 		</bezel>
-
-
-		<bezel name="digit20" element="digit">
-			<bounds x="2.4" y="1.9" width="0.2" height="0.3" />
+		<bezel element="static_black">
+			<bounds x="23" y="51" width="42" height="17" />
 		</bezel>
 
-		<bezel name="digit21" element="digit">
-			<bounds x="2.6" y="1.9" width="0.2" height="0.3" />
+		<bezel name="digit60" element="digit">
+			<bounds x="24" y="52" width="10" height="15" />
 		</bezel>
 
-
-		<bezel name="digit22" element="digit">
-			<bounds x="3.0" y="1.9" width="0.2" height="0.3" />
+		<bezel name="digit61" element="digit">
+			<bounds x="34" y="52" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit23" element="digit">
-			<bounds x="3.2" y="1.9" width="0.2" height="0.3" />
+		<bezel name="digit62" element="digit">
+			<bounds x="44" y="52" width="10" height="15" />
 		</bezel>
 
+		<bezel name="digit63" element="digit">
+			<bounds x="54" y="52" width="10" height="15" />
+		</bezel>
 
 
+<!-- today's highscores -->
 
-		<bezel name="digit24" element="digit">
-			<bounds x="0.0" y="2.5" width="0.2" height="0.3" />
+		<bezel element="text_best">
+			<bounds x="73.3" y="7" width="23.4" height="7" />
 		</bezel>
 
-		<bezel name="digit25" element="digit">
-			<bounds x="0.2" y="2.5" width="0.2" height="0.3" />
+		<bezel element="text_1">
+			<bounds x="63" y="25.5" width="10" height="7" />
 		</bezel>
-
-
-		<bezel name="digit26" element="digit">
-			<bounds x="0.6" y="2.5" width="0.2" height="0.3" />
+		<bezel element="text_2">
+			<bounds x="63" y="43.5" width="10" height="7" />
 		</bezel>
-
-		<bezel name="digit27" element="digit">
-			<bounds x="0.8" y="2.5" width="0.2" height="0.3" />
+		<bezel element="text_3">
+			<bounds x="63" y="61.5" width="10" height="7" />
 		</bezel>
 
-
-		<bezel name="digit28" element="digit">
-			<bounds x="1.2" y="2.5" width="0.2" height="0.3" />
+		<bezel element="static_blue">
+			<bounds x="73.3" y="14.3" width="23.4" height="54.4" />
 		</bezel>
 
-		<bezel name="digit29" element="digit">
-			<bounds x="1.4" y="2.5" width="0.2" height="0.3" />
+		<bezel element="static_black">
+			<bounds x="74" y="15" width="22" height="17" />
 		</bezel>
-
-
-		<bezel name="digit30" element="digit">
-			<bounds x="1.8" y="2.5" width="0.2" height="0.3" />
+		<bezel element="static_black">
+			<bounds x="74" y="33" width="22" height="17" />
 		</bezel>
-
-		<bezel name="digit31" element="digit">
-			<bounds x="2.0" y="2.5" width="0.2" height="0.3" />
+		<bezel element="static_black">
+			<bounds x="74" y="51" width="22" height="17" />
 		</bezel>
 
-
-		<bezel name="digit32" element="digit">
-			<bounds x="2.4" y="2.5" width="0.2" height="0.3" />
+		<bezel name="digit64" element="digit">
+			<bounds x="75" y="16" width="10" height="15" />
 		</bezel>
-
-		<bezel name="digit33" element="digit">
-			<bounds x="2.6" y="2.5" width="0.2" height="0.3" />
+		<bezel name="digit65" element="digit">
+			<bounds x="85" y="16" width="10" height="15" />
 		</bezel>
 
-
-		<bezel name="digit34" element="digit">
-			<bounds x="3.0" y="2.5" width="0.2" height="0.3" />
+		<bezel name="digit66" element="digit">
+			<bounds x="75" y="34" width="10" height="15" />
 		</bezel>
-
-		<bezel name="digit35" element="digit">
-			<bounds x="3.2" y="2.5" width="0.2" height="0.3" />
+		<bezel name="digit67" element="digit">
+			<bounds x="85" y="34" width="10" height="15" />
 		</bezel>
 
+		<bezel name="digit68" element="digit">
+			<bounds x="75" y="52" width="10" height="15" />
+		</bezel>
+		<bezel name="digit69" element="digit">
+			<bounds x="85" y="52" width="10" height="15" />
+		</bezel>
 
 
+<!-- ranking -->
 
-		<bezel name="digit36" element="digit">
-			<bounds x="0.0" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="15.75" width="6.25" height="6.25" />
 		</bezel>
-
-		<bezel name="digit37" element="digit">
-			<bounds x="0.2" y="3.1" width="0.2" height="0.3" />
+		<bezel name="lamp0" element="disk_lamp">
+			<bounds x="103" y="16" width="5.75" height="5.75" />
 		</bezel>
 
-
-		<bezel name="digit38" element="digit">
-			<bounds x="0.6" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="22.25" width="6.25" height="6.25" />
 		</bezel>
-
-		<bezel name="digit39" element="digit">
-			<bounds x="0.8" y="3.1" width="0.2" height="0.3" />
+		<bezel name="lamp1" element="disk_lamp">
+			<bounds x="103" y="22.5" width="5.75" height="5.75" />
 		</bezel>
 
-
-		<bezel name="digit40" element="digit">
-			<bounds x="1.2" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="28.75" width="6.25" height="6.25" />
 		</bezel>
-
-		<bezel name="digit41" element="digit">
-			<bounds x="1.4" y="3.1" width="0.2" height="0.3" />
+		<bezel name="lamp2" element="disk_lamp">
+			<bounds x="103" y="29" width="5.75" height="5.75" />
 		</bezel>
 
-
-		<bezel name="digit42" element="digit">
-			<bounds x="1.8" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="35.25" width="6.25" height="6.25" />
 		</bezel>
-
-		<bezel name="digit43" element="digit">
-			<bounds x="2.0" y="3.1" width="0.2" height="0.3" />
+		<bezel name="lamp3" element="disk_lamp">
+			<bounds x="103" y="35.5" width="5.75" height="5.75" />
 		</bezel>
 
-
-		<bezel name="digit44" element="digit">
-			<bounds x="2.4" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="41.75" width="6.25" height="6.25" />
 		</bezel>
-
-		<bezel name="digit45" element="digit">
-			<bounds x="2.6" y="3.1" width="0.2" height="0.3" />
+		<bezel name="lamp4" element="disk_lamp">
+			<bounds x="103" y="42" width="5.75" height="5.75" />
 		</bezel>
 
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="48.25" width="6.25" height="6.25" />
+		</bezel>
+		<bezel name="lamp5" element="disk_lamp">
+			<bounds x="103" y="48.5" width="5.75" height="5.75" />
+		</bezel>
 
-		<bezel name="digit46" element="digit">
-			<bounds x="3.0" y="3.1" width="0.2" height="0.3" />
+		<bezel element="disk_blue">
+			<bounds x="102.75" y="54.75" width="6.25" height="6.25" />
+		</bezel>
+		<bezel name="lamp6" element="disk_lamp">
+			<bounds x="103" y="55" width="5.75" height="5.75" />
 		</bezel>
 
-		<bezel name="digit47" element="digit">
-			<bounds x="3.2" y="3.1" width="0.2" height="0.3" />
+		<bezel element="text_rank1">
+			<bounds x="111" y="15.25" width="40" height="6.5" />
+		</bezel>
+		<bezel element="text_rank2">
+			<bounds x="111" y="21.75" width="40" height="6.5" />
+		</bezel>
+		<bezel element="text_rank3">
+			<bounds x="111" y="28.25" width="40" height="6.5" />
+		</bezel>
+		<bezel element="text_rank4">
+			<bounds x="111" y="34.75" width="40" height="6.5" />
+		</bezel>
+		<bezel element="text_rank5">
+			<bounds x="111" y="41.25" width="40" height="6.5" />
+		</bezel>
+		<bezel element="text_rank6">
+			<bounds x="111" y="47.75" width="40" height="6.5" />
 		</bezel>
 
+		<bezel element="text_gameover">
+			<bounds x="111" y="54.25" width="40" height="6.5" />
+		</bezel>
 
 
+<!-- the grid -->
+<!-- row 1 -->
 
-		<bezel name="digit48" element="digit">
-			<bounds x="0.0" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x01">
+			<bounds x="18" y="80" width="30" height="25" />
 		</bezel>
-
-		<bezel name="digit49" element="digit">
-			<bounds x="0.2" y="3.7" width="0.2" height="0.3" />
+		<bezel name="digit0" element="digit">
+			<bounds x="23" y="85" width="10" height="15" />
 		</bezel>
-
-
-		<bezel name="digit50" element="digit">
-			<bounds x="0.6" y="3.7" width="0.2" height="0.3" />
+		<bezel name="digit1" element="digit">
+			<bounds x="33" y="85" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit51" element="digit">
-			<bounds x="0.8" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x02">
+			<bounds x="54" y="80" width="30" height="25" />
 		</bezel>
-
-
-		<bezel name="digit52" element="digit">
-			<bounds x="1.2" y="3.7" width="0.2" height="0.3" />
+		<bezel name="digit2" element="digit">
+			<bounds x="59" y="85" width="10" height="15" />
+		</bezel>
+		<bezel name="digit3" element="digit">
+			<bounds x="69" y="85" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit53" element="digit">
-			<bounds x="1.4" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x04">
+			<bounds x="90" y="80" width="30" height="25" />
+		</bezel>
+		<bezel name="digit4" element="digit">
+			<bounds x="95" y="85" width="10" height="15" />
+		</bezel>
+		<bezel name="digit5" element="digit">
+			<bounds x="105" y="85" width="10" height="15" />
 		</bezel>
 
+		<bezel element="led_box" inputtag="IN0" inputmask="0x08">
+			<bounds x="126" y="80" width="30" height="25" />
+		</bezel>
+		<bezel name="digit6" element="digit">
+			<bounds x="131" y="85" width="10" height="15" />
+		</bezel>
+		<bezel name="digit7" element="digit">
+			<bounds x="141" y="85" width="10" height="15" />
+		</bezel>
 
-		<bezel name="digit54" element="digit">
-			<bounds x="1.8" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x10">
+			<bounds x="162" y="80" width="30" height="25" />
+		</bezel>
+		<bezel name="digit8" element="digit">
+			<bounds x="167" y="85" width="10" height="15" />
+		</bezel>
+		<bezel name="digit9" element="digit">
+			<bounds x="177" y="85" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit55" element="digit">
-			<bounds x="2.0" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x20">
+			<bounds x="198" y="80" width="30" height="25" />
+		</bezel>
+		<bezel name="digit10" element="digit">
+			<bounds x="203" y="85" width="10" height="15" />
+		</bezel>
+		<bezel name="digit11" element="digit">
+			<bounds x="213" y="85" width="10" height="15" />
 		</bezel>
 
+<!-- row 2 -->
 
-		<bezel name="digit56" element="digit">
-			<bounds x="2.4" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x40">
+			<bounds x="18" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit12" element="digit">
+			<bounds x="23" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit13" element="digit">
+			<bounds x="33" y="119" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit57" element="digit">
-			<bounds x="2.6" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN0" inputmask="0x80">
+			<bounds x="54" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit14" element="digit">
+			<bounds x="59" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit15" element="digit">
+			<bounds x="69" y="119" width="10" height="15" />
 		</bezel>
 
+		<bezel element="led_box" inputtag="IN1" inputmask="0x01">
+			<bounds x="90" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit16" element="digit">
+			<bounds x="95" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit17" element="digit">
+			<bounds x="105" y="119" width="10" height="15" />
+		</bezel>
 
-		<bezel name="digit58" element="digit">
-			<bounds x="3.0" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN1" inputmask="0x02">
+			<bounds x="126" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit18" element="digit">
+			<bounds x="131" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit19" element="digit">
+			<bounds x="141" y="119" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit59" element="digit">
-			<bounds x="3.2" y="3.7" width="0.2" height="0.3" />
+		<bezel element="led_box" inputtag="IN1" inputmask="0x04">
+			<bounds x="162" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit20" element="digit">
+			<bounds x="167" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit21" element="digit">
+			<bounds x="177" y="119" width="10" height="15" />
 		</bezel>
 
+		<bezel element="led_box" inputtag="IN1" inputmask="0x08">
+			<bounds x="198" y="114" width="30" height="25" />
+		</bezel>
+		<bezel name="digit22" element="digit">
+			<bounds x="203" y="119" width="10" height="15" />
+		</bezel>
+		<bezel name="digit23" element="digit">
+			<bounds x="213" y="119" width="10" height="15" />
+		</bezel>
 
+<!-- row 3 -->
 
+		<bezel element="led_box" inputtag="IN1" inputmask="0x10">
+			<bounds x="18" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit24" element="digit">
+			<bounds x="23" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit25" element="digit">
+			<bounds x="33" y="153" width="10" height="15" />
+		</bezel>
 
-		<bezel name="digit60" element="digit">
-			<bounds x="0.0" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN1" inputmask="0x20">
+			<bounds x="54" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit26" element="digit">
+			<bounds x="59" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit27" element="digit">
+			<bounds x="69" y="153" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit61" element="digit">
-			<bounds x="0.2" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN1" inputmask="0x40">
+			<bounds x="90" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit28" element="digit">
+			<bounds x="95" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit29" element="digit">
+			<bounds x="105" y="153" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit62" element="digit">
-			<bounds x="0.4" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN1" inputmask="0x80">
+			<bounds x="126" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit30" element="digit">
+			<bounds x="131" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit31" element="digit">
+			<bounds x="141" y="153" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit63" element="digit">
-			<bounds x="0.6" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x01">
+			<bounds x="162" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit32" element="digit">
+			<bounds x="167" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit33" element="digit">
+			<bounds x="177" y="153" width="10" height="15" />
 		</bezel>
 
+		<bezel element="led_box" inputtag="IN2" inputmask="0x02">
+			<bounds x="198" y="148" width="30" height="25" />
+		</bezel>
+		<bezel name="digit34" element="digit">
+			<bounds x="203" y="153" width="10" height="15" />
+		</bezel>
+		<bezel name="digit35" element="digit">
+			<bounds x="213" y="153" width="10" height="15" />
+		</bezel>
 
+<!-- row 4 -->
 
-		<bezel name="digit64" element="digit">
-			<bounds x="0.9" y="0.3" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x04">
+			<bounds x="18" y="182" width="30" height="25" />
 		</bezel>
-
-		<bezel name="digit65" element="digit">
-			<bounds x="1.1" y="0.3" width="0.2" height="0.2" />
+		<bezel name="digit36" element="digit">
+			<bounds x="23" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit37" element="digit">
+			<bounds x="33" y="187" width="10" height="15" />
 		</bezel>
 
-
-		<bezel name="digit66" element="digit">
-			<bounds x="0.9" y="0.6" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x08">
+			<bounds x="54" y="182" width="30" height="25" />
+		</bezel>
+		<bezel name="digit38" element="digit">
+			<bounds x="59" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit39" element="digit">
+			<bounds x="69" y="187" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit67" element="digit">
-			<bounds x="1.1" y="0.6" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x10">
+			<bounds x="90" y="182" width="30" height="25" />
+		</bezel>
+		<bezel name="digit40" element="digit">
+			<bounds x="95" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit41" element="digit">
+			<bounds x="105" y="187" width="10" height="15" />
 		</bezel>
 
+		<bezel element="led_box" inputtag="IN2" inputmask="0x20">
+			<bounds x="126" y="182" width="30" height="25" />
+		</bezel>
+		<bezel name="digit42" element="digit">
+			<bounds x="131" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit43" element="digit">
+			<bounds x="141" y="187" width="10" height="15" />
+		</bezel>
 
-		<bezel name="digit68" element="digit">
-			<bounds x="0.9" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x40">
+			<bounds x="162" y="182" width="30" height="25" />
+		</bezel>
+		<bezel name="digit44" element="digit">
+			<bounds x="167" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit45" element="digit">
+			<bounds x="177" y="187" width="10" height="15" />
 		</bezel>
 
-		<bezel name="digit69" element="digit">
-			<bounds x="1.1" y="0.9" width="0.2" height="0.2" />
+		<bezel element="led_box" inputtag="IN2" inputmask="0x80">
+			<bounds x="198" y="182" width="30" height="25" />
+		</bezel>
+		<bezel name="digit46" element="digit">
+			<bounds x="203" y="187" width="10" height="15" />
+		</bezel>
+		<bezel name="digit47" element="digit">
+			<bounds x="213" y="187" width="10" height="15" />
 		</bezel>
 
+<!-- row 5 -->
 
-		<bezel name="digit70" element="digit">
-			<bounds x="0.0" y="0.3" width="0.4" height="0.4" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x01">
+			<bounds x="18" y="214" width="30" height="25" />
 		</bezel>
-
-		<bezel name="digit71" element="digit">
-			<bounds x="0.4" y="0.3" width="0.4" height="0.4" />
+		<bezel name="digit48" element="digit">
+			<bounds x="23" y="219" width="10" height="15" />
 		</bezel>
-
-		<bezel name="lamp0" element="rank">
-			<bounds x="1.5" y="0.3" width="0.1" height="0.1" />
+		<bezel name="digit49" element="digit">
+			<bounds x="33" y="219" width="10" height="15" />
 		</bezel>
 
-		<bezel name="lamp1" element="rank">
-			<bounds x="1.5" y="0.4" width="0.1" height="0.1" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x02">
+			<bounds x="54" y="214" width="30" height="25" />
 		</bezel>
-
-		<bezel name="lamp2" element="rank">
-			<bounds x="1.5" y="0.5" width="0.1" height="0.1" />
+		<bezel name="digit50" element="digit">
+			<bounds x="59" y="219" width="10" height="15" />
+		</bezel>
+		<bezel name="digit51" element="digit">
+			<bounds x="69" y="219" width="10" height="15" />
 		</bezel>
 
-		<bezel name="lamp3" element="rank">
-			<bounds x="1.5" y="0.6" width="0.1" height="0.1" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x04">
+			<bounds x="90" y="214" width="30" height="25" />
+		</bezel>
+		<bezel name="digit52" element="digit">
+			<bounds x="95" y="219" width="10" height="15" />
+		</bezel>
+		<bezel name="digit53" element="digit">
+			<bounds x="105" y="219" width="10" height="15" />
 		</bezel>
 
-		<bezel name="lamp4" element="rank">
-			<bounds x="1.5" y="0.7" width="0.1" height="0.1" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x08">
+			<bounds x="126" y="214" width="30" height="25" />
+		</bezel>
+		<bezel name="digit54" element="digit">
+			<bounds x="131" y="219" width="10" height="15" />
+		</bezel>
+		<bezel name="digit55" element="digit">
+			<bounds x="141" y="219" width="10" height="15" />
 		</bezel>
 
-		<bezel name="lamp5" element="rank">
-			<bounds x="1.5" y="0.8" width="0.1" height="0.1" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x10">
+			<bounds x="162" y="214" width="30" height="25" />
+		</bezel>
+		<bezel name="digit56" element="digit">
+			<bounds x="167" y="219" width="10" height="15" />
+		</bezel>
+		<bezel name="digit57" element="digit">
+			<bounds x="177" y="219" width="10" height="15" />
 		</bezel>
 
-		<bezel name="lamp6" element="rank">
-			<bounds x="1.5" y="0.9" width="0.1" height="0.1" />
+		<bezel element="led_box" inputtag="IN3" inputmask="0x20">
+			<bounds x="198" y="214" width="30" height="25" />
+		</bezel>
+		<bezel name="digit58" element="digit">
+			<bounds x="203" y="219" width="10" height="15" />
+		</bezel>
+		<bezel name="digit59" element="digit">
+			<bounds x="213" y="219" width="10" height="15" />
 		</bezel>
 
 
diff -Nru src-old/mame/layout/avalnche.lay src/mame/layout/avalnche.lay
--- src-old/mame/layout/avalnche.lay	2007-12-17 16:19:59.000000000 +0100
+++ src/mame/layout/avalnche.lay	2012-02-12 03:18:06.000000000 +0100
@@ -10,15 +10,15 @@
 			<color red="0.125" green="0.125" blue="1" />
 		</rect>
 		<rect>
-			<bounds left="0" top="20" right="256" bottom="29" />
+			<bounds left="0" top="20" right="256" bottom="28.5" />
 			<color red="1" green="1" blue="0.125" />
 		</rect>
 		<rect>
-			<bounds left="0" top="29" right="256" bottom="40" />
+			<bounds left="0" top="28.5" right="256" bottom="40.5" />
 			<color red="1" green="0.5" blue="0.0627" />
 		</rect>
 		<rect>
-			<bounds left="0" top="40" right="256" bottom="240" />
+			<bounds left="0" top="40.5" right="256" bottom="240" />
 			<color red="0.5" green="1" blue="1" />
 		</rect>
 	</element>
diff -Nru src-old/mame/layout/circus.lay src/mame/layout/circus.lay
--- src-old/mame/layout/circus.lay	2007-12-17 16:19:59.000000000 +0100
+++ src/mame/layout/circus.lay	2012-02-12 03:18:06.000000000 +0100
@@ -10,15 +10,15 @@
 			<color red="0.125" green="0.125" blue="1" />
 		</rect>
 		<rect>
-			<bounds left="0" top="36" right="248" bottom="48" />
+			<bounds left="0" top="36" right="248" bottom="48.5" />
 			<color red="0.125" green="1" blue="0.125" />
 		</rect>
 		<rect>
-			<bounds left="0" top="48" right="248" bottom="64" />
+			<bounds left="0" top="48.5" right="248" bottom="64.5" />
 			<color red="1" green="1" blue="0.125" />
 		</rect>
 		<rect>
-			<bounds left="0" top="64" right="248" bottom="256" />
+			<bounds left="0" top="64.5" right="248" bottom="256" />
 			<color red="1" green="1" blue="1" />
 		</rect>
 	</element>
diff -Nru src-old/mame/layout/invad2ct.lay src/mame/layout/invad2ct.lay
--- src-old/mame/layout/invad2ct.lay	2007-12-17 16:19:59.000000000 +0100
+++ src/mame/layout/invad2ct.lay	2012-02-12 03:18:06.000000000 +0100
@@ -2,11 +2,11 @@
 <mamelayout version="2">
 	<element name="overlay">
 		<rect>
-			<bounds left="0" top="0" right="224" bottom="29" />
+			<bounds left="0" top="0" right="224" bottom="27.5" />
 			<color red="1" green="1" blue="0.125" />
 		</rect>
 		<rect>
-			<bounds left="0" top="29" right="224" bottom="52" />
+			<bounds left="0" top="27.5" right="224" bottom="52" />
 			<color red="0.5" green="1" blue="0" />
 		</rect>
 		<rect>
diff -Nru src-old/mame/layout/kungfur.lay src/mame/layout/kungfur.lay
--- src-old/mame/layout/kungfur.lay	1970-01-01 01:00:00.000000000 +0100
+++ src/mame/layout/kungfur.lay	2012-02-12 03:18:06.000000000 +0100
@@ -0,0 +1,350 @@
+<?xml version="1.0"?>
+<mamelayout version="2">
+
+	<element name="static_black">
+		<rect>
+			<color red="0.0" green="0.0" blue="0.0" />
+		</rect>
+	</element>
+	<element name="static_green">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+	</element>
+	<element name="static_yellow">
+		<rect>
+			<color red="0.85" green="0.85" blue="0.2" />
+		</rect>
+	</element>
+
+	<element name="digit" defstate="0">
+		<led7seg>
+			<color red="1.0" green="0.1" blue="0.1" />
+		</led7seg>
+	</element>
+
+
+<!-- define level lamps -->
+
+	<element name="level1" defstate="0">
+		<disk state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</disk>
+		<disk state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</disk>
+		<text string="1">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.25" width="1" height="0.5" />
+		</text>
+	</element>
+	<element name="level2" defstate="0">
+		<disk state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</disk>
+		<disk state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</disk>
+		<text string="2">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.25" width="1" height="0.5" />
+		</text>
+	</element>
+	<element name="level3" defstate="0">
+		<disk state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</disk>
+		<disk state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</disk>
+		<text string="3">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.25" width="1" height="0.5" />
+		</text>
+	</element>
+	<element name="level4" defstate="0">
+		<disk state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</disk>
+		<disk state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</disk>
+		<text string="4">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.25" width="1" height="0.5" />
+		</text>
+	</element>
+	<element name="level5" defstate="0">
+		<disk state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</disk>
+		<disk state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</disk>
+		<text string="5">
+			<color red="0.0" green="0.0" blue="0.0" />
+			<bounds x="0" y="0.25" width="1" height="0.5" />
+		</text>
+	</element>
+
+
+<!-- define text -->
+
+	<element name="text_score">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+		<text string="SCORE">
+			<color red="1.0" green="1.0" blue="1.0" />
+			<bounds x="0.03" y="0" width="0.94" height="1" />
+		</text>
+	</element>
+
+	<element name="text_level">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+		<text string="LEVEL">
+			<color red="1.0" green="1.0" blue="1.0" />
+			<bounds x="0.03" y="0" width="0.94" height="1" />
+		</text>
+	</element>
+
+	<element name="text_reaction">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+		<text string="REACTION TIME">
+			<color red="1.0" green="1.0" blue="1.0" />
+			<bounds x="0.02" y="0" width="0.96" height="1" />
+		</text>
+	</element>
+
+	<element name="text_average">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+		<text string="AVERAGE">
+			<color red="1.0" green="1.0" blue="1.0" />
+			<bounds x="0.03" y="0" width="0.94" height="1" />
+		</text>
+	</element>
+
+	<element name="text_today">
+		<rect>
+			<color red="0.0" green="0.22" blue="0.22" />
+		</rect>
+		<text string="TODAY'S BEST">
+			<bounds x="0.025" y="0" width="0.95" height="1" />
+			<color red="1.0" green="1.0" blue="1.0" />
+		</text>
+	</element>
+
+	<element name="text_1">
+		<text string="1ST" align="2">
+			<color red="1.0" green="1.0" blue="1.0" />
+		</text>
+	</element>
+	<element name="text_2">
+		<text string="2ND" align="2">
+			<color red="1.0" green="1.0" blue="1.0" />
+		</text>
+	</element>
+	<element name="text_3">
+		<text string="3RD" align="2">
+			<color red="1.0" green="1.0" blue="1.0" />
+		</text>
+	</element>
+
+	<element name="text_gameover" defstate="0">
+		<text string="GAME OVER" state="1">
+			<color red="1.0" green="0.3" blue="0.3" />
+		</text>
+		<text string="GAME OVER" state="0">
+			<color red="0.2" green="0.0" blue="0.0" />
+		</text>
+	</element>
+
+
+
+
+
+	<view name="Internal Layout">
+		<bounds left="0" right="147" top="0" bottom="100" />
+		<bezel element="static_green">
+			<bounds left="0" right="147" top="0" bottom="100" />
+		</bezel>
+
+
+<!-- today's highscores -->
+
+		<bezel element="static_yellow">
+			<bounds x="97" y="5" width="45" height="75" />
+		</bezel>
+		<bezel element="static_green">
+			<bounds x="98" y="6" width="43" height="73" />
+		</bezel>
+
+		<bezel element="text_today">
+			<bounds x="105" y="3" width="29" height="5" />
+		</bezel>
+
+		<bezel element="text_1">
+			<bounds x="97.5" y="21" width="10" height="5" />
+		</bezel>
+		<bezel element="static_black">
+			<bounds x="109" y="9" width="22" height="17" />
+		</bezel>
+
+		<bezel name="digit0" element="digit">
+			<bounds x="110" y="10" width="10" height="15" />
+		</bezel>
+		<bezel name="digit1" element="digit">
+			<bounds x="120" y="10" width="10" height="15" />
+		</bezel>
+
+		<bezel element="text_2">
+			<bounds x="97.5" y="46" width="10" height="5" />
+		</bezel>
+		<bezel element="static_black">
+			<bounds x="109" y="34" width="22" height="17" />
+		</bezel>
+
+		<bezel name="digit2" element="digit">
+			<bounds x="110" y="35" width="10" height="15" />
+		</bezel>
+		<bezel name="digit3" element="digit">
+			<bounds x="120" y="35" width="10" height="15" />
+		</bezel>
+
+		<bezel element="text_3">
+			<bounds x="97.5" y="71" width="10" height="5" />
+		</bezel>
+		<bezel element="static_black">
+			<bounds x="109" y="59" width="22" height="17" />
+		</bezel>
+
+		<bezel name="digit4" element="digit">
+			<bounds x="110" y="60" width="10" height="15" />
+		</bezel>
+		<bezel name="digit5" element="digit">
+			<bounds x="120" y="60" width="10" height="15" />
+		</bezel>
+
+
+<!-- reaction time -->
+
+		<bezel element="static_yellow">
+			<bounds x="5" y="70" width="90" height="25" />
+		</bezel>
+		<bezel element="static_green">
+			<bounds x="6" y="71" width="88" height="23" />
+		</bezel>
+
+		<bezel element="text_reaction">
+			<bounds x="9.5" y="68" width="33" height="5" />
+		</bezel>
+		<bezel element="text_average">
+			<bounds x="56" y="68" width="19.5" height="5" />
+		</bezel>
+
+		<bezel element="static_black">
+			<bounds x="9" y="74" width="32" height="17" />
+		</bezel>
+
+		<bezel name="digit6" element="digit">
+			<bounds x="10" y="75" width="10" height="15" />
+		</bezel>
+		<bezel name="digit7" element="digit">
+			<bounds x="20" y="75" width="10" height="15" />
+		</bezel>
+		<bezel name="digit8" element="digit">
+			<bounds x="30" y="75" width="10" height="15" />
+		</bezel>
+
+		<bezel element="static_black">
+			<bounds x="49" y="74" width="32" height="17" />
+		</bezel>
+
+		<bezel name="digit9" element="digit">
+			<bounds x="50" y="75" width="10" height="15" />
+		</bezel>
+		<bezel name="digit10" element="digit">
+			<bounds x="60" y="75" width="10" height="15" />
+		</bezel>
+		<bezel name="digit11" element="digit">
+			<bounds x="70" y="75" width="10" height="15" />
+		</bezel>
+
+
+<!-- score -->
+
+		<bezel element="static_yellow">
+			<bounds x="5" y="5" width="90" height="40" />
+		</bezel>
+		<bezel element="static_green">
+			<bounds x="6" y="6" width="88" height="38" />
+		</bezel>
+
+		<bezel element="text_score">
+			<bounds x="43" y="3" width="15" height="5" />
+		</bezel>
+
+		<bezel element="static_black">
+			<bounds x="29" y="9" width="42" height="32" />
+		</bezel>
+
+		<bezel name="digit12" element="digit">
+			<bounds x="30" y="10" width="20" height="30" />
+		</bezel>
+		<bezel name="digit13" element="digit">
+			<bounds x="50" y="10" width="20" height="30" />
+		</bezel>
+
+
+<!-- level -->
+
+		<bezel element="static_yellow">
+			<bounds x="5" y="47" width="90" height="21" />
+		</bezel>
+		<bezel element="static_green">
+			<bounds x="6" y="48" width="88" height="19" />
+		</bezel>
+
+		<bezel element="text_level">
+			<bounds x="43" y="45" width="13" height="5" />
+		</bezel>
+
+		<bezel name="lamp0" element="level1">
+			<bounds x="10" y="52.5" width="10" height="10" />
+		</bezel>
+		<bezel name="lamp1" element="level2">
+			<bounds x="27.5" y="52.5" width="10" height="10" />
+		</bezel>
+		<bezel name="lamp2" element="level3">
+			<bounds x="45" y="52.5" width="10" height="10" />
+		</bezel>
+		<bezel name="lamp3" element="level4">
+			<bounds x="62.5" y="52.5" width="10" height="10" />
+		</bezel>
+		<bezel name="lamp4" element="level5">
+			<bounds x="80" y="52.5" width="10" height="10" />
+		</bezel>
+
+
+<!-- gameover -->
+
+		<bezel element="static_yellow">
+			<bounds x="97" y="82" width="45" height="13" />
+		</bezel>
+		<bezel element="static_green">
+			<bounds x="98" y="83" width="43" height="11" />
+		</bezel>
+
+		<bezel name="lamp5" element="text_gameover">
+			<bounds x="97" y="86" width="45" height="5" />
+		</bezel>
+
+
+	</view>
+</mamelayout>
diff -Nru src-old/mame/layout/videopin.lay src/mame/layout/videopin.lay
--- src-old/mame/layout/videopin.lay	2007-12-17 16:19:59.000000000 +0100
+++ src/mame/layout/videopin.lay	2012-02-12 03:18:06.000000000 +0100
@@ -4,7 +4,7 @@
 			<color red="1.0" green="0.125" blue="0.125" />
 		</disk>
 	</element>
-	<view name="LEDs">
+	<view name="Simple LEDs">
 		<screen index="0">
 			<bounds x="0" y="0" width="300" height="400" />
 		</screen>
diff -Nru src-old/mame/machine/archimds.c src/mame/machine/archimds.c
--- src-old/mame/machine/archimds.c	2011-11-27 15:06:49.000000000 +0100
+++ src/mame/machine/archimds.c	2012-02-11 11:01:01.000000000 +0100
@@ -74,7 +74,7 @@
 
 	if (ioc_regs[IRQ_MASK_B] & mask)
 	{
-		generic_pulse_irq_line(machine.device("maincpu"), ARM_IRQ_LINE);
+		generic_pulse_irq_line(machine.device("maincpu"), ARM_IRQ_LINE, 1);
 	}
 }
 
@@ -84,7 +84,7 @@
 
 	if (ioc_regs[FIQ_MASK] & mask)
 	{
-		generic_pulse_irq_line(machine.device("maincpu"), ARM_FIRQ_LINE);
+		generic_pulse_irq_line(machine.device("maincpu"), ARM_FIRQ_LINE, 1);
 	}
 }
 
diff -Nru src-old/mame/machine/galaxold.c src/mame/machine/galaxold.c
--- src-old/mame/machine/galaxold.c	2011-05-11 23:50:01.000000000 +0200
+++ src/mame/machine/galaxold.c	2012-02-11 11:01:01.000000000 +0100
@@ -418,7 +418,7 @@
 
 INTERRUPT_GEN( hunchbks_vh_interrupt )
 {
-	generic_pulse_irq_line_and_vector(device,0,0x03);
+	generic_pulse_irq_line_and_vector(device,0,0x03,1);
 }
 
 DRIVER_INIT( ladybugg )
diff -Nru src-old/mame/machine/gaplus.c src/mame/machine/gaplus.c
--- src-old/mame/machine/gaplus.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/machine/gaplus.c	2012-02-19 02:53:16.000000000 +0100
@@ -21,9 +21,9 @@
 WRITE8_HANDLER( gaplus_customio_3_w )
 {
 	gaplus_state *state = space->machine().driver_data<gaplus_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 	if ((offset == 0x09) && (data >= 0x0f))
-		sample_start(samples,0,0,0);
+		samples->start(0,0);
 
 	state->m_customio_3[offset] = data;
 }
diff -Nru src-old/mame/machine/harddriv.c src/mame/machine/harddriv.c
--- src-old/mame/machine/harddriv.c	2011-05-30 20:07:19.000000000 +0200
+++ src/mame/machine/harddriv.c	2012-02-13 19:48:41.000000000 +0100
@@ -671,59 +671,6 @@
 }
 
 
-
-/*************************************
- *
- *  MSP synchronization helpers
- *
- *************************************/
-
-static TIMER_CALLBACK( stmsp_sync_update )
-{
-	harddriv_state *state = machine.driver_data<harddriv_state>();
-	int which = param >> 28;
-	offs_t offset = (param >> 16) & 0xfff;
-	UINT16 data = param;
-	state->m_stmsp_sync[which][offset] = data;
-	device_triggerint(state->m_msp);
-}
-
-
-INLINE void stmsp_sync_w(address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask, int which)
-{
-	harddriv_state *state = space->machine().driver_data<harddriv_state>();
-	UINT16 newdata = state->m_stmsp_sync[which][offset];
-	COMBINE_DATA(&newdata);
-
-	/* if being written from the 68000, synchronize on it */
-	if (state->m_hd34010_host_access)
-		space->machine().scheduler().synchronize(FUNC(stmsp_sync_update), newdata | (offset << 16) | (which << 28));
-
-	/* otherwise, just update */
-	else
-		state->m_stmsp_sync[which][offset] = newdata;
-}
-
-
-WRITE16_HANDLER( stmsp_sync0_w )
-{
-	stmsp_sync_w(space, offset, data, mem_mask, 0);
-}
-
-
-WRITE16_HANDLER( stmsp_sync1_w )
-{
-	stmsp_sync_w(space, offset, data, mem_mask, 1);
-}
-
-
-WRITE16_HANDLER( stmsp_sync2_w )
-{
-	stmsp_sync_w(space, offset, data, mem_mask, 2);
-}
-
-
-
 #if 0
 #pragma mark -
 #pragma mark * ADSP BOARD
@@ -1843,32 +1790,6 @@
 }
 
 
-READ16_HANDLER( stmsp_speedup_r )
-{
-	harddriv_state *state = space->machine().driver_data<harddriv_state>();
-
-	/* assumes: stmsp_sync[0] -> $80010, stmsp_sync[1] -> $99680, stmsp_sync[2] -> $99d30 */
-	if (state->m_stmsp_sync[0][0] == 0 &&		/* 80010 */
-		state->m_stmsp_sync[0][1] == 0 &&		/* 80020 */
-		state->m_stmsp_sync[0][2] == 0 &&		/* 80030 */
-		state->m_stmsp_sync[0][3] == 0 &&		/* 80040 */
-		state->m_stmsp_sync[0][4] == 0 &&		/* 80050 */
-		state->m_stmsp_sync[0][5] == 0 &&		/* 80060 */
-		state->m_stmsp_sync[0][6] == 0 &&		/* 80070 */
-		state->m_stmsp_sync[1][0] == 0 &&		/* 99680 */
-		state->m_stmsp_sync[2][0] == 0xffff &&	/* 99d30 */
-		state->m_stmsp_sync[2][1] == 0xffff &&	/* 99d40 */
-		state->m_stmsp_sync[2][2] == 0 &&		/* 99d50 */
-		cpu_get_pc(&space->device()) == 0x3c0)
-	{
-		state->m_msp_speedup_count[0]++;
-		device_spin_until_interrupt(&space->device());
-	}
-	return state->m_stmsp_sync[0][1];
-}
-
-
-
 #if 0
 #pragma mark -
 #pragma mark * ADSP OPTIMIZATIONS
diff -Nru src-old/mame/machine/irobot.c src/mame/machine/irobot.c
--- src-old/mame/machine/irobot.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/machine/irobot.c	2012-02-06 02:30:22.000000000 +0100
@@ -5,7 +5,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "cpu/m6809/m6809.h"
 #include "includes/irobot.h"
 
diff -Nru src-old/mame/machine/mw8080bw.c src/mame/machine/mw8080bw.c
--- src-old/mame/machine/mw8080bw.c	2011-04-01 07:50:56.000000000 +0200
+++ src/mame/machine/mw8080bw.c	2012-02-19 02:53:16.000000000 +0100
@@ -101,9 +101,9 @@
 	mw8080bw_create_interrupt_timer(machine);
 
 	state->m_maincpu = machine.device("maincpu");
-	state->m_samples = machine.device("samples");
-	state->m_samples1 = machine.device("samples1");
-	state->m_samples2 = machine.device("samples2");
+	state->m_samples = machine.device<samples_device>("samples");
+	state->m_samples1 = machine.device<samples_device>("samples1");
+	state->m_samples2 = machine.device<samples_device>("samples2");
 	state->m_sn = machine.device("snsnd");
 	state->m_sn1 = machine.device("sn1");
 	state->m_sn2 = machine.device("sn2");
diff -Nru src-old/mame/machine/n64.c src/mame/machine/n64.c
--- src-old/mame/machine/n64.c	2012-02-05 09:28:43.000000000 +0100
+++ src/mame/machine/n64.c	2012-02-19 16:23:23.000000000 +0100
@@ -5,8 +5,10 @@
 #include "cpu/mips/mips3.h"
 #include "cpu/mips/mips3com.h"
 #include "includes/n64.h"
+#include "video/n64.h"
 #include "profiler.h"
 
+UINT32 *n64_sram;
 UINT32 *rdram;
 UINT32 *rsp_imem;
 UINT32 *rsp_dmem;
@@ -16,17 +18,54 @@
 
 static TIMER_CALLBACK(ai_timer_callback);
 static TIMER_CALLBACK(pi_dma_callback);
+static TIMER_CALLBACK(vi_scanline_callback);
 
 n64_periphs::n64_periphs(const machine_config &mconfig, const char *tag, device_t *owner, UINT32 clock)
     : device_t(mconfig, N64PERIPH, "N64 Periphal Chips", tag, owner, clock)
 {
 }
 
+static TIMER_CALLBACK(reset_timer_callback)
+{
+	n64_periphs *periphs = machine.device<n64_periphs>("rcp");
+	periphs->reset_tick();
+}
+
+void n64_periphs::reset_tick()
+{
+	reset_timer->adjust(attotime::never);
+	cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ2, CLEAR_LINE);
+	machine().device("maincpu")->reset();
+	machine().device("rsp")->reset();
+	machine().device("rcp")->reset();
+	cputag_set_input_line(machine(), "rsp", INPUT_LINE_HALT, ASSERT_LINE);
+	reset_held = false;
+}
+
+void n64_periphs::poll_reset_button(bool button)
+{
+	bool old_held = reset_held;
+	reset_held = button;
+	if(!old_held && reset_held)
+	{
+		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ2, ASSERT_LINE);
+	}
+	else if(old_held && reset_held)
+	{
+		reset_timer->adjust(attotime::never);
+	}
+	else if(old_held && !reset_held)
+	{
+		reset_timer->adjust(attotime::from_hz(1));
+	}
+}
 
 void n64_periphs::device_start()
 {
 	ai_timer = machine().scheduler().timer_alloc(FUNC(ai_timer_callback));
 	pi_dma_timer = machine().scheduler().timer_alloc(FUNC(pi_dma_callback));
+	vi_scanline_timer = machine().scheduler().timer_alloc(FUNC(vi_scanline_callback));
+	reset_timer = machine().scheduler().timer_alloc(FUNC(reset_timer_callback));
 }
 
 void n64_periphs::device_reset()
@@ -37,7 +76,7 @@
 	rspcpu = machine().device("rsp");
 	mem_map = maincpu->memory().space(AS_PROGRAM);
 
-	mi_version = 0;
+	mi_version = 0x02020102;
 	mi_interrupt = 0;
 	mi_intr_mask = 0;
 	mi_mode = 0;
@@ -92,19 +131,34 @@
 	pi_bsd_dom2_rls = 0;
 	pi_dma_dir = 0;
 
+	dd_int = 0;
+	memset(dd_buffer, 0, sizeof(dd_buffer));
+	memset(dd_sector_data, 0, sizeof(dd_sector_data));
+	memset(dd_ram_seq_data, 0, sizeof(dd_ram_seq_data));
+	dd_data_reg = 0;
+	dd_status_reg = 0;
+	dd_track_reg = 0;
+	dd_buf_status_reg = 0;
+	dd_sector_err_reg = 0;
+	dd_seq_status_reg = 0;
+	dd_seq_ctrl_reg = 0;
+	dd_int = 0;
+
 	memset(pif_ram, 0, sizeof(pif_ram));
 	memset(pif_cmd, 0, sizeof(pif_cmd));
 	si_dram_addr = 0;
 	si_pif_addr = 0;
 	si_status = 0;
 
-	memset(eeprom, 0, sizeof(eeprom));
-	memset(mempack, 0, sizeof(mempack));
+	memset(m_save_data.eeprom, 0, 2048);
 
 	dp_clock = 0;
 
 	cic_status = 0;
 
+	reset_held = false;
+	reset_timer->adjust(attotime::never);
+
     // bootcode differs between CIC-chips, so we can use its checksum to detect the CIC-chip
     UINT64 boot_checksum = 0;
     for(int i = 0x40; i < 0x1000; i+=4)
@@ -112,21 +166,26 @@
         boot_checksum += cart[i/4]+i;
     }
 
-    if (boot_checksum == U64(0x000000d057e84864))
-    {
-        // CIC-NUS-6101
-        printf("CIC-NUS-6102 detected\n");
-        pif_ram[0x24] = 0x00;
-        pif_ram[0x25] = 0x02;
-        pif_ram[0x26] = 0x3f;
-        pif_ram[0x27] = 0x3f;
-        // crc_seed = 0x3f;
-    }
+	// CIC-NUS-6102 (default)
+	pif_ram[0x24] = 0x00;
+	pif_ram[0x25] = 0x02;
+	pif_ram[0x26] = 0x3f;
+	pif_ram[0x27] = 0x3f;
+	dd_present = false;
+
+	if (boot_checksum == U64(0x00000000001ff230))
+	{
+		//printf("64DD detected\n");
+		pif_ram[0x24] = 0x00;
+		pif_ram[0x25] = 0x0a;
+		pif_ram[0x26] = 0xdd; // How utterly predictable
+		pif_ram[0x27] = 0x3f;
+		dd_present = true;
+	}
     else if (boot_checksum == U64(0x000000cffb830843) || boot_checksum == U64(0x000000d0027fdf31))
     {
-        // CIC-NUS-6103
-        printf("CIC-NUS-6101 detected\n");
-        // crc_seed = 0x78;
+        // CIC-NUS-6101
+        //printf("CIC-NUS-6101 detected\n");
         pif_ram[0x24] = 0x00;
         pif_ram[0x25] = 0x06;
         pif_ram[0x26] = 0x3f;
@@ -135,8 +194,7 @@
     else if (boot_checksum == U64(0x000000d6499e376b))
     {
         // CIC-NUS-6103
-        printf("CIC-NUS-6103 detected\n");
-        // crc_seed = 0x78;
+        //printf("CIC-NUS-6103 detected\n");
         pif_ram[0x24] = 0x00;
         pif_ram[0x25] = 0x02;
         pif_ram[0x26] = 0x78;
@@ -145,10 +203,7 @@
     else if (boot_checksum == U64(0x0000011a4a1604b6))
     {
         // CIC-NUS-6105
-        printf("CIC-NUS-6105 detected\n");
-        // crc_seed = 0x91;
-
-        // first_rsp = 0;
+        //printf("CIC-NUS-6105 detected\n");
         pif_ram[0x24] = 0x00;
         pif_ram[0x25] = 0x02;
         pif_ram[0x26] = 0x91;
@@ -157,8 +212,7 @@
     else if (boot_checksum == U64(0x000000d6d5de4ba0))
     {
         // CIC-NUS-6106
-        printf("CIC-NUS-6106 detected\n");
-        // crc_seed = 0x85;
+        //printf("CIC-NUS-6106 detected\n");
         pif_ram[0x24] = 0x00;
         pif_ram[0x25] = 0x02;
         pif_ram[0x26] = 0x85;
@@ -166,7 +220,7 @@
     }
     else
     {
-        printf("Unknown BootCode Checksum %08X%08X\n", (UINT32)(boot_checksum>>32),(UINT32)(boot_checksum));
+        //printf("Unknown BootCode Checksum %08X%08X\n", (UINT32)(boot_checksum>>32),(UINT32)(boot_checksum));
     }
 }
 
@@ -185,27 +239,32 @@
 
 READ32_MEMBER( n64_periphs::mi_reg_r )
 {
-	//printf("mi_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
 	switch (offset)
 	{
         case 0x00/4:            // MI_MODE_REG
-            return mi_mode;
+            ret = mi_mode;
+            break;
 
 		case 0x04/4:			// MI_VERSION_REG
-			return mi_version;
+			ret = mi_version;
+			break;
 
 		case 0x08/4:			// MI_INTR_REG
-			return mi_interrupt;
+			ret = mi_interrupt;
+			break;
 
 		case 0x0c/4:			// MI_INTR_MASK_REG
-			return mi_intr_mask;
+			ret = mi_intr_mask;
+			break;
 
 		default:
 			logerror("mi_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(&mem_map->device()));
 			break;
 	}
 
-	return 0;
+	//printf("mi_reg_r %08x = %08x\n", offset * 4, ret);
+	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::mi_reg_w )
@@ -224,6 +283,8 @@
 			{
 				clear_rcp_interrupt(DP_INTERRUPT);
 			}
+			mi_mode &= ~0x7f;
+			mi_mode |= data & 0x7f;
 			break;
 
 		case 0x04/4:		// MI_VERSION_REG
@@ -280,6 +341,7 @@
             {
                 mi_intr_mask |= 0x20;      // set DP mask
             }
+            check_interrupts();
 			break;
 		}
 
@@ -294,24 +356,32 @@
 	machine.device<n64_periphs>("rcp")->signal_rcp_interrupt(interrupt);
 }
 
-void n64_periphs::signal_rcp_interrupt(int interrupt)
+void n64_periphs::check_interrupts()
 {
-	if (mi_intr_mask & interrupt)
+	if (mi_intr_mask & mi_interrupt)
 	{
-		mi_interrupt |= interrupt;
-
+		//printf("Asserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt);
 		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, ASSERT_LINE);
 	}
+	else
+	{
+		//printf("Deasserting IRQ, %02x : %02x\n", mi_intr_mask, mi_interrupt);
+		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, CLEAR_LINE);
+	}
+}
+
+void n64_periphs::signal_rcp_interrupt(int interrupt)
+{
+	mi_interrupt |= interrupt;
+
+	check_interrupts();
 }
 
 void n64_periphs::clear_rcp_interrupt(int interrupt)
 {
 	mi_interrupt &= ~interrupt;
 
-	//if (!mi_interrupt)
-	{
-		cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ0, CLEAR_LINE);
-	}
+	check_interrupts();
 }
 
 READ32_MEMBER( n64_periphs::is64_r )
@@ -347,10 +417,10 @@
         case 0x0014/4:
             for(i = 0x20; i < (0x20 + data); i++)
             {
-                printf( "%c", is64_buffer[i] );
+                //printf( "%c", is64_buffer[i] );
                 if(is64_buffer[i] == 0x0a)
                 {
-                    printf( "%c", 0x0d );
+                    //printf( "%c", 0x0d );
                 }
                 is64_buffer[i] = 0;
             }
@@ -368,7 +438,7 @@
 READ32_MEMBER( n64_periphs::open_r )
 {
     UINT32 retval = (offset << 2) & 0x0000ffff;
-    retval = (retval << 16) | retval;
+    retval = ((retval + 2) << 16) | retval;
     return retval;
 }
 
@@ -392,7 +462,7 @@
 
 READ32_MEMBER( n64_periphs::rdram_reg_r )
 {
-	//printf("rdram_reg_r %08x\n", offset * 4);
+	//printf("rdram_reg_r %08x = %08x\n", offset * 4, rdram_regs[offset]);
 	if(offset > 0x24/4)
 	{
 		logerror("rdram_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
@@ -406,7 +476,7 @@
 	//printf("rdram_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
 	if(offset > 0x24/4)
 	{
-		logerror("mi_reg_w: %08X, %08X, %08X at %08X\n", data, offset, mem_mask, cpu_get_pc(maincpu));
+		logerror("rdram_reg_w: %08X, %08X, %08X at %08X\n", data, offset, mem_mask, cpu_get_pc(maincpu));
 		return;
 	}
 	COMBINE_DATA(&rdram_regs[offset]);
@@ -416,12 +486,14 @@
 
 void n64_periphs::sp_dma(int direction)
 {
-	sp_dma_length++;
-	if ((sp_dma_length & 7) != 0)
+	UINT32 length = sp_dma_length + 1;
+
+	if ((length & 7) != 0)
 	{
-        sp_dma_length = (sp_dma_length + 7) & ~7;
+        length = (length + 7) & ~7;
 	}
 
+	//printf("Length %08x Skip %08x Count %08x\n", length, sp_dma_skip, sp_dma_count);
 	if (sp_mem_addr & 0x3)
 	{
         sp_mem_addr = sp_mem_addr & ~3;
@@ -431,11 +503,11 @@
         sp_dram_addr = sp_dram_addr & ~7;
 	}
 
-	if ((sp_mem_addr & 0xfff) + (sp_dma_length) > 0x1000)
+	if ((sp_mem_addr & 0xfff) + (length) > 0x1000)
 	{
-		printf("sp_dma: dma out of memory area: %08X, %08X\n", sp_mem_addr, sp_dma_length);
-		//fatalerror("sp_dma: dma out of memory area: %08X, %08X\n", sp_mem_addr, sp_dma_length);
-		sp_dma_length = 0x1000 - (sp_mem_addr & 0xfff);
+		//printf("sp_dma: dma out of memory area: %08X, %08X, %08X\n", sp_mem_addr, sp_dram_addr, length);
+		//fatalerror("sp_dma: dma out of memory area: %08X, %08X\n", sp_mem_addr, length);
+		length = 0x1000 - (sp_mem_addr & 0xfff);
 	}
 
 	UINT32 *sp_mem[2] = { rsp_dmem, rsp_imem };
@@ -447,13 +519,13 @@
             UINT32 src = (sp_dram_addr & 0x007fffff) >> 2;
             UINT32 dst = (sp_mem_addr & 0x1fff) >> 2;
 
-            for(int i = 0; i < sp_dma_length / 4; i++)
+            for(int i = 0; i < length / 4; i++)
             {
 				sp_mem[(dst + i) >> 10][(dst + i) & 0x3ff] = rdram[src + i];
             }
 
-            sp_mem_addr += sp_dma_length;
-            sp_dram_addr += sp_dma_length;
+            sp_mem_addr += length;
+            sp_dram_addr += length;
 
             sp_mem_addr += sp_dma_skip;
         }
@@ -465,13 +537,13 @@
             UINT32 src = (sp_mem_addr & 0x1fff) >> 2;
             UINT32 dst = (sp_dram_addr & 0x007fffff) >> 2;
 
-            for(int i = 0; i < sp_dma_length / 4; i++)
+            for(int i = 0; i < length / 4; i++)
             {
 				rdram[dst + i] = sp_mem[(src + i) >> 10][(src + i) & 0x3ff];
             }
 
-            sp_mem_addr += sp_dma_length;
-            sp_dram_addr += sp_dma_length;
+            sp_mem_addr += length;
+            sp_dram_addr += length;
 
             sp_dram_addr += sp_dma_skip;
         }
@@ -485,6 +557,7 @@
 
 void n64_periphs::sp_set_status(UINT32 status)
 {
+	//printf("sp_set_status: %08x\n", status);
 	if (status & 0x1)
 	{
 		device_set_input_line(rspcpu, INPUT_LINE_HALT, ASSERT_LINE);
@@ -504,61 +577,102 @@
 
 UINT32 n64_periphs::sp_reg_r(UINT32 offset)
 {
-	//printf("sp_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
 	switch (offset)
 	{
 		case 0x00/4:		// SP_MEM_ADDR_REG
-			return sp_mem_addr;
+			ret = sp_mem_addr;
+			break;
 
 		case 0x04/4:		// SP_DRAM_ADDR_REG
-			return sp_dram_addr;
+			ret = sp_dram_addr;
+			break;
 
 		case 0x08/4:		// SP_RD_LEN_REG
-			return (sp_dma_skip << 20) | (sp_dma_count << 12) | sp_dma_length;
+			ret = (sp_dma_skip << 20) | (sp_dma_count << 12) | sp_dma_length;
+			break;
 
 		case 0x10/4:		// SP_STATUS_REG
-            return cpu_get_reg(rspcpu, RSP_SR);
+			//machine().scheduler().synchronize();
+			//machine().scheduler().boost_interleave(attotime::from_msec(1), attotime::from_msec(m));
+            ret = cpu_get_reg(rspcpu, RSP_SR);
+			break;
 
 		case 0x14/4:		// SP_DMA_FULL_REG
-			return 0;
+			ret = 0;
+			break;
 
 		case 0x18/4:		// SP_DMA_BUSY_REG
-			return 0;
+			ret = 0;
+			break;
 
 		case 0x1c/4:		// SP_SEMAPHORE_REG
+			//machine().scheduler().boost_interleave(attotime::from_usec(1), attotime::from_usec(1));
             if( sp_semaphore )
             {
-                return 1;
+                ret = 1;
             }
             else
             {
                 sp_semaphore = 1;
-                return 0;
+                ret = 0;
             }
+			break;
 
         case 0x20/4:        // DP_CMD_START
+        {
+        	n64_state *state = machine().driver_data<n64_state>();
+        	ret = state->m_rdp->GetStartReg();
+        	break;
+		}
+
         case 0x24/4:        // DP_CMD_END
+        {
+        	n64_state *state = machine().driver_data<n64_state>();
+        	ret = state->m_rdp->GetEndReg();
+        	break;
+		}
+
         case 0x28/4:        // DP_CMD_CURRENT
+        {
+        	n64_state *state = machine().driver_data<n64_state>();
+        	ret = state->m_rdp->GetCurrentReg();
+        	break;
+		}
+
         case 0x34/4:        // DP_CMD_BUSY
         case 0x38/4:        // DP_CMD_PIPE_BUSY
         case 0x3c/4:        // DP_CMD_TMEM_BUSY
-            return 0;
+			break;
 
         case 0x2c/4:        // DP_CMD_STATUS
-        	return 0x88;
+        {
+        	n64_state *state = machine().driver_data<n64_state>();
+        	ret = state->m_rdp->GetStatusReg();
+			break;
+		}
 
         case 0x30/4:        // DP_CMD_CLOCK
-        	return ++dp_clock;
+        {
+        	if(!(machine().driver_data<n64_state>()->m_rdp->GetStatusReg() & DP_STATUS_FREEZE))
+        	{
+				dp_clock += 13;
+				ret = dp_clock;
+			}
+			break;
+		}
 
         case 0x40000/4:     // PC
-            return cpu_get_reg(rspcpu, RSP_PC) & 0x00000fff;
+            ret = cpu_get_reg(rspcpu, RSP_PC) & 0x00000fff;
+			break;
 
         default:
             logerror("sp_reg_r: %08X at %08X\n", offset, cpu_get_pc(maincpu));
             break;
 	}
 
-	return 0;
+	//printf("%08x sp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, ret);
+	return ret;
 }
 
 READ32_DEVICE_HANDLER( n64_sp_reg_r )
@@ -568,7 +682,8 @@
 
 void n64_periphs::sp_reg_w(UINT32 offset, UINT32 data, UINT32 mem_mask)
 {
-	//printf("sp_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
+	//printf("%08x sp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(maincpu, MIPS3_PC), offset * 4, data, mem_mask);
+
 	if ((offset & 0x10000) == 0)
 	{
 		switch (offset & 0xffff)
@@ -633,6 +748,7 @@
                     if(!(oldstatus & (RSP_STATUS_BROKE | RSP_STATUS_HALT)))
                     {
                         cpu_set_reg(rspcpu, RSP_STEPCNT, 1 );
+                        device_yield(machine().device("maincpu"));
                     }
                 }
                 if (data & 0x00000080)
@@ -712,6 +828,7 @@
             }
 
 			case 0x1c/4:		// SP_SEMAPHORE_REG
+				//machine().scheduler().boost_interleave(attotime::from_usec(1), attotime::from_usec(1));
 				if(data == 0)
 				{
                 	sp_semaphore = 0;
@@ -759,60 +876,78 @@
 
 READ32_DEVICE_HANDLER( n64_dp_reg_r )
 {
-	_n64_state *state = device->machine().driver_data<_n64_state>();
-
-	//printf("%08x\n", offset);
+	n64_state *state = device->machine().driver_data<n64_state>();
+	n64_periphs *periphs = device->machine().device<n64_periphs>("rcp");
+	UINT32 ret = 0;
 	switch (offset)
 	{
 		case 0x00/4:		// DP_START_REG
-			return state->m_rdp.GetStartReg();
+			ret = state->m_rdp->GetStartReg();
+			break;
 
 		case 0x04/4:		// DP_END_REG
-			return state->m_rdp.GetEndReg();
+			ret = state->m_rdp->GetEndReg();
+			break;
 
 		case 0x08/4:		// DP_CURRENT_REG
-			return state->m_rdp.GetCurrentReg();
+			ret = state->m_rdp->GetCurrentReg();
+			break;
 
 		case 0x0c/4:		// DP_STATUS_REG
-			return state->m_rdp.GetStatusReg();
+			ret = state->m_rdp->GetStatusReg();
+			break;
+
+		case 0x10/4:		// DP_CLOCK_REG
+        {
+        	if(!(state->m_rdp->GetStatusReg() & DP_STATUS_FREEZE))
+        	{
+				periphs->dp_clock += 13;
+				ret = periphs->dp_clock;
+			}
+			break;
+		}
 
 		default:
 			logerror("dp_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(device));
 			break;
 	}
 
-	return 0;
+	//printf("%08x dp_reg_r %08x = %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, ret);
+	return ret;
 }
 
 WRITE32_DEVICE_HANDLER( n64_dp_reg_w )
 {
-	_n64_state *state = device->machine().driver_data<_n64_state>();
+	n64_state *state = device->machine().driver_data<n64_state>();
+	n64_periphs *periphs = device->machine().device<n64_periphs>("rcp");
 
-	//printf("%08x: %08x\n", offset, data);
+	//printf("%08x dp_reg_w %08x %08x %08x\n", (UINT32)cpu_get_reg(device->machine().device("rsp"), RSP_PC), offset, data, mem_mask);
 	switch (offset)
 	{
 		case 0x00/4:		// DP_START_REG
-			state->m_rdp.SetStartReg(data);
-			state->m_rdp.SetCurrentReg(state->m_rdp.GetStartReg());
+			state->m_rdp->SetStartReg(data);
+			state->m_rdp->SetCurrentReg(state->m_rdp->GetStartReg());
 			break;
 
 		case 0x04/4:		// DP_END_REG
-			state->m_rdp.SetEndReg(data);
+			//printf("dp_end_reg %08x\n", data);
+			state->m_rdp->SetEndReg(data);
 			g_profiler.start(PROFILER_USER1);
-			state->m_rdp.ProcessList();
+			state->m_rdp->ProcessList();
 			g_profiler.stop();
 			break;
 
 		case 0x0c/4:		// DP_STATUS_REG
 		{
-			UINT32 current_status = state->m_rdp.GetStatusReg();
+			UINT32 current_status = state->m_rdp->GetStatusReg();
 			if (data & 0x00000001)	current_status &= ~DP_STATUS_XBUS_DMA;
 			if (data & 0x00000002)	current_status |= DP_STATUS_XBUS_DMA;
 			if (data & 0x00000004)	current_status &= ~DP_STATUS_FREEZE;
 			if (data & 0x00000008)	current_status |= DP_STATUS_FREEZE;
 			if (data & 0x00000010)	current_status &= ~DP_STATUS_FLUSH;
-			if (data & 0x00000020)	current_status |= DP_STATUS_FLUSH;
-			state->m_rdp.SetStatusReg(current_status);
+			if (data & 0x00000020)  current_status |= DP_STATUS_FLUSH;
+			if (data & 0x00000200)  periphs->dp_clock = 0;
+			state->m_rdp->SetStatusReg(current_status);
 			break;
 		}
 
@@ -832,11 +967,21 @@
 	sp_set_status
 };
 
+static TIMER_CALLBACK(vi_scanline_callback)
+{
+	machine.device<n64_periphs>("rcp")->vi_scanline_tick();
+}
+
+void n64_periphs::vi_scanline_tick()
+{
+	signal_rcp_interrupt(VI_INTERRUPT);
+	vi_scanline_timer->adjust(machine().primary_screen->time_until_pos(vi_intr >> 1));
+}
 
 // Video Interface
 void n64_periphs::vi_recalculate_resolution()
 {
-	_n64_state *state = machine().driver_data<_n64_state>();
+	n64_state *state = machine().driver_data<n64_state>();
 
     int x_start = (vi_hstart & 0x03ff0000) >> 16;
     int x_end = vi_hstart & 0x000003ff;
@@ -844,6 +989,7 @@
     int y_end = (vi_vstart & 0x000003ff) / 2;
     int width = ((vi_xscale & 0x00000fff) * (x_end - x_start)) / 0x400;
     int height = ((vi_yscale & 0x00000fff) * (y_end - y_start)) / 0x400;
+	//printf("%04x | %02x | ", vi_xscale >> 16, vi_burst & 0x000000ff);
     rectangle visarea = machine().primary_screen->visible_area();
     attoseconds_t period = machine().primary_screen->frame_period().attoseconds;
 
@@ -867,71 +1013,88 @@
     if (height > 480)
         height = 480;
 
-	state->m_rdp.MiscState.FBHeight = height;
+	state->m_rdp->MiscState.FBHeight = height;
 
     visarea.max_x = width - 1;
     visarea.max_y = height - 1;
+    //printf("Reconfig %d, %d (%d - %d), %08x, %08x, %08x, %08x, %08x\n", width, height, x_start, x_end, vi_width, vi_xscale, vi_hsync, vi_hstart, vi_burst);
     machine().primary_screen->configure(width, 525, visarea, period);
 }
 
 READ32_MEMBER( n64_periphs::vi_reg_r )
 {
-	//printf("vi_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
 	switch (offset)
 	{
 		case 0x00/4:		// VI_CONTROL_REG
-			return vi_control;
+			ret = vi_control;
+			break;
 
 		case 0x04/4:		// VI_ORIGIN_REG
-            return vi_origin;
+            ret = vi_origin;
+			break;
 
 		case 0x08/4:		// VI_WIDTH_REG
-            return vi_width;
+            ret = vi_width;
+			break;
 
 		case 0x0c/4:
-            return vi_intr;
+            ret = vi_intr;
+			break;
 
 		case 0x10/4:		// VI_CURRENT_REG
-			return machine().primary_screen->vpos();
+			ret = machine().primary_screen->vpos() << 1;
+			break;
 
 		case 0x14/4:		// VI_BURST_REG
-            return vi_burst;
+            ret = vi_burst;
+			break;
 
 		case 0x18/4:		// VI_V_SYNC_REG
-            return vi_vsync;
+            ret = vi_vsync;
+			break;
 
 		case 0x1c/4:		// VI_H_SYNC_REG
-            return vi_hsync;
+            ret = vi_hsync;
+			break;
 
 		case 0x20/4:		// VI_LEAP_REG
-            return vi_leap;
+            ret = vi_leap;
+			break;
 
 		case 0x24/4:		// VI_H_START_REG
-            return vi_hstart;
+            ret = vi_hstart;
+			break;
 
 		case 0x28/4:		// VI_V_START_REG
-            return vi_vstart;
+            ret = vi_vstart;
+			break;
 
 		case 0x2c/4:		// VI_V_BURST_REG
-            return vi_vburst;
+            ret = vi_vburst;
+			break;
 
 		case 0x30/4:		// VI_X_SCALE_REG
-            return vi_xscale;
+            ret = vi_xscale;
+			break;
 
 		case 0x34/4:		// VI_Y_SCALE_REG
-            return vi_yscale;
+            ret = vi_yscale;
+			break;
 
 		default:
 			logerror("vi_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
 			break;
 	}
-	return 0;
+
+	//printf("vi_reg_r %08x = %08x\n", offset * 4, ret);
+	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::vi_reg_w )
 {
 	//printf("vi_reg_w %08x %08x %08x\n", offset * 4, data, mem_mask);
-	_n64_state *state = machine().driver_data<_n64_state>();
+	n64_state *state = machine().driver_data<n64_state>();
 
 	switch (offset)
 	{
@@ -950,11 +1113,12 @@
                 vi_recalculate_resolution();
 			}
             vi_width = data;
-		    state->m_rdp.MiscState.FBWidth = data;
+		    state->m_rdp->MiscState.FBWidth = data;
 			break;
 
 		case 0x0c/4:		// VI_INTR_REG
             vi_intr = data;
+			vi_scanline_timer->adjust(machine().primary_screen->time_until_pos(vi_intr >> 1));
 			break;
 
 		case 0x10/4:		// VI_CURRENT_REG
@@ -1097,7 +1261,7 @@
 
     ram = &ram[current->address/2];
 
-//  mame_printf_debug("DACDMA: %x for %x bytes\n", current->address, current->length);
+	//mame_printf_debug("DACDMA: %x for %x bytes\n", current->address, current->length);
 
     dmadac_transfer(&ai_dac[0], 2, 1, 2, current->length/4, ram);
 
@@ -1131,33 +1295,39 @@
 
 READ32_MEMBER( n64_periphs::ai_reg_r )
 {
-	//printf("ai_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
     switch (offset)
     {
         case 0x04/4:        // AI_LEN_REG
         {
             if (ai_status & 0x80000001)
             {
-                return ai_len;
+                ret = ai_len;
             }
             else if (ai_status & 0x40000000)
             {
                 double secs_left = (ai_timer->expire() - machine().time()).as_double();
                 unsigned int samples_left = secs_left * DACRATE_NTSC / (ai_dacrate + 1);
-                return samples_left * 4;
+                ret = samples_left * 4;
             }
-            else return 0;
+            else
+            {
+				ret = 0;
+			}
+			break;
         }
 
         case 0x0c/4:        // AI_STATUS_REG
-            return ai_status;
+            ret = ai_status;
+			break;
 
         default:
             logerror("ai_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
             break;
     }
 
-    return 0;
+	//printf("ai_reg_r %08x = %08x\n", offset * 4, ret);
+    return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::ai_reg_w )
@@ -1215,14 +1385,29 @@
 	UINT32 cart_addr = (pi_cart_addr & 0x0fffffff) >> 1;
 	UINT32 dram_addr = (pi_dram_addr & 0x007fffff) >> 1;
 
-    cart_addr &= ((machine().region("user2")->bytes() >> 1) - 1);
+	if((cart_addr & 0x04000000) == 0x04000000)
+	{
+		cart16 = (UINT16*)n64_sram;
+		cart_addr = (pi_cart_addr & 0x0001ffff) >> 1;
+	}
+	else if((cart_addr & 0x03000000) == 0x03000000 && dd_present)
+	{
+		cart16 = (UINT16*)machine().region("ddipl")->base();
+    	cart_addr = (pi_cart_addr & 0x003fffff) >> 1;
+	}
+	else
+	{
+    	cart_addr &= ((machine().region("user2")->bytes() >> 1) - 1);
+	}
+
+	//printf("%08x Cart, %08x Dram\n", cart_addr << 1, dram_addr << 1);
 
 	if(pi_dma_dir == 1)
 	{
 		UINT32 dma_length = pi_wr_len + 1;
-		if (dma_length & 3)
+		if (dma_length & 7)
 		{
-			dma_length = (dma_length + 3) & ~3;
+			dma_length = (dma_length + 7) & ~7;
 		}
 
 		if (pi_dram_addr != 0xffffffff)
@@ -1247,9 +1432,9 @@
 	else
 	{
 		UINT32 dma_length = pi_rd_len + 1;
-		if (dma_length & 3)
+		if (dma_length & 7)
 		{
-			dma_length = (dma_length + 3) & ~3;
+			dma_length = (dma_length + 7) & ~7;
 		}
 
 		if (pi_dram_addr != 0xffffffff)
@@ -1274,47 +1459,60 @@
 
 READ32_MEMBER( n64_periphs::pi_reg_r )
 {
-	//printf("pi_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
 	switch (offset)
 	{
 		case 0x00/4:		// PI_DRAM_ADDR_REG
-			return pi_dram_addr;
+			ret = pi_dram_addr;
+            break;
 
 		case 0x04/4:		// PI_CART_ADDR_REG
-			return pi_cart_addr;
+			ret = pi_cart_addr;
+            break;
 
 		case 0x10/4:		// PI_STATUS_REG
-			return pi_status;
+			ret = pi_status;
+            break;
 
         case 0x14/4:        // PI_BSD_DOM1_LAT
-            return pi_bsd_dom1_lat;
+            ret = pi_bsd_dom1_lat;
+            break;
 
         case 0x18/4:        // PI_BSD_DOM1_PWD
-            return pi_bsd_dom1_pwd;
+            ret = pi_bsd_dom1_pwd;
+            break;
 
         case 0x1c/4:        // PI_BSD_DOM1_PGS
-            return pi_bsd_dom1_pgs;
+            ret = pi_bsd_dom1_pgs;
+            break;
 
         case 0x20/4:        // PI_BSD_DOM1_RLS
-            return pi_bsd_dom1_rls;
+            ret = pi_bsd_dom1_rls;
+            break;
 
         case 0x24/4:        // PI_BSD_DOM2_LAT
-            return pi_bsd_dom2_lat;
+            ret = pi_bsd_dom2_lat;
+            break;
 
         case 0x28/4:        // PI_BSD_DOM2_PWD
-            return pi_bsd_dom2_pwd;
+            ret = pi_bsd_dom2_pwd;
+            break;
 
         case 0x2c/4:        // PI_BSD_DOM2_PGS
-            return pi_bsd_dom2_pgs;
+            ret = pi_bsd_dom2_pgs;
+            break;
 
         case 0x30/4:        // PI_BSD_DOM2_RLS
-            return pi_bsd_dom2_rls;
+            ret = pi_bsd_dom2_rls;
+            break;
 
 		default:
 			logerror("pi_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
 			break;
 	}
-	return 0;
+
+	//printf("pi_reg_r %08x = %08x\n", offset * 4, ret);
+	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::pi_reg_w )
@@ -1343,6 +1541,7 @@
 			attotime dma_period = attotime::from_hz(93750000) * (pi_rd_len + 1) * 3;
 			//printf("want read dma in %d\n", (pi_rd_len + 1));
 			pi_dma_timer->adjust(dma_period);
+			//pi_dma_tick();
 			break;
 		}
 
@@ -1355,6 +1554,7 @@
 			attotime dma_period = attotime::from_hz(93750000) * (pi_wr_len + 1) * 3;
 			//printf("want write dma in %d\n", (pi_wr_len + 1));
 			pi_dma_timer->adjust(dma_period);
+			//pi_dma_tick();
 			break;
 		}
 
@@ -1410,7 +1610,7 @@
 
 READ32_MEMBER( n64_periphs::ri_reg_r )
 {
-	//printf("ri_reg_r %08x\n", offset * 4);
+	//printf("ri_reg_r %08x = %08x\n", offset * 4, ri_regs[offset]);
 	if(offset > 0x1c/4)
 	{
 		logerror("ri_reg_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(maincpu));
@@ -1431,7 +1631,7 @@
 }
 
 // Serial Interface
-UINT8 n64_periphs::calc_mempack_crc(UINT8 *buffer, int length)
+UINT8 n64_periphs::calc_mempak_crc(UINT8 *buffer, int length)
 {
 	UINT32 crc = 0;
 	UINT32 temp2 = 0;
@@ -1470,6 +1670,11 @@
 	return crc;
 }
 
+INLINE UINT8 convert_to_bcd(int val)
+{
+	return ((val / 10) << 4) | (val % 10);
+}
+
 int n64_periphs::pif_channel_handle_command(int channel, int slength, UINT8 *sdata, int rlength, UINT8 *rdata)
 {
 	UINT8 command = sdata[0];
@@ -1483,21 +1688,24 @@
 				case 0:
 				case 1:
 				{
+					//printf("Read controller %d status\n", channel + 1);
 					rdata[0] = 0x05;
 					rdata[1] = 0x00;
-					rdata[2] = 0x02;
+					rdata[2] = 0x01;
 					return 0;
 				}
 				case 2:
 				case 3:
 				{
+					//printf("Read controller %d status (NC)\n", channel + 1);
 					// not connected
 					return 1;
 				}
 				case 4:
 				{
+					//printf("Read EEPROM status\n");
 					rdata[0] = 0x00;
-					rdata[1] = 0x80;
+					rdata[1] = 0xc0;
 					rdata[2] = 0x00;
 
 					return 1;
@@ -1529,6 +1737,7 @@
 				case 0: //p1 inputs
 				case 1: //p2 inputs
 				{
+					//printf("Read p%d inputs\n", channel + 1);
                     buttons = input_port_read(machine(), portnames[(channel*3) + 0]);
                     x = input_port_read(machine(), portnames[(channel*3) + 1]) - 128;
                     y = input_port_read(machine(), portnames[(channel*3) + 2]) - 128;
@@ -1542,6 +1751,7 @@
 				case 2:
 				case 3:
 				{
+					//printf("Controller %d not connected\n", channel + 1);
 					// not connected
 					return 1;
 				}
@@ -1550,39 +1760,45 @@
 			break;
 		}
 
-		case 0x02:
+		case 0x02: // Read mempak
 		{
 			UINT32 address;
 
 			address = (sdata[1] << 8) | (sdata[2]);
 			address &= ~0x1f;
 
-			if(address == 0x400)
+			//printf("Read mempak at %04x\n", address);
+
+			if(address == 0x8000)
 			{
 				for(int i = 0; i < rlength-1; i++)
 				{
 					rdata[i] = 0x00;
 				}
 
-				rdata[rlength-1] = calc_mempack_crc(rdata, rlength-1);
+				rdata[rlength-1] = calc_mempak_crc(rdata, rlength-1);
+				return 0;
 			}
 			else if(address < 0x7fe0)
 			{
 				for(int i = 0; i < rlength-1; i++)
 				{
-					rdata[i] = mempack[address+i];
+					rdata[i] = m_save_data.mempak[channel & 1][address+i];
 				}
 
-				rdata[rlength-1] = calc_mempack_crc(rdata, rlength-1);
+				rdata[rlength-1] = calc_mempak_crc(rdata, rlength-1);
+				return 0;
 			}
+
 			return 1;
 		}
-		case 0x03:
+		case 0x03: // Write mempak
 		{
 			UINT32 address = (sdata[1] << 8) | (sdata[2]);
 			address &= ~0x1f;
 
-			if (address == 0x8000)
+			//printf("Write mempak at %04x\n", address);
+			if (address >= 0x8000)
 			{
 
 			}
@@ -1590,13 +1806,13 @@
 			{
 				for(int i = 3; i < slength; i++)
 				{
-					mempack[address++] = sdata[i];
+					m_save_data.mempak[channel & 1][address++] = sdata[i];
 				}
 			}
 
-			rdata[0] = calc_mempack_crc(&sdata[3], slength-3);
+			rdata[0] = calc_mempak_crc(&sdata[3], slength-3);
 
-			return 1;
+			return 0;
 		}
 
 		case 0x04:		// Read from EEPROM
@@ -1611,14 +1827,16 @@
 				fatalerror("handle_pif: write EEPROM (bytes to send %d, bytes to receive %d)\n", slength, rlength);
 			}
 
-			UINT8 block_offset = sdata[1] * 8;
+			UINT16 block_offset = sdata[1] * 8;
+
+			//printf("Read EEPROM at %04x\n", block_offset);
 
 			for(int i=0; i < 8; i++)
 			{
-				rdata[i] = eeprom[block_offset+i];
+				rdata[i] = m_save_data.eeprom[block_offset+i];
 			}
 
-			return 1;
+			return 0;
 		}
 
 		case 0x05:		// Write to EEPROM
@@ -1633,17 +1851,62 @@
 				fatalerror("handle_pif: write EEPROM (bytes to send %d, bytes to receive %d)\n", slength, rlength);
 			}
 
-			UINT8 block_offset = sdata[1] * 8;
+			UINT16 block_offset = sdata[1] * 8;
+
+			//printf("Write EEPROM at %04x\n", block_offset);
+
 			for(int i = 0; i < 8; i++)
 			{
-				eeprom[block_offset+i] = sdata[2+i];
+				m_save_data.eeprom[block_offset+i] = sdata[2+i];
 			}
 
+			return 0;
+		}
+
+		case 0x06:		// Read RTC Status
+		{
+			//printf("Read RTC Status\n");
+			rdata[0] = 0x00;
+			rdata[1] = 0x10;
+			rdata[2] = 0x00;
+			return 0;
+		}
+
+		case 0x07:		// Read RTC Block
+		{
+			switch(sdata[1])
+			{
+				case 0:
+					//printf("Read RTC Block Header\n");
+					rdata[0] = 0x00;
+					rdata[1] = 0x02;
+					rdata[8] = 0x00;
+					return 0;
+
+				case 1:
+					return 0;
+
+				case 2:
+					system_time systime;
+					machine().base_datetime(systime);
+					rdata[0] = convert_to_bcd(systime.local_time.second); // Seconds
+					rdata[1] = convert_to_bcd(systime.local_time.minute); // Minutes
+					rdata[2] = 0x80 | convert_to_bcd(systime.local_time.hour); // Hours
+					rdata[3] = convert_to_bcd(systime.local_time.mday); // Day of month
+					rdata[4] = convert_to_bcd(systime.local_time.weekday); // Day of week
+					rdata[5] = convert_to_bcd(systime.local_time.month + 1); // Month
+					rdata[6] = convert_to_bcd(systime.local_time.year % 100); // Year
+					rdata[7] = convert_to_bcd(systime.local_time.year / 100); // Century
+					rdata[8] = 0x00;
+					//printf("Read RTC Time\n");
+					return 0;
+			}
 			return 1;
 		}
 
 		case 0xff:		// reset
 		{
+			//printf("Reset\n");
 			rdata[0] = 0xff;
 			rdata[1] = 0xff;
 			rdata[2] = 0xff;
@@ -1662,6 +1925,15 @@
 
 void n64_periphs::handle_pif()
 {
+	//printf("Before:\n");
+	/*for(int i = 0; i < 0x40; i++)
+    {
+        printf("%02x ", pif_cmd[i]);
+        if((i & 0xf) == 0xf)
+        {
+            printf("\n");
+        }
+    }*/
 	if(pif_cmd[0x3f] == 0x1)		// only handle the command if the last byte is 1
 	{
 		int channel = 0;
@@ -1670,14 +1942,17 @@
 
 		while(cmd_ptr < 0x3f && !end)
 		{
-			UINT8 bytes_to_send = pif_cmd[cmd_ptr++];
+			INT8 bytes_to_send = (INT8)pif_cmd[cmd_ptr++];
+			//printf("bytes to send: 0x%02x\n", bytes_to_send);
 
-			if (bytes_to_send == 0xfe)
+			if (bytes_to_send == -2)
 			{
 				end = 1;
+				//printf("end\n");
 			}
-			else if (bytes_to_send == 0xff)
+			else if (bytes_to_send < 0)
 			{
+				//printf("do nothing\n");
 				// do nothing
 			}
 			else
@@ -1687,7 +1962,13 @@
 					UINT8 recv_buffer[0x40];
 					UINT8 send_buffer[0x40];
 
-					UINT8 bytes_to_recv = pif_cmd[cmd_ptr++];
+					INT8 bytes_to_recv = pif_cmd[cmd_ptr++];
+					//printf("bytes to receive: 0x%02x\n", bytes_to_recv);
+
+					if (bytes_to_recv == -2)
+					{
+						break; // Hack, shouldn't need to do this
+					}
 
 					for(int j = 0; j < bytes_to_send; j++)
 					{
@@ -1695,9 +1976,11 @@
 					}
 
                     int res = pif_channel_handle_command(channel, bytes_to_send, send_buffer, bytes_to_recv, recv_buffer);
+					//printf("result: %d\n", res);
 
 					if (res == 0)
 					{
+						//printf("cmd_ptr (%d) + bytes_to_recv (%d) = %d\n", cmd_ptr, bytes_to_recv, cmd_ptr + bytes_to_recv);
 						if (cmd_ptr + bytes_to_recv > 0x3f)
 						{
 							fatalerror("cmd_ptr overflow\n");
@@ -1720,6 +2003,16 @@
 
 		pif_ram[0x3f] = 0;
 	}
+
+	/*printf("After:\n");
+    for(int i = 0; i < 0x40; i++)
+    {
+        printf("%02x ", pif_ram[i]);
+        if((i & 0xf) == 0xf)
+        {
+            printf("\n");
+        }
+    }*/
 }
 
 void n64_periphs::pif_dma(int direction)
@@ -1770,16 +2063,18 @@
 
 READ32_MEMBER( n64_periphs::si_reg_r )
 {
-	//printf("si_reg_r %08x\n", offset * 4);
+	UINT32 ret = 0;
 	switch (offset)
 	{
 		//case 0x00/4:      // SI_DRAM_ADDR_REG
 			//return si_dram_addr;
 
 		case 0x18/4:		// SI_STATUS_REG
-			return si_status;
+			ret = si_status;
 	}
-	return 0;
+
+	//printf("si_reg_r %08x = %08x\n", offset * 4, ret);
+	return ret;
 }
 
 WRITE32_MEMBER( n64_periphs::si_reg_w )
@@ -1816,6 +2111,208 @@
 	}
 }
 
+#define DD_STATUS_INTR		(1 << 25)
+
+READ32_MEMBER( n64_periphs::dd_reg_r )
+{
+	if(offset < 0x400/4)
+	{
+		return dd_buffer[offset];
+	}
+
+	if(offset < 0x480/4)
+	{
+		return dd_sector_data[(offset - 0x400/4) / 4];
+	}
+
+	if(offset < 0x500/4)
+	{
+		return dd_ram_seq_data[(offset - 0x480/4) / 4];
+	}
+
+	offset -= 0x500/4;
+
+	UINT32 ret = 0;
+	switch(offset)
+	{
+		case 0x00/4: // DD Data
+			ret = dd_data_reg;
+			break;
+
+		case 0x04/4: // ??
+			break;
+
+		case 0x08/4: // DD Status
+			ret = dd_status_reg;
+			break;
+
+		case 0x0c/4: // Current Track
+			ret = dd_track_reg;
+			break;
+
+		case 0x10/4: // Transfer Buffer Status
+			ret = dd_buf_status_reg;
+			break;
+
+		case 0x14/4: // Sector Error
+			ret = dd_sector_err_reg;
+			break;
+
+		case 0x18/4: // Sequence Status
+			ret = dd_seq_status_reg;
+			break;
+
+		case 0x1c/4: // Sequence Control
+			ret = dd_seq_ctrl_reg;
+			break;
+	}
+
+	//logerror("dd_reg_r: %08x (%08x)\n", offset << 2, ret);
+	return ret;
+}
+
+WRITE32_MEMBER( n64_periphs::dd_reg_w )
+{
+	//logerror("dd_reg_w: %08X, %08X, %08X\n", data, offset << 2, mem_mask);
+
+	if(offset < 0x400/4)
+	{
+		COMBINE_DATA(&dd_buffer[offset]);
+		return;
+	}
+
+	if(offset < 0x480/4)
+	{
+		COMBINE_DATA(&dd_sector_data[(offset - 0x400/4) / 4]);
+		return;
+	}
+
+	if(offset < 0x500/4)
+	{
+		COMBINE_DATA(&dd_ram_seq_data[(offset - 0x480/4) / 4]);
+		return;
+	}
+
+	offset -= 0x500/4;
+
+	switch(offset)
+	{
+		case 0x00/4: // DD Data
+			dd_data_reg = data;
+			break;
+
+		case 0x08/4: // DD Command
+			switch((data >> 16) & 0xff)
+			{
+				case 0x01: // Seek Read
+					logerror("dd command: Seek Read\n");
+					break;
+				case 0x02: // Seek Write
+					logerror("dd command: Seek Write\n");
+					break;
+				case 0x03: // Re-Zero / Recalibrate
+					logerror("dd command: Re-Zero\n");
+					break;
+				case 0x04: // Engage Brake
+					logerror("dd command: Engage Brake\n");
+					break;
+				case 0x05: // Start Motor
+					logerror("dd command: Start Motor\n");
+					break;
+				case 0x06: // Standby
+					logerror("dd command: Standby\n");
+					break;
+				case 0x07: // Set Sleep Mode
+					logerror("dd command: Set Sleep Mode\n");
+					break;
+				case 0x08: // Unknown
+					logerror("dd command: Unknown\n");
+					break;
+				case 0x09: // Initialize Drive(?)
+					logerror("dd command: Initialize Drive\n");
+					break;
+				case 0x0B: // Select Disk Type
+					logerror("dd command: Select Disk Type\n");
+					break;
+				case 0x0C: // ASIC Command Inquiry
+					logerror("dd command: ASIC Commadn Inquiry\n");
+					break;
+				case 0x0D: // Standby Mode (?)
+					logerror("dd command: Standby Mode(?)\n");
+					break;
+				case 0x0E: // Detect Disk Index
+					logerror("dd command: Detect Disk Index\n");
+					break;
+				case 0x0F: // Set RTC Year / Month
+					logerror("dd command: Set RTC Year / Month\n");
+					break;
+				case 0x10: // Set RTC Day / Hour
+					logerror("dd command: Set RTC Day / Hour\n");
+					break;
+				case 0x11: // Set RTC Minute / Second
+					logerror("dd command: Set RTC Minute / Second\n");
+					break;
+				case 0x12: // Read RTC Month / Year
+				{
+					logerror("dd command: Read RTC Month / Year\n");
+
+					system_time systime;
+					machine().base_datetime(systime);
+
+					dd_data_reg = (convert_to_bcd(systime.local_time.year % 100) << 24) | (convert_to_bcd(systime.local_time.month + 1) << 16);
+
+					cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ1, ASSERT_LINE);
+					dd_status_reg |= DD_STATUS_INTR;
+					break;
+				}
+
+				case 0x13: // Read RTC Hour / Day
+				{
+					logerror("dd command: Read RTC Hour / Day\n");
+
+					system_time systime;
+					machine().base_datetime(systime);
+
+					dd_data_reg = (convert_to_bcd(systime.local_time.mday) << 24) | (convert_to_bcd(systime.local_time.hour) << 16);
+
+					cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ1, ASSERT_LINE);
+					dd_status_reg |= DD_STATUS_INTR;
+					break;
+				}
+
+				case 0x14: // Read RTC Minute / Second
+				{
+					logerror("dd command: Read RTC Minute / Second\n");
+
+					system_time systime;
+					machine().base_datetime(systime);
+
+					dd_data_reg = (convert_to_bcd(systime.local_time.minute) << 24) | (convert_to_bcd(systime.local_time.second) << 16);
+
+					cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ1, ASSERT_LINE);
+					dd_status_reg |= DD_STATUS_INTR;
+					break;
+				}
+
+				case 0x1B: // Disk Inquiry
+					logerror("dd command: Disk Inquiry\n");
+					break;
+			}
+			// Do something here
+			break;
+
+		case 0x10/4: // Interrupt Clear
+			logerror("dd interrupt clear\n");
+			cputag_set_input_line(machine(), "maincpu", INPUT_LINE_IRQ1, CLEAR_LINE);
+			dd_status_reg &= ~DD_STATUS_INTR;
+			break;
+
+		case 0x1c/4: // Sequence Control
+			dd_seq_ctrl_reg = data;
+			break;
+	}
+}
+
 READ32_MEMBER( n64_periphs::pif_ram_r )
 {
     if(!space.debugger_access())
@@ -1854,11 +2351,23 @@
     signal_rcp_interrupt(SI_INTERRUPT);
 }
 
-//static UINT16 crc_seed = 0x3f;
+static void n64_machine_stop(running_machine &machine)
+{
+	n64_periphs *periphs = machine.device<n64_periphs>("rcp");
+
+	device_image_interface *image = dynamic_cast<device_image_interface *>(periphs->m_nvram_image);
+	//printf("Saving stuff\n");
+	UINT8 data[0x30800];
+	memcpy(data, n64_sram, 0x20000);
+	memcpy(data + 0x20000, periphs->m_save_data.eeprom, 0x800);
+	memcpy(data + 0x20800, periphs->m_save_data.mempak[0], 0x8000);
+	memcpy(data + 0x28800, periphs->m_save_data.mempak[1], 0x8000);
+	image->battery_save(data, 0x30800);
+}
 
 MACHINE_START( n64 )
 {
-	mips3drc_set_options(machine.device("maincpu"), MIPS3DRC_FASTEST_OPTIONS + MIPS3DRC_STRICT_VERIFY + MIPS3DRC_STRICT_COP1);
+	mips3drc_set_options(machine.device("maincpu"), MIPS3DRC_COMPATIBLE_OPTIONS);
 
 	/* configure fast RAM regions for DRC */
 	mips3drc_add_fastram(machine.device("maincpu"), 0x00000000, 0x007fffff, FALSE, rdram);
@@ -1867,6 +2376,9 @@
 	rspdrc_flush_drc_cache(machine.device("rsp"));
 	rspdrc_add_dmem(machine.device("rsp"), rsp_dmem);
 	rspdrc_add_imem(machine.device("rsp"), rsp_imem);
+
+	/* add a hook for battery save */
+	machine.add_notifier(MACHINE_NOTIFY_EXIT, machine_notify_delegate(FUNC(n64_machine_stop),&machine));
 }
 
 MACHINE_RESET( n64 )
diff -Nru src-old/mame/machine/namcos2.c src/mame/machine/namcos2.c
--- src-old/mame/machine/namcos2.c	2011-08-23 05:59:11.000000000 +0200
+++ src/mame/machine/namcos2.c	2012-02-11 11:01:01.000000000 +0100
@@ -495,7 +495,14 @@
 
 	if( bWrite )
 	{
-		pC148Reg[(addr>>13)&0x1f] = data&0x0007;
+		int reg = (addr >> 13) & 0x1f;
+
+		// If writing an IRQ priority register, clear any pending IRQs.
+		// Dirt Fox and Winning Run require this behaviour
+		if (reg < 8)
+			device_set_input_line(&space->device(), pC148Reg[reg], CLEAR_LINE);
+
+		pC148Reg[reg] = data & 0x0007;
 	}
 
 	switch(addr)
@@ -767,7 +774,7 @@
 		/* If the interrupt enable bit is set trigger an A/D IRQ */
 		if(data & 0x20)
 		{
-			generic_pulse_irq_line(space->machine().device("mcu"), HD63705_INT_ADCONV);
+			generic_pulse_irq_line(space->machine().device("mcu"), HD63705_INT_ADCONV, 1);
 		}
 	}
 }
diff -Nru src-old/mame/machine/naomigd.c src/mame/machine/naomigd.c
--- src-old/mame/machine/naomigd.c	2011-10-23 16:06:49.000000000 +0200
+++ src/mame/machine/naomigd.c	2012-02-19 02:16:43.000000000 +0100
@@ -398,7 +398,7 @@
 	const UINT8 *picdata = machine().region(pic_tag)->base();
 
 	if(picdata) {
-		if(machine().region(pic_tag)->bytes() == 0x4000) {
+		if(machine().region(pic_tag)->bytes() >= 0x4000) {
 			printf("Real PIC binary found\n");
 			for(int i=0;i<7;i++)
 				name[i] = picdata[0x7c0+i*2];
diff -Nru src-old/mame/machine/playch10.c src/mame/machine/playch10.c
--- src-old/mame/machine/playch10.c	2012-01-23 13:25:48.000000000 +0100
+++ src/mame/machine/playch10.c	2012-02-11 11:01:01.000000000 +0100
@@ -872,7 +872,7 @@
 		if (--state->m_gboard_scanline_counter == -1)
 		{
 			state->m_gboard_scanline_counter = state->m_gboard_scanline_latch;
-			generic_pulse_irq_line(device->machine().device("cart"), 0);
+			generic_pulse_irq_line(device->machine().device("cart"), 0, 1);
 		}
 	}
 }
diff -Nru src-old/mame/machine/vectrex.c src/mame/machine/vectrex.c
--- src-old/mame/machine/vectrex.c	2011-09-22 12:14:43.000000000 +0200
+++ src/mame/machine/vectrex.c	2012-02-06 02:30:22.000000000 +0100
@@ -3,7 +3,6 @@
 #include "machine/6522via.h"
 #include "cpu/m6809/m6809.h"
 #include "sound/ay8910.h"
-#include "image.h"
 
 #include "includes/vectrex.h"
 
diff -Nru src-old/mame/machine/xevious.c src/mame/machine/xevious.c
--- src-old/mame/machine/xevious.c	2011-03-29 17:31:32.000000000 +0200
+++ src/mame/machine/xevious.c	2012-02-19 02:53:16.000000000 +0100
@@ -159,10 +159,10 @@
 	if( (battles_sound_played == 0) && (data == 0xFF) ){
 		samples_device *samples = space->machine().device<samples_device>("samples");
 		if( customio[0] == 0x40 ){
-			sample_start (samples, 0, 0, 0);
+			samples->start(0, 0);
 		}
 		else{
-			sample_start (samples, 0, 1, 0);
+			samples->start(0, 1);
 		}
 	}
 	battles_sound_played = data;
diff -Nru src-old/mame/mame.c src/mame/mame.c
--- src-old/mame/mame.c	2011-11-17 11:02:55.000000000 +0100
+++ src/mame/mame.c	2012-02-19 02:53:16.000000000 +0100
@@ -8,6 +8,7 @@
     Visit http://mamedev.org for licensing and usage restrictions.
 
 ****************************************************************************/
+
 #include "emu.h"
 
 #define APPNAME					"MAME"
diff -Nru src-old/mame/mame.lst src/mame/mame.lst
--- src-old/mame/mame.lst	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/mame.lst	2012-02-19 02:23:50.000000000 +0100
@@ -79,6 +79,7 @@
 ctrpllrp		// hack
 eyes			// (c) 1982 Digitrex Techstar + "Rockola presents"
 eyes2			// (c) 1982 Techstar + "Rockola presents"
+eyesb			// bootleg
 eyeszac			// (c) 1982 Techstar / Zaccaria
 eyeszacb		// bootleg
 birdiy			// (c) 1983 Mama Top
@@ -936,7 +937,7 @@
 
 // Namco System 21 games
 winrun			// (c) 1988
-				// 1989, Winning Run Suzuka Grand Prix
+winrungp		// (c) 1989
 winrun91		// (c) 1991
 solvalou		// (c) 1991 (Japan)
 starblad		// (c) 1991
@@ -1344,6 +1345,7 @@
 blueshrk		// 742 [1978]
 invad2ct		// 851 (c) 1980 Midway
 invadpt2		// 852 [1980] Taito
+invadpt2br		// Taito do Brasil
 invaddlx		// 852 [1980] Midway
 vortex			// 852 [1980] Zilec Electronics Ltd.
 moonbase		// Taito
@@ -3227,7 +3229,8 @@
 sfiii3a			// 12/05/1999 (c) 1999 (Euro)
 sfiii3u			// 08/06/1999 (c) 1999 (USA)
 sfiii3au		// 12/05/1999 (c) 1999 (USA)
-jojoba			// 13/09/1999 (c) 1999 (Japan)
+jojoba			// 27/09/1999 (c) 1999 (Japan)
+jojobaa			// 13/09/1999 (c) 1999 (Japan)
 
 sfiiin			// 04/02/1997 (c) 1997 (Asia)
 sfiii2n			// 30/09/1997 (c) 1997 (Asia)
@@ -3235,8 +3238,10 @@
 jojoan			// 02/12/1998 (c) 1998 (Asia)
 sfiii3n			// 08/06/1999 (c) 1999 (Japan)
 sfiii3an		// 12/05/1999 (c) 1999 (Japan)
-jojoban			// 13/09/1999 (c) 1999 (Japan)
-jojobane		// 13/09/1999 (c) 1999 (Euro)
+jojoban			// 27/09/1999 (c) 1999 (Japan)
+jojobaan		// 13/09/1999 (c) 1999 (Japan)
+jojobane		// 27/09/1999 (c) 1999 (Euro)
+jojobaane		// 13/09/1999 (c) 1999 (Euro)
 
 // Capcom ZN1
 cpzn1
@@ -4461,6 +4466,7 @@
 pclub2fc		// 1997.04 Print Club 2 Felix The Cat
 groovef			// 1997.05 Groove on Fight (Atlus)
 nclubv3			// 1997.07 Name Club Ver. 3
+pclb2elk		// 1997.07 Print Club Custom
 pclub2			// 1997.09 Print Club 2
 thunt			// 1997.09 Puzzle & Action Treasure Hunt (Sega (Deniam License))
 thuntk
@@ -4517,11 +4523,9 @@
 srallycb		// 1995.02 Sega Rally Championship - Rev B
 vcop2			// 1995.09 Virtua Cop 2
 vf2			// 1995.09 Virtua Fighter 2.1
-				// 1995.10 Sky Target
+skytargt		// 1995.10 Sky Target
 manxtt			// 1995.11 Manx T.T.
-				// 1996.08 Dynamite Baseball
-doaa			// 1996.11 Dead or Alive
-				// 1997.04 Dynamite Baseball '97
+doaa			// 1996.11 Dead or Alive (Model 2A)
 motoraid		// 1997.10 Motor Raid
 zeroguna		// 1997.12 Zero Gunner
 zerogunaj		// 1997.12 Zero Gunner (Japan)
@@ -4530,13 +4534,12 @@
 pltkidsa		// 1999.03 Pilot Kids
 
 // Model 2B-CRX (SHARC, SCSP sound board)
-vstriker		// 1995.05 virtua Striker
-vstrikero		// 1995.05 virtua Striker
+vstriker		// 1995.05 Virtua Striker
+vstrikero		// 1995.05 Virtua Striker
 rchase2			// 1995.06 Rail Chase 2 (Arcade TV Game List - P.104, Left, 12 from top)
 indy500			// 1995.07 Indy 500
 indy500d		// 1995.07 Indy 500
 indy500to		// 1995.07 Indy 500
-skytargt		// 1995.10 Sky Target
 fvipers			// 1995.11 Fighting Vipers
 von			// 1996.01 Dennou Senki Virtual-On (USA)
 vonj			// 1996.01 Dennou Senki Virtual-On (Japan)
@@ -4549,7 +4552,7 @@
 sgt24h			// 1996.07 Super GT 24h
 dynabb			// 1996.08 Dynamite Baseball
 doa			// 1996.11 Dead or Alive
-				// 1997.04 Dynamite Baseball '97
+dynabb97		// 1997.04 Dynamite Baseball 97
 zerogun			// 1997.12 Zero Gunner
 zerogunj		// 1997.12 Zero Gunner (Japan)
 dyndeka2b		// 1998.05 Dynamite Deka 2
@@ -4566,7 +4569,7 @@
 topskatr		// 1997.05 Top Skater
 topskatru		// 1997.05 Top Skater (USA)
 topskatrj		// 1997.05 Top Skater (Japan)
-overrev			// 1997.09 Overrev
+overrev			// 1997.09 Over Rev
 segawski		// 1997.09 Sega Water Ski
 dynamcopc		// 1998.09 Dynamite Cop
 bel			// 1998.12 Behind Enemy Lines
@@ -4990,7 +4993,7 @@
 kingrt66		// 2002.02 The King of Route 66 (Rev A)
 initd			// 2002.03 Initial D Arcade Stage (Japan) (Rev B)
 				// 2002.06 World Club Champion Football Serie A 2001-2002
-				// 2002.07 Soul Surfer
+soulsurf		// 2002.07 Soul Surfer
 vf4evoct		// 2002.08 Virtua Fighter 4 Evolution (cartridge)
 vf4evoa			// 2002.08 Virtua Fighter 4 Evolution
 				// 2002.11 World Club Champion Football Serie A 2001-2002 Ver.1.2
@@ -5008,6 +5011,7 @@
 				// 2004.01 Initial D Arcade Stage Ver. 3 (export)
 initdv3j		// 2004.01 Initial D Arcade Stage Ver. 3 (Japan) (Rev C)
 initdv3jb		// 2004.01 Initial D Arcade Stage Ver. 3 (Japan) (Rev B)
+initdv3e		// 2004.01 Initial D Arcade Stage Ver. 3 (Export)
 				// 2004.06 World Club Champion Football Serie A 2002-2003 Ver.2
 				// 2004.07 Virtua Fighter 4 Final Tuned
 vf4tuneda		// 2004.09 Virtua Fighter 4 Final Tuned (Rev A)
@@ -5216,7 +5220,7 @@
 cppicf			// 39 1984.02 Peter Pepper's Ice Cream Factory
 cppicf2			// 39
 cfghtice		// 40 1984.04 Fighting Ice Hockey
-				// 41 1984.05 Oozumou/The Grand Sumo
+cgsumo			// 41 1984.05 Oozumou/The Grand Sumo
 				// 42 1984.08 Hellow Gateball // not a typo, this is official spelling
 				// 43 1984.08 Yellow Cab
 cbdash			// 44 1985.08 Boulder Dash
@@ -10110,6 +10114,7 @@
 vamphalf		// (c) 1999 DanBi & F2 System
 vamphalfk		// (c) 1999 DanBi & F2 System
 dquizgo2		// (c) 2000 Semicom
+dtfamily		// (c) 2001 Semicom
 toyland			// (c) 2001 Semicom
 misncrft		// (c) 2000 Sun
 mrdig			// (c) 2000 Sun
@@ -10435,6 +10440,7 @@
 finalgdr		// (c) 2001 Semicom
 mrkicker		// (c) 2001 Semicom
 wyvernwg		// (c) 2001 Semicom / Game Vision
+wyvernwga		// (c) 2001 Semicom / Game Vision
 rbmk			// (c) 1995 GMS
 go2000			// (c) 2000 SA
 mirax			// (c) 1985 Current Technologies
@@ -12058,7 +12064,7 @@
 sc2wwcl		// Wild West Club (Bellfruit)
 sc2dick		// Spotted Dick (Global)
 sc2pick		// Pick Of The Bunch (Global)
-sc2rock		// How Bigs Your Rock (Global)
+sc2rock		// How Big's Your Rock? (Global)
 sc2call		// It's Your Call (Glonal)
 sc2prom		// Along The Prom
 sc2payr		// Pay Roll (Mazooma)
@@ -13527,7 +13533,7 @@
 sc4quartk	//
 sc4quartl	//
 sc4quartm	//
-sc4qmodo	// Quazzi Mo Dough (Qps)
+sc4qmodo	// Quazzi Mo' Dough (Qps)
 sc4qmodoa	//
 sc4qmodob	//
 sc4qmodoc	//
@@ -17162,7 +17168,7 @@
 ep_xspot	// X Marks The Spot (Maygay)
 ep_braid	// Bank Raid (Unk)
 ep_bathl	// Bat Outa Hell (Global)
-ep_beavr	// Beaver Las Vegas (Global)
+ep_beavr	// Casino Beaver Las Vegas (Global)
 ep_beavra	//
 ep_bvrcl	// Beaver Las Vegas Club (Global)
 ep_bvruc	// Beaver Uncovered (Global)
@@ -17198,7 +17204,7 @@
 ep_monrt	// Money Returns Club, The (Global)
 ep_monsh	// Moonshine Club, The (Unk)
 ep_mummy	// Mummy Talks (Impulse)
-ep_pkni		// Phoenix Knights (Global)
+ep_pkni		// The Phoenix Knights (Global)
 ep_redl		// Red Line (Unk)
 ep_rchik	// Rich Chics Club (Unk)
 ep_royrc	// Royal Roulette Club (Unk)
@@ -17215,7 +17221,7 @@
 ep_utncl	// Utter Nutter Club (Global)
 ep_wleek	// Weakest Leek Club (Global)
 ep_wud		// What's Up Doc (Global)
-ep_milhr	// Who Wants To Be A Millionhare (Global)
+ep_milhr	// Who Wants To Be A Millionhare? (Global)
 ep_mlhrc	// Who Whats To Be A Millionhare Club (Global)
 ep_wf		// Wildfire (Global)
 ep_bbars	// Balloon Bars (Maygay)
@@ -18697,6 +18703,7 @@
 pr_medl			// Medalist (Project)
 pr_megmn		// Mega Money (Project)
 pr_nudxs		// Nudge XS (Project)
+pr_qksht		// Quickshot (Maygay)
 pr_rags			// Rags To Riches (Project)
 pr_reflx		// Reflex (Project)
 pr_roadr		// Road Riot (Project)
@@ -18998,11 +19005,11 @@
 hb_gldwn	// Golden Winner (Fairgames)
 hb_jailb	// Jail Break (Qps)
 hb_jkrwl	// Jokers Wild (Fairgames)
-hb_mrmon	// Mr Money (Qps)
+hb_mrmon	// Mr. Money (Qps)
 hb_rhv		// Red Hot Voucher (Qps)
 hb_ringb	// Ring A Bell (Jpm)
 hb_rckrl	// Rock 'n' Roll (Qps)
-hb_ydd		// Yabba Dabba Dough (Qps)
+hb_ydd		// Yabba-Dabba-Dough (Qps)
 
 /* Summit Coin */
 
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/mame.mak	2012-02-11 17:05:10.000000000 +0100
@@ -1278,7 +1278,7 @@
 	$(VIDEO)/sei_crtc.o \
 
 $(MAMEOBJ)/seta.a: \
-	$(DRIVERS)/aleck64.o $(MACHINE)/n64.o $(VIDEO)/n64.o $(VIDEO)/rdpblend.o $(VIDEO)/rdpfb.o $(VIDEO)/rdpspn16.o $(VIDEO)/rdptpipe.o \
+	$(DRIVERS)/aleck64.o $(MACHINE)/n64.o $(VIDEO)/n64.o $(VIDEO)/rdpblend.o $(VIDEO)/rdpspn16.o $(VIDEO)/rdptpipe.o \
 	$(DRIVERS)/darkhors.o \
 	$(DRIVERS)/hanaawas.o $(VIDEO)/hanaawas.o \
 	$(DRIVERS)/macs.o \
@@ -1997,6 +1997,8 @@
 
 $(DRIVERS)/kingdrby.o:	$(LAYOUT)/kingdrby.lh
 
+$(DRIVERS)/kungfur.o:	$(LAYOUT)/kungfur.lh
+
 $(DRIVERS)/lazercmd.o:	$(LAYOUT)/lazercmd.lh
 
 $(DRIVERS)/luckgrln.o:	$(LAYOUT)/luckgrln.lh
diff -Nru src-old/mame/video/artmagic.c src/mame/video/artmagic.c
--- src-old/mame/video/artmagic.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/artmagic.c	2012-02-06 02:30:22.000000000 +0100
@@ -5,7 +5,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "cpu/tms34010/tms34010.h"
 #include "video/tlc34076.h"
 #include "includes/artmagic.h"
diff -Nru src-old/mame/video/buggychl.c src/mame/video/buggychl.c
--- src-old/mame/video/buggychl.c	2012-01-15 02:13:13.000000000 +0100
+++ src/mame/video/buggychl.c	2012-02-06 02:30:22.000000000 +0100
@@ -1,5 +1,4 @@
 #include "emu.h"
-#include "profiler.h"
 #include "includes/buggychl.h"
 
 
diff -Nru src-old/mame/video/dc.c src/mame/video/dc.c
--- src-old/mame/video/dc.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/video/dc.c	2012-02-06 02:30:22.000000000 +0100
@@ -8,7 +8,6 @@
 #include "cpu/sh4/sh4.h"
 #include "render.h"
 #include "rendutil.h"
-#include "profiler.h"
 #include "video/rgbutil.h"
 
 #define DEBUG_FIFO_POLY (0)
diff -Nru src-old/mame/video/itech32.c src/mame/video/itech32.c
--- src-old/mame/video/itech32.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/video/itech32.c	2012-02-06 02:30:22.000000000 +0100
@@ -6,7 +6,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "cpu/m68000/m68000.h"
 #include "includes/itech32.h"
 
diff -Nru src-old/mame/video/jaguar.c src/mame/video/jaguar.c
--- src-old/mame/video/jaguar.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/video/jaguar.c	2012-02-06 02:30:22.000000000 +0100
@@ -136,7 +136,6 @@
 
 #include "emu.h"
 #include "memconv.h"
-#include "profiler.h"
 #include "machine/atarigen.h"
 #include "cpu/mips/r3000.h"
 #include "cpu/m68000/m68000.h"
diff -Nru src-old/mame/video/mcatadv.c src/mame/video/mcatadv.c
--- src-old/mame/video/mcatadv.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/mcatadv.c	2012-02-06 02:30:22.000000000 +0100
@@ -11,7 +11,6 @@
 */
 
 #include "emu.h"
-#include "profiler.h"
 #include "includes/mcatadv.h"
 
 static TILE_GET_INFO( get_mcatadv_tile_info1 )
diff -Nru src-old/mame/video/midtunit.c src/mame/video/midtunit.c
--- src-old/mame/video/midtunit.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/midtunit.c	2012-02-06 02:30:22.000000000 +0100
@@ -5,7 +5,6 @@
 **************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "cpu/tms34010/tms34010.h"
 #include "includes/midtunit.h"
 
diff -Nru src-old/mame/video/midyunit.c src/mame/video/midyunit.c
--- src-old/mame/video/midyunit.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/midyunit.c	2012-02-06 02:30:22.000000000 +0100
@@ -5,7 +5,6 @@
 **************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "cpu/tms34010/tms34010.h"
 #include "includes/midyunit.h"
 
diff -Nru src-old/mame/video/n64.c src/mame/video/n64.c
--- src-old/mame/video/n64.c	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/video/n64.c	2012-02-19 16:23:23.000000000 +0100
@@ -31,29 +31,45 @@
 
 static FILE *rdp_exec;
 
+bool n64_rdp::rdp_range_check(UINT32 addr)
+{
+	if(MiscState.FBSize == 0) return false;
+
+	int fbcount = ((MiscState.FBWidth * Scissor.m_yl) << (MiscState.FBSize - 1)) * 3;
+	int zbcount = MiscState.FBWidth * Scissor.m_yl * 2;
+	int fbaddr = MiscState.FBAddress & 0x007fffff;
+	int zbaddr = MiscState.ZBAddress & 0x007fffff;
+	if ((addr >= fbaddr) && (addr < (fbaddr + fbcount)))
+	{
+		return false;
+	}
+	if ((addr >= zbaddr) && (addr < (zbaddr + zbcount)))
+	{
+		return false;
+	}
+
+	printf("Check failed: %08x vs. %08x-%08x, %08x-%08x (%d, %d)\n", addr, fbaddr, fbaddr + fbcount, zbaddr, zbaddr + zbcount, MiscState.FBWidth, Scissor.m_yl);
+	fflush(stdout);
+	return true;
+}
+
 /*****************************************************************************/
 
 // The functions in this file should be moved into the parent Processor class.
 #include "rdpfiltr.c"
 
-namespace N64
-{
-
-namespace RDP
-{
-
-void Processor::GetAlphaCvg(UINT8 *comb_alpha)
+void n64_rdp::GetAlphaCvg(UINT8 *comb_alpha, rdp_span_aux *userdata, const rdp_poly_state &object)
 {
 	INT32 temp = *comb_alpha;
-	INT32 temp2 = MiscState.CurrentPixCvg;
+	INT32 temp2 = userdata->CurrentPixCvg;
 	INT32 temp3 = 0;
 
-	if (OtherModes.cvg_times_alpha)
+	if (object.OtherModes.cvg_times_alpha)
 	{
 		temp3 = (temp * temp2) + 4;
-		MiscState.CurrentPixCvg = (temp3 >> 8) & 0xf;
+		userdata->CurrentPixCvg = (temp3 >> 8) & 0xf;
 	}
-	if (OtherModes.alpha_cvg_select)
+	if (object.OtherModes.alpha_cvg_select)
 	{
 		temp = (OtherModes.cvg_times_alpha) ? (temp3 >> 3) : (temp2 << 5);
 	}
@@ -66,7 +82,7 @@
 
 /*****************************************************************************/
 
-void Processor::VideoUpdate(n64_periphs *n64, bitmap_rgb32 &bitmap)
+void n64_rdp::VideoUpdate(n64_periphs *n64, bitmap_rgb32 &bitmap)
 {
 	switch(n64->vi_control & 0x3)
 	{
@@ -84,7 +100,7 @@
 	}
 }
 
-void Processor::VideoUpdate16(n64_periphs *n64, bitmap_rgb32 &bitmap)
+void n64_rdp::VideoUpdate16(n64_periphs *n64, bitmap_rgb32 &bitmap)
 {
     //int fsaa = (((n64->vi_control >> 8) & 3) < 2);
     //int divot = (n64->vi_control >> 4) & 1;
@@ -95,8 +111,8 @@
     //int vibuffering = ((n64->vi_control & 2) && fsaa && divot);
 
 	UINT16 *frame_buffer = (UINT16*)&rdram[(n64->vi_origin & 0xffffff) >> 2];
-	UINT32 hb = ((n64->vi_origin & 0xffffff) >> 2) >> 1;
-	UINT8* hidden_buffer = &HiddenBits[hb];
+	//UINT32 hb = ((n64->vi_origin & 0xffffff) >> 2) >> 1;
+	//UINT8* hidden_buffer = &HiddenBits[hb];
 
 	INT32 hdiff = (n64->vi_hstart & 0x3ff) - ((n64->vi_hstart >> 16) & 0x3ff);
 	float hcoeff = ((float)(n64->vi_xscale & 0xfff) / (1 << 10));
@@ -123,7 +139,7 @@
         vres = bitmap.height();
     }
 
-	UINT32 pixels = 0;
+    UINT32 pixels = 0;
 
 	if (frame_buffer)
 	{
@@ -137,7 +153,7 @@
 				//int r, g, b;
 
 				UINT16 pix = frame_buffer[pixels ^ WORD_ADDR_XOR];
-				MiscState.CurrentPixCvg = ((pix & 1) << 2) | (hidden_buffer[pixels ^ BYTE_ADDR_XOR] & 3);
+				//MiscState.CurrentPixCvg = ((pix & 1) << 2) | (hidden_buffer[pixels ^ BYTE_ADDR_XOR] & 3);
 
 				//if(divot)
 				//{
@@ -223,7 +239,7 @@
 	}
 }
 
-void Processor::VideoUpdate32(n64_periphs *n64, bitmap_rgb32 &bitmap)
+void n64_rdp::VideoUpdate32(n64_periphs *n64, bitmap_rgb32 &bitmap)
 {
     int gamma = (n64->vi_control >> 3) & 1;
     int gamma_dither = (n64->vi_control >> 2) & 1;
@@ -306,13 +322,13 @@
 
 /*****************************************************************************/
 
-void Processor::TCDivNoPersp(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst)
+void n64_rdp::TCDivNoPersp(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst)
 {
 	*sss = (SIGN16(ss)) & 0x1ffff;
 	*sst = (SIGN16(st)) & 0x1ffff;
 }
 
-void Processor::TCDiv(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst)
+void n64_rdp::TCDiv(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst)
 {
 	int w_carry = 0;
 	if ((sw & 0x8000) || !(sw & 0x7fff))
@@ -337,14 +353,14 @@
 
 	int sprod = SIGN16(ss) * tlu_rcp;
 	int tprod = SIGN16(st) * tlu_rcp;
-	int tempmask = ((1 << (shift + 1)) - 1) << (29 - shift);//tc.c,658
-	int shift_value = 13 - shift;//tc.c,653
+	int tempmask = ((1 << (shift + 1)) - 1) << (29 - shift);
+	int shift_value = 13 - shift;
 
-	int outofbounds_s = sprod & tempmask;//tc.c, 661
+	int outofbounds_s = sprod & tempmask;
 	int outofbounds_t = tprod & tempmask;
-	if (shift == 0xe)//tc.c, 664
+	if (shift == 0xe)
 	{
-		*sss = sprod << 1;//sw, tw ????? ?? ??????????
+		*sss = sprod << 1;
 		*sst = tprod << 1;
 	}
 	else
@@ -389,7 +405,7 @@
 	*sst = (*sst & 0x1ffff) | (over_s << 18) | (under_s << 17);
 }
 
-INT32 Processor::ColorCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d)
+INT32 n64_rdp::ColorCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d)
 {
 	a = KURT_AKELEY_SIGN9(a);
 	b = KURT_AKELEY_SIGN9(b);
@@ -401,7 +417,7 @@
 	return a;
 }
 
-INT32 Processor::AlphaCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d)
+INT32 n64_rdp::AlphaCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d)
 {
 	a = KURT_AKELEY_SIGN9(a);
 	b = KURT_AKELEY_SIGN9(b);
@@ -413,57 +429,69 @@
 	return a;
 }
 
-void Processor::ColorCombiner1Cycle(bool noisecompute)
+void n64_rdp::ColorCombiner1Cycle(rdp_span_aux *userdata)
 {
-	if (noisecompute)
-	{
-		NoiseColor.i.r = NoiseColor.i.g = NoiseColor.i.b = machine().rand() & 0xff; // Not accurate...
-	}
+	userdata->NoiseColor.i.r = userdata->NoiseColor.i.g = userdata->NoiseColor.i.b = GetRandom() << 3; // Not accurate
 
-	PixelColor.i.r = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_r[1],*ColorInputs.combiner_rgbsub_b_r[1],*ColorInputs.combiner_rgbmul_r[1],*ColorInputs.combiner_rgbadd_r[1]);
-	PixelColor.i.g = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_g[1],*ColorInputs.combiner_rgbsub_b_g[1],*ColorInputs.combiner_rgbmul_g[1],*ColorInputs.combiner_rgbadd_g[1]);
-	PixelColor.i.b = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_b[1],*ColorInputs.combiner_rgbsub_b_b[1],*ColorInputs.combiner_rgbmul_b[1],*ColorInputs.combiner_rgbadd_b[1]);
-	PixelColor.i.a = AlphaCombinerEquation(*ColorInputs.combiner_alphasub_a[1],*ColorInputs.combiner_alphasub_b[1],*ColorInputs.combiner_alphamul[1],*ColorInputs.combiner_alphaadd[1]);
-
-	//Alpha coverage combiner
-	GetAlphaCvg(&PixelColor.i.a);
+	userdata->PixelColor.i.r = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_r[1],*userdata->ColorInputs.combiner_rgbsub_b_r[1],*userdata->ColorInputs.combiner_rgbmul_r[1],*userdata->ColorInputs.combiner_rgbadd_r[1]);
+	userdata->PixelColor.i.g = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_g[1],*userdata->ColorInputs.combiner_rgbsub_b_g[1],*userdata->ColorInputs.combiner_rgbmul_g[1],*userdata->ColorInputs.combiner_rgbadd_g[1]);
+	userdata->PixelColor.i.b = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_b[1],*userdata->ColorInputs.combiner_rgbsub_b_b[1],*userdata->ColorInputs.combiner_rgbmul_b[1],*userdata->ColorInputs.combiner_rgbadd_b[1]);
+	userdata->PixelColor.i.a = AlphaCombinerEquation(*userdata->ColorInputs.combiner_alphasub_a[1],*userdata->ColorInputs.combiner_alphasub_b[1],*userdata->ColorInputs.combiner_alphamul[1],*userdata->ColorInputs.combiner_alphaadd[1]);
+}
+
+void n64_rdp::ColorCombiner2Cycle(rdp_span_aux *userdata)
+{
+	userdata->NoiseColor.i.r = userdata->NoiseColor.i.g = userdata->NoiseColor.i.b = GetRandom() << 3; // Not accurate
+	userdata->CombinedColor.i.r = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_r[0],
+														*userdata->ColorInputs.combiner_rgbsub_b_r[0],
+														*userdata->ColorInputs.combiner_rgbmul_r[0],
+														*userdata->ColorInputs.combiner_rgbadd_r[0]);
+	userdata->CombinedColor.i.g = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_g[0],
+														*userdata->ColorInputs.combiner_rgbsub_b_g[0],
+														*userdata->ColorInputs.combiner_rgbmul_g[0],
+														*userdata->ColorInputs.combiner_rgbadd_g[0]);
+	userdata->CombinedColor.i.b = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_b[0],
+														*userdata->ColorInputs.combiner_rgbsub_b_b[0],
+														*userdata->ColorInputs.combiner_rgbmul_b[0],
+														*userdata->ColorInputs.combiner_rgbadd_b[0]);
+	userdata->CombinedColor.i.a = AlphaCombinerEquation(*userdata->ColorInputs.combiner_alphasub_a[0],
+														*userdata->ColorInputs.combiner_alphasub_b[0],
+														*userdata->ColorInputs.combiner_alphamul[0],
+														*userdata->ColorInputs.combiner_alphaadd[0]);
+
+	userdata->Texel0Color = userdata->Texel1Color;
+	userdata->Texel1Color = userdata->NextTexelColor;
+
+	userdata->PixelColor.i.r = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_r[1],
+													 *userdata->ColorInputs.combiner_rgbsub_b_r[1],
+													 *userdata->ColorInputs.combiner_rgbmul_r[1],
+													 *userdata->ColorInputs.combiner_rgbadd_r[1]);
+	userdata->PixelColor.i.g = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_g[1],
+													 *userdata->ColorInputs.combiner_rgbsub_b_g[1],
+													 *userdata->ColorInputs.combiner_rgbmul_g[1],
+													 *userdata->ColorInputs.combiner_rgbadd_g[1]);
+	userdata->PixelColor.i.b = ColorCombinerEquation(*userdata->ColorInputs.combiner_rgbsub_a_b[1],
+													 *userdata->ColorInputs.combiner_rgbsub_b_b[1],
+													 *userdata->ColorInputs.combiner_rgbmul_b[1],
+													 *userdata->ColorInputs.combiner_rgbadd_b[1]);
+	userdata->PixelColor.i.a = AlphaCombinerEquation(*userdata->ColorInputs.combiner_alphasub_a[1],
+													 *userdata->ColorInputs.combiner_alphasub_b[1],
+													 *userdata->ColorInputs.combiner_alphamul[1],
+													 *userdata->ColorInputs.combiner_alphaadd[1]);
 }
 
-void Processor::ColorCombiner2Cycle(bool noisecompute)
-{
-	if (noisecompute)
-	{
-		NoiseColor.i.r = NoiseColor.i.g = NoiseColor.i.b = machine().rand() & 0xff; // HACK
-	}
-
-	CombinedColor.i.r = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_r[0],*ColorInputs.combiner_rgbsub_b_r[0],*ColorInputs.combiner_rgbmul_r[0],*ColorInputs.combiner_rgbadd_r[0]);
-	CombinedColor.i.g = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_g[0],*ColorInputs.combiner_rgbsub_b_g[0],*ColorInputs.combiner_rgbmul_g[0],*ColorInputs.combiner_rgbadd_g[0]);
-	CombinedColor.i.b = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_b[0],*ColorInputs.combiner_rgbsub_b_b[0],*ColorInputs.combiner_rgbmul_b[0],*ColorInputs.combiner_rgbadd_b[0]);
-	CombinedColor.i.a = AlphaCombinerEquation(*ColorInputs.combiner_alphasub_a[0],*ColorInputs.combiner_alphasub_b[0],*ColorInputs.combiner_alphamul[0],*ColorInputs.combiner_alphaadd[0]);
-
-	Texel0Color = Texel1Color;
-	Texel1Color = NextTexelColor;
-
-	PixelColor.i.r = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_r[1],*ColorInputs.combiner_rgbsub_b_r[1],*ColorInputs.combiner_rgbmul_r[1],*ColorInputs.combiner_rgbadd_r[1]);
-	PixelColor.i.g = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_g[1],*ColorInputs.combiner_rgbsub_b_g[1],*ColorInputs.combiner_rgbmul_g[1],*ColorInputs.combiner_rgbadd_g[1]);
-	PixelColor.i.b = ColorCombinerEquation(*ColorInputs.combiner_rgbsub_a_b[1],*ColorInputs.combiner_rgbsub_b_b[1],*ColorInputs.combiner_rgbmul_b[1],*ColorInputs.combiner_rgbadd_b[1]);
-	PixelColor.i.a = AlphaCombinerEquation(*ColorInputs.combiner_alphasub_a[1],*ColorInputs.combiner_alphasub_b[1],*ColorInputs.combiner_alphamul[1],*ColorInputs.combiner_alphaadd[1]);
-
-	GetAlphaCvg(&PixelColor.i.a);
-}
-
-void Processor::SetSubAInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code)
+void n64_rdp::SetSubAInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0xf)
 	{
-		case 0:		*input_r = &CombinedColor.i.r;	*input_g = &CombinedColor.i.g;	*input_b = &CombinedColor.i.b;	break;
-		case 1:		*input_r = &Texel0Color.i.r;	*input_g = &Texel0Color.i.g;	*input_b = &Texel0Color.i.b;	break;
-		case 2:		*input_r = &Texel1Color.i.r;	*input_g = &Texel1Color.i.g;	*input_b = &Texel1Color.i.b;	break;
-		case 3:		*input_r = &PrimColor.i.r;		*input_g = &PrimColor.i.g;		*input_b = &PrimColor.i.b;		break;
-		case 4:		*input_r = &ShadeColor.i.r;		*input_g = &ShadeColor.i.g;		*input_b = &ShadeColor.i.b;		break;
-		case 5:		*input_r = &EnvColor.i.r;		*input_g = &EnvColor.i.g;		*input_b = &EnvColor.i.b;		break;
-		case 6:		*input_r = &OneColor.i.r;		*input_g = &OneColor.i.g;		*input_b = &OneColor.i.b;		break;
-		case 7:		*input_r = &NoiseColor.i.r;		*input_g = &NoiseColor.i.g;		*input_b = &NoiseColor.i.b;		break;
+		case 0:		*input_r = &userdata->CombinedColor.i.r;	*input_g = &userdata->CombinedColor.i.g;	*input_b = &userdata->CombinedColor.i.b;	break;
+		case 1:		*input_r = &userdata->Texel0Color.i.r;		*input_g = &userdata->Texel0Color.i.g;		*input_b = &userdata->Texel0Color.i.b;		break;
+		case 2:		*input_r = &userdata->Texel1Color.i.r;		*input_g = &userdata->Texel1Color.i.g;		*input_b = &userdata->Texel1Color.i.b;		break;
+		case 3:		*input_r = &userdata->PrimColor.i.r;		*input_g = &userdata->PrimColor.i.g;		*input_b = &userdata->PrimColor.i.b;		break;
+		case 4:		*input_r = &userdata->ShadeColor.i.r;		*input_g = &userdata->ShadeColor.i.g;		*input_b = &userdata->ShadeColor.i.b;		break;
+		case 5:		*input_r = &userdata->EnvColor.i.r;			*input_g = &userdata->EnvColor.i.g;			*input_b = &userdata->EnvColor.i.b;			break;
+		case 6:		*input_r = &OneColor.i.r;					*input_g = &OneColor.i.g;					*input_b = &OneColor.i.b;					break;
+		case 7:		*input_r = &userdata->NoiseColor.i.r;		*input_g = &userdata->NoiseColor.i.g;		*input_b = &userdata->NoiseColor.i.b;		break;
 		case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15:
 		{
 					*input_r = &ZeroColor.i.r;		*input_g = &ZeroColor.i.g;		*input_b = &ZeroColor.i.b;		break;
@@ -471,16 +499,16 @@
 	}
 }
 
-void Processor::SetSubBInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code)
+void n64_rdp::SetSubBInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0xf)
 	{
-		case 0:		*input_r = &CombinedColor.i.r;	*input_g = &CombinedColor.i.g;	*input_b = &CombinedColor.i.b;	break;
-		case 1:		*input_r = &Texel0Color.i.r;	*input_g = &Texel0Color.i.g;	*input_b = &Texel0Color.i.b;	break;
-		case 2:		*input_r = &Texel1Color.i.r;	*input_g = &Texel1Color.i.g;	*input_b = &Texel1Color.i.b;	break;
-		case 3:		*input_r = &PrimColor.i.r;		*input_g = &PrimColor.i.g;		*input_b = &PrimColor.i.b;		break;
-		case 4:		*input_r = &ShadeColor.i.r;		*input_g = &ShadeColor.i.g;		*input_b = &ShadeColor.i.b;		break;
-		case 5:		*input_r = &EnvColor.i.r;		*input_g = &EnvColor.i.g;		*input_b = &EnvColor.i.b;		break;
+		case 0:		*input_r = &userdata->CombinedColor.i.r;	*input_g = &userdata->CombinedColor.i.g;	*input_b = &userdata->CombinedColor.i.b;	break;
+		case 1:		*input_r = &userdata->Texel0Color.i.r;		*input_g = &userdata->Texel0Color.i.g;		*input_b = &userdata->Texel0Color.i.b;		break;
+		case 2:		*input_r = &userdata->Texel1Color.i.r;		*input_g = &userdata->Texel1Color.i.g;		*input_b = &userdata->Texel1Color.i.b;		break;
+		case 3:		*input_r = &userdata->PrimColor.i.r;		*input_g = &userdata->PrimColor.i.g;		*input_b = &userdata->PrimColor.i.b;		break;
+		case 4:		*input_r = &userdata->ShadeColor.i.r;		*input_g = &userdata->ShadeColor.i.g;		*input_b = &userdata->ShadeColor.i.b;		break;
+		case 5:		*input_r = &userdata->EnvColor.i.r;			*input_g = &userdata->EnvColor.i.g;			*input_b = &userdata->EnvColor.i.b;			break;
 		case 6:		fatalerror("SET_SUBB_RGB_INPUT: key_center\n");	break;
 		case 7:		*input_r = (UINT8*)&m_k4;		*input_g = (UINT8*)&m_k4;		*input_b = (UINT8*)&m_k4;		break;
 		case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15:
@@ -490,26 +518,26 @@
 	}
 }
 
-void Processor::SetMulInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code)
+void n64_rdp::SetMulInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0x1f)
 	{
-		case 0:		*input_r = &CombinedColor.i.r;	*input_g = &CombinedColor.i.g;	*input_b = &CombinedColor.i.b;	break;
-		case 1:		*input_r = &Texel0Color.i.r;	*input_g = &Texel0Color.i.g;	*input_b = &Texel0Color.i.b;	break;
-		case 2:		*input_r = &Texel1Color.i.r;	*input_g = &Texel1Color.i.g;	*input_b = &Texel1Color.i.b;	break;
-		case 3:		*input_r = &PrimColor.i.r;		*input_g = &PrimColor.i.g;		*input_b = &PrimColor.i.b;		break;
-		case 4:		*input_r = &ShadeColor.i.r;		*input_g = &ShadeColor.i.g;		*input_b = &ShadeColor.i.b;		break;
-		case 5:		*input_r = &EnvColor.i.r;		*input_g = &EnvColor.i.g;		*input_b = &EnvColor.i.b;		break;
-		case 6:		*input_r = &KeyScale.i.r;		*input_g = &KeyScale.i.g;		*input_b = &KeyScale.i.b;		break;
-		case 7:		*input_r = &CombinedColor.i.a;	*input_g = &CombinedColor.i.a;	*input_b = &CombinedColor.i.a;	break;
-		case 8:		*input_r = &Texel0Color.i.a;	*input_g = &Texel0Color.i.a;		*input_b = &Texel0Color.i.a;	break;
-		case 9:		*input_r = &Texel1Color.i.a;	*input_g = &Texel1Color.i.a;		*input_b = &Texel1Color.i.a;	break;
-		case 10:	*input_r = &PrimColor.i.a;		*input_g = &PrimColor.i.a;		*input_b = &PrimColor.i.a;		break;
-		case 11:	*input_r = &ShadeColor.i.a;		*input_g = &ShadeColor.i.a;		*input_b = &ShadeColor.i.a;		break;
-		case 12:	*input_r = &EnvColor.i.a;		*input_g = &EnvColor.i.a;		*input_b = &EnvColor.i.a;		break;
-		case 13:	*input_r = &LODFraction;				*input_g = &LODFraction;				*input_b = &LODFraction;				break;
-		case 14:	*input_r = &PrimLODFraction;		*input_g = &PrimLODFraction;		*input_b = &PrimLODFraction;		break;
-		case 15:	*input_r = (UINT8*)&m_k5;			*input_g = (UINT8*)&m_k5;			*input_b = (UINT8*)&m_k5;			break;
+		case 0:		*input_r = &userdata->CombinedColor.i.r;	*input_g = &userdata->CombinedColor.i.g;	*input_b = &userdata->CombinedColor.i.b;	break;
+		case 1:		*input_r = &userdata->Texel0Color.i.r;		*input_g = &userdata->Texel0Color.i.g;		*input_b = &userdata->Texel0Color.i.b;		break;
+		case 2:		*input_r = &userdata->Texel1Color.i.r;		*input_g = &userdata->Texel1Color.i.g;		*input_b = &userdata->Texel1Color.i.b;		break;
+		case 3:		*input_r = &userdata->PrimColor.i.r;		*input_g = &userdata->PrimColor.i.g;		*input_b = &userdata->PrimColor.i.b;		break;
+		case 4:		*input_r = &userdata->ShadeColor.i.r;		*input_g = &userdata->ShadeColor.i.g;		*input_b = &userdata->ShadeColor.i.b;		break;
+		case 5:		*input_r = &userdata->EnvColor.i.r;			*input_g = &userdata->EnvColor.i.g;			*input_b = &userdata->EnvColor.i.b;			break;
+		case 6:		*input_r = &userdata->KeyScale.i.r;			*input_g = &userdata->KeyScale.i.g;			*input_b = &userdata->KeyScale.i.b;			break;
+		case 7:		*input_r = &userdata->CombinedColor.i.a;	*input_g = &userdata->CombinedColor.i.a;	*input_b = &userdata->CombinedColor.i.a;	break;
+		case 8:		*input_r = &userdata->Texel0Color.i.a;		*input_g = &userdata->Texel0Color.i.a;		*input_b = &userdata->Texel0Color.i.a;		break;
+		case 9:		*input_r = &userdata->Texel1Color.i.a;		*input_g = &userdata->Texel1Color.i.a;		*input_b = &userdata->Texel1Color.i.a;		break;
+		case 10:	*input_r = &userdata->PrimColor.i.a;		*input_g = &userdata->PrimColor.i.a;		*input_b = &userdata->PrimColor.i.a;		break;
+		case 11:	*input_r = &userdata->ShadeColor.i.a;		*input_g = &userdata->ShadeColor.i.a;		*input_b = &userdata->ShadeColor.i.a;		break;
+		case 12:	*input_r = &userdata->EnvColor.i.a;			*input_g = &userdata->EnvColor.i.a;			*input_b = &userdata->EnvColor.i.a;			break;
+		case 13:	*input_r = &userdata->LODFraction;			*input_g = &userdata->LODFraction;			*input_b = &userdata->LODFraction;			break;
+		case 14:	*input_r = &userdata->PrimLODFraction;		*input_g = &userdata->PrimLODFraction;		*input_b = &userdata->PrimLODFraction;		break;
+		case 15:	*input_r = (UINT8*)&m_k5;					*input_g = (UINT8*)&m_k5;					*input_b = (UINT8*)&m_k5;					break;
 		case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23:
 		case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31:
 		{
@@ -518,52 +546,52 @@
 	}
 }
 
-void Processor::SetAddInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code)
+void n64_rdp::SetAddInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0x7)
 	{
-		case 0:		*input_r = &CombinedColor.i.r;	*input_g = &CombinedColor.i.g;	*input_b = &CombinedColor.i.b;	break;
-		case 1:		*input_r = &Texel0Color.i.r;		*input_g = &Texel0Color.i.g;		*input_b = &Texel0Color.i.b;		break;
-		case 2:		*input_r = &Texel1Color.i.r;		*input_g = &Texel1Color.i.g;		*input_b = &Texel1Color.i.b;		break;
-		case 3:		*input_r = &PrimColor.i.r;		*input_g = &PrimColor.i.g;		*input_b = &PrimColor.i.b;		break;
-		case 4:		*input_r = &ShadeColor.i.r;		*input_g = &ShadeColor.i.g;		*input_b = &ShadeColor.i.b;		break;
-		case 5:		*input_r = &EnvColor.i.r;		*input_g = &EnvColor.i.g;		*input_b = &EnvColor.i.b;		break;
-		case 6:		*input_r = &OneColor.i.r;		*input_g = &OneColor.i.g;		*input_b = &OneColor.i.b;		break;
-		case 7:		*input_r = &ZeroColor.i.r;		*input_g = &ZeroColor.i.g;		*input_b = &ZeroColor.i.b;		break;
+		case 0:		*input_r = &userdata->CombinedColor.i.r;	*input_g = &userdata->CombinedColor.i.g;	*input_b = &userdata->CombinedColor.i.b;	break;
+		case 1:		*input_r = &userdata->Texel0Color.i.r;		*input_g = &userdata->Texel0Color.i.g;		*input_b = &userdata->Texel0Color.i.b;		break;
+		case 2:		*input_r = &userdata->Texel1Color.i.r;		*input_g = &userdata->Texel1Color.i.g;		*input_b = &userdata->Texel1Color.i.b;		break;
+		case 3:		*input_r = &userdata->PrimColor.i.r;		*input_g = &userdata->PrimColor.i.g;		*input_b = &userdata->PrimColor.i.b;		break;
+		case 4:		*input_r = &userdata->ShadeColor.i.r;		*input_g = &userdata->ShadeColor.i.g;		*input_b = &userdata->ShadeColor.i.b;		break;
+		case 5:		*input_r = &userdata->EnvColor.i.r;			*input_g = &userdata->EnvColor.i.g;			*input_b = &userdata->EnvColor.i.b;			break;
+		case 6:		*input_r = &OneColor.i.r;					*input_g = &OneColor.i.g;					*input_b = &OneColor.i.b;					break;
+		case 7:		*input_r = &ZeroColor.i.r;					*input_g = &ZeroColor.i.g;					*input_b = &ZeroColor.i.b;					break;
 	}
 }
 
-void Processor::SetSubInputAlpha(UINT8 **input, int code)
+void n64_rdp::SetSubInputAlpha(UINT8 **input, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0x7)
 	{
-		case 0:		*input = &CombinedColor.i.a; break;
-		case 1:		*input = &Texel0Color.i.a; break;
-		case 2:		*input = &Texel1Color.i.a; break;
-		case 3:		*input = &PrimColor.i.a; break;
-		case 4:		*input = &ShadeColor.i.a; break;
-		case 5:		*input = &EnvColor.i.a; break;
+		case 0:		*input = &userdata->CombinedColor.i.a; break;
+		case 1:		*input = &userdata->Texel0Color.i.a; break;
+		case 2:		*input = &userdata->Texel1Color.i.a; break;
+		case 3:		*input = &userdata->PrimColor.i.a; break;
+		case 4:		*input = &userdata->ShadeColor.i.a; break;
+		case 5:		*input = &userdata->EnvColor.i.a; break;
 		case 6:		*input = &OneColor.i.a; break;
 		case 7:		*input = &ZeroColor.i.a; break;
 	}
 }
 
-void Processor::SetMulInputAlpha(UINT8 **input, int code)
+void n64_rdp::SetMulInputAlpha(UINT8 **input, int code, rdp_span_aux *userdata)
 {
 	switch (code & 0x7)
 	{
-		case 0:		*input = &LODFraction; break;
-		case 1:		*input = &Texel0Color.i.a; break;
-		case 2:		*input = &Texel1Color.i.a; break;
-		case 3:		*input = &PrimColor.i.a; break;
-		case 4:		*input = &ShadeColor.i.a; break;
-		case 5:		*input = &EnvColor.i.a; break;
-		case 6:		*input = &PrimLODFraction; break;
+		case 0:		*input = &userdata->LODFraction; break;
+		case 1:		*input = &userdata->Texel0Color.i.a; break;
+		case 2:		*input = &userdata->Texel1Color.i.a; break;
+		case 3:		*input = &userdata->PrimColor.i.a; break;
+		case 4:		*input = &userdata->ShadeColor.i.a; break;
+		case 5:		*input = &userdata->EnvColor.i.a; break;
+		case 6:		*input = &userdata->PrimLODFraction; break;
 		case 7:		*input = &ZeroColor.i.a; break;
 	}
 }
 
-void Processor::SetBlenderInput(int cycle, int which, UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, UINT8 **input_a, int a, int b)
+void n64_rdp::SetBlenderInput(int cycle, int which, UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, UINT8 **input_a, int a, int b, rdp_span_aux *userdata)
 {
 	switch (a & 0x3)
 	{
@@ -571,40 +599,40 @@
 		{
 			if (cycle == 0)
 			{
-				*input_r = &PixelColor.i.r;
-				*input_g = &PixelColor.i.g;
-				*input_b = &PixelColor.i.b;
+				*input_r = &userdata->PixelColor.i.r;
+				*input_g = &userdata->PixelColor.i.g;
+				*input_b = &userdata->PixelColor.i.b;
 			}
 			else
 			{
-				*input_r = &BlendedPixelColor.i.r;
-				*input_g = &BlendedPixelColor.i.g;
-				*input_b = &BlendedPixelColor.i.b;
+				*input_r = &userdata->BlendedPixelColor.i.r;
+				*input_g = &userdata->BlendedPixelColor.i.g;
+				*input_b = &userdata->BlendedPixelColor.i.b;
 			}
 			break;
 		}
 
 		case 1:
 		{
-			*input_r = &MemoryColor.i.r;
-			*input_g = &MemoryColor.i.g;
-			*input_b = &MemoryColor.i.b;
+			*input_r = &userdata->MemoryColor.i.r;
+			*input_g = &userdata->MemoryColor.i.g;
+			*input_b = &userdata->MemoryColor.i.b;
 			break;
 		}
 
 		case 2:
 		{
-			*input_r = &BlendColor.i.r;
-			*input_g = &BlendColor.i.g;
-			*input_b = &BlendColor.i.b;
+			*input_r = &userdata->BlendColor.i.r;
+			*input_g = &userdata->BlendColor.i.g;
+			*input_b = &userdata->BlendColor.i.b;
 			break;
 		}
 
 		case 3:
 		{
-			*input_r = &FogColor.i.r;
-			*input_g = &FogColor.i.g;
-			*input_b = &FogColor.i.b;
+			*input_r = &userdata->FogColor.i.r;
+			*input_g = &userdata->FogColor.i.g;
+			*input_b = &userdata->FogColor.i.b;
 			break;
 		}
 	}
@@ -613,9 +641,9 @@
 	{
 		switch (b & 0x3)
 		{
-			case 0:		*input_a = &PixelColor.i.a; break;
-			case 1:		*input_a = &FogColor.i.a; break;
-			case 2:		*input_a = &ShadeColor.i.a; break;
+			case 0:		*input_a = &userdata->PixelColor.i.a; break;
+			case 1:		*input_a = &userdata->FogColor.i.a; break;
+			case 2:		*input_a = &userdata->ShadeColor.i.a; break;
 			case 3:		*input_a = &ZeroColor.i.a; break;
 		}
 	}
@@ -623,15 +651,15 @@
 	{
 		switch (b & 0x3)
 		{
-			case 0:		*input_a = &InvPixelColor.i.a; break;
-			case 1:		*input_a = &MemoryColor.i.a; break;
+			case 0:		*input_a = &userdata->InvPixelColor.i.a; break;
+			case 1:		*input_a = &userdata->MemoryColor.i.a; break;
 			case 2:		*input_a = &OneColor.i.a; break;
 			case 3:		*input_a = &ZeroColor.i.a; break;
 		}
 	}
 }
 
-const UINT8 Processor::s_bayer_matrix[16] =
+const UINT8 n64_rdp::s_bayer_matrix[16] =
 { /* Bayer matrix */
 	 0,  4,  1, 5,
 	 6,  2,  7, 3,
@@ -639,7 +667,7 @@
 	 7,  3,  6, 2
 };
 
-const UINT8 Processor::s_magic_matrix[16] =
+const UINT8 n64_rdp::s_magic_matrix[16] =
 { /* Magic square matrix */
 	 0,  6,  1, 7,
 	 4,  2,  5, 3,
@@ -647,7 +675,7 @@
 	 7,  1,  6, 0
 };
 
-const Processor::ZDecompressEntry Processor::z_dec_table[8] =
+const n64_rdp::ZDecompressEntry n64_rdp::z_dec_table[8] =
 {
 	{ 6, 0x00000 },
 	{ 5, 0x20000 },
@@ -661,7 +689,7 @@
 
 /*****************************************************************************/
 
-void Processor::z_build_com_table(void)
+void n64_rdp::z_build_com_table(void)
 {
 	UINT16 altmem = 0;
 	for(int z = 0; z < 0x40000; z++)
@@ -819,7 +847,7 @@
     }
 }
 
-void Processor::precalc_cvmask_derivatives(void)
+void n64_rdp::precalc_cvmask_derivatives(void)
 {
 	const UINT8 yarray[16] = {0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
 	const UINT8 xarray[16] = {0, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -855,36 +883,36 @@
 	}
 }
 
-UINT16 Processor::decompress_cvmask_frombyte(UINT8 x)
+UINT16 n64_rdp::decompress_cvmask_frombyte(UINT8 x)
 {
 	UINT16 y = (x & 1) | ((x & 2) << 1) | ((x & 4) << 3) | ((x & 8) << 4) |
 		((x & 0x10) << 4) | ((x & 0x20) << 5) | ((x & 0x40) << 7) | ((x & 0x80) << 8);
 	return y;
 }
 
-void Processor::lookup_cvmask_derivatives(UINT32 mask, UINT8* offx, UINT8* offy)
+void n64_rdp::lookup_cvmask_derivatives(UINT32 mask, UINT8* offx, UINT8* offy, rdp_span_aux *userdata)
 {
 	UINT32 index = compressed_cvmasks[mask];
-	MiscState.CurrentPixCvg = cvarray[index].cvg;
-	MiscState.CurrentCvgBit = cvarray[index].cvbit;
+	userdata->CurrentPixCvg = cvarray[index].cvg;
+	userdata->CurrentCvgBit = cvarray[index].cvbit;
 	*offx = cvarray[index].xoff;
 	*offy = cvarray[index].yoff;
 }
 
-void Processor::ZStore(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 z)
+void n64_rdp::ZStore(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 z, UINT32 enc)
 {
-	UINT16 zval = z_com_table[z & 0x3ffff]|(m_dzpix_enc >> 2);
+	UINT16 zval = z_com_table[z & 0x3ffff]|(enc >> 2);
 	if(zcurpixel <= MEM16_LIMIT)
 	{
 		((UINT16*)rdram)[zcurpixel ^ WORD_ADDR_XOR] = zval;
 	}
 	if(dzcurpixel <= MEM8_LIMIT)
 	{
-		HiddenBits[dzcurpixel ^ BYTE_ADDR_XOR] = m_dzpix_enc & 3;
+		HiddenBits[dzcurpixel ^ BYTE_ADDR_XOR] = enc & 3;
 	}
 }
 
-INT32 Processor::NormalizeDZPix(INT32 sum)
+INT32 n64_rdp::NormalizeDZPix(INT32 sum)
 {
 	if (sum & 0xc000)
 	{
@@ -904,31 +932,33 @@
     return 0;
 }
 
-UINT32 Processor::ZDecompress(UINT32 zcurpixel)
+UINT32 n64_rdp::ZDecompress(UINT32 zcurpixel)
 {
 	UINT32 zb = RREADIDX16(zcurpixel);
+	CHECK16(zcurpixel);
 	return z_complete_dec_table[(zb >> 2) & 0x3fff];
 }
 
-UINT32 Processor::DZDecompress(UINT32 zcurpixel, UINT32 dzcurpixel)
+UINT32 n64_rdp::DZDecompress(UINT32 zcurpixel, UINT32 dzcurpixel)
 {
 	UINT16 zval = RREADIDX16(zcurpixel);
+	CHECK16(zcurpixel);
 	UINT8 dzval = (((dzcurpixel) <= 0x7fffff) ? (HiddenBits[(dzcurpixel) ^ BYTE_ADDR_XOR]) : 0);
 	UINT32 dz_compressed = ((zval & 3) << 2) | (dzval & 3);
 	return (1 << dz_compressed);
 }
 
-UINT32 Processor::DZCompress(UINT32 value)
+UINT32 n64_rdp::DZCompress(UINT32 value)
 {
 	INT32 j = 0;
 	for (; value > 1; j++, value >>= 1);
 	return j;
 }
 
-void Processor::GetDitherValues(int x, int y, int* cdith, int* adith)
+void n64_rdp::GetDitherValues(int x, int y, int* cdith, int* adith, const rdp_poly_state& object)
 {
 	int dithindex = ((y & 3) << 2) | (x & 3);
-	switch((OtherModes.rgb_dither_sel << 2) | OtherModes.alpha_dither_sel)
+	switch((object.OtherModes.rgb_dither_sel << 2) | object.OtherModes.alpha_dither_sel)
 	{
 	case 0:
 		*adith = *cdith = s_magic_matrix[dithindex];
@@ -1001,7 +1031,7 @@
 	return in;
 }
 
-bool Processor::ZCompare(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 sz, UINT16 dzpix)
+bool n64_rdp::ZCompare(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 sz, UINT16 dzpix, rdp_span_aux *userdata, const rdp_poly_state &object)
 {
 	bool force_coplanar = false;
 	sz &= 0x3ffff;
@@ -1011,11 +1041,12 @@
 	UINT32 zval;
 	INT32 rawdzmem;
 
-	if (OtherModes.z_compare_en)
+	if (object.OtherModes.z_compare_en)
 	{
 		oz = ZDecompress(zcurpixel);
 		dzmem = DZDecompress(zcurpixel, dzcurpixel);
 		zval = RREADIDX16(zcurpixel);
+		CHECK16(zcurpixel);
 		rawdzmem = ((zval & 3) << 2) | ((((dzcurpixel) <= 0x3fffff) ? (HiddenBits[(dzcurpixel) ^ BYTE_ADDR_XOR]) : 0) & 3);
 	}
 	else
@@ -1026,9 +1057,9 @@
 		rawdzmem = 0xf;
 	}
 
-	m_dzpix_enc = DZCompress(dzpix & 0xffff);
-	Blender.ShiftA = CLAMP(m_dzpix_enc - rawdzmem, 0, 4);
-	Blender.ShiftB = CLAMP(rawdzmem - m_dzpix_enc, 0, 4);
+	userdata->m_dzpix_enc = DZCompress(dzpix & 0xffff);
+	userdata->ShiftA = CLAMP(userdata->m_dzpix_enc - rawdzmem, 0, 4);
+	userdata->ShiftB = CLAMP(rawdzmem - userdata->m_dzpix_enc, 0, 4);
 
 	int precision_factor = (zval >> 13) & 0xf;
 	if (precision_factor < 3)
@@ -1065,21 +1096,21 @@
 		farther = true;
 	}
 
-	bool overflow = ((MiscState.CurrentMemCvg + MiscState.CurrentPixCvg) & 8) > 0;
-	Blender.BlendEnable = OtherModes.force_blend || (!overflow && OtherModes.antialias_en && farther);
-	Framebuffer.SetPreWrap(overflow);
+	bool overflow = ((userdata->CurrentMemCvg + userdata->CurrentPixCvg) & 8) > 0;
+	userdata->BlendEnable = (object.OtherModes.force_blend || (!overflow && object.OtherModes.antialias_en && farther)) ? 1 : 0;
+	userdata->PreWrap = overflow;
 
 	int cvgcoeff = 0;
 	UINT32 dzenc = 0;
 
-	if (OtherModes.z_mode == 1 && infront && farther && overflow)
+	if (object.OtherModes.z_mode == 1 && infront && farther && overflow)
 	{
 		dzenc = DZCompress(dznotshift & 0xffff);
 		cvgcoeff = ((oz >> dzenc) - (sz >> dzenc)) & 0xf;
-		MiscState.CurrentPixCvg = ((cvgcoeff * MiscState.CurrentPixCvg) >> 3) & 0xf;
+		userdata->CurrentPixCvg = ((cvgcoeff * userdata->CurrentPixCvg) >> 3) & 0xf;
 	}
 
-	if (!OtherModes.z_compare_en)
+	if (!object.OtherModes.z_compare_en)
 	{
 		return true;
 	}
@@ -1092,7 +1123,7 @@
 		nearer = true;
 	}
 
-	switch(OtherModes.z_mode)
+	switch(object.OtherModes.z_mode)
 	{
 	case 0:
 		return (max || (overflow ? infront : nearer));
@@ -1111,7 +1142,7 @@
 	return false;
 }
 
-UINT32 Processor::GetLog2(UINT32 lod_clamp)
+UINT32 n64_rdp::GetLog2(UINT32 lod_clamp)
 {
 	if (lod_clamp < 2)
 	{
@@ -1133,7 +1164,7 @@
 
 /*****************************************************************************/
 
-UINT32 N64::RDP::Processor::ReadData(UINT32 address)
+UINT32 n64_rdp::ReadData(UINT32 address)
 {
 	if (m_status & 0x1)		// XBUS_DMEM_DMA enabled
 	{
@@ -1216,7 +1247,7 @@
 	8			// 0x3f, Set_Color_Image
 };
 
-void N64::RDP::Processor::Dasm(char *buffer)
+void n64_rdp::Dasm(char *buffer)
 {
 	int i;
 	int tile;
@@ -1730,22 +1761,6 @@
 
 /*****************************************************************************/
 
-N64::RDP::Triangle::Triangle(running_machine &machine, bool shade, bool texture, bool zbuffer, bool rect, bool flip)
-{
-	InitFromData(machine, shade, texture, zbuffer, rect, flip);
-}
-
-void N64::RDP::Triangle::InitFromData(running_machine &machine, bool shade, bool texture, bool zbuffer, bool rect, bool flip)
-{
-	m_machine = &machine;
-	m_rdp = &(machine.driver_data<_n64_state>())->m_rdp;
-	m_cmd_data = rect ? m_rdp->GetTempRectData() : m_rdp->GetCommandData();
-	m_shade = shade;
-	m_texture = texture;
-	m_zbuffer = zbuffer;
-	m_rect = rect;
-}
-
 static UINT32 rightcvghex(UINT32 x, UINT32 fmask)
 {
 	UINT32 stickybit = ((x >> 1) & 0x1fff) > 0;
@@ -1778,7 +1793,7 @@
 	}
 }
 
-void N64::RDP::Triangle::compute_cvg_noflip(INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl)
+void n64_rdp::compute_cvg_noflip(extent_t *Spans, INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl, INT32 base)
 {
 	INT32 purgestart = 0xfff;
 	INT32 purgeend = 0;
@@ -1805,7 +1820,8 @@
 
 	if (length < 0) return;
 
-	memset(&m_rdp->Spans[scanline].m_cvg[purgestart], 0, (length + 1) << 1);
+	rdp_span_aux *userdata = (rdp_span_aux*)Spans[scanline - base].userdata;
+	memset(&userdata->m_cvg[purgestart], 0, (length + 1) << 1);
 
 	for(int i = 0; i < 4; i++)
 	{
@@ -1827,11 +1843,11 @@
 			{
 				if (!(minorcurint & ~0x3ff))
 				{
-					m_rdp->Spans[scanline].m_cvg[minorcurint] |= (leftcvghex(minorcur, fmask) << maskshift);
+					userdata->m_cvg[minorcurint] |= (leftcvghex(minorcur, fmask) << maskshift);
 				}
 				if (!(majorcurint & ~0x3ff))
 				{
-					m_rdp->Spans[scanline].m_cvg[majorcurint] |= (rightcvghex(majorcur, fmask) << maskshift);
+					userdata->m_cvg[majorcurint] |= (rightcvghex(majorcur, fmask) << maskshift);
 				}
 			}
 			else
@@ -1839,18 +1855,18 @@
 				if (!(majorcurint & ~0x3ff))
 				{
 					INT32 samecvg = leftcvghex(minorcur, fmask) & rightcvghex(majorcur, fmask);
-					m_rdp->Spans[scanline].m_cvg[majorcurint] |= (samecvg << maskshift);
+					userdata->m_cvg[majorcurint] |= (samecvg << maskshift);
 				}
 			}
 			for (; fleft <= fright; fleft++)
 			{
-				m_rdp->Spans[scanline].m_cvg[fleft] |= fmaskshifted;
+				userdata->m_cvg[fleft] |= fmaskshifted;
 			}
 		}
 	}
 }
 
-void N64::RDP::Triangle::compute_cvg_flip(INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl)
+void n64_rdp::compute_cvg_flip(extent_t *Spans, INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl, INT32 base)
 {
 	INT32 purgestart = 0xfff;
 	INT32 purgeend = 0;
@@ -1878,7 +1894,8 @@
 
 	if (length < 0) return;
 
-	memset(&m_rdp->Spans[scanline].m_cvg[purgestart], 0, (length + 1) << 1);
+	rdp_span_aux *userdata = (rdp_span_aux*)Spans[scanline - base].userdata;
+	memset(&userdata->m_cvg[purgestart], 0, (length + 1) << 1);
 
 	for(int i = 0; i < 4; i++)
 	{
@@ -1900,11 +1917,11 @@
 			{
 				if (!(minorcurint & ~0x3ff))
 				{
-					m_rdp->Spans[scanline].m_cvg[minorcurint] |= (rightcvghex(minorcur, fmask) << maskshift);
+					userdata->m_cvg[minorcurint] |= (rightcvghex(minorcur, fmask) << maskshift);
 				}
 				if (!(majorcurint & ~0x3ff))
 				{
-					m_rdp->Spans[scanline].m_cvg[majorcurint] |= (leftcvghex(majorcur, fmask) << maskshift);
+					userdata->m_cvg[majorcurint] |= (leftcvghex(majorcur, fmask) << maskshift);
 				}
 			}
 			else
@@ -1912,25 +1929,26 @@
 				if (!(majorcurint & ~0x3ff))
 				{
 					INT32 samecvg = rightcvghex(minorcur, fmask) & leftcvghex(majorcur, fmask);
-					m_rdp->Spans[scanline].m_cvg[majorcurint] |= (samecvg << maskshift);
+					userdata->m_cvg[majorcurint] |= (samecvg << maskshift);
 				}
 			}
 			for (; fleft <= fright; fleft++)
 			{
-				m_rdp->Spans[scanline].m_cvg[fleft] |= fmaskshifted;
+				userdata->m_cvg[fleft] |= fmaskshifted;
 			}
 		}
 	}
 }
 
-void N64::RDP::Triangle::Draw()
+void n64_rdp::DrawTriangle(bool shade, bool texture, bool zbuffer, bool rect)
 {
-	UINT32 fifo_index = m_rect ? 0 : m_rdp->GetCurrFIFOIndex();
-	UINT32 w1 = m_cmd_data[fifo_index + 0];
-	UINT32 w2 = m_cmd_data[fifo_index + 1];
+	UINT32 *cmd_data = rect ? m_temp_rect_data : m_cmd_data;
+	UINT32 fifo_index = rect ? 0 : m_cmd_cur;
+	UINT32 w1 = cmd_data[fifo_index + 0];
+	UINT32 w2 = cmd_data[fifo_index + 1];
 
-	int flip = (w1 & 0x800000) ? 1 : 0;
-	m_rdp->MiscState.MaxLevel = ((w1 >> 19) & 7);
+	int flip = (w1 & 0x00800000) ? 1 : 0;
+	MiscState.MaxLevel = ((w1 >> 19) & 7);
 	int tilenum = (w1 >> 16) & 0x7;
 
 	int dsdiff = 0, dtdiff = 0, dwdiff = 0, drdiff = 0, dgdiff = 0, dbdiff = 0, dadiff = 0, dzdiff = 0;
@@ -1938,7 +1956,7 @@
 	int dsdxh = 0, dtdxh = 0, dwdxh = 0, drdxh = 0, dgdxh = 0, dbdxh = 0, dadxh = 0, dzdxh = 0;
 	int dsdyh = 0, dtdyh = 0, dwdyh = 0, drdyh = 0, dgdyh = 0, dbdyh = 0, dadyh = 0, dzdyh = 0;
 
-	INT32 maxxmx = 0;
+	INT32 maxxmx = 0; // maxxmx / minxhx very opaque names, consider re-naming
 	INT32 minxmx = 0;
 	INT32 maxxhx = 0;
 	INT32 minxhx = 0;
@@ -1946,22 +1964,22 @@
 	int shade_base = fifo_index + 8;
 	int texture_base = fifo_index + 8;
 	int zbuffer_base = fifo_index + 8;
-	if(m_shade)
+	if(shade)
 	{
 		texture_base += 16;
 		zbuffer_base += 16;
 	}
-	if(m_texture)
+	if(texture)
 	{
 		zbuffer_base += 16;
 	}
 
-	UINT32 w3 = m_cmd_data[fifo_index + 2];
-	UINT32 w4 = m_cmd_data[fifo_index + 3];
-	UINT32 w5 = m_cmd_data[fifo_index + 4];
-	UINT32 w6 = m_cmd_data[fifo_index + 5];
-	UINT32 w7 = m_cmd_data[fifo_index + 6];
-	UINT32 w8 = m_cmd_data[fifo_index + 7];
+	UINT32 w3 = cmd_data[fifo_index + 2];
+	UINT32 w4 = cmd_data[fifo_index + 3];
+	UINT32 w5 = cmd_data[fifo_index + 4];
+	UINT32 w6 = cmd_data[fifo_index + 5];
+	UINT32 w7 = cmd_data[fifo_index + 6];
+	UINT32 w8 = cmd_data[fifo_index + 7];
 
 	INT32 yl = (w1 & 0x3fff);
 	INT32 ym = ((w2 >> 16) & 0x3fff);
@@ -1982,68 +2000,61 @@
 	if (xm & 0x20000000)  xm |= 0xc0000000;
 	if (xh & 0x20000000)  xh |= 0xc0000000;
 
-	int r    = (m_cmd_data[shade_base+0 ] & 0xffff0000) | ((m_cmd_data[shade_base+4 ] >> 16) & 0x0000ffff);
-	int g    = ((m_cmd_data[shade_base+0 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+4 ] & 0x0000ffff);
-	int b    = (m_cmd_data[shade_base+1 ] & 0xffff0000) | ((m_cmd_data[shade_base+5 ] >> 16) & 0x0000ffff);
-	int a    = ((m_cmd_data[shade_base+1 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+5 ] & 0x0000ffff);
-	int drdx = (m_cmd_data[shade_base+2 ] & 0xffff0000) | ((m_cmd_data[shade_base+6 ] >> 16) & 0x0000ffff);
-	int dgdx = ((m_cmd_data[shade_base+2 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+6 ] & 0x0000ffff);
-	int dbdx = (m_cmd_data[shade_base+3 ] & 0xffff0000) | ((m_cmd_data[shade_base+7 ] >> 16) & 0x0000ffff);
-	int dadx = ((m_cmd_data[shade_base+3 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+7 ] & 0x0000ffff);
-	int drde = (m_cmd_data[shade_base+8 ] & 0xffff0000) | ((m_cmd_data[shade_base+12] >> 16) & 0x0000ffff);
-	int dgde = ((m_cmd_data[shade_base+8 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+12] & 0x0000ffff);
-	int dbde = (m_cmd_data[shade_base+9 ] & 0xffff0000) | ((m_cmd_data[shade_base+13] >> 16) & 0x0000ffff);
-	int dade = ((m_cmd_data[shade_base+9 ] << 16) & 0xffff0000) | (m_cmd_data[shade_base+13] & 0x0000ffff);
-	int drdy = (m_cmd_data[shade_base+10] & 0xffff0000) | ((m_cmd_data[shade_base+14] >> 16) & 0x0000ffff);
-	int dgdy = ((m_cmd_data[shade_base+10] << 16) & 0xffff0000) | (m_cmd_data[shade_base+14] & 0x0000ffff);
-	int dbdy = (m_cmd_data[shade_base+11] & 0xffff0000) | ((m_cmd_data[shade_base+15] >> 16) & 0x0000ffff);
-	int dady = ((m_cmd_data[shade_base+11] << 16) & 0xffff0000) | (m_cmd_data[shade_base+15] & 0x0000ffff);
-	int s    = (m_cmd_data[texture_base+0 ] & 0xffff0000) | ((m_cmd_data[texture_base+4 ] >> 16) & 0x0000ffff);
-	int t    = ((m_cmd_data[texture_base+0 ] << 16) & 0xffff0000)	| (m_cmd_data[texture_base+4 ] & 0x0000ffff);
-	int w    = (m_cmd_data[texture_base+1 ] & 0xffff0000) | ((m_cmd_data[texture_base+5 ] >> 16) & 0x0000ffff);
-	int dsdx = (m_cmd_data[texture_base+2 ] & 0xffff0000) | ((m_cmd_data[texture_base+6 ] >> 16) & 0x0000ffff);
-	int dtdx = ((m_cmd_data[texture_base+2 ] << 16) & 0xffff0000)	| (m_cmd_data[texture_base+6 ] & 0x0000ffff);
-	int dwdx = (m_cmd_data[texture_base+3 ] & 0xffff0000) | ((m_cmd_data[texture_base+7 ] >> 16) & 0x0000ffff);
-	int dsde = (m_cmd_data[texture_base+8 ] & 0xffff0000) | ((m_cmd_data[texture_base+12] >> 16) & 0x0000ffff);
-	int dtde = ((m_cmd_data[texture_base+8 ] << 16) & 0xffff0000)	| (m_cmd_data[texture_base+12] & 0x0000ffff);
-	int dwde = (m_cmd_data[texture_base+9 ] & 0xffff0000) | ((m_cmd_data[texture_base+13] >> 16) & 0x0000ffff);
-	int dsdy = (m_cmd_data[texture_base+10] & 0xffff0000) | ((m_cmd_data[texture_base+14] >> 16) & 0x0000ffff);
-	int dtdy = ((m_cmd_data[texture_base+10] << 16) & 0xffff0000)	| (m_cmd_data[texture_base+14] & 0x0000ffff);
-	int dwdy = (m_cmd_data[texture_base+11] & 0xffff0000) | ((m_cmd_data[texture_base+15] >> 16) & 0x0000ffff);
-	int z    = m_cmd_data[zbuffer_base+0];
-	int dzdx = m_cmd_data[zbuffer_base+1];
-	int dzde = m_cmd_data[zbuffer_base+2];
-	int dzdy = m_cmd_data[zbuffer_base+3];
-
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[0], m_cmd_data[1], m_cmd_data[2], m_cmd_data[3]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[4], m_cmd_data[5], m_cmd_data[6], m_cmd_data[7]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[8], m_cmd_data[9], m_cmd_data[10], m_cmd_data[11]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[12], m_cmd_data[13], m_cmd_data[14], m_cmd_data[15]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[16], m_cmd_data[17], m_cmd_data[18], m_cmd_data[19]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[20], m_cmd_data[21], m_cmd_data[22], m_cmd_data[23]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[24], m_cmd_data[25], m_cmd_data[26], m_cmd_data[27]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[28], m_cmd_data[29], m_cmd_data[30], m_cmd_data[31]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[32], m_cmd_data[33], m_cmd_data[34], m_cmd_data[35]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[36], m_cmd_data[37], m_cmd_data[38], m_cmd_data[39]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[40], m_cmd_data[41], m_cmd_data[42], m_cmd_data[43]);
-	//printf("%08x %08x %08x %08x\n", m_cmd_data[44], m_cmd_data[45], m_cmd_data[46], m_cmd_data[47]);
+	int r    = (cmd_data[shade_base+0 ] & 0xffff0000) | ((cmd_data[shade_base+4 ] >> 16) & 0x0000ffff);
+	int g    = ((cmd_data[shade_base+0 ] << 16) & 0xffff0000) | (cmd_data[shade_base+4 ] & 0x0000ffff);
+	int b    = (cmd_data[shade_base+1 ] & 0xffff0000) | ((cmd_data[shade_base+5 ] >> 16) & 0x0000ffff);
+	int a    = ((cmd_data[shade_base+1 ] << 16) & 0xffff0000) | (cmd_data[shade_base+5 ] & 0x0000ffff);
+	int drdx = (cmd_data[shade_base+2 ] & 0xffff0000) | ((cmd_data[shade_base+6 ] >> 16) & 0x0000ffff);
+	int dgdx = ((cmd_data[shade_base+2 ] << 16) & 0xffff0000) | (cmd_data[shade_base+6 ] & 0x0000ffff);
+	int dbdx = (cmd_data[shade_base+3 ] & 0xffff0000) | ((cmd_data[shade_base+7 ] >> 16) & 0x0000ffff);
+	int dadx = ((cmd_data[shade_base+3 ] << 16) & 0xffff0000) | (cmd_data[shade_base+7 ] & 0x0000ffff);
+	int drde = (cmd_data[shade_base+8 ] & 0xffff0000) | ((cmd_data[shade_base+12] >> 16) & 0x0000ffff);
+	int dgde = ((cmd_data[shade_base+8 ] << 16) & 0xffff0000) | (cmd_data[shade_base+12] & 0x0000ffff);
+	int dbde = (cmd_data[shade_base+9 ] & 0xffff0000) | ((cmd_data[shade_base+13] >> 16) & 0x0000ffff);
+	int dade = ((cmd_data[shade_base+9 ] << 16) & 0xffff0000) | (cmd_data[shade_base+13] & 0x0000ffff);
+	int drdy = (cmd_data[shade_base+10] & 0xffff0000) | ((cmd_data[shade_base+14] >> 16) & 0x0000ffff);
+	int dgdy = ((cmd_data[shade_base+10] << 16) & 0xffff0000) | (cmd_data[shade_base+14] & 0x0000ffff);
+	int dbdy = (cmd_data[shade_base+11] & 0xffff0000) | ((cmd_data[shade_base+15] >> 16) & 0x0000ffff);
+	int dady = ((cmd_data[shade_base+11] << 16) & 0xffff0000) | (cmd_data[shade_base+15] & 0x0000ffff);
+	int s    = (cmd_data[texture_base+0 ] & 0xffff0000) | ((cmd_data[texture_base+4 ] >> 16) & 0x0000ffff);
+	int t    = ((cmd_data[texture_base+0 ] << 16) & 0xffff0000)	| (cmd_data[texture_base+4 ] & 0x0000ffff);
+	int w    = (cmd_data[texture_base+1 ] & 0xffff0000) | ((cmd_data[texture_base+5 ] >> 16) & 0x0000ffff);
+	int dsdx = (cmd_data[texture_base+2 ] & 0xffff0000) | ((cmd_data[texture_base+6 ] >> 16) & 0x0000ffff);
+	int dtdx = ((cmd_data[texture_base+2 ] << 16) & 0xffff0000)	| (cmd_data[texture_base+6 ] & 0x0000ffff);
+	int dwdx = (cmd_data[texture_base+3 ] & 0xffff0000) | ((cmd_data[texture_base+7 ] >> 16) & 0x0000ffff);
+	int dsde = (cmd_data[texture_base+8 ] & 0xffff0000) | ((cmd_data[texture_base+12] >> 16) & 0x0000ffff);
+	int dtde = ((cmd_data[texture_base+8 ] << 16) & 0xffff0000)	| (cmd_data[texture_base+12] & 0x0000ffff);
+	int dwde = (cmd_data[texture_base+9 ] & 0xffff0000) | ((cmd_data[texture_base+13] >> 16) & 0x0000ffff);
+	int dsdy = (cmd_data[texture_base+10] & 0xffff0000) | ((cmd_data[texture_base+14] >> 16) & 0x0000ffff);
+	int dtdy = ((cmd_data[texture_base+10] << 16) & 0xffff0000)	| (cmd_data[texture_base+14] & 0x0000ffff);
+	int dwdy = (cmd_data[texture_base+11] & 0xffff0000) | ((cmd_data[texture_base+15] >> 16) & 0x0000ffff);
+	int z    = cmd_data[zbuffer_base+0];
+	int dzdx = cmd_data[zbuffer_base+1];
+	int dzde = cmd_data[zbuffer_base+2];
+	int dzdy = cmd_data[zbuffer_base+3];
 
 	int dzdy_dz = (dzdy >> 16) & 0xffff;
 	int dzdx_dz = (dzdx >> 16) & 0xffff;
 
-	m_rdp->set_span_base_y(drdy, dgdy, dbdy, dady, dzdy);
+	extent_t Spans[1024];
+
+	SpanBase.m_span_drdy = drdy;
+	SpanBase.m_span_dgdy = dgdy;
+	SpanBase.m_span_dbdy = dbdy;
+	SpanBase.m_span_dady = dady;
+	SpanBase.m_span_dzdy = OtherModes.z_source_sel ? 0 : dzdy;
+
 	UINT32 temp_dzpix = ((dzdy_dz & 0x8000) ? ((~dzdy_dz) & 0x7fff) : dzdy_dz) + ((dzdx_dz & 0x8000) ? ((~dzdx_dz) & 0x7fff) : dzdx_dz);
-	m_rdp->set_span_base(drdx & ~0x1f,
-						 dgdx & ~0x1f,
-						 dbdx & ~0x1f,
-						 dadx & ~0x1f,
-						 dsdx,
-						 dtdx,
-						 dwdx,
-						 dzdx,
-						 0,
-						 m_rdp->NormalizeDZPix(temp_dzpix & 0xffff) & 0xffff
-						);
+	SpanBase.m_span_dr = drdx & ~0x1f;
+	SpanBase.m_span_dg = dgdx & ~0x1f;
+	SpanBase.m_span_db = dbdx & ~0x1f;
+	SpanBase.m_span_da = dadx & ~0x1f;
+	SpanBase.m_span_ds = dsdx;
+	SpanBase.m_span_dt = dtdx;
+	SpanBase.m_span_dw = dwdx;
+	SpanBase.m_span_dz = OtherModes.z_source_sel ? 0 : dzdx;
+	SpanBase.m_span_dymax = 0;
+	SpanBase.m_span_dzpix = NormalizeDZPix(temp_dzpix & 0xffff) & 0xffff;
 
 	int xleft_inc = (dxmdy >> 2) & ~1;
 	int xright_inc = (dxhdy >> 2) & ~1;
@@ -2099,6 +2110,9 @@
 
 	int xfrac = ((xright >> 8) & 0xff);
 
+	bool new_object = true;
+	rdp_poly_state *object = NULL;
+
 	if(flip)
 	{
 		for (int k = ycur; k <= ylfar; k++)
@@ -2109,18 +2123,18 @@
 				xleft_inc = (dxldy >> 2) & ~1;
 			}
 
-			int xstart = xleft >> 16;
-			int xend = xright >> 16;
+			int xstart = xleft >> 16; // 319
+			int xend = xright >> 16; // 0
 			int j = k >> 2;
 			int spix = k & 3;
 			valid_y = !(k < yh || k >= yl);
 
 			if (k >= 0 && k < 0x1000)
 			{
-				majorxint[spix] = xend;
-				minorxint[spix] = xstart;
-				majorx[spix] = xright;
-				minorx[spix] = xleft;
+				majorxint[spix] = xend; // 0
+				minorxint[spix] = xstart; // 319
+				majorx[spix] = xright; // 0x00000000
+				minorx[spix] = xleft; // 0x013f0000
 
 				if (spix == 0)
 				{
@@ -2134,26 +2148,118 @@
 					minxhx = (xend < minxhx) ? xend : minxhx;
 				}
 
+				if (spix == 0)
+				{
+					if(new_object)
+					{
+						object = &object_data_alloc();
+						memcpy(object->m_tmem, m_tmem, 0x1000);
+						new_object = false;
+					}
+
+					Spans[j - (ycur >> 2)].userdata = (void*)((UINT8*)AuxBuf + AuxBufPtr);
+					AuxBufPtr += sizeof(rdp_span_aux);
+
+					if(AuxBufPtr >= EXTENT_AUX_COUNT)
+					{
+						fatalerror("n64_rdp::DrawTriangle: span aux buffer overflow\n");
+					}
+
+					rdp_span_aux *userdata = (rdp_span_aux*)Spans[j - (ycur >> 2)].userdata;
+
+					userdata->m_tmem = object->m_tmem;
+
+					userdata->BlendColor = BlendColor;
+					userdata->PrimColor = PrimColor;
+					userdata->EnvColor = EnvColor;
+					userdata->FogColor = FogColor;
+					userdata->KeyScale = KeyScale;
+					userdata->LODFraction = LODFraction;
+					userdata->PrimLODFraction = PrimLODFraction;
+
+					userdata->ColorInputs.combiner_rgbsub_a_r[0] = userdata->ColorInputs.combiner_rgbsub_a_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbsub_a_g[0] = userdata->ColorInputs.combiner_rgbsub_a_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbsub_a_b[0] = userdata->ColorInputs.combiner_rgbsub_a_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbsub_b_r[0] = userdata->ColorInputs.combiner_rgbsub_b_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbsub_b_g[0] = userdata->ColorInputs.combiner_rgbsub_b_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbsub_b_b[0] = userdata->ColorInputs.combiner_rgbsub_b_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbmul_r[0] = userdata->ColorInputs.combiner_rgbmul_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbmul_g[0] = userdata->ColorInputs.combiner_rgbmul_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbmul_b[0] = userdata->ColorInputs.combiner_rgbmul_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbadd_r[0] = userdata->ColorInputs.combiner_rgbadd_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbadd_g[0] = userdata->ColorInputs.combiner_rgbadd_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbadd_b[0] = userdata->ColorInputs.combiner_rgbadd_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_alphasub_a[0] = userdata->ColorInputs.combiner_alphasub_a[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphasub_b[0] = userdata->ColorInputs.combiner_alphasub_b[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphamul[0] = userdata->ColorInputs.combiner_alphamul[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphaadd[0] = userdata->ColorInputs.combiner_alphaadd[1] = &OneColor.i.a;
+
+					userdata->ColorInputs.blender1a_r[0] = userdata->ColorInputs.blender1a_r[1] = &userdata->PixelColor.i.r;
+					userdata->ColorInputs.blender1a_g[0] = userdata->ColorInputs.blender1a_g[1] = &userdata->PixelColor.i.g;
+					userdata->ColorInputs.blender1a_b[0] = userdata->ColorInputs.blender1a_b[1] = &userdata->PixelColor.i.b;
+					userdata->ColorInputs.blender1b_a[0] = userdata->ColorInputs.blender1b_a[1] = &userdata->PixelColor.i.a;
+					userdata->ColorInputs.blender2a_r[0] = userdata->ColorInputs.blender2a_r[1] = &userdata->PixelColor.i.r;
+					userdata->ColorInputs.blender2a_g[0] = userdata->ColorInputs.blender2a_g[1] = &userdata->PixelColor.i.g;
+					userdata->ColorInputs.blender2a_b[0] = userdata->ColorInputs.blender2a_b[1] = &userdata->PixelColor.i.b;
+					userdata->ColorInputs.blender2b_a[0] = userdata->ColorInputs.blender2b_a[1] = &userdata->PixelColor.i.a;
+
+					// Setup blender data for this scanline
+					SetBlenderInput(0, 0, &userdata->ColorInputs.blender1a_r[0],
+										  &userdata->ColorInputs.blender1a_g[0],
+										  &userdata->ColorInputs.blender1a_b[0],
+										  &userdata->ColorInputs.blender1b_a[0], OtherModes.blend_m1a_0, OtherModes.blend_m1b_0, userdata);
+					SetBlenderInput(0, 1, &userdata->ColorInputs.blender2a_r[0],
+										  &userdata->ColorInputs.blender2a_g[0],
+										  &userdata->ColorInputs.blender2a_b[0],
+										  &userdata->ColorInputs.blender2b_a[0], OtherModes.blend_m2a_0, OtherModes.blend_m2b_0, userdata);
+					SetBlenderInput(1, 0, &userdata->ColorInputs.blender1a_r[1],
+										  &userdata->ColorInputs.blender1a_g[1],
+										  &userdata->ColorInputs.blender1a_b[1],
+										  &userdata->ColorInputs.blender1b_a[1], OtherModes.blend_m1a_1, OtherModes.blend_m1b_1, userdata);
+					SetBlenderInput(1, 1, &userdata->ColorInputs.blender2a_r[1],
+										  &userdata->ColorInputs.blender2a_g[1],
+										  &userdata->ColorInputs.blender2a_b[1],
+										  &userdata->ColorInputs.blender2b_a[1], OtherModes.blend_m2a_1, OtherModes.blend_m2b_1, userdata);
+
+					// Setup color combiner data for this scanline
+					SetSubAInputRGB(&userdata->ColorInputs.combiner_rgbsub_a_r[0], &userdata->ColorInputs.combiner_rgbsub_a_g[0], &userdata->ColorInputs.combiner_rgbsub_a_b[0], m_combine.sub_a_rgb0, userdata);
+					SetSubBInputRGB(&userdata->ColorInputs.combiner_rgbsub_b_r[0], &userdata->ColorInputs.combiner_rgbsub_b_g[0], &userdata->ColorInputs.combiner_rgbsub_b_b[0], m_combine.sub_b_rgb0, userdata);
+					SetMulInputRGB(&userdata->ColorInputs.combiner_rgbmul_r[0], &userdata->ColorInputs.combiner_rgbmul_g[0], &userdata->ColorInputs.combiner_rgbmul_b[0], m_combine.mul_rgb0, userdata);
+					SetAddInputRGB(&userdata->ColorInputs.combiner_rgbadd_r[0], &userdata->ColorInputs.combiner_rgbadd_g[0], &userdata->ColorInputs.combiner_rgbadd_b[0], m_combine.add_rgb0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_a[0], m_combine.sub_a_a0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_b[0], m_combine.sub_b_a0, userdata);
+					SetMulInputAlpha(&userdata->ColorInputs.combiner_alphamul[0], m_combine.mul_a0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphaadd[0], m_combine.add_a0, userdata);
+
+					SetSubAInputRGB(&userdata->ColorInputs.combiner_rgbsub_a_r[1], &userdata->ColorInputs.combiner_rgbsub_a_g[1], &userdata->ColorInputs.combiner_rgbsub_a_b[1], m_combine.sub_a_rgb1, userdata);
+					SetSubBInputRGB(&userdata->ColorInputs.combiner_rgbsub_b_r[1], &userdata->ColorInputs.combiner_rgbsub_b_g[1], &userdata->ColorInputs.combiner_rgbsub_b_b[1], m_combine.sub_b_rgb1, userdata);
+					SetMulInputRGB(&userdata->ColorInputs.combiner_rgbmul_r[1], &userdata->ColorInputs.combiner_rgbmul_g[1], &userdata->ColorInputs.combiner_rgbmul_b[1], m_combine.mul_rgb1, userdata);
+					SetAddInputRGB(&userdata->ColorInputs.combiner_rgbadd_r[1], &userdata->ColorInputs.combiner_rgbadd_g[1], &userdata->ColorInputs.combiner_rgbadd_b[1], m_combine.add_rgb1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_a[1], m_combine.sub_a_a1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_b[1], m_combine.sub_b_a1, userdata);
+					SetMulInputAlpha(&userdata->ColorInputs.combiner_alphamul[1], m_combine.mul_a1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphaadd[1], m_combine.add_a1, userdata);
+				}
+
 				if (spix == 3)
 				{
-					m_rdp->Spans[j].m_lx = maxxmx;
-					m_rdp->Spans[j].m_rx = minxhx;
-					compute_cvg_flip(majorx, minorx, majorxint, minorxint, j, yh, yl);
+					Spans[j - (ycur >> 2)].startx = maxxmx;
+					Spans[j - (ycur >> 2)].stopx = minxhx;
+					compute_cvg_flip(Spans, majorx, minorx, majorxint, minorxint, j, yh, yl, ycur >> 2);
 				}
 
 				if (spix == ldflag)
 				{
-					m_rdp->Spans[j].m_unscissored_rx = xend;
+					((rdp_span_aux*)Spans[j - (ycur >> 2)].userdata)->m_unscissored_rx = xend;
 					xfrac = ((xright >> 8) & 0xff);
-					m_rdp->Spans[j].m_r.w = ((r >> 9) << 9) + drdiff - (xfrac * drdxh);
-					m_rdp->Spans[j].m_g.w = ((g >> 9) << 9) + dgdiff - (xfrac * dgdxh);
-					m_rdp->Spans[j].m_b.w = ((b >> 9) << 9) + dbdiff - (xfrac * dbdxh);
-					m_rdp->Spans[j].m_a.w = ((a >> 9) << 9) + dadiff - (xfrac * dadxh);
-					m_rdp->Spans[j].m_s.w = (((s >> 9) << 9)  + dsdiff - (xfrac * dsdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_t.w = (((t >> 9) << 9)  + dtdiff - (xfrac * dtdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_w.w = (((w >> 9) << 9)  + dwdiff - (xfrac * dwdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_z.w = ((z >> 9) << 9)  + dzdiff - (xfrac * dzdxh);
-					//printf("%d - %08x\n", j, m_rdp->Spans[j].m_z.w);
+					Spans[j - (ycur >> 2)].param[SPAN_R].start = ((r >> 9) << 9) + drdiff - (xfrac * drdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_G].start = ((g >> 9) << 9) + dgdiff - (xfrac * dgdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_B].start = ((b >> 9) << 9) + dbdiff - (xfrac * dbdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_A].start = ((a >> 9) << 9) + dadiff - (xfrac * dadxh);
+					Spans[j - (ycur >> 2)].param[SPAN_S].start = (((s >> 9) << 9)  + dsdiff - (xfrac * dsdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_T].start = (((t >> 9) << 9)  + dtdiff - (xfrac * dtdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_W].start = (((w >> 9) << 9)  + dwdiff - (xfrac * dwdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_Z].start = ((z >> 9) << 9)  + dzdiff - (xfrac * dzdxh);
 				}
 			}
 
@@ -2208,25 +2314,117 @@
 					maxxhx = (xend > maxxhx) ? xend : maxxhx;
 				}
 
+				if (spix == 0)
+				{
+					if(new_object)
+					{
+						object = &object_data_alloc();
+						memcpy(object->m_tmem, m_tmem, 0x1000);
+						new_object = false;
+					}
+
+					Spans[j - (ycur >> 2)].userdata = (void*)((UINT8*)AuxBuf + AuxBufPtr);
+					AuxBufPtr += sizeof(rdp_span_aux);
+
+					if(AuxBufPtr >= EXTENT_AUX_COUNT)
+					{
+						fatalerror("n64_rdp::DrawTriangle: span aux buffer overflow\n");
+					}
+
+					rdp_span_aux *userdata = (rdp_span_aux*)Spans[j - (ycur >> 2)].userdata;
+					userdata->m_tmem = object->m_tmem;
+
+					userdata->BlendColor = BlendColor;
+					userdata->PrimColor = PrimColor;
+					userdata->EnvColor = EnvColor;
+					userdata->FogColor = FogColor;
+					userdata->KeyScale = KeyScale;
+					userdata->LODFraction = LODFraction;
+					userdata->PrimLODFraction = PrimLODFraction;
+
+					userdata->ColorInputs.combiner_rgbsub_a_r[0] = userdata->ColorInputs.combiner_rgbsub_a_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbsub_a_g[0] = userdata->ColorInputs.combiner_rgbsub_a_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbsub_a_b[0] = userdata->ColorInputs.combiner_rgbsub_a_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbsub_b_r[0] = userdata->ColorInputs.combiner_rgbsub_b_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbsub_b_g[0] = userdata->ColorInputs.combiner_rgbsub_b_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbsub_b_b[0] = userdata->ColorInputs.combiner_rgbsub_b_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbmul_r[0] = userdata->ColorInputs.combiner_rgbmul_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbmul_g[0] = userdata->ColorInputs.combiner_rgbmul_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbmul_b[0] = userdata->ColorInputs.combiner_rgbmul_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_rgbadd_r[0] = userdata->ColorInputs.combiner_rgbadd_r[1] = &OneColor.i.r;
+					userdata->ColorInputs.combiner_rgbadd_g[0] = userdata->ColorInputs.combiner_rgbadd_g[1] = &OneColor.i.g;
+					userdata->ColorInputs.combiner_rgbadd_b[0] = userdata->ColorInputs.combiner_rgbadd_b[1] = &OneColor.i.b;
+					userdata->ColorInputs.combiner_alphasub_a[0] = userdata->ColorInputs.combiner_alphasub_a[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphasub_b[0] = userdata->ColorInputs.combiner_alphasub_b[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphamul[0] = userdata->ColorInputs.combiner_alphamul[1] = &OneColor.i.a;
+					userdata->ColorInputs.combiner_alphaadd[0] = userdata->ColorInputs.combiner_alphaadd[1] = &OneColor.i.a;
+
+					userdata->ColorInputs.blender1a_r[0] = userdata->ColorInputs.blender1a_r[1] = &userdata->PixelColor.i.r;
+					userdata->ColorInputs.blender1a_g[0] = userdata->ColorInputs.blender1a_g[1] = &userdata->PixelColor.i.g;
+					userdata->ColorInputs.blender1a_b[0] = userdata->ColorInputs.blender1a_b[1] = &userdata->PixelColor.i.b;
+					userdata->ColorInputs.blender1b_a[0] = userdata->ColorInputs.blender1b_a[1] = &userdata->PixelColor.i.a;
+					userdata->ColorInputs.blender2a_r[0] = userdata->ColorInputs.blender2a_r[1] = &userdata->PixelColor.i.r;
+					userdata->ColorInputs.blender2a_g[0] = userdata->ColorInputs.blender2a_g[1] = &userdata->PixelColor.i.g;
+					userdata->ColorInputs.blender2a_b[0] = userdata->ColorInputs.blender2a_b[1] = &userdata->PixelColor.i.b;
+					userdata->ColorInputs.blender2b_a[0] = userdata->ColorInputs.blender2b_a[1] = &userdata->PixelColor.i.a;
+
+					// Setup blender data for this scanline
+					SetBlenderInput(0, 0, &userdata->ColorInputs.blender1a_r[0],
+										  &userdata->ColorInputs.blender1a_g[0],
+										  &userdata->ColorInputs.blender1a_b[0],
+										  &userdata->ColorInputs.blender1b_a[0], OtherModes.blend_m1a_0, OtherModes.blend_m1b_0, userdata);
+					SetBlenderInput(0, 1, &userdata->ColorInputs.blender2a_r[0],
+										  &userdata->ColorInputs.blender2a_g[0],
+										  &userdata->ColorInputs.blender2a_b[0],
+										  &userdata->ColorInputs.blender2b_a[0], OtherModes.blend_m2a_0, OtherModes.blend_m2b_0, userdata);
+					SetBlenderInput(1, 0, &userdata->ColorInputs.blender1a_r[1],
+										  &userdata->ColorInputs.blender1a_g[1],
+										  &userdata->ColorInputs.blender1a_b[1],
+										  &userdata->ColorInputs.blender1b_a[1], OtherModes.blend_m1a_1, OtherModes.blend_m1b_1, userdata);
+					SetBlenderInput(1, 1, &userdata->ColorInputs.blender2a_r[1],
+										  &userdata->ColorInputs.blender2a_g[1],
+										  &userdata->ColorInputs.blender2a_b[1],
+										  &userdata->ColorInputs.blender2b_a[1], OtherModes.blend_m2a_1, OtherModes.blend_m2b_1, userdata);
+
+					// Setup color combiner data for this scanline
+					SetSubAInputRGB(&userdata->ColorInputs.combiner_rgbsub_a_r[0], &userdata->ColorInputs.combiner_rgbsub_a_g[0], &userdata->ColorInputs.combiner_rgbsub_a_b[0], m_combine.sub_a_rgb0, userdata);
+					SetSubBInputRGB(&userdata->ColorInputs.combiner_rgbsub_b_r[0], &userdata->ColorInputs.combiner_rgbsub_b_g[0], &userdata->ColorInputs.combiner_rgbsub_b_b[0], m_combine.sub_b_rgb0, userdata);
+					SetMulInputRGB(&userdata->ColorInputs.combiner_rgbmul_r[0], &userdata->ColorInputs.combiner_rgbmul_g[0], &userdata->ColorInputs.combiner_rgbmul_b[0], m_combine.mul_rgb0, userdata);
+					SetAddInputRGB(&userdata->ColorInputs.combiner_rgbadd_r[0], &userdata->ColorInputs.combiner_rgbadd_g[0], &userdata->ColorInputs.combiner_rgbadd_b[0], m_combine.add_rgb0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_a[0], m_combine.sub_a_a0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_b[0], m_combine.sub_b_a0, userdata);
+					SetMulInputAlpha(&userdata->ColorInputs.combiner_alphamul[0], m_combine.mul_a0, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphaadd[0], m_combine.add_a0, userdata);
+
+					SetSubAInputRGB(&userdata->ColorInputs.combiner_rgbsub_a_r[1], &userdata->ColorInputs.combiner_rgbsub_a_g[1], &userdata->ColorInputs.combiner_rgbsub_a_b[1], m_combine.sub_a_rgb1, userdata);
+					SetSubBInputRGB(&userdata->ColorInputs.combiner_rgbsub_b_r[1], &userdata->ColorInputs.combiner_rgbsub_b_g[1], &userdata->ColorInputs.combiner_rgbsub_b_b[1], m_combine.sub_b_rgb1, userdata);
+					SetMulInputRGB(&userdata->ColorInputs.combiner_rgbmul_r[1], &userdata->ColorInputs.combiner_rgbmul_g[1], &userdata->ColorInputs.combiner_rgbmul_b[1], m_combine.mul_rgb1, userdata);
+					SetAddInputRGB(&userdata->ColorInputs.combiner_rgbadd_r[1], &userdata->ColorInputs.combiner_rgbadd_g[1], &userdata->ColorInputs.combiner_rgbadd_b[1], m_combine.add_rgb1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_a[1], m_combine.sub_a_a1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphasub_b[1], m_combine.sub_b_a1, userdata);
+					SetMulInputAlpha(&userdata->ColorInputs.combiner_alphamul[1], m_combine.mul_a1, userdata);
+					SetSubInputAlpha(&userdata->ColorInputs.combiner_alphaadd[1], m_combine.add_a1, userdata);
+				}
+
 				if (spix == 3)
 				{
-					m_rdp->Spans[j].m_lx = minxmx;
-					m_rdp->Spans[j].m_rx = maxxhx;
-					compute_cvg_noflip(majorx, minorx, majorxint, minorxint, j, yh, yl);
+					Spans[j - (ycur >> 2)].startx = minxmx;
+					Spans[j - (ycur >> 2)].stopx = maxxhx;
+					compute_cvg_noflip(Spans, majorx, minorx, majorxint, minorxint, j, yh, yl, ycur >> 2);
 				}
 
 				if (spix == ldflag)
 				{
-					m_rdp->Spans[j].m_unscissored_rx = xend;
+					((rdp_span_aux*)Spans[j - (ycur >> 2)].userdata)->m_unscissored_rx = xend;
 					xfrac = ((xright >> 8) & 0xff);
-					m_rdp->Spans[j].m_r.w = ((r >> 9) << 9) + drdiff - (xfrac * drdxh);
-					m_rdp->Spans[j].m_g.w = ((g >> 9) << 9) + dgdiff - (xfrac * dgdxh);
-					m_rdp->Spans[j].m_b.w = ((b >> 9) << 9) + dbdiff - (xfrac * dbdxh);
-					m_rdp->Spans[j].m_a.w = ((a >> 9) << 9) + dadiff - (xfrac * dadxh);
-					m_rdp->Spans[j].m_s.w = (((s >> 9) << 9)  + dsdiff - (xfrac * dsdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_t.w = (((t >> 9) << 9)  + dtdiff - (xfrac * dtdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_w.w = (((w >> 9) << 9)  + dwdiff - (xfrac * dwdxh)) & ~0x1f;
-					m_rdp->Spans[j].m_z.w = ((z >> 9) << 9)  + dzdiff - (xfrac * dzdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_R].start = ((r >> 9) << 9) + drdiff - (xfrac * drdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_G].start = ((g >> 9) << 9) + dgdiff - (xfrac * dgdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_B].start = ((b >> 9) << 9) + dbdiff - (xfrac * dbdxh);
+					Spans[j - (ycur >> 2)].param[SPAN_A].start = ((a >> 9) << 9) + dadiff - (xfrac * dadxh);
+					Spans[j - (ycur >> 2)].param[SPAN_S].start = (((s >> 9) << 9)  + dsdiff - (xfrac * dsdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_T].start = (((t >> 9) << 9)  + dtdiff - (xfrac * dtdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_W].start = (((w >> 9) << 9)  + dwdiff - (xfrac * dwdxh)) & ~0x1f;
+					Spans[j - (ycur >> 2)].param[SPAN_Z].start = ((z >> 9) << 9)  + dzdiff - (xfrac * dzdxh);
 				}
 			}
 
@@ -2246,63 +2444,336 @@
 		}
 	}
 
-	m_rdp->RenderSpans(yh >> 2, yl >> 2, tilenum, flip);
+	if(!new_object)
+	{
+		RenderSpans(yh >> 2, yl >> 2, tilenum, flip ? true : false, Spans, rect, object);
+	}
+
+	//wait("DrawTriangle");
 }
 
 /*****************************************************************************/
 
 ////////////////////////
-// RDP COMMANDS
+// FB ACCESSORS
 ////////////////////////
+void n64_rdp::_Write16Bit_Cvg0_Blend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 1) + curpixel;
+	UINT32 hb = fb;
+
+	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX16(fb) & 0xfffe;
+		CHECK16(fb);
+	}
+
+	finalcvg = userdata->CurrentPixCvg + userdata->CurrentMemCvg;
+	if (finalcvg & 8)
+	{
+		finalcvg = 7;
+	}
+	RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
+	HWRITEADDR8(hb, finalcvg & 3);
+}
+
+void n64_rdp::_Write16Bit_Cvg0_NoBlend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 1) + curpixel;
+	UINT32 hb = fb;
+
+	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX16(fb) & 0xfffe;
+		CHECK16(fb);
+	}
+
+	finalcvg = (userdata->CurrentPixCvg - 1) & 7;
+	RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
+	HWRITEADDR8(hb, finalcvg & 3);
+}
+
+void n64_rdp::_Write16Bit_Cvg1(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 1) + curpixel;
+	UINT32 hb = fb;
+
+	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX16(fb) & 0xfffe;
+		CHECK16(fb);
+	}
+
+	finalcvg = (userdata->CurrentPixCvg + userdata->CurrentMemCvg) & 7;
+	RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
+	HWRITEADDR8(hb, finalcvg & 3);
+}
+
+void n64_rdp::_Write16Bit_Cvg2(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 1) + curpixel;
+	UINT32 hb = fb;
+
+	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
 
-void N64::RDP::Processor::Triangle(bool shade, bool texture, bool zbuffer)
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX16(fb) & 0xfffe;
+		CHECK16(fb);
+	}
+
+	RWRITEIDX16(fb, finalcolor | 1);
+	HWRITEADDR8(hb, 3);
+}
+
+void n64_rdp::_Write16Bit_Cvg3(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 1) + curpixel;
+	UINT32 hb = fb;
+
+	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX16(fb) & 0xfffe;
+		CHECK16(fb);
+	}
+
+	RWRITEIDX16(fb, finalcolor | ((userdata->CurrentMemCvg >> 2) & 1));
+	HWRITEADDR8(hb, userdata->CurrentMemCvg & 3);
+}
+
+void n64_rdp::_Write32Bit_Cvg0_Blend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 2) + curpixel;
+	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX32(fb) & 0xffffff00;
+		CHECK32(fb);
+	}
+
+	finalcvg = userdata->CurrentPixCvg + userdata->CurrentMemCvg;
+	if (finalcvg & 8)
+	{
+		finalcvg = 7;
+	}
+	RWRITEIDX32(fb, finalcolor | (finalcvg << 5));
+}
+
+void n64_rdp::_Write32Bit_Cvg0_NoBlend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
 {
-	N64::RDP::Triangle tri(*m_machine, shade, texture, zbuffer, false, false);
-	tri.Draw();
+	UINT32 fb = (object.MiscState.FBAddress >> 2) + curpixel;
+	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX32(fb) & 0xffffff00;
+		CHECK32(fb);
+	}
+
+	finalcvg = (userdata->CurrentPixCvg - 1) & 7;
+	RWRITEIDX32(fb, finalcolor | (finalcvg << 5));
 }
 
-void N64::RDP::Processor::CmdTriangle(UINT32 w1, UINT32 w2)
+void n64_rdp::_Write32Bit_Cvg1(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 2) + curpixel;
+	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
+	UINT32 finalcvg = 0;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX32(fb) & 0xffffff00;
+		CHECK32(fb);
+	}
+
+	finalcvg = (userdata->CurrentPixCvg + userdata->CurrentMemCvg) & 7;
+	finalcolor |= (finalcvg << 5);
+	RWRITEIDX32(fb, finalcolor);
+}
+
+void n64_rdp::_Write32Bit_Cvg2(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 2) + curpixel;
+	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX32(fb) & 0xffffff00;
+		CHECK32(fb);
+	}
+
+	RWRITEIDX32(fb, finalcolor | 0xE0);
+}
+
+void n64_rdp::_Write32Bit_Cvg3(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 fb = (object.MiscState.FBAddress >> 2) + curpixel;
+	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
+
+	if (object.OtherModes.color_on_cvg && !userdata->PreWrap)
+	{
+		finalcolor = RREADIDX32(fb) & 0xffffff00;
+		CHECK32(fb);
+	}
+
+	RWRITEIDX32(fb, finalcolor | (userdata->CurrentMemCvg << 5));
+}
+
+
+void n64_rdp::_Read16Bit_ImgRead0(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT16 fword = RREADIDX16((object.MiscState.FBAddress >> 1) + curpixel);
+	CHECK16((object.MiscState.FBAddress >> 1) + curpixel);
+	userdata->MemoryColor.i.r = GETHICOL(fword);
+	userdata->MemoryColor.i.g = GETMEDCOL(fword);
+	userdata->MemoryColor.i.b = GETLOWCOL(fword);
+	userdata->MemoryColor.i.a = 0xff;
+	userdata->CurrentMemCvg = 7;
+}
+
+void n64_rdp::_Read16Bit_ImgRead1(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT16 fword = RREADIDX16((object.MiscState.FBAddress >> 1) + curpixel);
+	CHECK16((object.MiscState.FBAddress >> 1) + curpixel);
+	UINT8 hbyte = HREADADDR8((object.MiscState.FBAddress >> 1) + curpixel);
+	userdata->MemoryColor.i.r = GETHICOL(fword);
+	userdata->MemoryColor.i.g = GETMEDCOL(fword);
+	userdata->MemoryColor.i.b = GETLOWCOL(fword);
+	userdata->MemoryColor.i.a = userdata->CurrentMemCvg << 5;
+	userdata->CurrentMemCvg = ((fword & 1) << 2) | (hbyte & 3);
+}
+
+void n64_rdp::_Read32Bit_ImgRead0(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 mem = RREADIDX32((object.MiscState.FBAddress >> 2) + curpixel);
+	CHECK32((object.MiscState.FBAddress >> 2) + curpixel);
+	userdata->MemoryColor.i.r = (mem >> 24) & 0xff;
+	userdata->MemoryColor.i.g = (mem >> 16) & 0xff;
+	userdata->MemoryColor.i.b = (mem >> 8) & 0xff;
+	userdata->MemoryColor.i.a = 0xff;
+	userdata->CurrentMemCvg = 7;
+}
+
+void n64_rdp::_Read32Bit_ImgRead1(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object)
+{
+	UINT32 mem = RREADIDX32((object.MiscState.FBAddress >> 2) + curpixel);
+	CHECK32((object.MiscState.FBAddress >> 2) + curpixel);
+	userdata->MemoryColor.i.r = (mem >> 24) & 0xff;
+	userdata->MemoryColor.i.g = (mem >> 16) & 0xff;
+	userdata->MemoryColor.i.b = (mem >> 8) & 0xff;
+	userdata->MemoryColor.i.a = (mem) & 0xff;
+	userdata->CurrentMemCvg = (mem >> 5) & 7;
+}
+
+void n64_rdp::_Copy16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, int CurrentPixCvg, const rdp_poly_state &object)
+{
+	UINT16 val = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1) | ((CurrentPixCvg >> 2) & 1);
+	RWRITEIDX16((object.MiscState.FBAddress >> 1) + curpixel, val);
+	HWRITEADDR8((object.MiscState.FBAddress >> 1) + curpixel, CurrentPixCvg & 3);
+	CHECK16((object.MiscState.FBAddress >> 1) + curpixel);
+}
+
+void n64_rdp::_Copy32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, int CurrentPixCvg, const rdp_poly_state &object)
+{
+	UINT32 val = (r << 24) | (g << 16) | (b << 8) | (CurrentPixCvg << 5);
+	RWRITEIDX32((object.MiscState.FBAddress >> 2) + curpixel, val);
+	CHECK32((object.MiscState.FBAddress >> 2) + curpixel);
+}
+
+
+void n64_rdp::_Fill16Bit(UINT32 curpixel, const rdp_poly_state &object)
+{
+	UINT16 val;
+	if (curpixel & 1)
+	{
+		val = object.FillColor & 0xffff;
+	}
+	else
+	{
+		val = (object.FillColor >> 16) & 0xffff;
+	}
+	RWRITEIDX16((object.MiscState.FBAddress >> 1) + curpixel, val);
+	CHECK16((object.MiscState.FBAddress >> 1) + curpixel);
+	HWRITEADDR8((object.MiscState.FBAddress >> 1) + curpixel, ((val & 1) << 1) | (val & 1));
+}
+
+void n64_rdp::_Fill32Bit(UINT32 curpixel, const rdp_poly_state &object)
+{
+	UINT32 FillColor = object.FillColor;
+	RWRITEIDX32((object.MiscState.FBAddress >> 2) + curpixel, FillColor);
+	CHECK32((object.MiscState.FBAddress >> 2) + curpixel);
+	HWRITEADDR8((object.MiscState.FBAddress >> 1) + (curpixel << 1), (FillColor & 0x10000) ? 3 : 0);
+	HWRITEADDR8((object.MiscState.FBAddress >> 1) + (curpixel << 1) + 1, (FillColor & 0x1) ? 3 : 0);
+}
+
+////////////////////////
+// RDP COMMANDS
+////////////////////////
+void n64_rdp::Triangle(bool shade, bool texture, bool zbuffer)
+{
+	DrawTriangle(shade, texture, zbuffer, false);
+	m_pipe_clean = false;
+	//wait();
+}
+
+void n64_rdp::CmdTriangle(UINT32 w1, UINT32 w2)
 {
 	Triangle(false, false, false);
 }
 
-void N64::RDP::Processor::CmdTriangleZ(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleZ(UINT32 w1, UINT32 w2)
 {
 	Triangle(false, false, true);
 }
 
-void N64::RDP::Processor::CmdTriangleT(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleT(UINT32 w1, UINT32 w2)
 {
 	Triangle(false, true, false);
 }
 
-void N64::RDP::Processor::CmdTriangleTZ(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleTZ(UINT32 w1, UINT32 w2)
 {
 	Triangle(false, true, true);
 }
 
-void N64::RDP::Processor::CmdTriangleS(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleS(UINT32 w1, UINT32 w2)
 {
 	Triangle(true, false, false);
 }
 
-void N64::RDP::Processor::CmdTriangleSZ(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleSZ(UINT32 w1, UINT32 w2)
 {
 	Triangle(true, false, true);
 }
 
-void N64::RDP::Processor::CmdTriangleST(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleST(UINT32 w1, UINT32 w2)
 {
 	Triangle(true, true, false);
 }
 
-void N64::RDP::Processor::CmdTriangleSTZ(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTriangleSTZ(UINT32 w1, UINT32 w2)
 {
 	Triangle(true, true, true);
 }
 
-void N64::RDP::Processor::CmdTexRect(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTexRect(UINT32 w1, UINT32 w2)
 {
+	//if(m_pending_mode_block) { wait("Block on pending mode-change"); m_pending_mode_block = false; }
+
 	UINT32 *data = m_cmd_data + m_cmd_cur;
 
 	UINT32 w3 = data[2];
@@ -2329,7 +2800,7 @@
 	UINT32 xlint = (xl >> 2) & 0x3ff;
 	UINT32 xhint = (xh >> 2) & 0x3ff;
 
-	UINT32* ewdata = GetTempRectData();
+	UINT32* ewdata = m_temp_rect_data;
 	ewdata[0] = (0x24 << 24) | ((0x80 | tilenum) << 16) | yl;	// command, flipped, tile, yl
 	ewdata[1] = (yl << 16) | yh;								// ym, yh
 	ewdata[2] = (xlint << 16) | ((xl & 3) << 14);				// xl, xl frac
@@ -2357,12 +2828,13 @@
 	ewdata[39] = 0;//dwdy frac
 	memset(&ewdata[40], 0, 4 * sizeof(UINT32));//depth
 
-	N64::RDP::Triangle tri(*m_machine, true, true, false, true, false);
-	tri.Draw();
+	DrawTriangle(true, true, false, true);
 }
 
-void N64::RDP::Processor::CmdTexRectFlip(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdTexRectFlip(UINT32 w1, UINT32 w2)
 {
+	//if(m_pending_mode_block) { wait("Block on pending mode-change"); m_pending_mode_block = false; }
+
 	UINT32 *data = m_cmd_data + m_cmd_cur;
 
 	UINT32 w3 = data[2];
@@ -2389,7 +2861,7 @@
 	UINT32 xlint = (xl >> 2) & 0x3ff;
 	UINT32 xhint = (xh >> 2) & 0x3ff;
 
-	UINT32* ewdata = GetTempRectData();
+	UINT32* ewdata = m_temp_rect_data;
 	ewdata[0] = (0x25 << 24) | ((0x80 | tilenum) << 16) | yl;//command, flipped, tile, yl
 	ewdata[1] = (yl << 16) | yh;//ym, yh
 	ewdata[2] = (xlint << 16) | ((xl & 3) << 14);//xl, xl frac
@@ -2417,48 +2889,50 @@
 	ewdata[39] = 0;//dwdy frac
 	memset(&ewdata[40], 0, 4 * sizeof(UINT32));//depth
 
-	N64::RDP::Triangle tri(*m_machine, true, true, false, true, false);
-	tri.Draw();
+	DrawTriangle(true, true, false, true);
 }
 
-void N64::RDP::Processor::CmdSyncLoad(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSyncLoad(UINT32 w1, UINT32 w2)
 {
-	// Nothing to do?
+	//wait("SyncLoad");
 }
 
-void N64::RDP::Processor::CmdSyncPipe(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSyncPipe(UINT32 w1, UINT32 w2)
 {
-	// Nothing to do?
+	//wait("SyncPipe");
 }
 
-void N64::RDP::Processor::CmdSyncTile(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSyncTile(UINT32 w1, UINT32 w2)
 {
-	// Nothing to do?
+	//wait("SyncTile");
 }
 
-void N64::RDP::Processor::CmdSyncFull(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSyncFull(UINT32 w1, UINT32 w2)
 {
+	//wait("SyncFull");
 	dp_full_sync(*m_machine);
 }
 
-void N64::RDP::Processor::CmdSetKeyGB(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetKeyGB(UINT32 w1, UINT32 w2)
 {
 	KeyScale.i.b = w2 & 0xff;
 	KeyScale.i.g = (w2 >> 16) & 0xff;
 }
 
-void N64::RDP::Processor::CmdSetKeyR(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetKeyR(UINT32 w1, UINT32 w2)
 {
 	KeyScale.i.r = w2 & 0xff;
 }
 
-void N64::RDP::Processor::CmdSetFillColor32(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetFillColor32(UINT32 w1, UINT32 w2)
 {
+	//wait("SetFillColor");
 	FillColor = w2;
 }
 
-void N64::RDP::Processor::CmdSetConvert(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetConvert(UINT32 w1, UINT32 w2)
 {
+	if(!m_pipe_clean) { m_pipe_clean = true; wait("SetConvert"); }
 	INT32 k0 = (w1 >> 13) & 0xff;
 	INT32 k1 = (w1 >> 4) & 0xff;
 	INT32 k2 = ((w1 & 7) << 5) | ((w2 >> 27) & 0x1f);
@@ -2474,25 +2948,25 @@
 	SetYUVFactors(k0, k1, k2, k3, k4, k5);
 }
 
-void N64::RDP::Processor::CmdSetScissor(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetScissor(UINT32 w1, UINT32 w2)
 {
-	m_scissor.m_xh = ((w1 >> 12) & 0xfff) >> 2;
-	m_scissor.m_yh = ((w1 >>  0) & 0xfff) >> 2;
-	m_scissor.m_xl = ((w2 >> 12) & 0xfff) >> 2;
-	m_scissor.m_yl = ((w2 >>  0) & 0xfff) >> 2;
+	Scissor.m_xh = ((w1 >> 12) & 0xfff) >> 2;
+	Scissor.m_yh = ((w1 >>  0) & 0xfff) >> 2;
+	Scissor.m_xl = ((w2 >> 12) & 0xfff) >> 2;
+	Scissor.m_yl = ((w2 >>  0) & 0xfff) >> 2;
 
 	// TODO: handle f & o?
 }
 
-void N64::RDP::Processor::CmdSetPrimDepth(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetPrimDepth(UINT32 w1, UINT32 w2)
 {
 	MiscState.PrimitiveZ = (UINT16)(w2 >> 16) & 0x7fff;
 	MiscState.PrimitiveDZ = (UINT16)(w1);
-
 }
 
-void N64::RDP::Processor::CmdSetOtherModes(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetOtherModes(UINT32 w1, UINT32 w2)
 {
+	//wait("SetOtherModes");
 	OtherModes.cycle_type		= (w1 >> 20) & 0x3; // 01
 	OtherModes.persp_tex_en		= (w1 & 0x80000) ? 1 : 0; // 1
 	OtherModes.detail_tex_en		= (w1 & 0x40000) ? 1 : 0; // 0
@@ -2522,24 +2996,19 @@
 	OtherModes.z_mode			= (w2 >> 10) & 0x3; // 00
 	OtherModes.cvg_dest			= (w2 >> 8) & 0x3; // 00
 	OtherModes.color_on_cvg		= (w2 >> 7) & 1; // 0
-	OtherModes.image_read_en		= (w2 >> 6) & 1; // 1
+	OtherModes.image_read_en	= (w2 >> 6) & 1; // 1
 	OtherModes.z_update_en		= (w2 >> 5) & 1; // 1
 	OtherModes.z_compare_en		= (w2 >> 4) & 1; // 1
 	OtherModes.antialias_en		= (w2 >> 3) & 1; // 1
 	OtherModes.z_source_sel		= (w2 >> 2) & 1; // 0
 	OtherModes.dither_alpha_en	= (w2 >> 1) & 1; // 0
 	OtherModes.alpha_compare_en	= (w2) & 1; // 0
-
-	// These should belong to the Blender class
-	SetBlenderInput(0, 0, &ColorInputs.blender1a_r[0], &ColorInputs.blender1a_g[0], &ColorInputs.blender1a_b[0], &ColorInputs.blender1b_a[0], OtherModes.blend_m1a_0, OtherModes.blend_m1b_0);
-	SetBlenderInput(0, 1, &ColorInputs.blender2a_r[0], &ColorInputs.blender2a_g[0], &ColorInputs.blender2a_b[0], &ColorInputs.blender2b_a[0], OtherModes.blend_m2a_0, OtherModes.blend_m2b_0);
-	SetBlenderInput(1, 0, &ColorInputs.blender1a_r[1], &ColorInputs.blender1a_g[1], &ColorInputs.blender1a_b[1], &ColorInputs.blender1b_a[1], OtherModes.blend_m1a_1, OtherModes.blend_m1b_1);
-	SetBlenderInput(1, 1, &ColorInputs.blender2a_r[1], &ColorInputs.blender2a_g[1], &ColorInputs.blender2a_b[1], &ColorInputs.blender2b_a[1], OtherModes.blend_m2a_1, OtherModes.blend_m2b_1);
 }
 
-void N64::RDP::Processor::CmdLoadTLUT(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdLoadTLUT(UINT32 w1, UINT32 w2)
 {
-	Tile* tile = GetTiles();
+	//wait("LoadTLUT");
+	N64Tile* tile = m_tiles;
 
 	int tilenum = (w2 >> 24) & 0x7;
 	int sl = tile[tilenum].sl = ((w1 >> 12) & 0xfff);
@@ -2571,7 +3040,7 @@
 			{
 				if (dststart < 2048)
 				{
-					dst[dststart] = RREADIDX16(srcstart);
+					dst[dststart] = U_RREADIDX16(srcstart);
 					dst[dststart + 1] = dst[dststart];
 					dst[dststart + 2] = dst[dststart];
 					dst[dststart + 3] = dst[dststart];
@@ -2585,8 +3054,10 @@
 	}
 }
 
-void N64::RDP::Processor::CmdSetTileSize(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetTileSize(UINT32 w1, UINT32 w2)
 {
+	//wait("SetTileSize");
+
 	const int tilenum = (w2 >> 24) & 0x7;
 
 	m_tiles[tilenum].sl = (w1 >> 12) & 0xfff;
@@ -2595,9 +3066,10 @@
 	m_tiles[tilenum].th = (w2 >>  0) & 0xfff;
 }
 
-void N64::RDP::Processor::CmdLoadBlock(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdLoadBlock(UINT32 w1, UINT32 w2)
 {
-	Tile* tile = GetTiles();
+	//wait("LoadBlock");
+	N64Tile* tile = m_tiles;
 
 	int tilenum = (w2 >> 24) & 0x7;
 	UINT16* tc = GetTMEM16();
@@ -2654,10 +3126,10 @@
 				ptr = tb + (i << 2);
 				srcptr = src + (i << 2);
 
-				tc[(ptr ^ t) & 0x7ff] = RREADIDX16(srcptr);
-				tc[((ptr + 1) ^ t) & 0x7ff] = RREADIDX16(srcptr + 1);
-				tc[((ptr + 2) ^ t) & 0x7ff] = RREADIDX16(srcptr + 2);
-				tc[((ptr + 3) ^ t) & 0x7ff] = RREADIDX16(srcptr + 3);
+				tc[(ptr ^ t) & 0x7ff] = U_RREADIDX16(srcptr);
+				tc[((ptr + 1) ^ t) & 0x7ff] = U_RREADIDX16(srcptr + 1);
+				tc[((ptr + 2) ^ t) & 0x7ff] = U_RREADIDX16(srcptr + 2);
+				tc[((ptr + 3) ^ t) & 0x7ff] = U_RREADIDX16(srcptr + 3);
 				j += dxt;
 			}
 		}
@@ -2675,14 +3147,14 @@
 				ptr = ((tb + (i << 1)) ^ t) & 0x3ff;
 				srcptr = src + (i << 2);
 
-				first = RREADIDX16(srcptr);
-				sec = RREADIDX16(srcptr + 1);
+				first = U_RREADIDX16(srcptr);
+				sec = U_RREADIDX16(srcptr + 1);
 				tc[ptr] = ((first >> 8) << 8) | (sec >> 8);
 				tc[ptr | 0x400] = ((first & 0xff) << 8) | (sec & 0xff);
 
 				ptr = ((tb + (i << 1) + 1) ^ t) & 0x3ff;
-				first = RREADIDX16(srcptr + 2);
-				sec = RREADIDX16(srcptr + 3);
+				first = U_RREADIDX16(srcptr + 2);
+				sec = U_RREADIDX16(srcptr + 3);
 				tc[ptr] = ((first >> 8) << 8) | (sec >> 8);
 				tc[ptr | 0x400] = ((first & 0xff) << 8) | (sec & 0xff);
 
@@ -2700,12 +3172,12 @@
 
 				ptr = ((tb + (i << 1)) ^ t) & 0x3ff;
 				srcptr = src + (i << 2);
-				tc[ptr] = RREADIDX16(srcptr);
-				tc[ptr | 0x400] = RREADIDX16(srcptr + 1);
+				tc[ptr] = U_RREADIDX16(srcptr);
+				tc[ptr | 0x400] = U_RREADIDX16(srcptr + 1);
 
 				ptr = ((tb + (i << 1) + 1) ^ t) & 0x3ff;
-				tc[ptr] = RREADIDX16(srcptr + 2);
-				tc[ptr | 0x400] = RREADIDX16(srcptr + 3);
+				tc[ptr] = U_RREADIDX16(srcptr + 2);
+				tc[ptr | 0x400] = U_RREADIDX16(srcptr + 3);
 
 				j += dxt;
 			}
@@ -2720,10 +3192,10 @@
 			{
 				ptr = tb + (i << 2);
 				srcptr = src + (i << 2);
-				tc[(ptr ^ WORD_ADDR_XOR) & 0x7ff] = RREADIDX16(srcptr);
-				tc[((ptr + 1) ^ WORD_ADDR_XOR) & 0x7ff] = RREADIDX16(srcptr + 1);
-				tc[((ptr + 2) ^ WORD_ADDR_XOR) & 0x7ff] = RREADIDX16(srcptr + 2);
-				tc[((ptr + 3) ^ WORD_ADDR_XOR) & 0x7ff] = RREADIDX16(srcptr + 3);
+				tc[(ptr ^ WORD_ADDR_XOR) & 0x7ff] = U_RREADIDX16(srcptr);
+				tc[((ptr + 1) ^ WORD_ADDR_XOR) & 0x7ff] = U_RREADIDX16(srcptr + 1);
+				tc[((ptr + 2) ^ WORD_ADDR_XOR) & 0x7ff] = U_RREADIDX16(srcptr + 2);
+				tc[((ptr + 3) ^ WORD_ADDR_XOR) & 0x7ff] = U_RREADIDX16(srcptr + 3);
 			}
 		}
 		else if (tile[tilenum].format == FORMAT_YUV)
@@ -2732,14 +3204,14 @@
 			{
 				ptr = ((tb + (i << 1)) ^ WORD_ADDR_XOR) & 0x3ff;
 				srcptr = src + (i << 2);
-				first = RREADIDX16(srcptr);
-				sec = RREADIDX16(srcptr + 1);
+				first = U_RREADIDX16(srcptr);
+				sec = U_RREADIDX16(srcptr + 1);
 				tc[ptr] = ((first >> 8) << 8) | (sec >> 8);//UV pair
 				tc[ptr | 0x400] = ((first & 0xff) << 8) | (sec & 0xff);
 
 				ptr = ((tb + (i << 1) + 1) ^ WORD_ADDR_XOR) & 0x3ff;
-				first = RREADIDX16(srcptr + 2);
-				sec = RREADIDX16(srcptr + 3);
+				first = U_RREADIDX16(srcptr + 2);
+				sec = U_RREADIDX16(srcptr + 3);
 				tc[ptr] = ((first >> 8) << 8) | (sec >> 8);
 				tc[ptr | 0x400] = ((first & 0xff) << 8) | (sec & 0xff);
 			}
@@ -2750,21 +3222,22 @@
 			{
 				ptr = ((tb + (i << 1)) ^ WORD_ADDR_XOR) & 0x3ff;
 				srcptr = src + (i << 2);
-				tc[ptr] = RREADIDX16(srcptr);
-				tc[ptr | 0x400] = RREADIDX16(srcptr + 1);
+				tc[ptr] = U_RREADIDX16(srcptr);
+				tc[ptr | 0x400] = U_RREADIDX16(srcptr + 1);
 
 				ptr = ((tb + (i << 1) + 1) ^ WORD_ADDR_XOR) & 0x3ff;
-				tc[ptr] = RREADIDX16(srcptr + 2);
-				tc[ptr | 0x400] = RREADIDX16(srcptr + 3);
+				tc[ptr] = U_RREADIDX16(srcptr + 2);
+				tc[ptr | 0x400] = U_RREADIDX16(srcptr + 3);
 			}
 		}
 		tile[tilenum].th = tl;
 	}
 }
 
-void N64::RDP::Processor::CmdLoadTile(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdLoadTile(UINT32 w1, UINT32 w2)
 {
-	Tile* tile = GetTiles();
+	//wait("LoadTile");
+	N64Tile* tile = m_tiles;
 	int tilenum = (w2 >> 24) & 0x7;
 
 	tile[tilenum].sl	= ((w1 >> 12) & 0xfff);
@@ -2807,7 +3280,7 @@
 				int xorval8 = ((j & 1) ? BYTE_XOR_DWORD_SWAP : BYTE_ADDR_XOR);
 				for (int i = 0; i < width; i++)
 				{
-					tc[((tline + i) ^ xorval8) & 0xfff] = RREADADDR8(src + s + i);
+					tc[((tline + i) ^ xorval8) & 0xfff] = U_RREADADDR8(src + s + i);
 				}
 			}
 			break;
@@ -2830,7 +3303,7 @@
 					for (int i = 0; i < width; i++)
 					{
 						UINT32 taddr = (tline + i) ^ xorval16;
-						tc[taddr & 0x7ff] = RREADIDX16(src + s + i);
+						tc[taddr & 0x7ff] = U_RREADIDX16(src + s + i);
 					}
 				}
 			}
@@ -2846,7 +3319,7 @@
 					for (int i = 0; i < width; i++)
 					{
 						UINT32 taddr = ((tline + i) ^ xorval8) & 0x7ff;
-						yuvword = RREADIDX16(src + s + i);
+						yuvword = U_RREADIDX16(src + s + i);
 						GetTMEM()[taddr] = yuvword >> 8;
 						GetTMEM()[taddr | 0x800] = yuvword & 0xff;
 					}
@@ -2868,7 +3341,7 @@
 				int xorval32cur = (j & 1) ? WORD_XOR_DWORD_SWAP : WORD_ADDR_XOR;
 				for (int i = 0; i < width; i++)
 				{
-					UINT32 c = RREADIDX32(src + s + i);
+					UINT32 c = U_RREADIDX32(src + s + i);
 					UINT32 ptr = ((tline + i) ^ xorval32cur) & 0x3ff;
 					tc16[ptr] = c >> 16;
 					tc16[ptr | 0x400] = c & 0xffff;
@@ -2881,10 +3354,12 @@
 	}
 }
 
-void N64::RDP::Processor::CmdSetTile(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetTile(UINT32 w1, UINT32 w2)
 {
+	//wait("SetTile");
+
 	int tilenum = (w2 >> 24) & 0x7;
-	N64::RDP::Tile* tex_tile = &m_tiles[tilenum];
+	N64Tile* tex_tile = &m_tiles[tilenum];
 
 	tex_tile->format	= (w1 >> 21) & 0x7;
 	tex_tile->size		= (w1 >> 19) & 0x3;
@@ -2913,10 +3388,14 @@
 	{
 		tex_tile->format = FORMAT_CI; // Used by Exterem-G2, Madden Football 64, and Rat Attack
 	}
+
+	//m_pending_mode_block = true;
 }
 
-void N64::RDP::Processor::CmdFillRect(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdFillRect(UINT32 w1, UINT32 w2)
 {
+	//if(m_pending_mode_block) { wait("Block on pending mode-change"); m_pending_mode_block = false; }
+
 	UINT32 xl = (w1 >> 12) & 0xfff;
 	UINT32 yl = (w1 >>  0) & 0xfff;
 	UINT32 xh = (w2 >> 12) & 0xfff;
@@ -2930,7 +3409,7 @@
 	UINT32 xlint = (xl >> 2) & 0x3ff;
 	UINT32 xhint = (xh >> 2) & 0x3ff;
 
-	UINT32* ewdata = GetTempRectData();
+	UINT32* ewdata = m_temp_rect_data;
 	ewdata[0] = (0x3680 << 16) | yl;//command, flipped, tile, yl
 	ewdata[1] = (yl << 16) | yh;//ym, yh
 	ewdata[2] = (xlint << 16) | ((xl & 3) << 14);//xl, xl frac
@@ -2941,33 +3420,32 @@
 	ewdata[7] = 0;//dxmdy, dxmdy frac
 	memset(&ewdata[8], 0, 36 * sizeof(UINT32));//shade, texture, depth
 
-	N64::RDP::Triangle tri(*m_machine, false, false, false, true, false);
-	tri.Draw();
+	DrawTriangle(false, false, false, true);
 }
 
-void N64::RDP::Processor::CmdSetFogColor(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetFogColor(UINT32 w1, UINT32 w2)
 {
 	FogColor.c = w2;
 }
 
-void N64::RDP::Processor::CmdSetBlendColor(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetBlendColor(UINT32 w1, UINT32 w2)
 {
 	BlendColor.c = w2;
 }
 
-void N64::RDP::Processor::CmdSetPrimColor(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetPrimColor(UINT32 w1, UINT32 w2)
 {
 	MiscState.MinLevel = (w1 >> 8) & 0x1f;
 	PrimLODFraction = w1 & 0xff;
 	PrimColor.c = w2;
 }
 
-void N64::RDP::Processor::CmdSetEnvColor(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetEnvColor(UINT32 w1, UINT32 w2)
 {
 	EnvColor.c = w2;
 }
 
-void N64::RDP::Processor::CmdSetCombine(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetCombine(UINT32 w1, UINT32 w2)
 {
 	m_combine.sub_a_rgb0	= (w1 >> 20) & 0xf;
 	m_combine.mul_rgb0		= (w1 >> 15) & 0x1f;
@@ -2986,27 +3464,9 @@
 	m_combine.add_rgb1		= (w2 >>  6) & 0x7;
 	m_combine.sub_b_a1		= (w2 >>  3) & 0x7;
 	m_combine.add_a1		= (w2 >>  0) & 0x7;
-
-	SetSubAInputRGB(&ColorInputs.combiner_rgbsub_a_r[0], &ColorInputs.combiner_rgbsub_a_g[0], &ColorInputs.combiner_rgbsub_a_b[0], m_combine.sub_a_rgb0);
-	SetSubBInputRGB(&ColorInputs.combiner_rgbsub_b_r[0], &ColorInputs.combiner_rgbsub_b_g[0], &ColorInputs.combiner_rgbsub_b_b[0], m_combine.sub_b_rgb0);
-	SetMulInputRGB(&ColorInputs.combiner_rgbmul_r[0], &ColorInputs.combiner_rgbmul_g[0], &ColorInputs.combiner_rgbmul_b[0], m_combine.mul_rgb0);
-	SetAddInputRGB(&ColorInputs.combiner_rgbadd_r[0], &ColorInputs.combiner_rgbadd_g[0], &ColorInputs.combiner_rgbadd_b[0], m_combine.add_rgb0);
-	SetSubInputAlpha(&ColorInputs.combiner_alphasub_a[0], m_combine.sub_a_a0);
-	SetSubInputAlpha(&ColorInputs.combiner_alphasub_b[0], m_combine.sub_b_a0);
-	SetMulInputAlpha(&ColorInputs.combiner_alphamul[0], m_combine.mul_a0);
-	SetSubInputAlpha(&ColorInputs.combiner_alphaadd[0], m_combine.add_a0);
-
-	SetSubAInputRGB(&ColorInputs.combiner_rgbsub_a_r[1], &ColorInputs.combiner_rgbsub_a_g[1], &ColorInputs.combiner_rgbsub_a_b[1], m_combine.sub_a_rgb1);
-	SetSubBInputRGB(&ColorInputs.combiner_rgbsub_b_r[1], &ColorInputs.combiner_rgbsub_b_g[1], &ColorInputs.combiner_rgbsub_b_b[1], m_combine.sub_b_rgb1);
-	SetMulInputRGB(&ColorInputs.combiner_rgbmul_r[1], &ColorInputs.combiner_rgbmul_g[1], &ColorInputs.combiner_rgbmul_b[1], m_combine.mul_rgb1);
-	SetAddInputRGB(&ColorInputs.combiner_rgbadd_r[1], &ColorInputs.combiner_rgbadd_g[1], &ColorInputs.combiner_rgbadd_b[1], m_combine.add_rgb1);
-	SetSubInputAlpha(&ColorInputs.combiner_alphasub_a[1], m_combine.sub_a_a1);
-	SetSubInputAlpha(&ColorInputs.combiner_alphasub_b[1], m_combine.sub_b_a1);
-	SetMulInputAlpha(&ColorInputs.combiner_alphamul[1], m_combine.mul_a1);
-	SetSubInputAlpha(&ColorInputs.combiner_alphaadd[1], m_combine.add_a1);
 }
 
-void N64::RDP::Processor::CmdSetTextureImage(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetTextureImage(UINT32 w1, UINT32 w2)
 {
 	MiscState.TIFormat	= (w1 >> 21) & 0x7;
 	MiscState.TISize	= (w1 >> 19) & 0x3;
@@ -3014,37 +3474,29 @@
 	MiscState.TIAddress	= w2 & 0x01ffffff;
 }
 
-void N64::RDP::Processor::CmdSetMaskImage(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetMaskImage(UINT32 w1, UINT32 w2)
 {
+	//wait("SetMaskImage");
+
 	MiscState.ZBAddress = w2 & 0x01ffffff;
 }
 
-void N64::RDP::Processor::CmdSetColorImage(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdSetColorImage(UINT32 w1, UINT32 w2)
 {
+	//wait("SetColorImage");
+
 	MiscState.FBFormat	= (w1 >> 21) & 0x7;
 	MiscState.FBSize	= (w1 >> 19) & 0x3;
 	MiscState.FBWidth		= (w1 & 0x3ff) + 1;
 	MiscState.FBAddress	= w2 & 0x01ffffff;
 
-	if (MiscState.FBFormat && MiscState.FBFormat != 2) // Jet Force Gemini sets the format to 4, Intensity.  Protection?
-	{
-		if (MiscState.FBSize == 1)
-		{
-			MiscState.FBFormat = 2;
-		}
-		else
-		{
-			MiscState.FBFormat = 0;
-		}
-	}
-
-	if (MiscState.FBFormat != 0)
+	if (MiscState.FBFormat < 2 || MiscState.FBFormat > 32) // Jet Force Gemini sets the format to 4, Intensity.  Protection?
 	{
-		MiscState.FBFormat = 0;
+		MiscState.FBFormat = 2;
 	}
 }
 
-UINT32 N64::RDP::Processor::AddRightCvg(UINT32 x, UINT32 k)
+UINT32 n64_rdp::AddRightCvg(UINT32 x, UINT32 k)
 {
 //#undef FULL_SUBPIXELS
 #define FULL_SUBPIXELS
@@ -3088,7 +3540,7 @@
 	}
 }
 
-UINT32 N64::RDP::Processor::AddLeftCvg(UINT32 x, UINT32 k)
+UINT32 n64_rdp::AddLeftCvg(UINT32 x, UINT32 k)
 {
 	UINT32 coveredsubpixels = 3 - ((x >> 14) & 3);
 	if (!(x & 0xffff))
@@ -3132,33 +3584,33 @@
 
 /*****************************************************************************/
 
-void N64::RDP::Processor::CmdInvalid(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdInvalid(UINT32 w1, UINT32 w2)
 {
-	fatalerror("N64::RDP::Processor::Invalid: %d, %08x %08x\n", (w1 >> 24) & 0x3f, w1, w2);
+	fatalerror("n64_rdp::Invalid: %d, %08x %08x\n", (w1 >> 24) & 0x3f, w1, w2);
 }
 
-void N64::RDP::Processor::CmdNoOp(UINT32 w1, UINT32 w2)
+void n64_rdp::CmdNoOp(UINT32 w1, UINT32 w2)
 {
 	// Do nothing
 }
 
 
-void N64::RDP::Processor::ProcessList()
+void n64_rdp::ProcessList()
 {
-	UINT32 length = m_end - m_current;
+	INT32 length = m_end - m_current;
 
-	//printf("length %08x\n", length);
-	//printf("end %08x\n", m_end);
-	//printf("current %08x\n", m_current);
+	if(length < 0)
+	{
+		m_current = m_end;
+		return;
+	}
 
 	// load command data
 	for(int i = 0; i < length; i += 4)
 	{
-		//printf("%08x\n", m_current);
 		m_cmd_data[m_cmd_ptr++] = ReadData((m_current & 0x1fffffff) + i);
 	}
 
-	//printf("Queued\n");
 	m_current = m_end;
 
 	UINT32 cmd = (m_cmd_data[0] >> 24) & 0x3f;
@@ -3169,13 +3621,11 @@
 	// check if more data is needed
 	if (cmd_length < rdp_command_length[cmd])
 	{
-		//printf("Early-out\n");
 		return;
 	}
 
 	while (m_cmd_cur < m_cmd_ptr)
 	{
-		//printf("Command\n");
 		cmd = (m_cmd_data[m_cmd_cur] >> 24) & 0x3f;
 
 		if (((m_cmd_ptr - m_cmd_cur) * 4) < rdp_command_length[cmd])
@@ -3253,48 +3703,144 @@
 	m_cmd_cur = 0;
 
 	m_start = m_current = m_end;
-	//printf("Done RDP\n");
 }
 
-} // namespace RDP
+/*****************************************************************************/
+
+n64_rdp::n64_rdp(n64_state &state) : poly_manager<UINT32, rdp_poly_state, 8, 32000>(state.machine())
+{
+	AuxBufPtr = 0;
+	AuxBuf = NULL;
+	m_pipe_clean = true;
 
-} // namespace N64
+	m_pending_mode_block = false;
 
-/*****************************************************************************/
+	m_cmd_ptr = 0;
+	m_cmd_cur = 0;
+
+	m_start = 0;
+	m_end = 0;
+	m_current = 0;
+	m_status = 0x88;
+
+	for (int i = 0; i < 8; i++)
+	{
+		m_tiles[i].num = i;
+	}
+
+	OneColor.c = 0xffffffff;
+	ZeroColor.c = 0x00000000;
+
+	m_tmem = NULL;
+
+	m_machine = NULL;
+
+	//memset(m_hidden_bits, 3, 8388608);
+
+	PrimLODFraction = 0;
+
+	for (int i = 0; i < 256; i++)
+	{
+		m_gamma_table[i] = sqrt((float)(i << 6));
+		m_gamma_table[i] <<= 1;
+	}
+
+	for (int i = 0; i < 0x4000; i++)
+	{
+		m_gamma_dither_table[i] = sqrt((float)i);
+		m_gamma_dither_table[i] <<= 1;
+	}
+
+	z_build_com_table();
+
+	for (int i = 0; i < 0x4000; i++)
+	{
+		UINT32 exponent = (i >> 11) & 7;
+		UINT32 mantissa = i & 0x7ff;
+		z_complete_dec_table[i] = ((mantissa << z_dec_table[exponent].shift) + z_dec_table[exponent].add) & 0x3fffff;
+	}
+
+	precalc_cvmask_derivatives();
+
+	for(int i = 0; i < 0x200; i++)
+	{
+		switch((i >> 7) & 3)
+		{
+		case 0:
+		case 1:
+			m_special_9bit_clamptable[i] = i & 0xff;
+			break;
+		case 2:
+			m_special_9bit_clamptable[i] = 0xff;
+			break;
+		case 3:
+			m_special_9bit_clamptable[i] = 0;
+			break;
+		}
+	}
+
+	for(int i = 0; i < 32; i++)
+	{
+		ReplicatedRGBA[i] = (i << 3) | ((i >> 2) & 7);
+	}
+
+	_Write[0] = &n64_rdp::_Write16Bit_Cvg0_NoBlend;
+	_Write[1] = &n64_rdp::_Write16Bit_Cvg0_Blend;
+	_Write[2] = &n64_rdp::_Write16Bit_Cvg1;
+	_Write[3] = &n64_rdp::_Write16Bit_Cvg1;
+	_Write[4] = &n64_rdp::_Write16Bit_Cvg2;
+	_Write[5] = &n64_rdp::_Write16Bit_Cvg2;
+	_Write[6] = &n64_rdp::_Write16Bit_Cvg3;
+	_Write[7] = &n64_rdp::_Write16Bit_Cvg3;
+	_Write[8] = &n64_rdp::_Write32Bit_Cvg0_NoBlend;
+	_Write[9] = &n64_rdp::_Write32Bit_Cvg0_Blend;
+	_Write[10] = &n64_rdp::_Write32Bit_Cvg1;
+	_Write[11] = &n64_rdp::_Write32Bit_Cvg1;
+	_Write[12] = &n64_rdp::_Write32Bit_Cvg2;
+	_Write[13] = &n64_rdp::_Write32Bit_Cvg2;
+	_Write[14] = &n64_rdp::_Write32Bit_Cvg3;
+	_Write[15] = &n64_rdp::_Write32Bit_Cvg3;
+
+	_Read[0] = &n64_rdp::_Read16Bit_ImgRead0;
+	_Read[1] = &n64_rdp::_Read16Bit_ImgRead1;
+	_Read[2] = &n64_rdp::_Read32Bit_ImgRead0;
+	_Read[3] = &n64_rdp::_Read32Bit_ImgRead1;
+
+	_Copy[0] = &n64_rdp::_Copy16Bit;
+	_Copy[1] = &n64_rdp::_Copy32Bit;
+
+	_Fill[0] = &n64_rdp::_Fill16Bit;
+	_Fill[1] = &n64_rdp::_Fill32Bit;
+}
 
 VIDEO_START(n64)
 {
-	_n64_state *state = machine.driver_data<_n64_state>();
+	n64_state *state = machine.driver_data<n64_state>();
+
+	state->m_rdp = auto_alloc(machine, n64_rdp(*state));
 
-	state->m_rdp.SetMachine(machine);
-	state->m_rdp.InitInternalState();
+	state->m_rdp->SetMachine(machine);
+	state->m_rdp->InitInternalState();
 
-	state->m_rdp.Blender.SetMachine(machine);
-	state->m_rdp.Blender.SetProcessor(&state->m_rdp);
+	state->m_rdp->Blender.SetMachine(machine);
+	state->m_rdp->Blender.SetProcessor(state->m_rdp);
 
-	state->m_rdp.Framebuffer.SetProcessor(&state->m_rdp);
+	state->m_rdp->TexPipe.SetMachine(machine);
 
-	state->m_rdp.TexPipe.SetMachine(machine);
+	state->m_rdp->AuxBuf = auto_alloc_array_clear(machine, UINT8, EXTENT_AUX_COUNT);
 
 	if (LOG_RDP_EXECUTION)
 	{
 		rdp_exec = fopen("rdp_execute.txt", "wt");
 	}
-
-	printf("A");
-	for (int i = 0; i < 4096; i++)
-	{
-		state->m_rdp.Spans[i].SetMachine(machine);
-	}
-	printf("B");
 }
 
 SCREEN_UPDATE_RGB32(n64)
 {
-	_n64_state *state = screen.machine().driver_data<_n64_state>();
+	n64_state *state = screen.machine().driver_data<n64_state>();
 	n64_periphs *n64 = screen.machine().device<n64_periphs>("rcp");
+    state->m_rdp->visarea = screen.visible_area();
 
-    int height = state->m_rdp.MiscState.FBHeight;
 	//UINT16 *frame_buffer = (UINT16*)&rdram[(n64->vi_origin & 0xffffff) >> 2];
 	//UINT8  *cvg_buffer = &state->m_rdp.HiddenBits[((n64->vi_origin & 0xffffff) >> 2) >> 1];
     //int vibuffering = ((n64->vi_control & 2) && fsaa && divot);
@@ -3333,20 +3879,16 @@
     }
     */
 
+	state->m_rdp->wait();
+	state->m_rdp->AuxBufPtr = 0;
+
     if (n64->vi_blank)
     {
-        for (int j = 0; j <height; j++)
-        {
-            UINT32 *d = &bitmap.pix32(j);
-            for (int i = 0; i < state->m_rdp.MiscState.FBWidth; i++)
-            {
-                d[BYTE_XOR_BE(i)] = 0;
-            }
-        }
+		bitmap.fill(0, state->m_rdp->visarea);
         return 0;
     }
 
-	state->m_rdp.VideoUpdate(n64, bitmap);
+	state->m_rdp->VideoUpdate(n64, bitmap);
 
 	return 0;
 }
diff -Nru src-old/mame/video/n64.h src/mame/video/n64.h
--- src-old/mame/video/n64.h	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/n64.h	2012-02-19 16:23:23.000000000 +0100
@@ -2,11 +2,10 @@
 #define _VIDEO_N64_H_
 
 #include "emu.h"
+#include "includes/n64.h"
+#include "video/polynew.h"
 #include "video/rdpblend.h"
-#include "video/rdptri.h"
-#include "video/rdpfb.h"
 #include "video/rdptpipe.h"
-#include "video/rdpspn16.h"
 
 /*****************************************************************************/
 
@@ -57,20 +56,50 @@
 #define MEM16_LIMIT 0x3fffff
 #define MEM32_LIMIT 0x1fffff
 
-#define RREADADDR8(in) (((in) <= MEM8_LIMIT) ? (((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR]) : 0)
-#define RREADIDX16(in) (((in) <= MEM16_LIMIT) ? (((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR]) : 0)
-#define RREADIDX32(in) (((in) <= MEM32_LIMIT) ? (rdram[(in)]) : 0)
-
-#define RWRITEADDR8(in, val)	{if ((in) <= MEM8_LIMIT) ((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR] = val;}
-#define RWRITEIDX16(in, val)	{if ((in) <= MEM16_LIMIT) ((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR] = val;}
-#define RWRITEIDX32(in, val)	{if ((in) <= MEM32_LIMIT) rdram[(in)] = val;}
+#define RDP_RANGE_CHECK	(0)
+
+#if RDP_RANGE_CHECK
+#define CHECK8(in) if(rdp_range_check((in))) { printf("Check8: Address %08x out of range!\n", (in)); fflush(stdout); fatalerror("Address %08x out of range!\n", (in)); }
+#define CHECK16(in) if(rdp_range_check((in) << 1)) { printf("Check16: Address %08x out of range!\n", (in) << 1); fflush(stdout); fatalerror("Address %08x out of range!\n", (in) << 1); }
+#define CHECK32(in) if(rdp_range_check((in) << 2)) { printf("Check32: Address %08x out of range!\n", (in) << 2); fflush(stdout); fatalerror("Address %08x out of range!\n", (in) << 2); }
+#else
+#define CHECK8(in) { }
+#define CHECK16(in) { }
+#define CHECK32(in) { }
+#endif
+
+#if RDP_RANGE_CHECK
+#define RREADADDR8(in) ((rdp_range_check((in))) ? 0 : (((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR]))
+#define RREADIDX16(in) ((rdp_range_check((in) << 1)) ? 0 : (((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR]))
+#define RREADIDX32(in) ((rdp_range_check((in) << 2)) ? 0 : rdram[(in)])
+
+#define RWRITEADDR8(in, val)	if(rdp_range_check((in))) { printf("Write8: Address %08x out of range!\n", (in)); fflush(stdout); fatalerror("Address %08x out of range!\n", (in)); } else { ((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR] = val;}
+#define RWRITEIDX16(in, val)	if(rdp_range_check((in) << 1)) { printf("Write16: Address %08x out of range!\n", (in) << 1); fflush(stdout); fatalerror("Address %08x out of range!\n", (in) << 1); } else { ((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR] = val;}
+#define RWRITEIDX32(in, val)	if(rdp_range_check((in) << 2)) { printf("Write32: Address %08x out of range!\n", (in) << 2); fflush(stdout); fatalerror("Address %08x out of range!\n", (in) << 2); } else { rdram[(in)] = val;}
+#else
+#define RREADADDR8(in) (((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR])
+#define RREADIDX16(in) (((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR])
+#define RREADIDX32(in) (rdram[(in)])
+
+#define RWRITEADDR8(in, val)	((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR] = val;
+#define RWRITEIDX16(in, val)	((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR] = val;
+#define RWRITEIDX32(in, val)	rdram[(in)] = val
+#endif
+
+#define U_RREADADDR8(in) (((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR])
+#define U_RREADIDX16(in) (((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR])
+#define U_RREADIDX32(in) (rdram[(in)])
+
+#define U_RWRITEADDR8(in, val)	((UINT8*)rdram)[(in) ^ BYTE_ADDR_XOR] = val;
+#define U_RWRITEIDX16(in, val)	((UINT16*)rdram)[(in) ^ WORD_ADDR_XOR] = val;
+#define U_RWRITEIDX32(in, val)	rdram[(in)] = val
 
 #define GETLOWCOL(x)	(((x) & 0x3e) << 2)
 #define GETMEDCOL(x)	(((x) & 0x7c0) >> 3)
 #define GETHICOL(x)		(((x) & 0xf800) >> 8)
 
-#define HREADADDR8(in)			(((in) <= MEM8_LIMIT) ? (m_rdp->HiddenBits[(in) ^ BYTE_ADDR_XOR]) : 0)
-#define HWRITEADDR8(in, val)	{if ((in) <= MEM8_LIMIT) m_rdp->HiddenBits[(in) ^ BYTE_ADDR_XOR] = val;}
+#define HREADADDR8(in)			/*(((in) <= MEM8_LIMIT) ? */(HiddenBits[(in) ^ BYTE_ADDR_XOR])/* : 0)*/
+#define HWRITEADDR8(in, val)	/*{if ((in) <= MEM8_LIMIT) */HiddenBits[(in) ^ BYTE_ADDR_XOR] = val;/*}*/
 
 //sign-extension macros
 #define SIGN22(x)	(((x) & 0x200000) ? ((x) | ~0x3fffff) : ((x) & 0x3fffff))
@@ -83,19 +112,30 @@
 
 #define KURT_AKELEY_SIGN9(x)	((((x) & 0x180) == 0x180) ? ((x) | ~0x1ff) : ((x) & 0x1ff))
 
-/*****************************************************************************/
+#define SPAN_R		(0)
+#define SPAN_G		(1)
+#define SPAN_B		(2)
+#define SPAN_A		(3)
+#define SPAN_S		(4)
+#define SPAN_T		(5)
+#define SPAN_W		(6)
+#define SPAN_Z		(7)
 
-class n64_periphs;
+#define RDP_CVG_SPAN_MAX			(1024)
 
-namespace N64
-{
+#define EXTENT_AUX_COUNT			(sizeof(rdp_span_aux)*(480*192)) // Screen coverage *192, more or less
 
-namespace RDP
-{
+/*****************************************************************************/
 
-class Processor;
-class MiscStateT;
-class OtherModesT;
+class n64_periphs;
+class n64_rdp;
+
+struct MiscStateT;
+struct OtherModesT;
+struct CombineModesT;
+struct ColorInputsT;
+struct SpanBaseT;
+struct Rectangle;
 
 class Color
 {
@@ -124,159 +164,215 @@
 	BIT_DEPTH_COUNT
 };
 
-class Tile
+class SpanParam
 {
 	public:
-		int format;	// Image data format: RGBA, YUV, CI, IA, I
-		int size; // Size of texel element: 4b, 8b, 16b, 32b
-		int line; // Size of tile line in bytes
-		int tmem; // Starting tmem address for this tile in bytes
-		int palette; // Palette number for 4b CI texels
-		int ct, mt, cs, ms; // Clamp / mirror enable bits for S / T direction
-		int mask_t, shift_t, mask_s, shift_s; // Mask values / LOD shifts
-		UINT16 sl, tl, sh, th;		// 10.2 fixed-point, starting and ending texel row / column
-		int num;
+		union
+		{
+			UINT32 w;
+#ifdef LSB_FIRST
+			struct { UINT16 l; INT16 h; } h;
+#else
+			struct { INT16 h; UINT16 l; } h;
+#endif
+		};
 };
 
-class MiscStateT
+struct N64Tile
 {
-	public:
-		MiscStateT()
-		{
-			CurrentPixCvg = 0;
-			CurrentMemCvg = 0;
-			CurrentCvgBit = 0;
-			CurrentPixOverlap = 0;
+	int format;	// Image data format: RGBA, YUV, CI, IA, I
+	int size; // Size of texel element: 4b, 8b, 16b, 32b
+	int line; // Size of tile line in bytes
+	int tmem; // Starting tmem address for this tile in bytes
+	int palette; // Palette number for 4b CI texels
+	int ct, mt, cs, ms; // Clamp / mirror enable bits for S / T direction
+	int mask_t, shift_t, mask_s, shift_s; // Mask values / LOD shifts
+	UINT16 sl, tl, sh, th;		// 10.2 fixed-point, starting and ending texel row / column
+	int num;
+};
 
-			MaxLevel = 0;
-			MinLevel = 0;
-		}
+struct SpanBaseT
+{
+	int m_span_dr;
+	int m_span_dg;
+	int m_span_db;
+	int m_span_da;
+	int m_span_ds;
+	int m_span_dt;
+	int m_span_dw;
+	int m_span_dz;
+	int m_span_dymax;
+	int m_span_dzpix;
+	int m_span_drdy;
+	int m_span_dgdy;
+	int m_span_dbdy;
+	int m_span_dady;
+	int m_span_dzdy;
+};
 
-		int FBFormat;				// Framebuffer pixel format index (0 - I, 1 - IA, 2 - CI, 3 - RGBA)
-		int FBSize;					// Framebuffer pixel size index (0 - 4bpp, 1 - 8bpp, 2 - 16bpp, 3 - 32bpp)
-		int FBWidth;				// Framebuffer width, in pixels
-		int FBHeight;				// Framebuffer height, in scanlines
-		UINT32 FBAddress;			// Framebuffer source address offset (in bytes) from start of RDRAM
+struct MiscStateT
+{
+	MiscStateT()
+	{
+		MaxLevel = 0;
+		MinLevel = 0;
+	}
 
-		UINT32 ZBAddress;			// Z-buffer source address offset (in bytes) from start of RDRAM
+	int FBFormat;				// Framebuffer pixel format index (0 - I, 1 - IA, 2 - CI, 3 - RGBA)
+	int FBSize;					// Framebuffer pixel size index (0 - 4bpp, 1 - 8bpp, 2 - 16bpp, 3 - 32bpp)
+	int FBWidth;				// Framebuffer width, in pixels
+	int FBHeight;				// Framebuffer height, in scanlines
+	UINT32 FBAddress;			// Framebuffer source address offset (in bytes) from start of RDRAM
 
-		int TIFormat;				// Format for Texture Interface (TI) transfers
-		int TISize;					// Size (in bytes) of TI transfers
-		int TIWidth;				// Width (in pixels) of TI transfers
-		UINT32 TIAddress;			// Destination address for TI transfers
+	UINT32 ZBAddress;			// Z-buffer source address offset (in bytes) from start of RDRAM
 
-		UINT32 CurrentPixCvg;		// Coverage for the current pixel
-		UINT32 CurrentMemCvg;		// Incoming coverage, in memory, for the current pixel
-		UINT32 CurrentCvgBit;		// Bitfield representation of current coverage value
-		UINT32 CurrentPixOverlap;	// Current overlap value, in coverage indices, for the current pixel
+	int TIFormat;				// Format for Texture Interface (TI) transfers
+	int TISize;					// Size (in bytes) of TI transfers
+	int TIWidth;				// Width (in pixels) of TI transfers
+	UINT32 TIAddress;			// Destination address for TI transfers
 
-		UINT8 RandomSeed;			// %HACK%, adds 19 each time it's read and is more or less random
+	UINT8 RandomSeed;			// %HACK%, adds 19 each time it's read and is more or less random
 
-		int SpecialBlendSelect0;	// Special blend-mode select for cycle 0
-		int SpecialBlendSelect1;	// Special blend-mode select for cycle 1
+	int SpecialBlendSelect0;	// Special blend-mode select for cycle 0
+	int SpecialBlendSelect1;	// Special blend-mode select for cycle 1
 
-		UINT32 MaxLevel;			// Maximum LOD level for texture filtering
-		UINT32 MinLevel;			// Minimum LOD level for texture filtering
+	UINT32 MaxLevel;			// Maximum LOD level for texture filtering
+	UINT32 MinLevel;			// Minimum LOD level for texture filtering
 
-		UINT16 PrimitiveZ;			// Forced Z value for current primitive, if applicable
-		UINT16 PrimitiveDZ;			// Forced Delta-Z value for current primitive, if applicable
+	UINT16 PrimitiveZ;			// Forced Z value for current primitive, if applicable
+	UINT16 PrimitiveDZ;			// Forced Delta-Z value for current primitive, if applicable
 };
 
-class CombineModes
+struct CombineModesT
 {
-	public:
-		int sub_a_rgb0;
-		int sub_b_rgb0;
-		int mul_rgb0;
-		int add_rgb0;
-		int sub_a_a0;
-		int sub_b_a0;
-		int mul_a0;
-		int add_a0;
-
-		int sub_a_rgb1;
-		int sub_b_rgb1;
-		int mul_rgb1;
-		int add_rgb1;
-		int sub_a_a1;
-		int sub_b_a1;
-		int mul_a1;
-		int add_a1;
+	int sub_a_rgb0;
+	int sub_b_rgb0;
+	int mul_rgb0;
+	int add_rgb0;
+	int sub_a_a0;
+	int sub_b_a0;
+	int mul_a0;
+	int add_a0;
+
+	int sub_a_rgb1;
+	int sub_b_rgb1;
+	int mul_rgb1;
+	int add_rgb1;
+	int sub_a_a1;
+	int sub_b_a1;
+	int mul_a1;
+	int add_a1;
 };
 
-class OtherModesT
+struct OtherModesT
 {
-	public:
-		int cycle_type;
-		bool persp_tex_en;
-		bool detail_tex_en;
-		bool sharpen_tex_en;
-		bool tex_lod_en;
-		bool en_tlut;
-		bool tlut_type;
-		bool sample_type;
-		bool mid_texel;
-		bool bi_lerp0;
-		bool bi_lerp1;
-		bool convert_one;
-		bool key_en;
-		int rgb_dither_sel;
-		int alpha_dither_sel;
-		int blend_m1a_0;
-		int blend_m1a_1;
-		int blend_m1b_0;
-		int blend_m1b_1;
-		int blend_m2a_0;
-		int blend_m2a_1;
-		int blend_m2b_0;
-		int blend_m2b_1;
-		int tex_edge;
-		bool force_blend;
-		bool alpha_cvg_select;
-		bool cvg_times_alpha;
-		int z_mode;
-		int cvg_dest;
-		bool color_on_cvg;
-		bool image_read_en;
-		bool z_update_en;
-		bool z_compare_en;
-		bool antialias_en;
-		bool z_source_sel;
-		bool dither_alpha_en;
-		bool alpha_compare_en;
+	int cycle_type;
+	bool persp_tex_en;
+	bool detail_tex_en;
+	bool sharpen_tex_en;
+	bool tex_lod_en;
+	bool en_tlut;
+	bool tlut_type;
+	bool sample_type;
+	bool mid_texel;
+	bool bi_lerp0;
+	bool bi_lerp1;
+	bool convert_one;
+	bool key_en;
+	int rgb_dither_sel;
+	int alpha_dither_sel;
+	int blend_m1a_0;
+	int blend_m1a_1;
+	int blend_m1b_0;
+	int blend_m1b_1;
+	int blend_m2a_0;
+	int blend_m2a_1;
+	int blend_m2b_0;
+	int blend_m2b_1;
+	int tex_edge;
+	bool force_blend;
+	bool alpha_cvg_select;
+	bool cvg_times_alpha;
+	int z_mode;
+	int cvg_dest;
+	bool color_on_cvg;
+	UINT8 image_read_en;
+	bool z_update_en;
+	bool z_compare_en;
+	bool antialias_en;
+	bool z_source_sel;
+	bool dither_alpha_en;
+	bool alpha_compare_en;
 };
 
-class ColorInputsT
+struct ColorInputsT
 {
-	public:
-		// combiner inputs
-		UINT8 *combiner_rgbsub_a_r[2];
-		UINT8 *combiner_rgbsub_a_g[2];
-		UINT8 *combiner_rgbsub_a_b[2];
-		UINT8 *combiner_rgbsub_b_r[2];
-		UINT8 *combiner_rgbsub_b_g[2];
-		UINT8 *combiner_rgbsub_b_b[2];
-		UINT8 *combiner_rgbmul_r[2];
-		UINT8 *combiner_rgbmul_g[2];
-		UINT8 *combiner_rgbmul_b[2];
-		UINT8 *combiner_rgbadd_r[2];
-		UINT8 *combiner_rgbadd_g[2];
-		UINT8 *combiner_rgbadd_b[2];
-
-		UINT8 *combiner_alphasub_a[2];
-		UINT8 *combiner_alphasub_b[2];
-		UINT8 *combiner_alphamul[2];
-		UINT8 *combiner_alphaadd[2];
-
-		// blender input
-		UINT8 *blender1a_r[2];
-		UINT8 *blender1a_g[2];
-		UINT8 *blender1a_b[2];
-		UINT8 *blender1b_a[2];
-		UINT8 *blender2a_r[2];
-		UINT8 *blender2a_g[2];
-		UINT8 *blender2a_b[2];
-		UINT8 *blender2b_a[2];
+	// combiner inputs
+	UINT8 *combiner_rgbsub_a_r[2];
+	UINT8 *combiner_rgbsub_a_g[2];
+	UINT8 *combiner_rgbsub_a_b[2];
+	UINT8 *combiner_rgbsub_b_r[2];
+	UINT8 *combiner_rgbsub_b_g[2];
+	UINT8 *combiner_rgbsub_b_b[2];
+	UINT8 *combiner_rgbmul_r[2];
+	UINT8 *combiner_rgbmul_g[2];
+	UINT8 *combiner_rgbmul_b[2];
+	UINT8 *combiner_rgbadd_r[2];
+	UINT8 *combiner_rgbadd_g[2];
+	UINT8 *combiner_rgbadd_b[2];
+
+	UINT8 *combiner_alphasub_a[2];
+	UINT8 *combiner_alphasub_b[2];
+	UINT8 *combiner_alphamul[2];
+	UINT8 *combiner_alphaadd[2];
+
+	// blender input
+	UINT8 *blender1a_r[2];
+	UINT8 *blender1a_g[2];
+	UINT8 *blender1a_b[2];
+	UINT8 *blender1b_a[2];
+	UINT8 *blender2a_r[2];
+	UINT8 *blender2a_g[2];
+	UINT8 *blender2a_b[2];
+	UINT8 *blender2b_a[2];
+};
+
+// This is enormous and horrible
+struct rdp_span_aux
+{
+	UINT32				m_unscissored_rx;
+	UINT16				m_cvg[RDP_CVG_SPAN_MAX];
+	Color				MemoryColor;
+	Color				PixelColor;
+	Color				InvPixelColor;
+	Color				BlendedPixelColor;
+	Color				CombinedColor;
+	Color				Texel0Color;
+	Color				Texel1Color;
+	Color				NextTexelColor;
+	Color				BlendColor;				/* constant blend color */
+	Color				PrimColor;				/* flat primitive color */
+	Color				EnvColor;				/* generic color constant ('environment') */
+	Color				FogColor;				/* generic color constant ('fog') */
+	Color				ShadeColor;				/* gouraud-shaded color */
+	Color				KeyScale;				/* color-keying constant */
+	Color				NoiseColor;				/* noise */
+	UINT8				LODFraction;			/* Z-based LOD fraction for this poly */
+	UINT8				PrimLODFraction;		/* fixed LOD fraction for this poly */
+	ColorInputsT		ColorInputs;
+	UINT32				CurrentPixCvg;
+	UINT32				CurrentMemCvg;
+	UINT32				CurrentCvgBit;
+	UINT32				CurrentPixOverlap;
+	INT32				ShiftA;
+	INT32				ShiftB;
+	INT32				m_precomp_s;
+	INT32				m_precomp_t;
+	UINT8				BlendEnable;
+	bool				PreWrap;
+	INT32				m_dzpix_enc;
+	UINT8				*m_tmem;				/* pointer to texture cache for this polygon */
+	bool				m_start_span;
 };
 
 struct Rectangle
@@ -287,138 +383,33 @@
 	UINT16 m_yh;	// 10.2 fixed-point
 };
 
-class Processor
+struct rdp_poly_state
 {
-	public:
-		Processor()
-		{
-			m_cmd_ptr = 0;
-			m_cmd_cur = 0;
-
-			m_start = 0;
-			m_end = 0;
-			m_current = 0;
-			m_status = 0x88;
-
-			for (int i = 0; i < 8; i++)
-			{
-				m_tiles[i].num = i;
-			}
-
-			OneColor.c = 0xffffffff;
-			ZeroColor.c = 0x00000000;
-
-			ColorInputs.combiner_rgbsub_a_r[0] = ColorInputs.combiner_rgbsub_a_r[1] = &OneColor.i.r;
-			ColorInputs.combiner_rgbsub_a_g[0] = ColorInputs.combiner_rgbsub_a_g[1] = &OneColor.i.g;
-			ColorInputs.combiner_rgbsub_a_b[0] = ColorInputs.combiner_rgbsub_a_b[1] = &OneColor.i.b;
-			ColorInputs.combiner_rgbsub_b_r[0] = ColorInputs.combiner_rgbsub_b_r[1] = &OneColor.i.r;
-			ColorInputs.combiner_rgbsub_b_g[0] = ColorInputs.combiner_rgbsub_b_g[1] = &OneColor.i.g;
-			ColorInputs.combiner_rgbsub_b_b[0] = ColorInputs.combiner_rgbsub_b_b[1] = &OneColor.i.b;
-			ColorInputs.combiner_rgbmul_r[0] = ColorInputs.combiner_rgbmul_r[1] = &OneColor.i.r;
-			ColorInputs.combiner_rgbmul_g[0] = ColorInputs.combiner_rgbmul_g[1] = &OneColor.i.g;
-			ColorInputs.combiner_rgbmul_b[0] = ColorInputs.combiner_rgbmul_b[1] = &OneColor.i.b;
-			ColorInputs.combiner_rgbadd_r[0] = ColorInputs.combiner_rgbadd_r[1] = &OneColor.i.r;
-			ColorInputs.combiner_rgbadd_g[0] = ColorInputs.combiner_rgbadd_g[1] = &OneColor.i.g;
-			ColorInputs.combiner_rgbadd_b[0] = ColorInputs.combiner_rgbadd_b[1] = &OneColor.i.b;
-
-			ColorInputs.combiner_alphasub_a[0] = ColorInputs.combiner_alphasub_a[1] = &OneColor.i.a;
-			ColorInputs.combiner_alphasub_b[0] = ColorInputs.combiner_alphasub_b[1] = &OneColor.i.a;
-			ColorInputs.combiner_alphamul[0] = ColorInputs.combiner_alphamul[1] = &OneColor.i.a;
-			ColorInputs.combiner_alphaadd[0] = ColorInputs.combiner_alphaadd[1] = &OneColor.i.a;
-
-			ColorInputs.blender1a_r[0] = ColorInputs.blender1a_r[1] = &PixelColor.i.r;
-			ColorInputs.blender1a_g[0] = ColorInputs.blender1a_g[1] = &PixelColor.i.r;
-			ColorInputs.blender1a_b[0] = ColorInputs.blender1a_b[1] = &PixelColor.i.r;
-			ColorInputs.blender1b_a[0] = ColorInputs.blender1b_a[1] = &PixelColor.i.r;
-			ColorInputs.blender2a_r[0] = ColorInputs.blender2a_r[1] = &PixelColor.i.r;
-			ColorInputs.blender2a_g[0] = ColorInputs.blender2a_g[1] = &PixelColor.i.r;
-			ColorInputs.blender2a_b[0] = ColorInputs.blender2a_b[1] = &PixelColor.i.r;
-			ColorInputs.blender2b_a[0] = ColorInputs.blender2b_a[1] = &PixelColor.i.r;
-
-			m_tmem = NULL;
-
-			m_machine = NULL;
-
-			//memset(m_hidden_bits, 3, 8388608);
-
-			PrimLODFraction = 0;
-			LODFraction = 0;
-
-			for (int i = 0; i < 256; i++)
-			{
-				m_gamma_table[i] = sqrt((float)(i << 6));
-				m_gamma_table[i] <<= 1;
-			}
+	n64_rdp *			m_rdp;					/* pointer back to the RDP state */
 
-			for (int i = 0; i < 0x4000; i++)
-			{
-				m_gamma_dither_table[i] = sqrt((float)i);
-				m_gamma_dither_table[i] <<= 1;
-			}
-
-			z_build_com_table();
-
-			for (int i = 0; i < 0x4000; i++)
-			{
-				UINT32 exponent = (i >> 11) & 7;
-				UINT32 mantissa = i & 0x7ff;
-				z_complete_dec_table[i] = ((mantissa << z_dec_table[exponent].shift) + z_dec_table[exponent].add) & 0x3fffff;
-			}
-
-			precalc_cvmask_derivatives();
-
-			for(int i = 0; i < 0x200; i++)
-			{
-				switch((i >> 7) & 3)
-				{
-				case 0:
-				case 1:
-					m_special_9bit_clamptable[i] = i & 0xff;
-					break;
-				case 2:
-					m_special_9bit_clamptable[i] = 0xff;
-					break;
-				case 3:
-					m_special_9bit_clamptable[i] = 0;
-					break;
-				}
-			}
-
-			for(int i = 0; i < 32; i++)
-			{
-				ReplicatedRGBA[i] = (i << 3) | ((i >> 2) & 7);
-			}
-		}
-
-		~Processor() { }
-
-		void	Dasm(char *buffer);
+	MiscStateT			MiscState;				/* miscellaneous rasterizer bits */
+	OtherModesT			OtherModes;				/* miscellaneous rasterizer bits (2) */
+	SpanBaseT			SpanBase;				/* span initial values for triangle rasterization */
+	Rectangle			Scissor;				/* screen-space scissor bounds */
+	UINT32				FillColor;				/* poly fill color */
+	N64Tile				m_tiles[8];				/* texture tile state */
+	UINT8				m_tmem[0x1000];			/* texture cache */
+	int					tilenum;				/* texture tile index */
+	bool				flip;					/* left-major / right-major flip */
+	bool				rect;					/* primitive is rectangle (vs. triangle) */
+};
 
-		void	ProcessList();
-		UINT32	ReadData(UINT32 address);
+//class n64_state;
 
-		void set_span_base(int dr, int dg, int db, int da, int ds, int dt, int dw, int dz, int dymax, int dzpix)
-		{
-			m_span_dr = dr;
-			m_span_dg = dg;
-			m_span_db = db;
-			m_span_da = da;
-			m_span_ds = ds;
-			m_span_dt = dt;
-			m_span_dw = dw;
-			m_span_dz = dz;
-			m_span_dymax = dymax;
-			m_span_dzpix = dzpix;
-		}
+class n64_rdp : public poly_manager<UINT32, rdp_poly_state, 8, 32000>
+{
+	public:
+		typedef void (n64_rdp::*Writer) (UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		typedef void (n64_rdp::*Reader) (UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object);
+		typedef void (n64_rdp::*Copier) (UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, int CurrentPixCvg, const rdp_poly_state &object);
+		typedef void (n64_rdp::*Filler) (UINT32 curpixel, const rdp_poly_state &object);
 
-		void set_span_base_y(int dr, int dg, int db, int da, int dz)
-		{
-			m_span_drdy = dr;
-			m_span_dgdy = dg;
-			m_span_dbdy = db;
-			m_span_dady = da;
-			m_span_dzdy = dz;
-		}
+		n64_rdp(n64_state &state);
 
 		running_machine &machine() const { assert(m_machine != NULL); return *m_machine; }
 
@@ -437,13 +428,23 @@
 			}
 		}
 
+		void		ProcessList();
+		UINT32		ReadData(UINT32 address);
+		void		Dasm(char *buffer);
+
 		void		SetMachine(running_machine& machine) { m_machine = &machine; }
 
 		// CPU-visible registers
-		void		SetStartReg(UINT32 val) { m_start = val; }
+		void		SetStartReg(UINT32 val)
+		{
+			m_start = val;
+		}
 		UINT32		GetStartReg() const { return m_start; }
 
-		void		SetEndReg(UINT32 val) { m_end = val; }
+		void		SetEndReg(UINT32 val)
+		{
+			m_end = val;
+		}
 		UINT32		GetEndReg() const { return m_end; }
 
 		void		SetCurrentReg(UINT32 val) { m_current = val; }
@@ -453,26 +454,25 @@
 		UINT32		GetStatusReg() const { return m_status; }
 
 		// Internal state
-		CombineModes*	GetCombine() { return &m_combine; }
+		CombineModesT*	GetCombine() { return &m_combine; }
 
 		// Color Combiner
 		INT32		ColorCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d);
 		INT32		AlphaCombinerEquation(INT32 a, INT32 b, INT32 c, INT32 d);
-		void		ColorCombiner2Cycle(bool noisecompute);
-		void		ColorCombiner1Cycle(bool noisecompute);
-		void		SetSubAInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code);
-		void		SetSubBInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code);
-		void		SetMulInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code);
-		void		SetAddInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code);
-		void		SetSubInputAlpha(UINT8 **input, int code);
-		void		SetMulInputAlpha(UINT8 **input, int code);
+		void		ColorCombiner2Cycle(rdp_span_aux *userdata);
+		void		ColorCombiner1Cycle(rdp_span_aux *userdata);
+		void		SetSubAInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata);
+		void		SetSubBInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata);
+		void		SetMulInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata);
+		void		SetAddInputRGB(UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, int code, rdp_span_aux *userdata);
+		void		SetSubInputAlpha(UINT8 **input, int code, rdp_span_aux *userdata);
+		void		SetMulInputAlpha(UINT8 **input, int code, rdp_span_aux *userdata);
 
 		// Texture memory
 		UINT8*		GetTMEM() { return m_tmem; }
 		UINT16*		GetTMEM16() { return (UINT16*)m_tmem; }
 		UINT32*		GetTMEM32() { return (UINT32*)m_tmem; }
 		UINT16*		GetTLUT() { return (UINT16*)(m_tmem + 0x800); }
-		Tile*		GetTiles(){ return m_tiles; }
 
 		// Emulation Accelerators
 		UINT8		GetRandom() { return MiscState.RandomSeed += 0x13; }
@@ -487,25 +487,30 @@
 		INT32*		GetK5() { return &m_k5; }
 
 		// Blender-related (move into RDP::Blender)
-		void		SetBlenderInput(int cycle, int which, UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, UINT8 **input_a, int a, int b);
+		void		SetBlenderInput(int cycle, int which, UINT8 **input_r, UINT8 **input_g, UINT8 **input_b, UINT8 **input_a, int a, int b, rdp_span_aux *userdata);
+
+		// Span rasterization
+		void	SpanDraw1Cycle(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid);
+		void	SpanDraw2Cycle(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid);
+		void	SpanDrawCopy(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid);
+		void	SpanDrawFill(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid);
 
 		// Render-related (move into eventual drawing-related classes?)
-		Rectangle*		GetScissor() { return &m_scissor; }
 		void			TCDiv(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst);
 		void			TCDivNoPersp(INT32 ss, INT32 st, INT32 sw, INT32* sss, INT32* sst);
 		UINT32			GetLog2(UINT32 lod_clamp);
-		void			RenderSpans(int start, int end, int tilenum, bool flip);
-		void			GetAlphaCvg(UINT8 *comb_alpha);
+		void			RenderSpans(int start, int end, int tilenum, bool flip, extent_t *Spans, bool rect, rdp_poly_state *object);
+		void			GetAlphaCvg(UINT8 *comb_alpha, rdp_span_aux *userdata, const rdp_poly_state &object);
 		const UINT8*	GetBayerMatrix() const { return s_bayer_matrix; }
 		const UINT8*	GetMagicMatrix() const { return s_magic_matrix; }
 		int				GetCurrFIFOIndex() const { return m_cmd_cur; }
 
-		void			ZStore(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 z);
+		void			ZStore(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 z, UINT32 enc);
 		UINT32			ZDecompress(UINT32 zcurpixel);
 		UINT32			DZDecompress(UINT32 zcurpixel, UINT32 dzcurpixel);
 		UINT32			DZCompress(UINT32 value);
 		INT32			NormalizeDZPix(INT32 sum);
-		bool			ZCompare(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 sz, UINT16 dzpix);
+		bool			ZCompare(UINT32 zcurpixel, UINT32 dzcurpixel, UINT32 sz, UINT16 dzpix, rdp_span_aux *userdata, const rdp_poly_state &object);
 
 		// Fullscreen update-related
 		void			VideoUpdate(n64_periphs *n64, bitmap_rgb32 &bitmap);
@@ -549,81 +554,71 @@
 		void		CmdSetMaskImage(UINT32 w1, UINT32 w2);
 		void		CmdSetColorImage(UINT32 w1, UINT32 w2);
 
+		void		RGBAZClip(int sr, int sg, int sb, int sa, int *sz, rdp_span_aux *userdata);
+		void		RGBAZCorrectTriangle(INT32 offx, INT32 offy, INT32* r, INT32* g, INT32* b, INT32* a, INT32* z, rdp_span_aux *userdata, const rdp_poly_state &object);
+
 		void		Triangle(bool shade, bool texture, bool zbuffer);
 		UINT32		AddRightCvg(UINT32 x, UINT32 k);
 		UINT32		AddLeftCvg(UINT32 x, UINT32 k);
 
-		UINT32*		GetCommandData() { return m_cmd_data; }
-		UINT32*		GetTempRectData() { return m_temp_rect_data; }
-
-		void		GetDitherValues(int x, int y, int* cdith, int* adith);
-
-
-		int 			m_span_dr;
-		int 			m_span_drdy;
-		int 			m_span_dg;
-		int 			m_span_dgdy;
-		int 			m_span_db;
-		int 			m_span_dbdy;
-		int 			m_span_da;
-		int 			m_span_dady;
-		int 			m_span_ds;
-		int 			m_span_dt;
-		int 			m_span_dw;
-		int 			m_span_dz;
-		int 			m_span_dzdy;
-		int 			m_span_dymax;
-		int 			m_span_dzpix;
+		void		GetDitherValues(int x, int y, int* cdith, int* adith, const rdp_poly_state &object);
 
 		UINT32*			GetSpecial9BitClampTable() { return m_special_9bit_clamptable; }
 
 		UINT16 decompress_cvmask_frombyte(UINT8 x);
-		void lookup_cvmask_derivatives(UINT32 mask, UINT8* offx, UINT8* offy);
+		void lookup_cvmask_derivatives(UINT32 mask, UINT8* offx, UINT8* offy, rdp_span_aux *userdata);
 
 		MiscStateT		MiscState;
 
 		// Color constants
-		Color			MemoryColor;
-		Color			PixelColor;
-		Color			InvPixelColor;
-		Color			BlendedPixelColor;
-		Color			BlendColor;
-
-		Color			PrimColor;
-		Color			EnvColor;
-		Color			FogColor;
-		Color			CombinedColor;
-		Color			Texel0Color;
-		Color			Texel1Color;
-		Color			NextTexelColor;
-		Color			ShadeColor;
-		Color			KeyScale;
-		Color			NoiseColor;
+		Color			BlendColor;				/* constant blend color */
+		Color			PrimColor;				/* flat primitive color */
+		Color			EnvColor;				/* generic color constant ('environment') */
+		Color			FogColor;				/* generic color constant ('fog') */
+		Color			KeyScale;				/* color-keying constant */
+		UINT8			LODFraction;			/* Z-based LOD fraction for this poly */
+		UINT8			PrimLODFraction;		/* fixed LOD fraction for this poly */
 
 		Color			OneColor;
 		Color			ZeroColor;
 
-		UINT8			LODFraction;
-		UINT8			PrimLODFraction;
-
 		UINT32			FillColor;
 
 		OtherModesT		OtherModes;
-		ColorInputsT	ColorInputs;
-
-		BlenderT		Blender;
 
-		Span Spans[4096];
+		N64BlenderT		Blender;
 
-		FramebufferT	Framebuffer;
-		TexturePipeT	TexPipe;
+		N64TexturePipeT	TexPipe;
 
 		UINT8 HiddenBits[0x800000];
 
 		UINT8 ReplicatedRGBA[32];
 
+		Rectangle		Scissor;
+		SpanBaseT		SpanBase;
+
+		rectangle		visarea;
+
+		void			DrawTriangle(bool shade, bool texture, bool zbuffer, bool rect);
+		void			compute_cvg_noflip(extent_t *Spans, INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl, INT32 base);
+		void			compute_cvg_flip(extent_t *Spans, INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl, INT32 base);
+
+		void*			AuxBuf;
+		UINT32			AuxBufPtr;
+		UINT32			AuxBufIndex;
+
+		void*			ExtentBuf[2];
+		UINT32			ExtentBufPtr[2];
+		UINT32			ExtentBufIndex;
+
+		bool			rdp_range_check(UINT32 addr);
+
+		N64Tile		m_tiles[8];
+
 	protected:
-		CombineModes	m_combine;
+		CombineModesT	m_combine;
+		bool			m_pending_mode_block;
+		bool			m_pipe_clean;
 
 		typedef struct
 		{
@@ -651,8 +646,6 @@
 
 		UINT8*		m_tmem;
 
-		Tile		m_tiles[8];
-
 		running_machine* m_machine;
 
 		// YUV factors
@@ -663,9 +656,6 @@
 		INT32 m_k4;
 		INT32 m_k5;
 
-		// Render-related (move into eventual drawing-related classes?)
-		Rectangle m_scissor;
-
 		// Texture perspective division
 		INT32 m_norm_point_rom[64];
 		INT32 m_norm_slope_rom[64];
@@ -678,8 +668,29 @@
 
 		UINT32 m_special_9bit_clamptable[512];
 
-		INT32 m_dzpix_enc;
-		INT32 m_dz_enc;
+		Writer				_Write[16];
+		Reader				_Read[4];
+		Copier				_Copy[2];
+		Filler				_Fill[2];
+
+		void				_Write16Bit_Cvg0_Blend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write16Bit_Cvg0_NoBlend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write16Bit_Cvg1(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write16Bit_Cvg2(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write16Bit_Cvg3(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write32Bit_Cvg0_Blend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write32Bit_Cvg0_NoBlend(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write32Bit_Cvg1(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write32Bit_Cvg2(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Write32Bit_Cvg3(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Read16Bit_ImgRead0(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Read16Bit_ImgRead1(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Read32Bit_ImgRead0(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Read32Bit_ImgRead1(UINT32 curpixel, rdp_span_aux *userdata, const rdp_poly_state &object);
+		void				_Copy16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, int CurrentPixCvg, const rdp_poly_state &object);
+		void				_Copy32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b, int CurrentPixCvg, const rdp_poly_state &object);
+		void				_Fill16Bit(UINT32 curpixel, const rdp_poly_state &object);
+		void				_Fill32Bit(UINT32 curpixel, const rdp_poly_state &object);
 
 		class ZDecompressEntry
 		{
@@ -701,8 +712,4 @@
 		static const Command m_commands[0x40];
 };
 
-} // namespace RDP
-
-} // namespace N64
-
 #endif // _VIDEO_N64_H_
diff -Nru src-old/mame/video/nmk16.c src/mame/video/nmk16.c
--- src-old/mame/video/nmk16.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/nmk16.c	2012-02-19 16:23:23.000000000 +0100
@@ -425,54 +425,150 @@
 
 // manybloc uses extra flip bits on the sprites, but these break other games
 
-static void nmk16_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority)
+static inline void nmk16_draw_sprite(nmk16_state *state, running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority, UINT16 *spr)
+{
+  if ((spr[0] & 0x0001))
+  {
+    int sx    = (spr[4] & 0x1FF) + state->m_videoshift;
+    int sy    =  spr[6] & 0x1FF;
+    int code  =  spr[3];
+    int color =  spr[7];
+    int w     =  spr[1] & 0x00F;
+    int h     = (spr[1] & 0x0F0) >> 4;
+    int pri   = (spr[0] & 0x0C0) >> 6;
+    int xx,yy,x;
+    int delta = 16;
+
+    if(pri != priority)
+      return;
+
+    if (flip_screen_get(machine))
+    {
+      sx = 368 - sx;
+      sy = 240 - sy;
+      delta = -16;
+    }
+
+    yy = h;
+    do
+    {
+      x = sx;
+      xx = w;
+      do
+      {
+        drawgfx_transpen(bitmap,cliprect,machine.gfx[2],
+            code,
+            color,
+            flip_screen_get(machine), flip_screen_get(machine),
+            ((x + 16) & 0x1FF) - 16,sy & 0x1FF,15);
+        code++;
+        x += delta;
+      } while (--xx >= 0);
+
+      sy += delta;
+    } while (--yy >= 0);
+  }
+}
+
+static inline void nmk16_draw_sprite_flipsupported(nmk16_state *state, running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority, UINT16 *spr)
+{
+  if ((spr[0] & 0x0001))
+  {
+    int sx    = (spr[4] & 0x1FF) + state->m_videoshift;
+    int sy    =  spr[6] & 0x1FF;
+    int code  =  spr[3];
+    int color =  spr[7];
+    int w     =  spr[1] & 0x00F;
+    int h     = (spr[1] & 0x0F0) >> 4;
+    int pri   = (spr[0] & 0x0C0) >> 6;
+    int flipy = (spr[1] & 0x200) >> 9;
+    int flipx = (spr[1] & 0x100) >> 8;
+
+    int xx,yy,x;
+    int delta = 16;
+
+    if(pri != priority)
+      return;
+
+    flipx ^= flip_screen_get(machine);
+    flipy ^= flip_screen_get(machine);
+
+    if (flip_screen_get(machine))
+    {
+      sx = 368 - sx;
+      sy = 240 - sy;
+      delta = -16;
+    }
+
+    yy = h;
+    sy += flipy ? (delta*h) : 0;
+    do
+    {
+      x = sx + (flipx ? (delta*w) : 0);
+      xx = w;
+      do
+      {
+        drawgfx_transpen(bitmap,cliprect,machine.gfx[2],
+            code,
+            color,
+            flipx, flipy,
+            ((x + 16) & 0x1FF) - 16,sy & 0x1FF,15);
+        code++;
+        x += delta * (flipx ? -1 : 1);
+      } while (--xx >= 0);
+      sy += delta * (flipy ? -1 : 1);
+    } while (--yy >= 0);
+  }
+}
+
+static void nmk16_draw_sprites2(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int *swaptbl)
 {
 	nmk16_state *state = machine.driver_data<nmk16_state>();
-	int offs;
+	int i, l, prio;
 
-	for (offs = 0;offs < 0x1000/2;offs += 8)
+  // Priority level (0x10 levels, 4 sub-levels, 0x10 sprites each)
+	for ( i = 0; i < 0x10; i++ )
 	{
-		if ((state->m_spriteram_old2[offs] & 0x0001))
-		{
-			int sx = (state->m_spriteram_old2[offs+4] & 0x1ff) + state->m_videoshift;
-			int sy = (state->m_spriteram_old2[offs+6] & 0x1ff);
-			int code = state->m_spriteram_old2[offs+3];
-			int color = state->m_spriteram_old2[offs+7];
-			int w = (state->m_spriteram_old2[offs+1] & 0x0f);
-			int h = ((state->m_spriteram_old2[offs+1] & 0xf0) >> 4);
-			int pri = (state->m_spriteram_old2[offs] & 0xc0) >> 6;
-			int xx,yy,x;
-			int delta = 16;
+    // Sub-priority level (4 levels)
+    for ( prio = 3; prio >= 0; prio-- )
+    {
+      // Sprite
+      for ( l = 0; l < 0x10; l++ )
+      {
+        nmk16_draw_sprite(state, machine, bitmap, cliprect, prio, state->m_spriteram_old2 + ((swaptbl[i] + l) * 8));
+      }
+    }
+	}
+}
 
-			if(pri != priority)
-				continue;
+static void nmk16_draw_sprites2_flipsupported(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int *swaptbl)
+{
+	nmk16_state *state = machine.driver_data<nmk16_state>();
+	int i, l, prio;
 
-			if (flip_screen_get(machine))
-			{
-				sx = 368 - sx;
-				sy = 240 - sy;
-				delta = -16;
-			}
+  // Priority level (0x10 levels, 4 sub-levels, 0x10 sprites each)
+	for ( i = 0; i < 0x10; i++ )
+	{
+    // Sub-priority level (4 levels)
+    for ( prio = 3; prio >= 0; prio-- )
+    {
+      // Sprite
+      for ( l = 0; l < 0x10; l++ )
+      {
+        nmk16_draw_sprite_flipsupported(state, machine, bitmap, cliprect, prio, state->m_spriteram_old2 + ((swaptbl[i] + l) * 8));
+      }
+    }
+	}
+}
 
-			yy = h;
-			do
-			{
-				x = sx;
-				xx = w;
-				do
-				{
-					drawgfx_transpen(bitmap,cliprect,machine.gfx[2],
-							code,
-							color,
-							flip_screen_get(machine), flip_screen_get(machine),
-							((x + 16) & 0x1ff) - 16,sy & 0x1ff,15);
-					code++;
-					x += delta;
-				} while (--xx >= 0);
+static void nmk16_draw_sprites(running_machine &machine, bitmap_ind16 &bitmap, const rectangle &cliprect, int priority)
+{
+	nmk16_state *state = machine.driver_data<nmk16_state>();
+	int offs;
 
-				sy += delta;
-			} while (--yy >= 0);
-		}
+	for (offs = 0;offs < 0x1000/2;offs += 8)
+	{
+		nmk16_draw_sprite(state, machine, bitmap, cliprect, priority, state->m_spriteram_old2 + offs);
 	}
 }
 
@@ -485,61 +581,11 @@
 	{
 		if (state->m_spriteram_old2[offs] & 0x0001)
 		{
-			int sx = (state->m_spriteram_old2[offs+4] & 0x1ff) + state->m_videoshift;
-			int sy = (state->m_spriteram_old2[offs+6] & 0x1ff);
-			int code = state->m_spriteram_old2[offs+3];
-			int color = state->m_spriteram_old2[offs+7];
-			int w = (state->m_spriteram_old2[offs+1] & 0x0f);
-			int h = ((state->m_spriteram_old2[offs+1] & 0xf0) >> 4);
-			int pri = (state->m_spriteram_old2[offs] & 0xc0) >> 6;
-			int flipy= ((state->m_spriteram_old2[offs+1] & 0x0200) >> 9);
-			int flipx = ((state->m_spriteram_old2[offs+1] & 0x0100) >> 8);
-
-			int xx,yy,x;
-			int delta = 16;
-
-			if(pri != priority)
-				continue;
-
-			flipx ^= flip_screen_get(machine);
-			flipy ^= flip_screen_get(machine);
-
-			if (flip_screen_get(machine))
-			{
-				sx = 368 - sx;
-				sy = 240 - sy;
-				delta = -16;
-			}
-
-			yy = h;
-			sy+=flipy?(delta*h):0;
-			do
-			{
-				x = sx+(flipx?(delta*w):0);
-
-
-				xx = w;
-				do
-				{
-					drawgfx_transpen(bitmap,cliprect,machine.gfx[2],
-							code,
-							color,
-							flipx, flipy,
-							((x + 16) & 0x1ff) - 16,sy & 0x1ff,15);
-
-					code++;
-					x +=delta * ( flipx?-1:1 );
-
-
-				} while (--xx >= 0);
-				sy += delta * ( flipy?-1:1);
-
-			} while (--yy >= 0);
+			nmk16_draw_sprite_flipsupported(state, machine, bitmap, cliprect, priority, state->m_spriteram_old2 + offs);
 		}
 	}
 }
 
-
 SCREEN_UPDATE_IND16( macross )
 {
 	nmk16_state *state = screen.machine().driver_data<nmk16_state>();
@@ -547,10 +593,11 @@
 
 	state->m_bg_tilemap0->draw(bitmap, cliprect, 0,0);
 
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,3);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,2);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,1);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,0);
+	static int macross_swaptbl[0x10] = {
+	0x00, 0x80, 0x20, 0xA0, 0x40, 0xC0, 0x60, 0xE0,
+	0x10, 0x90, 0x30, 0xB0, 0x50, 0xD0, 0x70, 0xF0,
+	};
+	nmk16_draw_sprites2(screen.machine(), bitmap,cliprect, macross_swaptbl);
 
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0,0);
 	return 0;
@@ -565,10 +612,12 @@
 
 	state->m_bg_tilemap0->draw(bitmap, cliprect, 0,0);
 
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,3);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,2);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,1);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,0);
+	// TODO: Fix this swap table; it's currently incorrect
+	static int tdragon_swaptbl[0x10] = {
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+	0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
+	};
+	nmk16_draw_sprites2(screen.machine(), bitmap,cliprect, tdragon_swaptbl);
 
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0,0);
 	return 0;
@@ -583,10 +632,16 @@
 
 	state->m_bg_tilemap0->draw(bitmap, cliprect, 0,0);
 
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,3);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,2);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,1);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,0);
+	// TODO: Fix this swap table; it's currently incorrect
+	static int hachamf_swaptbl[0x10] = {
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+	0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
+	};
+	nmk16_draw_sprites2(screen.machine(), bitmap,cliprect, hachamf_swaptbl);
+/*  nmk16_draw_sprites(screen.machine(), bitmap,cliprect,3);
+    nmk16_draw_sprites(screen.machine(), bitmap,cliprect,2);
+    nmk16_draw_sprites(screen.machine(), bitmap,cliprect,1);
+    nmk16_draw_sprites(screen.machine(), bitmap,cliprect,0);*/
 
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0,0);
 	return 0;
@@ -618,10 +673,12 @@
 	state->m_bg_tilemap0->set_scrollx(0,tharrier_scroll);
 	state->m_bg_tilemap0->draw(bitmap, cliprect, 0,0);
 
-	nmk16_draw_sprites_flipsupported(screen.machine(), bitmap,cliprect,3);
-	nmk16_draw_sprites_flipsupported(screen.machine(), bitmap,cliprect,2);
-	nmk16_draw_sprites_flipsupported(screen.machine(), bitmap,cliprect,1);
-	nmk16_draw_sprites_flipsupported(screen.machine(), bitmap,cliprect,0);
+	// TODO: Fix this swap table; it's currently incorrect
+	static int tharrier_swaptbl[0x10] = {
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+	0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
+	};
+	nmk16_draw_sprites2_flipsupported(screen.machine(), bitmap,cliprect, tharrier_swaptbl);
 
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0,0);
 	return 0;
@@ -696,10 +753,11 @@
 		bg_tilemap->draw(bitmap, cliprect, 0,0);
 	}
 
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,3);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,2);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,1);
-	nmk16_draw_sprites(screen.machine(), bitmap,cliprect,0);
+	static int gunnail_swaptbl[0x10] = {
+	0x00, 0x80, 0x20, 0xA0, 0x40, 0xC0, 0x60, 0xE0,
+	0x10, 0x90, 0x30, 0xB0, 0x50, 0xD0, 0x70, 0xF0,
+	};
+	nmk16_draw_sprites2(screen.machine(), bitmap,cliprect, gunnail_swaptbl);
 
 	state->m_tx_tilemap->set_scrollx(0,-state->m_videoshift);
 	state->m_tx_tilemap->draw(bitmap, cliprect, 0,0);
diff -Nru src-old/mame/video/ppu2c0x.c src/mame/video/ppu2c0x.c
--- src-old/mame/video/ppu2c0x.c	2012-01-29 17:34:26.000000000 +0100
+++ src/mame/video/ppu2c0x.c	2012-02-06 02:30:22.000000000 +0100
@@ -25,7 +25,6 @@
 
 #define ADDRESS_MAP_MODERN
 #include "emu.h"
-#include "profiler.h"
 #include "video/ppu2c0x.h"
 
 
diff -Nru src-old/mame/video/psikyosh.c src/mame/video/psikyosh.c
--- src-old/mame/video/psikyosh.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/psikyosh.c	2012-02-06 02:30:22.000000000 +0100
@@ -63,7 +63,6 @@
 */
 
 #include "emu.h"
-#include "profiler.h"
 #include "drawgfxm.h"
 #include "includes/psikyosh.h"
 #include "ui.h"
diff -Nru src-old/mame/video/rdpblend.c src/mame/video/rdpblend.c
--- src-old/mame/video/rdpblend.c	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdpblend.c	2012-02-11 17:05:10.000000000 +0100
@@ -2,50 +2,45 @@
 #include "includes/n64.h"
 #include "video/n64.h"
 
-namespace N64
-{
-
-namespace RDP
-{
-
-bool BlenderT::Blend1Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel)
+bool N64BlenderT::Blend1Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
 	INT32 r, g, b;
 
-	if (!m_rdp->OtherModes.alpha_cvg_select)
+	if (!object.OtherModes.alpha_cvg_select)
 	{
-		DitherA(&m_rdp->PixelColor.i.a, adseed);
+		DitherA(&userdata->PixelColor.i.a, adseed);
 	}
 
-	DitherA(&m_rdp->ShadeColor.i.a, adseed);
+	DitherA(&userdata->ShadeColor.i.a, adseed);
 
-	if (!AlphaCompare(m_rdp->PixelColor.i.a))
+	if (!AlphaCompare(userdata->PixelColor.i.a, userdata, object))
 	{
 		return false;
 	}
 
-	if (m_rdp->OtherModes.antialias_en ? (!m_rdp->MiscState.CurrentPixCvg) : (!m_rdp->MiscState.CurrentCvgBit))
+	if (object.OtherModes.antialias_en ? (!userdata->CurrentPixCvg) : (!userdata->CurrentCvgBit))
 	{
 		return false;
 	}
 
-	bool dontblend = (partialreject && m_rdp->PixelColor.i.a >= 0xff);
-	if (!BlendEnable || dontblend)
+	bool dontblend = (partialreject && userdata->PixelColor.i.a >= 0xff);
+	if (!userdata->BlendEnable || dontblend)
 	{
-		r = *m_rdp->ColorInputs.blender1a_r[0];
-		g = *m_rdp->ColorInputs.blender1a_g[0];
-		b = *m_rdp->ColorInputs.blender1a_b[0];
+		r = *userdata->ColorInputs.blender1a_r[0];
+		g = *userdata->ColorInputs.blender1a_g[0];
+		b = *userdata->ColorInputs.blender1a_b[0];
 	}
 	else
 	{
-		m_rdp->InvPixelColor.i.a = 0xff - *m_rdp->ColorInputs.blender1b_a[0];
-		BlendEquationCycle0(&r, &g, &b, special_bsel);
+		userdata->InvPixelColor.i.a = 0xff - *userdata->ColorInputs.blender1b_a[0];
+		BlendEquationCycle0(&r, &g, &b, special_bsel, userdata, object);
 	}
 
-	if (m_rdp->OtherModes.rgb_dither_sel < 3)
+	if (object.OtherModes.rgb_dither_sel < 3)
 	{
 		DitherRGB(&r, &g, &b, dith);
 	}
+
 	*fr = r;
 	*fg = g;
 	*fb = b;
@@ -53,49 +48,49 @@
 	return true;
 }
 
-bool BlenderT::Blend2Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel0, int special_bsel1)
+bool N64BlenderT::Blend2Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel0, int special_bsel1, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
-	if (!m_rdp->OtherModes.alpha_cvg_select)
+	if (!object.OtherModes.alpha_cvg_select)
 	{
-		DitherA(&m_rdp->PixelColor.i.a, adseed);
+		DitherA(&userdata->PixelColor.i.a, adseed);
 	}
 
-	DitherA(&m_rdp->ShadeColor.i.a, adseed);
+	DitherA(&userdata->ShadeColor.i.a, adseed);
 
-	if (!AlphaCompare(m_rdp->PixelColor.i.a))
+	if (!AlphaCompare(userdata->PixelColor.i.a, userdata, object))
 	{
 		return false;
 	}
 
-	if (m_rdp->OtherModes.antialias_en ? (!m_rdp->MiscState.CurrentPixCvg) : (!m_rdp->MiscState.CurrentCvgBit))
+	if (object.OtherModes.antialias_en ? (!userdata->CurrentPixCvg) : (!userdata->CurrentCvgBit))
 	{
 		return false;
 	}
 
-	m_rdp->InvPixelColor.i.a = 0xff - *m_rdp->ColorInputs.blender1b_a[0];
+	userdata->InvPixelColor.i.a = 0xff - *userdata->ColorInputs.blender1b_a[0];
 
 	INT32 r, g, b;
-	BlendEquationCycle0(&r, &g, &b, special_bsel0);
+	BlendEquationCycle0(&r, &g, &b, special_bsel0, userdata, object);
 
-	m_rdp->BlendedPixelColor.i.r = r;
-	m_rdp->BlendedPixelColor.i.g = g;
-	m_rdp->BlendedPixelColor.i.b = b;
-	m_rdp->BlendedPixelColor.i.a = m_rdp->PixelColor.i.a;
-
-	bool dontblend = (partialreject && m_rdp->PixelColor.i.a >= 0xff);
-	if (!BlendEnable || dontblend)
-	{
-		r = *m_rdp->ColorInputs.blender1a_r[1];
-		g = *m_rdp->ColorInputs.blender1a_g[1];
-		b = *m_rdp->ColorInputs.blender1a_b[1];
+	userdata->BlendedPixelColor.i.r = r;
+	userdata->BlendedPixelColor.i.g = g;
+	userdata->BlendedPixelColor.i.b = b;
+	userdata->BlendedPixelColor.i.a = userdata->PixelColor.i.a;
+
+	bool dontblend = (partialreject && userdata->PixelColor.i.a >= 0xff);
+	if (!userdata->BlendEnable || dontblend)
+	{
+		r = *userdata->ColorInputs.blender1a_r[1];
+		g = *userdata->ColorInputs.blender1a_g[1];
+		b = *userdata->ColorInputs.blender1a_b[1];
 	}
 	else
 	{
-		m_rdp->InvPixelColor.i.a = 0xff - *m_rdp->ColorInputs.blender1b_a[1];
-		BlendEquationCycle1(&r, &g, &b, special_bsel1);
+		userdata->InvPixelColor.i.a = 0xff - *userdata->ColorInputs.blender1b_a[1];
+		BlendEquationCycle1(&r, &g, &b, special_bsel1, userdata, object);
 	}
 
-	if (m_rdp->OtherModes.rgb_dither_sel < 3)
+	if (object.OtherModes.rgb_dither_sel < 3)
 	{
 		DitherRGB(&r, &g, &b, dith);
 	}
@@ -107,46 +102,46 @@
 	return true;
 }
 
-void BlenderT::BlendEquationCycle0(int* r, int* g, int* b, int bsel_special)
+void N64BlenderT::BlendEquationCycle0(int* r, int* g, int* b, int bsel_special, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
-	UINT8 blend1a = *m_rdp->ColorInputs.blender1b_a[0] >> 3;
-	UINT8 blend2a = *m_rdp->ColorInputs.blender2b_a[0] >> 3;
+	UINT8 blend1a = *userdata->ColorInputs.blender1b_a[0] >> 3;
+	UINT8 blend2a = *userdata->ColorInputs.blender2b_a[0] >> 3;
 
 	if (bsel_special)
 	{
-		blend1a = (blend1a >> ShiftA) & 0x1C;
-		blend2a = (blend2a >> ShiftB) & 0x1C;
+		blend1a = (blend1a >> userdata->ShiftA) & 0x1C;
+		blend2a = (blend2a >> userdata->ShiftB) & 0x1C;
 	}
 
 	UINT32 sum = ((blend1a >> 2) + (blend2a >> 2) + 1) & 0xf;
 
-	*r = (((int)(*m_rdp->ColorInputs.blender1a_r[0]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_r[0]) * (int)(blend2a)));
+	*r = (((int)(*userdata->ColorInputs.blender1a_r[0]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_r[0]) * (int)(blend2a)));
 
-	*g = (((int)(*m_rdp->ColorInputs.blender1a_g[0]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_g[0]) * (int)(blend2a)));
+	*g = (((int)(*userdata->ColorInputs.blender1a_g[0]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_g[0]) * (int)(blend2a)));
 
-	*b = (((int)(*m_rdp->ColorInputs.blender1a_b[0]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_b[0]) * (int)(blend2a)));
+	*b = (((int)(*userdata->ColorInputs.blender1a_b[0]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_b[0]) * (int)(blend2a)));
 
 	if (bsel_special)
 	{
-		*r += (((int)*m_rdp->ColorInputs.blender2a_r[0]) << 2);
-		*g += (((int)*m_rdp->ColorInputs.blender2a_g[0]) << 2);
-		*b += (((int)*m_rdp->ColorInputs.blender2a_b[0]) << 2);
+		*r += (((int)*userdata->ColorInputs.blender2a_r[0]) << 2);
+		*g += (((int)*userdata->ColorInputs.blender2a_g[0]) << 2);
+		*b += (((int)*userdata->ColorInputs.blender2a_b[0]) << 2);
 	}
 	else
 	{
-		*r += (int)*m_rdp->ColorInputs.blender2a_r[0];
-		*g += (int)*m_rdp->ColorInputs.blender2a_g[0];
-		*b += (int)*m_rdp->ColorInputs.blender2a_b[0];
+		*r += (int)*userdata->ColorInputs.blender2a_r[0];
+		*g += (int)*userdata->ColorInputs.blender2a_g[0];
+		*b += (int)*userdata->ColorInputs.blender2a_b[0];
 	}
 
 	*r >>= 2;
 	*g >>= 2;
 	*b >>= 2;
 
-	if (m_rdp->OtherModes.force_blend)
+	if (object.OtherModes.force_blend)
 	{
 		*r >>= 3;
 		*g >>= 3;
@@ -171,46 +166,46 @@
 	if (*b > 255) *b = 255;
 }
 
-void BlenderT::BlendEquationCycle1(INT32* r, INT32* g, INT32* b, int bsel_special)
+void N64BlenderT::BlendEquationCycle1(INT32* r, INT32* g, INT32* b, int bsel_special, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
-	UINT8 blend1a = *m_rdp->ColorInputs.blender1b_a[1] >> 3;
-	UINT8 blend2a = *m_rdp->ColorInputs.blender2b_a[1] >> 3;
+	UINT8 blend1a = *userdata->ColorInputs.blender1b_a[1] >> 3;
+	UINT8 blend2a = *userdata->ColorInputs.blender2b_a[1] >> 3;
 
 	if (bsel_special)
 	{
-		blend1a = (blend1a >> ShiftA) & 0x1C;
-		blend2a = (blend2a >> ShiftB) & 0x1C;
+		blend1a = (blend1a >> userdata->ShiftA) & 0x1C;
+		blend2a = (blend2a >> userdata->ShiftB) & 0x1C;
 	}
 
 	UINT32 sum = ((blend1a >> 2) + (blend2a >> 2) + 1) & 0xf;
 
-	*r = (((int)(*m_rdp->ColorInputs.blender1a_r[1]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_r[1]) * (int)(blend2a)));
+	*r = (((int)(*userdata->ColorInputs.blender1a_r[1]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_r[1]) * (int)(blend2a)));
 
-	*g = (((int)(*m_rdp->ColorInputs.blender1a_g[1]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_g[1]) * (int)(blend2a)));
+	*g = (((int)(*userdata->ColorInputs.blender1a_g[1]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_g[1]) * (int)(blend2a)));
 
-	*b = (((int)(*m_rdp->ColorInputs.blender1a_b[1]) * (int)(blend1a))) +
-		(((int)(*m_rdp->ColorInputs.blender2a_b[1]) * (int)(blend2a)));
+	*b = (((int)(*userdata->ColorInputs.blender1a_b[1]) * (int)(blend1a))) +
+		(((int)(*userdata->ColorInputs.blender2a_b[1]) * (int)(blend2a)));
 
 	if (bsel_special)
 	{
-		*r += (((int)*m_rdp->ColorInputs.blender2a_r[1]) << 2);
-		*g += (((int)*m_rdp->ColorInputs.blender2a_g[1]) << 2);
-		*b += (((int)*m_rdp->ColorInputs.blender2a_b[1]) << 2);
+		*r += (((int)*userdata->ColorInputs.blender2a_r[1]) << 2);
+		*g += (((int)*userdata->ColorInputs.blender2a_g[1]) << 2);
+		*b += (((int)*userdata->ColorInputs.blender2a_b[1]) << 2);
 	}
 	else
 	{
-		*r += (int)*m_rdp->ColorInputs.blender2a_r[1];
-		*g += (int)*m_rdp->ColorInputs.blender2a_g[1];
-		*b += (int)*m_rdp->ColorInputs.blender2a_b[1];
+		*r += (int)*userdata->ColorInputs.blender2a_r[1];
+		*g += (int)*userdata->ColorInputs.blender2a_g[1];
+		*b += (int)*userdata->ColorInputs.blender2a_b[1];
 	}
 
 	*r >>= 2;
 	*g >>= 2;
 	*b >>= 2;
 
-	if (m_rdp->OtherModes.force_blend)
+	if (object.OtherModes.force_blend)
 	{
 		*r >>= 3;
 		*g >>= 3;
@@ -235,12 +230,12 @@
 	if (*b > 255) *b = 255;
 }
 
-bool BlenderT::AlphaCompare(UINT8 alpha)
+bool N64BlenderT::AlphaCompare(UINT8 alpha, const rdp_span_aux *userdata, const rdp_poly_state& object)
 {
 	INT32 threshold;
-	if (m_rdp->OtherModes.alpha_compare_en)
+	if (object.OtherModes.alpha_compare_en)
 	{
-		threshold = (m_rdp->OtherModes.dither_alpha_en) ? m_rdp->GetRandom() : m_rdp->BlendColor.i.a;
+		threshold = (object.OtherModes.dither_alpha_en) ? m_rdp->GetRandom() : userdata->BlendColor.i.a;
 		if (alpha < threshold)
 		{
 			return false;
@@ -250,7 +245,7 @@
 	return true;
 }
 
-void BlenderT::DitherA(UINT8 *a, int dith)
+void N64BlenderT::DitherA(UINT8 *a, int dith)
 {
 	INT32 new_a = *a + dith;
 	if(new_a & 0x100)
@@ -260,7 +255,7 @@
 	*a = (UINT8)new_a;
 }
 
-void BlenderT::DitherRGB(INT32 *r, INT32 *g, INT32 *b, int dith)
+void N64BlenderT::DitherRGB(INT32 *r, INT32 *g, INT32 *b, int dith)
 {
 	if ((*r & 7) > dith)
 	{
@@ -287,7 +282,3 @@
 		}
 	}
 }
-
-} // namespace RDP
-
-} // namespace N64
diff -Nru src-old/mame/video/rdpblend.h src/mame/video/rdpblend.h
--- src-old/mame/video/rdpblend.h	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdpblend.h	2012-02-11 17:05:10.000000000 +0100
@@ -3,52 +3,39 @@
 
 #include "emu.h"
 
-namespace N64
-{
-
-namespace RDP
-{
-
 class OtherModesT;
 class MiscStateT;
-class Processor;
+class n64_rdp;
+class rdp_span_aux;
 class Color;
+struct rdp_poly_state;
 
-class BlenderT
+class N64BlenderT
 {
 	public:
-		BlenderT()
+		N64BlenderT()
 		{
-			BlendEnable = false;
 		}
 
-		bool				Blend2Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int bsel0, int bsel1);
-		bool				Blend1Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel);
+		bool				Blend2Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int bsel0, int bsel1, rdp_span_aux *userdata, const rdp_poly_state& object);
+		bool				Blend1Cycle(UINT32* fr, UINT32* fg, UINT32* fb, int dith, int adseed, int partialreject, int special_bsel, rdp_span_aux *userdata, const rdp_poly_state& object);
 
 		void				SetMachine(running_machine& machine) { m_machine = &machine; }
-		void				SetProcessor(Processor* rdp) { m_rdp = rdp; }
+		void				SetProcessor(n64_rdp* rdp) { m_rdp = rdp; }
 
 		running_machine &machine() const { assert(m_machine != NULL); return *m_machine; }
 
-		bool				BlendEnable;
-		INT32				ShiftA;
-		INT32				ShiftB;
-
 	private:
 		running_machine*	m_machine;
-		Processor*			m_rdp;
+		n64_rdp*			m_rdp;
 
-		void				BlendEquationCycle0(INT32* r, INT32* g, INT32* b, int bsel_special);
-		void				BlendEquationCycle1(INT32* r, INT32* g, INT32* b, int bsel_special);
+		void				BlendEquationCycle0(INT32* r, INT32* g, INT32* b, int bsel_special, rdp_span_aux *userdata, const rdp_poly_state& object);
+		void				BlendEquationCycle1(INT32* r, INT32* g, INT32* b, int bsel_special, rdp_span_aux *userdata, const rdp_poly_state& object);
 
-		bool				AlphaCompare(UINT8 alpha);
+		bool				AlphaCompare(UINT8 alpha, const rdp_span_aux *userdata, const rdp_poly_state& object);
 
 		void				DitherRGB(INT32* r, INT32* g, INT32* b, int dith);
 		void				DitherA(UINT8* a, int dith);
 };
 
-} // namespace RDP
-
-} // namespace N64
-
 #endif // _VIDEO_RDPBLEND_H_
diff -Nru src-old/mame/video/rdpfb.c src/mame/video/rdpfb.c
--- src-old/mame/video/rdpfb.c	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdpfb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-#include "emu.h"
-#include "includes/n64.h"
-#include "video/n64.h"
-
-namespace N64
-{
-
-namespace RDP
-{
-
-void FramebufferT::Write(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-	switch(m_rdp->MiscState.FBSize)
-	{
-		case PIXEL_SIZE_16BIT:
-			Write16Bit(curpixel, r, g, b);
-			break;
-
-		case PIXEL_SIZE_32BIT:
-			Write32Bit(curpixel, r, g, b);
-			break;
-
-		default:
-			fatalerror("Unsupported bit depth: %d\n", m_rdp->MiscState.FBSize);
-			break;
-	}
-}
-
-void FramebufferT::Write16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-#undef CVG_DRAW
-#ifdef CVG_DRAW
-	int covdraw = (CurrentPixCvg - 1) << 5;
-	r = covdraw;
-	g = covdraw;
-	b = covdraw;
-#endif
-
-	UINT32 fb = (m_rdp->MiscState.FBAddress >> 1) + curpixel;
-	UINT32 hb = fb;
-
-#if 0
-	if (m_rdp->MiscState.CurrentPixCvg > 8 && m_rdp->OtherModes.z_mode != 1)
-	{
-		stricterror("FBWRITE_16: CurrentPixCvg %d", m_rdp->MiscState.CurrentPixCvg);
-	}
-#endif
-
-	UINT16 finalcolor = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1);
-	UINT32 finalcvg = 0;
-
-	if (m_rdp->OtherModes.color_on_cvg && !m_pre_wrap)
-	{
-		finalcolor = RREADIDX16(fb) & 0xfffe;
-	}
-
-	switch(m_rdp->OtherModes.cvg_dest)
-	{
-	case 0:
-		if (!m_rdp->Blender.BlendEnable)
-		{
-			finalcvg = (m_rdp->MiscState.CurrentPixCvg - 1) & 7;
-			RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
-			HWRITEADDR8(hb, finalcvg & 3);
-		}
-		else
-		{
-			finalcvg = m_rdp->MiscState.CurrentPixCvg + m_rdp->MiscState.CurrentMemCvg;
-			if (finalcvg & 8)
-			{
-				finalcvg = 7;
-			}
-			RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
-			HWRITEADDR8(hb, finalcvg & 3);
-		}
-		break;
-	case 1:
-		finalcvg = (m_rdp->MiscState.CurrentPixCvg + m_rdp->MiscState.CurrentMemCvg) & 7;
-		RWRITEIDX16(fb, finalcolor | ((finalcvg >> 2) & 1));
-		HWRITEADDR8(hb, finalcvg & 3);
-		break;
-	case 2:
-		RWRITEIDX16(fb, finalcolor | 1);
-		HWRITEADDR8(hb, 3);
-		break;
-	case 3:
-		RWRITEIDX16(fb, finalcolor | ((m_rdp->MiscState.CurrentMemCvg >> 2) & 1));
-		HWRITEADDR8(hb, m_rdp->MiscState.CurrentMemCvg & 3);
-		break;
-	}
-}
-
-void FramebufferT::Write32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-	UINT32 fb = (m_rdp->MiscState.FBAddress >> 2) + curpixel;
-	UINT32 finalcolor = (r << 24) | (g << 16) | (b << 8);//cvg as 3 MSBs of alpha channel;
-	UINT32 finalcvg = 0;
-
-#if 0
-	if (CurrentPixCvg > 8 && m_rdp->OtherModes.z_mode != 1)
-	{
-		stricterror("FBWRITE_16: CurrentPixCvg %d", CurrentPixCvg);
-	}
-#endif
-
-	if (m_rdp->OtherModes.color_on_cvg && !m_pre_wrap)
-	{
-		finalcolor = RREADIDX32(fb) & 0xffffff00;
-	}
-
-	switch(m_rdp->OtherModes.cvg_dest)
-	{
-	case 0: //normal
-		if (!m_rdp->Blender.BlendEnable)
-		{
-			finalcvg = (m_rdp->MiscState.CurrentPixCvg - 1) & 7;
-			finalcolor |= (finalcvg << 5);
-			RWRITEIDX32(fb, finalcolor);
-		}
-		else
-		{
-			finalcvg = m_rdp->MiscState.CurrentPixCvg + m_rdp->MiscState.CurrentMemCvg;
-			if (finalcvg & 8)
-			{
-				finalcvg = 7;
-			}
-			finalcolor |= (finalcvg << 5);
-			RWRITEIDX32(fb, finalcolor);
-		}
-		break;
-	case 1:
-		finalcvg = (m_rdp->MiscState.CurrentPixCvg + m_rdp->MiscState.CurrentMemCvg) & 7;
-		finalcolor |= (finalcvg << 5);
-		RWRITEIDX32(fb, finalcolor);
-		break;
-	case 2:
-		RWRITEIDX32(fb, finalcolor | 0xE0);
-		break;
-	case 3:
-		finalcolor |= (m_rdp->MiscState.CurrentMemCvg << 5);
-		RWRITEIDX32(fb, finalcolor);
-		break;
-	}
-}
-
-void FramebufferT::Read(UINT32 curpixel)
-{
-	switch(m_rdp->MiscState.FBSize)
-	{
-		case PIXEL_SIZE_16BIT:
-			Read16Bit(curpixel);
-			break;
-
-		case PIXEL_SIZE_32BIT:
-			Read32Bit(curpixel);
-			break;
-
-		default:
-			fatalerror("Unsupported bit depth: %d\n", m_rdp->MiscState.FBSize);
-			break;
-	}
-}
-
-void FramebufferT::Read16Bit(UINT32 curpixel)
-{
-	UINT16 fword = RREADIDX16((m_rdp->MiscState.FBAddress >> 1) + curpixel);
-	UINT8 hbyte = HREADADDR8((m_rdp->MiscState.FBAddress >> 1) + curpixel);
-	m_rdp->MemoryColor.i.r = GETHICOL(fword);
-	m_rdp->MemoryColor.i.g = GETMEDCOL(fword);
-	m_rdp->MemoryColor.i.b = GETLOWCOL(fword);
-	if (m_rdp->OtherModes.image_read_en)
-	{
-		m_rdp->MiscState.CurrentMemCvg = ((fword & 1) << 2) | (hbyte & 3);
-		m_rdp->MemoryColor.i.a = m_rdp->MiscState.CurrentMemCvg << 5;
-	}
-	else
-	{
-		m_rdp->MiscState.CurrentMemCvg = 7;
-		m_rdp->MemoryColor.i.a = 0xff;
-	}
-}
-
-void FramebufferT::Read32Bit(UINT32 curpixel)
-{
-	UINT32 mem = RREADIDX32((m_rdp->MiscState.FBAddress >> 2) + curpixel);
-	m_rdp->MemoryColor.i.r = (mem >> 24) & 0xff;
-	m_rdp->MemoryColor.i.g = (mem >> 16) & 0xff;
-	m_rdp->MemoryColor.i.b = (mem >> 8) & 0xff;
-	if (m_rdp->OtherModes.image_read_en)
-	{
-		m_rdp->MiscState.CurrentMemCvg = (mem >> 5) & 7;
-		m_rdp->MemoryColor.i.a = (mem) & 0xff;
-	}
-	else
-	{
-		m_rdp->MiscState.CurrentMemCvg = 7;
-		m_rdp->MemoryColor.i.a = 0xff;
-	}
-}
-
-void FramebufferT::Copy(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-	switch(m_rdp->MiscState.FBSize)
-	{
-		case PIXEL_SIZE_16BIT:
-			Copy16Bit(curpixel, r, g, b);
-			break;
-
-		case PIXEL_SIZE_32BIT:
-			Copy32Bit(curpixel, r, g, b);
-			break;
-
-		default:
-			fatalerror("Unsupported bit depth: %d\n", m_rdp->MiscState.FBSize);
-			break;
-	}
-}
-
-void FramebufferT::Copy16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-	UINT16 val = ((r >> 3) << 11) | ((g >> 3) << 6) | ((b >> 3) << 1) | ((m_rdp->MiscState.CurrentPixCvg >> 2) & 1);
-	RWRITEIDX16((m_rdp->MiscState.FBAddress >> 1) + curpixel, val);
-	HWRITEADDR8((m_rdp->MiscState.FBAddress >> 1) + curpixel, m_rdp->MiscState.CurrentPixCvg & 3);
-}
-
-void FramebufferT::Copy32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b)
-{
-	UINT32 val = (r << 24) | (g << 16) | (b << 8) | (m_rdp->MiscState.CurrentPixCvg << 5);
-	RWRITEIDX32((m_rdp->MiscState.FBAddress >> 2) + curpixel, val);
-}
-
-void FramebufferT::Fill(UINT32 curpixel)
-{
-	switch(m_rdp->MiscState.FBSize)
-	{
-		case PIXEL_SIZE_16BIT:
-			Fill16Bit(curpixel);
-			break;
-
-		case PIXEL_SIZE_32BIT:
-			Fill32Bit(curpixel);
-			break;
-
-		default:
-			fatalerror("Unsupported bit depth: %d\n", m_rdp->MiscState.FBSize);
-			break;
-	}
-}
-
-void FramebufferT::Fill16Bit(UINT32 curpixel)
-{
-	UINT16 val;
-	if (curpixel & 1)
-	{
-		val = m_rdp->FillColor & 0xffff;
-	}
-	else
-	{
-		val = (m_rdp->FillColor >> 16) & 0xffff;
-	}
-	RWRITEIDX16((m_rdp->MiscState.FBAddress >> 1) + curpixel, val);
-	HWRITEADDR8((m_rdp->MiscState.FBAddress >> 1) + curpixel, ((val & 1) << 1) | (val & 1));
-}
-
-void FramebufferT::Fill32Bit(UINT32 curpixel)
-{
-	UINT32 FillColor = m_rdp->FillColor;
-	RWRITEIDX32((m_rdp->MiscState.FBAddress >> 2) + curpixel, FillColor);
-	HWRITEADDR8((m_rdp->MiscState.FBAddress >> 1) + (curpixel << 1), (FillColor & 0x10000) ? 3 : 0);
-	HWRITEADDR8((m_rdp->MiscState.FBAddress >> 1) + (curpixel << 1) + 1, (FillColor & 0x1) ? 3 : 0);
-}
-
-} // namespace RDP
-
-} // namespace N64
diff -Nru src-old/mame/video/rdpfb.h src/mame/video/rdpfb.h
--- src-old/mame/video/rdpfb.h	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdpfb.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-#ifndef _VIDEO_RDPFB_H_
-#define _VIDEO_RDPFB_H_
-
-#include "emu.h"
-
-namespace N64
-{
-
-namespace RDP
-{
-
-class OtherModes;
-class MiscState;
-
-class FramebufferT
-{
-	public:
-		FramebufferT()
-		{
-			m_pre_wrap = false;
-		}
-
-		void				Write(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Read(UINT32 index);
-		void				Copy(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Fill(UINT32 curpixel);
-
-		void				SetProcessor(Processor* rdp) { m_rdp = rdp; }
-		void				SetOtherModes(OtherModes* other_modes) { m_other_modes = other_modes; }
-		void				SetMiscState(MiscState* misc_state) { m_misc_state = misc_state; }
-		void				SetPreWrap(bool prewrap) { m_pre_wrap = prewrap; }
-
-	private:
-		Processor*			m_rdp;
-		OtherModes*			m_other_modes;
-		MiscState*			m_misc_state;
-		bool				m_pre_wrap;
-
-		void				Write16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Write32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Read16Bit(UINT32 curpixel);
-		void				Read32Bit(UINT32 curpixel);
-		void				Copy16Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Copy32Bit(UINT32 curpixel, UINT32 r, UINT32 g, UINT32 b);
-		void				Fill16Bit(UINT32 curpixel);
-		void				Fill32Bit(UINT32 curpixel);
-};
-
-} // namespace RDP
-
-} // namespace N64
-
-#endif // _VIDEO_RDPFB_H_
diff -Nru src-old/mame/video/rdpfiltr.c src/mame/video/rdpfiltr.c
--- src-old/mame/video/rdpfiltr.c	2010-04-02 06:34:10.000000000 +0200
+++ src/mame/video/rdpfiltr.c	2012-02-11 17:05:10.000000000 +0100
@@ -1,15 +1,15 @@
 INLINE void video_filter16(int *out_r, int *out_g, int *out_b, UINT16* vbuff, UINT8* hbuff, const UINT32 hres);
 INLINE void divot_filter16(UINT8* r, UINT8* g, UINT8* b, UINT16* fbuff, UINT32 fbuff_index);
 INLINE void restore_filter16(INT32* r, INT32* g, INT32* b, UINT16* fbuff, UINT32 fbuff_index, UINT32 hres);
-INLINE void divot_filter16_buffer(INT32* r, INT32* g, INT32* b, N64::RDP::Color* vibuffer);
-INLINE void restore_filter16_buffer(INT32* r, INT32* g, INT32* b, N64::RDP::Color* vibuff, UINT32 hres);
-INLINE void restore_two(N64::RDP::Color* filtered, N64::RDP::Color* neighbour);
+INLINE void divot_filter16_buffer(INT32* r, INT32* g, INT32* b, Color* vibuffer);
+INLINE void restore_filter16_buffer(INT32* r, INT32* g, INT32* b, Color* vibuff, UINT32 hres);
+INLINE void restore_two(Color* filtered, Color* neighbour);
 INLINE void video_max(UINT32* Pixels, UINT8* max, UINT32* enb);
 INLINE UINT32 ge_two(UINT32 enb);
 
 INLINE void video_filter16(int *out_r, int *out_g, int *out_b, UINT16* vbuff, UINT8* hbuff, const UINT32 hres)
 {
-	N64::RDP::Color penumax, penumin, max, min;
+	Color penumax, penumin, max, min;
 	UINT16 pix = *vbuff;
 	const UINT8 centercvg = (*hbuff & 3) + ((pix & 1) << 2) + 1;
 	UINT32 numoffull = 1;
@@ -253,11 +253,11 @@
 	}
 }
 
-INLINE void divot_filter16_buffer(int* r, int* g, int* b, N64::RDP::Color* vibuffer)
+INLINE void divot_filter16_buffer(int* r, int* g, int* b, Color* vibuffer)
 {
-	N64::RDP::Color leftpix = vibuffer[-1];
-	N64::RDP::Color rightpix = vibuffer[1];
-	N64::RDP::Color filtered = *vibuffer;
+	Color leftpix = vibuffer[-1];
+	Color rightpix = vibuffer[1];
+	Color filtered = *vibuffer;
 
 	*r = filtered.i.r;
 	*g = filtered.i.g;
@@ -427,12 +427,12 @@
 	}
 }
 
-INLINE void restore_filter16_buffer(INT32* r, INT32* g, INT32* b, N64::RDP::Color* vibuff, UINT32 hres)
+INLINE void restore_filter16_buffer(INT32* r, INT32* g, INT32* b, Color* vibuff, UINT32 hres)
 {
-	N64::RDP::Color filtered;
-	N64::RDP::Color leftuppix, leftdownpix, leftpix;
-	N64::RDP::Color rightuppix, rightdownpix, rightpix;
-	N64::RDP::Color uppix, downpix;
+	Color filtered;
+	Color leftuppix, leftdownpix, leftpix;
+	Color rightuppix, rightdownpix, rightpix;
+	Color uppix, downpix;
 	INT32 ihres = (INT32)hres; //can't apply unary minus to unsigned
 
 	leftuppix = vibuff[-ihres - 1];
@@ -471,7 +471,7 @@
 }
 
 // This is wrong, only the 5 upper bits are compared.
-INLINE void restore_two(N64::RDP::Color* filtered, N64::RDP::Color* neighbour)
+INLINE void restore_two(Color* filtered, Color* neighbour)
 {
 	if (neighbour->i.r > filtered->i.r)
 	{
diff -Nru src-old/mame/video/rdpspn16.c src/mame/video/rdpspn16.c
--- src-old/mame/video/rdpspn16.c	2012-02-04 18:35:42.000000000 +0100
+++ src/mame/video/rdpspn16.c	2012-02-19 12:21:36.000000000 +0100
@@ -2,18 +2,13 @@
 #include "includes/n64.h"
 #include "video/n64.h"
 
-namespace N64
-{
-
-namespace RDP
-{
-
 #define LookUpCC(A, B, C, D) m_rdp->GetCCLUT2()[(m_rdp->GetCCLUT1()[(A << 16) | (B << 8) | C] << 8) | D]
 
-void Processor::RenderSpans(int start, int end, int tilenum, bool flip)
+void n64_rdp::RenderSpans(int start, int end, int tilenum, bool flip, extent_t *Spans, bool rect, rdp_poly_state *object)
 {
-	int clipy1 = GetScissor()->m_yh;
-	int clipy2 = GetScissor()->m_yl;
+	int clipy1 = Scissor.m_yh;
+	int clipy2 = Scissor.m_yl;
+	int offset = 0;
 
 	if (clipy2 <= 0)
 	{
@@ -22,68 +17,60 @@
 
 	if (start < clipy1)
 	{
+		offset = clipy1 - start;
 		start = clipy1;
 	}
 	if (start >= clipy2)
 	{
+		offset = start - (clipy2 - 1);
 		start = clipy2 - 1;
 	}
 	if (end < clipy1)
 	{
 		end = clipy1;
 	}
-	if (end >= clipy2) // Needed by 40 Winks
+	if (end >= clipy2)
 	{
 		end = clipy2 - 1;
 	}
 
-	for(int i = start; i <= end; i++)
-	{
-		switch(OtherModes.cycle_type)
-		{
-			case CYCLE_TYPE_1: Spans[i].Draw1Cycle(i, tilenum, flip); break;
-			case CYCLE_TYPE_2: Spans[i].Draw2Cycle(i, tilenum, flip); break;
-			case CYCLE_TYPE_COPY: Spans[i].DrawCopy(i, tilenum, flip); break;
-			case CYCLE_TYPE_FILL: Spans[i].DrawFill(i, tilenum, flip); break;
-		}
-	}
-}
-
-void Span::Dump()
-{
-	printf("    m_lx = %d\n", m_lx);
-	printf("    m_rx = %d\n",  m_rx);
-	printf("    m_s.w = %08x\n", m_s.w);
-	printf("    m_t.w = %08x\n", m_t.w);
-	printf("    m_w.w = %08x\n", m_w.w);
-	printf("    m_r.w = %08x\n", m_r.w);
-	printf("    m_g.w = %08x\n", m_g.w);
-	printf("    m_b.w = %08x\n", m_b.w);
-	printf("    m_a.w = %08x\n", m_a.w);
-	printf("    m_z.w = %08x\n", m_z.w);
-
-	printf("    CVG: ");
-	for(int index = 0; index < RDP_CVG_SPAN_MAX; index++)
-	{
-		printf("%d", m_cvg[index]);
-	}
-	printf("\n");
-}
-
-void Span::SetMachine(running_machine &machine)
-{
-	_n64_state *state = machine.driver_data<_n64_state>();
-
-	m_machine = &machine;
-	m_rdp = &state->m_rdp;
-}
-
-void Span::RGBAZClip(int sr, int sg, int sb, int sa, int *sz)
-{
-	m_rdp->ShadeColor.i.r = m_rdp->GetSpecial9BitClampTable()[sr & 0x1ff];
-	m_rdp->ShadeColor.i.g = m_rdp->GetSpecial9BitClampTable()[sg & 0x1ff];
-	m_rdp->ShadeColor.i.b = m_rdp->GetSpecial9BitClampTable()[sb & 0x1ff];
-	m_rdp->ShadeColor.i.a = m_rdp->GetSpecial9BitClampTable()[sa & 0x1ff];
+	object->m_rdp = this;
+	memcpy(&object->MiscState, &MiscState, sizeof(MiscStateT));
+	memcpy(&object->OtherModes, &OtherModes, sizeof(OtherModesT));
+	memcpy(&object->SpanBase, &SpanBase, sizeof(SpanBaseT));
+	memcpy(&object->Scissor, &Scissor, sizeof(Rectangle));
+	memcpy(&object->m_tiles, &m_tiles, 8 * sizeof(N64Tile));
+	object->tilenum = tilenum;
+	object->flip = flip;
+	object->FillColor = FillColor;
+	object->rect = rect;
+
+	switch(OtherModes.cycle_type)
+	{
+		case CYCLE_TYPE_1:
+			render_triangle_custom(visarea, render_delegate(FUNC(n64_rdp::SpanDraw1Cycle), this), start, (end - start) + 1, Spans + offset);
+			break;
+		case CYCLE_TYPE_2:
+			render_triangle_custom(visarea, render_delegate(FUNC(n64_rdp::SpanDraw2Cycle), this), start, (end - start) + 1, Spans + offset);
+			break;
+
+		case CYCLE_TYPE_COPY:
+			render_triangle_custom(visarea, render_delegate(FUNC(n64_rdp::SpanDrawCopy), this), start, (end - start) + 1, Spans + offset);
+			break;
+
+		case CYCLE_TYPE_FILL:
+			render_triangle_custom(visarea, render_delegate(FUNC(n64_rdp::SpanDrawFill), this), start, (end - start) + 1, Spans + offset);
+			break;
+	}
+	wait();
+}
+
+void n64_rdp::RGBAZClip(int sr, int sg, int sb, int sa, int *sz, rdp_span_aux *userdata)
+{
+	userdata->ShadeColor.i.r = m_special_9bit_clamptable[sr & 0x1ff];
+	userdata->ShadeColor.i.g = m_special_9bit_clamptable[sg & 0x1ff];
+	userdata->ShadeColor.i.b = m_special_9bit_clamptable[sb & 0x1ff];
+	userdata->ShadeColor.i.a = m_special_9bit_clamptable[sa & 0x1ff];
 
 	INT32 zanded = (*sz) & 0x60000;
 
@@ -97,9 +84,9 @@
 	}
 }
 
-void Span::RGBAZCorrectTriangle(INT32 offx, INT32 offy, INT32* r, INT32* g, INT32* b, INT32* a, INT32* z)
+void n64_rdp::RGBAZCorrectTriangle(INT32 offx, INT32 offy, INT32* r, INT32* g, INT32* b, INT32* a, INT32* z, rdp_span_aux *userdata, const rdp_poly_state &object)
 {
-	if (m_rdp->MiscState.CurrentPixCvg == 8)
+	if (userdata->CurrentPixCvg == 8)
 	{
 		*r >>= 2;
 		*g >>= 2;
@@ -109,17 +96,17 @@
 	}
 	else
 	{
-		INT32 summand_xr = offx * SIGN13(m_rdp->m_span_dr >> 14);
-		INT32 summand_yr = offy * SIGN13(m_rdp->m_span_drdy >> 14);
-		INT32 summand_xb = offx * SIGN13(m_rdp->m_span_db >> 14);
-		INT32 summand_yb = offy * SIGN13(m_rdp->m_span_dbdy >> 14);
-		INT32 summand_xg = offx * SIGN13(m_rdp->m_span_dg >> 14);
-		INT32 summand_yg = offy * SIGN13(m_rdp->m_span_dgdy >> 14);
-		INT32 summand_xa = offx * SIGN13(m_rdp->m_span_da >> 14);
-		INT32 summand_ya = offy * SIGN13(m_rdp->m_span_dady >> 14);
+		INT32 summand_xr = offx * SIGN13(object.SpanBase.m_span_dr >> 14);
+		INT32 summand_yr = offy * SIGN13(object.SpanBase.m_span_drdy >> 14);
+		INT32 summand_xb = offx * SIGN13(object.SpanBase.m_span_db >> 14);
+		INT32 summand_yb = offy * SIGN13(object.SpanBase.m_span_dbdy >> 14);
+		INT32 summand_xg = offx * SIGN13(object.SpanBase.m_span_dg >> 14);
+		INT32 summand_yg = offy * SIGN13(object.SpanBase.m_span_dgdy >> 14);
+		INT32 summand_xa = offx * SIGN13(object.SpanBase.m_span_da >> 14);
+		INT32 summand_ya = offy * SIGN13(object.SpanBase.m_span_dady >> 14);
 
-		INT32 summand_xz = offx * SIGN22(m_rdp->m_span_dz >> 10);
-		INT32 summand_yz = offy * SIGN22(m_rdp->m_span_dzdy >> 10);
+		INT32 summand_xz = offx * SIGN22(object.SpanBase.m_span_dz >> 10);
+		INT32 summand_yz = offy * SIGN22(object.SpanBase.m_span_dzdy >> 10);
 
 		*r = ((*r << 2) + summand_xr + summand_yr) >> 4;
 		*g = ((*g << 2) + summand_xg + summand_yg) >> 4;
@@ -129,58 +116,71 @@
 	}
 }
 
-void Span::Draw1Cycle(int index, int tilenum, bool flip)
+void n64_rdp::SpanDraw1Cycle(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid)
 {
-	int clipx1 = m_rdp->GetScissor()->m_xh;
-	int clipx2 = m_rdp->GetScissor()->m_xl;
-
-	SpanParam r = m_r;
-	SpanParam g = m_g;
-	SpanParam b = m_b;
-	SpanParam a = m_a;
-	SpanParam z = m_z;
-	SpanParam s = m_s;
-	SpanParam t = m_t;
-	SpanParam w = m_w;
+	int clipx1 = object.Scissor.m_xh;
+	int clipx2 = object.Scissor.m_xl;
+	n64_rdp *m_rdp = object.m_rdp;
+	int tilenum = object.tilenum;
+	bool flip = object.flip;
+
+	SpanParam r; r.w = extent.param[SPAN_R].start;
+	SpanParam g; g.w = extent.param[SPAN_G].start;
+	SpanParam b; b.w = extent.param[SPAN_B].start;
+	SpanParam a; a.w = extent.param[SPAN_A].start;
+	SpanParam z; z.w = extent.param[SPAN_Z].start;
+	SpanParam s; s.w = extent.param[SPAN_S].start;
+	SpanParam t; t.w = extent.param[SPAN_T].start;
+	SpanParam w; w.w = extent.param[SPAN_W].start;
 
-	UINT32 zb = m_rdp->MiscState.ZBAddress >> 1;
+	UINT32 zb = object.MiscState.ZBAddress >> 1;
 	UINT32 zhb = zb;
 	UINT8 offx = 0, offy = 0;
 
 	INT32 tile1 = tilenum;
 
-	m_rdp->TexPipe.CalculateClampDiffs(tile1);
+	rdp_span_aux *userdata = (rdp_span_aux*)extent.userdata;
 
-	bool noisecompute = m_rdp->ColorInputs.combiner_rgbsub_a_r[1] == &m_rdp->NoiseColor.i.r;
-	bool partialreject = (m_rdp->ColorInputs.blender2b_a[0] == &m_rdp->InvPixelColor.i.a && m_rdp->ColorInputs.blender1b_a[0] == &m_rdp->PixelColor.i.a);
-	bool bsel0 = (m_rdp->ColorInputs.blender2b_a[0] == &m_rdp->MemoryColor.i.a);
-
-	int drinc = flip ? (m_rdp->m_span_dr) : -m_rdp->m_span_dr;
-	int dginc = flip ? (m_rdp->m_span_dg) : -m_rdp->m_span_dg;
-	int dbinc = flip ? (m_rdp->m_span_db) : -m_rdp->m_span_db;
-	int dainc = flip ? (m_rdp->m_span_da) : -m_rdp->m_span_da;
-	int dzinc = flip ? (m_rdp->m_span_dz) : -m_rdp->m_span_dz;
-	int dsinc = flip ? (m_rdp->m_span_ds) : -m_rdp->m_span_ds;
-	int dtinc = flip ? (m_rdp->m_span_dt) : -m_rdp->m_span_dt;
-	int dwinc = flip ? (m_rdp->m_span_dw) : -m_rdp->m_span_dw;
-	int dzpix = m_rdp->m_span_dzpix;
+	INT32 m_clamp_s_diff[8];
+	INT32 m_clamp_t_diff[8];
+	m_rdp->TexPipe.CalculateClampDiffs(tile1, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
+
+	bool partialreject = (userdata->ColorInputs.blender2b_a[0] == &userdata->InvPixelColor.i.a && userdata->ColorInputs.blender1b_a[0] == &userdata->PixelColor.i.a);
+	bool bsel0 = (userdata->ColorInputs.blender2b_a[0] == &userdata->MemoryColor.i.a);
+
+	int drinc = flip ? (object.SpanBase.m_span_dr) : -object.SpanBase.m_span_dr;
+	int dginc = flip ? (object.SpanBase.m_span_dg) : -object.SpanBase.m_span_dg;
+	int dbinc = flip ? (object.SpanBase.m_span_db) : -object.SpanBase.m_span_db;
+	int dainc = flip ? (object.SpanBase.m_span_da) : -object.SpanBase.m_span_da;
+	int dzinc = flip ? (object.SpanBase.m_span_dz) : -object.SpanBase.m_span_dz;
+	int dsinc = flip ? (object.SpanBase.m_span_ds) : -object.SpanBase.m_span_ds;
+	int dtinc = flip ? (object.SpanBase.m_span_dt) : -object.SpanBase.m_span_dt;
+	int dwinc = flip ? (object.SpanBase.m_span_dw) : -object.SpanBase.m_span_dw;
+	int dzpix = object.SpanBase.m_span_dzpix;
 	int xinc = flip ? 1 : -1;
 
-	int fb_index = m_rdp->MiscState.FBWidth * index;
+	int fb_index = object.MiscState.FBWidth * scanline;
 
 	int cdith = 0;
 	int adith = 0;
 
-	int xstart = m_lx;
-	int xend = m_unscissored_rx;
-	int xend_scissored = m_rx;
+	int xstart = extent.startx;
+	int xend = userdata->m_unscissored_rx;
+	int xend_scissored = extent.stopx;
 
 	int x = xend;
 
 	int length = flip ? (xstart - xend) : (xend - xstart);
-	m_rdp->TexPipe.m_start_span = true;
 	UINT32 fir, fig, fib;
 
+	if(object.OtherModes.z_source_sel)
+	{
+		z.w = ((UINT32)object.MiscState.PrimitiveZ) << 16;
+		dzpix = object.MiscState.PrimitiveDZ;
+		dzinc = 0;
+	}
+
+	userdata->m_start_span = true;
 	for (int j = 0; j <= length; j++)
 	{
 		int sr = r.w >> 14;
@@ -194,22 +194,15 @@
 		INT32 sss = 0;
 		INT32 sst = 0;
 
-		if (m_rdp->OtherModes.z_source_sel)
-		{
-			sz = (((UINT32)m_rdp->MiscState.PrimitiveZ) << 6) & 0x3fffff;
-			dzpix = m_rdp->MiscState.PrimitiveDZ;
-			dzinc = m_rdp->m_span_dz = m_rdp->m_span_dzdy = 0;
-		}
-
 		bool valid_x = (flip) ? (x >= xend_scissored) : (x <= xend_scissored);
 
 		if (x >= clipx1 && x < clipx2 && valid_x)
 		{
-			m_rdp->lookup_cvmask_derivatives(m_cvg[x], &offx, &offy);
+			m_rdp->lookup_cvmask_derivatives(userdata->m_cvg[x], &offx, &offy, userdata);
 
-			if (m_rdp->TexPipe.m_start_span)
+			if (userdata->m_start_span)
 			{
-				if (m_rdp->OtherModes.persp_tex_en)
+				if (object.OtherModes.persp_tex_en)
 				{
 					m_rdp->TCDiv(ss, st, sw, &sss, &sst);
 				}
@@ -220,37 +213,41 @@
 			}
 			else
 			{
-				sss = m_rdp->TexPipe.m_precomp_s;
-				sst = m_rdp->TexPipe.m_precomp_t;
+				sss = userdata->m_precomp_s;
+				sst = userdata->m_precomp_t;
 			}
 
-			m_rdp->TexPipe.LOD1Cycle(&sss, &sst, s.w, t.w, w.w, dsinc, dtinc, dwinc);
+			m_rdp->TexPipe.LOD1Cycle(&sss, &sst, s.w, t.w, w.w, dsinc, dtinc, dwinc, userdata, object);
 
-			RGBAZCorrectTriangle(offx, offy, &sr, &sg, &sb, &sa, &sz);
-			RGBAZClip(sr, sg, sb, sa, &sz);
+			RGBAZCorrectTriangle(offx, offy, &sr, &sg, &sb, &sa, &sz, userdata, object);
+			RGBAZClip(sr, sg, sb, sa, &sz, userdata);
 
-			m_rdp->TexPipe.Cycle(&m_rdp->Texel0Color, &m_rdp->Texel0Color, sss, sst, tilenum, 0);
+			m_rdp->TexPipe.Cycle(&userdata->Texel0Color, &userdata->Texel0Color, sss, sst, tilenum, 0, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
 
-			m_rdp->ColorCombiner1Cycle(noisecompute);
+			m_rdp->ColorCombiner1Cycle(userdata);
+
+			//Alpha coverage combiner
+			GetAlphaCvg(&userdata->PixelColor.i.a, userdata, object);
 
 			UINT32 curpixel = fb_index + x;
 			UINT32 zbcur = zb + curpixel;
 			UINT32 zhbcur = zhb + curpixel;
 
-			m_rdp->Framebuffer.Read(curpixel);
+			((this)->*(_Read[((object.MiscState.FBSize - 2) << 1) | object.OtherModes.image_read_en]))(curpixel, userdata, object);
 
-			if(m_rdp->ZCompare(zbcur, zhbcur, sz, dzpix))
+			if(m_rdp->ZCompare(zbcur, zhbcur, sz, dzpix, userdata, object))
 			{
-				m_rdp->GetDitherValues(index, j, &cdith, &adith);
+				m_rdp->GetDitherValues(scanline, j, &cdith, &adith, object);
 
-				bool rendered = m_rdp->Blender.Blend1Cycle(&fir, &fig, &fib, cdith, adith, partialreject, bsel0);
+				bool rendered = m_rdp->Blender.Blend1Cycle(&fir, &fig, &fib, cdith, adith, partialreject, bsel0, userdata, object);
 
                 if (rendered)
 				{
-					m_rdp->Framebuffer.Write(curpixel, fir, fig, fib);
-					if (m_rdp->OtherModes.z_update_en)
+					((this)->*(_Write[((object.MiscState.FBSize - 2) << 3) | (object.OtherModes.cvg_dest << 1) | userdata->BlendEnable]))(curpixel, fir, fig, fib, userdata, object);
+
+					if (object.OtherModes.z_update_en)
 					{
-						m_rdp->ZStore(zbcur, zhbcur, sz);
+						m_rdp->ZStore(zbcur, zhbcur, sz, userdata->m_dzpix_enc);
 					}
 				}
 			}
@@ -269,21 +266,24 @@
 	}
 }
 
-void Span::Draw2Cycle(int index, int tilenum, bool flip)
+void n64_rdp::SpanDraw2Cycle(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid)
 {
-	int clipx1 = m_rdp->GetScissor()->m_xh;
-	int clipx2 = m_rdp->GetScissor()->m_xl;
-
-	SpanParam r = m_r;
-	SpanParam g = m_g;
-	SpanParam b = m_b;
-	SpanParam a = m_a;
-	SpanParam z = m_z;
-	SpanParam s = m_s;
-	SpanParam t = m_t;
-	SpanParam w = m_w;
+	int clipx1 = object.Scissor.m_xh;
+	int clipx2 = object.Scissor.m_xl;
+	n64_rdp *m_rdp = object.m_rdp;
+	int tilenum = object.tilenum;
+	bool flip = object.flip;
+
+	SpanParam r; r.w = extent.param[SPAN_R].start;
+	SpanParam g; g.w = extent.param[SPAN_G].start;
+	SpanParam b; b.w = extent.param[SPAN_B].start;
+	SpanParam a; a.w = extent.param[SPAN_A].start;
+	SpanParam z; z.w = extent.param[SPAN_Z].start;
+	SpanParam s; s.w = extent.param[SPAN_S].start;
+	SpanParam t; t.w = extent.param[SPAN_T].start;
+	SpanParam w; w.w = extent.param[SPAN_W].start;
 
-	UINT32 zb = m_rdp->MiscState.ZBAddress >> 1;
+	UINT32 zb = object.MiscState.ZBAddress >> 1;
 	UINT32 zhb = zb;
 	UINT8 offx = 0, offy = 0;
 
@@ -295,41 +295,49 @@
 	INT32 news = 0;
 	INT32 newt = 0;
 
-	m_rdp->TexPipe.CalculateClampDiffs(tile1);
+	rdp_span_aux *userdata = (rdp_span_aux*)extent.userdata;
 
-	bool noisecompute = (m_rdp->ColorInputs.combiner_rgbsub_a_r[0] == &m_rdp->NoiseColor.i.r || m_rdp->ColorInputs.combiner_rgbsub_a_r[1] == &m_rdp->PixelColor.i.r);
-	bool partialreject = (m_rdp->ColorInputs.blender2b_a[1] == &m_rdp->InvPixelColor.i.a && m_rdp->ColorInputs.blender1b_a[1] == &m_rdp->PixelColor.i.a);
-	bool bsel0 = (m_rdp->ColorInputs.blender2b_a[0] == &m_rdp->MemoryColor.i.a);
-	bool bsel1 = (m_rdp->ColorInputs.blender2b_a[1] == &m_rdp->MemoryColor.i.a);
-
-	int dzpix = m_rdp->m_span_dzpix;
-	int drinc = flip ? (m_rdp->m_span_dr) : -m_rdp->m_span_dr;
-	int dginc = flip ? (m_rdp->m_span_dg) : -m_rdp->m_span_dg;
-	int dbinc = flip ? (m_rdp->m_span_db) : -m_rdp->m_span_db;
-	int dainc = flip ? (m_rdp->m_span_da) : -m_rdp->m_span_da;
-	int dzinc = flip ? (m_rdp->m_span_dz) : -m_rdp->m_span_dz;
-	int dsinc = flip ? (m_rdp->m_span_ds) : -m_rdp->m_span_ds;
-	int dtinc = flip ? (m_rdp->m_span_dt) : -m_rdp->m_span_dt;
-	int dwinc = flip ? (m_rdp->m_span_dw) : -m_rdp->m_span_dw;
+	INT32 m_clamp_s_diff[8];
+	INT32 m_clamp_t_diff[8];
+	m_rdp->TexPipe.CalculateClampDiffs(tile1, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
+
+	bool partialreject = (userdata->ColorInputs.blender2b_a[1] == &userdata->InvPixelColor.i.a && userdata->ColorInputs.blender1b_a[1] == &userdata->PixelColor.i.a);
+	bool bsel0 = (userdata->ColorInputs.blender2b_a[0] == &userdata->MemoryColor.i.a);
+	bool bsel1 = (userdata->ColorInputs.blender2b_a[1] == &userdata->MemoryColor.i.a);
+
+	int dzpix = object.SpanBase.m_span_dzpix;
+	int drinc = flip ? (object.SpanBase.m_span_dr) : -object.SpanBase.m_span_dr;
+	int dginc = flip ? (object.SpanBase.m_span_dg) : -object.SpanBase.m_span_dg;
+	int dbinc = flip ? (object.SpanBase.m_span_db) : -object.SpanBase.m_span_db;
+	int dainc = flip ? (object.SpanBase.m_span_da) : -object.SpanBase.m_span_da;
+	int dzinc = flip ? (object.SpanBase.m_span_dz) : -object.SpanBase.m_span_dz;
+	int dsinc = flip ? (object.SpanBase.m_span_ds) : -object.SpanBase.m_span_ds;
+	int dtinc = flip ? (object.SpanBase.m_span_dt) : -object.SpanBase.m_span_dt;
+	int dwinc = flip ? (object.SpanBase.m_span_dw) : -object.SpanBase.m_span_dw;
 	int xinc = flip ? 1 : -1;
 
-	int fb_index = m_rdp->MiscState.FBWidth * index;
+	int fb_index = object.MiscState.FBWidth * scanline;
 
 	int cdith = 0;
 	int adith = 0;
 
-	int xstart = m_lx;
-	int xend = m_unscissored_rx;
-	int xend_scissored = m_rx;
+	int xstart = extent.startx;
+	int xend = userdata->m_unscissored_rx;
+	int xend_scissored = extent.stopx;
 
 	int x = xend;
 
 	int length = flip ? (xstart - xend) : (xend - xstart);
-	m_rdp->TexPipe.m_start_span = true;
 	UINT32 fir, fig, fib;
 
-	//printf( "Span length: %d\n", length);
+	if(object.OtherModes.z_source_sel)
+	{
+		z.w = ((UINT32)object.MiscState.PrimitiveZ) << 16;
+		dzpix = object.MiscState.PrimitiveDZ;
+		dzinc = 0;
+	}
 
+	userdata->m_start_span = true;
 	for (int j = 0; j <= length; j++)
 	{
 		int sr = r.w >> 14;
@@ -345,22 +353,15 @@
 		Color c1;
 		Color c2;
 
-		if (m_rdp->OtherModes.z_source_sel)
-		{
-			sz = (((UINT32)m_rdp->MiscState.PrimitiveZ) << 6) & 0x3fffff;
-			dzpix = m_rdp->MiscState.PrimitiveDZ;
-			dzinc = m_rdp->m_span_dz = m_rdp->m_span_dzdy = 0;
-		}
-
 		bool valid_x = (flip) ? (x >= xend_scissored) : (x <= xend_scissored);
 
 		if (x >= clipx1 && x < clipx2 && valid_x)
 		{
-			m_rdp->lookup_cvmask_derivatives(m_cvg[x], &offx, &offy);
+			m_rdp->lookup_cvmask_derivatives(userdata->m_cvg[x], &offx, &offy, userdata);
 
-			if (m_rdp->TexPipe.m_start_span)
+			if (userdata->m_start_span)
 			{
-				if (m_rdp->OtherModes.persp_tex_en)
+				if (object.OtherModes.persp_tex_en)
 				{
 					m_rdp->TCDiv(ss, st, sw, &sss, &sst);
 				}
@@ -371,44 +372,47 @@
 			}
 			else
 			{
-				sss = m_rdp->TexPipe.m_precomp_s;
-				sst = m_rdp->TexPipe.m_precomp_t;
+				sss = userdata->m_precomp_s;
+				sst = userdata->m_precomp_t;
 			}
 
-			m_rdp->TexPipe.LOD2Cycle(&sss, &sst, s.w, t.w, w.w, dsinc, dtinc, dwinc, prim_tile, &tile1, &tile2);
+			m_rdp->TexPipe.LOD2Cycle(&sss, &sst, s.w, t.w, w.w, dsinc, dtinc, dwinc, prim_tile, &tile1, &tile2, userdata, object);
 
-			news = m_rdp->TexPipe.m_precomp_s;
-			newt = m_rdp->TexPipe.m_precomp_t;
-			m_rdp->TexPipe.LOD2CycleLimited(&news, &newt, s.w + dsinc, t.w + dtinc, w.w + dwinc, dsinc, dtinc, dwinc, prim_tile, &newtile1);
+			news = userdata->m_precomp_s;
+			newt = userdata->m_precomp_t;
+			m_rdp->TexPipe.LOD2CycleLimited(&news, &newt, s.w + dsinc, t.w + dtinc, w.w + dwinc, dsinc, dtinc, dwinc, prim_tile, &newtile1, object);
 
-			RGBAZCorrectTriangle(offx, offy, &sr, &sg, &sb, &sa, &sz);
-			RGBAZClip(sr, sg, sb, sa, &sz);
+			RGBAZCorrectTriangle(offx, offy, &sr, &sg, &sb, &sa, &sz, userdata, object);
+			RGBAZClip(sr, sg, sb, sa, &sz, userdata);
 
-			m_rdp->TexPipe.Cycle(&m_rdp->Texel0Color, &m_rdp->Texel0Color, sss, sst, tile1, 0);
-			m_rdp->TexPipe.Cycle(&m_rdp->Texel1Color, &m_rdp->Texel0Color, sss, sst, tile2, 1);
+			m_rdp->TexPipe.Cycle(&userdata->Texel0Color, &userdata->Texel0Color, sss, sst, tile1, 0, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
+			m_rdp->TexPipe.Cycle(&userdata->Texel1Color, &userdata->Texel0Color, sss, sst, tile2, 1, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
 
-			m_rdp->TexPipe.Cycle(&m_rdp->NextTexelColor, &m_rdp->NextTexelColor, sss, sst, tile2, 1);
+			m_rdp->TexPipe.Cycle(&userdata->NextTexelColor, &userdata->NextTexelColor, sss, sst, tile2, 1, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
 
-			m_rdp->ColorCombiner2Cycle(noisecompute);
+			m_rdp->ColorCombiner2Cycle(userdata);
+
+			//Alpha coverage combiner
+			GetAlphaCvg(&userdata->PixelColor.i.a, userdata, object);
 
 			UINT32 curpixel = fb_index + x;
 			UINT32 zbcur = zb + curpixel;
 			UINT32 zhbcur = zhb + curpixel;
 
-			m_rdp->Framebuffer.Read(curpixel);
+			((this)->*(_Read[((object.MiscState.FBSize - 2) << 1) | object.OtherModes.image_read_en]))(curpixel, userdata, object);
 
-			if(m_rdp->ZCompare(zbcur, zhbcur, sz, dzpix))
+			if(m_rdp->ZCompare(zbcur, zhbcur, sz, dzpix, userdata, object))
 			{
-				m_rdp->GetDitherValues(index, j, &cdith, &adith);
+				m_rdp->GetDitherValues(scanline, j, &cdith, &adith, object);
 
-				bool rendered = m_rdp->Blender.Blend2Cycle(&fir, &fig, &fib, cdith, adith, partialreject, bsel0, bsel1);
+				bool rendered = m_rdp->Blender.Blend2Cycle(&fir, &fig, &fib, cdith, adith, partialreject, bsel0, bsel1, userdata, object);
 
                 if (rendered)
 				{
-					m_rdp->Framebuffer.Write(curpixel, fir, fig, fib);
-					if (m_rdp->OtherModes.z_update_en)
+					((this)->*(_Write[((object.MiscState.FBSize - 2) << 3) | (object.OtherModes.cvg_dest << 1) | userdata->BlendEnable]))(curpixel, fir, fig, fib, userdata, object);
+					if (object.OtherModes.z_update_en)
 					{
-						m_rdp->ZStore(zbcur, zhbcur, sz);
+						m_rdp->ZStore(zbcur, zhbcur, sz, userdata->m_dzpix_enc);
 					}
 				}
 			}
@@ -427,25 +431,29 @@
 	}
 }
 
-void Span::DrawCopy(int index, int tilenum, bool flip)
+void n64_rdp::SpanDrawCopy(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid)
 {
-	int clipx1 = m_rdp->GetScissor()->m_xh;
-	int clipx2 = m_rdp->GetScissor()->m_xl;
+	int clipx1 = object.Scissor.m_xh;
+	int clipx2 = object.Scissor.m_xl;
+	n64_rdp *m_rdp = object.m_rdp;
+	int tilenum = object.tilenum;
+	bool flip = object.flip;
 
-	SpanParam s = m_s;
-	SpanParam t = m_t;
+	SpanParam s; s.w = extent.param[SPAN_S].start;
+	SpanParam t; t.w = extent.param[SPAN_T].start;
 
-	int ds = m_rdp->m_span_ds / 4;
-	int dt = m_rdp->m_span_dt / 4;
+	int ds = object.SpanBase.m_span_ds / 4;
+	int dt = object.SpanBase.m_span_dt / 4;
 	int dsinc = flip ? (ds) : -ds;
 	int dtinc = flip ? (dt) : -dt;
 	int xinc = flip ? 1 : -1;
 
-	int fb_index = m_rdp->MiscState.FBWidth * index;
+	int fb_index = object.MiscState.FBWidth * scanline;
 
-	int xstart = m_lx;
-	int xend = m_unscissored_rx;
-	int xend_scissored = m_rx;
+	rdp_span_aux *userdata = (rdp_span_aux*)extent.userdata;
+	int xstart = extent.startx;
+	int xend = userdata->m_unscissored_rx;
+	int xend_scissored = extent.stopx;
 
 	int x = xend;
 
@@ -459,13 +467,12 @@
 		{
 			INT32 sss = s.h.h;
 			INT32 sst = t.h.h;
-			m_rdp->TexPipe.Copy(&m_rdp->Texel0Color, sss, sst, tilenum);
+			m_rdp->TexPipe.Copy(&userdata->Texel0Color, sss, sst, tilenum, object, userdata);
 
 			UINT32 curpixel = fb_index + x;
-			m_rdp->MiscState.CurrentPixCvg = m_rdp->Texel0Color.i.a ? 7 : 0;
-			if ((m_rdp->Texel0Color.i.a != 0) || (!m_rdp->OtherModes.alpha_compare_en))
+			if ((userdata->Texel0Color.i.a != 0) || (!object.OtherModes.alpha_compare_en))
 			{
-				m_rdp->Framebuffer.Copy(curpixel, m_rdp->Texel0Color.i.r, m_rdp->Texel0Color.i.g, m_rdp->Texel0Color.i.b);
+				((this)->*(_Copy[object.MiscState.FBSize - 2]))(curpixel, userdata->Texel0Color.i.r, userdata->Texel0Color.i.g, userdata->Texel0Color.i.b, userdata->Texel0Color.i.a ? 7 : 0, object);
 			}
 		}
 
@@ -475,17 +482,19 @@
 	}
 }
 
-void Span::DrawFill(int index, int tilenum, bool flip)
+void n64_rdp::SpanDrawFill(INT32 scanline, const extent_t &extent, const rdp_poly_state &object, int threadid)
 {
-	int clipx1 = m_rdp->GetScissor()->m_xh;
-	int clipx2 = m_rdp->GetScissor()->m_xl;
+	bool flip = object.flip;
+
+	int clipx1 = object.Scissor.m_xh;
+	int clipx2 = object.Scissor.m_xl;
 
 	int xinc = flip ? 1 : -1;
 
-	int fb_index = m_rdp->MiscState.FBWidth * index;
+	int fb_index = object.MiscState.FBWidth * scanline;
 
-	int xstart = m_lx;
-	int xend_scissored = m_rx;
+	int xstart = extent.startx;
+	int xend_scissored = extent.stopx;
 
 	int x = xend_scissored;
 
@@ -495,14 +504,9 @@
 	{
 		if (x >= clipx1 && x < clipx2)
 		{
-			UINT32 curpixel = fb_index + x;
-			m_rdp->Framebuffer.Fill(curpixel);
+			((this)->*(_Fill[object.MiscState.FBSize - 2]))(fb_index + x, object);
 		}
 
 		x += xinc;
 	}
 }
-
-}
-
-}
diff -Nru src-old/mame/video/rdpspn16.h src/mame/video/rdpspn16.h
--- src-old/mame/video/rdpspn16.h	2012-02-04 18:35:42.000000000 +0100
+++ src/mame/video/rdpspn16.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-#ifndef _VIDEO_RDPSPAN_H_
-#define _VIDEO_RDPSPAN_H_
-
-#include "emu.h"
-
-namespace N64
-{
-
-namespace RDP
-{
-
-#define RDP_CVG_SPAN_MAX    1024
-
-class OtherModes;
-class MiscState;
-class Processor;
-
-class SpanParam
-{
-	public:
-		union
-		{
-			UINT32 w;
-#ifdef LSB_FIRST
-			struct { UINT16 l; INT16 h; } h;
-#else
-			struct { INT16 h; UINT16 l; } h;
-#endif
-		};
-};
-
-class Span
-{
-	public:
-		Span() { }
-
-		void	Dump();
-		void	SetMachine(running_machine& machine);
-
-		void	Draw1Cycle(int index, int tilenum, bool flip);
-		void	Draw2Cycle(int index, int tilenum, bool flip);
-		void	DrawCopy(int index, int tilenum, bool flip);
-		void	DrawFill(int index, int tilenum, bool flip);
-
-		running_machine &machine() const { assert(m_machine != NULL); return *m_machine; }
-
-	public:
-		int m_lx;
-		int m_rx;
-		int m_unscissored_rx;
-
-		SpanParam m_s;
-		SpanParam m_t;
-		SpanParam m_w;
-		SpanParam m_r;
-		SpanParam m_g;
-		SpanParam m_b;
-		SpanParam m_a;
-		SpanParam m_z;
-
-		UINT16 m_cvg[RDP_CVG_SPAN_MAX+1];   // guard word for worst-case
-
-	private:
-		void RGBAZClip(int sr, int sg, int sb, int sa, int *sz);
-		void RGBAZCorrectTriangle(INT32 offx, INT32 offy, INT32* r, INT32* g, INT32* b, INT32* a, INT32* z);
-
-		running_machine* m_machine;
-		Processor* m_rdp;
-		MiscState* m_misc_state;
-		OtherModes* m_other_modes;
-};
-
-} // namespace RDP
-
-} // namespace N64
-
-#endif // _VIDEO_RDPSPAN_H_
diff -Nru src-old/mame/video/rdptpipe.c src/mame/video/rdptpipe.c
--- src-old/mame/video/rdptpipe.c	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdptpipe.c	2012-02-19 12:21:36.000000000 +0100
@@ -2,20 +2,13 @@
 #include "includes/n64.h"
 #include "video/n64.h"
 
-namespace N64
-{
-
-namespace RDP
-{
-
 #define RELATIVE(x, y)	((((x) >> 3) - (y)) << 3) | (x & 7);
 
-void TexturePipeT::SetMachine(running_machine &machine)
+void N64TexturePipeT::SetMachine(running_machine &machine)
 {
-	_n64_state *state = machine.driver_data<_n64_state>();
+	n64_state *state = machine.driver_data<n64_state>();
 
-	m_machine = &machine;
-	m_rdp = &state->m_rdp;
+	m_rdp = state->m_rdp;
 
 	for(int i = 0; i < 0x10000; i++)
 	{
@@ -28,9 +21,9 @@
 	}
 }
 
-void TexturePipeT::Mask(INT32* S, INT32* T, INT32 num)
+void N64TexturePipeT::Mask(INT32* S, INT32* T, INT32 num, const rdp_poly_state& object)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 
 	if (tile[num].mask_s)
 	{
@@ -55,9 +48,9 @@
 	}
 }
 
-void TexturePipeT::MaskCoupled(INT32* S, INT32* S1, INT32* T, INT32* T1, INT32 num)
+void N64TexturePipeT::MaskCoupled(INT32* S, INT32* S1, INT32* T, INT32* T1, INT32 num, const rdp_poly_state& object)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 
 	if (tile[num].mask_s)
 	{
@@ -102,9 +95,9 @@
 	}
 }
 
-void TexturePipeT::ShiftCycle(INT32* S, INT32* T, INT32* maxs, INT32* maxt, UINT32 num)
+void N64TexturePipeT::ShiftCycle(INT32* S, INT32* T, INT32* maxs, INT32* maxt, UINT32 num, const rdp_poly_state& object)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	*S = SIGN16(*S);
 	*T = SIGN16(*T);
 	if (tile[num].shift_s < 11)
@@ -130,9 +123,9 @@
 	*maxt = ((*T >> 3) >= tile[num].th);
 }
 
-void TexturePipeT::ShiftCopy(INT32* S, INT32* T, UINT32 num)
+void N64TexturePipeT::ShiftCopy(INT32* S, INT32* T, UINT32 num, const rdp_poly_state& object)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	*S = SIGN16(*S);
 	*T = SIGN16(*T);
 	if (tile[num].shift_s < 11)//?-? tcu_tile
@@ -155,9 +148,9 @@
 	*T = SIGN16(*T);
 }
 
-void TexturePipeT::ClampCycle(INT32* S, INT32* T, INT32* SFRAC, INT32* TFRAC, INT32 maxs, INT32 maxt, INT32 num)
+void N64TexturePipeT::ClampCycle(INT32* S, INT32* T, INT32* SFRAC, INT32* TFRAC, INT32 maxs, INT32 maxt, INT32 num, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	int dos = tile[num].cs || !tile[num].mask_s;
 	int dot = tile[num].ct || !tile[num].mask_t;
 
@@ -206,9 +199,9 @@
 	}
 }
 
-void TexturePipeT::ClampCycleLight(INT32* S, INT32* T, bool maxs, bool maxt, INT32 num)
+void N64TexturePipeT::ClampCycleLight(INT32* S, INT32* T, bool maxs, bool maxt, INT32 num, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	int dos = tile[num].cs || !tile[num].mask_s;
 	int dot = tile[num].ct || !tile[num].mask_t;
 
@@ -253,18 +246,18 @@
 	}
 }
 
-void TexturePipeT::Cycle(Color* TEX, Color* prev, INT32 SSS, INT32 SST, UINT32 tilenum, UINT32 cycle)
+void N64TexturePipeT::Cycle(Color* TEX, Color* prev, INT32 SSS, INT32 SST, UINT32 tilenum, UINT32 cycle, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 
 #define TRELATIVE(x, y) 	((((x) >> 3) - (y)) << 3) | (x & 7);
-	INT32 bilerp = cycle ? m_rdp->OtherModes.bi_lerp1 : m_rdp->OtherModes.bi_lerp0;
-	int convert = m_rdp->OtherModes.convert_one && cycle;
+	INT32 bilerp = cycle ? object.OtherModes.bi_lerp1 : object.OtherModes.bi_lerp0;
+	int convert = object.OtherModes.convert_one && cycle;
 	Color t0;
 	Color t1;
 	Color t2;
 	Color t3;
-	if (m_rdp->OtherModes.sample_type)
+	if (object.OtherModes.sample_type)
 	{
 		int sss1, sst1, sss2, sst2;
 
@@ -278,7 +271,7 @@
 		INT32 maxs;
 		INT32 maxt;
 
-		ShiftCycle(&sss1, &sst1, &maxs, &maxt, tilenum);
+		ShiftCycle(&sss1, &sst1, &maxs, &maxt, tilenum, object);
 
 		sss1 = TRELATIVE(sss1, tile[tilenum].sl);
 		sst1 = TRELATIVE(sst1, tile[tilenum].tl);
@@ -286,12 +279,12 @@
 		INT32 sfrac = sss1 & 0x1f;
 		INT32 tfrac = sst1 & 0x1f;
 
-		ClampCycle(&sss1, &sst1, &sfrac, &tfrac, maxs, maxt, tilenum);
+		ClampCycle(&sss1, &sst1, &sfrac, &tfrac, maxs, maxt, tilenum, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
 
 		sss2 = sss1 + 1;
 		sst2 = sst1 + 1;
 
-		MaskCoupled(&sss1, &sss2, &sst1, &sst2, tilenum);
+		MaskCoupled(&sss1, &sss2, &sst1, &sst2, tilenum, object);
 
 		bool upper = ((sfrac + tfrac) >= 0x20);
 
@@ -301,20 +294,20 @@
 			invtf = 0x20 - tfrac;
 		}
 
-		center = (sfrac == 0x10) && (tfrac == 0x10) && m_rdp->OtherModes.mid_texel;
+		center = (sfrac == 0x10) && (tfrac == 0x10) && object.OtherModes.mid_texel;
 
 		invsf <<= 3;
 		invtf <<= 3;
 		sfrac <<= 3;
 		tfrac <<= 3;
 
-		t0.c = Fetch(sss1, sst1, tilenum);
+		t0.c = Fetch(sss1, sst1, tilenum, object, userdata);
 
 		if (bilerp)
 		{
-			t1.c = Fetch(sss2, sst1, tilenum);
-			t2.c = Fetch(sss1, sst2, tilenum);
-			t3.c = Fetch(sss2, sst2, tilenum);
+			t1.c = Fetch(sss2, sst1, tilenum, object, userdata);
+			t2.c = Fetch(sss1, sst2, tilenum, object, userdata);
+			t3.c = Fetch(sss2, sst2, tilenum, object, userdata);
 			if (!center)
 			{
 				if (upper)
@@ -336,7 +329,7 @@
 				TEX->i.b &= 0x1ff;
 				TEX->i.a &= 0x1ff;
 			}
-			else//tf.c,24
+			else
 			{
 				TEX->i.r = (t0.i.r + t1.i.r + t2.i.r + t3.i.r) >> 2;
 				TEX->i.g = (t0.i.g + t1.i.g + t2.i.g + t3.i.g) >> 2;
@@ -377,15 +370,15 @@
 		INT32 maxs;
 		INT32 maxt;
 
-		ShiftCycle(&sss1, &sst1, &maxs, &maxt, tilenum);
+		ShiftCycle(&sss1, &sst1, &maxs, &maxt, tilenum, object);
 		sss1 = TRELATIVE(sss1, tile[tilenum].sl);
 		sst1 = TRELATIVE(sst1, tile[tilenum].tl);
 
-		ClampCycleLight(&sss1, &sst1, maxs, maxt, tilenum);
+		ClampCycleLight(&sss1, &sst1, maxs, maxt, tilenum, userdata, object, m_clamp_s_diff, m_clamp_t_diff);
 
-        Mask(&sss1, &sst1, tilenum);
+        Mask(&sss1, &sst1, tilenum, object);
 
-		t0.c = Fetch(sss1, sst1, tilenum);
+		t0.c = Fetch(sss1, sst1, tilenum, object, userdata);
 		if (bilerp)
 		{
 			*TEX = t0;
@@ -419,27 +412,27 @@
 	}
 }
 
-void TexturePipeT::Copy(Color* TEX, INT32 SSS, INT32 SST, UINT32 tilenum)
+void N64TexturePipeT::Copy(Color* TEX, INT32 SSS, INT32 SST, UINT32 tilenum, const rdp_poly_state& object, rdp_span_aux *userdata)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	INT32 sss1 = SSS;
 	INT32 sst1 = SST;
-	ShiftCopy(&sss1, &sst1, tilenum);
+	ShiftCopy(&sss1, &sst1, tilenum, object);
 	sss1 = TRELATIVE(sss1, tile[tilenum].sl);
 	sst1 = TRELATIVE(sst1, tile[tilenum].tl);
 	sss1 = (SIGN17(sss1) >> 5) & 0x1fff;
 	sst1 = (SIGN17(sst1) >> 5) & 0x1fff;
-	Mask(&sss1, &sst1, tilenum);
-	TEX->c = Fetch(sss1, sst1, tilenum);
+	Mask(&sss1, &sst1, tilenum, object);
+	TEX->c = Fetch(sss1, sst1, tilenum, object, userdata);
 }
 
-void TexturePipeT::LOD1Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc)
+void N64TexturePipeT::LOD1Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
 	INT32 nextsw = (w + dwinc) >> 16;
 	INT32 nexts = (s + dsinc) >> 16;
 	INT32 nextt = (t + dtinc) >> 16;
 
-	if (m_rdp->OtherModes.persp_tex_en)
+	if (object.OtherModes.persp_tex_en)
 	{
 		m_rdp->TCDiv(nexts, nextt, nextsw, &nexts, &nextt);
 	}
@@ -448,9 +441,9 @@
 		m_rdp->TCDivNoPersp(nexts, nextt, nextsw, &nexts, &nextt);
 	}
 
-	m_start_span = false;
-	m_precomp_s = nexts;
-	m_precomp_t = nextt;
+	userdata->m_start_span = false;
+	userdata->m_precomp_s = nexts;
+	userdata->m_precomp_t = nextt;
 
 	int tempanded;
 	if (*sss & 0x40000)
@@ -504,13 +497,13 @@
 	}
 }
 
-void TexturePipeT::LOD2Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, INT32* t2)
+void N64TexturePipeT::LOD2Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, INT32* t2, rdp_span_aux *userdata, const rdp_poly_state& object)
 {
 	INT32 nextsw = (w + dwinc) >> 16;
 	INT32 nexts = (s + dsinc) >> 16;
 	INT32 nextt = (t + dtinc) >> 16;
 
-	if (m_rdp->OtherModes.persp_tex_en)
+	if (object.OtherModes.persp_tex_en)
 	{
 		m_rdp->TCDiv(nexts, nextt, nextsw, &nexts, &nextt);
 	}
@@ -519,9 +512,9 @@
 		m_rdp->TCDivNoPersp(nexts, nextt, nextsw, &nexts, &nextt);
 	}
 
-	m_start_span = false;
-	m_precomp_s = nexts;
-	m_precomp_t = nextt;
+	userdata->m_start_span = false;
+	userdata->m_precomp_s = nexts;
+	userdata->m_precomp_t = nextt;
 
 	INT32 lodclamp = (((*sst & 0x60000) > 0) | ((nextt & 0x60000) > 0)) || (((*sss & 0x60000) > 0) | ((nexts & 0x60000) > 0));
 
@@ -593,44 +586,44 @@
 	{
 		lod = 0x7fff;
 	}
-	else if (lod < m_rdp->MiscState.MinLevel)
+	else if (lod < object.MiscState.MinLevel)
 	{
-		lod = m_rdp->MiscState.MinLevel;
+		lod = object.MiscState.MinLevel;
 	}
 
 	bool magnify = (lod < 32);
 	INT32 l_tile = m_rdp->GetLog2((lod >> 5) & 0xff);
-	bool distant = ((lod & 0x6000) || (l_tile >= m_rdp->MiscState.MaxLevel));
+	bool distant = ((lod & 0x6000) || (l_tile >= object.MiscState.MaxLevel));
 
-	m_rdp->LODFraction = ((lod << 3) >> l_tile) & 0xff;
+	userdata->LODFraction = ((lod << 3) >> l_tile) & 0xff;
 
-	if(!m_rdp->OtherModes.sharpen_tex_en && !m_rdp->OtherModes.detail_tex_en)
+	if(!object.OtherModes.sharpen_tex_en && !object.OtherModes.detail_tex_en)
 	{
 		if (distant)
 		{
-			m_rdp->LODFraction = 0xff;
+			userdata->LODFraction = 0xff;
 		}
 		else if (magnify)
 		{
-			m_rdp->LODFraction = 0;
+			userdata->LODFraction = 0;
 		}
 	}
 
-	if(m_rdp->OtherModes.sharpen_tex_en && magnify)
+	if(object.OtherModes.sharpen_tex_en && magnify)
 	{
-		m_rdp->LODFraction = m_rdp->LODFraction | 0x100;
+		userdata->LODFraction = userdata->LODFraction | 0x100;
 	}
 
-	if (m_rdp->OtherModes.tex_lod_en)
+	if (object.OtherModes.tex_lod_en)
 	{
 		if (distant)
 		{
-			l_tile = m_rdp->MiscState.MaxLevel;
+			l_tile = object.MiscState.MaxLevel;
 		}
-		if (!m_rdp->OtherModes.detail_tex_en)
+		if (!object.OtherModes.detail_tex_en)
 		{
 			*t1 = (prim_tile + l_tile) & 7;
-			if (!(distant || (!m_rdp->OtherModes.sharpen_tex_en && magnify)))
+			if (!(distant || (!object.OtherModes.sharpen_tex_en && magnify)))
 			{
 				*t2 = (*t1 + 1) & 7;
 			}
@@ -662,13 +655,13 @@
 	}
 }
 
-void TexturePipeT::LOD2CycleLimited(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1)
+void N64TexturePipeT::LOD2CycleLimited(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, const rdp_poly_state& object)
 {
 	INT32 nextsw = (w + dwinc) >> 16;
 	INT32 nexts = (s + dsinc) >> 16;
 	INT32 nextt = (t + dtinc) >> 16;
 
-	if (m_rdp->OtherModes.persp_tex_en)
+	if (object.OtherModes.persp_tex_en)
 	{
 		m_rdp->TCDiv(nexts, nextt, nextsw, &nexts, &nextt);
 	}
@@ -747,22 +740,22 @@
 	{
 		lod = 0x7fff;
 	}
-	else if (lod < m_rdp->MiscState.MinLevel)
+	else if (lod < object.MiscState.MinLevel)
 	{
-		lod = m_rdp->MiscState.MinLevel;
+		lod = object.MiscState.MinLevel;
 	}
 
 	bool magnify = (lod < 32);
 	INT32 l_tile = m_rdp->GetLog2((lod >> 5) & 0xff);
-	bool distant = (lod & 0x6000) || (l_tile >= m_rdp->MiscState.MaxLevel);
+	bool distant = (lod & 0x6000) || (l_tile >= object.MiscState.MaxLevel);
 
-	if (m_rdp->OtherModes.tex_lod_en)
+	if (object.OtherModes.tex_lod_en)
 	{
 		if (distant)
 		{
-			l_tile = m_rdp->MiscState.MaxLevel;
+			l_tile = object.MiscState.MaxLevel;
 		}
-		if (!m_rdp->OtherModes.detail_tex_en)
+		if (!object.OtherModes.detail_tex_en)
 		{
 			*t1 = (prim_tile + l_tile) & 7;
 		}
@@ -781,12 +774,12 @@
 	}
 }
 
-void TexturePipeT::CalculateClampDiffs(UINT32 prim_tile)
+void N64TexturePipeT::CalculateClampDiffs(UINT32 prim_tile, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff)
 {
-	Tile* tile = m_rdp->GetTiles();
-	if (m_rdp->OtherModes.cycle_type == CYCLE_TYPE_2)
+	const N64Tile* tile = object.m_tiles;
+	if (object.OtherModes.cycle_type == CYCLE_TYPE_2)
 	{
-		if (m_rdp->OtherModes.tex_lod_en)
+		if (object.OtherModes.tex_lod_en)
 		{
 			int start = 0;
 			int end = 7;
@@ -818,14 +811,14 @@
 static INT32 sTexAddrSwap16[2] = { WORD_ADDR_XOR, WORD_XOR_DWORD_SWAP };
 static INT32 sTexAddrSwap8[2] = { BYTE_ADDR_XOR, BYTE_XOR_DWORD_SWAP };
 
-UINT32 TexturePipeT::_FetchRGBA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x7ff;
 
-	UINT16 c = m_rdp->GetTMEM16()[taddr];
-	c = m_rdp->GetTLUT()[(c >> 8) << 2];
+	UINT16 c = ((UINT16*)userdata->m_tmem)[taddr];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 8) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -839,14 +832,14 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchRGBA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x7ff;
 
-	UINT16 c = m_rdp->GetTMEM16()[taddr];
-	c = m_rdp->GetTLUT()[(c >> 8) << 2];
+	UINT16 c = ((UINT16*)userdata->m_tmem)[taddr];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 8) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -854,16 +847,16 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchRGBA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x7ff;
 
 #if USE_64K_LUT
-	return Expand16To32Table[m_rdp->GetTMEM16()[taddr]];
+	return Expand16To32Table[((UINT16*)userdata->m_tmem)[taddr]];
 #else
-	UINT16 c = m_rdp->GetTMEM16()[taddr];
+	UINT16 c = ((UINT16*)userdata->m_tmem)[taddr];
 	Color color;
 	color.i.r = GET_HI_RGBA16_TMEM(c);
 	color.i.g = GET_MED_RGBA16_TMEM(c);
@@ -873,15 +866,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchRGBA_32_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_32_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT32 *tc = m_rdp->GetTMEM32();
+	UINT32 *tc = ((UINT32*)userdata->m_tmem);
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 
 	taddr &= 0x3ff;
 	UINT32 c = tc[taddr];
-	c = m_rdp->GetTLUT()[(c >> 24) << 2];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 24) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -895,15 +888,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchRGBA_32_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_32_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT32 *tc = m_rdp->GetTMEM32();
+	UINT32 *tc = ((UINT32*)userdata->m_tmem);
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 
 	taddr &= 0x3ff;
 	UINT32 c = tc[taddr];
-	c = m_rdp->GetTLUT()[(c >> 24) << 2];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 24) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -912,29 +905,29 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchRGBA_32_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchRGBA_32_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 
 	taddr &= 0x3ff;
 
-	UINT32 c = m_rdp->GetTMEM16()[taddr];
+	UINT32 c = ((UINT16*)userdata->m_tmem)[taddr];
 	Color color;
 	color.i.r = (c >> 8) & 0xff;
 	color.i.g = c & 0xff;
-	c = m_rdp->GetTMEM16()[taddr | 0x400];
+	c = ((UINT16*)userdata->m_tmem)[taddr | 0x400];
 	color.i.b = (c >>  8) & 0xff;
 	color.i.a = c & 0xff;
 
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchNOP(INT32 s, INT32 t, INT32 tbase, INT32 tpal) { return 0; }
+UINT32 N64TexturePipeT::_FetchNOP(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata) { return 0; }
 
-UINT32 TexturePipeT::_FetchYUV(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchYUV(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT16 *tc = m_rdp->GetTMEM16();
+	UINT16 *tc = ((UINT16*)userdata->m_tmem);
 
 	int taddr = (tbase << 3) + s;
 	int taddrlow = taddr >> 1;
@@ -947,7 +940,7 @@
 
 	UINT16 c = tc[taddrlow];
 
-	INT32 y = m_rdp->GetTMEM()[taddr | 0x800];
+	INT32 y = userdata->m_tmem[taddr | 0x800];
 	INT32 u = c >> 8;
 	INT32 v = c & 0xff;
 
@@ -964,16 +957,16 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchCI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
 
 	taddr &= 0x7ff;
 	UINT8 p = (s & 1) ? (tc[taddr] & 0xf) : (tc[taddr] >> 4);
-	UINT16 c = m_rdp->GetTLUT()[((tpal << 4) | p) << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | p) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -987,16 +980,16 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchCI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
 
 	taddr &= 0x7ff;
 	UINT8 p = (s & 1) ? (tc[taddr] & 0xf) : (tc[taddr] >> 4);
-	UINT16 c = m_rdp->GetTLUT()[((tpal << 4) | p) << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | p) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -1005,9 +998,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchCI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1021,15 +1014,15 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchCI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = tc[taddr];
-	UINT16 c = m_rdp->GetTLUT()[p << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[p << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -1043,15 +1036,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchCI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = tc[taddr];
-	UINT16 c = m_rdp->GetTLUT()[p << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[p << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -1060,9 +1053,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchCI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchCI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1075,15 +1068,15 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = ((s) & 1) ? (tc[taddr] & 0xf) : (tc[taddr] >> 4);
-	UINT16 c = m_rdp->GetTLUT()[((tpal << 4) | p) << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | p) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -1097,15 +1090,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchIA_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = ((s) & 1) ? (tc[taddr] & 0xf) : (tc[taddr] >> 4);
-	UINT16 c = m_rdp->GetTLUT()[((tpal << 4) | p) << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | p) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -1114,9 +1107,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1129,20 +1122,20 @@
 	color.i.r = i;
 	color.i.g = i;
 	color.i.b = i;
-	color.i.a = (p & 1) & 0xff;
+	color.i.a = (p & 1) * 0xff;
 
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = tc[taddr];
-	UINT16 c = m_rdp->GetTLUT()[p << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[p << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -1156,15 +1149,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchIA_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 p = tc[taddr];
-	UINT16 c = m_rdp->GetTLUT()[p << 2];
+	UINT16 c = ((UINT16*)(userdata->m_tmem + 0x800))[p << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -1173,9 +1166,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1193,15 +1186,15 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT16 *tc = m_rdp->GetTMEM16();
+	UINT16 *tc = ((UINT16*)userdata->m_tmem);
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x3ff;
 
 	UINT16 c = tc[taddr];
-	c = m_rdp->GetTLUT()[(c >> 8) << 2];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 8) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[c];
@@ -1215,15 +1208,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchIA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT16 *tc = m_rdp->GetTMEM16();
+	UINT16 *tc = ((UINT16*)userdata->m_tmem);
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x3ff;
 
 	UINT16 c = tc[taddr];
-	c = m_rdp->GetTLUT()[(c >> 8) << 2];
+	c = ((UINT16*)(userdata->m_tmem + 0x800))[(c >> 8) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (c >> 8) & 0xff;
@@ -1232,9 +1225,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchIA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchIA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT16 *tc = m_rdp->GetTMEM16();
+	UINT16 *tc = ((UINT16*)userdata->m_tmem);
 	int taddr = (tbase << 2) + s;
 	taddr ^= sTexAddrSwap16[t & 1];
 	taddr &= 0x7ff;
@@ -1251,16 +1244,16 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 byteval = tc[taddr];
 	UINT8 c = ((s & 1)) ? (byteval & 0xf) : ((byteval >> 4) & 0xf);
-	UINT16 k = m_rdp->GetTLUT()[((tpal << 4) | c) << 2];
+	UINT16 k = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | c) << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[k];
@@ -1274,16 +1267,16 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 byteval = tc[taddr];
 	UINT8 c = ((s & 1)) ? (byteval & 0xf) : ((byteval >> 4) & 0xf);
-	UINT16 k = m_rdp->GetTLUT()[((tpal << 4) | c) << 2];
+	UINT16 k = ((UINT16*)(userdata->m_tmem + 0x800))[((tpal << 4) | c) << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (k >> 8) & 0xff;
@@ -1292,9 +1285,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = ((tbase << 4) + s) >> 1;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1312,15 +1305,15 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 c = tc[taddr];
-	UINT16 k = m_rdp->GetTLUT()[c << 2];
+	UINT16 k = ((UINT16*)(userdata->m_tmem + 0x800))[c << 2];
 
 #if USE_64K_LUT
 	return Expand16To32Table[k];
@@ -1334,15 +1327,15 @@
 #endif
 }
 
-UINT32 TexturePipeT::_FetchI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0x7ff;
 
 	UINT8 c = tc[taddr];
-	UINT16 k = m_rdp->GetTLUT()[c << 2];
+	UINT16 k = ((UINT16*)(userdata->m_tmem + 0x800))[c << 2];
 
 	Color color;
 	color.i.r = color.i.g = color.i.b = (k >> 8) & 0xff;
@@ -1351,9 +1344,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::_FetchI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal)
+UINT32 N64TexturePipeT::_FetchI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata)
 {
-	UINT8 *tc = m_rdp->GetTMEM();
+	UINT8 *tc = userdata->m_tmem;
 	int taddr = (tbase << 3) + s;
 	taddr ^= sTexAddrSwap8[t & 1];
 	taddr &= 0xfff;
@@ -1369,9 +1362,9 @@
 	return color.c;
 }
 
-UINT32 TexturePipeT::Fetch(INT32 s, INT32 t, INT32 tilenum)
+UINT32 N64TexturePipeT::Fetch(INT32 s, INT32 t, INT32 tilenum, const rdp_poly_state& object, rdp_span_aux *userdata)
 {
-	Tile* tile = m_rdp->GetTiles();
+	const N64Tile* tile = object.m_tiles;
 	UINT32 tformat = tile[tilenum].format;
 	UINT32 tsize =	tile[tilenum].size;
 
@@ -1379,11 +1372,7 @@
 	tbase += tile[tilenum].tmem;
 	UINT32 tpal	= tile[tilenum].palette;
 
-	UINT32 index = (tformat << 4) | (tsize << 2) | (m_rdp->OtherModes.en_tlut << 1) | m_rdp->OtherModes.tlut_type;
+	UINT32 index = (tformat << 4) | (tsize << 2) | (object.OtherModes.en_tlut << 1) | object.OtherModes.tlut_type;
 
-	return ((this)->*(TexelFetch[index]))(s, t, tbase, tpal);
+	return ((this)->*(TexelFetch[index]))(s, t, tbase, tpal, userdata);
 }
-
-} // namespace RDP
-
-} // namespace N64
diff -Nru src-old/mame/video/rdptpipe.h src/mame/video/rdptpipe.h
--- src-old/mame/video/rdptpipe.h	2012-02-05 16:14:28.000000000 +0100
+++ src/mame/video/rdptpipe.h	2012-02-19 12:21:36.000000000 +0100
@@ -3,23 +3,18 @@
 
 #include "emu.h"
 
-namespace N64
-{
-
-namespace RDP
-{
-
-class OtherModes;
-class MiscState;
-class Processor;
+class OtherModesT;
+class MiscStateT;
 class Color;
+class rdp_span_aux;
+struct rdp_poly_state;
 
-class TexturePipeT
+class N64TexturePipeT
 {
 	public:
-		typedef UINT32 (N64::RDP::TexturePipeT::*TexelFetcher) (INT32 s, INT32 t, INT32 tbase, INT32 tpal);
+		typedef UINT32 (N64TexturePipeT::*TexelFetcher) (INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
 
-		TexturePipeT()
+		N64TexturePipeT()
 		{
 			m_maskbits_table[0] = 0x3ff;
 			for(int i = 1; i < 16; i++)
@@ -27,135 +22,122 @@
 				m_maskbits_table[i] = ((UINT16)(0xffff) >> (16 - i)) & 0x3ff;
 			}
 			m_start_span = false;
-			m_precomp_s = 0;
-			m_precomp_t = 0;
 
 			for (int idx = 0; idx < 80; idx++)
 			{
-				TexelFetch[idx] = &N64::RDP::TexturePipeT::_FetchNOP;
+				TexelFetch[idx] = &N64TexturePipeT::_FetchNOP;
 			}
 
-			TexelFetch[ 8] = &N64::RDP::TexturePipeT::_FetchRGBA_16_RAW;
-			TexelFetch[ 9] = &N64::RDP::TexturePipeT::_FetchRGBA_16_RAW;
-			TexelFetch[10] = &N64::RDP::TexturePipeT::_FetchRGBA_16_TLUT0;
-			TexelFetch[11] = &N64::RDP::TexturePipeT::_FetchRGBA_16_TLUT1;
-			TexelFetch[12] = &N64::RDP::TexturePipeT::_FetchRGBA_32_RAW;
-			TexelFetch[13] = &N64::RDP::TexturePipeT::_FetchRGBA_32_RAW;
-			TexelFetch[14] = &N64::RDP::TexturePipeT::_FetchRGBA_32_TLUT0;
-			TexelFetch[15] = &N64::RDP::TexturePipeT::_FetchRGBA_32_TLUT1;
-
-			TexelFetch[24] = &N64::RDP::TexturePipeT::_FetchYUV;
-			TexelFetch[25] = &N64::RDP::TexturePipeT::_FetchYUV;
-			TexelFetch[26] = &N64::RDP::TexturePipeT::_FetchYUV;
-			TexelFetch[27] = &N64::RDP::TexturePipeT::_FetchYUV;
-
-			TexelFetch[32] = &N64::RDP::TexturePipeT::_FetchCI_4_RAW;
-			TexelFetch[33] = &N64::RDP::TexturePipeT::_FetchCI_4_RAW;
-			TexelFetch[34] = &N64::RDP::TexturePipeT::_FetchCI_4_TLUT0;
-			TexelFetch[35] = &N64::RDP::TexturePipeT::_FetchCI_4_TLUT1;
-			TexelFetch[36] = &N64::RDP::TexturePipeT::_FetchCI_8_RAW;
-			TexelFetch[37] = &N64::RDP::TexturePipeT::_FetchCI_8_RAW;
-			TexelFetch[38] = &N64::RDP::TexturePipeT::_FetchCI_8_TLUT0;
-			TexelFetch[39] = &N64::RDP::TexturePipeT::_FetchCI_8_TLUT1;
-
-			TexelFetch[48] = &N64::RDP::TexturePipeT::_FetchIA_4_RAW;
-			TexelFetch[49] = &N64::RDP::TexturePipeT::_FetchIA_4_RAW;
-			TexelFetch[50] = &N64::RDP::TexturePipeT::_FetchIA_4_TLUT0;
-			TexelFetch[51] = &N64::RDP::TexturePipeT::_FetchIA_4_TLUT1;
-			TexelFetch[52] = &N64::RDP::TexturePipeT::_FetchIA_8_RAW;
-			TexelFetch[53] = &N64::RDP::TexturePipeT::_FetchIA_8_RAW;
-			TexelFetch[54] = &N64::RDP::TexturePipeT::_FetchIA_8_TLUT0;
-			TexelFetch[55] = &N64::RDP::TexturePipeT::_FetchIA_8_TLUT1;
-			TexelFetch[56] = &N64::RDP::TexturePipeT::_FetchIA_16_RAW;
-			TexelFetch[57] = &N64::RDP::TexturePipeT::_FetchIA_16_RAW;
-			TexelFetch[58] = &N64::RDP::TexturePipeT::_FetchIA_16_TLUT0;
-			TexelFetch[59] = &N64::RDP::TexturePipeT::_FetchIA_16_TLUT1;
-
-			TexelFetch[64] = &N64::RDP::TexturePipeT::_FetchI_4_RAW;
-			TexelFetch[65] = &N64::RDP::TexturePipeT::_FetchI_4_RAW;
-			TexelFetch[66] = &N64::RDP::TexturePipeT::_FetchI_4_TLUT0;
-			TexelFetch[67] = &N64::RDP::TexturePipeT::_FetchI_4_TLUT1;
-			TexelFetch[68] = &N64::RDP::TexturePipeT::_FetchI_8_RAW;
-			TexelFetch[69] = &N64::RDP::TexturePipeT::_FetchI_8_RAW;
-			TexelFetch[70] = &N64::RDP::TexturePipeT::_FetchI_8_TLUT0;
-			TexelFetch[71] = &N64::RDP::TexturePipeT::_FetchI_8_TLUT1;
+			TexelFetch[ 8] = &N64TexturePipeT::_FetchRGBA_16_RAW;
+			TexelFetch[ 9] = &N64TexturePipeT::_FetchRGBA_16_RAW;
+			TexelFetch[10] = &N64TexturePipeT::_FetchRGBA_16_TLUT0;
+			TexelFetch[11] = &N64TexturePipeT::_FetchRGBA_16_TLUT1;
+			TexelFetch[12] = &N64TexturePipeT::_FetchRGBA_32_RAW;
+			TexelFetch[13] = &N64TexturePipeT::_FetchRGBA_32_RAW;
+			TexelFetch[14] = &N64TexturePipeT::_FetchRGBA_32_TLUT0;
+			TexelFetch[15] = &N64TexturePipeT::_FetchRGBA_32_TLUT1;
+
+			TexelFetch[24] = &N64TexturePipeT::_FetchYUV;
+			TexelFetch[25] = &N64TexturePipeT::_FetchYUV;
+			TexelFetch[26] = &N64TexturePipeT::_FetchYUV;
+			TexelFetch[27] = &N64TexturePipeT::_FetchYUV;
+
+			TexelFetch[32] = &N64TexturePipeT::_FetchCI_4_RAW;
+			TexelFetch[33] = &N64TexturePipeT::_FetchCI_4_RAW;
+			TexelFetch[34] = &N64TexturePipeT::_FetchCI_4_TLUT0;
+			TexelFetch[35] = &N64TexturePipeT::_FetchCI_4_TLUT1;
+			TexelFetch[36] = &N64TexturePipeT::_FetchCI_8_RAW;
+			TexelFetch[37] = &N64TexturePipeT::_FetchCI_8_RAW;
+			TexelFetch[38] = &N64TexturePipeT::_FetchCI_8_TLUT0;
+			TexelFetch[39] = &N64TexturePipeT::_FetchCI_8_TLUT1;
+
+			TexelFetch[48] = &N64TexturePipeT::_FetchIA_4_RAW;
+			TexelFetch[49] = &N64TexturePipeT::_FetchIA_4_RAW;
+			TexelFetch[50] = &N64TexturePipeT::_FetchIA_4_TLUT0;
+			TexelFetch[51] = &N64TexturePipeT::_FetchIA_4_TLUT1;
+			TexelFetch[52] = &N64TexturePipeT::_FetchIA_8_RAW;
+			TexelFetch[53] = &N64TexturePipeT::_FetchIA_8_RAW;
+			TexelFetch[54] = &N64TexturePipeT::_FetchIA_8_TLUT0;
+			TexelFetch[55] = &N64TexturePipeT::_FetchIA_8_TLUT1;
+			TexelFetch[56] = &N64TexturePipeT::_FetchIA_16_RAW;
+			TexelFetch[57] = &N64TexturePipeT::_FetchIA_16_RAW;
+			TexelFetch[58] = &N64TexturePipeT::_FetchIA_16_TLUT0;
+			TexelFetch[59] = &N64TexturePipeT::_FetchIA_16_TLUT1;
+
+			TexelFetch[64] = &N64TexturePipeT::_FetchI_4_RAW;
+			TexelFetch[65] = &N64TexturePipeT::_FetchI_4_RAW;
+			TexelFetch[66] = &N64TexturePipeT::_FetchI_4_TLUT0;
+			TexelFetch[67] = &N64TexturePipeT::_FetchI_4_TLUT1;
+			TexelFetch[68] = &N64TexturePipeT::_FetchI_8_RAW;
+			TexelFetch[69] = &N64TexturePipeT::_FetchI_8_RAW;
+			TexelFetch[70] = &N64TexturePipeT::_FetchI_8_TLUT0;
+			TexelFetch[71] = &N64TexturePipeT::_FetchI_8_TLUT1;
 		}
 
-		void				Cycle(Color* TEX, Color* prev, INT32 SSS, INT32 SST, UINT32 tilenum, UINT32 cycle);
-		void				Copy(Color* TEX, INT32 SSS, INT32 SST, UINT32 tilenum);
-		UINT32				Fetch(INT32 SSS, INT32 SST, INT32 tile);
-		void				CalculateClampDiffs(UINT32 prim_tile);
-		void				LOD1Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc);
-		void				LOD2Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, INT32* t2);
-		void				LOD2CycleLimited(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1);
+		void				Cycle(Color* TEX, Color* prev, INT32 SSS, INT32 SST, UINT32 tilenum, UINT32 cycle, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff);
+		void				Copy(Color* TEX, INT32 SSS, INT32 SST, UINT32 tilenum, const rdp_poly_state& object, rdp_span_aux *userdata);
+		UINT32				Fetch(INT32 SSS, INT32 SST, INT32 tile, const rdp_poly_state& object, rdp_span_aux *userdata);
+		void				CalculateClampDiffs(UINT32 prim_tile, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff);
+		void				LOD1Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, rdp_span_aux *userdata, const rdp_poly_state& object);
+		void				LOD2Cycle(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, INT32* t2, rdp_span_aux *userdata, const rdp_poly_state& object);
+		void				LOD2CycleLimited(INT32* sss, INT32* sst, INT32 s, INT32 t, INT32 w, INT32 dsinc, INT32 dtinc, INT32 dwinc, INT32 prim_tile, INT32* t1, const rdp_poly_state& object);
 
 		void				SetMachine(running_machine& machine);
 
 		bool				m_start_span;
-		INT32				m_precomp_s;
-		INT32				m_precomp_t;
 
 	private:
 		UINT32				Expand16To32Table[0x10000];
 
-		void				Mask(INT32* S, INT32* T, INT32 num);
-		void				MaskCoupled(INT32* S, INT32* S1, INT32* T, INT32* T1, INT32 num);
+		void				Mask(INT32* S, INT32* T, INT32 num, const rdp_poly_state& object);
+		void				MaskCoupled(INT32* S, INT32* S1, INT32* T, INT32* T1, INT32 num, const rdp_poly_state& object);
 
-		void				ShiftCycle(INT32* S, INT32* T, INT32* maxs, INT32* maxt, UINT32 num);
-		void				ShiftCopy(INT32* S, INT32* T, UINT32 num);
+		void				ShiftCycle(INT32* S, INT32* T, INT32* maxs, INT32* maxt, UINT32 num, const rdp_poly_state& object);
+		void				ShiftCopy(INT32* S, INT32* T, UINT32 num, const rdp_poly_state& object);
 
-		void				ClampCycle(INT32* S, INT32* T, INT32* SFRAC, INT32* TFRAC, INT32 maxs, INT32 maxt, INT32 num);
-		void				ClampCycleLight(INT32* S, INT32* T, bool maxs, bool maxt, INT32 num);
+		void				ClampCycle(INT32* S, INT32* T, INT32* SFRAC, INT32* TFRAC, INT32 maxs, INT32 maxt, INT32 num, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff);
+		void				ClampCycleLight(INT32* S, INT32* T, bool maxs, bool maxt, INT32 num, rdp_span_aux *userdata, const rdp_poly_state& object, INT32 *m_clamp_s_diff, INT32 *m_clamp_t_diff);
 
-		UINT32				_FetchNOP(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-
-		UINT32				_FetchRGBA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchRGBA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchRGBA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchRGBA_32_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchRGBA_32_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchRGBA_32_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-
-		UINT32				_FetchYUV(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-
-		UINT32				_FetchCI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchCI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchCI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchCI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchCI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchCI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-
-		UINT32				_FetchIA_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchIA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-
-		UINT32				_FetchI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
-		UINT32				_FetchI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal);
+		UINT32				_FetchNOP(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+
+		UINT32				_FetchRGBA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchRGBA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchRGBA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchRGBA_32_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchRGBA_32_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchRGBA_32_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+
+		UINT32				_FetchYUV(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+
+		UINT32				_FetchCI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchCI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchCI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchCI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchCI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchCI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+
+		UINT32				_FetchIA_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_16_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_16_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchIA_16_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+
+		UINT32				_FetchI_4_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchI_4_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchI_4_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchI_8_TLUT0(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchI_8_TLUT1(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
+		UINT32				_FetchI_8_RAW(INT32 s, INT32 t, INT32 tbase, INT32 tpal, rdp_span_aux *userdata);
 
 		TexelFetcher		TexelFetch[16*5];
 
-		running_machine*	m_machine;
-		OtherModes*			m_other_modes;
-		MiscState*			m_misc_state;
-		Processor*			m_rdp;
+		n64_rdp*			m_rdp;
 
 		INT32				m_maskbits_table[16];
-		INT32				m_clamp_t_diff[8];
-		INT32				m_clamp_s_diff[8];
 };
 
-} // namespace RDP
-
-} // namespace N64
-
 #endif // _VIDEO_RDPTEXPIPE_H_
diff -Nru src-old/mame/video/rdptri.h src/mame/video/rdptri.h
--- src-old/mame/video/rdptri.h	2012-02-03 22:06:10.000000000 +0100
+++ src/mame/video/rdptri.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-#ifndef _VIDEO_RDPTRI_H_
-#define _VIDEO_RDPTRI_H_
-
-#include "emu.h"
-
-namespace N64
-{
-
-namespace RDP
-{
-
-class MiscState;
-class Processor;
-
-class Triangle
-{
-	public:
-		Triangle() { fatalerror("Please don't use the default constructor for N64::RDP::Triangle\n"); }
-		Triangle(running_machine &machine, bool shade, bool texture, bool zbuffer, bool rect, bool flip);
-
-		void InitFromData(running_machine& machine, bool shade, bool texture, bool zbuffer, bool rect, bool flip);
-		void Draw();
-
-	private:
-		void compute_cvg_noflip(INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl);
-		void compute_cvg_flip(INT32* majorx, INT32* minorx, INT32* majorxint, INT32* minorxint, INT32 scanline, INT32 yh, INT32 yl);
-
-		running_machine*	m_machine;
-		UINT32*				m_cmd_data;
-		Processor*			m_rdp;
-		bool				m_shade;
-		bool				m_texture;
-		bool				m_zbuffer;
-		bool				m_rect;
-};
-
-} // namespace RDP
-
-} // namespace N64
-
-#endif // _VIDEO_RDPTRI_H_
diff -Nru src-old/mame/video/segas32.c src/mame/video/segas32.c
--- src-old/mame/video/segas32.c	2012-01-17 01:25:05.000000000 +0100
+++ src/mame/video/segas32.c	2012-02-06 02:30:22.000000000 +0100
@@ -142,7 +142,6 @@
 */
 
 #include "emu.h"
-#include "profiler.h"
 #include "includes/segas32.h"
 
 
diff -Nru src-old/mame/video/shangha3.c src/mame/video/shangha3.c
--- src-old/mame/video/shangha3.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/video/shangha3.c	2012-02-06 02:30:22.000000000 +0100
@@ -59,7 +59,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "includes/shangha3.h"
 
 
diff -Nru src-old/mame/video/snes.c src/mame/video/snes.c
--- src-old/mame/video/snes.c	2012-01-12 22:19:49.000000000 +0100
+++ src/mame/video/snes.c	2012-02-06 02:30:22.000000000 +0100
@@ -71,7 +71,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "includes/snes.h"
 
 #define SNES_MAINSCREEN    0
diff -Nru src-old/mame/video/starcrus.c src/mame/video/starcrus.c
--- src-old/mame/video/starcrus.c	2012-01-16 12:06:28.000000000 +0100
+++ src/mame/video/starcrus.c	2012-02-19 02:53:16.000000000 +0100
@@ -30,7 +30,7 @@
 WRITE8_HANDLER( starcrus_ship_parm_1_w )
 {
 	starcrus_state *state = space->machine().driver_data<starcrus_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	state->m_s1_sprite = data&0x1f;
 	state->m_engine1_on = ((data&0x20)>>5)^0x01;
@@ -40,7 +40,7 @@
 		if (state->m_engine_sound_playing == 0)
 		{
 			state->m_engine_sound_playing = 1;
-			sample_start(samples, 0, 0, 1);	/* engine sample */
+			samples->start(0, 0, true);	/* engine sample */
 		}
 	}
 	else
@@ -48,7 +48,7 @@
 		if (state->m_engine_sound_playing == 1)
 		{
 			state->m_engine_sound_playing = 0;
-			sample_stop(samples, 0);
+			samples->stop(0);
 		}
 	}
 }
@@ -56,7 +56,7 @@
 WRITE8_HANDLER( starcrus_ship_parm_2_w )
 {
 	starcrus_state *state = space->machine().driver_data<starcrus_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	state->m_s2_sprite = data&0x1f;
 	set_led_status(space->machine(), 2,~data & 0x80);			/* game over lamp */
@@ -68,7 +68,7 @@
 		if (state->m_engine_sound_playing == 0)
 		{
 			state->m_engine_sound_playing = 1;
-			sample_start(samples, 0, 0, 1);	/* engine sample */
+			samples->start(0, 0, true);	/* engine sample */
 		}
 	}
 	else
@@ -76,7 +76,7 @@
 		if (state->m_engine_sound_playing == 1)
 		{
 			state->m_engine_sound_playing = 0;
-			sample_stop(samples, 0);
+			samples->stop(0);
 		}
 	}
 
@@ -85,7 +85,7 @@
 WRITE8_HANDLER( starcrus_proj_parm_1_w )
 {
 	starcrus_state *state = space->machine().driver_data<starcrus_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	state->m_p1_sprite = data&0x0f;
 	state->m_launch1_on = ((data&0x20)>>5)^0x01;
@@ -96,7 +96,7 @@
 		if (state->m_explode_sound_playing == 0)
 		{
 			state->m_explode_sound_playing = 1;
-			sample_start(samples, 1,1,1);	/* explosion initial sample */
+			samples->start(1,1, true);	/* explosion initial sample */
 		}
 	}
 	else
@@ -104,7 +104,7 @@
 		if (state->m_explode_sound_playing == 1)
 		{
 			state->m_explode_sound_playing = 0;
-			sample_start(samples, 1,2,0);	/* explosion ending sample */
+			samples->start(1,2);	/* explosion ending sample */
 		}
 	}
 
@@ -113,7 +113,7 @@
 		if (state->m_launch1_sound_playing == 0)
 		{
 			state->m_launch1_sound_playing = 1;
-			sample_start(samples, 2,3,0);	/* launch sample */
+			samples->start(2,3);	/* launch sample */
 		}
 	}
 	else
@@ -125,7 +125,7 @@
 WRITE8_HANDLER( starcrus_proj_parm_2_w )
 {
 	starcrus_state *state = space->machine().driver_data<starcrus_state>();
-	device_t *samples = space->machine().device("samples");
+	samples_device *samples = space->machine().device<samples_device>("samples");
 
 	state->m_p2_sprite = data&0x0f;
 	state->m_launch2_on = ((data&0x20)>>5)^0x01;
@@ -136,7 +136,7 @@
 		if (state->m_explode_sound_playing == 0)
 		{
 			state->m_explode_sound_playing = 1;
-			sample_start(samples, 1,1,1);	/* explosion initial sample */
+			samples->start(1,1, true);	/* explosion initial sample */
 		}
 	}
 	else
@@ -144,7 +144,7 @@
 		if (state->m_explode_sound_playing == 1)
 		{
 			state->m_explode_sound_playing = 0;
-			sample_start(samples, 1,2,0);	/* explosion ending sample */
+			samples->start(1,2);	/* explosion ending sample */
 		}
 	}
 
@@ -153,7 +153,7 @@
 		if (state->m_launch2_sound_playing == 0)
 		{
 			state->m_launch2_sound_playing = 1;
-			sample_start(samples, 3,3,0);	/* launch sample */
+			samples->start(3,3);	/* launch sample */
 		}
 	}
 	else
diff -Nru src-old/mame/video/stvvdp2.c src/mame/video/stvvdp2.c
--- src-old/mame/video/stvvdp2.c	2012-02-03 22:31:09.000000000 +0100
+++ src/mame/video/stvvdp2.c	2012-02-07 00:06:04.000000000 +0100
@@ -102,9 +102,7 @@
 */
 
 #include "emu.h"
-#include "profiler.h"
 #include "includes/stv.h"
-#include "drawgfxm.h"
 
 static UINT8 get_vblank(running_machine &machine);
 static UINT8 get_hblank(running_machine &machine);
@@ -2438,10 +2436,10 @@
 {
 	UINT32 rb = (a & 0xff00ff) + (b & 0xff00ff);
 	UINT32 g = (a & 0x00ff00) + (b & 0x00ff00);
-	if (rb & 0x1000000) rb |= 0xff0000;
-	if (g & 0x10000) g = 0xff00;
-	if (rb & 0x100) rb |= 0xff;
-	return (rb & 0xff00ff) | g;
+	return MAKE_RGB((rb & 0x1000000) ? 0xff : RGB_RED(rb),
+		(g & 0x0010000) ? 0xff : RGB_GREEN(g),
+		(rb & 0x0000100) ? 0xff : RGB_BLUE(rb)
+	);
 }
 
 static void stv_vdp2_drawgfxzoom(
@@ -2692,7 +2690,6 @@
 	saturn_state *state = machine.driver_data<saturn_state>();
 	rectangle myclip;
 	UINT8* gfxdata;
-	int t_pen;
 	int sprite_screen_width, sprite_screen_height;
 
 	gfxdata = state->m_vdp2.gfx_decode + code * 0x20;
@@ -2772,12 +2769,11 @@
 					int r,g,b;
 
 					data = (source[(x_index>>16)*2] << 8) | source[(x_index>>16)*2+1];
-					t_pen = (data & 0x8000) || ( transparency == STV_TRANSPARENCY_NONE );
-					if (t_pen)
+					if ((data & 0x8000) || (transparency == STV_TRANSPARENCY_NONE))
 					{
-						b = (data & 0x7c00) >> 7;
-						g = (data & 0x03e0) >> 2;
-						r = (data & 0x001f) << 3;
+						b = pal5bit((data & 0x7c00) >> 10);
+						g = pal5bit((data & 0x03e0) >> 5);
+						r = pal5bit( data & 0x001f);
 						if(stv2_current_tilemap.fade_control & 1)
 							stv_vdp2_compute_color_offset(machine,&r,&g,&b,stv2_current_tilemap.fade_control & 2);
 
@@ -2805,7 +2801,6 @@
 	saturn_state *state = machine.driver_data<saturn_state>();
 	rectangle myclip;
 	UINT8* gfxdata;
-	int t_pen;
 	int sprite_screen_width, sprite_screen_height;
 
 	gfxdata = state->m_vdp2.gfx_decode + code * 0x20;
@@ -2885,8 +2880,7 @@
 					int r,g,b;
 
 					data = (source[(x_index>>16)*4+0] << 24) | (source[(x_index>>16)*4+1] << 16) | (source[(x_index>>16)*4+2] << 8) | (source[(x_index>>16)*4+3] << 0);
-					t_pen = (data & 0x80000000) || ( transparency == STV_TRANSPARENCY_NONE );
-					if (t_pen)
+					if ((data & 0x80000000) || (transparency == STV_TRANSPARENCY_NONE))
 					{
 						b = (data & 0xff0000) >> 16;
 						g = (data & 0x00ff00) >> 8;
@@ -2925,13 +2919,9 @@
 	int xlinesize = 0/*, xpixelsize = 0*/;
 	int xcnt,ycnt;
 	UINT8* gfxdata = state->m_vdp2.gfx_decode;
-	static UINT32 *destline;
+	UINT32 *destline;
 	UINT16 pal_color_offset = 0;
 	UINT8* gfxdatalow, *gfxdatahigh;
-	/*Window effect 1=no draw*/
-	int tw = 0;
-	/*Transparency code 1=opaque,0=transparent*/
-	int t_pen;
 	int screen_x,screen_y;
 
 	if (!stv2_current_tilemap.enabled) return;
@@ -2993,35 +2983,29 @@
 			{
 				for (xcnt = 0; xcnt <xsize;xcnt+=2)
 				{
-					tw = stv_vdp2_window_process(machine,xcnt+1,ycnt);
-					if(tw == 0)
+					if (!stv_vdp2_window_process(machine,xcnt+1,ycnt))
 					{
-						t_pen = (((gfxdata[0] & 0x0f) >> 0) != 0) ? (1) : (0);
-						if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-						if(t_pen)
+						if ((gfxdata[0] & 0x0f) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 						{
 							if (((xcnt + 1) <= screen_x) && (ycnt <= screen_y))
 							{
-							if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-								bitmap.pix32(ycnt, xcnt+1) = machine.pens[((gfxdata[0] & 0x0f) >> 0) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
-							else
-								bitmap.pix32(ycnt, xcnt+1) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt+1), machine.pens[((gfxdata[0] & 0x0f) >> 0) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
+								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+									bitmap.pix32(ycnt, xcnt+1) = machine.pens[((gfxdata[0] & 0x0f) >> 0) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
+								else
+									bitmap.pix32(ycnt, xcnt+1) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt+1), machine.pens[((gfxdata[0] & 0x0f) >> 0) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
 							}
 						}
 					}
-					tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-					if(tw == 0)
+					if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 					{
-						t_pen = (((gfxdata[0] & 0xf0) >> 4) != 0) ? (1) : (0);
-						if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-						if(t_pen)
+						if ((gfxdata[0] & 0xf0) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 						{
 							if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 							{
-							if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-								bitmap.pix32(ycnt, xcnt) = machine.pens[((gfxdata[0] & 0xf0) >> 4) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
-							else
-								bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[((gfxdata[0] & 0xf0) >> 4) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
+								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+									bitmap.pix32(ycnt, xcnt) = machine.pens[((gfxdata[0] & 0xf0) >> 4) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
+								else
+									bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[((gfxdata[0] & 0xf0) >> 4) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
 							}
 						}
 					}
@@ -3043,20 +3027,17 @@
 					{
 						int xs = xcnt & xsizemask;
 
-						tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-						if(tw == 0)
+						if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 						{
 							//60aee2c = $0013 at @605d838
-							t_pen = ((gfxdata[xs] & 0xff) != 0) ? (1) : (0);
-							if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-							if(t_pen)
+							if ((gfxdata[xs] & 0xff) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 							{
 								if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 								{
-								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-									bitmap.pix32(ycnt, xcnt) = machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
-								else
-									bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
+									if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+										bitmap.pix32(ycnt, xcnt) = machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
+									else
+										bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
 								}
 							}
 						}
@@ -3085,24 +3066,20 @@
 					gfxdata += xlinesize*(yy>>16);
 					yy &= 0xffff;
 
-					destline = &bitmap.pix32(ycnt);
 					xx = 0;
 					for (xcnt = cliprect.min_x; xcnt <= cliprect.max_x; xx+=stv2_current_tilemap.incx, xcnt++)
 					{
 						xs = xx >> 16;
-						tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-						if(tw == 0)
+						if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 						{
-							t_pen = ((gfxdata[xs] & 0xff) != 0) ? 1 : 0;
-							if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-							if(t_pen)
+							if ((gfxdata[xs] & 0xff) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 							{
 								if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 								{
-								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-									bitmap.pix32(ycnt, xcnt) = machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
-								else
-									bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
+									if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+										bitmap.pix32(ycnt, xcnt) = machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset];
+									else
+										bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[(gfxdata[xs] & 0xff) | (stv2_current_tilemap.bitmap_palette_number * 0x100) | pal_color_offset], stv2_current_tilemap.alpha);
 								}
 							}
 						}
@@ -3118,19 +3095,16 @@
 			{
 				for (xcnt = 0; xcnt <xsize;xcnt++)
 				{
-					tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-					if(tw == 0)
+					if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 					{
-						t_pen = ((((gfxdata[0] & 0x07) * 0x100) | (gfxdata[1] & 0xff)) != 0) ? (1) : (0);
-						if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-						if(t_pen)
+						if (((gfxdata[0] & 0x07) | (gfxdata[1] & 0xff)) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 						{
 							if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 							{
-							if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-								bitmap.pix32(ycnt, xcnt) = machine.pens[((gfxdata[0] & 0x07) * 0x100) | (gfxdata[1] & 0xff) | pal_color_offset];
-							else
-								bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[((gfxdata[0] & 0x07) * 0x100) | (gfxdata[1] & 0xff) | pal_color_offset], stv2_current_tilemap.alpha);
+								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+									bitmap.pix32(ycnt, xcnt) = machine.pens[((gfxdata[0] & 0x07) * 0x100) | (gfxdata[1] & 0xff) | pal_color_offset];
+								else
+									bitmap.pix32(ycnt, xcnt) = alpha_blend_r32(bitmap.pix32(ycnt, xcnt), machine.pens[((gfxdata[0] & 0x07) * 0x100) | (gfxdata[1] & 0xff) | pal_color_offset], stv2_current_tilemap.alpha);
 							}
 						}
 					}
@@ -3162,24 +3136,22 @@
 						int r,g,b;
 						int xs = xcnt & xsizemask;
 
-						t_pen = ((gfxdata[2*xs] & 0x80) >> 7) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE);
-
-						if(t_pen)
+						if ((gfxdata[2*xs] & 0x80) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 						{
-							b = ((gfxdata[2*xs] & 0x7c) << 1);
-							g = ((gfxdata[2*xs] & 0x03) << 6) | ((gfxdata[2*xs+1] & 0xe0) >> 2);
-							r = ((gfxdata[2*xs+1] & 0x1f) << 3);
+							b = pal5bit(((gfxdata[2*xs] & 0x7c) >> 2));
+							g = pal5bit(((gfxdata[2*xs] & 0x03) << 3) | ((gfxdata[2*xs+1] & 0xe0) >> 5));
+							r = pal5bit(gfxdata[2*xs+1] & 0x1f);
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset(machine,&r,&g,&b,stv2_current_tilemap.fade_control & 2);
-							tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-							if(tw == 0)
+
+							if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 							{
 								if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 								{
-								if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
-									destline[xcnt] = MAKE_RGB(r, g, b);
-								else
-									destline[xcnt] = alpha_blend_r32( destline[xcnt], MAKE_RGB(r, g, b), stv2_current_tilemap.alpha );
+									if ( stv2_current_tilemap.colour_calculation_enabled == 0 )
+										destline[xcnt] = MAKE_RGB(r, g, b);
+									else
+										destline[xcnt] = alpha_blend_r32( destline[xcnt], MAKE_RGB(r, g, b), stv2_current_tilemap.alpha );
 								}
 							}
 						}
@@ -3208,17 +3180,15 @@
 						int r,g,b;
 
 						xs = xx >> 16;
-						t_pen = ((gfxdata[2*xs] & 0x80) >> 7);
-						if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-						b = ((gfxdata[2*xs] & 0x7c) << 1);
-						g = ((gfxdata[2*xs] & 0x03) << 6) | ((gfxdata[2*xs+1] & 0xe0) >> 2);
-						r = ((gfxdata[2*xs+1] & 0x1f) << 3);
+						b = pal5bit(((gfxdata[2*xs] & 0x7c) >> 2));
+						g = pal5bit(((gfxdata[2*xs] & 0x03) << 3) | ((gfxdata[2*xs+1] & 0xe0) >> 5));
+						r = pal5bit(gfxdata[2*xs+1] & 0x1f);
 						if(stv2_current_tilemap.fade_control & 1)
 							stv_vdp2_compute_color_offset(machine, &r,&g,&b,stv2_current_tilemap.fade_control & 2);
-						tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-						if(tw == 0)
+
+						if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 						{
-							if(t_pen)
+							if ((gfxdata[2*xs] & 0x80) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 							{
 								if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 								{
@@ -3260,11 +3230,7 @@
 					UINT32 dot_data;
 
 					dot_data = (gfxdata[4*xs+0]<<24)|(gfxdata[4*xs+1]<<16)|(gfxdata[4*xs+2]<<8)|(gfxdata[4*xs+3]<<0);
-
-					t_pen = (dot_data & 0x80000000) >> 31;
-					if(stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE) t_pen = 1;
-
-					if(t_pen)
+					if ((dot_data & 0x80000000) || (stv2_current_tilemap.transparency == STV_TRANSPARENCY_NONE))
 					{
 						b = ((dot_data & 0x00ff0000) >> 16);
 						g = ((dot_data & 0x0000ff00) >> 8);
@@ -3272,8 +3238,8 @@
 
 						if(stv2_current_tilemap.fade_control & 1)
 							stv_vdp2_compute_color_offset(machine,&r,&g,&b,stv2_current_tilemap.fade_control & 2);
-						tw = stv_vdp2_window_process(machine,xcnt,ycnt);
-						if(tw == 0)
+
+						if (!stv_vdp2_window_process(machine,xcnt,ycnt))
 						{
 							if (((xcnt + 0) <= screen_x) && (ycnt <= screen_y))
 							{
@@ -4506,7 +4472,7 @@
 				switch( stv2_current_tilemap.transparency )
 				{
 					case STV_TRANSPARENCY_PEN:
-						if ( pix != 0x0000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -4521,7 +4487,7 @@
 						line[hcnt] = pix;
 						break;
 					case STV_TRANSPARENCY_ALPHA:
-						if ( pix != 0x000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -4530,7 +4496,7 @@
 						}
 						break;
 					case STV_TRANSPARENCY_ADD_BLEND:
-						if ( pix != 0x0000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -4617,7 +4583,7 @@
 				switch( stv2_current_tilemap.transparency )
 				{
 					case STV_TRANSPARENCY_PEN:
-						if ( pix != 0x0000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -4632,7 +4598,7 @@
 						line[hcnt] = pix;
 						break;
 					case STV_TRANSPARENCY_ALPHA:
-						if ( pix != 0x000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -4641,7 +4607,7 @@
 						}
 						break;
 					case STV_TRANSPARENCY_ADD_BLEND:
-						if ( pix != 0x0000 )
+						if (pix & 0xffffff)
 						{
 							if(stv2_current_tilemap.fade_control & 1)
 								stv_vdp2_compute_color_offset_UINT32(machine,&pix,stv2_current_tilemap.fade_control & 2);
@@ -5380,9 +5346,9 @@
 				UINT16 dot;
 
 				dot = (gfxdata[base_offs+0]<<8)|gfxdata[base_offs+1];
-				b = (dot & 0x7c00) >> 7;
-				g = (dot & 0x03e0) >> 2;
-				r = (dot & 0x001f) << 3;
+				b = pal5bit((dot & 0x7c00) >> 10);
+				g = pal5bit((dot & 0x03e0) >> 5);
+				r = pal5bit( dot & 0x001f);
 				if(STV_VDP2_BKCOEN)
 					stv_vdp2_compute_color_offset( machine, &r, &g, &b, STV_VDP2_BKCOSL );
 
@@ -5584,6 +5550,7 @@
 			palette_set_color_rgb(space->machine(),(offset*2)+1,pal5bit(r),pal5bit(g),pal5bit(b));
 			if(cmode0)
 				palette_set_color_rgb(space->machine(),((offset*2)+1)^0x400,pal5bit(r),pal5bit(g),pal5bit(b));
+
 			b = ((state->m_vdp2_cram[offset] & 0x7c000000) >> 26);
 			g = ((state->m_vdp2_cram[offset] & 0x03e00000) >> 21);
 			r = ((state->m_vdp2_cram[offset] & 0x001f0000) >> 16);
@@ -5734,9 +5701,8 @@
 
 static UINT8 get_hblank(running_machine &machine)
 {
-	static int cur_h;
 	const rectangle &visarea = machine.primary_screen->visible_area();
-	cur_h = machine.primary_screen->hpos();
+	int cur_h = machine.primary_screen->hpos();
 
 	if (cur_h > visarea.max_x) //TODO
 		return 1;
@@ -6321,10 +6287,9 @@
 						if(STV_VDP2_SPWINEN && pix == 0x8000) /* Pukunpa */
 							continue;
 
-						b = (pix & 0x7c00) >> 7;
-						g = (pix & 0x03e0) >> 2;
-						r = (pix & 0x1f) << 3;
-
+						b = pal5bit((pix & 0x7c00) >> 10);
+						g = pal5bit((pix & 0x03e0) >> 5);
+						r = pal5bit( pix & 0x001f);
 						if ( color_offset_pal )
 						{
 							stv_vdp2_compute_color_offset( machine, &r, &g, &b, STV_VDP2_SPCOSL );
@@ -6346,7 +6311,8 @@
 						{
 							if ( pix & ~sprite_shadow )
 							{
-								bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+								UINT32 p = bitmap_line[x];
+								bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 							}
 						}
 						else
@@ -6357,7 +6323,8 @@
 								/*shadow - in reality, we should check from what layer pixel beneath comes...*/
 								if ( STV_VDP2_SDCTL & 0x3f )
 								{
-									bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+									UINT32 p = bitmap_line[x];
+									bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 								}
 								/* note that when shadows are disabled, "shadow" palette entries are not drawn */
 							}
@@ -6396,9 +6363,9 @@
 							continue;
 						};
 
-						b = (pix & 0x7c00) >> 7;
-						g = (pix & 0x03e0) >> 2;
-						r = (pix & 0x1f) << 3;
+						b = pal5bit((pix & 0x7c00) >> 10);
+						g = pal5bit((pix & 0x03e0) >> 5);
+						r = pal5bit( pix & 0x001f);
 						if ( color_offset_pal )
 						{
 							stv_vdp2_compute_color_offset( machine, &r, &g, &b, STV_VDP2_SPCOSL );
@@ -6436,7 +6403,8 @@
 						{
 							if ( pix & ~sprite_shadow )
 							{
-								bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+								UINT32 p = bitmap_line[x];
+								bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 							}
 						}
 						else
@@ -6447,7 +6415,8 @@
 								/*shadow - in reality, we should check from what layer pixel beneath comes...*/
 								if ( STV_VDP2_SDCTL & 0x3f )
 								{
-									bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+									UINT32 p = bitmap_line[x];
+									bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 								}
 								/* note that when shadows are disabled, "shadow" palette entries are not drawn */
 							} else if ( pix )
@@ -6505,9 +6474,10 @@
 						stv_sprite_priorities_in_fb_line[y][sprite_priorities[0]] = 1;
 						continue;
 					};
-					b = (pix & 0x7c00) >> 7;
-					g = (pix & 0x03e0) >> 2;
-					r = (pix & 0x1f) << 3;
+
+					b = pal5bit((pix & 0x7c00) >> 10);
+					g = pal5bit((pix & 0x03e0) >> 5);
+					r = pal5bit( pix & 0x001f);
 					if ( color_offset_pal )
 					{
 						stv_vdp2_compute_color_offset( machine, &r, &g, &b, STV_VDP2_SPCOSL );
@@ -6588,7 +6558,8 @@
 					{
 						if ( pix & ~sprite_shadow )
 						{
-							bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+							UINT32 p = bitmap_line[x];
+							bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 						}
 					}
 					else
@@ -6599,7 +6570,8 @@
 							/*shadow - in reality, we should check from what layer pixel beneath comes...*/
 							if ( STV_VDP2_SDCTL & 0x3f )
 							{
-								bitmap_line[x] = (bitmap_line[x] & ~0x010101) >> 1;
+								UINT32 p = bitmap_line[x];
+								bitmap_line[x] = MAKE_RGB(RGB_RED(p) >> 1, RGB_GREEN(p) >> 1, RGB_BLUE(p) >> 1);
 							}
 							/* note that when shadows are disabled, "shadow" palette entries are not drawn */
 						} else if ( pix )
@@ -6668,7 +6640,6 @@
 SCREEN_UPDATE_RGB32( stv_vdp2 )
 {
 	saturn_state *state = screen.machine().driver_data<saturn_state>();
-	static UINT8 pri;
 
 	stv_vdp2_fade_effects(screen.machine());
 
@@ -6709,6 +6680,8 @@
 
 	if(STV_VDP2_DISP)
 	{
+		UINT8 pri;
+
 		stv_sprite_priorities_usage_valid = 0;
 		memset(stv_sprite_priorities_used, 0, sizeof(stv_sprite_priorities_used));
 		memset(stv_sprite_priorities_in_fb_line, 0, sizeof(stv_sprite_priorities_in_fb_line));
diff -Nru src-old/mame/video/taito_b.c src/mame/video/taito_b.c
--- src-old/mame/video/taito_b.c	2012-01-25 17:08:33.000000000 +0100
+++ src/mame/video/taito_b.c	2012-02-06 02:30:22.000000000 +0100
@@ -1,5 +1,4 @@
 #include "emu.h"
-#include "profiler.h"
 #include "video/hd63484.h"
 #include "video/taitoic.h"
 #include "includes/taito_b.h"
diff -Nru src-old/mame/video/vertigo.c src/mame/video/vertigo.c
--- src-old/mame/video/vertigo.c	2012-01-27 17:00:46.000000000 +0100
+++ src/mame/video/vertigo.c	2012-02-06 02:30:22.000000000 +0100
@@ -44,7 +44,6 @@
 *************************************************************************/
 
 #include "emu.h"
-#include "profiler.h"
 #include "video/vector.h"
 #include "includes/vertigo.h"
 
diff -Nru src-old/osd/sdl/README_SDL13.txt src/osd/sdl/README_SDL13.txt
--- src-old/osd/sdl/README_SDL13.txt	2010-06-03 23:27:48.000000000 +0200
+++ src/osd/sdl/README_SDL13.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-======================================================================================
-SDLMAME only supports SDL hg revisions up to 4464 
-
-Every revision after 4464 has multi-mice/multi-keyboard ripped out. 
-Revisions >= 4465 will not work with SDLMAME.
-
-To build a version suitable for SDLMAME, use ...
-
-hg clone http://hg.libsdl.org/SDL
-hg update 4464
-sh autogen.sh
-./configure --prefix=/usr/local/sdl13 --enable-maintainer-mode --disable-video-directfb --disable-fusionsound
-
-Know caveats: DirectFB is broken (will not compile)
-
-=======================================================================================
-
-
-Warning
-=======
-
-- SDL1.3 still is still under development, the following may or may not
-  work.
-- if you are using wine on unix be sure to disable wintab32.dll
-
-Known bugs:
-===========
-
-* SDL1.3/X11: Some compound keys, e.g. "'" are not supported by SDL driver
-* SDL1.3: sdlvideofps does not take -numscreens>1 into account.
-* SDL1.3/WIN32: crashes with -rd d3d
-* SDL1.3/WIN32: resizing does not work
-      
-Build SDL 1.3 from SVN
-======================
-
-Pull 1.3 from svn. Than 
-
-sh autogen.sh
-./configure --prefix=/usr/local/sdl13/ --disable-video-svga --enable-video-directfb --enable-fusionsound
-make 
-[sudo] make install
-
-You may leave away the last two enables, if you do not want to play around with directfb - although it is lightning fast now :-)
-
-To build the files in test, do
-
-cd test
-./configure --prefix=/usr/local/sdl13/ --with-sdl-pfx=/usr/local/sdl13
-make
-
-Replace /usr/local/sdl13 above with a safe location, this may as well be a directory in $HOME.
-
-Edit sdl.mak to have
-
-SDL_INSTALL_ROOT = /usr/local/sdl13
-
-That's it.
-
-make
-./mame -video sdl13 -rd opengl dkong
-
-
-All drivers
-===========
-
-should support:
-
--waitvsync
--prescale
--resolution[X]
--switchres
--numscreens
--screen[X]
-
-The following modes are working:
-
-SDL13
-=====
-
-This is driver using SDL texture and line drawing support. It supports 
--prescale, -filter and -waitvsync.  The driver determines which pixel 
-formats perform best and converts textures to these pixel formats and at 
-the same time performs any necessary rotation.  
-
-Basic usage examples:
-
-X11/opengl: ./mamed -video sdl13 -rd opengl mario 
-DFB/DFB:    ./mamed -video sdl13 -rd directfb mario 
-WIN32/opengl ./mamed -video sdl13 -rd opengl mario
-
-The performance of the directfb driver depends on the combined
-support of the kernel framebuffer driver and the directfb driver.
-Having loaded radeonfb I get the same performance as with the open source
-radeon X11 driver.
-
-Using the SDL software renderer (preferred is -video soft, thought)
-
-X11,DFB,WIN32 ./mamed -video sdl13 -rd software
-
-Soft:
-=====
-
-./mamed -mt -video soft  -ym none -numscreens 2 mario
-
-OpenGL:
-=======
-
-Plain opengl does work. Anything more advanced like pbo, fbo or glsl will 
-most probably not.
-
-	./mamed -mt -video opengl mario -ym none -nogl_pbo -numscreens 2
-
-YUV - modes:
-============
-
-	./mamed -mt -video soft -rd software -ym yuy2 -numscreens 2 mario
-
-The "-rd" overwrites the default which is built-in opengl. This renderer
-does not support yuv modes. The software driver does support them non-accelarated.
-This has been left in for the time Xv is once again implemented in SDL.
-
-Using DirectFB, the following should get you going
-
-	./mamed -mt -video soft -sm yuy2 -vd directfb -rd directfb mario
-	
-for accelerated blitting on the framebuffer - provided directfb supports it. 
-At least my Radeon R480 is supported.
-
--video soft and -scale_mode (-sm)
-=================================
-
-sdlmame supports 7 scale modes using textures in -video soft:
-
-none: All rendering/scaling in software.
-
-hwblit: Rendering in software/scaling with hardware (if supported)
-
-hwbest: Rendering in software/antialiased scaling with hardware (if supported)
-
-yv12, yv12x2, yuy2, yuy2x2: 
-Rendering in software / scaling with hardware (if supported)
-
-Whether these are actually hardware accelerated depends on the SDL driver
-and the hardware. The current SDL X11 driver needs opengl for rendering but
-does not support yuv textures. The "to-be-submitted" SDL directfb driver 
-supports all above if the hardware supports it. However, only one YUV-texture
-per display is supported. The second window consequently will get "software" 
-YUV blitting.
-
-	  
diff -Nru src-old/osd/sdl/README_SDL20.txt src/osd/sdl/README_SDL20.txt
--- src-old/osd/sdl/README_SDL20.txt	1970-01-01 01:00:00.000000000 +0100
+++ src/osd/sdl/README_SDL20.txt	2012-02-12 21:59:24.000000000 +0100
@@ -0,0 +1,132 @@
+======================================================================================
+SDLMAME now supports SDL from version 2.0 on upwards.
+=======================================================================================
+
+
+Warning
+=======
+
+- SDL2.0 still is still under development, the following may or may not
+  work.
+- if you are using wine on unix be sure to disable wintab32.dll
+
+Known bugs:
+===========
+
+* SDL1.3/X11: Some compound keys, e.g. "'" are not supported by SDL driver
+* SDL2.0: sdlvideofps does not take -numscreens>1 into account.
+* SDL1.3/WIN32: crashes with -rd d3d
+* SDL1.3/WIN32: resizing does not work
+      
+Build SDL 2.0 from HG
+======================
+
+Pull 2.0 from hg. Than 
+
+sh autogen.sh
+./configure --prefix=/usr/local/sdl13/ --disable-video-svga --enable-video-directfb --enable-fusionsound
+make 
+[sudo] make install
+
+You may leave away the last two enables, if you do not want to play around with directfb - although it is lightning fast now :-)
+
+To build the files in test, do
+
+cd test
+./configure --prefix=/usr/local/sdl13/ --with-sdl-pfx=/usr/local/sdl13
+make
+
+Replace /usr/local/sdl13 above with a safe location, this may as well be a directory in $HOME.
+
+Edit sdl.mak to have
+
+SDL_LIBVER = sdl2
+SDL_INSTALL_ROOT = /usr/local/sdl13
+
+That's it.
+
+make
+./mame -video sdl13 -rd opengl dkong
+
+
+All drivers
+===========
+
+should support:
+
+-waitvsync
+-prescale
+-resolution[X]
+-switchres
+-numscreens
+-screen[X]
+
+The following modes are working:
+
+SDL13
+=====
+
+This is driver using SDL texture and line drawing support. It supports 
+-prescale, -filter and -waitvsync.  The driver determines which pixel 
+formats perform best and converts textures to these pixel formats and at 
+the same time performs any necessary rotation.  
+
+Basic usage examples:
+
+X11/opengl: ./mamed -video sdl13 -rd opengl mario 
+DFB/DFB:    ./mamed -video sdl13 -vd directfb -rd directfb mario 
+
+The performance of the directfb driver depends on the combined
+support of the kernel framebuffer driver and the directfb driver.
+Having loaded radeonfb I get the same performance as with the open source
+radeon X11 driver.
+
+Using the SDL software renderer (preferred is -video soft, thought)
+
+X11,DFB,WIN32 ./mamed -video sdl13 -rd software
+
+Soft:
+=====
+
+./mamed -mt -video soft  -sm none -numscreens 2 mario
+
+OpenGL:
+=======
+
+Plain opengl does work. Anything more advanced like pbo, fbo or glsl will 
+most probably not work with more than one screen.
+
+	./mamed -mt -video opengl mario -nogl_pbo -nogl_vbo -nogl_glsl -numscreens 2
+
+YUV - modes:
+============
+
+	./mamed -mt -video soft -sm yuy2 mario
+
+Using DirectFB, the following should get you going
+
+	./mamed -mt -video soft -sm yuy2 -vd directfb -rd directfb mario
+	
+for accelerated blitting on the framebuffer - provided directfb supports it. 
+At least my Radeon R480 is supported.
+
+-video soft and -scale_mode (-sm)
+=================================
+
+sdlmame supports 7 scale modes using textures in -video soft:
+
+none: All rendering/scaling in software.
+
+hwblit: Rendering in software/scaling with hardware (if supported)
+
+hwbest: Rendering in software/antialiased scaling with hardware (if supported)
+
+yv12, yv12x2, yuy2, yuy2x2: 
+Rendering in software / scaling with hardware (if supported)
+
+Whether these are actually hardware accelerated depends on the SDL driver
+and the hardware. The SDL directfb driver supports all above if the hardware 
+supports it. However, only one YUV-texture per display is supported. 
+The second window consequently will get "software" YUV blitting.
+
+	  
diff -Nru src-old/osd/sdl/debugwin.c src/osd/sdl/debugwin.c
--- src-old/osd/sdl/debugwin.c	2011-06-05 23:35:20.000000000 +0200
+++ src/osd/sdl/debugwin.c	2012-02-12 21:59:24.000000000 +0100
@@ -1276,8 +1276,7 @@
 
 #else
 
-#include <SDL/SDL.h>
-#include <SDL/SDL_version.h>
+#include "sdlinc.h"
 
 #include "emu.h"
 #include "osdepend.h"
diff -Nru src-old/osd/sdl/draw13.c src/osd/sdl/draw13.c
--- src-old/osd/sdl/draw13.c	2012-01-12 22:19:49.000000000 +0100
+++ src/osd/sdl/draw13.c	2012-02-12 21:59:24.000000000 +0100
@@ -18,7 +18,7 @@
 #include "options.h"
 
 // standard SDL headers
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 // OSD headers
 #include "osdsdl.h"
@@ -379,11 +379,11 @@
 #if 0
 		if ((PRIMFLAG_GET_SCREENTEX(prim->flags)) && video_config.filter)
 		{
-			SDL_SetTextureScaleMode(texture->texture_id,  SDL_SCALEMODE_BEST);
+			SDL_SetTextureScaleMode(texture->texture_id,  DRAW2_SCALEMODE_BEST);
 		}
 		else
 		{
-			SDL_SetTextureScaleMode(texture->texture_id,  SDL_SCALEMODE_NONE);
+			SDL_SetTextureScaleMode(texture->texture_id,  DRAW2_SCALEMODE_NEAREST);
 		}
 #endif
 		SDL_SetTextureBlendMode(texture_id, texture->sdl_blendmode);
@@ -497,7 +497,7 @@
 	callbacks->exit = draw13_exit;
 	callbacks->attach = draw13_attach;
 
-	mame_printf_verbose("Using SDL native texturing driver (SDL 1.3+)\n");
+	mame_printf_verbose("Using SDL native texturing driver (SDL 2.0+)\n");
 
 	expand_copy_info(blit_info_default);
 	//FIXME: -opengl16 should be -opengl -prefer16bpp
@@ -577,6 +577,9 @@
 			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_FULLSCREEN : SDL_WINDOW_RESIZABLE);
 
 	// create the SDL window
+	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED_DISPLAY(window->monitor->handle), SDL_WINDOWPOS_UNDEFINED,
+			width, height, sdl->extra_flags);
+
 	if (window->fullscreen && video_config.switchres)
 	{
 		SDL_DisplayMode mode;
@@ -610,15 +613,12 @@
 	else
 		SDL_SetWindowDisplayMode(window->sdl_window, NULL);	// Use desktop
 
-	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED_DISPLAY(window->monitor->handle), SDL_WINDOWPOS_UNDEFINED,
-			width, height, sdl->extra_flags);
-
 	// create renderer
 
 	if (video_config.waitvsync)
-		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD | */SDL_RENDERER_PRESENTVSYNC);
+		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_ACCELERATED);
 	else
-		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD*/ 0);
+		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, SDL_RENDERER_ACCELERATED);
 
 	if (!sdl->sdl_renderer)
 	{
@@ -721,6 +721,7 @@
 		SDL_SetWindowSize(window->sdl_window, sdl->resize_width, sdl->resize_height);
 		SDL_GetWindowSize(window->sdl_window, &window->width, &window->height);
 		sdl->resize_pending = 0;
+		SDL_RenderSetViewport(sdl->sdl_renderer, NULL);
 	}
 
     //SDL_SelectRenderer(window->sdl_window);
diff -Nru src-old/osd/sdl/drawogl.c src/osd/sdl/drawogl.c
--- src-old/osd/sdl/drawogl.c	2012-01-24 21:18:55.000000000 +0100
+++ src/osd/sdl/drawogl.c	2012-02-12 21:59:24.000000000 +0100
@@ -24,7 +24,7 @@
 #include "emuopts.h"
 
 // standard SDL headers
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 // OpenGL headers
 #include "osd_opengl.h"
@@ -219,7 +219,7 @@
 	INT32			blittimer;
 	UINT32			extra_flags;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	SDL_GLContext	gl_context_id;
 #else
 	// SDL surface
@@ -437,15 +437,14 @@
 
 	dll_loaded = 0;
 
-	if (SDL_VERSION_ATLEAST(1,3,0))
-		mame_printf_verbose("Using SDL multi-window OpenGL driver (SDL 1.3+)\n");
+	if (SDLMAME_SDL2)
+	{
+		mame_printf_verbose("Using SDL multi-window OpenGL driver (SDL 2.0+)\n");
+		load_gl_lib(machine);
+	}
 	else
 		mame_printf_verbose("Using SDL single-window OpenGL driver (SDL 1.2)\n");
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
-	load_gl_lib(machine);
-#endif
-
 	return 0;
 }
 
@@ -546,7 +545,7 @@
 
 	window->dxdata = sdl;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	sdl->extra_flags = (window->fullscreen ?
 			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_FULLSCREEN : SDL_WINDOW_RESIZABLE);
 	sdl->extra_flags |= SDL_WINDOW_OPENGL;
@@ -556,6 +555,14 @@
 	//load_gl_lib(window->machine());
 
 	// create the SDL window
+	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED_DISPLAY(window->monitor->handle), SDL_WINDOWPOS_UNDEFINED,
+			width, height, sdl->extra_flags);
+
+	if  (!window->sdl_window )
+	{
+		mame_printf_error("OpenGL not supported on this driver: %s\n", SDL_GetError());
+		return 1;
+	}
 
 	if (window->fullscreen && video_config.switchres)
 	{
@@ -570,15 +577,6 @@
 	else
 		SDL_SetWindowDisplayMode(window->sdl_window, NULL);	// Use desktop
 
-	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED_DISPLAY(window->monitor->handle), SDL_WINDOWPOS_UNDEFINED,
-			width, height, sdl->extra_flags);
-
-	if  (!window->sdl_window )
-	{
-		mame_printf_error("OpenGL not supported on this driver: %s\n", SDL_GetError());
-		return 1;
-	}
-
 	SDL_ShowWindow(window->sdl_window);
 	//SDL_SetWindowFullscreen(window->sdl_window, window->fullscreen);
 	SDL_RaiseWindow(window->sdl_window);
@@ -798,7 +796,7 @@
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	//SDL_GL_MakeCurrent(window->sdl_window, sdl->gl_context_id);
 	SDL_SetWindowSize(window->sdl_window, width, height);
 	SDL_GetWindowSize(window->sdl_window, &window->width, &window->height);
@@ -1190,7 +1188,7 @@
 		return 0;
 	}
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	SDL_GL_MakeCurrent(window->sdl_window, sdl->gl_context_id);
 #endif
 	if (sdl->init_context)
@@ -1546,7 +1544,7 @@
 	window->primlist->release_lock();
 	sdl->init_context = 0;
 
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 	SDL_GL_SwapBuffers();
 #else
 	SDL_GL_SwapWindow(window->sdl_window);
@@ -1721,7 +1719,7 @@
 
 	drawogl_destroy_all_textures(window);
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	SDL_GL_DeleteContext(sdl->gl_context_id);
 	SDL_DestroyWindow(window->sdl_window);
 #else
@@ -3135,7 +3133,7 @@
 	if ( !sdl->initialized )
 		return;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	SDL_GL_MakeCurrent(window->sdl_window, sdl->gl_context_id);
 #endif
 
diff -Nru src-old/osd/sdl/drawsdl.c src/osd/sdl/drawsdl.c
--- src-old/osd/sdl/drawsdl.c	2011-06-05 23:35:20.000000000 +0200
+++ src/osd/sdl/drawsdl.c	2012-02-12 21:59:24.000000000 +0100
@@ -18,7 +18,7 @@
 #include "ui.h"
 
 // standard SDL headers
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 // OSD headers
 #include "osdsdl.h"
@@ -38,11 +38,10 @@
 
 typedef struct _sdl_scale_mode sdl_scale_mode;
 
-// FIXME: Only until there is a final decision from SAM on scalemodes
-#if (SDL_VERSION_ATLEAST(1,3,0))
-#define	SDL_SCALEMODE_NONE	(0)
-#define	SDL_SCALEMODE_FAST	(0)
-#define	SDL_SCALEMODE_BEST	(0)
+#if (SDLMAME_SDL2)
+#define	DRAW2_SCALEMODE_NEAREST	"0"
+#define	DRAW2_SCALEMODE_LINEAR	"1"
+#define	DRAW2_SCALEMODE_BEST	"2"
 #endif
 
 /* sdl_info is the information about SDL for the current screen */
@@ -52,7 +51,8 @@
 	INT32				blittimer;
 	UINT32				extra_flags;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
+	SDL_Renderer		*sdl_renderer;
 	SDL_Texture			*texture_id;
 #else
 	// SDL surface
@@ -73,10 +73,6 @@
 	int					last_vofs;
 	int					old_blitwidth;
 	int					old_blitheight;
-
-	// shortcut to scale mode info
-
-	const sdl_scale_mode		*scale_mode;
 };
 
 struct _sdl_scale_mode
@@ -86,11 +82,10 @@
 	int				is_yuv;				/* Yuv mode?             */
 	int				mult_w;				/* Width multiplier      */
 	int				mult_h;				/* Height multiplier     */
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 	int				extra_flags;		/* Texture/surface flags */
 #else
-	//SDL_ScaleMode sdl_scale_mode;     /* sdl 1.3 scale mode    */
-	int				sdl_scale_mode;		/* got removed recently - trying to get it in again */
+	const char		*sdl_scale_mode;		/* what to use as a hint ? */
 #endif
 	int				pixel_format;		/* Pixel/Overlay format  */
 	void    		(*yuv_blit)(UINT16 *bitmap, sdl_info *sdl, UINT8 *ptr, int pitch);
@@ -116,7 +111,7 @@
 static void drawsdl_window_clear(sdl_window_info *window);
 static int drawsdl_xy_to_render_target(sdl_window_info *window, int x, int y, int *xt, int *yt);
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 static void setup_texture(sdl_window_info *window, int tempwidth, int tempheight);
 #endif
 
@@ -137,7 +132,7 @@
 
 // Static declarations
 
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 static int shown_video_info = 0;
 
 static const sdl_scale_mode scale_modes[] =
@@ -153,13 +148,13 @@
 #else
 static const sdl_scale_mode scale_modes[] =
 {
-		{ "none",    0, 0, 0, 0, SDL_SCALEMODE_NONE, 0, 0 },
-		{ "hwblit",  1, 0, 1, 1, SDL_SCALEMODE_FAST, 0, 0 },
-		{ "hwbest",  1, 0, 1, 1, SDL_SCALEMODE_BEST, 0, 0 },
-		{ "yv12",    1, 1, 1, 1, SDL_SCALEMODE_NONE, SDL_PIXELFORMAT_YV12, yuv_RGB_to_YV12 },
-		{ "yv12x2",  1, 1, 2, 2, SDL_SCALEMODE_NONE, SDL_PIXELFORMAT_YV12, yuv_RGB_to_YV12X2 },
-		{ "yuy2",    1, 1, 1, 1, SDL_SCALEMODE_NONE, SDL_PIXELFORMAT_YUY2, yuv_RGB_to_YUY2 },
-		{ "yuy2x2",  1, 1, 2, 1, SDL_SCALEMODE_NONE, SDL_PIXELFORMAT_YUY2, yuv_RGB_to_YUY2X2 },
+		{ "none",    0, 0, 0, 0, DRAW2_SCALEMODE_NEAREST, 0, 0 },
+		{ "hwblit",  1, 0, 1, 1, DRAW2_SCALEMODE_LINEAR, 0, 0 },
+		{ "hwbest",  1, 0, 1, 1, DRAW2_SCALEMODE_BEST, 0, 0 },
+		{ "yv12",    1, 1, 1, 1, DRAW2_SCALEMODE_NEAREST, SDL_PIXELFORMAT_YV12, yuv_RGB_to_YV12 },
+		{ "yv12x2",  1, 1, 2, 2, DRAW2_SCALEMODE_NEAREST, SDL_PIXELFORMAT_YV12, yuv_RGB_to_YV12X2 },
+		{ "yuy2",    1, 1, 1, 1, DRAW2_SCALEMODE_NEAREST, SDL_PIXELFORMAT_YUY2, yuv_RGB_to_YUY2 },
+		{ "yuy2x2",  1, 1, 2, 1, DRAW2_SCALEMODE_NEAREST, SDL_PIXELFORMAT_YUY2, yuv_RGB_to_YUY2X2 },
 		{ NULL }
 };
 #endif
@@ -208,8 +203,8 @@
 	callbacks->exit = drawsdl_exit;
 	callbacks->attach = drawsdl_attach;
 
-	if (SDL_VERSION_ATLEAST(1,3,0))
-		mame_printf_verbose("Using SDL multi-window soft driver (SDL 1.3+)\n");
+	if (SDLMAME_SDL2)
+		mame_printf_verbose("Using SDL multi-window soft driver (SDL 2.0+)\n");
 	else
 		mame_printf_verbose("Using SDL single-window soft driver (SDL 1.2)\n");
 
@@ -254,11 +249,11 @@
 //  setup_texture for window
 //============================================================
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 static void setup_texture(sdl_window_info *window, int tempwidth, int tempheight)
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
-	const sdl_scale_mode *sdl_sm = sdl->scale_mode;
+	const sdl_scale_mode *sdl_sm = &scale_modes[video_config.scale_mode];
 	SDL_DisplayMode mode;
 	UINT32 fmt;
 
@@ -278,6 +273,9 @@
 		{
 			sdl->hw_scale_width *= video_config.prescale;
 			sdl->hw_scale_height *= video_config.prescale;
+
+			/* This must be a multiple of 2 */
+			sdl->hw_scale_width = (sdl->hw_scale_width + 1) & ~1;
 		}
 	}
 
@@ -291,17 +289,14 @@
 		int w = sdl->hw_scale_width * sdl_sm->mult_w;
 		int h = sdl->hw_scale_height * sdl_sm->mult_h;
 
-		sdl->texture_id = SDL_CreateTexture(window->sdl_renderer, fmt, SDL_TEXTUREACCESS_STREAMING, w, h);
+		sdl->texture_id = SDL_CreateTexture(sdl->sdl_renderer, fmt, SDL_TEXTUREACCESS_STREAMING, w, h);
 
 	}
 	else
 	{
-		sdl->texture_id = SDL_CreateTexture(window->sdl_renderer,fmt, SDL_TEXTUREACCESS_STREAMING,
+		sdl->texture_id = SDL_CreateTexture(sdl->sdl_renderer,fmt, SDL_TEXTUREACCESS_STREAMING,
 				tempwidth, tempheight);
 	}
-
-	//SDL_SetTextureScaleMode(window->sdl_renderer,sdl->texture_id, sdl_sm->sdl_scale_mode);
-
 }
 #endif
 
@@ -309,11 +304,11 @@
 //  yuv_overlay_init
 //============================================================
 
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 static void yuv_overlay_init(sdl_window_info *window)
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
-	const sdl_scale_mode *sdl_sm = sdl->scale_mode;
+	const sdl_scale_mode *sdl_sm = &scale_modes[video_config.scale_mode];
 	int minimum_width, minimum_height;
 
 	window->target->compute_minimum_size(minimum_width, minimum_height);
@@ -364,7 +359,7 @@
 //  drawsdl_show_info
 //============================================================
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 static void	drawsdl_show_info(sdl_window_info *window, struct SDL_RendererInfo *render_info)
 {
 #define RF_ENTRY(x) {x, #x }
@@ -400,6 +395,7 @@
 static int drawsdl_window_create(sdl_window_info *window, int width, int height)
 {
 	sdl_info *sdl;
+    const sdl_scale_mode *sm = &scale_modes[video_config.scale_mode];
 
 	// allocate memory for our structures
 	sdl = (sdl_info *) osd_malloc(sizeof(sdl_info));
@@ -407,13 +403,19 @@
 
 	window->dxdata = sdl;
 
-	sdl->scale_mode = &scale_modes[window->scale_mode];
+#if (SDLMAME_SDL2)
+
+	/* set hints ... */
+
+	SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, sm->sdl_scale_mode);
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
 	sdl->extra_flags = (window->fullscreen ?
 			SDL_WINDOW_BORDERLESS | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_MOUSE_FOCUS
 			| SDL_WINDOW_INPUT_GRABBED : SDL_WINDOW_RESIZABLE);
 
+	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
+			width, height, sdl->extra_flags);
+
 	if (window->fullscreen && video_config.switchres)
 	{
 		SDL_DisplayMode mode;
@@ -427,8 +429,6 @@
 	else
 		SDL_SetWindowDisplayMode(window->sdl_window, NULL);	// Use desktop
 
-	window->sdl_window = SDL_CreateWindow(window->title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
-			width, height, sdl->extra_flags);
 	SDL_ShowWindow(window->sdl_window);
 
 	SDL_SetWindowFullscreen(window->sdl_window, (SDL_bool) window->fullscreen);
@@ -442,34 +442,33 @@
 	// create a texture
 
 	if (video_config.waitvsync)
-		window->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD |*/ SDL_RENDERER_PRESENTVSYNC);
+		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD |*/ SDL_RENDERER_PRESENTVSYNC);
 	else
-		window->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD*/ 0);
+		sdl->sdl_renderer = SDL_CreateRenderer(window->sdl_window, -1, /*SDL_RENDERER_PRESENTFLIP2 | SDL_RENDERER_PRESENTDISCARD*/ 0);
 
     //SDL_SelectRenderer(window->sdl_window);
 
     {
         struct SDL_RendererInfo render_info;
-    	SDL_GetRendererInfo(window->sdl_renderer, &render_info);
 
+        SDL_GetRendererInfo(sdl->sdl_renderer, &render_info);
     	drawsdl_show_info(window, &render_info);
 
     	// Check scale mode
 
-    	if (sdl->scale_mode->pixel_format)
+    	if (sm->pixel_format)
     	{
     		int i;
     		int found = 0;
 
     		for (i=0; i < render_info.num_texture_formats; i++)
-    			if (sdl->scale_mode->pixel_format == render_info.texture_formats[i])
+    			if (sm->pixel_format == render_info.texture_formats[i])
     				found = 1;
 
     		if (!found)
     		{
-    			mame_printf_verbose("window: Scale mode %s not supported! Using default.\n", sdl->scale_mode->name);
-    			ui_popup_time(3, "Scale mode %s not supported! Using default.", sdl->scale_mode->name);
-    			sdl->scale_mode = &scale_modes[0];
+    			mame_printf_verbose("window: Scale mode %s not supported!\n", sm->name);
+    			ui_popup_time(3, "Scale mode %s not supported!", sm->name);
     		}
     	}
     }
@@ -478,7 +477,7 @@
 #else
 	sdl->extra_flags = (window->fullscreen ?  SDL_FULLSCREEN : SDL_RESIZABLE);
 
-	sdl->extra_flags |= sdl->scale_mode->extra_flags;
+	sdl->extra_flags |= sm->extra_flags;
 
 	sdl->sdlsurf = SDL_SetVideoMode(width, height,
 				   0, SDL_SWSURFACE | SDL_ANYFORMAT | sdl->extra_flags);
@@ -489,7 +488,7 @@
 	window->width = sdl->sdlsurf->w;
 	window->height = sdl->sdlsurf->h;
 
-	if (sdl->scale_mode->is_yuv)
+	if (sm->is_yuv)
 		yuv_overlay_init(window);
 
 	// set the window title
@@ -508,8 +507,10 @@
 
 static void drawsdl_window_resize(sdl_window_info *window, int width, int height)
 {
-
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
+	const sdl_scale_mode *sdl_sm = &scale_modes[video_config.scale_mode];
+#endif
+#if (SDLMAME_SDL2)
 	SDL_SetWindowSize(window->sdl_window, width, height);
 	SDL_GetWindowSize(window->sdl_window, &window->width, &window->height);
 
@@ -529,7 +530,7 @@
 	window->width = sdl->sdlsurf->w;
 	window->height = sdl->sdlsurf->h;
 
-	if (sdl->scale_mode->is_yuv)
+	if (sdl_sm->is_yuv)
 	{
 		yuv_overlay_init(window);
 	}
@@ -550,7 +551,7 @@
 	if (sdl == NULL)
 		return;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	//SDL_SelectRenderer(window->sdl_window);
 	SDL_DestroyTexture(sdl->texture_id);
 	//SDL_DestroyRenderer(window->sdl_window);
@@ -602,6 +603,7 @@
 static int drawsdl_xy_to_render_target(sdl_window_info *window, int x, int y, int *xt, int *yt)
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
+	const sdl_scale_mode *sm = &scale_modes[video_config.scale_mode];
 
 	*xt = x - sdl->last_hofs;
 	*yt = y - sdl->last_vofs;
@@ -609,7 +611,7 @@
 		return 0;
 	if (*yt<0 || *xt >= window->blitheight)
 		return 0;
-	if (!sdl->scale_mode->is_scale)
+	if (!sm->is_scale)
 	{
 		return 1;
 	}
@@ -626,6 +628,7 @@
 static render_primitive_list &drawsdl_window_get_primitives(sdl_window_info *window)
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
+	const sdl_scale_mode *sm = &scale_modes[video_config.scale_mode];
 
 	if ((!window->fullscreen) || (video_config.switchres))
 	{
@@ -636,7 +639,7 @@
 		sdlwindow_blit_surface_size(window, window->monitor->center_width, window->monitor->center_height);
 	}
 
-	if (!sdl->scale_mode->is_scale)
+	if (!sm->is_scale)
 		window->target->set_bounds(window->blitwidth, window->blitheight, sdlvideo_monitor_get_aspect(window->monitor));
 	else
 		window->target->set_bounds(sdl->hw_scale_width, sdl->hw_scale_height);
@@ -651,11 +654,12 @@
 static int drawsdl_window_draw(sdl_window_info *window, UINT32 dc, int update)
 {
 	sdl_info *sdl = (sdl_info *) window->dxdata;
+	const sdl_scale_mode *sm = &scale_modes[video_config.scale_mode];
 	UINT8 *surfptr;
 	INT32 pitch;
 	int bpp;
 	Uint32 rmask, gmask, bmask;
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	Uint32 amask;
 #endif
 	INT32 vofs, hofs, blitwidth, blitheight, ch, cw;
@@ -670,7 +674,7 @@
 		return 1;
 
 	// lock it if we need it
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 
 	pitch = sdl->sdlsurf->pitch;
 	bpp = sdl->sdlsurf->format->BytesPerPixel;
@@ -681,7 +685,7 @@
 
 	if (window->blitwidth != sdl->old_blitwidth || window->blitheight != sdl->old_blitheight)
 	{
-		if (sdl->scale_mode->is_yuv)
+		if (sm->is_yuv)
 			yuv_overlay_init(window);
 		sdl->old_blitwidth = window->blitwidth;
 		sdl->old_blitheight = window->blitheight;
@@ -698,7 +702,7 @@
 	}
 
 
-	if (sdl->scale_mode->is_yuv)
+	if (sm->is_yuv)
 	{
 		SDL_LockYUVOverlay(sdl->yuvsurf);
 		surfptr = sdl->yuvsurf->pixels[0]; // (UINT8 *) sdl->yuv_bitmap;
@@ -711,6 +715,8 @@
 
 	if (window->blitwidth != sdl->old_blitwidth || window->blitheight != sdl->old_blitheight)
 	{
+		SDL_RenderSetViewport(sdl->sdl_renderer, NULL);
+
 		SDL_DestroyTexture(sdl->texture_id);
 		setup_texture(window, window->blitwidth, window->blitheight);
 		sdl->old_blitwidth = window->blitwidth;
@@ -731,8 +737,8 @@
 	if (sdl->blittimer > 0)
 	{
 		/* SDL Underlays need alpha = 0 ! */
-		SDL_SetRenderDrawColor(window->sdl_renderer,0,0,0,0);
-		SDL_RenderFillRect(window->sdl_renderer,NULL);
+		SDL_SetRenderDrawColor(sdl->sdl_renderer,0,0,0,0);
+		SDL_RenderFillRect(sdl->sdl_renderer,NULL);
 		//SDL_RenderFill(0,0,0,0 /*255*/,NULL);
 		sdl->blittimer--;
 	}
@@ -784,15 +790,15 @@
 	window->primlist->acquire_lock();
 
 	// render to it
-	if (!sdl->scale_mode->is_yuv)
+	if (!sm->is_yuv)
 	{
 		int mamewidth, mameheight;
 
-		if (!sdl->scale_mode->is_scale)
+		if (!sm->is_scale)
 		{
 			mamewidth = blitwidth;
 			mameheight = blitheight;
-#if !SDL_VERSION_ATLEAST(1,3,0)
+#if !SDLMAME_SDL2
 			surfptr += ((vofs * pitch) + (hofs * bpp));
 #endif
 		}
@@ -833,15 +839,15 @@
 		assert (sdl->yuv_bitmap != NULL);
 		assert (surfptr != NULL);
 		drawsdl_rgb555_draw_primitives(*window->primlist, sdl->yuv_bitmap, sdl->hw_scale_width, sdl->hw_scale_height, sdl->hw_scale_width);
-		sdl->scale_mode->yuv_blit((UINT16 *)sdl->yuv_bitmap, sdl, surfptr, pitch);
+		sm->yuv_blit((UINT16 *)sdl->yuv_bitmap, sdl, surfptr, pitch);
 	}
 
 	window->primlist->release_lock();
 
 	// unlock and flip
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 	if (SDL_MUSTLOCK(sdl->sdlsurf)) SDL_UnlockSurface(sdl->sdlsurf);
-	if (!sdl->scale_mode->is_yuv)
+	if (!sm->is_yuv)
 	{
 		SDL_Flip(sdl->sdlsurf);
 	}
@@ -867,8 +873,8 @@
 		r.h=blitheight;
 		//printf("blitwidth %d %d - %d %d\n", blitwidth, blitheight, window->width, window->height);
 		//SDL_UpdateTexture(sdl->sdltex, NULL, sdl->sdlsurf->pixels, pitch);
-		SDL_RenderCopy(window->sdl_renderer,sdl->texture_id, NULL, &r);
-		SDL_RenderPresent(window->sdl_renderer);
+		SDL_RenderCopy(sdl->sdl_renderer,sdl->texture_id, NULL, &r);
+		SDL_RenderPresent(sdl->sdl_renderer);
 	}
 #endif
 	return 0;
diff -Nru src-old/osd/sdl/gl_shader_mgr.c src/osd/sdl/gl_shader_mgr.c
--- src-old/osd/sdl/gl_shader_mgr.c	2010-02-28 13:16:38.000000000 +0100
+++ src/osd/sdl/gl_shader_mgr.c	2012-02-12 21:59:24.000000000 +0100
@@ -1,5 +1,5 @@
 
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 #include "osd_opengl.h"
 
diff -Nru src-old/osd/sdl/input.c src/osd/sdl/input.c
--- src-old/osd/sdl/input.c	2011-05-30 21:58:55.000000000 +0200
+++ src/osd/sdl/input.c	2012-02-16 02:38:13.000000000 +0100
@@ -13,7 +13,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 #include <ctype.h>
 #include <stddef.h>
 
@@ -95,6 +95,7 @@
 	INT32 axes[MAX_AXES];
 	INT32 buttons[MAX_BUTTONS];
 	INT32 hatsU[MAX_HATS], hatsD[MAX_HATS], hatsL[MAX_HATS], hatsR[MAX_HATS];
+	INT32 balls[MAX_AXES];
 };
 
 // generic device information
@@ -206,7 +207,7 @@
 	char		*	ui_name;
 };
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 
 #define OSD_SDL_INDEX(x) (x)
 #define OSD_SDL_INDEX_KEYSYM(keysym) ((keysym)->scancode)
@@ -470,7 +471,7 @@
 	const char *name;
 };
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 #define KE(x) { SDL_SCANCODE_ ## x, "SDL_SCANCODE_" #x },
 #define KE8(A, B, C, D, E, F, G, H) KE(A) KE(B) KE(C) KE(D) KE(E) KE(F) KE(G) KE(H)
 #define KE7(A, B, C, D, E, F, G) KE(A) KE(B) KE(C) KE(D) KE(E) KE(F) KE(G)
@@ -495,8 +496,7 @@
 	KE8(F6,			F7,			F8,				F9,			F10,		F11,		F12,		F13			)
 	KE8(F14,		F15,		NUMLOCKCLEAR,	CAPSLOCK,	SCROLLLOCK,	RSHIFT,		LSHIFT,		RCTRL		)
 	KE5(LCTRL,		RALT,		LALT,			LGUI,		RGUI)
-	KE(PRINTSCREEN)
-	KE(MENU)
+	KE8(GRAVE,		LEFTBRACKET,RIGHTBRACKET,	SEMICOLON,	APOSTROPHE,	BACKSLASH,	PRINTSCREEN,MENU		)
 	KE(UNDO)
 	{-1, ""}
 };
@@ -541,7 +541,6 @@
 };
 #endif
 
-
 //============================================================
 //  INLINE FUNCTIONS
 //============================================================
@@ -681,7 +680,7 @@
 static void sdlinput_register_joysticks(running_machine &machine)
 {
 	device_info *devinfo;
-	int physical_stick, axis, button, hat, stick;
+	int physical_stick, axis, button, hat, stick, ball;
 	char tempname[512];
 	SDL_Joystick *joy;
 
@@ -709,7 +708,7 @@
 		devinfo->joystick.device = joy;
 
 		mame_printf_verbose("Joystick: %s\n", devinfo->name);
-		mame_printf_verbose("Joystick:   ...  %d axes, %d buttons %d hats\n", SDL_JoystickNumAxes(joy), SDL_JoystickNumButtons(joy), SDL_JoystickNumHats(joy));
+		mame_printf_verbose("Joystick:   ...  %d axes, %d buttons %d hats %d balls\n", SDL_JoystickNumAxes(joy), SDL_JoystickNumButtons(joy), SDL_JoystickNumHats(joy), SDL_JoystickNumBalls(joy));
 		mame_printf_verbose("Joystick:   ...  Physical id %d mapped to logical id %d\n", physical_stick, stick);
 
 		// loop over all axes
@@ -764,6 +763,22 @@
 			itemid = (input_item_id) ((hat < INPUT_MAX_HATS) ? ITEM_ID_HAT1RIGHT + 4 * hat : ITEM_ID_OTHER_SWITCH);
 	    	devinfo->device->add_item(tempname, itemid, generic_button_get_state, &devinfo->joystick.hatsR[hat]);
 		}
+
+		// loop over all (track)balls
+		for (ball = 0; ball < SDL_JoystickNumBalls(joy); ball++)
+		{
+			int itemid;
+
+			if (ball * 2 < INPUT_MAX_ADD_RELATIVE)
+				itemid = ITEM_ID_ADD_RELATIVE1 + ball * 2;
+			else
+				itemid = ITEM_ID_OTHER_AXIS_RELATIVE;
+
+			sprintf(tempname, "R%d %s", ball * 2, devinfo->name);
+			devinfo->device->add_item(tempname, (input_item_id) itemid, generic_axis_get_state, &devinfo->joystick.balls[ball * 2]);
+			sprintf(tempname, "R%d %s", ball * 2 + 1, devinfo->name);
+			devinfo->device->add_item(tempname, (input_item_id) (itemid + 1), generic_axis_get_state, &devinfo->joystick.balls[ball * 2 + 1]);
+		}
 	}
 	mame_printf_verbose("Joystick: End initialization\n");
 }
@@ -790,7 +805,7 @@
 //  sdlinput_register_mice
 //============================================================
 
-#if (!SDL13_POST_HG4464 && SDL_VERSION_ATLEAST(1,3,0))
+#if defined(SDL2_MULTIAPI) && 0
 static void sdlinput_register_mice(running_machine &machine)
 {
 	int index, physical_mouse;
@@ -938,9 +953,10 @@
 	int line = 1;
 	int index,i, sk, vk, ak;
 	char buf[256];
-	char mks[21];
-	char sks[21];
-	char kns[21];
+	char mks[41];
+	char sks[41];
+	char kns[41];
+	int  sdl2section=0;
 
 	if (!machine.options().bool_value(SDLOPTION_KEYMAP))
 		return sdl_key_trans_table;
@@ -960,34 +976,41 @@
 
 	while (!feof(keymap_file))
 	{
-		fgets(buf, 255, keymap_file);
-		if (*buf && buf[0] && buf[0] != '#')
+		char *ret = fgets(buf, 255, keymap_file);
+		if (ret && buf[0] != '\n' && buf[0] != '#')
 		{
 			buf[255]=0;
 			i=strlen(buf);
 			if (i && buf[i-1] == '\n')
 				buf[i-1] = 0;
-			mks[0]=0;
-			sks[0]=0;
-			memset(kns, 0, ARRAY_LENGTH(kns));
-			sscanf(buf, "%20s %20s %x %x %20c\n",
-					mks, sks, &vk, &ak, kns);
+			if (strncmp(buf,"[SDL2]",6) == 0)
+			{
+				sdl2section = 1;
+			}
+			else if (((SDLMAME_SDL2) ^ sdl2section) == 0)
+			{
+				mks[0]=0;
+				sks[0]=0;
+				memset(kns, 0, ARRAY_LENGTH(kns));
+				sscanf(buf, "%40s %40s %x %x %40c\n",
+						mks, sks, &vk, &ak, kns);
 
-			index=lookup_mame_index(mks);
-			sk = lookup_sdl_code(sks);
+				index=lookup_mame_index(mks);
+				sk = lookup_sdl_code(sks);
 
-			if ( sk >= 0 && index >=0)
-			{
-				key_trans_table[index].sdl_key = sk;
-				// vk and ak are not really needed
-				//key_trans_table[index][VIRTUAL_KEY] = vk;
-				//key_trans_table[index][ASCII_KEY] = ak;
-				key_trans_table[index].ui_name = auto_alloc_array(machine, char, strlen(kns)+1);
-				strcpy(key_trans_table[index].ui_name, kns);
-				mame_printf_verbose("Keymap: Mapped <%s> to <%s> with ui-text <%s>\n", sks, mks, kns);
+				if ( sk >= 0 && index >=0)
+				{
+					key_trans_table[index].sdl_key = sk;
+					// vk and ak are not really needed
+					//key_trans_table[index][VIRTUAL_KEY] = vk;
+					//key_trans_table[index][ASCII_KEY] = ak;
+					key_trans_table[index].ui_name = auto_alloc_array(machine, char, strlen(kns)+1);
+					strcpy(key_trans_table[index].ui_name, kns);
+					mame_printf_verbose("Keymap: Mapped <%s> to <%s> with ui-text <%s>\n", sks, mks, kns);
+				}
+				else
+					mame_printf_warning("Keymap: Error on line %d - %s key not found: %s\n", line, (sk<0) ? "sdl" : "mame", buf);
 			}
-			else
-				mame_printf_warning("Keymap: Error on line %d - %s key not found: %s\n", line, (sk<0) ? "sdl" : "mame", buf);
 		}
 		line++;
 	}
@@ -1002,7 +1025,7 @@
 //  sdlinput_register_keyboards
 //============================================================
 
-#if ((1 ||!SDL13_POST_HG4464) && SDL_VERSION_ATLEAST(1,3,0))
+#ifdef SDL2_MULTIAPI
 static void sdlinput_register_keyboards(running_machine &machine)
 {
 	int physical_keyboard;
@@ -1193,7 +1216,7 @@
 //  sdlinput_poll
 //============================================================
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 INLINE sdl_window_info * window_from_id(Uint32 windowID)
 {
 	sdl_window_info *w;
@@ -1238,7 +1261,7 @@
 	if (SDLMAME_EVENTS_IN_WORKER_THREAD)
 	{
 		osd_lock_acquire(input_lock);
-	#if (SDL_VERSION_ATLEAST(1,3,0))
+	#if (SDLMAME_SDL2)
 		/* Make sure we get all pending events */
 		SDL_PumpEvents();
 	#endif
@@ -1306,15 +1329,24 @@
 		}
 		switch(event.type) {
 		case SDL_KEYDOWN:
+#ifdef SDL2_MULTIAPI
 			devinfo = generic_device_find_index( keyboard_list, keyboard_map.logical[event.key.which]);
 			//printf("Key down %d %d %s => %d %s (scrlock keycode is %d)\n", event.key.which, event.key.keysym.scancode, devinfo->name, OSD_SDL_INDEX_KEYSYM(&event.key.keysym), sdl_key_trans_table[event.key.keysym.scancode].mame_key_name, KEYCODE_SCRLOCK);
+#else
+			devinfo = generic_device_find_index( keyboard_list, keyboard_map.logical[0]);
+#endif
 			devinfo->keyboard.state[OSD_SDL_INDEX_KEYSYM(&event.key.keysym)] = 0x80;
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 			ui_input_push_char_event(machine, sdl_window_list->target, (unicode_char) event.key.keysym.unicode);
 #endif
 			break;
 		case SDL_KEYUP:
+#ifdef SDL2_MULTIAPI
 			devinfo = generic_device_find_index( keyboard_list, keyboard_map.logical[event.key.which]);
+			//printf("Key up: %d %d\n", OSD_SDL_INDEX_KEYSYM(&event.key.keysym), event.key.which);
+#else
+			devinfo = generic_device_find_index( keyboard_list, keyboard_map.logical[0]);
+#endif
 			devinfo->keyboard.state[OSD_SDL_INDEX_KEYSYM(&event.key.keysym)] = 0x00;
 			break;
 		case SDL_JOYAXISMOTION:
@@ -1389,7 +1421,11 @@
 			}
 			break;
 		case SDL_MOUSEBUTTONDOWN:
+#ifdef SDL2_MULTIAPI
 			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[event.button.which]);
+#else
+			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[0]);
+#endif
 			devinfo->mouse.buttons[event.button.button-1] = 0x80;
 			//printf("But down %d %d %d %d %s\n", event.button.which, event.button.button, event.button.x, event.button.y, devinfo->name);
 			if (event.button.button == 1)
@@ -1422,7 +1458,11 @@
 			}
 			break;
 		case SDL_MOUSEBUTTONUP:
+#ifdef SDL2_MULTIAPI
 			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[event.button.which]);
+#else
+			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[0]);
+#endif
 			devinfo->mouse.buttons[event.button.button-1] = 0;
 			//printf("But up %d %d %d %d\n", event.button.which, event.button.button, event.button.x, event.button.y);
 
@@ -1438,8 +1478,12 @@
 			}
 			break;
 		case SDL_MOUSEMOTION:
+#ifdef SDL2_MULTIAPI
 			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[event.motion.which]);
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#else
+			devinfo = generic_device_find_index(mouse_list, mouse_map.logical[0]);
+#endif
+#if (SDLMAME_SDL2)
 			// FIXME: may apply to 1.2 as well ...
 			//printf("Motion %d %d %d %s\n", event.motion.which, event.motion.x, event.motion.y, devinfo->name);
 			devinfo->mouse.lX += event.motion.xrel * INPUT_RELATIVE_PER_PIXEL;
@@ -1456,7 +1500,13 @@
 					ui_input_push_mouse_move_event(machine, window->target, cx, cy);
 			}
 			break;
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+		case SDL_JOYBALLMOTION:
+			devinfo = generic_device_find_index(joystick_list, joy_map.logical[event.jball.which]);
+			//printf("Ball %d %d\n", event.jball.xrel, event.jball.yrel);
+			devinfo->joystick.balls[event.jball.ball * 2] = event.jball.xrel * INPUT_RELATIVE_PER_PIXEL;
+			devinfo->joystick.balls[event.jball.ball * 2 + 1] = event.jball.yrel * INPUT_RELATIVE_PER_PIXEL;
+			break;
+#if (!SDLMAME_SDL2)
 		case SDL_APPMOUSEFOCUS:
 			app_has_mouse_focus = event.active.gain;
 			if (!event.active.gain)
@@ -1533,7 +1583,7 @@
 #endif
 		}
 	}
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	resize_all_windows();
 #endif
 }
@@ -1549,7 +1599,7 @@
 	// FIXME: SDL >= 1.3 will nuke the window event buffer when
 	// a window is closed. This will leave keys in a pressed
 	// state when a window is destroyed and recreated.
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	device_info *devinfo;
 	int index;
 
diff -Nru src-old/osd/sdl/keymaps/km-de.txt src/osd/sdl/keymaps/km-de.txt
--- src-old/osd/sdl/keymaps/km-de.txt	2010-01-16 15:40:50.000000000 +0100
+++ src/osd/sdl/keymaps/km-de.txt	2012-02-16 02:38:13.000000000 +0100
@@ -12,3 +12,15 @@
 ITEM_ID_SLASH SDLK_MINUS 0x3d 0x2d -
 ITEM_ID_Z SDLK_y 0x34 0x79 Y
 ITEM_ID_Y SDLK_z 0x1d 0x7a Z
+[SDL2]
+ITEM_ID_TILDE SDL_SCANCODE_GRAVE 0x35 0x0 ^
+ITEM_ID_MINUS SDL_SCANCODE_MINUS 0x2d 0x0 
+ITEM_ID_EQUALS SDL_SCANCODE_EQUALS 0x2e 0x0 '
+ITEM_ID_OPENBRACE SDL_SCANCODE_LEFTBRACKET 0x2f 0x0 
+ITEM_ID_CLOSEBRACE SDL_SCANCODE_RIGHTBRACKET 0x30 0x0 +
+ITEM_ID_COLON SDL_SCANCODE_SEMICOLON 0x33 0x0 
+ITEM_ID_QUOTE SDL_SCANCODE_APOSTROPHE 0x34 0x0 
+ITEM_ID_BACKSLASH SDL_SCANCODE_BACKSLASH 0x31 0x0 #
+ITEM_ID_SLASH SDL_SCANCODE_SLASH 0x38 0x0 -
+ITEM_ID_Z SDL_SCANCODE_Y 0x34 0x79 Y
+ITEM_ID_Y SDL_SCANCODE_Z 0x1d 0x7a Z
diff -Nru src-old/osd/sdl/osd_opengl.h src/osd/sdl/osd_opengl.h
--- src-old/osd/sdl/osd_opengl.h	2011-04-18 01:06:50.000000000 +0200
+++ src/osd/sdl/osd_opengl.h	2012-02-12 21:59:24.000000000 +0100
@@ -15,14 +15,22 @@
 	/* equivalent to #include <GL/gl.h>
      * #include <GL/glext.h>
      */
+	#if (SDLMAME_SDL2)
+	#include <SDL2/SDL_version.h>
+	#else
 	#include <SDL/SDL_version.h>
+	#endif
 
 #if (SDL_VERSION_ATLEAST(1,2,10))
 	#if defined(SDLMAME_WIN32)
 		// Avoid that winnt.h (included via sdl_opengl.h, windows.h, windef.h includes intrin.h
 		#define __INTRIN_H_
 	#endif
+	#if (SDLMAME_SDL2)
+	#include <SDL2/SDL_opengl.h>
+	#else
 	#include <SDL/SDL_opengl.h>
+	#endif
 #else
 	/*
      * SDL 1.2.9 does not provide everything we need
diff -Nru src-old/osd/sdl/osdsdl.h src/osd/sdl/osdsdl.h
--- src-old/osd/sdl/osdsdl.h	2012-01-12 22:19:49.000000000 +0100
+++ src/osd/sdl/osdsdl.h	2012-02-12 21:59:24.000000000 +0100
@@ -1,33 +1,24 @@
 #ifndef _osdsdl_h_
 #define _osdsdl_h_
 
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 #include "watchdog.h"
 #include "clifront.h"
 
 //============================================================
-//  Temporary SDL 1.3 defines
-//============================================================
-
-// set this to 0 if compiling against a "hg update 4464"
-// checkout of SDL 1.3
-
-#define SDL13_POST_HG4464	(1)
-
-//============================================================
 //  System dependent defines
 //============================================================
 
 // Process events in worker thread
-#if defined(SDLMAME_WIN32) || (SDL_VERSION_ATLEAST(1,3,0))
+#if defined(SDLMAME_WIN32) || (SDLMAME_SDL2)
 #define SDLMAME_EVENTS_IN_WORKER_THREAD	(1)
 #else
 #define SDLMAME_EVENTS_IN_WORKER_THREAD	(0)
 #endif
 
 #if defined(SDLMAME_WIN32)
-	#if (SDL_VERSION_ATLEAST(1,3,0))
+	#if (SDLMAME_SDL2)
 		#define SDLMAME_INIT_IN_WORKER_THREAD	(0) //FIXME: breaks mt
 		#define SDL13_COMBINE_RESIZE (1)
 	#else
@@ -215,7 +206,7 @@
 	const char *joy_index(int index) const { astring temp; return value(temp.format("%s%d", SDLOPTION_JOYINDEX, index)); }
 	bool sixaxis() const { return bool_value(SDLOPTION_SIXAXIS); }
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	const char *mouse_index(int index) const { astring temp; return value(temp.format("%s%d", SDLOPTION_MOUSEINDEX, index)); }
 	const char *keyboard_index(int index) const { astring temp; return value(temp.format("%s%d", SDLOPTION_KEYBINDEX, index)); }
 #endif
diff -Nru src-old/osd/sdl/sdl.mak src/osd/sdl/sdl.mak
--- src-old/osd/sdl/sdl.mak	2011-12-15 09:17:18.000000000 +0100
+++ src/osd/sdl/sdl.mak	2012-02-19 16:23:23.000000000 +0100
@@ -21,7 +21,6 @@
 # for details
 #-------------------------------------------------
 
-
 # uncomment and edit next line to specify a distribution
 # supported debian-stable, ubuntu-intrepid
 
@@ -48,17 +47,20 @@
 
 USE_DISPATCH_GL = 1
 
-# uncomment and change the next line to compile and link to specific
-# SDL library. This is currently supported for unix and win32.
+# The following settings are currently supported for unix only.
 # There is no need to play with this option unless you are doing
 # active development on sdlmame or SDL.
 
-ifeq ($(TARGETOS),win32)
-#SDL_INSTALL_ROOT = /usr/local/sdl13w32
-else
-#SDL_INSTALL_ROOT = /usr/local/sdl13
-#SDL_INSTALL_ROOT = /usr/local/test
-endif
+# uncomment the next line to compile and link against SDL2.0
+
+# SDL_LIBVER = sdl2
+
+# uncomment the next line to use couriersud's multi-keyboard patch for sdl2.0
+# SDL2_MULTIAPI = 1
+
+# uncomment the next line to specify where you have installed
+# SDL. Equivalent to the ./configure --prefix=<path>
+# SDL_INSTALL_ROOT = /usr/local/sdl13
 
 # uncomment and change the next line to build the gtk debugger for win32
 # Get what you need here: http://www.gtk.org/download-windows.html
@@ -70,6 +72,25 @@
 ##################   END USER-CONFIGURABLE OPTIONS   ######################
 ###########################################################################
 
+ifndef SDL_LIBVER
+SDL_LIBVER = sdl
+endif
+
+ifdef SDL_INSTALL_ROOT
+SDL_CONFIG = $(SDL_INSTALL_ROOT)/bin/$(SDL_LIBVER)-config
+else
+SDL_CONFIG = $(SDL_LIBVER)-config
+endif
+
+ifeq ($(SDL_LIBVER),sdl2)
+DEFS += -DSDLMAME_SDL2=1
+	ifeq ($(SDL2_MULTIAPI),1)
+	DEFS += -DSDL2_MULTIAPI
+	endif
+else
+DEFS += -DSDLMAME_SDL2=0
+endif
+
 ifdef NOASM
 DEFS += -DSDLMAME_NOASM
 endif
@@ -288,8 +309,9 @@
 	$(SDLOBJ)/output.o \
 	$(SDLOBJ)/watchdog.o
 
-# Add SDL1.3 support
-ifdef SDL_INSTALL_ROOT
+# Add SDL2.0 support
+
+ifeq ($(SDL_LIBVER),sdl2)
 OSDOBJS += $(SDLOBJ)/draw13.o
 endif
 
@@ -350,31 +372,27 @@
 endif
 endif
 
-ifndef SDL_INSTALL_ROOT
-INCPATH += `sdl-config --cflags  | sed -e 's:/SDL::' -e 's:\(-D[^ ]*\)::g'`
-CCOMFLAGS += `sdl-config --cflags  | sed -e 's:/SDL::' -e 's:\(-I[^ ]*\)::g'`
-LIBS += -lm `sdl-config --libs`
-
-else
-# The commented out statements document what sdl-config returns when build from svn.
-# sdl-config --libs on ubuntu returns "-L/usr/lib -lSDL" which is not what we really
-# want in a multi-version SDL environment. Should the svn sdl-config at some point
-# return the same output, we need the commented out section again.
-
-#INCPATH += -I$(SDL_INSTALL_ROOT)/include
-#CCOMFLAGS += -D_GNU_SOURCE=1
-#LIBS += -lm -L$(SDL_INSTALL_ROOT)/lib -Wl,-rpath,$(SDL_INSTALL_ROOT)/lib -lSDL
 
-# FIXME: remove the directfb ref. later. This is just there for now to work around an issue with SDL1.3.
+INCPATH += `$(SDL_CONFIG) --cflags  | sed -e 's:/SDL[2]*::' -e 's:\(-D[^ ]*\)::g'`
+CCOMFLAGS += `$(SDL_CONFIG) --cflags  | sed -e 's:/SDL[2]*::' -e 's:\(-I[^ ]*\)::g'`
+LIBS += -lm `$(SDL_CONFIG) --libs`
+
+ifeq ($(SDL_LIBVER),sdl2)
+ifdef SDL_INSTALL_ROOT
+# FIXME: remove the directfb ref. later. This is just there for now to work around an issue with SDL1.3 and SDL2.0
 INCPATH += -I$(SDL_INSTALL_ROOT)/include/directfb
-INCPATH += `$(SDL_INSTALL_ROOT)/bin/sdl-config --cflags  | sed -e 's:/SDL::' -e 's:\(-D[^ ]*\)::g'`
-CCOMFLAGS += `$(SDL_INSTALL_ROOT)/bin/sdl-config --cflags  | sed -e 's:/SDL::' -e 's:\(-I[^ ]*\)::g'`
-LIBS += -lm `$(SDL_INSTALL_ROOT)/bin/sdl-config --libs`
+endif
 endif
 
 INCPATH += `pkg-config --cflags fontconfig`
 LIBS += `pkg-config --libs fontconfig`
+
+ifeq ($(SDL_LIBVER),sdl2)
+LIBS += -lSDL2_ttf -lutil
+else
 LIBS += -lSDL_ttf -lutil
+endif
+
 
 endif # Unix
 
@@ -591,9 +609,10 @@
 #-------------------------------------------------
 
 testlib:
-	-echo LIBS: $(LIBS)
-	-echo DEFS: $(DEFS)
-	-echo CORE: $(OSDCOREOBJS)
+	@echo LIBS: $(LIBS)
+	@echo INCPATH: $(INCPATH)
+	@echo DEFS: $(DEFS)
+	@echo CORE: $(OSDCOREOBJS)
 
 ifneq ($(TARGETOS),win32)
 BUILD_VERSION = $(shell grep 'build_version\[\] =' src/version.c | sed -e "s/.*= \"//g" -e "s/ .*//g")
diff -Nru src-old/osd/sdl/sdlinc.h src/osd/sdl/sdlinc.h
--- src-old/osd/sdl/sdlinc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/osd/sdl/sdlinc.h	2012-02-12 21:59:24.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef _sdlinc_h_
+#define _sdlinc_h_
+
+#if (SDLMAME_SDL2)
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_version.h>
+// on win32 this includes windows.h by itself and breaks us!
+#ifndef SDLMAME_WIN32
+#include <SDL2/SDL_syswm.h>
+#endif
+#else
+#include <SDL/SDL.h>
+#include <SDL/SDL_version.h>
+// on win32 this includes windows.h by itself and breaks us!
+#ifndef SDLMAME_WIN32
+#include <SDL/SDL_syswm.h>
+#endif
+#endif
+
+#endif
diff -Nru src-old/osd/sdl/sdlmain.c src/osd/sdl/sdlmain.c
--- src-old/osd/sdl/sdlmain.c	2012-01-29 03:32:28.000000000 +0100
+++ src/osd/sdl/sdlmain.c	2012-02-14 00:38:49.000000000 +0100
@@ -9,13 +9,14 @@
 //
 //============================================================
 
-// standard sdl header
-#include <SDL/SDL.h>
-#include <SDL/SDL_version.h>
 
 #ifdef SDLMAME_UNIX
 #ifndef SDLMAME_MACOSX
+#if (SDLMAME_SDL2)
+#include <SDL2/SDL_ttf.h>
+#else
 #include <SDL/SDL_ttf.h>
+#endif
 #include <fontconfig/fontconfig.h>
 #endif
 #ifdef SDLMAME_MACOSX
@@ -33,6 +34,8 @@
 #include <os2.h>
 #endif
 
+#include "sdlinc.h"
+
 // MAME headers
 #include "osdepend.h"
 #include "emu.h"
@@ -109,10 +112,10 @@
 	{ SDLOPTION_CENTERH,                      "1",        OPTION_BOOLEAN,    "center horizontally within the view area" },
 	{ SDLOPTION_CENTERV,                      "1",        OPTION_BOOLEAN,    "center vertically within the view area" },
 	#if (SDL_VERSION_ATLEAST(1,2,10))
-	{ SDLOPTION_WAITVSYNC,                    "0",        OPTION_BOOLEAN,    "enable waiting for the start of VBLANK before flipping screens; reduces tearing effects" },
-	{ SDLOPTION_SYNCREFRESH,                  "0",        OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
+	{ SDLOPTION_WAITVSYNC ";vs",              "0",        OPTION_BOOLEAN,    "enable waiting for the start of VBLANK before flipping screens; reduces tearing effects" },
+	{ SDLOPTION_SYNCREFRESH ";sr",            "0",        OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 	#endif
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	{ SDLOPTION_SCALEMODE ";sm",         SDLOPTVAL_NONE,  OPTION_STRING,     "Scale mode: none, hwblit, hwbest, yv12, yuy2, yv12x2, yuy2x2 (-video soft only)" },
 #else
 	{ SDLOPTION_SCALEMODE ";sm",         SDLOPTVAL_NONE,  OPTION_STRING,     "Scale mode: none, async, yv12, yuy2, yv12x2, yuy2x2 (-video soft only)" },
@@ -211,7 +214,7 @@
 	{ SDLOPTION_JOYINDEX "8",                SDLOPTVAL_AUTO, OPTION_STRING,         "name of joystick mapped to joystick #8" },
 	{ SDLOPTION_SIXAXIS,			         "0",	 OPTION_BOOLEAN,    "Use special handling for PS3 Sixaxis controllers" },
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	{ NULL, 		                         NULL,   OPTION_HEADER,     "SDL MOUSE MAPPING" },
 	{ SDLOPTION_MOUSEINDEX "1",              SDLOPTVAL_AUTO, OPTION_STRING,         "name of mouse mapped to mouse #1" },
 	{ SDLOPTION_MOUSEINDEX "2",              SDLOPTVAL_AUTO, OPTION_STRING,         "name of mouse mapped to mouse #2" },
@@ -235,7 +238,7 @@
 	// SDL low level driver options
 	{ NULL, 		                         NULL,   OPTION_HEADER,     "SDL LOWLEVEL DRIVER OPTIONS" },
 	{ SDLOPTION_VIDEODRIVER ";vd",           SDLOPTVAL_AUTO,  OPTION_STRING,        "sdl video driver to use ('x11', 'directfb', ... or 'auto' for SDL default" },
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	{ SDLOPTION_RENDERDRIVER ";rd",          SDLOPTVAL_AUTO,  OPTION_STRING,        "sdl render driver to use ('software', 'opengl', 'directfb' ... or 'auto' for SDL default" },
 #endif
 	{ SDLOPTION_AUDIODRIVER ";ad",           SDLOPTVAL_AUTO,  OPTION_STRING,        "sdl audio driver to use ('alsa', 'arts', ... or 'auto' for SDL default" },
@@ -298,7 +301,7 @@
 {
 	int res = 0;
 
-#if	!(SDL_VERSION_ATLEAST(1,3,0))
+#if	!(SDLMAME_SDL2)
 	/* Load SDL dynamic link library */
 	if ( SDL_Init(SDL_INIT_NOPARACHUTE) < 0 ) {
 		fprintf(stderr, "WinMain() error: %s", SDL_GetError());
@@ -416,7 +419,14 @@
 	#endif
 
 	if (!SDLMAME_INIT_IN_WORKER_THREAD)
+	{
+		/* FixMe: Bug in SDL2.0, Quitting joystick will cause SIGSEGV */
+#if SDLMAME_SDL2
+		SDL_QuitSubSystem(SDL_INIT_TIMER|SDL_INIT_AUDIO| SDL_INIT_VIDEO /*| SDL_INIT_JOYSTICK */);
+#else
 		SDL_Quit();
+#endif
+	}
 }
 
 //============================================================
@@ -492,7 +502,7 @@
 
 static void osd_sdl_info(void)
 {
-#if SDL_VERSION_ATLEAST(1,3,0)
+#if SDLMAME_SDL2
 	int i, num = SDL_GetNumVideoDrivers();
 
 	mame_printf_verbose("Available videodrivers: ");
@@ -572,15 +582,15 @@
 		osd_setenv(SDLENV_VIDEODRIVER, stemp, 1);
 	}
 
-	if (SDL_VERSION_ATLEAST(1,3,0))
-	{
+#if (SDLMAME_SDL2)
 		stemp = options.render_driver();
 		if (stemp != NULL && strcmp(stemp, SDLOPTVAL_AUTO) != 0)
 		{
 			mame_printf_verbose("Setting SDL renderdriver '%s' ...\n", stemp);
-			osd_setenv(SDLENV_RENDERDRIVER, stemp, 1);
+			//osd_setenv(SDLENV_RENDERDRIVER, stemp, 1);
+			SDL_SetHint(SDL_HINT_RENDER_DRIVER, stemp);
 		}
-	}
+#endif
 
 	/* Set the SDL environment variable for drivers wanting to load the
      * lib at startup.
@@ -615,7 +625,7 @@
 
 	if (!SDLMAME_INIT_IN_WORKER_THREAD)
 	{
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 		if (SDL_InitSubSystem(SDL_INIT_TIMER|SDL_INIT_AUDIO| SDL_INIT_VIDEO| SDL_INIT_JOYSTICK|SDL_INIT_NOPARACHUTE)) {
 #else
 		if (SDL_Init(SDL_INIT_TIMER|SDL_INIT_AUDIO| SDL_INIT_VIDEO| SDL_INIT_JOYSTICK|SDL_INIT_NOPARACHUTE)) {
@@ -670,7 +680,7 @@
 		m_watchdog->setTimeout(watchdog_timeout);
 	}
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	SDL_EventState(SDL_TEXTINPUT, SDL_TRUE);
 #else
 	SDL_EnableUNICODE(SDL_TRUE);
diff -Nru src-old/osd/sdl/sdlmisc_macosx.c src/osd/sdl/sdlmisc_macosx.c
--- src-old/osd/sdl/sdlmisc_macosx.c	2010-01-22 22:14:06.000000000 +0100
+++ src/osd/sdl/sdlmisc_macosx.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <signal.h>
diff -Nru src-old/osd/sdl/sdlmisc_os2.c src/osd/sdl/sdlmisc_os2.c
--- src-old/osd/sdl/sdlmisc_os2.c	2010-02-28 13:16:38.000000000 +0100
+++ src/osd/sdl/sdlmisc_os2.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 #include <unistd.h>
 #include <stdio.h>
 #include <string.h>
diff -Nru src-old/osd/sdl/sdlmisc_win32.c src/osd/sdl/sdlmisc_win32.c
--- src-old/osd/sdl/sdlmisc_win32.c	2010-01-21 23:54:49.000000000 +0100
+++ src/osd/sdl/sdlmisc_win32.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 
 #define WIN32_LEAN_AND_MEAN
diff -Nru src-old/osd/sdl/sdlos_macosx.c src/osd/sdl/sdlos_macosx.c
--- src-old/osd/sdl/sdlos_macosx.c	2011-05-23 01:57:17.000000000 +0200
+++ src/osd/sdl/sdlos_macosx.c	2012-02-14 00:23:41.000000000 +0100
@@ -10,8 +10,6 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
-
 #include <sys/stat.h>
 #include <unistd.h>
 
@@ -19,6 +17,8 @@
 #include <mach/mach_time.h>
 #include <Carbon/Carbon.h>
 
+#include "sdlinc.h"
+
 // MAME headers
 #include "osdcore.h"
 
diff -Nru src-old/osd/sdl/sdlos_os2.c src/osd/sdl/sdlos_os2.c
--- src-old/osd/sdl/sdlos_os2.c	2011-08-02 03:27:31.000000000 +0200
+++ src/osd/sdl/sdlos_os2.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 #include <unistd.h>
 #include <stdio.h>
 #include <string.h>
diff -Nru src-old/osd/sdl/sdlos_unix.c src/osd/sdl/sdlos_unix.c
--- src-old/osd/sdl/sdlos_unix.c	2011-05-23 01:57:17.000000000 +0200
+++ src/osd/sdl/sdlos_unix.c	2012-02-12 21:59:24.000000000 +0100
@@ -16,8 +16,7 @@
 #include <sys/time.h>
 #include <sys/stat.h>
 
-#include <SDL/SDL.h>
-#include <SDL/SDL_syswm.h>
+#include "sdlinc.h"
 
 // MAME headers
 #include "osdcore.h"
@@ -138,7 +137,27 @@
 	return setenv(name, value, overwrite);
 }
 
-#if defined(SDL_VIDEO_DRIVER_X11) && defined(SDLMAME_X11)
+#if (SDLMAME_SDL2)
+
+//============================================================
+//  osd_get_clipboard_text
+//============================================================
+
+char *osd_get_clipboard_text(void)
+{
+	char *result = NULL;
+
+	if (SDL_HasClipboardText())
+	{
+		char *temp = SDL_GetClipboardText();
+		result = (char *) osd_malloc_array(strlen(temp) + 1);
+		strcpy(result, temp);
+		SDL_free(temp);
+	}
+	return result;
+}
+
+#elif defined(SDL_VIDEO_DRIVER_X11) && defined(SDLMAME_X11)
 
 //============================================================
 //  osd_get_clipboard_text
@@ -167,17 +186,11 @@
 		return NULL;
 	if ( info.subsystem != SDL_SYSWM_X11 )
 		return NULL;
-#if (SDL_VERSION_ATLEAST(1,3,0))
-	if ( (display = info.info.x11.display) == NULL )
-		return NULL;
-	if ( (our_win = info.info.x11.window) == None )
-		return NULL;
-#else
 	if ( (display = info.info.x11.display) == NULL )
 		return NULL;
 	if ( (our_win = info.info.x11.window) == None )
 		return NULL;
-#endif
+
 	/* request data to owner */
 	selection_win = XGetSelectionOwner( display, XA_PRIMARY );
 	if ( selection_win == None )
diff -Nru src-old/osd/sdl/sdlos_win32.c src/osd/sdl/sdlos_win32.c
--- src-old/osd/sdl/sdlos_win32.c	2011-05-23 01:57:17.000000000 +0200
+++ src/osd/sdl/sdlos_win32.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 
 #define WIN32_LEAN_AND_MEAN
diff -Nru src-old/osd/sdl/sdlsync_ntc.c src/osd/sdl/sdlsync_ntc.c
--- src-old/osd/sdl/sdlsync_ntc.c	2011-09-08 01:15:12.000000000 +0200
+++ src/osd/sdl/sdlsync_ntc.c	2012-02-12 21:59:24.000000000 +0100
@@ -13,7 +13,7 @@
 #define _GNU_SOURCE 	// for PTHREAD_MUTEX_RECURSIVE; needs to be here before other glibc headers are included
 #endif
 
-#include "SDL/SDL.h"
+#include "sdlinc.h"
 
 #ifdef SDLMAME_MACOSX
 #include <mach/mach.h>
diff -Nru src-old/osd/sdl/sdlsync_os2.c src/osd/sdl/sdlsync_os2.c
--- src-old/osd/sdl/sdlsync_os2.c	2012-01-05 04:23:51.000000000 +0100
+++ src/osd/sdl/sdlsync_os2.c	2012-02-12 21:59:24.000000000 +0100
@@ -13,7 +13,7 @@
 #define _GNU_SOURCE 	// for PTHREAD_MUTEX_RECURSIVE; needs to be here before other glibc headers are included
 #endif
 
-#include "SDL/SDL.h"
+#include "sdlinc.h"
 
 // standard C headers
 #include <math.h>
diff -Nru src-old/osd/sdl/sdlsync_sdl.c src/osd/sdl/sdlsync_sdl.c
--- src-old/osd/sdl/sdlsync_sdl.c	2010-01-16 05:12:04.000000000 +0100
+++ src/osd/sdl/sdlsync_sdl.c	2012-02-12 21:59:24.000000000 +0100
@@ -9,7 +9,7 @@
 //
 //============================================================
 
-#include "SDL/SDL.h"
+#include "sdlinc.h"
 
 // standard C headers
 #include <unistd.h>
diff -Nru src-old/osd/sdl/sdlsync_tc.c src/osd/sdl/sdlsync_tc.c
--- src-old/osd/sdl/sdlsync_tc.c	2011-01-02 20:12:08.000000000 +0100
+++ src/osd/sdl/sdlsync_tc.c	2012-02-12 21:59:24.000000000 +0100
@@ -13,7 +13,7 @@
 #define _GNU_SOURCE 	// for PTHREAD_MUTEX_RECURSIVE; needs to be here before other glibc headers are included
 #endif
 
-#include "SDL/SDL.h"
+#include "sdlinc.h"
 
 #ifdef SDLMAME_MACOSX
 #include <mach/mach.h>
diff -Nru src-old/osd/sdl/sound.c src/osd/sdl/sound.c
--- src-old/osd/sdl/sound.c	2011-05-20 00:58:10.000000000 +0200
+++ src/osd/sdl/sound.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,7 +10,7 @@
 //============================================================
 
 // standard sdl header
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 // MAME headers
 #include "emu.h"
@@ -432,7 +432,7 @@
 	}
 
 	mame_printf_verbose("Audio: Start initialization\n");
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	strncpy(audio_driver, SDL_GetCurrentAudioDriver(), sizeof(audio_driver));
 #else
 	SDL_AudioDriverName(audio_driver, sizeof(audio_driver));
diff -Nru src-old/osd/sdl/testkeys.c src/osd/sdl/testkeys.c
--- src-old/osd/sdl/testkeys.c	2010-03-17 12:59:16.000000000 +0100
+++ src/osd/sdl/testkeys.c	2012-02-16 02:38:13.000000000 +0100
@@ -15,17 +15,10 @@
 #include <string.h>
 #include <wchar.h>
 
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 
 #include "unicode.h"
 
-// Check whether SDL has compat interface
-#if defined(SDL_AllocSurface) || (!SDL_VERSION_ATLEAST(1,3,0))
-#define SDL_HAS_COMPAT		1
-#else
-#define SDL_HAS_COMPAT		0
-#endif
-
 typedef struct _key_lookup_table key_lookup_table;
 
 struct _key_lookup_table
@@ -34,8 +27,7 @@
 	const char *name;
 };
 
-#if SDL_HAS_COMPAT
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 #define KE(x) { SDL_SCANCODE_ ## x, "SDL_SCANCODE_" #x },
 #define KE8(A, B, C, D, E, F, G, H) KE(A) KE(B) KE(C) KE(D) KE(E) KE(F) KE(G) KE(H)
 #define KE7(A, B, C, D, E, F, G) KE(A) KE(B) KE(C) KE(D) KE(E) KE(F) KE(G)
@@ -116,7 +108,6 @@
 	}
 	return NULL;
 }
-#endif // SDL_HAS_COMPAT
 
 #ifdef SDLMAME_WIN32
 int utf8_main(int argc, char *argv[])
@@ -124,18 +115,25 @@
 int main(int argc, char *argv[])
 #endif
 {
-#if SDL_HAS_COMPAT
 	SDL_Event event;
 	int quit = 0;
+#if (SDLMAME_SDL2)
+	char lasttext[20] = "";
+#else
 	char buf[20];
+#endif
 
 	if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {
 		fprintf(stderr, "Couldn't initialize SDL: %s\n",
 							SDL_GetError());
 		exit(1);
 	}
+#if (SDLMAME_SDL2)
+	SDL_CreateWindow("Input Test", 0, 0, 100, 100,0 );
+#else
 	SDL_SetVideoMode(100, 50, 16, SDL_ANYFORMAT);
 	SDL_EnableUNICODE(1);
+#endif
 	while(SDL_PollEvent(&event) || !quit) {
 		switch(event.type) {
 		case SDL_QUIT:
@@ -146,32 +144,46 @@
 				quit=1;
 			else
 			{
-				memset(buf, 0, ARRAY_LENGTH(buf));
+#if (SDLMAME_SDL2)
+				printf("ITEM_ID_XY %s 0x%x 0x%x %s\n",
+					lookup_key_name(sdl_lookup, event.key.keysym.scancode),
+					(int) event.key.keysym.scancode,
+					(int) event.key.keysym.unicode,
+					"");
+				lasttext[0] = 0;
+#else
+				memset(buf, 0, 19);
 				utf8_from_uchar(buf, sizeof(buf), event.key.keysym.unicode);
-				printf("ITEM_ID_XY %s 0x%x 0x%x %s \n",
-#if (SDL_VERSION_ATLEAST(1,3,0))
-						lookup_key_name(sdl_lookup, event.key.keysym.scancode),
-#else
-						lookup_key_name(sdl_lookup, event.key.keysym.sym),
-#endif
-						(int) event.key.keysym.scancode,
-						(int) event.key.keysym.unicode,
-						buf);
+				printf("ITEM_ID_XY %s 0x%x 0x%x %s\n",
+					lookup_key_name(sdl_lookup, event.key.keysym.sym),
+					(int) event.key.keysym.scancode,
+					(int) event.key.keysym.unicode,
+					buf);
+#endif
 			}
 			break;
 		case SDL_KEYUP:
-			memset(buf, 0, 19);
-			utf8_from_uchar(buf, sizeof(buf), event.key.keysym.unicode);
-			printf("ITEM_ID_XY %s 0x%x 0x%x %s \n",
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
+			printf("ITEM_ID_XY %s 0x%x 0x%x %s\n",
 					lookup_key_name(sdl_lookup, event.key.keysym.scancode),
+					(int) event.key.keysym.scancode,
+					(int) event.key.keysym.unicode,
+					lasttext);
 #else
+			memset(buf, 0, 19);
+			utf8_from_uchar(buf, sizeof(buf), event.key.keysym.unicode);
+			printf("ITEM_ID_XY %s 0x%x 0x%x %s\n",
 					lookup_key_name(sdl_lookup, event.key.keysym.sym),
-#endif
 					(int) event.key.keysym.scancode,
 					(int) event.key.keysym.unicode,
 					buf);
+#endif
+			break;
+#if (SDLMAME_SDL2)
+		case SDL_TEXTINPUT:
+			strcpy(lasttext, event.text.text);
 			break;
+#endif
 		}
 		event.type = 0;
 
@@ -181,9 +193,5 @@
 	}
 	SDL_Quit();
 	return(0);
-#else
-	printf("This SDL Version does not support 1.2 compatibility interface.\n");
-	return(1);
-#endif
 }
 
diff -Nru src-old/osd/sdl/video.c src/osd/sdl/video.c
--- src-old/osd/sdl/video.c	2011-12-15 15:10:46.000000000 +0100
+++ src/osd/sdl/video.c	2012-02-14 00:38:49.000000000 +0100
@@ -9,12 +9,6 @@
 //
 //============================================================
 
-#include <SDL/SDL.h>
-// on win32 this includes windows.h by itself and breaks us!
-#ifndef SDLMAME_WIN32
-#include <SDL/SDL_syswm.h>
-#endif
-
 #ifdef SDLMAME_X11
 #include <X11/extensions/Xinerama.h>
 #endif
@@ -41,6 +35,8 @@
 #include <os2.h>
 #endif
 
+#include "sdlinc.h"
+
 // MAME headers
 #include "emu.h"
 #include "rendutil.h"
@@ -163,7 +159,7 @@
 
 void sdlvideo_monitor_refresh(sdl_monitor_info *monitor)
 {
-	#if (SDL_VERSION_ATLEAST(1,3,0))
+	#if (SDLMAME_SDL2)
 	SDL_DisplayMode dmode;
 
 	SDL_GetDesktopDisplayMode(monitor->handle, &dmode);
@@ -283,7 +279,7 @@
 			info_shown = 1;
 		}
 	}
-	#endif //  (SDL_VERSION_ATLEAST(1,3,0))
+	#endif //  (SDLMAME_SDL2)
 }
 
 
@@ -354,7 +350,7 @@
 //  add_primary_monitor
 //============================================================
 
-#if !defined(SDLMAME_WIN32) && !(SDL_VERSION_ATLEAST(1,3,0))
+#if !defined(SDLMAME_WIN32) && !(SDLMAME_SDL2)
 static void add_primary_monitor(void *data)
 {
 	sdl_monitor_info ***tailptr = (sdl_monitor_info ***)data;
@@ -385,7 +381,7 @@
 //  monitor_enum_callback
 //============================================================
 
-#if defined(SDLMAME_WIN32) && !(SDL_VERSION_ATLEAST(1,3,0))
+#if defined(SDLMAME_WIN32) && !(SDLMAME_SDL2)
 static BOOL CALLBACK monitor_enum_callback(HMONITOR handle, HDC dc, LPRECT rect, LPARAM data)
 {
 	sdl_monitor_info ***tailptr = (sdl_monitor_info ***)data;
@@ -446,7 +442,7 @@
 	sdl_monitor_list = NULL;
 	tailptr = &sdl_monitor_list;
 
-	#if (SDL_VERSION_ATLEAST(1,3,0))
+	#if (SDLMAME_SDL2)
 	{
 		int i;
 
@@ -494,7 +490,7 @@
 //  pick_monitor
 //============================================================
 
-#if (SDL_VERSION_ATLEAST(1,3,0)) || defined(SDLMAME_WIN32)
+#if (SDLMAME_SDL2) || defined(SDLMAME_WIN32)
 static sdl_monitor_info *pick_monitor(sdl_options &options, int index)
 {
 	sdl_monitor_info *monitor;
@@ -580,7 +576,7 @@
 		ui_popup_time(1, "Keepaspect %s", video_config.keepaspect? "enabled":"disabled");
 	}
 
-	if (USE_OPENGL || SDL_VERSION_ATLEAST(1,3,0))
+	if (USE_OPENGL || SDLMAME_SDL2)
 	{
 		//FIXME: on a per window basis
 		if (ui_input_pressed(machine, IPT_OSD_5))
@@ -654,7 +650,7 @@
 		video_config.mode = VIDEO_MODE_OPENGL;
 		video_config.prefer16bpp_tex = 1;
 	}
-	else if (SDL_VERSION_ATLEAST(1,3,0) && (strcmp(stemp, SDLOPTVAL_SDL13) == 0))
+	else if (SDLMAME_SDL2 && (strcmp(stemp, SDLOPTVAL_SDL13) == 0))
 	{
 		video_config.mode = VIDEO_MODE_SDL13;
 		video_config.prefer16bpp_tex = 1;
@@ -676,7 +672,7 @@
 		video_config.syncrefresh = 0;
 	}
 
-	if (USE_OPENGL || SDL_VERSION_ATLEAST(1,3,0))
+	if (USE_OPENGL || SDLMAME_SDL2)
 	{
 		video_config.filter        = options.filter();
 	}
@@ -765,7 +761,7 @@
 	// misc options: sanity check values
 
 	// global options: sanity check values
-#if (!SDL_VERSION_ATLEAST(1,3,0))
+#if (!SDLMAME_SDL2)
 	if (video_config.numscreens < 1 || video_config.numscreens > 1) //MAX_VIDEO_WINDOWS)
 	{
 		mame_printf_warning("Invalid numscreens value %d; reverting to 1\n", video_config.numscreens);
diff -Nru src-old/osd/sdl/window.c src/osd/sdl/window.c
--- src-old/osd/sdl/window.c	2011-11-17 11:02:55.000000000 +0100
+++ src/osd/sdl/window.c	2012-02-12 21:59:24.000000000 +0100
@@ -10,9 +10,13 @@
 //============================================================
 
 // standard SDL headers
-#include <SDL/SDL.h>
-#include <SDL/SDL_syswm.h>
+#include "sdlinc.h"
+
+#if (SDLMAME_SDL2)
+#include <SDL2/SDL_thread.h>
+#else
 #include <SDL/SDL_thread.h>
+#endif
 
 // standard C headers
 #include <math.h>
@@ -84,7 +88,7 @@
 static int multithreading_enabled;
 static osd_work_queue *work_queue;
 
-#if !(SDL_VERSION_ATLEAST(1,3,0))
+#if !(SDLMAME_SDL2)
 typedef int SDL_threadID;
 #endif
 
@@ -184,7 +188,7 @@
 
 	if (SDLMAME_INIT_IN_WORKER_THREAD)
 	{
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 		if (SDL_InitSubSystem(SDL_INIT_TIMER|SDL_INIT_AUDIO| SDL_INIT_VIDEO| SDL_INIT_JOYSTICK|SDL_INIT_NOPARACHUTE))
 #else
 		if (SDL_Init(SDL_INIT_TIMER|SDL_INIT_AUDIO| SDL_INIT_VIDEO| SDL_INIT_JOYSTICK|SDL_INIT_NOPARACHUTE))
@@ -239,7 +243,7 @@
 			video_config.mode = VIDEO_MODE_SOFT;
 	}
 #endif
-#if	SDL_VERSION_ATLEAST(1,3,0)
+#if	SDLMAME_SDL2
 	if (video_config.mode == VIDEO_MODE_SDL13)
 	{
 		if (draw13_init(machine, &draw))
@@ -408,7 +412,7 @@
 
     //FIXME: really necessary to distinguish for yuv_modes ?
 	if (window->target->zoom_to_screen()
-		&& (window->scale_mode == VIDEO_SCALE_MODE_NONE ))
+		&& (video_config.scale_mode == VIDEO_SCALE_MODE_NONE ))
 		newwidth = window_width;
 
 	if ((window->blitwidth != newwidth) || (window->blitheight != newheight))
@@ -595,7 +599,7 @@
 
 static void sdlwindow_update_cursor_state(running_machine &machine, sdl_window_info *window)
 {
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	// do not do mouse capture if the debugger's enabled to avoid
 	// the possibility of losing control
 	if (!(machine.debug_flags & DEBUG_FLAG_OSD_ENABLED))
@@ -672,7 +676,6 @@
 	//FIXME: these should be per_window in config-> or even better a bit set
 	window->fullscreen = !video_config.windowed;
 	window->prescale = video_config.prescale;
-	window->scale_mode = video_config.scale_mode;
 
 	// set the initial maximized state
 	// FIXME: Does not belong here
@@ -798,7 +801,7 @@
 //  pick_best_mode
 //============================================================
 
-#if SDL_VERSION_ATLEAST(1,3,0)
+#if SDLMAME_SDL2
 static void pick_best_mode(sdl_window_info *window, int *fswidth, int *fsheight)
 {
 	int minimum_width, minimum_height, target_width, target_height;
diff -Nru src-old/osd/sdl/window.h src/osd/sdl/window.h
--- src-old/osd/sdl/window.h	2011-03-29 16:50:04.000000000 +0200
+++ src/osd/sdl/window.h	2012-02-12 21:59:24.000000000 +0100
@@ -12,7 +12,7 @@
 #ifndef __SDLWINDOW__
 #define __SDLWINDOW__
 
-#include <SDL/SDL.h>
+#include "sdlinc.h"
 #include "video.h"
 #include "render.h"
 #include "sdlsync.h"
@@ -88,16 +88,12 @@
 	int					totalColors;		// total colors from machine/sdl_window_config
 	int					start_viewscreen;
 
-	// per window modes ...
-	int					scale_mode;
-
 	// GL specific
 	int					prescale;
 
-#if (SDL_VERSION_ATLEAST(1,3,0))
+#if (SDLMAME_SDL2)
 	// Needs to be here as well so we can identify window
 	SDL_Window			*sdl_window;
-	SDL_Renderer		*sdl_renderer;
 	// These are used in combine resizing events ... #if SDL13_COMBINE_RESIZE
 	int 				resize_width;
 	int					resize_height;
diff -Nru src-old/osd/windows/windows.mak src/osd/windows/windows.mak
--- src-old/osd/windows/windows.mak	2011-12-24 22:49:38.000000000 +0100
+++ src/osd/windows/windows.mak	2012-02-19 09:50:03.000000000 +0100
@@ -281,7 +281,8 @@
 	$(WINOBJ)/winutil.o \
 	$(WINOBJ)/winclip.o \
 	$(WINOBJ)/winsocket.o \
-	$(WINOBJ)/winwork.o
+	$(WINOBJ)/winwork.o \
+	$(WINOBJ)/winptty.o
 
 
 
diff -Nru src-old/osd/windows/winfile.c src/osd/windows/winfile.c
--- src-old/osd/windows/winfile.c	2011-09-22 13:48:44.000000000 +0200
+++ src/osd/windows/winfile.c	2012-02-19 09:50:03.000000000 +0100
@@ -72,6 +72,7 @@
 	return (_strnicmp(path, "\\\\.\\physicaldrive", 17) == 0);
 }
 
+extern const char *winfile_ptty_identifier;
 
 
 //============================================================
@@ -110,6 +111,13 @@
 		goto error;
 	}
 
+	if (strncmp(path, winfile_ptty_identifier, strlen(winfile_ptty_identifier)) == 0)
+	{
+		(*file)->type = WINFILE_PTTY;
+		filerr = win_open_ptty(path, openflags, file, filesize);
+		goto error;
+	}
+
 	(*file)->type = WINFILE_FILE;
 
 	// convert the path into something Windows compatible
@@ -214,6 +222,9 @@
 		case WINFILE_SOCKET:
 			return win_read_socket(file, buffer, offset, length, actual);
 			break;
+		case WINFILE_PTTY:
+			return win_read_ptty(file, buffer, offset, length, actual);
+			break;
 
 	}
 	return FILERR_NONE;
@@ -250,6 +261,9 @@
 		case WINFILE_SOCKET:
 			return win_write_socket(file, buffer, offset, length, actual);
 			break;
+		case WINFILE_PTTY:
+			return win_write_ptty(file, buffer, offset, length, actual);
+			break;
 
 	}
 	return FILERR_NONE;
@@ -272,6 +286,8 @@
 		case WINFILE_SOCKET:
 			return win_close_socket(file);
 			break;
+		case WINFILE_PTTY:
+			return win_close_ptty(file);
 	}
 	return FILERR_NONE;
 }
diff -Nru src-old/osd/windows/winfile.h src/osd/windows/winfile.h
--- src-old/osd/windows/winfile.h	2011-08-15 00:01:08.000000000 +0200
+++ src/osd/windows/winfile.h	2012-02-19 09:50:03.000000000 +0100
@@ -15,7 +15,8 @@
 enum
 {
 	WINFILE_FILE = 0,
-	WINFILE_SOCKET
+	WINFILE_SOCKET,
+	WINFILE_PTTY
 };
 
 //============================================================
@@ -43,6 +44,11 @@
 file_error win_write_socket(osd_file *file, const void *buffer, UINT64 offset, UINT32 count, UINT32 *actual);
 file_error win_close_socket(osd_file *file);
 
+file_error win_open_ptty(const char *path, UINT32 openflags, osd_file **file, UINT64 *filesize);
+file_error win_read_ptty(osd_file *file, void *buffer, UINT64 offset, UINT32 count, UINT32 *actual);
+file_error win_write_ptty(osd_file *file, const void *buffer, UINT64 offset, UINT32 count, UINT32 *actual);
+file_error win_close_ptty(osd_file *file);
+
 file_error win_error_to_mame_file_error(DWORD error);
 
 #endif //__WINFILE__
diff -Nru src-old/osd/windows/winmain.c src/osd/windows/winmain.c
--- src-old/osd/windows/winmain.c	2012-01-24 21:18:55.000000000 +0100
+++ src/osd/windows/winmain.c	2012-02-10 20:26:14.000000000 +0100
@@ -317,8 +317,8 @@
 	{ WINOPTION_MAXIMIZE ";max",                      "1",        OPTION_BOOLEAN,    "default to maximized windows; otherwise, windows will be minimized" },
 	{ WINOPTION_KEEPASPECT ";ka",                     "1",        OPTION_BOOLEAN,    "constrain to the proper aspect ratio" },
 	{ WINOPTION_PRESCALE,                             "1",        OPTION_INTEGER,    "scale screen rendering by this amount in software" },
-	{ WINOPTION_WAITVSYNC,                            "0",        OPTION_BOOLEAN,    "enable waiting for the start of VBLANK before flipping screens; reduces tearing effects" },
-	{ WINOPTION_SYNCREFRESH,                          "0",        OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
+	{ WINOPTION_WAITVSYNC ";vs",                      "0",        OPTION_BOOLEAN,    "enable waiting for the start of VBLANK before flipping screens; reduces tearing effects" },
+	{ WINOPTION_SYNCREFRESH ";sr",                    "0",        OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 	{ WINOPTION_MENU,           		              "0",        OPTION_BOOLEAN,    "enable menu bar if available by UI implementation" },
 
 	// DirectDraw-specific options
diff -Nru src-old/osd/windows/winptty.c src/osd/windows/winptty.c
--- src-old/osd/windows/winptty.c	1970-01-01 01:00:00.000000000 +0100
+++ src/osd/windows/winptty.c	2012-02-19 09:50:03.000000000 +0100
@@ -0,0 +1,67 @@
+#define WIN32_LEAN_AND_MEAN
+
+#include <windows.h>
+
+#include "winfile.h"
+#include "strconv.h"
+#include "winutil.h"
+
+const char *winfile_ptty_identifier = "\\\\.\\pipe\\";
+
+file_error win_open_ptty(const char *path, UINT32 openflags, osd_file **file, UINT64 *filesize)
+{
+	TCHAR *t_name;
+	HANDLE pipe;
+
+	if((t_name = tstring_from_utf8(path)) == NULL)
+		return FILERR_OUT_OF_MEMORY;
+
+	pipe = CreateNamedPipe(t_name, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_NOWAIT, 1, 32, 32, 0, NULL);
+
+	if(pipe == INVALID_HANDLE_VALUE)
+		return FILERR_ACCESS_DENIED;
+
+	(*file)->handle = pipe;
+	*filesize = 0;
+	osd_free(t_name);
+	return FILERR_NONE;
+}
+
+file_error win_read_ptty(osd_file *file, void *buffer, UINT64 offset, UINT32 count, UINT32 *actual)
+{
+	BOOL res;
+	DWORD bytes_read;
+
+	res = ReadFile(file->handle, buffer, count, &bytes_read, NULL);
+	if(res == FALSE)
+		return win_error_to_file_error(GetLastError());
+
+	if(actual != NULL)
+		*actual = bytes_read;
+
+	return FILERR_NONE;
+}
+
+file_error win_write_ptty(osd_file *file, const void *buffer, UINT64 offset, UINT32 count, UINT32 *actual)
+{
+	BOOL res;
+	DWORD bytes_wrote;
+
+	res = WriteFile(file->handle, buffer, count, &bytes_wrote, NULL);
+	if(res == FALSE)
+		return win_error_to_file_error(GetLastError());
+
+	if(actual != NULL)
+		*actual = bytes_wrote;
+
+	return FILERR_NONE;
+}
+
+file_error win_close_ptty(osd_file *file)
+{
+	FlushFileBuffers(file->handle);
+	DisconnectNamedPipe(file->handle);
+	CloseHandle(file->handle);
+	osd_free(file);
+	return FILERR_NONE;
+}
diff -Nru src-old/osd/windows/wintime.c src/osd/windows/wintime.c
--- src-old/osd/windows/wintime.c	2010-02-14 23:07:25.000000000 +0100
+++ src/osd/windows/wintime.c	2012-02-16 10:47:18.000000000 +0100
@@ -104,6 +104,8 @@
 
 osd_ticks_t osd_ticks_per_second(void)
 {
+	if (ticks_per_second == 0)
+		osd_ticks();
 	return ticks_per_second;
 }
 
diff -Nru src-old/osd/windows/winwork.c src/osd/windows/winwork.c
--- src-old/osd/windows/winwork.c	2011-09-22 13:48:44.000000000 +0200
+++ src/osd/windows/winwork.c	2012-02-19 16:23:23.000000000 +0100
@@ -321,9 +321,14 @@
 	if (numprocs == 1)
 		queue->threads = (flags & WORK_QUEUE_FLAG_IO) ? 1 : 0;
 
-	// on an n-CPU system, create (n-1) threads for multi queues, and 1 thread for everything else
+	// on an n-CPU system, create n threads for multi queues, and 1 thread for everything else
 	else
-		queue->threads = (flags & WORK_QUEUE_FLAG_MULTI) ? (numprocs - 1) : 1;
+		queue->threads = (flags & WORK_QUEUE_FLAG_MULTI) ? numprocs : 1;
+
+	// multi-queues with high frequency items should top out at 4 for now
+	// since we have scaling problems above that
+	if ((flags & WORK_QUEUE_FLAG_HIGH_FREQ) && queue->threads > 1)
+		queue->threads = MIN(queue->threads - 1, 4);
 
 	// clamp to the maximum
 	queue->threads = MIN(queue->threads, WORK_MAX_THREADS);
@@ -706,13 +711,12 @@
 		int numprocs = 0;
 
 		// if the OSDPROCESSORS environment variable is set, use that value if valid
+		// note that we permit more than the real number of processors for testing
 		procsoverride = _tgetenv(_T("OSDPROCESSORS"));
 		if (procsoverride != NULL && _stscanf(procsoverride, _T("%d"), &numprocs) == 1 && numprocs > 0)
-			// Be well behaved ...
 			return MIN(info.dwNumberOfProcessors * 4, numprocs);
 
-		// max out at 4 for now since scaling above that seems to do poorly
-		return MIN(info.dwNumberOfProcessors, 4);
+		return info.dwNumberOfProcessors;
 	}
 }
 
diff -Nru src-old/tools/chdman.c src/tools/chdman.c
--- src-old/tools/chdman.c	2012-01-29 17:34:26.000000000 +0100
+++ src/tools/chdman.c	2012-02-19 16:23:23.000000000 +0100
@@ -39,11 +39,12 @@
 #include "corefile.h"
 #include "chdcd.h"
 #include "aviio.h"
-#include "avcomp.h"
+#include "avhuff.h"
 #include "bitmap.h"
 #include "md5.h"
 #include "sha1.h"
 #include "vbiparse.h"
+#include "tagmap.h"
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -51,3398 +52,2628 @@
 #include <ctype.h>
 #include <new>
 
-
-/***************************************************************************
-    CONSTANTS & DEFINES
-***************************************************************************/
-
-#define IDE_SECTOR_SIZE			512
-
-#define ENABLE_CUSTOM_CHOMP		0
-
-#define OPERATION_UPDATE		0
-#define OPERATION_MERGE			1
-#define OPERATION_CHOMP			2
-
-#ifdef PTR64
-#define IS_FAKE_AVI_FILE(a)		((UINT64)(a) <= 2)
+#ifdef _WIN32
+#define NUM_PROCESSORS_SUPPORTED 1
 #else
-#define IS_FAKE_AVI_FILE(a)		((UINT32)(a) <= 2)
+#define NUM_PROCESSORS_SUPPORTED 0
 #endif
-#define AVI_FAKE_FILE_22		((avi_file *)1)
-#define AVI_FAKE_FILE_32		((avi_file *)2)
 
-#define AVI_FAKE_FRAMERATE		29970000
-#define AVI_FAKE_FRAMES			54004
-#define AVI_FAKE_WIDTH			720
-#define AVI_FAKE_HEIGHT			524
-#define AVI_FAKE_CHANNELS		2
-#define AVI_FAKE_SAMPLERATE		48000
 
+//**************************************************************************
+//  CONSTANTS & DEFINES
+//**************************************************************************
+
+// default hard disk sector size
+const UINT32 IDE_SECTOR_SIZE = 512;
+
+// temporary input buffer size
+const UINT32 TEMP_BUFFER_SIZE = 32 * 1024 * 1024;
+
+// command modifier
+#define REQUIRED "~"
+
+// command strings
+#define COMMAND_HELP "help"
+#define COMMAND_INFO "info"
+#define COMMAND_VERIFY "verify"
+#define COMMAND_CREATE_RAW "createraw"
+#define COMMAND_CREATE_HD "createhd"
+#define COMMAND_CREATE_CD "createcd"
+#define COMMAND_CREATE_LD "createld"
+#define COMMAND_EXTRACT_RAW "extractraw"
+#define COMMAND_EXTRACT_HD "extracthd"
+#define COMMAND_EXTRACT_CD "extractcd"
+#define COMMAND_EXTRACT_LD "extractld"
+#define COMMAND_COPY "copy"
+#define COMMAND_ADD_METADATA "addmeta"
+#define COMMAND_DEL_METADATA "delmeta"
+
+// option strings
+#define OPTION_INPUT "input"
+#define OPTION_OUTPUT "output"
+#define OPTION_OUTPUT_BIN "outputbin"
+#define OPTION_OUTPUT_FORCE "force"
+#define OPTION_INPUT_START_BYTE "inputstartbyte"
+#define OPTION_INPUT_START_HUNK "inputstarthunk"
+#define OPTION_INPUT_START_FRAME "inputstartframe"
+#define OPTION_INPUT_LENGTH_BYTES "inputbytes"
+#define OPTION_INPUT_LENGTH_HUNKS "inputhunks"
+#define OPTION_INPUT_LENGTH_FRAMES "inputframes"
+#define OPTION_HUNK_SIZE "hunksize"
+#define OPTION_UNIT_SIZE "unitsize"
+#define OPTION_COMPRESSION "compression"
+#define OPTION_INPUT_PARENT "inputparent"
+#define OPTION_OUTPUT_PARENT "outputparent"
+#define OPTION_IDENT "ident"
+#define OPTION_CHS "chs"
+#define OPTION_SECTOR_SIZE "sectorsize"
+#define OPTION_TAG "tag"
+#define OPTION_INDEX "index"
+#define OPTION_VALUE_TEXT "valuetext"
+#define OPTION_VALUE_FILE "valuefile"
+#define OPTION_NO_CHECKSUM "nochecksum"
+#define OPTION_VERBOSE "verbose"
+#define OPTION_FIX "fix"
+#define OPTION_NUMPROCESSORS "numprocessors"
+
+
+
+//**************************************************************************
+//  FUNCTION PROTOTYPES
+//**************************************************************************
+
+typedef tagmap_t<astring *> parameters_t;
+
+static void report_error(int error, const char *format, ...);
+static void do_info(parameters_t &params);
+static void do_verify(parameters_t &params);
+static void do_create_raw(parameters_t &params);
+static void do_create_hd(parameters_t &params);
+static void do_create_cd(parameters_t &params);
+static void do_create_ld(parameters_t &params);
+static void do_copy(parameters_t &params);
+static void do_extract_raw(parameters_t &params);
+static void do_extract_cd(parameters_t &params);
+static void do_extract_ld(parameters_t &params);
+static void do_add_metadata(parameters_t &params);
+static void do_del_metadata(parameters_t &params);
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> option_description
+
+struct option_description
+{
+	const char *name;
+	const char *shortname;
+	bool parameter;
+	const char *description;
+};
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+// ======================> command_description
 
-struct _chd_interface_file
+struct command_description
 {
-	osd_file *file;
-	UINT64 length;
+	const char *name;
+	void (*handler)(parameters_t &);
+	const char *description;
+	const char *valid_options[16];
 };
 
 
+// ======================> avi_info
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-static chd_error chdman_compress_file(chd_file *chd, const char *rawfile, UINT32 offset);
-static chd_error chdman_compress_chd(chd_file *chd, chd_file *source, UINT32 totalhunks);
-static chd_error chdman_clone_metadata(chd_file *source, chd_file *dest);
-
-
-
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
-
-static clock_t lastprogress = 0;
-
-
-
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    print_big_int - 64-bit int printing with
-    commas
--------------------------------------------------*/
-
-static void print_big_int(UINT64 intvalue, char *output)
-{
-	int chunk;
-
-	chunk = intvalue % 1000;
-	intvalue /= 1000;
-	if (intvalue != 0)
-	{
-		print_big_int(intvalue, output);
-		strcat(output, ",");
-		sprintf(&output[strlen(output)], "%03d", chunk);
-	}
-	else
-		sprintf(&output[strlen(output)], "%d", chunk);
-}
+struct avi_info
+{
+	UINT32 fps_times_1million;
+	UINT32 width;
+	UINT32 height;
+	bool interlaced;
+	UINT32 channels;
+	UINT32 rate;
+	UINT32 max_samples_per_frame;
+	UINT32 bytes_per_frame;
+};
 
 
-/*-------------------------------------------------
-    big_int_string - return a string for a big
-    integer
--------------------------------------------------*/
+// ======================> metadata_index_info
 
-static char *big_int_string(UINT64 intvalue)
+struct metadata_index_info
 {
-	static char buffer[256];
-	buffer[0] = 0;
-	print_big_int(intvalue, buffer);
-	return buffer;
-}
+	chd_metadata_tag	tag;
+	UINT32				index;
+};
 
 
-/*-------------------------------------------------
-    progress - generic progress callback
--------------------------------------------------*/
+// ======================> fatal_error
 
-static void ATTR_PRINTF(2,3) progress(int forceit, const char *fmt, ...)
+class fatal_error : public std::exception
 {
-	clock_t curtime = clock();
-	va_list arg;
+public:
+	fatal_error(int error)
+		: m_error(error) { }
 
-	/* skip if it hasn't been long enough */
-	if (!forceit && curtime - lastprogress < CLOCKS_PER_SEC / 2)
-		return;
-	lastprogress = curtime;
+	int error() const { return m_error; }
 
-	/* standard vfprintf stuff here */
-	va_start(arg, fmt);
-	vfprintf(stderr, fmt, arg);
-	fflush(stderr);
-	va_end(arg);
-}
+private:
+	int m_error;
+};
 
 
-/*-------------------------------------------------
-    usage - generic usage error display
--------------------------------------------------*/
-
-static int usage(void)
-{
-	printf("usage: chdman -info input.chd\n");
-	printf("   or: chdman -createraw inputhd.raw output.chd [inputoffs [hunksize]]\n");
-	printf("   or: chdman -createhd inputhd.raw output.chd [ident.bin] [inputoffs [cylinders heads sectors [sectorsize [hunksize]]]]\n");
-	printf("   or: chdman -createuncomphd inputhd.raw output.chd [ident.bin] [inputoffs [cylinders heads sectors [sectorsize [hunksize]]]]\n");
-	printf("   or: chdman -createblankhd output.chd cylinders heads sectors [sectorsize [hunksize]]\n");
-	printf("   or: chdman -createcd input.(toc/cue/nrg/gdi) output.chd\n");
-	printf("   or: chdman -createav input.avi output.chd [firstframe [numframes]]\n");
-	printf("   or: chdman -copydata input.chd output.chd\n");
-	printf("   or: chdman -extract input.chd output.raw\n");
-	printf("   or: chdman -extractcd input.chd output.(toc/cue) output.bin (if toc, no extension if cue)\n");
-	printf("   or: chdman -extractav input.chd output.avi [firstframe [numframes]]\n");
-	printf("   or: chdman -verify input.chd\n");
-	printf("   or: chdman -verifyfix input.chd\n");
-	printf("   or: chdman -update input.chd output.chd\n");
-	printf("   or: chdman -chomp inout.chd output.chd maxhunk\n");
-	printf("   or: chdman -merge parent.chd diff.chd output.chd\n");
-	printf("   or: chdman -diff parent.chd compare.chd diff.chd\n");
-	printf("   or: chdman -setchs inout.chd cylinders heads sectors\n");
-	printf("   or: chdman -fixavdata inout.chd\n");
-	printf("   or: chdman -addmetabin inout.chd tag [index] sourcefile\n");
-	printf("   or: chdman -addmetatext inout.chd tag [index] sourcefile\n");
-	return 1;
-}
+// ======================> chd_rawfile_compressor
 
+class chd_rawfile_compressor : public chd_file_compressor
+{
+public:
+	// construction/destruction
+	chd_rawfile_compressor(core_file *file, UINT64 offset = 0, UINT64 maxoffset = ~0)
+		: m_file(file),
+		  m_offset(offset),
+		  m_maxoffset(MIN(maxoffset, (file != NULL) ? core_fsize(file) : 0)) { }
+
+	// read interface
+	virtual UINT32 read_data(void *dest, UINT64 offset, UINT32 length)
+	{
+		offset += m_offset;
+		if (offset >= m_maxoffset)
+			return 0;
+		if (offset + length > m_maxoffset)
+			length = m_maxoffset - offset;
+		core_fseek(m_file, offset, SEEK_SET);
+		return core_fread(m_file, dest, length);
+	}
+
+private:
+	// internal state
+	core_file *		m_file;
+	UINT64			m_offset;
+	UINT64			m_maxoffset;
+};
 
-/*-------------------------------------------------
-    get_file_size - get the size of a file
--------------------------------------------------*/
 
-static UINT64 get_file_size(const char *filename)
-{
-	osd_file *file;
-	UINT64 filesize = 0;
-	file_error filerr;
+// ======================> chd_chdfile_compressor
 
-	filerr = osd_open(filename, OPEN_FLAG_READ, &file, &filesize);
-	if (filerr == FILERR_NONE)
-		osd_close(file);
-	return filesize;
-}
+class chd_chdfile_compressor : public chd_file_compressor
+{
+public:
+	// construction/destruction
+	chd_chdfile_compressor(chd_file &file, UINT64 offset = 0, UINT64 maxoffset = ~0)
+		: m_file(file),
+		  m_offset(offset),
+		  m_maxoffset(MIN(maxoffset, file.logical_bytes())) { }
+
+	// read interface
+	virtual UINT32 read_data(void *dest, UINT64 offset, UINT32 length)
+	{
+		offset += m_offset;
+		if (offset >= m_maxoffset)
+			return 0;
+		if (offset + length > m_maxoffset)
+			length = m_maxoffset - offset;
+		chd_error err = m_file.read_bytes(offset, dest, length);
+		if (err != CHDERR_NONE)
+			throw err;
+		return length;
+	}
+
+private:
+	// internal state
+	chd_file &		m_file;
+	UINT64			m_offset;
+	UINT64			m_maxoffset;
+};
 
 
-/*-------------------------------------------------
-    guess_chs - given a file and an offset,
-    compute a best guess CHS value set
--------------------------------------------------*/
+// ======================> chd_cd_compressor
 
-static chd_error guess_chs(const char *filename, int offset, int sectorsize, UINT32 *cylinders, UINT32 *heads, UINT32 *sectors, UINT32 *bps)
+class chd_cd_compressor : public chd_file_compressor
 {
-	UINT32 totalsecs, hds, secs;
-	UINT64 filesize;
-
-	/* if this is a direct physical drive read, handle it specially */
-	if (osd_get_physical_drive_geometry(filename, cylinders, heads, sectors, bps))
-		return CHDERR_NONE;
+public:
+	// construction/destruction
+	chd_cd_compressor(cdrom_toc &toc, chdcd_track_input_info &info)
+		: m_file(NULL),
+		  m_toc(toc),
+		  m_info(info) { }
 
-	/* compute the filesize */
-	filesize = get_file_size(filename);
-	if (filesize <= offset)
+	~chd_cd_compressor()
 	{
-		fprintf(stderr, "Invalid file '%s'\n", filename);
-		return CHDERR_INVALID_FILE;
+		if (m_file != NULL)
+			core_fclose(m_file);
 	}
-	filesize -= offset;
 
-	/* validate the size */
-	if (filesize % sectorsize != 0)
+	// read interface
+	virtual UINT32 read_data(void *_dest, UINT64 offset, UINT32 length)
 	{
-		fprintf(stderr, "Can't guess CHS values because data size is not divisible by the sector size\n");
-		return CHDERR_INVALID_FILE;
-	}
-	totalsecs = filesize / sectorsize;
+		// verify assumptions made below
+		assert(offset % CD_FRAME_SIZE == 0);
+		assert(length % CD_FRAME_SIZE == 0);
 
-	/* now find a valid value */
-	for (secs = 63; secs > 1; secs--)
-		if (totalsecs % secs == 0)
-		{
-			size_t totalhds = totalsecs / secs;
-			for (hds = 16; hds > 1; hds--)
-				if (totalhds % hds == 0)
+		// initialize destination to 0 so that unused areas are filled
+		UINT8 *dest = reinterpret_cast<UINT8 *>(_dest);
+		memset(dest, 0, length);
+
+		// find out which track we're starting in
+		UINT64 startoffs = 0;
+		UINT32 length_remaining = length;
+		for (int tracknum = 0; tracknum < m_toc.numtrks; tracknum++)
+		{
+			const cdrom_track_info &trackinfo = m_toc.tracks[tracknum];
+			UINT64 endoffs = startoffs + (trackinfo.frames + trackinfo.extraframes) * CD_FRAME_SIZE;
+			if (offset >= startoffs && offset < endoffs)
+			{
+				// if we don't already have this file open, open it now
+				if (m_file == NULL || m_lastfile != m_info.track[tracknum].fname)
 				{
-					*cylinders = totalhds / hds;
-					*heads = hds;
-					*sectors = secs;
-					*bps = sectorsize;
-					return CHDERR_NONE;
+					if (m_file != NULL)
+						core_fclose(m_file);
+					m_lastfile = m_info.track[tracknum].fname;
+					file_error filerr = core_fopen(m_lastfile, OPEN_FLAG_READ, &m_file);
+					if (filerr != FILERR_NONE)
+						report_error(1, "Error opening input file (%s)'", m_lastfile.cstr());
 				}
-		}
-
-	/* ack, it didn't work! */
-	fprintf(stderr, "Can't guess CHS values because no logical combination works!\n");
-	return CHDERR_INVALID_FILE;
-}
 
+				// iterate over frames
+				UINT32 bytesperframe = trackinfo.datasize + trackinfo.subsize;
+				UINT64 src_track_start = m_info.track[tracknum].offset;
+				UINT64 src_track_end = src_track_start + bytesperframe * trackinfo.frames;
+				while (length_remaining != 0 && offset < endoffs)
+				{
+					// determine start of current frame
+					UINT64 src_frame_start = src_track_start + ((offset - startoffs) / CD_FRAME_SIZE) * bytesperframe;
+					if (src_frame_start < src_track_end)
+					{
+						// read it in
+						core_fseek(m_file, src_frame_start, SEEK_SET);
+						UINT32 count = core_fread(m_file, dest, bytesperframe);
+						if (count != bytesperframe)
+							report_error(1, "Error reading input file (%s)'", m_lastfile.cstr());
+
+						// swap if appropriate
+						if (m_info.track[tracknum].swap)
+							for (UINT32 swapindex = 0; swapindex < 2352; swapindex += 2)
+							{
+								UINT8 temp = dest[swapindex];
+								dest[swapindex] = dest[swapindex + 1];
+								dest[swapindex + 1] = temp;
+							}
+					}
 
-/*-------------------------------------------------
-    get_chs_from_ident - extract chs from an ident
-    information, validate it with the file size
-
-    Note: limited to IDE for now
--------------------------------------------------*/
-
-static chd_error get_chs_from_ident(const char *filename, int offset, const UINT8 *ident, UINT32 identsize, UINT32 *cylinders, UINT32 *heads, UINT32 *sectors, UINT32 *bps)
-{
-	UINT64 filesize, expected_size;
+					// advance
+					offset += CD_FRAME_SIZE;
+					dest += CD_FRAME_SIZE;
+					length_remaining -= CD_FRAME_SIZE;
+					if (length_remaining == 0)
+						break;
+				}
+			}
 
-	filesize = get_file_size(filename);
-	if (filesize <= offset)
-	{
-		fprintf(stderr, "Invalid file '%s'\n", filename);
-		return CHDERR_INVALID_FILE;
+			// next track starts after the previous one
+			startoffs = endoffs;
+		}
+		return length - length_remaining;
 	}
 
-	if (filesize % 512 != 0)
-	{
-		fprintf(stderr, "Can't validate CHS values because data size is not divisible by the sector size\n");
-		return CHDERR_INVALID_FILE;
-	}
+private:
+	// internal state
+	astring						m_lastfile;
+	core_file *					m_file;
+	cdrom_toc &					m_toc;
+	chdcd_track_input_info &	m_info;
+};
 
-	if (identsize < 14)
-	{
-		fprintf(stderr, "Error: the ident metadata is too short to include geometry information\n");
-		return CHDERR_INVALID_FILE;
-	}
 
-	*bps = 512;
-	*cylinders = ((unsigned char)ident[ 2]) | (((unsigned char )ident[ 3]) << 8);
-	*heads     = ((unsigned char)ident[ 6]) | (((unsigned char )ident[ 7]) << 8);
-	*sectors   = ((unsigned char)ident[12]) | (((unsigned char )ident[13]) << 8);
+// ======================> chd_avi_compressor
 
-	expected_size = (UINT64)*cylinders * (UINT64)*heads * (UINT64)*sectors * 512;
-	if (expected_size != filesize - offset)
-	{
-		fprintf(stderr, "Error: Mismatch between the ident CHS data (%u/%u/%u, %u sectors) and the file size (%u sectors)\n",
-				*cylinders, *heads, *sectors, *cylinders * *heads * *sectors,
-				(UINT32)((filesize-offset)/512));
-		return CHDERR_INVALID_FILE;
-	}
-	return CHDERR_NONE;
-}
+class chd_avi_compressor : public chd_file_compressor
+{
+public:
+	// construction/destruction
+	chd_avi_compressor(avi_file &file, avi_info &info, UINT32 first_frame, UINT32 num_frames)
+		: m_file(file),
+		  m_info(info),
+		  m_bitmap(info.width, info.height * (info.interlaced ? 2 : 1)),
+		  m_start_frame(first_frame),
+		  m_frame_count(num_frames),
+		  m_ldframedata(num_frames * VBI_PACKED_BYTES),
+		  m_rawdata(info.bytes_per_frame) { }
+
+	// getters
+	const dynamic_buffer &ldframedata() const { return m_ldframedata; }
+
+	// read interface
+	virtual UINT32 read_data(void *_dest, UINT64 offset, UINT32 length)
+	{
+		UINT8 *dest = reinterpret_cast<UINT8 *>(_dest);
+		int interlace_factor = m_info.interlaced ? 2 : 1;
+		UINT32 length_remaining = length;
+
+		// iterate over frames
+		INT32 start_frame = offset / m_info.bytes_per_frame;
+		INT32 end_frame = (offset + length - 1) / m_info.bytes_per_frame;
+		for (INT32 framenum = start_frame; framenum <= end_frame; framenum++)
+			if (framenum < m_frame_count)
+			{
+				// determine effective frame number and first/last samples
+				INT32 effframe = m_start_frame + framenum;
+				UINT32 first_sample = (UINT64(m_info.rate) * UINT64(effframe) * UINT64(1000000) + m_info.fps_times_1million - 1) / UINT64(m_info.fps_times_1million);
+				UINT32 samples = (UINT64(m_info.rate) * UINT64(effframe + 1) * UINT64(1000000) + m_info.fps_times_1million - 1) / UINT64(m_info.fps_times_1million) - first_sample;
+
+				// loop over channels and read the samples
+				int channels = MIN(m_info.channels, ARRAY_LENGTH(m_audio));
+				INT16 *samplesptr[ARRAY_LENGTH(m_audio)];
+				for (int chnum = 0; chnum < channels; chnum++)
+				{
+					// read the sound samples
+					m_audio[chnum].resize(samples);
+					samplesptr[chnum] = m_audio[chnum];
+					avi_error avierr = avi_read_sound_samples(&m_file, chnum, first_sample, samples, m_audio[chnum]);
+					if (avierr != AVIERR_NONE)
+						report_error(1, "Error reading audio samples %d-%d from channel %d: %s", first_sample, samples, chnum, avi_error_string(avierr));
+				}
 
+				// read the video data
+				avi_error avierr = avi_read_video_frame(&m_file, effframe / interlace_factor, m_bitmap);
+				if (avierr != AVIERR_NONE)
+					report_error(1, "Error reading AVI frame %d: %s", effframe / interlace_factor, avi_error_string(avierr));
+				bitmap_yuy16 subbitmap(&m_bitmap.pix(effframe % interlace_factor), m_bitmap.width(), m_bitmap.height() / interlace_factor, m_bitmap.rowpixels() * interlace_factor);
 
-/*-------------------------------------------------
-    do_createhd - create a new compressed hard
-    disk image from a raw file
--------------------------------------------------*/
+				// update metadata for this frame
+				if (m_info.height == 524/2 || m_info.height == 624/2)
+				{
+					vbi_metadata vbi;
+					vbi_parse_all(&subbitmap.pix16(0), subbitmap.rowpixels(), subbitmap.width(), 8, &vbi);
+					vbi_metadata_pack(&m_ldframedata[framenum * VBI_PACKED_BYTES], framenum, &vbi);
+				}
 
-static int do_createhd(int argc, char *argv[], int param)
-{
-	UINT32 guess_cylinders = 0, guess_heads = 0, guess_sectors = 0, guess_sectorsize = 0;
-	UINT32 cylinders, heads, sectors, sectorsize, hunksize, totalsectors, offset;
-	const char *inputfile, *outputfile = NULL;
-	chd_error err = CHDERR_NONE;
-	UINT32 identdatasize = 0;
-	UINT8 *identdata = NULL;
-	chd_file *chd = NULL;
-	char metadata[256];
+				// assemble the data into final form
+				avhuff_error averr = avhuff_encoder::assemble_data(m_rawdata, m_rawdata.count(), subbitmap, channels, samples, samplesptr);
+				if (averr != AVHERR_NONE)
+					report_error(1, "Error assembling data for frame %d", framenum);
+				UINT32 rawsize = avhuff_encoder::raw_data_size(m_rawdata);
+				if (rawsize < m_rawdata.count())
+					memset(&m_rawdata[rawsize], 0, m_rawdata.count() - rawsize);
+
+				// copy to the destination
+				UINT64 start_offset = UINT64(framenum) * UINT64(m_info.bytes_per_frame);
+				UINT64 end_offset = start_offset + m_info.bytes_per_frame;
+				UINT32 bytes_to_copy = MIN(length_remaining, end_offset - offset);
+				memcpy(dest, &m_rawdata[offset - start_offset], bytes_to_copy);
+
+				// advance
+				offset += bytes_to_copy;
+				dest += bytes_to_copy;
+				length_remaining -= bytes_to_copy;
+			}
+
+		return length;
+	}
+
+private:
+	// internal state
+	avi_file &					m_file;
+	avi_info &					m_info;
+	bitmap_yuy16				m_bitmap;
+	UINT32						m_start_frame;
+	UINT32						m_frame_count;
+	dynamic_array<INT16>		m_audio[8];
+	dynamic_buffer				m_ldframedata;
+	dynamic_buffer				m_rawdata;
+};
 
-	/* if a file is provided for argument 4 (ident filename), then shift the remaining arguments down */
-	if (argc >= 5)
-	{
-		char *scan;
 
-		/* if there are any non-digits in the 'offset', then treat it as a ident file */
-		for (scan = argv[4]; *scan != 0; scan++)
-			if (!isdigit((UINT8)*scan))
-				break;
-		if (*scan != 0)
-		{
-			/* attempt to load the file */
-			file_error filerr = core_fload(argv[4], (void **)&identdata, &identdatasize);
-			if (filerr != FILERR_NONE)
-			{
-				fprintf(stderr, "Error opening ident file '%s'\n", argv[4]);
-				return 1;
-			}
 
-			/* shift the remaining arguments down */
-			if (argc > 5)
-				memmove(&argv[4], &argv[5], (argc - 5) * sizeof(argv[0]));
-			argc--;
-		}
-	}
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-	/* require 4-5, or 8-10 args total */
-	if (argc != 4 && argc != 5 && argc != 8 && argc != 9 && argc != 10)
-		return usage();
+// timing
+static clock_t lastprogress = 0;
 
-	/* extract the first few parameters */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	offset = (argc >= 5) ? atoi(argv[4]) : (get_file_size(inputfile) % IDE_SECTOR_SIZE);
 
-	/* if less than 8 parameters, we need to guess the CHS values */
-	if (argc < 8)
-	{
-		if (identdata != NULL)
-			err = get_chs_from_ident(inputfile, offset, identdata, identdatasize, &guess_cylinders, &guess_heads, &guess_sectors, &guess_sectorsize);
-		else
-			err = guess_chs(inputfile, offset, IDE_SECTOR_SIZE, &guess_cylinders, &guess_heads, &guess_sectors, &guess_sectorsize);
-		if (err != CHDERR_NONE)
-			goto cleanup;
-	}
+// default compressors
+static const chd_codec_type s_default_raw_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN };
+static const chd_codec_type s_default_hd_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN };
+static const chd_codec_type s_default_cd_compression[4] = { CHD_CODEC_LZMA, CHD_CODEC_ZLIB, CHD_CODEC_HUFFMAN, CHD_CODEC_CD_FLAC };
+static const chd_codec_type s_default_ld_compression[4] = { CHD_CODEC_AVHUFF };
+
+
+// descriptions for each option
+static const option_description s_options[] =
+{
+	{ OPTION_INPUT, 				"i",	true, " <filename>: input file name" },
+	{ OPTION_INPUT_PARENT,			"ip",	true, " <filename>: parent file name for input CHD" },
+	{ OPTION_OUTPUT,				"o",	true, " <filename>: output file name" },
+	{ OPTION_OUTPUT_BIN,			"ob",	true, " <filename>: output file name for binary data" },
+	{ OPTION_OUTPUT_FORCE,			"f",	false, ": force overwriting an existing file" },
+	{ OPTION_OUTPUT_PARENT,			"op",	true, " <filename>: parent file name for output CHD" },
+	{ OPTION_INPUT_START_BYTE,		"isb",	true, " <offset>: starting byte offset within the input" },
+	{ OPTION_INPUT_START_HUNK,		"ish",	true, " <offset>: starting hunk offset within the input" },
+	{ OPTION_INPUT_START_FRAME,		"isf",	true, " <offset>: starting frame within the input" },
+	{ OPTION_INPUT_LENGTH_BYTES,	"ib",	true, " <length>: effective length of input in bytes" },
+	{ OPTION_INPUT_LENGTH_HUNKS,	"ih",	true, " <length>: effective length of input in hunks" },
+	{ OPTION_INPUT_LENGTH_FRAMES,	"if",	true, " <length>: effective length of input in frames" },
+	{ OPTION_HUNK_SIZE,				"hs",	true, " <bytes>: size of each hunk, in bytes" },
+	{ OPTION_UNIT_SIZE,				"us",	true, " <bytes>: size of each unit, in bytes" },
+	{ OPTION_COMPRESSION,			"c",	true, " <none|type1[,type2[,...]]>: which compression codecs to use (up to 4)" },
+	{ OPTION_IDENT,					"id",	true, " <filename>: name of ident file to provide CHS information" },
+	{ OPTION_CHS,					"chs",	true, " <cylinders,heads,sectors>: specifies CHS values directly" },
+	{ OPTION_SECTOR_SIZE,			"ss",	true, " <bytes>: size of each hard disk sector" },
+	{ OPTION_TAG,					"t",	true, " <tag>: 4-character tag for metadata" },
+	{ OPTION_INDEX,					"ix",	true, " <index>: indexed instance of this metadata tag" },
+	{ OPTION_VALUE_TEXT,			"vt",	true, " <text>: text for the metadata" },
+	{ OPTION_VALUE_FILE,			"vf",	true, " <file>: file containing data to add" },
+#if NUM_PROCESSORS_SUPPORTED
+	{ OPTION_NUMPROCESSORS,			"np",	true, " <processors>: limit the number of processors to use during compression" },
+#endif
+	{ OPTION_NO_CHECKSUM,			"nocs",	false, ": do not include this metadata information in the overall SHA-1" },
+	{ OPTION_FIX,					"f",	false, ": fix the SHA-1 if it is incorrect" },
+	{ OPTION_VERBOSE,				"v",	false, ": output additional information" },
+};
 
-	/* parse the remaining parameters */
-	cylinders = (argc >= 6) ? atoi(argv[5]) : guess_cylinders;
-	heads = (argc >= 7) ? atoi(argv[6]) : guess_heads;
-	sectors = (argc >= 8) ? atoi(argv[7]) : guess_sectors;
-	sectorsize = (argc >= 9) ? atoi(argv[8]) : guess_sectorsize;
-	if (sectorsize == 0) sectorsize = IDE_SECTOR_SIZE;
-	hunksize = (argc >= 10) ? atoi(argv[9]) : (sectorsize > 4096) ? sectorsize : ((4096 / sectorsize) * sectorsize);
-	totalsectors = cylinders * heads * sectors;
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-	printf("Input offset: %d\n", offset);
-	printf("Cylinders:    %d\n", cylinders);
-	printf("Heads:        %d\n", heads);
-	printf("Sectors:      %d\n", sectors);
-	printf("Bytes/sector: %d\n", sectorsize);
-	printf("Sectors/hunk: %d\n", hunksize / sectorsize);
-	printf("Logical size: %s\n", big_int_string((UINT64)totalsectors * (UINT64)sectorsize));
 
-	/* create the new hard drive */
-	err = chd_create(outputfile, (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_ZLIB_PLUS, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+// descriptions for each command
+static const command_description s_commands[] =
+{
+	{ COMMAND_INFO, do_info, ": displays information about a CHD",
+		{
+			REQUIRED OPTION_INPUT,
+			OPTION_VERBOSE
+		}
+	},
+
+	{ COMMAND_VERIFY, do_verify, ": verifies a CHD's integrity",
+		{
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT
+		}
+	},
+
+	{ COMMAND_CREATE_RAW, do_create_raw, ": create a raw CHD from the input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_PARENT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_START_BYTE,
+			OPTION_INPUT_START_HUNK,
+			OPTION_INPUT_LENGTH_BYTES,
+			OPTION_INPUT_LENGTH_HUNKS,
+			REQUIRED OPTION_HUNK_SIZE,
+			REQUIRED OPTION_UNIT_SIZE,
+			OPTION_COMPRESSION,
+#if NUM_PROCESSORS_SUPPORTED
+			OPTION_NUMPROCESSORS
+#endif
+		}
+	},
 
-	/* open the new hard drive */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+	{ COMMAND_CREATE_HD, do_create_hd, ": create a hard disk CHD from the input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_PARENT,
+			OPTION_OUTPUT_FORCE,
+			OPTION_INPUT,
+			OPTION_INPUT_START_BYTE,
+			OPTION_INPUT_START_HUNK,
+			OPTION_INPUT_LENGTH_BYTES,
+			OPTION_INPUT_LENGTH_HUNKS,
+			OPTION_HUNK_SIZE,
+			OPTION_COMPRESSION,
+			OPTION_IDENT,
+			OPTION_CHS,
+			OPTION_SECTOR_SIZE,
+#if NUM_PROCESSORS_SUPPORTED
+			OPTION_NUMPROCESSORS
+#endif
+		}
+	},
 
-	/* write the metadata */
-	sprintf(metadata, HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sectorsize);
-	err = chd_set_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error adding hard disk metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+	{ COMMAND_CREATE_CD, do_create_cd, ": create a CD CHD from the input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_PARENT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_HUNK_SIZE,
+			OPTION_COMPRESSION,
+#if NUM_PROCESSORS_SUPPORTED
+			OPTION_NUMPROCESSORS
+#endif
+		}
+	},
 
-	/* write the ident if present */
-	if (identdata != NULL)
-	{
-		err = chd_set_metadata(chd, HARD_DISK_IDENT_METADATA_TAG, 0, identdata, identdatasize, CHD_MDFLAGS_CHECKSUM);
-		if (err != CHDERR_NONE)
+	{ COMMAND_CREATE_LD, do_create_ld, ": create a laserdisc CHD from the input file",
 		{
-			fprintf(stderr, "Error adding hard disk metadata: %s\n", chd_error_string(err));
-			goto cleanup;
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_PARENT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_START_FRAME,
+			OPTION_INPUT_LENGTH_FRAMES,
+			OPTION_HUNK_SIZE,
+			OPTION_COMPRESSION,
+#if NUM_PROCESSORS_SUPPORTED
+			OPTION_NUMPROCESSORS
+#endif
 		}
-	}
+	},
 
-	/* compress the hard drive */
-	err = chdman_compress_file(chd, inputfile, offset);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
+	{ COMMAND_EXTRACT_RAW, do_extract_raw, ": extract raw file from a CHD input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT,
+			OPTION_INPUT_START_BYTE,
+			OPTION_INPUT_START_HUNK,
+			OPTION_INPUT_LENGTH_BYTES,
+			OPTION_INPUT_LENGTH_HUNKS
+		}
+	},
+
+	{ COMMAND_EXTRACT_HD, do_extract_raw, ": extract raw hard disk file from a CHD input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT,
+			OPTION_INPUT_START_BYTE,
+			OPTION_INPUT_START_HUNK,
+			OPTION_INPUT_LENGTH_BYTES,
+			OPTION_INPUT_LENGTH_HUNKS
+		}
+	},
+
+	{ COMMAND_EXTRACT_CD, do_extract_cd, ": extract CD file from a CHD input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_BIN,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT,
+		}
+	},
+
+	{ COMMAND_EXTRACT_LD, do_extract_ld, ": extract laserdisc AVI from a CHD input file",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT,
+			OPTION_INPUT_START_FRAME,
+			OPTION_INPUT_LENGTH_FRAMES
+		}
+	},
+
+	{ COMMAND_COPY, do_copy, ": copy data from one CHD to another of the same type",
+		{
+			REQUIRED OPTION_OUTPUT,
+			OPTION_OUTPUT_PARENT,
+			OPTION_OUTPUT_FORCE,
+			REQUIRED OPTION_INPUT,
+			OPTION_INPUT_PARENT,
+			OPTION_INPUT_START_BYTE,
+			OPTION_INPUT_START_HUNK,
+			OPTION_INPUT_LENGTH_BYTES,
+			OPTION_INPUT_LENGTH_HUNKS,
+			OPTION_HUNK_SIZE,
+			OPTION_COMPRESSION,
+#if NUM_PROCESSORS_SUPPORTED
+			OPTION_NUMPROCESSORS
+#endif
+		}
+	},
 
-cleanup:
-	/* close everything down */
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	if (identdata != NULL)
-		osd_free(identdata);
-	return (err != CHDERR_NONE);
-}
-
-/*-------------------------------------------------
-    do_createhd_uncomp - create a new uncompressed hard
-    disk image from a raw file
--------------------------------------------------*/
-
-static int do_createhd_uncomp(int argc, char *argv[], int param)
-{
-	UINT32 guess_cylinders = 0, guess_heads = 0, guess_sectors = 0, guess_sectorsize = 0;
-	UINT32 cylinders, heads, sectors, sectorsize, hunksize, totalsectors, offset;
-	const char *inputfile, *outputfile = NULL;
-	chd_error err = CHDERR_NONE;
-	UINT32 identdatasize = 0;
-	UINT8 *identdata = NULL;
-	chd_file *chd = NULL;
-	char metadata[256];
-	chd_header header;
-
-	/* if a file is provided for argument 4 (ident filename), then shift the remaining arguments down */
-	if (argc >= 5)
-	{
-		char *scan;
-
-		/* if there are any non-digits in the 'offset', then treat it as a ident file */
-		for (scan = argv[4]; *scan != 0; scan++)
-			if (!isdigit((UINT8)*scan))
-				break;
-		if (*scan != 0)
+	{ COMMAND_ADD_METADATA, do_add_metadata, ": add metadata to the CHD",
 		{
-			/* attempt to load the file */
-			file_error filerr = core_fload(argv[4], (void **)&identdata, &identdatasize);
-			if (filerr != FILERR_NONE)
-			{
-				fprintf(stderr, "Error opening ident file '%s'\n", argv[4]);
-				return 1;
-			}
+			REQUIRED OPTION_INPUT,
+			REQUIRED OPTION_TAG,
+			OPTION_INDEX,
+			OPTION_VALUE_TEXT,
+			OPTION_VALUE_FILE,
+			OPTION_NO_CHECKSUM
+		}
+	},
 
-			/* shift the remaining arguments down */
-			if (argc > 5)
-				memmove(&argv[4], &argv[5], (argc - 5) * sizeof(argv[0]));
-			argc--;
+	{ COMMAND_DEL_METADATA, do_del_metadata, ": remove metadata from the CHD",
+		{
+			REQUIRED OPTION_INPUT,
+			REQUIRED OPTION_TAG,
+			OPTION_INDEX
 		}
 	}
+};
 
-	/* require 4-5, or 8-10 args total */
-	if (argc != 4 && argc != 5 && argc != 8 && argc != 9 && argc != 10)
-		return usage();
 
-	/* extract the first few parameters */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	offset = (argc >= 5) ? atoi(argv[4]) : (get_file_size(inputfile) % IDE_SECTOR_SIZE);
 
-	/* if less than 8 parameters, we need to guess the CHS values */
-	if (argc < 8)
-	{
-		if (identdata != NULL)
-			err = get_chs_from_ident(inputfile, offset, identdata, identdatasize, &guess_cylinders, &guess_heads, &guess_sectors, &guess_sectorsize);
-		else
-			err = guess_chs(inputfile, offset, IDE_SECTOR_SIZE, &guess_cylinders, &guess_heads, &guess_sectors, &guess_sectorsize);
-		if (err != CHDERR_NONE)
-			goto cleanup;
-	}
+//**************************************************************************
+//  IMPLEMENTATION
+//**************************************************************************
 
-	/* parse the remaining parameters */
-	cylinders = (argc >= 6) ? atoi(argv[5]) : guess_cylinders;
-	heads = (argc >= 7) ? atoi(argv[6]) : guess_heads;
-	sectors = (argc >= 8) ? atoi(argv[7]) : guess_sectors;
-	sectorsize = (argc >= 9) ? atoi(argv[8]) : guess_sectorsize;
-	if (sectorsize == 0) sectorsize = IDE_SECTOR_SIZE;
-	hunksize = (argc >= 10) ? atoi(argv[9]) : (sectorsize > 4096) ? sectorsize : ((4096 / sectorsize) * sectorsize);
-	totalsectors = cylinders * heads * sectors;
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-	printf("Input offset: %d\n", offset);
-	printf("Cylinders:    %d\n", cylinders);
-	printf("Heads:        %d\n", heads);
-	printf("Sectors:      %d\n", sectors);
-	printf("Bytes/sector: %d\n", sectorsize);
-	printf("Sectors/hunk: %d\n", hunksize / sectorsize);
-	printf("Logical size: %s\n", big_int_string((UINT64)totalsectors * (UINT64)sectorsize));
+//-------------------------------------------------
+//  report_error - report an error
+//-------------------------------------------------
 
-	/* create the new hard drive */
-	err = chd_create(outputfile, (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_NONE, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+static void report_error(int error, const char *format, ...)
+{
+	// output to stderr
+	va_list arg;
+	va_start(arg, format);
+	vfprintf(stderr, format, arg);
+	fflush(stderr);
+	va_end(arg);
+	fprintf(stderr, "\n");
 
-	/* open the new hard drive */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+	// reset time for progress and return the error
+	lastprogress = 0;
+	throw fatal_error(error);
+}
 
-	/* write the metadata */
-	sprintf(metadata, HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sectorsize);
-	err = chd_set_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error adding hard disk metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
 
-	/* write the ident if present */
-	if (identdata != NULL)
-	{
-		err = chd_set_metadata(chd, HARD_DISK_IDENT_METADATA_TAG, 0, identdata, identdatasize, CHD_MDFLAGS_CHECKSUM);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error adding hard disk metadata: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
-	}
+//-------------------------------------------------
+//  progress - generic progress callback
+//-------------------------------------------------
 
-	/* compress the hard drive */
-	err = chdman_compress_file(chd, inputfile, offset);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
+static void ATTR_PRINTF(2,3) progress(bool forceit, const char *format, ...)
+{
+	// skip if it hasn't been long enough
+	clock_t curtime = clock();
+	if (!forceit && lastprogress != 0 && curtime - lastprogress < CLOCKS_PER_SEC / 2)
+		return;
+	lastprogress = curtime;
 
-	/* make it writeable */
-	header = *chd_get_header(chd);
-	header.flags |= CHDFLAGS_IS_WRITEABLE;
-	err = chd_set_header_file(chd_core_file(chd), &header);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error writing new header: %s\n", chd_error_string(err));
+	// standard vfprintf stuff here
+	va_list arg;
+	va_start(arg, format);
+	vfprintf(stderr, format, arg);
+	fflush(stderr);
+	va_end(arg);
+}
 
-cleanup:
-	/* close everything down */
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	if (identdata != NULL)
-		osd_free(identdata);
-	return (err != CHDERR_NONE);
-}
-
-/*-------------------------------------------------
-    do_createraw - create a new compressed raw
-    image from a raw file
--------------------------------------------------*/
-
-static int do_createraw(int argc, char *argv[], int param)
-{
-	const char *inputfile, *outputfile;
-	UINT32 hunksize, offset;
-	UINT64 logicalbytes;
-	chd_file *chd = NULL;
-	chd_error err;
 
-	/* require 4, 5, or 6 args total */
-	if (argc != 4 && argc != 5 && argc != 6)
-		return usage();
-
-	/* extract the first few parameters */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	offset = (argc >= 5) ? atoi(argv[4]) : 0;
-	hunksize = (argc >= 6) ? atoi(argv[5]) : 4096;
-	logicalbytes = get_file_size(inputfile) - offset;
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-	printf("Input offset: %d\n", offset);
-	printf("Bytes/hunk:   %d\n", hunksize);
-	printf("Logical size: %s\n", big_int_string(logicalbytes));
+//-------------------------------------------------
+//  print_help - print help for all the commands
+//-------------------------------------------------
 
-	/* create the new CHD */
-	err = chd_create(outputfile, logicalbytes, hunksize, CHDCOMPRESSION_ZLIB_PLUS, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+static int print_help(const char *argv0, const char *error = NULL)
+{
+	// print the error message first
+	if (error != NULL)
+		fprintf(stderr, "Error: %s\n\n", error);
 
-	/* open the new CHD */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
+	// print a summary of each command
+	printf("Usage:\n");
+	for (int cmdnum = 0; cmdnum < ARRAY_LENGTH(s_commands); cmdnum++)
 	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
+		const command_description &desc = s_commands[cmdnum];
+		printf("   %s %s%s\n", argv0, desc.name, desc.description);
 	}
+	printf("\nFor help with any command, run:\n");
+	printf("   %s %s <command>\n", argv0, COMMAND_HELP);
+	return 1;
+}
 
-	/* compress the CHD */
-	err = chdman_compress_file(chd, inputfile, offset);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
 
-cleanup:
-	/* close everything down */
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
+//-------------------------------------------------
+//  print_help - print help for all a specific
+//  command
+//-------------------------------------------------
+
+static int print_help(const char *argv0, const command_description &desc, const char *error = NULL)
+{
+	// print the error message first
+	if (error != NULL)
+		fprintf(stderr, "Error: %s\n\n", error);
+
+	// print usage for this command
+	printf("Usage:\n");
+	printf("   %s %s [options], where valid options are:\n", argv0, desc.name);
+	for (int valid = 0; valid < ARRAY_LENGTH(desc.valid_options); valid++)
+	{
+		// determine whether we are required
+		const char *option = desc.valid_options[valid];
+		if (option == NULL)
+			break;
+		bool required = (option[0] == REQUIRED[0]);
+		if (required)
+			option++;
+
+		// find the option
+		for (int optnum = 0; optnum < ARRAY_LENGTH(s_options); optnum++)
+			if (strcmp(option, s_options[optnum].name) == 0)
+			{
+				const option_description &odesc = s_options[optnum];
+				printf("      --%s", odesc.name);
+				if (odesc.shortname != NULL)
+					printf(", -%s", odesc.shortname);
+				printf("%s%s\n", odesc.description, required ? " (required)" : "");
+			}
+	}
+	return 1;
 }
 
 
-/*-------------------------------------------------
-    do_createcd - create a new compressed CD
-    image from a raw file
--------------------------------------------------*/
-
-static int do_createcd(int argc, char *argv[], int param)
-{
-	static chdcd_track_input_info track_info;
-	static cdrom_toc toc;
-	UINT32 hunksize = CD_FRAME_SIZE * CD_FRAMES_PER_HUNK;
-	UINT32 sectorsize = CD_FRAME_SIZE;
-	const char *inputfile, *outputfile;
-	core_file *srcfile = NULL;
-	UINT32 origtotalsectors;
-	chd_file *chd = NULL;
-	UINT8 *cache = NULL;
-	UINT32 totalsectors;
-	double ratio = 1.0;
-	UINT32 totalhunks;
-	file_error filerr;
-	chd_error err;
-	int i;
+//-------------------------------------------------
+//  big_int_string - create a 64-bit string
+//-------------------------------------------------
 
-	/* require 4 args total */
-	if (argc != 4)
-		return usage();
+const char *big_int_string(astring &string, UINT64 intvalue)
+{
+	// 0 is a special case
+	if (intvalue == 0)
+		return string.cpy("0");
 
-	/* extract the data */
-	inputfile = argv[2];
-	outputfile = argv[3];
+	// loop until all chunks are done
+	string.reset();
+	bool first = true;
+	while (intvalue != 0)
+	{
+		int chunk = intvalue % 1000;
+		intvalue /= 1000;
 
-	/* clear the TOC */
-	memset(&toc, 0, sizeof(toc));
+		astring insert;
+		insert.format((intvalue != 0) ? "%03d" : "%d", chunk);
 
-	/* allocate a cache */
-	cache = (UINT8 *)malloc(hunksize);
-	if (cache == NULL)
-	{
-		fprintf(stderr, "Out of memory allocating temporary buffer\n");
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
+		if (!first)
+			string.ins(0, ",");
+		first = false;
+		string.ins(0, insert);
 	}
+	return string;
+}
 
-	/* setup the CDROM module and get the disc info */
-	err = chdcd_parse_toc(inputfile, &toc, &track_info);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error reading input file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
 
-	/* pad each track to a hunk boundry. cdrom.c will deal with this on the read side */
-	for (i = 0; i < toc.numtrks; i++)
-	{
-		int hunks = (toc.tracks[i].frames + CD_FRAMES_PER_HUNK - 1) / CD_FRAMES_PER_HUNK;
-		toc.tracks[i].extraframes = hunks * CD_FRAMES_PER_HUNK - toc.tracks[i].frames;
-	}
+//-------------------------------------------------
+//  msf_string_from_frames - output the given
+//  number of frames in M:S:F format
+//-------------------------------------------------
 
+const char *msf_string_from_frames(astring &string, UINT32 frames)
+{
+	return string.format("%02d:%02d:%02d", frames / (75 * 60), (frames / 75) % 60, frames % 75);
+}
 
-	/* count up the total number of frames */
-	origtotalsectors = totalsectors = 0;
-	for (i = 0; i < toc.numtrks; i++)
-	{
-		origtotalsectors += toc.tracks[i].frames;
-		totalsectors += toc.tracks[i].frames + toc.tracks[i].extraframes;
-	}
-	printf("\nCD-ROM %s has %d tracks and %d total frames\n", inputfile, toc.numtrks, origtotalsectors);
 
-	/* create the new CHD file */
-	if (param) err = chd_create(outputfile, (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_ZLIB_PLUS_WITH_FLAC, NULL);
-	else err = chd_create(outputfile, (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_ZLIB_PLUS, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+//-------------------------------------------------
+//  parse_number - parse a number string with an
+//  optional k/m/g suffix
+//-------------------------------------------------
 
-	/* open the new CHD file */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+UINT64 parse_number(const char *string)
+{
+	// 0-length string is 0
+	int length = strlen(string);
+	if (length == 0)
+		return 0;
 
-	/* write the metadata */
-	err = cdrom_write_metadata(chd, &toc);
-	if (err != CHDERR_NONE)
+	// scan forward over digits
+	UINT64 result = 0;
+	while (isdigit(*string))
 	{
-		fprintf(stderr, "Error adding CD-ROM metadata: %s\n", chd_error_string(err));
-		goto cleanup;
+		result = (result * 10) + (*string - '0');
+		string++;
 	}
 
-	/* begin state for writing */
-	err = chd_compress_begin(chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error compressing: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+	// handle multipliers
+	if (*string == 'k' || *string == 'K')
+		result *= 1024;
+	if (*string == 'm' || *string == 'M')
+		result *= 1024 * 1024;
+	if (*string == 'g' || *string == 'G')
+		result *= 1024 * 1024 * 1024;
 
-	/* loop over tracks */
-	totalhunks = 0;
-	for (i = 0; i < toc.numtrks; i++)
-	{
-		int frames = 0;
-		int bytespersector = toc.tracks[i].datasize + toc.tracks[i].subsize;
-		int trackhunks = (toc.tracks[i].frames + toc.tracks[i].extraframes) / CD_FRAMES_PER_HUNK;
-		UINT64 sourcefileoffset = track_info.offset[i];
-		int curhunk;
+	return result;
+}
 
-		/* open the input file for this track */
-		filerr = core_fopen(track_info.fname[i], OPEN_FLAG_READ, &srcfile);
-		if (filerr != FILERR_NONE)
-		{
-			fprintf(stderr, "Unable to open file: %s\n", track_info.fname[i]);
-			err = CHDERR_FILE_NOT_FOUND;
-			goto cleanup;
-		}
 
-		printf("Track %02d/%02d (%s:%d,%d frames,%d hunks,swap %d,pregap %d,postgap %d)\n", i+1, toc.numtrks, track_info.fname[i], track_info.offset[i], toc.tracks[i].frames, trackhunks, track_info.swap[i], toc.tracks[i].pregap, toc.tracks[i].postgap);
+//-------------------------------------------------
+//  guess_chs - given a file and an offset,
+//  compute a best guess CHS value set
+//-------------------------------------------------
 
-		/* loop over hunks */
-		for (curhunk = 0; curhunk < trackhunks; curhunk++, totalhunks++)
-		{
-			int secnum;
+static void guess_chs(astring *filename, UINT64 filesize, int sectorsize, UINT32 &cylinders, UINT32 &heads, UINT32 &sectors, UINT32 &bps)
+{
+	// if this is a direct physical drive read, handle it specially
+	if (filename != NULL && osd_get_physical_drive_geometry(*filename, &cylinders, &heads, &sectors, &bps))
+		return;
 
-			progress(FALSE, "Compressing hunk %d/%d... (ratio=%d%%)  \r", totalhunks, chd_get_header(chd)->totalhunks, (int)(ratio * 100));
+	// if we have no length to work with, we can't guess
+	if (filesize == 0)
+		report_error(1, "Can't guess CHS values because there is no input file");
 
-			/* loop over sectors in this hunk, reading the source data into a fixed start location */
-			/* relative to the start; we zero out the buffer ahead of time to ensure that unpopulated */
-			/* areas are cleared */
-			memset(cache, 0, hunksize);
-			for (secnum = 0; secnum < CD_FRAMES_PER_HUNK; secnum++)
-			{
-				if (frames < toc.tracks[i].frames)
-				{
-					core_fseek(srcfile, sourcefileoffset, SEEK_SET);
-					core_fread(srcfile, &cache[secnum * CD_FRAME_SIZE], bytespersector);
+	// validate the size
+	if (filesize % sectorsize != 0)
+		report_error(1, "Can't guess CHS values because data size is not divisible by %d", sectorsize);
+	;
 
-					if (track_info.swap[i])
+	// now find a valid value
+	for (UINT32 totalsectors = filesize / sectorsize; ; totalsectors++)
+		for (UINT32 cursectors = 63; cursectors > 1; cursectors--)
+			if (totalsectors % cursectors == 0)
+			{
+				UINT32 totalheads = totalsectors / cursectors;
+				for (UINT32 curheads = 16; curheads > 1; curheads--)
+					if (totalheads % curheads == 0)
 					{
-						int swapindex;
-
-						for (swapindex = 0; swapindex < 2352; swapindex += 2 )
-						{
-							int swapoffset = ( secnum * CD_FRAME_SIZE ) + swapindex;
-
-							int swaptemp = cache[ swapoffset ];
-							cache[ swapoffset ] = cache[ swapoffset + 1 ];
-							cache[ swapoffset + 1 ] = swaptemp;
-						}
+						cylinders = totalheads / curheads;
+						heads = curheads;
+						sectors = cursectors;
+						return;
 					}
-				}
-
-				sourcefileoffset += bytespersector;
-				frames++;
 			}
 
-			int is_half_hunk = 0;
-			if ((curhunk == trackhunks-1) && (toc.tracks[i].extraframes>3))
-				is_half_hunk = 1;
+	// ack, it didn't work!
+	report_error(1, "Can't guess CHS values because no logical combination works!");
+}
 
 
-			/* compress the current hunk */
+//-------------------------------------------------
+//  parse_input_chd_parameters - parse the
+//  standard set of input CHD parameters
+//-------------------------------------------------
 
-			err = chd_compress_hunk(chd, cache, &ratio, is_half_hunk);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
-				goto cleanup;
-			}
-		}
+static void parse_input_chd_parameters(const parameters_t &params, chd_file &input_chd, chd_file &input_parent_chd, bool writeable = false)
+{
+	// process input parent file
+	astring *input_chd_parent_str = params.find(OPTION_INPUT_PARENT);
+	if (input_chd_parent_str != NULL)
+	{
+		chd_error err = input_parent_chd.open(*input_chd_parent_str);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error opening parent CHD file (%s): %s", input_chd_parent_str->cstr(), chd_file::error_string(err));
+	}
 
-		/* close the file */
-		core_fclose(srcfile);
-		srcfile = NULL;
+	// process input file
+	astring *input_chd_str = params.find(OPTION_INPUT);
+	if (input_chd_str != NULL)
+	{
+		chd_error err = input_chd.open(*input_chd_str, writeable, input_parent_chd.opened() ? &input_parent_chd : NULL);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error opening CHD file (%s): %s", input_chd_str->cstr(), chd_file::error_string(err));
 	}
+}
 
-	/* cleanup */
-	err = chd_compress_finish(chd, TRUE);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression finalization: %s\n", chd_error_string(err));
-	else
-		progress(TRUE, "Compression complete ... final ratio = %d%%            \n", (int)(100.0 * ratio));
 
-cleanup:
-	if (cache != NULL)
-		free(cache);
-	if (srcfile != NULL)
-		core_fclose(srcfile);
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
+//-------------------------------------------------
+//  parse_input_start_end - parse input start/end
+//  parameters in a standard way
+//-------------------------------------------------
+
+static void parse_input_start_end(const parameters_t &params, UINT64 logical_size, UINT32 hunkbytes, UINT32 framebytes, UINT64 &input_start, UINT64 &input_end)
+{
+	// process start/end if we were provided an input CHD
+	input_start = 0;
+	input_end = logical_size;
+
+	// process input start
+	astring *input_start_byte_str = params.find(OPTION_INPUT_START_BYTE);
+	astring *input_start_hunk_str = params.find(OPTION_INPUT_START_HUNK);
+	astring *input_start_frame_str = params.find(OPTION_INPUT_START_FRAME);
+	if (input_start_byte_str != NULL)
+		input_start = parse_number(*input_start_byte_str);
+	if (input_start_hunk_str != NULL)
+		input_start = parse_number(*input_start_hunk_str) * hunkbytes;
+	if (input_start_frame_str != NULL)
+		input_start = parse_number(*input_start_frame_str) * framebytes;
+	if (input_start >= input_end)
+		report_error(1, "Input start offset greater than input file size");
+
+	// process input length
+	astring *input_length_bytes_str = params.find(OPTION_INPUT_LENGTH_BYTES);
+	astring *input_length_hunks_str = params.find(OPTION_INPUT_LENGTH_HUNKS);
+	astring *input_length_frames_str = params.find(OPTION_INPUT_LENGTH_FRAMES);
+	UINT64 input_length = input_end;
+	if (input_length_bytes_str != NULL)
+		input_length = parse_number(*input_length_bytes_str);
+	if (input_length_hunks_str != NULL)
+		input_length = parse_number(*input_length_hunks_str) * hunkbytes;
+	if (input_length_frames_str != NULL)
+		input_length = parse_number(*input_length_frames_str) * framebytes;
+	if (input_start + input_length < input_end)
+		input_end = input_start + input_length;
 }
 
 
-/*-------------------------------------------------
-    read_avi_frame - read an AVI frame
--------------------------------------------------*/
+//-------------------------------------------------
+//  check_existing_output_file - see if an output
+//  file already exists, and error if it does,
+//  unless --force is specified
+//-------------------------------------------------
 
-static avi_error read_avi_frame(avi_file *avi, UINT32 framenum, UINT32 first_sample, bitmap_yuy16 &fullbitmap, int interlaced, av_codec_compress_config *avconfig)
+static void check_existing_output_file(const parameters_t &params, const char *filename)
 {
-	const avi_movie_info *info = avi_get_movie_info(avi);
-	int interlace_factor = interlaced ? 2 : 1;
-	avi_error avierr = AVIERR_NONE;
-	int chnum;
-
-	/* loop over channels and read the samples */
-	for (chnum = 0; chnum < info->audio_channels; chnum++)
+	if (params.find(OPTION_OUTPUT_FORCE) == NULL)
 	{
-		/* read the sound samples */
-		avierr = avi_read_sound_samples(avi, chnum, first_sample, avconfig->samples, avconfig->audio[chnum]);
-		if (avierr != AVIERR_NONE)
-			goto cleanup;
+		core_file *file;
+		file_error filerr = core_fopen(filename, OPEN_FLAG_READ, &file);
+		if (filerr == FILERR_NONE)
+		{
+			core_fclose(file);
+			report_error(1, "Error: file already exists (%s)\nUse --force (or -f) to force overwriting", filename);
+		}
 	}
+}
+
 
-	/* read the video data when we hit a new frame */
-	if (framenum % interlace_factor == 0)
+//-------------------------------------------------
+//  parse_output_chd_parameters - parse the
+//  standard set of output CHD parameters
+//-------------------------------------------------
+
+static astring *parse_output_chd_parameters(const parameters_t &params, chd_file &output_parent_chd)
+{
+	// process output parent file
+	astring *output_chd_parent_str = params.find(OPTION_OUTPUT_PARENT);
+	if (output_chd_parent_str != NULL)
 	{
-		avierr = avi_read_video_frame(avi, framenum / interlace_factor, fullbitmap);
-		if (avierr != AVIERR_NONE)
-			goto cleanup;
+		chd_error err = output_parent_chd.open(*output_chd_parent_str);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error opening parent CHD file (%s): %s", output_chd_parent_str->cstr(), chd_file::error_string(err));
 	}
 
-	/* build the fake bitmap */
-	if (!interlaced)
-		avconfig->video.wrap(fullbitmap, fullbitmap.cliprect());
-	else
-		avconfig->video.wrap(&fullbitmap.pix16(framenum % interlace_factor), fullbitmap.width(), fullbitmap.height() / 2, fullbitmap.rowpixels() * 2);
-
-cleanup:
-	return avierr;
+	// process output file
+	astring *output_chd_str = params.find(OPTION_OUTPUT);
+	if (output_chd_str != NULL)
+		check_existing_output_file(params, *output_chd_str);
+	return output_chd_str;
 }
 
 
-/*-------------------------------------------------
-    fake_avi_frame - fake an AVI frame
--------------------------------------------------*/
+//-------------------------------------------------
+//  parse_hunk_size - parse the hunk_size
+//  parameter in a standard way
+//-------------------------------------------------
 
-static avi_error fake_avi_frame(avi_file *avi, UINT32 framenum, UINT32 first_sample, bitmap_yuy16 &fullbitmap, int interlaced, av_codec_compress_config *avconfig)
+static void parse_hunk_size(const parameters_t &params, UINT32 required_granularity, UINT32 &hunk_size)
 {
-	static int framecounter = 0;
-	int leftsamp = (framenum % 200 < 10) ? 10000 : 0;
-	int rightsamp = (framenum % 200 >= 100 && framenum % 200 < 110) ? 10000 : 0;
-	int interlace_factor = interlaced ? 2 : 1;
-	int chnum, sampnum, x, y;
-	int whiteflag, line1718;
-
-	/* reset framecounter to 1 on frame 0 */
-	if (framenum == 0)
-		framecounter = 1;
-
-	/* loop over channels and read the samples */
-	for (chnum = 0; chnum < AVI_FAKE_CHANNELS; chnum++)
+	astring *hunk_size_str = params.find(OPTION_HUNK_SIZE);
+	if (hunk_size_str != NULL)
 	{
-		int modcheck = AVI_FAKE_SAMPLERATE / ((chnum == 0) ? 110 : 220);
-		int samp = (chnum == 0) ? leftsamp : rightsamp;
-		INT16 *dest = avconfig->audio[chnum];
-
-		/* store them to the audio buffer */
-		for (sampnum = 0; sampnum < avconfig->samples; sampnum++)
-			*dest++ = ((first_sample + sampnum) % modcheck < modcheck / 2) ? samp : -samp;
+		hunk_size = parse_number(*hunk_size_str);
+		if (hunk_size < 16 || hunk_size > 1024 * 1024)
+			report_error(1, "Invalid hunk size");
+		if (hunk_size % required_granularity != 0)
+			report_error(1, "Hunk size is not an even multiple of %d", required_granularity);
 	}
-
-	/* determine what metadata we should generate */
-	whiteflag = line1718 = 0;
-	if (framenum < 2)
-	{
-		whiteflag = (framenum == 0);
-		line1718 = 0x88ffff;
-	}
-	else if (framenum >= AVI_FAKE_FRAMES * 2 - 2)
-	{
-		whiteflag = (framenum == AVI_FAKE_FRAMES * 2 - 2);
-		line1718 = 0x80eeee;
-	}
-	else
-	{
-		int effnum = framenum - 2;
-		if (avi == AVI_FAKE_FILE_22 && effnum % 2 == 0)
-			whiteflag = 1;
-		else if (avi == AVI_FAKE_FILE_32 && (effnum % 5 == 0 || effnum % 5 == 2))
-			whiteflag = 1;
-		if (whiteflag)
-		{
-			line1718 = 0xf80000 | (((framecounter / 10000) % 10) << 16) | (((framecounter / 1000) % 10) << 12) |
-						(((framecounter / 100) % 10) << 8) | (((framecounter / 10) % 10) << 4) | (framecounter % 10);
-			framecounter++;
-		}
-	}
-
-	/* build the fake bitmap */
-	if (!interlaced)
-		avconfig->video.wrap(fullbitmap, fullbitmap.cliprect());
-	else
-		avconfig->video.wrap(&fullbitmap.pix16(framenum % interlace_factor), fullbitmap.width(), fullbitmap.height() / 2, fullbitmap.rowpixels() * 2);
-
-	/* loop over the data and copy it to the cache */
-	for (y = 0; y < avconfig->video.height(); y++)
-	{
-		UINT16 *dest = &avconfig->video.pix16(y);
-
-		/* white flag? */
-		if (y == 11 && whiteflag)
-		{
-			for (x = 0; x < AVI_FAKE_WIDTH; x++)
-				*dest++ = (x > 10 && x < avconfig->video.width() - 10) ? 0xff80 : 0x0080;
-		}
-
-		/* line 17/18 */
-		else if ((y == 17 || y == 18) && line1718 != 0)
-		{
-			for (x = 0; x < avconfig->video.width(); x++)
-			{
-				UINT16 pixel = 0x0080;
-				if (x >= 20)
-				{
-					int bitnum = (x - 20) / 28;
-					if (bitnum < 24)
-					{
-						int bithalf = (x - (bitnum * 28 + 20)) / 14;
-						if ((line1718 << bitnum) & 0x800000) bithalf ^= 1;
-						pixel = bithalf ? 0x0080 : 0xff80;
-					}
-				}
-				*dest++ = pixel;
-			}
-		}
-
-		/* anything else in VBI-land */
-		else if (y < 22)
-		{
-			for (x = 0; x < avconfig->video.width(); x++)
-				*dest++ = 0x0080;
-		}
-
-		/* everything else */
-		else
-		{
-			for (x = 0; x < avconfig->video.width(); x++)
-				*dest++ = framenum;
-		}
-	}
-
-	return AVIERR_NONE;
-}
-
-
-/*-------------------------------------------------
-    do_createav - create a new A/V file from an
-    input AVI file and metadata
--------------------------------------------------*/
-
-static int do_createav(int argc, char *argv[], int param)
-{
-	UINT32 fps_times_1million, width, height, interlaced, channels, rate, totalframes;
-	UINT32 max_samples_per_frame, bytes_per_frame, firstframe, numframes;
-	av_codec_compress_config avconfig;
-	const char *inputfile, *outputfile;
-	const avi_movie_info *info;
-	UINT8 *ldframedata = NULL;
-	const chd_header *header;
-	chd_file *chd = NULL;
-	avi_file *avi = NULL;
-	double ratio = 1.0;
-	char metadata[256];
-	avi_error avierr;
-	UINT32 framenum;
-	chd_error err;
-	int chnum;
-
-	/* require 4-6 args total */
-	if (argc < 4 || argc > 6)
-		return usage();
-
-	/* extract the first few parameters */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	firstframe = (argc > 4) ? atoi(argv[4]) : 0;
-	numframes = (argc > 5) ? atoi(argv[5]) : 1000000;
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-
-	/* special AVI files */
-	if (strcmp(inputfile, "2:2") == 0 || strcmp(inputfile, "3:2") == 0)
-	{
-		/* create a fake handle */
-		avi = (strcmp(inputfile, "2:2") == 0) ? AVI_FAKE_FILE_22 : AVI_FAKE_FILE_32;
-
-		/* fake the movie information */
-		fps_times_1million = AVI_FAKE_FRAMERATE;
-		width = AVI_FAKE_WIDTH;
-		height = AVI_FAKE_HEIGHT;
-		interlaced = TRUE;
-		channels = 2;
-		rate = AVI_FAKE_SAMPLERATE;
-		totalframes = AVI_FAKE_FRAMES;
-	}
-	else
-	{
-		/* open the source file */
-		avierr = avi_open(inputfile, &avi);
-		if (avierr != AVIERR_NONE)
-		{
-			fprintf(stderr, "Error opening AVI file: %s\n", avi_error_string(avierr));
-			err = CHDERR_INVALID_FILE;
-			goto cleanup;
-		}
-
-		/* get the movie information */
-		info = avi_get_movie_info(avi);
-		fps_times_1million = (UINT64)info->video_timescale * 1000000 / info->video_sampletime;
-		width = info->video_width;
-		height = info->video_height;
-		interlaced = ((fps_times_1million / 1000000) <= 30) && (height % 2 == 0) && (height > 288);
-		channels = info->audio_channels;
-		rate = info->audio_samplerate;
-		totalframes = info->video_numsamples;
-	}
-	numframes = MIN(totalframes - firstframe, numframes);
-
-	/* print some of it */
-	printf("Use frames:   %d-%d\n", firstframe, firstframe + numframes - 1);
-	printf("Frame rate:   %d.%06d\n", fps_times_1million / 1000000, fps_times_1million % 1000000);
-	printf("Frame size:   %d x %d %s\n", width, height, interlaced ? "interlaced" : "non-interlaced");
-	printf("Audio:        %d channels at %d Hz\n", channels, rate);
-	printf("Total frames: %d (%02d:%02d:%02d)\n", totalframes,
-			(UINT32)((UINT64)totalframes * 1000000 / fps_times_1million / 60 / 60),
-			(UINT32)(((UINT64)totalframes * 1000000 / fps_times_1million / 60) % 60),
-			(UINT32)(((UINT64)totalframes * 1000000 / fps_times_1million) % 60));
-
-	/* adjust for interlacing */
-	if (interlaced)
-	{
-		fps_times_1million *= 2;
-		totalframes *= 2;
-		height /= 2;
-		firstframe *= 2;
-		numframes *= 2;
-	}
-
-	/* allocate space for the frame data */
-	if (height == 524/2 || height == 624/2)
-	{
-		ldframedata = (UINT8 *)malloc(numframes * VBI_PACKED_BYTES);
-		if (ldframedata == NULL)
-		{
-			fprintf(stderr, "Out of memory allocating frame metadata\n");
-			err = CHDERR_OUT_OF_MEMORY;
-			goto cleanup;
-		}
-		memset(ldframedata, 0, numframes * VBI_PACKED_BYTES);
-	}
-
-	/* determine the number of bytes per frame */
-	max_samples_per_frame = ((UINT64)rate * 1000000 + fps_times_1million - 1) / fps_times_1million;
-	bytes_per_frame = 12 + channels * max_samples_per_frame * 2 + width * height * 2;
-
-	/* allocate a video buffer */
-	{
-		bitmap_yuy16 fullbitmap(width, height * (interlaced ? 2 : 1));
-		avconfig.video.wrap(fullbitmap, fullbitmap.cliprect());
-
-		/* allocate audio buffers */
-		avconfig.channels = channels;
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			avconfig.audio[chnum] = (INT16 *)malloc(max_samples_per_frame * 2);
-			if (avconfig.audio[chnum] == NULL)
-			{
-				fprintf(stderr, "Out of memory allocating temporary audio buffer\n");
-				err = CHDERR_OUT_OF_MEMORY;
-				goto cleanup;
-			}
-		}
-
-		/* create the new CHD */
-		err = chd_create(outputfile, (UINT64)numframes * (UINT64)bytes_per_frame, bytes_per_frame, CHDCOMPRESSION_AV, NULL);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
-
-		/* open the new CHD */
-		err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
-		header = chd_get_header(chd);
-
-		/* write the metadata */
-		sprintf(metadata, AV_METADATA_FORMAT, fps_times_1million / 1000000, fps_times_1million % 1000000, width, height, interlaced, channels, rate);
-		err = chd_set_metadata(chd, AV_METADATA_TAG, 0, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error adding AV metadata: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
-
-		/* begin compressing */
-		err = chd_compress_begin(chd);
-		if (err != CHDERR_NONE)
-			goto cleanup;
-
-		/* loop over source hunks until we run out */
-		for (framenum = 0; framenum < numframes; framenum++)
-		{
-			int effframe = firstframe + framenum;
-			UINT32 first_sample;
-
-			/* progress */
-			progress(framenum == 0, "Compressing hunk %d/%d... (ratio=%d%%)  \r", framenum, header->totalhunks, (int)(100.0 * ratio));
-
-			/* compute the number of samples in this frame */
-			first_sample = ((UINT64)rate * (UINT64)effframe * (UINT64)1000000 + fps_times_1million - 1) / (UINT64)fps_times_1million;
-			avconfig.samples = ((UINT64)rate * (UINT64)(effframe + 1) * (UINT64)1000000 + fps_times_1million - 1) / (UINT64)fps_times_1million - first_sample;
-
-			/* read the frame into its proper format in the cache */
-			if (IS_FAKE_AVI_FILE(avi))
-				avierr = fake_avi_frame(avi, effframe, first_sample, fullbitmap, interlaced, &avconfig);
-			else
-				avierr = read_avi_frame(avi, effframe, first_sample, fullbitmap, interlaced, &avconfig);
-			if (avierr != AVIERR_NONE)
-			{
-				fprintf(stderr, "Error reading frame %d from AVI file: %s\n", effframe, avi_error_string(avierr));
-				err = CHDERR_COMPRESSION_ERROR;
-			}
-
-			/* update metadata for this frame */
-			if (ldframedata != NULL)
-			{
-				/* parse the data and pack it */
-				vbi_metadata vbi;
-				vbi_parse_all(&avconfig.video.pix16(0), avconfig.video.rowpixels(), avconfig.video.width(), 8, &vbi);
-				vbi_metadata_pack(&ldframedata[framenum * VBI_PACKED_BYTES], framenum, &vbi);
-			}
-
-			/* configure the compressor for this frame */
-			chd_codec_config(chd, AV_CODEC_COMPRESS_CONFIG, &avconfig);
-
-			/* append the data */
-			err = chd_compress_hunk(chd, NULL, &ratio);
-			if (err != CHDERR_NONE)
-				goto cleanup;
-		}
-
-		/* write the final metadata */
-		if (ldframedata != NULL)
-		{
-			err = chd_set_metadata(chd, AV_LD_METADATA_TAG, 0, ldframedata, numframes * VBI_PACKED_BYTES, CHD_MDFLAGS_CHECKSUM);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error adding AVLD metadata: %s\n", chd_error_string(err));
-				goto cleanup;
-			}
-		}
-
-		/* finish compression */
-		err = chd_compress_finish(chd, TRUE);
-		if (err != CHDERR_NONE)
-			goto cleanup;
-		else
-			progress(TRUE, "Compression complete ... final ratio = %d%%            \n", (int)(100.0 * ratio));
-	}
-
-cleanup:
-	/* close everything down */
-	if (avi != NULL && !IS_FAKE_AVI_FILE(avi))
-		avi_close(avi);
-	if (chd != NULL)
-		chd_close(chd);
-	for (chnum = 0; chnum < ARRAY_LENGTH(avconfig.audio); chnum++)
-		if (avconfig.audio[chnum] != NULL)
-			free(avconfig.audio[chnum]);
-	if (ldframedata != NULL)
-		free(ldframedata);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_createblankhd - create a new non-compressed
-    hard disk image, with all hunks filled with 0s
--------------------------------------------------*/
-
-static int do_createblankhd(int argc, char *argv[], int param)
-{
-	UINT32 cylinders, heads, sectors, sectorsize, hunksize, totalsectors, hunknum;
-	const char *outputfile;
-	chd_file *chd = NULL;
-	UINT8 *cache = NULL;
-	char metadata[256];
-	chd_error err;
-
-	/* require 6, 7, or 8 args total */
-	if (argc != 6 && argc != 7 && argc != 8)
-		return usage();
-
-	/* extract the data */
-	outputfile = argv[2];
-	cylinders = atoi(argv[3]);
-	heads = atoi(argv[4]);
-	sectors = atoi(argv[5]);
-	sectorsize = (argc >= 7) ? atoi(argv[6]) : IDE_SECTOR_SIZE;
-	if (sectorsize == 0) sectorsize = IDE_SECTOR_SIZE;
-	hunksize = (argc >= 8) ? atoi(argv[7]) : (sectorsize > 4096) ? sectorsize : ((4096 / sectorsize) * sectorsize);
-	totalsectors = cylinders * heads * sectors;
-
-	/* print some info */
-	printf("Output file:  %s\n", outputfile);
-	printf("Cylinders:    %d\n", cylinders);
-	printf("Heads:        %d\n", heads);
-	printf("Sectors:      %d\n", sectors);
-	printf("Bytes/sector: %d\n", sectorsize);
-	printf("Sectors/hunk: %d\n", hunksize / sectorsize);
-	printf("Logical size: %s\n", big_int_string((UINT64)totalsectors * (UINT64)sectorsize));
-
-	/* create the new hard drive */
-	err = chd_create(outputfile, (UINT64)totalsectors * (UINT64)sectorsize, hunksize, CHDCOMPRESSION_NONE, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* open the new hard drive */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* write the metadata */
-	sprintf(metadata, HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sectorsize);
-	err = chd_set_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error adding hard disk metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* alloc and zero buffer*/
-	cache = (UINT8 *)malloc(hunksize);
-	if (cache == NULL)
-	{
-		fprintf(stderr, "Error allocating memory buffer\n");
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
-	}
-	memset(cache, 0, hunksize);
-
-	/* Zero every hunk */
-	for (hunknum = 0; hunknum < chd_get_header(chd)->totalhunks; hunknum++)
-	{
-		/* progress */
-		progress(hunknum == 0, "Zeroing hunk %d/%d...  \r", hunknum, chd_get_header(chd)->totalhunks);
-
-		/* write out the data */
-		err = chd_write(chd, hunknum, cache);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error writing CHD file: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
-	}
-	progress(TRUE, "Creation complete!                    \n");
-
-cleanup:
-	/* close everything down */
-	if (cache != NULL)
-		free(cache);
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_copydata - copy all hunks of data from one
-    CHD file to another. The hunk sizes do not
-    need to match. If the source is shorter than
-    the destination, the source data will be
-    padded with 0s.
--------------------------------------------------*/
-
-static int do_copydata(int argc, char *argv[], int param)
-{
-	const char *inputfile, *outputfile;
-	chd_file *outputchd = NULL;
-	chd_file *inputchd = NULL;
-	chd_error err;
-
-	/* require 4 args total */
-	if (argc != 4)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-	outputfile = argv[3];
-
-	/* print some info */
-	printf("Input file:  %s\n", inputfile);
-	printf("Output file: %s\n", outputfile);
-
-	/* open the src hard drive */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &inputchd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening src CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* open the dest hard drive */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &outputchd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening dest CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* compress the source into the dest */
-	err = chdman_compress_chd(outputchd, inputchd, 0);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
-
-cleanup:
-	/* close everything down */
-	if (outputchd != NULL)
-		chd_close(outputchd);
-	if (inputchd != NULL)
-		chd_close(inputchd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_extract - extract a raw file from a
-    CHD image
--------------------------------------------------*/
-
-static int do_extract(int argc, char *argv[], int param)
-{
-	const char *inputfile, *outputfile;
-	core_file *outfile = NULL;
-	chd_file *infile = NULL;
-	const chd_header *header;
-	UINT64 bytesremaining;
-	void *hunk = NULL;
-	file_error filerr;
-	chd_error err;
-	int hunknum;
-
-	/* require 4 args total */
-	if (argc != 4)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-	outputfile = argv[3];
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-
-	/* get the header */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &infile);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
-	}
-	header = chd_get_header(infile);
-
-	/* allocate memory to hold a hunk */
-	hunk = malloc(header->hunkbytes);
-	if (hunk == NULL)
-	{
-		fprintf(stderr, "Out of memory allocating hunk buffer!\n");
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
-	}
-
-	/* create the output file */
-	filerr = core_fopen(outputfile, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &outfile);
-	if (filerr != FILERR_NONE)
-	{
-		fprintf(stderr, "Error opening output file '%s'\n", outputfile);
-		err = CHDERR_CANT_CREATE_FILE;
-		goto cleanup;
-	}
-
-	/* loop over hunks, reading and writing */
-	bytesremaining = header->logicalbytes;
-	for (hunknum = 0; hunknum < header->totalhunks; hunknum++)
-	{
-		UINT32 byteswritten, bytes_to_write;
-
-		/* progress */
-		progress(hunknum == 0, "Extracting hunk %d/%d...  \r", hunknum, header->totalhunks);
-
-		/* read the hunk into a buffer */
-		err = chd_read(infile, hunknum, hunk);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error reading hunk %d from CHD file: %s\n", hunknum, chd_error_string(err));
-			goto cleanup;
-		}
-
-		/* write the hunk to the file */
-		bytes_to_write = MIN(bytesremaining, header->hunkbytes);
-		core_fseek(outfile, (UINT64)hunknum * (UINT64)header->hunkbytes, SEEK_SET);
-		byteswritten = core_fwrite(outfile, hunk, bytes_to_write);
-		if (byteswritten != bytes_to_write)
-		{
-			fprintf(stderr, "Error writing hunk %d to output file: %s\n", hunknum, chd_error_string(CHDERR_WRITE_ERROR));
-			err = CHDERR_WRITE_ERROR;
-			goto cleanup;
-		}
-		bytesremaining -= byteswritten;
-	}
-	progress(TRUE, "Extraction complete!                    \n");
-
-cleanup:
-	/* clean up our mess */
-	if (outfile != NULL)
-		core_fclose(outfile);
-	if (hunk != NULL)
-		free(hunk);
-	if (infile != NULL)
-		chd_close(infile);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_extractcd - extract a CDRDAO .toc/.bin
-    or CDRWIN .cue/.bin file from a CHD-CD image
--------------------------------------------------*/
-
-static int do_extractcd(int argc, char *argv[], int param)
-{
-	const char *inputfile, *outputfile, *outputfile2;
-	core_file *outfile2 = NULL;
-	chd_file *inputchd = NULL;
-	cdrom_file *cdrom = NULL;
-	FILE *outfile = NULL;
-	const cdrom_toc *toc;
-	UINT64 out2offs, discoffs;
-	file_error filerr;
-	chd_error err;
-	int track, cuemode;
-
-	/* require 5 args total */
-	if (argc != 5)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	outputfile2 = argv[4];
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output files:  %s and %s\n", outputfile, outputfile2);
-
-	/* get the header */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &inputchd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* open the CD */
-	cdrom = cdrom_open(inputchd);
-	if (cdrom == NULL)
-	{
-		fprintf(stderr, "Error opening CHD-CD '%s'\n", inputfile);
-		err = CHDERR_INVALID_FILE;
-		goto cleanup;
-	}
-
-	/* check for CDRWIN format */
-	cuemode = 0;
-	if (strstr(outputfile, ".cue"))
-	{
-		cuemode = 1;
-	}
-
-	/* get the TOC data */
-	toc = cdrom_get_toc(cdrom);
-
-	/* create the output files */
-	outfile = fopen(outputfile, "w");
-	if (outfile == NULL)
-	{
-		fprintf(stderr, "Error opening output file '%s'\n", outputfile);
-		err = CHDERR_CANT_CREATE_FILE;
-		goto cleanup;
-	}
-
-	if (!cuemode)
-	{
-		fprintf(outfile, "CD_ROM\n\n\n");
-	}
-
-	filerr = core_fopen(outputfile2, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &outfile2);
-	if (filerr != FILERR_NONE)
-	{
-		fprintf(stderr, "Error opening output file '%s'\n", outputfile2);
-		err = CHDERR_CANT_CREATE_FILE;
-		goto cleanup;
-	}
-
-	/* process away */
-	out2offs = 0;
-	discoffs = 0;
-	for (track = 0; track < toc->numtrks; track++)
-	{
-		UINT32 m, s, f, frame, trackframes;
-
-		progress(TRUE, "Extracting track %d...   \r", track+1);
-
-		trackframes = toc->tracks[track].frames;
-
-		if (cuemode)
-		{
-			char modestr[16];
-
-			if (track == 0)
-			{
-				fprintf(outfile, "FILE \"%s\" BINARY\n", outputfile2);
-			}
-
-			switch (toc->tracks[track].trktype)
-			{
-				case CD_TRACK_MODE1:
-				case CD_TRACK_MODE1_RAW:
-					sprintf(modestr, "MODE1/%04d", toc->tracks[track].datasize);
-					break;
-
-				case CD_TRACK_MODE2:
-				case CD_TRACK_MODE2_FORM1:
-				case CD_TRACK_MODE2_FORM2:
-				case CD_TRACK_MODE2_FORM_MIX:
-				case CD_TRACK_MODE2_RAW:
-					sprintf(modestr, "MODE2/%04d", toc->tracks[track].datasize);
-					break;
-
-				case CD_TRACK_AUDIO:
-					strcpy(modestr, "AUDIO");
-					break;
-			}
-
-			fprintf(outfile, "  TRACK %02d %s\n", track+1, modestr);
-
-			if (toc->tracks[track].pregap > 0)
-			{
-				f = toc->tracks[track].pregap;
-				s = f / 75;
-				f %= 75;
-				m = s / 60;
-				s %= 60;
-				fprintf(outfile, "    PREGAP %02d:%02d:%02d\n", m, s, f);
-			}
-
-			f = discoffs;
-			s = f / 75;
-			f %= 75;
-			m = s / 60;
-			s %= 60;
-			fprintf(outfile, "    INDEX 01 %02d:%02d:%02d\n", m, s, f);
-
-			if (toc->tracks[track].postgap > 0)
-			{
-				f = toc->tracks[track].postgap;
-				s = f / 75;
-				f %= 75;
-				m = s / 60;
-				s %= 60;
-				fprintf(outfile, "    POSTGAP %02d:%02d:%02d\n", m, s, f);
-			}
-		}
-		else
-		{
-			char modesubmode[64];
-
-			fprintf(outfile, "// Track %d\n", track+1);
-
-			/* write out the track type */
-			if (toc->tracks[track].subtype != CD_SUB_NONE)
-			{
-				sprintf(modesubmode, "%s %s", cdrom_get_type_string(toc->tracks[track].trktype), cdrom_get_subtype_string(toc->tracks[track].subtype));
-			}
-			else
-			{
-				sprintf(modesubmode, "%s", cdrom_get_type_string(toc->tracks[track].trktype));
-			}
-
-			fprintf(outfile, "TRACK %s\n", modesubmode);
-
-			/* write out the attributes */
-			fprintf(outfile, "NO COPY\n");
-			if (toc->tracks[track].trktype == CD_TRACK_AUDIO)
-			{
-				fprintf(outfile, "NO PRE_EMPHASIS\n");
-				fprintf(outfile, "TWO_CHANNEL_AUDIO\n");
-			}
-
-			if (toc->tracks[track].pregap > 0)
-			{
-				f = toc->tracks[track].pregap;
-				s = f / 75;
-				f %= 75;
-				m = s / 60;
-				s %= 60;
-
-				fprintf(outfile, "ZERO %s %02d:%02d:%02d\n", modesubmode, m, s, f);
-			}
-
-			/* convert to minutes/seconds/frames */
-			f = trackframes;
-			s = f / 75;
-			f %= 75;
-			m = s / 60;
-			s %= 60;
-
-			/* all tracks but the first one have a file offset */
-			if (track > 0)
-				fprintf(outfile, "DATAFILE \"%s\" #%d %02d:%02d:%02d // length in bytes: %d\n", outputfile2, (UINT32)out2offs, m, s, f, trackframes*(toc->tracks[track].datasize+toc->tracks[track].subsize));
-			else
-				fprintf(outfile, "DATAFILE \"%s\" %02d:%02d:%02d // length in bytes: %d\n", outputfile2, m, s, f, trackframes*(toc->tracks[track].datasize+toc->tracks[track].subsize));
-
-			/* tracks with pregaps get a START marker too */
-			if (toc->tracks[track].pregap > 0)
-			{
-				f = toc->tracks[track].pregap;
-				s = f / 75;
-				f %= 75;
-				m = s / 60;
-				s %= 60;
-
-				fprintf(outfile, "START %02d:%02d:%02d\n", m, s, f);
-			}
-
-			fprintf(outfile, "\n\n");
-		}
-
-		/* now write the actual data */
-		for (frame = 0; frame < trackframes; frame++)
-		{
-			UINT8 sector[CD_MAX_SECTOR_DATA + CD_MAX_SUBCODE_DATA];
-			UINT32 byteswritten;
-
-			progress(frame == 0, "Extracting track %d... %d/%d...   \r", track+1, frame, trackframes);
-
-			/* read the raw data */
-			cdrom_read_data(cdrom, cdrom_get_track_start(cdrom, track) + frame, sector, toc->tracks[track].trktype);
-
-			/* for CDRWin, audio tracks must be reversed */
-			if ((cuemode) && (toc->tracks[track].trktype == CD_TRACK_AUDIO))
-			{
-				int swapindex;
-
-				for (swapindex = 0; swapindex < toc->tracks[track].datasize; swapindex += 2)
-				{
-					UINT8 swaptemp = sector[swapindex];
-					sector[swapindex] = sector[swapindex+1];
-					sector[swapindex + 1] = swaptemp;
-				}
-			}
-
-			/* write it out */
-			core_fseek(outfile2, out2offs, SEEK_SET);
-			byteswritten = core_fwrite(outfile2, sector, toc->tracks[track].datasize);
-			if (byteswritten != toc->tracks[track].datasize)
-			{
-				fprintf(stderr, "Error writing frame %d to output file: %s\n", frame, chd_error_string(CHDERR_WRITE_ERROR));
-				err = CHDERR_WRITE_ERROR;
-				goto cleanup;
-			}
-			out2offs += toc->tracks[track].datasize;
-			discoffs++;
-
-			/* read the subcode data */
-			if (toc->tracks[track].subtype != CD_SUB_NONE)
-			{
-				cdrom_read_subcode(cdrom, cdrom_get_track_start(cdrom, track) + frame, sector);
-
-				/* write it out */
-				core_fseek(outfile2, out2offs, SEEK_SET);
-				byteswritten = core_fwrite(outfile2, sector, toc->tracks[track].subsize);
-				if (byteswritten != toc->tracks[track].subsize)
-				{
-					fprintf(stderr, "Error writing frame %d to output file: %s\n", frame, chd_error_string(CHDERR_WRITE_ERROR));
-					err = CHDERR_WRITE_ERROR;
-					goto cleanup;
-				}
-				out2offs += toc->tracks[track].subsize;
-			}
-		}
-		progress(TRUE, "Extracting track %d... complete         \n", track+1);
-	}
-	progress(TRUE, "Completed!\n");
-
-cleanup:
-	/* close everything down */
-	if (outfile != NULL)
-		fclose(outfile);
-	if (outfile2 != NULL)
-		core_fclose(outfile2);
-	if (cdrom != NULL)
-		cdrom_close(cdrom);
-	if (inputchd != NULL)
-		chd_close(inputchd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_extractav - extract an AVI file from a
-    CHD image
--------------------------------------------------*/
-
-static int do_extractav(int argc, char *argv[], int param)
-{
-	int fps, fpsfrac, width, height, interlaced, channels, rate, totalframes;
-	av_codec_decompress_config avconfig;
-	const char *inputfile, *outputfile;
-	UINT32 firstframe, numframes;
-	UINT32 framenum, numsamples;
-	UINT32 fps_times_1million;
-	const chd_header *header;
-	chd_file *chd = NULL;
-	avi_file *avi = NULL;
-	avi_movie_info info;
-	char metadata[256];
-	avi_error avierr;
-	chd_error err;
-	int chnum;
-
-	/* require 4-6 args total */
-	if (argc < 4 || argc > 6)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-	outputfile = argv[3];
-	firstframe = (argc > 4) ? atoi(argv[4]) : 0;
-	numframes = (argc > 5) ? atoi(argv[5]) : 1000000;
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-
-	/* get the header */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
-	}
-	header = chd_get_header(chd);
-
-	/* get the metadata */
-	err = chd_get_metadata(chd, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* extract the info */
-	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
-	{
-		fprintf(stderr, "Improperly formatted metadata\n");
-		err = CHDERR_INVALID_METADATA;
-		goto cleanup;
-	}
-	fps_times_1million = fps * 1000000 + fpsfrac;
-	totalframes = header->totalhunks;
-
-	/* adjust for interlacing */
-	if (interlaced)
-	{
-		fps_times_1million /= 2;
-		height *= 2;
-		firstframe *= 2;
-		numframes *= 2;
-	}
-	numframes = MIN(totalframes - firstframe, numframes);
-
-	/* allocate a video buffer */
-	{
-		bitmap_yuy16 fullbitmap(width, height);
-		avconfig.video.wrap(fullbitmap, fullbitmap.cliprect());
-
-		/* allocate audio buffers */
-		avconfig.maxsamples = ((UINT64)rate * 1000000 + fps_times_1million - 1) / fps_times_1million;
-		avconfig.actsamples = &numsamples;
-		for (chnum = 0; chnum < channels; chnum++)
-		{
-			avconfig.audio[chnum] = (INT16 *)malloc(avconfig.maxsamples * 2);
-			if (avconfig.audio[chnum] == NULL)
-			{
-				fprintf(stderr, "Out of memory allocating temporary audio buffer\n");
-				err = CHDERR_OUT_OF_MEMORY;
-				goto cleanup;
-			}
-		}
-
-		/* print some of it */
-		printf("Use frames:   %d-%d\n", firstframe, firstframe + numframes - 1);
-		printf("Frame rate:   %d.%06d\n", fps_times_1million / 1000000, fps_times_1million % 1000000);
-		printf("Frame size:   %d x %d %s\n", width, height, interlaced ? "interlaced" : "non-interlaced");
-		printf("Audio:        %d channels at %d Hz\n", channels, rate);
-		printf("Total frames: %d (%02d:%02d:%02d)\n", totalframes,
-				(UINT32)((UINT64)totalframes * 1000000 / fps_times_1million / 60 / 60),
-				(UINT32)(((UINT64)totalframes * 1000000 / fps_times_1million / 60) % 60),
-				(UINT32)(((UINT64)totalframes * 1000000 / fps_times_1million) % 60));
-
-		/* build up the movie info */
-		info.video_format = FORMAT_YUY2;
-		info.video_timescale = fps_times_1million;
-		info.video_sampletime = 1000000;
-		info.video_width = width;
-		info.video_height = height;
-		info.video_depth = 16;
-		info.audio_format = 0;
-		info.audio_timescale = rate;
-		info.audio_sampletime = 1;
-		info.audio_channels = channels;
-		info.audio_samplebits = 16;
-		info.audio_samplerate = rate;
-
-		/* create the output file */
-		avierr = avi_create(outputfile, &info, &avi);
-		if (avierr != AVIERR_NONE)
-		{
-			fprintf(stderr, "Error opening output file '%s': %s\n", outputfile, avi_error_string(avierr));
-			err = CHDERR_CANT_CREATE_FILE;
-			goto cleanup;
-		}
-
-		/* loop over hunks, reading and writing */
-		for (framenum = 0; framenum < numframes; framenum++)
-		{
-			/* progress */
-			progress(framenum == 0, "Extracting hunk %d/%d...  \r", framenum, numframes);
-
-			/* set up the fake bitmap for this frame */
-			if (!interlaced)
-				avconfig.video.wrap(fullbitmap, fullbitmap.cliprect());
-			else
-				avconfig.video.wrap(&fullbitmap.pix16(framenum % 2), fullbitmap.width(), fullbitmap.height() / 2, fullbitmap.rowpixels() * 2);
-
-			/* configure the decompressor for this frame */
-			chd_codec_config(chd, AV_CODEC_DECOMPRESS_CONFIG, &avconfig);
-
-			/* read the hunk into the buffers */
-			err = chd_read(chd, firstframe + framenum, NULL);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error reading hunk %d from CHD file: %s\n", firstframe + framenum, chd_error_string(err));
-				goto cleanup;
-			}
-
-			/* write audio */
-			for (chnum = 0; chnum < channels; chnum++)
-			{
-				avierr = avi_append_sound_samples(avi, chnum, avconfig.audio[chnum], numsamples, 0);
-				if (avierr != AVIERR_NONE)
-				{
-					fprintf(stderr, "Error writing samples for hunk %d to AVI file: %s\n", firstframe + framenum, avi_error_string(avierr));
-					goto cleanup;
-				}
-			}
-
-			/* write video */
-			if (!interlaced || (firstframe + framenum) % 2 == 1)
-			{
-				avierr = avi_append_video_frame(avi, fullbitmap);
-				if (avierr != AVIERR_NONE)
-				{
-					fprintf(stderr, "Error writing video for hunk %d to AVI file: %s\n", firstframe + framenum, avi_error_string(avierr));
-					goto cleanup;
-				}
-			}
-		}
-		progress(TRUE, "Extraction complete!                    \n");
-	}
-
-cleanup:
-	/* clean up our mess */
-	if (avi != NULL)
-		avi_close(avi);
-	for (chnum = 0; chnum < ARRAY_LENGTH(avconfig.audio); chnum++)
-		if (avconfig.audio[chnum] != NULL)
-			free(avconfig.audio[chnum]);
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
 }
 
 
-/*-------------------------------------------------
-    do_verify - validate the MD5/SHA1 on a drive
-    image
--------------------------------------------------*/
+//-------------------------------------------------
+//  parse_compression - parse a standard
+//  compression parameter string
+//-------------------------------------------------
 
-static int do_verify(int argc, char *argv[], int param)
+static void parse_compression(const parameters_t &params, chd_codec_type compression[4])
 {
-	chd_verify_result verify;
-	const char *inputfile;
-	chd_file *chd = NULL;
-	chd_header header;
-	int fixed = FALSE;
-	chd_error err;
-	int i;
-
-	/* require 3 args total */
-	if (argc != 3)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-
-	/* open the CHD file */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &chd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-	header = *chd_get_header(chd);
+	// see if anything was specified
+	astring *compression_str = params.find(OPTION_COMPRESSION);
+	if (compression_str == NULL)
+		return;
 
-	/* verify the CHD data */
-	err = chd_verify_begin(chd);
-	if (err == CHDERR_NONE)
+	// special case: 'none'
+	if (*compression_str == "none")
 	{
-		UINT32 hunknum;
-		for (hunknum = 0; hunknum < header.totalhunks; hunknum++)
-		{
-			/* progress */
-			progress(FALSE, "Verifying hunk %d/%d... \r", hunknum, header.totalhunks);
-
-			/* verify the data */
-			err = chd_verify_hunk(chd);
-			if (err != CHDERR_NONE)
-				break;
-		}
-
-		/* finish it */
-		if (err == CHDERR_NONE)
-			err = chd_verify_finish(chd, &verify);
+		compression[0] = compression[1] = compression[2] = compression[3] = CHD_CODEC_NONE;
+		return;
 	}
 
-	/* handle errors */
-	if (err != CHDERR_NONE)
-	{
-		if (err == CHDERR_CANT_VERIFY)
-			fprintf(stderr, "Can't verify this type of image (probably writeable)\n");
-		else
-			fprintf(stderr, "\nError during verify: %s\n", chd_error_string(err));
-		goto cleanup;
+	// iterate through compressors
+	int index = 0;
+	for (int start = 0, end = compression_str->chr(0, ','); index < 4; start = end + 1, end = compression_str->chr(end + 1, ','))
+	{
+		astring name(*compression_str, start, (end == -1) ? -1 : end - start);
+		if (name.len() != 4)
+			report_error(1, "Invalid compressor '%s' specified", name.cstr());
+		chd_codec_type type = CHD_MAKE_TAG(name[0], name[1], name[2], name[3]);
+		if (!chd_codec_list::codec_exists(type))
+			report_error(1, "Invalid compressor '%s' specified", name.cstr());
+		compression[index++] = type;
+		if (end == -1)
+			break;
 	}
+}
 
-	/* verify the MD5 */
-	if (header.version <= 3)
-	{
-		if (memcmp(header.md5, verify.md5, sizeof(header.md5)) == 0)
-			printf("MD5 verification successful!\n");
-		else
-		{
-			fprintf(stderr, "Error: MD5 in header = ");
-			for (i = 0; i < CHD_MD5_BYTES; i++)
-				fprintf(stderr, "%02x", header.md5[i]);
-			fprintf(stderr, "\n");
-			fprintf(stderr, "          actual MD5 = ");
-			for (i = 0; i < CHD_MD5_BYTES; i++)
-				fprintf(stderr, "%02x", verify.md5[i]);
-			fprintf(stderr, "\n");
 
-			/* fix it */
-			if (param)
-			{
-				memcpy(header.md5, verify.md5, sizeof(header.md5));
-				fixed = TRUE;
-			}
-		}
-	}
+//-------------------------------------------------
+//  parse_numprocessors - handle the numprocessors
+//  command
+//-------------------------------------------------
+
+static void parse_numprocessors(const parameters_t &params)
+{
+#if NUM_PROCESSORS_SUPPORTED
+	astring *numprocessors_str = params.find(OPTION_NUMPROCESSORS);
+	if (numprocessors_str == NULL)
+		return;
 
-	/* verify the SHA1 */
-	if (header.version >= 3)
+	int count = atoi(*numprocessors_str);
+	if (count > 0)
 	{
-		if (memcmp(header.sha1, verify.sha1, sizeof(header.sha1)) == 0)
-			printf("SHA1 verification successful!\n");
-		else
-		{
-			fprintf(stderr, "Error: SHA1 in header = ");
-			for (i = 0; i < CHD_SHA1_BYTES; i++)
-				fprintf(stderr, "%02x", header.sha1[i]);
-			fprintf(stderr, "\n");
-			fprintf(stderr, "          actual SHA1 = ");
-			for (i = 0; i < CHD_SHA1_BYTES; i++)
-				fprintf(stderr, "%02x", verify.sha1[i]);
-			fprintf(stderr, "\n");
-
-			/* fix it */
-			if (param)
-			{
-				memcpy(header.sha1, verify.sha1, sizeof(header.sha1));
-				fixed = TRUE;
-			}
-
-			/* verify the raw SHA1 */
-			if (header.version >= 4)
-			{
-				if (memcmp(header.rawsha1, verify.rawsha1, sizeof(header.rawsha1)) != 0)
-				{
-					fprintf(stderr, "Error: raw SHA1 in header = ");
-					for (i = 0; i < CHD_SHA1_BYTES; i++)
-						fprintf(stderr, "%02x", header.rawsha1[i]);
-					fprintf(stderr, "\n");
-					fprintf(stderr, "          actual raw SHA1 = ");
-					for (i = 0; i < CHD_SHA1_BYTES; i++)
-						fprintf(stderr, "%02x", verify.rawsha1[i]);
-					fprintf(stderr, "\n");
-
-					/* fix it */
-					if (param)
-					{
-						memcpy(header.rawsha1, verify.rawsha1, sizeof(header.rawsha1));
-						fixed = TRUE;
-					}
-				}
-			}
-		}
+		extern int osd_num_processors;
+		osd_num_processors = count;
 	}
+#endif
+}
+
 
-	/* close the drive */
-	chd_close(chd);
-	chd = NULL;
+//-------------------------------------------------
+//  compression_string - create a friendly string
+//  describing a set of compressors
+//-------------------------------------------------
+
+static const char *compression_string(astring &string, chd_codec_type compression[4])
+{
+	// output compression types
+	string.reset();
+	if (compression[0] == CHD_CODEC_NONE)
+		return string.cpy("none");
 
-	/* update the header */
-	if (fixed)
+	// iterate over types
+	for (int index = 0; index < 4; index++)
 	{
-		err = chd_set_header(inputfile, &header);
-		if (err != CHDERR_NONE)
-			fprintf(stderr, "Error writing new header: %s\n", chd_error_string(err));
-		else
-			printf("Updated header successfully\n");
+		chd_codec_type type = compression[index];
+		if (type == CHD_CODEC_NONE)
+			break;
+		if (index != 0)
+			string.cat(", ");
+		string.cat((type >> 24) & 0xff).cat((type >> 16) & 0xff).cat((type >> 8) & 0xff).cat(type & 0xff);
+		string.cat(" (").cat(chd_codec_list::codec_name(type)).cat(")");
 	}
-
-cleanup:
-	/* close everything down */
-	if (chd != NULL)
-		chd_close(chd);
-	return (err != CHDERR_NONE);
+	return string;
 }
 
 
-/*-------------------------------------------------
-    do_fixavdata - fix the AV metadata for an
-    A/V file
--------------------------------------------------*/
-
-static int do_fixavdata(int argc, char *argv[], int param)
-{
-	int fps, fpsfrac, width, height, interlaced, channels, rate;
-	av_codec_decompress_config avconfig;
-	const char *inputfile;
-	UINT8 *vbidata = NULL;
-	int writeable = FALSE;
-	chd_file *chd = NULL;
-	bitmap_yuy16 fakebitmap;
-	char metadata[256];
-	chd_header header;
-	UINT32 actlength;
-	UINT32 framenum;
-	chd_error err;
-	int fixframes = 0;
-	int fixes = 0;
-
-	/* require 3 args total */
-	if (argc != 3)
-		return usage();
+//-------------------------------------------------
+//  compress_common - standard compression loop
+//-------------------------------------------------
 
-	/* extract the data */
-	inputfile = argv[2];
+static void compress_common(chd_file_compressor &chd)
+{
+	// begin compressing
+	chd.compress_begin();
 
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
+	// loop until done
+	double complete, ratio;
+	chd_error err;
+	while ((err = chd.compress_continue(complete, ratio)) == CHDERR_WALKING_PARENT || err == CHDERR_COMPRESSING)
+		if (err == CHDERR_WALKING_PARENT)
+			progress(false, "Examining parent, %.1f%% complete...  \r", 100.0 * complete);
+		else
+			progress(false, "Compressing, %.1f%% complete... (ratio=%.1f%%)  \r", 100.0 * complete, 100.0 * ratio);
 
-	/* get the header */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &chd);
+	// handle errors
 	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
-	}
-	header = *chd_get_header(chd);
+		report_error(1, "Error during compression: %-40s", chd_file::error_string(err));
 
-	/* get the metadata */
-	err = chd_get_metadata(chd, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+	// final progress update
+	progress(true, "Compression complete ... final ratio = %.1f%%            \n", 100.0 * ratio);
+}
 
-	/* extract the info */
-	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
-	{
-		fprintf(stderr, "Improperly formatted metadata\n");
-		err = CHDERR_INVALID_METADATA;
-		goto cleanup;
-	}
 
-	/* allocate space for the frame data */
-	if ((height != 524/2 && height != 624/2) || !interlaced)
-	{
-		fprintf(stderr, "This file does not need VBI metadata\n");
-		err = CHDERR_INVALID_METADATA;
-		goto cleanup;
-	}
+//-------------------------------------------------
+//  output_track_metadata - output track metadata
+//  to a CUE file
+//-------------------------------------------------
 
-	/* allocate a video buffer */
+void output_track_metadata(bool cuemode, core_file *file, int tracknum, const cdrom_track_info &info, const char *filename, UINT32 frameoffs, UINT64 discoffs)
+{
+	// CUE mode?
+	if (cuemode)
 	{
-		bitmap_yuy16 fullbitmap(width, height);
-		avconfig.video.wrap(fullbitmap, fullbitmap.cliprect());
-
-		/* allocate memory for VBI data */
-		vbidata = (UINT8 *)malloc(header.totalhunks * VBI_PACKED_BYTES);
-		if (vbidata == NULL)
-		{
-			fprintf(stderr, "Out of memory allocating VBI data\n");
-			err = CHDERR_OUT_OF_MEMORY;
-			goto cleanup;
-		}
-
-		/* read the metadata */
-		err = chd_get_metadata(chd, AV_LD_METADATA_TAG, 0, vbidata, header.totalhunks * VBI_PACKED_BYTES, &actlength, NULL, NULL);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error getting VBI metadata: %s\n", chd_error_string(err));
-			memset(vbidata, 0, header.totalhunks * VBI_PACKED_BYTES);
-			fixes++;
-		}
-		if (actlength != header.totalhunks * VBI_PACKED_BYTES)
-		{
-			fprintf(stderr, "VBI metadata incorrect size\n");
-			memset(vbidata, 0, header.totalhunks * VBI_PACKED_BYTES);
-			fixes++;
-		}
+		// first track specifies the file
+		if (tracknum == 0)
+			core_fprintf(file, "FILE \"%s\" BINARY\n", filename);
 
-		/* loop over hunks, reading */
-		for (framenum = 0; framenum < header.totalhunks; framenum++)
+		// determine submode
+		astring tempstr;
+		switch (info.trktype)
 		{
-			vbi_metadata origvbi;
-			vbi_metadata vbi;
-			UINT32 vbiframe;
-
-			/* progress */
-			progress(framenum == 0, "Processing hunk %d/%d...  \r", framenum, header.totalhunks);
-
-			/* set up the fake bitmap for this frame */
-			avconfig.video.wrap(fullbitmap, fullbitmap.cliprect());
-
-			/* configure the decompressor for this frame */
-			chd_codec_config(chd, AV_CODEC_DECOMPRESS_CONFIG, &avconfig);
-
-			/* read the hunk into the buffers */
-			err = chd_read(chd, framenum, NULL);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error reading hunk %d from CHD file: %s\n", framenum, chd_error_string(err));
-				goto cleanup;
-			}
-
-			/* unpack the current data for this frame */
-			vbi_metadata_unpack(&origvbi, &vbiframe, &vbidata[framenum * VBI_PACKED_BYTES]);
-
-			/* parse the video data */
-			vbi_parse_all(&avconfig.video.pix16(0), avconfig.video.rowpixels(), avconfig.video.width(), 8, &vbi);
-
-			/* verify the data */
-			if (vbiframe != 0 || origvbi.white != 0 || origvbi.line16 != 0 || origvbi.line17 != 0 || origvbi.line18 != 0 || origvbi.line1718 != 0)
-			{
-				int errors = 0;
+			case CD_TRACK_MODE1:
+			case CD_TRACK_MODE1_RAW:
+				tempstr.format("MODE1/%04d", info.datasize);
+				break;
 
-				if (vbiframe != framenum)
-				{
-					fprintf(stderr, "%d:Frame mismatch in VBI data (%d, should be %d)\n", framenum, vbiframe, framenum);
-					errors++;
-				}
-				if (vbi.white != origvbi.white)
-				{
-					fprintf(stderr, "%d:White flag mismatch in VBI data (%d, should be %d)\n", framenum, origvbi.white, vbi.white);
-					errors++;
-				}
-				if (vbi.line16 != origvbi.line16)
-				{
-					fprintf(stderr, "%d:Line 16 mismatch in VBI data (%06X, should be %06X)\n", framenum, origvbi.line16, vbi.line16);
-					errors++;
-				}
-				if (vbi.line17 != origvbi.line17)
-				{
-					fprintf(stderr, "%d:Line 17 mismatch in VBI data (%06X, should be %06X)\n", framenum, origvbi.line17, vbi.line17);
-					errors++;
-				}
-				if (vbi.line18 != origvbi.line18)
-				{
-					fprintf(stderr, "%d:Line 18 mismatch in VBI data (%06X, should be %06X)\n", framenum, origvbi.line18, vbi.line18);
-					errors++;
-				}
-				if (vbi.line1718 != origvbi.line1718)
-				{
-					fprintf(stderr, "%d:Line 17/18 mismatch in VBI data (%06X, should be %06X)\n", framenum, origvbi.line1718, vbi.line1718);
-					errors++;
-				}
-				fixes += errors;
-				fixframes += (errors != 0);
-			}
+			case CD_TRACK_MODE2:
+			case CD_TRACK_MODE2_FORM1:
+			case CD_TRACK_MODE2_FORM2:
+			case CD_TRACK_MODE2_FORM_MIX:
+			case CD_TRACK_MODE2_RAW:
+				tempstr.format("MODE2/%04d", info.datasize);
+				break;
 
-			/* pack the new data */
-			vbi_metadata_pack(&vbidata[framenum * VBI_PACKED_BYTES], framenum, &vbi);
+			case CD_TRACK_AUDIO:
+				tempstr.cpy("AUDIO");
+				break;
 		}
-		progress(TRUE, "Processing complete!                                     \n");
 
-		/* print final results */
-		if (fixes == 0)
-			printf("\nNo fixes required\n");
-		else
-			printf("\nFound %d errors on %d frames\n", fixes, fixframes);
-
-		/* close the drive */
-		chd_close(chd);
-		chd = NULL;
-
-		/* apply fixes */
-		if (fixes > 0)
-		{
-			/* mark the CHD writeable */
-			header.flags |= CHDFLAGS_IS_WRITEABLE;
-			err = chd_set_header(inputfile, &header);
-			if (err != CHDERR_NONE)
-				fprintf(stderr, "Error writing new header: %s\n", chd_error_string(err));
-			header.flags &= ~CHDFLAGS_IS_WRITEABLE;
-			writeable = TRUE;
+		// output TRACK entry
+		core_fprintf(file, "  TRACK %02d %s\n", tracknum + 1, tempstr.cstr());
 
-			/* open the file */
-			err = chd_open(inputfile, CHD_OPEN_READWRITE, NULL, &chd);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-				goto cleanup;
-			}
+		// output PREGAP
+		if (info.pregap > 0)
+			core_fprintf(file, "    PREGAP %s\n", msf_string_from_frames(tempstr, info.pregap));
 
-			/* write new metadata */
-			err = chd_set_metadata(chd, AV_LD_METADATA_TAG, 0, vbidata, header.totalhunks * VBI_PACKED_BYTES, CHD_MDFLAGS_CHECKSUM);
-			if (err != CHDERR_NONE)
-			{
-				fprintf(stderr, "Error adding AVLD metadata: %s\n", chd_error_string(err));
-				goto cleanup;
-			}
-			else
-				printf("Updated metadata written successfully\n");
+		// output track data
+		core_fprintf(file, "    INDEX 01 %s\n", msf_string_from_frames(tempstr, frameoffs));
 
-			/* allow cleanup code to close the file and revert the header */
-		}
+		// output POSTGAP
+		if (info.postgap > 0)
+			core_fprintf(file, "    POSTGAP %s\n", msf_string_from_frames(tempstr, info.postgap));
 	}
 
-cleanup:
-	/* clean up our mess */
-	if (vbidata != NULL)
-		free(vbidata);
-	if (chd != NULL)
-		chd_close(chd);
-	if (writeable)
-		chd_set_header(inputfile, &header);
-	return (err != CHDERR_NONE);
-}
-
-
-/*-------------------------------------------------
-    do_info - dump the header information from
-    a drive image
--------------------------------------------------*/
-
-static int do_info(int argc, char *argv[], int param)
-{
-	const char *inputfile;
-	chd_file *chd = NULL;
-	UINT8 metadata[256];
-	chd_header header;
-	chd_error err;
-	int i, j;
-
-	/* require 3 args total */
-	if (argc != 3)
-		return usage();
-
-	/* extract the data */
-	inputfile = argv[2];
-
-	/* print some info */
-	printf("Input file:   %s\n", inputfile);
-
-	/* get the header */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &chd);
-	if (err != CHDERR_NONE)
+	// non-CUE mode
+	else
 	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
-	}
-	header = *chd_get_header(chd);
-
-	/* print the info */
-	printf("Header Size:  %d bytes\n", header.length);
-	printf("File Version: %d\n", header.version);
-	printf("Flags:        %s, %s\n",
-			(header.flags & CHDFLAGS_HAS_PARENT) ? "HAS_PARENT" : "NO_PARENT",
-			(header.flags & CHDFLAGS_IS_WRITEABLE) ? "WRITEABLE" : "READ_ONLY");
-	printf("Compression:  %s\n", chd_get_codec_name(header.compression));
-	printf("Hunk Size:    %d bytes\n", header.hunkbytes);
-	printf("Total Hunks:  %d\n", header.totalhunks);
-	printf("Logical size: %s bytes\n", big_int_string(header.logicalbytes));
-	if (!(header.flags & CHDFLAGS_IS_WRITEABLE) && header.version <= 3)
-		printf("MD5:          %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				header.md5[0], header.md5[1], header.md5[2], header.md5[3],
-				header.md5[4], header.md5[5], header.md5[6], header.md5[7],
-				header.md5[8], header.md5[9], header.md5[10], header.md5[11],
-				header.md5[12], header.md5[13], header.md5[14], header.md5[15]);
-	if (!(header.flags & CHDFLAGS_IS_WRITEABLE) && header.version >= 3)
-		printf("SHA1:         %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				header.sha1[0], header.sha1[1], header.sha1[2], header.sha1[3],
-				header.sha1[4], header.sha1[5], header.sha1[6], header.sha1[7],
-				header.sha1[8], header.sha1[9], header.sha1[10], header.sha1[11],
-				header.sha1[12], header.sha1[13], header.sha1[14], header.sha1[15],
-				header.sha1[16], header.sha1[17], header.sha1[18], header.sha1[19]);
-	if (!(header.flags & CHDFLAGS_IS_WRITEABLE) && header.version >= 4)
-	{
-		printf("Raw SHA1:     %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				header.rawsha1[0], header.rawsha1[1], header.rawsha1[2], header.rawsha1[3],
-				header.rawsha1[4], header.rawsha1[5], header.rawsha1[6], header.rawsha1[7],
-				header.rawsha1[8], header.rawsha1[9], header.rawsha1[10], header.rawsha1[11],
-				header.rawsha1[12], header.rawsha1[13], header.rawsha1[14], header.rawsha1[15],
-				header.rawsha1[16], header.rawsha1[17], header.rawsha1[18], header.rawsha1[19]);
-	}
-	if (header.flags & CHDFLAGS_HAS_PARENT)
-	{
-		printf("Parent MD5:   %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				header.parentmd5[0], header.parentmd5[1], header.parentmd5[2], header.parentmd5[3],
-				header.parentmd5[4], header.parentmd5[5], header.parentmd5[6], header.parentmd5[7],
-				header.parentmd5[8], header.parentmd5[9], header.parentmd5[10], header.parentmd5[11],
-				header.parentmd5[12], header.parentmd5[13], header.parentmd5[14], header.parentmd5[15]);
-		if (header.version >= 3)
-			printf("Parent SHA1:  %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-					header.parentsha1[0], header.parentsha1[1], header.parentsha1[2], header.parentsha1[3],
-					header.parentsha1[4], header.parentsha1[5], header.parentsha1[6], header.parentsha1[7],
-					header.parentsha1[8], header.parentsha1[9], header.parentsha1[10], header.parentsha1[11],
-					header.parentsha1[12], header.parentsha1[13], header.parentsha1[14], header.parentsha1[15],
-					header.parentsha1[16], header.parentsha1[17], header.parentsha1[18], header.parentsha1[19]);
-	}
+		// header on the first track
+		if (tracknum == 0)
+			core_fprintf(file, "CD_ROM\n\n\n");
+		core_fprintf(file, "// Track %d\n", tracknum + 1);
+
+		// write out the track type
+		astring modesubmode;
+		if (info.subtype != CD_SUB_NONE)
+			modesubmode.format("%s %s", cdrom_get_type_string(info.trktype), cdrom_get_subtype_string(info.subtype));
+		else
+			modesubmode.format("%s", cdrom_get_type_string(info.trktype));
+		core_fprintf(file, "TRACK %s\n", modesubmode.cstr());
 
-	/* print out metadata */
-	for (i = 0; ; i++)
-	{
-		UINT32 metatag, metasize;
+		// write out the attributes
+		core_fprintf(file, "NO COPY\n");
+		if (info.trktype == CD_TRACK_AUDIO)
+		{
+			core_fprintf(file, "NO PRE_EMPHASIS\n");
+			core_fprintf(file, "TWO_CHANNEL_AUDIO\n");
+		}
 
-		/* get the indexed metadata item; stop when we hit an error */
-		err = chd_get_metadata(chd, CHDMETATAG_WILDCARD, i, metadata, sizeof(metadata), &metasize, &metatag, NULL);
-		if (err != CHDERR_NONE)
-			break;
+		// output pregap
+		astring tempstr;
+		if (info.pregap > 0)
+			core_fprintf(file, "ZERO %s %s\n", modesubmode.cstr(), msf_string_from_frames(tempstr, info.pregap));
 
-		/* print either a string representation or a hex representation of the tag */
-		if (isprint((metatag >> 24) & 0xff) && isprint((metatag >> 16) & 0xff) && isprint((metatag >> 8) & 0xff) && isprint(metatag & 0xff))
-			printf("Metadata:     Tag='%c%c%c%c'    Length=%d\n", (metatag >> 24) & 0xff, (metatag >> 16) & 0xff, (metatag >> 8) & 0xff, metatag & 0xff, metasize);
+		// all tracks but the first one have a file offset
+		if (tracknum > 0)
+			core_fprintf(file, "DATAFILE \"%s\" #%d %s // length in bytes: %d\n", filename, UINT32(discoffs), msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
 		else
-			printf("Metadata:     Tag=%08x  Length=%d\n", metatag, metasize);
-		printf("              ");
+			core_fprintf(file, "DATAFILE \"%s\" %s // length in bytes: %d\n", filename, msf_string_from_frames(tempstr, info.frames), info.frames * (info.datasize + info.subsize));
 
-		/* print up to 60 characters of metadata */
-		metasize = MIN(60, metasize);
-		for (j = 0; j < metasize; j++)
-			printf("%c", isprint(metadata[j]) ? metadata[j] : '.');
-		printf("\n");
+		// tracks with pregaps get a START marker too
+		if (info.pregap > 0)
+			core_fprintf(file, "START %s\n", msf_string_from_frames(tempstr, info.pregap));
+
+		core_fprintf(file, "\n\n");
 	}
-
-cleanup:
-	/* close everything down */
-	if (chd != NULL)
-		chd_close(chd);
-	return (err != CHDERR_NONE);
 }
 
 
-/*-------------------------------------------------
-    handle_custom_chomp - custom chomp a file
--------------------------------------------------*/
-
-#if ENABLE_CUSTOM_CHOMP
-static chd_error handle_custom_chomp(const char *name, chd_file *chd, UINT32 *maxhunk)
-{
-	const chd_header *header = chd_get_header(chd);
-	int sectors_per_hunk = (header->hunkbytes / IDE_SECTOR_SIZE);
-	chd_error err = CHDERR_INVALID_DATA;
-	UINT8 *temp = NULL;
-
-	/* allocate memory to hold a hunk */
-	temp = malloc(header->hunkbytes);
-	if (temp == NULL)
-	{
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
-	}
-
-	/* check for midway */
-	if (strcmp(name, "midway") == 0)
-	{
-		UINT32 maxsector = 0;
-		UINT32 numparts;
-		chd_error err;
-		int i;
-
-		/* read sector 0 */
-		err = chd_read(chd, 0, temp);
+//-------------------------------------------------
+//  do_info - dump the header information from
+//  a drive image
+//-------------------------------------------------
+
+static void do_info(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
+
+	// print filename and version
+	astring tempstr;
+	printf("Input file:   %s\n", params.find(OPTION_INPUT)->cstr());
+	printf("File Version: %d\n", input_chd.version());
+	if (input_chd.version() < 3)
+		report_error(1, "Unsupported version (%d); use an older chdman to upgrade to version 3 or later", input_chd.version());
+
+	// output cmpression and size information
+	chd_codec_type compression[4] = { input_chd.compression(0), input_chd.compression(1), input_chd.compression(2), input_chd.compression(3) };
+	printf("Logical size: %s bytes\n", big_int_string(tempstr, input_chd.logical_bytes()));
+	printf("Hunk Size:    %s bytes\n", big_int_string(tempstr, input_chd.hunk_bytes()));
+	printf("Total Hunks:  %s\n", big_int_string(tempstr, input_chd.hunk_count()));
+	printf("Unit Size:    %s bytes\n", big_int_string(tempstr, input_chd.unit_bytes()));
+	printf("Total Units:  %s\n", big_int_string(tempstr, input_chd.unit_count()));
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("CHD size:     %s bytes\n", big_int_string(tempstr, core_fsize(input_chd)));
+	if (compression[0] != CHD_CODEC_NONE)
+		printf("Ratio:        %.1f%%\n", 100.0 * double(core_fsize(input_chd)) / double(input_chd.logical_bytes()));
+
+	// add SHA1 output
+	sha1_t overall = input_chd.sha1();
+	if (overall != sha1_t::null)
+	{
+		printf("SHA1:         %s\n", overall.as_string(tempstr));
+		if (input_chd.version() >= 4)
+			printf("Data SHA1:    %s\n", input_chd.raw_sha1().as_string(tempstr));
+	}
+	sha1_t parent = input_chd.parent_sha1();
+	if (parent != sha1_t::null)
+		printf("Parent SHA1:  %s\n", parent.as_string(tempstr));
+
+	// print out metadata
+	dynamic_buffer buffer;
+	dynamic_array<metadata_index_info> info;
+	for (int index = 0; ; index++)
+	{
+		// get the indexed metadata item; stop when we hit an error
+		chd_metadata_tag metatag;
+		UINT8 metaflags;
+		chd_error err = input_chd.read_metadata(CHDMETATAG_WILDCARD, index, buffer, metatag, metaflags);
 		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error reading hunk 0\n");
-			goto cleanup;
-		}
-
-		/* look for the signature */
-		if (temp[0] != 0x54 || temp[1] != 0x52 || temp[2] != 0x41 || temp[3] != 0x50)
-			goto cleanup;
+			break;
 
-		/* determine the number of partitions */
-		numparts = temp[4] | (temp[5] << 8) | (temp[6] << 16) | (temp[7] << 24);
-		printf("%d partitions\n", numparts);
+		// determine our index
+		UINT32 metaindex = ~0;
+		for (int cur = 0; cur < info.count(); cur++)
+			if (info[cur].tag == metatag)
+			{
+				metaindex = ++info[cur].index;
+				break;
+			}
 
-		/* get the partition information for each one and track the maximum referenced sector */
-		for (i = 0; i < numparts; i++)
+		// if not found, add to our tracking
+		if (metaindex == ~0)
 		{
-			UINT32 pstart = temp[i*12 + 8] | (temp[i*12 + 9] << 8) | (temp[i*12 + 10] << 16) | (temp[i*12 + 11] << 24);
-			UINT32 psize  = temp[i*12 + 12] | (temp[i*12 + 13] << 8) | (temp[i*12 + 14] << 16) | (temp[i*12 + 15] << 24);
-			UINT32 pflags = temp[i*12 + 16] | (temp[i*12 + 17] << 8) | (temp[i*12 + 18] << 16) | (temp[i*12 + 19] << 24);
-			printf("  %2d. %7d - %7d (%X)\n", i, pstart, pstart + psize - 1, pflags);
-			if (i != 0 && pstart + psize > maxsector)
-				maxsector = pstart + psize;
+			metadata_index_info curinfo = { metatag, 0 };
+			info.append(curinfo);
+			metaindex = 0;
 		}
 
-		/* the maximum hunk is the one that contains the last sector */
-		*maxhunk = (maxsector + sectors_per_hunk - 1) / sectors_per_hunk;
-		printf("Maximum hunk: %d\n", *maxhunk);
+		// print either a string representation or a hex representation of the tag
+		if (isprint((metatag >> 24) & 0xff) && isprint((metatag >> 16) & 0xff) && isprint((metatag >> 8) & 0xff) && isprint(metatag & 0xff))
+			printf("Metadata:     Tag='%c%c%c%c'  Index=%d  Length=%d bytes\n", (metatag >> 24) & 0xff, (metatag >> 16) & 0xff, (metatag >> 8) & 0xff, metatag & 0xff, metaindex, buffer.count());
+		else
+			printf("Metadata:     Tag=%08x  Index=%d  Length=%d bytes\n", metatag, metaindex, buffer.count());
+		printf("              ");
 
-		/* warn if there will be no effect */
-		if (*maxhunk >= header->totalhunks)
-		{
-			printf("Warning: chomp will have no effect\n");
-			*maxhunk = header->totalhunks;
-		}
+		// print up to 60 characters of metadata
+		UINT32 count = MIN(60, buffer.count());
+		for (int chnum = 0; chnum < count; chnum++)
+			printf("%c", isprint(UINT8(buffer[chnum])) ? buffer[chnum] : '.');
+		printf("\n");
 	}
 
-	/* check for atari */
-	if (strcmp(name, "atari") == 0)
+	// print compression stats if verbose
+	if (params.find(OPTION_VERBOSE) != NULL)
 	{
-		UINT32 sectors[4];
-		UINT8 *data;
-		int i, maxdiff;
-		chd_error err;
-
-		/* read the second sector */
-		err = chd_read(chd, 0x200 / header->hunkbytes, temp);
-		if (err != CHDERR_NONE)
+		UINT32 compression_types[10] = { 0 };
+		for (UINT32 hunknum = 0; hunknum < input_chd.hunk_count(); hunknum++)
 		{
-			fprintf(stderr, "Error reading sector 1\n");
-			goto cleanup;
-		}
-		data = &temp[0x200 % header->hunkbytes];
+			// get info on this hunk
+			chd_codec_type codec;
+			UINT32 compbytes;
+			chd_error err = input_chd.hunk_info(hunknum, codec, compbytes);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error getting info on hunk %d: %s", hunknum, chd_file::error_string(err));
 
-		/* look for the signature */
-		if (data[0] != 0x0d || data[1] != 0xf0 || data[2] != 0xed || data[3] != 0xfe)
-			goto cleanup;
+			// decode into our data
+			if (codec > CHD_CODEC_MINI)
+				for (int comptype = 0; comptype < 4; comptype++)
+					if (codec == input_chd.compression(comptype))
+					{
+						codec = CHD_CODEC_MINI + 1 + comptype;
+						break;
+					}
+			if (codec > ARRAY_LENGTH(compression_types))
+				codec = ARRAY_LENGTH(compression_types) - 1;
 
-		/* loop over 4 partitions and compute the number of sectors in each */
-		for (i = 0; i < 4; i++)
-			sectors[i] = data[i*4+0x40] | (data[i*4+0x41] << 8) | (data[i*4+0x42] << 16) | (data[i*4+0x43] << 24);
-		maxdiff = sectors[2] - sectors[1];
-		if (sectors[3] - sectors[2] > maxdiff)
-			maxdiff = sectors[3] - sectors[2];
-		if (sectors[0] != 8)
-			goto cleanup;
+			// count stats
+			compression_types[codec]++;
+		}
 
-		/* the maximum hunk is the end of the fourth copy of the data */
-		*maxhunk = (sectors[3] + maxdiff + sectors_per_hunk - 1) / sectors_per_hunk;
-		printf("Maximum hunk: %d\n", *maxhunk);
+		// output the stats
+		printf("\n");
+		printf("     Hunks  Percent  Name\n");
+		printf("----------  -------  ------------------------------------\n");
+		for (int comptype = 0; comptype < ARRAY_LENGTH(compression_types); comptype++)
+			if (compression_types[comptype] != 0)
+			{
+				// determine the name
+				const char *name = "Unknown";
+				switch (comptype)
+				{
+					case CHD_CODEC_NONE:		name = "Uncompressed";					break;
+					case CHD_CODEC_SELF:		name = "Copy from self";				break;
+					case CHD_CODEC_PARENT:		name = "Copy from parent";				break;
+					case CHD_CODEC_MINI:		name = "Legacy 8-byte mini";			break;
+					default:
+						int index = comptype - 1 - CHD_CODEC_MINI;
+						if (index < 4)
+							name = chd_codec_list::codec_name(input_chd.compression(index));
+						break;
+				}
 
-		/* warn if there will be no effect */
-		if (*maxhunk >= header->totalhunks)
-		{
-			fprintf(stderr, "Warning: chomp will have no effect\n");
-			*maxhunk = header->totalhunks;
-		}
+				// output the stats
+				astring tempstr;
+				printf("%10s   %5.1f%%  %-40s\n",
+						big_int_string(tempstr, compression_types[comptype]),
+						100.0 * double(compression_types[comptype]) / double(input_chd.hunk_count()),
+						name);
+			}
 	}
+}
 
-	/* if we fall through, there was no error */
-	err = CHDERR_NONE;
 
-cleanup:
-	if (temp != NULL)
-		free(temp);
-	if (err == CHDERR_INVALID_DATA)
-		fprintf(stderr, "Error: unable to identify file or compute chomping size.\n");
-	return err;
-}
-#endif
+//-------------------------------------------------
+//  do_verify - validate the SHA1 on a CHD
+//-------------------------------------------------
 
+static void do_verify(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
 
-/*-------------------------------------------------
-    do_merge_update_chomp - merge a parent and its
-    child together (also works for update & chomp)
--------------------------------------------------*/
-
-static int do_merge_update_chomp(int argc, char *argv[], int param)
-{
-	const char *parentfile, *inputfile, *outputfile;
-	const chd_header *inputheader;
-	chd_file *parentchd = NULL;
-	chd_file *outputchd = NULL;
-	chd_file *inputchd = NULL;
-	UINT32 maxhunk = ~0;
-	chd_error err;
+	// only makes sense for compressed CHDs with valid SHA1's
+	if (!input_chd.compressed())
+		report_error(0, "No verification to be done; CHD is uncompressed");
+	sha1_t raw_sha1 = (input_chd.version() <= 3) ? input_chd.sha1() : input_chd.raw_sha1();
+	if (raw_sha1 == sha1_t::null)
+		report_error(0, "No verification to be done; CHD has no checksum");
 
-	/* require 4-5 args total */
-	if (param == OPERATION_UPDATE && argc != 4)
-		return usage();
-	if ((param == OPERATION_MERGE || param == OPERATION_CHOMP) && argc != 5)
-		return usage();
-
-	/* extract the data */
-	if (param == OPERATION_MERGE)
-	{
-		parentfile = argv[2];
-		inputfile = argv[3];
-		outputfile = argv[4];
-	}
-	else
-	{
-		parentfile = NULL;
-		inputfile = argv[2];
-		outputfile = argv[3];
-		if (param == OPERATION_CHOMP)
-			maxhunk = atoi(argv[4]);
-	}
+	// create an array to read into
+	dynamic_buffer buffer((TEMP_BUFFER_SIZE / input_chd.hunk_bytes()) * input_chd.hunk_bytes());
 
-	/* print some info */
-	if (parentfile != NULL)
+	// read all the data and build up an SHA-1
+	sha1_creator rawsha1;
+	for (UINT64 offset = 0; offset < input_chd.logical_bytes(); )
 	{
-		printf("Parent file:  %s\n", parentfile);
-		printf("Diff file:    %s\n", inputfile);
-	}
-	else
-		printf("Input file:   %s\n", inputfile);
-	printf("Output file:  %s\n", outputfile);
-	if (param == OPERATION_CHOMP)
-		printf("Maximum hunk: %d\n", maxhunk);
+		progress(false, "Verifying, %.1f%% complete... \r", 100.0 * double(offset) / double(input_chd.logical_bytes()));
 
-	/* open the parent CHD */
-	if (parentfile != NULL)
-	{
-		err = chd_open(parentfile, CHD_OPEN_READ, NULL, &parentchd);
+		// determine how much to read
+		UINT32 bytes_to_read = MIN(buffer.count(), input_chd.logical_bytes() - offset);
+		chd_error err = input_chd.read_bytes(offset, buffer, bytes_to_read);
 		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error opening CHD file '%s': %s\n", parentfile, chd_error_string(err));
-			goto cleanup;
-		}
-	}
+			report_error(1, "Error reading CHD file (%s): %s", params.find(OPTION_INPUT)->cstr(), chd_file::error_string(err));
 
-	/* open the diff CHD */
-	err = chd_open(inputfile, CHD_OPEN_READ, parentchd, &inputchd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
+		// add to the checksum
+		rawsha1.append(buffer, bytes_to_read);
+		offset += bytes_to_read;
 	}
-	inputheader = chd_get_header(inputchd);
-
-#if ENABLE_CUSTOM_CHOMP
-	/* if we're chomping with a auto parameter, now is the time to figure it out */
-	if (param == OPERATION_CHOMP && maxhunk == 0)
-		if (handle_custom_chomp(argv[4], inputchd, &maxhunk) != CHDERR_NONE)
-			return 1;
-#endif
+	sha1_t computed_sha1 = rawsha1.finish();
 
-	/* create the new merged CHD */
-	err = chd_create(outputfile, inputheader->logicalbytes, inputheader->hunkbytes, inputheader->compression, NULL);
-	if (err != CHDERR_NONE)
+	// finish up
+	if (raw_sha1 != computed_sha1)
 	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+		astring tempstr;
+		fprintf(stderr, "Error: Raw SHA1 in header = %s\n", raw_sha1.as_string(tempstr));
+		fprintf(stderr, "              actual SHA1 = %s\n", computed_sha1.as_string(tempstr));
 
-	/* open the new CHD */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, NULL, &outputchd);
-	if (err != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
+		// fix it if requested; this also fixes the overall one so we don't need to do any more
+		if (params.find(OPTION_FIX) != NULL)
+		{
+			input_chd.set_raw_sha1(computed_sha1);
+			printf("SHA-1 updated to correct value in input CHD\n");
+		}
 	}
-
-	/* clone the metadata from the input file (which should have inherited from the parent) */
-	err = chdman_clone_metadata(inputchd, outputchd);
-	if (err != CHDERR_NONE)
+	else
 	{
-		fprintf(stderr, "Error cloning metadata: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
-
-	/* do the compression; our interface will route reads for us */
-	err = chdman_compress_chd(outputchd, inputchd, (param == OPERATION_CHOMP) ? (maxhunk + 1) : 0);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
-
-cleanup:
-	/* close everything down */
-	if (outputchd != NULL)
-		chd_close(outputchd);
-	if (inputchd != NULL)
-		chd_close(inputchd);
-	if (parentchd != NULL)
-		chd_close(parentchd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
-}
+		printf("Raw SHA1 verification successful!\n");
 
+		// now include the metadata for >= v4
+		if (input_chd.version() >= 4)
+		{
+			sha1_t computed_overall_sha1 = input_chd.compute_overall_sha1(computed_sha1);
+			if (input_chd.sha1() == computed_overall_sha1)
+				printf("Overall SHA1 verification successful!\n");
+			else
+			{
+				astring tempstr;
+				fprintf(stderr, "Error: Overall SHA1 in header = %s\n", input_chd.sha1().as_string(tempstr));
+				fprintf(stderr, "                  actual SHA1 = %s\n", computed_overall_sha1.as_string(tempstr));
 
-/*-------------------------------------------------
-    do_diff - generate a difference between two
-    CHD files
--------------------------------------------------*/
-
-static int do_diff(int argc, char *argv[], int param)
-{
-	const char *parentfile = NULL, *inputfile = NULL, *outputfile = NULL;
-	chd_file *parentchd = NULL;
-	chd_file *outputchd = NULL;
-	chd_file *inputchd = NULL;
-	chd_error err;
+				// fix it if requested
+				if (params.find(OPTION_FIX) != NULL)
+				{
+					input_chd.set_raw_sha1(computed_sha1);
+					printf("SHA-1 updated to correct value in input CHD\n");
+				}
+			}
+		}
+	}
+}
 
-	/* require 5 args total */
-	if (argc != 5)
-		return usage();
-
-	/* extract the data */
-	parentfile = argv[2];
-	inputfile = argv[3];
-	outputfile = argv[4];
-
-	/* print some info */
-	printf("Parent file:  %s\n", parentfile);
-	printf("Input file:   %s\n", inputfile);
-	printf("Diff file:    %s\n", outputfile);
 
-	/* open the soon-to-be-parent CHD */
-	err = chd_open(parentfile, CHD_OPEN_READ, NULL, &parentchd);
-	if (err != CHDERR_NONE)
+//-------------------------------------------------
+//  do_create_raw - create a new compressed raw
+//  image from a raw file
+//-------------------------------------------------
+
+static void do_create_raw(parameters_t &params)
+{
+	// process input file
+	core_file *input_file = NULL;
+	astring *input_file_str = params.find(OPTION_INPUT);
+	if (input_file_str != NULL)
 	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", parentfile, chd_error_string(err));
-		goto cleanup;
+		file_error filerr = core_fopen(*input_file_str, OPEN_FLAG_READ, &input_file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Unable to open file (%s)", input_file_str->cstr());
 	}
 
-	/* open the input CHD */
-	err = chd_open(inputfile, CHD_OPEN_READ, NULL, &inputchd);
-	if (err != CHDERR_NONE)
+	// process output CHD
+	chd_file output_parent;
+	astring *output_chd_str = parse_output_chd_parameters(params, output_parent);
+
+	// process hunk size
+	UINT32 hunk_size = output_parent.opened() ? output_parent.hunk_bytes() : 0;
+	parse_hunk_size(params, 1, hunk_size);
+
+	// process unit size
+	UINT32 unit_size = output_parent.opened() ? output_parent.unit_bytes() : 0;
+	astring *unit_size_str = params.find(OPTION_UNIT_SIZE);
+	if (unit_size_str != NULL)
 	{
-		fprintf(stderr, "Error opening CHD file '%s': %s\n", inputfile, chd_error_string(err));
-		goto cleanup;
+		unit_size = parse_number(*unit_size_str);
+		if (hunk_size % unit_size != 0)
+			report_error(1, "Unit size is not an even divisor of the hunk size");
 	}
 
-	/* create the new CHD as a diff against the parent */
-	err = chd_create(outputfile, 0, 0, chd_get_header(parentchd)->compression, parentchd);
-	if (err != CHDERR_NONE)
+	// process input start/end (needs to know hunk_size)
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, core_fsize(input_file), hunk_size, hunk_size, input_start, input_end);
+
+	// process compression
+	chd_codec_type compression[4];
+	memcpy(compression, s_default_raw_compression, sizeof(compression));
+	parse_compression(params, compression);
+
+	// process numprocessors
+	parse_numprocessors(params);
+
+	// print some info
+	astring tempstr;
+	printf("Output CHD:   %s\n", output_chd_str->cstr());
+	if (output_parent.opened())
+		printf("Parent CHD:   %s\n", params.find(OPTION_OUTPUT_PARENT)->cstr());
+	printf("Input file:   %s\n", input_file_str->cstr());
+	if (input_start != 0 || input_end != core_fsize(input_file))
 	{
-		fprintf(stderr, "Error creating CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
+		printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+		printf("Input length: %s\n", big_int_string(tempstr, input_end - input_start));
 	}
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("Hunk size:    %s\n", big_int_string(tempstr, hunk_size));
+	printf("Logical size: %s\n", big_int_string(tempstr, input_end - input_start));
 
-	/* open the new CHD */
-	err = chd_open(outputfile, CHD_OPEN_READWRITE, parentchd, &outputchd);
-	if (err != CHDERR_NONE)
+	// catch errors so we can close & delete the output file
+	try
 	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
-	}
+		// create the new CHD
+		chd_rawfile_compressor chd(input_file, input_start, input_end);
+		chd_error err;
+		if (output_parent.opened())
+			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
+		else
+			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, unit_size, compression);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
-	/* do the compression; our interface will route reads for us */
-	err = chdman_compress_chd(outputchd, inputchd, 0);
-	if (err != CHDERR_NONE)
-		fprintf(stderr, "Error during compression: %s\n", chd_error_string(err));
+		// if we have a parent, copy forward all the metadata
+		if (output_parent.opened())
+			chd.clone_all_metadata(output_parent);
 
-cleanup:
-	/* close everything down */
-	if (outputchd != NULL)
-		chd_close(outputchd);
-	if (inputchd != NULL)
-		chd_close(inputchd);
-	if (parentchd != NULL)
-		chd_close(parentchd);
-	if (err != CHDERR_NONE)
-		osd_rmfile(outputfile);
-	return (err != CHDERR_NONE);
+		// compress it generically
+		compress_common(chd);
+	}
+	catch (...)
+	{
+		// delete the output file
+		astring *output_chd_str = params.find(OPTION_OUTPUT);
+		if (output_chd_str != NULL)
+			osd_rmfile(*output_chd_str);
+		throw;
+	}
 }
 
 
-/*-------------------------------------------------
-    do_setchs - change the CHS values on a hard
-    disk image
--------------------------------------------------*/
-
-static int do_setchs(int argc, char *argv[], int param)
-{
-	int oldcyls, oldhds, oldsecs, oldsecsize;
-	UINT8 was_readonly = FALSE;
-	UINT64 old_logicalbytes;
-	const char *inoutfile;
-	chd_file *chd = NULL;
-	int cyls, hds, secs;
-	char metadata[256];
-	chd_header header;
-	chd_error err;
-
-	/* require 6 args total */
-	if (argc != 6)
-		return usage();
-
-	/* extract the data */
-	inoutfile = argv[2];
-	cyls = atoi(argv[3]);
-	hds = atoi(argv[4]);
-	secs = atoi(argv[5]);
-
-	/* print some info */
-	printf("Input file:   %s\n", inoutfile);
-	printf("Cylinders:    %d\n", cyls);
-	printf("Heads:        %d\n", hds);
-	printf("Sectors:      %d\n", secs);
+//-------------------------------------------------
+//  do_create_hd - create a new compressed hard
+//  disk image from a raw file
+//-------------------------------------------------
 
-	/* open the file read-only and get the header */
-	err = chd_open(inoutfile, CHD_OPEN_READ, NULL, &chd);
-	if (err != CHDERR_NONE)
+static void do_create_hd(parameters_t &params)
+{
+	// process input file
+	core_file *input_file = NULL;
+	astring *input_file_str = params.find(OPTION_INPUT);
+	if (input_file_str != NULL)
 	{
-		fprintf(stderr, "Error opening CHD file '%s' read-only: %s\n", inoutfile, chd_error_string(err));
-		goto cleanup;
+		file_error filerr = core_fopen(*input_file_str, OPEN_FLAG_READ, &input_file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Unable to open file (%s)", input_file_str->cstr());
 	}
-	header = *chd_get_header(chd);
-	chd_close(chd);
-	chd = NULL;
 
-	/* if the drive is not writeable, note that, and make it so */
-	if (!(header.flags & CHDFLAGS_IS_WRITEABLE))
+	// process output CHD
+	chd_file output_parent;
+	astring *output_chd_str = parse_output_chd_parameters(params, output_parent);
+
+	// process sectorsize
+	UINT32 sector_size = output_parent.opened() ? output_parent.unit_bytes() : IDE_SECTOR_SIZE;
+	astring *sectorsize_str = params.find(OPTION_SECTOR_SIZE);
+	if (sectorsize_str != NULL)
+	{
+		if (output_parent.opened())
+			report_error(1, "Sector size does not apply when creating a diff from the parent");
+		sector_size = parse_number(*sectorsize_str);
+	}
+
+	// process hunk size (needs to know sector_size)
+	UINT32 hunk_size = output_parent.opened() ? output_parent.hunk_bytes() : MAX((4096 / sector_size) * sector_size, sector_size);
+	parse_hunk_size(params, sector_size, hunk_size);
+
+	// process input start/end (needs to know hunk_size)
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, core_fsize(input_file), hunk_size, hunk_size, input_start, input_end);
+
+	// process compression
+	chd_codec_type compression[4];
+	memcpy(compression, s_default_hd_compression, sizeof(compression));
+	if (input_file == NULL)
+		compression[0] = compression[1] = compression[2] = compression[3] = CHD_CODEC_NONE;
+	parse_compression(params, compression);
+	if (input_file == NULL && compression[0] != CHD_CODEC_NONE)
+		report_error(1, "Blank hard disks must be uncompressed");
+
+	// process numprocessors
+	parse_numprocessors(params);
+
+	// process chs
+	UINT32 cylinders = 0;
+	UINT32 heads = 0;
+	UINT32 sectors = 0;
+	astring *chs_str = params.find(OPTION_CHS);
+	if (chs_str != NULL)
+	{
+		if (output_parent.opened())
+			report_error(1, "CHS does not apply when creating a diff from the parent");
+		if (sscanf(*chs_str, "%d,%d,%d", &cylinders, &heads, &sectors) != 3)
+			report_error(1, "Invalid CHS string; must be of the form <cylinders>,<heads>,<sectors>");
+	}
+
+	// process ident
+	dynamic_buffer identdata;
+	if (output_parent.opened())
+		output_parent.read_metadata(HARD_DISK_IDENT_METADATA_TAG, 0, identdata);
+	astring *ident_str = params.find(OPTION_IDENT);
+	if (ident_str != NULL)
 	{
-		was_readonly = TRUE;
-		header.flags |= CHDFLAGS_IS_WRITEABLE;
+		// load the file
+		file_error filerr = core_fload(*ident_str, identdata);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Error reading ident file (%s)", ident_str->cstr());
 
-		/* write the new header */
-		err = chd_set_header(inoutfile, &header);
-		if (err != CHDERR_NONE)
-		{
-			fprintf(stderr, "Error making CHD file writeable: %s\n", chd_error_string(err));
-			goto cleanup;
-		}
+		// must be at least 14 bytes; extract CHS data from there
+		if (identdata.count() < 14)
+			report_error(1, "Ident file '%s' is invalid (too short)", ident_str->cstr());
+		cylinders = (identdata[3] << 8) | identdata[2];
+		heads = (identdata[7] << 8) | identdata[6];
+		sectors = (identdata[13] << 8) | identdata[12];
 	}
 
-	/* open the file read/write */
-	err = chd_open(inoutfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
+	// extract geometry from the parent if we have one
+	if (output_parent.opened() && cylinders == 0)
 	{
-		fprintf(stderr, "Error opening CHD file '%s' read/write: %s\n", inoutfile, chd_error_string(err));
-		goto cleanup;
+		astring metadata;
+		if (output_parent.read_metadata(HARD_DISK_METADATA_TAG, 0, metadata) != CHDERR_NONE)
+			report_error(1, "Unable to find hard disk metadata in parent CHD");
+		if (sscanf(metadata, HARD_DISK_METADATA_FORMAT, &cylinders, &heads, &sectors, &sector_size) != 4)
+			report_error(1, "Error parsing hard disk metadata in parent CHD");
 	}
 
-	/* get the hard disk metadata */
-	err = chd_get_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
-	if (err != CHDERR_NONE || sscanf(metadata, HARD_DISK_METADATA_FORMAT, &oldcyls, &oldhds, &oldsecs, &oldsecsize) != 4)
+	// if no CHS values, try to guess them
+	if (cylinders == 0)
 	{
-		fprintf(stderr, "CHD file '%s' is not a hard disk!\n", inoutfile);
-		err = CHDERR_INVALID_FILE;
-		goto cleanup;
+		if (input_file == NULL && input_end - input_start == 0)
+			report_error(1, "Blank hard drives must specify either a length or a set of CHS values");
+		guess_chs(input_file_str, input_end - input_start, sector_size, cylinders, heads, sectors, sector_size);
 	}
+	UINT32 totalsectors = cylinders * heads * sectors;
 
-	/* write our own */
-	sprintf(metadata, HARD_DISK_METADATA_FORMAT, cyls, hds, secs, oldsecsize);
-	err = chd_set_metadata(chd, HARD_DISK_METADATA_TAG, 0, metadata, strlen(metadata) + 1, CHD_MDFLAGS_CHECKSUM);
-	if (err != CHDERR_NONE)
+	// print some info
+	astring tempstr;
+	printf("Output CHD:   %s\n", output_chd_str->cstr());
+	if (output_parent.opened())
+		printf("Parent CHD:   %s\n", params.find(OPTION_OUTPUT_PARENT)->cstr());
+	if (input_file != NULL)
 	{
-		fprintf(stderr, "Error writing new metadata to CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
+		printf("Input file:   %s\n", input_file_str->cstr());
+		if (input_start != 0 || input_end != core_fsize(input_file))
+		{
+			printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+			printf("Input length: %s\n", big_int_string(tempstr, input_end - input_start));
+		}
 	}
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("Cylinders:    %d\n", cylinders);
+	printf("Heads:        %d\n", heads);
+	printf("Sectors:      %d\n", sectors);
+	printf("Bytes/sector: %d\n", sector_size);
+	printf("Sectors/hunk: %d\n", hunk_size / sector_size);
+	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(totalsectors) * UINT64(sector_size)));
 
-	/* get the header and compute the new logical size */
-	header = *chd_get_header(chd);
-	old_logicalbytes = header.logicalbytes;
-	header.logicalbytes = (UINT64)cyls * (UINT64)hds * (UINT64)secs * (UINT64)oldsecsize;
+	// catch errors so we can close & delete the output file
+	try
+	{
+		// create the new hard drive
+		chd_rawfile_compressor chd(input_file, input_start, input_end);
+		chd_error err;
+		if (output_parent.opened())
+			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, compression, output_parent);
+		else
+			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(sector_size), hunk_size, sector_size, compression);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
-	/* close the file */
-	chd_close(chd);
-	chd = NULL;
+		// add the standard hard disk metadata
+		astring metadata;
+		metadata.format(HARD_DISK_METADATA_FORMAT, cylinders, heads, sectors, sector_size);
+		err = chd.write_metadata(HARD_DISK_METADATA_TAG, 0, metadata);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error adding hard disk metadata: %s", chd_file::error_string(err));
 
-	/* restore the read-only state */
-	if (was_readonly)
-		header.flags &= ~CHDFLAGS_IS_WRITEABLE;
+		// write the ident if present
+		if (identdata.count() > 0)
+		{
+			err = chd.write_metadata(HARD_DISK_IDENT_METADATA_TAG, 0, identdata);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error adding hard disk metadata: %s", chd_file::error_string(err));
+		}
 
-	/* set the new logical size */
-	if (header.logicalbytes != old_logicalbytes || was_readonly)
+		// compress it generically
+		if (input_file != NULL)
+			compress_common(chd);
+	}
+	catch (...)
 	{
-		err = chd_set_header(inoutfile, &header);
-		if (err != CHDERR_NONE)
-			fprintf(stderr, "Error writing new header to CHD file: %s\n", chd_error_string(err));
+		// delete the output file
+		astring *output_chd_str = params.find(OPTION_OUTPUT);
+		if (output_chd_str != NULL)
+			osd_rmfile(*output_chd_str);
+		throw;
 	}
+}
 
-	/* print a warning if the size is different */
-	if (header.logicalbytes < old_logicalbytes)
-		fprintf(stderr, "WARNING: new size is smaller; run chdman -update to reclaim empty space\n");
-	else if (header.logicalbytes > old_logicalbytes)
-		fprintf(stderr, "WARNING: new size is larger; run chdman -update to account for new empty space\n");
 
-cleanup:
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE && was_readonly)
+//-------------------------------------------------
+//  do_create_cd - create a new compressed CD
+//  image from a raw file
+//-------------------------------------------------
+
+static void do_create_cd(parameters_t &params)
+{
+	// process input file
+	chdcd_track_input_info track_info;
+	cdrom_toc toc = { 0 };
+	astring *input_file_str = params.find(OPTION_INPUT);
+	if (input_file_str != NULL)
 	{
-		header.flags &= ~CHDFLAGS_IS_WRITEABLE;
-		chd_set_header(inoutfile, &header);
+		chd_error err = chdcd_parse_toc(*input_file_str, toc, track_info);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error parsing input file (%s: %s\n", input_file_str->cstr(), chd_file::error_string(err));
 	}
-	return (err != CHDERR_NONE);
-}
 
+	// process output CHD
+	chd_file output_parent;
+	astring *output_chd_str = parse_output_chd_parameters(params, output_parent);
 
-/*-------------------------------------------------
-    do_addmeta - add metadata to a CHD from a
-    file
--------------------------------------------------*/
+	// process hunk size
+	UINT32 hunk_size = output_parent.opened() ? output_parent.hunk_bytes() : CD_FRAMES_PER_HUNK * CD_FRAME_SIZE;
+	parse_hunk_size(params, CD_FRAME_SIZE, hunk_size);
 
-static int do_addmeta(int argc, char *argv[], int param)
-{
-	const char *inoutfile, *srcfile, *tagstring;
-	UINT8 was_readonly = FALSE;
-	UINT8 *metadata = NULL;
-	chd_file *chd = NULL;
-	chd_header header;
-	file_error filerr;
-	UINT32 metalength;
-	UINT32 metaindex;
-	UINT32 metatag;
-	chd_error err;
+	// process compression
+	chd_codec_type compression[4];
+	memcpy(compression, s_default_cd_compression, sizeof(compression));
+	parse_compression(params, compression);
 
-	/* require 5 or 6 args total */
-	if (argc != 5 && argc != 6)
-		return usage();
-
-	/* extract the data */
-	inoutfile = argv[2];
-	tagstring = argv[3];
-	if (argc == 5)
+	// process numprocessors
+	parse_numprocessors(params);
+
+	// pad each track to a 4-frame boundry. cdrom.c will deal with this on the read side
+	UINT32 origtotalsectors = 0;
+	UINT32 totalsectors = 0;
+	for (int tracknum = 0; tracknum < toc.numtrks; tracknum++)
 	{
-		metaindex = 0;
-		srcfile = argv[4];
+		cdrom_track_info &trackinfo = toc.tracks[tracknum];
+		int padded = (trackinfo.frames + CD_TRACK_PADDING - 1) / CD_TRACK_PADDING;
+		trackinfo.extraframes = padded * CD_TRACK_PADDING - trackinfo.frames;
+		origtotalsectors += trackinfo.frames;
+		totalsectors += trackinfo.frames + trackinfo.extraframes;
 	}
-	else
+
+	// print some info
+	astring tempstr;
+	printf("Output CHD:   %s\n", output_chd_str->cstr());
+	if (output_parent.opened())
+		printf("Parent CHD:   %s\n", params.find(OPTION_OUTPUT_PARENT)->cstr());
+	printf("Input file:   %s\n", input_file_str->cstr());
+	printf("Input tracks: %d\n", toc.numtrks);
+	printf("Input length: %s\n", msf_string_from_frames(tempstr, origtotalsectors));
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(totalsectors) * CD_FRAME_SIZE));
+
+	// catch errors so we can close & delete the output file
+	try
 	{
-		metaindex = atoi(argv[4]);
-		srcfile = argv[5];
-	}
+		// create the new hard drive
+		chd_cd_compressor chd(toc, track_info);
+		chd_error err;
+		if (output_parent.opened())
+			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, compression, output_parent);
+		else
+			err = chd.create(*output_chd_str, UINT64(totalsectors) * UINT64(CD_FRAME_SIZE), hunk_size, CD_FRAME_SIZE, compression);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
+
+		// add the standard CD metadata; we do this even if we have a parent because it might be different
+		err = cdrom_write_metadata(&chd, &toc);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error adding CD metadata: %s", chd_file::error_string(err));
 
-	/* verify the tag */
-	if (strlen(tagstring) > 4)
+		// compress it generically
+		compress_common(chd);
+	}
+	catch (...)
 	{
-		fprintf(stderr, "Invalid tag '%s'; must be 4 characters or less\n", tagstring);
-		return CHDERR_INVALID_PARAMETER;
+		// delete the output file
+		astring *output_chd_str = params.find(OPTION_OUTPUT);
+		if (output_chd_str != NULL)
+			osd_rmfile(*output_chd_str);
+		throw;
 	}
-	metatag = ((tagstring[0] == 0) ? ' ' : tagstring[0]) << 24;
-	metatag |= ((tagstring[1] == 0) ? ' ' : tagstring[1]) << 16;
-	metatag |= ((tagstring[2] == 0) ? ' ' : tagstring[2]) << 8;
-	metatag |= ((tagstring[3] == 0) ? ' ' : tagstring[3]) << 0;
+}
 
-	/* print some info */
-	printf("Input file:   %s\n", inoutfile);
-	printf("Tag:          '%c%c%c%c'\n", (metatag >> 24) & 0xff, (metatag >> 16) & 0xff, (metatag >> 8) & 0xff, metatag & 0xff);
-	printf("Index:        %d\n", metaindex);
-	printf("Source file:  %s\n", srcfile);
 
-	/* open the file read-only and get the header */
-	err = chd_open(inoutfile, CHD_OPEN_READ, NULL, &chd);
-	if (err != CHDERR_NONE)
+//-------------------------------------------------
+//  do_create_ld - create a new A/V file from an
+//  input AVI file and metadata
+//-------------------------------------------------
+
+static void do_create_ld(parameters_t &params)
+{
+	// process input file
+	avi_file *input_file = NULL;
+	astring *input_file_str = params.find(OPTION_INPUT);
+	if (input_file_str != NULL)
 	{
-		fprintf(stderr, "Error opening CHD file '%s' read-only: %s\n", inoutfile, chd_error_string(err));
-		goto cleanup;
+		avi_error avierr = avi_open(*input_file_str, &input_file);
+		if (avierr != AVIERR_NONE)
+			report_error(1, "Error opening AVI file (%s): %s\n", input_file_str->cstr(), avi_error_string(avierr));
 	}
-	header = *chd_get_header(chd);
-	chd_close(chd);
-	chd = NULL;
+	const avi_movie_info *aviinfo = avi_get_movie_info(input_file);
 
-	/* if the drive is not writeable, note that, and make it so */
-	if (!(header.flags & CHDFLAGS_IS_WRITEABLE))
+	// process output CHD
+	chd_file output_parent;
+	astring *output_chd_str = parse_output_chd_parameters(params, output_parent);
+
+	// process input start/end
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, aviinfo->video_numsamples, 0, 1, input_start, input_end);
+
+	// determine parameters of the incoming video stream
+	avi_info info;
+	info.fps_times_1million = UINT64(aviinfo->video_timescale) * 1000000 / aviinfo->video_sampletime;
+	info.width = aviinfo->video_width;
+	info.height = aviinfo->video_height;
+	info.interlaced = ((info.fps_times_1million / 1000000) <= 30) && (info.height % 2 == 0) && (info.height > 288);
+	info.channels = aviinfo->audio_channels;
+	info.rate = aviinfo->audio_samplerate;
+
+	// adjust for interlacing
+	if (info.interlaced)
+	{
+		info.fps_times_1million *= 2;
+		info.height /= 2;
+		input_start *= 2;
+		input_end *= 2;
+	}
+
+	// determine the number of bytes per frame
+	info.max_samples_per_frame = (UINT64(info.rate) * 1000000 + info.fps_times_1million - 1) / info.fps_times_1million;
+	info.bytes_per_frame = avhuff_encoder::raw_data_size(info.width, info.height, info.channels, info.max_samples_per_frame);
+
+	// process hunk size
+	UINT32 hunk_size = output_parent.opened() ? output_parent.hunk_bytes() : info.bytes_per_frame;
+	parse_hunk_size(params, info.bytes_per_frame, hunk_size);
+
+	// process compression
+	chd_codec_type compression[4];
+	memcpy(compression, s_default_ld_compression, sizeof(compression));
+	parse_compression(params, compression);
+
+	// process numprocessors
+	parse_numprocessors(params);
+
+	// print some info
+	astring tempstr;
+	printf("Output CHD:   %s\n", output_chd_str->cstr());
+	if (output_parent.opened())
+		printf("Parent CHD:   %s\n", params.find(OPTION_OUTPUT_PARENT)->cstr());
+	printf("Input file:   %s\n", input_file_str->cstr());
+	if (input_start != 0 && input_end != aviinfo->video_numsamples)
+		printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+	printf("Input length: %s (%02d:%02d:%02d)\n", big_int_string(tempstr, input_end - input_start),
+			UINT32((UINT64(input_end - input_start) * 1000000 / info.fps_times_1million / 60 / 60)),
+			UINT32(((UINT64(input_end - input_start) * 1000000 / info.fps_times_1million / 60) % 60)),
+			UINT32(((UINT64(input_end - input_start) * 1000000 / info.fps_times_1million) % 60)));
+	printf("Frame rate:   %d.%06d\n", info.fps_times_1million / 1000000, info.fps_times_1million % 1000000);
+	printf("Frame size:   %d x %d %s\n", info.width, info.height * (info.interlaced ? 2 : 1), info.interlaced ? "interlaced" : "non-interlaced");
+	printf("Audio:        %d channels at %d Hz\n", info.channels, info.rate);
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("Hunk size:    %s\n", big_int_string(tempstr, hunk_size));
+	printf("Logical size: %s\n", big_int_string(tempstr, UINT64(input_end - input_start) * hunk_size));
+
+	// catch errors so we can close & delete the output file
+	try
 	{
-		was_readonly = TRUE;
-		header.flags |= CHDFLAGS_IS_WRITEABLE;
+		// create the new CHD
+		chd_avi_compressor chd(*input_file, info, input_start, input_end);
+		chd_error err;
+		if (output_parent.opened())
+			err = chd.create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, compression, output_parent);
+		else
+			err = chd.create(*output_chd_str, UINT64(input_end - input_start) * hunk_size, hunk_size, info.bytes_per_frame, compression);
+		if (err != CHDERR_NONE)
+			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
 
-		/* write the new header */
-		err = chd_set_header(inoutfile, &header);
+		// write the core A/V metadata
+		astring metadata;
+		metadata.format(AV_METADATA_FORMAT, info.fps_times_1million / 1000000, info.fps_times_1million % 1000000, info.width, info.height, info.interlaced, info.channels, info.rate);
+		err = chd.write_metadata(AV_METADATA_TAG, 0, metadata);
 		if (err != CHDERR_NONE)
+			report_error(1, "Error adding AV metadata: %s\n", chd_file::error_string(err));
+
+		// create the compressor and then run it generically
+		compress_common(chd);
+
+		// write the final LD metadata
+		if (info.height == 524/2 || info.height == 624/2)
 		{
-			fprintf(stderr, "Error making CHD file writeable: %s\n", chd_error_string(err));
-			goto cleanup;
+			err = chd.write_metadata(AV_LD_METADATA_TAG, 0, chd.ldframedata());
+			if (err != CHDERR_NONE)
+				report_error(1, "Error adding AVLD metadata: %s\n", chd_file::error_string(err));
 		}
 	}
-
-	/* open the file read/write */
-	err = chd_open(inoutfile, CHD_OPEN_READWRITE, NULL, &chd);
-	if (err != CHDERR_NONE)
+	catch (...)
 	{
-		fprintf(stderr, "Error opening CHD file '%s' read/write: %s\n", inoutfile, chd_error_string(err));
-		goto cleanup;
+		// delete the output file
+		astring *output_chd_str = params.find(OPTION_OUTPUT);
+		if (output_chd_str != NULL)
+			osd_rmfile(*output_chd_str);
+		throw;
 	}
+}
 
-	/* attempt to open the source file */
-	filerr = core_fload(srcfile, (void **)&metadata, &metalength);
-	if (filerr != FILERR_NONE)
-	{
-		fprintf(stderr, "Error opening source file '%s'\n", srcfile);
-		err = CHDERR_FILE_NOT_FOUND;
-		goto cleanup;
-	}
 
-	/* if it's text, strip any trailing Ctrl-Z and CR/LF and add a trailing NULL */
-	if (param)
+//-------------------------------------------------
+//  do_copy - create a new CHD with data from
+//  another CHD
+//-------------------------------------------------
+
+static void do_copy(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
+
+	// parse out input start/end
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, input_chd.logical_bytes(), input_chd.hunk_bytes(), input_chd.hunk_bytes(), input_start, input_end);
+
+	// process output CHD
+	chd_file output_parent;
+	astring *output_chd_str = parse_output_chd_parameters(params, output_parent);
+
+	// process hunk size
+	UINT32 hunk_size = input_chd.hunk_bytes();
+	parse_hunk_size(params, 1, hunk_size);
+	if (hunk_size % input_chd.hunk_bytes() != 0 && input_chd.hunk_bytes() % hunk_size != 0)
+		report_error(1, "Hunk size is not an even multiple or divisor of input hunk size");
+
+	// process compression; we default to our current preferences using metadata to pick the type
+	chd_codec_type compression[4];
 	{
-		metadata = (UINT8 *)realloc(metadata, metalength + 1);
-		if (metadata == NULL)
-		{
-			fprintf(stderr, "Out of memory preparing metadata\n");
-			err = CHDERR_OUT_OF_MEMORY;
-			goto cleanup;
-		}
-		metadata[metalength++] = 0;
-		while (metalength > 0 && (metadata[metalength - 2] == 0x0a || metadata[metalength - 2] == 0x0d || metadata[metalength - 2] == 0x1a))
-			metadata[--metalength] = 0;
+		dynamic_buffer metadata;
+		if (input_chd.read_metadata(HARD_DISK_METADATA_TAG, 0, metadata) == CHDERR_NONE)
+			memcpy(compression, s_default_hd_compression, sizeof(compression));
+		else if (input_chd.read_metadata(AV_METADATA_TAG, 0, metadata) == CHDERR_NONE)
+			memcpy(compression, s_default_ld_compression, sizeof(compression));
+		else if (input_chd.read_metadata(CDROM_OLD_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
+				 input_chd.read_metadata(CDROM_TRACK_METADATA_TAG, 0, metadata) == CHDERR_NONE ||
+				 input_chd.read_metadata(CDROM_TRACK_METADATA2_TAG, 0, metadata) == CHDERR_NONE)
+			memcpy(compression, s_default_cd_compression, sizeof(compression));
+		else
+			memcpy(compression, s_default_raw_compression, sizeof(compression));
 	}
+	parse_compression(params, compression);
 
-	/* write the new metadata */
-	err = chd_set_metadata(chd, metatag, metaindex, metadata, metalength, CHD_MDFLAGS_CHECKSUM);
-	if (err != CHDERR_NONE)
+	// process numprocessors
+	parse_numprocessors(params);
+
+	// print some info
+	astring tempstr;
+	printf("Output CHD:   %s\n", output_chd_str->cstr());
+	if (output_parent.opened())
+		printf("Parent CHD:   %s\n", params.find(OPTION_OUTPUT_PARENT)->cstr());
+	printf("Input CHD:    %s\n", params.find(OPTION_INPUT)->cstr());
+	if (input_start != 0 || input_end != input_chd.logical_bytes())
 	{
-		fprintf(stderr, "Error writing new metadata to CHD file: %s\n", chd_error_string(err));
-		goto cleanup;
+		printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+		printf("Input length: %s\n", big_int_string(tempstr, input_end - input_start));
 	}
-	header = *chd_get_header(chd);
-
-	/* close the file */
-	chd_close(chd);
-	chd = NULL;
+	printf("Compression:  %s\n", compression_string(tempstr, compression));
+	printf("Hunk size:    %s\n", big_int_string(tempstr, hunk_size));
+	printf("Logical size: %s\n", big_int_string(tempstr, input_end - input_start));
 
-	/* restore the read-only state */
-	if (was_readonly)
+	// catch errors so we can close & delete the output file
+	try
 	{
-		header.flags &= ~CHDFLAGS_IS_WRITEABLE;
-		err = chd_set_header(inoutfile, &header);
+		// create the new CHD
+		chd_chdfile_compressor chd(input_chd, input_start, input_end);
+		chd_error err;
+		if (output_parent.opened())
+			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, compression, output_parent);
+		else
+			err = chd.create(*output_chd_str, input_end - input_start, hunk_size, input_chd.unit_bytes(), compression);
 		if (err != CHDERR_NONE)
-			fprintf(stderr, "Error writing new header to CHD file: %s\n", chd_error_string(err));
-	}
-	if (err == CHDERR_NONE)
-		printf("Metadata added successfully as %s\n", param ? "text" : "binary");
+			report_error(1, "Error creating CHD file (%s): %s", output_chd_str->cstr(), chd_file::error_string(err));
+
+		// clone all the metadata, upgrading where appropriate
+		dynamic_buffer metadata;
+		chd_metadata_tag metatag;
+		UINT8 metaflags;
+		UINT32 index = 0;
+		bool redo_cd = false;
+		for (err = input_chd.read_metadata(CHDMETATAG_WILDCARD, index++, metadata, metatag, metaflags); err == CHDERR_NONE; err = input_chd.read_metadata(CHDMETATAG_WILDCARD, index++, metadata, metatag, metaflags))
+		{
+			// if this is an old CD-CHD tag, note that we want to re-do it
+			if (metatag == CDROM_OLD_METADATA_TAG || metatag == CDROM_TRACK_METADATA_TAG)
+			{
+				redo_cd = true;
+				continue;
+			}
+
+			// otherwise, clone it
+			err = chd.write_metadata(metatag, CHDMETAINDEX_APPEND, metadata);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error writing cloned metadata: %s", chd_file::error_string(err));
+		}
 
-cleanup:
-	if (metadata != NULL)
-		osd_free(metadata);
-	if (chd != NULL)
-		chd_close(chd);
-	if (err != CHDERR_NONE && was_readonly)
+		// if we need to re-do the CD metadata, do it now
+		if (redo_cd)
+		{
+			cdrom_file *cdrom = cdrom_open(&input_chd);
+			if (cdrom == NULL)
+				report_error(1, "Error upgrading CD metadata");
+			const cdrom_toc *toc = cdrom_get_toc(cdrom);
+			err = cdrom_write_metadata(&chd, toc);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error writing upgraded CD metadata: %s", chd_file::error_string(err));
+		}
+
+		// compress it generically
+		compress_common(chd);
+	}
+	catch (...)
 	{
-		header.flags &= ~CHDFLAGS_IS_WRITEABLE;
-		chd_set_header(inoutfile, &header);
+		// delete the output file
+		astring *output_chd_str = params.find(OPTION_OUTPUT);
+		if (output_chd_str != NULL)
+			osd_rmfile(*output_chd_str);
+		throw;
 	}
-	return (err != CHDERR_NONE);
 }
 
 
-/*-------------------------------------------------
-    chdman_compress_file - compress a regular
-    file via the compression interfaces
--------------------------------------------------*/
+//-------------------------------------------------
+//  do_extract_raw - extract a raw file from a
+//  CHD image
+//-------------------------------------------------
 
-static chd_error chdman_compress_file(chd_file *chd, const char *rawfile, UINT32 offset)
+static void do_extract_raw(parameters_t &params)
 {
-	core_file *sourcefile;
-	const chd_header *header;
-	UINT64 sourceoffset = 0;
-	UINT8 *cache = NULL;
-	double ratio = 1.0;
-	file_error filerr;
-	chd_error err;
-	int hunknum;
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
 
-	/* open the raw file */
-	filerr = core_fopen(rawfile, OPEN_FLAG_READ, &sourcefile);
-	if (filerr != FILERR_NONE)
-	{
-		err = CHDERR_FILE_NOT_FOUND;
-		goto cleanup;
-	}
+	// parse out input start/end
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, input_chd.logical_bytes(), input_chd.hunk_bytes(), input_chd.hunk_bytes(), input_start, input_end);
 
-	/* get the header */
-	header = chd_get_header(chd);
-	cache = (UINT8 *)malloc(header->hunkbytes);
-	if (cache == NULL)
+	// verify output file doesn't exist
+	astring *output_file_str = params.find(OPTION_OUTPUT);
+	if (output_file_str != NULL)
+		check_existing_output_file(params, *output_file_str);
+
+	// print some info
+	astring tempstr;
+	printf("Output File:  %s\n", output_file_str->cstr());
+	printf("Input CHD:    %s\n", params.find(OPTION_INPUT)->cstr());
+	if (input_start != 0 || input_end != input_chd.logical_bytes())
 	{
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
+		printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+		printf("Input length: %s\n", big_int_string(tempstr, input_end - input_start));
 	}
 
-	/* begin compressing */
-	err = chd_compress_begin(chd);
-	if (err != CHDERR_NONE)
-		goto cleanup;
-
-	/* loop over source hunks until we run out */
-	for (hunknum = 0; hunknum < header->totalhunks; hunknum++)
+	// catch errors so we can close & delete the output file
+	core_file *output_file = NULL;
+	try
 	{
-		UINT32 bytesread;
-
-		/* progress */
-		progress(hunknum == 0, "Compressing hunk %d/%d... (ratio=%d%%)  \r", hunknum, header->totalhunks, (int)(100.0 * ratio));
-
-		/* read the data */
-		core_fseek(sourcefile, sourceoffset + offset, SEEK_SET);
-		bytesread = core_fread(sourcefile, cache, header->hunkbytes);
-		if (bytesread < header->hunkbytes)
-			memset(&cache[bytesread], 0, header->hunkbytes - bytesread);
+		// process output file
+		file_error filerr = core_fopen(*output_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Unable to open file (%s)", output_file_str->cstr());
 
-		/* append the data */
-		err = chd_compress_hunk(chd, cache, &ratio);
-		if (err != CHDERR_NONE)
-			goto cleanup;
+		// copy all data
+		dynamic_buffer buffer((TEMP_BUFFER_SIZE / input_chd.hunk_bytes()) * input_chd.hunk_bytes());
+		for (UINT64 offset = input_start; offset < input_end; )
+		{
+			progress(false, "Extracting, %.1f%% complete... \r", 100.0 * double(offset - input_start) / double(input_end - input_start));
 
-		/* prepare for the next hunk */
-		sourceoffset += header->hunkbytes;
-	}
+			// determine how much to read
+			UINT32 bytes_to_read = MIN(buffer.count(), input_end - offset);
+			chd_error err = input_chd.read_bytes(offset, buffer, bytes_to_read);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error reading CHD file (%s): %s", params.find(OPTION_INPUT)->cstr(), chd_file::error_string(err));
 
-	/* finish compression */
-	err = chd_compress_finish(chd, TRUE);
-	if (err != CHDERR_NONE)
-		goto cleanup;
+			// write to the output
+			UINT32 count = core_fwrite(output_file, buffer, bytes_to_read);
+			if (count != bytes_to_read)
+				report_error(1, "Error writing to file; check disk space (%s)", output_file_str->cstr());
 
-	/* final progress update */
-	progress(TRUE, "Compression complete ... final ratio = %d%%            \n", (int)(100.0 * ratio));
+			// advance
+			offset += bytes_to_read;
+		}
 
-cleanup:
-	if (sourcefile != NULL)
-		core_fclose(sourcefile);
-	if (cache != NULL)
-		free(cache);
-	return err;
+		// finish up
+		core_fclose(output_file);
+		printf("Extraction complete                                    \n");
+	}
+	catch (...)
+	{
+		// delete the output file
+		if (output_file != NULL)
+		{
+			core_fclose(output_file);
+			osd_rmfile(*output_file_str);
+		}
+		throw;
+	}
 }
 
 
-/*-------------------------------------------------
-    chdman_compress_chd - (re)compress a CHD file
-    via the compression interfaces
--------------------------------------------------*/
+//-------------------------------------------------
+//  do_extract_cd - extract a CD file from a
+//  CHD image
+//-------------------------------------------------
 
-static chd_error chdman_compress_chd(chd_file *chd, chd_file *source, UINT32 totalhunks)
+static void do_extract_cd(parameters_t &params)
 {
-	const chd_header *source_header;
-	const chd_header *header;
-	UINT8 *source_cache = NULL;
-	UINT64 source_offset = 0;
-	UINT32 source_bytes = 0;
-	UINT8 *cache = NULL;
-	double ratio = 1.0;
-	chd_error err, verifyerr;
-	int hunknum;
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
 
-	/* get the header */
-	header = chd_get_header(chd);
-	cache = (UINT8 *)malloc(header->hunkbytes);
-	if (cache == NULL)
-	{
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
-	}
+	// further process input file
+	cdrom_file *cdrom = cdrom_open(&input_chd);
+	if (cdrom == NULL)
+		report_error(1, "Unable to recognize CHD file as a CD");
+	const cdrom_toc *toc = cdrom_get_toc(cdrom);
 
-	/* get the source CHD header */
-	source_header = chd_get_header(source);
-	source_cache = (UINT8 *)malloc(source_header->hunkbytes);
-	if (source_cache == NULL)
+	// verify output file doesn't exist
+	astring *output_file_str = params.find(OPTION_OUTPUT);
+	if (output_file_str != NULL)
+		check_existing_output_file(params, *output_file_str);
+
+	// verify output BIN file doesn't exist
+	astring *output_bin_file_str = params.find(OPTION_OUTPUT_BIN);
+	astring default_name(*output_file_str);
+	int chop = default_name.rchr(0, '.');
+	if (chop != -1)
+		default_name.substr(0, chop);
+	default_name.cat(".bin");
+	if (output_bin_file_str == NULL)
+		output_bin_file_str = &default_name;
+	check_existing_output_file(params, *output_bin_file_str);
+
+	// print some info
+	astring tempstr;
+	printf("Output TOC:   %s\n", output_file_str->cstr());
+	printf("Output Data:  %s\n", output_bin_file_str->cstr());
+	printf("Input CHD:    %s\n", params.find(OPTION_INPUT)->cstr());
+
+	// catch errors so we can close & delete the output file
+	core_file *output_bin_file = NULL;
+	core_file *output_toc_file = NULL;
+	try
 	{
-		err = CHDERR_OUT_OF_MEMORY;
-		goto cleanup;
-	}
+		// process output file
+		file_error filerr = core_fopen(*output_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_NO_BOM, &output_toc_file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Unable to open file (%s)", output_file_str->cstr());
+		bool cuemode = (output_file_str->find(".cue") != -1);
 
-	/* begin compressing */
-	err = chd_compress_begin(chd);
-	if (err != CHDERR_NONE)
-		goto cleanup;
+		// process output BIN file
+		filerr = core_fopen(*output_bin_file_str, OPEN_FLAG_WRITE | OPEN_FLAG_CREATE, &output_bin_file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Unable to open file (%s)", output_bin_file_str->cstr());
 
-	/* also begin verifying the source driver */
-	verifyerr = chd_verify_begin(source);
+		// determine total frames
+		UINT64 total_bytes = 0;
+		for (int tracknum = 0; tracknum < toc->numtrks; tracknum++)
+			total_bytes += toc->tracks[tracknum].frames * (toc->tracks[tracknum].datasize + toc->tracks[tracknum].subsize);
+
+		// iterate over tracks and copy all data
+		UINT64 outputoffs = 0;
+		UINT32 discoffs = 0;
+		dynamic_buffer buffer;
+		for (int tracknum = 0; tracknum < toc->numtrks; tracknum++)
+		{
+			// output the metadata about the track to the TOC file
+			const cdrom_track_info &trackinfo = toc->tracks[tracknum];
+			output_track_metadata(cuemode, output_toc_file, tracknum, trackinfo, *output_bin_file_str, discoffs, outputoffs);
+
+			// resize the buffer for the track
+			UINT32 output_frame_size = trackinfo.datasize + ((trackinfo.subtype != CD_SUB_NONE) ? trackinfo.subsize : 0);
+			buffer.resize((TEMP_BUFFER_SIZE / output_frame_size) * output_frame_size);
+
+			// now read and output the actual data
+			UINT32 bufferoffs = 0;
+			for (int frame = 0; frame < trackinfo.frames; frame++)
+			{
+				progress(false, "Extracting, %.1f%% complete... \r", 100.0 * double(outputoffs) / double(total_bytes));
+
+				// read the data
+				cdrom_read_data(cdrom, cdrom_get_track_start(cdrom, tracknum) + frame, &buffer[bufferoffs], trackinfo.trktype);
+
+				// for CDRWin, audio tracks must be reversed
+				if (cuemode && (trackinfo.trktype == CD_TRACK_AUDIO))
+					for (int swapindex = 0; swapindex < trackinfo.datasize; swapindex += 2)
+					{
+						UINT8 swaptemp = buffer[bufferoffs + swapindex];
+						buffer[bufferoffs + swapindex] = buffer[bufferoffs + swapindex + 1];
+						buffer[bufferoffs + swapindex + 1] = swaptemp;
+					}
+				bufferoffs += trackinfo.datasize;
+				discoffs++;
+
+				// read the subcode data
+				if (trackinfo.subtype != CD_SUB_NONE)
+				{
+					cdrom_read_subcode(cdrom, cdrom_get_track_start(cdrom, tracknum) + frame, &buffer[bufferoffs]);
+					bufferoffs += trackinfo.subsize;
+				}
 
-	/* a zero count means the natural number */
-	if (totalhunks == 0)
-		totalhunks = source_header->totalhunks;
+				// write it out if we need to
+				if (bufferoffs == buffer.count() || frame == trackinfo.frames - 1)
+				{
+					core_fseek(output_bin_file, outputoffs, SEEK_SET);
+					UINT32 byteswritten = core_fwrite(output_bin_file, buffer, bufferoffs);
+					if (byteswritten != bufferoffs)
+						report_error(1, "Error writing frame %d to file (%s): %s\n", frame, output_file_str->cstr(), chd_file::error_string(CHDERR_WRITE_ERROR));
+					outputoffs += bufferoffs;
+					bufferoffs = 0;
+				}
+			}
+		}
 
-	/* loop over source hunks until we run out */
-	for (hunknum = 0; hunknum < totalhunks; hunknum++)
+		// finish up
+		core_fclose(output_bin_file);
+		core_fclose(output_toc_file);
+		printf("Extraction complete                                    \n");
+	}
+	catch (...)
 	{
-		UINT32 bytesremaining = header->hunkbytes;
-		UINT8 *dest = cache;
+		// delete the output files
+		if (output_bin_file != NULL)
+			core_fclose(output_bin_file);
+		if (output_toc_file != NULL)
+			core_fclose(output_toc_file);
+		osd_rmfile(*output_bin_file_str);
+		osd_rmfile(*output_file_str);
+		throw;
+	}
+}
 
-		/* progress */
-		progress(hunknum == 0, "Compressing hunk %d/%d... (ratio=%d%%)  \r", hunknum, totalhunks, (int)(100.0 * ratio));
 
-		/* read the data */
-		while (bytesremaining > 0)
-		{
-			/* if we have data in the buffer, copy it */
-			if (source_bytes > 0)
-			{
-				UINT32 bytestocopy = MIN(bytesremaining, source_bytes);
-				memcpy(dest, &source_cache[source_header->hunkbytes - source_bytes], bytestocopy);
-				dest += bytestocopy;
-				source_bytes -= bytestocopy;
-				bytesremaining -= bytestocopy;
-			}
+//-------------------------------------------------
+//  do_extract_ld - extract an AVI file from a
+//  CHD image
+//-------------------------------------------------
 
-			/* otherwise, read in another hunk of the source */
-			else
-			{
-				/* verify the next hunk */
-				if (verifyerr == CHDERR_NONE)
-					err = chd_verify_hunk(source);
-
-				/* then read it (should be the same) */
-				err = chd_read(source, source_offset / source_header->hunkbytes, source_cache);
-				if (err != CHDERR_NONE)
-					memset(source_cache, 0, source_header->hunkbytes);
-				source_bytes = source_header->hunkbytes;
-				source_offset += source_bytes;
-			}
-		}
+static void do_extract_ld(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd);
 
-		/* append the data */
-		err = chd_compress_hunk(chd, cache, &ratio);
-		if (err != CHDERR_NONE)
-			goto cleanup;
+	// read core metadata
+	astring metadata;
+	chd_error err = input_chd.read_metadata(AV_METADATA_TAG, 0, metadata);
+	if (err != CHDERR_NONE)
+		report_error(1, "Unable to find A/V metadata in the input CHD");
+
+	// parse the metadata
+	UINT32 fps_times_1million;
+	UINT32 max_samples_per_frame;
+	UINT32 frame_bytes;
+	int width;
+	int height;
+	int interlaced;
+	int channels;
+	int rate;
+	{
+		int fps;
+		int fpsfrac;
+		if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
+			report_error(1, "Improperly formatted A/V metadata found");
+		fps_times_1million = fps * 1000000 + fpsfrac;
 	}
+	int interlace_factor = interlaced ? 2 : 1;
+
+	// determine key parameters and validate
+	max_samples_per_frame = (UINT64(rate) * 1000000 + fps_times_1million - 1) / fps_times_1million;
+	frame_bytes = avhuff_encoder::raw_data_size(width, height, channels, max_samples_per_frame);
+	if (frame_bytes != input_chd.hunk_bytes())
+		report_error(1, "Frame size does not match hunk size for this CHD");
+
+	// parse out input start/end
+	UINT64 input_start;
+	UINT64 input_end;
+	parse_input_start_end(params, input_chd.hunk_count() / interlace_factor, 0, 1, input_start, input_end);
+	input_start *= interlace_factor;
+	input_end *= interlace_factor;
 
-	/* if we read all the source data, verify the checksums */
-	if (verifyerr == CHDERR_NONE && source_offset >= source_header->logicalbytes)
+	// build up the movie info
+	avi_movie_info info;
+	info.video_format = FORMAT_YUY2;
+	info.video_timescale = fps_times_1million / interlace_factor;
+	info.video_sampletime = 1000000;
+	info.video_width = width;
+	info.video_height = height * interlace_factor;
+	info.video_depth = 16;
+	info.audio_format = 0;
+	info.audio_timescale = rate;
+	info.audio_sampletime = 1;
+	info.audio_channels = channels;
+	info.audio_samplebits = 16;
+	info.audio_samplerate = rate;
+
+	// verify output file doesn't exist
+	astring *output_file_str = params.find(OPTION_OUTPUT);
+	if (output_file_str != NULL)
+		check_existing_output_file(params, *output_file_str);
+
+	// print some info
+	astring tempstr;
+	printf("Output File:  %s\n", output_file_str->cstr());
+	printf("Input CHD:    %s\n", params.find(OPTION_INPUT)->cstr());
+	if (input_start != 0 || input_end != input_chd.hunk_count())
+	{
+		printf("Input start:  %s\n", big_int_string(tempstr, input_start));
+		printf("Input length: %s\n", big_int_string(tempstr, input_end - input_start));
+	}
+
+	// catch errors so we can close & delete the output file
+	avi_file *output_file = NULL;
+	try
 	{
-		static const UINT8 empty_checksum[CHD_SHA1_BYTES] = { 0 };
-		chd_verify_result verify;
-		int i;
+		// process output file
+		avi_error avierr = avi_create(*output_file_str, &info, &output_file);
+		if (avierr != AVIERR_NONE)
+			report_error(1, "Unable to open file (%s)", output_file_str->cstr());
 
-		/* get the final values */
-		err = chd_verify_finish(source, &verify);
+		// create the codec configuration
+		avhuff_decompress_config avconfig;
+		dynamic_array<INT16> audio_data[16];
+		UINT32 actsamples;
+		avconfig.maxsamples = max_samples_per_frame;
+		avconfig.actsamples = &actsamples;
+		for (int chnum = 0; chnum < ARRAY_LENGTH(audio_data); chnum++)
+		{
+			audio_data[chnum].resize(max_samples_per_frame);
+			avconfig.audio[chnum] = audio_data[chnum];
+		}
 
-		/* check the MD5 */
-		if (memcmp(source_header->md5, empty_checksum, CHD_MD5_BYTES) != 0)
+		// iterate over frames
+		bitmap_yuy16 fullbitmap(width, height * interlace_factor);
+		for (int framenum = input_start; framenum < input_end; framenum++)
 		{
-			if (memcmp(source_header->md5, verify.md5, CHD_MD5_BYTES) != 0)
+			progress(framenum == 0, "Extracting, %.1f%% complete...  \r", 100.0 * double(framenum - input_start) / double(input_end - input_start));
+
+			// set up the fake bitmap for this frame
+			avconfig.video.wrap(&fullbitmap.pix(framenum % interlace_factor), fullbitmap.width(), fullbitmap.height() / interlace_factor, fullbitmap.rowpixels() * interlace_factor);
+			input_chd.codec_configure(CHD_CODEC_AVHUFF, AVHUFF_CODEC_DECOMPRESS_CONFIG, &avconfig);
+
+			// read the hunk into the buffers
+			chd_error err = input_chd.read_hunk(framenum, NULL);
+			if (err != CHDERR_NONE)
+				report_error(1, "Error reading hunk %d from CHD file (%s): %s\n", framenum, params.find(OPTION_INPUT)->cstr(), chd_file::error_string(err));
+
+			// write audio
+			for (int chnum = 0; chnum < channels; chnum++)
 			{
-				progress(TRUE, "WARNING: expected input MD5 = ");
-				for (i = 0; i < CHD_MD5_BYTES; i++)
-					progress(TRUE, "%02x", source_header->md5[i]);
-				progress(TRUE, "\n");
-
-				progress(TRUE, "                 actual MD5 = ");
-				for (i = 0; i < CHD_MD5_BYTES; i++)
-					progress(TRUE, "%02x", verify.md5[i]);
-				progress(TRUE, "\n");
+				avi_error avierr = avi_append_sound_samples(output_file, chnum, avconfig.audio[chnum], actsamples, 0);
+				if (avierr != AVIERR_NONE)
+					report_error(1, "Error writing samples for hunk %d to file (%s): %s\n", framenum, output_file_str->cstr(), avi_error_string(avierr));
 			}
-			else
-				progress(TRUE, "Input MD5 verified                            \n");
-		}
 
-		/* check the SHA1 */
-		if (memcmp(source_header->sha1, empty_checksum, CHD_SHA1_BYTES) != 0)
-		{
-			if (memcmp(source_header->sha1, verify.sha1, CHD_SHA1_BYTES) != 0)
+			// write video
+			if (framenum % interlace_factor == interlace_factor - 1)
 			{
-				progress(TRUE, "WARNING: expected input SHA1 = ");
-				for (i = 0; i < CHD_SHA1_BYTES; i++)
-					progress(TRUE, "%02x", source_header->sha1[i]);
-				progress(TRUE, "\n");
-
-				progress(TRUE, "                 actual SHA1 = ");
-				for (i = 0; i < CHD_SHA1_BYTES; i++)
-					progress(TRUE, "%02x", verify.sha1[i]);
-				progress(TRUE, "\n");
+				avi_error avierr = avi_append_video_frame(output_file, fullbitmap);
+				if (avierr != AVIERR_NONE)
+					report_error(1, "Error writing video for hunk %d to file (%s): %s\n", framenum, output_file_str->cstr(), avi_error_string(avierr));
 			}
-			else
-				progress(TRUE, "Input SHA1 verified                            \n");
 		}
+
+		// close and return
+		avi_close(output_file);
+		printf("Extraction complete                                    \n");
+	}
+	catch (...)
+	{
+		// delete the output file
+		if (output_file != NULL)
+			avi_close(output_file);
+		osd_rmfile(*output_file_str);
+		throw;
 	}
+}
 
-	/* finish compression */
-	err = chd_compress_finish(chd, !(source_header->flags & CHDFLAGS_IS_WRITEABLE));
-	if (err != CHDERR_NONE)
-		goto cleanup;
 
-	/* final progress update */
-	progress(TRUE, "Compression complete ... final ratio = %d%%            \n", (int)(100.0 * ratio));
+//-------------------------------------------------
+//  do_add_metadata - add metadata to a CHD from a
+//  file
+//-------------------------------------------------
 
-cleanup:
-	if (source_cache != NULL)
-		free(source_cache);
-	if (cache != NULL)
-		free(cache);
-	return err;
-}
+static void do_add_metadata(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd, true);
 
+	// process tag
+	chd_metadata_tag tag = CHD_MAKE_TAG('?','?','?','?');
+	astring *tag_str = params.find(OPTION_TAG);
+	if (tag_str != NULL)
+	{
+		tag_str->cat("    ");
+		tag = CHD_MAKE_TAG((*tag_str)[0], (*tag_str)[1], (*tag_str)[2], (*tag_str)[3]);
+	}
 
-/*-------------------------------------------------
-    chdman_clone_metadata - clone the metadata from
-    one CHD to a second
--------------------------------------------------*/
+	// process index
+	UINT32 index = 0;
+	astring *index_str = params.find(OPTION_INDEX);
+	if (index_str != NULL)
+		index = atoi(*index_str);
 
-static chd_error chdman_clone_metadata(chd_file *source, chd_file *dest)
-{
-	const chd_header *header = chd_get_header(source);
-	UINT8 metabuffer[MAX(4096, sizeof(cdrom_toc))];
-	UINT32 metatag, metasize, metaindex;
-	UINT8 metaflags;
-	chd_error err;
+	// process text input
+	astring *text_str = params.find(OPTION_VALUE_TEXT);
+	astring text;
+	if (text_str != NULL)
+	{
+		text = *text_str;
+		if (text[0] == '"' && text[text.len() - 1] == '"')
+			text.substr(1, text.len() - 2);
+	}
 
-	/* clone the metadata */
-	for (metaindex = 0; ; metaindex++)
+	// process file input
+	astring *file_str = params.find(OPTION_VALUE_FILE);
+	dynamic_buffer file;
+	if (file_str != NULL)
 	{
-		/* fetch the next piece of metadata */
-		err = chd_get_metadata(source, CHDMETATAG_WILDCARD, metaindex, metabuffer, sizeof(metabuffer), &metasize, &metatag, &metaflags);
-		if (err != CHDERR_NONE)
-		{
-			if (err == CHDERR_METADATA_NOT_FOUND)
-				err = CHDERR_NONE;
-			break;
-		}
+		file_error filerr = core_fload(*file_str, file);
+		if (filerr != FILERR_NONE)
+			report_error(1, "Error reading metadata file (%s)", file_str->cstr());
+	}
 
-		/* promote certain bits of metadata to checksummed for older CHDs */
-		if (header->version <= 3)
-		{
-			if (metatag == HARD_DISK_METADATA_TAG || metatag == CDROM_OLD_METADATA_TAG ||
-			    metatag == CDROM_TRACK_METADATA_TAG || metatag == AV_METADATA_TAG ||
-			    metatag == CDROM_TRACK_METADATA2_TAG || metatag == AV_LD_METADATA_TAG)
-			{
-				metaflags |= CHD_MDFLAGS_CHECKSUM;
-			}
+	// make sure we have one or the other
+	if (text_str == NULL && file_str == NULL)
+		report_error(1, "Error: missing either --valuetext/-vt or --valuefile/-vf parameters");
+	if (text_str != NULL && file_str != NULL)
+		report_error(1, "Error: both --valuetext/-vt or --valuefile/-vf parameters specified; only one permitted");
+
+	// process no checksum
+	UINT8 flags = CHD_MDFLAGS_CHECKSUM;
+	if (params.find(OPTION_NO_CHECKSUM) != NULL)
+		flags &= ~CHD_MDFLAGS_CHECKSUM;
+
+	// print some info
+	astring tempstr;
+	printf("Input file:   %s\n", params.find(OPTION_INPUT)->cstr());
+	printf("Tag:          %c%c%c%c\n", (tag >> 24) & 0xff, (tag >> 16) & 0xff, (tag >> 8) & 0xff, tag & 0xff);
+	printf("Index:        %d\n", index);
+	if (text_str != NULL)
+		printf("Text:         %s\n", text.cstr());
+	else
+		printf("Data:         %s (%d bytes)\n", file_str->cstr(), file.count());
 
-			/* convert old-style CD-ROM data to newer */
-			if (metatag == CDROM_OLD_METADATA_TAG)
-			{
-				cdrom_toc *toc = (cdrom_toc *)metabuffer;
-				err = cdrom_parse_metadata(source, toc);
-				if (err == CHDERR_NONE)
-					err = cdrom_write_metadata(dest, toc);
-				if (err == CHDERR_NONE)
-					continue;
-			}
-		}
+	// write the metadata
+	chd_error err;
+	if (text_str != NULL)
+		err = input_chd.write_metadata(tag, index, text, flags);
+	else
+		err = input_chd.write_metadata(tag, index, file, flags);
+	if (err != CHDERR_NONE)
+		report_error(1, "Error adding metadata: %s", chd_file::error_string(err));
+	else
+		printf("Metadata added\n");
+}
 
-		/* if that fit, just write it back from the temporary buffer */
-		if (metasize <= sizeof(metabuffer))
-		{
-			/* write it to the target */
-			err = chd_set_metadata(dest, metatag, CHD_METAINDEX_APPEND, metabuffer, metasize, metaflags);
-			if (err != CHDERR_NONE)
-				break;
-		}
 
-		/* otherwise, allocate a bigger temporary buffer */
-		else
-		{
-			UINT8 *allocbuffer = (UINT8 *)malloc(metasize);
-			if (allocbuffer == NULL)
-			{
-				err = CHDERR_OUT_OF_MEMORY;
-				break;
-			}
+//-------------------------------------------------
+//  do_del_metadata - remove metadata from a CHD
+//-------------------------------------------------
 
-			/* re-read the whole thing */
-			err = chd_get_metadata(source, CHDMETATAG_WILDCARD, metaindex, allocbuffer, metasize, &metasize, &metatag, &metaflags);
-			if (err != CHDERR_NONE)
-			{
-				free(allocbuffer);
-				break;
-			}
+static void do_del_metadata(parameters_t &params)
+{
+	// parse out input files
+	chd_file input_parent_chd;
+	chd_file input_chd;
+	parse_input_chd_parameters(params, input_chd, input_parent_chd, true);
 
-			/* write it to the target */
-			err = chd_set_metadata(dest, metatag, CHD_METAINDEX_APPEND, allocbuffer, metasize, metaflags);
-			free(allocbuffer);
-			if (err != CHDERR_NONE)
-				break;
-		}
+	// process tag
+	chd_metadata_tag tag = CHD_MAKE_TAG('?','?','?','?');
+	astring *tag_str = params.find(OPTION_TAG);
+	if (tag_str != NULL)
+	{
+		tag_str->cat("    ");
+		tag = CHD_MAKE_TAG((*tag_str)[0], (*tag_str)[1], (*tag_str)[2], (*tag_str)[3]);
 	}
-	return err;
+
+	// process index
+	UINT32 index = 0;
+	astring *index_str = params.find(OPTION_INDEX);
+	if (index_str != NULL)
+		index = atoi(*index_str);
+
+	// print some info
+	astring tempstr;
+	printf("Input file:   %s\n", params.find(OPTION_INPUT)->cstr());
+	printf("Tag:          %c%c%c%c\n", (tag >> 24) & 0xff, (tag >> 16) & 0xff, (tag >> 8) & 0xff, tag & 0xff);
+	printf("Index:        %d\n", index);
+
+	// write the metadata
+	chd_error err = input_chd.delete_metadata(tag, index);
+	if (err != CHDERR_NONE)
+		report_error(1, "Error removing metadata: %s", chd_file::error_string(err));
+	else
+		printf("Metadata removed\n");
 }
 
 
-/*-------------------------------------------------
-    main - entry point
--------------------------------------------------*/
+//-------------------------------------------------
+//  main - entry point
+//-------------------------------------------------
 
 int CLIB_DECL main(int argc, char *argv[])
 {
-	static const struct
-	{
-		const char *	option;
-		int (*callback)(int argc, char *argv[], int param);
-		int param;
-	} option_list[] =
-	{
-		{ "-createhd",		do_createhd, 0 },
-		{ "-createuncomphd",	do_createhd_uncomp, 0 },
-		{ "-createraw",		do_createraw, 0 },
-		{ "-createcd",		do_createcd, 0 },
-//      { "-createcdflac",  do_createcd, 1 },
-		{ "-createblankhd",	do_createblankhd, 0 },
-		{ "-createav",		do_createav, 0 },
-		{ "-copydata",		do_copydata, 0 },
-		{ "-extract",		do_extract, 0 },
-		{ "-extractcd",		do_extractcd, 0 },
-		{ "-extractav",		do_extractav, 0 },
-		{ "-verify",		do_verify, 0 },
-		{ "-verifyfix",		do_verify, 1 },
-		{ "-update",		do_merge_update_chomp, OPERATION_UPDATE },
-		{ "-chomp",			do_merge_update_chomp, OPERATION_CHOMP },
-		{ "-info",			do_info, 0 },
-		{ "-merge",			do_merge_update_chomp, OPERATION_MERGE },
-		{ "-diff",			do_diff, 0 },
-		{ "-setchs",		do_setchs, 0 },
-		{ "-fixavdata",		do_fixavdata, 0 },
-		{ "-addmetatext",   do_addmeta, TRUE },
-		{ "-addmetabin",    do_addmeta, FALSE },
-	};
+	// print the header
 	extern const char build_version[];
-	int i;
-
-	/* print the header */
 	printf("chdman - MAME Compressed Hunks of Data (CHD) manager %s\n", build_version);
 
-	/* require at least 1 argument */
+	// handle help specially
 	if (argc < 2)
-		return usage();
+		return print_help(argv[0]);
+	int argnum = 1;
+	const char *command = argv[argnum++];
+	bool help = (strcmp(command, COMMAND_HELP) == 0);
+	if (help)
+	{
+		if (argc <= 2)
+			return print_help(argv[0]);
+		command = argv[argnum++];
+	}
+
+	// iterate over commands to find our match
+	for (int cmdnum = 0; cmdnum < ARRAY_LENGTH(s_commands); cmdnum++)
+		if (strcmp(command, s_commands[cmdnum].name) == 0)
+		{
+			const command_description &desc = s_commands[cmdnum];
+
+			// print help if that was requested
+			if (help)
+				return print_help(argv[0], desc);
+
+			// otherwise, verify the parameters
+			tagmap_t<astring *> parameters;
+			while (argnum < argc)
+			{
+				// should be an option name
+				const char *arg = argv[argnum++];
+				if (arg[0] != '-')
+					return print_help(argv[0], desc, "Expected option, not parameter");
+
+				// iterate over valid options
+				int valid;
+				for (valid = 0; valid < ARRAY_LENGTH(desc.valid_options); valid++)
+				{
+					// reduce to the option name
+					const char *validname = desc.valid_options[valid];
+					if (validname == NULL)
+						break;
+					if (*validname == REQUIRED[0])
+						validname++;
+
+					// find the matching option description
+					int optnum;
+					for (optnum = 0; optnum < ARRAY_LENGTH(s_options); optnum++)
+						if (strcmp(s_options[optnum].name, validname) == 0)
+							break;
+					assert(optnum != ARRAY_LENGTH(s_options));
+
+					// do we match?
+					const option_description &odesc = s_options[optnum];
+					if ((arg[1] == '-' && strcmp(odesc.name, &arg[2]) == 0) ||
+						(arg[1] != '-' && odesc.shortname != NULL && strcmp(odesc.shortname, &arg[1]) == 0))
+					{
+						// if we need a parameter, consume it
+						const char *param = "";
+						if (odesc.parameter)
+						{
+							if (argnum >= argc || argv[argnum][0] == '-')
+								return print_help(argv[0], desc, "Option is missing parameter");
+							param = argv[argnum++];
+						}
+
+						// add to the map
+						if (parameters.add(odesc.name, new astring(param)) == TMERR_DUPLICATE)
+							return print_help(argv[0], desc, "Multiple parameters of the same type specified");
+						break;
+					}
+				}
+
+				// if not valid, error
+				if (valid == ARRAY_LENGTH(desc.valid_options))
+					return print_help(argv[0], desc, "Option not valid for this command");
+			}
+
+			// make sure we got all our required parameters
+			for (int valid = 0; valid < ARRAY_LENGTH(desc.valid_options); valid++)
+			{
+				const char *validname = desc.valid_options[valid];
+				if (validname == NULL)
+					break;
+				if (*validname == REQUIRED[0] && parameters.find(++validname) == NULL)
+					return print_help(argv[0], desc, "Required parameters missing");
+			}
 
-	/* handle the appropriate command */
-	for (i = 0; i < ARRAY_LENGTH(option_list); i++)
-		if (strcmp(argv[1], option_list[i].option) == 0)
-			return (*option_list[i].callback)(argc, argv, option_list[i].param);
+			// all clear, run the command
+			try
+			{
+				(*s_commands[cmdnum].handler)(parameters);
+				return 0;
+			}
+			catch (fatal_error &err)
+			{
+				return err.error();
+			}
+			catch (std::bad_alloc &)
+			{
+				fprintf(stderr, "Out of memory\n");
+				return 1;
+			}
+			catch (...)
+			{
+				fprintf(stderr, "Unhandled exception\n");
+				return 1;
+			}
+		}
 
-	return usage();
+	// print generic help if nothing found
+	return print_help(argv[0]);
 }
diff -Nru src-old/tools/ldresample.c src/tools/ldresample.c
--- src-old/tools/ldresample.c	2012-01-12 22:19:49.000000000 +0100
+++ src/tools/ldresample.c	2012-02-17 19:37:10.000000000 +0100
@@ -82,9 +82,9 @@
 	int			samplerate;
 	int			channels;
 	int			interlaced;
-	bitmap_yuy16 *bitmap;
-	INT16 *		lsound;
-	INT16 *		rsound;
+	bitmap_yuy16 bitmap;
+	dynamic_array<INT16> lsound;
+	dynamic_array<INT16> rsound;
 	UINT32		samples;
 };
 
@@ -144,99 +144,52 @@
 ***************************************************************************/
 
 /*-------------------------------------------------
-    chd_allocate_buffers - allocate buffers for
-    CHD I/O
--------------------------------------------------*/
-
-static int chd_allocate_buffers(movie_info *info)
-{
-	/* allocate a bitmap */
-	info->bitmap = new(std::nothrow) bitmap_yuy16(info->width, info->height);
-	if (info->bitmap == NULL)
-	{
-		fprintf(stderr, "Out of memory creating %dx%d bitmap\n", info->width, info->height);
-		return FALSE;
-	}
-
-	/* allocate sound buffers */
-	info->lsound = (INT16 *)malloc(info->samplerate * sizeof(*info->lsound));
-	info->rsound = (INT16 *)malloc(info->samplerate * sizeof(*info->rsound));
-	if (info->lsound == NULL || info->rsound == NULL)
-	{
-		fprintf(stderr, "Out of memory allocating sound buffers of %d bytes\n", (INT32)(info->samplerate * sizeof(*info->rsound)));
-		return FALSE;
-	}
-	return TRUE;
-}
-
-
-/*-------------------------------------------------
-    chd_free_buffers - release buffers for
-    CHD I/O
--------------------------------------------------*/
-
-static void chd_free_buffers(movie_info *info)
-{
-	delete info->bitmap;
-	if (info->lsound != NULL)
-		free(info->lsound);
-	if (info->rsound != NULL)
-		free(info->rsound);
-}
-
-
-/*-------------------------------------------------
     open_chd - open a CHD file and return
     information about it
 -------------------------------------------------*/
 
-static chd_file *open_chd(const char *filename, movie_info *info)
+static chd_error open_chd(chd_file &file, const char *filename, movie_info &info)
 {
-	int fps, fpsfrac, width, height, interlaced, channels, rate;
-	char metadata[256];
-	chd_error chderr;
-	chd_file *chd;
-
 	/* open the file */
-	chderr = chd_open(filename, CHD_OPEN_READ, NULL, &chd);
+	chd_error chderr = file.open(filename);
 	if (chderr != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error opening CHD file: %s\n", chd_error_string(chderr));
-		return NULL;
+		return chderr;
 	}
 
 	/* get the metadata */
-	chderr = chd_get_metadata(chd, AV_METADATA_TAG, 0, metadata, sizeof(metadata), NULL, NULL, NULL);
+	astring metadata;
+	chderr = chd.read_metadata(chd, AV_METADATA_TAG, 0, metadata);
 	if (chderr != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error getting A/V metadata: %s\n", chd_error_string(chderr));
-		chd_close(chd);
-		return NULL;
+		return chderr;
 	}
 
 	/* extract the info */
+	int fps, fpsfrac, width, height, interlaced, channels, rate;
 	if (sscanf(metadata, AV_METADATA_FORMAT, &fps, &fpsfrac, &width, &height, &interlaced, &channels, &rate) != 7)
 	{
 		fprintf(stderr, "Improperly formatted metadata\n");
-		chd_close(chd);
-		return NULL;
+		return CHDERR_INVALID_DATA;
 	}
 
 	/* extract movie info */
-	info->iframerate = fps * 1000000 + fpsfrac;
-	info->framerate = info->iframerate / 1000000.0;
-	info->numfields = chd_get_header(chd)->totalhunks;
-	info->width = width;
-	info->height = height;
-	info->interlaced = interlaced;
-	info->samplerate = rate;
-	info->channels = channels;
+	info.iframerate = fps * 1000000 + fpsfrac;
+	info.framerate = info.iframerate / 1000000.0;
+	info.numfields = file->hunk_count();
+	info.width = width;
+	info.height = height;
+	info.interlaced = interlaced;
+	info.samplerate = rate;
+	info.channels = channels;
 
 	/* allocate buffers */
-	if (!chd_allocate_buffers(info))
-		return NULL;
-
-	return chd;
+	info.bitmap.resize(info.width, info.height);
+	info.lsound.resize(info.samplerate);
+	info.rsound.resize(info.samplerate);
+	return CHDERR_NONE;
 }
 
 
@@ -244,46 +197,34 @@
     create_chd - create a new CHD file
 -------------------------------------------------*/
 
-static chd_file *create_chd(const char *filename, chd_file *source, const movie_info *info)
+static chd_error create_chd(chd_compressor &file, const char *filename, chd_file &source, const movie_info &info)
 {
-	const chd_header *srcheader = chd_get_header(source);
-	chd_error chderr;
-	chd_file *chd;
-
 	/* create the file */
-	chderr = chd_create(filename, srcheader->logicalbytes, srcheader->hunkbytes, CHDCOMPRESSION_AV, NULL);
+	chd_codec_type compression = { CHD_CODEC_AVHUFF };
+	chd_error chderr = file.create(filename, source.logical_bytes(), source.hunk_bytes(), source.unit_bytes(), compression);
 	if (chderr != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error creating new CHD file: %s\n", chd_error_string(chderr));
-		return NULL;
-	}
-
-	/* open the file */
-	chderr = chd_open(filename, CHD_OPEN_READWRITE, NULL, &chd);
-	if (chderr != CHDERR_NONE)
-	{
-		fprintf(stderr, "Error opening new CHD file: %s\n", chd_error_string(chderr));
-		return NULL;
+		return chderr;
 	}
 
 	/* clone the metadata */
-	chderr = chd_clone_metadata(source, chd);
+	chderr = file.clone_all_metadata(source);
 	if (chderr != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error cloning metadata: %s\n", chd_error_string(chderr));
-		chd_close(chd);
-		return NULL;
+		return chderr;
 	}
 
 	/* begin compressing */
-	chderr = chd_compress_begin(chd);
+	chderr = file.compress_begin();
 	if (chderr != CHDERR_NONE)
 	{
 		fprintf(stderr, "Error beginning compression: %s\n", chd_error_string(chderr));
-		return NULL;
+		return chderr;
 	}
 
-	return chd;
+	return CHDERR_NONE;
 }
 
 
@@ -549,7 +490,6 @@
 	const char *srcfilename;
 	const char *dstfilename;
 	double offset, slope;
-	chd_file *srcfile;
 	chd_file *dstfile;
 
 	/* verify arguments */
@@ -570,8 +510,9 @@
 	}
 
 	/* open the source file */
-	srcfile = open_chd(srcfilename, &info);
-	if (srcfile == NULL)
+	chd_file srcfile;
+	chd_error err = open_chd(srcfile, srcfilename, info);
+	if (err != CHDERR_NONE)
 	{
 		fprintf(stderr, "Unable to open file '%s'\n", srcfilename);
 		return 1;
@@ -604,7 +545,7 @@
 		UINT32 fieldnum;
 
 		/* open the destination file */
-		dstfile = create_chd(dstfilename, srcfile, &info);
+		err = create_chd(dstfile, dstfilename, srcfile, info);
 		if (dstfile == NULL)
 		{
 			fprintf(stderr, "Unable to create file '%s'\n", dstfilename);
diff -Nru src-old/tools/tools.mak src/tools/tools.mak
--- src-old/tools/tools.mak	2012-01-22 19:38:22.000000000 +0100
+++ src/tools/tools.mak	2012-02-16 10:47:18.000000000 +0100
@@ -84,7 +84,8 @@
 CHDMANOBJS = \
 	$(TOOLSOBJ)/chdman.o \
 
-chdman$(EXE): $(VERSIONOBJ) $(CHDMANOBJS) $(LIBUTIL) $(ZLIB) $(EXPAT) $(FLAC_LIB) $(LIBOCORE)
+chdman$(EXE): $(VERSIONOBJ) $(CHDMANOBJS) $(LIBUTIL) $(ZLIB) $(EXPAT) $(FLAC_LIB) $(7Z_LIB) $(LIBOCORE)
+	$(CC) $(CDEFS) $(CFLAGS) -c $(SRC)/version.c -o $(VERSIONOBJ)
 	@echo Linking $@...
 	$(LD) $(LDFLAGS) $^ $(LIBS) $(FLAC_LIB) -o $@
 
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2012-02-05 16:14:28.000000000 +0100
+++ src/version.c	2012-02-19 16:23:23.000000000 +0100
@@ -38,4 +38,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.145 ("__DATE__")";
+const char build_version[] = "0.145u1 ("__DATE__")";
